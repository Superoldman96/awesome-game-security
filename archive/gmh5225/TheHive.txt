Project Path: arc_gmh5225_TheHive_agqv4ojt

Source Tree:

```txt
arc_gmh5225_TheHive_agqv4ojt
├── AUTHORS
├── CHANGELOG.md
├── LICENSE
├── PGP-PUBLIC-KEY
├── README.md
├── SECURITY.md
├── ScalliGraph
├── app
│   └── org
│       └── thp
│           └── thehive
│               └── CustomServer.scala
├── build.sbt
├── client
│   └── src
│       └── main
│           └── scala
│               └── org
│                   └── thp
│                       └── thehive
│                           └── client
│                               └── TheHiveClient.scala
├── client-common
│   └── src
│       ├── main
│       │   └── scala
│       │       └── org
│       │           └── thp
│       │               └── client
│       │                   ├── Authentication.scala
│       │                   ├── BaseClient.scala
│       │                   └── ProxyWS.scala
│       └── test
│           └── scala
│               └── org
│                   └── thp
│                       └── client
│                           └── ProxyWSTest.scala
├── code_of_conduct.md
├── conf
│   ├── application.sample.conf
│   ├── cloner.sample.conf
│   ├── logback.xml
│   └── migration-logback.xml
├── cortex
│   ├── client
│   │   └── src
│   │       ├── main
│   │       │   └── scala
│   │       │       └── org
│   │       │           └── thp
│   │       │               └── cortex
│   │       │                   └── client
│   │       │                       └── CortexClient.scala
│   │       └── test
│   │           ├── resources
│   │           │   ├── analyzers.json
│   │           │   ├── file.test.txt
│   │           │   ├── jobs.json
│   │           │   └── responders.json
│   │           └── scala
│   │               └── org
│   │                   └── thp
│   │                       └── cortex
│   │                           └── client
│   │                               ├── CortexClientTest.scala
│   │                               └── TestCortexClientProvider.scala
│   ├── connector
│   │   └── src
│   │       ├── main
│   │       │   ├── resources
│   │       │   │   ├── play
│   │       │   │   │   └── reference-overrides.conf
│   │       │   │   └── reference.conf
│   │       │   └── scala
│   │       │       └── org
│   │       │           └── thp
│   │       │               └── thehive
│   │       │                   └── connector
│   │       │                       └── cortex
│   │       │                           ├── CortexModule.scala
│   │       │                           ├── CortexRouter.scala
│   │       │                           ├── controllers
│   │       │                           │   └── v0
│   │       │                           │       ├── ActionCtrl.scala
│   │       │                           │       ├── AnalyzerCtrl.scala
│   │       │                           │       ├── AnalyzerTemplateCtrl.scala
│   │       │                           │       ├── Conversion.scala
│   │       │                           │       ├── CortexQueryExecutor.scala
│   │       │                           │       ├── JobCtrl.scala
│   │       │                           │       ├── JobRenderer.scala
│   │       │                           │       ├── ResponderCtrl.scala
│   │       │                           │       └── Router.scala
│   │       │                           ├── models
│   │       │                           │   ├── Action.scala
│   │       │                           │   ├── ActionOperation.scala
│   │       │                           │   ├── AnalyzerTemplate.scala
│   │       │                           │   ├── CortexSchemaDefinition.scala
│   │       │                           │   ├── Job.scala
│   │       │                           │   └── TheHiveCortexSchemaProvider.scala
│   │       │                           └── services
│   │       │                               ├── ActionOperationSrv.scala
│   │       │                               ├── ActionSrv.scala
│   │       │                               ├── AnalyzerSrv.scala
│   │       │                               ├── AnalyzerTemplateSrv.scala
│   │       │                               ├── Connector.scala
│   │       │                               ├── Conversion.scala
│   │       │                               ├── CortexActor.scala
│   │       │                               ├── CortexAuditSrv.scala
│   │       │                               ├── CortexSerializer.scala
│   │       │                               ├── EntityHelper.scala
│   │       │                               ├── JobSrv.scala
│   │       │                               ├── ResponderSrv.scala
│   │       │                               ├── ServiceHelper.scala
│   │       │                               └── notification
│   │       │                                   └── notifiers
│   │       │                                       ├── RunAnalyzer.scala
│   │       │                                       └── RunResponder.scala
│   │       └── test
│   │           ├── resources
│   │           │   ├── cortex-jobs.json
│   │           │   ├── observables.json
│   │           │   └── report-templates.zip
│   │           └── scala
│   │               └── org
│   │                   └── thp
│   │                       └── thehive
│   │                           └── connector
│   │                               └── cortex
│   │                                   ├── controllers
│   │                                   │   └── v0
│   │                                   │       ├── AnalyzerCtrlTest.scala
│   │                                   │       ├── AnalyzerTemplateCtrlTest.scala
│   │                                   │       ├── JobCtrlTest.scala
│   │                                   │       └── TheHiveCortexQueryExecutorProvider.scala
│   │                                   └── services
│   │                                       ├── ActionSrvTest.scala
│   │                                       ├── AnalyzerSrvTest.scala
│   │                                       ├── EntityHelperTest.scala
│   │                                       ├── JobSrvTest.scala
│   │                                       ├── ResponderSrvTest.scala
│   │                                       ├── ServiceHelperTest.scala
│   │                                       └── TestConnector.scala
│   └── dto
│       └── src
│           └── main
│               └── scala
│                   └── org
│                       └── thp
│                           └── cortex
│                               └── dto
│                                   └── v0
│                                       ├── Action.scala
│                                       ├── Artifact.scala
│                                       ├── Attachment.scala
│                                       ├── Job.scala
│                                       ├── SearchQuery.scala
│                                       └── Worker.scala
├── debian.sbt
├── docker.sbt
├── dto
│   └── src
│       └── main
│           └── scala
│               └── org
│                   └── thp
│                       └── thehive
│                           ├── connector
│                           │   └── cortex
│                           │       └── dto
│                           │           └── v0
│                           │               ├── Action.scala
│                           │               ├── Job.scala
│                           │               ├── ReportTemplate.scala
│                           │               ├── Responder.scala
│                           │               └── Worker.scala
│                           └── dto
│                               ├── v0
│                               │   ├── Alert.scala
│                               │   ├── Attachment.scala
│                               │   ├── Audit.scala
│                               │   ├── Case.scala
│                               │   ├── CaseTemplate.scala
│                               │   ├── CustomFieldValue.scala
│                               │   ├── Dashboard.scala
│                               │   ├── Log.scala
│                               │   ├── Observable.scala
│                               │   ├── ObservableType.scala
│                               │   ├── Organistion.scala
│                               │   ├── Page.scala
│                               │   ├── Permission.scala
│                               │   ├── Profile.scala
│                               │   ├── Share.scala
│                               │   ├── Tag.scala
│                               │   ├── Task.scala
│                               │   └── User.scala
│                               └── v1
│                                   ├── Alert.scala
│                                   ├── Attachment.scala
│                                   ├── Audit.scala
│                                   ├── Case.scala
│                                   ├── CaseTemplate.scala
│                                   ├── CustomFieldValue.scala
│                                   ├── Dashboard.scala
│                                   ├── Log.scala
│                                   ├── Observable.scala
│                                   ├── ObservableType.scala
│                                   ├── Organisation.scala
│                                   ├── Pattern.scala
│                                   ├── Procedure.scala
│                                   ├── Profile.scala
│                                   ├── Share.scala
│                                   ├── Tag.scala
│                                   ├── Task.scala
│                                   ├── Taxonomy.scala
│                                   └── User.scala
├── frontend
│   ├── Gruntfile.js
│   ├── README.md
│   ├── app
│   │   ├── images
│   │   │   ├── cortex-logo.svg
│   │   │   ├── favicons
│   │   │   │   ├── favicon-128.png
│   │   │   │   ├── favicon-16x16.png
│   │   │   │   ├── favicon-196x196.png
│   │   │   │   ├── favicon-32x32.png
│   │   │   │   └── favicon-96x96.png
│   │   │   ├── logo.png
│   │   │   ├── logo.svg
│   │   │   ├── logo.white.svg
│   │   │   ├── misp-logo.svg
│   │   │   └── no-avatar.png
│   │   ├── index.html
│   │   ├── scripts
│   │   │   ├── app.js
│   │   │   ├── components
│   │   │   │   ├── alert
│   │   │   │   │   ├── AlertObservableListCmp.js
│   │   │   │   │   └── AlertSimilarCaseListCmp.js
│   │   │   │   ├── app-container.component.js
│   │   │   │   ├── charts
│   │   │   │   │   └── donut-chart.component.js
│   │   │   │   ├── common
│   │   │   │   │   ├── custom-field-input.component.js
│   │   │   │   │   ├── custom-field-labels.component.js
│   │   │   │   │   ├── datalist-header.component.js
│   │   │   │   │   ├── observable-flags.component.js
│   │   │   │   │   ├── tag.component.js
│   │   │   │   │   └── task-flags.component.js
│   │   │   │   ├── control-sidebar.component.js
│   │   │   │   ├── header.component.js
│   │   │   │   ├── list
│   │   │   │   │   └── stats-item.component.js
│   │   │   │   ├── main-sidebar.component.js
│   │   │   │   ├── organisation
│   │   │   │   │   ├── OrgCaseTemplateListCmp.js
│   │   │   │   │   ├── OrgCaseTemplateModalCtrl.js
│   │   │   │   │   ├── OrgConfigListCmp.js
│   │   │   │   │   ├── OrgCustomTagsListCmp.js
│   │   │   │   │   ├── OrgSwitchCtrl.js
│   │   │   │   │   └── OrgUserListCmp.js
│   │   │   │   ├── search
│   │   │   │   │   └── filters-preview.component.js
│   │   │   │   └── sharing
│   │   │   │       ├── SharingListCmp.js
│   │   │   │       ├── SharingModalCtrl.js
│   │   │   │       └── task
│   │   │   │           └── SharingListCmp.js
│   │   │   ├── controllers
│   │   │   │   ├── AboutCtrl.js
│   │   │   │   ├── AuthenticationCtrl.js
│   │   │   │   ├── LiveCtrl.js
│   │   │   │   ├── MainPageCtrl.js
│   │   │   │   ├── MigrationCtrl.js
│   │   │   │   ├── RootCtrl.js
│   │   │   │   ├── SearchCtrl.js
│   │   │   │   ├── SettingsCtrl.js
│   │   │   │   ├── admin
│   │   │   │   │   ├── AdminAnalyzerTemplatesCtrl.js
│   │   │   │   │   ├── AdminCustomFieldDialogCtrl.js
│   │   │   │   │   ├── AdminCustomFieldsCtrl.js
│   │   │   │   │   ├── AdminObservablesCtrl.js
│   │   │   │   │   ├── AdminUiSettingsCtrl.js
│   │   │   │   │   ├── attack
│   │   │   │   │   │   └── AttackPatternListCtrl.js
│   │   │   │   │   ├── organisation
│   │   │   │   │   │   ├── OrgDetailsCtrl.js
│   │   │   │   │   │   ├── OrgLinksModalCtrl.js
│   │   │   │   │   │   ├── OrgListCtrl.js
│   │   │   │   │   │   ├── OrgModalCtrl.js
│   │   │   │   │   │   ├── OrgUserModalCtrl.js
│   │   │   │   │   │   ├── OrgUsersCtrl.js
│   │   │   │   │   │   └── case-template
│   │   │   │   │   │       ├── AdminCaseTemplateImportCtrl.js
│   │   │   │   │   │       └── AdminCaseTemplateTasksCtrl.js
│   │   │   │   │   ├── platform
│   │   │   │   │   │   └── PlatformStatusCtrl.js
│   │   │   │   │   ├── profile
│   │   │   │   │   │   ├── ProfileListCtrl.js
│   │   │   │   │   │   └── ProfileModalCtrl.js
│   │   │   │   │   └── taxonomy
│   │   │   │   │       └── TaxonomyListCtrl.js
│   │   │   │   ├── alert
│   │   │   │   │   ├── AlertEventCtrl.js
│   │   │   │   │   ├── AlertListCtrl.js
│   │   │   │   │   └── AlertStatsCtrl.js
│   │   │   │   ├── case
│   │   │   │   │   ├── CaseAlertsCtrl.js
│   │   │   │   │   ├── CaseCloseModalCtrl.js
│   │   │   │   │   ├── CaseCreationCtrl.js
│   │   │   │   │   ├── CaseDeleteModalCtrl.js
│   │   │   │   │   ├── CaseDetailsCtrl.js
│   │   │   │   │   ├── CaseExportDialogCtrl.js
│   │   │   │   │   ├── CaseLinksCtrl.js
│   │   │   │   │   ├── CaseListCtrl.js
│   │   │   │   │   ├── CaseMainCtrl.js
│   │   │   │   │   ├── CaseMergeModalCtrl.js
│   │   │   │   │   ├── CaseObservablesCtrl.js
│   │   │   │   │   ├── CaseObservablesExportCtrl.js
│   │   │   │   │   ├── CaseObservablesItemCtrl.js
│   │   │   │   │   ├── CaseProceduresCtrl.js
│   │   │   │   │   ├── CaseReopenModalCtrl.js
│   │   │   │   │   ├── CaseSharingCtrl.js
│   │   │   │   │   ├── CaseStatsCtrl.js
│   │   │   │   │   ├── CaseTasksCtrl.js
│   │   │   │   │   ├── CaseTasksItemCtrl.js
│   │   │   │   │   ├── CaseTemplatesDialogCtrl.js
│   │   │   │   │   ├── CaseUpdateCtrl.js
│   │   │   │   │   ├── ObservableAnalyzeCtrl.js
│   │   │   │   │   ├── ObservableCreationCtrl.js
│   │   │   │   │   ├── ObservableUpdateCtrl.js
│   │   │   │   │   ├── ObservablesStatsCtrl.js
│   │   │   │   │   ├── procedure
│   │   │   │   │   │   └── AddProcedureModalCtrl.js
│   │   │   │   │   ├── share
│   │   │   │   │   │   └── CaseShareModalCtrl.js
│   │   │   │   │   └── tasklogs
│   │   │   │   │       └── AddTaskLogModalCtrl.js
│   │   │   │   ├── cortex
│   │   │   │   │   ├── CortexInstanceDialogCtrl.js
│   │   │   │   │   └── ResponderActionDialogCtrl.js
│   │   │   │   ├── dashboard
│   │   │   │   │   ├── DashboardViewCtrl.js
│   │   │   │   │   └── DashboardsCtrl.js
│   │   │   │   └── misc
│   │   │   │       ├── ResponderSelectorCtrl.js
│   │   │   │       ├── ServerInstanceDialogCtrl.js
│   │   │   │       └── TaxonomySelectionModalCtrl.js
│   │   │   ├── directives
│   │   │   │   ├── affixer.js
│   │   │   │   ├── alert-duration.js
│   │   │   │   ├── auto-focus.js
│   │   │   │   ├── case-duration.js
│   │   │   │   ├── charts
│   │   │   │   │   └── c3Chart.js
│   │   │   │   ├── compare-to.js
│   │   │   │   ├── dashboard
│   │   │   │   │   ├── bar.js
│   │   │   │   │   ├── counter.js
│   │   │   │   │   ├── donut.js
│   │   │   │   │   ├── filter-editor.js
│   │   │   │   │   ├── item.js
│   │   │   │   │   ├── line.js
│   │   │   │   │   ├── multiline.js
│   │   │   │   │   └── text.js
│   │   │   │   ├── dateTimePicker.js
│   │   │   │   ├── dt-picker.js
│   │   │   │   ├── entityLink.js
│   │   │   │   ├── fileChooser.js
│   │   │   │   ├── filter-box.js
│   │   │   │   ├── fixed-height.js
│   │   │   │   ├── flow
│   │   │   │   │   ├── flow-item.js
│   │   │   │   │   └── flow.js
│   │   │   │   ├── if-not-permission.js
│   │   │   │   ├── if-permission.js
│   │   │   │   ├── logEntry.js
│   │   │   │   ├── mini-report-list.js
│   │   │   │   ├── page-sizer.js
│   │   │   │   ├── permission-list.js
│   │   │   │   ├── psearch.js
│   │   │   │   ├── report-observables.js
│   │   │   │   ├── report.js
│   │   │   │   ├── responder-actions.js
│   │   │   │   ├── search
│   │   │   │   │   └── search-item.js
│   │   │   │   ├── severity.js
│   │   │   │   ├── tag-colour.js
│   │   │   │   ├── tag-item.js
│   │   │   │   ├── tag-list.js
│   │   │   │   ├── task-progress.js
│   │   │   │   ├── tlp.js
│   │   │   │   ├── updatable.js
│   │   │   │   ├── updatableBoolean.js
│   │   │   │   ├── updatableColour.js
│   │   │   │   ├── updatableDataDropdown.js
│   │   │   │   ├── updatableDate.js
│   │   │   │   ├── updatableSelect.js
│   │   │   │   ├── updatableSimpleText.js
│   │   │   │   ├── updatableTag.js
│   │   │   │   ├── updatableTagList.js
│   │   │   │   ├── updatableTags.js
│   │   │   │   ├── updatableText.js
│   │   │   │   ├── updatableUser.js
│   │   │   │   ├── user.js
│   │   │   │   ├── userinfo.js
│   │   │   │   └── utils
│   │   │   │       └── autofocus.js
│   │   │   ├── filters
│   │   │   │   ├── custom-field-value.js
│   │   │   │   ├── duration.js
│   │   │   │   ├── ellipsis.js
│   │   │   │   ├── fang.js
│   │   │   │   ├── filesize.js
│   │   │   │   ├── filter-value.js
│   │   │   │   ├── flattern-object.js
│   │   │   │   ├── getField.js
│   │   │   │   ├── hash-type.js
│   │   │   │   ├── limited-count.js
│   │   │   │   ├── md5.js
│   │   │   │   ├── offset.js
│   │   │   │   ├── order-object-by.js
│   │   │   │   ├── percent.js
│   │   │   │   ├── sha256.js
│   │   │   │   ├── shortDate.js
│   │   │   │   ├── showDate.js
│   │   │   │   ├── tag-value.js
│   │   │   │   └── urlencode.js
│   │   │   ├── services
│   │   │   │   ├── AnalyzerInfoSrv.js
│   │   │   │   ├── EntitySrv.js
│   │   │   │   ├── api
│   │   │   │   │   ├── AlertingSrv.js
│   │   │   │   │   ├── AnalyzerSrv.js
│   │   │   │   │   ├── AnalyzerTemplateSrv.js
│   │   │   │   │   ├── AttackPatternSrv.js
│   │   │   │   │   ├── AuditSrv.js
│   │   │   │   │   ├── AuthenticationSrv.js
│   │   │   │   │   ├── CaseSrv.js
│   │   │   │   │   ├── CaseTaskSrv.js
│   │   │   │   │   ├── CaseTemplateSrv.js
│   │   │   │   │   ├── CortexSrv.js
│   │   │   │   │   ├── CustomFieldsSrv.js
│   │   │   │   │   ├── DashboardSrv.js
│   │   │   │   │   ├── JobSrv.js
│   │   │   │   │   ├── ListSrv.js
│   │   │   │   │   ├── MispSrv.js
│   │   │   │   │   ├── ObservableTypeSrv.js
│   │   │   │   │   ├── OrganisationSrv.js
│   │   │   │   │   ├── PlatformSrv.js
│   │   │   │   │   ├── ProcedureSrv.js
│   │   │   │   │   ├── ProfileSrv.js
│   │   │   │   │   ├── TagSrv.js
│   │   │   │   │   ├── TaskLogSrv.js
│   │   │   │   │   ├── TaxonomyCacheSrv.js
│   │   │   │   │   ├── TaxonomySrv.js
│   │   │   │   │   ├── UiSettingsSrv.js
│   │   │   │   │   ├── UserSrv.js
│   │   │   │   │   └── VersionSrv.js
│   │   │   │   ├── common
│   │   │   │   │   ├── Constants.js
│   │   │   │   │   ├── HtmlSanitizeSrv.js
│   │   │   │   │   ├── QueryBuilderSrv.js
│   │   │   │   │   ├── QuerySrv.js
│   │   │   │   │   ├── SecuritySrv.js
│   │   │   │   │   ├── UtilsSrv.js
│   │   │   │   │   ├── data
│   │   │   │   │   │   ├── CaseArtifactSrv.js
│   │   │   │   │   │   ├── FileResource.js
│   │   │   │   │   │   ├── PSearchSrv.js
│   │   │   │   │   │   ├── PaginatedQuerySrv.js
│   │   │   │   │   │   ├── SearchSrv.js
│   │   │   │   │   │   ├── StatSrv.js
│   │   │   │   │   │   ├── StreamQuerySrv.js
│   │   │   │   │   │   ├── StreamSrv.js
│   │   │   │   │   │   └── StreamStatSrv.js
│   │   │   │   │   └── ui
│   │   │   │   │       ├── AppLayoutSrv.js
│   │   │   │   │       ├── FilteringSrv.js
│   │   │   │   │       ├── ModalUtilsSrv.js
│   │   │   │   │       ├── NotificationSrv.js
│   │   │   │   │       └── modal
│   │   │   │   │           └── ModalSrv.js
│   │   │   │   └── ui
│   │   │   │       ├── AfkSrv.js
│   │   │   │       ├── CaseTabsSrv.js
│   │   │   │       ├── ChartSrv.js
│   │   │   │       └── GlobalSearchSrv.js
│   │   │   ├── thirdparty
│   │   │   │   └── theme.js
│   │   │   └── utils
│   │   │       ├── highlight.min.js
│   │   │       └── saveSvgAsPng.js
│   │   ├── styles
│   │   │   ├── case-item.css
│   │   │   ├── case-template.css
│   │   │   ├── case.css
│   │   │   ├── components
│   │   │   │   └── tag.css
│   │   │   ├── custom-fields.css
│   │   │   ├── dashboard.css
│   │   │   ├── directives
│   │   │   │   ├── page-sizer.css
│   │   │   │   └── user.css
│   │   │   ├── filters.css
│   │   │   ├── flex-table.css
│   │   │   ├── flow.css
│   │   │   ├── fonts
│   │   │   │   ├── SIL Open Font License.txt
│   │   │   │   ├── SourceSansPro-Black.otf
│   │   │   │   ├── SourceSansPro-BlackIt.otf
│   │   │   │   ├── SourceSansPro-Bold.otf
│   │   │   │   ├── SourceSansPro-BoldIt.otf
│   │   │   │   ├── SourceSansPro-ExtraLight.otf
│   │   │   │   ├── SourceSansPro-ExtraLightIt.otf
│   │   │   │   ├── SourceSansPro-It.otf
│   │   │   │   ├── SourceSansPro-Light.otf
│   │   │   │   ├── SourceSansPro-LightIt.otf
│   │   │   │   ├── SourceSansPro-Regular.otf
│   │   │   │   ├── SourceSansPro-Semibold.otf
│   │   │   │   └── SourceSansPro-SemiboldIt.otf
│   │   │   ├── label.css
│   │   │   ├── main.css
│   │   │   ├── procedure.css
│   │   │   ├── search.css
│   │   │   ├── updatable.css
│   │   │   └── vendors
│   │   │       ├── AdminLTE-fonts.css
│   │   │       ├── AdminLTE-skin-blue.css
│   │   │       └── AdminLTE.css
│   │   └── views
│   │       ├── app.case.html
│   │       ├── app.html
│   │       ├── components
│   │       │   ├── alert
│   │       │   │   ├── observable-list.component.html
│   │       │   │   ├── observables
│   │       │   │   │   ├── filters.html
│   │       │   │   │   └── toolbar.html
│   │       │   │   ├── similar-case-list.component.html
│   │       │   │   └── similarity
│   │       │   │       ├── filters.html
│   │       │   │       └── toolbar.html
│   │       │   ├── app-container.component.html
│   │       │   ├── common
│   │       │   │   ├── custom-field-input.component.html
│   │       │   │   ├── custom-field-labels.component.html
│   │       │   │   ├── datalist-header.component.html
│   │       │   │   ├── modal
│   │       │   │   │   └── modal.confirm.html
│   │       │   │   ├── observable-flags.component.html
│   │       │   │   ├── tag.component.html
│   │       │   │   └── task-flags.component.html
│   │       │   ├── control-sidebar.component.html
│   │       │   ├── header.component.html
│   │       │   ├── list
│   │       │   │   └── stats-item.component.html
│   │       │   ├── main-sidebar.component.html
│   │       │   ├── org
│   │       │   │   ├── case-template
│   │       │   │   │   ├── case-templates.html
│   │       │   │   │   ├── case-templates.task.html
│   │       │   │   │   ├── custom-fields.html
│   │       │   │   │   ├── details.html
│   │       │   │   │   ├── details.modal.html
│   │       │   │   │   ├── filters.html
│   │       │   │   │   ├── import.html
│   │       │   │   │   ├── tasks.html
│   │       │   │   │   └── toolbar.html
│   │       │   │   ├── config.list.html
│   │       │   │   ├── custom-tags
│   │       │   │   │   ├── filters.html
│   │       │   │   │   ├── tag-list.html
│   │       │   │   │   └── toolbar.html
│   │       │   │   ├── orgSwitch.modal.html
│   │       │   │   └── user.list.html
│   │       │   ├── search
│   │       │   │   └── filters-preview.component.html
│   │       │   └── sharing
│   │       │       ├── sharing-list.html
│   │       │       ├── sharing-modal.html
│   │       │       └── task
│   │       │           └── sharing-list.html
│   │       ├── directives
│   │       │   ├── alert-duration.html
│   │       │   ├── artifact-labels.html
│   │       │   ├── case-duration.html
│   │       │   ├── charts
│   │       │   │   └── c3.html
│   │       │   ├── dashboard
│   │       │   │   ├── bar
│   │       │   │   │   ├── basic.html
│   │       │   │   │   └── edit.html
│   │       │   │   ├── counter
│   │       │   │   │   ├── basic.html
│   │       │   │   │   ├── edit.html
│   │       │   │   │   ├── series.html
│   │       │   │   │   └── view.html
│   │       │   │   ├── customize.html
│   │       │   │   ├── donut
│   │       │   │   │   ├── basic.html
│   │       │   │   │   ├── edit.html
│   │       │   │   │   └── sort.html
│   │       │   │   ├── edit.dialog.html
│   │       │   │   ├── filter-editor.html
│   │       │   │   ├── filters.html
│   │       │   │   ├── item.html
│   │       │   │   ├── line
│   │       │   │   │   ├── basic.html
│   │       │   │   │   ├── edit.html
│   │       │   │   │   └── series.html
│   │       │   │   ├── multiline
│   │       │   │   │   ├── basic.html
│   │       │   │   │   ├── edit.html
│   │       │   │   │   ├── serie.filters.html
│   │       │   │   │   └── series.html
│   │       │   │   ├── serie.filters.html
│   │       │   │   └── text
│   │       │   │       ├── basic.html
│   │       │   │       ├── edit.html
│   │       │   │       ├── serie.filters.html
│   │       │   │       ├── series.html
│   │       │   │       └── view.html
│   │       │   ├── date-time-picker.html
│   │       │   ├── dropzone.html
│   │       │   ├── dt-picker.html
│   │       │   ├── entity-link.html
│   │       │   ├── filter-box.html
│   │       │   ├── flow
│   │       │   │   ├── action.html
│   │       │   │   ├── alert.html
│   │       │   │   ├── case.html
│   │       │   │   ├── caseTemplate.html
│   │       │   │   ├── dashboard.html
│   │       │   │   ├── flow-item.html
│   │       │   │   ├── flow.html
│   │       │   │   ├── observable-job.html
│   │       │   │   ├── observable.html
│   │       │   │   ├── operation.html
│   │       │   │   ├── organisation.html
│   │       │   │   ├── procedure.html
│   │       │   │   ├── task-log.html
│   │       │   │   ├── task.html
│   │       │   │   └── user.html
│   │       │   ├── log-entry-delete.html
│   │       │   ├── log-entry.html
│   │       │   ├── mini-report-list.html
│   │       │   ├── page-sizer.html
│   │       │   ├── permission-list.html
│   │       │   ├── psearch.html
│   │       │   ├── report-observables.html
│   │       │   ├── responder-actions.html
│   │       │   ├── search
│   │       │   │   ├── alert.html
│   │       │   │   ├── audit.html
│   │       │   │   ├── case.html
│   │       │   │   ├── observable-job.html
│   │       │   │   ├── observable.html
│   │       │   │   ├── search-item.html
│   │       │   │   ├── task-log.html
│   │       │   │   └── task.html
│   │       │   ├── severity.html
│   │       │   ├── tag-input-item.html
│   │       │   ├── tag-item.html
│   │       │   ├── tag-list.html
│   │       │   ├── task-progress.html
│   │       │   ├── tlp.html
│   │       │   ├── updatable-boolean.html
│   │       │   ├── updatable-colour.html
│   │       │   ├── updatable-date.html
│   │       │   ├── updatable-select.html
│   │       │   ├── updatable-simple-text.html
│   │       │   ├── updatable-tag-list.html
│   │       │   ├── updatable-tag.html
│   │       │   ├── updatable-tags.html
│   │       │   ├── updatable-text.html
│   │       │   ├── updatable-user.html
│   │       │   ├── updatable.html
│   │       │   └── user.html
│   │       ├── login.html
│   │       ├── maintenance.html
│   │       ├── partials
│   │       │   ├── about.html
│   │       │   ├── admin
│   │       │   │   ├── analyzer-template-delete.html
│   │       │   │   ├── analyzer-template-dialog.html
│   │       │   │   ├── analyzer-template-import.html
│   │       │   │   ├── analyzer-templates.html
│   │       │   │   ├── attack
│   │       │   │   │   ├── import.html
│   │       │   │   │   ├── list
│   │       │   │   │   │   ├── filters.html
│   │       │   │   │   │   └── toolbar.html
│   │       │   │   │   ├── list.html
│   │       │   │   │   └── view.html
│   │       │   │   ├── custom-field-dialog.html
│   │       │   │   ├── custom-fields.html
│   │       │   │   ├── observables.html
│   │       │   │   ├── organisation
│   │       │   │   │   ├── case-templates
│   │       │   │   │   │   └── list.html
│   │       │   │   │   ├── details.html
│   │       │   │   │   ├── list
│   │       │   │   │   │   ├── create.modal.html
│   │       │   │   │   │   ├── filters.html
│   │       │   │   │   │   ├── link.modal.html
│   │       │   │   │   │   └── toolbar.html
│   │       │   │   │   ├── list.html
│   │       │   │   │   └── user.modal.html
│   │       │   │   ├── platform
│   │       │   │   │   └── status.html
│   │       │   │   ├── profile
│   │       │   │   │   ├── list
│   │       │   │   │   │   └── toolbar.html
│   │       │   │   │   ├── list.html
│   │       │   │   │   └── profile.modal.html
│   │       │   │   ├── taxonomy
│   │       │   │   │   ├── import.html
│   │       │   │   │   ├── list
│   │       │   │   │   │   ├── filters.html
│   │       │   │   │   │   └── toolbar.html
│   │       │   │   │   ├── list.html
│   │       │   │   │   └── view.html
│   │       │   │   └── ui-settings.html
│   │       │   ├── afk-modal.html
│   │       │   ├── alert
│   │       │   │   ├── custom.fields.html
│   │       │   │   ├── event.dialog.html
│   │       │   │   ├── event.similarity.html
│   │       │   │   ├── list
│   │       │   │   │   ├── filters.html
│   │       │   │   │   ├── mini-stats.html
│   │       │   │   │   └── toolbar.html
│   │       │   │   └── list.html
│   │       │   ├── case
│   │       │   │   ├── case.add.field.html
│   │       │   │   ├── case.alerts.html
│   │       │   │   ├── case.bulk.delete.confirm.html
│   │       │   │   ├── case.close.html
│   │       │   │   ├── case.creation.html
│   │       │   │   ├── case.delete.confirm.html
│   │       │   │   ├── case.details.html
│   │       │   │   ├── case.links.html
│   │       │   │   ├── case.list.html
│   │       │   │   ├── case.merge.html
│   │       │   │   ├── case.observables.html
│   │       │   │   ├── case.observables.item.html
│   │       │   │   ├── case.panelinfo.html
│   │       │   │   ├── case.procedures.html
│   │       │   │   ├── case.reopen.html
│   │       │   │   ├── case.sharing.html
│   │       │   │   ├── case.tasks.html
│   │       │   │   ├── case.tasks.item.html
│   │       │   │   ├── case.templates.selector.html
│   │       │   │   ├── case.update.html
│   │       │   │   ├── details
│   │       │   │   │   ├── custom.fields.html
│   │       │   │   │   └── related.cases.html
│   │       │   │   ├── list
│   │       │   │   │   ├── filters.html
│   │       │   │   │   ├── mini-stats.html
│   │       │   │   │   └── toolbar.html
│   │       │   │   ├── procedures
│   │       │   │   │   ├── add-procedure.modal.html
│   │       │   │   │   ├── filters.html
│   │       │   │   │   └── toolbar.html
│   │       │   │   ├── share
│   │       │   │   │   └── case.share.modal.html
│   │       │   │   ├── tasklogs
│   │       │   │   │   └── add-task-log.modal.html
│   │       │   │   └── tasks
│   │       │   │       ├── filters.html
│   │       │   │       └── toolbar.html
│   │       │   ├── cortex
│   │       │   │   ├── choose-instance-dialog.html
│   │       │   │   └── responder-action-dialog.html
│   │       │   ├── dashboard
│   │       │   │   ├── container.html
│   │       │   │   ├── create.dialog.html
│   │       │   │   ├── import.dialog.html
│   │       │   │   ├── list
│   │       │   │   │   ├── filters.html
│   │       │   │   │   └── toolbar.html
│   │       │   │   ├── list.html
│   │       │   │   └── view.html
│   │       │   ├── live.html
│   │       │   ├── main
│   │       │   │   ├── filters.html
│   │       │   │   ├── index-mytasks.html
│   │       │   │   ├── index-waitingtasks.html
│   │       │   │   ├── list.html
│   │       │   │   └── toolbar.html
│   │       │   ├── misc
│   │       │   │   ├── responder.selector.html
│   │       │   │   └── taxonomy-selection.modal.html
│   │       │   ├── misp
│   │       │   │   ├── case.export.confirm.html
│   │       │   │   └── choose-instance-dialog.html
│   │       │   ├── observables
│   │       │   │   ├── creation
│   │       │   │   │   ├── error.html
│   │       │   │   │   └── form.html
│   │       │   │   ├── details
│   │       │   │   │   ├── analysers.html
│   │       │   │   │   ├── responders.html
│   │       │   │   │   ├── sharing.html
│   │       │   │   │   └── summary.html
│   │       │   │   ├── list
│   │       │   │   │   ├── export.html
│   │       │   │   │   ├── filters.html
│   │       │   │   │   ├── job-report-dialog.html
│   │       │   │   │   ├── mini-stats.html
│   │       │   │   │   └── observables.html
│   │       │   │   ├── observable.analyze.html
│   │       │   │   ├── observable.creation.html
│   │       │   │   └── observable.update.html
│   │       │   ├── personal-settings.html
│   │       │   ├── search
│   │       │   │   └── list.html
│   │       │   └── utils
│   │       │       └── confirm.modal.html
│   │       └── reports
│   │           └── default.html
│   ├── bower.json
│   ├── package.json
│   └── test
│       └── karma.conf.js
├── images
│   ├── Alerts_Panel.png
│   ├── Current_cases.png
│   ├── thehive-architecture.png
│   ├── thehive-logo.png
│   └── thehive-workflow.png
├── issues.md
├── lib
│   └── play-propfind.jar
├── migration
│   └── src
│       ├── main
│       │   ├── resources
│       │   │   └── reference.conf
│       │   └── scala
│       │       └── org
│       │           └── thp
│       │               └── thehive
│       │                   ├── cloner
│       │                   │   ├── Cloner.scala
│       │                   │   └── IntegrityCheckApp.scala
│       │                   └── migration
│       │                       ├── IdMapping.scala
│       │                       ├── Input.scala
│       │                       ├── Migrate.scala
│       │                       ├── MigrationOps.scala
│       │                       ├── Output.scala
│       │                       ├── ProgressBar.scala
│       │                       ├── QueueIterator.scala
│       │                       ├── Terminal.scala
│       │                       ├── dto
│       │                       │   ├── InputAction.scala
│       │                       │   ├── InputAlert.scala
│       │                       │   ├── InputAttachment.scala
│       │                       │   ├── InputAudit.scala
│       │                       │   ├── InputCase.scala
│       │                       │   ├── InputCaseTemplate.scala
│       │                       │   ├── InputCustomField.scala
│       │                       │   ├── InputDashboard.scala
│       │                       │   ├── InputImpactStatus.scala
│       │                       │   ├── InputJob.scala
│       │                       │   ├── InputLog.scala
│       │                       │   ├── InputObservable.scala
│       │                       │   ├── InputObservableType.scala
│       │                       │   ├── InputOrganisation.scala
│       │                       │   ├── InputProfile.scala
│       │                       │   ├── InputResolutionStatus.scala
│       │                       │   ├── InputTask.scala
│       │                       │   ├── InputUser.scala
│       │                       │   └── MetaData.scala
│       │                       ├── th3
│       │                       │   ├── Conversion.scala
│       │                       │   ├── ElasticClient.scala
│       │                       │   ├── ElasticDsl.scala
│       │                       │   ├── Input.scala
│       │                       │   └── SearchWithScroll.scala
│       │                       └── th4
│       │                           ├── DummyActor.scala
│       │                           ├── JanusDatabaseProvider.scala
│       │                           ├── NoAuditSrv.scala
│       │                           └── Output.scala
│       └── test
│           └── scala
│               └── org
│                   └── thp
│                       └── thehive
│                           └── migration
│                               └── th3
│                                   └── UserNormalisationTest.scala
├── misp
│   ├── client
│   │   └── src
│   │       └── main
│   │           └── scala
│   │               └── org
│   │                   └── thp
│   │                       └── misp
│   │                           ├── client
│   │                           │   ├── Base64Flow.scala
│   │                           │   └── MispClient.scala
│   │                           └── dto
│   │                               ├── Attribute.scala
│   │                               ├── Event.scala
│   │                               ├── Organisation.scala
│   │                               ├── Tag.scala
│   │                               └── User.scala
│   └── connector
│       └── src
│           ├── main
│           │   ├── resources
│           │   │   ├── play
│           │   │   │   └── reference-overrides.conf
│           │   │   └── reference.conf
│           │   └── scala
│           │       └── org
│           │           └── thp
│           │               └── thehive
│           │                   └── connector
│           │                       └── misp
│           │                           ├── MispModule.scala
│           │                           ├── MispRouter.scala
│           │                           ├── controllers
│           │                           │   └── v0
│           │                           │       ├── MispCtrl.scala
│           │                           │       └── Router.scala
│           │                           └── services
│           │                               ├── AttributeConverter.scala
│           │                               ├── Connector.scala
│           │                               ├── MispActor.scala
│           │                               ├── MispExportSrv.scala
│           │                               ├── MispImportSrv.scala
│           │                               ├── MispSerializer.scala
│           │                               ├── QueueIterator.scala
│           │                               └── TheHiveMispClient.scala
│           └── test
│               ├── resources
│               │   ├── attributes.json
│               │   ├── events.json
│               │   ├── organisation.json
│               │   └── user.json
│               └── scala
│                   └── org
│                       └── thp
│                           └── thehive
│                               └── connector
│                                   └── misp
│                                       └── services
│                                           ├── MispImportSrvTest.scala
│                                           └── TestMispClientProvider.scala
├── package
│   ├── debian
│   │   ├── postinst
│   │   ├── postrm
│   │   └── prerm
│   ├── docker
│   │   ├── Dockerfile
│   │   └── entrypoint
│   ├── empty
│   ├── logback-migration.xml
│   ├── logback.xml
│   ├── rpm
│   │   ├── post
│   │   ├── postun
│   │   ├── pre
│   │   └── preun
│   ├── rpm-release
│   │   └── thehive-rpm.repo
│   ├── thehive.default
│   └── thehive.service
├── package.sbt
├── project
│   ├── Common.scala
│   ├── Dependencies.scala
│   ├── FileBuilder.scala
│   ├── build.properties
│   └── plugins.sbt
├── rpm.sbt
├── sbt
├── test
│   └── resources
│       └── logback-test.xml
└── thehive
    ├── app
    │   └── org
    │       └── thp
    │           └── thehive
    │               ├── ClusterSetup.scala
    │               ├── GuiceAkkaExtension.scala
    │               ├── TheHiveModule.scala
    │               ├── TheHiveRouter.scala
    │               ├── controllers
    │               │   ├── HttpHeaderParameterEncoding.scala
    │               │   ├── dav
    │               │   │   ├── Resource.scala
    │               │   │   ├── Router.scala
    │               │   │   └── VFS.scala
    │               │   ├── v0
    │               │   │   ├── AlertCtrl.scala
    │               │   │   ├── AttachmentCtrl.scala
    │               │   │   ├── AuditCtrl.scala
    │               │   │   ├── AuditRenderer.scala
    │               │   │   ├── AuthenticationCtrl.scala
    │               │   │   ├── CaseCtrl.scala
    │               │   │   ├── CaseRenderer.scala
    │               │   │   ├── CaseTemplateCtrl.scala
    │               │   │   ├── ConfigCtrl.scala
    │               │   │   ├── Conversion.scala
    │               │   │   ├── CustomFieldCtrl.scala
    │               │   │   ├── DashboardCtrl.scala
    │               │   │   ├── DescribeCtrl.scala
    │               │   │   ├── ListCtrl.scala
    │               │   │   ├── LogCtrl.scala
    │               │   │   ├── ObservableCtrl.scala
    │               │   │   ├── ObservableRenderer.scala
    │               │   │   ├── ObservableTypeCtrl.scala
    │               │   │   ├── OrganisationCtrl.scala
    │               │   │   ├── PageCtrl.scala
    │               │   │   ├── PermissionCtrl.scala
    │               │   │   ├── ProfileCtrl.scala
    │               │   │   ├── QueryCtrl.scala
    │               │   │   ├── Router.scala
    │               │   │   ├── ShareCtrl.scala
    │               │   │   ├── StatsCtrl.scala
    │               │   │   ├── StatusCtrl.scala
    │               │   │   ├── StreamCtrl.scala
    │               │   │   ├── TagCtrl.scala
    │               │   │   ├── TaskCtrl.scala
    │               │   │   ├── TheHiveQueryExecutor.scala
    │               │   │   └── UserCtrl.scala
    │               │   └── v1
    │               │       ├── AdminCtrl.scala
    │               │       ├── AlertCtrl.scala
    │               │       ├── AlertRenderer.scala
    │               │       ├── AuditCtrl.scala
    │               │       ├── AuthenticationCtrl.scala
    │               │       ├── BaseRenderer.scala
    │               │       ├── CaseCtrl.scala
    │               │       ├── CaseRenderer.scala
    │               │       ├── CaseTemplateCtrl.scala
    │               │       ├── Conversion.scala
    │               │       ├── CustomFieldCtrl.scala
    │               │       ├── DashboardCtrl.scala
    │               │       ├── DescribeCtrl.scala
    │               │       ├── LogCtrl.scala
    │               │       ├── LogRenderer.scala
    │               │       ├── MonitoringCtrl.scala
    │               │       ├── ObservableCtrl.scala
    │               │       ├── ObservableRenderer.scala
    │               │       ├── ObservableTypeCtrl.scala
    │               │       ├── OrganisationCtrl.scala
    │               │       ├── PatternCtrl.scala
    │               │       ├── PatternRenderer.scala
    │               │       ├── ProcedureCtrl.scala
    │               │       ├── ProcedureRenderer.scala
    │               │       ├── ProfileCtrl.scala
    │               │       ├── Properties.scala
    │               │       ├── QueryableCtrl.scala
    │               │       ├── Router.scala
    │               │       ├── ShareCtrl.scala
    │               │       ├── StatusCtrl.scala
    │               │       ├── TagCtrl.scala
    │               │       ├── TagRenderer.scala
    │               │       ├── TaskCtrl.scala
    │               │       ├── TaskRenderer.scala
    │               │       ├── TaxonomyCtrl.scala
    │               │       ├── TaxonomyRenderer.scala
    │               │       ├── TheHiveQueryExecutor.scala
    │               │       ├── UserCtrl.scala
    │               │       └── UserRenderer.scala
    │               ├── models
    │               │   ├── Alert.scala
    │               │   ├── Attachment.scala
    │               │   ├── Audit.scala
    │               │   ├── Case.scala
    │               │   ├── CaseTemplate.scala
    │               │   ├── Config.scala
    │               │   ├── CustomField.scala
    │               │   ├── Dashboard.scala
    │               │   ├── HealthStatus.scala
    │               │   ├── KeyValue.scala
    │               │   ├── Log.scala
    │               │   ├── Observable.scala
    │               │   ├── ObservableType.scala
    │               │   ├── Organisation.scala
    │               │   ├── Page.scala
    │               │   ├── Pattern.scala
    │               │   ├── Permissions.scala
    │               │   ├── Procedure.scala
    │               │   ├── ReportTag.scala
    │               │   ├── Role.scala
    │               │   ├── Share.scala
    │               │   ├── Tag.scala
    │               │   ├── Task.scala
    │               │   ├── Taxonomy.scala
    │               │   ├── TheHiveSchemaDefinition.scala
    │               │   └── User.scala
    │               └── services
    │                   ├── AlertSrv.scala
    │                   ├── AttachmentSrv.scala
    │                   ├── AuditSrv.scala
    │                   ├── CaseNumber.scala
    │                   ├── CaseSrv.scala
    │                   ├── CaseTemplateSrv.scala
    │                   ├── ConfigContext.scala
    │                   ├── ConfigSrv.scala
    │                   ├── Connector.scala
    │                   ├── CustomFieldSrv.scala
    │                   ├── DashboardSrv.scala
    │                   ├── DataSrv.scala
    │                   ├── FlowActor.scala
    │                   ├── FlowSerializer.scala
    │                   ├── ImpactStatusSrv.scala
    │                   ├── IntegrityCheckActor.scala
    │                   ├── IntegrityCheckSerializer.scala
    │                   ├── KeyValueSrv.scala
    │                   ├── LocalKeyAuthSrv.scala
    │                   ├── LocalPasswordAuthSrv.scala
    │                   ├── LocalUserSrv.scala
    │                   ├── LogSrv.scala
    │                   ├── ObservableSrv.scala
    │                   ├── ObservableTypeSrv.scala
    │                   ├── OrganisationSrv.scala
    │                   ├── PageSrv.scala
    │                   ├── PatternSrv.scala
    │                   ├── ProcedureSrv.scala
    │                   ├── ProfileSrv.scala
    │                   ├── ReportTagSrv.scala
    │                   ├── ResolutionStatusSrv.scala
    │                   ├── RoleSrv.scala
    │                   ├── ShareSrv.scala
    │                   ├── StreamSrv.scala
    │                   ├── TOTPAuthSrv.scala
    │                   ├── TagSrv.scala
    │                   ├── TaskSrv.scala
    │                   ├── TaxonomySrv.scala
    │                   ├── UserSrv.scala
    │                   ├── notification
    │                   │   ├── NotificationActor.scala
    │                   │   ├── NotificationConfig.scala
    │                   │   ├── NotificationSerializer.scala
    │                   │   ├── notifiers
    │                   │   │   ├── AppendToFile.scala
    │                   │   │   ├── Emailer.scala
    │                   │   │   ├── Mattermost.scala
    │                   │   │   ├── Notifier.scala
    │                   │   │   ├── Template.scala
    │                   │   │   └── Webhook.scala
    │                   │   └── triggers
    │                   │       ├── AlertCreated.scala
    │                   │       ├── AnyEvent.scala
    │                   │       ├── CaseCreated.scala
    │                   │       ├── CaseShared.scala
    │                   │       ├── FilteredEvent.scala
    │                   │       ├── GlobalTrigger.scala
    │                   │       ├── JobFinished.scala
    │                   │       ├── LogInMyTask.scala
    │                   │       ├── TaskAssigned.scala
    │                   │       └── Trigger.scala
    │                   └── th3
    │                       └── Aggregation.scala
    ├── conf
    │   ├── play
    │   │   └── reference-overrides.conf
    │   └── reference.conf
    └── test
        ├── org
        │   └── thp
        │       └── thehive
        │           ├── DatabaseBuilder.scala
        │           ├── DevStart.scala
        │           ├── DummyActor.scala
        │           ├── FunctionalTest.scala
        │           ├── QueryTest.scala
        │           ├── TestAppBuilder.scala
        │           ├── controllers
        │           │   ├── v0
        │           │   │   ├── AlertCtrlTest.scala
        │           │   │   ├── AttachmentCtrlTest.scala
        │           │   │   ├── AuditCtrlTest.scala
        │           │   │   ├── AuthenticationCtrlTest.scala
        │           │   │   ├── CaseCtrlTest.scala
        │           │   │   ├── CaseTemplateCtrlTest.scala
        │           │   │   ├── ConfigCtrlTest.scala
        │           │   │   ├── CustomFieldCtrlTest.scala
        │           │   │   ├── DashboardCtrlTest.scala
        │           │   │   ├── DescribeCtrlTest.scala
        │           │   │   ├── LogCtrlTest.scala
        │           │   │   ├── ObservableCtrlTest.scala
        │           │   │   ├── OrganisationCtrlTest.scala
        │           │   │   ├── PageCtrlTest.scala
        │           │   │   ├── ProfileCtrlTest.scala
        │           │   │   ├── QueryTest.scala
        │           │   │   ├── ShareCtrlTest.scala
        │           │   │   ├── StatusCtrlTest.scala
        │           │   │   ├── StreamCtrlTest.scala
        │           │   │   ├── TagCtrlTest.scala
        │           │   │   ├── TaskCtrlTest.scala
        │           │   │   └── UserCtrlTest.scala
        │           │   └── v1
        │           │       ├── AlertCtrlTest.scala
        │           │       ├── CaseCtrlTest.scala
        │           │       ├── GraphqlTest.scala
        │           │       ├── OrganisationCtrlTest.scala
        │           │       ├── PatternCtrlTest.scala
        │           │       ├── ProcedureCtrlTest.scala
        │           │       ├── TaxonomyCtrlTest.scala
        │           │       └── UserCtrlTest.scala
        │           └── services
        │               ├── AlertSrvTest.scala
        │               ├── AttachmentSrvTest.scala
        │               ├── AuditSrvTest.scala
        │               ├── CaseNumberTest.scala
        │               ├── CaseSrvTest.scala
        │               ├── CaseTemplateSrvTest.scala
        │               ├── ConfigSrvTest.scala
        │               ├── CustomFieldSrvTest.scala
        │               ├── DashboardSrvTest.scala
        │               ├── DataSrvTest.scala
        │               ├── ImpactStatusSrvTest.scala
        │               ├── LocalPasswordAuthSrvTest.scala
        │               ├── ObservableSrvTest.scala
        │               ├── OrganisationSrvTest.scala
        │               ├── TagSrvTest.scala
        │               ├── TaskSrvTest.scala
        │               ├── UserSrvTest.scala
        │               └── notification
        │                   ├── notifiers
        │                   │   └── NotificationTemplateTest.scala
        │                   └── triggers
        │                       ├── AlertCreatedTest.scala
        │                       └── TaskAssignedTest.scala
        └── resources
            ├── data
            │   ├── Alert.json
            │   ├── AlertCase.json
            │   ├── AlertCaseTemplate.json
            │   ├── AlertCustomField.json
            │   ├── AlertObservable.json
            │   ├── AlertOrganisation.json
            │   ├── Attachment.json
            │   ├── Case.json
            │   ├── CaseCustomField.json
            │   ├── CaseProcedure.json
            │   ├── CaseTemplate.json
            │   ├── CaseTemplateCustomField.json
            │   ├── CaseTemplateOrganisation.json
            │   ├── CustomField.json
            │   ├── Dashboard.json
            │   ├── DashboardUser.json
            │   ├── Job.json
            │   ├── Log.json
            │   ├── LogAttachment.json
            │   ├── Observable.json
            │   ├── ObservableAttachment.json
            │   ├── ObservableJob.json
            │   ├── Organisation.json
            │   ├── OrganisationDashboard.json
            │   ├── OrganisationOrganisation.json
            │   ├── OrganisationPage.json
            │   ├── OrganisationShare.json
            │   ├── OrganisationTaxonomy.json
            │   ├── Page.json
            │   ├── Pattern.json
            │   ├── Procedure.json
            │   ├── ProcedurePattern.json
            │   ├── Profile.json
            │   ├── Role.json
            │   ├── RoleOrganisation.json
            │   ├── RoleProfile.json
            │   ├── Share.json
            │   ├── ShareCase.json
            │   ├── ShareObservable.json
            │   ├── ShareProfile.json
            │   ├── ShareTask.json
            │   ├── Tag.json
            │   ├── Task.json
            │   ├── TaskLog.json
            │   ├── Taxonomy.json
            │   ├── TaxonomyTag.json
            │   ├── User.json
            │   └── UserRole.json
            ├── init_orgs.sh
            ├── machinetag-badformat.zip
            ├── machinetag-folders.zip
            ├── machinetag-otherfiles.zip
            ├── machinetag-present.zip
            ├── machinetag.zip
            ├── patterns.json
            └── patternsUpdate.json

```

`AUTHORS`:

```
Authors
-------

* Nabil Adouani <nabil@thehive-project.org>
* Thomas Franco <toom@thehive-project.org>
* Saâd Kadhi <saad@thehive-project.org> (project leader)
* Jérôme Leonard <jerome@thehive-project.org>

Contributors
------------

* CERT Banque de France (CERT-BDF)

Copyright (C) 2017-2018 Nabil Adouani
Copyright (C) 2014-2018 Thomas Franco
Copyright (C) 2014-2018 Saâd Kadhi
Copyright (C) 2014-2018 Jérôme Leonard
```

`CHANGELOG.md`:

```md
# Change Log

## [4.1.24](https://github.com/TheHive-Project/TheHive/milestone/95) (2022-09-12)

**Fixed bugs:**

- [Bug] All analyzers become unavailable when an analyzer is updated [\#2420](https://github.com/TheHive-Project/TheHive/issues/2420)

## [4.1.23](https://github.com/TheHive-Project/TheHive/milestone/94) (2022-08-30)

**Fixed bugs:**

- [Bug] system user can be deleted by integrity checks [\#2406](https://github.com/TheHive-Project/TheHive/issues/2406)

## [4.1.22](https://github.com/TheHive-Project/TheHive/milestone/93) (2022-07-01)

**Implemented enhancements:**

- [Enhancement] Add check on user role [\#2401](https://github.com/TheHive-Project/TheHive/issues/2401)

**Fixed bugs:**

- [Bug] Use dedicated stream topic for stream dispatcher subscription [\#2400](https://github.com/TheHive-Project/TheHive/issues/2400)

## [4.1.21](https://github.com/TheHive-Project/TheHive/milestone/91) (2022-06-22)

**Fixed bugs:**

- [Bug] S3 storage fails with old version of Minio [\#2388](https://github.com/TheHive-Project/TheHive/issues/2388)
- [Bug ] Authentication Bypass Vulnerability [\#2391](https://github.com/TheHive-Project/TheHive/issues/2391)

## [4.1.20](https://github.com/TheHive-Project/TheHive/milestone/90) (2022-05-16)

**Implemented enhancements:**

- [Enhancement] Improve artifact creation from responder operation [\#2383](https://github.com/TheHive-Project/TheHive/issues/2383)
- [Enhancement] Accept operations in analyzer reports [\#2384](https://github.com/TheHive-Project/TheHive/issues/2384)
- [Enhancement] Add queries to filter observables based on the type of object it belongs to [\#2385](https://github.com/TheHive-Project/TheHive/issues/2385)

**Fixed bugs:**

- [Bug] Unable to use AWS S3 as storage backend  [\#2316](https://github.com/TheHive-Project/TheHive/issues/2316)
- [Bug] Typo on migration elasticsearch http config [\#2374](https://github.com/TheHive-Project/TheHive/issues/2374)

## [4.1.19](https://github.com/TheHive-Project/TheHive/milestone/89) (2022-04-07)

**Implemented enhancements:**

- Migrate hive3 to 4, migrate SSL error. Requesting SSL bypass option [\#2356](https://github.com/TheHive-Project/TheHive/issues/2356)
- [Enhancement] Improve logging [\#2371](https://github.com/TheHive-Project/TheHive/issues/2371)

**Fixed bugs:**

- [Bug] Regression starting with 4.1.17 in the migration tool with certificate validation  [\#2342](https://github.com/TheHive-Project/TheHive/issues/2342)
- [Bug] Deadlock when the index backend changed [\#2351](https://github.com/TheHive-Project/TheHive/issues/2351)
- [Bug][Security] TheHive4 libraries vulnerabilities [\#2362](https://github.com/TheHive-Project/TheHive/issues/2362)
- [Bug] The Link given in /etc/thehive/application.conf says error. [\#2364](https://github.com/TheHive-Project/TheHive/issues/2364)
- [Bug] An unshared case is still visible [\#2366](https://github.com/TheHive-Project/TheHive/issues/2366)
- [Bug] Prevent custom field creation if it already exists [\#2367](https://github.com/TheHive-Project/TheHive/issues/2367)
- [Bug] An user may exist without being member of any organisation [\#2368](https://github.com/TheHive-Project/TheHive/issues/2368)
- [Bug] Tags can't be updated [\#2369](https://github.com/TheHive-Project/TheHive/issues/2369)
- [Bug] Dashboarding on weeks provide incorrect results on specific dates [\#2370](https://github.com/TheHive-Project/TheHive/issues/2370)

## [4.1.18](https://github.com/TheHive-Project/TheHive/milestone/88) (2022-02-07)

**Implemented enhancements:**

- [Enhancement] Integrity check improvement [\#2334](https://github.com/TheHive-Project/TheHive/issues/2334)
- [Enhancement] Improve migration tool [\#2335](https://github.com/TheHive-Project/TheHive/issues/2335)

**Fixed bugs:**

- [Bug] "Character 8211 cannot match AsciiSet because it is out of range" error when downloading a report [\#1534](https://github.com/TheHive-Project/TheHive/issues/1534)
- [Bug] Can add a "space" as observable [\#2324](https://github.com/TheHive-Project/TheHive/issues/2324)
- [Bug]- Migration from Hive 3.4.4 to Hive 4.1.17 not working [\#2331](https://github.com/TheHive-Project/TheHive/issues/2331)
- [Bug] Duplicated entities after "db.janusgraph.forceDropAndRebuildIndex: true" with Elasticsearch index [\#2333](https://github.com/TheHive-Project/TheHive/issues/2333)
- [Bug] Query with parendId filter doesn't work (v0) [\#2336](https://github.com/TheHive-Project/TheHive/issues/2336)

## [4.1.17](https://github.com/TheHive-Project/TheHive/milestone/87) (2022-01-24)

**Implemented enhancements:**

- [Enhancement] Improve migration tool by accepting old versions of TheHive [\#2305](https://github.com/TheHive-Project/TheHive/issues/2305)
- Security concern [\#2309](https://github.com/TheHive-Project/TheHive/issues/2309)

**Fixed bugs:**

- [Bug] Action 'mergeCase' not mapped in v0  [\#2304](https://github.com/TheHive-Project/TheHive/issues/2304)
- Can't start after upgrade thehive4 (4.1.16-1) over (4.0.0-1) [Bug] [\#2308](https://github.com/TheHive-Project/TheHive/issues/2308)
- [Bug] Notifications are executed several times [\#2317](https://github.com/TheHive-Project/TheHive/issues/2317)

## [4.1.16](https://github.com/TheHive-Project/TheHive/milestone/86) (2021-12-17)

**Implemented enhancements:**

- [Feature Request] Remove persistent filters on "Similar Cases" tab [\#2282](https://github.com/TheHive-Project/TheHive/issues/2282)
- [Enhancement] When observable data is too big, use hash [\#2288](https://github.com/TheHive-Project/TheHive/issues/2288)
- Remove unnecessary log4j dependency  [\#2291](https://github.com/TheHive-Project/TheHive/issues/2291)

**Fixed bugs:**

- [Bug] Index fails with immense terms [\#2289](https://github.com/TheHive-Project/TheHive/issues/2289)
- [Bug] Marking an alert as read do not update it's "updatedAt" nor "updatedBy" field [\#2292](https://github.com/TheHive-Project/TheHive/issues/2292)

## [4.1.15](https://github.com/TheHive-Project/TheHive/milestone/85) (2021-12-06)

**Implemented enhancements:**

- [Feature Request] Add query to retrieve audit from an object [\#2266](https://github.com/TheHive-Project/TheHive/issues/2266)
- [Feature Request] Sort similar Alerts by Observables [\#2270](https://github.com/TheHive-Project/TheHive/issues/2270)
- [Enhancement] Add space after the title prefix from case template [\#2278](https://github.com/TheHive-Project/TheHive/issues/2278)

**Fixed bugs:**

- [Bug] Search without sort make queries slow [\#2261](https://github.com/TheHive-Project/TheHive/issues/2261)
- [Bug] Marking an alert as read do not update it's "updatedAt" field [\#2262](https://github.com/TheHive-Project/TheHive/issues/2262)
- [Bug] dataType removal doesn't work [\#2263](https://github.com/TheHive-Project/TheHive/issues/2263)
- [Bug] Fix index creation and rebuild [\#2265](https://github.com/TheHive-Project/TheHive/issues/2265)

## [4.1.14](https://github.com/TheHive-Project/TheHive/milestone/84) (2021-11-19)

**Implemented enhancements:**

- [FR] Add user/org in Analyzers requests parameters [\#2245](https://github.com/TheHive-Project/TheHive/issues/2245)
- [Feature Request] Add sort capability on "Profile" field of a organisations users list [\#2246](https://github.com/TheHive-Project/TheHive/issues/2246)
- [Feature Request] Add API for change observable from a type to another [\#2251](https://github.com/TheHive-Project/TheHive/issues/2251)

**Fixed bugs:**

- [Bug] Fix observable type inconsistencies [\#2248](https://github.com/TheHive-Project/TheHive/issues/2248)
- [Bug] Send notification to all viewing organisations [\#2249](https://github.com/TheHive-Project/TheHive/issues/2249)
- [Bug] Update the field caseId in alert when it is imported in case [\#2250](https://github.com/TheHive-Project/TheHive/issues/2250)
- [Bug] Incomplete alert observable details in search page [\#2252](https://github.com/TheHive-Project/TheHive/issues/2252)

## [4.1.13](https://github.com/TheHive-Project/TheHive/milestone/83) (2021-11-08)

**Implemented enhancements:**

- [Feature Request] Add API to link alert and case after a broken migration from TH3 [\#2238](https://github.com/TheHive-Project/TheHive/issues/2238)

**Fixed bugs:**

- [Bug] Migration breaks links between alerts and cases thus rendering all alert statuses as ignored [\#2232](https://github.com/TheHive-Project/TheHive/issues/2232)
- [Bug] Search Section results missing (Observables) [\#2233](https://github.com/TheHive-Project/TheHive/issues/2233)
- [Enhancement] Accept slash in attachment filename [\#2240](https://github.com/TheHive-Project/TheHive/issues/2240)

## [4.1.12](https://github.com/TheHive-Project/TheHive/milestone/82) (2021-10-29)

**Fixed bugs:**

- [Bug] Upon case merge: missing webhook events about the operation performed on merged cases [\#1969](https://github.com/TheHive-Project/TheHive/issues/1969)
- [Bug] Uploading zipped observables raises a ClassCastException [\#2224](https://github.com/TheHive-Project/TheHive/issues/2224)
- [Bug] The search for an observable data is slow [\#2225](https://github.com/TheHive-Project/TheHive/issues/2225)
- [Bug] Uploading files could cause TheHive crash with "too many open files" errror [\#2226](https://github.com/TheHive-Project/TheHive/issues/2226)
- [Bug] Configuration containing endpoint with "authentication: none" cannot be written [\#2231](https://github.com/TheHive-Project/TheHive/issues/2231)

## [4.1.11](https://github.com/TheHive-Project/TheHive/milestone/81) (2021-10-06)

**Implemented enhancements:**

- [Feature Request] Add the ability to update type of observable [\#2125](https://github.com/TheHive-Project/TheHive/issues/2125)

**Closed issues:**

- [Bug] Editing Someone Else's Dashboard [\#2212](https://github.com/TheHive-Project/TheHive/issues/2212)

**Fixed bugs:**

- [Bug] Dashboard are shared in read only by default [\#2190](https://github.com/TheHive-Project/TheHive/issues/2190)
- [Bug] Analyzer reports migration to 4.1.10 problem [\#2203](https://github.com/TheHive-Project/TheHive/issues/2203)

## [4.1.10](https://github.com/TheHive-Project/TheHive/milestone/79) (2021-08-26)

**Fixed bugs:**

- [Bug] Reload last case number from database periodically [\#2182](https://github.com/TheHive-Project/TheHive/issues/2182)

## [4.1.9](https://github.com/TheHive-Project/TheHive/milestone/78) (2021-07-23)

**Implemented enhancements:**

- [Enhancement] Add button for index rebuilding [\#2144](https://github.com/TheHive-Project/TheHive/issues/2144)

**Fixed bugs:**

- [Bug] MISP sync delete existing observables when updating existing Alert [\#2134](https://github.com/TheHive-Project/TheHive/issues/2134)
- [Bug] Livestream emptied of audit logs after TheHive reboot [\#2135](https://github.com/TheHive-Project/TheHive/issues/2135)
- [Bug] AddTagToCase operation does not work [\#2136](https://github.com/TheHive-Project/TheHive/issues/2136)

## [4.1.8](https://github.com/TheHive-Project/TheHive/milestone/77) (2021-07-19)

**Implemented enhancements:**

- [Feature Request] Improve SSO user auto creation [\#2127](https://github.com/TheHive-Project/TheHive/issues/2127)
- [Feature Request] Add simple improvements in alerts list [\#2129](https://github.com/TheHive-Project/TheHive/issues/2129)

**Closed issues:**

- typo in entrypoint man for "cortex-hostnames" [\#2114](https://github.com/TheHive-Project/TheHive/issues/2114)

**Fixed bugs:**

- [Bug] TheHive updates an alert from an updated MISP event but not the promoted Case [\#2110](https://github.com/TheHive-Project/TheHive/issues/2110)

## [4.1.7](https://github.com/TheHive-Project/TheHive/milestone/76) (2021-07-05)

**Implemented enhancements:**

- [Enhancement] Copy the database even if the schema version doesn't match (with force flag) [\#2105](https://github.com/TheHive-Project/TheHive/issues/2105)

**Fixed bugs:**

- [Bug] Issue with Migration 3.5.1 -> 4.1.6 [\#2089](https://github.com/TheHive-Project/TheHive/issues/2089)
- [Bug] Fix serialization for case number messages [\#2107](https://github.com/TheHive-Project/TheHive/issues/2107)
- [Bug] Case is removed if the assignee is removed [\#2109](https://github.com/TheHive-Project/TheHive/issues/2109)

## [4.1.6](https://github.com/TheHive-Project/TheHive/milestone/75) (2021-06-14)

**Implemented enhancements:**

- [Feature Request] Add API to repair database [\#2081](https://github.com/TheHive-Project/TheHive/issues/2081)

**Fixed bugs:**

- [Bug] Editing case template tasks incorrectly removes tasks  [\#1926](https://github.com/TheHive-Project/TheHive/issues/1926)
- [Bug] When creating cases from alerts via API, the same case number gets assigned to multiple distinct cases [\#1970](https://github.com/TheHive-Project/TheHive/issues/1970)
- [Bug] src:MISP-ORG missing on MISP alerts [\#2058](https://github.com/TheHive-Project/TheHive/issues/2058)
- [Bug] Analyzer reports dissapear in 4.1.5 (observable already exists error) [\#2059](https://github.com/TheHive-Project/TheHive/issues/2059)
- [Bug] CaseNumber Conflict [\#2061](https://github.com/TheHive-Project/TheHive/issues/2061)
- [Bug] Alert tags glitch after previewing alert [\#2062](https://github.com/TheHive-Project/TheHive/issues/2062)
- [Bug] Case Template content mixed across organisations [\#2068](https://github.com/TheHive-Project/TheHive/issues/2068)
- [Bug] /api/v1/<user.ID>/key returns 401/403 if user hasn't key [\#2069](https://github.com/TheHive-Project/TheHive/issues/2069)
- [Bug] When API call returns failure, actual response depends on  authentication methods [\#2070](https://github.com/TheHive-Project/TheHive/issues/2070)
- [Bug] Deleting observables doesn't produce audit log [\#2076](https://github.com/TheHive-Project/TheHive/issues/2076)

## [4.1.5](https://github.com/TheHive-Project/TheHive/milestone/74) (2021-06-03)

**Implemented enhancements:**

- [Enhancement] Improve API v1 [\#2010](https://github.com/TheHive-Project/TheHive/issues/2010)
- [Enhancement] Improve integrity checks [\#2033](https://github.com/TheHive-Project/TheHive/issues/2033)
- [Feature Request] Add the ability to copy data from a database to another [\#2042](https://github.com/TheHive-Project/TheHive/issues/2042)
- [Feature Request] Add organisation name in responder data [\#2048](https://github.com/TheHive-Project/TheHive/issues/2048)
- [Feature Request] Add alert updatable fields [\#2055](https://github.com/TheHive-Project/TheHive/issues/2055)

**Closed issues:**

- [Bug] API GET /api/alert fails when similarity is specified [\#1981](https://github.com/TheHive-Project/TheHive/issues/1981)

**Fixed bugs:**

- [Bug] Imported filter does not show alerts which are associated to removed cases [\#1940](https://github.com/TheHive-Project/TheHive/issues/1940)
- [Bug]  Observable already exists [\#1963](https://github.com/TheHive-Project/TheHive/issues/1963)
- [Bug] using quick-filter "shared with my org" takes arround 90 seconds [\#1979](https://github.com/TheHive-Project/TheHive/issues/1979)
- [Bug] Analyzer reports dissapear in 4.1.4 (observable already exists error) [\#1982](https://github.com/TheHive-Project/TheHive/issues/1982)
- [Bug] Merge Into Case search by title not working [\#1983](https://github.com/TheHive-Project/TheHive/issues/1983)
- [Bug] Able to merge alert into closed case, even though it is not allowed [\#1985](https://github.com/TheHive-Project/TheHive/issues/1985)
- Custom Dashboards issue - see #1877 as reference [Bug] [\#2001](https://github.com/TheHive-Project/TheHive/issues/2001)
- [Question] A security issue? [\#2008](https://github.com/TheHive-Project/TheHive/issues/2008)
- [Bug] Case description edit button misplaced after description update [\#2012](https://github.com/TheHive-Project/TheHive/issues/2012)
- [Bug] Analyzer list is not refreshing properly when organization change [\#2025](https://github.com/TheHive-Project/TheHive/issues/2025)
- [Bug] Alert list constantly resets [\#2030](https://github.com/TheHive-Project/TheHive/issues/2030)
- [Bug] Can't Delete Case Custom Field (contains [ character) After Migration [\#2043](https://github.com/TheHive-Project/TheHive/issues/2043)
- [Bug] Unable to find case by Case Number [\#2044](https://github.com/TheHive-Project/TheHive/issues/2044)
- [Bug] add TTP error message on the hive - 4.1.4-1 [\#2045](https://github.com/TheHive-Project/TheHive/issues/2045)
- [Bug] Merge Into Case search by title not a real search [\#2049](https://github.com/TheHive-Project/TheHive/issues/2049)
- [Bug] max-attributes param not working for MISP [\#2050](https://github.com/TheHive-Project/TheHive/issues/2050)
- [Bug] Invalid output when a file observable already exist [\#2054](https://github.com/TheHive-Project/TheHive/issues/2054)

## [4.1.4](https://github.com/TheHive-Project/TheHive/milestone/73) (2021-04-15)

**Implemented enhancements:**

- [Feature Request] Sort case templates in alert Import drop down menu [\#1956](https://github.com/TheHive-Project/TheHive/issues/1956)
- [Enhancement] Make alert deletion more robust [\#1967](https://github.com/TheHive-Project/TheHive/issues/1967)

**Fixed bugs:**

- [Bug] Alert counter refresh not working [\#1911](https://github.com/TheHive-Project/TheHive/issues/1911)
- [Bug] Enabled or Disabled Taxonomies doesn't work [\#1957](https://github.com/TheHive-Project/TheHive/issues/1957)
- [Bug] TheHive 4.1.3-1 Task in Case is not visible [\#1964](https://github.com/TheHive-Project/TheHive/issues/1964)
- [Bug] Aggregation on custom fields provides incorect result (again) [\#1965](https://github.com/TheHive-Project/TheHive/issues/1965)
- [Bug] TheHive startup times out if schema evolution is long [\#1966](https://github.com/TheHive-Project/TheHive/issues/1966)
- [Bug] Default analyst rol cant add TTPs [\#1968](https://github.com/TheHive-Project/TheHive/issues/1968)
- [Bug] Links section should not be empty in Observables details view [\#1972](https://github.com/TheHive-Project/TheHive/issues/1972)
- [Bug] Deleting a shared rule case for org2 - deleting observables (sharing to org2) from the org1. [\#1973](https://github.com/TheHive-Project/TheHive/issues/1973)
- [Bug] AddTagToArtifact operation not working in 4.1.3 [\#1974](https://github.com/TheHive-Project/TheHive/issues/1974)

## [4.1.3](https://github.com/TheHive-Project/TheHive/milestone/72) (2021-04-12)

**Implemented enhancements:**

- [Improvement] Cleanup deprecated filter usage [\#1922](https://github.com/TheHive-Project/TheHive/issues/1922)
- [Improvement] Make the property "Imported" in alerts optimised for index [\#1923](https://github.com/TheHive-Project/TheHive/issues/1923)
- [Feature Request] Display case templates in alphabetic order in "New case" menu [\#1925](https://github.com/TheHive-Project/TheHive/issues/1925)
- [Enhancement] Prevent the application to start if database initialisation fails [\#1935](https://github.com/TheHive-Project/TheHive/issues/1935)
- [Enhancement] Improve performance [\#1946](https://github.com/TheHive-Project/TheHive/issues/1946)
- [Enhancement] Remove blocking queries in some UI pages [\#1948](https://github.com/TheHive-Project/TheHive/issues/1948)
- [Enhancement] Use polluingDuration config from the UI [\#1951](https://github.com/TheHive-Project/TheHive/issues/1951)
- [Enhancement] Disable confirm buttons in import dialogs [\#1953](https://github.com/TheHive-Project/TheHive/issues/1953)
- [Enhancement] Add environment file in service [\#1954](https://github.com/TheHive-Project/TheHive/issues/1954)

**Fixed bugs:**

- [Bug] Add "Not assigned" to Assignee field on task page for tasks without an assigned user [\#1508](https://github.com/TheHive-Project/TheHive/issues/1508)
- [Bug] (Still) slow loading of list-tags endpoint with 4.1.2 [\#1914](https://github.com/TheHive-Project/TheHive/issues/1914)
- [Bug] Aggregation on custom fields provides incorect result [\#1921](https://github.com/TheHive-Project/TheHive/issues/1921)
- [Bug] Very slow load of Case Task list in UI in 4.1.2 [\#1927](https://github.com/TheHive-Project/TheHive/issues/1927)
- [Bug] Task "Take" Button not working [\#1931](https://github.com/TheHive-Project/TheHive/issues/1931)
- [Bug] Cluster: new nodes fail to start when the oldest node has been restarted [\#1934](https://github.com/TheHive-Project/TheHive/issues/1934)
- [Bug] Index status page is very slow [\#1936](https://github.com/TheHive-Project/TheHive/issues/1936)
- [Bug] Update of color in tags [\#1950](https://github.com/TheHive-Project/TheHive/issues/1950)

## [4.1.2](https://github.com/TheHive-Project/TheHive/milestone/71) (2021-03-29)

**Implemented enhancements:**

- [Feature Request] Add case search by TTP [\#1893](https://github.com/TheHive-Project/TheHive/issues/1893)

**Fixed bugs:**

- [Bug] Slow loading of TheHive because of Tags [\#1869](https://github.com/TheHive-Project/TheHive/issues/1869)
- [Bug] After migration from 4.0.5 to 4.1.0 old tasklogs are not returned by "/api/v1/query?name=case-task-logs" query [\#1875](https://github.com/TheHive-Project/TheHive/issues/1875)
- Dashboards - custom fields  [\#1877](https://github.com/TheHive-Project/TheHive/issues/1877)
- [Bug] TH 4.1.1 : Filter by "IMPORTED" does not work for alerts imported into existing cases [\#1891](https://github.com/TheHive-Project/TheHive/issues/1891)
- [Bug] Fix the S3 configuration options [\#1892](https://github.com/TheHive-Project/TheHive/issues/1892)
- [Bug] All attachments in task logs disappeared following upgrade to 4.1.1 [\#1894](https://github.com/TheHive-Project/TheHive/issues/1894)
- [Bug] Continued performance issues after upgrade to 4.1.1 [\#1896](https://github.com/TheHive-Project/TheHive/issues/1896)
- [Bug] Fix issues dashboard list [\#1901](https://github.com/TheHive-Project/TheHive/issues/1901)
- [Bug] Migration tool migrates unsupported elastic index [\#1907](https://github.com/TheHive-Project/TheHive/issues/1907)
- [Bug] Folder permissions are not correctly set in docker image [\#1908](https://github.com/TheHive-Project/TheHive/issues/1908)

## [4.1.1](https://github.com/TheHive-Project/TheHive/milestone/70) (2021-03-23)

**Implemented enhancements:**

- [Feature Request] Include organisation ID in webhooks [\#1865](https://github.com/TheHive-Project/TheHive/issues/1865)

**Closed issues:**

- [Bug] Importing the ATT&CK library fails on 4.1 [\#1862](https://github.com/TheHive-Project/TheHive/issues/1862)
- Thehive4.1.0 Issues with Lucene [\#1863](https://github.com/TheHive-Project/TheHive/issues/1863)

**Fixed bugs:**

- [Bug] TheHive doesn't start if webhook is configured without authentication [\#1859](https://github.com/TheHive-Project/TheHive/issues/1859)
- [Bug] Migration fails from 4.0.5 to 4.1 [\#1861](https://github.com/TheHive-Project/TheHive/issues/1861)
- [Bug] Filter by "IMPORTED" does not work [\#1866](https://github.com/TheHive-Project/TheHive/issues/1866)
- [Bug] TheHive doesn't start in cluster mode (serializer is missing) [\#1868](https://github.com/TheHive-Project/TheHive/issues/1868)
- [Bug] Full-text search is slow [\#1870](https://github.com/TheHive-Project/TheHive/issues/1870)

## [4.1.0](https://github.com/TheHive-Project/TheHive/milestone/56) (2021-03-18)

**Implemented enhancements:**

- Suggestion: Marge cases on the oldest and close the newest as duplicated [\#960](https://github.com/TheHive-Project/TheHive/issues/960)
- [Feature Request] Implement case merging feature [\#1264](https://github.com/TheHive-Project/TheHive/issues/1264)
- [Enhancement] Enrich v1 API [\#1454](https://github.com/TheHive-Project/TheHive/issues/1454)
- [Feature Request] Prompt to save changes to Case Templates before navigating away [\#1524](https://github.com/TheHive-Project/TheHive/issues/1524)
- [Feature Request] allow user to choose the format of the date displayed [\#1583](https://github.com/TheHive-Project/TheHive/issues/1583)
- [Feature Request] Add support to taxonomies [\#1670](https://github.com/TheHive-Project/TheHive/issues/1670)
- [Enhancement] Improve search performance by using external index engine [\#1731](https://github.com/TheHive-Project/TheHive/issues/1731)
- [Feature Request] Default filter of alert case similarity : add "No filter" as an option [\#1750](https://github.com/TheHive-Project/TheHive/issues/1750)
- [Feature Request] Add MITRE ATT&CK support [\#1766](https://github.com/TheHive-Project/TheHive/issues/1766)
- [Feature Request] Show case status in the default view (open / closed as FP / closed as TP, etc.)  [\#1781](https://github.com/TheHive-Project/TheHive/issues/1781)
- [Enhancement] Create logfile after installation [\#1789](https://github.com/TheHive-Project/TheHive/issues/1789)
- [Feature Request] Revamp case template admin section [\#1804](https://github.com/TheHive-Project/TheHive/issues/1804)
- [Feature Request] Improve date fields in data lists [\#1807](https://github.com/TheHive-Project/TheHive/issues/1807)
- [Feature Request] Enhance organisation list page [\#1813](https://github.com/TheHive-Project/TheHive/issues/1813)
- [Feature Request] Add a platform status page [\#1815](https://github.com/TheHive-Project/TheHive/issues/1815)
- [Feature Request] Add organisation free tags administration section [\#1816](https://github.com/TheHive-Project/TheHive/issues/1816)
- [Feature Request] Enhance the dashboard list section [\#1817](https://github.com/TheHive-Project/TheHive/issues/1817)
- [Enhancement] Add migration from TheHive 3.5.1 [\#1818](https://github.com/TheHive-Project/TheHive/issues/1818)
- [Feature Request] Additional case bulk actions [\#1821](https://github.com/TheHive-Project/TheHive/issues/1821)
- [Feature Request] Add support to "isEmpty" filter option [\#1824](https://github.com/TheHive-Project/TheHive/issues/1824)
- [Feature Request] Improve task list page [\#1831](https://github.com/TheHive-Project/TheHive/issues/1831)
- [Feature Request] Disk usage monitoring API route [\#1843](https://github.com/TheHive-Project/TheHive/issues/1843)
- [Feature Request] Allow cancelling task action request [\#1844](https://github.com/TheHive-Project/TheHive/issues/1844)
- [Feature Request] Add more quick filters to case list [\#1848](https://github.com/TheHive-Project/TheHive/issues/1848)
- [Feature Request] Add support of authentication in webhooks [\#1850](https://github.com/TheHive-Project/TheHive/issues/1850)
- [Feature Request] Allow removing a custom field from a case [\#1852](https://github.com/TheHive-Project/TheHive/issues/1852)

**Closed issues:**

- [Feature Request] Alphabetize Case Template view [\#1551](https://github.com/TheHive-Project/TheHive/issues/1551)
- [Feature Request] Add the ability to directly close a task [\#1727](https://github.com/TheHive-Project/TheHive/issues/1727)
- [Question] Tags and custom fields can be seen across organisations / potential for data leakage  [\#1778](https://github.com/TheHive-Project/TheHive/issues/1778)
- [Feature Request] Allow user to reorder case templates, or display them in alphabetic order [\#1787](https://github.com/TheHive-Project/TheHive/issues/1787)
- [Repository] Improve github issue templates [\#1840](https://github.com/TheHive-Project/TheHive/issues/1840)

**Fixed bugs:**

- Can not view or delete alert when delete the case that created by Import Alert [\#1123](https://github.com/TheHive-Project/TheHive/issues/1123)
- Imported Alerts Cannot be Deleted [\#1201](https://github.com/TheHive-Project/TheHive/issues/1201)
- [Bug] Creating Cases via API ignores the owner field [\#1473](https://github.com/TheHive-Project/TheHive/issues/1473)
- [Bug] Missing cases migrating from TH3 to TH4 [\#1682](https://github.com/TheHive-Project/TheHive/issues/1682)
- [Bug] Attachment files are not deleted from local filesystem storage when logs is deleted [\#1687](https://github.com/TheHive-Project/TheHive/issues/1687)
- [Bug] Impossible to switch organization if organization name contains an accent [\#1741](https://github.com/TheHive-Project/TheHive/issues/1741)
- [Bug] Filtering issue [\#1753](https://github.com/TheHive-Project/TheHive/issues/1753)
- Identical URL Observables can still be added multiple times to the same case [\#1756](https://github.com/TheHive-Project/TheHive/issues/1756)
- [Bug] Integrity checks for user deduplication is not run when an user is added [\#1759](https://github.com/TheHive-Project/TheHive/issues/1759)
- [Bug] Deleting a shared case on org2 doesn't delete task from the Org1 resulting in log spam and undeletable task [\#1767](https://github.com/TheHive-Project/TheHive/issues/1767)
- [Bug] Fix pivoting from donuts to search pages on custom fields based widgets [\#1777](https://github.com/TheHive-Project/TheHive/issues/1777)
- [Bug] Unable to migrate to TH 4.0.5 [\#1785](https://github.com/TheHive-Project/TheHive/issues/1785)
- [Bug] Elapsed time for re-opened cases is showed as "closed". [\#1796](https://github.com/TheHive-Project/TheHive/issues/1796)
- [Bug] Observables list doesn't reload  [\#1802](https://github.com/TheHive-Project/TheHive/issues/1802)
- [Bug] Error in handling users included in many organisations [\#1803](https://github.com/TheHive-Project/TheHive/issues/1803)
- [Bug] Organisation users list doesn't include update date [\#1805](https://github.com/TheHive-Project/TheHive/issues/1805)
- [Bug] Reveal API key not working for users with profile analyst [\#1806](https://github.com/TheHive-Project/TheHive/issues/1806)
- [Bug] Observables not present in some events imported from MISP [\#1819](https://github.com/TheHive-Project/TheHive/issues/1819)
- [Bug] Migration: parameter input is unusable [\#1827](https://github.com/TheHive-Project/TheHive/issues/1827)
- [Bug] Migration of caseTemplate without task fails [\#1828](https://github.com/TheHive-Project/TheHive/issues/1828)
- [Bug] - Use API v1 to fetch observable job history [\#1838](https://github.com/TheHive-Project/TheHive/issues/1838)
- [Bug] File observables with special character in name can not be downloaded [\#1842](https://github.com/TheHive-Project/TheHive/issues/1842)
- [Bug] Shared dashboards are not editable [\#1849](https://github.com/TheHive-Project/TheHive/issues/1849)
- [Bug] Disable the Audit search section [\#1851](https://github.com/TheHive-Project/TheHive/issues/1851)

## [4.0.5](https://github.com/TheHive-Project/TheHive/milestone/68) (2021-02-08)

**Implemented enhancements:**

- Support for using asterisks by tag-filtering [\#933](https://github.com/TheHive-Project/TheHive/issues/933)
- "Close tasks and case" deletes tasks instead of closing them [\#1755](https://github.com/TheHive-Project/TheHive/issues/1755)
- [Enhancement] Add schema update status in status API [\#1782](https://github.com/TheHive-Project/TheHive/issues/1782)

**Closed issues:**

- Running TheHive 4.0.1-1 it appears that application.log is no longer rotated. [\#1746](https://github.com/TheHive-Project/TheHive/issues/1746)

**Fixed bugs:**

- [Bug] RPM package does not create secret.conf file [\#1248](https://github.com/TheHive-Project/TheHive/issues/1248)
- [Bug] More webhooks or more detailed webhook events [\#1739](https://github.com/TheHive-Project/TheHive/issues/1739)
- [Bug] Webhooks opening infinite amount of files [\#1743](https://github.com/TheHive-Project/TheHive/issues/1743)
- [Bug] Dashboards are always created as private [\#1754](https://github.com/TheHive-Project/TheHive/issues/1754)
- [Bug]/Unable to get MISP organisation [\#1758](https://github.com/TheHive-Project/TheHive/issues/1758)
- [Bug] TheHive 4 Cluster and Haproxy with roundrobin [\#1760](https://github.com/TheHive-Project/TheHive/issues/1760)
- [Bug] TheHive -> MISP works. MISP -> TheHive not. [\#1761](https://github.com/TheHive-Project/TheHive/issues/1761)
- [Bug] TheHive 4.0.4 cannot show tasks created in previous versions [\#1763](https://github.com/TheHive-Project/TheHive/issues/1763)
- [Bug] `Imported` property in Alerts not taken into account  [\#1769](https://github.com/TheHive-Project/TheHive/issues/1769)
- [Bug] Sort field list in dashboard widget filters [\#1771](https://github.com/TheHive-Project/TheHive/issues/1771)
- [Bug] Dashboard on organisation (and other) doesn't work [\#1772](https://github.com/TheHive-Project/TheHive/issues/1772)
- [BUG] Cannot link multiple organisations together [\#1773](https://github.com/TheHive-Project/TheHive/issues/1773)
- [Bug] Fix custom field filters in v0 APIs [\#1779](https://github.com/TheHive-Project/TheHive/issues/1779)

## [4.0.4](https://github.com/TheHive-Project/TheHive/milestone/67) (2021-01-12)

**Implemented enhancements:**

- [Feature Request] Add alert observable API endpoints [\#1732](https://github.com/TheHive-Project/TheHive/issues/1732)
- [Feature Request] Add alert import date property [\#1733](https://github.com/TheHive-Project/TheHive/issues/1733)
- [Feature Request] Add handling duration properties to imported Alert type [\#1734](https://github.com/TheHive-Project/TheHive/issues/1734)

**Fixed bugs:**

- [Bug] TheHive doesn't start if cassandra is not ready [\#1725](https://github.com/TheHive-Project/TheHive/issues/1725)
- [Bug] Alert imported multiple times (bis) [\#1738](https://github.com/TheHive-Project/TheHive/issues/1738)
- [Bug] Cosmetic fix in alert observables list [\#1744](https://github.com/TheHive-Project/TheHive/issues/1744)

## [4.0.3](https://github.com/TheHive-Project/TheHive/milestone/66) (2020-12-22)

**Implemented enhancements:**

- Providing output details for Responders [\#1293](https://github.com/TheHive-Project/TheHive/issues/1293)
- [Enhancement] Change artifacts by observables on the onMouseOver tooltip of the eye icon of observable [\#1695](https://github.com/TheHive-Project/TheHive/issues/1695)
- [Enhancement] Enhance support of S3 for attachment storage [\#1705](https://github.com/TheHive-Project/TheHive/issues/1705)
- [Enhancement] Update the headers of basic info sections [\#1710](https://github.com/TheHive-Project/TheHive/issues/1710)
- [Enhancement] Add poll duration config for UI Stream [\#1720](https://github.com/TheHive-Project/TheHive/issues/1720)

**Fixed bugs:**

- [Bug] MISP filters are not correctly implemented [\#1685](https://github.com/TheHive-Project/TheHive/issues/1685)
- [Bug] The query "getObservable" doesn't work for alert observables [\#1691](https://github.com/TheHive-Project/TheHive/issues/1691)
- [Bug] Click analyzers mini-report does not load the full report [\#1694](https://github.com/TheHive-Project/TheHive/issues/1694)
- [Bug] Import file observable in gui generate error [\#1697](https://github.com/TheHive-Project/TheHive/issues/1697)
- [Bug] Cannot search for alerts per observables [\#1707](https://github.com/TheHive-Project/TheHive/issues/1707)
- [Bug] Serialization problem in cluster mode [\#1708](https://github.com/TheHive-Project/TheHive/issues/1708)
- [Bug] Issue with sorting [\#1716](https://github.com/TheHive-Project/TheHive/issues/1716)
- [Bug] Identical URL Observables can be added multiple times to the same case [\#1718](https://github.com/TheHive-Project/TheHive/issues/1718)

## [4.0.2](https://github.com/TheHive-Project/TheHive/milestone/64) (2020-11-20)

**Implemented enhancements:**

- [Feature Request] Add a dedicated permission to give access to TheHiveFS [\#1655](https://github.com/TheHive-Project/TheHive/issues/1655)
- [Feature Request] Normalize editable input fields [\#1669](https://github.com/TheHive-Project/TheHive/issues/1669)

**Fixed bugs:**

- [Bug] Unable to list Cases [\#1598](https://github.com/TheHive-Project/TheHive/issues/1598)
- [Bug] Alert to case merge is broken in v4.0.1 [\#1648](https://github.com/TheHive-Project/TheHive/issues/1648)
- [Bug] Attachment.* filters are broken under observable search in v4.0.1  [\#1649](https://github.com/TheHive-Project/TheHive/issues/1649)
- [Bug] Result of observable update API v0 is empty [\#1652](https://github.com/TheHive-Project/TheHive/issues/1652)
- [Bug] Display issue of custom fields [\#1653](https://github.com/TheHive-Project/TheHive/issues/1653)
- [Bug] Persistent AuditSrv:undefined error on 4.0.1 [\#1656](https://github.com/TheHive-Project/TheHive/issues/1656)
- [Bug] Issues with case attachments section [\#1657](https://github.com/TheHive-Project/TheHive/issues/1657)
- [Bug] API method broken: /api/case/artifact/_search in 4.0.1 [\#1659](https://github.com/TheHive-Project/TheHive/issues/1659)
- [Bug] API method broken: /api/case/task/log/_search in 4.0.1 [\#1660](https://github.com/TheHive-Project/TheHive/issues/1660)
- [Bug] Unable to define ES index on migration [\#1661](https://github.com/TheHive-Project/TheHive/issues/1661)
- [Bug] Dashboard max aggregation on custom-integer field does not work [\#1662](https://github.com/TheHive-Project/TheHive/issues/1662)
- [Bug] Missing the fix for errorMessage [\#1666](https://github.com/TheHive-Project/TheHive/issues/1666)
- [Bug] Fix alert details dialog [\#1672](https://github.com/TheHive-Project/TheHive/issues/1672)
- [Bug] error 500 with adding an empty file in Observables of an Alert [\#1673](https://github.com/TheHive-Project/TheHive/issues/1673)
- [Bug] Fix migration of audit logs [\#1676](https://github.com/TheHive-Project/TheHive/issues/1676)

## [4.0.1](https://github.com/TheHive-Project/TheHive/milestone/60) (2020-11-13)

**Implemented enhancements:**

- [Enhancement] Remove gremlin-scala library  [\#1501](https://github.com/TheHive-Project/TheHive/issues/1501)
- [Feature request] Improve case similarity details in alert preview pane [\#1579](https://github.com/TheHive-Project/TheHive/issues/1579)
- [Enhancement] Check tag autocompletion [\#1611](https://github.com/TheHive-Project/TheHive/issues/1611)
- [Feature] Add Cortex related notifiers in notification system [\#1619](https://github.com/TheHive-Project/TheHive/issues/1619)
- [Feature] Add properties related to share [\#1621](https://github.com/TheHive-Project/TheHive/issues/1621)
- [Feature Request] Update user settings view to give access to API key  [\#1623](https://github.com/TheHive-Project/TheHive/issues/1623)
- [Feature Request] Permit to disable similarity (case and alert) for some observable [\#1625](https://github.com/TheHive-Project/TheHive/issues/1625)
- [Enhancement] Add link to report template archive [\#1627](https://github.com/TheHive-Project/TheHive/issues/1627)
- [Enahancement] Display TheHive version in the login page [\#1629](https://github.com/TheHive-Project/TheHive/issues/1629)
- [Feature Request] Display custom fields in alert and case list [\#1637](https://github.com/TheHive-Project/TheHive/issues/1637)
- [Feature Request] Revamp the statistics section in lists [\#1641](https://github.com/TheHive-Project/TheHive/issues/1641)
- [Enhancement] Improve the filter observables panel [\#1642](https://github.com/TheHive-Project/TheHive/issues/1642)
- [Enhancement] Refine the migration of users with admin role [\#1645](https://github.com/TheHive-Project/TheHive/issues/1645)

**Closed issues:**

- [Bug] default MISP connector import line has a typo [\#1595](https://github.com/TheHive-Project/TheHive/issues/1595)

**Fixed bugs:**

- [Bug] MISP->THEHIVE4 'ExportOnly' and 'Exceptions' ignored in application.conf file [\#1482](https://github.com/TheHive-Project/TheHive/issues/1482)
- [Bug] Mobile-responsive Hamburger not visible [\#1290](https://github.com/TheHive-Project/TheHive/issues/1290)
- [Bug] Unable to start TheHive after migration [\#1450](https://github.com/TheHive-Project/TheHive/issues/1450)
- [Bug] Expired session should show a dialog or login page on pageload [\#1456](https://github.com/TheHive-Project/TheHive/issues/1456)
- [Bug] TheHive 4 - Application.conf file  [\#1461](https://github.com/TheHive-Project/TheHive/issues/1461)
- [Bug] Improve migration [\#1469](https://github.com/TheHive-Project/TheHive/issues/1469)
- [Bug] Merge Alert in similar Case button does not work [\#1470](https://github.com/TheHive-Project/TheHive/issues/1470)
- [Bug] Missing Case number in Alert Preview / Similar Cases tab [\#1471](https://github.com/TheHive-Project/TheHive/issues/1471)
- [Bug] Dashboard shared/private [\#1474](https://github.com/TheHive-Project/TheHive/issues/1474)
- [Bug]Migration tool date/number/duration params don't work [\#1478](https://github.com/TheHive-Project/TheHive/issues/1478)
- [Bug] AuditSrv: undefined on non-case page(s), thehive4-4.0.0-1, Ubuntu [\#1479](https://github.com/TheHive-Project/TheHive/issues/1479)
- [Bug] Unable to enumerate tasks via API [\#1483](https://github.com/TheHive-Project/TheHive/issues/1483)
- [Bug] Case close notification displays "#undefined" instead of case number [\#1488](https://github.com/TheHive-Project/TheHive/issues/1488)
- [Bug] Task under "Waiting tasks" and "My tasks" do not display the case number [\#1489](https://github.com/TheHive-Project/TheHive/issues/1489)
- [Bug] Live Stream log in main page is not limited to 10 entries [\#1490](https://github.com/TheHive-Project/TheHive/issues/1490)
- [Bug] Several API Endpoints could never get called due to the routing structure [\#1492](https://github.com/TheHive-Project/TheHive/issues/1492)
- [Bug] Missing link to linked cases from observable details view [\#1494](https://github.com/TheHive-Project/TheHive/issues/1494)
- [Bug] TheHive V4 API Errors "Operation Not Permitted" and "Date format" [\#1496](https://github.com/TheHive-Project/TheHive/issues/1496)
- [Bug] V4 Merge observable tags with existing observables during importing alerts into case [\#1499](https://github.com/TheHive-Project/TheHive/issues/1499)
- [Bug] Multiline dashboard doesn't work [\#1503](https://github.com/TheHive-Project/TheHive/issues/1503)
- [Bug] Tags of observables in Alerts are not created when promoted [\#1510](https://github.com/TheHive-Project/TheHive/issues/1510)
- [Bug] Alert creation fails if alert contains similar observables [\#1514](https://github.com/TheHive-Project/TheHive/issues/1514)
- [Bug] "Undefined" in notification message when a case is closed [\#1515](https://github.com/TheHive-Project/TheHive/issues/1515)
- [Bug] The creation of multiline observable is not possible [\#1517](https://github.com/TheHive-Project/TheHive/issues/1517)
- [Bug] Entrypoint: Waiting for cassandra with --no-config [\#1519](https://github.com/TheHive-Project/TheHive/issues/1519)
- [Bug] Suppress Reduntant AuthenticationFailed Error+Warn [\#1523](https://github.com/TheHive-Project/TheHive/issues/1523)
- [Bug] API v0: "startDate" sort criteria not implemented [\#1540](https://github.com/TheHive-Project/TheHive/issues/1540)
- [Bug] Fix case search in case merge dialog [\#1541](https://github.com/TheHive-Project/TheHive/issues/1541)
- [Bug] Soft-Deleted cases show up as "(Closed at  as  )" in the case list. [\#1543](https://github.com/TheHive-Project/TheHive/issues/1543)
- [Bug] Related cases show only one observable [\#1544](https://github.com/TheHive-Project/TheHive/issues/1544)
- [Bug] An user can create a task even if it doesn't the permission [\#1545](https://github.com/TheHive-Project/TheHive/issues/1545)
- [Bug] Wrong stats url on user and audit [\#1546](https://github.com/TheHive-Project/TheHive/issues/1546)
- [Bug] Add DATETIME information to each task log [\#1547](https://github.com/TheHive-Project/TheHive/issues/1547)
- [Bug] Custom configuration is not correctly read in docker image [\#1548](https://github.com/TheHive-Project/TheHive/issues/1548)
- [Bug] Typo in MFA onboarding [\#1549](https://github.com/TheHive-Project/TheHive/issues/1549)
- [Bug] New custom fields doesn't appear in search criteria [\#1550](https://github.com/TheHive-Project/TheHive/issues/1550)
- [Bug] Custom Field Order ignored [\#1552](https://github.com/TheHive-Project/TheHive/issues/1552)
- [Bug] Additional Fields are discarded during merge [\#1553](https://github.com/TheHive-Project/TheHive/issues/1553)
- [Bug] Unable to list alerts in case's related alerts section [\#1554](https://github.com/TheHive-Project/TheHive/issues/1554)
- [Bug] Deleting the first case breaks the the audit flow until the next restart [\#1556](https://github.com/TheHive-Project/TheHive/issues/1556)
- [Bug] Issues surrounding Alerts merging [\#1557](https://github.com/TheHive-Project/TheHive/issues/1557)
- [Bug] Uncaught exception with duplicate mail type observables when added to case [\#1561](https://github.com/TheHive-Project/TheHive/issues/1561)
- [Bug] Case Tasks get deleted if not started [\#1565](https://github.com/TheHive-Project/TheHive/issues/1565)
- [Bug] Can't export Case tags to MISP event [\#1566](https://github.com/TheHive-Project/TheHive/issues/1566)
- [Bug]The link to similar observable in observable details page doesn't work [\#1567](https://github.com/TheHive-Project/TheHive/issues/1567)
- [Bug] TheHive4 'follow/unfollow' API doesn't return alert objects like TheHive3 does [\#1571](https://github.com/TheHive-Project/TheHive/issues/1571)
- [Bug] Alert Custom Field with integer value [\#1588](https://github.com/TheHive-Project/TheHive/issues/1588)
- [Bug] Tag filter is broken [\#1590](https://github.com/TheHive-Project/TheHive/issues/1590)
- [Bug] Admin user does not have the right to list users of other organisations [\#1592](https://github.com/TheHive-Project/TheHive/issues/1592)
- [Bug] Add missing query operations [\#1599](https://github.com/TheHive-Project/TheHive/issues/1599)
- [Bug] Fix configuration sample [\#1600](https://github.com/TheHive-Project/TheHive/issues/1600)
- [Bug] Analyzer tags are removes if Cortex job fails [\#1610](https://github.com/TheHive-Project/TheHive/issues/1610)
- [Bug] deleted Tasks displayed in MyTasks [\#1612](https://github.com/TheHive-Project/TheHive/issues/1612)
- [Bug] the "_in" query operator doesn't work [\#1617](https://github.com/TheHive-Project/TheHive/issues/1617)
- [Bug] Sort filter field dropdowns [\#1630](https://github.com/TheHive-Project/TheHive/issues/1630)
- [Bug] Alert imported multiple times [\#1631](https://github.com/TheHive-Project/TheHive/issues/1631)
- [Bug] Import observables from analyzer report is broken [\#1633](https://github.com/TheHive-Project/TheHive/issues/1633)
- [Bug] Import observable from a zip archive doesn't work [\#1634](https://github.com/TheHive-Project/TheHive/issues/1634)
- [Bug] Case handling duration attributes are not working in time based dashboard widgets [\#1635](https://github.com/TheHive-Project/TheHive/issues/1635)
- [Bug] Fix custom field in filter forms [\#1636](https://github.com/TheHive-Project/TheHive/issues/1636)
- [Bug] It is possible to add an identical file observable several times in a case [\#1643](https://github.com/TheHive-Project/TheHive/issues/1643)
- [Bug] Hash observables are not correctly export to MISP [\#1644](https://github.com/TheHive-Project/TheHive/issues/1644)

## [4.0.0](https://github.com/TheHive-Project/TheHive/milestone/59) (2020-07-24)

**Implemented enhancements:**

- No longer possible to force usage of a case template (ui setting is missing) [\#1239](https://github.com/TheHive-Project/TheHive/issues/1239)
- Make user management list paginable and sortable with default sort of username [\#1332](https://github.com/TheHive-Project/TheHive/issues/1332)
- Cursor is set wrong on new-Case -> severity [\#1373](https://github.com/TheHive-Project/TheHive/issues/1373)
- [Enhancement] Prevent link with "admin" organisation [\#1395](https://github.com/TheHive-Project/TheHive/issues/1395)
- [Enhancement] An user should not be able to lock himself [\#1396](https://github.com/TheHive-Project/TheHive/issues/1396)
- Performance - Don't load stats if not displayed [\#1401](https://github.com/TheHive-Project/TheHive/issues/1401)
- [RBAC] Add routes guard configuration to secure routes [\#1403](https://github.com/TheHive-Project/TheHive/issues/1403)
- [Enhancement] Add checks for database integrity [\#1404](https://github.com/TheHive-Project/TheHive/issues/1404)
- Use Query APIs in list pages [\#1410](https://github.com/TheHive-Project/TheHive/issues/1410)
- Improve autocomplete queries for tags [\#1411](https://github.com/TheHive-Project/TheHive/issues/1411)
- [Enhancement] Add ability to add tasks in case creation API [\#1414](https://github.com/TheHive-Project/TheHive/issues/1414)
- Improve user details caching [\#1418](https://github.com/TheHive-Project/TheHive/issues/1418)
- Add bulk edit in cases list [\#1423](https://github.com/TheHive-Project/TheHive/issues/1423)
- Use a responder selector window instead of dynamic dropdown menues [\#1431](https://github.com/TheHive-Project/TheHive/issues/1431)
- Show sharing summary in task and observable lists [\#1437](https://github.com/TheHive-Project/TheHive/issues/1437)
- Add some quick filters in tasks list [\#1438](https://github.com/TheHive-Project/TheHive/issues/1438)
- Use assignable users API to populate assignee options [\#1444](https://github.com/TheHive-Project/TheHive/issues/1444)
- Migrate the stats widgets on listing pages [\#1446](https://github.com/TheHive-Project/TheHive/issues/1446)

**Closed issues:**

- Default Dashboards are missing [\#1240](https://github.com/TheHive-Project/TheHive/issues/1240)

**Fixed bugs:**

- [Bug] Migration issues from ES to Cassandra [\#1340](https://github.com/TheHive-Project/TheHive/issues/1340)
- [Bug] Deleting and observable doesn't refresh the list [\#1355](https://github.com/TheHive-Project/TheHive/issues/1355)
- [Bug] Limiting admin rights breaks front end [\#1368](https://github.com/TheHive-Project/TheHive/issues/1368)
- [Bug] Imported Dashboards from TH3 doesn't work [\#1371](https://github.com/TheHive-Project/TheHive/issues/1371)
- [Bug] Top 5 tags in Case -> Stats aren't correctly ordered [\#1372](https://github.com/TheHive-Project/TheHive/issues/1372)
- [Bug] Migration of usernames from ES to Cassandra [\#1374](https://github.com/TheHive-Project/TheHive/issues/1374)
- [Bug] Switching User Organisation failes using header variable authentication [\#1375](https://github.com/TheHive-Project/TheHive/issues/1375)
- [Bug] Tags gets wrong renamed [\#1376](https://github.com/TheHive-Project/TheHive/issues/1376)
- [Bug] MISP integration alert link generated incorrectly [\#1378](https://github.com/TheHive-Project/TheHive/issues/1378)
- [Bug] CustomFields does not appear sorted in the case template [\#1383](https://github.com/TheHive-Project/TheHive/issues/1383)
- [Bug] Users in Admin-Org are not allowed to switch to any other org [\#1385](https://github.com/TheHive-Project/TheHive/issues/1385)
- [Bug] Custom Observable Types can be created multiple-times with the same name [\#1387](https://github.com/TheHive-Project/TheHive/issues/1387)
- [Bug] Issues during Migration - Some Observables are missing [\#1388](https://github.com/TheHive-Project/TheHive/issues/1388)
- [Bug] Proxy configuration is not correctly parsed [\#1392](https://github.com/TheHive-Project/TheHive/issues/1392)
- [Bug] Handle 401 on route failure [\#1402](https://github.com/TheHive-Project/TheHive/issues/1402)
- [Bug] Delete case api fails [\#1405](https://github.com/TheHive-Project/TheHive/issues/1405)
- Fix the filter preview deletion button [\#1412](https://github.com/TheHive-Project/TheHive/issues/1412)
- Fix OAuth redirect handling from Javascript [\#1420](https://github.com/TheHive-Project/TheHive/issues/1420)
- [Bug] Error when exporting a case with severity Critical in MISP [\#1424](https://github.com/TheHive-Project/TheHive/issues/1424)
- [Bug] Cases owned by non-linked organisations visible to all organisations, potential data leakage [\#1427](https://github.com/TheHive-Project/TheHive/issues/1427)
- [Bug] TheHive doesn't start correctly [\#1429](https://github.com/TheHive-Project/TheHive/issues/1429)
- [Bug] Permission is not correctly checked for MISP export [\#1432](https://github.com/TheHive-Project/TheHive/issues/1432)
- Observable type deletion doesn't wait for the confirmation [\#1433](https://github.com/TheHive-Project/TheHive/issues/1433)
- Fix rendering of jobs in search section [\#1434](https://github.com/TheHive-Project/TheHive/issues/1434)
- Remove obsolete options in Search page [\#1436](https://github.com/TheHive-Project/TheHive/issues/1436)
- [Bug] Click on dashboards to access filtered data [\#1445](https://github.com/TheHive-Project/TheHive/issues/1445)
- [Bug] Pivoting from dashboard to search page is loosing the date filter [\#1448](https://github.com/TheHive-Project/TheHive/issues/1448)
- [Bug] Series' filters in dashboard widgets are taken into account [\#1449](https://github.com/TheHive-Project/TheHive/issues/1449)

## [4.0.0-RC3](https://github.com/TheHive-Project/TheHive/milestone/58) (2020-05-27)

**Implemented enhancements:**

- [Feature] Show case sharing information on main case overview page [\#1277](https://github.com/TheHive-Project/TheHive/issues/1277)
- [Feature] Allow users to be part of multiple organisations [\#1316](https://github.com/TheHive-Project/TheHive/issues/1316)
- [Enhancement] Hide multifactor option in user-dialog if Enable Multi-Factor Authentication is disabled. [\#1317](https://github.com/TheHive-Project/TheHive/issues/1317)
- [Feature] Authentication API should return user information [\#1346](https://github.com/TheHive-Project/TheHive/issues/1346)
- [Enhancement] Enrich queries [\#1353](https://github.com/TheHive-Project/TheHive/issues/1353)

**Fixed bugs:**

- [Bug] Unable to add new datatypes [\#1288](https://github.com/TheHive-Project/TheHive/issues/1288)
- [Bug] Unable to bulk delete an alert [\#1310](https://github.com/TheHive-Project/TheHive/issues/1310)
- [Bug] importing alert as template not working [\#1311](https://github.com/TheHive-Project/TheHive/issues/1311)
- [Bug] Tasks not displayed when importing alert into case with case template [\#1312](https://github.com/TheHive-Project/TheHive/issues/1312)
- [Bug] WebHook creation does not work [\#1318](https://github.com/TheHive-Project/TheHive/issues/1318)
- [Bug] Opening Analyzer Templates without Cortex brings error message [\#1319](https://github.com/TheHive-Project/TheHive/issues/1319)
- [Bug] Case Statistics does not correctly display top 5 tags  [\#1320](https://github.com/TheHive-Project/TheHive/issues/1320)
- [Bug] Importing of some user failes [\#1323](https://github.com/TheHive-Project/TheHive/issues/1323)
- [Bug] invisible dashborards [\#1324](https://github.com/TheHive-Project/TheHive/issues/1324)
- [Bug] Assignee List in Case and Tasks is no longer sorted Alphabetical [\#1327](https://github.com/TheHive-Project/TheHive/issues/1327)
- [Bug] Sorting in Observables of a case does not work [\#1328](https://github.com/TheHive-Project/TheHive/issues/1328)
- [Bug] Read-only has options to edit task-logs [\#1334](https://github.com/TheHive-Project/TheHive/issues/1334)
- [Bug] Adding a custom-field on an open case requires a reload, otherwise field is not visible [\#1336](https://github.com/TheHive-Project/TheHive/issues/1336)
- [Bug] severity change when create new case don't work [\#1338](https://github.com/TheHive-Project/TheHive/issues/1338)
- [Bug] The filter operator "_child" is missing [\#1344](https://github.com/TheHive-Project/TheHive/issues/1344)
- [Bug] Webhook compatibility issues on custom-fields [\#1345](https://github.com/TheHive-Project/TheHive/issues/1345)
- [Bug] Object sent to responder doesn't contain parent [\#1348](https://github.com/TheHive-Project/TheHive/issues/1348)
- [Bug] Show Sharing link to all users [\#1351](https://github.com/TheHive-Project/TheHive/issues/1351)
- [Bug] Unable to create case or alert using integer custom field [\#1356](https://github.com/TheHive-Project/TheHive/issues/1356)
- [Bug] Get observables of a case using API not working [\#1357](https://github.com/TheHive-Project/TheHive/issues/1357)
- [Bug] OAuth2 authentication doesn't redirect to home page on success [\#1360](https://github.com/TheHive-Project/TheHive/issues/1360)
- [Bug] Confusion on same alert on different organisations [\#1361](https://github.com/TheHive-Project/TheHive/issues/1361)
- [Bug] Search link to observable does not work [\#1365](https://github.com/TheHive-Project/TheHive/issues/1365)
- [Bug] Unable to vienw analysis report from observable list [\#1366](https://github.com/TheHive-Project/TheHive/issues/1366)
- [Bug] MISP export succeeds but show an error message [\#1367](https://github.com/TheHive-Project/TheHive/issues/1367)
- [Bug] rc3 migration script failure [\#1369](https://github.com/TheHive-Project/TheHive/issues/1369)
- [Bug] set HTTP redirect correctly when behind a reverse proxy  [\#1370](https://github.com/TheHive-Project/TheHive/issues/1370)

## [4.0.0-RC2](https://github.com/TheHive-Project/TheHive/milestone/54) (2020-05-07)

**Implemented enhancements:**

- Custom severity levels for alerts and cases [\#363](https://github.com/TheHive-Project/TheHive/issues/363)
- A (received) Shared Case is displayed as sender/owner [\#1245](https://github.com/TheHive-Project/TheHive/issues/1245)
- FR: Alignment of case custom-fields (metrics) [\#1246](https://github.com/TheHive-Project/TheHive/issues/1246)
- Add information about the age of a Case  [\#1257](https://github.com/TheHive-Project/TheHive/issues/1257)
- Add support to multi-factor authentication [\#1303](https://github.com/TheHive-Project/TheHive/issues/1303)
- Add support to webhooks [\#1306](https://github.com/TheHive-Project/TheHive/issues/1306)

**Closed issues:**

- [Bug] Attachment stored in thehive but not in configured file-storage [\#1244](https://github.com/TheHive-Project/TheHive/issues/1244)

**Fixed bugs:**

- [Bug] TH doesn't find cases related to an alert's artifacts [\#1236](https://github.com/TheHive-Project/TheHive/issues/1236)
- [Bug] Creation of multiple user with same login within same org [\#1237](https://github.com/TheHive-Project/TheHive/issues/1237)
- Date is now a required attribute for generating an Alert [\#1238](https://github.com/TheHive-Project/TheHive/issues/1238)
- [Bug] Case Template default values can't be set during template creation [\#1241](https://github.com/TheHive-Project/TheHive/issues/1241)
- SearchSrv.NotFoundError  [\#1242](https://github.com/TheHive-Project/TheHive/issues/1242)
- Assignee is not changeable [\#1243](https://github.com/TheHive-Project/TheHive/issues/1243)
- [Bug] In TheHive, a user is a member of one or more organisations. One user has a profile for each organisation and can have different profiles for different organisations.  [\#1247](https://github.com/TheHive-Project/TheHive/issues/1247)
- [Bug] Unable to save new or imported dashboards in 4.0-RC1 [\#1250](https://github.com/TheHive-Project/TheHive/issues/1250)
- [Bug] Header Variable authentication does not work [\#1251](https://github.com/TheHive-Project/TheHive/issues/1251)
- Filtering by custom fields returns no results [\#1252](https://github.com/TheHive-Project/TheHive/issues/1252)
- Cannot Deleted user - Error "OrgUserCtrl: org.thp.thehive.models.User not found" [\#1253](https://github.com/TheHive-Project/TheHive/issues/1253)
- [Bug] Error while importing Alert in TH4 [\#1255](https://github.com/TheHive-Project/TheHive/issues/1255)
- [Bug] Cortex errors [\#1270](https://github.com/TheHive-Project/TheHive/issues/1270)
- [Bug] error when closing a reopened case [\#1271](https://github.com/TheHive-Project/TheHive/issues/1271)
- [Bug] Unable to rename/update case template Name field [\#1275](https://github.com/TheHive-Project/TheHive/issues/1275)
- [Bug] Wrong dataType sent to Cortex (responders) [\#1279](https://github.com/TheHive-Project/TheHive/issues/1279)
- [Bug] Changing task name removes other tasks [\#1281](https://github.com/TheHive-Project/TheHive/issues/1281)
- [Bug] Disable deleting a share with owner = true [\#1283](https://github.com/TheHive-Project/TheHive/issues/1283)
- [Bug] Responder actions not displayed in Case, Task and Observable pages [\#1300](https://github.com/TheHive-Project/TheHive/issues/1300)
- [Bug] Custom field should be readonly [\#1307](https://github.com/TheHive-Project/TheHive/issues/1307)
- [Bug] Unable to display long analyzer report from observables list [\#1309](https://github.com/TheHive-Project/TheHive/issues/1309)

```

`LICENSE`:

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<http://www.gnu.org/licenses/>.

```

`PGP-PUBLIC-KEY`:

```
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1

mQINBFkRxeYBEAC8N672/5USJztb1R4pn8zB2/fujg71uAh1ZEERbiMFHC0IJbuh
8aF0F+tn1YIbMuI8B1byMOLhSRnnuw630StbnUsVqRbLXg3plLDAg50I1v90pXfO
FiOOG1XApnb8NhS+huGwIXXLk65NE1MPwhPC9jxK1Bx/RJZNKg9UDz5+YPPEydhh
ZJ+35UKb94DuY/YsqMCSYJwlHL3ZnqENcQvylVD9TSdJCJ51xu655kbbZks1Amaz
j7aWJQs8ur9nhEw/au221rUdOrS0XW5m4XCfE7hTqjREjDEGsUHilbsO+RH2f2+h
PWalG/9aN2f1maiAezAuT/agFBWbuyYqBfSvuZOMCuLdXsiQNxdPJPcEQUIcO1Qf
g4RTWJCoXrlL2QQSSstswPrlZxloHsGvl0AtAlard2+rr6Fz1QG3hokOhFav8LS+
0lbwQpR1K3RY2HUrof1r4HCQHqEJ76q0bwk9vhd8cAA9tc5uTh+oBbKXaPyO/8Be
SUiBU94kJd12RR81FIF4bAcqgrTi8JDj+EaXeGH5b6eUiRmEWCSzQpq6nOYMYBQw
4r62v4zYYq0NgM6f8rZ+EeuvCiGxSGAzvtLtKRYZRYHZanasO/pyVy6cpRxiWVRR
5+smEarOU8ul1o8D19si/sjFAs9nQMs20R+O76wHDb32aAKTjiRWkTUAVQARAQAB
tENUaGVIaXZlIFByb2plY3QgKFRoZUhpdmUgcmVsZWFzZSBrZXkpIDxzdXBwb3J0
QHRoZWhpdmUtcHJvamVjdC5vcmc+iQI4BBMBAgAiBQJZEcXmAhsDBgsJCAcDAgYV
CAIJCgsEFgIDAQIeAQIXgAAKCRA9mbsYViy8HHcvD/9yZvUvNGDJ//8frjwuRvWa
3jUxoX6m+KcUSHOf1wc6SyVZ/E0AJKDXMkYBJAjv5FvJOu//XGcMNwiNtR8gtZnd
razokSbUcg8osijPWsNFQ5te7wMqo34M3GP2rpXz+QC6UMd2/UDk6mdWtgqzTIzi
MsXm4A9p5So54Twkl32ZIfCG952rpQdr5lTq4FM5usZhtQzpOtm240ChOozU8SBE
CKH49I4iNBiFUNCHNivmGEA8CpP6ouCJaAmMF6cruyxRsZnwImU1SvjXUJYGdBQ8
u5pEvSQLhCwo12o7dATUmBMLNW05ksewDYVOj52lMg29TAZ+e0dBKCzMyz6+HpIk
6XJ0NZFWwLgzex863KI7S/ytErUKSjUhwHfoWhEkLvpUtuhHRbv5Ryyg7da7bp+B
4Q3MJbAzgOvZMXPlJpu4luIB5eEwRYyYQ3W7f1dSSklkaFuKh1rc0EACREJ7Y2e4
Vt8++zRbp1oFGQ5+0s64HlEBiaujc7F2/BRFR1MKE9Fd6WH2YljkQ0DidY7IWdTK
FxN7YPM9jeF51FP+W0I7PvK415W66UF60CDBtPL0wE7cQuujB856IDwZKPKi5Uro
ivsVewKw/nN4T92Xk87sdnYDBvQ++nQmg5SDTET+IJ6cP9OzDQ3ecmgSSAPw02jT
pl/GX01j04rUUOOpEaXttrkCDQRZEcXmARAAqgHpWyaPlD0mdVLnXMg9cxVQyR8X
VTQ7dmszgsRNtGdr60T6FZ5ORb5EowkBHKe3vfyUtrYmDhyFr0sikitYxIjHAIdn
EFgHWRHBPcc/fwt8omPyVtnNcVTJ/p27t01hwBzGNVvDbI6Lqj1X6MmWY8tphJu6
Ox0GozJZU8J3FCor0BqI/yeR4X3rFRfiZfz2Ejc/6tktfyKlSyPS8tNkPn0CulNa
TpYAhZ3S4coGlaC1MQcRRbGjuMRXZozLxYVDF3AvGXuwAtH53nly+skIG9Exk9UW
jfy6SHlKjq9UW5kSeFE4uRJkJBQeqXg/rO337rquJkUobiizHnepRtnjHxnWpHNs
jiZbEYgbHJBqNhuf1qaTVdup8mTOSVzUynr1aNHrQCmHkVR/P/fWOF09R9p+lRCp
I3yZwXbACvFeScidMtm1T8aFItmcQ+QXtyrRPvOvy8jCO/gkDpKm/NE5f3nT4Tg6
DOKtEQlo657FyG3t7STZ6H7uD2dd2TTWxelCaO9GaR743ybJYb5H02V9Dm3qIYFb
1cafz8Q43kAqcq29/Sgpx8yHv2SmsFilAfuW2ic0Mi6DbRUiF7p1qKLIj+ZsP3Ax
Mo1FwZI4zHlKKwm2Uapyqmd+xF9y7Y2pFgNYfDuj6/nd0VPFZ1T+6+9RjPWT7TPB
1+Eaf/o3/v31YZ8AEQEAAYkCHwQYAQIACQUCWRHF5gIbDAAKCRA9mbsYViy8HBEZ
EACFmsm9jPNFkjw7w6XC1+V4lY9HUQagwwf41XcYWt5gYlJww2oO+PzG9MIfj+25
mrmkKoVbNZhJmjH1ZgME5aIDbw+gSn3tsuBKriuryPS9aKjfDDpN2SmxO3N+m+uR
OxwoFvzzQUeba8ItdED4ATUj5qBDcwdTBZWrPDlC/Pr1ASY4NrG6f5uSUyTNwaR+
l1kKAGZxDm3/8tkI9UAmvSC2i0yxuOyHj9rpuz57aAKAvMu3vNGd7eU4bLPCuZFu
FhZvU6wAd/1+oLIVYUVjF1Nh3RgF+mn2MzH5AvShIpZzOkajY91ebQYAZ55AU2iU
y3C1sjSRa1lWzxbThJBT5Sm1B35vTABaM1m25HcjumKeU2XtfN4EArlxuxZRHSbQ
2ceWDPm5TuvjMyZdb5u90xpJ/VGmFYxqjfR1nwku9mY1JKDvZgI9i3Gm+JgrDI4c
ldFFLTSdSASnOfW1P+flMKUkDOBIIOYJtZgZ9BU9U/lU5/ZssPoCWkfwy022anqu
wR6Z0Ao/cKE+l+XoXFOvtcRvJyfarXs9EON0s/HNyPRpy20KPyv2lCwm11bhGoI3
LGYf9udLuLm2Dex9U4+Hs2KWDT9QeVmS7OQUz0Yg184CkVWGLqaVIReYv9q7qPlI
CykvrXDiG+C5OTn1wvPRUX1wA1f7dRsYXOK3AHxz65zMSw==
=f0Hb
-----END PGP PUBLIC KEY BLOCK-----

```

`README.md`:

```md
<div>
  <p align="center">
    <img src="images/thehive-logo.png"width="600"/>  
  </p>
</div>
<div>
  <p align="center">
    <a href="https://chat.thehive-project.org" target"_blank"><img src="https://img.shields.io/badge/chat-on%20discord-7289da.svg?sanitize=true" alt="Discord"></a>
    <a href><img src="https://drone.strangebee.com/api/badges/TheHive-Project/TheHive/status.svg?ref=refs/heads/master-th4" alt="Build status"></a>
    <a href="./LICENSE" target"_blank"><img src="https://img.shields.io/github/license/TheHive-Project/TheHive" alt="License"></a>        
  </p>
</div>

[TheHive](https://thehive-project.org/) is a scalable 3-in-1 open source and free Security Incident Response Platform designed to make life easier for SOCs, CSIRTs, CERTs and any information security practitioner dealing with security incidents that need to be investigated and acted upon swiftly. It is the perfect companion to [MISP](http://www.misp-project.org/). You can synchronize it with one or multiple MISP instances to start investigations out of MISP events. You can also export an investigation's results as a MISP event to help your peers detect and react to attacks you've dealt with. Additionally, when TheHive is used in conjunction with [Cortex](https://github.com/TheHive-Project/Cortex/), security analysts and researchers can easily analyze tens if not hundred of observables.  

![Current Cases View](images/Current_cases.png)

## Collaborate
Collaboration is at the heart of TheHive.

Multiple analysts from one organisations can work together on the same case simultaneously. For example, an analyst may deal with malware analysis while another may work on tracking C2 beaconing activity on proxy logs as soon as IOCs have been added by their coworker. Using TheHive's live stream, everyone can keep an eye on what's happening on the platform, in real time.

Multi-tenancy and fine grained user profiles let organisations and analysts work and collaborate on a same case accross organisations. For example, one case can be created by a first organisation who start investigating and ask for contribution from other teams or escalate to another organisation.

## Elaborate
Within TheHive, every investigation corresponds to a case. Cases can be created from scratch or from [MISP](http://www.misp-project.org/) events, SIEM alerts, email reports and any other noteworthy source of security events.

Each case can be broken down into one or more tasks. Instead of adding the same tasks to a given type of case every time one is created, analysts can use TheHive's template engine to create them once and for all. Case templates can also be used to associate metrics to specific case types in order to drive the team's activity, identify the type of investigations that take significant time and seek to automate tedious tasks.

Each task can be assigned to a given analyst. Team members can also take charge of a task without waiting for someone to assign it to them.

Tasks may contain multiple work logs that contributing analysts can use to describe what they are up to, what was the outcome, attach pieces of evidence or noteworthy files and so on. Logs can be written using a rich text editor or Markdown.

## Analyze
You can add one or hundreds if not thousands of observables to each case you create. You can also create a case out of a [MISP](http://www.misp-project.org/) event. TheHive can be very easily linked to one or several MISP instances and MISP events can be previewed to decide whether they warrant an investigation or not. If an investigation is in order, the analyst can then add the event to an existing case or import it as a new case using a customizable template.

Thanks to [TheHive4py](https://thehive-project.org/#section_thehive4py), TheHive's Python API client, it is possible to send SIEM alerts, phishing and other suspicious emails and other security events to TheHive. They will appear in its `Alerts` panel along with new or updated MISP events, where they can be previewed, imported into cases or ignored.

![The Alerts Pane](images/Alerts_Panel.png)

TheHive has the ability to automatically identify observables that have been already seen in previous cases. Observables can also be associated with a TLP and the source which provided or generated them using tags. The analyst can also easily mark observables as IOCs and isolate those using a search query then export them for searching in a SIEM or other data stores.

Analysts can analyze tens or hundreds of observables in a few clicks by leveraging the analyzers of one or several [Cortex](https://github.com/TheHive-Project/Cortex/) instances depending on your OPSEC needs: DomainTools, VirusTotal, PassiveTotal, Joe Sandbox, geolocation, threat feed lookups and so on.

Security analysts with a knack for scripting can easily add their own analyzers to Cortex in order to automate actions that must be performed on observables or IOCs. They can also decide how analyzers behave according to the TLP. For example, a file added as observable can be submitted to VirusTotal if the associated TLP is WHITE or GREEN. If it's AMBER, its hash is computed and submitted to VT but not the file. If it's RED, no VT lookup is done.

# Try it
To try TheHive, you can use the [training VM](https://www.strangebee.com/tryit) or install it by reading the [Installation Guide](https://docs.thehive-project.org/thehive/installation-and-configuration/installation/step-by-step-guide/).

# Details

## Documentation
We have made several guides available in the [Documentation repository](https://docs.thehive-project.org/thehive/).



## Main features

### Multi-tenancy
TheHive comes with a special multi-tenancy support. It allows the following strategies:

- Use a siloed multi-tenancy: many organisations can be defined without allowing them to share data;
- Use a collaborative multi-tenancy: a set of organisations can be allowed to collaborate on specific cases/tasks/observables, using custom defined user profiles (RBAC).


### RBAC
TheHive comes with a set of permissions and several pre-configured user profiles: 

- `admin`: full administrative permissions on the platform ; can't manage any Cases or other data related to investigations;
- `org-admin`: manage users and all organisation-level configuration, can create and edit Cases, Tasks, Observables and run Analyzers and Responders;
- `analyst`: can create and edit _Cases_, _Tasks_, _Observables_ and run _Analyzers_ & _Responders_;
- `read-only`: Can only read, Cases, Tasks and Observables details;

New profiles can be created by administrators of the platform. 

### Authentication
TheHive 4 supports authentication methods:

- local accounts
- Active Directory
- LDAP
- Basic Auth
- API keys
- OAUTH2
- Multi Factor Authentication

### Statistics & Dashboards
TheHive comes with a powerful statistics module that allows you to create meaningful dashboards to drive your activity and support your budget requests.

## Integrations 

### MISP and Cortex
TheHive can be configured to import events from one or multiple [MISP](http://www.misp-project.org/) instances. You can also use TheHive to export cases as MISP events to one or several MISP servers. 

[Cortex](https://github.com/TheHive-Project/Cortex/) is the perfect companion for TheHive. Use one or several to analyze observables at scale.

### Integration with Digital Shadows
TheHive Project provides [DigitalShadows2TH](https://github.com/TheHive-Project/DigitalShadows2TH), a free, open source [Digital Shadows](https://www.digitalshadows.com/) alert feeder for TheHive. You can use it to import Digital Shadows *incidents* and *intel-incidents* as alerts in TheHive, where they can be previewed and transformed into new cases using pre-defined incident response templates or added into existing ones.

### Integration with Zerofox
[Zerofox2TH](https://github.com/TheHive-Project/Zerofox2TH) is a free, open source [ZeroFOX](https://www.zerofox.com/) alert feeder for TheHive, written by TheHive Project. You can use it to feed ZeroFOX alerts into TheHive, where they can be previewed and transformed into new cases using pre-defined incident response templates or added into existing ones.

### And many more

Lots of **awesome** integrations shared by the community could be listed there. If you're looking for a specific one, **a  dedicated repository** containing all known details and references about existing integrations is updated frequently, and can be found here: [https://github.com/TheHive-Project/awesome](https://github.com/TheHive-Project/awesome).

# License
TheHive is an open source and free software released under the [AGPL](https://github.com/TheHive-Project/TheHive/blob/master/LICENSE) (Affero General Public License). We, TheHive Project, are committed to ensure that TheHive will remain a free and open source project on the long-run.

# Updates
Information, news and updates are regularly posted on [TheHive Project Twitter account](https://twitter.com/thehive_project) and on [the blog](https://blog.thehive-project.org/).

# Contributing
Please see our [Code of conduct](code_of_conduct.md). We welcome your contributions. Please feel free to fork the code, play with it, make some patches and send us pull requests via [issues](https://github.com/TheHive-Project/TheHive/issues).

# Support
Please [open an issue on GitHub](https://github.com/TheHive-Project/TheHive/issues) if you'd like to report a bug or request a feature. We are also available on [Discord](https://chat.thehive-project.org) to help you out.

If you need to contact the project team, send an email to <support@thehive-project.org>.

**Important Note**:

- If you have problems with [TheHive4py](https://github.com/TheHive-Project/TheHive4py), please [open an issue on its dedicated repository](https://github.com/TheHive-Project/TheHive4py/issues/new).
- If you encounter an issue with Cortex or would like to request a Cortex-related feature, please [open an issue on its dedicated GitHub repository](https://github.com/TheHive-Project/Cortex/issues/new).
- If you have troubles with a Cortex analyzer or would like to request a new one or an improvement to an existing analyzer, please open an issue on the [analyzers' dedicated GitHub repository](https://github.com/TheHive-Project/cortex-analyzers/issues/new).

# Community Discussions
We have set up a Google forum at <https://groups.google.com/a/thehive-project.org/d/forum/users>. To request access, you need a Google account. You may create one [using a Gmail address](https://accounts.google.com/SignUp?hl=en) or [without it](https://accounts.google.com/SignUpWithoutGmail?hl=en).

# Website
<https://thehive-project.org/>

```

`SECURITY.md`:

```md
# StrangeBee Security Policies 

At [StrangeBee](https://www.strangebee.com) we take the security our software and services seriously, including following applications and projects: 
- TheHive (TheHive 5, and [previous open source version](https://github.com/TheHive-Project/TheHive))
- [Cortex](https://github.com/TheHive-Project/Cortex)
- [Cortex-Analyzers](https://github.com/TheHive-Project/Cortex-Analyzers)

## Reporting a vulnerability
If you believe you have found a security vulnerability in our applications and services (TheHive, Cortex, Cortex-Analyzers ...), report it to us.

**Please do not report security vulnerabilities through public GitHub issues, discussions, or pull requests.**

Instead, please send security vulnerabilities by emailing the StrangeBee Security team: 

```
security[@]strangebee.com
``` 

In this email, please include as much information as possible that can help us better understand and resolve the issue:
- Application and version
- Special configuration and usage required to reproduce the issue
- Step-by-step instructions to reproduce the issue
- Exploit code is any
- Impact of the issue

This will be very useful and help us triage your report more quickly.

More information regarding our Security policies and Advisories can be found here: [https://github.com/StrangeBeeCorp/security]().

```

`app/org/thp/thehive/CustomServer.scala`:

```scala
package org.thp.thehive

import akka.http.scaladsl.model.HttpMethod
import akka.http.scaladsl.settings.ParserSettings
import play.core.server.{AkkaHttpServer, ServerProvider}

/** A custom Akka HTTP server with advanced configuration. */
class CustomAkkaHttpServer(context: AkkaHttpServer.Context) extends AkkaHttpServer(context) {
  override protected def createParserSettings(): ParserSettings =
    super.createParserSettings().withCustomMethods(HttpMethod.custom("PROPFIND"))
}

/** A factory that instantiates a CustomAkkaHttpServer. */
class CustomAkkaHttpServerProvider extends ServerProvider {

  def createServer(context: ServerProvider.Context): CustomAkkaHttpServer = {
    val serverContext = AkkaHttpServer.Context.fromServerProviderContext(context)
    new CustomAkkaHttpServer(serverContext)
  }
}

```

`build.sbt`:

```sbt
import Dependencies._
import com.typesafe.sbt.packager.Keys.bashScriptDefines
import org.thp.ghcl.Milestone

val thehiveVersion         = "4.1.24-1"
val scala212               = "2.12.13"
val scala213               = "2.13.1"
val supportedScalaVersions = List(scala212, scala213)

organization in ThisBuild := "org.thp"
scalaVersion in ThisBuild := scala212
crossScalaVersions in ThisBuild := supportedScalaVersions
resolvers in ThisBuild ++= Seq(
  Resolver.mavenLocal,
  "Oracle Released Java Packages" at "https://download.oracle.com/maven",
  "TheHive project repository" at "https://dl.bintray.com/thehive-project/maven/"
)
scalacOptions in ThisBuild ++= Seq(
  "-encoding",
  "UTF-8",
  "-deprecation",         // Emit warning and location for usages of deprecated APIs.
  "-feature",             // Emit warning and location for usages of features that should be imported explicitly.
  "-unchecked",           // Enable additional warnings where generated code depends on assumptions.
  "-Xlint",               // Enable recommended additional warnings.
  "-Ywarn-numeric-widen", // Warn when numerics are widened.
  "-Ywarn-value-discard", // Warn when non-Unit expression results are unused
  //"-Xfatal-warnings",   // Fail the compilation if there are any warnings.
  //"-Ywarn-adapted-args",// Warn if an argument list is modified to match the receiver.
  //"-Ywarn-dead-code",   // Warn when dead code is identified.
  //"-Ywarn-inaccessible",// Warn about inaccessible types in method signatures.
  //"-Ywarn-nullary-override",// Warn when non-nullary overrides nullary, e.g. def foo() over def foo.
  //"-Ylog-classpath",
  //"-Xlog-implicits",
  //"-Yshow-trees-compact",
  //"-Yshow-trees-stringified",
  //"-Ymacro-debug-lite",
  "-Xlog-free-types",
  "-Xlog-free-terms",
  "-Xprint-types"
)
fork in Test in ThisBuild := true
javaOptions in Test in ThisBuild += s"-Dlogger.file=${file("test/resources/logback-test.xml").getAbsoluteFile}"
javaOptions in ThisBuild ++= Seq(
  "-Xms512M",
  "-Xmx2048M",
  "-Xss1M",
  "-XX:+CMSClassUnloadingEnabled",
  "-XX:MaxPermSize=256M",
  "-XX:MaxMetaspaceSize=512m"
)
scalafmtConfig in ThisBuild := file(".scalafmt.conf")
scalacOptions in ThisBuild ++= {
  CrossVersion.partialVersion((Compile / scalaVersion).value) match {
    case Some((2, n)) if n >= 13 => "-Ymacro-annotations" :: Nil
    case _                       => Nil
  }
}
libraryDependencies in ThisBuild ++= {
  CrossVersion.partialVersion(scalaVersion.value) match {
    case Some((2, n)) if n >= 13 => Nil
    case _                       => compilerPlugin(macroParadise) :: Nil
  }
}
dependencyOverrides in ThisBuild ++= Seq(
  akkaActor,
  logbackClassic
)
val securityUpdates = Seq(
  "com.fasterxml.jackson.module" %% "jackson-module-scala" % "2.12.6",
  "com.fasterxml.jackson.core"    % "jackson-databind"     % "2.12.6.1",
  "org.yaml"                      % "snakeyaml"            % "1.30"
)
dependencyOverrides in ThisBuild ++= securityUpdates
PlayKeys.includeDocumentationInBinary := false
milestoneFilter := ((milestone: Milestone) => milestone.title.startsWith("4"))

lazy val scalligraph = (project in file("ScalliGraph"))
  .settings(name := "scalligraph")

lazy val thehive = (project in file("."))
  .enablePlugins(PlayScala)
  .dependsOn(thehiveCore, thehiveCortex, thehiveMisp, thehiveFrontend, thehiveMigration)
  .settings(
    name := "thehive",
    version := thehiveVersion,
    crossScalaVersions := Nil,
    PlayKeys.playMonitoredFiles ~= (_.filter(f => f.compareTo(file("frontend/app").getAbsoluteFile) != 0)),
    PlayKeys.devSettings += "play.server.provider" -> "org.thp.thehive.CustomAkkaHttpServerProvider",
//    Universal / mappings ++= (thehiveMigration / Universal / mappings).value,
    Compile / run := {
      (thehiveFrontend / gruntDev).value
      (Compile / run).evaluated
    },
    discoveredMainClasses in Compile := Seq("play.core.server.ProdServerStart", "org.thp.thehive.migration.Migrate", "org.thp.thehive.cloner.Cloner"),
    mainClass in (Compile, bashScriptDefines) := None,
    makeBashScripts ~= {
      _.map {
        case (f, "bin/prod-server-start") => (f, "bin/thehive")
        case other                        => other
      }
    },
    clean := {
      (clean in scalligraph).value
      (clean in thehiveCore).value
      (clean in thehiveDto).value
      (clean in thehiveClient).value
      (clean in thehiveFrontend).value
      (clean in thehiveCortex).value
      (clean in thehiveMisp).value
      (clean in cortexClient).value
      (clean in mispClient).value
      (clean in thehiveMigration).value
      (clean in clientCommon).value
      (clean in cortexDto).value
    },
    test := {
      (test in Test in scalligraph).value
      (test in Test in thehiveCore).value
      (test in Test in thehiveDto).value
      (test in Test in thehiveClient).value
      (test in Test in thehiveFrontend).value
      (test in Test in thehiveCortex).value
      (test in Test in thehiveMisp).value
      (test in Test in cortexClient).value
      (test in Test in mispClient).value
      (test in Test in thehiveMigration).value
      (test in Test in clientCommon).value
      (test in Test in cortexDto).value
    },
    testQuick := {
      (testQuick in Test in scalligraph).evaluated
      (testQuick in Test in thehiveCore).evaluated
      (testQuick in Test in thehiveDto).evaluated
      (testQuick in Test in thehiveClient).evaluated
      (testQuick in Test in thehiveFrontend).evaluated
      (testQuick in Test in thehiveCortex).evaluated
      (testQuick in Test in thehiveMisp).evaluated
      (testQuick in Test in cortexClient).evaluated
      (testQuick in Test in mispClient).evaluated
      (testQuick in Test in thehiveMigration).evaluated
      (testQuick in Test in clientCommon).evaluated
      (testQuick in Test in cortexDto).evaluated
    }
  )

lazy val thehiveCore = (project in file("thehive"))
  .enablePlugins(PlayScala)
  .dependsOn(scalligraph)
  .dependsOn(scalligraph % "test -> test")
  .dependsOn(cortexClient % "test -> test")
  .dependsOn(thehiveDto)
  .dependsOn(clientCommon)
  .dependsOn(thehiveClient % Test)
  .settings(
    name := "thehive-core",
    version := thehiveVersion,
    libraryDependencies ++= Seq(
      chimney,
      guice,
      akkaCluster,
      akkaClusterTyped,
      akkaClusterTools,
      zip4j,
      ws,
      specs % Test,
      handlebars,
      playMailer,
      playMailerGuice,
      pbkdf2,
      commonCodec,
      scalaGuice,
      reflections,
      quartzScheduler
    )
  )

lazy val thehiveDto = (project in file("dto"))
  .dependsOn(scalligraph)
  .settings(
    name := "thehive-dto",
    version := thehiveVersion,
    libraryDependencies ++= Seq(
      aix
    )
  )

lazy val thehiveClient = (project in file("client"))
  .dependsOn(thehiveDto)
  .dependsOn(clientCommon)
  .settings(
    name := "thehive-client",
    version := thehiveVersion,
    libraryDependencies ++= Seq(
      ws
    )
  )

lazy val npm        = taskKey[Unit]("Install npm dependencies")
lazy val bower      = taskKey[Unit]("Install bower dependencies")
lazy val gruntDev   = taskKey[Unit]("Inject bower dependencies in index.html")
lazy val gruntBuild = taskKey[Seq[(File, String)]]("Build frontend files")

lazy val thehiveFrontend = (project in file("frontend"))
  .settings(
    name := "thehive-frontend",
    version := thehiveVersion,
    npm :=
      FileBuilder(
        label = "npm",
        inputFiles = baseDirectory.value / "package.json",
        outputFiles = baseDirectory.value / "node_modules" ** AllPassFilter,
        command = baseDirectory.value -> "npm install",
        streams = streams.value
      ),
    bower := FileBuilder(
      label = "bower",
      inputFiles = baseDirectory.value / "bower.json",
      outputFiles = baseDirectory.value / "bower_components" ** AllPassFilter,
      command = baseDirectory.value -> "bower install",
      streams = streams.value
    ),
    gruntDev := {
      npm.value
      bower.value
      FileBuilder(
        label = "grunt",
        inputFiles = baseDirectory.value / "bower_components" ** AllPassFilter,
        outputFiles = baseDirectory.value / "app" / "index.html",
        command = baseDirectory.value -> "grunt wiredep",
        streams = streams.value
      )
    },
    gruntBuild := {
      npm.value
      bower.value
      val dist = baseDirectory.value / "dist"
      val outputFiles = FileBuilder(
        label = "grunt",
        inputFiles = baseDirectory.value / "bower_components" ** AllPassFilter,
        outputFiles = dist ** AllPassFilter,
        command = baseDirectory.value -> "grunt build",
        streams = streams.value
      )
      for {
        file        <- outputFiles.toSeq
        rebasedFile <- sbt.Path.rebase(dist, "frontend")(file)
      } yield file -> rebasedFile
    },
    Compile / resourceDirectory := baseDirectory.value / "app",
    Compile / packageBin / mappings := gruntBuild.value,
    watchSources := Nil,
    cleanFiles ++= Seq(
      baseDirectory.value / "dist",
      baseDirectory.value / "bower_components",
      baseDirectory.value / "node_modules"
    )
  )

lazy val clientCommon = (project in file("client-common"))
  .dependsOn(scalligraph)
  .settings(
    name := "client-common",
    version := thehiveVersion,
    libraryDependencies ++= Seq(
      ws,
      specs % Test
    )
  )

lazy val thehiveCortex = (project in file("cortex/connector"))
  .dependsOn(thehiveCore)
  .dependsOn(cortexClient)
  .dependsOn(cortexClient % "test -> test")
  .dependsOn(thehiveCore % "test -> test")
  .dependsOn(scalligraph % "test -> test")
  .settings(
    name := "thehive-cortex",
    version := thehiveVersion,
    libraryDependencies ++= Seq(
      reflections,
      specs % Test
    )
  )

lazy val cortexDto = (project in file("cortex/dto"))
  .dependsOn(scalligraph)
  .settings(
    name := "cortex-dto",
    version := thehiveVersion,
    libraryDependencies ++= Seq(
      chimney
    )
  )

lazy val cortexClient = (project in file("cortex/client"))
  .dependsOn(cortexDto)
  .dependsOn(clientCommon)
  .dependsOn(scalligraph % "test -> test")
  .settings(
    name := "cortex-client",
    version := thehiveVersion,
    libraryDependencies ++= Seq(
      ws,
      specs            % Test,
      playFilters      % Test,
      playMockws       % Test,
      akkaClusterTyped % Test
    )
  )

lazy val thehiveMisp = (project in file("misp/connector"))
  .dependsOn(thehiveCore)
  .dependsOn(mispClient)
  .dependsOn(thehiveCore % "test -> test")
  .settings(
    name := "thehive-misp",
    version := thehiveVersion,
    libraryDependencies ++= Seq(
      specs      % Test,
      playMockws % Test
    )
  )

lazy val mispClient = (project in file("misp/client"))
  .dependsOn(scalligraph)
  .dependsOn(clientCommon)
  .settings(
    name := "misp-client",
    version := thehiveVersion,
    libraryDependencies ++= Seq(
      ws,
      alpakka,
      akkaHttp,
      specs      % Test,
      playMockws % Test
    )
  )

lazy val thehiveMigration = (project in file("migration"))
  .enablePlugins(JavaAppPackaging)
  .dependsOn(scalligraph)
  .dependsOn(thehiveCore)
  .dependsOn(thehiveCortex)
  .settings(
    name := "thehive-migration",
    version := thehiveVersion,
    resolvers += "elasticsearch-releases" at "https://artifacts.elastic.co/maven",
    crossScalaVersions := Seq(scala212),
    libraryDependencies ++= Seq(
      alpakka,
      ehcache,
      scopt,
      specs % Test
    ),
    normalizedName := "migrate"
  )

```

`client-common/src/main/scala/org/thp/client/Authentication.scala`:

```scala
package org.thp.client

import play.api.http.HeaderNames
import play.api.libs.json._
import play.api.libs.ws.{WSAuthScheme, WSRequest}

trait Authentication {
  def apply(request: WSRequest): WSRequest
}

object Authentication {

  val reads: Reads[Authentication] = Reads[Authentication] { json =>
    (json \ "type").asOpt[String].fold[JsResult[Authentication]](JsSuccess(NoAuthentication)) {
      case "basic" =>
        for {
          username <- (json \ "username").validate[String]
          password <- (json \ "password").validate[String]
        } yield PasswordAuthentication(username, password)
      case "bearer" => (json \ "key").validate[String].map(KeyAuthentication(_, "Bearer "))
      case "key"    => (json \ "key").validate[String].map(KeyAuthentication(_, ""))
      case "none"   => JsSuccess(NoAuthentication)
      case other    => JsError(s"Unknown authentication type: $other")
    }
  }

  val writes: Writes[Authentication] = Writes[Authentication] {
    case PasswordAuthentication(username, password) => Json.obj("type" -> "basic", "username" -> username, "password" -> password)
    case KeyAuthentication(key, "")                 => Json.obj("type" -> "key", "key" -> key)
    case KeyAuthentication(key, "Bearer ")          => Json.obj("type" -> "bearer", "key" -> key)
    case NoAuthentication                           => Json.obj("type" -> "none")
    case KeyAuthentication(key, other)              => Json.obj("type" -> other, "key" -> key)
  }
  implicit val format: Format[Authentication] = Format(reads, writes)
}

case class PasswordAuthentication(username: String, password: String) extends Authentication {
  override def apply(request: WSRequest): WSRequest = request.withAuth(username, password, WSAuthScheme.BASIC)
}

case class KeyAuthentication(key: String, prefix: String) extends Authentication {
  override def apply(request: WSRequest): WSRequest = request.addHttpHeaders(HeaderNames.AUTHORIZATION -> s"$prefix$key")
}

object NoAuthentication extends Authentication {
  override def apply(request: WSRequest): WSRequest = request
}

```

`client-common/src/main/scala/org/thp/client/BaseClient.scala`:

```scala
package org.thp.client

import play.api.Logger
import play.api.http.Status
import play.api.libs.json._
import play.api.libs.ws.{WSClient, WSResponse}

import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success, Try}

case class ApplicationError(status: Int, body: JsValue) extends Exception(s"ApplicationError($status):\n${Json.prettyPrint(body)}")

object ApplicationError {
  def apply(r: WSResponse): ApplicationError = ApplicationError(r.status, Try(r.json).getOrElse(Json.obj("body" -> r.body)))
}

class BaseClient[Input: Writes, Output: Reads](baseUrl: String)(implicit ws: WSClient) {
  lazy val logger: Logger = Logger(getClass)

  def create(input: Input, url: String = baseUrl)(implicit ec: ExecutionContext, auth: Authentication): Future[Output] = {
    val body = Json.toJson(input)
//    val url  = urlOverride.getOrElse(baseUrl)
    logger.debug(s"Request POST $url\n${Json.prettyPrint(body)}")
    auth(ws.url(url))
      .post(body)
      .transform {
        case Success(r) if r.status == Status.CREATED => Success(r.body[JsValue].as[Output])
        case Success(r)                               => Failure(ApplicationError(r))
        case Failure(t)                               => throw t
      }
  }

  def search[SearchInput: Writes](input: SearchInput)(implicit ec: ExecutionContext, auth: Authentication): Future[Seq[Output]] = {
    val body = Json.toJson(input)
    val url  = s"$baseUrl/_search"
    logger.debug(s"Request POST $url\n${Json.prettyPrint(body)}")
    auth(ws.url(url))
      .post(body)
      .transform {
        case Success(r) if r.status == Status.OK => Success(r.body[JsValue].as[Seq[Output]])
        case Success(r)                          => Failure(ApplicationError(r))
        case Failure(t)                          => throw t
      }
  }

  def get(id: String, urlFragments: String = "")(implicit ec: ExecutionContext, auth: Authentication): Future[Output] = {
    logger.debug(s"Request GET $baseUrl/$id$urlFragments")
    auth(ws.url(s"$baseUrl/$id$urlFragments"))
      .get()
      .transform {
        case Success(r) if r.status == Status.OK => Success(r.body[JsValue].as[Output])
        case Success(r)                          => Failure(ApplicationError(r))
        case Failure(t)                          => throw t
      }
  }

  def list(urlFragments: String = "", range: Option[String] = None)(implicit ec: ExecutionContext, auth: Authentication): Future[Seq[Output]] = {
    val url = range.fold(s"$baseUrl$urlFragments")(r => s"$baseUrl$urlFragments?range=$r")
    logger.debug(s"Request GET $url")
    auth(ws.url(s"$url"))
      .get
      .transform {
        case Success(r) if r.status == Status.OK => Success(r.body[JsValue].as[Seq[Output]])
        case Success(r)                          => Failure(ApplicationError(r))
        case Failure(t)                          => throw t
      }
  }
}

```

`client-common/src/main/scala/org/thp/client/ProxyWS.scala`:

```scala
package org.thp.client

import akka.stream.Materializer
import com.typesafe.config.{Config, ConfigFactory}
import com.typesafe.sslconfig.ssl.{KeyStoreConfig, SSLConfigFactory, SSLConfigSettings, SSLDebugConfig, SSLLooseConfig, TrustStoreConfig}
import org.thp.scalligraph.services.config.ApplicationConfig.durationFormat
import play.api.libs.json._
import play.api.libs.ws.ahc.{AhcWSClient, AhcWSClientConfig}
import play.api.libs.ws.{DefaultWSProxyServer, WSClient, WSClientConfig, WSProxyServer, WSRequest}

import scala.concurrent.duration.{Duration, DurationInt}

case class ProxyWSConfig(wsConfig: AhcWSClientConfig = AhcWSClientConfig(), proxyConfig: Option[WSProxyServer] = None)

object ProxyWSConfig {
  val defaultWSProxyServerReads: Reads[DefaultWSProxyServer] = Json.reads[DefaultWSProxyServer]

  implicit val wsProxyServerFormat: Format[WSProxyServer] =
    Format[WSProxyServer](
      defaultWSProxyServerReads.widen[WSProxyServer],
      Writes { c =>
        Json.obj(
          "host"          -> c.host,
          "port"          -> c.port,
          "protocol"      -> c.protocol,
          "principal"     -> c.principal,
          "password"      -> c.password,
          "ntlmDomain"    -> c.ntlmDomain,
          "encoding"      -> c.encoding,
          "nonProxyHosts" -> c.nonProxyHosts
        )
      }
    )

  implicit val sslDebugConfigWrites: Writes[SSLDebugConfig] = Writes[SSLDebugConfig](conf =>
    Json.obj(
      "all"          -> conf.all,
      "keymanager"   -> conf.keymanager,
      "ssl"          -> conf.ssl,
      "sslctx"       -> conf.sslctx,
      "trustmanager" -> conf.trustmanager
    )
  )

  implicit val sslLooseConfigWrites: Writes[SSLLooseConfig] = Writes[SSLLooseConfig] { c =>
    Json.obj(
      "acceptAnyCertificate"        -> c.acceptAnyCertificate,
      "allowLegacyHelloMessages"    -> c.allowLegacyHelloMessages,
      "allowUnsafeRenegotiation"    -> c.allowUnsafeRenegotiation,
      "allowWeakCiphers"            -> c.allowWeakCiphers,
      "allowWeakProtocols"          -> c.allowWeakProtocols,
      "disableHostnameVerification" -> c.disableHostnameVerification,
      "disableSNI"                  -> c.disableSNI
    )
  }

  implicit val keyStoreConfigWrites: Writes[KeyStoreConfig] = Writes[KeyStoreConfig] { c =>
    Json.obj(
      "data"      -> c.data,
      "filePath"  -> c.filePath,
      "password"  -> c.password,
      "storeType" -> c.storeType
    )
  }
  implicit val trustStoreConfigWrites: Writes[TrustStoreConfig] = Writes[TrustStoreConfig] { c =>
    Json.obj(
      "data"      -> c.data,
      "filePath"  -> c.filePath,
      "storeType" -> c.storeType
    )
  }

  lazy val defaultSSLConfig: Config = ConfigFactory.load().getConfig("ssl-config")
  implicit val sslConfigFormat: Format[SSLConfigSettings] = Format[SSLConfigSettings](
    Reads[SSLConfigSettings](json => JsSuccess(SSLConfigFactory.parse(ConfigFactory.parseString(json.toString).withFallback(defaultSSLConfig)))),
    Writes[SSLConfigSettings] { c =>
      Json.obj(
        "default"                     -> c.default,
        "protocol"                    -> c.protocol,
        "checkRevocation"             -> c.checkRevocation,
        "revocationLists"             -> c.revocationLists.fold[JsValue](JsArray.empty)(url => JsArray(url.map(u => JsString(u.toString)))),
        "debug"                       -> c.debug,
        "loose"                       -> c.loose,
        "enabledCipherSuites"         -> c.enabledCipherSuites.fold[JsValue](JsArray.empty)(Json.toJson(_)),
        "enabledProtocols"            -> c.enabledProtocols.fold[JsValue](JsArray.empty)(Json.toJson(_)),
        "hostnameVerifierClass"       -> c.hostnameVerifierClass.getCanonicalName,
        "disabledSignatureAlgorithms" -> c.disabledSignatureAlgorithms,
        "disabledKeyAlgorithms"       -> c.disabledKeyAlgorithms,
        "keyManager" -> Json.obj(
          "algorithm" -> c.keyManagerConfig.algorithm,
          "stores"    -> c.keyManagerConfig.keyStoreConfigs,
          "prototype" -> Json.obj(
            "stores" -> Json.obj(
              "type"     -> JsNull,
              "path"     -> JsNull,
              "data"     -> JsNull,
              "password" -> JsNull
            )
          )
        ),
        "trustManager" -> Json.obj(
          "algorithm" -> c.trustManagerConfig.algorithm,
          "stores"    -> c.trustManagerConfig.trustStoreConfigs,
          "prototype" -> Json.obj(
            "stores" -> Json.obj(
              "type" -> JsNull,
              "path" -> JsNull,
              "data" -> JsNull
            )
          )
        ),
        "sslParameters" -> Json.obj(
          "clientAuth" -> c.sslParametersConfig.clientAuth.toString,
          "protocols"  -> c.sslParametersConfig.protocols
        )
      )
    }
  )

  implicit val format: OFormat[ProxyWSConfig] = OFormat[ProxyWSConfig](
    json =>
      for {
        connectionTimeout           <- (json \ "timeout.connection").validateOpt[Duration].map(_.getOrElse(2.minutes))
        idleTimeout                 <- (json \ "timeout.idle").validateOpt[Duration].map(_.getOrElse(2.minutes))
        requestTimeout              <- (json \ "timeout.request").validateOpt[Duration].map(_.getOrElse(2.minutes))
        followRedirects             <- (json \ "followRedirects").validateOpt[Boolean].map(_.getOrElse(true))
        useProxyProperties          <- (json \ "useProxyProperties").validateOpt[Boolean].map(_.getOrElse(true))
        userAgent                   <- (json \ "userAgent").validateOpt[String]
        compressionEnabled          <- (json \ "compressionEnabled").validateOpt[Boolean].map(_.getOrElse(false))
        ssl                         <- (json \ "ssl").validateOpt[SSLConfigSettings].map(_.getOrElse(SSLConfigSettings()))
        maxConnectionsPerHost       <- (json \ "maxConnectionsPerHost").validateOpt[Int].map(_.getOrElse(-1))
        maxConnectionsTotal         <- (json \ "maxConnectionsTotal").validateOpt[Int].map(_.getOrElse(-1))
        maxConnectionLifetime       <- (json \ "maxConnectionLifetime").validateOpt[Duration].map(_.getOrElse(Duration.Inf))
        idleConnectionInPoolTimeout <- (json \ "idleConnectionInPoolTimeout").validateOpt[Duration].map(_.getOrElse(1.minute))
        maxNumberOfRedirects        <- (json \ "maxNumberOfRedirects").validateOpt[Int].map(_.getOrElse(5))
        maxRequestRetry             <- (json \ "maxRequestRetry").validateOpt[Int].map(_.getOrElse(5))
        disableUrlEncoding          <- (json \ "disableUrlEncoding").validateOpt[Boolean].map(_.getOrElse(false))
        keepAlive                   <- (json \ "keepAlive").validateOpt[Boolean].map(_.getOrElse(true))
        useLaxCookieEncoder         <- (json \ "useLaxCookieEncoder").validateOpt[Boolean].map(_.getOrElse(false))
        useCookieStore              <- (json \ "useCookieStore").validateOpt[Boolean].map(_.getOrElse(false))

        host          <- (json \ "proxy" \ "host").validateOpt[String]
        port          <- (json \ "proxy" \ "port").validateOpt[Int]
        protocol      <- (json \ "proxy" \ "protocol").validateOpt[String]
        principal     <- (json \ "proxy" \ "principal").validateOpt[String]
        password      <- (json \ "proxy" \ "password").validateOpt[String]
        ntlmDomain    <- (json \ "proxy" \ "ntlmDomain").validateOpt[String]
        encoding      <- (json \ "proxy" \ "encoding").validateOpt[String]
        nonProxyHosts <- (json \ "proxy" \ "nonProxyHosts").validateOpt[Seq[String]]
      } yield ProxyWSConfig(
        AhcWSClientConfig(
          WSClientConfig(connectionTimeout, idleTimeout, requestTimeout, followRedirects, useProxyProperties, userAgent, compressionEnabled, ssl),
          maxConnectionsPerHost,
          maxConnectionsTotal,
          maxConnectionLifetime,
          idleConnectionInPoolTimeout,
          maxNumberOfRedirects,
          maxRequestRetry,
          disableUrlEncoding,
          keepAlive,
          useLaxCookieEncoder,
          useCookieStore
        ),
        host.map(DefaultWSProxyServer(_, port.getOrElse(3128), protocol, principal, password, ntlmDomain, encoding, nonProxyHosts))
      ), { cfg: ProxyWSConfig =>
      val wsConfig =
        Json.obj(
          "timeout" -> Json.obj(
            "connection" -> cfg.wsConfig.wsClientConfig.connectionTimeout,
            "idle"       -> cfg.wsConfig.wsClientConfig.idleTimeout,
            "request"    -> cfg.wsConfig.wsClientConfig.requestTimeout
          ),
          "followRedirects"             -> cfg.wsConfig.wsClientConfig.followRedirects,
          "useProxyProperties"          -> cfg.wsConfig.wsClientConfig.useProxyProperties,
          "userAgent"                   -> cfg.wsConfig.wsClientConfig.userAgent,
          "compressionEnabled"          -> cfg.wsConfig.wsClientConfig.compressionEnabled,
          "ssl"                         -> cfg.wsConfig.wsClientConfig.ssl,
          "maxConnectionsPerHost"       -> cfg.wsConfig.maxConnectionsPerHost,
          "maxConnectionsTotal"         -> cfg.wsConfig.maxConnectionsTotal,
          "maxConnectionLifetime"       -> cfg.wsConfig.maxConnectionLifetime,
          "idleConnectionInPoolTimeout" -> cfg.wsConfig.idleConnectionInPoolTimeout,
          "maxNumberOfRedirects"        -> cfg.wsConfig.maxNumberOfRedirects,
          "maxRequestRetry"             -> cfg.wsConfig.maxRequestRetry,
          "disableUrlEncoding"          -> cfg.wsConfig.disableUrlEncoding,
          "keepAlive"                   -> cfg.wsConfig.keepAlive,
          "useLaxCookieEncoder"         -> cfg.wsConfig.useLaxCookieEncoder,
          "useCookieStore"              -> cfg.wsConfig.useCookieStore
        )
      cfg
        .proxyConfig
        .fold(wsConfig)(proxyConfig =>
          wsConfig + ("proxy" ->
            Json.obj(
              "host"          -> proxyConfig.host,
              "port"          -> proxyConfig.port,
              "protocol"      -> proxyConfig.protocol,
              "principal"     -> proxyConfig.principal,
              "password"      -> proxyConfig.password,
              "ntlmDomain"    -> proxyConfig.ntlmDomain,
              "encoding"      -> proxyConfig.encoding,
              "nonProxyHosts" -> proxyConfig.nonProxyHosts
            ))
        )
    }
  )
}

class ProxyWS(ws: AhcWSClient, val proxy: Option[WSProxyServer]) extends WSClient {

  def this(wsConfig: AhcWSClientConfig, proxyConfig: Option[WSProxyServer], mat: Materializer) = this(AhcWSClient(wsConfig)(mat), proxyConfig)

  def this(config: ProxyWSConfig, mat: Materializer) = this(config.wsConfig, config.proxyConfig, mat)

  def this(mat: Materializer) = this(AhcWSClient()(mat), None)

  override def underlying[T]: T = ws.underlying

  override def url(url: String): WSRequest = {
    val req = ws.url(url)
    proxy.fold(req)(req.withProxyServer)
  }

  override def close(): Unit = ws.close()
}

```

`client-common/src/test/scala/org/thp/client/ProxyWSTest.scala`:

```scala
package org.thp.client

import play.api.libs.json.{JsObject, Json}
import play.api.test.PlaySpecification

class ProxyWSTest extends PlaySpecification {
  "WS config" should {
    "be serializable" in {
      val proxyWSConfig = JsObject.empty.as[ProxyWSConfig]
      val json          = Json.toJson(proxyWSConfig)
      json.as[ProxyWSConfig]
      ok
    }

    "accept proxy configuration" in {
      val proxyWSConfig = Json
        .obj("proxy" -> Json.obj("host" -> "127.0.0.1", "port" -> 3128, "protocol" -> "http"))
        .as[ProxyWSConfig]
      val json = Json.toJson(proxyWSConfig)
      json.as[ProxyWSConfig].proxyConfig.map(_.host) must beSome("127.0.0.1")
    }

    "accept ssl config" in {
      val proxyWSConfig = Json
        .obj("ssl" -> Json.obj("protocol" -> "TLSv1.0"))
        .as[ProxyWSConfig]
      val json = Json.toJson(proxyWSConfig)
      json.as[ProxyWSConfig].wsConfig.wsClientConfig.ssl.protocol must beEqualTo("TLSv1.0")
    }
  }
}

```

`client/src/main/scala/org/thp/thehive/client/TheHiveClient.scala`:

```scala
package org.thp.thehive.client

import org.thp.client.{ApplicationError, Authentication, BaseClient}
import org.thp.thehive.dto.v1._
import play.api.Logger
import play.api.http.Status
import play.api.libs.json.{JsObject, JsValue, Json}
import play.api.libs.ws.WSClient

import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success}

class TheHiveClient(baseUrl: String)(implicit ws: WSClient) {
  lazy val logger: Logger = Logger(getClass)
  val `case`              = new BaseClient[InputCase, OutputCase](s"$baseUrl/api/v1/case")
  val user                = new BaseClient[InputUser, OutputUser](s"$baseUrl/api/v1/user")
  val customFields        = new BaseClient[InputCustomField, OutputCustomField](s"$baseUrl/api/v1/customField")
  val organisation        = new BaseClient[InputOrganisation, OutputOrganisation](s"$baseUrl/api/v1/organisation")
//  val share        = new BaseClient[InputShare, OutputShare](s"$baseUrl/api/v1/share")
  val task  = new BaseClient[InputTask, OutputTask](s"$baseUrl/api/v1/task")
  val alert = new BaseClient[InputAlert, OutputAlert](s"$baseUrl/api/v1/alert")

  object audit {

    def list(implicit ec: ExecutionContext, auth: Authentication): Future[Seq[OutputAudit]] = {
      logger.debug(s"Request GET $baseUrl")
      auth(ws.url(s"$baseUrl/api/v1/audit"))
        .get()
        .transform {
          case Success(r) if r.status == Status.OK => Success(r.body[JsValue].as[Seq[OutputAudit]])
          case Success(r)                          => Failure(ApplicationError(r))
          case Failure(t)                          => throw t
        }
    }
  }

  def query(q: JsObject*)(implicit ec: ExecutionContext, auth: Authentication): Future[JsValue] =
    auth(ws.url(s"$baseUrl/api/v1/query"))
      .post(Json.obj("query" -> q))
      .transform {
        case Success(r) if r.status == Status.OK => Success(r.body[JsValue])
        case Success(r)                          => Failure(ApplicationError(r))
        case Failure(t)                          => throw t
      }
}

```

`code_of_conduct.md`:

```md
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, gender identity and expression, level of experience,
nationality, personal appearance, race, religion, or sexual identity and
orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
  advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
  address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior, in compliance with the
licensing terms applying to the Project developments.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful. However, these actions shall respect the
licensing terms of the Project Developments that will always supersede such
Code of Conduct.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at support@thehive-project.org. The project team
will review and investigate all complaints, and will respond in a way that it deems
appropriate to the circumstances. The project team is obligated to maintain
confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at [http://contributor-covenant.org/version/1/4][version]

This version includes a clarification to ensure that the code of conduct is in
compliance with the free software licensing terms of the project.

[homepage]: http://contributor-covenant.org
[version]: http://contributor-covenant.org/version/1/4/

```

`conf/application.sample.conf`:

```conf
###
## Documentation is available at https://docs.thehive-project.org/thehive/
###

## Include Play secret key
# More information on secret key at https://www.playframework.com/documentation/2.8.x/ApplicationSecret
include "/etc/thehive/secret.conf"

## Database configuration
db.janusgraph {
  storage {
    ## Cassandra configuration
    # More information at https://docs.janusgraph.org/basics/configuration-reference/#storagecql
    // backend: cql
    // hostname: ["ip1", "ip2"]
    # Cassandra authentication (if configured)
    // username: "thehive"
    // password: "password"
    cql {
      cluster-name: thp
      keyspace: thehive
    }
  }
  index.search {
    backend: lucene
    directory: /opt/thp/thehive/index
    # If TheHive is in cluster ElasticSearch must be used:
    // backend: elasticsearch
    // hostname: ["ip1", "ip2"]
    // index-name: thehive
  }

  ## For test only !
  # Comment the two lines below before enable Cassandra database
  storage.backend: berkeleyje
  storage.directory: /opt/thp/thehive/database
  // berkeleyje.freeDisk: 200 # disk usage threshold
}

## Attachment storage configuration
storage {
  ## Local filesystem
  // provider: localfs
  // localfs.location: /path/to/files

  ## Hadoop filesystem (HDFS)
  // provider: hdfs
  // hdfs {
  //   root: "hdfs://localhost:10000" # namenode server hostname
  //   location: "/thehive"           # location inside HDFS
  //   username: thehive              # file owner
  // }
}

## Authentication configuration
# More information at https://github.com/TheHive-Project/TheHiveDocs/TheHive4/Administration/Authentication.md
//auth {
//  providers: [
//    {name: session}               # required !
//    {name: basic, realm: thehive}
//    {name: local}
//    {name: key}
//  ]
# The format of logins must be valid email address format. If the provided login doesn't contain `@` the following
# domain is automatically appended
//  defaultUserDomain: "thehive.local"
//}

## CORTEX configuration
# More information at https://github.com/TheHive-Project/TheHiveDocs/TheHive4/Administration/Connectors.md
# Enable Cortex connector
// play.modules.enabled += org.thp.thehive.connector.cortex.CortexModule
// cortex {
//  servers: [
//    {
//      name: "local"                # Cortex name
//      url: "http://localhost:9001" # URL of Cortex instance
//      auth {
//        type: "bearer"
//        key: "***"                 # Cortex API key
//      }
//      wsConfig {}                  # HTTP client configuration (SSL and proxy)
//    }
//  ]
// }

## MISP configuration
# More information at https://github.com/TheHive-Project/TheHiveDocs/TheHive4/Administration/Connectors.md
# Enable MISP connector
// play.modules.enabled += org.thp.thehive.connector.misp.MispModule
// misp {
//  interval: 1 hour
//  servers: [
//    {
//      name = "local"            # MISP name
//      url = "http://localhost/" # URL or MISP
//      auth {
//        type = key
//        key = "***"             # MISP API key
//      }
//      wsConfig {}               # HTTP client configuration (SSL and proxy)
//    }
//  ]
//}

# Define maximum size of attachments (default 10MB)
//play.http.parser.maxDiskBuffer: 1GB

```

`conf/cloner.sample.conf`:

```conf
# This is a sample configuration for the database cloner tool

# Configuration of the source database (same format as in application.conf)
from.db.janusgraph {
  storage {
    // backend: cql
    // hostname: ["ip1", "ip2"]
  }
  index.search {
    backend: lucene
    directory: /opt/thp/thehive/index
  }
}
# Configuration of the target database
to.db.janusgraph {
  storage {
    // backend: cql
    // hostname: ["ip1", "ip2"]
  }
  index.search {
    backend: lucene
    directory: /opt/thp/thehive/otherIndex
  }
}

```

`conf/logback.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="false">

    <conversionRule conversionWord="coloredLevel"
                    converterClass="play.api.libs.logback.ColoredLevel"/>

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${application.home:-.}/logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
            <fileNamePattern>${application.home:-.}/logs/application.%i.log.zip</fileNamePattern>
            <minIndex>1</minIndex>
            <maxIndex>10</maxIndex>
        </rollingPolicy>
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <maxFileSize>10MB</maxFileSize>
        </triggeringPolicy>
        <encoder>
            <pattern>%date [%level] from %logger in %thread %replace(\(%X{userId}@%X{organisation}\) ){'\(@\) ',''}[%X{request}|%X{tx}] %message%n%xException</pattern>
        </encoder>
    </appender>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%coloredLevel %logger{15} %replace(\(%X{userId}@%X{organisation}\) ){'\(@\) ',''}[%X{request}|%X{tx}] %message%n%xException{10}
            </pattern>
        </encoder>
    </appender>

    <appender name="ASYNCFILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
    </appender>

    <appender name="ASYNCSTDOUT" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="STDOUT"/>
    </appender>

    <!-- do not set the following logger to TRACE -->
    <logger name="org.thp.scalligraph.traversal" level="INFO"/>
    <logger name="org.reflections8.Reflections" level="ERROR" />
    <logger name="org.janusgraph.graphdb.database.management.ManagementLogger" level="OFF"/>
    <logger name="org.janusgraph.graphdb.database.IndexSerializer" level="ERROR"/>

    <logger name="org.thp.scalligraph.models" level="INFO"/>
    <logger name="org.thp" level="INFO"/>

    <root level="INFO">
        <appender-ref ref="ASYNCFILE"/>
        <appender-ref ref="ASYNCSTDOUT"/>
    </root>

</configuration>


```

`conf/migration-logback.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="false">

    <conversionRule conversionWord="coloredLevel"
                    converterClass="play.api.libs.logback.ColoredLevel"/>

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${application.home:-.}/logs/migration.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
            <fileNamePattern>${application.home:-.}/logs/application.%i.log.zip</fileNamePattern>
            <minIndex>1</minIndex>
            <maxIndex>10</maxIndex>
        </rollingPolicy>
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <maxFileSize>10MB</maxFileSize>
        </triggeringPolicy>
        <encoder>
            <pattern>%date [%level] from %logger in %thread - %message%n%xException</pattern>
        </encoder>
    </appender>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>INFO</level>
        </filter>
        <encoder>
            <pattern>%coloredLevel %logger{15} - %message%n%xException{10}
            </pattern>
        </encoder>
    </appender>

    <appender name="ASYNCFILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
    </appender>

    <appender name="ASYNCSTDOUT" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="STDOUT"/>
    </appender>

    <!--
    <logger name="org.thp.scalligraph.models.Database" level="TRACE" />
    <logger name="org.janusgraph.graphdb" level="INFO" />
    <logger name="org.thp.thehive.client" level="DEBUG" />
    <logger name="org.thp.thehive.services.LocalAuthSrv" level="TRACE" />
    <logger name="org.thp.scalligraph.graphql" level="TRACE" />
    -->
    <logger name="org.thp.scalligraph.traversal" level="INFO"/>
    <logger name="org.janusgraph.graphdb.transaction.StandardJanusGraphTx" level="ERROR"/>
    <logger name="org.thp.thehive" level="INFO"/>

    <root level="INFO">
        <appender-ref ref="ASYNCFILE"/>
        <appender-ref ref="ASYNCSTDOUT"/>
    </root>

</configuration>


```

`cortex/client/src/main/scala/org/thp/cortex/client/CortexClient.scala`:

```scala
package org.thp.cortex.client

import akka.stream.Materializer
import akka.stream.scaladsl.Source
import akka.util.ByteString
import org.thp.client._
import org.thp.cortex.dto.v0.{Attachment, _}
import play.api.Logger
import play.api.http.Status
import play.api.libs.json.{Format, JsObject, JsString, Json}
import play.api.libs.ws.WSClient
import play.api.libs.ws.ahc.AhcWSClientConfig
import play.api.mvc.MultipartFormData.{DataPart, FilePart}

import scala.concurrent.duration.Duration
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success, Try}

case class CortexClientConfig(
    name: String,
    url: String,
    includedTheHiveOrganisations: Seq[String] = Seq("*"),
    excludedTheHiveOrganisations: Seq[String] = Nil,
    wsConfig: ProxyWSConfig = ProxyWSConfig(AhcWSClientConfig(), None),
    auth: Authentication
)

object CortexClientConfig {
  implicit val format: Format[CortexClientConfig] = Json.using[Json.WithDefaultValues].format[CortexClientConfig]
}

class CortexClient(
    val name: String,
    val baseUrl: String,
    val includedTheHiveOrganisations: Seq[String],
    val excludedTheHiveOrganisations: Seq[String],
    implicit val ws: WSClient,
    implicit val auth: Authentication,
    implicit val ec: ExecutionContext
) {

  def this(config: CortexClientConfig, mat: Materializer, ec: ExecutionContext) =
    this(
      config.name,
      config.url,
      config.includedTheHiveOrganisations,
      config.excludedTheHiveOrganisations,
      new ProxyWS(config.wsConfig, mat),
      config.auth,
      ec
    )

  lazy val job            = new BaseClient[InputJob, OutputJob](s"$strippedUrl/api/job")
  lazy val analyser       = new BaseClient[InputWorker, OutputWorker](s"$strippedUrl/api/analyzer")
  lazy val responder      = new BaseClient[InputWorker, OutputWorker](s"$strippedUrl/api/responder")
  lazy val logger: Logger = Logger(getClass)
  val strippedUrl: String = baseUrl.replaceFirst("/*$", "")

  /**
    * GET analysers endpoint
    *
    * @return
    */
  def listAnalyser(range: Option[String] = None): Future[Seq[OutputWorker]] = analyser.list(range = range)

  /**
    * GET analyzer by id
    *
    * @param id guess
    * @return
    */
  def getAnalyzer(id: String): Future[OutputWorker] = analyser.get(id)

  /**
    * GET analyzer by dataType
    *
    * @param dataType guess
    * @return
    */
  def listAnalyzersByType(dataType: String, range: Option[String] = None): Future[Seq[OutputWorker]] = analyser.list(s"/type/$dataType", range)

  /**
    * Search an analyzer by name
    *
    * @param analyzerName the name to search for
    * @return
    */
  def getAnalyzerByName(analyzerName: String): Future[OutputWorker] =
    analyser
      .search[SearchQuery](SearchQuery("name", analyzerName, "0-1"))
      .map(_.headOption.getOrElse(throw ApplicationError(404, JsString(s"Analyzer $analyzerName not found"))))

  /**
    * Gets the job status and report if complete
    *
    * @param jobId the cortex job id
    * @param atMost the time that Cortex has to wait before sending a response
    *               (in case the job terminates in the meantime)
    * @return
    */
  def getReport(jobId: String, atMost: Duration): Future[OutputJob] = job.get(jobId, s"/waitreport?atMost=$atMost")

  /**
    * Submits an artifact for analyze with the appropriate analyzer selection
    *
    * @param analyzerId the analyzer to invoke
    * @param artifact the artifact to analyze
    * @return
    */
  def analyse(analyzerId: String, artifact: InputArtifact): Future[OutputJob] = {
    val requestBody = Json.toJson(artifact)
    val result = artifact.attachment match {
      case None =>
        auth(ws.url(s"$strippedUrl/api/analyzer/$analyzerId/run"))
          .post(requestBody)
      case Some(Attachment(filename, size, contentType, data)) =>
        auth(ws.url(s"$strippedUrl/api/analyzer/$analyzerId/run"))
          .post(
            Source(
              List(
                FilePart("data", filename, Some(contentType), data, size),
                DataPart("_json", requestBody.toString)
              )
            )
          )
    }
    result.transform {
      case Success(r) if r.status == Status.CREATED => Success(r.json.as[OutputJob])
      case Success(r)                               => Try(r.json.as[OutputJob])
      case Failure(t)                               => throw t
    }
  }

  /**
    * Gets an artifact attachment from id
    *
    * @param id the id the look for
    * @return
    */
  def getAttachment(id: String): Future[Source[ByteString, _]] =
    auth(ws.url(s"$strippedUrl/api/datastore/$id"))
      .stream()
      .map(r => r.bodyAsSource)

  /**
    * Gets a responder by id
    *
    * @param id the id to look for
    * @return
    */
  def getResponder(id: String): Future[OutputWorker] = responder.get(id)

  /**
    * Search a responder by name
    *
    * @param responderName the name to search for
    * @return
    */
  def getResponderByName(responderName: String): Future[OutputWorker] =
    responder
      .search[SearchQuery](SearchQuery("name", responderName, "0-1"))
      .map(_.headOption.getOrElse(throw ApplicationError(404, JsString(s"Responder $responderName not found"))))

  /**
    * Search a responder by entity type
    *
    * @param entityType the type to search for
    * @return
    */
  def getRespondersByType(entityType: String): Future[Seq[OutputWorker]] =
    responder
      .search[SearchQuery](SearchQuery(field = "dataTypeList", value = s"thehive:$entityType", range = "all"))

  /**
    * Search responders according to a formatted query
    * @param query the query that should look like {query: {...}}
    * @return
    */
  def searchResponders(query: JsObject): Future[Seq[OutputWorker]] =
    responder
      .search[SearchQuery](SearchQuery(field = "", value = "", range = "all", queryOverride = Some(query)))

  /**
    * Materializes an action as a job on Cortex client server
    *
    * @param responderId the responsible responder
    * @param action the action to execute
    * @return
    */
  def execute(responderId: String, action: InputAction): Future[OutputJob] = {
    val requestBody = Json.toJson(action)
    val result      = auth(ws.url(s"$strippedUrl/api/responder/$responderId/run")).post(requestBody)

    result.transform {
      case Success(r) if r.status == Status.CREATED => Success(r.json.as[OutputJob])
      case Success(r)                               => Try(r.json.as[OutputJob])
      case Failure(t)                               => throw t
    }
  }

  /**
    * Retrieve the name of the cortex user
    * @return user name
    */
  def getCurrentUser: Future[String] =
    auth(ws.url(s"$strippedUrl/api/user/current"))
      .get
      .transform {
        case Success(r) if r.status == Status.OK => Try((r.json \ "id").as[String])
        case Success(r)                          => Failure(ApplicationError(r))
        case Failure(t)                          => throw t
      }

  def getHealth: Future[String] = getVersion.transform {
    case _: Success[_] => Success("Ok")
    case _             => Success("Error")
  }

  /**
    * Retrieve version of remote cortex
    * @return version of cortex
    */
  def getVersion: Future[String] =
    auth(ws.url(s"$strippedUrl/api/status"))
      .get
      .transform {
        case Success(r) if r.status == Status.OK => Try((r.json \ "versions" \ "Cortex").as[String])
        case Success(r)                          => Failure(ApplicationError(r))
        case Failure(t)                          => throw t
      }
}

```

`cortex/client/src/test/resources/analyzers.json`:

```json
[
  {
    "id": "anaTest1",
    "name": "anaTest1",
    "version": "1",
    "description": "Ego vero sic intellego, Patres conscripti, nos hoc tempore in provinciis decernendis perpetuae pacis",
    "dataTypeList": [
      "test"
    ],
    "maxTlp": 3,
    "maxPap": 3
  },
  {
    "id": "anaTest2",
    "name": "anaTest2",
    "version": "2",
    "description": "nos hoc tempore in provinciis decernendis perpetuae pacis",
    "dataTypeList": [
      "test",
      "dummy"
    ],
    "maxTlp": 2,
    "maxPap": 2
  }
]
```

`cortex/client/src/test/resources/file.test.txt`:

```txt
empty
```

`cortex/client/src/test/resources/jobs.json`:

```json
[
  {
    "date": 1561625908856,
    "data": "https://www.faux-texte.com/lorem-ipsum-2.htm",
    "type": "analyzer",
    "cacheTag": "8b075e00a860a984993017dec86c16e1",
    "createdAt": 1561625908856,
    "_parent": null,
    "id": "AWuYKFatq3Rtqym9DFmL",
    "_version": 1,
    "pap": 2,
    "_routing": "AWuYKFatq3Rtqym9DFmL",
    "workerId": "anaTest1",
    "analyzerName": "anaTest1",
    "analyzerDefinitionId": "anaTest1",
    "dataType": "domain",
    "_type": "job",
    "message": "0ad6e75a-1a2e-419a-b54a-7a92d6528404",
    "analyzerId": "anaTest1",
    "createdBy": "billotei",
    "organization": "test",
    "tlp": 2,
    "workerDefinitionId": "anaTest1",
    "_id": "AWuYKFatq3Rtqym9DFmL",
    "workerName": "anaTest1",
    "parameters": {},
    "status": "Waiting"
  },
  {
    "date": 1561625908856,
    "data": "https://www.example.com",
    "type": "responder",
    "cacheTag": "8b075e00a860a984993017dec86c16e1",
    "createdAt": 1561625908856,
    "_parent": null,
    "id": "AWuYKBreakinq3Rtqym9DFmL",
    "_version": 1,
    "pap": 3,
    "_routing": "AWuYKBreakinq3Rtqym9DFmL",
    "workerId": "respTest1",
    "analyzerName": "",
    "analyzerDefinitionId": "",
    "dataType": "domain",
    "_type": "job",
    "message": "0ad6e75a-1a2e-419a-b54a-7a92d6528404",
    "analyzerId": "",
    "createdBy": "billotei",
    "organization": "test",
    "tlp": 3,
    "workerDefinitionId": "respTest1",
    "_id": "AWuYKBreakinq3Rtqym9DFmL",
    "workerName": "respTest1",
    "parameters": {},
    "status": "Waiting"
  },
  {
    "date": 1561625908856,
    "data": "https://www.faux-texte.com/lorem-ipsum-2.htm",
    "type": "analyzer",
    "cacheTag": "8b075e00a860a984993017dec86c16e1",
    "createdAt": 1561625908856,
    "_parent": null,
    "id": "XQuYKFert7Rtcvm9DFmT",
    "_version": 1,
    "pap": 2,
    "_routing": "XQuYKFert7Rtcvm9DFmT",
    "workerId": "anaTest2",
    "analyzerName": "anaTest2",
    "analyzerDefinitionId": "anaTest2",
    "dataType": "domain",
    "_type": "job",
    "message": "0ad6e75a-1a2e-419a-b54a-7a92d6528404",
    "analyzerId": "anaTest2",
    "createdBy": "billotei",
    "organization": "test",
    "tlp": 2,
    "workerDefinitionId": "anaTest2",
    "_id": "XQuYKFert7Rtcvm9DFmT",
    "workerName": "anaTest2",
    "parameters": {},
    "status": "Success",
    "report": {
      "summary": {
        "taxonomies": [
          {
            "level": "info",
            "namespace": "test",
            "predicate": "data",
            "value": "test"
          }
        ]
      },
      "full": {
        "data": "imageedit_2_3904987689.jpg",
        "input": {
          "file": "attachment7619802021796183482",
          "filename": "imageedit_2_3904987689.jpg",
          "dataType": "file",
          "tlp": 2,
          "message": "179e85c4-4170-45fe-9d2d-3173539554a6",
          "contentType": "image/jpeg",
          "parameters": {
          },
          "config": {
            "proxy_https": null,
            "cacerts": null,
            "max_pap": 2,
            "jobTimeout": 30,
            "check_tlp": true,
            "proxy_http": null,
            "max_tlp": 2,
            "auto_extract_artifacts": false,
            "jobCache": 10,
            "check_pap": true
          },
          "pap": 2
        }
      },
      "success": true,
      "artifacts": [
        {
          "attachment": {
            "contentType": "application/octet-stream",
            "id": "e64871cf4652cb6e1babc06a376e7c79256dd6b967ca845ae06708cbeb686663",
            "name": "passwd",
            "size": 2644
          },
          "dataType": "file",
          "message": null,
          "tags": [
            "file",
            "virus"
          ],
          "tlp": 3
        },
        {
          "data": "127.0.0.1",
          "dataType": "ip",
          "message": null,
          "tags": [
            "localhost"
          ],
          "tlp": 2
        }
      ],
      "operations": [
      ]
    }
  }
]
```

`cortex/client/src/test/resources/responders.json`:

```json
[
  {
    "id": "respTest1",
    "name": "respTest1",
    "version": "1",
    "description": "Ego vero sic intellego, Patres conscripti, nos hoc tempore in provinciis decernendis perpetuae pacis",
    "dataTypeList": [
      "test",
      "case_task"
    ],
    "maxTlp": 2,
    "maxPap": 3
  },
  {
    "id": "respTest2",
    "name": "respTest2",
    "version": "2",
    "description": "nos hoc tempore in provinciis decernendis perpetuae pacis",
    "dataTypeList": [
      "test",
      "dummy"
    ],
    "maxTlp": 2,
    "maxPap": 3
  }
]
```

`cortex/client/src/test/scala/org/thp/cortex/client/CortexClientTest.scala`:

```scala
package org.thp.cortex.client

import org.thp.cortex.dto.v0._
import org.thp.scalligraph.AppBuilder
import play.api.libs.json.{JsObject, JsString, Json}
import play.api.test.PlaySpecification

import java.util.Date
import scala.concurrent.duration._

class CortexClientTest extends PlaySpecification {
  val app: AppBuilder = new AppBuilder()
    .bindToProvider[CortexClient, TestCortexClientProvider]
  val client: CortexClient = app[CortexClient]

  "Cortex client" should {
    "list analysers" in {
      await(client.listAnalyser()).map(_.name) must contain(exactly("anaTest1", "anaTest2"))
    }

    "get analyzer by its id" in {
      await(client.getAnalyzer("anaTest2")).name must beEqualTo("anaTest2")
    }

    "get analyzer by its name" in {
      await(client.getAnalyzerByName("anaTest1")) must equalTo(
        OutputWorker(
          id = "anaTest1",
          name = "anaTest1",
          version = "1",
          description = "Ego vero sic intellego, Patres conscripti, nos hoc tempore in provinciis decernendis perpetuae pacis",
          dataTypeList = Seq("test"),
          maxTlp = 3,
          maxPap = 3
        )
      )
    }

    "run an analysis" in {
      await(client.analyse("anaTest1", InputArtifact(1, 1, "test", "test", Some("test"), None, JsObject.empty))) must equalTo(
        OutputJob(
          id = "AWuYKFatq3Rtqym9DFmL",
          workerId = "anaTest1",
          workerName = "anaTest1",
          workerDefinition = "anaTest1",
          date = new Date(1561625908856L),
          startDate = None,
          endDate = None,
          status = JobStatus.Waiting,
          data = Some("https://www.faux-texte.com/lorem-ipsum-2.htm"),
          attachment = None,
          organization = "test",
          dataType = "domain",
          //          attributes = Json.obj("tlp" -> 2, "message" -> "0ad6e75a-1a2e-419a-b54a-7a92d6528404", "parameters" -> JsObject.empty, "pap" -> 2),
          None,
          JobType.analyzer
        )
      )
    }

    "get a report" in {
      await(client.getReport("XQuYKFert7Rtcvm9DFmT", 0.second)).report must beSome(
        OutputReport(
          summary = Seq(OutputMinireport("info", "test", "data", JsString("test"))),
          success = true,
          full = Some(
            Json
              .parse("""{
                "data": "imageedit_2_3904987689.jpg",
                "input": {
                  "file": "attachment7619802021796183482",
                  "filename": "imageedit_2_3904987689.jpg",
                  "dataType": "file",
                  "tlp": 2,
                  "message": "179e85c4-4170-45fe-9d2d-3173539554a6",
                  "contentType": "image/jpeg",
                  "parameters": {
                  },
                  "config": {
                    "proxy_https": null,
                    "cacerts": null,
                    "max_pap": 2,
                    "jobTimeout": 30,
                    "check_tlp": true,
                    "proxy_http": null,
                    "max_tlp": 2,
                    "auto_extract_artifacts": false,
                    "jobCache": 10,
                    "check_pap": true
                  },
                  "pap": 2
                }
              }""")
              .as[JsObject]
          ),
          artifacts = Json
            .parse("""[
              {
                "attachment": {
                  "contentType": "application/octet-stream",
                  "id": "e64871cf4652cb6e1babc06a376e7c79256dd6b967ca845ae06708cbeb686663",
                  "name": "passwd",
                  "size": 2644
                },
                "dataType": "file",
                "message": null,
                "tags": ["file", "virus"],
                "tlp": 3
              },
              {
                "data": "127.0.0.1",
                "dataType": "ip",
                "message": null,
                "tags": [
                  "localhost"
                ],
                "tlp": 2
              }
            ]""")
            .as[List[OutputArtifact]],
          operations = Nil,
          errorMessage = None,
          input = None
        )
      )
    }

    "get responder by its name" in {
      await(client.getResponderByName("respTest1")) must equalTo(
        OutputWorker(
          id = "respTest1",
          name = "respTest1",
          version = "1",
          description = "Ego vero sic intellego, Patres conscripti, nos hoc tempore in provinciis decernendis perpetuae pacis",
          dataTypeList = Seq("test", "case_task"),
          maxPap = 3,
          maxTlp = 2
        )
      )
    }

    "get responder by its id" in {
      await(client.getResponder("respTest2")) must equalTo(
        OutputWorker(
          id = "respTest2",
          name = "respTest2",
          version = "2",
          description = "nos hoc tempore in provinciis decernendis perpetuae pacis",
          dataTypeList = Seq("test", "dummy"),
          maxPap = 3,
          maxTlp = 2
        )
      )
    }

    "list analyzers by type" in {
      await(client.listAnalyzersByType("test")).length must beEqualTo(2)
    }

    "list all responders" in {
      await(client.searchResponders(Json.obj("query" -> Json.obj()))).length must beEqualTo(2)
    }
  }
}

```

`cortex/client/src/test/scala/org/thp/cortex/client/TestCortexClientProvider.scala`:

```scala
package org.thp.cortex.client

import akka.stream.scaladsl._
import mockws.MockWS
import org.thp.client.NoAuthentication
import org.thp.cortex.dto.v0.{OutputJob, OutputWorker}
import play.api.http.{FileMimeTypes, HttpEntity}
import play.api.libs.json.{JsValue, Json}
import play.api.mvc._
import play.api.test.Helpers._

import java.net.URLEncoder
import java.nio.file.{Path, Paths}
import javax.inject.{Inject, Provider}
import scala.concurrent.ExecutionContext
import scala.io.Source
import scala.util.matching.Regex

class TestCortexClientProvider @Inject() (Action: DefaultActionBuilder, implicit val fileMimeTypes: FileMimeTypes, implicit val ec: ExecutionContext)
    extends Provider[CortexClient] {
  lazy val analyzers: Seq[OutputWorker]  = readResourceAsJson("/analyzers.json").as[Seq[OutputWorker]]
  lazy val jobs: Seq[OutputJob]          = readResourceAsJson("/jobs.json").as[Seq[OutputJob]]
  lazy val responders: Seq[OutputWorker] = readResourceAsJson("/responders.json").as[Seq[OutputWorker]]
  val apiJobIdWaitReport: Regex          = "^/api/job/([^/]*)/waitreport\\?atMost=\\d+ \\w+$".r
  val apiAnalyzerId: Regex               = "^/api/analyzer/([^/]*)$".r
  val apiAnalyzer: Regex                 = "/api/analyzer(?:\\?.*)?".r
  val apiAnalyzerDataType: Regex         = "^/api/analyzer/type/([^/]*)$".r
  val apiAnalyzerIdRun: Regex            = "^/api/analyzer/([^/]*)/run$".r
  val apiDatastoreId: Regex              = "^/api/datastore/([^/]*)$".r
  val apiResponderId: Regex              = "^/api/responder/([^/]*)$".r
  val apiResponderIdRun: Regex           = "^/api/responder/([^/]*)/run$".r

  val ws: MockWS = MockWS {
    case (GET, apiJobIdWaitReport(id))        => Action(Results.Ok(Json.toJson(jobs.find(_.id == id).get)))
    case (GET, apiAnalyzer())                 => Action(Results.Ok.sendResource("analyzers.json"))
    case (GET, apiAnalyzerDataType(dataType)) => Action(Results.Ok(Json.toJson(analyzers.filter(_.dataTypeList.contains(dataType)))))
    case (GET, apiAnalyzerId(id))             => Action(analyzers.find(_.id == id).map(a => Results.Ok(Json.toJson(a))).getOrElse(Results.NotFound))
    case (POST, "/api/analyzer/_search")      => Action(Results.Ok(Json.toJson(analyzers)))
    case (POST, apiAnalyzerIdRun(id))         => Action(Results.Created(Json.toJson(jobs.find(_.workerId == id).get)))
    case (GET, apiDatastoreId(id)) =>
      val filename = URLEncoder.encode(s"$id.test.txt", "utf-8")
      Action(
        Result(
          header =
            ResponseHeader(200, Map("Content-Disposition" -> s"""attachment; filename="$filename"""", "Content-Transfer-Encoding" -> "binary")),
          body = HttpEntity.Streamed(FileIO.fromPath(fileResource(id)), None, None)
        )
      )
    case (GET, apiResponderId(id))        => Action(Results.Ok(Json.toJson(responders.find(_.id == id).get)))
    case (POST, "/api/responder/_search") => Action(Results.Ok(Json.toJson(responders)))
    case (POST, apiResponderIdRun(id))    => Action(Results.Created(Json.toJson(jobs.find(_.workerId == id).get)))
    case (method, path)                   => Action(Results.NotFound(s"$method $path"))
  }

  def readResourceAsJson(name: String): JsValue = {
    val dataSource = Source.fromFile(getClass.getResource(name).getPath)
    val data       = dataSource.mkString
    dataSource.close()
    Json.parse(data)
  }

  def fileResource(id: String): Path = Paths.get(getClass.getResource(s"/$id.test.txt").getPath)

  def apply[T](block: CortexClient => T): T =
    block(get())

  override def get(): CortexClient =
    new CortexClient("test", "", Seq("*"), Nil, ws, NoAuthentication, ec)
}

```

`cortex/connector/src/main/resources/play/reference-overrides.conf`:

```conf
akka {
  actor {
    serializers {
      //cortex-schema-updater = "org.thp.thehive.connector.cortex.models.SchemaUpdaterSerializer"
      cortex-jobs = "org.thp.thehive.connector.cortex.services.CortexSerializer"
    }

    serialization-bindings {
      //"org.thp.thehive.connector.cortex.models.SchemaUpdaterMessage" = cortex-schema-updater
      "org.thp.thehive.connector.cortex.services.CortexActorMessage" = cortex-jobs
    }
  }
}

```

`cortex/connector/src/main/resources/reference.conf`:

```conf
# Cortex
# TheHive can connect to one or multiple Cortex instances. Give each
# Cortex instance a name and specify the associated URL.
#
# In order to use Cortex, first you need to enable the Cortex module by uncommenting the next line

#play.modules.enabled += connectors.cortex.CortexConnector

cortex = {
  # Check remote Cortex status time interval
  statusCheckInterval = 1 minute
  # Check job update time interval on cortex server instance
  refreshDelay = 5 second
  # Maximum number of successive errors before give up
  maxRetryOnError = 3
  # The client servers list
  servers = []
  //  servers = [{
  //    name = "local"
  //    url = "http://localhost:9001"
  //    key = "M36i01PbDHLSO4p3eqyceBNLQYiInD8/"
  //    # HTTP client configuration (SSL and proxy)
  //    #  ws {}
  //  }]
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/CortexModule.scala`:

```scala
package org.thp.thehive.connector.cortex

import com.google.inject.AbstractModule
import net.codingwell.scalaguice.{ScalaModule, ScalaMultibinder}
import org.thp.scalligraph.models.UpdatableSchema
import org.thp.scalligraph.query.QueryExecutor
import org.thp.thehive.connector.cortex.controllers.v0.{CortexQueryExecutor => CortexQueryExecutorV0}
import org.thp.thehive.connector.cortex.models.CortexSchemaDefinition
import org.thp.thehive.connector.cortex.services.notification.notifiers.{RunAnalyzerProvider, RunResponderProvider}
import org.thp.thehive.connector.cortex.services.{Connector, CortexActor}
import org.thp.thehive.services.notification.notifiers.NotifierProvider
import org.thp.thehive.services.{Connector => TheHiveConnector}
import play.api.libs.concurrent.AkkaGuiceSupport
import play.api.routing.{Router => PlayRouter}
import play.api.{Configuration, Environment, Logger}

class CortexModule(environment: Environment, configuration: Configuration) extends AbstractModule with ScalaModule with AkkaGuiceSupport {
  lazy val logger: Logger = Logger(getClass)

  override def configure(): Unit = {
    val routerBindings = ScalaMultibinder.newSetBinder[PlayRouter](binder)
    routerBindings.addBinding.toProvider[CortexRouter]
    val queryExecutorBindings = ScalaMultibinder.newSetBinder[QueryExecutor](binder)
    queryExecutorBindings.addBinding.to[CortexQueryExecutorV0]
    val connectorBindings = ScalaMultibinder.newSetBinder[TheHiveConnector](binder)
    connectorBindings.addBinding.to[Connector]
    val schemaBindings = ScalaMultibinder.newSetBinder[UpdatableSchema](binder)
    schemaBindings.addBinding.to[CortexSchemaDefinition]

    val notifierBindings = ScalaMultibinder.newSetBinder[NotifierProvider](binder)
    notifierBindings.addBinding.to[RunResponderProvider]
    notifierBindings.addBinding.to[RunAnalyzerProvider]

    bindActor[CortexActor]("cortex-actor")
    ()
  }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/CortexRouter.scala`:

```scala
package org.thp.thehive.connector.cortex

import org.thp.thehive.connector.cortex.controllers.v0
import play.api.Logger
import play.api.routing.Router

import javax.inject.{Inject, Provider, Singleton}

@Singleton
class CortexRouter @Inject() (routerV0: v0.Router) extends Provider[Router] {

  lazy val logger: Logger = Logger(getClass)
  lazy val get: Router    =
    //routerV1.withPrefix("/api/cortex/v1/") orElse
    routerV0.withPrefix("/api/connector/cortex/")
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/controllers/v0/ActionCtrl.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.connector.cortex.controllers.v0.Conversion._
import org.thp.thehive.connector.cortex.dto.v0.InputAction
import org.thp.thehive.connector.cortex.models.{Action, ActionContext, RichAction}
import org.thp.thehive.connector.cortex.services.ActionOps._
import org.thp.thehive.connector.cortex.services.{ActionSrv, EntityHelper}
import org.thp.thehive.controllers.v0.Conversion.{toObjectType, _}
import org.thp.thehive.controllers.v0._
import org.thp.thehive.models._
import org.thp.thehive.services._
import play.api.libs.json.{JsObject, Json, OWrites}
import play.api.mvc.{AnyContent, Results, Action => PlayAction}

import javax.inject.{Inject, Named, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.reflect.runtime.{universe => ru}

@Singleton
class ActionCtrl @Inject() (
    override val entrypoint: Entrypoint,
    override val db: Database,
    actionSrv: ActionSrv,
    entityHelper: EntityHelper,
    caseSrv: CaseSrv,
    taskSrv: TaskSrv,
    observableSrv: ObservableSrv,
    logSrv: LogSrv,
    alertSrv: AlertSrv,
    implicit val executionContext: ExecutionContext,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicAction
) extends AuditRenderer
    with QueryCtrl {

  implicit val entityWrites: OWrites[Entity] = OWrites[Entity] { entity =>
    db.roTransaction { implicit graph =>
      entity match {
        case c: Case       => caseToJson(caseSrv.get(c)).getOrFail("Case")
        case t: Task       => taskToJson(taskSrv.get(t)).getOrFail("Task")
        case o: Observable => observableToJson(observableSrv.get(o)).getOrFail("Observable")
        case l: Log        => logToJson(logSrv.get(l)).getOrFail("Log")
        case a: Alert      => alertToJson(alertSrv.get(a)).getOrFail("Alert")
      }
    }.getOrElse(Json.obj("_type" -> entity._label, "_id" -> entity._id))
  }

  def create: PlayAction[AnyContent] =
    entrypoint("create action")
      .extract("action", FieldsParser[InputAction])
      .asyncAuth { implicit request =>
        val action: InputAction = request.body("action")
        val tryEntity = db.roTransaction { implicit graph =>
          entityHelper.get(toObjectType(action.objectType), EntityIdOrName(action.objectId), Permissions.manageAction)
        }
        for {
          entity <- Future.fromTry(tryEntity)
          action <- actionSrv.execute(entity, action.cortexId, action.responderId, action.parameters.getOrElse(JsObject.empty))
        } yield Results.Ok(action.toJson)
      }

  def getByEntity(objectType: String, objectId: String): PlayAction[AnyContent] =
    entrypoint("get by entity")
      .authRoTransaction(db) { implicit request => implicit graph =>
        for {
          entity <- entityHelper.get(toObjectType(objectType), EntityIdOrName(objectId), Permissions.manageAction)
        } yield Results.Ok(actionSrv.listForEntity(entity._id).toJson)
      }
}

@Singleton
class PublicAction @Inject() (actionSrv: ActionSrv, organisationSrv: OrganisationSrv, db: Database) extends PublicData {

  override val entityName: String = "action"
  override val initialQuery: Query =
    Query.init[Traversal.V[Action]]("listAction", (graph, authContext) => actionSrv.startTraversal(graph).visible(organisationSrv)(authContext))
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Action]](
    "getAction",
    (idOrName, graph, authContext) => actionSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Action], IteratorOutput](
      "page",
      (range, actionSteps, _) => actionSteps.richPage(range.from, range.to, withTotal = true, limitedCountThreshold)(_.richAction)
    )
  override val outputQuery: Query = Query.output[RichAction, Traversal.V[Action]](_.richAction)
  val actionsQuery: Query = new Query {
    override val name: String = "actions"
    override def checkFrom(t: ru.Type): Boolean =
      SubType(t, ru.typeOf[Traversal.V[Case]]) ||
        SubType(t, ru.typeOf[Traversal.V[Observable]]) ||
        SubType(t, ru.typeOf[Traversal.V[Task]]) ||
        SubType(t, ru.typeOf[Traversal.V[Log]]) ||
        SubType(t, ru.typeOf[Traversal.V[Alert]])
    override def toType(t: ru.Type): ru.Type = ru.typeOf[Traversal.V[Action]]

    override def apply(param: Unit, fromType: ru.Type, from: Any, authContext: AuthContext): Any =
      from.asInstanceOf[Traversal.V[_]].in[ActionContext].v[Action]
  }

  override val extraQueries: Seq[ParamQuery[_]] = Seq(actionsQuery)
  override val publicProperties: PublicProperties =
    PublicPropertyListBuilder[Action]
      .property("responderId", UMapping.string)(_.field.readonly)
      .property("objectType", UMapping.string)(_.select(_.context.domainMap(o => fromObjectType(o._label))).readonly)
      .property("status", UMapping.string)(_.field.readonly)
      .property("startDate", UMapping.date)(_.field.readonly)
      .property("objectId", db.idMapping)(_.select(_.out[ActionContext]._id).readonly)
      .property("responderName", UMapping.string.optional)(_.field.readonly)
      .property("cortexId", UMapping.string.optional)(_.field.readonly)
      .property("tlp", UMapping.int.optional)(_.field.readonly)
      .build
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/controllers/v0/AnalyzerCtrl.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import akka.actor.ActorSystem
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.thehive.connector.cortex.controllers.v0.Conversion._
import org.thp.thehive.connector.cortex.services.AnalyzerSrv
import org.thp.thehive.controllers.v0.Conversion._
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.concurrent.ExecutionContext

@Singleton
class AnalyzerCtrl @Inject() (
    entrypoint: Entrypoint,
    analyzerSrv: AnalyzerSrv,
    implicit val system: ActorSystem,
    implicit val ec: ExecutionContext
) {

  def list: Action[AnyContent] =
    entrypoint("list analyzer")
      .extract("range", FieldsParser.string.optional.on("range"))
      .asyncAuth { implicit request =>
        val range: Option[String] = request.body("range")
        analyzerSrv
          .listAnalyzer(range)
          .map(analyzers => Results.Ok(analyzers.toSeq.toJson))
      }

  def listByType(dataType: String): Action[AnyContent] =
    entrypoint("list analyzer by dataType")
      .asyncAuth { implicit req =>
        analyzerSrv
          .listAnalyzerByType(dataType)
          .map(analyzers => Results.Ok(analyzers.toSeq.toJson))
      }

  def getById(id: String): Action[AnyContent] =
    entrypoint("get analyzer by id")
      .asyncAuth { implicit req =>
        analyzerSrv
          .getAnalyzer(id)
          .map(a => Results.Ok(a.toJson))
      }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/controllers/v0/AnalyzerTemplateCtrl.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import com.google.inject.name.Named
import org.thp.scalligraph.{EntityIdOrName, NotFoundError}
import org.thp.scalligraph.controllers.{Entrypoint, FFile, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.connector.cortex.controllers.v0.Conversion._
import org.thp.thehive.connector.cortex.dto.v0.InputAnalyzerTemplate
import org.thp.thehive.connector.cortex.models.AnalyzerTemplate
import org.thp.thehive.connector.cortex.services.AnalyzerTemplateOps._
import org.thp.thehive.connector.cortex.services.AnalyzerTemplateSrv
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.controllers.v0.{OutputParam, PublicData, QueryCtrl}
import org.thp.thehive.models.Permissions
import play.api.libs.json.{JsFalse, JsObject, JsTrue}
import play.api.mvc.{Action, AnyContent, Results}

import java.util.zip.ZipFile
import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success}

@Singleton
class AnalyzerTemplateCtrl @Inject() (
    override val entrypoint: Entrypoint,
    override val db: Database,
    analyzerTemplateSrv: AnalyzerTemplateSrv,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicAnalyzerTemplate
) extends QueryCtrl {

  def get(id: String): Action[AnyContent] =
    entrypoint("get content")
      .authTransaction(db) { _ => implicit graph =>
        analyzerTemplateSrv
          .getOrFail(EntityIdOrName(id))
          .map(report => Results.Ok(report.content))
          .recover {
            case _: NotFoundError => Results.NotFound(s"AnalyzerTemplate $id not found")
          }
      }

  def importTemplates: Action[AnyContent] =
    entrypoint("import templates")
      .extract("archive", FieldsParser.file.on("templates"))
      .auth { implicit request =>
        val archive: FFile = request.body("archive")
        val triedTemplates = analyzerTemplateSrv
          .importZipFile(db, new ZipFile(archive.filepath.toFile))
          .map {
            case (analyzerId, Success(_)) => analyzerId -> JsTrue
            case (analyzerId, Failure(e)) =>
              logger.error(s"Import of report template $analyzerId fails", e)
              analyzerId -> JsFalse
          }

        Success(Results.Ok(JsObject(triedTemplates)))
      }

  def create: Action[AnyContent] =
    entrypoint("create template")
      .extract("analyzerTemplate", FieldsParser[InputAnalyzerTemplate])
      .authPermittedTransaction(db, Permissions.manageAnalyzerTemplate) { implicit request => implicit graph =>
        val analyzerTemplate: InputAnalyzerTemplate = request.body("analyzerTemplate")
        analyzerTemplateSrv.create(analyzerTemplate.toAnalyzerTemplate).map { createdAnalyzerTemplate =>
          Results.Created(createdAnalyzerTemplate.toJson)
        }
      }

  def delete(id: String): Action[AnyContent] =
    entrypoint("delete template")
      .authPermittedTransaction(db, Permissions.manageAnalyzerTemplate) { implicit request => implicit graph =>
        analyzerTemplateSrv
          .get(EntityIdOrName(id))
          .getOrFail("AnalyzerTemplate")
          .map { analyzerTemplate =>
            analyzerTemplateSrv.remove(analyzerTemplate)
            Results.NoContent
          }
      }

  def update(id: String): Action[AnyContent] =
    entrypoint("update template")
      .extract("template", FieldsParser.update("template", publicData.publicProperties))
      .authPermittedTransaction(db, Permissions.manageAnalyzerTemplate) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("template")

        for {
          (templateSteps, _) <- analyzerTemplateSrv.update(_.get(EntityIdOrName(id)), propertyUpdaters)
          template           <- templateSteps.getOrFail("AnalyzerTemplate")
        } yield Results.Ok(template.toJson)

      }
}

@Singleton
class PublicAnalyzerTemplate @Inject() (analyzerTemplateSrv: AnalyzerTemplateSrv) extends PublicData {
  override val entityName: String = "analyzerTemplate"
  override val initialQuery: Query =
    Query.init[Traversal.V[AnalyzerTemplate]]("listAnalyzerTemplate", (graph, _) => analyzerTemplateSrv.startTraversal(graph))
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[AnalyzerTemplate]](
    "getReportTemplate",
    (idOrName, graph, _) => analyzerTemplateSrv.get(idOrName)(graph)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[AnalyzerTemplate], IteratorOutput](
      "page",
      (range, analyzerTemplateTraversal, _) => analyzerTemplateTraversal.page(range.from, range.to, withTotal = true, limitedCountThreshold)
    )
  override val outputQuery: Query = Query.output[AnalyzerTemplate with Entity]
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[AnalyzerTemplate]
    .property("analyzerId", UMapping.string)(_.rename("workerId").readonly)
    .property("reportType", UMapping.string)(_.field.readonly)
    .property("content", UMapping.string)(_.field.updatable)
    .build
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/controllers/v0/Conversion.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import io.scalaland.chimney.dsl._
import org.thp.cortex.dto.v0.{OutputWorker => CortexWorker}
import org.thp.scalligraph.controllers.Renderer
import org.thp.scalligraph.models.Entity
import org.thp.thehive.connector.cortex.dto.v0._
import org.thp.thehive.connector.cortex.models._
import org.thp.thehive.dto.v0.OutputObservable
import org.thp.thehive.models.{RichCase, RichObservable}
import play.api.libs.json.{JsArray, JsFalse, JsObject, Json}
object Conversion {
  import org.thp.thehive.controllers.v0.Conversion._

  implicit val actionOutput: Renderer.Aux[RichAction, OutputAction] = Renderer.toJson[RichAction, OutputAction](
    _.into[OutputAction]
      .withFieldRenamed(_.workerId, _.responderId)
      .withFieldRenamed(_.workerName, _.responderName)
      .withFieldRenamed(_.workerDefinition, _.responderDefinition)
      .withFieldComputed(_.status, _.status.toString)
      .withFieldComputed(_.objectId, _.context._id.toString)
      .withFieldComputed(_.objectType, _.context._label)
      .withFieldComputed(_.operations, a => JsArray(a.operations).toString)
      .withFieldComputed(_.report, _.report.map(_.toString).getOrElse("{}"))
      .enableMethodAccessors
      .transform
  )

  implicit val jobOutput: Renderer.Aux[RichJob, OutputJob] = Renderer.toJson[RichJob, OutputJob](job =>
    job
      .into[OutputJob]
      .withFieldComputed(_.analyzerId, _.workerId)
      .withFieldComputed(_.analyzerName, _.workerName)
      .withFieldComputed(_.analyzerDefinition, _.workerDefinition)
      .withFieldComputed(_.status, _.status.toString)
      .withFieldComputed(_.endDate, _.endDate)
      .withFieldComputed(_.cortexId, _.cortexId)
      .withFieldComputed(_.cortexJobId, _.cortexJobId)
      .withFieldComputed(
        _.report,
        j =>
          j.report.map {
            case r if j.status == JobStatus.Success => Json.obj("success" -> true, "full" -> r, "artifacts" -> j.observables.map(_.toJson))
            case r                                  => r + ("success" -> JsFalse)
          }
      )
      .withFieldComputed(_.id, _._id.toString)
      .withFieldConst(_._type, "case_artifact_job")
      .withFieldConst(_.case_artifact, None)
      .withFieldComputed(_.operations, a => JsArray(a.operations).toString)
      .enableMethodAccessors
      .transform
  )

  implicit val jobWithParentOutput: Renderer.Aux[(RichJob, Option[(RichObservable, RichCase)]), OutputJob] =
    Renderer.toJson[(RichJob, Option[(RichObservable, RichCase)]), OutputJob] { jobWithParent =>
      jobWithParent
        ._1
        .into[OutputJob]
        .withFieldComputed(_.analyzerId, _.workerId)
        .withFieldComputed(_.analyzerName, _.workerName)
        .withFieldComputed(_.analyzerDefinition, _.workerDefinition)
        .withFieldComputed(_.status, _.status.toString)
        .withFieldComputed(_.endDate, _.endDate)
        .withFieldComputed(_.cortexId, _.cortexId)
        .withFieldComputed(_.cortexJobId, _.cortexJobId)
        .withFieldComputed(
          _.report,
          j =>
            j.report.map {
              case r if j.status == JobStatus.Success => Json.obj("success" -> true, "full" -> r, "artifacts" -> j.observables.map(_.toJson))
              case r                                  => r + ("success" -> JsFalse)
            }
        )
        .withFieldComputed(_.id, _._id.toString)
        .withFieldConst(_._type, "case_artifact_job")
        .withFieldConst(
          _.case_artifact,
          jobWithParent._2.fold[Option[OutputObservable]](None) {
            case (richObservable, richCase) =>
              Some(observableWithExtraOutput.toValue((richObservable, JsObject.empty, Some(Left(richCase)))))
          }
        )
        .withFieldComputed(_.operations, a => JsArray(a.operations).toString)
        .enableMethodAccessors
        .transform
    }

  implicit val analyzerTemplateOutput: Renderer.Aux[AnalyzerTemplate with Entity, OutputAnalyzerTemplate] =
    Renderer.toJson[AnalyzerTemplate with Entity, OutputAnalyzerTemplate](at =>
      at.asInstanceOf[AnalyzerTemplate]
        .into[OutputAnalyzerTemplate]
        .withFieldComputed(_.analyzerId, _.workerId)
        .withFieldConst(_.id, at._id.toString)
        .withFieldComputed(_.content, _.content)
        .transform
    )

  implicit class InputAnalyzerTemplateOpsDefs(inputAnalyzerTemplate: InputAnalyzerTemplate) {

    def toAnalyzerTemplate: AnalyzerTemplate =
      inputAnalyzerTemplate
        .into[AnalyzerTemplate]
        .withFieldRenamed(_.analyzerId, _.workerId)
        .transform
  }

  implicit val workerOutput: Renderer.Aux[(CortexWorker, Seq[String]), OutputWorker] =
    Renderer.toJson[(CortexWorker, Seq[String]), OutputWorker](worker =>
      worker
        ._1
        .into[OutputWorker]
        .withFieldConst(_.cortexIds, worker._2)
        .transform
    )
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/controllers/v0/CortexQueryExecutor.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import org.scalactic.Good
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.FieldsParser
import org.thp.scalligraph.models._
import org.thp.scalligraph.query._
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.Traversal
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{BadRequestError, EntityIdOrName}
import org.thp.thehive.connector.cortex.models.Job
import org.thp.thehive.connector.cortex.services.JobOps._
import org.thp.thehive.controllers.v0._
import org.thp.thehive.models.Observable
import org.thp.thehive.services.ObservableOps._

import javax.inject.{Inject, Singleton}
import scala.reflect.runtime.{universe => ru}

@Singleton
class CortexQueryExecutor @Inject() (
    appConfig: ApplicationConfig,
    override val db: Database,
    job: PublicJob,
    report: PublicAnalyzerTemplate,
    action: PublicAction,
    analyzerTemplate: PublicAnalyzerTemplate
) extends QueryExecutor {
  lazy val controllers: List[PublicData] = action :: report :: job :: analyzerTemplate :: Nil

  val limitedCountThresholdConfig: ConfigItem[Long, Long] = appConfig.item[Long]("query.limitedCountThreshold", "Maximum number returned by a count")
  override val limitedCountThreshold: Long                = limitedCountThresholdConfig.get

  override lazy val publicProperties: PublicProperties = controllers.map(_.publicProperties).reduce(_ ++ _)

  override lazy val queries: Seq[ParamQuery[_]] =
    controllers.map(_.initialQuery) :::
      controllers.map(_.getQuery) :::
      controllers.map(_.pageQuery(limitedCountThreshold)) ::: // FIXME the value of limitedCountThreshold is read only once. The value is not updated.
      controllers.map(_.outputQuery) :::
      controllers.flatMap(_.extraQueries)

  val childTypes: PartialFunction[(ru.Type, String), ru.Type] = {
    case (tpe, "case_artifact_job") if SubType(tpe, ru.typeOf[Traversal.V[Observable]]) => ru.typeOf[Traversal.V[Observable]]
  }
  val parentTypes: PartialFunction[ru.Type, ru.Type] = {
    case tpe if SubType(tpe, ru.typeOf[Traversal.V[Job]]) => ru.typeOf[Traversal.V[Observable]]
  }

  override val customFilterQuery: FilterQuery = FilterQuery(publicProperties) { (tpe, globalParser) =>
    FieldsParser("parentChildFilter") {
      case (_, FObjOne("_parent", ParentIdFilter(parentId, _))) if parentTypes.isDefinedAt(tpe) =>
        Good(new CortexParentIdInputFilter(parentId))
      case (path, FObjOne("_parent", ParentQueryFilter(_, parentFilterField))) if parentTypes.isDefinedAt(tpe) =>
        globalParser(parentTypes(tpe)).apply(path, parentFilterField).map(query => new CortexParentQueryInputFilter(query))
      case (path, FObjOne("_child", ChildQueryFilter(childType, childQueryField))) if childTypes.isDefinedAt((tpe, childType)) =>
        globalParser(childTypes((tpe, childType))).apply(path, childQueryField).map(query => new CortexChildQueryInputFilter(childType, query))
    }
  }

  override val version: (Int, Int) = 0 -> 1
}

class CortexParentIdInputFilter(parentId: String) extends InputQuery[Traversal.Unk, Traversal.Unk] {
  override def apply(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Unk =
    if (traversalType =:= ru.typeOf[Traversal.V[Job]])
      traversal.asInstanceOf[Traversal.V[Job]].filter(_.observable.get(EntityIdOrName(parentId))).asInstanceOf[Traversal.Unk]
    else throw BadRequestError(s"$traversalType hasn't parent")
}

/**
  * The parent query parser traversing properly to appropriate parent
  *
  * @param parentFilter the query
  */
class CortexParentQueryInputFilter(parentFilter: InputQuery[Traversal.Unk, Traversal.Unk]) extends InputQuery[Traversal.Unk, Traversal.Unk] {
  override def apply(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Unk =
    if (traversalType =:= ru.typeOf[Traversal.V[Job]])
      traversal
        .asInstanceOf[Traversal.V[Job]]
        .filter { t =>
          parentFilter(publicProperties, ru.typeOf[Traversal.V[Observable]], t.observable.asInstanceOf[Traversal.Unk], authContext)
        }
        .asInstanceOf[Traversal.Unk]
    else throw BadRequestError(s"$traversalType hasn't parent")
}

class CortexChildQueryInputFilter(childType: String, childFilter: InputQuery[Traversal.Unk, Traversal.Unk])
    extends InputQuery[Traversal.Unk, Traversal.Unk] {
  override def apply(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Unk =
    if (traversalType =:= ru.typeOf[Traversal.V[Observable]] && childType == "case_artifact_job")
      traversal
        .asInstanceOf[Traversal.V[Observable]]
        .filter { t =>
          childFilter(publicProperties, ru.typeOf[Traversal.V[Job]], t.jobs.asInstanceOf[Traversal.Unk], authContext)
        }
        .asInstanceOf[Traversal.Unk]
    else throw BadRequestError(s"$traversalType hasn't child of type $childType")
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/controllers/v0/JobCtrl.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import com.google.inject.name.Named
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.scalligraph.{AuthorizationError, EntityIdOrName, ErrorHandler}
import org.thp.thehive.connector.cortex.controllers.v0.Conversion._
import org.thp.thehive.connector.cortex.models.{Job, RichJob}
import org.thp.thehive.connector.cortex.services.JobOps._
import org.thp.thehive.connector.cortex.services.JobSrv
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.controllers.v0.{OutputParam, PublicData, QueryCtrl}
import org.thp.thehive.models.{Observable, Permissions, RichCase, RichObservable}
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.ObservableSrv
import play.api.libs.json.JsObject
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class JobCtrl @Inject() (
    override val entrypoint: Entrypoint,
    override val db: Database,
    jobSrv: JobSrv,
    observableSrv: ObservableSrv,
    errorHandler: ErrorHandler,
    implicit val ec: ExecutionContext,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicJob
) extends QueryCtrl {
  def get(jobId: String): Action[AnyContent] =
    entrypoint("get job")
      .authRoTransaction(db) { implicit request => implicit graph =>
        jobSrv
          .get(EntityIdOrName(jobId))
          .visible
          .richJob
          .getOrFail("Job")
          .map(job => Results.Ok(job.toJson))
      }

  def create: Action[AnyContent] =
    entrypoint("create job")
      .extract("analyzerId", FieldsParser[String].on("analyzerId"))
      .extract("cortexId", FieldsParser[String].on("cortexId"))
      .extract("artifactId", FieldsParser[String].on("artifactId"))
      .extract("parameters", FieldsParser.jsObject.optional.on("parameters"))
      .asyncAuth { implicit request =>
        if (request.isPermitted(Permissions.manageAnalyse)) {
          val analyzerId: String           = request.body("analyzerId")
          val cortexId: String             = request.body("cortexId")
          val parameters: Option[JsObject] = request.body("parameters")
          db.roTransaction { implicit graph =>
            val artifactId: String = request.body("artifactId")
            for {
              o <- observableSrv.get(EntityIdOrName(artifactId)).can(Permissions.manageAnalyse).richObservable.getOrFail("Observable")
              c <- observableSrv.get(EntityIdOrName(artifactId)).`case`.getOrFail("Case")
            } yield (o, c)
          }.fold(
            error => errorHandler.onServerError(request, error),
            {
              case (o, c) =>
                jobSrv
                  .submit(cortexId, analyzerId, o, c, parameters.getOrElse(JsObject.empty))
                  .map(j => Results.Created(j.toJson))
            }
          )
        } else Future.failed(AuthorizationError("Job creation not allowed"))
      }
}

@Singleton
class PublicJob @Inject() (jobSrv: JobSrv) extends PublicData with JobRenderer {
  override val entityName: String = "job"
  override val initialQuery: Query =
    Query.init[Traversal.V[Job]]("listJob", (graph, authContext) => jobSrv.startTraversal(graph).visible(authContext))
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Job]](
    "getJob",
    (idOrName, graph, authContext) => jobSrv.get(idOrName)(graph).visible(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Job], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, _, withParents), jobSteps, authContext) if withParents > 0 =>
          jobSteps.richPage(from, to, withTotal = true, limitedCountThreshold)(_.richJobWithCustomRenderer(jobParents(_)(authContext))(authContext))
        case (range, jobSteps, authContext) =>
          jobSteps.richPage(range.from, range.to, withTotal = true, limitedCountThreshold)(
            _.richJob(authContext).domainMap((_, None: Option[(RichObservable, RichCase)]))
          )
      }
    )
  override val outputQuery: Query = Query.outputWithContext[RichJob, Traversal.V[Job]]((jobSteps, authContext) => jobSteps.richJob(authContext))
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[Observable], Traversal.V[Job]]("jobs", (observables, _) => observables.jobs)
  )
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[Job]
    .property("analyzerId", UMapping.string)(_.rename("workerId").readonly)
    .property("cortexId", UMapping.string.optional)(_.field.readonly)
    .property("startDate", UMapping.date)(_.field.readonly)
    .property("status", UMapping.string)(_.field.readonly)
    .property("analyzerDefinition", UMapping.string)(_.rename("workerDefinition").readonly)
    .build
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/controllers/v0/JobRenderer.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.connector.cortex.models.Job
import org.thp.thehive.connector.cortex.services.JobOps._
import org.thp.thehive.models.{RichCase, RichObservable}
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._

import java.util.{Map => JMap}

trait JobRenderer {
  def jobParents(traversal: Traversal.V[Job])(implicit
      authContext: AuthContext
  ): Traversal[Option[(RichObservable, RichCase)], JMap[String, Any], Converter[Option[(RichObservable, RichCase)], JMap[String, Any]]] =
    traversal.observable.project(_.by(_.richObservable).by(_.`case`.richCase)).domainMap(Some(_))
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/controllers/v0/ResponderCtrl.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.thehive.connector.cortex.controllers.v0.Conversion._
import org.thp.thehive.connector.cortex.services.ResponderSrv
import org.thp.thehive.controllers.v0.Conversion._
import play.api.libs.json.JsObject
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.concurrent.ExecutionContext

@Singleton
class ResponderCtrl @Inject() (
    entrypoint: Entrypoint,
    implicit val db: Database,
    responderSrv: ResponderSrv,
    implicit val ex: ExecutionContext
) {

  def getResponders(entityType: String, entityId: String): Action[AnyContent] =
    entrypoint("get responders")
      .asyncAuth { implicit req =>
        responderSrv
          .getRespondersByType(entityType, EntityIdOrName(entityId))
          .map(l => Results.Ok(l.toSeq.toJson))
      }

  def searchResponders: Action[AnyContent] =
    entrypoint("search responders")
      .extract("query", FieldsParser.jsObject)
      .asyncAuth { implicit req =>
        val query: JsObject = req.body("query")
        responderSrv
          .searchResponders(query)
          .map(l => Results.Ok(l.toSeq.toJson))
      }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/controllers/v0/Router.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import play.api.routing.Router.Routes
import play.api.routing.SimpleRouter
import play.api.routing.sird._

import javax.inject.{Inject, Singleton}

@Singleton
class Router @Inject() (
    val jobCtrl: JobCtrl,
    analyzerCtrl: AnalyzerCtrl,
    val actionCtrl: ActionCtrl,
    val reportCtrl: AnalyzerTemplateCtrl,
    responderCtrl: ResponderCtrl
) extends SimpleRouter {
  override def routes: Routes = {
    case GET(p"/job/$jobId<[^/]*>") => jobCtrl.get(jobId)
    case POST(p"/job/_search")      => jobCtrl.search
    case POST(p"/job/_stats")       => jobCtrl.stats
    case POST(p"/job")              => jobCtrl.create // Audit ok

    case POST(p"/action")                                    => actionCtrl.create // Audit ok
    case POST(p"/action/_search")                            => actionCtrl.search
    case POST(p"/action/_stats")                             => actionCtrl.stats
    case GET(p"/action")                                     => actionCtrl.search
    case GET(p"/action/$entityType<[^/]*>/$entityId<[^/]*>") => actionCtrl.getByEntity(entityType, entityId)

    case GET(p"/analyzer/template/content/$analyzerId<[^/]*>$x*") => reportCtrl.get(analyzerId)
    case POST(p"/analyzer/template/_import")                      => reportCtrl.importTemplates            // Audit ok
    case POST(p"/analyzer/template/_search")                      => reportCtrl.search
    case POST(p"/analyzer/template")                              => reportCtrl.create()                   // Audit ok
    case DELETE(p"/analyzer/template/$analyzerTemplateId<[^/]*>") => reportCtrl.delete(analyzerTemplateId) // Audit ok
    case GET(p"/analyzer/template/$analyzerTemplateId<[^/]*>")    => reportCtrl.get(analyzerTemplateId)
    case PATCH(p"/analyzer/template/$analyzerTemplateId<[^/]*>")  => reportCtrl.update(analyzerTemplateId) // Audit ok

    case GET(p"/report/template/content/$analyzerId<[^/]*>$x*") => reportCtrl.get(analyzerId)
    case POST(p"/report/template/_import")                      => reportCtrl.importTemplates            // Audit ok
    case POST(p"/report/template/_search")                      => reportCtrl.search
    case POST(p"/report/template")                              => reportCtrl.create()                   // Audit ok
    case DELETE(p"/report/template/$analyzerTemplateId<[^/]*>") => reportCtrl.delete(analyzerTemplateId) // Audit ok
    case GET(p"/report/template/$analyzerTemplateId<[^/]*>")    => reportCtrl.get(analyzerTemplateId)
    case PATCH(p"/report/template/$analyzerTemplateId<[^/]*>")  => reportCtrl.update(analyzerTemplateId) // Audit ok

    case GET(p"/analyzer/$analyzerId<[^/]*>")    => analyzerCtrl.getById(analyzerId)
    case GET(p"/analyzer")                       => analyzerCtrl.list
    case GET(p"/analyzer/type/$dataType<[^/]*>") => analyzerCtrl.listByType(dataType)

    case GET(p"/responder/$entityType<[^/]*>/$entityId<[^/]*>") => responderCtrl.getResponders(entityType, entityId)
    case POST(p"/responder/_search")                            => responderCtrl.searchResponders
  }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/models/Action.scala`:

```scala
package org.thp.thehive.connector.cortex.models

import org.apache.tinkerpop.gremlin.structure.{Edge, Vertex}
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.{Converter, Graph}
import org.thp.scalligraph.{BuildVertexEntity, EntityId}
import play.api.libs.json.JsObject

import java.util.Date

@BuildVertexEntity
case class Action(
    workerId: String,
    workerName: String,
    workerDefinition: String,
    status: JobStatus.Value,
    parameters: JsObject,
    startDate: Date,
    endDate: Option[Date],
    report: Option[JsObject],
    cortexId: String,
    cortexJobId: String,
    operations: Seq[JsObject]
)

case class RichAction(action: Action with Entity, context: Product with Entity) {
  def _id: EntityId             = action._id
  def _createdAt: Date          = action._createdAt
  def _createdBy: String        = action._createdBy
  def workerId: String          = action.workerId
  def workerName: String        = action.workerName
  def workerDefinition: String  = action.workerDefinition
  def status: JobStatus.Value   = action.status
  def startDate: Date           = action.startDate
  def endDate: Option[Date]     = action.endDate
  def report: Option[JsObject]  = action.report
  def cortexId: String          = action.cortexId
  def cortexJobId: String       = action.cortexJobId
  def operations: Seq[JsObject] = action.operations
}

case class ActionContext()

object ActionContext extends HasModel {

  override val model: Model.Edge[ActionContext] = new EdgeModel {
    override type E = ActionContext
    override val label: String                                = "ActionContext"
    override val indexes: Seq[(IndexType.Value, Seq[String])] = Nil

    override val fields: Map[String, Mapping[_, _, _]] = Map.empty
    override val converter: Converter[EEntity, Edge] = (element: Edge) =>
      new ActionContext with Entity {
        override val _id: EntityId              = EntityId(element.id())
        override val _label: String             = "ActionContext"
        override val _createdBy: String         = UMapping.string.getProperty(element, "_createdBy")
        override val _updatedBy: Option[String] = UMapping.string.optional.getProperty(element, "_updatedBy")
        override val _createdAt: Date           = UMapping.date.getProperty(element, "_createdAt")
        override val _updatedAt: Option[Date]   = UMapping.date.optional.getProperty(element, "_updatedAt")
      }
    override def addEntity(a: ActionContext, entity: Entity): EEntity =
      new ActionContext with Entity {
        override def _id: EntityId              = entity._id
        override def _label: String             = entity._label
        override def _createdBy: String         = entity._createdBy
        override def _updatedBy: Option[String] = entity._updatedBy
        override def _createdAt: Date           = entity._createdAt
        override def _updatedAt: Option[Date]   = entity._updatedAt
      }
    override def create(e: ActionContext, from: Vertex, to: Vertex)(implicit graph: Graph): Edge =
      from.addEdge(label, to)
  }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/models/ActionOperation.scala`:

```scala
package org.thp.thehive.connector.cortex.models

import play.api.libs.json._

/**
  * Base trait for all Action operations available
  */
trait ActionOperation

case class AddTagToCase(tag: String)                                  extends ActionOperation
case class AddTagToArtifact(tag: String)                              extends ActionOperation
case class CreateTask(title: String, description: String)             extends ActionOperation
case class AddCustomFields(name: String, tpe: String, value: JsValue) extends ActionOperation
case class CloseTask()                                                extends ActionOperation
case class MarkAlertAsRead()                                          extends ActionOperation
case class AddLogToTask(content: String, owner: Option[String])       extends ActionOperation
case class AddTagToAlert(tag: String)                                 extends ActionOperation
case class AddArtifactToCase(
    data: String,
    dataType: String,
    message: String,
    tlp: Option[Int],
    ioc: Option[Boolean],
    sighted: Option[Boolean],
    ignoreSimilarity: Option[Boolean],
    tags: Option[Seq[String]]
)                                    extends ActionOperation
case class AssignCase(owner: String) extends ActionOperation

object ActionOperation {
  val addTagToCaseFormat: OFormat[AddTagToCase]           = Json.format[AddTagToCase]
  val addTagToArtifactFormat: OFormat[AddTagToArtifact]   = Json.format[AddTagToArtifact]
  val createTaskFormat: OFormat[CreateTask]               = Json.format[CreateTask]
  val addCustomFieldsFormat: OFormat[AddCustomFields]     = Json.format[AddCustomFields]
  val addLogToTaskFormat: OFormat[AddLogToTask]           = Json.format[AddLogToTask]
  val addTagToAlertFormat: OFormat[AddTagToAlert]         = Json.format[AddTagToAlert]
  val addArtifactToCaseFormat: OFormat[AddArtifactToCase] = Json.format[AddArtifactToCase]
  val assignCaseFormat: OFormat[AssignCase]               = Json.format[AssignCase]

  implicit val actionOperationWrites: OWrites[ActionOperation] = OWrites[ActionOperation] { operation =>
    (operation match {
      case a: AddTagToCase      => addTagToCaseFormat.writes(a)
      case a: AddTagToArtifact  => addTagToArtifactFormat.writes(a)
      case a: CreateTask        => createTaskFormat.writes(a)
      case a: AddCustomFields   => addCustomFieldsFormat.writes(a)
      case _: CloseTask         => JsObject.empty
      case _: MarkAlertAsRead   => JsObject.empty
      case a: AddLogToTask      => addLogToTaskFormat.writes(a)
      case a: AddTagToAlert     => addTagToAlertFormat.writes(a)
      case a: AddArtifactToCase => addArtifactToCaseFormat.writes(a)
      case a: AssignCase        => assignCaseFormat.writes(a)
      case a                    => Json.obj("unsupported operation" -> a.toString)
    }) + ("type" -> JsString(operation.getClass.getSimpleName))
  }

  implicit val actionOperationReads: Reads[ActionOperation] = Reads[ActionOperation] { json =>
    (json \ "type").validate[String].flatMap {
      case "AddTagToCase"      => json.validate(addTagToCaseFormat)
      case "AddTagToArtifact"  => json.validate(addTagToArtifactFormat)
      case "CreateTask"        => json.validate(createTaskFormat)
      case "AddCustomFields"   => json.validate(addCustomFieldsFormat)
      case "CloseTask"         => JsSuccess(CloseTask())
      case "MarkAlertAsRead"   => JsSuccess(MarkAlertAsRead())
      case "AddLogToTask"      => json.validate(addLogToTaskFormat)
      case "AddTagToAlert"     => json.validate(addTagToAlertFormat)
      case "AddArtifactToCase" => json.validate(addArtifactToCaseFormat)
      case "AssignCase"        => json.validate(assignCaseFormat)
    }
  }
}

case class ActionOperationStatus(operation: ActionOperation, success: Boolean, message: String)

object ActionOperationStatus {
  implicit val writes: OWrites[ActionOperationStatus] = OWrites[ActionOperationStatus] { operationStatus =>
    Json.toJsObject(operationStatus.operation) +
      ("status"  -> JsString(if (operationStatus.success) "Success" else "Failure")) +
      ("message" -> JsString(operationStatus.message))
  }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/models/AnalyzerTemplate.scala`:

```scala
package org.thp.thehive.connector.cortex.models

import org.thp.scalligraph.BuildVertexEntity

@BuildVertexEntity
case class AnalyzerTemplate(workerId: String, content: String)

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/models/CortexSchemaDefinition.scala`:

```scala
package org.thp.thehive.connector.cortex.models

import org.reflections.Reflections
import org.reflections.scanners.SubTypesScanner
import org.reflections.util.ConfigurationBuilder
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.thehive.services.LocalUserSrv
import play.api.Logger

import javax.inject.{Inject, Singleton}
import scala.collection.JavaConverters._
import scala.reflect.runtime.{universe => ru}

@Singleton
class CortexSchemaDefinition @Inject() () extends Schema with UpdatableSchema {

  lazy val logger: Logger    = Logger(getClass)
  val operations: Operations = Operations("thehive-cortex").noop

  lazy val reflectionClasses = new Reflections(
    new ConfigurationBuilder()
      .forPackages("org.thp.thehive.connector.cortex.models")
      .addClassLoaders(getClass.getClassLoader)
      .setExpandSuperTypes(true)
      .setScanners(new SubTypesScanner(false))
  )

  override lazy val modelList: Seq[Model] = {
    val rm: ru.Mirror = ru.runtimeMirror(getClass.getClassLoader)
    reflectionClasses
      .getSubTypesOf(classOf[HasModel])
      .asScala
      .filterNot(c => java.lang.reflect.Modifier.isAbstract(c.getModifiers))
      .map(modelClass => rm.reflectModule(rm.classSymbol(modelClass).companion.companion.asModule).instance)
      .collect {
        case hasModel: HasModel =>
          logger.debug(s"Loading model ${hasModel.model.label}")
          hasModel.model
      }
      .toSeq
  }
  override val authContext: AuthContext = LocalUserSrv.getSystemAuthContext
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/models/Job.scala`:

```scala
package org.thp.thehive.connector.cortex.models

import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}
import org.thp.thehive.models.{Observable, RichObservable}
import play.api.libs.json.{Format, JsObject, Json}

import java.util.Date

object JobStatus extends Enumeration {
  val InProgress, Success, Failure, Waiting, Deleted = Value

  implicit val format: Format[JobStatus.Value] = Json.formatEnum(JobStatus)
}

@BuildEdgeEntity[Observable, Job]
case class ObservableJob()

@BuildEdgeEntity[Job, Observable]
case class ReportObservable()

@BuildVertexEntity
case class Job(
    workerId: String,
    workerName: String,
    workerDefinition: String,
    status: JobStatus.Value,
    startDate: Date,
    endDate: Date, // end date of the job or if it is not finished date of the last check
    report: Option[JsObject],
    cortexId: String,
    cortexJobId: String,
    operations: Seq[JsObject]
)

case class RichJob(
    job: Job with Entity,
    observables: Seq[(RichObservable, JsObject)]
) {
  def _id: EntityId              = job._id
  def _createdBy: String         = job._createdBy
  def _updatedBy: Option[String] = job._updatedBy
  def _createdAt: Date           = job._createdAt
  def _updatedAt: Option[Date]   = job._updatedAt
  def workerId: String           = job.workerId
  def workerName: String         = job.workerName
  def workerDefinition: String   = job.workerDefinition
  def status: JobStatus.Value    = job.status
  def startDate: Date            = job.startDate
  def endDate: Date              = job.endDate
  def report: Option[JsObject]   = job.report
  def cortexId: String           = job.cortexId
  def cortexJobId: String        = job.cortexJobId
  def operations: Seq[JsObject]  = job.operations
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/models/TheHiveCortexSchemaProvider.scala`:

```scala
package org.thp.thehive.connector.cortex.models

import org.thp.scalligraph.models.Schema
import org.thp.thehive.models.TheHiveSchemaDefinition

import javax.inject.{Inject, Provider, Singleton}

@Singleton
class TheHiveCortexSchemaProvider @Inject() (thehiveSchema: TheHiveSchemaDefinition, cortexSchema: CortexSchemaDefinition) extends Provider[Schema] {
  override lazy val get: Schema = thehiveSchema + cortexSchema
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/ActionOperationSrv.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{EntityIdOrName, InternalError}
import org.thp.thehive.connector.cortex.models._
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputTask
import org.thp.thehive.models._
import org.thp.thehive.services._
import play.api.Logger

import java.util.Date
import javax.inject.Inject
import scala.util.{Failure, Success, Try}

class ActionOperationSrv @Inject() (
    caseSrv: CaseSrv,
    observableSrv: ObservableSrv,
    taskSrv: TaskSrv,
    alertSrv: AlertSrv,
    logSrv: LogSrv,
    organisationSrv: OrganisationSrv,
    userSrv: UserSrv
) {
  private[ActionOperationSrv] lazy val logger: Logger = Logger(getClass)

  /**
    * Executes an operation from Cortex responder
    * report
    * @param entity the entity concerned by the operation
    * @param operation the operation to execute
    * @param relatedCase the related case if applicable
    * @param graph graph traversal
    * @param authContext auth for access check
    * @return
    */
  def execute(entity: Entity, operation: ActionOperation, relatedCase: Option[Case with Entity], relatedTask: Option[Task with Entity])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[ActionOperationStatus] = {

    def updateOperation(operation: ActionOperation) = ActionOperationStatus(operation, success = true, "Success")

    operation match {
      case AddTagToCase(tag) =>
        for {
          c <- relatedCase.fold[Try[Case with Entity]](Failure(InternalError("Unable to apply action AddTagToCase without case")))(Success(_))
          _ <- caseSrv.addTags(c, Set(tag))
        } yield updateOperation(operation)

      case AddTagToArtifact(tag) =>
        for {
          obs <- observableSrv.getOrFail(entity._id)
          _   <- observableSrv.addTags(obs, Set(tag))
        } yield updateOperation(operation)

      case CreateTask(title, description) =>
        for {
          case0 <- relatedCase.fold[Try[Case with Entity]](Failure(InternalError("Unable to apply action CreateTask without case")))(Success(_))
          _     <- caseSrv.createTask(case0, InputTask(title = title, description = Some(description)).toTask)
        } yield updateOperation(operation)

      case AddCustomFields(name, _, value) =>
        for {
          c <- relatedCase.fold[Try[Case with Entity]](Failure(InternalError("Unable to apply action AddCustomFields without case")))(Success(_))
          _ <- caseSrv.setOrCreateCustomField(c, EntityIdOrName(name), Some(value), None)
        } yield updateOperation(operation)

      case CloseTask() =>
        for {
          t <- relatedTask.fold[Try[Task with Entity]](Failure(InternalError("Unable to apply action CloseTask without task")))(Success(_))
          _ <-
            taskSrv
              .get(t)
              .update(_.status, TaskStatus.Completed)
              .update(_._updatedAt, Some(new Date))
              .update(_._updatedBy, Some(authContext.userId))
              .getOrFail("Task")
        } yield updateOperation(operation)

      case MarkAlertAsRead() =>
        entity._label match {
          case "Alert" => alertSrv.markAsRead(entity._id).map(_ => updateOperation(operation))
          case x       => Failure(new Exception(s"Wrong entity for MarkAlertAsRead: ${x.getClass}"))
        }

      case AddLogToTask(content, _) =>
        for {
          t <- relatedTask.fold[Try[Task with Entity]](Failure(InternalError("Unable to apply action AddLogToTask without task")))(Success(_))
          _ <- logSrv.create(Log(content, new Date()), t, None)
        } yield updateOperation(operation)

      case AddArtifactToCase(data, dataType, message, tlp, ioc, sighted, ignoreSimilarity, tags) =>
        for {
          c            <- relatedCase.fold[Try[Case with Entity]](Failure(InternalError("Unable to apply action AddArtifactToCase without case")))(Success(_))
          organisation <- organisationSrv.getOrFail(authContext.organisation)
          _ <- caseSrv.createObservable(
            c,
            Observable(
              message = Some(message),
              tlp = tlp.getOrElse(2),
              ioc = ioc.getOrElse(false),
              sighted = sighted.getOrElse(false),
              ignoreSimilarity = ignoreSimilarity,
              dataType = dataType,
              tags = tags.getOrElse(Nil),
              relatedId = c._id,
              organisationIds = Set(organisation._id)
            ),
            data
          )
        } yield updateOperation(operation)

      case AssignCase(owner) =>
        for {
          c <- relatedCase.fold[Try[Case with Entity]](Failure(InternalError("Unable to apply action AssignCase without case")))(Success(_))
          u <- userSrv.get(EntityIdOrName(owner)).getOrFail("User")
          _ <- caseSrv.unassign(c)
          _ <- caseSrv.assign(c, u)
        } yield updateOperation(operation)

      case AddTagToAlert(tag) =>
        entity._label match {
          case "Alert" => alertSrv.get(entity).getOrFail("Alert").flatMap(alertSrv.addTags(_, Set(tag)).map(_ => updateOperation(operation)))
          case x       => Failure(new Exception(s"Wrong entity for AddTagToAlert: ${x.getClass}"))
        }

      case x =>
        val m = s"ActionOperation ${x.toString} unknown"
        logger.error(m)
        Failure(new Exception(m))
    }
  } recover {
    case e =>
      logger.error("Operation execution fails", e)
      ActionOperationStatus(operation, success = false, e.getMessage)
  }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/ActionSrv.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import akka.actor.ActorRef
import com.google.inject.name.Named
import org.apache.tinkerpop.gremlin.structure.Element
import org.thp.cortex.client.CortexClient
import org.thp.cortex.dto.v0.{InputAction => CortexAction, OutputJob => CortexJob}
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.scalligraph.{EntityId, NotFoundError}
import org.thp.thehive.connector.cortex.controllers.v0.Conversion._
import org.thp.thehive.connector.cortex.models._
import org.thp.thehive.connector.cortex.services.ActionOps._
import org.thp.thehive.connector.cortex.services.Conversion._
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.{LogSrv, OrganisationSrv}
import play.api.libs.json.{JsObject, JsString, Json, OWrites}

import java.util.{Date, Map => JMap}
import javax.inject.Inject
import scala.concurrent.{ExecutionContext, Future}
import scala.util.Try

class ActionSrv @Inject() (
    @Named("cortex-actor") cortexActor: ActorRef,
    actionOperationSrv: ActionOperationSrv,
    entityHelper: EntityHelper,
    serviceHelper: ServiceHelper,
    logSrv: LogSrv,
    connector: Connector,
    db: Database,
    implicit val ec: ExecutionContext,
    auditSrv: CortexAuditSrv,
    organisationSrv: OrganisationSrv
) extends VertexSrv[Action] {

  val actionContextSrv = new EdgeSrv[ActionContext, Action, Product]

  /**
    * Executes an Action on user demand,
    * creates a job on Cortex side and then persist the
    * Action, looking forward job completion
    *
    * @param entity      the Entity to execute an Action upon
    * @param authContext necessary auth context
    * @return
    */
  def execute(entity: Product with Entity, cortexId: Option[String], workerId: String, parameters: JsObject)(implicit
      writes: OWrites[Entity],
      authContext: AuthContext
  ): Future[RichAction] = {
    val cortexClients = serviceHelper.availableCortexClients(connector.clients, authContext.organisation)
    for {
      client <- cortexId match {
        case Some(cortexId) =>
          cortexClients
            .find(_.name == cortexId)
            .fold[Future[CortexClient]](Future.failed(NotFoundError(s"Cortex $cortexId not found")))(Future.successful)
        case None if cortexClients.nonEmpty =>
          Future
            .traverse(cortexClients) { client =>
              client.getResponder(workerId).map(_ => Some(client)).recover { case _ => None }
            }
            .flatMap(
              _.flatten.headOption.fold[Future[CortexClient]](Future.failed(NotFoundError(s"Responder $workerId not found")))(Future.successful)
            )

        case None => Future.failed(NotFoundError(s"Responder $workerId not found"))
      }
      (label, tlp, pap) <- Future.fromTry(db.roTransaction(implicit graph => entityHelper.entityInfo(entity)))
      parametersWithRequesterInfo = db.roTransaction { implicit graph =>
        parameters +
          ("organisation" -> JsString(organisationSrv.current.value(_.name).head)) +
          ("user"         -> JsString(authContext.userId))
      }
      inputCortexAction =
        CortexAction(label, writes.writes(entity), s"thehive:${fromObjectType(entity._label)}", tlp, pap, parametersWithRequesterInfo)
      job <- client.execute(workerId, inputCortexAction)
      action = Action(
        job.workerId,
        job.workerName,
        job.workerDefinition,
        job.status.toJobStatus,
        parametersWithRequesterInfo,
        new Date,
        job.endDate,
        job.report.flatMap(_.full),
        client.name,
        job.id,
        Nil
      )
      createdAction <- Future.fromTry {
        db.tryTransaction { implicit graph =>
          for {
            richAction <- create(action, entity)
            auditContext = entity._label match {
              case "Log" => logSrv.get(entity).task.headOption.getOrElse(entity)
              case _     => entity
            }
            _ <- auditSrv.action.create(richAction.action, auditContext, richAction.toJson)
          } yield richAction
        }
      }
      _ = cortexActor ! CheckJob(None, job.id, Some(createdAction._id), client.name, authContext)
    } yield createdAction
  }

  /**
    * Creates an Action with necessary ActionContext edge
    *
    * @param action      the action to persist
    * @param context     the context Entity to link to
    * @param graph       graph needed for db queries
    * @param authContext auth for db queries
    * @return
    */
  def create(
      action: Action,
      context: Product with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[RichAction] =
    for {
      createdAction <- createEntity(action)
      _             <- actionContextSrv.create(ActionContext(), createdAction, context)
    } yield RichAction(createdAction, context)

  /**
    * Once the job is finished for a precise Action,
    * updates it
    *
    * @param actionId    the action to update
    * @param cortexJob   the result Cortex job
    * @param authContext context for db queries
    * @return
    */
  def finished(actionId: EntityId, cortexJob: CortexJob)(implicit authContext: AuthContext): Try[Action with Entity] =
    db.tryTransaction { implicit graph =>
      getByIds(actionId).richAction.getOrFail("Action").flatMap { action =>
        val operations: Seq[ActionOperationStatus] = cortexJob
          .report
          .fold[Seq[ActionOperation]](Nil)(_.operations.map(_.as[ActionOperation]))
          .map { operation =>
            actionOperationSrv
              .execute(
                action.context,
                operation,
                relatedCase(actionId),
                relatedTask(actionId)
              )
              .fold(t => ActionOperationStatus(operation, success = false, t.getMessage), identity)
          }
        val auditContext = action.context._label match {
          case "Log" => logSrv.get(action.context).task.headOption.getOrElse(action.context)
          case _     => action.context
        }

        getByIds(actionId)
          .update(_.status, cortexJob.status.toJobStatus)
          .update(_.report, cortexJob.report.map(r => Json.toJsObject(r.copy(operations = Nil))))
          .update(_.endDate, Some(new Date()))
          .update(_.operations, operations.map(o => Json.toJsObject(o)))
          .update(_._updatedAt, Some(new Date))
          .update(_._updatedBy, Some(authContext.userId))
          .getOrFail("Action")
          .map { updated =>
            auditSrv
              .action
              .update(
                updated,
                auditContext,
                Json.obj(
                  "status"        -> updated.status.toString,
                  "objectId"      -> action.context._id,
                  "objectType"    -> action.context._label,
                  "responderName" -> action.workerName
                )
              )

            updated
          }
      }
    }

  /**
    * Gets an optional related Case to the Action Entity
    * @param id action id
    * @param graph db graph
    * @return
    */
  def relatedCase(id: EntityId)(implicit graph: Graph): Option[Case with Entity] =
    for {
      richAction  <- startTraversal.getByIds(id).richAction.headOption
      relatedCase <- entityHelper.parentCase(richAction.context)
    } yield relatedCase

  def relatedTask(id: EntityId)(implicit graph: Graph): Option[Task with Entity] =
    for {
      richAction  <- startTraversal.getByIds(id).richAction.headOption
      relatedTask <- entityHelper.parentTask(richAction.context)
    } yield relatedTask

  // TODO to be tested
  def listForEntity(id: EntityId)(implicit graph: Graph): Seq[RichAction] = startTraversal.forEntity(id).richAction.toSeq
}

object ActionOps {

  implicit class ActionOpsDefs(traversal: Traversal.V[Action]) {

    /**
      * Provides a RichAction model with additional Entity context
      *
      * @return
      */
    def richAction: Traversal[RichAction, JMap[String, Any], Converter[RichAction, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.out[ActionContext].entity)
        )
        .domainMap {
          case (action, context) =>
            RichAction(action, context)
        }

    def forEntity(entityId: EntityId): Traversal.V[Action] =
      traversal.filter(_.out[ActionContext].hasId(entityId))

    def context: Traversal[Product with Entity, Element, Converter[Product with Entity, Element]] = traversal.out[ActionContext].entity

    def visible(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Action] =
      traversal.filter(
        _.out[ActionContext]
          .chooseBranch[String, Any](
            _.on(_.label)
              .option("Case", _.v[Case].visible(organisationSrv).widen[Any])
              .option("Task", _.v[Task].visible(organisationSrv).widen[Any])
              .option("Log", _.v[Log].visible(organisationSrv).widen[Any])
              .option("Alert", _.v[Alert].visible(organisationSrv).widen[Any])
              .option("Observable", _.v[Observable].visible(organisationSrv).widen[Any])
          )
      )
  }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/AnalyzerSrv.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.cortex.dto.v0.{OutputWorker => CortexWorker}
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.{EntityIdOrName, NotFoundError}
import play.api.Logger
import play.api.libs.json.{JsObject, Json}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success}

@Singleton
class AnalyzerSrv @Inject() (connector: Connector, serviceHelper: ServiceHelper, implicit val ec: ExecutionContext) {

  lazy val logger: Logger = Logger(getClass)

  /**
    * Lists the Cortex analyzers from all CortexClients
    *
    * @return
    */
  def listAnalyzer(range: Option[String])(implicit authContext: AuthContext): Future[Map[CortexWorker, Seq[String]]] =
    Future
      .traverse(serviceHelper.availableCortexClients(connector.clients, authContext.organisation)) { client =>
        client
          .listAnalyser(range)
          .transform {
            case Success(analyzers) => Success(analyzers.map(_ -> client.name))
            case Failure(error) =>
              logger.error(s"List Cortex analyzers fails on ${client.name}", error)
              Success(Nil)
          }
      }
      .map(serviceHelper.flattenList)

  def listAnalyzerByType(dataType: String)(implicit authContext: AuthContext): Future[Map[CortexWorker, Seq[String]]] =
    Future
      .traverse(serviceHelper.availableCortexClients(connector.clients, authContext.organisation)) { client =>
        client
          .listAnalyzersByType(dataType)
          .transform {
            case Success(analyzers) => Success(analyzers.map(_ -> client.name))
            case Failure(error) =>
              logger.error(s"List Cortex analyzers by dataType fails on ${client.name}", error)
              Success(Nil)
          }
      }
      .map(serviceHelper.flattenList)

  def getAnalyzer(id: String)(implicit authContext: AuthContext): Future[(CortexWorker, Seq[String])] =
    Future
      .traverse(serviceHelper.availableCortexClients(connector.clients, authContext.organisation)) { client =>
        client
          .getAnalyzer(id)
          .map(_ -> client.name)
      }
      .flatMap { analyzerByClients =>
        analyzerByClients     // Seq[(worker, cortexId)]
          .groupBy(_._1.name) // Map[CortexId, Seq[(worker, cortexId)]]
          .values             // Seq[Seq[(worker, cortexId)]]
          .map(a => a.head._1 -> a.map(_._2).toSeq) // Map[worker, Seq[CortexId]]
          .headOption
          .fold[Future[(CortexWorker, Seq[String])]](Future.failed(NotFoundError(s"Analyzer $id not found")))(Future.successful)
      }

  def getAnalyzerByName(analyzerName: String, organisation: EntityIdOrName): Future[Map[CortexWorker, Seq[String]]] =
    searchAnalyzers(Json.obj("query" -> Json.obj("_field" -> "name", "_value" -> analyzerName)), organisation)

  def searchAnalyzers(query: JsObject)(implicit authContext: AuthContext): Future[Map[CortexWorker, Seq[String]]] =
    searchAnalyzers(query, authContext.organisation)

  def searchAnalyzers(query: JsObject, organisation: EntityIdOrName): Future[Map[CortexWorker, Seq[String]]] =
    Future
      .traverse(serviceHelper.availableCortexClients(connector.clients, organisation)) { client =>
        client
          .searchResponders(query)
          .transform {
            case Success(analyzers) => Success(analyzers.map(_ -> client.name))
            case Failure(error) =>
              logger.error(s"List Cortex analyzers fails on ${client.name}", error)
              Success(Nil)
          }
      }
      .map(serviceHelper.flattenList)
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/AnalyzerTemplateSrv.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.scalligraph.{CreateError, EntityIdOrName, EntityName}
import org.thp.thehive.connector.cortex.controllers.v0.Conversion._
import org.thp.thehive.connector.cortex.models.AnalyzerTemplate
import org.thp.thehive.connector.cortex.services.AnalyzerTemplateOps._
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.services.OrganisationSrv
import play.api.libs.json.{JsObject, Json}

import java.util.Date
import java.util.zip.{ZipEntry, ZipFile}
import javax.inject.{Inject, Singleton}
import scala.collection.JavaConverters._
import scala.io.Source
import scala.util.{Failure, Try}

@Singleton
class AnalyzerTemplateSrv @Inject() (
    auditSrv: CortexAuditSrv,
    organisationSrv: OrganisationSrv
) extends VertexSrv[AnalyzerTemplate] {

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[AnalyzerTemplate] =
    startTraversal.getByAnalyzerId(name)

  def readZipEntry(file: ZipFile, entry: ZipEntry): Try[String] =
    Try {
      val stream = file.getInputStream(entry)
      try Source.fromInputStream(stream).mkString
      finally stream.close()
    }

  def create(analyzerTemplate: AnalyzerTemplate)(implicit graph: Graph, authContext: AuthContext): Try[AnalyzerTemplate with Entity] =
    if (startTraversal.getByAnalyzerId(analyzerTemplate.workerId).exists)
      Failure(CreateError(s"Analyzer template for ${analyzerTemplate.workerId} already exists"))
    else
      for {
        created <- createEntity(analyzerTemplate)
        _       <- auditSrv.analyzerTemplate.create(created, created.toJson)
      } yield created

  override def update(
      traversal: Traversal.V[AnalyzerTemplate],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[AnalyzerTemplate], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (analyzerTemplateSteps, updatedFields) =>
        analyzerTemplateSteps
          .clone()
          .getOrFail("AnalyzerTemplate")
          .flatMap(auditSrv.analyzerTemplate.update(_, updatedFields))
    }

  def remove(analyzerTemplate: AnalyzerTemplate with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    organisationSrv.getOrFail(authContext.organisation).flatMap { organisation =>
      get(analyzerTemplate).remove()
      auditSrv.analyzerTemplate.delete(analyzerTemplate, organisation)
    }

  /**
    * Creates or updates if found templates contained in a zip file
    *
    * @param db          needed database connection
    * @param file        the zip file
    * @param authContext needed auth context for db query
    * @return
    */
  def importZipFile(db: Database, file: ZipFile)(implicit authContext: AuthContext): Map[String, Try[AnalyzerTemplate with Entity]] =
    file
      .entries
      .asScala
      .filterNot(_.isDirectory)
      .toSeq
      .groupBy(_.getName.takeWhile(c => c != '/' && c != '.'))
      .flatMap {
        case (name, entries) if entries.lengthCompare(1) == 0 => List(name -> entries.head)
        case (name, entries)                                  => entries.filterNot(_.getName.endsWith("short.html")).headOption.map(name -> _)
      }
      .foldLeft(Map.empty[String, Try[AnalyzerTemplate with Entity]]) {
        case (templateMap, (analyzerId, _)) if templateMap.contains(analyzerId) => templateMap
        case (templateMap, (analyzerId, entry)) =>
          val analyzerTemplate = readZipEntry(file, entry)
            .flatMap { content =>
              db.tryTransaction { implicit graph =>
                (for {
                  updated <- get(EntityName(analyzerId))
                    .update(_.content, content)
                    .update(_._updatedAt, Some(new Date))
                    .update(_._updatedBy, Some(authContext.userId))
                    .getOrFail("AnalyzerTemplate")
                  _ <- auditSrv.analyzerTemplate.update(updated, Json.obj("content" -> content))
                } yield updated).recoverWith {
                  case _ =>
                    for {
                      created <- create(AnalyzerTemplate(analyzerId, content))
                      _       <- auditSrv.analyzerTemplate.create(created, created.toJson)
                    } yield created
                }
              }
            }
          templateMap + (analyzerId -> analyzerTemplate)
      }
}

object AnalyzerTemplateOps {
  implicit class AnalyzerTemplateOpsDefs(traversal: Traversal.V[AnalyzerTemplate]) {

    def get(idOrAnalyzerId: EntityIdOrName): Traversal.V[AnalyzerTemplate] =
      idOrAnalyzerId.fold(traversal.getByIds(_), getByAnalyzerId)

    /**
      * Looks for a template that has the workerId supplied
      *
      * @param workerId the id to look for
      * @return
      */
    def getByAnalyzerId(workerId: String): Traversal.V[AnalyzerTemplate] = traversal.has(_.workerId, workerId)
  }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/Connector.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import akka.actor.ActorSystem
import akka.stream.Materializer
import org.thp.cortex.client.{CortexClient, CortexClientConfig}
import org.thp.scalligraph.services.config.ApplicationConfig.finiteDurationFormat
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.thehive.models.HealthStatus
import org.thp.thehive.services.{Connector => TheHiveConnector}
import play.api.libs.json.{JsObject, Json}

import javax.inject.{Inject, Singleton}
import scala.concurrent.duration.FiniteDuration
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success}

@Singleton
class Connector @Inject() (
    appConfig: ApplicationConfig,
    mat: Materializer,
    implicit val system: ActorSystem,
    implicit val ec: ExecutionContext
) extends TheHiveConnector {
  override val name: String = "cortex"

  val clientsConfig: ConfigItem[Seq[CortexClientConfig], Seq[CortexClient]] =
    appConfig.mapItem[Seq[CortexClientConfig], Seq[CortexClient]]("cortex.servers", "", _.map(new CortexClient(_, mat, ec)))
  def clients: Seq[CortexClient]                                     = clientsConfig.get
  val refreshDelayConfig: ConfigItem[FiniteDuration, FiniteDuration] = appConfig.item[FiniteDuration]("cortex.refreshDelay", "")
  def refreshDelay: FiniteDuration                                   = refreshDelayConfig.get
  val maxRetryOnErrorConfig: ConfigItem[Int, Int]                    = appConfig.item[Int]("cortex.maxRetryOnError", "")
  def maxRetryOnError: Int                                           = maxRetryOnErrorConfig.get

  val statusCheckIntervalConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("cortex.statusCheckInterval", "Interval between two checks of cortex status")
  def statusCheckInterval: FiniteDuration = statusCheckIntervalConfig.get
  var cachedHealth: HealthStatus.Value    = HealthStatus.Ok
  override def health: HealthStatus.Value = cachedHealth
  var cachedStatus: JsObject              = JsObject.empty
  override def status: JsObject           = cachedStatus

  protected def updateHealth(): Unit =
    Future
      .traverse(clients)(_.getHealth)
      .foreach { healthStatus =>
        val distinctStatus = healthStatus.toSet.map(HealthStatus.withName)
        cachedHealth =
          if (distinctStatus.contains(HealthStatus.Ok))
            if (distinctStatus.size > 1) HealthStatus.Warning else HealthStatus.Ok
          else if (distinctStatus.contains(HealthStatus.Error)) HealthStatus.Error
          else HealthStatus.Warning

        system.scheduler.scheduleOnce(statusCheckInterval)(updateHealth())
      }
  updateHealth()

  protected def updateStatus(): Unit =
    Future
      .traverse(clients) { client =>
        client.getVersion.transformWith {
          case Success(version) =>
            client.getCurrentUser.transform {
              case _: Success[_] => Success((client.name, version, "OK"))
              case _: Failure[_] => Success((client.name, version, "AUTH_ERROR"))
            }
          case _: Failure[_] => Future.successful((client.name, "", "ERROR"))
        }
      }
      .foreach { statusDetails =>
        val distinctStatus = statusDetails.map(_._3).toSet
        val healthStatus =
          if (distinctStatus.contains("OK"))
            if (distinctStatus.size > 1) "WARNING" else "OK"
          else "ERROR"

        cachedStatus = Json.obj(
          "enabled" -> true,
          "status"  -> healthStatus,
          "servers" -> statusDetails.map {
            case (n, v, s) => Json.obj("name" -> n, "version" -> v, "status" -> s)
          }
        )

        system.scheduler.scheduleOnce(statusCheckInterval)(updateStatus())
      }
  updateStatus()
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/Conversion.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import io.scalaland.chimney.dsl._
import org.thp.cortex.dto.v0.{OutputArtifact, OutputMinireport, JobStatus => CortexJobStatus}
import org.thp.scalligraph.EntityId
import org.thp.thehive.connector.cortex.models.JobStatus
import org.thp.thehive.models.{Observable, ReportTag, ReportTagLevel}

object Conversion {

  implicit class CortexJobStatusOps(jobStatus: CortexJobStatus.Value) {

    def toJobStatus: JobStatus.Value =
      jobStatus match {
        case CortexJobStatus.Failure    => JobStatus.Failure
        case CortexJobStatus.InProgress => JobStatus.InProgress
        case CortexJobStatus.Success    => JobStatus.Success
        case CortexJobStatus.Waiting    => JobStatus.Waiting
        case CortexJobStatus.Deleted    => JobStatus.Deleted
      }
  }

  implicit class CortexOutputArtifactOps(artifact: OutputArtifact) {

    def toObservable(
        relatedId: EntityId,
        organisations: Set[EntityId]
    ): Observable =
      artifact
        .into[Observable]
        .withFieldComputed(_.message, _.message)
        .withFieldComputed(_.tlp, _.tlp)
        .withFieldConst(_.ioc, false)
        .withFieldConst(_.sighted, false)
        .withFieldConst(_.ignoreSimilarity, None)
        .withFieldConst(_.data, None)
        .withFieldComputed(_.tags, _.tags.toSeq)
        .withFieldConst(_.relatedId, relatedId)
        .withFieldConst(_.organisationIds, organisations)
        .transform
  }

  implicit class CortexAnalyzerTagOps(outputAnalyzerTag: OutputMinireport) {

    def toAnalyzerTag(analyzerName: String): ReportTag =
      outputAnalyzerTag
        .into[ReportTag]
        .withFieldConst(_.origin, analyzerName)
        .withFieldComputed(_.level, t => ReportTagLevel.withName(t.level))
        .transform
  }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/CortexActor.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import akka.actor._
import akka.pattern.pipe
import org.thp.client.ApplicationError
import org.thp.cortex.dto.v0.{JobStatus, JobType, OutputJob}
import org.thp.scalligraph.EntityId
import org.thp.scalligraph.auth.AuthContext
import play.api.Logger

import java.util.Date
import javax.inject.Inject
import scala.concurrent.ExecutionContext
import scala.concurrent.duration._

sealed trait CortexActorMessage
case class RemoteJob(job: OutputJob) extends CortexActorMessage
case class CheckJob(
    jobId: Option[EntityId],
    cortexJobId: String,
    actionId: Option[EntityId],
    cortexId: String,
    authContext: AuthContext
) extends CortexActorMessage

private case object CheckJobs extends CortexActorMessage
private case object CheckJobsKey
private case object FirstCheckJobs extends CortexActorMessage
// FIXME Add serializer
/**
  * This actor is primarily used to check Job statuses on regular
  * ticks using the provided client for each job
  */
class CortexActor @Inject() (connector: Connector, jobSrv: JobSrv, actionSrv: ActionSrv) extends Actor with Timers {
  implicit val ec: ExecutionContext = context.dispatcher
  lazy val logger: Logger           = Logger(getClass)

  def receive: Receive = receive(Nil, 0)

  private def receive(checkedJobs: List[CheckJob], failuresCount: Int): Receive = {
    case FirstCheckJobs =>
      logger.debug(s"CortexActor starting check jobs ticking every ${connector.refreshDelay}")
      timers.startTimerAtFixedRate(CheckJobsKey, CheckJobs, connector.refreshDelay)

    case cj @ CheckJob(jobId, cortexJobId, actionId, cortexId, _) =>
      logger.info(s"CortexActor received job or action (${jobId.getOrElse(actionId.get)}, $cortexJobId, $cortexId) to check, added to $checkedJobs")
      if (!timers.isTimerActive(CheckJobsKey))
        timers.startSingleTimer(CheckJobsKey, FirstCheckJobs, 500.millis)
      context.become(receive(cj :: checkedJobs, failuresCount))

    case CheckJobs if checkedJobs.isEmpty =>
      logger.debug("CortexActor has empty checkedJobs state, stopping ticks")
      timers.cancel(CheckJobsKey)

    case CheckJobs =>
      checkedJobs
        .foreach {
          case CheckJob(_, cortexJobId, _, cortexId, _) =>
            connector
              .clients
              .find(_.name == cortexId)
              .fold(logger.error(s"Receive a CheckJob for an unknown cortexId: $cortexId")) { client =>
                client
                  .getReport(cortexJobId, 1.second)
                  .recover { // this is a workaround for a timeout bug in Cortex
                    case ApplicationError(500, body) if (body \ "type").asOpt[String].contains("akka.pattern.AskTimeoutException") =>
                      OutputJob(cortexJobId, "", "", "", new Date, None, None, JobStatus.InProgress, None, None, "", "", None, JobType.analyzer)
                  }
                  .map(RemoteJob)
                  .pipeTo(self)
                ()
              }
        }

    case RemoteJob(job) if job.status == JobStatus.Success || job.status == JobStatus.Failure =>
      checkedJobs.find(_.cortexJobId == job.id) match {
        case Some(CheckJob(Some(jobId), cortexJobId, _, cortexId, authContext)) if job.`type` == JobType.analyzer =>
          logger.info(s"Job $cortexJobId in cortex $cortexId has finished with status ${job.status}, updating job $jobId")
          jobSrv.finished(cortexId, jobId, job)(authContext)
          context.become(receive(checkedJobs.filterNot(_.cortexJobId == job.id), failuresCount))

        case Some(CheckJob(_, cortexJobId, Some(actionId), cortexId, authContext)) if job.`type` == JobType.responder =>
          logger.info(s"Job $cortexJobId in cortex $cortexId has finished with status ${job.status}, updating action $actionId")
          actionSrv.finished(actionId, job)(authContext)
          context.become(receive(checkedJobs.filterNot(_.cortexJobId == job.id), failuresCount))

        case Some(_) =>
          logger.error(s"CortexActor received job output $job but with unknown type ${job.`type`}")

        case None =>
          logger.error(s"CortexActor received job output $job but did not have it in state $checkedJobs")
      }
    case RemoteJob(job) if job.status == JobStatus.InProgress || job.status == JobStatus.Waiting =>
      logger.info(s"CortexActor received ${job.status} from client, retrying in ${connector.refreshDelay}")

    case _: RemoteJob =>
      logger.warn(s"CortexActor received JobStatus.Unknown from client, retrying in ${connector.refreshDelay}")

    case Status.Failure(e) if failuresCount < connector.maxRetryOnError =>
      logger.error(
        s"CortexActor received ${failuresCount + 1} failure(s), last: ${e.getMessage}, " +
          s"retrying again ${connector.maxRetryOnError - failuresCount} time(s)"
      )
      context.become(receive(checkedJobs, failuresCount + 1))

    // TODO handle failure propagation on job or action side and 404 responses
    case Status.Failure(e) =>
      logger.error(s"CortexActor received $failuresCount failures, last: ${e.getMessage}, stopping ticks")
      timers.cancelAll()

    case x => logger.error(s"CortexActor received unhandled message ${x.toString}")
  }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/CortexAuditSrv.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import akka.actor.ActorRef
import com.google.inject.Singleton
import com.google.inject.name.Named
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services.EventSrv
import org.thp.thehive.connector.cortex.models.{Action, AnalyzerTemplate, Job}
import org.thp.thehive.models.Observable
import org.thp.thehive.services.{AuditSrv, UserSrv}

import javax.inject.{Inject, Provider}

@Singleton
class CortexAuditSrv @Inject() (
    userSrvProvider: Provider[UserSrv],
    @Named("notification-actor") notificationActor: ActorRef,
    eventSrv: EventSrv,
    db: Database
) extends AuditSrv(userSrvProvider, notificationActor, eventSrv, db) {

  val job              = new ObjectAudit[Job, Observable]
  val action           = new ObjectAudit[Action, Product with Entity]
  val analyzerTemplate = new SelfContextObjectAudit[AnalyzerTemplate]

}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/CortexSerializer.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import akka.serialization.Serializer
import org.thp.cortex.dto.v0.OutputJob
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.auth.{AuthContext, AuthContextImpl, Permission}
import play.api.libs.functional.syntax._
import play.api.libs.json._

import java.io.NotSerializableException

object CortexSerializer {
  implicit val authContextReads: Reads[AuthContext] =
    ((JsPath \ "userId").read[String] and
      (JsPath \ "userName").read[String] and
      (JsPath \ "organisation").read[String].map(EntityIdOrName.apply) and
      (JsPath \ "requestId").read[String] and
      (JsPath \ "permissions").read[Set[String]].map(Permission.apply))(AuthContextImpl.apply _)

  implicit val authContextWrites: Writes[AuthContext] = Writes[AuthContext] { authContext =>
    Json.obj(
      "userId"       -> authContext.userId,
      "userName"     -> authContext.userName,
      "organisation" -> authContext.organisation.toString,
      "requestId"    -> authContext.requestId,
      "permissions"  -> authContext.permissions
    )
  }
  implicit val format: OFormat[CheckJob] = Json.format[CheckJob]
}

class CortexSerializer extends Serializer {
  import CortexSerializer._
  override def identifier: Int = -414525848

  override def includeManifest: Boolean = false

  override def toBinary(o: AnyRef): Array[Byte] =
    o match {
      case CheckJobs      => Array(0)
      case FirstCheckJobs => Array(1)
      case RemoteJob(job) => 2.toByte +: Json.toJson(job).toString.getBytes
      case cj: CheckJob   => 3.toByte +: Json.toJson(cj).toString().getBytes
      case _              => throw new NotSerializableException
    }

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef =
    bytes(0) match {
      case 0 => CheckJobs
      case 1 => FirstCheckJobs
      case 2 => RemoteJob(Json.parse(bytes.tail).as[OutputJob])
      case 3 => Json.parse(bytes.tail).as[CheckJob]
      case _ => throw new NotSerializableException
    }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/EntityHelper.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{BadRequestError, EntityIdOrName}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services._
import play.api.Logger

import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Try}

@Singleton
class EntityHelper @Inject() (
    taskSrv: TaskSrv,
    caseSrv: CaseSrv,
    alertSrv: AlertSrv,
    observableSrv: ObservableSrv,
    logSrv: LogSrv,
    organisationSrv: OrganisationSrv
) {

  lazy val logger: Logger = Logger(getClass)

  /**
    * Gets an entity from name and id if manageable
    *
    * @param objectType entity name
    * @param objectId entity id
    * @param permission the permission to use for access right
    * @param graph graph db
    * @param authContext auth for permission check
    * @return
    */
  def get(objectType: String, objectId: EntityIdOrName, permission: Permission)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Product with Entity] =
    objectType match {
      case "Task"       => taskSrv.get(objectId).can(permission).getOrFail("Task")
      case "Case"       => caseSrv.get(objectId).can(permission).getOrFail("Case")
      case "Observable" => observableSrv.get(objectId).can(permission).getOrFail("Observable")
      case "Log"        => logSrv.get(objectId).can(permission).getOrFail("Log")
      case "Alert"      => alertSrv.get(objectId).can(organisationSrv, permission).getOrFail("Alert")
      case _            => Failure(BadRequestError(s"objectType $objectType is not recognised"))
    }

  /**
    * Retrieves an optional parent Case
    * @param entity the child entity
    * @param graph db traversal
    * @return
    */
  def parentCase(entity: Entity)(implicit graph: Graph): Option[Case with Entity] =
    entity._label match {
      case "Task"       => taskSrv.get(entity).`case`.headOption
      case "Case"       => caseSrv.get(entity).headOption
      case "Observable" => observableSrv.get(entity).`case`.headOption
      case "Log"        => logSrv.get(entity).`case`.headOption
      case "Alert"      => None
      case _            => None
    }

  /**
    * Retrieves an optional parent Task
    * @param entity the child entity
    * @param graph db traversal
    * @return
    */
  def parentTask(entity: Entity)(implicit graph: Graph): Option[Task with Entity] =
    entity._label match {
      case "Log" => logSrv.get(entity).task.headOption
      case _     => None
    }

  /**
    * Tries to fetch the tlp and pap associated to the supplied entity
    *
    * @param entity the entity to retrieve
    * @param graph the necessary traversal graph
    * @param authContext the auth context for visibility check
    * @return
    */
  def entityInfo(entity: Entity)(implicit graph: Graph, authContext: AuthContext): Try[(String, Int, Int)] =
    entity match {
      case t: Task => taskSrv.get(t).visible(organisationSrv).`case`.getOrFail("Case").map(c => (s"${t.title} (${t.status})", c.tlp, c.pap))
      case c: Case => caseSrv.get(c).visible(organisationSrv).getOrFail("Case").map(c => (s"#${c.number} ${c.title}", c.tlp, c.pap))
      case l: Log  => logSrv.get(l).visible(organisationSrv).`case`.getOrFail("Case").map(c => (s"${l.message} from ${l._createdBy}", c.tlp, c.pap))
      case a: Alert =>
        alertSrv.get(a).visible(organisationSrv).getOrFail("Alert").map(a => (s"[${a.source}:${a.sourceRef}] ${a.title}", a.tlp, a.pap))
      case o: Observable =>
        for {
          ro <- observableSrv.get(o).visible(organisationSrv).richObservable.getOrFail("Observable")
          c  <- observableSrv.get(o).`case`.getOrFail("Case")
        } yield (s"[${ro.dataType}] ${ro.data.getOrElse("<no data>")}", ro.tlp, c.pap) // TODO add attachment info
    }
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/JobSrv.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import akka.Done
import akka.actor._
import akka.stream.Materializer
import akka.stream.scaladsl.FileIO
import com.google.inject.name.Named
import io.scalaland.chimney.dsl._
import org.apache.tinkerpop.gremlin.process.traversal.P
import org.thp.cortex.client.CortexClient
import org.thp.cortex.dto.v0.{InputArtifact, OutputArtifact, Attachment => CortexAttachment, JobStatus => CortexJobStatus, OutputJob => CortexJob}
import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.controllers.FFile
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, StepLabel, Traversal}
import org.thp.scalligraph.{CreateError, EntityId, EntityIdOrName, NotFoundError}
import org.thp.thehive.connector.cortex.controllers.v0.Conversion._
import org.thp.thehive.connector.cortex.models._
import org.thp.thehive.connector.cortex.services.Conversion._
import org.thp.thehive.connector.cortex.services.JobOps._
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.{AttachmentSrv, ObservableSrv, ObservableTypeSrv, OrganisationSrv, ReportTagSrv}
import play.api.libs.json.{JsObject, JsString, Json}

import java.nio.file.Files
import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Success, Try}

@Singleton
class JobSrv @Inject() (
    connector: Connector,
    @Named("cortex-actor") cortexActor: ActorRef,
    observableSrv: ObservableSrv,
    observableTypeSrv: ObservableTypeSrv,
    attachmentSrv: AttachmentSrv,
    reportTagSrv: ReportTagSrv,
    actionOperationSrv: ActionOperationSrv,
    serviceHelper: ServiceHelper,
    auditSrv: CortexAuditSrv,
    organisationSrv: OrganisationSrv,
    implicit val db: Database,
    implicit val ec: ExecutionContext,
    implicit val mat: Materializer
) extends VertexSrv[Job] {

  val observableJobSrv    = new EdgeSrv[ObservableJob, Observable, Job]
  val reportObservableSrv = new EdgeSrv[ReportObservable, Job, Observable]

  /**
    * Submits an observable for analysis to cortex client and stores
    * resulting job and send the cortex reference id to the polling job status actor
    *
    * @param cortexId    the client id name
    * @param workerId    the analyzer (worker) id
    * @param observable  the observable to analyze
    * @param `case`      the related case
    * @param authContext auth context instance
    * @return
    */
  def submit(cortexId: String, workerId: String, observable: RichObservable, `case`: Case with Entity, parameters: JsObject)(implicit
      authContext: AuthContext
  ): Future[RichJob] = {
    val parametersWithRequesterInfo = db.roTransaction { implicit graph =>
      parameters +
        ("organisation" -> JsString(organisationSrv.current.value(_.name).head)) +
        ("user"         -> JsString(authContext.userId))
    }

    for {
      cortexClient <-
        serviceHelper
          .availableCortexClients(connector.clients, authContext.organisation)
          .find(_.name == cortexId)
          .fold[Future[CortexClient]](Future.failed(NotFoundError(s"Cortex $cortexId not found")))(Future.successful)
      analyzer <- cortexClient.getAnalyzer(workerId).recoverWith {
        case _ => cortexClient.getAnalyzerByName(workerId)
      } // if get analyzer using cortex2 API fails, try using legacy API
      cortexArtifact <- observable.dataOrAttachment match {
        case Left(data) =>
          Future.successful(
            InputArtifact(observable.tlp, `case`.pap, observable.dataType, `case`.number.toString, Some(data), None, parametersWithRequesterInfo)
          )
        case Right(a) =>
          val attachment = CortexAttachment(a.name, a.size, a.contentType, attachmentSrv.source(a))
          Future.successful(
            InputArtifact(
              observable.tlp,
              `case`.pap,
              observable.dataType,
              `case`.number.toString,
              None,
              Some(attachment),
              parametersWithRequesterInfo
            )
          )
        case _ => Future.failed(new Exception(s"Invalid Observable data for ${observable.observable._id}"))
      }
      cortexOutputJob <- cortexClient.analyse(analyzer.id, cortexArtifact)
      createdJob <- Future.fromTry(db.tryTransaction { implicit graph =>
        create(fromCortexOutputJob(cortexOutputJob).copy(cortexId = cortexId), observable.observable)
      })
      _ <- Future.fromTry(db.tryTransaction { implicit graph =>
        auditSrv
          .job
          .create(
            createdJob.job,
            observable.observable,
            createdJob.toJson.as[JsObject] + ("objectType" -> JsString("Observable")) + ("objectId" -> JsString(observable._id.toString))
          )
      })
      _ = cortexActor ! CheckJob(Some(createdJob._id), cortexOutputJob.id, None, cortexClient.name, authContext)
    } yield createdJob
  }

  private def fromCortexOutputJob(j: CortexJob): Job =
    j.into[Job]
      .withFieldComputed(_.workerId, _.workerId)
      .withFieldComputed(_.workerName, _.workerName)
      .withFieldComputed(_.workerDefinition, _.workerDefinition)
      .withFieldComputed(_.status, s => JobStatus.withName(s.status.toString))
      .withFieldComputed(_.startDate, j => j.startDate.getOrElse(j.date))
      .withFieldComputed(_.endDate, j => j.endDate.getOrElse(j.date))
      .withFieldConst(_.report, None)
      .withFieldConst(_.cortexId, "tbd")
      .withFieldComputed(_.cortexJobId, _.id)
      .withFieldConst(_.operations, Nil)
      .transform

  /**
    * Creates a Job with with according ObservableJob edge
    *
    * @param job         the job date to create
    * @param observable  the related observable
    * @param graph       the implicit graph instance needed
    * @param authContext the implicit auth needed
    * @return
    */
  def create(job: Job, observable: Observable with Entity)(implicit graph: Graph, authContext: AuthContext): Try[RichJob] =
    for {
      createdJob <- createEntity(job)
      _          <- observableJobSrv.create(ObservableJob(), observable, createdJob)
    } yield RichJob(createdJob, Nil)

  /**
    * Once a job has finished on Cortex side
    * the report is processed here: each report's artifacts
    * are stored as separate Observable with the appropriate edge ObservableJob
    *
    * @param cortexId     Id of cortex
    * @param jobId        the job db id
    * @param cortexJob    the CortexOutputJob
    * @param authContext  the auth context for db queries
    * @return the updated job
    */
  def finished(cortexId: String, jobId: EntityId, cortexJob: CortexJob)(implicit
      authContext: AuthContext
  ): Future[Job with Entity] =
    for {
      cortexClient <-
        serviceHelper
          .availableCortexClients(connector.clients, authContext.organisation)
          .find(_.name == cortexId)
          .fold[Future[CortexClient]](Future.failed(NotFoundError(s"Cortex $cortexId not found")))(Future.successful)
      operations <- Future.fromTry(executeOperations(jobId, cortexJob))
      job        <- Future.fromTry(updateJobStatus(jobId, cortexJob, operations))
      _          <- importCortexArtifacts(job, cortexJob, cortexClient)
      _          <- Future.fromTry(importAnalyzerTags(job, cortexJob))
    } yield job

  def executeOperations(jobId: EntityId, cortexJob: CortexJob)(implicit authContext: AuthContext): Try[Seq[ActionOperationStatus]] =
    db.tryTransaction { implicit graph =>
      get(jobId)
        .observable
        .project(_.by.by(_.`case`.option))
        .getOrFail("Observable")
        .map {
          case (relatedObservable, relatedCase) =>
            cortexJob
              .report
              .fold[Seq[ActionOperation]](Nil)(_.operations.map(_.as[ActionOperation]))
              .map { operation =>
                actionOperationSrv
                  .execute(relatedObservable, operation, relatedCase, None)
                  .fold(t => ActionOperationStatus(operation, success = false, t.getMessage), identity)
              }
        }
    }

  /**
    * Update job status, set the endDate and remove artifacts from report
    *
    * @param jobId id of the job to update
    * @param cortexJob the job from cortex
    * @param authContext the authentication context
    * @return the updated job
    */
  private def updateJobStatus(jobId: EntityId, cortexJob: CortexJob, operations: Seq[ActionOperationStatus])(implicit
      authContext: AuthContext
  ): Try[Job with Entity] =
    db.tryTransaction { implicit graph =>
      getOrFail(jobId).flatMap { job =>
        val report  = cortexJob.report.flatMap(r => r.full orElse r.errorMessage.map(m => Json.obj("errorMessage" -> m)))
        val status  = cortexJob.status.toJobStatus
        val endDate = new Date()
        for {
          job <- get(job)
            .update(_.report, report)
            .update(_.status, status)
            .update(_.endDate, endDate)
            .update(_._updatedAt, Some(new Date))
            .update(_._updatedBy, Some(authContext.userId))
            .update(_.operations, operations.map(o => Json.toJsObject(o)))
            .getOrFail("Job")
          observable <- get(job).observable.getOrFail("Observable")
          _ <-
            auditSrv
              .job
              .update(
                job,
                observable,
                Json.obj("status" -> status, "endDate" -> endDate, "objectType" -> "Observable", "objectId" -> observable._id.toString)
              )
        } yield job
      }
    }

  private def importAnalyzerTags(job: Job with Entity, cortexJob: CortexJob)(implicit authContext: AuthContext): Try[Unit] =
    if (cortexJob.status == CortexJobStatus.Success)
      db.tryTransaction { implicit graph =>
        val tags = cortexJob.report.fold[Seq[ReportTag]](Nil)(_.summary.map(_.toAnalyzerTag(job.workerName)))
        for {
          observable <- get(job).observable.getOrFail("Observable")
          _          <- reportTagSrv.updateTags(observable, tags)
        } yield ()
      }
    else Success(())

  /**
    * Create observable for each artifact of the job report
    *
    * @param job the job on which the observables will be linked
    * @param cortexJob the cortex job containing the artifact to import
    * @param cortexClient the cortex client used to download attachment observable
    * @param authContext the authentication context
    * @return
    */
  private def importCortexArtifacts(job: Job with Entity, cortexJob: CortexJob, cortexClient: CortexClient)(implicit
      authContext: AuthContext
  ): Future[Done] = {
    val artifacts = cortexJob
      .report
      .toList
      .flatMap(_.artifacts)
    Future
      .traverse(artifacts) { artifact =>
        db.tryTransaction(graph => observableTypeSrv.getOrFail(EntityIdOrName(artifact.dataType))(graph))
          .fold(
            Future.failed,
            {
              case attachmentType if attachmentType.isAttachment => importCortexAttachment(job, artifact, cortexClient)
              case _ =>
                Future
                  .fromTry {
                    db.tryTransaction { implicit graph =>
                      get(job).observable.getOrFail("Observable").map { origObs =>
                        observableSrv
                          .create(artifact.toObservable(job._id, origObs.organisationIds), artifact.data.get)
                          .foreach(obs => addObservable(job, obs.observable))
                      }
                    }
                  }
            }
          )
          .recover {
            case _: CreateError =>
            case error          => logger.error("Fail to import observable from Job", error)
          }
      }
      .map(_ => Done)
  }

  def addObservable(
      job: Job with Entity,
      observable: Observable with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[ReportObservable with Entity] =
    reportObservableSrv.create(ReportObservable(), job, observable)

  /**
    * Downloads and import the attachment file for an artifact of type file
    * from the job's report and saves the Attachment to the db
    *
    * @param cortexClient the client api
    * @param authContext  the auth context necessary for db persistence
    * @return
    */
  private def importCortexAttachment(
      job: Job with Entity,
      artifact: OutputArtifact,
      cortexClient: CortexClient
  )(implicit
      authContext: AuthContext
  ): Future[Unit] =
    artifact
      .attachment
      .map { attachment =>
        val file = Files.createTempFile(s"job-cortex-${attachment.id}", "")
        (for {
          src <- cortexClient.getAttachment(attachment.id)
          _   <- src.runWith(FileIO.toPath(file))
          fFile = FFile(attachment.name.getOrElse(attachment.id), file, attachment.contentType.getOrElse("application/octet-stream"))
          _ <- Future.fromTry {
            db.tryTransaction { implicit graph =>
              for {
                origObs           <- get(job).observable.getOrFail("Observable")
                createdAttachment <- attachmentSrv.create(fFile)
                richObservable    <- observableSrv.create(artifact.toObservable(job._id, origObs.organisationIds), createdAttachment)
                _                 <- reportObservableSrv.create(ReportObservable(), job, richObservable.observable)
              } yield ()
            }
          }
        } yield ())
          .andThen { case _ => Files.delete(file) }
      }
      .getOrElse(Future.failed(new Exception(s"Attachment not present for artifact ${artifact.dataType}")))

}

object JobOps {

  implicit class JobOpsDefs(traversal: Traversal.V[Job]) {

    /**
      * Checks if a Job is visible from a certain UserRole end
      *
      * @param authContext the auth context to check login against
      * @return
      */
    def visible(implicit authContext: AuthContext): Traversal.V[Job] =
      traversal.filter(_.observable.organisations.visible)

    /**
      * Checks if a job is accessible if the user and
      * the share profile contain the permission
      *
      * @param permission  the permission to check
      * @param authContext the user context
      * @return
      */
    def can(permission: Permission)(implicit authContext: AuthContext): Traversal.V[Job] =
      if (authContext.permissions.contains(permission))
        traversal.filter(_.observable.can(permission))
      else traversal.empty

    def observable: Traversal.V[Observable] = traversal.in[ObservableJob].v[Observable]

    /**
      * Returns the potential observables that were attached to a job report
      * after analyze has completed
      *
      * @return
      */
    def reportObservables: Traversal.V[Observable] = traversal.out[ReportObservable].v[Observable]

    def richJob(implicit authContext: AuthContext): Traversal[RichJob, JMap[String, Any], Converter[RichJob, JMap[String, Any]]] = {
      val thisJob = StepLabel.v[Job]
      traversal
        .as(thisJob)
        .project(
          _.by
            .by(
              _.reportObservables
                .project(
                  _.by(_.richObservable)
                    .by(_.similar.where(_.`case`.observables.out[ObservableJob].v[Job].isStep(P.eq[String](thisJob.name)))._id.fold)
                )
                .fold
            )
        )
        .domainMap {
          case (job, observablesWithLink) =>
            val observables = observablesWithLink.map {
              case (obs, l) => obs -> Json.obj("observableId" -> l.headOption)
            }
            RichJob(job, observables)
        }
    }

    def richJobWithCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Job] => Traversal[D, G, C]
    )(implicit authContext: AuthContext): Traversal[(RichJob, D), JMap[String, Any], Converter[(RichJob, D), JMap[String, Any]]] = {
      val thisJob = StepLabel.v[Job]
      traversal
        .as(thisJob)
        .project(
          _.by
            .by(
              _.reportObservables
                .project(
                  _.by(_.richObservable)
                    .by(_.similar.filter(_.`case`.observables.out[ObservableJob].where(P.eq[String](thisJob.name)))._id.fold)
                )
                .fold
            )
            .by(entityRenderer)
        )
        .domainMap {
          case (job, observablesWithLink, renderedEntity) =>
            val observables = observablesWithLink.map {
              case (obs, l) => obs -> Json.obj("observableId" -> l)
            }
            RichJob(job, observables) -> renderedEntity
        }
    }
  }
  implicit class CortexObservableOpsDefs(traversal: Traversal.V[Observable]) {
    def jobs: Traversal.V[Job] = traversal.out[ObservableJob].v[Job]
  }

}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/ResponderSrv.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.cortex.dto.v0.OutputWorker
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Database
import org.thp.thehive.controllers.v0.Conversion.toObjectType
import org.thp.thehive.models.Permissions
import play.api.Logger
import play.api.libs.json.{JsObject, Json}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success}

@Singleton
class ResponderSrv @Inject() (
    connector: Connector,
    db: Database,
    entityHelper: EntityHelper,
    serviceHelper: ServiceHelper,
    implicit val ec: ExecutionContext
) {

  lazy val logger: Logger = Logger(getClass)

  /**
    * Gets a list of OutputCortexWorker from all available CortexClients
    * in relation with the entity type and id passed and
    * filtered by the allowed entity's tlp and pap
    *
    * @param entityType the entity
    * @param entityId its id
    * @param authContext the auth context for visibility check
    * @return
    */
  def getRespondersByType(
      entityType: String,
      entityId: EntityIdOrName
  )(implicit authContext: AuthContext): Future[Map[OutputWorker, Seq[String]]] =
    for {
      entity        <- Future.fromTry(db.roTransaction(implicit graph => entityHelper.get(toObjectType(entityType), entityId, Permissions.manageAction)))
      (_, tlp, pap) <- Future.fromTry(db.roTransaction(implicit graph => entityHelper.entityInfo(entity)))
      responders <-
        Future
          .traverse(serviceHelper.availableCortexClients(connector.clients, authContext.organisation))(client =>
            client
              .getRespondersByType(entityType)
              .transform {
                case Success(analyzers) => Success(analyzers.map(_ -> client.name))
                case Failure(error) =>
                  logger.error(s"List Cortex analyzers fails on ${client.name}", error)
                  Success(Nil)
              }
          )
    } yield serviceHelper.flattenList(responders).filter { case (w, _) => w.maxTlp >= tlp && w.maxPap >= pap }

  def getRespondersByName(responderName: String, organisation: EntityIdOrName): Future[Map[OutputWorker, Seq[String]]] =
    searchResponders(Json.obj("query" -> Json.obj("_field" -> "name", "_value" -> responderName)), organisation)

  /**
    * Search responders
    * @param query the raw query from frontend
    * @param authContext auth context for organisation filter
    * @return
    */
  def searchResponders(query: JsObject)(implicit authContext: AuthContext): Future[Map[OutputWorker, Seq[String]]] =
    searchResponders(query, authContext.organisation)

  def searchResponders(query: JsObject, organisation: EntityIdOrName): Future[Map[OutputWorker, Seq[String]]] =
    Future
      .traverse(serviceHelper.availableCortexClients(connector.clients, organisation)) { client =>
        client
          .searchResponders(query)
          .transform {
            case Success(analyzers) => Success(analyzers.map(_ -> client.name))
            case Failure(error) =>
              logger.error(s"List Cortex analyzers fails on ${client.name}", error)
              Success(Nil)
          }
      }
      .map(serviceHelper.flattenList)
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/ServiceHelper.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.apache.tinkerpop.gremlin.process.traversal.P
import org.thp.cortex.client.CortexClient
import org.thp.cortex.dto.v0.OutputWorker
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.Traversal
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.models.Organisation
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services._
import play.api.Logger

import javax.inject.{Inject, Singleton}

@Singleton
class ServiceHelper @Inject() (
    db: Database,
    organisationSrv: OrganisationSrv
) {

  lazy val logger: Logger = Logger(getClass)

  /**
    * Returns the filtered CortexClients according to config
    * @param clients cortex clients instances
    * @param organisationName the concerned organisation to get available clients for
    * @return
    */
  def availableCortexClients(clients: Seq[CortexClient], organisationName: EntityIdOrName): Iterable[CortexClient] =
    db.roTransaction { implicit graph =>
      val l = clients
        .filter(c =>
          organisationFilter(
            organisationSrv.startTraversal,
            c.includedTheHiveOrganisations,
            c.excludedTheHiveOrganisations
          ).get(organisationName).exists
        )

      if (l.isEmpty)
        logger.warn(s"No CortexClient found for organisation $organisationName in list ${clients.map(_.name)}")

      l
    }

  /**
    * Returns the filtered organisations according to the supplied lists (mainly conf based)
    *
    * @param organisationSteps the organisation steps graph instance
    * @param includedTheHiveOrganisations the allowed organisation
    * @param excludedTheHiveOrganisations the excluded ones
    * @return
    */
  def organisationFilter(
      organisationSteps: Traversal.V[Organisation],
      includedTheHiveOrganisations: Seq[String],
      excludedTheHiveOrganisations: Seq[String]
  ): Traversal.V[Organisation] = {
    val includedOrgs =
      if (includedTheHiveOrganisations.contains("*") || includedTheHiveOrganisations.isEmpty) organisationSteps
      else organisationSteps.has(_.name, P.within(includedTheHiveOrganisations: _*))
    if (excludedTheHiveOrganisations.isEmpty) includedOrgs
    else includedOrgs.has(_.name, P.without(excludedTheHiveOrganisations: _*))
  }

  /**
    * After querying several Cortex clients,
    * it is necessary to group worker results
    * @param l the list of workers list by client
    * @return
    */
  def flattenList(
      l: Iterable[Seq[(OutputWorker, String)]]
//      f: ((OutputWorker, Seq[String])) => Boolean
  ): Map[OutputWorker, Seq[String]] =
    l                     // Iterable[Seq[(worker, cortexId)]]
      .flatten            // Seq[(worker, cortexId)]
      .groupBy(_._1.name) // Map[workerName, Seq[(worker, cortexId)]]
      .values             // Seq[Seq[(worker, cortexId)]]
      .map(a => a.head._1 -> a.map(_._2).toSeq) // Map[worker, Seq[CortexId] ]
      //      .filter(w => f(w))
      .toMap
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/notification/notifiers/RunAnalyzer.scala`:

```scala
package org.thp.thehive.connector.cortex.services.notification.notifiers

import com.typesafe.config.ConfigRenderOptions
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{BadConfigurationError, NotFoundError, RichOption}
import org.thp.thehive.connector.cortex.services.{AnalyzerSrv, JobSrv}
import org.thp.thehive.controllers.v0.AuditRenderer
import org.thp.thehive.models._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services._
import org.thp.thehive.services.notification.notifiers.{Notifier, NotifierProvider}
import play.api.Configuration
import play.api.libs.json.{JsObject, Json}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Try}

@Singleton
class RunAnalyzerProvider @Inject() (
    analyzerSrv: AnalyzerSrv,
    jobSrv: JobSrv,
    caseSrv: CaseSrv,
    observableSrv: ObservableSrv,
    ec: ExecutionContext
) extends NotifierProvider {
  override val name: String = "RunAnalyzer"

  override def apply(config: Configuration): Try[Notifier] = {
    val parameters = Try(Json.parse(config.underlying.getValue("parameters").render(ConfigRenderOptions.concise())).as[JsObject]).toOption
    config.getOrFail[String]("analyzerName").map { responderName =>
      new RunAnalyzer(
        responderName,
        parameters.getOrElse(JsObject.empty),
        analyzerSrv,
        jobSrv,
        caseSrv,
        observableSrv,
        ec
      )
    }
  }
}

class RunAnalyzer(
    analyzerName: String,
    parameters: JsObject,
    analyzerSrv: AnalyzerSrv,
    jobSrv: JobSrv,
    caseSrv: CaseSrv,
    observableSrv: ObservableSrv,
    implicit val ec: ExecutionContext
) extends Notifier
    with AuditRenderer {
  override val name: String = "RunAnalyzer"

  def getObservable(`object`: Option[Entity])(implicit graph: Graph): Future[RichObservable] =
    `object` match {
      case Some(o) if o._label == "Observable" => Future.fromTry(observableSrv.get(o._id).richObservable.getOrFail("Observable"))
      case _                                   => Future.failed(NotFoundError("Audit object is not an observable"))
    }

  def getCase(context: Option[Entity])(implicit graph: Graph): Future[Case with Entity] =
    context match {
      case Some(c) if c._label == "Case" => Future.fromTry(caseSrv.getOrFail(c._id))
      case _                             => Future.failed(NotFoundError("Audit context is not a case"))
    }

  override def execute(
      audit: Audit with Entity,
      context: Option[Map[String, Seq[Any]] with Entity],
      `object`: Option[Map[String, Seq[Any]] with Entity],
      organisation: Organisation with Entity,
      user: Option[User with Entity]
  )(implicit graph: Graph): Future[Unit] =
    if (user.isDefined)
      Future.failed(BadConfigurationError("The notification runAnalyzer must not be applied on user"))
    else
      for {
        observable          <- getObservable(`object`)
        case0               <- getCase(context)
        workers             <- analyzerSrv.getAnalyzerByName(analyzerName, organisation._id)
        (worker, cortexIds) <- Future.fromTry(workers.headOption.toTry(Failure(NotFoundError(s"Analyzer $analyzerName not found"))))
        authContext = LocalUserSrv.getSystemAuthContext.changeOrganisation(organisation._id, Permissions.all)
        _ <- jobSrv.submit(cortexIds.head, worker.id, observable, case0, parameters)(authContext)
      } yield ()
}

```

`cortex/connector/src/main/scala/org/thp/thehive/connector/cortex/services/notification/notifiers/RunResponder.scala`:

```scala
package org.thp.thehive.connector.cortex.services.notification.notifiers

import com.typesafe.config.ConfigRenderOptions
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{BadConfigurationError, NotFoundError, RichOption}
import org.thp.thehive.connector.cortex.services.{ActionSrv, ResponderSrv}
import org.thp.thehive.controllers.v0.AuditRenderer
import org.thp.thehive.models.{Audit, Organisation, Permissions, User}
import org.thp.thehive.services._
import org.thp.thehive.services.notification.notifiers.{Notifier, NotifierProvider}
import play.api.Configuration
import play.api.libs.json.{JsObject, Json, OWrites}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Try}

@Singleton
class RunResponderProvider @Inject() (
    responderSrv: ResponderSrv,
    actionSrv: ActionSrv,
    taskSrv: TaskSrv,
    caseSrv: CaseSrv,
    observableSrv: ObservableSrv,
    logSrv: LogSrv,
    alertSrv: AlertSrv,
    ec: ExecutionContext
) extends NotifierProvider {
  override val name: String = "RunResponder"

  override def apply(config: Configuration): Try[Notifier] = {

    val parameters = Try(Json.parse(config.underlying.getValue("parameters").render(ConfigRenderOptions.concise())).as[JsObject]).toOption
    config.getOrFail[String]("responderName").map { responderName =>
      new RunResponder(
        responderName,
        parameters.getOrElse(JsObject.empty),
        responderSrv,
        actionSrv,
        taskSrv,
        caseSrv,
        observableSrv,
        logSrv,
        alertSrv,
        ec
      )
    }
  }
}

class RunResponder(
    responderName: String,
    parameters: JsObject,
    responderSrv: ResponderSrv,
    actionSrv: ActionSrv,
    taskSrv: TaskSrv,
    caseSrv: CaseSrv,
    observableSrv: ObservableSrv,
    logSrv: LogSrv,
    alertSrv: AlertSrv,
    implicit val ec: ExecutionContext
) extends Notifier
    with AuditRenderer {
  override val name: String = "RunResponder"

  def getEntity(audit: Audit)(implicit graph: Graph): Try[(Product with Entity, JsObject)] =
    audit
      .objectEntityId
      .flatMap { objectId =>
        audit.objectType.map {
          case "Task"       => taskSrv.get(objectId).project(_.by.by(taskToJson)).getOrFail("Task")
          case "Case"       => caseSrv.get(objectId).project(_.by.by(caseToJson)).getOrFail("Case")
          case "Observable" => observableSrv.get(objectId).project(_.by.by(observableToJson)).getOrFail("Observable")
          case "Log"        => logSrv.get(objectId).project(_.by.by(logToJson)).getOrFail("Log")
          case "Alert"      => alertSrv.get(objectId).project(_.by.by(alertToJson)).getOrFail("Alert")
          case objectType   => Failure(NotFoundError(s"objectType $objectType is not recognised"))
        }
      }
      .getOrElse(Failure(NotFoundError("Object not present in the audit")))

  override def execute(
      audit: Audit with Entity,
      context: Option[Map[String, Seq[Any]] with Entity],
      `object`: Option[Map[String, Seq[Any]] with Entity],
      organisation: Organisation with Entity,
      user: Option[User with Entity]
  )(implicit graph: Graph): Future[Unit] =
    if (user.isDefined)
      Future.failed(BadConfigurationError("The notification runResponder must not be applied on user"))
    else
      for {
        (entity, entityJson) <- Future.fromTry(getEntity(audit))
        workers              <- responderSrv.getRespondersByName(responderName, organisation._id)
        (worker, cortexIds)  <- Future.fromTry(workers.headOption.toTry(Failure(NotFoundError(s"Responder $responderName not found"))))
        authContext = LocalUserSrv.getSystemAuthContext.changeOrganisation(organisation._id, Permissions.all)
        _ <- actionSrv.execute(entity, cortexIds.headOption, worker.id, parameters)(OWrites[Entity](_ => entityJson), authContext)
      } yield ()
}

```

`cortex/connector/src/test/resources/cortex-jobs.json`:

```json
[
  {
    "date": 1562157321611,
    "endDate": 1562157324938,
    "type": "analyzer",
    "cacheTag": "99bf872b81f82fe224fa450604d7cefa",
    "createdAt": 1562157321611,
    "_parent": null,
    "attachment": {
      "name": "imageedit_2_3904987689.jpg",
      "hashes": [
        "cd86f8b78fc9ce4c31e6fca6595b97d9ff49f12c246a0fafdc5081dac99f2e71",
        "ae935b4669d03994d0fe60e9255b81abeb4f0299",
        "b0e0792b9ea92b16a49dfcbe06cd2a88"
      ],
      "size": 16824,
      "contentType": "image/jpeg",
      "id": "cd86f8b78fc9ce4c31e6fca6595b97d9ff49f12c246a0fafdc5081dac99f2e71"
    },
    "id": "ZWu85Q1OCVNx03hXK4df",
    "_version": 3,
    "pap": 2,
    "updatedAt": 1562157324938,
    "_routing": "ZWu85Q1OCVNx03hXK4df",
    "workerId": "da4bdbecae5b1f6d4180e25450b65459",
    "updatedBy": "billotei",
    "analyzerName": "testAnalyzer_1_0",
    "analyzerDefinitionId": "testAnalyzer_1_0",
    "dataType": "file",
    "_type": "job",
    "message": "179e85c4-4170-45fe-9d2d-3173539554a6",
    "analyzerId": "da4bdbecae5b1f6d4180e25450b65459",
    "createdBy": "billotei",
    "organization": "cert",
    "report": {
      "summary": {
        "taxonomies": [
          {
            "level": "info",
            "namespace": "test",
            "predicate": "data",
            "value": "test"
          }
        ]
      },
      "full": {
        "data": "imageedit_2_3904987689.jpg",
        "input": {
          "file": "attachment7619802021796183482",
          "filename": "imageedit_2_3904987689.jpg",
          "dataType": "file",
          "tlp": 2,
          "message": "179e85c4-4170-45fe-9d2d-3173539554a6",
          "contentType": "image/jpeg",
          "parameters": {
          },
          "config": {
            "proxy_https": null,
            "cacerts": null,
            "max_pap": 2,
            "jobTimeout": 30,
            "check_tlp": true,
            "proxy_http": null,
            "max_tlp": 2,
            "auto_extract_artifacts": false,
            "jobCache": 10,
            "check_pap": true
          },
          "pap": 2
        }
      },
      "success": true,
      "artifacts": [
        {
          "attachment": {
            "contentType": "application/octet-stream",
            "id": "file",
            "name": "file.test.txt",
            "size": 5
          },
          "message": null,
          "tags": [
          ],
          "tlp": 3,
          "dataType": "file"
        },
        {
          "data": "192.168.1.1",
          "message": "myIp",
          "tags": ["tag-test"],
          "tlp": 2,
          "dataType": "ip"
        }
      ],
      "operations": [
        {
          "type": "AddArtifactToCase",
          "data": "myData",
          "dataType": "other",
          "message": "test-operation",
          "tlp": 3,
          "ignoreSimilarity": false,
          "tags": ["tag1", "tag2"]
        }
      ]
    },
    "tlp": 2,
    "workerDefinitionId": "testAnalyzer_1_0",
    "_id": "ZWu85Q1OCVNx03hXK4df",
    "workerName": "testAnalyzer_1_0",
    "parameters": {
    },
    "startDate": 1562157321892,
    "status": "Success"
  },
  {
    "date": 1562167321611,
    "endDate": 1562167324938,
    "type": "responder",
    "cacheTag": "99bf872b81f82fe224fa450604d7cefa",
    "createdAt": 1562167321611,
    "_parent": null,
    "attachment": {
      "name": "imageedit_2_3904987689.jpg",
      "hashes": [
        "cd86f8b78fc9ce4c31e6fca6595b97d9ff49f12c246a0fafdc5081dac99f2e71",
        "ae935b4669d03994d0fe60e9255b81abeb4f0299",
        "b0e0792b9ea92b16a49dfcbe06cd2a88"
      ],
      "size": 16824,
      "contentType": "image/jpeg",
      "id": "cd86f8b78fc9ce4c31e6fca6595b97d9ff49f12c246a0fafdc5081dac99f2e71"
    },
    "id": "AWu78Q1OCVNz03gXK4df",
    "_version": 3,
    "pap": 2,
    "updatedAt": 1562167324938,
    "_routing": "AWu78Q1OCVNz03gXK4df",
    "workerId": "da4bdbecae5b1f6d4180e25450b65459",
    "updatedBy": "billotei",
    "analyzerName": "testResponder_1_0",
    "analyzerDefinitionId": "testResponder_1_0",
    "dataType": "file",
    "_type": "job",
    "message": "179e85c4-4170-45fe-9d2d-3173539554a6",
    "analyzerId": "da4bdbecae5b1f6d4180e25450b65459",
    "createdBy": "billotei",
    "organization": "cert",
    "report": {
      "summary": {},
      "full": {
        "message": "TestResponder has run"
      },
      "success": true,
      "artifacts": [],
      "operations": [
        {
          "type": "AddTagToCase",
          "tag": "mail sent"
        },
        {
          "type": "CreateTask",
          "title": "task created by action",
          "description": "yop !"
        },
        {
          "type": "AddCustomFields",
          "name": "date1",
          "value": 1562157321892,
          "tpe": "date"
        },
        {
          "type": "AddCustomFields",
          "name": "float1",
          "value": 15.54,
          "tpe": "float"
        },
        {
          "type": "AddCustomFields",
          "name": "boolean1",
          "value": false,
          "tpe": "boolean"
        },
        {
          "type": "AddArtifactToCase",
          "data": "testObservable",
          "dataType": "mail-subject",
          "message": "test observable from action"
        },
        {
          "type": "AssignCase",
          "owner": "certuser@thehive.local"
        }
      ]
    },
    "tlp": 2,
    "workerDefinitionId": "testResponder_1_0",
    "_id": "AWu78Q1OCVNz03gXK4df",
    "workerName": "testResponder_1_0",
    "parameters": {
    },
    "startDate": 1562157321892,
    "status": "Success"
  },
  {
    "date": 1565859747991,
    "endDate": 1565859772001,
    "type": "responder",
    "cacheTag": "99bf872b81f82fe224fa450604d7cefa",
    "createdAt": 1565859747991,
    "_parent": null,
    "attachment": {
      "name": "imageedit_2_3904987689.jpg",
      "hashes": [
        "cd86f8b78fc9ce4c31e6fca6595b97d9ff49f12c246a0fafdc5081dac99f2e71",
        "ae935b4669d03994d0fe60e9255b81abeb4f0299",
        "b0e0792b9ea92b16a49dfcbe06cd2a88"
      ],
      "size": 16824,
      "contentType": "image/jpeg",
      "id": "cd86f8b78fc9ce4c31e6fca6595b97d9ff49f12c246a0fafdc5081dac99f2e71"
    },
    "id": "FDs5Q1ODXCz03gXK4df",
    "_version": 3,
    "pap": 2,
    "updatedAt": 1565859772001,
    "_routing": "FDs5Q1ODXCz03gXK4df",
    "workerId": "da4bdbecae5b1f6d4180e25450b65459",
    "updatedBy": "billotei",
    "analyzerName": "testResponder_1_0",
    "analyzerDefinitionId": "testResponder_1_0",
    "dataType": "file",
    "_type": "job",
    "message": "179e85c4-4170-45fe-9d2d-3173539554a6",
    "analyzerId": "da4bdbecae5b1f6d4180e25450b65459",
    "createdBy": "billotei",
    "organization": "default",
    "report": {
      "summary": {},
      "full": {
        "message": "TestResponder has run"
      },
      "success": true,
      "artifacts": [],
      "operations": [
        {
          "type": "AddLogToTask",
          "content": "test log from action"
        },
        {
          "type": "CloseTask"
        }
      ]
    },
    "tlp": 2,
    "workerDefinitionId": "testResponder_1_0",
    "_id": "FDs5Q1ODXCz03gXK4df",
    "workerName": "testResponder_1_0",
    "parameters": {
    },
    "startDate": 1562157321892,
    "status": "Success"
  },
  {
    "date": 1565859757991,
    "endDate": 1565859782001,
    "type": "responder",
    "cacheTag": "99bf872b81f82fe224fa450604d7cefa",
    "createdAt": 1565859757991,
    "_parent": null,
    "attachment": {
      "name": "imageedit_2_3904987689.jpg",
      "hashes": [
        "cd86f8b78fc9ce4c31e6fca6595b97d9ff49f12c246a0fafdc5081dac99f2e71",
        "ae935b4669d03994d0fe60e9255b81abeb4f0299",
        "b0e0792b9ea92b16a49dfcbe06cd2a88"
      ],
      "size": 16824,
      "contentType": "image/jpeg",
      "id": "cd86f8b78fc9ce4c31e6fca6595b97d9ff49f12c246a0fafdc5081dac99f2e71"
    },
    "id": "FGv4E3ODXCz03gXK6jk",
    "_version": 3,
    "pap": 1,
    "updatedAt": 1565859782001,
    "_routing": "FGv4E3ODXCz03gXK6jk",
    "workerId": "da4bdbecae5b1f6d4180e25450b65459",
    "updatedBy": "billotei",
    "analyzerName": "testResponder_1_0",
    "analyzerDefinitionId": "testResponder_1_0",
    "dataType": "file",
    "_type": "job",
    "message": "179e85c4-4170-45fe-9d2d-3173539554a6",
    "analyzerId": "da4bdbecae5b1f6d4180e25450b65459",
    "createdBy": "billotei",
    "organization": "default",
    "report": {
      "summary": {},
      "full": {
        "message": "TestResponder has run"
      },
      "success": true,
      "artifacts": [],
      "operations": [
        {
          "type": "MarkAlertAsRead"
        },
        {
          "type": "AddTagToAlert",
          "tag": "test tag from action"
        }
      ]
    },
    "tlp": 3,
    "workerDefinitionId": "testResponder_1_0",
    "_id": "FGv4E3ODXCz03gXK6jk",
    "workerName": "testResponder_1_0",
    "parameters": {
    },
    "startDate": 1562157321892,
    "status": "Success"
  }
]
```

`cortex/connector/src/test/resources/observables.json`:

```json
[
  {
    "type": "ip",
    "ioc": false,
    "sighted": false,
    "tlp": 2,
    "message": "localhost",
    "tags": [
      "local",
      "host"
    ],
    "data": "127.0.0.1"
  }
]
```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/controllers/v0/AnalyzerCtrlTest.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import org.thp.thehive.TestAppBuilder
import org.thp.thehive.connector.cortex.dto.v0.OutputWorker
import play.api.test.{FakeRequest, PlaySpecification}

class AnalyzerCtrlTest extends PlaySpecification with TestAppBuilder {

  "analyzer controller" should {
    "list analyzers" in testApp { app =>
      val request = FakeRequest("GET", s"/api/connector/cortex/analyzer?range=all").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[AnalyzerCtrl].list(request)

      status(result) shouldEqual 200

      val resultList = contentAsJson(result).as[Seq[OutputWorker]]

      resultList must beEmpty
    }
  }
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/controllers/v0/AnalyzerTemplateCtrlTest.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import org.thp.scalligraph.controllers.FakeTemporaryFile
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.connector.cortex.dto.v0.OutputAnalyzerTemplate
import play.api.libs.json.Json
import play.api.mvc.MultipartFormData.FilePart
import play.api.mvc.{AnyContentAsMultipartFormData, MultipartFormData}
import play.api.test.{FakeRequest, PlaySpecification}

import scala.util.Random

class AnalyzerTemplateCtrlTest extends PlaySpecification with TestAppBuilder {

  "report controller" should {
//      "create, fetch, update and delete a template" in testApp {app =>
//
//      }

    "import valid templates contained in a zip file and fetch them by id and type" in testApp { app =>
      val file = FilePart("templates", "report-templates.zip", Option("application/zip"), FakeTemporaryFile.fromResource("/report-templates.zip"))
      val request = FakeRequest("POST", s"/api/connector/cortex/report/template/_import")
        .withHeaders("user" -> "admin@thehive.local")
        .withBody(AnyContentAsMultipartFormData(MultipartFormData(Map.empty, Seq(file), Nil)))

      val result = app[AnalyzerTemplateCtrl].importTemplates(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")

      val importedList = contentAsJson(result)

      importedList must equalTo(
        Json.obj(
          "JoeSandbox_File_Analysis_Noinet_2_0" -> true,
          "Yeti_1_0"                            -> true,
          "testAnalyzer_short"                  -> true
        )
      )

      val getRequest = FakeRequest("GET", s"/api/connector/cortex/report/template/content/JoeSandbox_File_Analysis_Noinet_2_0/long")
        .withHeaders("user" -> "admin@thehive.local")
      val getResult = app[AnalyzerTemplateCtrl].get("JoeSandbox_File_Analysis_Noinet_2_0")(getRequest)
      status(getResult) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(getResult)}")

      val createRequest = FakeRequest("POST", "/api/connector/cortex/report/template")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse(s"""
              {
                "analyzerId": "anaTest1",
                "content": "<span>${Random.alphanumeric.take(10).mkString}</span>"
              }
            """.stripMargin))
      val createResult = app[AnalyzerTemplateCtrl].create(createRequest)
      status(createResult) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(createResult)}")

      val outputAnalyzerTemplate = contentAsJson(createResult).as[OutputAnalyzerTemplate]
      val getRequest2 = FakeRequest("GET", s"/api/connector/cortex/analyzer/template/${outputAnalyzerTemplate.id}")
        .withHeaders("user" -> "admin@thehive.local")
      val getResult2 = app[AnalyzerTemplateCtrl].get(outputAnalyzerTemplate.id)(getRequest2)
      status(getResult2) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(getResult2)}")

      val updateRequest = FakeRequest("PATCH", s"/api/connector/cortex/analyzer/template/${outputAnalyzerTemplate.id}")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""{"content": "<br/>"}"""))
      val updateResult = app[AnalyzerTemplateCtrl].update(outputAnalyzerTemplate.id)(updateRequest)
      status(updateResult) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(updateResult)}")
      contentAsJson(updateResult).as[OutputAnalyzerTemplate].content must equalTo("<br/>")

      val deleteRequest = FakeRequest("DELETE", s"/api/connector/cortex/report/template/${outputAnalyzerTemplate.id}")
        .withHeaders("user" -> "admin@thehive.local")
      val deleteResult = app[AnalyzerTemplateCtrl].delete(outputAnalyzerTemplate.id)(deleteRequest)
      status(deleteResult) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(updateResult)}")
    }
  }
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/controllers/v0/JobCtrlTest.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import org.thp.cortex.client.{CortexClient, TestCortexClientProvider}
import org.thp.scalligraph.AppBuilder
import org.thp.scalligraph.models.{Database, Schema}
import org.thp.scalligraph.query.QueryExecutor
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.connector.cortex.models.TheHiveCortexSchemaProvider
import org.thp.thehive.connector.cortex.services.{Connector, CortexActor, TestConnector}
import org.thp.thehive.services.ObservableSrv
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class JobCtrlTest extends PlaySpecification with TestAppBuilder {
  override val databaseName: String = "thehiveCortex"
  override def appConfigure: AppBuilder =
    super
      .appConfigure
      .`override`(
        _.bindActor[CortexActor]("cortex-actor")
          .bindToProvider[CortexClient, TestCortexClientProvider]
          .bind[Connector, TestConnector]
          .bindToProvider[Schema, TheHiveCortexSchemaProvider]
          .bindNamedToProvider[QueryExecutor, TheHiveCortexQueryExecutorProvider]("v0")
      )

  "job controller" should {
    "get a job" in testApp { app =>
      val observable = app[Database].roTransaction { implicit graph =>
        app[ObservableSrv].startTraversal.has(_.message, "Some weird domain").getOrFail("Observable").get
      }

      val requestSearch = FakeRequest("POST", s"/api/connector/cortex/job/_search?range=0-200&sort=-startDate")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse(s"""
              {
                 "query":{
                    "_and":[
                       {
                          "_parent":{
                             "_type":"case_artifact",
                             "_query":{
                                "_id":"${observable._id}"
                             }
                          }
                       }
                    ]
                 }
              }
            """.stripMargin))
      val resultSearch = app[JobCtrl].search(requestSearch)
      status(resultSearch) shouldEqual 200
    }

    "get stats for a job" in testApp { app =>
      val request = FakeRequest("POST", s"/api/connector/cortex/job/_stats")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse(s"""
                                   {
                                     "query": {
                                       "_and": [{
                                         "_in": {
                                           "_field": "status",
                                           "_values": ["Waiting", "InProgress"]
                                         }
                                       }, {
                                         "analyzerId": "anaTest1"
                                       }]
                                     },
                                     "stats": [{
                                       "_agg": "field",
                                       "_field": "status",
                                       "_select": [{ "_agg": "count"}]
                                     }, {
                                       "_agg": "count"
                                     }]
                                   }
            """.stripMargin))
      val result = app[JobCtrl].stats(request)

      status(result) shouldEqual 200
    }
  }
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/controllers/v0/TheHiveCortexQueryExecutorProvider.scala`:

```scala
package org.thp.thehive.connector.cortex.controllers.v0

import org.thp.scalligraph.query.QueryExecutor
import org.thp.thehive.controllers.v0.TheHiveQueryExecutor

import javax.inject.{Inject, Provider}

class TheHiveCortexQueryExecutorProvider @Inject() (thehiveQueryExecutor: TheHiveQueryExecutor, cortexQueryExecutor: CortexQueryExecutor)
    extends Provider[QueryExecutor] {
  override def get(): QueryExecutor = thehiveQueryExecutor ++ cortexQueryExecutor
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/services/ActionSrvTest.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.cortex.client.{CortexClient, TestCortexClientProvider}
import org.thp.cortex.dto.v0.OutputJob
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AppBuilder, EntityName}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.connector.cortex.controllers.v0.ActionCtrl
import org.thp.thehive.connector.cortex.models.{JobStatus, TheHiveCortexSchemaProvider}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.{AlertSrv, LogSrv, OrganisationSrv, TaskSrv}
import play.api.libs.json._
import play.api.test.PlaySpecification

import scala.io.Source

class ActionSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext =
    DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert", permissions = Permissions.all).authContext

  override val databaseName: String = "thehiveCortex"
  override def appConfigure: AppBuilder =
    super
      .appConfigure
      .`override`(_.bindToProvider[Schema, TheHiveCortexSchemaProvider])
      .`override`(
        _.bindActor[CortexActor]("cortex-actor")
          .bindToProvider[CortexClient, TestCortexClientProvider]
          .bind[Connector, TestConnector]
          .bindToProvider[Schema, TheHiveCortexSchemaProvider]
      )

  def testAppBuilder[A](body: AppBuilder => A): A =
    testApp { app =>
      body(
        app
          .`override`(
            _.bindActor[CortexActor]("cortex-actor")
              .bindToProvider[CortexClient, TestCortexClientProvider]
              .bind[Connector, TestConnector]
              .bindToProvider[Schema, TheHiveCortexSchemaProvider]
          )
      )
    }

  "action service" should {
    "execute, create and handle finished action operations" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        implicit val entityWrites: OWrites[Entity] = app[ActionCtrl].entityWrites
        val task1: Task with Entity                = app[TaskSrv].startTraversal.has(_.title, "case 1 task 1").head

        val richAction = await(app[ActionSrv].execute(task1, None, "respTest1", JsObject.empty))
        richAction.workerId shouldEqual "respTest1"

        val cortexOutputJob = readJsonResource("cortex-jobs.json")
          .as[List[OutputJob]]
          .find(_.id == "AWu78Q1OCVNz03gXK4df")
          .get
        val updatedActionTry = app[ActionSrv].finished(richAction._id, cortexOutputJob)
        updatedActionTry must beSuccessfulTry
        val updatedAction = updatedActionTry.get

        updatedAction.status must equalTo(JobStatus.Success)
        updatedAction.operations.map(o => (o \ "type").as[String]) must contain(
          exactly("AddTagToCase", "CreateTask", "AddCustomFields", "AddCustomFields", "AddCustomFields", "AssignCase", "AddArtifactToCase")
        )
        updatedAction.operations.map(o => (o \ "status").as[String]).toSet must beEqualTo(Set("Success")).updateMessage { s =>
          s"$s\nSome operations failed:\n${Json.prettyPrint(JsArray(updatedAction.operations))}"
        }
      }
    }

    "handle action related to Task and Log" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        implicit val entityWrites: OWrites[Entity] = app[ActionCtrl].entityWrites
        val log1                                   = app[LogSrv].startTraversal.has(_.message, "log for action test").head

        val richAction = await(app[ActionSrv].execute(log1, None, "respTest1", JsObject.empty))
        richAction.workerId shouldEqual "respTest1"

        val cortexOutputJob = readJsonResource("cortex-jobs.json")
          .as[List[OutputJob]]
          .find(_.id == "FDs5Q1ODXCz03gXK4df")
          .get

        val updatedActionTry = app[ActionSrv].finished(richAction._id, cortexOutputJob)
        updatedActionTry must beSuccessfulTry
        val updatedAction = updatedActionTry.get

        updatedAction.status shouldEqual JobStatus.Success
        updatedAction.operations must contain(
          exactly(
            Json.obj("message" -> "Success", "type" -> "AddLogToTask", "content" -> "test log from action", "status" -> "Success"),
            Json.obj("message" -> "Success", "type" -> "CloseTask", "status"     -> "Success")
          )
        )
      }

      app[Database].roTransaction { implicit graph =>
        app[TaskSrv].startTraversal.has(_.title, "case 2 task 2").has(_.status, TaskStatus.Completed).exists must beTrue
        app[TaskSrv].startTraversal.has(_.title, "case 2 task 2").logs.has(_.message, "test log from action").exists must beTrue
      }
    }

    "handle action related to an Alert" in testApp { app =>
      implicit val entityWrites: OWrites[Entity] = app[ActionCtrl].entityWrites
      val alert = app[Database].roTransaction { implicit graph =>
        app[AlertSrv].get(EntityName("testType;testSource;ref2")).visible(app[OrganisationSrv]).head
      }
      alert.read must beFalse
      val richAction = await(app[ActionSrv].execute(alert, None, "respTest1", JsObject.empty))

      val cortexOutputJob = readJsonResource("cortex-jobs.json")
        .as[List[OutputJob]]
        .find(_.id == "FGv4E3ODXCz03gXK6jk")
        .get
      val updatedActionTry = app[ActionSrv].finished(richAction._id, cortexOutputJob)
      updatedActionTry must beSuccessfulTry

      app[Database].roTransaction { implicit graph =>
        val updatedAlert = app[AlertSrv].get(EntityName("testType;testSource;ref2")).visible(app[OrganisationSrv]).richAlert.head // FIXME
        updatedAlert.read must beTrue
        updatedAlert.tags must contain("test tag from action") // TODO
      }
    }
  }

  def readJsonResource(resourceName: String): JsValue = {
    val dataSource = Source.fromResource(resourceName)
    try {
      val data = dataSource.mkString
      Json.parse(data)
    } finally dataSource.close()
  }
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/services/AnalyzerSrvTest.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.cortex.client.{CortexClient, TestCortexClientProvider}
import org.thp.cortex.dto.v0.OutputWorker
import org.thp.scalligraph.AppBuilder
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.connector.cortex.models.TheHiveCortexSchemaProvider
import org.thp.thehive.models.Permissions
import play.api.test.PlaySpecification

class AnalyzerSrvTest extends PlaySpecification with TestAppBuilder {
  override val databaseName: String = "thehiveCortex"
  override def appConfigure: AppBuilder =
    super
      .appConfigure
      .`override`(_.bindToProvider[Schema, TheHiveCortexSchemaProvider])
      .`override`(
        _.bindActor[CortexActor]("cortex-actor")
          .bindToProvider[CortexClient, TestCortexClientProvider]
          .bind[Connector, TestConnector]
          .bindToProvider[Schema, TheHiveCortexSchemaProvider]
      )

  implicit val authContext: AuthContext =
    DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert", permissions = Permissions.all).authContext
  "analyzer service" should {
    "get a list of Cortex workers" in testApp { app =>
      val r = await(app[AnalyzerSrv].listAnalyzer(Some("all")))
      val outputWorker2 =
        OutputWorker(
          "anaTest2",
          "anaTest2",
          "2",
          "nos hoc tempore in provinciis decernendis perpetuae pacis",
          Seq("test", "dummy"),
          2,
          2
        )
      val outputWorker1 =
        OutputWorker(
          "anaTest1",
          "anaTest1",
          "1",
          "Ego vero sic intellego, Patres conscripti, nos hoc tempore in provinciis decernendis perpetuae pacis",
          Seq("test"),
          3,
          3
        )

      r shouldEqual Map(outputWorker2 -> Seq("test"), outputWorker1 -> Seq("test"))
    }

    "get Cortex worker by id" in testApp { app =>
      val r = await(app[AnalyzerSrv].getAnalyzer("anaTest2"))
      val outputWorker =
        OutputWorker(
          "anaTest2",
          "anaTest2",
          "2",
          "nos hoc tempore in provinciis decernendis perpetuae pacis",
          Seq("test", "dummy"),
          2,
          2
        )

      r shouldEqual ((outputWorker, Seq("test")))
    }

    "get a list of Cortex workers by dataType" in testApp { app =>
      val r = await(app[AnalyzerSrv].listAnalyzerByType("test"))
      val outputWorker2 =
        OutputWorker(
          "anaTest2",
          "anaTest2",
          "2",
          "nos hoc tempore in provinciis decernendis perpetuae pacis",
          Seq("test", "dummy"),
          2,
          2
        )
      val outputWorker1 =
        OutputWorker(
          "anaTest1",
          "anaTest1",
          "1",
          "Ego vero sic intellego, Patres conscripti, nos hoc tempore in provinciis decernendis perpetuae pacis",
          Seq("test"),
          3,
          3
        )

      r shouldEqual Map(outputWorker2 -> Seq("test"), outputWorker1 -> Seq("test"))
    }
  }
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/services/EntityHelperTest.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models.Permissions
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.{AlertSrv, ObservableSrv, OrganisationSrv, TaskSrv}
import play.api.test.PlaySpecification

class EntityHelperTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext =
    DummyUserSrv(userId = "certadmin@thehive.local", organisation = "cert", permissions = Permissions.all).authContext
  "entity helper" should {

    "return task info" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        for {
          task              <- app[TaskSrv].startTraversal.has(_.title, "case 1 task 1").getOrFail("Task")
          (title, tlp, pap) <- app[EntityHelper].entityInfo(task)
        } yield (title, tlp, pap)
      } must beASuccessfulTry.which {
        case (title, tlp, pap) =>
          title must beEqualTo("case 1 task 1 (Waiting)")
          tlp must beEqualTo(2)
          pap must beEqualTo(2)
      }
    }

    "return observable info" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        for {
          observable        <- app[ObservableSrv].startTraversal.has(_.message, "Some weird domain").getOrFail("Observable")
          (title, tlp, pap) <- app[EntityHelper].entityInfo(observable)
        } yield (title, tlp, pap)
      } must beASuccessfulTry.which {
        case (title, tlp, pap) =>
          title must beEqualTo("[domain] h.fr")
          tlp must beEqualTo(3)
          pap must beEqualTo(2)
      }
    }

    "find a manageable entity only (task)" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        for {
          task <- app[TaskSrv].startTraversal.has(_.title, "case 1 task 1").getOrFail("Task")
          t    <- app[EntityHelper].get("Task", task._id, Permissions.manageAction)
        } yield t
      } must beSuccessfulTry
    }

    "find a manageable entity only (alert)" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        for {
          alert <- app[AlertSrv].get(EntityName("testType;testSource;ref2")).visible(app[OrganisationSrv]).getOrFail("Alert")
          t     <- app[EntityHelper].get("Alert", alert._id, Permissions.manageAction)
        } yield t
      } must beSuccessfulTry
    }
  }
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/services/JobSrvTest.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.cortex.client.{CortexClient, TestCortexClientProvider}
import org.thp.cortex.dto.v0.OutputJob
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv, Schema}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AppBuilder, EntityName}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.connector.cortex.models.{ActionOperationStatus, Job, JobStatus, TheHiveCortexSchemaProvider}
import org.thp.thehive.connector.cortex.services.JobOps._
import org.thp.thehive.models.Permissions
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import org.thp.thehive.services.notification.triggers.JobFinished
import play.api.libs.json.{JsObject, Json}
import play.api.test.PlaySpecification

import java.util.Date
import scala.concurrent.Await
import scala.concurrent.duration.DurationInt
import scala.io.Source

class JobSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext =
    DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert", permissions = Permissions.all).authContext
  override def appConfigure: AppBuilder =
    super
      .appConfigure
      .bindActor[CortexActor]("cortex-actor")
      .bindToProvider[CortexClient, TestCortexClientProvider]
      .bind[Connector, TestConnector]
      .`override`(_.bindToProvider[Schema, TheHiveCortexSchemaProvider])

  "job service" should {
    val cortexOutputJob = {
      val dataSource = Source.fromResource("cortex-jobs.json")
      val data       = dataSource.mkString
      dataSource.close()
      Json.parse(data).as[List[OutputJob]].find(_.id == "ZWu85Q1OCVNx03hXK4df").get
    }

    "handle creation and then finished job" in testApp { app =>
      val job = Job(
        workerId = "anaTest2",
        workerName = "anaTest2",
        workerDefinition = "test2",
        status = JobStatus.Waiting,
        startDate = new Date(1561625908856L),
        endDate = new Date(1561625908856L),
        report = None,
        cortexId = "test",
        cortexJobId = "LVyYKFstq3Rtrdc9DFmL",
        operations = Nil
      )

      val createdJobTry = app[Database].tryTransaction { implicit graph =>
        for {
          observable <- app[ObservableSrv].startTraversal.has(_.message, "hello world").getOrFail("Observable")
          createdJob <- app[JobSrv].create(job, observable)
        } yield createdJob
      }
      val finishedJobTry = createdJobTry.map { createdJob =>
        Await.result(app[JobSrv].finished(app[CortexClient].name, createdJob._id, cortexOutputJob), 20.seconds)
      }
      finishedJobTry must beASuccessfulTry
      val updatedJob = finishedJobTry.get
      updatedJob.status shouldEqual JobStatus.Success
      updatedJob.report must beSome
      (updatedJob.report.get \ "data").as[String] shouldEqual "imageedit_2_3904987689.jpg"
      updatedJob.operations must haveSize(1)
      updatedJob.operations.map(o => (o \ "status").as[String]) must contain(beEqualTo("Success"))
        .forall
        .updateMessage(s => s"$s\nOperation has failed: ${updatedJob.operations.map("\n -" + _).mkString}")

      app[Database].roTransaction { implicit graph =>
        app[JobSrv].get(updatedJob).observable.has(_.message, "hello world").exists must beTrue
        val reportObservables = app[JobSrv].get(updatedJob).reportObservables.toSeq
        reportObservables.length must equalTo(2).updateMessage { s =>
          s"$s\nreport observables are : ${app[JobSrv].get(updatedJob).reportObservables.richObservable.toList.mkString("\n")}"
        }
        val ipObservable = reportObservables.find(_.dataType == "ip").get
        ipObservable.data    must beSome("192.168.1.1")
        ipObservable.message must beSome("myIp")
        ipObservable.tags    must contain(exactly("tag-test"))
        ipObservable.tlp     must beEqualTo(2)

        val operationObservableMaybe = app[JobSrv]
          .get(updatedJob)
          .observable
          .`case`
          .observables
          .has(_.message, "test-operation")
          .headOption
        operationObservableMaybe must beSome.which { operationObservable =>
          operationObservable.data must beSome("myData")
          operationObservable.tlp  must beEqualTo(3)
          operationObservable.tags must contain(exactly("tag1", "tag2"))
        }
        for {
          audit        <- app[AuditSrv].startTraversal.has(_.objectId, updatedJob._id.toString).getOrFail("Audit")
          organisation <- app[OrganisationSrv].getByName("cert").getOrFail("Organisation")
          user         <- app[UserSrv].startTraversal.getByName("certadmin@thehive.local").getOrFail("User")
        } yield JobFinished.filter(audit, Some(updatedJob), organisation, Some(user))
      } must beASuccessfulTry(true).setMessage("The audit doesn't match the expected criteria")
    }

    "submit a job" in testApp { app =>
      val x = for {
        observable <- app[Database].roTransaction { implicit graph =>
          app[ObservableSrv].startTraversal.has(_.message, "Some weird domain").richObservable.getOrFail("Observable")
        }
        case0 <- app[Database].roTransaction { implicit graph =>
          app[CaseSrv].getOrFail(EntityName("1"))
        }
      } yield await(app[JobSrv].submit("test", "anaTest1", observable, case0, JsObject.empty))

      x must beASuccessfulTry.which { job =>
        job.cortexId shouldEqual "test"
        job.workerId shouldEqual "anaTest1"
      }
    }
  }
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/services/ResponderSrvTest.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.cortex.client.{CortexClient, TestCortexClientProvider}
import org.thp.scalligraph.AppBuilder
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.connector.cortex.models.TheHiveCortexSchemaProvider
import org.thp.thehive.models.Permissions
import org.thp.thehive.services._
import play.api.libs.json.Json
import play.api.test.PlaySpecification

class ResponderSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext =
    DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert", permissions = Permissions.all).authContext

  override val databaseName: String = "thehiveCortex"
  override def appConfigure: AppBuilder =
    super
      .appConfigure
      .`override`(_.bindToProvider[Schema, TheHiveCortexSchemaProvider])
      .`override`(
        _.bindActor[CortexActor]("cortex-actor")
          .bindToProvider[CortexClient, TestCortexClientProvider]
          .bind[Connector, TestConnector]
          .bindToProvider[Schema, TheHiveCortexSchemaProvider]
      )

  "responder service" should {
    "fetch responders by type" in testApp { app =>
      val task = app[Database].roTransaction { implicit graph =>
        app[TaskSrv].startTraversal.has(_.title, "case 1 task 1").head
      }

      val r = await(app[ResponderSrv].getRespondersByType("case_task", task._id))

      r.find(_._1.name == "respTest1") must beSome
    }

    "search responders" in testApp { app =>
      val r = await(app[ResponderSrv].searchResponders(Json.obj("query" -> Json.obj())))

      r.size must be greaterThan 0
      r.head._2 shouldEqual Seq("test")
    }
  }
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/services/ServiceHelperTest.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import org.thp.cortex.client.{CortexClient, TestCortexClientProvider}
import org.thp.scalligraph.models.{Database, Schema}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AppBuilder, EntityName}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.connector.cortex.models.TheHiveCortexSchemaProvider
import org.thp.thehive.models.Organisation
import org.thp.thehive.services._
import play.api.test.PlaySpecification

class ServiceHelperTest extends PlaySpecification with TestAppBuilder {
  override val databaseName: String = "thehiveCortex"
  override def appConfigure: AppBuilder =
    super
      .appConfigure
      .`override`(_.bindToProvider[Schema, TheHiveCortexSchemaProvider])
      .`override`(
        _.bindActor[CortexActor]("cortex-actor")
          .bindToProvider[CortexClient, TestCortexClientProvider]
          .bind[Connector, TestConnector]
          .bindToProvider[Schema, TheHiveCortexSchemaProvider]
      )

  "service helper" should {
    "filter properly organisations according to supplied config" in testApp { app =>
      val r = app[Database].roTransaction { implicit graph =>
        app[ServiceHelper]
          .organisationFilter(
            app.apply[OrganisationSrv].startTraversal,
            List("*"),
            List("cert")
          )
          .toList
      }
      r must contain(Organisation.administration)

      val r2 = app[Database].roTransaction { implicit graph =>
        app[ServiceHelper]
          .organisationFilter(
            app.apply[OrganisationSrv].startTraversal,
            Nil,
            Nil
          )
          .toList
      }
      r2 must contain(Organisation.administration, Organisation("cert", "cert"))
    }

    "return the correct filtered CortexClient list" in testApp { app =>
      val client = app[CortexClient]
      val r      = app[ServiceHelper].availableCortexClients(Seq(client), EntityName(Organisation.administration.name))

      r must contain(client)
    }
  }
}

```

`cortex/connector/src/test/scala/org/thp/thehive/connector/cortex/services/TestConnector.scala`:

```scala
package org.thp.thehive.connector.cortex.services

import akka.actor.ActorSystem
import akka.stream.Materializer
import org.thp.cortex.client.CortexClient
import org.thp.scalligraph.services.config.ApplicationConfig

import javax.inject.{Inject, Singleton}
import scala.concurrent.ExecutionContext

@Singleton
class TestConnector @Inject() (
    client: CortexClient,
    appConfig: ApplicationConfig,
    mat: Materializer,
    system: ActorSystem,
    ec: ExecutionContext
) extends Connector(appConfig, mat, system, ec) {
  override def clients: Seq[CortexClient] = Seq(client)

  override protected def updateHealth(): Unit = ()
  override protected def updateStatus(): Unit = ()
}

```

`cortex/dto/src/main/scala/org/thp/cortex/dto/v0/Action.scala`:

```scala
package org.thp.cortex.dto.v0

import play.api.libs.json.{JsObject, Json, OFormat}

case class InputAction(
    label: String,
    data: JsObject,
    dataType: String,
    tlp: Int,
    pap: Int,
    parameters: JsObject
)

object InputAction {
  implicit val format: OFormat[InputAction] = Json.format[InputAction]
}

```

`cortex/dto/src/main/scala/org/thp/cortex/dto/v0/Artifact.scala`:

```scala
package org.thp.cortex.dto.v0

import play.api.libs.json._

case class InputArtifact(
    tlp: Int,
    pap: Int,
    dataType: String,
    message: String,
    data: Option[String],
    attachment: Option[Attachment],
    parameters: JsObject
)

object InputArtifact {
  implicit val writes: Writes[InputArtifact] = Writes[InputArtifact] { a =>
    Json.obj(
      "tlp"        -> a.tlp,
      "pap"        -> a.pap,
      "dataType"   -> a.dataType,
      "message"    -> a.message,
      "data"       -> a.data,
      "parameters" -> a.parameters
    )
  }
}

```

`cortex/dto/src/main/scala/org/thp/cortex/dto/v0/Attachment.scala`:

```scala
package org.thp.cortex.dto.v0

import akka.stream.scaladsl.Source
import akka.util.ByteString

case class Attachment(name: String, size: Long, contentType: String, data: Source[ByteString, _])

```

`cortex/dto/src/main/scala/org/thp/cortex/dto/v0/Job.scala`:

```scala
package org.thp.cortex.dto.v0

import play.api.libs.json._

import java.util.Date

object JobStatus extends Enumeration {
  val InProgress, Success, Failure, Waiting, Deleted = Value
}

object JobType extends Enumeration {
  val analyzer, responder = Value
}

case class InputJob(
    id: String,
    workerId: String,
    workerName: String,
    workerDefinition: String,
    date: Date
)

object InputJob {
  implicit val format: OFormat[InputJob] = Json.format[InputJob]
}

case class OutputJob(
    id: String,
    workerId: String,
    workerName: String,
    workerDefinition: String,
    date: Date,
    startDate: Option[Date],
    endDate: Option[Date],
    status: JobStatus.Value,
    data: Option[String],
    attachment: Option[JsObject],
    organization: String,
    dataType: String,
    report: Option[OutputReport],
    `type`: JobType.Value
)

case class OutputAttachment(id: String, name: Option[String], contentType: Option[String])

object OutputAttachment {
  implicit val format: Format[OutputAttachment] = Json.format[OutputAttachment]
}

case class OutputArtifact(
    dataType: String,
    data: Option[String],
    attachment: Option[OutputAttachment],
    message: Option[String],
    tlp: Int,
    tags: Set[String]
)

object OutputArtifact {
  implicit val format: Format[OutputArtifact] = Json.format[OutputArtifact]
}

case class OutputMinireport(level: String, namespace: String, predicate: String, value: JsValue)

object OutputMinireport {
  implicit val format: Format[OutputMinireport] = Json.format[OutputMinireport]

}

case class OutputReport(
    summary: Seq[OutputMinireport],
    full: Option[JsObject],
    success: Boolean,
    artifacts: Seq[OutputArtifact],
    operations: Seq[JsObject],
    errorMessage: Option[String],
    input: Option[String]
)

object OutputReport {
  implicit val writes: OWrites[OutputReport] = OWrites[OutputReport] { outputReport =>
    Json.obj(
      "summary"      -> Json.obj("taxonomies" -> Json.toJson(outputReport.summary)),
      "full"         -> Json.toJson(outputReport.full),
      "success"      -> Json.toJson(outputReport.success),
      "artifacts"    -> Json.toJson(outputReport.artifacts),
      "operations"   -> Json.toJson(outputReport.operations),
      "errorMessage" -> Json.toJson(outputReport.errorMessage),
      "input"        -> Json.toJson(outputReport.input)
    )
  }
  implicit val reads: Reads[OutputReport] = Reads[OutputReport] { json =>
    JsSuccess(
      OutputReport(
        (json \ "summary" \ "taxonomies").asOpt[Seq[OutputMinireport]].getOrElse(Nil),
        (json \ "full").asOpt[JsObject],
        (json \ "success").asOpt[Boolean].contains(true),
        (json \ "artifacts").asOpt[Seq[OutputArtifact]].getOrElse(Nil),
        (json \ "operations").asOpt[Seq[JsObject]].getOrElse(Nil),
        (json \ "errorMessage").asOpt[String],
        (json \ "input").asOpt[String]
      )
    )
  }
}

object OutputJob {
  implicit val jobStatusFormat: Format[JobStatus.Value] = Json.formatEnum(JobStatus)
  implicit val jobTypeFormat: Format[JobType.Value]     = Json.formatEnum(JobType)
  implicit val writes: Writes[OutputJob]                = Json.writes[OutputJob]
  implicit val reads: Reads[OutputJob] = Reads[OutputJob](json =>
    for {
      id       <- (json \ "id").validate[String]
      workerId <- (json \ "workerId").orElse(json \ "analyzerId").validate[String]
      workerName       = (json \ "workerName").orElse(json \ "analyzerName").validate[String].getOrElse(workerId)
      workerDefinition = (json \ "workerDefinitionId").orElse(json \ "analyzerDefinitionId").validate[String].getOrElse(workerId)
      data             = (json \ "data").asOpt[String]
      attachment       = (json \ "attachment").asOpt[JsObject]
      date <- (json \ "date").validate[Date]
      startDate = (json \ "startDate").asOpt[Date]
      endDate   = (json \ "endDate").asOpt[Date]
      status       <- (json \ "status").validate[JobStatus.Value]
      organization <- (json \ "organization").validate[String]
      dataType     <- (json \ "dataType").validate[String]
      report = (json \ "report").asOpt[OutputReport]
      jobType <- (json \ "type").validate[JobType.Value]
    } yield OutputJob(
      id,
      workerId,
      workerName,
      workerDefinition,
      date,
      startDate,
      endDate,
      status,
      data,
      attachment,
      organization,
      dataType,
      report,
      jobType
    )
  )
}

```

`cortex/dto/src/main/scala/org/thp/cortex/dto/v0/SearchQuery.scala`:

```scala
package org.thp.cortex.dto.v0

import play.api.libs.json.{JsObject, Json, Writes}

case class SearchQuery(
    field: String,
    value: String,
    range: String,
    queryOverride: Option[JsObject] = None
)

object SearchQuery {
  implicit val writes: Writes[SearchQuery] = (o: SearchQuery) =>
    o.queryOverride
      .getOrElse(
        Json.obj(
          "query" -> Json.obj(
            "_field" -> o.field,
            "_value" -> o.value
          )
        )
      ) ++ Json.obj("range" -> o.range)
}

```

`cortex/dto/src/main/scala/org/thp/cortex/dto/v0/Worker.scala`:

```scala
package org.thp.cortex.dto.v0

import play.api.libs.json.{Json, OFormat, Reads, Writes}

case class OutputWorker(
    id: String,
    name: String,
    version: String,
    description: String,
    dataTypeList: Seq[String],
    maxTlp: Long,
    maxPap: Long
)

object OutputWorker {
  implicit val writes: Writes[OutputWorker] = Json.writes[OutputWorker]
  implicit val reads: Reads[OutputWorker] = Reads[OutputWorker](json =>
    for {
      id           <- (json \ "id").validate[String]
      name         <- (json \ "name").validate[String]
      version      <- (json \ "version").validate[String]
      description  <- (json \ "description").validate[String]
      dataTypeList <- (json \ "dataTypeList").validateOpt[Seq[String]]
      maxTlp = (json \ "maxTlp").asOpt[Long].getOrElse(3L)
      maxPap = (json \ "maxPap").asOpt[Long].getOrElse(3L)
    } yield OutputWorker(
      id,
      name,
      version,
      description,
      dataTypeList.getOrElse(Nil),
      maxTlp,
      maxPap
    )
  )
}

case class InputWorker(id: String, name: String, description: String, dataTypeList: Seq[String])

object InputWorker {
  implicit val format: OFormat[InputWorker] = Json.format[InputWorker]
}

```

`debian.sbt`:

```sbt
import Common.{betaVersion, snapshotVersion, stableVersion, versionUsage}

linuxPackageMappings in Debian += packageMapping(file("LICENSE") -> "/usr/share/doc/thehive/copyright").withPerms("644")
name in Debian := "thehive4"
version in Debian := {
  version.value match {
    case stableVersion(_, _)                      => version.value
    case betaVersion(v1, v2, v3)                  => v1 + "-0." + v3 + "RC" + v2
    case snapshotVersion(stableVersion(v1, v2))   => v1 + "-" + v2 + "-SNAPSHOT"
    case snapshotVersion(betaVersion(v1, v2, v3)) => v1 + "-0." + v3 + "RC" + v2 + "-SNAPSHOT"
    case _                                        => versionUsage(version.value)
  }
}
debianPackageConflicts += "thehive"
debianPackageDependencies += "java8-runtime-headless"
maintainerScripts in Debian := maintainerScriptsFromDirectory(
  baseDirectory.value / "package" / "debian",
  Seq(DebianConstants.Postinst, DebianConstants.Prerm, DebianConstants.Postrm)
)
linuxMakeStartScript in Debian := None

```

`docker.sbt`:

```sbt
import Common.{betaVersion, snapshotVersion, stableVersion, versionUsage}
import com.typesafe.sbt.packager.docker.{Cmd, ExecCmd}

version in Docker := {
  version.value match {
    case stableVersion(_, _)                      => version.value
    case betaVersion(v1, v2, v3)                  => v1 + "-0." + v3 + "RC" + v2
    case snapshotVersion(stableVersion(v1, v2))   => v1 + "-" + v2 + "-SNAPSHOT"
    case snapshotVersion(betaVersion(v1, v2, v3)) => v1 + "-0." + v3 + "RC" + v2 + "-SNAPSHOT"
    case _                                        => versionUsage(version.value)
  }
}
defaultLinuxInstallLocation in Docker := "/opt/thehive"
dockerRepository := Some("thehiveproject")
dockerUpdateLatest := !version.value.toUpperCase.contains("RC") && !version.value.contains("SNAPSHOT")
dockerExposedPorts := Seq(9000)
mappings in Docker ++= Seq(
  file("package/docker/entrypoint")     -> "/opt/thehive/entrypoint",
  file("package/logback.xml")           -> "/etc/thehive/logback.xml",
  file("package/logback-migration.xml") -> "/etc/thehive/logback-migration.xml",
  file("package/empty")                 -> "/var/log/thehive/application.log"
)
mappings in Docker ~= (_.filterNot {
  case (_, filepath) => filepath == "/opt/thehive/conf/application.conf"
})
dockerCommands := Seq(
  Cmd("FROM", "openjdk:8"),
  Cmd("LABEL", "MAINTAINER=\"TheHive Project <support@thehive-project.org>\"", "repository=\"https://github.com/TheHive-Project/TheHive\""),
  Cmd("WORKDIR", "/opt/thehive"),
  // format: off
  Cmd("RUN",
    "apt", "update", "&&",
    "apt", "upgrade", "-y", "&&",
    "apt", "autoclean", "-y", "-q",  "&&",
    "apt", "autoremove", "-y", "-q",  "&&",
    "rm", "-rf", "/var/lib/apt/lists/*", "&&",
    "(", "type", "groupadd", "1>/dev/null", "2>&1", "&&",
      "groupadd", "-g", "1000", "thehive", "||",
      "addgroup", "-g", "1000", "-S", "thehive",
    ")", "&&",
    "(", "type", "useradd", "1>/dev/null", "2>&1", "&&",
      "useradd", "--system", "--uid", "1000", "--gid", "1000", "thehive", "||",
      "adduser", "-S", "-u", "1000", "-G", "thehive", "thehive",
    ")"),
  //format: on
  Cmd("ADD", "--chown=root:root", "opt", "/opt"),
  Cmd("ADD", "--chown=thehive:thehive", "var", "/var"),
  Cmd("ADD", "--chown=thehive:thehive", "etc", "/etc"),
  ExecCmd("RUN", "chmod", "+x", "/opt/thehive/bin/thehive", "/opt/thehive/entrypoint", "/opt/thehive/bin/cloner", "/opt/thehive/bin/migrate"),
  Cmd("RUN", "mkdir", "/data", "/opt/thp", "&&", "chown", "thehive:thehive", "/data", "/opt/thp"),
  Cmd("EXPOSE", "9000"),
  Cmd("USER", "thehive"),
  ExecCmd("ENTRYPOINT", "/opt/thehive/entrypoint"),
  ExecCmd("CMD")
)

```

`dto/src/main/scala/org/thp/thehive/connector/cortex/dto/v0/Action.scala`:

```scala
package org.thp.thehive.connector.cortex.dto.v0

import play.api.libs.json.{JsObject, Json, OFormat}

import java.util.Date

case class InputAction(
    responderId: String,
    cortexId: Option[String],
    objectType: String,
    objectId: String,
    parameters: Option[JsObject],
    tlp: Option[Int]
)

object InputAction {
  implicit val format: OFormat[InputAction] = Json.format[InputAction]
}

case class OutputAction(
    responderId: String,
    responderName: Option[String],
    responderDefinition: Option[String],
    cortexId: Option[String],
    cortexJobId: Option[String],
    objectType: String,
    objectId: String,
    status: String,
    startDate: Date,
    endDate: Option[Date],
    operations: String,
    report: String
)

object OutputAction {
  implicit val format: OFormat[OutputAction] = Json.format[OutputAction]
}

```

`dto/src/main/scala/org/thp/thehive/connector/cortex/dto/v0/Job.scala`:

```scala
package org.thp.thehive.connector.cortex.dto.v0

import org.thp.thehive.dto.v0.OutputObservable
import play.api.libs.json.{JsObject, Json, OFormat}

import java.util.Date

case class OutputJob(
    _type: String,
    analyzerId: String,
    analyzerName: String,
    analyzerDefinition: String,
    status: String,
    startDate: Date,
    endDate: Date,
    report: Option[JsObject],
    cortexId: String,
    cortexJobId: String,
    id: String,
    case_artifact: Option[OutputObservable],
    operations: String
)

object OutputJob {
  implicit val format: OFormat[OutputJob] = Json.format[OutputJob]
}

```

`dto/src/main/scala/org/thp/thehive/connector/cortex/dto/v0/ReportTemplate.scala`:

```scala
package org.thp.thehive.connector.cortex.dto.v0

import play.api.libs.json.{Json, OFormat}

case class OutputAnalyzerTemplate(
    id: String,
    analyzerId: String,
    content: String
)

object OutputAnalyzerTemplate {
  implicit val format: OFormat[OutputAnalyzerTemplate] = Json.format[OutputAnalyzerTemplate]
}

case class InputAnalyzerTemplate(
    analyzerId: String,
    content: String
)

object InputAnalyzerTemplate {
  implicit val format: OFormat[InputAnalyzerTemplate] = Json.format[InputAnalyzerTemplate]
}

```

`dto/src/main/scala/org/thp/thehive/connector/cortex/dto/v0/Responder.scala`:

```scala
package org.thp.thehive.connector.cortex.dto.v0

import play.api.libs.json.{Json, OFormat}

case class InputResponder(
    name: String,
    description: String,
    dataTypeList: Seq[String]
)

object InputResponder {
  implicit val format: OFormat[InputResponder] = Json.format[InputResponder]
}

case class OutputResponder(
    id: String,
    name: String,
    version: String,
    description: String,
    dataTypeList: Seq[String],
    maxTlp: Option[Long],
    maxPap: Option[Long],
    cortexIds: List[String] = Nil
)

object OutputResponder {
  implicit val format: OFormat[OutputResponder] = Json.format[OutputResponder]
}

```

`dto/src/main/scala/org/thp/thehive/connector/cortex/dto/v0/Worker.scala`:

```scala
package org.thp.thehive.connector.cortex.dto.v0

import play.api.libs.json.{Json, OFormat}

case class OutputWorker(
    id: String,
    name: String,
    version: String,
    description: String,
    dataTypeList: Seq[String],
    cortexIds: Seq[String]
)

object OutputWorker {
  implicit val format: OFormat[OutputWorker] = Json.format[OutputWorker]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Alert.scala`:

```scala
package org.thp.thehive.dto.v0

import org.thp.scalligraph.controllers.WithParser
import play.api.libs.json._

import java.util.Date

case class InputAlert(
    `type`: String,
    source: String,
    sourceRef: String,
    externalLink: Option[String],
    title: String,
    description: String,
    severity: Option[Int] = None,
    date: Option[Date] = None,
    tags: Set[String] = Set.empty,
    flag: Option[Boolean] = None,
    tlp: Option[Int] = None,
    pap: Option[Int] = None,
    @WithParser(InputCustomFieldValue.parser)
    customFields: Seq[InputCustomFieldValue] = Nil
)

object InputAlert {
  implicit val writes: OWrites[InputAlert] = Json.writes[InputAlert]
}

case class OutputSimilarCase(
    _id: String,
    id: String,
    caseId: Int, // number
    title: String,
    severity: Int,
    startDate: Date,
    endDate: Option[Date] = None,
    resolutionStatus: Option[String] = None,
    tags: Set[String] = Set.empty,
    tlp: Int,
    status: String,
    similarIocCount: Int,
    iocCount: Int,
    similarArtifactCount: Int,
    artifactCount: Int
)

object OutputSimilarCase {
  implicit val format: OFormat[OutputSimilarCase] = Json.format[OutputSimilarCase]
}

case class OutputAlert(
    _id: String,
    id: String,
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    _type: String,
    `type`: String,
    source: String,
    sourceRef: String,
    externalLink: Option[String],
    title: String,
    description: String,
    severity: Int,
    date: Date,
    tags: Set[String] = Set.empty,
    tlp: Int,
    pap: Int,
    status: String,
    follow: Boolean,
    `case`: Option[String],
    customFields: JsObject,
    caseTemplate: Option[String] = None,
    artifacts: Seq[OutputObservable] = Nil,
    similarCases: Seq[OutputSimilarCase]
)

object OutputAlert {
  implicit val reads: Reads[OutputAlert] = Reads[OutputAlert] { json =>
    for {
      _id          <- (json \ "_id").validate[String]
      id           <- (json \ "id").validate[String]
      createdBy    <- (json \ "createdBy").validate[String]
      updatedBy    <- (json \ "updatedBy").validateOpt[String]
      createdAt    <- (json \ "createdAt").validate[Date]
      updatedAt    <- (json \ "updatedAt").validateOpt[Date]
      _type        <- (json \ "_type").validate[String]
      tpe          <- (json \ "type").validate[String]
      source       <- (json \ "source").validate[String]
      sourceRef    <- (json \ "sourceRef").validate[String]
      externalLink <- (json \ "externalLink").validateOpt[String]
      case0        <- (json \ "case").validateOpt[String]
      title        <- (json \ "title").validate[String]
      description  <- (json \ "description").validate[String]
      severity     <- (json \ "severity").validate[Int]
      date         <- (json \ "date").validate[Date]
      tags         <- (json \ "tags").validate[Set[String]]
      tlp          <- (json \ "tlp").validate[Int]
      pap          <- (json \ "pap").validate[Int]
      status       <- (json \ "status").validate[String]
      follow       <- (json \ "follow").validate[Boolean]
      customFields <- (json \ "customFields").validate[JsObject]
      caseTemplate <- (json \ "caseTemplate").validateOpt[String]
      artifacts    <- (json \ "artifacts").validate[Seq[OutputObservable]]
      similarCases <- (json \ "similarCases").validate[Seq[OutputSimilarCase]]
    } yield OutputAlert(
      _id,
      id,
      createdBy,
      updatedBy,
      createdAt,
      updatedAt,
      _type,
      tpe,
      source,
      sourceRef,
      externalLink,
      title,
      description,
      severity,
      date,
      tags,
      tlp,
      pap,
      status,
      follow,
      case0,
      customFields,
      caseTemplate,
      artifacts,
      similarCases
    )
  }
  implicit val writes: OWrites[OutputAlert] = OWrites[OutputAlert] { outputAlert =>
    Json.obj(
      "_id"          -> outputAlert._id,
      "id"           -> outputAlert.id,
      "createdBy"    -> outputAlert.createdBy,
      "updatedBy"    -> outputAlert.updatedBy,
      "createdAt"    -> outputAlert.createdAt,
      "updatedAt"    -> outputAlert.updatedAt,
      "_type"        -> outputAlert._type,
      "type"         -> outputAlert.`type`,
      "source"       -> outputAlert.source,
      "sourceRef"    -> outputAlert.sourceRef,
      "externalLink" -> outputAlert.externalLink,
      "case"         -> outputAlert.`case`,
      "title"        -> outputAlert.title,
      "description"  -> outputAlert.description,
      "severity"     -> outputAlert.severity,
      "date"         -> outputAlert.date,
      "tags"         -> outputAlert.tags,
      "tlp"          -> outputAlert.tlp,
      "pap"          -> outputAlert.pap,
      "status"       -> outputAlert.status,
      "follow"       -> outputAlert.follow,
      "customFields" -> outputAlert.customFields,
      "caseTemplate" -> outputAlert.caseTemplate,
      "artifacts"    -> outputAlert.artifacts,
      "similarCases" -> outputAlert.similarCases
    )
  }
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Attachment.scala`:

```scala
package org.thp.thehive.dto.v0

import play.api.libs.json.{Json, OFormat, Writes}

case class InputAttachment(name: String, contentType: String, id: String)

object InputAttachment {
  implicit val writes: Writes[InputAttachment] = Json.writes[InputAttachment]
}

case class OutputAttachment(name: String, hashes: Seq[String], size: Long, contentType: String, id: String)

object OutputAttachment {
  implicit val format: OFormat[OutputAttachment] = Json.format[OutputAttachment]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Audit.scala`:

```scala
package org.thp.thehive.dto.v0

import org.thp.scalligraph.models.Entity
import play.api.libs.json._

import java.util.Date

case class OutputEntity(_type: String, _id: String, _createdAt: Date, _createdBy: String, _updatedAt: Option[Date], _updatedBy: Option[String])

object OutputEntity {
  implicit val format: OFormat[OutputEntity] = Json.format[OutputEntity]

  def apply(e: Entity): OutputEntity =
    OutputEntity(
      e._label,
      e._id.toString,
      e._createdAt,
      e._createdBy,
      e._updatedAt,
      e._updatedBy
    )
}

case class OutputAudit(
    _id: String,
    id: String,
    createdBy: String,
//    _updatedBy: Option[String] = None, // can't be set
    createdAt: Date,
//    _updatedAt: Option[Date] = None, // can't be set
    _type: String,
    base: Boolean = true, // always true
    details: JsObject,
    objectId: String,
    objectType: String,
    operation: String,
    requestId: String,
    rootId: String,
    startDate: Date,
    `object`: Option[OutputEntity],
    summary: Map[String, Map[String, Int]]
)

object OutputAudit {

  val auditWrites: OWrites[OutputAudit] = Json.writes[OutputAudit].transform { js: JsObject =>
    Json.obj("base" -> (js - "summary"), "summary" -> (js \ "summary").asOpt[JsObject], "_type" -> "audit")
  }

  val auditReads: Reads[OutputAudit] = Reads[OutputAudit] { js =>
    for {
      base    <- (js \ "base").validate[JsObject]
      summary <- (js \ "summary").validate[JsObject]
      audit   <- Json.reads[OutputAudit].reads(base ++ summary)
    } yield audit
  }
  implicit val format: OFormat[OutputAudit] = OFormat(auditReads, auditWrites)
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Case.scala`:

```scala
package org.thp.thehive.dto.v0

import org.thp.scalligraph.controllers.WithParser
import play.api.libs.json._

import java.util.Date

case class InputCase(
    title: String,
    description: String,
    severity: Option[Int] = None,
    startDate: Option[Date] = None,
    endDate: Option[Date] = None,
    tags: Set[String] = Set.empty,
    flag: Option[Boolean] = None,
    tlp: Option[Int] = None,
    pap: Option[Int] = None,
    status: Option[String] = None,
    summary: Option[String] = None,
    user: Option[String] = None,
    @WithParser(InputCustomFieldValue.parser)
    customFields: Seq[InputCustomFieldValue] = Nil
)

object InputCase {
  implicit val writes: OWrites[InputCase] = Json.writes[InputCase]
}

case class OutputCase(
    _id: String,
    id: String,
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    _type: String,
    caseId: Int, // number
    title: String,
    description: String,
    severity: Int,
    startDate: Date,
    endDate: Option[Date] = None,
    impactStatus: Option[String] = None,
    resolutionStatus: Option[String] = None,
    tags: Set[String] = Set.empty,
    flag: Boolean,
    tlp: Int,
    pap: Int,
    status: String,
    summary: Option[String] = None,
    owner: Option[String], // user
    customFields: JsObject,
    stats: JsValue,
    permissions: Set[String]
)

object OutputCase {

  implicit val writes: OWrites[OutputCase] = OWrites[OutputCase](c =>
    Json.obj(
      "_id"              -> c._id,
      "id"               -> c.id,
      "createdBy"        -> c.createdBy,
      "updatedBy"        -> c.updatedBy,
      "createdAt"        -> c.createdAt,
      "updatedAt"        -> c.updatedAt,
      "_type"            -> c._type,
      "caseId"           -> c.caseId,
      "title"            -> c.title,
      "description"      -> c.description,
      "severity"         -> c.severity,
      "startDate"        -> c.startDate,
      "endDate"          -> c.endDate,
      "impactStatus"     -> c.impactStatus,
      "resolutionStatus" -> c.resolutionStatus,
      "tags"             -> c.tags,
      "flag"             -> c.flag,
      "tlp"              -> c.tlp,
      "pap"              -> c.pap,
      "status"           -> c.status,
      "summary"          -> c.summary,
      "owner"            -> c.owner,
      "customFields"     -> c.customFields,
      "stats"            -> c.stats,
      "permissions"      -> c.permissions
    )
  )

  implicit val reads: Reads[OutputCase] = Reads[OutputCase](j =>
    for {
      _id              <- (j \ "_id").validate[String]
      id               <- (j \ "id").validate[String]
      createdBy        <- (j \ "createdBy").validate[String]
      updatedBy        <- (j \ "updatedBy").validateOpt[String]
      createdAt        <- (j \ "createdAt").validate[Date]
      updatedAt        <- (j \ "updatedAt").validateOpt[Date]
      _type            <- (j \ "_type").validate[String]
      caseId           <- (j \ "caseId").validate[Int]
      title            <- (j \ "title").validate[String]
      description      <- (j \ "description").validate[String]
      severity         <- (j \ "severity").validate[Int]
      startDate        <- (j \ "startDate").validate[Date]
      endDate          <- (j \ "endDate").validateOpt[Date]
      impactStatus     <- (j \ "impactStatus").validateOpt[String]
      resolutionStatus <- (j \ "resolutionStatus").validateOpt[String]
      tags             <- (j \ "tags").validate[Set[String]]
      flag             <- (j \ "flag").validate[Boolean]
      tlp              <- (j \ "tlp").validate[Int]
      pap              <- (j \ "pap").validate[Int]
      status           <- (j \ "status").validate[String]
      summary          <- (j \ "summary").validateOpt[String]
      owner            <- (j \ "owner").validateOpt[String]
      customFields     <- (j \ "customFields").validate[JsObject]
      stats            <- (j \ "stats").validate[JsValue]
      permissions      <- (j \ "permissions").validate[Set[String]]
    } yield OutputCase(
      _id,
      id,
      createdBy,
      updatedBy,
      createdAt,
      updatedAt,
      _type,
      caseId,
      title,
      description,
      severity,
      startDate,
      endDate,
      impactStatus,
      resolutionStatus,
      tags,
      flag,
      tlp,
      pap,
      status,
      summary,
      owner,
      customFields,
      stats,
      permissions
    )
  )
  implicit val format: OFormat[OutputCase] = OFormat(reads, writes)
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/CaseTemplate.scala`:

```scala
package org.thp.thehive.dto.v0

import org.thp.scalligraph.controllers.WithParser
import play.api.libs.json.{JsObject, Json, OFormat, OWrites}

import java.util.Date

case class InputCaseTemplate(
    name: String,
    displayName: Option[String],
    titlePrefix: Option[String],
    description: Option[String],
    severity: Option[Int] = None,
    tags: Set[String] = Set.empty,
    flag: Option[Boolean] = None,
    tlp: Option[Int] = None,
    pap: Option[Int] = None,
    summary: Option[String] = None,
    tasks: Seq[InputTask] = Nil,
    @WithParser(InputCustomFieldValue.parser)
    customFields: Seq[InputCustomFieldValue] = Nil
)

object InputCaseTemplate {
  implicit val writes: OWrites[InputCaseTemplate] = Json.writes[InputCaseTemplate]
}

case class OutputCaseTemplate(
    _id: String,
    id: String,
    createdBy: String,
    updatedBy: Option[String],
    createdAt: Date,
    updatedAt: Option[Date],
    _type: String,
    name: String,
    displayName: String,
    titlePrefix: Option[String],
    description: Option[String],
    severity: Option[Int],
    tags: Set[String],
    flag: Boolean,
    tlp: Option[Int],
    pap: Option[Int],
    summary: Option[String],
    tasks: Seq[OutputTask],
    status: String,
    customFields: JsObject,
    metrics: JsObject
)

object OutputCaseTemplate {
  implicit val format: OFormat[OutputCaseTemplate] = Json.format[OutputCaseTemplate]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/CustomFieldValue.scala`:

```scala
package org.thp.thehive.dto.v0

import org.scalactic.Accumulation._
import org.scalactic._
import org.thp.scalligraph.controllers.{FNull, _}
import org.thp.scalligraph.{AttributeError, InvalidFormatAttributeError}
import play.api.libs.json._

import java.util.Date

case class OutputCustomField(
    id: String,
    name: String,
    reference: String,
    description: String,
    `type`: String,
    options: Seq[JsValue],
    mandatory: Boolean
)

object OutputCustomField {
  implicit val format: OFormat[OutputCustomField] = Json.format[OutputCustomField]
}

case class InputCustomFieldValue(name: String, value: Option[Any], order: Option[Int])

object InputCustomFieldValue {

  def getStringCustomField(name: String, obj: FObject): Option[Or[InputCustomFieldValue, Every[AttributeError]]] =
    obj.get("string") match {
      case FUndefined     => None
      case FNull          => Some(Good(InputCustomFieldValue(name, None, obj.getNumber("order").map(_.toInt))))
      case FString(value) => Some(Good(InputCustomFieldValue(name, Some(value), obj.getNumber("order").map(_.toInt))))
      case other          => Some(Bad(One(InvalidFormatAttributeError(s"customField.$name.string", "string", Set.empty, other))))
    }

  def getIntegerCustomField(name: String, obj: FObject): Option[Or[InputCustomFieldValue, Every[AttributeError]]] =
    obj.get("integer") match {
      case FUndefined     => None
      case FNull          => Some(Good(InputCustomFieldValue(name, None, obj.getNumber("order").map(_.toInt))))
      case FNumber(value) => Some(Good(InputCustomFieldValue(name, Some(value.toInt), obj.getNumber("order").map(_.toInt))))
      case other          => Some(Bad(One(InvalidFormatAttributeError(s"customField.$name.integer", "integer", Set.empty, other))))
    }

  def getFloatCustomField(name: String, obj: FObject): Option[Or[InputCustomFieldValue, Every[AttributeError]]] =
    obj.get("float") match {
      case FUndefined     => None
      case FNull          => Some(Good(InputCustomFieldValue(name, None, obj.getNumber("order").map(_.toInt))))
      case FNumber(value) => Some(Good(InputCustomFieldValue(name, Some(value.toDouble), obj.getNumber("order").map(_.toInt))))
      case other          => Some(Bad(One(InvalidFormatAttributeError(s"customField.$name.float", "float", Set.empty, other))))
    }

  def getDateCustomField(name: String, obj: FObject): Option[Or[InputCustomFieldValue, Every[AttributeError]]] =
    obj.get("date") match {
      case FUndefined     => None
      case FNull          => Some(Good(InputCustomFieldValue(name, None, obj.getNumber("order").map(_.toInt))))
      case FNumber(value) => Some(Good(InputCustomFieldValue(name, Some(new Date(value.toLong)), obj.getNumber("order").map(_.toInt))))
      case other          => Some(Bad(One(InvalidFormatAttributeError(s"customField.$name.date", "date", Set.empty, other))))
    }

  def getBooleanCustomField(name: String, obj: FObject): Option[Or[InputCustomFieldValue, Every[AttributeError]]] =
    obj.get("boolean") match {
      case FUndefined      => None
      case FNull           => Some(Good(InputCustomFieldValue(name, None, obj.getNumber("order").map(_.toInt))))
      case FBoolean(value) => Some(Good(InputCustomFieldValue(name, Some(value), obj.getNumber("order").map(_.toInt))))
      case other           => Some(Bad(One(InvalidFormatAttributeError(s"customField.$name.boolean", "boolean", Set.empty, other))))
    }

  val parser: FieldsParser[Seq[InputCustomFieldValue]] = FieldsParser("customFieldValue") {
    case (_, FObject(fields)) =>
      fields
        .toSeq
        .validatedBy {
          case (name, FString(value))   => Good(InputCustomFieldValue(name, Some(value), None))
          case (name, FNumber(value))   => Good(InputCustomFieldValue(name, Some(value), None))
          case (name, FBoolean(value))  => Good(InputCustomFieldValue(name, Some(value), None))
          case (name, FAny(value :: _)) => Good(InputCustomFieldValue(name, Some(value), None))
          case (name, FNull)            => Good(InputCustomFieldValue(name, None, None))
          case (name, obj: FObject) =>
            getStringCustomField(name, obj) orElse
              getIntegerCustomField(name, obj) orElse
              getFloatCustomField(name, obj) orElse
              getDateCustomField(name, obj) orElse
              getBooleanCustomField(name, obj) getOrElse
              Good(InputCustomFieldValue(name, None, None))
          case (name, other) =>
            Bad(
              One(
                InvalidFormatAttributeError(name, "CustomFieldValue", Set("field: string", "field: number", "field: boolean", "field: date"), other)
              )
            )
        }
        .map(_.toSeq)
    case (_, FUndefined) => Good(Nil)
  }

  implicit val writes: Writes[Seq[InputCustomFieldValue]] = Writes[Seq[InputCustomFieldValue]] { icfv =>
    val fields = icfv.map {
      case InputCustomFieldValue(name, Some(s: String), _)  => name -> JsString(s)
      case InputCustomFieldValue(name, Some(l: Long), _)    => name -> JsNumber(l)
      case InputCustomFieldValue(name, Some(d: Double), _)  => name -> JsNumber(d)
      case InputCustomFieldValue(name, Some(i: Integer), _) => name -> JsNumber(i.toLong)
      case InputCustomFieldValue(name, Some(f: Float), _)   => name -> JsNumber(f.toDouble)
      case InputCustomFieldValue(name, Some(b: Boolean), _) => name -> JsBoolean(b)
      case InputCustomFieldValue(name, Some(d: Date), _)    => name -> JsNumber(d.getTime)
      case InputCustomFieldValue(name, None, _)             => name -> JsNull
      case InputCustomFieldValue(name, other, _)            => sys.error(s"The custom field $name has invalid value: $other (${other.getClass})")
    }
    JsObject(fields)
  }
}

case class InputCustomField(
    name: String,
    description: String,
    `type`: String,
    reference: String,
    mandatory: Option[Boolean],
    options: Seq[JsValue] = Nil
)

object InputCustomField {
  implicit val reads: Reads[InputCustomField] = Json.reads[InputCustomField]
}

case class OutputCustomFieldValue(name: String, description: String, tpe: String, value: Option[String])

object OutputCustomFieldValue {
  implicit val format: OFormat[OutputCustomFieldValue] = Json.format[OutputCustomFieldValue]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Dashboard.scala`:

```scala
package org.thp.thehive.dto.v0

import play.api.libs.json.{Json, OFormat, OWrites}

import java.util.Date

case class InputDashboard(title: String, description: String, status: String, definition: String)

object InputDashboard {
  implicit val writes: OWrites[InputDashboard] = Json.writes[InputDashboard]
}

case class OutputDashboard(
    _id: String,
    id: String,
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    _type: String,
    title: String,
    description: String,
    status: String,
    definition: String,
    writable: Boolean
)

object OutputDashboard {
  implicit val format: OFormat[OutputDashboard] = Json.format[OutputDashboard]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Log.scala`:

```scala
package org.thp.thehive.dto.v0

import org.thp.scalligraph.controllers.FFile
import play.api.libs.json.{Json, OFormat}

import java.util.Date

case class InputLog(message: String, startDate: Option[Date] = None, attachment: Option[FFile] = None)

case class OutputLog(
    _id: String,
    id: String, // _id
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    _type: String,
    message: String,
    startDate: Date,
    attachment: Option[OutputAttachment] = None,
    status: String,
    owner: String,
    case_task: Option[OutputTask]
)

object OutputLog {
  implicit val format: OFormat[OutputLog] = Json.format[OutputLog]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Observable.scala`:

```scala
package org.thp.thehive.dto.v0

import org.scalactic.Accumulation._
import org.scalactic.Good
import org.thp.scalligraph.controllers._
import play.api.libs.json.{JsObject, Json, OFormat, Writes}

import java.util.Date

case class InputObservable(
    dataType: String,
    @WithParser(InputObservable.dataParser)
    data: Seq[String] = Nil,
    message: Option[String] = None,
    startDate: Option[Date] = None,
    @WithParser(InputObservable.fileOrAttachmentParser)
    attachment: Seq[Either[FFile, InputAttachment]] = Seq.empty,
    tlp: Option[Int] = None,
    tags: Set[String] = Set.empty,
    ioc: Option[Boolean] = None,
    sighted: Option[Boolean] = None,
    ignoreSimilarity: Option[Boolean] = None
)

object InputObservable {
  implicit val fileOrAttachmentWrites: Writes[Either[FFile, InputAttachment]] = Writes[Either[FFile, InputAttachment]] {
    case Left(file)        => Json.toJson(file)
    case Right(attachment) => Json.toJson(attachment)
  }
  implicit val writes: Writes[InputObservable] = Json.writes[InputObservable]

  val dataParser: FieldsParser[Seq[String]] = FieldsParser[Seq[String]]("data") {
    case (_, FString(s)) => Good(Seq(s))
    case (_, FAny(s))    => Good(s)
    case (_, FSeq(a))    => a.validatedBy(FieldsParser.string(_))
    case (_, FUndefined) => Good(Nil)
  }

  val fileOrAttachmentParser: FieldsParser[Seq[Either[FFile, InputAttachment]]] =
    FieldsParser[FFile]
      .map("fileOrAttachmentParser")(f => Seq(Left(f)))
      .recover(
        FieldsParser[InputAttachment]
          .map("fileOrAttachmentParser")(a => Seq(Right(a)))
          .recover(
            FieldsParser[InputAttachment]
              .sequence
              .map("fileOrAttachmentParser")(as => as.map(Right(_)))
          )
      )
}

case class OutputObservable(
    _id: String,
    id: String, // _id
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    _type: String,
    dataType: String,
    data: Option[String],
    startDate: Date,
    attachment: Option[OutputAttachment],
    tlp: Int,
    tags: Set[String],
    ioc: Boolean,
    sighted: Boolean,
    message: Option[String],
    reports: JsObject,
    stats: JsObject,
    seen: Option[Boolean],
    `case`: Option[OutputCase],
    alert: Option[OutputAlert],
    ignoreSimilarity: Option[Boolean]
)

object OutputObservable {
  implicit val format: OFormat[OutputObservable] = Json.format[OutputObservable]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/ObservableType.scala`:

```scala
package org.thp.thehive.dto.v0

import play.api.libs.json.{Json, OFormat, Writes}

import java.util.Date

case class InputObservableType(name: String, isAttachment: Option[Boolean])
object InputObservableType {
  implicit val writes: Writes[InputObservableType] = Json.writes[InputObservableType]
}

case class OutputObservableType(
    name: String,
    isAttachment: Boolean,
    _id: String,
    id: String,
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    _type: String
)

object OutputObservableType {
  implicit val format: OFormat[OutputObservableType] = Json.format[OutputObservableType]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Organistion.scala`:

```scala
package org.thp.thehive.dto.v0

import play.api.libs.json.{Format, Json, Writes}

import java.util.Date

case class InputOrganisation(name: String, description: String)

object InputOrganisation {
  implicit val writes: Writes[InputOrganisation] = Json.writes[InputOrganisation]
}

case class OutputOrganisation(
    name: String,
    description: String,
    _id: String,
    id: String,
    createdAt: Date,
    createdBy: String,
    updatedAt: Option[Date],
    updatedBy: Option[String],
    _type: String,
    links: Seq[String]
)

object OutputOrganisation {
  implicit val format: Format[OutputOrganisation] = Json.format[OutputOrganisation]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Page.scala`:

```scala
package org.thp.thehive.dto.v0

import play.api.libs.json._

import java.util.Date

case class InputPage(
    title: String,
    content: String,
    order: Option[Int],
    category: String
)

object InputPage {
  implicit val writes: OWrites[InputPage] = Json.writes[InputPage]
}

case class OutputPage(
    _id: String,
    id: String,
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    title: String,
    content: String,
    _type: String,
    slug: String,
    order: Int,
    category: String
)

object OutputPage {
  implicit val format: OFormat[OutputPage] = Json.format[OutputPage]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Permission.scala`:

```scala
package org.thp.thehive.dto.v0

import play.api.libs.json.{Json, OFormat}

case class OutputPermission(name: String, label: String, scope: Seq[String])

object OutputPermission {
  implicit val format: OFormat[OutputPermission] = Json.format[OutputPermission]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Profile.scala`:

```scala
package org.thp.thehive.dto.v0

import play.api.libs.json.{Json, OFormat, OWrites}

import java.util.Date

case class InputProfile(name: String, permissions: Set[String])

object InputProfile {
  implicit val writes: OWrites[InputProfile] = Json.writes[InputProfile]
}

case class OutputProfile(
    _id: String,
    id: String,
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    _type: String,
    name: String,
    permissions: Seq[String],
    editable: Boolean,
    isAdmin: Boolean
)

object OutputProfile {
  implicit val format: OFormat[OutputProfile] = Json.format[OutputProfile]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Share.scala`:

```scala
package org.thp.thehive.dto.v0

import org.thp.thehive.dto.v0.ObservablesFilter.ObservablesFilter
import org.thp.thehive.dto.v0.TasksFilter.TasksFilter
import play.api.libs.json.{Format, Json, Writes}

import java.util.Date

case class InputShare(organisationName: String, profile: String, tasks: TasksFilter, observables: ObservablesFilter)

object TasksFilter extends Enumeration {
  type TasksFilter = Value

  val all: TasksFilter  = Value("all")
  val none: TasksFilter = Value("none")

  implicit val format: Format[TasksFilter] = Json.formatEnum(TasksFilter)
}

object ObservablesFilter extends Enumeration {
  type ObservablesFilter = Value

  val all: ObservablesFilter  = Value("all")
  val none: ObservablesFilter = Value("none")

  implicit val format: Format[ObservablesFilter] = Json.formatEnum(ObservablesFilter)
}

object InputShare {
  implicit val writes: Writes[InputShare] = Json.writes[InputShare]
}

case class OutputShare(
    _id: String,
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    caseId: String,
    profileName: String,
    organisationName: String,
    owner: Boolean
)

object OutputShare {
  implicit val format: Format[OutputShare] = Json.format[OutputShare]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Tag.scala`:

```scala
package org.thp.thehive.dto.v0

import play.api.libs.json.{Json, OFormat, OWrites}

case class InputTag(namespace: String, predicate: String, value: Option[String], description: Option[String], colour: Option[String])

object InputTag {
  implicit val writes: OWrites[InputTag] = Json.writes[InputTag]
}

case class OutputTag(namespace: String, predicate: String, value: Option[String], description: Option[String], colour: String)

object OutputTag {
  implicit val format: OFormat[OutputTag] = Json.format[OutputTag]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/Task.scala`:

```scala
package org.thp.thehive.dto.v0

import play.api.libs.json.{Json, OFormat, OWrites}

import java.util.Date

case class InputTask(
    title: String,
    group: Option[String] = None,
    description: Option[String] = None,
    owner: Option[String] = None,
    status: Option[String] = None,
    flag: Option[Boolean] = None,
    startDate: Option[Date] = None,
    endDate: Option[Date] = None,
    order: Option[Int] = None,
    dueDate: Option[Date] = None
)

object InputTask {
  implicit val writes: OWrites[InputTask] = Json.writes[InputTask]
}

case class OutputTask(
    id: String,
    _id: String,
    createdBy: String,
    updatedBy: Option[String] = None,
    createdAt: Date,
    updatedAt: Option[Date] = None,
    _type: String,
    title: String,
    group: String,
    description: Option[String],
    owner: Option[String],
    status: String,
    flag: Boolean,
    startDate: Option[Date],
    endDate: Option[Date],
    order: Int,
    dueDate: Option[Date],
    `case`: Option[OutputCase]
)

object OutputTask {
  implicit val format: OFormat[OutputTask] = Json.format[OutputTask]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v0/User.scala`:

```scala
package org.thp.thehive.dto.v0

import org.thp.scalligraph.controllers.FFile
import play.api.libs.json.{Json, OFormat, Writes}

import java.util.Date

case class InputUser(
    login: String,
    name: String,
    roles: Seq[String],
    password: Option[String],
    organisation: Option[String] = None,
    avatar: Option[FFile]
)

object InputUser {
  implicit val writes: Writes[InputUser] = Json.writes[InputUser]
}

case class OutputUser(
    _id: String,
    id: String,
    createdBy: String,
    updatedBy: Option[String],
    createdAt: Date,
    updatedAt: Option[Date],
    _type: String,
    login: String,
    name: String,
    roles: Set[String],
    organisation: String,
    hasKey: Boolean,
    status: String
)

object OutputUser {
  implicit val format: OFormat[OutputUser] = Json.format[OutputUser]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Alert.scala`:

```scala
package org.thp.thehive.dto.v1

import ai.x.play.json.Encoders.encoder
import ai.x.play.json.Jsonx
import org.thp.scalligraph.controllers.WithParser
import play.api.libs.json._

import java.util.Date

case class InputAlert(
    `type`: String,
    source: String,
    sourceRef: String,
    externalLink: Option[String],
    title: String,
    description: String,
    severity: Option[Int] = None,
    date: Date = new Date,
    tags: Set[String] = Set.empty,
    flag: Option[Boolean] = None,
    tlp: Option[Int] = None,
    pap: Option[Int] = None,
    @WithParser(InputCustomFieldValue.parser)
    customFieldValue: Seq[InputCustomFieldValue] = Nil
)

object InputAlert {
  implicit val writes: OWrites[InputAlert] = Json.writes[InputAlert]
}

case class OutputAlert(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    `type`: String,
    source: String,
    sourceRef: String,
    externalLink: Option[String],
    title: String,
    description: String,
    severity: Int,
    date: Date,
    tags: Set[String] = Set.empty,
    tlp: Int,
    pap: Int,
    read: Boolean,
    follow: Boolean,
    customFields: Seq[OutputCustomFieldValue] = Seq.empty,
    caseTemplate: Option[String] = None,
    observableCount: Long,
    caseId: Option[String],
    extraData: JsObject
)

object OutputAlert {
  implicit val format: OFormat[OutputAlert] = Jsonx.formatCaseClass[OutputAlert]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Attachment.scala`:

```scala
package org.thp.thehive.dto.v1

import play.api.libs.json.{Json, OFormat, Writes}

case class InputAttachment(name: String, contentType: String, id: String)

object InputAttachment {
  implicit val writes: Writes[InputAttachment] = Json.writes[InputAttachment]
}

case class OutputAttachment(name: String, hashes: Seq[String], size: Long, contentType: String, id: String)

object OutputAttachment {
  implicit val format: OFormat[OutputAttachment] = Json.format[OutputAttachment]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Audit.scala`:

```scala
package org.thp.thehive.dto.v1

import org.thp.scalligraph.models.Entity
import play.api.libs.json.{Json, OFormat}

import java.util.Date

case class OutputEntity(_type: String, _id: String, _createdAt: Date, _createdBy: String, _updatedAt: Option[Date], _updatedBy: Option[String])

object OutputEntity {
  implicit val format: OFormat[OutputEntity] = Json.format[OutputEntity]

  def apply(e: Entity): OutputEntity =
    OutputEntity(
      e._label,
      e._id.toString,
      e._createdAt,
      e._createdBy,
      e._updatedAt,
      e._updatedBy
    )
}

case class OutputAudit(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    operation: String,
    requestId: String,
    attributeName: Option[String],
    oldValue: Option[String],
    newValue: Option[String],
    obj: Option[OutputEntity],
    summary: Map[String, Map[String, Int]]
)

object OutputAudit {
  implicit val format: OFormat[OutputAudit] = Json.format[OutputAudit]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Case.scala`:

```scala
package org.thp.thehive.dto.v1

import ai.x.play.json.Encoders.encoder
import ai.x.play.json.Jsonx
import org.thp.scalligraph.controllers.WithParser
import play.api.libs.json._

import java.util.Date

case class InputCase(
    title: String,
    description: String,
    severity: Option[Int] = None,
    startDate: Option[Date] = None,
    endDate: Option[Date] = None,
    tags: Set[String] = Set.empty,
    flag: Option[Boolean] = None,
    tlp: Option[Int] = None,
    pap: Option[Int] = None,
    status: Option[String] = None,
    summary: Option[String] = None,
    user: Option[String] = None,
    @WithParser(InputCustomFieldValue.parser)
    customFieldValues: Seq[InputCustomFieldValue] = Nil
)

object InputCase {
  implicit val writes: OWrites[InputCase] = Json.writes[InputCase]
}

case class OutputCase(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    number: Int,
    title: String,
    description: String,
    severity: Int,
    startDate: Date,
    endDate: Option[Date] = None,
    tags: Set[String] = Set.empty,
    flag: Boolean,
    tlp: Int,
    pap: Int,
    status: String,
    summary: Option[String] = None,
    impactStatus: Option[String] = None,
    resolutionStatus: Option[String] = None,
    assignee: Option[String],
    customFields: Seq[OutputCustomFieldValue] = Seq.empty,
    extraData: JsObject
)

object OutputCase {
  implicit val format: OFormat[OutputCase] = Jsonx.formatCaseClass[OutputCase]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/CaseTemplate.scala`:

```scala
package org.thp.thehive.dto.v1

import org.thp.scalligraph.controllers.WithParser
import play.api.libs.json.{Json, OFormat, OWrites}

import java.util.Date

case class InputCaseTemplate(
    name: String,
    displayName: Option[String],
    titlePrefix: Option[String],
    description: Option[String],
    severity: Option[Int] = None,
    tags: Set[String] = Set.empty,
    flag: Option[Boolean] = None,
    tlp: Option[Int] = None,
    pap: Option[Int] = None,
    summary: Option[String] = None,
    tasks: Seq[InputTask] = Nil,
    @WithParser(InputCustomFieldValue.parser)
    customFieldValue: Seq[InputCustomFieldValue] = Nil
)

object InputCaseTemplate {
  implicit val writes: OWrites[InputCaseTemplate] = Json.writes[InputCaseTemplate]
}

case class OutputCaseTemplate(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    name: String,
    displayName: String,
    titlePrefix: Option[String],
    description: Option[String],
    severity: Option[Int],
    tags: Set[String] = Set.empty,
    flag: Boolean,
    tlp: Option[Int],
    pap: Option[Int],
    summary: Option[String],
    customFields: Seq[OutputCustomFieldValue] = Seq.empty,
    tasks: Seq[OutputTask]
)

object OutputCaseTemplate {
  implicit val format: OFormat[OutputCaseTemplate] = Json.format[OutputCaseTemplate]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/CustomFieldValue.scala`:

```scala
package org.thp.thehive.dto.v1

import org.scalactic.Accumulation._
import org.scalactic.{Bad, Good, One}
import org.thp.scalligraph.InvalidFormatAttributeError
import org.thp.scalligraph.controllers._
import play.api.libs.json._

import java.util.Date

case class InputCustomField(name: String, description: String, `type`: String, mandatory: Option[Boolean])

object InputCustomField {
  implicit val writes: Writes[InputCustomField] = Json.writes[InputCustomField]
}

case class OutputCustomField(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    name: String,
    description: String,
    `type`: String,
    options: Seq[JsValue],
    mandatory: Boolean
)

object OutputCustomField {
  implicit val format: OFormat[OutputCustomField] = Json.format[OutputCustomField]
}

case class InputCustomFieldValue(name: String, value: Option[Any], order: Option[Int])

object InputCustomFieldValue {

  val valueParser: FieldsParser[Option[Any]] = FieldsParser("customFieldValue") {
    case (_, FString(value))     => Good(Some(value))
    case (_, FNumber(value))     => Good(Some(value))
    case (_, FBoolean(value))    => Good(Some(value))
    case (_, FAny(value :: _))   => Good(Some(value))
    case (_, FUndefined | FNull) => Good(None)
  }

  val parser: FieldsParser[Seq[InputCustomFieldValue]] = FieldsParser("customFieldValues") {
    case (_, FObject(fields)) =>
      fields
        .toSeq
        .validatedBy {
          case (name, valueField) => valueParser(valueField).map(v => InputCustomFieldValue(name, v, None))
        }
        .map(_.toSeq)
    case (_, FSeq(list)) =>
      list
        .validatedBy {
          case cf: FObject =>
            val order = FieldsParser.int(cf.get("order")).toOption
            for {
              name  <- FieldsParser.string(cf.get("name"))
              value <- valueParser(cf.get("value"))
            } yield InputCustomFieldValue(name, value, order)
          case other =>
            Bad(
              One(
                InvalidFormatAttributeError(s"customField", "CustomFieldValue", Set.empty, other)
              )
            )
        }
    case _ => Good(Nil)
  }

  implicit val writes: Writes[Seq[InputCustomFieldValue]] = Writes[Seq[InputCustomFieldValue]] { icfv =>
    val fields = icfv.map {
      case InputCustomFieldValue(name, Some(s: String), _)  => name -> JsString(s)
      case InputCustomFieldValue(name, Some(l: Long), _)    => name -> JsNumber(l)
      case InputCustomFieldValue(name, Some(d: Double), _)  => name -> JsNumber(d)
      case InputCustomFieldValue(name, Some(b: Boolean), _) => name -> JsBoolean(b)
      case InputCustomFieldValue(name, Some(d: Date), _)    => name -> JsNumber(d.getTime)
      case InputCustomFieldValue(name, None, _)             => name -> JsNull
      case InputCustomFieldValue(name, other, _)            => sys.error(s"The custom field $name has invalid value: $other (${other.getClass})")
    }
    // TODO Change JsObject to JsArray ?
    JsObject(fields)
  }
}

case class OutputCustomFieldValue(_id: String, name: String, description: String, `type`: String, value: JsValue, order: Int)

object OutputCustomFieldValue {
  implicit val format: OFormat[OutputCustomFieldValue] = Json.format[OutputCustomFieldValue]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Dashboard.scala`:

```scala
package org.thp.thehive.dto.v1

import play.api.libs.json.{Json, OFormat, OWrites}

import java.util.Date

case class InputDashboard(title: String, description: String, status: String, definition: String)

object InputDashboard {
  implicit val writes: OWrites[InputDashboard] = Json.writes[InputDashboard]
}

case class OutputDashboard(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    title: String,
    description: String,
    status: String,
    definition: String,
    writable: Boolean
)

object OutputDashboard {
  implicit val format: OFormat[OutputDashboard] = Json.format[OutputDashboard]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Log.scala`:

```scala
package org.thp.thehive.dto.v1

import org.thp.scalligraph.controllers.FFile
import play.api.libs.json.{JsObject, Json, OFormat}

import java.util.Date

case class InputLog(message: String, startDate: Option[Date] = None, attachment: Option[FFile] = None)

case class OutputLog(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    message: String,
    date: Date,
    attachment: Option[OutputAttachment] = None,
    owner: String,
    extraData: JsObject
)

object OutputLog {
  implicit val format: OFormat[OutputLog] = Json.format[OutputLog]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Observable.scala`:

```scala
package org.thp.thehive.dto.v1

import org.scalactic.Accumulation._
import org.scalactic.Good
import org.thp.scalligraph.controllers._
import play.api.libs.json.{JsObject, Json, OFormat, Writes}

import java.util.Date

case class InputObservable(
    dataType: String,
    @WithParser(InputObservable.dataParser)
    data: Seq[String] = Nil,
    message: Option[String] = None,
    startDate: Option[Date] = None,
    @WithParser(InputObservable.fileOrAttachmentParser)
    attachment: Seq[Either[FFile, InputAttachment]] = Seq.empty,
    tlp: Option[Int] = None,
    tags: Set[String] = Set.empty,
    ioc: Option[Boolean] = None,
    sighted: Option[Boolean] = None,
    ignoreSimilarity: Option[Boolean] = None
)

object InputObservable {
  implicit val fileOrAttachmentWrites: Writes[Either[FFile, InputAttachment]] = Writes[Either[FFile, InputAttachment]] {
    case Left(file)        => Json.toJson(file)
    case Right(attachment) => Json.toJson(attachment)
  }

  implicit val writes: Writes[InputObservable] = Json.writes[InputObservable]

  val dataParser: FieldsParser[Seq[String]] = FieldsParser[Seq[String]]("data") {
    case (_, FString(s)) => Good(Seq(s))
    case (_, FAny(s))    => Good(s)
    case (_, FSeq(a))    => a.validatedBy(FieldsParser.string(_))
    case (_, FUndefined) => Good(Nil)
  }

  val fileOrAttachmentParser: FieldsParser[Seq[Either[FFile, InputAttachment]]] =
    FieldsParser[FFile]
      .map("fileOrAttachmentParser")(f => Seq(Left(f)))
      .recover(
        FieldsParser[InputAttachment]
          .map("fileOrAttachmentParser")(a => Seq(Right(a)))
          .recover(
            FieldsParser[InputAttachment]
              .sequence
              .map("fileOrAttachmentParser")(as => as.map(Right(_)))
          )
      )
}

case class OutputObservable(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    dataType: String,
    data: Option[String],
    startDate: Date,
    attachment: Option[OutputAttachment],
    tlp: Int,
    tags: Set[String],
    ioc: Boolean,
    sighted: Boolean,
    reports: JsObject,
    message: Option[String],
    extraData: JsObject,
    ignoreSimilarity: Option[Boolean]
)

object OutputObservable {
  implicit val format: OFormat[OutputObservable] = Json.format[OutputObservable]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/ObservableType.scala`:

```scala
package org.thp.thehive.dto.v1

import play.api.libs.json.{Json, OFormat, Writes}

import java.util.Date

case class InputObservableType(name: String, isAttachment: Option[Boolean])

object InputObservableType {
  implicit val writes: Writes[InputObservableType] = Json.writes[InputObservableType]
}

case class OutputObservableType(
    _id: String,
    _type: String,
    _updatedAt: Option[Date] = None,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _createdBy: String,
    name: String,
    isAttachment: Boolean
)

object OutputObservableType {
  implicit val format: OFormat[OutputObservableType] = Json.format[OutputObservableType]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Organisation.scala`:

```scala
package org.thp.thehive.dto.v1

import play.api.libs.json.{Format, Json, Writes}

import java.util.Date

case class InputOrganisation(name: String, description: String)

object InputOrganisation {
  implicit val writes: Writes[InputOrganisation] = Json.writes[InputOrganisation]
}

case class OutputOrganisation(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    name: String,
    description: String,
    links: Seq[String]
)

object OutputOrganisation {
  implicit val format: Format[OutputOrganisation] = Json.format[OutputOrganisation]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Pattern.scala`:

```scala
package org.thp.thehive.dto.v1

import ai.x.play.json.Encoders.encoder
import ai.x.play.json.Jsonx
import play.api.libs.json._

import java.util.Date

case class InputPattern(
    external_id: String,
    name: String,
    description: Option[String],
    kill_chain_phases: Seq[InputKillChainPhase],
    url: String,
    `type`: String,
    capec_id: Option[String],
    capec_url: Option[String],
    revoked: Boolean,
    x_mitre_data_sources: Seq[String],
    x_mitre_defense_bypassed: Seq[String],
    x_mitre_detection: Option[String],
    x_mitre_is_subtechnique: Boolean,
    x_mitre_permissions_required: Seq[String],
    x_mitre_platforms: Seq[String],
    x_mitre_remote_support: Boolean,
    x_mitre_system_requirements: Seq[String],
    x_mitre_version: Option[String]
)

case class InputReference(
    source_name: String,
    external_id: Option[String],
    url: Option[String]
)

case class InputKillChainPhase(
    kill_chain_name: String,
    phase_name: String
)

object InputReference {
  implicit val reads: Reads[InputReference] = Reads[InputReference] { json =>
    for {
      source_name <- (json \ "source_name").validate[String]
      external_id <- (json \ "external_id").validateOpt[String]
      url         <- (json \ "url").validateOpt[String]
    } yield InputReference(
      source_name,
      external_id,
      url
    )
  }

  implicit val writes: Writes[InputReference] = Json.writes[InputReference]
}

object InputKillChainPhase {
  implicit val reads: Reads[InputKillChainPhase] = Json.reads[InputKillChainPhase]

  implicit val writes: Writes[InputKillChainPhase] = Json.writes[InputKillChainPhase]
}

object InputPattern {
  implicit val reads: Reads[InputPattern] = Reads[InputPattern] { json =>
    for {
      optReferences <- (json \ "external_references").validateOpt[Seq[InputReference]]
      references     = optReferences.getOrElse(Seq())
      mitreReference = references.find(ref => isSourceNameMitre(ref.source_name))
      capecReference = references.find(ref => isSourceNameCapec(ref.source_name))
      name                         <- (json \ "name").validateOpt[String]
      description                  <- (json \ "description").validateOpt[String]
      kill_chain_phases            <- (json \ "kill_chain_phases").validateOpt[Seq[InputKillChainPhase]]
      techniqueType                <- (json \ "type").validateOpt[String]
      revoked                      <- (json \ "revoked").validateOpt[Boolean]
      x_mitre_data_sources         <- (json \ "x_mitre_data_sources").validateOpt[Seq[String]]
      x_mitre_defense_bypassed     <- (json \ "x_mitre_defense_bypassed").validateOpt[Seq[String]]
      x_mitre_detection            <- (json \ "x_mitre_detection").validateOpt[String]
      x_mitre_is_subtechnique      <- (json \ "x_mitre_is_subtechnique").validateOpt[Boolean]
      x_mitre_permissions_required <- (json \ "x_mitre_permissions_required").validateOpt[Seq[String]]
      x_mitre_platforms            <- (json \ "x_mitre_platforms").validateOpt[Seq[String]]
      x_mitre_remote_support       <- (json \ "x_mitre_remote_support").validateOpt[Boolean]
      x_mitre_system_requirements  <- (json \ "x_mitre_system_requirements").validateOpt[Seq[String]]
      x_mitre_version              <- (json \ "x_mitre_version").validateOpt[String]
    } yield InputPattern(
      mitreReference.flatMap(_.external_id).getOrElse(""),
      name.getOrElse(""),
      description,
      kill_chain_phases.getOrElse(Seq()),
      mitreReference.flatMap(_.url).getOrElse(""),
      techniqueType.getOrElse(""),
      capecReference.flatMap(_.external_id),
      capecReference.flatMap(_.url),
      revoked.getOrElse(false),
      x_mitre_data_sources.getOrElse(Seq()),
      x_mitre_defense_bypassed.getOrElse(Seq()),
      x_mitre_detection,
      x_mitre_is_subtechnique.getOrElse(false),
      x_mitre_permissions_required.getOrElse(Seq()),
      x_mitre_platforms.getOrElse(Seq()),
      x_mitre_remote_support.getOrElse(false),
      x_mitre_system_requirements.getOrElse(Seq()),
      x_mitre_version
    )
  }

  private def isSourceNameMitre(reference: String): Boolean =
    reference == "mitre-attack"

  private def isSourceNameCapec(reference: String): Boolean =
    reference == "capec"

  implicit val writes: Writes[InputPattern] = Json.writes[InputPattern]
}

case class OutputPattern(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String],
    _createdAt: Date,
    _updatedAt: Option[Date],
    patternId: String,
    name: String,
    description: Option[String],
    tactics: Set[String],
    url: String,
    patternType: String,
    capecId: Option[String],
    capecUrl: Option[String],
    revoked: Boolean,
    dataSources: Seq[String],
    defenseBypassed: Seq[String],
    detection: Option[String],
    permissionsRequired: Seq[String],
    platforms: Seq[String],
    remoteSupport: Boolean,
    systemRequirements: Seq[String],
    version: Option[String],
    extraData: JsObject
)

object OutputPattern {
  implicit val format: OFormat[OutputPattern] = Jsonx.formatCaseClass[OutputPattern]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Procedure.scala`:

```scala
package org.thp.thehive.dto.v1

import play.api.libs.json._

import java.util.Date

case class InputProcedure(
    description: Option[String],
    occurDate: Date,
    tactic: String,
    caseId: String,
    patternId: String
)

object InputProcedure {
  implicit val reads: Reads[InputProcedure] = Reads[InputProcedure] { json =>
    for {
      description <- (json \ "description").validateOpt[String]
      occurDate   <- (json \ "occurDate").validate[Date]
      tactic      <- (json \ "tactic").validate[String]
      caseId      <- (json \ "caseId").validate[String]
      patternId   <- (json \ "patternId").validate[String]
    } yield InputProcedure(
      description,
      occurDate,
      tactic,
      caseId,
      patternId
    )
  }

  implicit val writes: Writes[InputProcedure] = Json.writes[InputProcedure]
}

case class OutputProcedure(
    _id: String,
    _createdAt: Date,
    _createdBy: String,
    _updatedAt: Option[Date],
    _updatedBy: Option[String],
    description: Option[String],
    occurDate: Date,
    patternId: String,
    tactic: String,
    extraData: JsObject
)

object OutputProcedure {
  implicit val format: Format[OutputProcedure] = Json.format[OutputProcedure]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Profile.scala`:

```scala
package org.thp.thehive.dto.v1

import play.api.libs.json.{Json, OFormat, OWrites}

import java.util.Date

case class InputProfile(name: String, permissions: Set[String])

object InputProfile {
  implicit val writes: OWrites[InputProfile] = Json.writes[InputProfile]
}

case class OutputProfile(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    name: String,
    permissions: Seq[String],
    editable: Boolean,
    isAdmin: Boolean
)

object OutputProfile {
  implicit val format: OFormat[OutputProfile] = Json.format[OutputProfile]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Share.scala`:

```scala
package org.thp.thehive.dto.v1

import org.thp.thehive.dto.v1.ObservablesFilter.ObservablesFilter
import org.thp.thehive.dto.v1.TasksFilter.TasksFilter
import play.api.libs.json.{Format, Json, Writes}

import java.util.Date

case class InputShare(organisationName: String, profile: String, tasks: TasksFilter, observables: ObservablesFilter)

object TasksFilter extends Enumeration {
  type TasksFilter = Value

  val all: TasksFilter  = Value("all")
  val none: TasksFilter = Value("none")

  implicit val format: Format[TasksFilter] = Json.formatEnum(TasksFilter)
}

object ObservablesFilter extends Enumeration {
  type ObservablesFilter = Value

  val all: ObservablesFilter  = Value("all")
  val none: ObservablesFilter = Value("none")

  implicit val format: Format[ObservablesFilter] = Json.formatEnum(ObservablesFilter)
}

object InputShare {
  implicit val writes: Writes[InputShare] = Json.writes[InputShare]
}

case class OutputShare(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    caseId: String,
    profileName: String,
    organisationName: String,
    owner: Boolean
)

object OutputShare {
  implicit val format: Format[OutputShare] = Json.format[OutputShare]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Tag.scala`:

```scala
package org.thp.thehive.dto.v1

import play.api.libs.json.{JsObject, Json, OFormat}

import java.util.Date

case class OutputTag(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    namespace: String,
    predicate: String,
    value: Option[String],
    description: Option[String],
    colour: String,
    extraData: JsObject
)

object OutputTag {
  implicit val format: OFormat[OutputTag] = Json.format[OutputTag]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Task.scala`:

```scala
package org.thp.thehive.dto.v1

import play.api.libs.json.{JsObject, Json, OFormat, OWrites}

import java.util.Date

case class InputTask(
    title: String,
    group: Option[String] = None,
    description: Option[String] = None,
    status: Option[String] = None,
    flag: Option[Boolean] = None,
    startDate: Option[Date] = None,
    endDate: Option[Date] = None,
    order: Option[Int] = None,
    dueDate: Option[Date] = None,
    assignee: Option[String] = None
)

object InputTask {
  implicit val writes: OWrites[InputTask] = Json.writes[InputTask]
}

case class OutputTask(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    title: String,
    group: String,
    description: Option[String],
    status: String,
    flag: Boolean,
    startDate: Option[Date],
    endDate: Option[Date],
    assignee: Option[String],
    order: Int,
    dueDate: Option[Date],
    extraData: JsObject
)

object OutputTask {
  implicit val format: OFormat[OutputTask] = Json.format[OutputTask]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/Taxonomy.scala`:

```scala
package org.thp.thehive.dto.v1

import play.api.libs.json.Json.WithDefaultValues
import play.api.libs.json.{JsObject, Json, OFormat}

import java.util.Date

/*
Format based on :
https://tools.ietf.org/id/draft-dulaunoy-misp-taxonomy-format-04.html
 */

case class InputTaxonomy(
    namespace: String,
    description: String,
    version: Int,
    exclusive: Option[Boolean],
    predicates: Seq[InputPredicate],
    values: Seq[InputValue] = Nil
)

case class InputPredicate(
    value: String,
    expanded: Option[String],
    exclusive: Option[Boolean],
    description: Option[String],
    colour: Option[String]
)

case class InputValue(
    predicate: String,
    entry: Seq[InputEntry]
)

case class InputEntry(
    value: String,
    expanded: Option[String],
    colour: Option[String],
    description: Option[String],
    numerical_value: Option[Int]
)

object InputTaxonomy {
  implicit val format: OFormat[InputTaxonomy] = Json.configured[WithDefaultValues].format[InputTaxonomy]
}

object InputPredicate {
  implicit val format: OFormat[InputPredicate] = Json.format[InputPredicate]
}

object InputValue {
  implicit val format: OFormat[InputValue] = Json.format[InputValue]
}

object InputEntry {
  implicit val format: OFormat[InputEntry] = Json.format[InputEntry]
}

case class OutputTaxonomy(
    _id: String,
    _type: String,
    _createdBy: String,
    _updatedBy: Option[String] = None,
    _createdAt: Date,
    _updatedAt: Option[Date] = None,
    namespace: String,
    description: String,
    version: Int,
    tags: Seq[OutputTag],
    extraData: JsObject
)

object OutputTaxonomy {
  implicit val format: OFormat[OutputTaxonomy] = Json.format[OutputTaxonomy]
}

```

`dto/src/main/scala/org/thp/thehive/dto/v1/User.scala`:

```scala
package org.thp.thehive.dto.v1

import org.thp.scalligraph.controllers.FFile
import play.api.libs.json.{JsObject, Json, OFormat, Writes}

import java.util.Date

case class InputUser(login: String, name: String, password: Option[String], profile: String, organisation: Option[String], avatar: Option[FFile])

object InputUser {
  implicit val writes: Writes[InputUser] = Json.writes[InputUser]
}

case class OutputOrganisationProfile(organisationId: String, organisation: String, profile: String)
object OutputOrganisationProfile {
  implicit val format: OFormat[OutputOrganisationProfile] = Json.format[OutputOrganisationProfile]
}

case class OutputUser(
    _id: String,
    _createdBy: String,
    _updatedBy: Option[String],
    _createdAt: Date,
    _updatedAt: Option[Date],
    login: String,
    name: String,
    hasKey: Boolean,
    hasPassword: Boolean,
    hasMFA: Boolean,
    locked: Boolean,
    profile: String,
    permissions: Set[String],
    organisation: String,
    avatar: Option[String],
    organisations: Seq[OutputOrganisationProfile],
    extraData: JsObject
)

object OutputUser {
  implicit val format: OFormat[OutputUser] = Json.format[OutputUser]
}

```

`frontend/Gruntfile.js`:

```js
module.exports = function(grunt) {
    'use strict';

    // Time how long tasks take. Can help when optimizing build times
    require('time-grunt')(grunt);

    // Automatically load required Grunt tasks
    require('jit-grunt')(grunt, {
        useminPrepare: 'grunt-usemin',
        ngtemplates: 'grunt-angular-templates'
    });

    grunt.loadNpmTasks('grunt-connect-proxy');
    grunt.loadNpmTasks('grunt-injector');

    // Configurable paths for the application
    var appConfig = {
        app: require('./bower.json').appPath || 'app',
        dist: 'dist'
    };

    var proxySnippet = require('grunt-connect-proxy/lib/utils').proxyRequest;

    var serveStatic = require('serve-static');

    // Define the configuration for all the tasks
    grunt.initConfig({

        // Project settings
        yeoman: appConfig,

        // Watches files for changes and runs tasks based on the changed files
        watch: {
            bower: {
                files: ['bower.json'],
                tasks: ['wiredep']
            },
            js: {
                files: ['<%= yeoman.app %>/scripts/**/{,*/}*.js'],
                tasks: ['newer:jshint:all'],
                options: {
                    livereload: '<%= connect.options.livereload %>'
                }
            },
            jsTest: {
                files: ['test/spec/{,*/}*.js'],
                tasks: ['newer:jshint:test', 'karma']
            },
            styles: {
                files: ['<%= yeoman.app %>/styles/{,*/}*.css'],
                tasks: ['newer:copy:styles', 'postcss']
            },
            gruntfile: {
                files: ['Gruntfile.js']
            },
            livereload: {
                options: {
                    livereload: '<%= connect.options.livereload %>'
                },
                files: [
                    '<%= yeoman.app %>/**/*.html',
                    '.tmp/styles/{,*/}*.css',
                    '<%= yeoman.app %>/images/{,*/}*.{png,jpg,jpeg,gif,webp,svg}'
                ]
            }
        },

        injector: {
            options: {
                transform: function(filepath) {
                    return '<script src="'+filepath.substr(5)+'"></script>';
                }
            },
            local_dependencies: {
                files: {
                    'app/index.html': ['<%= yeoman.app %>/scripts/**/*.js'],
                }
            }
        },

        // The actual grunt server settings
        connect: {
            options: {
                port: 3001,
                // Change this to '0.0.0.0' to access the server from outside.
                hostname: '0.0.0.0',
                livereload: 35729
            },
            proxies: [{
                context: '/api',
                host: 'localhost',
                port: 9000,
                https: false,
                xforward: false
            }],
            livereload: {
                options: {
                    open: true,
                    middleware: function(connect) {
                        return [
                            serveStatic('.tmp'),
                            connect().use(
                                '/bower_components',
                                serveStatic('./bower_components')
                            ),
                            connect().use(
                                '/app/styles',
                                serveStatic('./app/styles')
                            ),
                            serveStatic(appConfig.app),
                            proxySnippet
                        ];
                    }
                }
            },
            test: {
                options: {
                    port: 9000,
                    middleware: function(connect) {
                        return [
                            serveStatic('.tmp'),
                            serveStatic('test'),
                            connect().use(
                                '/bower_components',
                                serveStatic('./bower_components')
                            ),
                            serveStatic(appConfig.app)
                        ];
                    }
                }
            },
            dist: {
                options: {
                    open: true,
                    base: '<%= yeoman.dist %>',
                    middleware: function(/*connect*/) {
                        return [
                            serveStatic(appConfig.dist),
                            proxySnippet
                        ];
                    }
                }
            }
        },

        // Make sure code styles are up to par and there are no obvious mistakes
        jshint: {
            options: {
                jshintrc: '.jshintrc',
                reporter: require('jshint-stylish')
            },
            all: {
                src: [
                    'Gruntfile.js',
                    '<%= yeoman.app %>/scripts/{,*/}*.js'
                ]
            },
            test: {
                options: {
                    jshintrc: 'test/.jshintrc'
                },
                src: ['test/spec/{,*/}*.js']
            }
        },

        // Empties folders to start fresh
        clean: {
            dist: {
                files: [{
                    dot: true,
                    src: [
                        '.tmp',
                        '<%= yeoman.dist %>/{,*/}*',
                        '!<%= yeoman.dist %>/.git{,*/}*'
                    ]
                }]
            },
            server: '.tmp'
        },

        // Add vendor prefixed styles
        postcss: {
            options: {
                processors: [
                  //require('autoprefixer')({overrideBrowserslist: ['last 1 version']})
                ]
            },
            server: {
                options: {
                    map: true,
                },
                files: [{
                    expand: true,
                    cwd: '.tmp/styles/',
                    src: '{,*/}*.css',
                    dest: '.tmp/styles/'
                }]
            },
            dist: {
                files: [{
                    expand: true,
                    cwd: '.tmp/styles/',
                    src: '{,*/}*.css',
                    dest: '.tmp/styles/'
                }]
            }
        },

        // Automatically inject Bower components into the app
        wiredep: {
            app: {
                src: ['<%= yeoman.app %>/index.html'],
                ignorePath: /\.\.\//,
                exclude: [/cryptojslib/, /smalot-bootstrap-datetimepicker/]
            },
            test: {
                devDependencies: true,
                src: '<%= karma.unit.configFile %>',
                ignorePath: /\.\.\//,
                exclude: [/cryptojslib/, /smalot-bootstrap-datetimepicker/],
                fileTypes: {
                    js: {
                        block: /(([\s\t]*)\/{2}\s*?bower:\s*?(\S*))(\n|\r|.)*?(\/{2}\s*endbower)/gi,
                        detect: {
                            js: /'(.*\.js)'/gi
                        },
                        replace: {
                            js: '\'{{filePath}}\','
                        }
                    }
                }
            }
        },

        // Renames files for browser caching purposes
        filerev: {
            dist: {
                src: [
                    '<%= yeoman.dist %>/scripts/{,*/}*.js',
                    '<%= yeoman.dist %>/styles/{,*/}*.css',
                    //'<%= yeoman.dist %>/images/{,*/}*.{png,jpg,jpeg,gif,webp,svg}',
                    '<%= yeoman.dist %>/styles/fonts/*'
                ]
            }
        },

        // Reads HTML for usemin blocks to enable smart builds that automatically
        // concat, minify and revision files. Creates configurations in memory so
        // additional tasks can operate on them
        useminPrepare: {
            html: '<%= yeoman.app %>/index.html',
            options: {
                dest: '<%= yeoman.dist %>',
                flow: {
                    html: {
                        steps: {
                            js: ['concat', 'uglifyjs'],
                            css: ['cssmin']
                        },
                        post: {}
                    }
                }
            }
        },

        // Performs rewrites based on filerev and the useminPrepare configuration
        usemin: {
            html: ['<%= yeoman.dist %>/{,*/}*.html'],
            css: ['<%= yeoman.dist %>/styles/{,*/}*.css'],
            js: ['<%= yeoman.dist %>/scripts/{,*/}*.js'],
            options: {
                assetsDirs: [
                    '<%= yeoman.dist %>',
                    '<%= yeoman.dist %>/images',
                    '<%= yeoman.dist %>/styles'
                ],
                patterns: {
                    js: [
                        [/(images\/[^''""]*\.(png|jpg|jpeg|gif|webp|svg))/g, 'Replacing references to images']
                    ]
                }
            }
        },

        imagemin: {
            dist: {
                files: [{
                    expand: true,
                    cwd: '<%= yeoman.app %>/images',
                    src: '{,*/}*.{png,jpg,jpeg,gif}',
                    dest: '<%= yeoman.dist %>/images'
                }]
            }
        },

        svgmin: {
            dist: {
                files: [{
                    expand: true,
                    cwd: '<%= yeoman.app %>/images',
                    src: '{,*/}*.svg',
                    dest: '<%= yeoman.dist %>/images'
                }]
            }
        },

        htmlmin: {
            dist: {
                options: {
                    collapseWhitespace: true,
                    conservativeCollapse: true,
                    collapseBooleanAttributes: true,
                    removeCommentsFromCDATA: true
                },
                files: [{
                    expand: true,
                    cwd: '<%= yeoman.dist %>',
                    src: ['*.html'],
                    dest: '<%= yeoman.dist %>'
                }]
            }
        },

        ngtemplates: {
            dist: {
                options: {
                    module: 'thehive',
                    htmlmin: '<%= htmlmin.dist.options %>',
                    usemin: 'scripts/scripts.js'
                },
                cwd: '<%= yeoman.app %>',
                src: 'views/**/*.html',
                dest: '.tmp/templateCache.js'
            }
        },

        // ng-annotate tries to make the code safe for minification automatically
        // by using the Angular long form for dependency injection.
        ngAnnotate: {
            dist: {
                files: [{
                    expand: true,
                    cwd: '.tmp/concat/scripts',
                    src: '*.js',
                    dest: '.tmp/concat/scripts'
                }]
            }
        },

        // Copies remaining files to places other tasks can use
        copy: {
            dist: {
                files: [{
                    expand: true,
                    dot: true,
                    cwd: '<%= yeoman.app %>',
                    dest: '<%= yeoman.dist %>',
                    src: [
                        '*.{ico,png,txt}',
                        '.htaccess',
                        '*.html',
                        'images/{,*/}*.{webp}'
                        //'styles/fonts/{,*/}*.*'
                    ]
                }, {
                    expand: true,
                    cwd: '.tmp/images',
                    dest: '<%= yeoman.dist %>/images',
                    src: ['generated/*']
                }, {
                    expand: true,
                    dot: true,
                    cwd: '<%= yeoman.app %>/styles',
                    src: ['fonts/*.*'],
                    dest: '<%= yeoman.dist %>'
                }, {
                    expand: true,
                    cwd: 'bower_components/bootstrap/dist',
                    src: 'fonts/*',
                    dest: '<%= yeoman.dist %>'
                }, {
                    expand: true,
                    dot: true,
                    cwd: 'bower_components/font-awesome',
                    src: ['fonts/*.*'],
                    dest: '<%= yeoman.dist %>'
                }, {
                    expand: true,
                    dot: true,
                    cwd: 'bower_components/roboto-fontface',
                    src: ['fonts/roboto/*.*'],
                    dest: '<%= yeoman.dist %>'
                }]
            },
            styles: {
                expand: true,
                cwd: '<%= yeoman.app %>/styles',
                dest: '.tmp/styles/',
                src: '{,*/}*.css'
            },
            images: {
                expand: true,
                cwd: '<%= yeoman.app %>/images',
                dest: '<%= yeoman.dist %>/images',
                src: '{,*/}*.{png,jpg,jpeg,gif}'
            }
        },

        // Run some tasks in parallel to speed up the build process
        concurrent: {
            server: [
                'copy:styles'
            ],
            test: [
                'copy:styles'
            ],
            dist: [
                'copy:styles',
                'copy:images',
                //'imagemin',
                'svgmin'
            ]
        },

        // Test settings
        karma: {
            unit: {
                configFile: 'test/karma.conf.js',
                singleRun: true
            }
        }
    });


    grunt.registerTask('serve', 'Compile then start a connect web server', function(target) {
        if (target === 'dist') {
            return grunt.task.run(['build', 'configureProxies:dist','connect:dist:keepalive']);
        }

        grunt.task.run([
            'clean:server',
            'wiredep',
            'concurrent:server',
            'postcss:server',
            'configureProxies',
            'connect:livereload',
            'watch'
        ]);
    });

    grunt.registerTask('server', 'DEPRECATED TASK. Use the "serve" task instead', function(target) {
        grunt.log.warn('The `server` task has been deprecated. Use `grunt serve` to start a server.');
        grunt.task.run(['serve:' + target]);
    });

    grunt.registerTask('test', [
        'clean:server',
        'wiredep',
        'concurrent:test',
        'postcss',
        'connect:test',
        'karma'
    ]);

    grunt.registerTask('build', [
        'clean:dist',
        'wiredep',
        'injector',
        'useminPrepare',
        'concurrent:dist',
        'postcss',
        'ngtemplates',
        'concat',
        'ngAnnotate',
        'copy:dist',
        'cssmin',
        'uglify',
        'filerev',
        'usemin',
        'htmlmin'
    ]);

    grunt.registerTask('default', [
        'newer:jshint',
        'test',
        'build'
    ]);
};

```

`frontend/README.md`:

```md
<div>
  <p a
```

`frontend/app/images/cortex-logo.svg`:

```svg
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 18.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 300 300" enable-background="new 0 0 300 300" xml:space="preserve">
<g>
	<circle fill="#5F6062" cx="150" cy="150" r="125"/>
	<g>
		<path fill="#FFFFFF" d="M221.3,158.2c0-11.3-5.7-12.4-15.8-13.5c-8.9-0.9-19.1-2-23.5-14.7c-0.2-0.4-0.1-0.9,0.1-1.2
			c0.2-0.4,0.5-0.8,1-0.8c0.8-0.3,1.8,0.2,2.2,1c3.8,10.7,12.3,11.5,20.7,12.4c4.1,0.4,8.8,0.9,12.4,3c0.4,0.2,0.9,0.2,1.2,0
			c0.4-0.2,0.6-0.7,0.6-1.2c-2-22.7-11.6-34.1-19.2-39.7c-4.3-3.1-8.2-4.5-10.6-5.1c-0.5-0.1-1,0.1-1.2,0.4
			c-0.3,0.4-0.3,0.9-0.1,1.3c1.7,2.9,2.6,6.3,3.5,9.7c1.9,6.9,3.6,13,11.1,14.4c0.4,0.1,0.8,0.3,1.1,0.8c0.2,0.4,0.3,0.8,0.2,1.2
			c-0.2,0.8-0.8,1.3-1.7,1.3c-0.1,0-0.2,0-0.3,0c-9.6-1.9-11.7-9.5-13.8-16.9c-1.3-4.9-2.7-9.6-6.1-12.5c-4.9-4.1-13.2-6.8-20.6-6.8
			c-1.2,0-2.4,0.1-3.6,0.2c-2.4,0.3-5.8,1.2-8.5,3.6c-0.2,0.2-0.4,0.5-0.4,0.8c0,0.3,0.1,0.7,0.3,0.9c3.5,3.8,6.8,8.8,9.8,14.8
			c0.4,0.8,0.1,1.8-0.8,2.2c-0.8,0.4-1.8,0.1-2.2-0.8c-3.4-6.8-7.2-12.2-11.1-15.9l0,0l0,0c-5.6-5.2-10.5-6.4-13.7-6.4
			c-0.8,0-1.7,0.1-2.5,0.3c-4.5,0.9-7.5,3.8-8.3,6.2c-0.2,0.3-0.1,0.8,0.1,1.1c1,1.7,1.7,3.6,2.3,5.3c2,5.6,4,10.9,13.6,11.3
			c0.4,0,0.8,0.2,1.2,0.6c0.3,0.3,0.5,0.8,0.4,1.2c-0.1,0.9-0.8,1.6-1.8,1.6l0,0c-11.9-0.6-14.5-7.8-16.7-13.6
			c-0.8-2.3-1.5-3.9-2.3-5.1c0-0.1-0.1-0.1-0.1-0.2c-0.1-0.1-0.2-0.2-0.2-0.2c-0.1-0.1-0.1-0.2-0.2-0.2c-1.1-1.2-2.3-1.7-4.2-1.7
			c-4.1,0-7.2,1.3-9.3,3.8c-0.8,0.9-1.4,2.1-1.8,3.4c0,0.1-0.1,0.2-0.1,0.2c0,0.2-0.1,0.2-0.2,0.4c0,0.1,0,0.1-0.1,0.2
			c-0.9,3.2-1.1,7.2-0.2,10.8c1.4,6.6,5.5,14.8,16.9,16.9c1.1,0.2,2.2,0.2,3.4,0.2c2.7,0,5.5-0.4,8.6-0.8c3.2-0.5,6.8-1,10.5-1
			c5.6,0,10.5,1.2,14.9,3.7c0.3,0.2,0.7,0.2,1,0.1c0.3-0.1,0.6-0.4,0.8-0.7c2-5.1,5.1-8.4,7.5-11.1c4.8-5.3,8.4-9.2,3.3-22.6
			c-0.2-0.4-0.2-0.9,0-1.3c0.2-0.4,0.5-0.8,0.9-0.9c0.8-0.3,1.8,0.2,2.2,1c5.8,15.3,1.2,20.3-4,26.1c-2.6,2.8-5.6,6.1-7.3,11.2
			c-0.2,0.5,0,1.1,0.4,1.4c11.8,8.6,18,11.4,24.6,11.4c0.8,0,1.6-0.1,2.5-0.2c0.9-0.1,1.8,0.6,1.8,1.5c0.1,0.4-0.1,0.9-0.3,1.2
			c-0.2,0.3-0.7,0.6-1.2,0.6c-1,0.1-2,0.2-2.9,0.2c-7.5,0-14.6-3.3-28.2-13.3c-4.8-3.5-9.8-5.1-16-5.1c-3.4,0-6.8,0.5-10.2,1
			c-3.2,0.4-6.2,0.9-9.1,0.9c-1.5,0-2.8-0.1-4.1-0.3c-10.4-1.9-17.3-8.8-19.7-19.5c-0.3-1-0.6-3-0.6-5.5c0-0.5-0.3-0.9-0.8-1.1
			c-0.4-0.2-1-0.1-1.3,0.3c-9.7,9-10.3,17.9-9.8,22.3c0.8,7.2,5.2,12.5,9,14.1c1.2,0.5,2.7,0.8,4.3,0.8c1.7,0,3.4-0.2,5.4-0.5
			c2.2-0.3,4.7-0.7,7.4-0.7c7.4,0,14.2,2.5,21.6,7.9c0.8,0.6,0.9,1.6,0.3,2.3c-0.5,0.8-1.7,0.9-2.3,0.3c-6.8-4.9-12.9-7.2-19.5-7.2
			c-2.5,0-4.8,0.3-7,0.6c-2,0.2-4,0.5-5.9,0.5c-2.1,0-3.8-0.3-5.5-1c-4.8-1.9-8.9-7.2-10.6-13.6c-0.2-0.5-0.6-0.8-1.1-0.9
			c-0.5-0.1-1,0.3-1.2,0.7c-4.6,10-2,20,2.6,25.5c3.4,4.1,8,6.2,13.1,6.2c3.8,0,7.6-1.1,11.5-3.3c0.3-0.2,0.5-0.4,0.6-0.7
			c0.6-2.2,1.4-4.4,2.5-6.2c0.5-0.7,1.6-1,2.3-0.6c0.4,0.2,0.7,0.6,0.8,1.1c0.1,0.4,0,0.9-0.2,1.2c-3.3,5.4-4.2,14.8,0.5,21.6
			c3.6,5.2,9.7,7.8,18.1,7.8c0.8,0,1.5,0,2.2-0.1c0.4,0,0.8-0.3,1.1-0.7c0.2-0.4,0.2-0.9-0.2-1.2c-4.3-5.7,0.4-11.8,5-17.7
			c4.6-5.9,9.3-12,7.4-18.7c-0.2-0.9,0.2-1.8,1.2-2.1c0.9-0.2,1.8,0.3,2.1,1.2c2.3,8.3-3.4,15.7-8.1,21.7c-5.3,6.7-8,10.7-4.3,14.4
			c1.4,1.4,2.8,2.1,4.3,2.1c2.4,0,5.2-1.5,10.6-4.8c4.6-2.8,10.9-6.8,19-9.2c0.5-0.2,0.8-0.6,0.9-1.1c0-0.5-0.2-1-0.7-1.2
			c-2.2-1.1-4.1-2.4-5.2-4c-2.1-2.7-2.7-6-1.7-9.9c0.2-0.9,1.2-1.4,2.1-1.2c0.9,0.2,1.4,1.2,1.2,2.1c-0.7,2.8-0.3,5.2,1.1,7
			c1.8,2.3,6.4,5.2,18.2,6c2,0,3.9,0,5.9,0.2c5.9,0,12.2-1.2,17-3.1c0.3-0.2,0.7-0.5,0.7-0.8c0.1-0.4,0-0.8-0.2-1.1
			c-1.2-1.2-2.8-2-4.9-2.9c-3.3-1.4-7.5-3.2-8.1-9c-0.1-0.9,0.6-1.8,1.5-1.8s1.8,0.6,1.8,1.5c0.3,3.8,2.8,4.8,6,6.2
			c2.2,0.9,5,2.1,6.8,4.7c0.2,0.2,0.5,0.5,0.8,0.5c0.3,0.1,0.7-0.1,0.9-0.2C220,163.4,221.3,160.9,221.3,158.2z"/>
		<g>
			<path fill="#FFFFFF" d="M194,174.2c-1,0-1.9-0.1-2.9-0.2c-15.4,0.2-25.5,6.5-32.8,11c-2.5,1.5-5,3.1-7.5,4.1
				c-0.4,0.2-0.8,0.6-0.8,1s0.2,0.9,0.6,1.2c1.3,0.8,2.7,1.5,4.1,2.2c1.7,0.8,3.3,1,4.9,1.2c4.4,0.7,7.9,1.2,9.5,13.4
				c0.1,0.6,0.6,1.1,1.2,1.1h8.6c0.3,0,0.7-0.2,0.9-0.4s0.3-0.7,0.2-1c-1.7-12.2-0.2-13,3.2-15c1.2-0.7,2.4-1.4,3.8-2.6
				c3.3-2.8,6.8-5.8,7.9-14.8c0.1-0.3-0.1-0.7-0.2-0.9C194.7,174.3,194.3,174.2,194,174.2z"/>
		</g>
	</g>
</g>
</svg>

```

`frontend/app/images/logo.svg`:

```svg
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 18.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 624 200" enable-background="new 0 0 624 200" xml:space="preserve">
<g>
	<g>
		<path fill="#151632" d="M172.2,73v66.4h-20.7V73h-27.4V54.8h75.5V73H172.2z"/>
		<path fill="#151632" d="M272.8,100.5v38.9h-20.1v-34.6c0-7.4-4.4-12.5-11-12.5c-7.8,0-13,5.4-13,17.7v29.4h-20.2V48.5h20.2V82
			c4.9-5,11.5-7.9,19.6-7.9C263,74.1,272.8,84.6,272.8,100.5z"/>
		<path fill="#151632" d="M356.3,112.8h-46.4c1.6,7.6,6.8,12.2,13.6,12.2c4.7,0,10.1-1.1,13.5-7.3l17.9,3.7
			c-5.4,13.4-16.9,19.8-31.4,19.8c-18.3,0-33.4-13.5-33.4-33.6c0-19.9,15.1-33.6,33.6-33.6c17.9,0,32.3,12.9,32.7,33.6V112.8z
			 M310.3,100.5h26.1c-1.9-6.8-6.9-10-12.7-10C318,90.5,312.2,94,310.3,100.5z"/>
		<path fill="#F3D02F" d="M445.5,139.3h-20.7v-33.4h-35.6v33.4h-20.8V54.8h20.8v32.9h35.6V54.8h20.7V139.3z"/>
		<path fill="#F3D02F" d="M478.6,57.3c0,6.4-4.9,11.2-11.7,11.2c-6.8,0-11.6-4.8-11.6-11.2c0-6.2,4.8-11.5,11.6-11.5
			C473.7,45.8,478.6,51.1,478.6,57.3z M456.8,139.3V76h20.2v63.3H456.8z"/>
		<path fill="#F3D02F" d="M528.5,139.3h-20.6l-26.2-63.5H503l15.3,39.1l15.1-39.1h21.3L528.5,139.3z"/>
		<path fill="#F3D02F" d="M618.3,112.8h-46.4c1.6,7.6,6.8,12.2,13.6,12.2c4.7,0,10.1-1.1,13.5-7.3l17.9,3.7
			c-5.4,13.4-16.9,19.8-31.4,19.8c-18.3,0-33.4-13.5-33.4-33.6c0-19.9,15.1-33.6,33.6-33.6c17.9,0,32.3,12.9,32.7,33.6V112.8z
			 M572.2,100.5h26.1c-1.9-6.8-6.9-10-12.7-10C579.9,90.5,574.1,94,572.2,100.5z"/>
	</g>
	<g>
		<g>
			<path fill="#F3D02F" d="M57,70.3c6.6,0,12.2,6.4,12.2,11.5c0,6.1-10,6.6-12,6.6l0,0c-2.2,0-12-0.3-12-6.6
				C44.8,76.7,50.4,70.3,57,70.3L57,70.3z M44.1,133.6l25.2,0.1l2.2,5.6l-29.6-0.1L44.1,133.6z M47.6,125.6l2.2-5.6l14.2,0l2.2,5.6
				L47.6,125.6z M53,112.1l3.9-9.5l3.9,9.5L53,112.1z M23.3,143.6c-1.7,0-3.2-0.3-4.6-1c-6.1-2.7-9.3-9.8-6.5-15.9
				c6.9-16.6,27.7-28.5,39-30.2l-7.4,18.1l0,0L38.3,128l0,0l-3.5,8.1C32.6,140.7,28.2,143.6,23.3,143.6L23.3,143.6z M56.7,161.8
				c-8.1,0-14.7-5.9-17.3-15l34.7,0.1C71.4,156.2,64.8,161.8,56.7,161.8L56.7,161.8z M95,142.9c-1.5,0.7-3.2,1-4.6,1
				c-4.9,0-9.3-3-11.2-7.6l-3.4-8.1l0,0l-5.1-12.7c0-0.5-0.2-1-0.5-1.5l-7-17.6c11.2,2,32,14,38.8,30.5
				C104.3,133.3,101.3,140.4,95,142.9L95,142.9z"/>
			
				<line fill="none" stroke="#F3D02F" stroke-width="5.2146" stroke-linecap="round" stroke-miterlimit="10" x1="47.8" y1="67.5" x2="43.7" y2="58.9"/>
			
				<line fill="none" stroke="#F3D02F" stroke-width="5.2146" stroke-linecap="round" stroke-miterlimit="10" x1="66.1" y1="67.5" x2="70.1" y2="58.9"/>
		</g>
		
			<polyline fill="none" stroke="#F3D02F" stroke-width="5.2146" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="
			94.8,103.5 105.5,84.2 81.1,42.1 32.7,42.1 8.3,84.2 20,103.5 		"/>
	</g>
</g>
</svg>

```

`frontend/app/images/logo.white.svg`:

```svg
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 18.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 100 36" enable-background="new 0 0 100 36" xml:space="preserve">
<g>
	<path fill="#FFFFFF" d="M27.8,14.3v10.4h-3.3V14.3h-4.3v-2.9h11.9v2.9H27.8z"/>
	<path fill="#FFFFFF" d="M43.6,18.6v6.1h-3.2v-5.4c0-1.2-0.7-2-1.7-2c-1.2,0-2,0.9-2,2.8v4.6h-3.2V10.4h3.2v5.3
		c0.8-0.8,1.8-1.3,3.1-1.3C42.1,14.4,43.6,16.1,43.6,18.6z"/>
	<path fill="#FFFFFF" d="M56.8,20.5h-7.3c0.3,1.2,1.1,1.9,2.1,1.9c0.7,0,1.6-0.2,2.1-1.2l2.8,0.6C55.7,24,53.9,25,51.6,25
		c-2.9,0-5.3-2.1-5.3-5.3c0-3.1,2.4-5.3,5.3-5.3c2.8,0,5.1,2,5.1,5.3V20.5z M49.5,18.6h4.1c-0.3-1.1-1.1-1.6-2-1.6
		C50.7,17,49.8,17.6,49.5,18.6z"/>
	<path fill="#F3D02F" d="M70.8,24.7h-3.3v-5.3h-5.6v5.3h-3.3V11.4h3.3v5.2h5.6v-5.2h3.3V24.7z"/>
	<path fill="#F3D02F" d="M76,11.8c0,1-0.8,1.8-1.8,1.8c-1.1,0-1.8-0.8-1.8-1.8c0-1,0.8-1.8,1.8-1.8C75.2,10,76,10.8,76,11.8z
		 M72.6,24.7v-10h3.2v10H72.6z"/>
	<path fill="#F3D02F" d="M83.9,24.7h-3.2l-4.1-10h3.4l2.4,6.2l2.4-6.2H88L83.9,24.7z"/>
	<path fill="#F3D02F" d="M98,20.5h-7.3c0.3,1.2,1.1,1.9,2.1,1.9c0.7,0,1.6-0.2,2.1-1.2l2.8,0.6C96.9,24,95.1,25,92.8,25
		c-2.9,0-5.3-2.1-5.3-5.3c0-3.1,2.4-5.3,5.3-5.3c2.8,0,5.1,2,5.1,5.3V20.5z M90.8,18.6h4.1c-0.3-1.1-1.1-1.6-2-1.6
		C92,17,91.1,17.6,90.8,18.6z"/>
	<g>
		<g>
			<path fill="#F3D02F" d="M9.7,13.9c1,0,1.9,1,1.9,1.8c0,1-1.6,1-1.9,1l0,0c-0.3,0-1.9,0-1.9-1C7.7,14.9,8.6,13.9,9.7,13.9
				L9.7,13.9z M7.6,23.8l4,0l0.3,0.9l-4.7,0L7.6,23.8z M8.2,22.6l0.3-0.9l2.2,0l0.3,0.9L8.2,22.6z M9,20.4l0.6-1.5l0.6,1.5L9,20.4z
				 M4.4,25.4c-0.3,0-0.5,0-0.7-0.2c-1-0.4-1.5-1.5-1-2.5C3.7,20.1,7,18.2,8.7,18l-1.2,2.8l0,0l-0.9,2.1l0,0l-0.5,1.3
				C5.8,24.9,5.1,25.4,4.4,25.4L4.4,25.4z M9.6,28.3c-1.3,0-2.3-0.9-2.7-2.4l5.5,0C11.9,27.4,10.9,28.3,9.6,28.3L9.6,28.3z
				 M15.6,25.3c-0.2,0.1-0.5,0.2-0.7,0.2c-0.8,0-1.5-0.5-1.8-1.2L12.6,23l0,0l-0.8-2c0-0.1,0-0.2-0.1-0.2l-1.1-2.8
				c1.8,0.3,5,2.2,6.1,4.8C17.1,23.8,16.6,24.9,15.6,25.3L15.6,25.3z"/>
			
				<line fill="none" stroke="#F3D02F" stroke-width="0.8207" stroke-linecap="round" stroke-miterlimit="10" x1="8.2" y1="13.4" x2="7.6" y2="12"/>
			
				<line fill="none" stroke="#F3D02F" stroke-width="0.8207" stroke-linecap="round" stroke-miterlimit="10" x1="11.1" y1="13.4" x2="11.7" y2="12"/>
		</g>
		
			<polyline fill="none" stroke="#F3D02F" stroke-width="0.8207" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="
			15.6,19.1 17.3,16 13.5,9.4 5.8,9.4 2,16 3.8,19.1 		"/>
	</g>
</g>
</svg>

```

`frontend/app/images/misp-logo.svg`:

```svg
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 18.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1"
	 id="svg4883" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" sodipodi:docname="New document 5" inkscape:version="0.48.0 r9654"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 300 300" enable-background="new 0 0 300 300" xml:space="preserve">

<!-- <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" x="0px" y="0px"
	 viewBox="0 0 300 300" enable-background="new 0 0 300 300" xml:space="preserve"> -->
<g>
	<circle fill="#5F6163" cx="150" cy="150" r="125"/>
	<g>
		<g id="g310-5">
			<g id="g316" transform="translate(385.579,529.5928)">
				<path id="path318" inkscape:connector-curvature="0" fill="#FFFFFF" d="M-167.9-400.7h-4v43.9c0,6.8-4,13-12,13h-78.1v2.1
					c0,6,6.9,12.1,13.9,12.1h59.7l22.9,13.4l-3.3-13.4h0.9c7,0,10.2-6.1,10.2-12.1v-48.6C-157.6-396.3-160.8-400.7-167.9-400.7"/>
			</g>
			<g id="g320-4" transform="translate(349.7253,569.1839)">
				<path id="path322-8" inkscape:connector-curvature="0" fill="#FFFFFF" d="M-159.6-470.7h-90.7c-8,0-17.2,7.1-17.2,13.9v55
					c0,6.3,7.8,10.8,15.3,11.5l-4.9,18.4l31.1-18.3h66.4c8,0,15.4-4.8,15.4-11.7v-44.5v-10.5C-144.3-463.7-151.6-470.7-159.6-470.7
					 M-236.5-424.3c-4.5,0-8.2-3.7-8.2-8.2s3.7-8.2,8.2-8.2c4.5,0,8.2,3.7,8.2,8.2S-232-424.3-236.5-424.3 M-205.9-424.3
					c-4.5,0-8.2-3.7-8.2-8.2s3.7-8.2,8.2-8.2s8.2,3.7,8.2,8.2S-201.4-424.3-205.9-424.3 M-175.3-424.3c-4.5,0-8.2-3.7-8.2-8.2
					s3.7-8.2,8.2-8.2c4.5,0,8.2,3.7,8.2,8.2S-170.8-424.3-175.3-424.3"/>
			</g>
		</g>
	</g>
</g>
</svg>

```

`frontend/app/index.html`:

```html
<!doctype html>
<html ng-app="thehive">
  <head>
    <meta charset="utf-8">
    <title ng-bind="'TheHive' + (title ? ' - ' + title : '')"></title>

    <meta name="description" content="">
    <meta name="viewport" content="width=device-width">

    <!-- <link rel="icon" type="image/png" href="images/favicon.png" /> -->

    <link rel="icon" type="image/png" href="images/favicons/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="images/favicons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="images/favicons/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="images/favicons/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="images/favicons/favicon-128.png" sizes="128x128" />

    <!-- build:css(.) styles/vendor.css -->
    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="bower_components/font-awesome/css/font-awesome.min.css"/>
    <!-- bower:css -->
    <link rel="stylesheet" href="bower_components/animate.css/animate.css" />
    <link rel="stylesheet" href="bower_components/dropzone/dist/min/dropzone.min.css" />
    <link rel="stylesheet" href="bower_components/ng-tags-input/ng-tags-input.css" />
    <link rel="stylesheet" href="bower_components/roboto-fontface/css/roboto/roboto-fontface.css" />
    <link rel="stylesheet" href="bower_components/angular-ui-notification/dist/angular-ui-notification.css" />
    <link rel="stylesheet" href="bower_components/c3/c3.css" />
    <link rel="stylesheet" href="bower_components/css-spaces/dist/spaces.css" />
    <link rel="stylesheet" href="bower_components/bootstrap-markdown/css/bootstrap-markdown.min.css" />
    <link rel="stylesheet" href="bower_components/angular-markdown-editor-ghiscoding/styles/angular-markdown-editor.css" />
    <link rel="stylesheet" href="bower_components/angular-page-loader/dist/angular-page-loader.css" />
    <link rel="stylesheet" href="bower_components/angular-bootstrap-colorpicker/css/colorpicker.css" />
    <!-- endbower -->
    <link rel="stylesheet" href="bower_components/smalot-bootstrap-datetimepicker/css/bootstrap-datetimepicker.css" />
    <link rel="stylesheet" href="bower_components/ng-tags-input/ng-tags-input.bootstrap.min.css"/>
    <!-- endbuild -->

    <!-- build:css(.tmp) styles/app.css -->
    <link rel="stylesheet" href="styles/vendors/AdminLTE.css">
    <link rel="stylesheet" href="styles/vendors/AdminLTE-skin-blue.css">

    <link rel="stylesheet" href="styles/main.css"/>
    <link rel="stylesheet" href="styles/case.css"/>
    <link rel="stylesheet" href="styles/flow.css"/>
    <link rel="stylesheet" href="styles/label.css"/>
    <link rel="stylesheet" href="styles/updatable.css"/>
    <link rel="stylesheet" href="styles/flex-table.css"/>
    <link rel="stylesheet" href="styles/search.css"/>
    <link rel="stylesheet" href="styles/filters.css"/>
    <link rel="stylesheet" href="styles/dashboard.css"/>
    <link rel="stylesheet" href="styles/case-item.css"/>
    <link rel="stylesheet" href="styles/case-template.css"/>
    <link rel="stylesheet" href="styles/procedure.css"/>
    <link rel="stylesheet" href="styles/custom-fields.css"/>
    <link rel="stylesheet" href="styles/directives/page-sizer.css"/>
    <link rel="stylesheet" href="styles/directives/user.css"/>
    <link rel="stylesheet" href="styles/components/tag.css"/>
    <!-- endbuild -->

    <style>
		app-container { display: block }
	</style>

  </head>
  <body ng-cloak class="hold-transition skin-blue layout-top-nav">
    <page-loader flag="isLoading" bg-color="#ecf0f5"></page-loader>
    <div ui-view></div>

    <!-- build:js(.) scripts/vendor.js -->
    <!-- bower:js -->
    <script src="bower_components/jquery/dist/jquery.js"></script>
    <script src="bower_components/angular/angular.js"></script>
    <script src="bower_components/angular-animate/angular-animate.js"></script>
    <script src="bower_components/angular-bootstrap/ui-bootstrap-tpls.js"></script>
    <script src="bower_components/angular-cookies/angular-cookies.js"></script>
    <script src="bower_components/moment/moment.js"></script>
    <script src="bower_components/angular-moment/angular-moment.js"></script>
    <script src="bower_components/angular-resource/angular-resource.js"></script>
    <script src="bower_components/angular-sanitize/angular-sanitize.js"></script>
    <script src="bower_components/humanize-duration/humanize-duration.js"></script>
    <script src="bower_components/angular-timer/dist/angular-timer.js"></script>
    <script src="bower_components/angular-touch/angular-touch.js"></script>
    <script src="bower_components/angular-ui-router/release/angular-ui-router.js"></script>
    <script src="bower_components/bootstrap/dist/js/bootstrap.js"></script>
    <script src="bower_components/bootstrap-sass-official/assets/javascripts/bootstrap.js"></script>
    <script src="bower_components/dropzone/dist/min/dropzone.min.js"></script>
    <script src="bower_components/ng-csv/build/ng-csv.min.js"></script>
    <script src="bower_components/ng-tags-input/ng-tags-input.js"></script>
    <script src="bower_components/underscore/underscore-umd.js"></script>
    <script src="bower_components/angular-ui-notification/dist/angular-ui-notification.js"></script>
    <script src="bower_components/d3/d3.js"></script>
    <script src="bower_components/c3/c3.js"></script>
    <script src="bower_components/angular-messages/angular-messages.js"></script>
    <script src="bower_components/ng-file-upload/ng-file-upload.js"></script>
    <script src="bower_components/ng-file-upload-shim/ng-file-upload-shim.js"></script>
    <script src="bower_components/es5-shim/es5-shim.js"></script>
    <script src="bower_components/es6-shim/es6-shim.js"></script>
    <script src="bower_components/angular-clipboard/angular-clipboard.js"></script>
    <script src="bower_components/angular-local-storage/dist/angular-local-storage.js"></script>
    <script src="bower_components/angular-highlightjs/build/angular-highlightjs.js"></script>
    <script src="bower_components/marked/lib/marked.js"></script>
    <script src="bower_components/angular-marked/dist/angular-marked.js"></script>
    <script src="bower_components/bootstrap-markdown/js/bootstrap-markdown.js"></script>
    <script src="bower_components/angular-markdown-editor-ghiscoding/src/angular-markdown-editor.js"></script>
    <script src="bower_components/angular-ui-ace/ui-ace.js"></script>
    <script src="bower_components/angular-page-loader/dist/angular-page-loader.js"></script>
    <script src="bower_components/angular-images-resizer/angular-images-resizer.js"></script>
    <script src="bower_components/angular-base64-upload/src/angular-base64-upload.js"></script>
    <script src="bower_components/jquery-ui/jquery-ui.js"></script>
    <script src="bower_components/angular-ui-sortable/sortable.js"></script>
    <script src="bower_components/js-base64/base64.js"></script>
    <script src="bower_components/angular-scroll/angular-scroll.js"></script>
    <script src="bower_components/underscore.string/dist/underscore.string.js"></script>
    <script src="bower_components/angular-drag-and-drop-lists/angular-drag-and-drop-lists.js"></script>
    <script src="bower_components/angular-bootstrap-colorpicker/js/bootstrap-colorpicker-module.js"></script>
    <script src="bower_components/file-saver/FileSaver.js"></script>
    <script src="bower_components/js-url/url.js"></script>
    <script src="bower_components/bootstrap-sass/assets/javascripts/bootstrap.js"></script>
    <script src="bower_components/angular-bootstrap-multiselect/dist/angular-bootstrap-multiselect.js"></script>
    <script src="bower_components/qrcode.js/lib/qrcode.js"></script>
    <script src="bower_components/qrcode/lib/qrcode.js"></script>
    <script src="bower_components/angular-qr/src/angular-qr.js"></script>
    <!-- endbower -->

    <script type="text/javascript" src="bower_components/ace-builds/src-min-noconflict/ace.js"></script>
    <script type="text/javascript" src="bower_components/angular-ui-ace/ui-ace.js"></script>

    <script src="bower_components/smalot-bootstrap-datetimepicker/js/bootstrap-datetimepicker.min.js"></script>
    <script src="bower_components/cryptojslib/components/core-min.js"></script>
    <script src="bower_components/cryptojslib/components/sha256-min.js"></script>
    <script src="bower_components/cryptojslib/components/md5-min.js"></script>
    <!-- endbuild -->

    <!-- build:js({.tmp,app}) scripts/scripts.js -->
    <!-- injector:js -->
    <script src="scripts/app.js"></script>
    <script src="scripts/components/alert/AlertObservableListCmp.js"></script>
    <script src="scripts/components/alert/AlertSimilarCaseListCmp.js"></script>
    <script src="scripts/components/app-container.component.js"></script>
    <script src="scripts/components/charts/donut-chart.component.js"></script>
    <script src="scripts/components/common/custom-field-input.component.js"></script>
    <script src="scripts/components/common/custom-field-labels.component.js"></script>
    <script src="scripts/components/common/datalist-header.component.js"></script>
    <script src="scripts/components/common/observable-flags.component.js"></script>
    <script src="scripts/components/common/tag.component.js"></script>
    <script src="scripts/components/common/task-flags.component.js"></script>
    <script src="scripts/components/control-sidebar.component.js"></script>
    <script src="scripts/components/header.component.js"></script>
    <script src="scripts/components/list/stats-item.component.js"></script>
    <script src="scripts/components/main-sidebar.component.js"></script>
    <script src="scripts/components/organisation/OrgCaseTemplateListCmp.js"></script>
    <script src="scripts/components/organisation/OrgCaseTemplateModalCtrl.js"></script>
    <script src="scripts/components/organisation/OrgConfigListCmp.js"></script>
    <script src="scripts/components/organisation/OrgCustomTagsListCmp.js"></script>
    <script src="scripts/components/organisation/OrgSwitchCtrl.js"></script>
    <script src="scripts/components/organisation/OrgUserListCmp.js"></script>
    <script src="scripts/components/search/filters-preview.component.js"></script>
    <script src="scripts/components/sharing/SharingListCmp.js"></script>
    <script src="scripts/components/sharing/SharingModalCtrl.js"></script>
    <script src="scripts/components/sharing/task/SharingListCmp.js"></script>
    <script src="scripts/controllers/AboutCtrl.js"></script>
    <script src="scripts/controllers/admin/AdminAnalyzerTemplatesCtrl.js"></script>
    <script src="scripts/controllers/admin/AdminCustomFieldDialogCtrl.js"></script>
    <script src="scripts/controllers/admin/AdminCustomFieldsCtrl.js"></script>
    <script src="scripts/controllers/admin/AdminObservablesCtrl.js"></script>
    <script src="scripts/controllers/admin/AdminUiSettingsCtrl.js"></script>
    <script src="scripts/controllers/admin/attack/AttackPatternListCtrl.js"></script>
    <script src="scripts/controllers/admin/organisation/case-template/AdminCaseTemplateImportCtrl.js"></script>
    <script src="scripts/controllers/admin/organisation/case-template/AdminCaseTemplateTasksCtrl.js"></script>
    <script src="scripts/controllers/admin/organisation/OrgDetailsCtrl.js"></script>
    <script src="scripts/controllers/admin/organisation/OrgLinksModalCtrl.js"></script>
    <script src="scripts/controllers/admin/organisation/OrgListCtrl.js"></script>
    <script src="scripts/controllers/admin/organisation/OrgModalCtrl.js"></script>
    <script src="scripts/controllers/admin/organisation/OrgUserModalCtrl.js"></script>
    <script src="scripts/controllers/admin/organisation/OrgUsersCtrl.js"></script>
    <script src="scripts/controllers/admin/platform/PlatformStatusCtrl.js"></script>
    <script src="scripts/controllers/admin/profile/ProfileListCtrl.js"></script>
    <script src="scripts/controllers/admin/profile/ProfileModalCtrl.js"></script>
    <script src="scripts/controllers/admin/taxonomy/TaxonomyListCtrl.js"></script>
    <script src="scripts/controllers/alert/AlertEventCtrl.js"></script>
    <script src="scripts/controllers/alert/AlertListCtrl.js"></script>
    <script src="scripts/controllers/alert/AlertStatsCtrl.js"></script>
    <script src="scripts/controllers/AuthenticationCtrl.js"></script>
    <script src="scripts/controllers/case/CaseAlertsCtrl.js"></script>
    <script src="scripts/controllers/case/CaseCloseModalCtrl.js"></script>
    <script src="scripts/controllers/case/CaseCreationCtrl.js"></script>
    <script src="scripts/controllers/case/CaseDeleteModalCtrl.js"></script>
    <script src="scripts/controllers/case/CaseDetailsCtrl.js"></script>
    <script src="scripts/controllers/case/CaseExportDialogCtrl.js"></script>
    <script src="scripts/controllers/case/CaseLinksCtrl.js"></script>
    <script src="scripts/controllers/case/CaseListCtrl.js"></script>
    <script src="scripts/controllers/case/CaseMainCtrl.js"></script>
    <script src="scripts/controllers/case/CaseMergeModalCtrl.js"></script>
    <script src="scripts/controllers/case/CaseObservablesCtrl.js"></script>
    <script src="scripts/controllers/case/CaseObservablesExportCtrl.js"></script>
    <script src="scripts/controllers/case/CaseObservablesItemCtrl.js"></script>
    <script src="scripts/controllers/case/CaseProceduresCtrl.js"></script>
    <script src="scripts/controllers/case/CaseReopenModalCtrl.js"></script>
    <script src="scripts/controllers/case/CaseSharingCtrl.js"></script>
    <script src="scripts/controllers/case/CaseStatsCtrl.js"></script>
    <script src="scripts/controllers/case/CaseTasksCtrl.js"></script>
    <script src="scripts/controllers/case/CaseTasksItemCtrl.js"></script>
    <script src="scripts/controllers/case/CaseTemplatesDialogCtrl.js"></script>
    <script src="scripts/controllers/case/CaseUpdateCtrl.js"></script>
    <script src="scripts/controllers/case/ObservableAnalyzeCtrl.js"></script>
    <script src="scripts/controllers/case/ObservableCreationCtrl.js"></script>
    <script src="scripts/controllers/case/ObservablesStatsCtrl.js"></script>
    <script src="scripts/controllers/case/ObservableUpdateCtrl.js"></script>
    <script src="scripts/controllers/case/procedure/AddProcedureModalCtrl.js"></script>
    <script src="scripts/controllers/case/share/CaseShareModalCtrl.js"></script>
    <script src="scripts/controllers/case/tasklogs/AddTaskLogModalCtrl.js"></script>
    <script src="scripts/controllers/cortex/CortexInstanceDialogCtrl.js"></script>
    <script src="scripts/controllers/cortex/ResponderActionDialogCtrl.js"></script>
    <script src="scripts/controllers/dashboard/DashboardsCtrl.js"></script>
    <script src="scripts/controllers/dashboard/DashboardViewCtrl.js"></script>
    <script src="scripts/controllers/LiveCtrl.js"></script>
    <script src="scripts/controllers/MainPageCtrl.js"></script>
    <script src="scripts/controllers/MigrationCtrl.js"></script>
    <script src="scripts/controllers/misc/ResponderSelectorCtrl.js"></script>
    <script src="scripts/controllers/misc/ServerInstanceDialogCtrl.js"></script>
    <script src="scripts/controllers/misc/TaxonomySelectionModalCtrl.js"></script>
    <script src="scripts/controllers/RootCtrl.js"></script>
    <script src="scripts/controllers/SearchCtrl.js"></script>
    <script src="scripts/controllers/SettingsCtrl.js"></script>
    <script src="scripts/directives/affixer.js"></script>
    <script src="scripts/directives/alert-duration.js"></script>
    <script src="scripts/directives/auto-focus.js"></script>
    <script src="scripts/directives/case-duration.js"></script>
    <script src="scripts/directives/charts/c3Chart.js"></script>
    <script src="scripts/directives/compare-to.js"></script>
    <script src="scripts/directives/dashboard/bar.js"></script>
    <script src="scripts/directives/dashboard/counter.js"></script>
    <script src="scripts/directives/dashboard/donut.js"></script>
    <script src="scripts/directives/dashboard/filter-editor.js"></script>
    <script src="scripts/directives/dashboard/item.js"></script>
    <script src="scripts/directives/dashboard/line.js"></script>
    <script src="scripts/directives/dashboard/multiline.js"></script>
    <script src="scripts/directives/dashboard/text.js"></script>
    <script src="scripts/directives/dateTimePicker.js"></script>
    <script src="scripts/directives/dt-picker.js"></script>
    <script src="scripts/directives/entityLink.js"></script>
    <script src="scripts/directives/fileChooser.js"></script>
    <script src="scripts/directives/filter-box.js"></script>
    <script src="scripts/directives/fixed-height.js"></script>
    <script src="scripts/directives/flow/flow-item.js"></script>
    <script src="scripts/directives/flow/flow.js"></script>
    <script src="scripts/directives/if-not-permission.js"></script>
    <script src="scripts/directives/if-permission.js"></script>
    <script src="scripts/directives/logEntry.js"></script>
    <script src="scripts/directives/mini-report-list.js"></script>
    <script src="scripts/directives/page-sizer.js"></script>
    <script src="scripts/directives/permission-list.js"></script>
    <script src="scripts/directives/psearch.js"></script>
    <script src="scripts/directives/report-observables.js"></script>
    <script src="scripts/directives/report.js"></script>
    <script src="scripts/directives/responder-actions.js"></script>
    <script src="scripts/directives/search/search-item.js"></script>
    <script src="scripts/directives/severity.js"></script>
    <script src="scripts/directives/tag-colour.js"></script>
    <script src="scripts/directives/tag-item.js"></script>
    <script src="scripts/directives/tag-list.js"></script>
    <script src="scripts/directives/task-progress.js"></script>
    <script src="scripts/directives/tlp.js"></script>
    <script src="scripts/directives/updatable.js"></script>
    <script src="scripts/directives/updatableBoolean.js"></script>
    <script src="scripts/directives/updatableColour.js"></script>
    <script src="scripts/directives/updatableDataDropdown.js"></script>
    <script src="scripts/directives/updatableDate.js"></script>
    <script src="scripts/directives/updatableSelect.js"></script>
    <script src="scripts/directives/updatableSimpleText.js"></script>
    <script src="scripts/directives/updatableTag.js"></script>
    <script src="scripts/directives/updatableTagList.js"></script>
    <script src="scripts/directives/updatableTags.js"></script>
    <script src="scripts/directives/updatableText.js"></script>
    <script src="scripts/directives/updatableUser.js"></script>
    <script src="scripts/directives/user.js"></script>
    <script src="scripts/directives/userinfo.js"></script>
    <script src="scripts/directives/utils/autofocus.js"></script>
    <script src="scripts/filters/custom-field-value.js"></script>
    <script src="scripts/filters/duration.js"></script>
    <script src="scripts/filters/ellipsis.js"></script>
    <script src="scripts/filters/fang.js"></script>
    <script src="scripts/filters/filesize.js"></script>
    <script src="scripts/filters/filter-value.js"></script>
    <script src="scripts/filters/flattern-object.js"></script>
    <script src="scripts/filters/getField.js"></script>
    <script src="scripts/filters/hash-type.js"></script>
    <script src="scripts/filters/limited-count.js"></script>
    <script src="scripts/filters/md5.js"></script>
    <script src="scripts/filters/offset.js"></script>
    <script src="scripts/filters/order-object-by.js"></script>
    <script src="scripts/filters/percent.js"></script>
    <script src="scripts/filters/sha256.js"></script>
    <script src="scripts/filters/shortDate.js"></script>
    <script src="scripts/filters/showDate.js"></script>
    <script src="scripts/filters/tag-value.js"></script>
    <script src="scripts/filters/urlencode.js"></script>
    <script src="scripts/services/AnalyzerInfoSrv.js"></script>
    <script src="scripts/services/api/AlertingSrv.js"></script>
    <script src="scripts/services/api/AnalyzerSrv.js"></script>
    <script src="scripts/services/api/AnalyzerTemplateSrv.js"></script>
    <script src="scripts/services/api/AttackPatternSrv.js"></script>
    <script src="scripts/services/api/AuditSrv.js"></script>
    <script src="scripts/services/api/AuthenticationSrv.js"></script>
    <script src="scripts/services/api/CaseSrv.js"></script>
    <script src="scripts/services/api/CaseTaskSrv.js"></script>
    <script src="scripts/services/api/CaseTemplateSrv.js"></script>
    <script src="scripts/services/api/CortexSrv.js"></script>
    <script src="scripts/services/api/CustomFieldsSrv.js"></script>
    <script src="scripts/services/api/DashboardSrv.js"></script>
    <script src="scripts/services/api/JobSrv.js"></script>
    <script src="scripts/services/api/ListSrv.js"></script>
    <script src="scripts/services/api/MispSrv.js"></script>
    <script src="scripts/services/api/ObservableTypeSrv.js"></script>
    <script src="scripts/services/api/OrganisationSrv.js"></script>
    <script src="scripts/services/api/PlatformSrv.js"></script>
    <script src="scripts/services/api/ProcedureSrv.js"></script>
    <script src="scripts/services/api/ProfileSrv.js"></script>
    <script src="scripts/services/api/TagSrv.js"></script>
    <script src="scripts/services/api/TaskLogSrv.js"></script>
    <script src="scripts/services/api/TaxonomyCacheSrv.js"></script>
    <script src="scripts/services/api/TaxonomySrv.js"></script>
    <script src="scripts/services/api/UiSettingsSrv.js"></script>
    <script src="scripts/services/api/UserSrv.js"></script>
    <script src="scripts/services/api/VersionSrv.js"></script>
    <script src="scripts/services/common/Constants.js"></script>
    <script src="scripts/services/common/data/CaseArtifactSrv.js"></script>
    <script src="scripts/services/common/data/FileResource.js"></script>
    <script src="scripts/services/common/data/PaginatedQuerySrv.js"></script>
    <script src="scripts/services/common/data/PSearchSrv.js"></script>
    <script src="scripts/services/common/data/SearchSrv.js"></script>
    <script src="scripts/services/common/data/StatSrv.js"></script>
    <script src="scripts/services/common/data/StreamQuerySrv.js"></script>
    <script src="scripts/services/common/data/StreamSrv.js"></script>
    <script src="scripts/services/common/data/StreamStatSrv.js"></script>
    <script src="scripts/services/common/HtmlSanitizeSrv.js"></script>
    <script src="scripts/services/common/QueryBuilderSrv.js"></script>
    <script src="scripts/services/common/QuerySrv.js"></script>
    <script src="scripts/services/common/SecuritySrv.js"></script>
    <script src="scripts/services/common/ui/AppLayoutSrv.js"></script>
    <script src="scripts/services/common/ui/FilteringSrv.js"></script>
    <script src="scripts/services/common/ui/modal/ModalSrv.js"></script>
    <script src="scripts/services/common/ui/ModalUtilsSrv.js"></script>
    <script src="scripts/services/common/ui/NotificationSrv.js"></script>
    <script src="scripts/services/common/UtilsSrv.js"></script>
    <script src="scripts/services/EntitySrv.js"></script>
    <script src="scripts/services/ui/AfkSrv.js"></script>
    <script src="scripts/services/ui/CaseTabsSrv.js"></script>
    <script src="scripts/services/ui/ChartSrv.js"></script>
    <script src="scripts/services/ui/GlobalSearchSrv.js"></script>
    <script src="scripts/thirdparty/theme.js"></script>
    <script src="scripts/utils/highlight.min.js"></script>
    <script src="scripts/utils/saveSvgAsPng.js"></script>
    <!-- endinjector -->
    <!-- endbuild -->

  </body>
</html>

```

`frontend/app/scripts/app.js`:

```js
angular.module('theHiveControllers', []);
angular.module('theHiveServices', []);
angular.module('theHiveFilters', []);
angular.module('theHiveDirectives', []);
angular.module('theHiveComponents', []);

angular.module('thehive', [
    'ngAnimate',
    'ngMessages',
    'ngSanitize',
    'ui.bootstrap',
    'ui.router',
    'ui.sortable',
    'timer',
    'angularMoment',
    'ngCsv',
    'ngTagsInput',
    'ngResource',
    'ui-notification',
    'angular-clipboard',
    'LocalStorageModule',
    'angular-markdown-editor',
    'hc.marked',
    'hljs',
    'ui.ace',
    'angular-page-loader',
    'naif.base64',
    'images-resizer',
    'duScroll',
    'dndLists',
    'colorpicker.module',
    'btorfs.multiselect',
    'ja.qr',
    'theHiveControllers',
    'theHiveServices',
    'theHiveFilters',
    'theHiveDirectives',
    'theHiveComponents'
])
    .config(function ($resourceProvider) {
        'use strict';

        $resourceProvider.defaults.stripTrailingSlashes = true;
    })
    .config(function ($compileProvider) {
        'use strict';
        $compileProvider.debugInfoEnabled(false);
    })
    .config(function ($stateProvider, $urlRouterProvider) {
        'use strict';

        //$urlRouterProvider.otherwise('/index');
        $urlRouterProvider.otherwise(function ($injector) {
            $injector.invoke(['$state', function ($state) {
                $state.go('app.index');
            }]);
        });

        $stateProvider
            .state('login', {
                url: '/login',
                controller: 'AuthenticationCtrl',
                templateUrl: 'views/login.html',
                resolve: {
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    }
                },
                params: {
                    autoLogin: false
                },
                title: 'Login'
            })
            .state('live', {
                url: '/live',
                templateUrl: 'views/partials/live.html',
                controller: 'LiveCtrl',
                title: 'Live feed'
            })
            .state('maintenance', {
                url: '/maintenance',
                templateUrl: 'views/maintenance.html',
                controller: 'MigrationCtrl',
                title: 'Database migration'
            })
            .state('app', {
                url: '/',
                abstract: true,
                templateUrl: 'views/app.html',
                controller: 'RootCtrl',
                resolve: {
                    currentUser: function ($q, $state, UserSrv, AuthenticationSrv, NotificationSrv) {
                        var deferred = $q.defer();

                        AuthenticationSrv.current()
                            .then(function (userData) {
                                // Prepare user cache
                                UserSrv.loadCache(userData.organisation);

                                return deferred.resolve(userData);
                            })
                            .catch(function (err) {
                                NotificationSrv.error('App', err.data, err.status);
                                return deferred.reject(err);
                                //return deferred.resolve(err.status === 520 ? err.status : null);
                            });

                        return deferred.promise;
                    },
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    },
                    appLayout: function ($q, $rootScope, AppLayoutSrv) {
                        AppLayoutSrv.init();
                        return $q.resolve();
                    },
                    uiConfig: function ($q, UiSettingsSrv) {
                        return UiSettingsSrv.all();
                    },
                    taxonomyCache: function (TaxonomyCacheSrv) {
                        return TaxonomyCacheSrv.all();
                    }
                }
            })
            .state('app.index', {
                url: 'index',
                onEnter: function ($state, AuthenticationSrv) {
                    $state.go(AuthenticationSrv.getHomePage(), {}, { reload: true });
                }
            })
            .state('app.main', {
                url: 'main/{viewId}',
                params: {
                    viewId: 'mytasks'
                },
                templateUrl: 'views/partials/main/list.html',
                controller: 'MainPageCtrl',
                controllerAs: '$vm',
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.cases', {
                url: 'cases',
                templateUrl: 'views/partials/case/case.list.html',
                controller: 'CaseListCtrl',
                controllerAs: '$vm',
                title: 'Cases',
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.search', {
                url: 'search?q',
                templateUrl: 'views/partials/search/list.html',
                controller: 'SearchCtrl',
                title: 'Search',
                resolve: {
                    metadata: function ($q, DashboardSrv, NotificationSrv) {
                        var defer = $q.defer();

                        DashboardSrv.getMetadata()
                            .then(function (response) {
                                defer.resolve(response);
                            }, function (err) {
                                NotificationSrv.error('DashboardViewCtrl', err.data, err.status);
                                defer.reject(err);
                            });

                        return defer.promise;
                    }
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.settings', {
                url: 'settings',
                templateUrl: 'views/partials/personal-settings.html',
                controller: 'SettingsCtrl',
                title: 'Personal settings',
                resolve: {
                    currentUser: function ($q, $state, $timeout, AuthenticationSrv, NotificationSrv) {
                        var deferred = $q.defer();

                        AuthenticationSrv.current()
                            .then(function (userData) {
                                return deferred.resolve(userData);
                            })
                            .catch(function (err) {
                                NotificationSrv.error('SettingsCtrl', err.data, err.status);

                                return deferred.reject(err);
                            });

                        return deferred.promise;
                    },
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    }
                }
            })
            .state('app.administration', {
                abstract: true,
                url: 'administration',
                template: '<ui-view/>'
            })
            .state('app.administration.platform', {
                url: '/platform',
                templateUrl: 'views/partials/admin/platform/status.html',
                controller: 'PlatformStatusCtrl',
                controllerAs: '$vm',
                title: 'Platform administration',
                resolve: {
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    }
                },
                guard: {
                    permissions: ['managePlatform']
                }
            })
            .state('app.administration.profiles', {
                url: '/profiles',
                templateUrl: 'views/partials/admin/profile/list.html',
                controller: 'ProfileListCtrl',
                controllerAs: '$vm',
                title: 'Profiles administration',
                resolve: {
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    }
                },
                guard: {
                    permissions: ['manageProfile']
                }
            })
            .state('app.administration.taxonomies', {
                url: '/taxonomies',
                templateUrl: 'views/partials/admin/taxonomy/list.html',
                controller: 'TaxonomyListCtrl',
                controllerAs: '$vm',
                title: 'Taxonomies administration',
                resolve: {
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    }
                },
                guard: {
                    permissions: ['manageTaxonomy']
                }
            })
            .state('app.administration.attackPatterns', {
                url: '/attack-patterns',
                templateUrl: 'views/partials/admin/attack/list.html',
                controller: 'AttackPatternListCtrl',
                controllerAs: '$vm',
                title: 'ATT&CK patterns administration',
                resolve: {
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    }
                }
                // guard: {
                //     permissions: ['manageTaxonomy']
                // }
            })
            .state('app.administration.organisations', {
                url: '/organisations',
                templateUrl: 'views/partials/admin/organisation/list.html',
                controller: 'OrgListCtrl',
                controllerAs: '$vm',
                title: 'Organisations administration',
                resolve: {
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    }
                },
                guard: {
                    permissions: ['manageOrganisation']
                }
            })
            .state('app.administration.organisations-details', {
                url: '/organisations/{organisation}/details',
                templateUrl: 'views/partials/admin/organisation/details.html',
                controller: 'OrgDetailsCtrl',
                controllerAs: '$vm',
                resolve: {
                    organisation: function ($stateParams, OrganisationSrv) {
                        return OrganisationSrv.get($stateParams.organisation);
                    },
                    fields: function (CustomFieldsSrv) {
                        return CustomFieldsSrv.all();
                    },
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    },
                    uiConfig: function ($q, UiSettingsSrv) {
                        return UiSettingsSrv.all(true);
                    }
                },
                guard: {
                    permissions: ['manageOrganisation', 'manageUser', 'manageCaseTemplate']
                }
            })
            .state('app.administration.analyzer-templates', {
                url: '/analyzer-templates',
                templateUrl: 'views/partials/admin/analyzer-templates.html',
                controller: 'AdminAnalyzerTemplatesCtrl',
                controllerAs: 'vm',
                title: 'Analyzer templates administration',
                resolve: {
                    appConfig: function ($q, VersionSrv) {
                        var defer = $q.defer();

                        VersionSrv.get()
                            .then(function (config) {
                                // Check if Cortex is enabled
                                if (VersionSrv.hasCortexConnector()) {
                                    defer.resolve(config);
                                } else {
                                    defer.reject();
                                }
                            });

                        return defer.promise;
                    },
                },
                guard: {
                    permissions: ['manageAnalyzerTemplate']
                }
            })
            .state('app.administration.custom-fields', {
                url: '/custom-fields',
                templateUrl: 'views/partials/admin/custom-fields.html',
                controller: 'AdminCustomFieldsCtrl',
                controllerAs: '$vm',
                title: 'Custom fields administration',
                guard: {
                    permissions: ['manageCustomField']
                }
            })
            .state('app.administration.observables', {
                url: '/observables',
                templateUrl: 'views/partials/admin/observables.html',
                controller: 'AdminObservablesCtrl',
                controllerAs: '$vm',
                title: 'Observable administration',
                resolve: {
                    types: function (ObservableTypeSrv, $q) {
                        return ObservableTypeSrv.list()
                            .then(function (response) {
                                return $q.resolve(response.data);
                            });
                    }
                },
                guard: {
                    permissions: ['manageObservableTemplate']
                }
            })
            .state('app.case', {
                abstract: true,
                url: 'case/{caseId}',
                templateUrl: 'views/app.case.html',
                controller: 'CaseMainCtrl',
                title: 'Case',
                resolve: {
                    caze: function ($q, $stateParams, CaseSrv, NotificationSrv) {
                        var deferred = $q.defer();

                        CaseSrv.getById($stateParams.caseId, true)
                            .then(function (data) {
                                deferred.resolve(data);
                            }).catch(function (response) {
                                deferred.reject(response);
                                NotificationSrv.error('CaseMainCtrl', response.data, response.status);
                            });

                        return deferred.promise;
                    }
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.case.details', {
                url: '/details',
                templateUrl: 'views/partials/case/case.details.html',
                controller: 'CaseDetailsCtrl',
                data: {
                    tab: 'details'
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.case.tasks', {
                url: '/tasks',
                templateUrl: 'views/partials/case/case.tasks.html',
                controller: 'CaseTasksCtrl',
                data: {
                    tab: 'tasks'
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.case.links', {
                url: '/links',
                templateUrl: 'views/partials/case/case.links.html',
                controller: 'CaseLinksCtrl',
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.case.sharing', {
                url: '/sharing',
                templateUrl: 'views/partials/case/case.sharing.html',
                controller: 'CaseSharingCtrl',
                controllerAs: '$vm',
                resolve: {
                    organisations: function (AuthenticationSrv, OrganisationSrv) {
                        return AuthenticationSrv.current()
                            .then(function (user) {
                                return OrganisationSrv.links(user.organisation);
                            })
                            .then(function (response) {
                                return _.map(response, function (item) {
                                    return _.pick(item, 'name', 'description');
                                });
                            });
                    },
                    profiles: function (ProfileSrv) {
                        return ProfileSrv.list()
                            .then(function (response) {

                                return _.map(_.filter(response.data, function (item) {
                                    return !item.isAdmin;
                                }), 'name');
                            });
                    },
                    shares: function (CaseSrv, $stateParams) {
                        return CaseSrv.getShares($stateParams.caseId)
                            .then(function (response) {
                                return response.data;
                            });
                    }
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.case.alerts', {
                url: '/alerts',
                templateUrl: 'views/partials/case/case.alerts.html',
                controller: 'CaseAlertsCtrl',
                resolve: {
                    alerts: function ($stateParams, CaseSrv) {
                        return CaseSrv.alerts($stateParams.caseId);
                    }
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.case.tasks-item', {
                url: '/tasks/{itemId}',
                templateUrl: 'views/partials/case/case.tasks.item.html',
                controller: 'CaseTasksItemCtrl',
                resolve: {
                    task: function ($q, $stateParams, CaseTaskSrv, NotificationSrv) {
                        var deferred = $q.defer();

                        CaseTaskSrv.getById($stateParams.itemId)
                            .then(function (data) {
                                deferred.resolve(data);
                            })
                            .catch(function (response) {
                                deferred.reject(response);
                                NotificationSrv.error('taskDetails', response.data, response.status);
                            });

                        return deferred.promise;
                    }
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.case.observables', {
                url: '/observables',
                templateUrl: 'views/partials/case/case.observables.html',
                controller: 'CaseObservablesCtrl',
                data: {
                    tab: 'observables'
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.case.observables-item', {
                url: '/observables/{itemId}',
                templateUrl: 'views/partials/case/case.observables.item.html',
                controller: 'CaseObservablesItemCtrl',
                resolve: {
                    appConfig: function (VersionSrv) {
                        return VersionSrv.get();
                    },
                    artifact: function ($q, $stateParams, CaseArtifactSrv, NotificationSrv) {
                        var deferred = $q.defer();

                        CaseArtifactSrv.api().get({
                            'artifactId': $stateParams.itemId
                        }).$promise.then(function (data) {
                            deferred.resolve(data);
                        }).catch(function (response) {
                            deferred.reject(response);
                            NotificationSrv.error('Observable Details', response.data, response.status);
                        });

                        return deferred.promise;
                    }
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.case.procedures', {
                url: '/procedures',
                templateUrl: 'views/partials/case/case.procedures.html',
                controller: 'CaseProceduresCtrl',
                controllerAs: '$vm',
                data: {
                    tab: 'procedures'
                },
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.alert-list', {
                url: 'alert/list',
                templateUrl: 'views/partials/alert/list.html',
                controller: 'AlertListCtrl',
                controllerAs: '$vm',
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.dashboards', {
                url: 'dashboards',
                templateUrl: 'views/partials/dashboard/list.html',
                controller: 'DashboardsCtrl',
                controllerAs: '$vm',
                guard: {
                    isSuperAdmin: false
                }
            })
            .state('app.dashboards-view', {
                url: 'dashboards/{id}',
                templateUrl: 'views/partials/dashboard/view.html',
                controller: 'DashboardViewCtrl',
                controllerAs: '$vm',
                resolve: {
                    dashboard: function (NotificationSrv, DashboardSrv, $stateParams, $q) {
                        var defer = $q.defer();

                        DashboardSrv.get($stateParams.id)
                            .then(function (response) {
                                defer.resolve(response.data);
                            }, function (err) {
                                NotificationSrv.error('DashboardViewCtrl', err.data, err.status);
                                defer.reject(err);
                            });

                        return defer.promise;
                    },
                    metadata: function ($q, DashboardSrv, NotificationSrv) {
                        var defer = $q.defer();

                        DashboardSrv.getMetadata()
                            .then(function (response) {
                                defer.resolve(response);
                            }, function (err) {
                                NotificationSrv.error('DashboardViewCtrl', err.data, err.status);
                                defer.reject(err);
                            });

                        return defer.promise;
                    }
                },
                guard: {
                    isSuperAdmin: false
                }
            });
    })
    .config(function ($httpProvider) {
        'use strict';

        $httpProvider.defaults.xsrfCookieName = 'THEHIVE-XSRF-TOKEN';
        $httpProvider.defaults.xsrfHeaderName = 'X-THEHIVE-XSRF-TOKEN';
        $httpProvider.interceptors.push(function ($rootScope, $q) {
            var isApiCall = function (url) {
                return url && url.startsWith('./api') && !url.startsWith('./api/stream');
            };

            return {
                request: function (config) {
                    if (isApiCall(config.url)) {
                        $rootScope.async += 1;
                    }
                    return config;
                },
                response: function (response) {
                    if (isApiCall(response.config.url)) {
                        $rootScope.async -= 1;
                    }
                    return response;
                },
                responseError: function (rejection) {
                    if (isApiCall(rejection.config.url)) {
                        $rootScope.async -= 1;
                    }
                    return $q.reject(rejection);
                }
            };
        });
    })
    .config(function (localStorageServiceProvider) {
        'use strict';

        localStorageServiceProvider
            .setPrefix('th4')
            .setStorageType('localStorage')
            .setNotify(false, false);
    })
    .config(function (NotificationProvider) {
        'use strict';

        NotificationProvider.setOptions({
            delay: 10000,
            startTop: 20,
            startRight: 10,
            verticalSpacing: 20,
            horizontalSpacing: 20,
            positionX: 'left',
            positionY: 'bottom',
            maxCount: 5
        });
    })
    .config(function ($provide, markedProvider, hljsServiceProvider) {
        'use strict';

        markedProvider.setOptions({
            gfm: true,
            tables: true,
            sanitize: true,
            highlight: function (code, lang) {
                if (lang) {
                    return hljs.highlight(lang, code, true).value;
                } else {
                    return hljs.highlightAuto(code).value;
                }
            }
        });

        // highlight config
        hljsServiceProvider.setOptions({
            tabReplace: '    '
        });

        // Decorate the marked service to allow generating links with _target="blank"
        $provide.decorator('marked', [
            '$delegate',
            function markedDecorator($delegate) {
                // Credits: https://github.com/markedjs/marked/issues/655#issuecomment-383226346
                var defaults = markedProvider.defaults;

                var renderer = defaults.renderer;
                var linkRenderer = _.wrap(renderer.link, function (originalLink, href, title, text) {
                    var html = originalLink.call(renderer, href, title, text);
                    return html.replace(/^<a /, '<a target="_blank" rel="nofollow" ');
                });

                // Customize the link renderer
                defaults.renderer.link = linkRenderer;

                // Patch the marked instance
                $delegate.setOptions(defaults);

                return $delegate;
            }
        ]);
    })
    .run(function ($rootScope, $state, $q, AuthenticationSrv) {
        'use strict';
        $rootScope.async = 0;

        // Handle route guards
        $rootScope.$on('$stateChangeSuccess', function (event, toState/*, toParams*/) {

            if (!toState.guard) {
                return;
            }

            // Try Permissions
            if (toState.guard.permissions !== undefined) {
                var permissions = toState.guard.permissions;

                if (permissions && !AuthenticationSrv.hasPermission(permissions)) {
                    event.preventDefault();
                    $state.go('app.index');
                }
            }

            // Try isSupperAdmin
            if (toState.guard.isSuperAdmin !== undefined && AuthenticationSrv.isSuperAdmin() !== toState.guard.isSuperAdmin) {
                event.preventDefault();
                $state.go('app.index');
            }
        });

        // Update page title based on the route
        $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams) {
            if (_.isFunction(toState.title)) {
                $rootScope.title = toState.title(toParams);
            } else {
                $rootScope.title = toState.title;
            }
        });

        // Handle 401 errors when navigating to a route
        $rootScope.$on('$stateChangeError', function (event, toState, toParams, fromState, fromParams, error) {
            if (error && error.status && error.status === 401) {
                event.preventDefault();
                $state.go('login');
            }
        });
    })
    .constant('UrlParser', url);

```

`frontend/app/scripts/components/alert/AlertObservableListCmp.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveComponents')
        .component('alertObservableList', {
            controller: function ($scope, FilteringSrv, QuerySrv, PaginatedQuerySrv) {
                var self = this;

                self.observablesCount = null;

                self.$onInit = function () {
                    this.filtering = new FilteringSrv('observable', 'alert.dialog.observables', {
                        version: 'v1',
                        defaults: {
                            showFilters: false,
                            showStats: false,
                            pageSize: 15,
                            sort: ['-startDate']
                        },
                        defaultFilter: []
                    });

                    self.filtering.initContext(this.alertId)
                        .then(function () {
                            self.load();

                            $scope.$watch('$cmp.list.pageSize', function (newValue) {
                                self.filtering.setPageSize(newValue);
                            });
                        });

                    QuerySrv.query(
                        'v1',
                        [{ '_name': 'countAlertObservable', 'alertId': self.alertId }],
                        {
                            params: {
                                name: 'alert-all-observables.count'
                            }
                        })
                        .then(function (response) {
                            self.observablesCount = response.data;
                            self.onListLoad({ count: self.observablesCount });
                        });
                };

                this.load = function () {
                    this.list = new PaginatedQuerySrv({
                        name: 'alert-observables',
                        skipStream: true,
                        version: 'v1',
                        sort: self.filtering.context.sort,
                        loadAll: false,
                        limitedCount: true,
                        pageSize: self.filtering.context.pageSize,
                        filter: this.filtering.buildQuery(),
                        operations: [
                            { '_name': 'getAlert', 'idOrName': this.alertId },
                            { '_name': 'observables' }
                        ],
                        extraData: ['seen'],
                        onUpdate: function () { }
                    });
                };

                this.search = function () {
                    self.load();
                    self.filtering.storeContext();
                };

                this.addFilterValue = function (field, value) {
                    this.filtering.addFilterValue(field, value);
                    this.search();
                };

                this.filterBy = function (field, value) {
                    this.filtering.clearFilters()
                        .then(function () {
                            self.addFilterValue(field, value);
                        });
                };

                // this.filter = function () {
                //     self.filtering.filter().then(this.applyFilters);
                // };
                //

                // Filtering methods
                this.toggleFilters = function () {
                    this.filtering.toggleFilters();
                };

                this.clearFilters = function () {
                    this.filtering.clearFilters()
                        .then(self.search);
                };

                this.removeFilter = function (index) {
                    self.filtering.removeFilter(index)
                        .then(self.search);
                };

            },
            controllerAs: '$cmp',
            templateUrl: 'views/components/alert/observable-list.component.html',
            bindings: {
                alertId: '<',
                onListLoad: '&'
            }
        });
})();

```

`frontend/app/scripts/components/alert/AlertSimilarCaseListCmp.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveComponents')
        .component('alertSimilarCaseList', {
            controller: function ($scope, AlertingSrv, FilteringSrv, PaginatedQuerySrv, CaseResolutionStatus, UiSettingsSrv) {
                var self = this;

                self.CaseResolutionStatus = CaseResolutionStatus;

                self.similarityFilters = {
                    fTitle: undefined
                };

                self.matchFilters = {
                    fMatches: []
                };

                self.rateFilters = {
                    fObservables: undefined,
                    fIocs: undefined
                };

                self.sortField = '-fObservables';
                self.matches = [];
                self.filteredCases = [];

                self.pagination = {
                    pageSize: 10,
                    currentPage: 1
                };

                self.state = {
                    disallowMerge: UiSettingsSrv.disallowMergeAlertInResolvedSimilarCases() === true,
                    defaultAlertSimilarCaseFilter: UiSettingsSrv.defaultAlertSimilarCaseFilter()
                };

                self.$onInit = function () {
                    this.filtering = new FilteringSrv('case', 'alert.dialog.similar-cases', {
                        version: 'v1',
                        defaults: {
                            showFilters: false,
                            showStats: false,
                            pageSize: 2,
                            sort: ['-startDate']
                        },
                        defaultFilter: []
                    });

                    //self.filtering.initContext('alert.dialog.similar-cases')
                    self.filtering.initContext()
                        .then(function () {
                            var defaultFilter = AlertingSrv.getSimilarityFilter(self.state.defaultAlertSimilarCaseFilter);

                            if (_.isEmpty(self.filtering.context.filters) && defaultFilter && defaultFilter.length > 0) {
                                _.each(defaultFilter, function (item) {
                                    self.filtering.addFilter(item);
                                });
                            }

                            self.load();

                            $scope.$watch('$cmp.list.pageSize', function (newValue) {
                                self.filtering.setPageSize(newValue);
                            });

                            $scope.$watch('$cmp.list.total', function (total) {
                                self.onListLoad({ count: total });
                            });
                        });
                };

                this.load = function () {
                    this.list = new PaginatedQuerySrv({
                        name: 'alert-similar-cases',
                        skipStream: true,
                        version: 'v1',
                        loadAll: true,
                        //pageSize: self.filtering.context.pageSize,
                        operations: [
                            { '_name': 'getAlert', 'idOrName': this.alertId },
                            { '_name': 'similarCases', 'caseFilter': this.filtering.buildQuery() }
                        ],
                        onUpdate: function (data) {
                            _.each(data, function (item) {
                                item.fTitle = item.case.title;
                                item.fMatches = _.keys(item.observableTypes);
                                item.fObservables = Math.floor((item.similarObservableCount / item.observableCount) * 100);
                                item.fIocs = Math.floor((item.similarIocCount / item.iocCount) * 100) || 0;

                                item.sCreatedAt = item.case._createdAt;
                            });

                            self.matches = _.uniq(_.flatten(_.map(data, function (item) {
                                return _.keys(item.observableTypes);
                            }))).sort();
                        }
                    });
                };

                self.merge = function (caseId) {
                    this.onMergeIntoCase({
                        caseId: caseId
                    });
                };

                // Frontend filter methods
                this.clearLocalFilters = function () {
                    self.similarityFilters = {
                        fTitle: undefined
                    };

                    self.matchFilters = {
                        fMatches: []
                    };

                    self.rateFilters = {
                        fObservables: undefined,
                        fIocs: undefined
                    };
                };

                this.greaterThan = function (prop) {
                    return function (item) {
                        return !self.rateFilters[prop] || item[prop] >= self.rateFilters[prop];
                    };
                };

                this.matchFilter = function () {
                    return function (item) {
                        return !self.matchFilters.fMatches || self.matchFilters.fMatches.length === 0 ||
                            _.intersection(self.matchFilters.fMatches, item.fMatches).length > 0;
                    };
                };

                // Filtering methods
                this.toggleFilters = function () {
                    this.filtering.toggleFilters();
                };

                this.search = function () {
                    self.load();
                    self.filtering.storeContext();
                };

                this.addFilterValue = function (field, value) {
                    self.filtering.addFilterValue(field, value);
                    self.search();
                };

                /// Clear all filters
                this.clearFilters = function () {
                    self.filtering.clearFilters()
                        .then(self.search);
                };

                // Remove a filter
                this.removeFilter = function (index) {
                    self.filtering.removeFilter(index)
                        .then(self.search);
                };

                this.filterBy = function (field, value) {
                    self.filtering.clearFilters()
                        .then(function () {
                            self.addFilterValue(field, value);
                        });
                };

                this.applyDefaultFilter = function () {
                    self.filtering.clearFilters()
                        .then(function () {
                            var defaultFilter = AlertingSrv.getSimilarityFilter(self.state.defaultAlertSimilarCaseFilter);

                            if (defaultFilter && defaultFilter.length > 0) {
                                _.each(defaultFilter, function (item) {
                                    self.filtering.addFilter(item);
                                });

                                self.search();
                            }
                        });
                };

                this.filterSimilarities = function (data) {
                    return data;
                };

                this.sortByField = function (field) {
                    var sort = null;

                    if (this.sortField.substr(1) !== field) {
                        sort = '+' + field;
                    } else {
                        sort = (this.sortField === '+' + field) ? '-' + field : '+' + field;
                    }

                    this.sortField = sort;
                };


            },
            controllerAs: '$cmp',
            templateUrl: 'views/components/alert/similar-case-list.component.html',
            bindings: {
                alertId: '<',
                readonly: '<',
                onListLoad: '&',
                onMergeIntoCase: '&'
            }
        });
})();

```

`frontend/app/scripts/components/app-container.component.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .directive('appContainer', function() {
            return {
                restrict: 'E',
                templateUrl: 'views/components/app-container.component.html'
            };
        });
})();

```

`frontend/app/scripts/components/charts/donut-chart.component.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('donutChart', {
            controller: function($scope) {
                var self = this;

                this.$onInit = function() {
                    $scope.$watch('$cmp.data', function (data) {
                        self.updateChart(data);
                    });
                };

                this.updateChart = function(rawData) {
                    this.error = false;

                    var data = _.map(rawData, function(item) {
                        return [item.key, item.count];
                    });

                    this.chart = {
                        data: {
                            columns: data,
                            names: self.labels || undefined,
                            type: 'donut',
                            onclick: function(d) {
                                if(self.onItemClicked) {
                                    self.onItemClicked({
                                        value: d.id
                                    });
                                }
                            }
                        },
                        donut: {
                            label: {
                                show: false
                            }
                        },
                        legend: {
                            position: 'right'
                        }
                    };
                };
            },
            controllerAs: '$cmp',
            template: '<c3 chart="$cmp.chart" error="$cmp.error" height="150" hide-actions="true"></c3>',
            bindings: {
                data: '<',
                labels: '<',
                title: '@',
                field: '@',
                onItemClicked: '&'
            }
        });
})();

```

`frontend/app/scripts/components/common/custom-field-input.component.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('customFieldInput', {
            controller: function() {
                this.updateField = function(newValue) {
                    this.onUpdate({
                        fieldName: ['customFields', this.field.reference, this.field.type].join('.'),
                        value: newValue
                    });
                };
                this.removeCustomField = function(id) {
                    this.onRemove({
                        fieldId: id
                    })
                }
            },
            controllerAs: '$ctrl',
            templateUrl: 'views/components/common/custom-field-input.component.html',
            bindings: {
                index: '<',
                field: '<',
                value: '=',
                id: '<',
                onUpdate: '&',
                onRemove: '&',
                editable: '<',
                removable: '<'
            }
        });
})();

```

`frontend/app/scripts/components/common/custom-field-labels.component.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('customFieldLabels', {
            controller: function(CustomFieldsSrv) {
                var self = this;

                this.fieldsCache = {};
                this.definedValues = 0;
                this.fieldClicked = function(fieldName, newValue) {
                    this.onFieldClick({
                        name: fieldName,
                        value: newValue
                    });
                };

                this.$onInit = function() {
                    CustomFieldsSrv.all().then(function(fields) {
                        self.fieldsCache = fields;
                    });

                    self.definedValues = (_.filter(self.customFields, function(item) {
                        return item.value !== null && item.value !== undefined;
                    }) || []).length;

                };
            },
            controllerAs: '$cmp',
            templateUrl: 'views/components/common/custom-field-labels.component.html',
            bindings: {
                customFields: '<',
                onFieldClick: '&'
            }
        });
})();

```

`frontend/app/scripts/components/common/datalist-header.component.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveComponents')
        .component('datalistHeader', {
            controller: function () { },
            controllerAs: '$ctrl',
            templateUrl: 'views/components/common/datalist-header.component.html',
            bindings: {
                title: '@',
                list: '<',
                total: '<'
            }
        });
})();

```

`frontend/app/scripts/components/common/observable-flags.component.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('observableFlags', {
            controller: function() {
                this.filterBy = function(fieldName, newValue) {
                    this.onFilter({
                        fieldName: fieldName,
                        value: newValue
                    });
                };
            },
            controllerAs: '$ctrl',
            templateUrl: 'views/components/common/observable-flags.component.html',
            bindings: {
                observable: '<',
                inline: '<',
                hideSimilarity: '<',
                hideSeen: '<',
                hideTlp: '<',
                onFilter: '&'
            }
        });
})();

```

`frontend/app/scripts/components/common/tag.component.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('tag', {
            controller: function() {
                this.$onInit = function() {
                    if(!this.value) {
                        return;
                    }                    
                    if(_.isString(this.value)) {
                        this.tag = this.value;
                        this.bgColor = '#3c8dbc';
                    } else {
                        this.tag = _.without([
                            this.value.namespace,
                            ':',
                            this.value.predicate,
                            this.value.value ? ("=\"" + this.value.value + "\"") : null
                        ], null).join('');
                        this.bgColor = this.value.colour || '#3c8dbc';
                    }
                };
            },
            controllerAs: '$ctrl',
            replace: true,
            templateUrl: 'views/components/common/tag.component.html',
            bindings: {
                value: '<'
            }
        });
})();

```

`frontend/app/scripts/components/common/task-flags.component.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('taskFlags', {
            controller: function() {
                this.filterBy = function(fieldName, newValue) {
                    this.onFilter({
                        fieldName: fieldName,
                        value: newValue
                    });
                };
            },
            controllerAs: '$ctrl',
            templateUrl: 'views/components/common/task-flags.component.html',
            bindings: {
                task: '<',
                inline: '<',
                onFilter: '&'
            }
        });
})();

```

`frontend/app/scripts/components/control-sidebar.component.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .directive('controlSidebar', function() {
            return {
                restrict: 'E',
                templateUrl: 'views/components/control-sidebar.component.html'
            };
        });
})();

```

`frontend/app/scripts/components/header.component.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .directive('header', function() {
            return {
                restrict: 'E',
                templateUrl: 'views/components/header.component.html'
            };
        });
})();

```

`frontend/app/scripts/components/list/stats-item.component.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveComponents')
        .component('statsItem', {
            controller: function() {
                var self = this;

                this.onClick = function(value) {
                    self.onItemClicked({
                        field: self.field,
                        value: self.values ? self.values[value] : value
                    });
                };
            },
            controllerAs: '$cmp',
            templateUrl: 'views/components/list/stats-item.component.html',
            replace: true,
            bindings: {
                field: '@',
                title: '@',
                data: '<',
                mode: '<',
                labels: '<',
                values: '<',
                onItemClicked: '&'
            }
        });
})();

```

`frontend/app/scripts/components/main-sidebar.component.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .directive('mainSidebar', function() {
            return {
                restrict: 'E',
                templateUrl: 'views/components/main-sidebar.component.html'
            };
        });
})();

```

`frontend/app/scripts/components/organisation/OrgCaseTemplateListCmp.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveComponents')
        .component('orgCaseTemplateList', {
            controller: function ($uibModal, $scope, $q, CaseTemplateSrv, PaginatedQuerySrv, FilteringSrv, UserSrv, NotificationSrv, ModalUtilsSrv) {
                var self = this;

                self.task = '';
                self.tags = [];
                self.templateCustomFields = [];
                self.templateIndex = -1;
                self.getUserInfo = UserSrv.getCache;


                this.$onInit = function () {
                    self.filtering = new FilteringSrv('caseTemplate', 'caseTemplate.list', {
                        version: 'v1',
                        defaults: {
                            showFilters: true,
                            showStats: false,
                            pageSize: 15,
                            sort: ['+displayName']
                        },
                        defaultFilter: []
                    });

                    self.filtering.initContext(self.organisation.name)
                        .then(function () {
                            self.load();

                            $scope.$watch('$vm.list.pageSize', function (newValue) {
                                self.filtering.setPageSize(newValue);
                            });
                        });
                };

                this.load = function () {

                    self.list = new PaginatedQuerySrv({
                        name: 'organisation-case-templates',
                        version: 'v1',
                        skipStream: true,
                        sort: self.filtering.context.sort,
                        loadAll: false,
                        pageSize: self.filtering.context.pageSize,
                        filter: this.filtering.buildQuery(),
                        operations: [{
                            '_name': 'getOrganisation',
                            'idOrName': self.organisation.name
                        },
                        {
                            '_name': 'caseTemplates'
                        }
                        ],
                        onFailure: function (err) {
                            if (err && err.status === 400) {
                                self.filtering.resetContext();
                                self.load();
                            }
                        }
                    });
                };

                // Filtering
                this.toggleFilters = function () {
                    this.filtering.toggleFilters();
                };

                this.filter = function () {
                    self.filtering.filter().then(this.applyFilters);
                };

                this.clearFilters = function () {
                    this.filtering.clearFilters()
                        .then(self.search);
                };

                this.removeFilter = function (index) {
                    self.filtering.removeFilter(index)
                        .then(self.search);
                };

                this.search = function () {
                    self.load();
                    self.filtering.storeContext();
                };
                this.addFilterValue = function (field, value) {
                    this.filtering.addFilterValue(field, value);
                    this.search();
                };

                this.filterBy = function (field, value) {
                    self.filtering.clearFilters()
                        .then(function () {
                            self.addFilterValue(field, value);
                        });
                };

                this.sortBy = function (sort) {
                    self.list.sort = sort;
                    self.list.update();
                    self.filtering.setSort(sort);
                };

                this.sortByField = function (field) {
                    var context = this.filtering.context;
                    var currentSort = Array.isArray(context.sort) ? context.sort[0] : context.sort;
                    var sort = null;

                    if (currentSort.substr(1) !== field) {
                        sort = ['+' + field];
                    } else {
                        sort = [(currentSort === '+' + field) ? '-' + field : '+' + field];
                    }

                    self.list.sort = sort;
                    self.list.update();
                    self.filtering.setSort(sort);
                };

                this.newTemplate = function () {
                    self.showTemplate({
                        name: '',
                        titlePrefix: '',
                        severity: 2,
                        tlp: 2,
                        pap: 2,
                        tags: [],
                        tasks: [],
                        customFields: {},
                        description: ''
                    });
                };

                this.showTemplate = function (template) {

                    var promise = template._id ? CaseTemplateSrv.get(template._id) : $q.resolve(template);

                    promise
                        .then(function (response) {
                            var modalInstance = $uibModal.open({
                                animation: true,
                                keyboard: false,
                                backdrop: 'static',
                                templateUrl: 'views/components/org/case-template/details.modal.html',
                                controller: 'OrgCaseTemplateModalCtrl',
                                controllerAs: '$vm',
                                size: 'max',
                                resolve: {
                                    template: function () {
                                        var tmpl = angular.copy(response);

                                        if (tmpl.tasks && tmpl.tasks.length > 0) {
                                            tmpl.tasks = _.sortBy(tmpl.tasks, 'order');
                                        }

                                        return tmpl;
                                    },
                                    fields: function () {
                                        return self.fields;
                                    }
                                }
                            });

                            return modalInstance.result;
                        })
                        .then(function () {
                            self.load();
                        })
                        .catch(function (err) {
                            if (err && !_.isString(err)) {
                                NotificationSrv.error('Case Template Admin', err.data, err.status);
                            }
                        })
                }

                self.createTemplate = function (template) {
                    return CaseTemplateSrv.create(template).then(
                        function (/*response*/) {
                            self.load();

                            $scope.$emit('templates:refresh');

                            NotificationSrv.log('The template [' + template.name + '] has been successfully created', 'success');
                        },
                        function (response) {
                            NotificationSrv.error('TemplateCtrl', response.data, response.status);
                        }
                    );
                };

                self.importTemplate = function () {
                    var modalInstance = $uibModal.open({
                        animation: true,
                        templateUrl: 'views/components/org/case-template/import.html',
                        controller: 'AdminCaseTemplateImportCtrl',
                        controllerAs: 'vm',
                        size: 'lg'
                    });

                    modalInstance.result
                        .then(function (template) {
                            return self.createTemplate(template);
                        })
                        .catch(function (err) {
                            if (err && err.status) {
                                NotificationSrv.error('TemplateCtrl', err.data, err.status);
                            }
                        });
                };

                self.deleteTemplate = function (template) {
                    ModalUtilsSrv.confirm('Remove case template', 'Are you sure you want to delete this case template?', {
                        okText: 'Yes, remove it',
                        flavor: 'danger'
                    })
                        .then(function () {
                            return CaseTemplateSrv.delete(template._id);
                        })
                        .then(function () {
                            self.load();

                            $scope.$emit('templates:refresh');
                        });
                };

                self.exportTemplate = function (template) {
                    CaseTemplateSrv.get(template._id)
                        .then(function (response) {
                            var fileName = 'Case-Template__' + response.name.replace(/\s/gi, '_') + '.json';

                            // Create a blob of the data
                            var fileToSave = new Blob([angular.toJson(_.omit(response, 'id'))], {
                                type: 'application/json',
                                name: fileName
                            });

                            // Save the file
                            saveAs(fileToSave, fileName);
                        })

                };
            },
            controllerAs: '$vm',
            templateUrl: 'views/components/org/case-template/case-templates.html',
            bindings: {
                organisation: '<',
                templates: '=',
                fields: '<',
                onReload: '&',
                onEdit: '&'
            }
        });
})();

```

`frontend/app/scripts/components/organisation/OrgCaseTemplateModalCtrl.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveControllers')
        .controller('OrgCaseTemplateModalCtrl', function ($scope, $uibModalInstance, $uibModal, CaseTemplateSrv, AuthenticationSrv, TaxonomyCacheSrv, TagSrv, UserSrv, NotificationSrv, UtilsSrv, template, fields) {
            var self = this;

            this.template = template;
            this.fields = fields;
            self.task = '';
            self.tags = [];
            self.templateCustomFields = [];
            self.templateIndex = -1;
            self.currentUser = AuthenticationSrv.currentUser;

            /**
             * Convert the template custom fields definition to a list of ordered field names
             * to be used for drag&drop sorting feature
             */
            var getTemplateCustomFields = function (customFields) {
                var result = [];

                result = _.sortBy(
                    _.map(customFields, function (definition, name) {
                        var fieldDef = self.fields[name];
                        var type = fieldDef ? fieldDef.type : null;

                        // The field doesn't exist, trying to find the field type from it's template value
                        if (type === null) {
                            var keys = _.without(_.keys(definition), 'order');
                            if (keys.length > 0) {
                                type = keys[0];
                            }
                        }

                        return {
                            name: name,
                            order: definition.order,
                            value: fieldDef ? definition[type] : null,
                            type: type
                        };
                    }),
                    'order'
                );

                return result;
            };

            this.$onInit = function () {
                if (self.template._id) {
                    self.action = 'Edit';
                } else {
                    self.action = 'Add';
                }

                self.tags = UtilsSrv.objectify(self.template.tags, 'text');
                self.templateCustomFields = getTemplateCustomFields(self.template.customFields);
            }

            this.cancel = function () {
                $uibModalInstance.dismiss();
            };

            self.dateOptions = {
                closeOnDateSelection: true,
                formatYear: 'yyyy',
                startingDay: 1
            };

            self.sortableOptions = {
                handle: '.drag-handle',
                stop: function ( /*e, ui*/) {
                    self.reorderTasks();
                },
                axis: 'y'
            };

            self.sortableFields = {
                handle: '.drag-handle',
                axis: 'y'
            };

            self.keys = function (obj) {
                if (!obj) {
                    return [];
                }
                return _.keys(obj);
            };

            self.fromTagLibrary = function () {
                TaxonomyCacheSrv.openTagLibrary()
                    .then(function (tags) {
                        self.tags = self.tags.concat(tags);
                    })
            };

            self.reorderTasks = function () {
                _.each(self.template.tasks, function (task, index) {
                    task.order = index;
                });
            };

            self.removeTask = function (task) {
                self.template.tasks = _.without(self.template.tasks, task);
                self.reorderTasks();
            };

            self.addTask = function () {
                var order = self.template.tasks ? self.template.tasks.length : 0;

                self.openTaskDialog({
                    order: order
                }, 'Add');
            };

            self.editTask = function (task) {
                self.openTaskDialog(task, 'Update');
            };

            self.openTaskDialog = function (task, action) {
                var modal = $uibModal.open({
                    scope: $scope,
                    templateUrl: 'views/components/org/case-template/case-templates.task.html',
                    controller: 'AdminCaseTemplateTasksCtrl',
                    size: 'lg',
                    resolve: {
                        action: function () {
                            return action;
                        },
                        task: function () {
                            return _.extend({}, task);
                        },
                        users: function () {
                            return UserSrv.list(
                                self.currentUser.organisation,
                                {
                                    filter: {
                                        _is: {
                                            _field: 'locked',
                                            _value: false
                                        }
                                    },
                                    sort: ['+name']
                                }
                            );
                        },
                        groups: function () {
                            var existingGroups = _.uniq(_.pluck(self.template.tasks, 'group').sort());

                            return existingGroups.length === 0 ? ['default'] : existingGroups;
                        }
                    }
                });

                modal.result.then(function (data) {
                    if (action === 'Add') {
                        if (self.template.tasks) {
                            self.template.tasks.push(data);
                        } else {
                            self.template.tasks = [data];
                        }
                    } else {
                        self.template.tasks[data.order] = data;
                    }
                });
            };

            self.addCustomFieldRow = function () {
                self.templateCustomFields.push({
                    name: null,
                    order: self.templateCustomFields.length + 1,
                    value: null
                });
            };

            self.removeCustomField = function (field) {
                self.templateCustomFields = _.without(self.templateCustomFields, field);
            };

            self.updateCustomField = function (field, value) {
                field.value = value;
            };

            self.saveTemplate = function () {
                // Set tags
                self.template.tags = _.pluck(self.tags, 'text');

                // Set custom fields
                self.template.customFields = {};
                _.each(self.templateCustomFields, function (cf, index) {
                    var fieldDef = self.fields[cf.name];
                    var value = null;
                    if (fieldDef) {
                        value = fieldDef.type === 'date' && cf.value ? moment(cf.value).valueOf() : cf.value;
                    }

                    self.template.customFields[cf.name] = {};
                    self.template.customFields[cf.name][fieldDef ? fieldDef.type : cf.type] = value;
                    self.template.customFields[cf.name].order = index + 1;
                });

                if (_.isEmpty(self.template.id)) {
                    self.createTemplate(self.template);
                } else {
                    self.updateTemplate(self.template);
                }
            };

            self.createTemplate = function (template) {
                return CaseTemplateSrv.create(template).then(
                    function (/*response*/) {
                        $scope.$emit('templates:refresh');

                        NotificationSrv.log('The template [' + template.name + '] has been successfully created', 'success');
                        $uibModalInstance.close();
                    },
                    function (response) {
                        NotificationSrv.error('TemplateCtrl', response.data, response.status);
                    }
                );
            };

            self.updateTemplate = function (template) {
                return CaseTemplateSrv.update(template.id, _.omit(template, 'id', 'user')).then(
                    function ( /*response*/) {
                        $scope.$emit('templates:refresh');

                        NotificationSrv.log('The template [' + template.name + '] has been successfully updated', 'success');
                        $uibModalInstance.close();
                    },
                    function (response) {
                        NotificationSrv.error('TemplateCtrl', response.data, response.status);
                    }
                );
            };

            self.getTags = function (query) {
                return TagSrv.autoComplete(query);
            };
        });
})();

```

`frontend/app/scripts/components/organisation/OrgConfigListCmp.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('orgConfigList', {
            controller: function($scope, $q, $interval, NotificationSrv, AlertingSrv, UiSettingsSrv) {
                var self = this;

                self.alertSimilarityFilters = [];

                self.isDirtySetting = function(key, newValue) {
                    return newValue !== self.currentSettings[key];
                };

                self.save = function(/*form*/) {
                    var promises = [];

                    self.settingsKeys.forEach(function(key) {
                        if(self.isDirtySetting(key, self.configs[key])) {
                            promises.push(UiSettingsSrv.save(key, self.configs[key]));
                        }
                    });

                    if(promises.length === 0) {
                        return;
                    }

                    $q.all(promises)
                        .then(function(/*responses*/) {
                            self.loadSettings();
                            NotificationSrv.log('UI Settings updated successfully', 'success');
                        })
                        .catch(function(/*errors*/) {
                            NotificationSrv.error('An error occurred during UI Settings update');
                        });
                };

                self.loadSettings = function(configurations) {

                    var notifyRoot = false;
                    var promise;

                    if(configurations) {
                        promise = $q.resolve(configurations);
                    } else {
                        promise = UiSettingsSrv.all(true);
                        notifyRoot = true;
                    }

                    promise.then(function(configs) {
                        self.settingsKeys = UiSettingsSrv.keys;
                        self.currentSettings = configs;

                        self.configs = {};
                        self.settingsKeys.forEach(function(key) {
                            self.configs[key] = configs[key];
                        });

                        if(notifyRoot) {
                            $scope.$emit('ui-settings:refresh', configs);
                        }
                    });
                };

                self.$onInit = function() {
                    self.loadSettings(this.uiConfig);

                    self.alertSimilarityFilters = AlertingSrv.getSimilarityFilters();


                    self.timer = $interval(function() {
                        self.date = new moment();
                      }, 1000);

                };

                self.$onDestroy = function() {
                    if(self.timer) {
                        $interval.cancel(self.timer);
                    }
                }
            },
            controllerAs: '$ctrl',
            templateUrl: 'views/components/org/config.list.html',
            bindings: {
                uiConfig: '<',
                onReload: '&'
            }
        });
})();

```

`frontend/app/scripts/components/organisation/OrgCustomTagsListCmp.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveComponents')
        .component('orgCustomTagsList', {
            controller: function ($scope, PaginatedQuerySrv, QuerySrv, FilteringSrv, TaxonomyCacheSrv, TagSrv, UserSrv, ModalUtilsSrv, NotificationSrv) {
                var self = this;

                self.tags = [];
                self.getUserInfo = UserSrv.getCache;

                self.freetagsCount = null;

                this.$onInit = function () {
                    self.filtering = new FilteringSrv('tag', 'custom-tags.list', {
                        version: 'v1',
                        defaults: {
                            showFilters: true,
                            showStats: false,
                            pageSize: 15,
                            sort: ['+predicate']
                        },
                        defaultFilter: []
                    });

                    self.filtering.initContext(self.organisation.name)
                        .then(function () {
                            self.load();

                            $scope.$watch('$vm.list.pageSize', function (newValue) {
                                self.filtering.setPageSize(newValue);
                            });
                        });

                    QuerySrv.query(
                        'v1',
                        [{ '_name': 'countFreetags' }],
                        {
                            params: {
                                name: 'all-custom-tags.count'
                            }
                        })
                        .then(function (response) {
                            self.freetagsCount = response.data;
                        });
                };

                this.load = function () {

                    self.list = new PaginatedQuerySrv({
                        name: 'organisation-custom-tags',
                        version: 'v1',
                        skipStream: true,
                        sort: self.filtering.context.sort,
                        loadAll: false,
                        limitedCount: true,
                        pageSize: self.filtering.context.pageSize,
                        filter: this.filtering.buildQuery(),
                        operations: [
                            {
                                '_name': 'freetags'
                            }
                        ],
                        extraData: ['usage'],
                        onFailure: function (err) {
                            if (err && err.status === 400) {
                                self.filtering.resetContext();
                                self.load();
                            }
                        }
                    });
                };

                self.deleteTag = function (tag) {
                    ModalUtilsSrv.confirm('Remove free tag', 'Are you sure you want to delete this tag?', {
                        okText: 'Yes, remove it',
                        flavor: 'danger'
                    })
                        .then(function () {
                            return TagSrv.removeTag(tag._id);
                        })
                        .then(function () {
                            NotificationSrv.success('Tag [' + tag.predicate + '] removed successfully');

                            self.load();

                            $scope.$emit('freetags:refresh');
                        });
                };

                self.updateColour = function (id, colour) {
                    TagSrv.updateTag(id, { colour: colour })
                        .then(function (/*response*/) {
                            NotificationSrv.success('Tag colour updated successfully');
                            TaxonomyCacheSrv.refreshFreeTags();
                        })
                        .catch(function (err) {
                            NotificationSrv.error('Tag list', err.data, err.status);
                        })
                }

                self.updateTag = function (id, value) {
                    TagSrv.updateTag(id, { predicate: value })
                        .then(function (/*response*/) {
                            NotificationSrv.success('Tag value updated successfully');
                            TaxonomyCacheSrv.refreshFreeTags();
                        })
                        .catch(function (err) {
                            NotificationSrv.error('Tag list', err.data, err.status);
                        })
                }

                // Filtering
                this.toggleFilters = function () {
                    this.filtering.toggleFilters();
                };

                this.filter = function () {
                    self.filtering.filter().then(this.applyFilters);
                };

                this.clearFilters = function () {
                    this.filtering.clearFilters()
                        .then(self.search);
                };

                this.removeFilter = function (index) {
                    self.filtering.removeFilter(index)
                        .then(self.search);
                };

                this.search = function () {
                    self.load();
                    self.filtering.storeContext();
                };
                this.addFilterValue = function (field, value) {
                    this.filtering.addFilterValue(field, value);
                    this.search();
                };

                this.filterBy = function (field, value) {
                    self.filtering.clearFilters()
                        .then(function () {
                            self.addFilterValue(field, value);
                        });
                };

                this.sortBy = function (sort) {
                    self.list.sort = sort;
                    self.list.update();
                    self.filtering.setSort(sort);
                };

                this.sortByField = function (field) {
                    var context = this.filtering.context;
                    var currentSort = Array.isArray(context.sort) ? context.sort[0] : context.sort;
                    var sort = null;

                    if (currentSort.substr(1) !== field) {
                        sort = ['+' + field];
                    } else {
                        sort = [(currentSort === '+' + field) ? '-' + field : '+' + field];
                    }

                    self.list.sort = sort;
                    self.list.update();
                    self.filtering.setSort(sort);
                };
            },
            controllerAs: '$vm',
            templateUrl: 'views/components/org/custom-tags/tag-list.html',
            bindings: {
                organisation: '<',
                templates: '=',
                fields: '<',
                onReload: '&',
                onEdit: '&'
            }
        });
})();

```

`frontend/app/scripts/components/organisation/OrgSwitchCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('OrgSwitchCtrl',
        function($uibModalInstance, currentUser) {
            //var self = this;

            this.currentUser = currentUser;

            this.selectOrg = function(selected) {
                $uibModalInstance.close(selected);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };        
        });
})();

```

`frontend/app/scripts/components/organisation/OrgUserListCmp.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('orgUserList', {
            controller: function($scope, $stateParams, UserSrv, NotificationSrv, ModalSrv, AuthenticationSrv, clipboard) {
                var self = this;

                self.userKeyCache = {};
                self.showPwdForm = {};
                self.currentUser = AuthenticationSrv.currentUser;

                self.$onInit = function() {
                    self.canSetPass = this.setPasswordEnabled;
                };

                self.sortByField = function(field) {
                    this.onSort({field: field});
                };

                self.addFilterValue = function(field, value) {
                    self.onFilter({
                        field: field,
                        value: value
                    });
                }

                self.reload = function() {
                    self.onReload();
                };

                self.showPassword = function(user, visible) {
                    self.showPwdForm[user._id] = visible;
                    if (visible) {
                        $scope.$broadcast('user-showPassword-' + user._id);
                    }
                };

                self.getKey = function(user) {
                    UserSrv.getKey(user._id).then(function(key) {
                        self.userKeyCache[user._id] = key;
                    });
                };

                self.resetMfa = function(user) {
                    var modalInstance = ModalSrv.confirm(
                        'Reset MFA',
                        'Are you sure you want to reset MFA settings for this user?', {
                            okText: 'Yes, reset it',
                            flavor: 'danger'
                        }
                    );

                    modalInstance.result
                        .then(function() {
                            UserSrv.resetMfa(user._id);
                        })
                        .then(function() {
                            self.onReload();
                            NotificationSrv.success(
                                'MFA configuration of user ' + user.login + ' has been successfully disabled.'
                            );
                        })
                        .catch(function(err) {
                            if (!_.isString(err)) {
                                NotificationSrv.error('OrgUserCtrl', err.data, err.status);
                            }
                        });
                };

                self.createKey = function(user) {
                    var modalInstance = ModalSrv.confirm(
                        'Create API key',
                        'Are you sure you want to create a new API key for this user?', {
                            okText: 'Yes, create it'
                        }
                    );

                    modalInstance.result
                        .then(function() {
                            return UserSrv.setKey(user._id);
                        })
                        .then(function( /*response*/ ) {
                            delete self.userKeyCache[user._id];
                            self.onReload();
                            NotificationSrv.success(
                                'API key of user ' + user.login + ' has been successfully created.'
                            );
                        })
                        .catch(function(err) {
                            if (!_.isString(err)) {
                                NotificationSrv.error('OrgUserCtrl', err.data, err.status);
                            }
                        });
                };

                self.revokeKey = function(user) {
                    var modalInstance = ModalSrv.confirm(
                        'Revoke API key',
                        'Are you sure you want to revoke the API key of this user?', {
                            flavor: 'danger',
                            okText: 'Yes, revoke it'
                        }
                    );

                    modalInstance.result
                        .then(function() {
                            return UserSrv.revokeKey(user._id);
                        })
                        .then(function( /*response*/ ) {
                            delete self.userKeyCache[user._id];
                            self.onReload();
                            NotificationSrv.success(
                                'API key of user ' + user.login + ' has been successfully revoked.'
                            );
                        })
                        .catch(function(err) {
                            if (err && !_.isString(err)) {
                                NotificationSrv.error('OrgUserCtrl', err.data, err.status);
                            }
                        });
                };

                self.copyKey = function(user) {
                    clipboard.copyText(self.userKeyCache[user._id]);
                    delete self.userKeyCache[user._id];
                    NotificationSrv.success(
                        'API key of user ' + user.login + ' has been successfully copied to clipboard.'
                    );
                };

                self.setPassword = function(user, password) {
                    if (!self.canSetPass) {
                        return;
                    }

                    UserSrv.setPass(user._id, password)
                        .then(function() {
                            NotificationSrv.success('Password of user ' + user.login + ' has been successfully updated.');
                            self.onReload();
                        })
                        .catch(function(response) {
                            NotificationSrv.error(
                                'OrgUserCtrl',
                                response.data,
                                response.status
                            );
                        });
                };

                self.editUser = function(user) {
                    self.onEdit({
                        user: user
                    });
                };

                self.lockUser = function(user, locked) {
                    var action = (locked ? 'lock' : 'unlock');

                    var modalInstance = ModalSrv.confirm(
                        (locked ? 'Lock' : 'Unlock') + ' User',
                        'Are you sure you want to ' + action +' this user?', {
                            flavor: 'danger',
                            okText: 'Yes, proceed'
                        }
                    );

                    modalInstance.result
                        .then(function(/*response*/) {
                            return UserSrv.update(user._id, {locked: locked});
                        })
                        .then(function() {
                            NotificationSrv.success('User ' + user.login + ' has been successfully updated.');
                            self.onReload();
                        })
                        .catch(function(response) {
                            NotificationSrv.error(
                                'OrgUserCtrl',
                                response.data,
                                response.status
                            );
                        });
                };

                self.removeUser = function(user) {
                    var modalInstance = ModalSrv.confirm(
                        'Permanently remove User',
                        'Are you sure you want to permanently remove this user?', {
                            flavor: 'danger',
                            okText: 'Yes, proceed'
                        }
                    );

                    modalInstance.result
                        .then(function(/*response*/) {
                            return UserSrv.remove(user._id, $stateParams.organisation);
                        })
                        .then(function() {
                            NotificationSrv.success('User ' + user.login + ' has been successfully removed.');
                            self.onReload();
                        })
                        .catch(function(response) {
                            NotificationSrv.error(
                                'OrgUserCtrl',
                                response.data,
                                response.status
                            );
                        });
                };
            },
            controllerAs: '$ctrl',
            templateUrl: 'views/components/org/user.list.html',
            bindings: {
                users: '<',
                sort: '<',
                mfaEnabled: '<',
                setPasswordEnabled: '<',
                onReload: '&',
                onEdit: '&',
                onSort: '&',
                onFilter: '&'
            }
        });
})();

```

`frontend/app/scripts/components/search/filters-preview.component.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveComponents')
        .component('filtersPreview', {
            controller: function() {
                this.clearItem = function(field) {
                    this.onClearItem({
                        field: field
                    });
                };

                this.clearAll = function() {
                    this.onClearAll();
                };
            },
            controllerAs: '$ctrl',
            templateUrl: 'views/components/search/filters-preview.component.html',
            bindings: {
                filters: '<',
                onClearItem: '&',
                onClearAll: '&'
            }
        });
})();

```

`frontend/app/scripts/components/sharing/SharingListCmp.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('sharingList', {
            controller: function() {
                this.remove = function(share) {
                    this.onDelete({
                        share: share
                    });
                };

                this.updateProfile = function(org, newProfile) {
                    this.onUpdateProfile({
                        profile: newProfile,
                        org: org
                    });
                };
            },
            controllerAs: '$ctrl',
            templateUrl: 'views/components/sharing/sharing-list.html',
            bindings: {
                shares: '<',
                organisations: '<',
                profiles: '<',
                readOnly: '<',
                //onReload: '&',
                onUpdateProfile: '&',
                onDelete: '&',
                permissions: '='
            }
        });
})();

```

`frontend/app/scripts/components/sharing/SharingModalCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers')
        .controller('SharingModalCtrl', function($uibModalInstance, shares) {
            var self = this;

            this.shares = shares || [];
            this.selectAll = false;

            this.toggleAll = function() {
                _.each(this.shares, function(item) {
                    item.selected = self.selectAll;
                });
            };

            this.save = function() {
                var selection = _.filter(this.shares, function(item) {
                    return item.selected;
                });

                $uibModalInstance.close(_.pluck(selection, 'organisationName'));
            };

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };
        });
})();

```

`frontend/app/scripts/components/sharing/task/SharingListCmp.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveComponents')
        .component('taskSharingList', {
            controller: function() {
                var self = this;

                this.remove = function(share) {
                    this.onDelete({
                        share: share
                    });
                };

                this.updateProfile = function(org, newProfile) {
                    this.onUpdateProfile({
                        profile: newProfile,
                        org: org
                    });
                };

                this.requireAction = function(org) {
                    this.onRequireAction({
                        task: self.task,
                        org: org
                    });
                };

                this.cancelRequireAction = function(org) {
                    this.onCancelRequireAction({
                        task: self.task,
                        org: org
                    });
                }
            },
            controllerAs: '$ctrl',
            templateUrl: 'views/components/sharing/task/sharing-list.html',
            bindings: {
                task: '<',
                shares: '<',
                organisations: '<',
                profiles: '<',
                readOnly: '<',
                //onReload: '&',
                onUpdateProfile: '&',
                onDelete: '&',
                onRequireAction: '&',
                onCancelRequireAction: '&',
                permissions: '='
            }
        });
})();

```

`frontend/app/scripts/controllers/AboutCtrl.js`:

```js
/**
 * Controller for About TheHive modal page
 */
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('AboutCtrl',
        function($rootScope, $scope, $uibModalInstance, VersionSrv, NotificationSrv) {
            VersionSrv.get().then(function(response) {
                $scope.version = response.versions;
                $scope.connectors = response.connectors;
            }, function(data, status) {
                NotificationSrv.error('AboutCtrl', data, status);
            });

            $scope.close = function() {
                $uibModalInstance.close();
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/AuthenticationCtrl.js`:

```js
/**
 * Controller for login modal page2
 */
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .controller('AuthenticationCtrl', function($rootScope, $scope, $state, $location, $uibModalStack, $stateParams, AuthenticationSrv, NotificationSrv, UtilsSrv, UrlParser, appConfig) {
            $scope.appConfig = appConfig;
            $scope.version = appConfig.versions.TheHive;

            $scope.params = {
                requireMfa: false
            };

            $uibModalStack.dismissAll();

            $scope.ssoEnabled = function() {
                return appConfig.config.authType.indexOf("oauth2") !== -1;
            };


            $scope.login = function() {
                $scope.params.username = $scope.params.username.toLowerCase();
                AuthenticationSrv.login($scope.params.username, $scope.params.password, $scope.params.mfaCode)
                    .then(function() {
                        $location.search('error', null);
                        $state.go('app.index');
                    })
                    .catch(function(err) {
                        if (err.status === 520) {
                            NotificationSrv.error('AuthenticationCtrl', err.data.message, err.status);
                        } else if(err.status === 402){
                            $scope.params.requireMfa = true;
                        } else {
                            NotificationSrv.log(err.data.message, 'error');
                        }
                    });
            };

            var error = UtilsSrv.extractQueryParam('error', UrlParser('query', $location.absUrl()));
            if(!_.isEmpty(error)) {
                $scope.ssoError = window.decodeURIComponent(error).replace(/\+/gi, ' ', '');
            }
        });
})();

```

`frontend/app/scripts/controllers/LiveCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .controller('LiveCtrl', function($rootScope, $scope, $window, StreamSrv) {
            StreamSrv.init();
            $rootScope.hideStatusBar = true;
            if ($window.opener) {
                $scope.targetWindow = $window.opener;
            } else {
                $scope.targetWindow = '_blank';
            }
        });
})();

```

`frontend/app/scripts/controllers/MainPageCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('MainPageCtrl',
        function($rootScope, $scope, $window, $stateParams, $state, FilteringSrv, CaseTaskSrv, PaginatedQuerySrv, EntitySrv, UserSrv) {
            var self = this;
            var view = $stateParams.viewId;

            self.$onInit = function() {
                self.view = {};

                self.defaultFilter = {
                    _in: {
                        _field: 'status',
                        _values: ['Waiting', 'InProgress']
                    }
                };

                self.queryOperations = view === 'mytasks' ? [
                    {_name: 'currentUser'},
                    {_name: 'tasks'}
                ] : [
                    {_name: 'waitingTasks'}
                ];

                if ($stateParams.viewId === 'mytasks') {
                    $rootScope.title = 'My tasks';
                    self.view.data = 'mytasks';

                } else if ($stateParams.viewId === 'waitingtasks') {
                    $rootScope.title = 'Waiting tasks';
                    self.view.data = 'waitingtasks';
                }

                self.filtering = new FilteringSrv('task', $stateParams.viewId + '.list', {
                    version: 'v1',
                    defaults: {
                        showFilters: true,
                        showStats: false,
                        pageSize: 15,
                        sort: ['-flag', '-startDate'],
                    },
                    defaultFilter: [],
                    excludes: view === 'mytasks' ? ['owner'] : ['status']
                });
                self.filtering.initContext('list')
                    .then(function() {
                        self.load();

                        $scope.$watch('$vm.list.pageSize', function (newValue) {
                            self.filtering.setPageSize(newValue);
                        });
                    });
            };

            self.load = function() {
                self.list = new PaginatedQuerySrv({
                    objectType: 'case_task',
                    version: 'v1',
                    scope: $scope,
                    sort: self.filtering.context.sort,
                    loadAll: false,
                    pageSize: self.filtering.context.pageSize,
                    filter: self.filtering.buildQuery(),
                    baseFilter: view === 'mytasks' ? self.defaultFilter : [],
                    operations: self.queryOperations,
                    extraData: ['case', 'actionRequired'],
                    name: $stateParams.viewId
                });
            };

            self.toggleStats = function () {
                self.filtering.toggleStats();
            };

            self.toggleFilters = function () {
                self.filtering.toggleFilters();
            };

            self.filter = function () {
                self.filtering.filter().then(self.applyFilters);
            };

            self.clearFilters = function () {
                self.filtering.clearFilters()
                    .then(self.search);
            };

            self.removeFilter = function (index) {
                self.filtering.removeFilter(index)
                    .then(self.search);
            };

            self.search = function () {
                self.load();
                self.filtering.storeContext();
            };
            self.addFilterValue = function (field, value) {
                self.filtering.addFilterValue(field, value);
                self.search();
            };

            // init values
            self.showFlow = true;
            self.openEntity = EntitySrv.open;
            self.getUserInfo = UserSrv.getCache;

            self.openWTask = function(task) {
                if (task.status === 'Waiting') {
                    CaseTaskSrv.update({
                        'taskId': task._id
                    }, {
                        'status': 'InProgress'
                    }, function(data) {
                        if (data.status === 'InProgress') {
                            self.openEntity(task);
                        }
                    }, function(response) {
                        console.log(response);
                    });
                }
            };

            self.live = function() {
                $window.open($state.href('live'), 'TheHiveLive',
                    'width=500,height=700,menubar=no,status=no,toolbar=no,location=no,scrollbars=yes');
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/MigrationCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('MigrationCtrl',
        function($rootScope, $scope, $http, $state, $timeout, $window, NotificationSrv, StreamSrv, UserSrv) {
            $rootScope.title = 'Database migration';
            $scope.migrationStatus = {};
            $scope.showUserForm = false;
            $scope.migrating = false;
            $scope.newUser = {};

            StreamSrv.init();

            StreamSrv.addListener({
                scope: $scope,
                rootId: 'any',
                objectType: 'migration',
                callback: function(events) {
                    angular.forEach(events, function(event) {
                        var tableName = event.base.tableName;

                        if (tableName === 'end') {
                            // check if there is at least one user registered
                            var users = UserSrv.query(function() {
                                if (users.length === 0) {
                                    $scope.showUserForm = true;
                                } else {
                                    $state.go('app.cases');
                                }
                            }, function() {
                                $state.go('app.cases');
                            });
                        }
                        var current = 0;
                        if (angular.isDefined($scope.migrationStatus[tableName])) {
                            current = $scope.migrationStatus[tableName].current;
                        }
                        if (event.base.current > current) {
                            $scope.migrationStatus[tableName] = event.base;
                        }
                    });
                }
            });

            $scope.migrate = function() {
                $scope.migrating = true;
                $http.post('./api/maintenance/migrate', {}, {
                    timeout: 10 * 60 * 60 * 1000 // 10 minutes
                }).then(function(/*response*/) {
                    console.log('Migration started');
                }).catch(function(err) {
                    if (angular.isObject(err)) {
                        NotificationSrv.error('UserMgmtCtrl', err.data, err.status);
                    } else {
                      console.log("Migration timeout");
                    }
                });
            };

            $scope.createInitialUser = function() {
                console.log("createInitialUser");
                UserSrv.save({
                    'login': $scope.newUser.login.toLowerCase(),
                    'name': $scope.newUser.name,
                    'password': $scope.newUser.password,
                    'roles': ['read', 'write', 'admin']
                }, function() {
                    $state.go('app.cases');
                });
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/RootCtrl.js`:

```js
/**
 * Controller for main page
 */
angular.module('theHiveControllers').controller('RootCtrl',
    function ($scope, $rootScope, $timeout, $uibModal, $location, $state, AuthenticationSrv, AnalyzerSrv, StreamSrv, StreamQuerySrv, CaseSrv, CaseTemplateSrv, CustomFieldsSrv, NotificationSrv, AppLayoutSrv, VersionSrv, currentUser, appConfig) {
        'use strict';

        if (currentUser === 520) {
            $state.go('maintenance');
            return;
        } else if (!currentUser || !currentUser.login) {
            $state.go('login', { autoLogin: appConfig.config.ssoAutoLogin });
            return;
        }

        $rootScope.layoutSrv = AppLayoutSrv;
        $scope.appConfig = appConfig;
        $scope.hasCortexConnector = VersionSrv.hasCortexConnector();

        $scope.querystring = '';
        $scope.view = {
            data: 'mytasks'
        };
        $scope.mispEnabled = false;
        $scope.customFieldsCache = [];
        $scope.currentUser = currentUser;

        StreamSrv.init();
        VersionSrv.startMonitoring(function (conf) {
            var connectors = ['misp', 'cortex'];

            _.each(connectors, function (connector) {
                var currentStatus = $scope.appConfig.connectors[connector];
                var newStatus = conf.connectors[connector];
                if (currentStatus && currentStatus.enabled === newStatus.enabled &&
                    newStatus.enabled === true &&
                    currentStatus.status !== newStatus.status) {

                    if (newStatus.status === 'OK') {
                        NotificationSrv.log('The configured ' + connector.toUpperCase() + ' connections are now up.', 'success');
                    } else if (newStatus.status === 'WARNING') {
                        NotificationSrv.log('Some of the configured ' + connector.toUpperCase() + ' connections have errors. Please check your configuration.', 'warning');
                    } else {
                        NotificationSrv.log('The configured ' + connector.toUpperCase() + ' connections have errors. Please check your configuration.', 'error');
                    }
                }
            });

            $scope.appConfig = conf;
            $scope.hasCortexConnector = VersionSrv.hasCortexConnector();
        });

        CaseTemplateSrv.list().then(function (templates) {
            $scope.templates = templates;
        });

        StreamQuerySrv('v1', [
            { _name: 'myTasks' },
            {
                _name: 'filter',
                _in: {
                    _field: 'status',
                    _values: ['Waiting', 'InProgress']
                }
            },
            { _name: 'count' }
        ], {
            scope: $scope,
            rootId: 'any',
            objectType: 'case_task',
            query: {
                params: {
                    name: 'my-tasks.stats'
                }
            },
            onUpdate: function (data) {
                $scope.myCurrentTasksCount = data;
            }
        });

        StreamQuerySrv('v1', [
            { _name: 'waitingTasks' },
            { _name: 'count' }
        ], {
            scope: $scope,
            rootId: 'any',
            objectType: 'case_task',
            query: {
                params: {
                    name: 'waiting-tasks.stats'
                }
            },
            onUpdate: function (data) {
                $scope.waitingTasksCount = data;
            }
        });

        StreamQuerySrv('v1', [
            { _name: 'countUnreadAlert' },
        ], {
            scope: $scope,
            rootId: 'any',
            objectType: 'alert',
            query: {
                params: {
                    name: 'unread-alert-count'
                }
            },
            onUpdate: function (data) {
                $scope.unreadAlertCount = data;
            }
        });

        $scope.$on('templates:refresh', function () {
            CaseTemplateSrv.list().then(function (templates) {
                $scope.templates = templates;
            });
        });

        $scope.$on('custom-fields:refresh', function () {
            // Get custom fields cache
            $scope.initCustomFieldsCache();
        });


        // Get Alert counts
        //$scope.alertEvents = AlertingSrv.stats($scope);

        // $scope.$on('alert:event-imported', function() {
        //     $scope.alertEvents = AlertingSrv.stats($scope);
        // });

        // FIXME
        // $scope.$on('misp:status-updated', function(event, enabled) {
        //     $scope.mispEnabled = enabled;
        // });

        $scope.initCustomFieldsCache = function () {
            CustomFieldsSrv.all().then(function (list) {
                $scope.customFieldsCache = list;
            });
        };
        $scope.initCustomFieldsCache();

        $scope.isSuperAdmin = function () {
            return AuthenticationSrv.isSuperAdmin();
        };

        $scope.selectView = function (name) {
            $state.go('app.main', {
                viewId: name
            });
            $scope.view.data = name;
        };

        $scope.logout = function () {
            AuthenticationSrv.logout(function () {
                $state.go('login');
            }, function (data, status) {
                NotificationSrv.error('RootCtrl', data, status);
            });
        };

        $scope.switchOrg = function () {
            var modal = $uibModal.open({
                templateUrl: 'views/components/org/orgSwitch.modal.html',
                controller: 'OrgSwitchCtrl',
                controllerAs: '$dialog',
                resolve: {
                    currentUser: $scope.currentUser
                }
            });

            modal.result
                .then(function (organisation) {
                    $rootScope.isLoading = true;

                    return AuthenticationSrv.current(organisation)
                        .then(function (userData) {
                            $scope.currentUser = userData;
                            StreamSrv.cancelPoll();
                        });
                })
                .then(function () {
                    AnalyzerSrv.clearCache()

                    $state.go('app.index', {}, { reload: true });
                })
                .catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('Switch organisation', err.data, err.status);
                    }
                })
                .finally(function () {
                    $timeout(function () {
                        $rootScope.isLoading = false;
                    }, 500);

                });

        };

        $scope.createNewCase = function (template) {
            var modal = $uibModal.open({
                templateUrl: 'views/partials/case/case.creation.html',
                controller: 'CaseCreationCtrl',
                size: 'lg',
                resolve: {
                    template: template
                }
            });

            modal.result
                .then(function (data) {
                    $state.go('app.case.details', {
                        caseId: data.id
                    });
                })
                .catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('CaseCreationCtrl', err.data, err.status);
                    }
                });
        };

        $scope.openTemplateSelector = function () {
            var modal = $uibModal.open({
                templateUrl: 'views/partials/case/case.templates.selector.html',
                controller: 'CaseTemplatesDialogCtrl',
                controllerAs: 'dialog',
                size: 'lg',
                resolve: {
                    templates: function () {
                        return $scope.templates;
                    },
                    uiSettings: ['UiSettingsSrv', function (UiSettingsSrv) {
                        return UiSettingsSrv.all();
                    }]
                }
            });

            modal.result
                .then(function (template) {
                    $scope.createNewCase(template);
                })
                .catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('Template Selection', err.data, err.status);
                    }
                });
        };

        $scope.aboutTheHive = function () {
            $uibModal.open({
                templateUrl: 'views/partials/about.html',
                controller: 'AboutCtrl',
                size: ''
            });
        };

        $scope.search = function (caseId) {
            if (!caseId || !_.isNumber(caseId) || caseId <= 0) {
                return;
            }

            CaseSrv.getById(caseId.toString())
                .then(function (response) {
                    if (response !== undefined) {
                        $state.go('app.case.details', { caseId: response._id });
                    } else {
                        NotificationSrv.log('Unable to find the case with number ' + caseId, 'error');
                    }
                })
                .catch(function (err) {
                    NotificationSrv.error('Case search', err.data, err.status);
                })
        };

        // Used to show spinning refresh icon n times
        $scope.getNumber = function (num) {
            return new Array(num);
        };
    }
);

```

`frontend/app/scripts/controllers/SearchCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .controller('SearchCtrl', function($scope, $q, $stateParams, $uibModal, PSearchSrv, AlertingSrv, CaseTemplateSrv, CaseTaskSrv, NotificationSrv, EntitySrv, UserSrv, QueryBuilderSrv, GlobalSearchSrv, metadata) {
            $scope.metadata = metadata;
            $scope.toolbar = [
                // {name: 'all', label: 'All', icon: 'glyphicon glyphicon-search'},
                {name: 'case', label: 'Cases', icon: 'glyphicon glyphicon-folder-open'},
                {name: 'case_task', label: 'Tasks', icon: 'glyphicon glyphicon-tasks'},
                {name: 'case_task_log', label: 'Tasks Logs', icon: 'glyphicon glyphicon-comment'},
                {name: 'case_artifact', label: 'Observables', icon: 'glyphicon glyphicon-pushpin'},
                {name: 'alert', label: 'Alerts', icon: 'glyphicon glyphicon-alert'},
                {name: 'case_artifact_job', label: 'Jobs', icon: 'glyphicon glyphicon-cog'}
                // {name: 'audit', label: 'Audit Logs', icon: 'glyphicon glyphicon-list-alt'}
            ];

            $scope.getUserInfo = UserSrv.getCache;
            $scope.config = GlobalSearchSrv.restore();

            $scope.openEntity = EntitySrv.open;
            $scope.isImage = function(contentType) {
                return angular.isString(contentType) && contentType.indexOf('image') === 0;
            };

            $scope.buildBaseFilter = function(entityName) {
                var typeCriterion = {
                  _not: {
                      '_in': {
                          '_field': '_type',
                          '_values': ['dashboard', 'data', 'user', 'analyzer', 'caseTemplate', 'reportTemplate', 'action']
                      }
                  }
                };

                return entityName === 'all' ? typeCriterion : undefined;
            };

            $scope.importAlert = function(event) {
                $uibModal.open({
                    templateUrl: 'views/partials/alert/event.dialog.html',
                    controller: 'AlertEventCtrl',
                    controllerAs: 'dialog',
                    size: 'max',
                    resolve: {
                        event: function() {
                            return AlertingSrv.get(event.id);
                        },
                        templates: function() {
                            return CaseTemplateSrv.list();
                        },
                        readonly: true
                    }
                })
                .result
                .then(function(/*response*/) {
                  $scope.searchResults.update();
                })
                .catch(function(err) {
                    if(err && !_.isString(err)) {
                        NotificationSrv.error('AlertPreview', err.data, err.status);
                    }

                });
            };

            // filters
            $scope.addFilter = function() {
                var entity = $scope.config.entity;

                $scope.config[entity].filters = $scope.config[entity].filters || [];

                $scope.config[entity].filters.push({
                    field: null,
                    type: null
                });
            };

            $scope.removeFilter = function(index) {
                $scope.config[$scope.config.entity].filters.splice(index, 1);
            };

            $scope.clearFilters = function() {
                $scope.config[$scope.config.entity].filters = [];
                $scope.config[$scope.config.entity].search = null;
                $scope.searchResults = null;

                GlobalSearchSrv.save($scope.config);
            };

            $scope.setFilterField = function(filter, entity) {
                var field = $scope.metadata[entity].attributes[filter.field];

                if(!field) {
                    return;
                }

                filter.type = field.type;

                if (field.type === 'date') {
                    filter.value = {
                        from: null,
                        to: null
                    };
                } else {
                    filter.value = null;
                }
            };

            $scope.setEntity = function(entity) {
                $scope.config.entity = entity;
                $scope.search();
            };

            $scope.filterFields = function(entity) {
                return _.pluck(_.filter($scope.metadata[entity].attributes, function(value, key) {
                    return !key.startsWith('computed.');
                }), 'name').sort();
            };

            $scope.search = function() {
                var entityName = $scope.config.entity,
                    entity = $scope.config[entityName] || {},
                    search = entity.search,
                    filters = entity.filters || [],
                    filters_query = null,
                    search_query = null;

                try {
                    if(entityName !== 'all' && filters.length > 0) {
                        filters_query = QueryBuilderSrv.buildFiltersQuery($scope.metadata[entityName].attributes, filters);
                    }

                    if(search) {
                        search_query = _.isString(search) ? { _string: search } : (search || {});
                    }

                    var criterias = _.without([search_query, filters_query], null, undefined);
                    var query = criterias.length === 0 ? undefined : criterias.length === 1 ? criterias[0] : { _and: criterias };

                    if(query) {
                        GlobalSearchSrv.save($scope.config);

                        $scope.searchResults = PSearchSrv(undefined, entityName === 'all' ? 'any' : $scope.metadata[entityName].path, {
                            filter: query,
                            baseFilter: $scope.buildBaseFilter(entityName),
                            sort: "-createdAt",
                            nparent: 10,
                            nstats: entityName === 'audit',
                            skipStream: true
                        });
                    } else {
                        $scope.searchResults = null;
                    }
                } catch(err) {
                    NotificationSrv.log('Invalid filters error', 'error');
                }
            };

            $scope.search();
        });
})();

```

`frontend/app/scripts/controllers/SettingsCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('SettingsCtrl',
        function($scope, $state, UserSrv, ModalSrv, AuthenticationSrv, NotificationSrv, clipboard, resizeService, readLocalPicService, currentUser, appConfig) {
            $scope.currentUser = currentUser;
            $scope.appConfig = appConfig;

            if(!currentUser || !currentUser.login) {
                $state.go('login');
                return;
            }

            $scope.basicData = {
                username: $scope.currentUser.login,
                name: $scope.currentUser.name,
                avatar: $scope.currentUser.avatar,
                avatarB64: null
            };

            $scope.passData = {
                changePassword: false,
                currentPassword: '',
                password: '',
                passwordConfirm: ''
            };

            $scope.keyData = {};

            $scope.mfaData = {
                enabled: $scope.currentUser.hasMFA,
                secret: null,
                uri: null,
                code: null
            };

            $scope.canChangePass = appConfig.config.capabilities.indexOf('changePassword') !== -1;
            $scope.canChangeKey = appConfig.config.capabilities.indexOf('authByKey') !== -1;
            $scope.canChangeMfa = appConfig.config.capabilities.indexOf('mfa') !== -1;


            $scope.updateBasicInfo = function(form) {
                if (!form.$valid) {
                    return;
                }

                var postData = {
                    name: $scope.basicData.name
                };

                if($scope.basicData.avatarB64) {
                    postData.avatar = $scope.basicData.avatarB64;
                }

                if($scope.basicData.avatar === '') {
                    postData.avatar = '';
                }

                UserSrv.update($scope.currentUser.login, postData)
                    .then(function() {
                        return AuthenticationSrv.current();
                    })
                    .then(function(data) {
                        $scope.currentUser.name = data.name;

                        UserSrv.updateCache(data.login, data);

                        NotificationSrv.log('Your basic information have been successfully updated', 'success');

                        $state.reload();
                    })
                    .catch(function(response) {
                        NotificationSrv.error('SettingsCtrl', response.data, response.status);
                    });
            };

            $scope.updatePassword = function(form) {
                if (!form.$valid) {
                    return;
                }

                var updatedFields = {};
                if ($scope.passData.currentPassword && $scope.passData.password !== '' && $scope.passData.password === $scope.passData.passwordConfirm) {
                    updatedFields.currentPassword = $scope.passData.currentPassword;
                    updatedFields.password = $scope.passData.password;
                }

                if (updatedFields !== {}) {
                    UserSrv.changePass($scope.currentUser.login, updatedFields.currentPassword, updatedFields.password)
                        .then(function( /*data*/ ) {
                            NotificationSrv.log('Your password has been successfully updated', 'success');
                            $state.reload();
                        })
                        .catch(function(response) {
                            NotificationSrv.error('SettingsCtrl', response.data, response.status);
                        });
                } else {
                    $state.go('app.cases');
                }
            };

            $scope.createKey = function(){
                    var modalInstance = ModalSrv.confirm(
                        'Renew API Key',
                        'Are you sure you want to renew your API Key?', {
                            flavor: 'danger',
                            okText: 'Yes, renew it'
                        }
                    );

                    modalInstance.result
                        .then(function() {
                            UserSrv.setKey($scope.currentUser.login);
                        })
                        .then(function() {
                            delete $scope.keyData.key;
                            NotificationSrv.success('API key has been successfully renewed.');
                        })
                        .catch(function(err) {
                            if (!_.isString(err)) {
                                NotificationSrv.error('SettingsCtrl', err.data, err.status);
                            }
                        });
            };

            $scope.getKey = function() {
                UserSrv.getKey($scope.currentUser.login)
                    .then(function(key) {
                        $scope.keyData.key = key;
                    });
            };

            $scope.copyKey = function() {
                clipboard.copyText($scope.keyData.key);
                delete $scope.keyData.key;
                NotificationSrv.success('API key has been successfully copied to clipboard.');
            };

            $scope.copySecret = function(secret) {
                clipboard.copyText(secret);
                NotificationSrv.success('MFA Secret has been successfully copied to clipboard.');
            };

            $scope.enableMfa = function() {
                if($scope.mfaData.enabled) {
                    // Fetch the secret
                    UserSrv.fetchMfaSecret()
                        .then(function(response) {
                            $scope.mfaData.secret = response.data.secret;
                            $scope.mfaData.uri = response.data.uri;
                        })
                        .catch(function(err) {
                            NotificationSrv.error('SettingsCtrl', err.data, err.status);
                        });
                }
            };

            $scope.setMfaSettings = function(form) {
                UserSrv.setMfa($scope.mfaData.code)
                    .then(function(/*response*/) {
                        NotificationSrv.log('Your multi-factor authentication has been successfully configured', 'success');
                        $state.reload();
                    })
                    .catch(function(/*err*/) {
                        $scope.mfaData.enabled = true;
                        form.mfaCode.$setValidity('mfaInvalid', false);
                    });
            };

            $scope.resetMfa = function() {
                var modalInstance = ModalSrv.confirm(
                    'Disable MFA',
                    'Are you sure you want to disabble MFA settings?', {
                        okText: 'Yes, disable it',
                        flavor: 'danger'
                    }
                );

                modalInstance.result
                    .then(function() {
                        UserSrv.resetMfa();
                    })
                    .then(function() {
                        NotificationSrv.log('Your multi-factor authentication has been successfully disabled', 'success');
                        $state.reload();
                    })
                    .catch(function(err) {
                        if (!_.isString(err)) {
                            NotificationSrv.error('SettingsCtrl', err.data, err.status);
                        }
                    });
            };

            $scope.clearPassword = function(form, changePassword) {

                if (!changePassword) {
                    $scope.passData.currentPassword = '';
                    $scope.passData.password = '';
                    $scope.passData.passwordConfirm = '';
                }

                form.$setValidity('currentPassword', true);
                form.$setValidity('password', true);
                form.$setValidity('passwordConfirm', true);
                form.$setPristine(true);
            };

            $scope.cancel = function() {
                $state.go('app.index');
            };

            $scope.clearAvatar = function(form) {
                $scope.basicData.avatar = '';
                $scope.basicData.avatarB64 = null;
                form.avatar.$setValidity('maxsize', true);
                form.avatar.$setPristine(true);
            };

            $scope.$watch('avatarB64', function(value) {
               if(!value){
                   return;
               }

               resizeService.resizeImage('data:' + value.filetype + ';base64,' + value.base64, {
                   height: 100,
                   width: 100,
                   outputFormat: 'image/jpeg'
               })
               .then(function(image) {
                   $scope.basicData.avatarB64 = image.replace('data:image/jpeg;base64,', '');
                   $scope.basicData.avatar = null;
               });
           });
        }
    );
})();

```

`frontend/app/scripts/controllers/admin/AdminAnalyzerTemplatesCtrl.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveControllers')
        .controller('AdminAnalyzerTemplatesCtrl', AdminAnalyzerTemplatesCtrl)
        .controller('AdminAnalyzerTemplateDialogCtrl', AdminAnalyzerTemplateDialogCtrl)
        .controller('AdminAnalyzerTemplateImportCtrl', AdminAnalyzerTemplateImportCtrl)
        .controller('AdminAnalyzerTemplateDeleteCtrl', AdminAnalyzerTemplateDeleteCtrl);


    function AdminAnalyzerTemplatesCtrl($q, $uibModal, AnalyzerSrv, AnalyzerTemplateSrv, NotificationSrv, appConfig) {
        var self = this;

        this.appConfig = appConfig;
        this.templates = [];
        this.analyzers = [];
        this.analyzerIds = [];
        this.analyzerCount = 0;


        this.load = function() {
            $q.all([
                AnalyzerTemplateSrv.list(),
                AnalyzerSrv.query()
            ]).then(function (response) {
                self.templates = response[0].data;
                self.analyzers = response[1];

                var cleared = _.mapObject(self.analyzers, function(val) {
                    delete val.template;

                    return val;
                });

                self.analyzers = cleared;

                return $q.resolve(self.analyzers);
            }, function(rejection) {
                NotificationSrv.error('Analyzer Templates', rejection.data, rejection.status);
            }).then(function (analyzersMap) {
                if(_.isEmpty(analyzersMap)) {
                    _.each(_.pluck(self.templates, 'analyzerId'), function(item) {
                        analyzersMap[item] = {
                            id: item
                        };
                    });
                }

                _.each(self.templates, function (tpl) {
                    if(analyzersMap[tpl.analyzerId]) {
                        analyzersMap[tpl.analyzerId].template = tpl;
                    }
                });

                self.analyzerIds = _.keys(analyzersMap);
                self.analyzerCount = self.analyzerIds.length;
            });
        };

        this.showTemplate = function (analyzer) {
            var modalInstance = $uibModal.open({
                //scope: $scope,
                templateUrl: 'views/partials/admin/analyzer-template-dialog.html',
                controller: 'AdminAnalyzerTemplateDialogCtrl',
                controllerAs: 'vm',
                size: 'max',
                resolve: {
                    analyzer: function () {
                        return angular.copy(analyzer);
                    }
                }
            });

            modalInstance.result
                .then(function() {
                    self.load();
                })
                .catch(function(err){
                    if(err && !_.isString(err)) {
                        NotificationSrv.error('Analyzer Templates', err.data, err.status);
                    }
                });
        };

        this.deleteTemplate = function(template) {
            var modalInstance = $uibModal.open({
                templateUrl: 'views/partials/admin/analyzer-template-delete.html',
                controller: 'AdminAnalyzerTemplateDeleteCtrl',
                controllerAs: 'vm',
                size: '',
                resolve: {
                    template: function() {
                        return template;
                    }
                }
            });

            modalInstance.result
                .then(function() {
                    self.load();
                })
                .catch(function(err){
                    if(err && !_.isString(err)) {
                        NotificationSrv.error('Analyzer Templates', err.data, err.status);
                    }
                });
        };

        this.import = function () {
            var modalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'views/partials/admin/analyzer-template-import.html',
                controller: 'AdminAnalyzerTemplateImportCtrl',
                controllerAs: 'vm',
                size: 'lg'
            });

            modalInstance.result
                .then(function() {
                    self.load();
                })
                .catch(function(err){
                    if(err && !_.isString(err)) {
                        NotificationSrv.error('Analyzer Templates', err.data, err.status);
                    }
                });
        };

        this.load();
    }

    function AdminAnalyzerTemplateDialogCtrl($uibModalInstance, AnalyzerTemplateSrv, NotificationSrv, analyzer) {
        this.analyzer = analyzer;
        this.editorOptions = {
            useWrapMode: true,
            showGutter: true
        };

        this.formData = _.pick(analyzer.template, 'id', 'content');
        this.formData.analyzerId = this.analyzer.name || this.analyzer.id;

        this.cancel = function () {
            $uibModalInstance.dismiss();
        };

        this.saveTemplate = function() {
            AnalyzerTemplateSrv.save(this.formData)
                .then(function() {
                    $uibModalInstance.close();
                }, function(response) {
                    NotificationSrv.error('AdminAnalyzerTemplateDialogCtrl', response.data, response.status);
                });
        };
    }

    function AdminAnalyzerTemplateDeleteCtrl($uibModalInstance, AnalyzerTemplateSrv, NotificationSrv, template) {
        this.template = template;

        this.ok = function () {
            AnalyzerTemplateSrv.delete(template.id)
                .then(function() {
                    $uibModalInstance.close();
                }, function(response) {
                    NotificationSrv.error('AdminAnalyzerTemplateDeleteCtrl', response.data, response.status);
                });
        };
        this.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }

    function AdminAnalyzerTemplateImportCtrl($uibModalInstance, AnalyzerTemplateSrv, NotificationSrv) {
        this.formData = {};

        this.ok = function () {
            AnalyzerTemplateSrv.import(this.formData)
                .then(function() {
                    $uibModalInstance.close();
                }, function(response) {
                    NotificationSrv.error('AdminAnalyzerTemplateImportCtrl', response.data, response.status);
                });
        };

        this.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();

```

`frontend/app/scripts/controllers/admin/AdminCustomFieldDialogCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('AdminCustomFieldDialogCtrl', function($scope, $uibModalInstance, CustomFieldsSrv, NotificationSrv, customField) {
        var self = this;
        self.config = {
            types: [
                'string', 'integer', 'boolean', 'date', 'float'
            ],
            reference: '^[a-zA-Z]{1}[a-zA-Z0-9_-]*'
        };

        self.customField = customField;
        self.customField.options = (customField.options || []).join('\n');

        var onSuccess = function(data) {
            NotificationSrv.log('The Custom field has been successfully saved.', 'success');
            $uibModalInstance.close(data);
        };

        var onFailure = function(response) {
            NotificationSrv.error('AdminCustomFieldDialogCtrl', response.data, response.status);
        };

        var buildOptionsCollection = function(options) {
            if (!options || options === '') {
                return [];
            }

            var type = self.customField.type;
            var values = self.customField.options.split('\n');

            switch(type) {
                case 'integer':
                    return _.without(values.map(function(item) {
                        return Number(item);
                    }), NaN) || [];
                case 'float':
                    return _.without(values.map(function(item) {
                        return parseFloat(item.replace(/,/gi, '.'));
                    }), NaN) || [];
            }

            return values;
        };

        self.saveField = function(form) {
            if (!form.$valid) {
                return;
            }

            var postData = _.pick(self.customField, 'name', 'reference', 'description', 'type', 'mandatory');
            postData.options = buildOptionsCollection(self.customField.options);

            if (self.customField.id) {
                CustomFieldsSrv.update(self.customField.id, postData)
                    .then(onSuccess)
                    .catch(onFailure);
            } else {

                CustomFieldsSrv.get(postData.reference)
                    .then(function() {
                        form.reference.$setValidity('unique', false);
                        form.reference.$setDirty();
                    }, function(err) {
                        if(err.status === 404) {
                            CustomFieldsSrv.create(postData)
                                .then(onSuccess)
                                .catch(onFailure);
                        }
                    })
                    .catch(function(err) {
                        NotificationSrv.error('AdminCustomFieldDialogCtrl', err.data, err.status);
                    });
            }
        };

        self.clearUniqueNameError = function(form) {
            form.reference.$setValidity('unique', true);
            form.reference.$setPristine();
        };

        self.cancel = function() {
            $uibModalInstance.dismiss();
        };

        self.onNamechanged = function(form) {
            if (self.customField.id || !self.customField.name) {
                return;
            }

            var reference = s.trim(s.slugify(self.customField.name));

            self.customField.reference = reference;

            self.clearUniqueNameError(form);
        };

    });
})();

```

`frontend/app/scripts/controllers/admin/AdminCustomFieldsCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('AdminCustomFieldsCtrl',
        function($scope, $uibModal, CustomFieldsSrv, NotificationSrv, ModalUtilsSrv) {
            var self = this;

            self.reference = {
                types: ['string', 'number', 'boolean', 'date']
            };

            self.state = {
                sort: 'name',
                asc: true
            };

            self.sortBy = function(field) {
                if(self.state.sort === field) {
                    self.state.asc = !self.state.asc;
                } else {
                    self.state.sort = field;
                    self.state.asc = true;
                }
            };

            self.customFields = [];

            self.initCustomfields = function() {
                self.formData = {
                    name: null,
                    label: null,
                    description: null,
                    type: null,
                    options: []
                };

                CustomFieldsSrv.list()
                    .then(function(response) {
                        self.customFields = response.data;
                    })
                    .catch(function(response) {
                        NotificationSrv.error('AdminCustomfieldsCtrl', response.data, response.status);
                    });
            };

            self.showFieldDialog = function(customField) {
                var modalInstance = $uibModal.open({
                    templateUrl: 'views/partials/admin/custom-field-dialog.html',
                    controller: 'AdminCustomFieldDialogCtrl',
                    controllerAs: '$vm',
                    size: 'lg',
                    resolve: {
                        customField: function() {
                            return customField.id ? angular.copy(customField, {}) : {};
                        }
                    }
                });

                modalInstance.result.then(function(/*data*/) {
                    self.initCustomfields();
                    CustomFieldsSrv.clearCache();
                    $scope.$emit('custom-fields:refresh');
                })
                .catch(function(err) {
                    if(err && !_.isString(err)) {
                        NotificationSrv.error('AdminCustomfieldsCtrl', err.data, err.status);
                    }
                });
            };

            self.deleteField = function(customField) {
                CustomFieldsSrv.usage(customField)
                    .then(function(response) {
                        var usage = response.data,
                            message,
                            isHtml = false;


                        if (usage.total === 0) {
                            message = 'Are you sure you want to delete this custom field?';
                        } else {
                            var segs = [
                                'Are you sure you want to delete this custom field?',
                                '<br />',
                                '<br />',
                                'This custom field is used by:',
                                '<ul>'
                              ];

                            if(usage.case) {
                                segs.push('<li>' + usage.case + ' ' + (usage.case > 1 ? 'cases' : 'case') + '</li>');
                            }

                            if(usage.alert) {
                                segs.push('<li>' + usage.alert + ' ' + (usage.alert > 1 ? 'alerts' : 'alert') + '</li>');
                            }

                            if(usage.caseTemplate) {
                                segs.push('<li>' + usage.caseTemplate + ' case ' + ' ' + (usage.caseTemplate > 1 ? 'templates' : 'template') + '</li>');
                            }

                            segs.push('</ul>');

                            message = segs.join('');
                            isHtml = true;
                        }

                        return ModalUtilsSrv.confirm('Remove custom field', message, {
                            okText: 'Yes, remove it',
                            flavor: 'danger',
                            isHtml: isHtml
                        });
                    })
                    .then(function(/*response*/) {
                        return CustomFieldsSrv.removeField(customField);
                    })
                    .then(function() {
                        NotificationSrv.log('The custom field has been removed successfully', 'success');

                        self.initCustomfields();
                        CustomFieldsSrv.clearCache();
                        $scope.$emit('custom-fields:refresh');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('AdminCustomFields', err.data, err.status);
                        }
                    });
            };

            self.initCustomfields();
        });
})();

```

`frontend/app/scripts/controllers/admin/AdminObservablesCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('AdminObservablesCtrl',
        function(ModalUtilsSrv, NotificationSrv, ObservableTypeSrv, types) {
            var self = this;

            self.dataTypeList = types;
            self.params = {
                newDataType: null
            };

            self.load = function() {
                ObservableTypeSrv.list()
                    .then(function(response) {
                        self.dataTypeList = response.data;
                    })
                    .catch(function(response) {
                        NotificationSrv.error('AdminObservablesCtrl', response.data, response.status);
                    });
            };

            self.addArtifactDataTypeList = function() {
                ObservableTypeSrv.create({
                    name: self.params.newDataType
                }).then(function(/*response*/) {
                    NotificationSrv.log('Observable type created successfully', 'success');
                    self.load();
                }).catch(function(response) {
                    NotificationSrv.error('AdminObservablesCtrl', response.data, response.status);
                });

                self.params.newDataType = '';
            };

            self.deleteArtifactDataType = function(type) {
                ModalUtilsSrv.confirm('Remove observable type', s.sprintf('Are your sure your want to remove the observable type <strong>%s</strong>', type.name), {
                    okText: 'Yes, remove it',
                    flavor: 'danger',
                    isHtml: true
                })
                    .then(function() {
                        return ObservableTypeSrv.remove(type._id);
                    })
                    .then(function(/*response*/) {
                        NotificationSrv.log('Observable type removed successfully', 'success');
                        self.load();
                    })
                    .catch(function(err){
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('AdminObservablesCtrl', err.data, err.status);
                        }
                    });
            };
        });

})();

```

`frontend/app/scripts/controllers/admin/AdminUiSettingsCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('AdminUiSettingsCtrl', function($scope, $q, NotificationSrv, UiSettingsSrv, uiConfig) {
            var self = this;

            self.isDirtySetting = function(key, newValue) {
                var currentValue = (self.currentSettings[key] || {}).value;

                return newValue !== currentValue;
            };

            self.save = function(/*form*/) {
                var promises = [];

                self.settingsKeys.forEach(function(key) {
                    if(self.isDirtySetting(key, self.configs[key])) {
                        if(!self.currentSettings[key]) {
                            promises.push(UiSettingsSrv.create(key, self.configs[key]));
                        } else {
                            promises.push(UiSettingsSrv.update(self.currentSettings[key].id, key, self.configs[key]));
                        }
                    }
                });

                if(promises.length === 0) {
                    return;
                }

                $q.all(promises)
                    .then(function(/*responses*/) {
                        self.loadSettings();
                        NotificationSrv.log('UI Settings updated successfully', 'success');
                    })
                    .catch(function(/*errors*/) {
                        NotificationSrv.error('An error occurred during UI Settings update');
                    });
            };

            self.loadSettings = function(configurations) {
                var notifyRoot = false;
                var promise;

                if(configurations) {
                    promise = $q.resolve(configurations);
                } else {
                    promise = UiSettingsSrv.all(true);
                    notifyRoot = true;
                }

                promise.then(function(configs) {
                    self.settingsKeys = UiSettingsSrv.keys;
                    self.currentSettings = configs;

                    self.configs = {};
                    self.settingsKeys.forEach(function(key) {
                        self.configs[key] = (configs[key] || {}).value;
                    });

                    if(notifyRoot) {
                        $scope.$emit('ui-settings:refresh', configs);
                    }
                });
            };

            self.loadSettings(uiConfig);

        });
})();

```

`frontend/app/scripts/controllers/admin/attack/AttackPatternListCtrl.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveControllers')
        .controller('AttackPatternListCtrl', AttackPatternListCtrl)
        .controller('AttackPatternDialogCtrl', AttackPatternDialogCtrl)
        .controller('AttackPatternImportCtrl', AttackPatternImportCtrl);

    function AttackPatternListCtrl($scope, $uibModal, PaginatedQuerySrv, FilteringSrv, AttackPatternSrv, NotificationSrv, ModalSrv, appConfig) {
        var self = this;

        this.appConfig = appConfig;

        self.load = function () {
            this.loading = true;

            this.list = new PaginatedQuerySrv({
                name: 'attack-patterns',
                root: undefined,
                objectType: 'pattern',
                version: 'v1',
                scope: $scope,
                sort: self.filtering.context.sort,
                loadAll: false,
                pageSize: self.filtering.context.pageSize,
                filter: this.filtering.buildQuery(),
                baseFilter: {
                    _field: 'patternType',
                    _value: 'attack-pattern'
                },
                operations: [
                    { '_name': 'listPattern' }
                ],
                extraData: ['enabled', 'parent'],
                onUpdate: function () {
                    self.loading = false;
                }
            });
        };

        self.show = function (patternId) {
            $uibModal.open({
                animation: true,
                templateUrl: 'views/partials/admin/attack/view.html',
                controller: 'AttackPatternDialogCtrl',
                controllerAs: '$modal',
                size: 'max',
                resolve: {
                    pattern: function () {
                        return AttackPatternSrv.get(patternId);
                    }
                }
            });
        };


        self.import = function () {
            var modalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'views/partials/admin/attack/import.html',
                controller: 'AttackPatternImportCtrl',
                controllerAs: '$vm',
                size: 'lg',
                resolve: {
                    appConfig: self.appConfig
                }
            });

            modalInstance.result
                .then(function () {
                    self.load();
                })
                .catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('Pattern import', err.data, err.status);
                    }
                });
        };

        this.toggleFilters = function () {
            this.filtering.toggleFilters();
        };

        this.filter = function () {
            self.filtering.filter().then(this.applyFilters);
        };

        this.clearFilters = function () {
            this.filtering.clearFilters()
                .then(self.search);
        };

        this.removeFilter = function (index) {
            self.filtering.removeFilter(index)
                .then(self.search);
        };

        this.search = function () {
            self.load();
            self.filtering.storeContext();
        };
        this.addFilterValue = function (field, value) {
            this.filtering.addFilterValue(field, value);
            this.search();
        };

        self.$onInit = function () {
            self.filtering = new FilteringSrv('pattern', 'attack-pattern.list', {
                version: 'v1',
                defaults: {
                    showFilters: true,
                    showStats: false,
                    pageSize: 15,
                    sort: ['+name']
                },
                defaultFilter: []
            });

            self.filtering.initContext('list')
                .then(function () {
                    self.load();

                    $scope.$watch('$vm.list.pageSize', function (newValue) {
                        self.filtering.setPageSize(newValue);
                    });
                });
        };
    }

    function AttackPatternDialogCtrl($uibModalInstance, AttackPatternSrv, NotificationSrv, pattern) {
        this.pattern = pattern;

        this.ok = function () {
            $uibModalInstance.close();
        };

        this.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };

        this.$onInit = function () {
            if (this.pattern.extraData.parent) {
                this.pattern.isSubTechnique = true;
                this.pattern.parentId = this.pattern.extraData.parent.patternId;
                this.pattern.parentName = this.pattern.extraData.parent.name;
            } else {
                this.pattern.isSubTechnique = false;
            }
        };
    }

    function AttackPatternImportCtrl($uibModalInstance, AttackPatternSrv, NotificationSrv, appConfig) {
        this.appConfig = appConfig;
        this.formData = {};
        this.loading = false;

        this.ok = function () {
            this.loading = true;
            AttackPatternSrv.import(this.formData)
                .then(function () {
                    $uibModalInstance.close();
                })
                .catch(function (response) {
                    NotificationSrv.error('AttackPatternImportCtrl', response.data, response.status);
                })
                .finally(function () {
                    this.loading = false;
                });
        };

        this.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();

```

`frontend/app/scripts/controllers/admin/organisation/OrgDetailsCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('OrgDetailsCtrl',
        function($scope, FilteringSrv, PaginatedQuerySrv, NotificationSrv, UserSrv, organisation, fields, appConfig, uiConfig) {
            var self = this;

            this.uiConfig = uiConfig;
            this.org = organisation;
            this.fields = fields;
            this.canChangeMfa = appConfig.config.capabilities.indexOf('mfa') !== -1;
            this.canSetPass = appConfig.config.capabilities.indexOf('setPassword') !== -1;

            this.getUserInfo = UserSrv.getCache;

            this.$onInit = function() {
                self.filtering = new FilteringSrv('user', 'user.list', {
                    version: 'v1',
                    defaults: {
                        showFilters: true,
                        showStats: false,
                        pageSize: 15,
                        sort: ['+login']
                    },
                    defaultFilter: []
                });

                self.filtering.initContext(self.org.name)
                    .then(function() {
                        self.loadUsers();

                        $scope.$watch('$vm.users.pageSize', function (newValue) {
                            self.filtering.setPageSize(newValue);
                        });
                    });
            };

            this.loadUsers = function() {

                self.users = new PaginatedQuerySrv({
                    name: 'organisation-users',
                    version: 'v1',
                    skipStream: true,
                    sort: self.filtering.context.sort,
                    loadAll: false,
                    pageSize: self.filtering.context.pageSize,
                    pageOptions: {organisation: self.org.name},
                    filter: this.filtering.buildQuery(),
                    operations: [{
                            '_name': 'getOrganisation',
                            'idOrName': self.org.name
                        },
                        {
                            '_name': 'users'
                        }
                    ],
                    onFailure: function(err) {
                        if(err && err.status === 400) {
                            self.filtering.resetContext();
                            self.loadUsers();
                        }
                    }
                });
            };

            this.showUserDialog = function(user) {
                UserSrv.openModal(user, self.org.name)
                    .then(function() {
                        self.loadUsers();
                    })
                    .catch(function(err) {
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('OrgDetailsCtrl', err.data, err.status);
                        }
                    });
            };

            // Filtering
            this.toggleFilters = function () {
                this.filtering.toggleFilters();
            };

            this.filter = function () {
                self.filtering.filter().then(this.applyFilters);
            };

            this.clearFilters = function () {
                this.filtering.clearFilters()
                    .then(self.search);
            };

            this.removeFilter = function (index) {
                self.filtering.removeFilter(index)
                    .then(self.search);
            };

            this.search = function () {
                self.loadUsers();
                self.filtering.storeContext();
            };
            this.addFilterValue = function (field, value) {
                this.filtering.addFilterValue(field, value);
                this.search();
            };

            this.filterBy = function(field, value) {
                self.filtering.clearFilters()
                    .then(function(){
                        self.addFilterValue(field, value);
                    });
            };

            this.sortByField = function(field) {
                var context = this.filtering.context;
                var currentSort = Array.isArray(context.sort) ? context.sort[0] : context.sort;
                var sort = null;

                if(currentSort && currentSort.substr(1) !== field) {
                    sort = ['+' + field];
                } else {
                    sort = [(currentSort === '+' + field) ? '-'+field : '+'+field];
                }

                self.users.sort = sort;
                self.users.update();
                self.filtering.setSort(sort);
            };

        });
})();

```

`frontend/app/scripts/controllers/admin/organisation/OrgLinksModalCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('OrgLinksModalCtrl',
        function($uibModalInstance, $filter, organisation, organisations, links) {
            var self = this;

            this.organisation = organisation;
            this.organisations = organisations;
            this.links = links;
            this.allSelected = false;

            self.$onInit = function() {
                _.each(self.organisations, function(item) {
                    item.linked = false;

                    var found = _.find(self.links, function(link) {
                        return link.name === item.name;
                    });

                    item.linked = !!found;
                });

                self.initialHash = self.hash = $filter('sha256')(self.getStateHash(self.organisations));
            };

            self.getStateHash = function() {
                return JSON.stringify(_.map(self.organisations, function(item) {
                    return _.pick(item, 'name', 'linked');
                }));
            };

            self.toggleLink = function(org) {
                // Toogle the flag
                org.linked = !org.linked;

                // Compute the dirty hash
                self.hash = $filter('sha256')(self.getStateHash(self.organisations));
            };

            self.toggleLinkAll = function() {
                _.each(this.organisations, function(item){
                    item.linked = self.allSelected;
                });

                self.hash = $filter('sha256')(self.getStateHash(self.organisations));
            };

            self.ok = function() {
                var newLinks;

                if(self.initialHash !== self.hash) {
                    newLinks = _.pluck(_.filter(this.organisations, function(item) {
                        return item.linked;
                    }), 'name');
                }

                $uibModalInstance.close(newLinks);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss('cancel');
            };

        });
})();

```

`frontend/app/scripts/controllers/admin/organisation/OrgListCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('OrgListCtrl',
        function($scope, $q, $uibModal, PaginatedQuerySrv, OrganisationSrv, NotificationSrv, FilteringSrv, appConfig) {
            var self = this;

            self.appConfig = appConfig;

            this.$onInit = function() {
                self.filtering = new FilteringSrv('organisation', 'organisation.list', {
                    version: 'v1',
                    defaults: {
                        showFilters: true,
                        showStats: false,
                        pageSize: 15,
                        sort: ['-_updatedAt']
                    },
                    defaultFilter: []
                });
                self.filtering.initContext('list')
                    .then(function() {
                        self.load();

                        $scope.$watch('$vm.list.pageSize', function (newValue) {
                            self.filtering.setPageSize(newValue);
                        });
                    });
            };

            this.load = function() {

                this.list = new PaginatedQuerySrv({
                    name: 'organisations',
                    root: undefined,
                    objectType: 'organisation',
                    version: 'v1',
                    scope: $scope,
                    sort: self.filtering.context.sort,
                    loadAll: false,
                    pageSize: self.filtering.context.pageSize,
                    filter: this.filtering.buildQuery(),
                    operations: [
                        {'_name': 'listOrganisation'}
                    ]
                });
            };

            self.showNewOrg = function(mode, org) {
                var modal = $uibModal.open({
                    controller: 'OrgModalCtrl',
                    controllerAs: '$modal',
                    templateUrl: 'views/partials/admin/organisation/list/create.modal.html',
                    size: 'lg',
                    resolve: {
                        organisation: angular.copy(org),
                        mode: function(){
                            return mode;
                        }
                    }
                });

                modal.result
                    .then(function(newOrg) {
                        if (mode === 'edit') {
                            self.update(org.name, newOrg);
                        } else {
                            self.create(newOrg);
                        }
                    })
                    .catch(function(err){
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Unable to save the organisation.', err.status);
                        }
                    });
            };

            /**
             * Fetch org links and show a modal to allow selecting the links
             */
            self.showLinks = function(org) {
                var modalInstance = $uibModal.open({
                    //scope: $scope,
                    templateUrl: 'views/partials/admin/organisation/list/link.modal.html',
                    controller: 'OrgLinksModalCtrl',
                    controllerAs: '$modal',
                    resolve: {
                        organisation: function() {
                            return org;
                        },
                        organisations: function() {
                            var defer = $q.defer();

                            OrganisationSrv.list()
                                .then(function(response) {
                                    var list = _.filter(response.data, function(item) {
                                        return [OrganisationSrv.defaultOrg, org.name].indexOf(item.name) === -1;
                                    });

                                    defer.resolve(_.sortBy(list, 'name'));
                                });

                            return defer.promise;
                        },
                        links: function () {
                            return OrganisationSrv.links(org.name);
                        }
                    }
                });

                modalInstance.result
                    .then(function(newLinks) {
                        OrganisationSrv.setLinks(org.name, newLinks)
                            .then(function() {
                                self.load();
                                NotificationSrv.log('Organisation updated successfully', 'success');
                            })
                            .catch(function(err) {
                                NotificationSrv.error('Error', 'Organisation update failed', err.status);
                            });
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Organisation update failed', err.status);
                        }
                    });
            };

            self.update = function(orgName, org) {
                OrganisationSrv.update(orgName, _.pick(org, 'name', 'description'))
                    .then(function(/*response*/) {
                        self.load();
                        NotificationSrv.log('Organisation updated successfully', 'success');
                    })
                    .catch(function(err) {
                        NotificationSrv.error('Error', 'Organisation update failed', err.status);
                    });
            };

            self.create = function(org) {
                OrganisationSrv.create(org)
                    .then(function(/*response*/) {
                        self.load();
                        NotificationSrv.log('Organisation created successfully', 'success');
                    })
                    .catch(function(err) {
                        NotificationSrv.error('Error', 'Organisation creation failed', err.status);
                    });
            };

            this.toggleFilters = function () {
                this.filtering.toggleFilters();
            };

            this.filter = function () {
                self.filtering.filter().then(this.applyFilters);
            };

            this.clearFilters = function () {
                this.filtering.clearFilters()
                    .then(self.search);
            };

            this.removeFilter = function (index) {
                self.filtering.removeFilter(index)
                    .then(self.search);
            };

            this.search = function () {
                self.load();
                self.filtering.storeContext();
            };
            this.addFilterValue = function (field, value) {
                this.filtering.addFilterValue(field, value);
                this.search();
            };

            this.sortBy = function(sort) {
                this.list.sort = sort;
                this.list.update();
                this.filtering.setSort(sort);
            };

            this.sortByField = function(field) {
                var context = this.filtering.context;
                var currentSort = Array.isArray(context.sort) ? context.sort[0] : context.sort;
                var sort = null;

                if(currentSort.substr(1) !== field) {
                    sort = ['+' + field];
                } else {
                    sort = [(currentSort === '+' + field) ? '-'+field : '+'+field];
                }

                self.list.sort = sort;
                self.list.update();
                self.filtering.setSort(sort);
            };
        });
})();

```

`frontend/app/scripts/controllers/admin/organisation/OrgModalCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('OrgModalCtrl',
        function($scope, $uibModalInstance, OrganisationSrv, organisation, mode) {
            var self = this;

            this.organisation = organisation;
            this.mode = mode;

            self.initForm = function(org) {
                self.formData = _.defaults(
                    _.pick(org || {}, '_id', 'name', 'description'), {
                        name: null
                    }
                );

                self.nameIsEditable = !!!self.formData._id || self.formData.name !== OrganisationSrv.defaultOrg;
            };



            self.ok = function() {
                $uibModalInstance.close(self.formData);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss('cancel');
            };

            this.initForm(this.organisation);
        });
})();

```

`frontend/app/scripts/controllers/admin/organisation/OrgUserModalCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('OrgUserModalCtrl', function($scope, $uibModalInstance, OrganisationSrv, UserSrv, NotificationSrv, organisation, user, profiles, isEdit) {
        var self = this;

        self.user = user;
        self.isEdit = isEdit;
        self.organisation = organisation;

        self.$onInit = function() {

            // filter profiles based organisation
            if(OrganisationSrv.isDefaultOrg({name: self.organisation})) {

                self.profiles = _.indexBy(_.filter(_.values(profiles), function(profile) {
                    return !!profile.isAdmin;
                }), 'name');
            } else {
                self.profiles = _.indexBy(_.filter(_.values(profiles), function(profile) {
                    return !!!profile.isAdmin;
                }), 'name');
            }

            var formData = _.defaults(_.pick(self.user, '_id', 'name', 'login', 'organisation'), {
                _id: null,
                login: null,
                name: null,
                organisation: self.organisation
            });

            formData.profile = self.user.profile ? self.profiles[self.user.profile] : undefined;

            self.formData = formData;
        };

        var onSuccess = function(data) {
            $uibModalInstance.close(data);
        };

        var onFailure = function(response) {
            NotificationSrv.error('OrgUserModalCtrl', response.data, response.status);
        };

        self.saveUser = function(form) {
            if (!form.$valid) {
                return;
            }

            var postData = {};

            var profile = self.formData.profile.name;

            if (self.user._id) {
                postData = {
                    name: self.formData.name,
                    profile: profile,
                    organisation: self.formData.organisation
                };
                UserSrv.update(self.user._id, postData)
                    .then(onSuccess)
                    .catch(onFailure);
            } else {
                postData = {
                    login: self.formData.login.toLowerCase(),
                    name: self.formData.name,
                    profile: profile,
                    organisation: self.formData.organisation
                };
                UserSrv.save(postData)
                    .then(onSuccess)
                    .catch(onFailure);
            }
        };

        self.cancel = function() {
            $uibModalInstance.dismiss();
        };

    });
})();

```

`frontend/app/scripts/controllers/admin/organisation/case-template/AdminCaseTemplateImportCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('AdminCaseTemplateImportCtrl', function($scope, $uibModalInstance) {
        var self = this;
        this.formData = {
            fileContent: {}
        };

        $scope.$watch('vm.formData.attachment', function(file) {
            if (!file) {
                self.formData.fileContent = {};
                return;
            }
            var aReader = new FileReader();
            aReader.readAsText(self.formData.attachment, 'UTF-8');
            aReader.onload = function( /*evt*/ ) {
                $scope.$apply(function() {
                    self.formData.fileContent = JSON.parse(aReader.result);
                });
            };
            aReader.onerror = function( /*evt*/ ) {
                $scope.$apply(function() {
                    self.formData.fileContent = {};
                });
            };
        });

        this.ok = function() {
            var template = _.pick(
                this.formData.fileContent,
                'name',
                'title',
                'description',
                'tlp',
                'pap',
                'severity',
                'tags',
                'status',
                'titlePrefix',
                'tasks',
                'customFields'
            );
            $uibModalInstance.close(template);
        };

        this.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };
    });
})();

```

`frontend/app/scripts/controllers/admin/organisation/case-template/AdminCaseTemplateTasksCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('AdminCaseTemplateTasksCtrl', function($scope, $uibModalInstance, action, task, users, groups) {
        $scope.task = task || {};
        $scope.action = action;
        $scope.users = users;
        $scope.groups = groups;

        $scope.cancel = function() {
            $uibModalInstance.dismiss();
        };

        $scope.addTask = function() {
            $uibModalInstance.close(task);
        };
    });
})();

```

`frontend/app/scripts/controllers/admin/platform/PlatformStatusCtrl.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveControllers').controller('PlatformStatusCtrl', function (ModalSrv, PlatformSrv, NotificationSrv, appConfig) {
        var self = this;

        self.appConfig = appConfig;
        self.indexStatus = {};
        self.checkStats = {};

        self.loading = {
            index: false,
            check: false
        }

        this.loadIndexStatus = function () {
            self.indexStatus = {};
            self.loading.index = true;

            PlatformSrv.getIndexStatus()
                .then(function (response) {
                    self.indexStatus = response.data;
                    self.loading.index = false;
                });
        }

        this.loadCheckStats = function () {
            self.loading.check = true;

            PlatformSrv.getCheckStats()
                .then(function (response) {
                    self.checkStats = response.data;
                    self.loading.check = false;
                })
        }

        this.$onInit = function () {
            self.loadIndexStatus();
            self.loadCheckStats();
        };

        this.exportReport = function () {
            var date = new moment().format('YYYYMMDD-HH:mmZ');
            var fileName = 'Platform-Status-Report-' + date + '.json';

            var content = {
                indexStatus: self.indexStatus,
                checkStatus: self.checkStats,
                schemaStatus: self.appConfig.schemaStatus
            };

            // Create a blob of the data
            var fileToSave = new Blob([JSON.stringify(content)], {
                type: 'application/json',
                name: fileName
            });

            // Save the file
            saveAs(fileToSave, fileName);
        }

        this.reindex = function (indexName) {
            var modalInstance = ModalSrv.confirm(
                'Reindex',
                'Are you sure you want to trigger ' + indexName + ' data reindex', {
                okText: 'Yes, reindex it'
            }
            );

            modalInstance.result
                .then(function () {
                    PlatformSrv.runReindex(indexName);
                })
                .then(function (/*response*/) {
                    NotificationSrv.success('Reindexing of ' + indexName + ' data started sucessfully');
                })
                .catch(function (err) {
                    if (!_.isString(err)) {
                        NotificationSrv.error('Platform status', err.data, err.status);
                    }
                });
        };

        this.rebuildIndex = function (indexName) {
            var modalInstance = ModalSrv.confirm(
                'Drop & Rebuild Index',
                'Are you sure you want to delete and rebuild ' + indexName + ' data reindex. ' +
                'This operation will drop your existing data index and create a new one.', {
                okText: 'Yes, rebuild it',
                flavor: 'danger'
            }
            );

            modalInstance.result
                .then(function () {
                    PlatformSrv.runRebuildIndex(indexName);
                })
                .then(function (/*response*/) {
                    NotificationSrv.success('Rebuild of ' + indexName + ' data started sucessfully');
                })
                .catch(function (err) {
                    if (!_.isString(err)) {
                        NotificationSrv.error('Platform status', err.data, err.status);
                    }
                });
        };

        this.checkControl = function (checkName) {
            var modalInstance = ModalSrv.confirm(
                'Data health check',
                'Are you sure you want to trigger ' + checkName + ' health check', {
                okText: 'Yes, trigger it'
            }
            );

            modalInstance.result
                .then(function () {
                    PlatformSrv.runCheck(checkName);
                })
                .then(function (/*response*/) {
                    NotificationSrv.success('Data health check of ' + checkName + ' started sucessfully');
                })
                .catch(function (err) {
                    if (!_.isString(err)) {
                        NotificationSrv.error('Platform status', err.data, err.status);
                    }
                });
        }

    });
})();

```

`frontend/app/scripts/controllers/admin/profile/ProfileListCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('ProfileListCtrl',
        function($uibModal, ProfileSrv, NotificationSrv, ModalSrv) {
            var self = this;

            self.load = function() {
                ProfileSrv.list()
                    .then(function(response) {
                        self.list = response.data;
                    })
                    .catch(function(rejection) {
                        NotificationSrv.error('Profile management', rejection.data, rejection.status);
                    });
            };

            self.showProfile = function(mode, profile) {
                var modal = $uibModal.open({
                    controller: 'ProfileModalCtrl',
                    controllerAs: '$modal',
                    templateUrl: 'views/partials/admin/profile/profile.modal.html',
                    size: 'lg',
                    resolve: {
                        profile: profile,
                        mode: function(){
                            return mode;
                        }
                    }
                });

                modal.result
                    .then(function(profile) {
                        if (mode === 'edit') {
                            self.update(profile.id, profile);
                        } else {
                            self.create(profile);
                        }
                    })
                    .catch(function(err){
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('Unable to save the organisation.');
                        }
                    });
            };

            self.update = function(id, profile) {
                ProfileSrv.update(id, _.pick(profile, 'permissions'))
                    .then(function(/*response*/) {
                        self.load();
                        NotificationSrv.log('Profile updated successfully', 'success');
                    })
                    .catch(function(err) {
                        NotificationSrv.error('Error', 'Profile update failed', err.status);
                    });
            };

            self.create = function(profile) {
                ProfileSrv.create(profile)
                    .then(function(/*response*/) {
                        self.load();
                        NotificationSrv.log('Profile created successfully', 'success');
                    })
                    .catch(function(err) {
                        NotificationSrv.error('Error', 'Profile creation failed', err.status);
                    });
            };

            self.removeProfile = function(profile) {
                var modalInstance = ModalSrv.confirm(
                    'Remove profile',
                    'Are you sure you want to remove the selected profile?', {
                        flavor: 'danger',
                        okText: 'Yes, remove it'
                    }
                );

                modalInstance.result
                    .then(function() {
                        return ProfileSrv.remove(profile.id);
                    })
                    .then(function( /*response*/ ) {
                        self.load();
                        NotificationSrv.success(
                            'Profile ' + profile.name + ' has been successfully removed.'
                        );
                    })
                    .catch(function(err) {
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('ProfileListCtrl', err.data, err.status);
                        }
                    });
            };

            self.canDelete = function(profile) {
                return profile.editable === true && profile.name !== 'all' && profile.name !== ProfileSrv.adminProfile;
            };

            self.load();
        });
})();

```

`frontend/app/scripts/controllers/admin/profile/ProfileModalCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('ProfileModalCtrl',
        function($scope,$uibModalInstance, ProfileSrv, profile, mode) {
            var self = this;

            this.permissions = ProfileSrv.permissions;
            this.profile = profile || {};
            this.mode = mode;
            this.isEdit = !!this.profile.id;

            self.initForm = function(profile) {
                self.formData = _.defaults(
                    _.pick(profile || {}, 'id', 'name', 'permissions', 'isAdmin'), {
                        name: null,
                        permissions: [],
                        isAdmin: false
                    }
                );
            };

            self.ok = function() {
                $uibModalInstance.close(self.formData);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss('cancel');
            };

            this.initForm(this.profile);
        });
})();

```

`frontend/app/scripts/controllers/admin/taxonomy/TaxonomyListCtrl.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveControllers')
        .controller('TaxonomyListCtrl', TaxonomyListCtrl)
        .controller('TaxonomyDialogCtrl', TaxonomyDialogCtrl)
        .controller('TaxonomyImportCtrl', TaxonomyImportCtrl);

    function TaxonomyListCtrl($scope, $uibModal, PaginatedQuerySrv, FilteringSrv, TaxonomySrv, NotificationSrv, ModalSrv, QuerySrv, appConfig) {
        var self = this;

        this.appConfig = appConfig;
        this.allTaxonomyCount = null;

        self.$onInit = function () {
            self.filtering = new FilteringSrv('taxonomy', 'taxonomy.list', {
                version: 'v1',
                defaults: {
                    showFilters: true,
                    showStats: false,
                    pageSize: 15,
                    sort: ['+namespace']
                },
                defaultFilter: []
            });

            self.filtering.initContext('list')
                .then(function () {
                    self.load();

                    $scope.$watch('$vm.list.pageSize', function (newValue) {
                        self.filtering.setPageSize(newValue);
                    });
                });

            QuerySrv.count(
                'v1',
                [{ '_name': 'listTaxonomy' }],
                {
                    name: 'all-taxonomy'
                })
                .then(function (total) {
                    self.allTaxonomyCount = total;
                });
        };

        self.load = function () {
            this.loading = true;

            this.list = new PaginatedQuerySrv({
                name: 'taxonomies',
                root: undefined,
                objectType: 'taxonomy',
                version: 'v1',
                scope: $scope,
                sort: self.filtering.context.sort,
                loadAll: false,
                pageSize: self.filtering.context.pageSize,
                filter: this.filtering.buildQuery(),
                operations: [
                    { '_name': 'listTaxonomy' }
                ],
                extraData: ['enabled'],
                onUpdate: function () {
                    self.loading = false;
                }
            });
        };

        self.show = function (taxonomy) {
            // var modalInstance = $uibModal.open({

            $uibModal.open({
                animation: true,
                templateUrl: 'views/partials/admin/taxonomy/view.html',
                controller: 'TaxonomyDialogCtrl',
                controllerAs: '$modal',
                size: 'max',
                resolve: {
                    taxonomy: angular.copy(taxonomy)
                }
            });

            // modalInstance.result
            //     .then(function() {
            //         self.load();
            //     })
            //     .catch(function(err){
            //         if(err && !_.isString(err)) {
            //             NotificationSrv.error('Taxonomies import', err.data, err.status);
            //         }
            //     });
        };


        self.import = function () {
            var modalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'views/partials/admin/taxonomy/import.html',
                controller: 'TaxonomyImportCtrl',
                controllerAs: '$vm',
                size: 'lg',
                resolve: {
                    appConfig: self.appConfig
                }
            });

            modalInstance.result
                .then(function () {
                    self.load();
                })
                .catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('Taxonomies import', err.data, err.status);
                    }
                });
        };

        this.toggleActive = function (taxonomy) {
            var active = !taxonomy.extraData.enabled;

            TaxonomySrv.toggleActive(taxonomy._id, active)
                .then(function () {
                    NotificationSrv.log(['Taxonomy [', taxonomy.namespace, '] has been successfully', (active ? 'activated' : 'deactivated')].join(' '), 'success');

                    self.load();
                })
                .catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('Taxonomies ' + active ? 'activation' : 'deactivation', err.data, err.status);
                    }
                });
        };

        self.remove = function (taxonomy) {
            var modalInstance = ModalSrv.confirm(
                'Remove taxonomy',
                'Are you sure you want to remove the selected taxonomy?', {
                flavor: 'danger',
                okText: 'Yes, remove it'
            }
            );

            modalInstance.result
                .then(function () {
                    return TaxonomySrv.remove(taxonomy._id);
                })
                .then(function ( /*response*/) {
                    self.load();
                    NotificationSrv.success(
                        'Taxonomy ' + taxonomy.namespace + ' has been successfully removed.'
                    );
                })
                .catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('TaxonomyListCtrl', err.data, err.status);
                    }
                });
        };

        this.toggleFilters = function () {
            this.filtering.toggleFilters();
        };

        this.filter = function () {
            self.filtering.filter().then(this.applyFilters);
        };

        this.clearFilters = function () {
            this.filtering.clearFilters()
                .then(self.search);
        };

        this.removeFilter = function (index) {
            self.filtering.removeFilter(index)
                .then(self.search);
        };

        this.search = function () {
            self.load();
            self.filtering.storeContext();
        };
        this.addFilterValue = function (field, value) {
            this.filtering.addFilterValue(field, value);
            this.search();
        };

    }

    function TaxonomyDialogCtrl($uibModalInstance, TaxonomySrv, NotificationSrv, taxonomy) {
        this.taxonomy = taxonomy;

        this.ok = function () {
            $uibModalInstance.close();
        };

        this.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }

    function TaxonomyImportCtrl($uibModalInstance, TaxonomySrv, NotificationSrv, appConfig) {
        this.appConfig = appConfig;
        this.formData = {};
        this.loading = false;

        this.ok = function () {
            this.loading = true;
            TaxonomySrv.import(this.formData)
                .then(function () {
                    $uibModalInstance.close();
                })
                .catch(function (response) {
                    NotificationSrv.error('TaxonomyImportCtrl', response.data, response.status);
                })
                .finally(function () {
                    this.loading = false;
                });
        };

        this.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };
    }
})();

```

`frontend/app/scripts/controllers/alert/AlertEventCtrl.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveControllers')
        .controller('AlertEventCtrl', function ($scope, $rootScope, $state, $uibModal, $uibModalInstance, ModalUtilsSrv, TagSrv, AuthenticationSrv, CustomFieldsSrv, CaseResolutionStatus, AlertingSrv, NotificationSrv, UiSettingsSrv, clipboard, event, templates, readonly) {
            var self = this;
            var eventId = event._id;

            self.eventId = event._id;
            self.readonly = readonly;
            self.templates = _.pluck(templates, 'name');
            self.CaseResolutionStatus = CaseResolutionStatus;
            self.event = event;
            self.canEdit = AuthenticationSrv.hasPermission('manageAlert');

            self.loading = true;

            self.customFieldsCache = CustomFieldsSrv;

            self.counts = {
                observables: 0,
                similarCases: 0
            };

            self.hideEmptyCaseButton = UiSettingsSrv.hideEmptyCaseButton();

            self.updateObservableCount = function (count) {
                self.counts.observables = count;
            };

            self.updateSimilarCasesCount = function (count) {
                self.counts.similarCases = count;
            };

            self.getCustomFieldName = function (fieldDef) {
                return 'customFields.' + fieldDef.reference + '.' + fieldDef.type;
            };

            self.getTags = function (selection) {
                var tags = [];

                angular.forEach(selection, function (tag) {
                    tags.push(tag.text);
                });

                return tags;
            };

            self.getAlertTags = function (query) {
                return TagSrv.autoComplete(query);
            };

            self.load = function () {
                AlertingSrv.get(eventId).then(function (data) {
                    self.event = data;
                    self.loading = false;
                }, function (response) {
                    self.loading = false;
                    NotificationSrv.error('AlertEventCtrl', response.data, response.status);
                    $uibModalInstance.dismiss();
                });
            };

            self.updateField = function (fieldName, newValue) {
                var field = {};
                field[fieldName] = newValue;

                return AlertingSrv.update(self.event._id, field)
                    .then(function () {
                        NotificationSrv.log('Alert updated successfully', 'success');
                    })
                    .catch(function (response) {
                        NotificationSrv.error('AlertEventCtrl', response.data, response.status);
                    });
            };

            self.import = function () {
                self.loading = true;
                AlertingSrv.create(self.event._id, {
                    caseTemplate: self.event.caseTemplate
                }).then(function (response) {
                    $uibModalInstance.dismiss();

                    $rootScope.$broadcast('alert:event-imported');

                    $state.go('app.case.details', {
                        caseId: response.data.id
                    });
                }, function (response) {
                    self.loading = false;
                    NotificationSrv.error('AlertEventCtrl', response.data, response.status);
                });
            };

            self.mergeIntoCase = function (caseId) {
                self.loading = true;
                AlertingSrv.mergeInto(self.event._id, caseId)
                    .then(function (response) {
                        $uibModalInstance.dismiss();

                        $rootScope.$broadcast('alert:event-imported');

                        $state.go('app.case.details', {
                            caseId: response.data.id
                        });
                    }, function (response) {
                        self.loading = false;
                        NotificationSrv.error('AlertEventCtrl', response.data, response.status);
                    });
            };

            self.merge = function () {
                var caseModal = $uibModal.open({
                    templateUrl: 'views/partials/case/case.merge.html',
                    controller: 'CaseMergeModalCtrl',
                    controllerAs: 'dialog',
                    size: 'lg',
                    resolve: {
                        source: function () {
                            return self.event;
                        },
                        title: function () {
                            return 'Merge Alert: ' + self.event.title;
                        },
                        prompt: function () {
                            return self.event.title;
                        },
                        filter: function () {
                            var skipResolvedCases = UiSettingsSrv.disallowMergeAlertInResolvedSimilarCases() === true;

                            if (skipResolvedCases) {
                                return {
                                    _ne: {
                                        _field: 'status',
                                        _value: 'Resolved'
                                    }
                                }
                            }

                            return null;
                        }
                    }
                });

                caseModal.result.then(function (selectedCase) {
                    self.mergeIntoCase(selectedCase._id);
                }).catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('AlertEventCtrl', err.data, err.status);
                    }
                });
            };

            this.follow = function () {
                var fn = angular.noop;

                if (self.event.follow === true) {
                    fn = AlertingSrv.unfollow;
                } else {
                    fn = AlertingSrv.follow;
                }

                fn(self.event._id).then(function () {
                    $uibModalInstance.close();
                }).catch(function (response) {
                    NotificationSrv.error('AlertEventCtrl', response.data, response.status);
                });
            };

            this.delete = function () {
                ModalUtilsSrv.confirm('Remove Alert', 'Are you sure you want to delete this Alert?', {
                    okText: 'Yes, remove it',
                    flavor: 'danger'
                }).then(function () {
                    AlertingSrv.forceRemove(self.event._id)
                        .then(function () {
                            $uibModalInstance.close();
                            NotificationSrv.log('Alert has been permanently deleted', 'success');
                        })
                        .catch(function (response) {
                            NotificationSrv.error('AlertEventCtrl', response.data, response.status);
                        });
                });

            };

            this.canMarkAsRead = AlertingSrv.canMarkAsRead;
            this.canMarkAsUnread = AlertingSrv.canMarkAsUnread;

            this.markAsRead = function () {
                var fn = angular.noop;

                if (this.canMarkAsRead(this.event)) {
                    fn = AlertingSrv.markAsRead;
                } else {
                    fn = AlertingSrv.markAsUnread;
                }

                fn(this.event._id).then(function ( /*data*/) {
                    $uibModalInstance.close();
                }, function (response) {
                    NotificationSrv.error('AlertEventCtrl', response.data, response.status);
                });
            };

            self.cancel = function () {
                $uibModalInstance.dismiss();
            };

            self.copyId = function (id) {
                clipboard.copyText(id);
                NotificationSrv.log('Alert ID has been copied to clipboard', 'success');
            };

            this.$onInit = function () {
                self.load();
            };
        });
})();

```

`frontend/app/scripts/controllers/alert/AlertListCtrl.js`:

```js

(function () {
    'use strict';
    angular.module('theHiveControllers')
        .controller('AlertListCtrl', function ($rootScope, $scope, $q, $state, $uibModal, TagSrv, UiSettingsSrv, StreamQuerySrv, CaseTemplateSrv, UtilsSrv, ModalUtilsSrv, AlertingSrv, NotificationSrv, FilteringSrv, CortexSrv, Severity, VersionSrv) {
            var self = this;

            self.urls = VersionSrv.mispUrls();

            self.list = [];
            self.selection = [];
            self.menu = {
                follow: false,
                unfollow: false,
                markAsRead: false,
                markAsUnRead: false,
                delete: false,
                selectAll: false
            };

            self.lastSearch = null;
            self.responders = null;
            self.alertCountAll = null;

            this.$onInit = function () {
                self.filtering = new FilteringSrv('alert', 'alert.list', {
                    version: 'v1',
                    defaults: {
                        showFilters: true,
                        showStats: false,
                        pageSize: 15,
                        sort: ['-date']
                    },
                    defaultFilter: [{
                        field: 'imported',
                        type: 'boolean',
                        value: false
                    }]
                });
                self.filtering.initContext('list')
                    .then(function () {
                        self.load();

                        $scope.$watch('$vm.list.pageSize', function (newValue) {
                            self.filtering.setPageSize(newValue);
                        });
                    });


                StreamQuerySrv('v1', [
                    { _name: 'countAlert' }
                ], {
                    scope: $scope,
                    rootId: 'any',
                    objectType: 'alert',
                    query: {
                        params: {
                            name: 'alert-count-all'
                        }
                    },
                    guard: UtilsSrv.hasAddDeleteEvents,
                    onUpdate: function (data) {
                        self.alertCountAll = data;
                    }
                });
            };

            self.load = function () {
                var config = {
                    scope: $scope,
                    filter: this.filtering.buildQuery(),
                    loadAll: false,
                    limitedCount: true,
                    sort: self.filtering.context.sort,
                    pageSize: self.filtering.context.pageSize,
                };

                self.list = AlertingSrv.list(config, self.resetSelection);
            };

            this.toggleStats = function () {
                this.filtering.toggleStats();
            };

            this.toggleFilters = function () {
                this.filtering.toggleFilters();
            };

            this.toggleAdvanced = function () {
                this.filtering.toggleAdvanced();
            };

            this.canMarkAsRead = AlertingSrv.canMarkAsRead;
            this.canMarkAsUnread = AlertingSrv.canMarkAsUnread;

            this.markAsRead = function (event) {
                var fn = angular.noop;

                if (this.canMarkAsRead(event)) {
                    fn = AlertingSrv.markAsRead;
                } else {
                    fn = AlertingSrv.markAsUnread;
                }

                fn(event._id).then(function ( /*data*/) {
                }, function (response) {
                    NotificationSrv.error('AlertListCtrl', response.data, response.status);
                });
            };

            self.follow = function (event) {
                var fn = angular.noop;

                if (event.follow === true) {
                    fn = AlertingSrv.unfollow;
                } else {
                    fn = AlertingSrv.follow;
                }

                fn(event._id).then(function ( /*data*/) {
                }, function (response) {
                    NotificationSrv.error('AlertListCtrl', response.data, response.status);
                });
            };

            self.bulkFollow = function (follow) {
                var ids = _.pluck(self.selection, '_id');
                var fn = angular.noop;

                if (follow === true) {
                    fn = AlertingSrv.follow;
                } else {
                    fn = AlertingSrv.unfollow;
                }

                var promises = _.map(ids, function (id) {
                    return fn(id);
                });

                $q.all(promises).then(function ( /*response*/) {
                    NotificationSrv.log('The selected events have been ' + (follow ? 'followed' : 'unfollowed'), 'success');
                }, function (response) {
                    NotificationSrv.error('AlertListCtrl', response.data, response.status);
                });
            };

            self.bulkMarkAsRead = function (markAsReadFlag) {
                var ids = _.pluck(self.selection, '_id');
                var fn = angular.noop;
                var markAsRead = markAsReadFlag && this.canMarkAsRead(self.selection[0]);

                if (markAsRead) {
                    fn = AlertingSrv.markAsRead;
                } else {
                    fn = AlertingSrv.markAsUnread;
                }

                var promises = _.map(ids, function (id) {
                    return fn(id);
                });

                $q.all(promises).then(function ( /*response*/) {
                    self.list.update();
                    NotificationSrv.log('The selected events have been ' + (markAsRead ? 'marked as read' : 'marked as unread'), 'success');
                }, function (response) {
                    NotificationSrv.error('AlertListCtrl', response.data, response.status);
                });
            };

            self.bulkDelete = function () {

                ModalUtilsSrv.confirm('Remove Alerts', 'Are you sure you want to delete the selected Alerts?', {
                    okText: 'Yes, remove them',
                    flavor: 'danger'
                }).then(function () {
                    var ids = _.pluck(self.selection, '_id');

                    AlertingSrv.bulkRemove(ids)
                        .then(function (/*response*/) {
                            NotificationSrv.log('The selected events have been deleted', 'success');
                        })
                        .catch(function (response) {
                            NotificationSrv.error('AlertListCtrl', response.data, response.status);
                        });
                });
            };

            self.import = function (event, readonly) {
                var modalInstance = $uibModal.open({
                    templateUrl: 'views/partials/alert/event.dialog.html',
                    controller: 'AlertEventCtrl',
                    controllerAs: 'dialog',
                    size: 'max',
                    resolve: {
                        event: function () {
                            return angular.copy(event);
                        },
                        templates: function () {
                            return CaseTemplateSrv.list();
                        },
                        readonly: readonly
                    }
                });

                modalInstance.result.catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('AlertListCtrl', err.data, err.status);
                    }
                });
            };

            self.resetSelection = function () {
                if (self.menu.selectAll) {
                    self.selectAll();
                } else {
                    self.selection = [];
                    self.menu.selectAll = false;
                    self.updateMenu();
                }
            };

            this.getResponders = function (event, force) {
                if (!force && this.responders !== null) {
                    return;
                }

                this.responders = null;
                CortexSrv.getResponders('alert', event._id)
                    .then(function (responders) {
                        self.responders = responders;
                        return CortexSrv.promntForResponder(responders);
                    })
                    .then(function (response) {
                        if (response && _.isString(response)) {
                            NotificationSrv.log(response, 'warning');
                        } else {
                            return CortexSrv.runResponder(response.id, response.name, 'alert', _.pick(event, '_id', 'tlp'));
                        }
                    })
                    .then(function (response) {
                        NotificationSrv.log(['Responder', response.data.responderName, 'started successfully on alert', event.title].join(' '), 'success');
                    })
                    .catch(function (err) {
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('AlertList', err.data, err.status);
                        }
                    });
            };

            self.cancel = function () {
                self.modalInstance.close();
            };

            self.updateMenu = function () {
                var temp = _.uniq(_.pluck(self.selection, 'follow'));

                self.menu.unfollow = temp.length === 1 && temp[0] === true;
                self.menu.follow = temp.length === 1 && temp[0] === false;


                temp = _.uniq(_.pluck(self.selection, 'read'));

                self.menu.markAsRead = temp.length === 1 && temp[0] === false;
                self.menu.markAsUnread = temp.length === 1 && temp[0] === true;

                // TODO nadouani: don't rely on alert status
                temp = _.without(_.uniq(_.pluck(self.selection, 'caseId')), null, undefined);

                self.menu.createNewCase = temp.length === 0;
                self.menu.mergeInCase = temp.length === 0;
                self.menu.delete = temp.length === 0;
            };

            self.select = function (event) {
                if (event.selected) {
                    self.selection.push(event);
                } else {
                    self.selection = _.reject(self.selection, function (item) {
                        return item._id === event._id;
                    });
                }

                self.updateMenu();

            };

            self.selectAll = function () {
                var selected = self.menu.selectAll;
                _.each(self.list.values, function (item) {
                    item.selected = selected;
                });

                if (selected) {
                    self.selection = self.list.values;
                } else {
                    self.selection = [];
                }

                self.updateMenu();

            };

            self.createNewCase = function () {
                var alertIds = _.pluck(self.selection, '_id');

                CaseTemplateSrv.list()
                    .then(function (templates) {

                        if (!templates || templates.length === 0) {
                            return $q.resolve(undefined);
                        }

                        // Open template selection dialog
                        var modal = $uibModal.open({
                            templateUrl: 'views/partials/case/case.templates.selector.html',
                            controller: 'CaseTemplatesDialogCtrl',
                            controllerAs: 'dialog',
                            size: 'lg',
                            resolve: {
                                templates: function () {
                                    return templates;
                                },
                                uiSettings: ['UiSettingsSrv', function (UiSettingsSrv) {
                                    return UiSettingsSrv.all();
                                }]
                            }
                        });

                        return modal.result;
                    })
                    .then(function (template) {

                        // Open case creation dialog
                        var modal = $uibModal.open({
                            templateUrl: 'views/partials/case/case.creation.html',
                            controller: 'CaseCreationCtrl',
                            size: 'lg',
                            resolve: {
                                template: template
                            }
                        });

                        return modal.result;
                    })
                    .then(function (createdCase) {
                        // Bulk merge the selected alerts into the created case
                        NotificationSrv.log('New case has been created', 'success');

                        return AlertingSrv.bulkMergeInto(alertIds, createdCase.id);
                    })
                    .then(function (response) {
                        if (alertIds.length === 1) {
                            NotificationSrv.log(alertIds.length + ' Alert has been merged into the newly created case.', 'success');
                        } else {
                            NotificationSrv.log(alertIds.length + ' Alert(s) have been merged into the newly created case.', 'success');
                        }

                        $rootScope.$broadcast('alert:event-imported');

                        $state.go('app.case.details', {
                            caseId: response.data.id
                        });
                    })
                    .catch(function (err) {
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('AlertEventCtrl', err.data, err.status);
                        }
                    });

            };

            self.mergeInCase = function () {
                var caseModal = $uibModal.open({
                    templateUrl: 'views/partials/case/case.merge.html',
                    controller: 'CaseMergeModalCtrl',
                    controllerAs: 'dialog',
                    size: 'lg',
                    resolve: {
                        source: function () {
                            return self.event;
                        },
                        title: function () {
                            return 'Merge selected Alert(s)';
                        },
                        prompt: function () {
                            return 'the ' + self.selection.length + ' selected Alert(s)';
                        },
                        filter: function () {
                            var skipResolvedCases = UiSettingsSrv.disallowMergeAlertInResolvedSimilarCases() === true;

                            if (skipResolvedCases) {
                                return {
                                    _ne: {
                                        _field: 'status',
                                        _value: 'Resolved'
                                    }
                                }
                            }

                            return null;
                        }
                    }
                });

                caseModal.result.then(function (selectedCase) {
                    return AlertingSrv.bulkMergeInto(_.pluck(self.selection, '_id'), selectedCase._id);
                })
                    .then(function (response) {
                        $rootScope.$broadcast('alert:event-imported');

                        $state.go('app.case.details', {
                            caseId: response.data.id
                        });
                    })
                    .catch(function (err) {
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('AlertEventCtrl', err.data, err.status);
                        }
                    });
            };

            this.filter = function () {
                self.filtering.filter().then(this.applyFilters);
            };

            this.clearFilters = function () {
                this.filtering.clearFilters()
                    .then(self.search);
            };

            this.addFilter = function (field, value) {
                self.filtering.addFilter(field, value).then(this.applyFilters);
            };

            this.removeFilter = function (index) {
                self.filtering.removeFilter(index)
                    .then(self.search);
            };

            this.search = function () {
                self.load();
                self.filtering.storeContext();
            };
            this.addFilterValue = function (field, value) {
                this.filtering.addFilterValue(field, value);
                this.search();
            };

            this.filterByStatus = function (flag) {
                self.filtering.clearFilters()
                    .then(function () {
                        self.addFilterValue('imported', flag);
                    });
            };

            this.filterByNewAndUpdated = function () {
                self.filtering.clearFilters()
                    .then(function () {
                        // TODO nadouani: how to support updated alerts
                        self.addFilterValue('imported', true);
                    });
            };

            this.filterBySeverity = function (numericSev) {
                self.addFilterValue('severity', Severity.values[numericSev]);
            };

            this.filterBy = function (field, value) {
                self.filtering.clearFilters()
                    .then(function () {
                        self.addFilterValue(field, value);
                    });
            };

            this.sortBy = function (sort) {
                self.list.sort = sort;
                self.list.update();
                self.filtering.setSort(sort);
            };

            this.sortByField = function (field) {
                var context = this.filtering.context;
                var currentSort = Array.isArray(context.sort) ? context.sort[0] : context.sort;
                var sort = null;

                if (currentSort.substr(1) !== field) {
                    sort = ['+' + field];
                } else {
                    sort = [(currentSort === '+' + field) ? '-' + field : '+' + field];
                }

                self.list.sort = sort;
                self.list.update();
                self.filtering.setSort(sort);
            };
        });
})();

```

`frontend/app/scripts/controllers/alert/AlertStatsCtrl.js`:

```js
/**
 * Controller for About TheHive modal page
 */
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('AlertStatsCtrl',
        function($rootScope, $scope, $stateParams, $timeout, StatSrv, StreamQuerySrv, FilteringSrv) {
            var self = this;

            this.filtering = FilteringSrv;

            this.byType = {};
            this.byStatus = {};
            this.byTags = {};

            this.readAlerts = {
                'true': 'Read',
                'false': 'Unread'
            };

            this.readValues = {
                'true': true,
                'false': false
            };

            self.$onInit = function() {

                // Get stats by tags
                StreamQuerySrv('v1', [
                    { _name: 'listAlert' },
                    {
                       _name: 'aggregation',
                       _agg: 'field',
                       _field: 'tags',
                       _select: [
                           { _agg: 'count' }
                       ],
                       _order: [ '-count' ],
                       _size: 5
                   }
                ], {
                    scope: $scope,
                    rootId: 'any',
                    objectType: 'alert',
                    query: {
                        params: {
                            name: 'alert-by-tags-stats'
                        }
                    },
                    onUpdate: function(data) {
                        self.byTags = StatSrv.prepareResult(data);
                    }
                });

                // Get stats by read status
                StreamQuerySrv('v1', [
                    { _name: 'listAlert' },
                    {
                       _name: 'aggregation',
                       _agg: 'field',
                       _field: 'read',
                       _select: [
                           { _agg: 'count' }
                       ]
                   }
                ], {
                    scope: $scope,
                    rootId: 'any',
                    objectType: 'alert',
                    query: {
                        params: {
                            name: 'alert-by-read-status-stats'
                        }
                    },
                    onUpdate: function(data) {
                        self.byStatus = StatSrv.prepareResult(data);
                    }
                });

                // Get stats by ioc
                StreamQuerySrv('v1', [
                    { _name: 'listAlert' },
                    {
                       _name: 'aggregation',
                       _agg: 'field',
                       _field: 'type',
                       _select: [
                           { _agg: 'count' }
                       ],
                       _order: [ '-count' ],
                       _size: 5
                   }
                ], {
                    scope: $scope,
                    rootId: 'any',
                    objectType: 'alert',
                    query: {
                        params: {
                            name: 'alert-by-type-stats'
                        }
                    },
                    onUpdate: function(data) {
                        self.byType = StatSrv.prepareResult(data);
                    }
                });
            };

            this.filterBy = function(field, value) {
                this.filtering.addFilter(field, value);
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/case/CaseAlertsCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('CaseAlertsCtrl',
        function($scope, $state, $stateParams, $uibModal, $timeout, CaseTabsSrv, VersionSrv, NotificationSrv, alerts) {
            $scope.caseId = $stateParams.caseId;
            $scope.alerts = alerts;
            $scope.alertStats = [];
            $scope.currentFilter = '';
            $scope.filtering = {};
            $scope.sorting = {
              field: '-date'
            };
            var tabName = 'alerts-' + $scope.caseId;

            $scope.mispUrls = VersionSrv.mispUrls();

            // Add tab
            CaseTabsSrv.addTab(tabName, {
                name: tabName,
                label: 'Related Alerts',
                closable: true,
                state: 'app.case.alerts',
                params: {}
            });

            // Select tab
            $timeout(function() {
                CaseTabsSrv.activateTab(tabName);
            }, 0);

            $scope.initStats = function(data) {
                var stats = {
                    type: {},
                    source: {}
                };

                // Init the stats object
                _.each(data, function(item) {
                    stats.type[item.type] = stats.type[item.type] ? stats.type[item.type] + 1 : 1;
                    stats.source[item.source] = stats.source[item.source] ? stats.source[item.source] + 1 : 1;
                });

                var result = {};
                Object.keys(stats).forEach(function(field) {
                    result[field] = [];
                    Object.keys(stats[field]).forEach(function(key) {
                        result[field].push({
                            key: key,
                            value: stats[field][key]
                        });
                    });
                });

                return result;
            };

            $scope.filterBy = function(field, filter) {
                $scope.currentFilter = filter;
                if(field === '') {
                    $scope.filtering = {};
                } else {
                    var temp = {};
                    temp[field] = filter;
                    $scope.filtering = temp;
                }
            };

            $scope.sortBy = function(field) {
                if($scope.sorting.field.substr(1) !== field) {
                    $scope.sorting.field = '+' + field;
                } else {
                    $scope.sorting.field = ($scope.sorting.field === '+' + field) ? '-'+field : '+'+field;
                }
            };

            $scope.previewEvent = function(event) {
                $uibModal.open({
                    templateUrl: 'views/partials/alert/event.dialog.html',
                    controller: 'AlertEventCtrl',
                    controllerAs: 'dialog',
                    size: 'max',
                    resolve: {
                        event: event,
                        templates: function() {
                            //return CaseTemplateSrv.list();
                            return [];
                        },
                        readonly: true
                    }
                })
                .result
                .catch(function(err) {
                    if(err && !_.isString(err)) {
                        NotificationSrv.error('AlertPreview', err.data, err.status);
                    }

                });
            };

            $scope.alertStats = $scope.initStats($scope.alerts);
        }
    );
})();

```

`frontend/app/scripts/controllers/case/CaseCloseModalCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('CaseCloseModalCtrl',
        function($scope, $uibModalInstance, SearchSrv, CustomFieldsSrv, NotificationSrv, caze) {
            $scope.caze = caze;
            $scope.tasksValid = false;
            $scope.tasks = [];
            $scope.formData = {};
            $scope.customFieldsSrv = CustomFieldsSrv;

            SearchSrv(function(data) {
                $scope.initialize();
                $scope.tasks = data;

                if (data && data.length === 0) {
                    $scope.tasksValid = true;
                }
            }, {
                '_and': [{
                    '_parent': {
                        "_query": {
                            "_id": $scope.caze._id
                        },
                        "_type": "case"
                    }
                }, {
                    '_in': {
                        '_field': 'status',
                        '_values': ['Waiting', 'InProgress']
                    }
                }]
            }, 'case_task', 'all');

            $scope.initialize = function() {
                CustomFieldsSrv.all().then(function() {
                    $scope.mandatoryFields = _.sortBy(_.filter($scope.caze.customFields, function(cf) {
                        var fieldDef = $scope.customFieldsSrv.getCache(cf.name);

                        if(!fieldDef) {
                            return;
                        }

                        return ((cf.value === undefined || cf.value === null) && fieldDef.mandatory === true);
                    }), 'order');

                });

                $scope.formData = {
                    status: 'Resolved',
                    resolutionStatus: $scope.caze.resolutionStatus || 'Indeterminate',
                    summary: $scope.caze.summary || '',
                    impactStatus: $scope.caze.impactStatus || null
                };


                $scope.$watchCollection('formData', function(data, oldData) {
                    if (data.resolutionStatus !== oldData.resolutionStatus) {
                        data.impactStatus = null;
                    }
                });
            };

            $scope.confirmTaskClose = function() {
                $scope.tasksValid = true;
            };

            $scope.getCustomFieldsForUpdate = function() {
                var customFields = {};

                _.each($scope.caze.customFields, function(cf) {
                    customFields[cf.name] = {
                        order: cf.order
                    };

                    customFields[cf.name][cf.type] = cf.type === 'date' ? moment(cf.value).valueOf() : cf.value;
                });

                return customFields;
            };

            $scope.closeCase = function() {
                var data = $scope.formData;

                if (data.impactStatus === null) {
                    data.impactStatus = 'NotApplicable';
                }

                data.customFields = $scope.getCustomFieldsForUpdate();

                var promise = $scope.updateField(data);

                promise.then(function(caze) {
                    $scope.caze = caze;

                    NotificationSrv.log('The case #' + caze.number + ' has been closed', 'success');

                    $uibModalInstance.close();
                });
            };

            $scope.cancel = function() {
                $uibModalInstance.dismiss();
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/case/CaseCreationCtrl.js`:

```js
/**
 * Controller for new case modal page
 */
(function () {
    'use strict';
    angular.module('theHiveControllers').controller('CaseCreationCtrl',
        function ($rootScope, $scope, $uibModalInstance, CaseSrv, TaxonomyCacheSrv, NotificationSrv, TagSrv, template) {

            $rootScope.title = 'New case';
            $scope.activeTlp = 'active';
            $scope.activePap = 'active';
            $scope.active = true;
            $scope.pendingAsync = false;
            $scope.temp = {
                titleSuffix: '',
                task: ''
            };
            $scope.template = template;
            $scope.fromTemplate = angular.isDefined(template) && !_.isEqual($scope.template, {});

            $scope.tags = [];

            if ($scope.fromTemplate === true) {

                // Set basic info from template
                $scope.newCase = _.defaults({
                    status: 'Open',
                    title: '',
                    description: template.description,
                    tlp: template.tlp,
                    pap: template.pap,
                    severity: template.severity
                }, {tlp: 2, pap: 2});

                // Set tags from template
                $scope.tags = template.tags;

                // Set tasks from template
                $scope.tasks = _.map(template.tasks, function (t) {
                    return t.title;
                });

            } else {
                $scope.tasks = [];
                $scope.newCase = {
                    status: 'Open'
                };
            }

            $scope.updateTlp = function (tlp) {
                $scope.newCase.tlp = tlp;
            };

            $scope.updatePap = function (pap) {
                $scope.newCase.pap = pap;
            };

            $scope.createNewCase = function (isValid) {
                if (!isValid) {
                    return;
                }

                $scope.newCase.tags = [];
                angular.forEach($scope.tags, function (tag) {
                    $scope.newCase.tags.push(tag.text);
                });
                $scope.newCase.tags = $.unique($scope.newCase.tags.sort());

                // Append title prefix
                if ($scope.fromTemplate) {
                    $scope.newCase.template = $scope.template.name;
                } else {
                    $scope.newCase.tasks = _.map($scope.tasks, function (task) {
                        return {
                            title: task,
                            flag: false,
                            status: 'Waiting'
                        };
                    });
                }

                $scope.pendingAsync = true;
                CaseSrv.save({}, $scope.newCase, function (data) {
                    $uibModalInstance.close(data);
                }, function (response) {
                    $scope.pendingAsync = false;
                    NotificationSrv.error('CaseCreationCtrl', response.data, response.status);
                });
            };

            $scope.fromTagLibrary = function() {
                TaxonomyCacheSrv.openTagLibrary()
                    .then(function(tags){
                        $scope.tags = $scope.tags.concat(tags);
                    })
            };

            $scope.addTask = function (task) {
                if ($scope.tasks.indexOf(task) === -1) {
                    $scope.tasks.push(task);
                }
                $scope.temp.task = '';
                angular.element('.task-input').focus();
            };

            $scope.removeTask = function (task) {
                $scope.tasks = _.without($scope.tasks, task);
            };

            $scope.cancel = function () {
                $uibModalInstance.dismiss();
            };

            $scope.getTags = function(query) {
                return TagSrv.autoComplete(query);
            };

            $scope.keys = function(o) {
                return _.keys(o).length;
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/case/CaseDeleteModalCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('CaseDeleteModalCtrl', function($scope, CaseSrv, $uibModalInstance, caze) {
        $scope.caze = caze;
        $scope.loading = false;

        $scope.confirm = function() {
            $scope.loading = true;
            CaseSrv.forceRemove({ caseId: $scope.caze._id })
                .$promise.then(function(response) {
                    $uibModalInstance.close(response);
                })
                .catch(function(err) {
                    $uibModalInstance.dismiss(err);
                });
        };

        $scope.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };
    });
})();

```

`frontend/app/scripts/controllers/case/CaseDetailsCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('CaseDetailsCtrl', function($scope, $state, $uibModal, PaginatedQuerySrv, CaseTabsSrv, UserSrv, TagSrv) {

        CaseTabsSrv.activateTab($state.current.data.tab);

        $scope.isDefined = false;
        $scope.state = {
            'editing': false,
            'isCollapsed': true
        };

        $scope.attachments = new PaginatedQuerySrv({
            name: 'case-attachments',
            skipStream: true,
            version: 'v1',
            loadAll: false,
            filter: {
                '_contains': 'attachment.id'
            },
            extraData: ['taskId'],
            pageSize: 100,
            operations: [
                { '_name': 'getCase', 'idOrName': $scope.caseId },
                { '_name': 'tasks' },
                { '_name': 'filter', '_ne':{'_field': 'status', '_value': 'Cancel'}},
                { '_name': 'logs' },
            ]
        });

        $scope.assignableUsersQuery = [
            {_name: 'getCase', idOrName: $scope.caseId},
            {_name: 'assignableUsers'}
        ];

        var connectors = $scope.appConfig.connectors;
        if(connectors.cortex && connectors.cortex.enabled) {
            $scope.actions = new PaginatedQuerySrv({
                name: 'case-actions',
                version: 'v1',
                scope: $scope,
                streamObjectType: 'action',
                loadAll: true,
                sort: ['-startDate'],
                pageSize: 100,
                operations: [
                    { '_name': 'getCase', 'idOrName': $scope.caseId },
                    { '_name': 'actions' }
                ],
                guard: function(updates) {
                    return _.find(updates, function(item) {
                        return (item.base.details.objectType === 'Case') && (item.base.details.objectId === $scope.caseId);
                    }) !== undefined;
                }
            });
        }

        $scope.openAttachment = function(attachment) {
            $state.go('app.case.tasks-item', {
                caseId: $scope.caze._id,
                itemId: attachment.extraData.taskId
            });
        };

        $scope.getCaseTags = function(query) {
            return TagSrv.autoComplete(query);
        };
    });

    angular.module('theHiveControllers').controller('CaseCustomFieldsCtrl', function($scope, $uibModal, NotificationSrv, ModalUtilsSrv, CustomFieldsSrv, CaseSrv) {

        $scope.getCustomFieldName = function(fieldDef) {
            return 'customFields.' + fieldDef.reference + '.' + fieldDef.type;
        };

        $scope.addCustomField = function(customField) {
            var modalInstance = $uibModal.open({
                scope: $scope,
                templateUrl: 'views/partials/case/case.add.field.html',
                controller: 'CaseAddMetadataConfirmCtrl',
                size: '',
                resolve: {
                    data: function() {
                        return customField;
                    }
                }
            });

            modalInstance.result.then(function() {
                var customFieldValue = {};
                customFieldValue[customField.type] = null;
                customFieldValue.order = _.max(_.pluck($scope.caze.customFields, 'order')) + 1;

                $scope.updateField('customFields.' + customField.reference, customFieldValue);
            });
        };

        $scope.updateCustomFieldsList = function() {
            CustomFieldsSrv.all().then(function(fields) {
                $scope.allCustomFields = _.omit(fields, _.pluck($scope.caze.customFields, 'name'));
                $scope.customFieldsAvailable = _.keys($scope.allCustomFields).length > 0;
            });
        };

        $scope.removeField = function(fieldId) {
            ModalUtilsSrv.confirm('Remove custom field value', 'Are you sure you want to delete this case custom field value?', {
                okText: 'Yes, remove it',
                flavor: 'danger'
            })
                .then(function () {
                    return CaseSrv.removeCustomField(fieldId);
                })
                .then(function() {
                    var newList = _.reject($scope.caze.customFields, function(item) {
                        return item._id === fieldId
                    });

                    $scope.caze.customFields = newList;

                    $scope.updateCustomFieldsList();
                })
                .catch(function(err) {
                    if(err && !_.isString(err)) {
                        NotificationSrv.error('Remove custom field', err.data, err.status);
                    }
                });
        }

        $scope.keys = function(obj) {
            return _.keys(obj);
        };

        $scope.updateCustomFieldsList();

        $scope.$on('case:refresh-custom-fields', function() {
            $scope.updateCustomFieldsList();
        });

        $scope.$watch('caze.customFields', function() {
            $scope.updateCustomFieldsList();
        });
    });

    angular.module('theHiveControllers').controller('CaseAddMetadataConfirmCtrl', function($scope, $uibModalInstance, data) {
        $scope.data = data;

        $scope.cancel = function() {
            $uibModalInstance.dismiss(data);
        };

        $scope.confirm = function() {
            $uibModalInstance.close(data);
        };
    });

})();

```

`frontend/app/scripts/controllers/case/CaseExportDialogCtrl.js`:

```js
(function() {
    'use strict';

    angular
        .module('theHiveControllers')
        .controller('CaseExportDialogCtrl', function(MispSrv, NotificationSrv, clipboard, $uibModalInstance, caze, config) {
            var self = this;

            this.caze = caze;
            this.mode = '';
            this.servers = _.filter(config.servers, function(server) {
                return !server.purpose || (server.purpose === 'ImportAndExport' || server.purpose === 'ExportOnly');
            });
            this.failures = [];

            this.existingExports = {};
            this.loading = false;

            _.each(_.filter(this.caze.extraData.alerts || [], function(item) {
                return item.type === 'misp';
            }), function(item) {
                self.existingExports[item.source] = true;
            });

            var extractExportErrors = function (errors) {
                var result = [];

                result = errors.map(function(item) {
                    return {
                        data: item.object.dataType === 'file' ? item.object.attachment.name : item.object.data,
                        message: item.message
                    };
                });

                return result;
            };

            this.copyToClipboard = function() {
                clipboard.copyText(_.pluck(self.failures, 'data').join('\n'));
                $uibModalInstance.dismiss();
            };

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };

            this.confirm = function() {
                $uibModalInstance.close();
            };

            this.export = function(server) {
                self.loading = true;
                self.failures = [];

                MispSrv.export(self.caze._id, server.name)
                .then(function(response){
                    var success = 0,
                        failure = 0;

                    if (response.status === 207) {
                        success = response.data.success.length;
                        failure = response.data.failure.length;

                        self.mode = 'error';
                        self.failures = extractExportErrors(response.data.failure);

                        NotificationSrv.log('The case has been successfully exported, but '+ failure +' observable(s) failed', 'warning');
                    } else {
                        success = angular.isArray(response.data) ? response.data.length : 1 ;
                        NotificationSrv.log('The case has been successfully exported with ' + success+ ' observable(s)', 'success');
                        $uibModalInstance.close();
                    }
                    self.loading = false;

                }, function(err) {
                    if(!err) {
                        return;
                    }

                    if (err.status === 400) {
                        self.mode = 'error';
                        self.failures = extractExportErrors(err.data);
                    } else {
                        NotificationSrv.error('CaseExportCtrl', 'An unexpected error occurred while exporting case', err.status);
                    }
                    self.loading = false;
                });
            };
        });
})();

```

`frontend/app/scripts/controllers/case/CaseLinksCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('CaseLinksCtrl',
        function($scope, $state, $stateParams, $uibModal, $timeout, CaseTabsSrv, CaseResolutionStatus) {
            $scope.caseId = $stateParams.caseId;
            $scope.linkStats = [];
            $scope.currentFilter = '';
            $scope.filtering = {};
            $scope.sorting = {
              field: '-startDate'
            }
            $scope.displayOptions = {};
            var tabName = 'links-' + $scope.caseId;

            // Add tab
            CaseTabsSrv.addTab(tabName, {
                name: tabName,
                label: 'Related Cases',
                closable: true,
                state: 'app.case.links',
                params: {}
            });

            // Select tab
            $timeout(function() {
                CaseTabsSrv.activateTab(tabName);
            }, 0);

            $scope.initStats = function(data) {
                var stats = {
                    'Open': 0
                };

                // Init the stats object
                _.each(_.without(_.keys(CaseResolutionStatus), 'Duplicated'), function(key) {
                    stats[key] = 0
                });

                _.each(data, function(item) {
                    if(item.status === 'Open') {
                        stats[item.status] = stats[item.status] + 1;
                    } else {
                        stats[item.resolutionStatus] = stats[item.resolutionStatus] + 1;
                    }
                });

                var result = [];
                _.each(_.keys(stats), function(key) {
                    result.push({
                        key: key,
                        value: stats[key]
                    })
                });

                return result;
            };

            $scope.filterLinks = function(filter) {
                $scope.currentFilter = filter;
                if(filter === '') {
                    $scope.filtering = {};
                } else if(filter === 'Open') {
                    $scope.filtering = {
                        status: filter
                    };
                } else {
                    $scope.filtering = {
                        resolutionStatus: filter
                    };
                }
            };

            $scope.sortBy = function(field) {
                if($scope.sorting.field.substr(1) !== field) {
                    $scope.sorting.field = '+' + field;
                } else {
                    $scope.sorting.field = ($scope.sorting.field === '+' + field) ? '-'+field : '+'+field;
                }
            };

            $scope.$watch('links', function(data){
                $scope.linkStats = $scope.initStats(data);

                _.each(data, function(link) {
                    if($scope.displayOptions[link.id] === undefined) {
                        $scope.displayOptions[link.id] = 5;
                    }
                });


            });
        }
    );
})();

```

`frontend/app/scripts/controllers/case/CaseListCtrl.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveControllers')
        .controller('CaseListCtrl', CaseListCtrl)
        .controller('CaseBulkDeleteModalCtrl', CaseBulkDeleteModalCtrl);

    function CaseListCtrl($scope, $rootScope, $q, $uibModal, StreamQuerySrv, FilteringSrv, SecuritySrv, ModalUtilsSrv, PaginatedQuerySrv, EntitySrv, CaseSrv, UserSrv, AuthenticationSrv, CaseResolutionStatus, CaseImpactStatus, NotificationSrv, CortexSrv, UtilsSrv) {
        var self = this;

        this.openEntity = EntitySrv.open;
        this.getUserInfo = UserSrv.getCache;
        this.CaseResolutionStatus = CaseResolutionStatus;
        this.caseResponders = null;
        self.caseCountAll = null;

        this.lastQuery = null;

        self.selection = [];
        self.menu = {
            selectAll: false
        };

        this.$onInit = function () {
            self.filtering = new FilteringSrv('case', 'case.list', {
                version: 'v1',
                defaults: {
                    showFilters: true,
                    showStats: false,
                    pageSize: 15,
                    sort: ['-flag', '-startDate']
                },
                defaultFilter: [{
                    field: 'status',
                    type: 'enumeration',
                    value: {
                        list: [{
                            text: 'Open',
                            label: 'Open'
                        }]
                    }
                }]
            });

            self.filtering.initContext('list')
                .then(function () {
                    self.load();

                    $scope.$watch('$vm.list.pageSize', function (newValue) {
                        self.filtering.setPageSize(newValue);
                    });
                });

            StreamQuerySrv('v1', [
                { _name: 'countCase' }
            ], {
                scope: $scope,
                rootId: 'any',
                objectType: 'case',
                query: {
                    params: {
                        name: 'case-count-all'
                    }
                },
                guard: UtilsSrv.hasAddDeleteEvents,
                onUpdate: function (data) {
                    self.caseCountAll = data;
                }
            });
        };

        this.load = function () {

            this.list = new PaginatedQuerySrv({
                name: 'cases',
                root: undefined,
                objectType: 'case',
                version: 'v1',
                scope: $scope,
                sort: self.filtering.context.sort,
                loadAll: false,
                limitedCount: true,
                pageSize: self.filtering.context.pageSize,
                filter: this.filtering.buildQuery(),
                operations: [
                    { '_name': 'listCase' }
                ],
                extraData: ['observableStats', 'taskStats', 'procedureCount', 'isOwner', 'shareCount', 'permissions', 'actionRequired'],
                onUpdate: function () {
                    self.resetSelection();
                }
            });
        };

        self.resetSelection = function () {
            if (self.menu.selectAll) {
                self.selectAll();
            } else {
                self.selection = [];
                self.menu.selectAll = false;
                self.updateMenu();
            }
        };

        self.updateMenu = function () {
            // Handle flag/unflag menu items
            var temp = _.uniq(_.pluck(self.selection, 'flag'));
            self.menu.unflag = temp.length === 1 && temp[0] === true;
            self.menu.flag = temp.length === 1 && temp[0] === false;

            // Handle close menu item
            temp = _.uniq(_.pluck(self.selection, 'status'));
            self.menu.close = temp.length === 1 && temp[0] === 'Open';
            self.menu.reopen = temp.length === 1 && temp[0] === 'Resolved';

            self.menu.delete = self.selection.length > 0;
        };

        self.select = function (caze) {
            if (caze.selected) {
                self.selection.push(caze);
            } else {
                self.selection = _.reject(self.selection, function (item) {
                    return item._id === caze._id;
                });
            }
            self.updateMenu();
        };

        self.selectAll = function () {
            var selected = self.menu.selectAll;

            _.each(self.list.values, function (item) {
                if (SecuritySrv.checkPermissions(['manageCase'], item.extraData.permissions)) {
                    item.selected = selected;
                }
            });

            if (selected) {
                self.selection = _.filter(self.list.values, function (item) {
                    return !!item.selected;
                });
            } else {
                self.selection = [];
            }

            self.updateMenu();
        };

        this.toggleStats = function () {
            this.filtering.toggleStats();
        };

        this.toggleFilters = function () {
            this.filtering.toggleFilters();
        };

        this.toggleAdvanced = function () {
            this.filtering.toggleAdvanced();
        };

        this.filter = function () {
            self.filtering.filter().then(this.applyFilters);
        };

        this.clearFilters = function () {
            this.filtering.clearFilters()
                .then(self.search);
        };

        this.removeFilter = function (index) {
            self.filtering.removeFilter(index)
                .then(self.search);
        };

        this.search = function () {
            self.load();
            self.filtering.storeContext();
        };
        this.addFilterValue = function (field, value) {
            this.filtering.addFilterValue(field, value);
            this.search();
        };

        this.filterMyCases = function () {
            this.filtering.clearFilters()
                .then(function () {
                    var currentUser = AuthenticationSrv.currentUser;
                    self.filtering.addFilter({
                        field: 'assignee',
                        type: 'user',
                        value: {
                            list: [{
                                text: currentUser.login,
                                label: currentUser.name
                            }]
                        }
                    });
                    self.search();
                });
        };

        this.filterMyOrgCases = function () {
            this.filtering.clearFilters()
                .then(function () {
                    var currentUser = AuthenticationSrv.currentUser;
                    self.filtering.addFilter({
                        field: 'owningOrganisation',
                        type: 'string',
                        value: {
                            operator: 'all',
                            list: [{
                                text: currentUser.organisation,
                                label: currentUser.organisation
                            }]
                        }
                    });
                    self.search();
                });
        };

        this.filterSharedWithMyOrg = function () {
            this.filtering.clearFilters()
                .then(function () {
                    var currentUser = AuthenticationSrv.currentUser;
                    self.filtering.addFilter({
                        field: 'owningOrganisation',
                        type: 'string',
                        value: {
                            operator: 'none',
                            list: [{
                                text: currentUser.organisation,
                                label: currentUser.organisation
                            }]
                        }
                    });
                    self.search();
                });
        };

        this.filterMyOpenCases = function () {
            this.filtering.clearFilters()
                .then(function () {
                    var currentUser = AuthenticationSrv.currentUser;
                    self.filtering.addFilter({
                        field: 'assignee',
                        type: 'user',
                        value: {
                            list: [{
                                text: currentUser.login,
                                label: currentUser.name
                            }]
                        }
                    });
                    self.addFilterValue('status', 'Open');
                });
        };

        this.filterByStatus = function (status) {
            this.filtering.clearFilters()
                .then(function () {
                    self.addFilterValue('status', status);
                });
        };

        this.filterByResolutionStatus = function (status) {
            this.filtering.clearFilters()
                .then(function () {
                    self.filtering.addFilterValue('resolutionStatus', status);
                    self.addFilterValue('status', 'Resolved');
                });
        };

        this.sortBy = function (sort) {
            this.list.sort = sort;
            this.list.update();
            this.filtering.setSort(sort);
        };

        this.sortByField = function (field) {
            var context = this.filtering.context;
            var currentSort = Array.isArray(context.sort) ? _.without(context.sort, '-flag', '+flag')[0] : context.sort;
            var sort = null;

            if (currentSort.substr(1) !== field) {
                sort = ['-flag', '+' + field];
            } else {
                sort = ['-flag', (currentSort === '+' + field) ? '-' + field : '+' + field];
            }

            self.list.sort = sort;
            self.list.update();
            self.filtering.setSort(sort);
        };

        this.bulkFlag = function (flag) {
            var ids = _.pluck(self.selection, '_id');

            return CaseSrv.bulkUpdate(ids, { flag: flag })
                .then(function (/*responses*/) {
                    NotificationSrv.log('Selected cases have been updated successfully', 'success');
                })
                .catch(function (err) {
                    NotificationSrv.error('Bulk flag cases', err.data, err.status);
                });

        }

        this.bulkEdit = function () {
            var modal = $uibModal.open({
                animation: 'true',
                templateUrl: 'views/partials/case/case.update.html',
                controller: 'CaseUpdateCtrl',
                controllerAs: '$dialog',
                size: 'lg',
                resolve: {
                    selection: function () {
                        return self.selection;
                    }
                }
            });

            modal.result.then(function (operations) {
                $q.all(_.map(operations, function (operation) {
                    return CaseSrv.bulkUpdate(operation.ids, operation.patch);
                })).then(function (/*responses*/) {
                    NotificationSrv.log('Selected cases have been updated successfully', 'success');
                });
            });
        };

        this.bulkRemove = function () {
            var modal = $uibModal.open({
                animation: 'true',
                templateUrl: 'views/partials/case/case.bulk.delete.confirm.html',
                controller: 'CaseBulkDeleteModalCtrl',
                controllerAs: '$dialog',
                size: 'lg',
                resolve: {
                    selection: function () {
                        return self.selection;
                    }
                }
            });

            modal.result.catch(function (err) {
                if (err && !_.isString(err)) {
                    NotificationSrv.error('Case Remove', err.data, err.status);
                }
            })
        }

        this.bulkReopen = function () {
            return ModalUtilsSrv.confirm('Reopen cases', 'Are you sure you want to reopen the selected cases?', {
                okText: 'Yes, proceed'
            }).then(function () {
                var ids = _.pluck(self.selection, '_id');

                return CaseSrv.bulkUpdate(ids, { status: 'Open' })
                    .then(function (/*responses*/) {
                        NotificationSrv.log('Selected cases have been reopened successfully', 'success');
                    })
                    .catch(function (err) {
                        NotificationSrv.error('Bulk reopen cases', err.data, err.status);
                    });
            });
        }

        this.closeCase = function (caze) {
            var scope = $rootScope.$new();

            scope.CaseResolutionStatus = CaseResolutionStatus;
            scope.CaseImpactStatus = CaseImpactStatus;
            scope.caseId = caze._id;
            scope.updateField = function (data) {
                return CaseSrv.update({
                    caseId: caze._id
                }, data)
                    .$promise
                    .then(function (/*response*/) {
                        return caze;
                    });
            };

            var modal = $uibModal.open({
                scope: scope,
                templateUrl: 'views/partials/case/case.close.html',
                controller: 'CaseCloseModalCtrl',
                size: 'lg',
                resolve: {
                    caze: function () {
                        return angular.copy(caze);
                    }
                }
            })

            return modal.result.catch(function (err) {
                if (err && !_.isString(err)) {
                    NotificationSrv.error('Case bulk close', err.data, err.status);
                }
            });
        }

        $scope.updateField = function (data) {
            return CaseSrv.update({
                caseId: caseId
            }, data).$promise;
        };

        this.bulkClose = function () {
            return ModalUtilsSrv.confirm('Close cases', 'Are you sure you want to close the selected ' + self.selection.length + ' case(s)?', {
                okText: 'Yes, proceed'
            }).then(function () {
                return self.selection.reduce(function (initialPromise, nextCase) {
                    return initialPromise
                        .then(self.closeCase(nextCase));
                }, $q.resolve());
            }).catch(function (err) {
                if (err && !_.isString(err)) {
                    NotificationSrv.error('Case bulk close', err.data, err.status);
                }
            });
        }

        this.getCaseResponders = function (caze, force) {
            if (!force && this.caseResponders !== null) {
                return;
            }

            self.caseResponders = null;
            CortexSrv.getResponders('case', caze._id)
                .then(function (responders) {
                    self.caseResponders = responders;
                    return CortexSrv.promntForResponder(responders);
                })
                .then(function (response) {
                    if (response && _.isString(response)) {
                        NotificationSrv.log(response, 'warning');
                    } else {
                        return CortexSrv.runResponder(response.id, response.name, 'case', _.pick(caze, '_id', 'tlp', 'pap'));
                    }
                })
                .then(function (response) {
                    NotificationSrv.log(['Responder', response.data.responderName, 'started successfully on case', caze.title].join(' '), 'success');
                })
                .catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('CaseList', err.data, err.status);
                    }
                });
        };
    }

    function CaseBulkDeleteModalCtrl($uibModalInstance, $q, CaseSrv, NotificationSrv, selection) {
        var self = this;

        this.selection = selection;
        this.count = selection.length;
        this.typedCount = undefined;
        this.loading = false;

        this.ok = function () {
            $uibModalInstance.close();
        }
        this.cancel = function () {
            $uibModalInstance.dismiss();
        }
        this.confirm = function () {
            self.loading = true;

            var promises = _.map(self.selection, function (caze) {
                return CaseSrv.forceRemove({ caseId: caze._id }).$promise;
            });

            $q.all(promises)
                .then(function (responses) {
                    self.loading = false;
                    NotificationSrv.log('Cases have been deleted successfully: ' + responses.length, 'success');
                    $uibModalInstance.close();
                })
                .catch(function (errors) {
                    self.loading = false;
                    _.each(errors, function (err) {
                        NotificationSrv.error('Bulk delete cases', err.data, err.status);
                    });
                })
        }
    }
})();

```

`frontend/app/scripts/controllers/case/CaseMainCtrl.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveControllers').controller('CaseMainCtrl',
        function ($scope, $rootScope, $state, $stateParams, $q, $uibModal, CaseTabsSrv, CaseSrv, UserSrv, StreamSrv, StreamQuerySrv, NotificationSrv, UtilsSrv, CaseResolutionStatus, CaseImpactStatus, CortexSrv, caze) {
            $scope.CaseResolutionStatus = CaseResolutionStatus;
            $scope.CaseImpactStatus = CaseImpactStatus;
            $scope.caseResponders = null;

            var caseId = $stateParams.caseId;
            if (!$rootScope.currentCaseId) {
                $rootScope.currentCaseId = caseId;
            }

            if (caseId !== $rootScope.currentCaseId) {
                $rootScope.currentCaseId = caseId;
                CaseTabsSrv.initTabs();
            }

            $scope.tabSrv = CaseTabsSrv;
            $scope.tabs = CaseTabsSrv.getTabs();
            $scope.getUserInfo = UserSrv.getCache;
            $scope.caseId = caseId;
            $scope.links = [];
            $scope.newestLink = null;
            $scope.oldestLink = null;

            $scope.tasksCount = null;
            $scope.observablesCount = null;
            $scope.alertCount = null;

            $scope.caze = caze;
            $scope.userPermissions = (caze.extraData.permissions || []).join(',');
            $rootScope.title = 'Case #' + caze.number + ': ' + caze.title;

            $scope.canEdit = caze.extraData.permissions.indexOf('manageCase') !== -1;

            $scope.initExports = function () {
                $scope.existingExports = _.filter($scope.caze.extraData.alerts || [], function (item) {
                    return item.type === 'misp';
                }).length;
            };
            $scope.initExports();

            $scope.countIoc = function (link) {
                return _.filter(link.linkedWith, function (l) {
                    return l.ioc;
                }).length;
            };

            CaseSrv.links({
                caseId: $scope.caseId
            }, function (data) {
                $scope.links = _.map(data, function (item) {
                    item.linksCount = item.linkedWith.length || 0;

                    return item;
                });

                if (data.length > 0) {
                    $scope.newestLink = data[0];
                    $scope.newestLink.iocCount = $scope.countIoc($scope.newestLink);
                }

                if (data.length > 1) {
                    $scope.oldestLink = data[data.length - 1];
                    $scope.oldestLink.iocCount = $scope.countIoc($scope.oldestLink);
                }
            });

            StreamSrv.addListener({
                scope: $scope,
                rootId: $scope.caseId,
                objectType: 'case',
                callback: function (updates) {
                    CaseSrv.getById($stateParams.caseId, true)
                        .then(function (data) {
                            $scope.caze = data;

                            if (updates.length === 1 && updates[0] && updates[0].base.details.customFields) {
                                $scope.$broadcast('case:refresh-custom-fields');
                            }
                        }).catch(function (response) {
                            NotificationSrv.error('CaseMainCtrl', response.data, response.status);
                        });
                }
            });

            // Stats for case tasks counter
            StreamQuerySrv('v1', [
                { _name: 'countTask', caseId: caseId },
            ], {
                scope: $scope,
                rootId: caseId,
                objectType: 'case_task',
                query: {
                    params: {
                        name: 'task-stats-' + caseId
                    }
                },
                guard: UtilsSrv.hasAddDeleteEvents,
                onUpdate: function (updates) {
                    $scope.tasksCount = updates;
                }
            });

            // Stats for case observables counter
            StreamQuerySrv('v1', [
                { _name: 'countCaseObservable', caseId: caseId },
            ], {
                scope: $scope,
                rootId: caseId,
                objectType: 'case_artifact',
                query: {
                    params: {
                        name: 'observable-stats-' + caseId
                    }
                },
                guard: UtilsSrv.hasAddDeleteEvents,
                onUpdate: function (updates) {
                    $scope.observablesCount = updates;
                }
            });

            // Stats for case alerts counter
            StreamQuerySrv('v1', [
                { _name: 'countRelatedAlert', caseId: caseId },
            ], {
                scope: $scope,
                rootId: caseId,
                objectType: 'alert',
                query: {
                    params: {
                        name: 'alert-stats-' + caseId
                    }
                },
                onUpdate: function (updates) {
                    $scope.alertCount = updates;
                }
            });

            $scope.$on('tasks:task-removed', function (event, task) {
                CaseTabsSrv.removeTab('task-' + task._id);
            });
            $scope.$on('observables:observable-removed', function (event, observable) {
                CaseTabsSrv.removeTab('observable-' + observable._id);
            });

            $scope.openTab = function (tabName) {
                var tab = CaseTabsSrv.getTab(tabName),
                    params = angular.extend({}, $state.params, tab.params || {});

                $state.go(tab.state, params);
            };

            $scope.removeTab = function (tab) {
                var switchToDetails = CaseTabsSrv.removeTab(tab);

                if (switchToDetails) {
                    $scope.openTab('details');
                }
            };

            $scope.switchFlag = function () {
                if ($scope.caze.flag === true) {
                    $scope.updateField('flag', false);
                } else {
                    $scope.updateField('flag', true);
                }
            };

            // update a specific case field
            $scope.updateField = function (fieldName, newValue) {
                var data = {};

                if (angular.isString(fieldName)) {
                    data[fieldName] = newValue;
                } else {
                    data = fieldName;
                }

                var defer = $q.defer();

                CaseSrv.update({
                    caseId: $scope.caseId
                }, data, function (/*response*/) {
                    //UtilsSrv.shallowClearAndCopy(response, $scope.caze);
                    defer.resolve($scope.caze);
                }, function (response) {
                    NotificationSrv.error('caseDetails', response.data, response.status);
                    defer.reject(response);
                });

                return defer.promise;
            };

            $scope.isCaseClosed = function () {
                return $scope.caze.status === 'Resolved';
            };

            $scope.isCaseTruePositive = function () {
                return $scope.caze.resolutionStatus === 'TruePositive';
            };

            $scope.openCloseDialog = function () {
                var modalInstance = $uibModal.open({
                    scope: $scope,
                    templateUrl: 'views/partials/case/case.close.html',
                    controller: 'CaseCloseModalCtrl',
                    size: 'lg',
                    resolve: {
                        caze: function () {
                            return angular.copy($scope.caze);
                        }
                    }
                });

                modalInstance.result.then(function () {
                    $state.go('app.cases');
                });
            };

            $scope.reopenCase = function () {
                $uibModal.open({
                    scope: $scope,
                    templateUrl: 'views/partials/case/case.reopen.html',
                    controller: 'CaseReopenModalCtrl',
                });
            };

            $scope.mergeCase = function () {
                var caseModal = $uibModal.open({
                    templateUrl: 'views/partials/case/case.merge.html',
                    controller: 'CaseMergeModalCtrl',
                    controllerAs: 'dialog',
                    size: 'lg',
                    resolve: {
                        source: function () {
                            return $scope.caze;
                        },
                        title: function () {
                            return 'Merge Case #' + $scope.caze.number;
                        },
                        prompt: function () {
                            return '#' + $scope.caze.number + ': ' + $scope.caze.title;
                        },
                        filter: function () {
                            return {
                                _ne: {
                                    _field: 'number',
                                    _value: $scope.caze.number
                                }
                            }
                        }
                    }
                });

                caseModal.result.then(function (selectedCase) {
                    CaseSrv.merge([$scope.caze._id, selectedCase._id])
                        .then(function (response) {
                            var merged = response.data;

                            $state.go('app.case.details', {
                                caseId: merged._id
                            });

                            NotificationSrv.log('The cases have been successfully merged into a new case #' + merged.number, 'success');
                        })
                        .catch(function (response) {
                            //this.pendingAsync = false;
                            NotificationSrv.error('Case Merge', response.data, response.status);
                        })

                    // CaseSrv.merge({}, {
                    //     caseId: $scope.caze.id,
                    //     mergedCaseId: selectedCase.id
                    // }, , );
                }).catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('Case Merge', err.data, err.status);
                    }
                });
            };

            $scope.exportToMisp = function () {
                if ($scope.appConfig.connectors.misp && $scope.appConfig.connectors.misp.servers.length === 0) {
                    NotificationSrv.log('There are no MISP servers defined', 'error');
                    return;
                }

                var modalInstance = $uibModal.open({
                    templateUrl: 'views/partials/misp/case.export.confirm.html',
                    controller: 'CaseExportDialogCtrl',
                    controllerAs: 'dialog',
                    size: 'lg',
                    resolve: {
                        caze: function () {
                            return $scope.caze;
                        },
                        config: function () {
                            return $scope.appConfig.connectors.misp;
                        }
                    }
                });

                modalInstance.result.then(function () {
                    return CaseSrv.getById($scope.caseId, true);
                    // return CaseSrv.get({
                    //     'caseId': $scope.caseId,
                    //     'nstats': true
                    // }).$promise;
                }).then(function (data) {
                    $scope.caze = data;
                    $scope.initExports();
                });
            };

            $scope.removeCase = function () {
                var modalInstance = $uibModal.open({
                    templateUrl: 'views/partials/case/case.delete.confirm.html',
                    controller: 'CaseDeleteModalCtrl',
                    resolve: {
                        caze: function () {
                            return $scope.caze;
                        }
                    }
                });

                modalInstance.result.then(function () {
                    $state.go('app.cases');
                })
                    .catch(function (err) {
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('caseDetails', err.data, err.status);
                        }
                    });
            };

            $scope.getCaseResponders = function (force) {
                if (!force && $scope.caseResponders !== null) {
                    return;
                }

                $scope.caseResponders = null;
                CortexSrv.getResponders('case', $scope.caseId)
                    .then(function (responders) {
                        $scope.caseResponders = responders;
                        return CortexSrv.promntForResponder(responders);
                    })
                    .then(function (response) {
                        if (response && _.isString(response)) {
                            NotificationSrv.log(response, 'warning');
                        } else {
                            return CortexSrv.runResponder(response.id, response.name, 'case', _.pick($scope.caze, '_id', 'tlp', 'pap'));
                        }
                    })
                    .then(function (response) {
                        NotificationSrv.log(['Responder', response.data.responderName, 'started successfully on case', $scope.caze.title].join(' '), 'success');
                    })
                    .catch(function (err) {
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('caseDetails', err.data, err.status);
                        }
                    });
            };

            /**
             * A workaround filter to make sure the ngRepeat doesn't order the
             * object keys
             */
            $scope.notSorted = function (obj) {
                if (!obj) {
                    return [];
                }
                return Object.keys(obj);
            };

            $scope.keys = function (obj) {
                return _.keys(obj);
            };

            $scope.getTags = function (selection) {
                var tags = [];

                angular.forEach(selection, function (tag) {
                    tags.push(tag.text);
                });

                return tags;
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/case/CaseMergeModalCtrl.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveControllers')
        .controller('CaseMergeModalCtrl', CaseMergeModalCtrl);

    function CaseMergeModalCtrl($uibModalInstance, $q, QuerySrv, UserSrv, NotificationSrv, source, title, prompt, filter) {
        var me = this;

        this.source = source;
        this.caze = source;
        this.title = title;
        this.prompt = prompt;
        this.search = {
            type: 'title',
            placeholder: 'Search by case title. "Ex: Malware*"',
            minInputLength: 1,
            input: null,
            cases: []
        };
        this.getUserInfo = UserSrv.getCache;

        this.getCaseList = function (type, input) {
            var defer = $q.defer();

            var selectionFilter = (type === 'title') ? {
                _like: {
                    _field: 'title',
                    _value: input
                }
            } : {
                _field: 'number',
                _value: Number.parseInt(input)
            };

            var caseFilter;

            if (filter) {
                caseFilter = {
                    _and: [selectionFilter, filter]
                }
            } else {
                caseFilter = selectionFilter
            }

            QuerySrv.call('v1',
                [{ _name: 'listCase' }],
                {
                    filter: caseFilter,
                    name: 'get-case-for-merge'
                }
            ).then(function (data) {
                defer.resolve(data);
            }); // TODO add error handler

            return defer.promise;
        };

        this.format = function (caze) {
            if (caze) {
                return '#' + caze.number + ' - ' + caze.title;
            }
            return null;
        };

        this.clearSearch = function () {
            this.search.input = null;
            this.search.cases = [];
        };

        this.onTypeChange = function (type) {
            this.clearSearch();

            this.search.placeholder = 'Search by case ' + type;

            if (type === 'title') {
                this.search.minInputLength = 3;
            } else if (type === 'number') {
                this.search.minInputLength = 1;
            }
        };

        this.onSelect = function (item /*, model, label*/) {
            this.search.cases = [item];
        };

        this.merge = function () {
            $uibModalInstance.close(me.search.cases[0]);
        };

        this.cancel = function () {
            $uibModalInstance.dismiss();
        };
    }
})();

```

`frontend/app/scripts/controllers/case/CaseObservablesCtrl.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveControllers').controller('CaseObservablesCtrl',
        function ($scope, $q, $state, $stateParams, $filter, $uibModal, SecuritySrv, ModalUtilsSrv, FilteringSrv, StreamSrv, CaseTabsSrv, PaginatedQuerySrv, ObservableTypeSrv, CaseArtifactSrv, NotificationSrv, AnalyzerSrv, CortexSrv, VersionSrv) {

            CaseTabsSrv.activateTab($state.current.data.tab);

            $scope.analysisEnabled = VersionSrv.hasCortex();
            $scope.caseId = $stateParams.caseId;
            $scope.obsResponders = null;

            $scope.selection = {
                artifacts: []
            };

            $scope.menu = {
                selectAll: false
            };

            this.$onInit = function () {
                $scope.filtering = new FilteringSrv('observable', 'observable.list', {
                    version: 'v1',
                    defaults: {
                        showFilters: true,
                        showStats: false,
                        pageSize: 15,
                        sort: ['-startDate']
                    },
                    defaultFilter: []
                });

                $scope.filtering.initContext($scope.caseId)
                    .then(function () {
                        $scope.load();

                        $scope.initAnalyzersList();

                        // Add a listener to refresh observables list on job finish
                        StreamSrv.addListener({
                            scope: $scope,
                            rootId: $scope.caseId,
                            objectType: 'case_artifact_job',
                            callback: function (data) {
                                var successFound = false;
                                var i = 0;
                                var ln = data.length;

                                while (!successFound && i < ln) {
                                    if (data[i].base.operation === 'Update' && data[i].base.details.status === 'Success') {
                                        successFound = true;
                                    }
                                    i++;
                                }

                                if (successFound) {
                                    $scope.artifacts.update();
                                }
                            }
                        });

                        $scope.$watchCollection('artifacts.pageSize', function (newValue) {
                            $scope.filtering.setPageSize(newValue);
                        });
                    });
            };

            $scope.load = function () {
                $scope.artifacts = new PaginatedQuerySrv({
                    name: 'observables',
                    root: $scope.caseId,
                    objectType: 'observable',
                    streamObjectType: 'case_artifact',
                    version: 'v1',
                    scope: $scope,
                    limitedCount: true,
                    sort: $scope.filtering.context.sort,
                    pageSize: $scope.filtering.context.pageSize,
                    filter: $scope.filtering.buildQuery(),
                    extraData: ['seen', 'permissions', 'shareCount'],
                    // extraData: ['seen', 'permissions', 'isOwner', 'shareCount'],
                    operations: [
                        { '_name': 'getCase', 'idOrName': $scope.caseId },
                        { '_name': 'observables' }
                    ],
                    onUpdate: function () {
                        $scope.resetSelection();
                    }
                });
            };

            $scope.resetSelection = function () {
                if ($scope.menu.selectAll) {
                    $scope.selectAll();
                } else {
                    $scope.selection.artifacts = [];
                    $scope.menu.selectAll = false;

                }
            };

            $scope.sortByField = function (field) {
                var context = this.filtering.context;
                var currentSort = Array.isArray(context.sort) ? context.sort[0] : context.sort;
                var sort = null;

                if (currentSort.substr(1) !== field) {
                    sort = ['+' + field];
                } else {
                    sort = [(currentSort === '+' + field) ? '-' + field : '+' + field];
                }

                $scope.artifacts.sort = sort;
                $scope.artifacts.update();
                $scope.filtering.setSort(sort);
            };

            $scope.keys = function (obj) {
                return _.keys(obj || {});
            };

            // ***************************************************
            $scope.toggleStats = function () {
                $scope.filtering.toggleStats();
            };

            $scope.toggleFilters = function () {
                $scope.filtering.toggleFilters();
            };

            $scope.filter = function () {
                $scope.filtering.filter().then($scope.applyFilters);
            };

            $scope.clearFilters = function () {
                $scope.filtering.clearFilters()
                    .then($scope.search);
            };

            $scope.removeFilter = function (index) {
                $scope.filtering.removeFilter(index)
                    .then($scope.search);
            };

            $scope.search = function () {
                $scope.load();
                $scope.filtering.storeContext();
            };
            $scope.addFilterValue = function (field, value) {
                $scope.filtering.addFilterValue(field, value);
                $scope.search();
            };

            $scope.filterByTlp = function (value) {
                $scope.addFilterValue('tlp', value);
            };
            // ***************************************************


            $scope.countReports = function (observable) {
                return _.keys(observable.reports).length;
            };

            // FIXME à quoi ça sert ? c'est un tableau ou un object ?
            $scope.artifactList = [];
            $scope.artifactList.Action = 'main';
            $scope.artifactList.isCollapsed = true;
            $scope.artifactList.ttags = [];
            $scope.analyzersList = {
                active: {},
                datatypes: {}
            };
            $scope.selection = {};

            //
            // init lists
            //
            $scope.initAnalyzersList = function () {
                if ($scope.analysisEnabled) {
                    AnalyzerSrv.query()
                        .then(function (analyzers) {
                            $scope.analyzersList.analyzers = analyzers;
                        });
                }
            };

            // select all artifacts : add all artifacts in selection or delete selection
            $scope.selectAll = function () {
                var selected = $scope.menu.selectAll;

                _.each($scope.artifacts.values, function (item) {
                    if (SecuritySrv.checkPermissions(['manageObservable'], item.extraData.permissions)) {
                        item.selected = selected;
                    }
                });

                if (selected) {
                    $scope.selection.artifacts = _.filter($scope.artifacts.values, function (item) {
                        return !!item.selected;
                    });
                } else {
                    $scope.selection.artifacts = [];
                }
            };

            // select or unselect an artifact
            $scope.selectArtifact = function (artifact) {
                if (artifact.selected) {
                    $scope.selection.artifacts.push(artifact);
                } else {
                    $scope.selection.artifacts = _.reject($scope.selection.artifacts, function (item) {
                        return item._id === artifact._id;
                    });
                }
            };

            // actions on artifacts
            $scope.addArtifact = function () {
                $uibModal.open({
                    animation: 'true',
                    templateUrl: 'views/partials/observables/observable.creation.html',
                    controller: 'ObservableCreationCtrl',
                    size: 'lg',
                    resolve: {
                        params: function () {
                            return null;
                        },
                        tags: function () {
                            return [];
                        }
                    }
                });
            };

            $scope.bulkEdit = function () {
                var modal = $uibModal.open({
                    animation: 'true',
                    templateUrl: 'views/partials/observables/observable.update.html',
                    controller: 'ObservableUpdateCtrl',
                    controllerAs: '$dialog',
                    size: 'lg',
                    resolve: {
                        selection: function () {
                            return $scope.selection.artifacts;
                        },
                        dataTypes: function () {
                            return ObservableTypeSrv.list()
                                .then(function (response) {
                                    return response.data;
                                });
                        }
                    }
                });

                modal.result.then(function (operations) {
                    $q.all(_.map(operations, function (operation) {
                        return CaseArtifactSrv.bulkUpdate(operation.ids, operation.patch);
                    })).then(function (/*responses*/) {
                        NotificationSrv.log('Selected observables have been updated successfully', 'success');
                    });
                });
            };

            $scope.bulkAnalyze = function () {
                var modal = $uibModal.open({
                    animation: 'true',
                    templateUrl: 'views/partials/observables/observable.analyze.html',
                    controller: 'ObservableAnalyzeCtrl',
                    controllerAs: '$dialog',
                    size: 'lg',
                    resolve: {
                        selection: function () {
                            return $scope.selection.artifacts;
                        },
                        analyzers: function () {
                            return $scope.analyzersList.analyzers;
                        }
                    }
                });

                modal.result.then(function (operations) {
                    var analyzerNames = _.uniq(_.pluck(operations, 'analyzerName'));

                    CortexSrv.getServers(analyzerNames)
                        .then(function (serverId) {
                            return $q.all(
                                _.map(operations, function (item) {
                                    return CortexSrv.createJob({
                                        cortexId: serverId,
                                        artifactId: item.observableId,
                                        analyzerId: item.analyzerName
                                    });
                                })
                            );
                        })
                        .then(function () {
                            NotificationSrv.log('Analyzers have been successfully started for the selected observables', 'success');
                        }, function () {

                        });
                });
            };

            $scope.showExport = function () {
                $scope.showExportPanel = true;
            };

            $scope.hideExport = function () {
                $scope.showExportPanel = false;
            };

            $scope.removeObservables = function () {

                ModalUtilsSrv.confirm('Remove Observables', 'Are you sure you want to delete the selected Observables?', {
                    okText: 'Yes, remove them',
                    flavor: 'danger'
                }).then(function () {

                    $q.all(_.map($scope.selection.artifacts, function (observable) {
                        return CaseArtifactSrv.api().delete({
                            artifactId: observable._id
                        }, function () {
                            $scope.$emit('observables:observable-removed', observable);
                        }).$promise;
                    }));
                }).then(function (/*responses*/) {
                    NotificationSrv.log('The selected observables have been deleted', 'success');
                }).catch(function (/*err*/) {
                    //NotificationSrv.error('Observable deletion', response.data, response.status);
                });
            };

            // run selected analyzers on selected artifacts
            $scope.runAnalyzerOnSelection = function () {
                var toRun = [];
                var nbArtifacts = $scope.selection.artifacts.length;

                angular.forEach($scope.selection.artifacts, function (element) {
                    angular.forEach($scope.analyzersList.analyzers, function (analyzer) {
                        if (($scope.analyzersList.selected[analyzer.name]) && ($scope.checkDataTypeList(analyzer, element.dataType))) {
                            toRun.push({
                                analyzerId: analyzer.name,
                                artifact: element
                            });
                        }
                    });
                });

                var analyzerIds = _.uniq(_.pluck(toRun, 'analyzerId'));

                CortexSrv.getServers(analyzerIds)
                    .then(function (serverId) {
                        return $q.all(
                            _.map(toRun, function (item) {
                                return CortexSrv.createJob({
                                    cortexId: serverId,
                                    artifactId: item.artifact._id,
                                    analyzerId: item.analyzerId
                                });
                            })
                        );
                    })
                    .then(function () {
                        NotificationSrv.log('Analyzers have been successfully started for ' + nbArtifacts + ' observables', 'success');
                    }, function () {

                    });
            };

            $scope.openArtifact = function (artifact) {
                $state.go('app.case.observables-item', {
                    itemId: artifact._id
                });
            };

            $scope.showReport = function (observable, analyzerId) {
                CortexSrv.getJobs($scope.caseId, observable._id, analyzerId, 1)
                    .then(function (response) {
                        if (!response.data || response.data.length !== 1) {
                            return;
                        }

                        var job = response.data[0];
                        var report = {
                            job: job,
                            template: job.analyzerName || job.analyzerId,
                            content: job.report,
                            status: job.status,
                            startDate: job.startDate,
                            endDate: job.endDate
                        };

                        $uibModal.open({
                            templateUrl: 'views/partials/observables/list/job-report-dialog.html',
                            controller: 'JobReportModalCtrl',
                            controllerAs: '$vm',
                            size: 'max',
                            resolve: {
                                report: function () {
                                    return report;
                                },
                                observable: function () {
                                    return observable;
                                }
                            }
                        });
                    })
                    .catch(function (/*err*/) {
                        NotificationSrv.error('Unable to fetch the analysis report');
                    });
            };

            $scope.getObsResponders = function (observable, force) {
                if (!force && $scope.obsResponders !== null) {
                    return;
                }

                $scope.obsResponders = null;
                CortexSrv.getResponders('case_artifact', observable._id)
                    .then(function (responders) {
                        $scope.obsResponders = responders;
                        return CortexSrv.promntForResponder(responders);
                    })
                    .then(function (response) {
                        if (response && _.isString(response)) {
                            NotificationSrv.log(response, 'warning');
                        } else {
                            return CortexSrv.runResponder(response.id, response.name, 'case_artifact', _.pick(observable, '_id'));
                        }
                    })
                    .then(function (response) {
                        var data = '[' + $filter('fang')(observable.data || observable.attachment.name) + ']';
                        NotificationSrv.log(['Responder', response.data.responderName, 'started successfully on observable', data].join(' '), 'success');
                    })
                    .catch(function (err) {
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('observablesList', err.data, err.status);
                        }
                    });
            };
        }
    )
        .controller('JobReportModalCtrl', function ($uibModalInstance, report, observable) {
            this.report = report;
            this.observable = observable;
            this.close = function () {
                $uibModalInstance.dismiss();
            };
        });

})();

```

`frontend/app/scripts/controllers/case/CaseObservablesExportCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .controller('CaseObservablesExportCtrl', function($scope, clipboard, UtilsSrv) {

            $scope.exportParams = {
                protect: 'fang',
                format: 'csv'
            };

            $scope.getObservableValue = function(observable) {
                if (observable.attachment) {
                    return observable.attachment.name + '|' + observable.attachment.hashes[0];
                } else {
                    return $scope.protect(observable);
                }
            };

            $scope.protect = function(observable) {
                if ($scope.exportParams.protect === 'fang') {
                    return UtilsSrv.fang(observable);
                }

                return observable.data;
            };

            $scope.copyToClipboard = function() {
                var content = $scope.getCSV();
                var copied = content.map(function(item) {
                    return item.data;
                });

                clipboard.copyText(copied.join('\n'));
            };

            $scope.getDataType = function(observable) {
                return observable.attachment ? 'filename|sha256' : observable.dataType;
            };

            $scope.getCSV = function() {
                var format = $scope.exportParams.format,
                    csv = [];

                if(format === 'txt') {
                    angular.forEach($scope.selection.artifacts, function(observable) {
                        csv.push({data: $scope.getObservableValue(observable)});
                    });
                } else if(format === 'csv') {
                    angular.forEach($scope.selection.artifacts, function(observable) {
                        csv.push({data: observable.dataType + ';' + $scope.getObservableValue(observable)});
                    });
                } else if(format === 'misp') {
                    angular.forEach($scope.selection.artifacts, function(observable) {
                        csv.push({data: '*' + $scope.getDataType(observable) + '\t:' + $scope.getObservableValue(observable)});
                    });
                }

                return csv;
            };
        });

})();

```

`frontend/app/scripts/controllers/case/CaseObservablesItemCtrl.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveControllers').controller('CaseObservablesItemCtrl',
        function ($scope, $state, $stateParams, $q, $filter, $timeout, $document, $uibModal, PaginatedQuerySrv, CaseSrv, ModalSrv, SecuritySrv, CaseTabsSrv, CaseArtifactSrv, CortexSrv, PSearchSrv, AnalyzerSrv, NotificationSrv, VersionSrv, TagSrv, appConfig, artifact) {
            var observableId = $stateParams.itemId,
                observableName = 'observable-' + observableId;

            $scope.caseId = $stateParams.caseId;
            $scope.report = null;
            $scope.obsResponders = null;
            $scope.analyzers = {};
            $scope.analyzerJobs = {};
            //$scope.jobs = {};
            $scope.state = {
                'editing': false,
                'isCollapsed': false,
                'dropdownOpen': false,
                'logMissing': ''
            };

            $scope.artifact = artifact;
            $scope.artifact.tlp = $scope.artifact.tlp !== undefined ? $scope.artifact.tlp : -1;
            $scope.analysisEnabled = VersionSrv.hasCortex();
            $scope.cortexServers = $scope.analysisEnabled && appConfig.connectors.cortex.servers;
            $scope.protectDownloadsWith = appConfig.config.protectDownloadsWith;
            $scope.similarArtifactsLimit = 10;

            $scope.editorOptions = {
                lineNumbers: true,
                theme: 'twilight',
                readOnly: 'nocursor',
                lineWrapping: true,
                mode: 'vb'
            };

            $scope.initScope = function (artifact) {

                var promise = $scope.analysisEnabled ? AnalyzerSrv.forDataType(artifact.dataType) : $q.resolve([]);

                promise
                    .then(function (analyzers) {
                        $scope.analyzers = analyzers;
                    }, function () {
                        $scope.analyzers = [];
                    })
                    .finally(function () {
                        if($scope.analysisEnabled) {
                            $scope.jobs = CortexSrv.listJobs($scope, $scope.caseId, observableId, $scope.onJobsChange);
                        }
                    });

                var connectors = $scope.appConfig.connectors;
                if(connectors.cortex && connectors.cortex.enabled) {
                    $scope.actions = new PaginatedQuerySrv({
                        name: 'case-observable-actions',
                        version: 'v1',
                        scope: $scope,
                        streamObjectType: 'action',
                        loadAll: true,
                        sort: ['-startDate'],
                        pageSize: 100,
                        operations: [
                            { '_name': 'getObservable', 'idOrName': artifact.id },
                            { '_name': 'actions' }
                        ],
                        guard: function(updates) {
                            return _.find(updates, function(item) {
                                return (item.base.details.objectType === 'Observable') && (item.base.details.objectId === artifact.id);
                            }) !== undefined;
                        }
                    });
                }
            };

            // Prepare the scope data
            $scope.initScope(artifact);

            $scope.scrollTo = function(hash) {
                $timeout(function() {
                    var el = angular.element(hash)[0];

                    // Scrolling hack using jQuery stuff
                    $('html,body').animate({
                        scrollTop: $(el).offset().top
                    }, 'fast');
                }, 100);
            };

            $scope.onJobsChange = function (updates) {
                $scope.analyzerJobs = {};

                _.each(_.keys($scope.analyzers).sort(), function(analyzerName) {
                    $scope.analyzerJobs[analyzerName] = [];
                });

                angular.forEach($scope.jobs.values, function (job) {
                    if (job.analyzerName in $scope.analyzerJobs) {
                        $scope.analyzerJobs[job.analyzerName].push(job);
                    } else {
                        $scope.analyzerJobs[job.analyzerName] = [job];
                    }
                });

                // Check it a job completed successfully and update the observableId
                if(updates && updates.length > 0) {

                    var statuses = _.pluck(_.map(updates, function(item) {
                        return item.base.details;
                    }), 'status');

                    if(statuses.indexOf('Success') > -1) {
                        CaseArtifactSrv.api().get({
                            'artifactId': observableId
                        }, function (observable) {
                            $scope.artifact = observable;
                        }, function (response) {
                            NotificationSrv.error('ObservableDetails', response.data, response.status);
                            CaseTabsSrv.activateTab('observables');
                        });
                    }
                }
            };

            $scope.showMoreSimilar = function() {
                $scope.similarArtifactsLimit = $scope.similarArtifactsLimit + 10;
            };

            $scope.refreshCurrentJob = function() {
                $scope.loadReport($scope.currentJob);
            };

            $scope.loadReport = function(jobId) {
                $scope.report = {};

                return CortexSrv.getJob(jobId, true)
                    .then(function(response) {
                        var job = response.data;
                        $scope.report = {
                            template: job.analyzerDefinition,
                            content: job.report,
                            status: job.status,
                            startDate: job.startDate,
                            endDate: job.endDate
                        };

                        $scope.currentJob = jobId;
                    });
            };

            $scope.showReport = function (jobId) {

                $scope.loadReport(jobId)
                    .then(function(){
                        $timeout(function() {
                            var reportEl = angular.element('#analysis-report')[0];

                            // Scrolling hack using jQuery stuff
                            $('html,body').animate({
                                scrollTop: $(reportEl).offset().top
                            }, 'fast');
                        }, 500);
                    })
                    .catch(function(/*err*/) {
                        NotificationSrv.error('An expected error occured while fetching the job report');
                    });

                // $scope.report = {};

                // CortexSrv.getJob(jobId, true).then(function(response) {
                //     var job = response.data;
                //     $scope.report = {
                //         template: job.analyzerDefinition,
                //         content: job.report,
                //         status: job.status,
                //         startDate: job.startDate,
                //         endDate: job.endDate
                //     };
                //
                //     $scope.currentJob = jobId;
                //
                //     $timeout(function() {
                //         var reportEl = angular.element('#analysis-report')[0];
                //
                //         // Scrolling hack using jQuery stuff
                //         $('html,body').animate({
                //             scrollTop: $(reportEl).offset().top
                //         }, 'fast');
                //     }, 500);
                //
                // }, function(/*err*/) {
                //     NotificationSrv.error('An expected error occured while fetching the job report');
                // });
            };

            $scope.openArtifact = function (a) {
                $state.go('app.case.observables-item', {
                    caseId: a.stats['case']._id,
                    itemId: a._id
                });
            };

            $scope.getLabels = function (selection) {
                var labels = [];

                angular.forEach(selection, function (label) {
                    labels.push(label.text);
                });

                return labels;
            };

            $scope.updateField = function (fieldName, newValue) {
                var field = {};
                field[fieldName] = newValue;

                return CaseArtifactSrv.api()
                    .update({
                        artifactId: $scope.artifact.id
                    }, field)
                    .$promise
                    .then(function () {
                        NotificationSrv.log('Observable has been updated', 'success');
                        return CaseArtifactSrv.api()
                            .get({
                                artifactId: $scope.artifact.id
                            }).$promise;
                    })
                    .then(function(response) {
                        $scope.artifact = response.toJSON();

                        if(fieldName === 'ignoreSimilarity' && !!!newValue) {
                            $scope.getSimilarity();
                        }
                    })
                    .catch(function (response) {
                        NotificationSrv.error('ObservableDetails', response.data, response.status);
                    });
            };

            $scope._runAnalyzer = function (serverId, analyzerId, artifactId) {
                return CortexSrv.createJob({
                    cortexId: serverId,
                    artifactId: artifactId,
                    analyzerId: analyzerId
                });
            };

            $scope.runAnalyzer = function (analyzerName, serverId) {
                var artifactName = $scope.artifact.data || $scope.artifact.attachment.name;

                var promise = serverId ? $q.resolve(serverId) : CortexSrv.getServers([analyzerName]);

                promise.then(function (serverId) {
                        return $scope._runAnalyzer(serverId, analyzerName, $scope.artifact._id);
                    })
                    .then(function () {
                        NotificationSrv.log('Analyzer ' + analyzerName + ' has been successfully started for observable: ' + artifactName, 'success');
                    }, function (response) {
                        if (response && response.status) {
                            NotificationSrv.log('Unable to run analyzer ' + analyzerName + ' for observable: ' + artifactName, 'error');
                        }
                    });
            };

            $scope.runAll = function () {
                var artifactId = $scope.artifact._id;
                var artifactName = $scope.artifact.data || $scope.artifact.attachment.name;
                var analyzerIds = _.pluck(_.filter($scope.analyzers, function (a) {
                    return a.active === true;
                }), 'name');

                CortexSrv.getServers(analyzerIds)
                    .then(function (serverId) {
                        return $q.all(_.map(analyzerIds, function (analyzerId) {
                            return $scope._runAnalyzer(serverId, analyzerId, artifactId);
                        }));
                    })
                    .then(function () {
                        NotificationSrv.log('Analyzers has been successfully started for observable: ' + artifactName, 'success');
                    });
            };

            $scope.getObsResponders = function(observable, force) {
                if(!force && $scope.obsResponders !== null) {
                   return;
                }

                $scope.obsResponders = null;
                CortexSrv.getResponders('case_artifact', observable._id)
                  .then(function(responders) {
                      $scope.obsResponders = responders;
                      return CortexSrv.promntForResponder(responders);
                  })
                  .then(function(response) {
                      if(response && _.isString(response)) {
                          NotificationSrv.log(response, 'warning');
                      } else {
                          return CortexSrv.runResponder(response.id, response.name, 'case_artifact', _.pick(observable, '_id'));
                      }
                  })
                  .then(function(response){
                      var data = '['+$filter('fang')(observable.data || observable.attachment.name)+']';
                      NotificationSrv.log(['Responder', response.data.responderName, 'started successfully on observable', data].join(' '), 'success');
                  })
                  .catch(function(err) {
                      if(err && !_.isString(err)) {
                          NotificationSrv.error('Observable Details', err.data, err.status);
                      }
                  });
            };

            $scope.getTags = function(query) {
                return TagSrv.autoComplete(query);
            };

            $scope.loadShares = function () {
                return CaseArtifactSrv.getShares($scope.caseId, observableId)
                    .then(function(response) {
                        $scope.shares = response.data;
                    });
            };

            $scope.removeShare = function(share) {
                var modalInstance = ModalSrv.confirm(
                    'Remove observable share',
                    'Are you sure you want to remove this sharing rule?', {
                        okText: 'Yes, remove it',
                        flavor: 'danger'
                    }
                );

                modalInstance.result
                    .then(function() {
                        return CaseArtifactSrv.removeShare($scope.artifact.id, share);
                    })
                    .then(function(/*response*/) {
                        $scope.loadShares();
                        NotificationSrv.log('Observable sharings updated successfully', 'success');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Observable sharings update failed', err.status);
                        }
                    });
            };

            $scope.addTaskShare = function() {
                var modalInstance = $uibModal.open({
                    animation: true,
                    templateUrl: 'views/components/sharing/sharing-modal.html',
                    controller: 'SharingModalCtrl',
                    controllerAs: '$modal',
                    size: 'lg',
                    resolve: {
                        shares: function() {
                            return CaseSrv.getShares($scope.caseId)
                                .then(function(response) {
                                    var caseShares = response.data;
                                    var taskShares = _.pluck($scope.shares, 'organisationName');

                                    var shares = _.filter(caseShares, function(item) {
                                        return taskShares.indexOf(item.organisationName) === -1;
                                    });

                                    return angular.copy(shares);
                                });
                        },

                    }
                });

                modalInstance.result
                    .then(function(orgs) {
                        return CaseArtifactSrv.addShares(observableId, orgs);
                    })
                    .then(function(/*response*/) {
                        $scope.loadShares();
                        NotificationSrv.log('Observable sharings updated successfully', 'success');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Observable sharings update failed', err.status);
                        }
                    });
            };

            $scope.getSimilarity = function() {
                CaseArtifactSrv.similar(observableId, {
                    range: 'all',
                    sort: ['-startDate']
                }).then(function(response) {
                    $scope.similarArtifacts = response;
                });
            };

            this.$onInit = function () {

                // Add tab
                CaseTabsSrv.addTab(observableName, {
                    name: observableName,
                    label: artifact.data || artifact.attachment.name,
                    closable: true,
                    state: 'app.case.observables-item',
                    params: {
                        itemId: artifact.id
                    }
                });

                // Select tab
                $timeout(function() {
                    CaseTabsSrv.activateTab(observableName);
                    $('html,body').animate({scrollTop: $('body').offset().top}, 'fast');
                }, 0);

                // Fetch similar cases
                if(!$scope.artifact.ignoreSimilarity) {
                    $scope.getSimilarity();
                }

                if(SecuritySrv.checkPermissions(['manageShare'], $scope.userPermissions)) {
                    $scope.loadShares();
                }
            };

        }
    );

})();

```

`frontend/app/scripts/controllers/case/CaseProceduresCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .controller('CaseProceduresCtrl', CaseProceduresCtrl);

    function CaseProceduresCtrl($scope, $state, $stateParams, $uibModal, ModalUtilsSrv, AttackPatternSrv, FilteringSrv, CaseTabsSrv, ProcedureSrv, PaginatedQuerySrv, NotificationSrv) {
        var self = this;

        CaseTabsSrv.activateTab($state.current.data.tab);

        this.caseId = $stateParams.caseId;
        this.tactics = AttackPatternSrv.tactics.values;
        this.expanded = {};

        this.$onInit = function() {
            self.filtering = new FilteringSrv('procedure', 'procedure.list', {
                version: 'v1',
                defaults: {
                    showFilters: true,
                    showStats: false,
                    pageSize: 15,
                    sort: ['-occurDate'],
                },
                defaultFilter: []
            });

            self.filtering.initContext(self.caseId)
                .then(function() {
                    self.load();

                    $scope.$watchCollection('$vm.list.pageSize', function (newValue) {
                        self.filtering.setPageSize(newValue);
                    });
                });
        };

        this.addProcedure = function(procedure) {
            var modalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'views/partials/case/procedures/add-procedure.modal.html',
                controller: 'AddProcedureModalCtrl',
                controllerAs: '$modal',
                size: 'lg',
                resolve: {
                    caseId: function() {
                        return self.caseId;
                    },
                    procedure: function() {
                        return angular.copy(procedure);
                    }
                }
            });

            return modalInstance.result
                .then(function() {
                    self.load();
                })
                .catch(function(err) {
                    if(err && !_.isString(err)) {
                        NotificationSrv.error('ProcedureCtrl', err.data, err.status);
                    }
                });
        };

        this.updateField = function(procedure, field, reload) {
            var data = {};
            data[field] = procedure[field];

            ProcedureSrv.update(procedure._id, data)
                .then(function(/*response*/) {
                    if(reload) {
                        self.load();
                    }
                }).catch(function(err) {
                    NotificationSrv.error('ProcedureCtrl', err.data, err.status);
                });
        };

        this.load = function() {
            self.list = new PaginatedQuerySrv({
                name: 'case-procedures',
                root: self.caseId,
                version: 'v1',
                scope: $scope,
                sort: self.filtering.context.sort,
                loadAll: false,
                pageSize: self.filtering.context.pageSize,
                filter: self.filtering.buildQuery(),
                operations: [
                    {'_name': 'getCase', "idOrName": self.caseId},
                    {'_name': 'procedures'}
                ],
                extraData: ['pattern', 'patternParent']
            });
        };

        self.remove = function(procedure) {
            ModalUtilsSrv.confirm('Delete TTP', 'Are you sure you want to delete the selected tactic, technique and procedure?', {
                okText: 'Yes, remove it',
                flavor: 'danger'
            }).then(function() {
                ProcedureSrv.remove(procedure._id)
                    .then(function() {
                        self.load();
                        NotificationSrv.success('TTP has been successfully removed');
                    })
                    .catch(function(err) {
                        NotificationSrv.error('Procedure List', err.data, err.status);
                    });
            });
        };

        self.showPattern = function(patternId) {
            $uibModal.open({
                animation: true,
                templateUrl: 'views/partials/admin/attack/view.html',
                controller: 'AttackPatternDialogCtrl',
                controllerAs: '$modal',
                size: 'max',
                resolve: {
                    pattern: function() {
                        return AttackPatternSrv.get(patternId);
                    }
                }
            });
        };

        this.toggleFilters = function () {
            this.filtering.toggleFilters();
        };


        this.filter = function () {
            self.filtering.filter().then(this.applyFilters);
        };

        this.clearFilters = function () {
            this.filtering.clearFilters()
                .then(self.search);
        };

        this.addFilter = function (field, value) {
            self.filtering.addFilter(field, value).then(this.applyFilters);
        };

        this.removeFilter = function (index) {
            self.filtering.removeFilter(index)
                .then(self.search);
        };

        this.search = function () {
            self.load();
            self.filtering.storeContext();
        };

        this.addFilterValue = function (field, value) {
            this.filtering.addFilterValue(field, value);
            this.search();
        };

        self.filterBy = function(field, value) {
            self.filtering.clearFilters()
                .then(function() {
                    self.addFilterValue(field, value);
                });
        };

        this.sortBy = function(sort) {
            self.list.sort = sort;
            self.list.update();
            self.filtering.setSort(sort);
        };

        self.sortByField = function(field) {
            var context = this.filtering.context;
            var currentSort = Array.isArray(context.sort) ? context.sort[0] : context.sort;
            var sort = null;

            if(currentSort.substr(1) !== field) {
                sort = ['+' + field];
            } else {
                sort = [(currentSort === '+' + field) ? '-'+field : '+'+field];
            }

            self.list.sort = sort;
            self.list.update();
            self.filtering.setSort(sort);
        };
    }
}());

```

`frontend/app/scripts/controllers/case/CaseReopenModalCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers')
        .controller('CaseReopenModalCtrl', function($scope, $uibModalInstance, NotificationSrv) {

            $scope.cancel = function() {
                $uibModalInstance.dismiss();
            };

            $scope.confirm = function() {
                $scope.updateField('status', 'Open')
                    .then(function(caze) {
                        $scope.caze = caze;

                        NotificationSrv.log('The case #' + caze.number + ' has been reopened', 'success');
                    });
                $uibModalInstance.close();
            };
        });
})();

```

`frontend/app/scripts/controllers/case/CaseSharingCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('CaseSharingCtrl',
        function($scope, $state, $stateParams, $uibModal, $timeout, ModalSrv, CaseSrv, CaseTabsSrv, NotificationSrv, organisations, profiles, shares) {
            var self = this;

            this.caseId = $stateParams.caseId;

            this.organisations = organisations;
            this.profiles = profiles;
            this.shares = shares;

            var tabName = 'sharing-' + this.caseId;

            this.$onInit = function() {
                // Add tab
                CaseTabsSrv.addTab(tabName, {
                    name: tabName,
                    label: 'Sharing',
                    closable: true,
                    state: 'app.case.sharing',
                    params: {}
                });

                // Select tab
                $timeout(function() {
                    CaseTabsSrv.activateTab(tabName);
                }, 0);

                self.enableAddButton = self.getRemainingOrgs().length > 0;
            };

            this.load = function() {
                return CaseSrv.getShares(this.caseId)
                    .then(function(response) {
                        self.shares = response.data;
                        self.enableAddButton = self.getRemainingOrgs().length > 0;
                    });
            };

            this.getRemainingOrgs = function() {
                var organisationNames = _.pluck(self.organisations, 'name');
                var shareNames = _.pluck(self.shares, 'organisationName');

                return _.filter(organisationNames, function(name) {
                    return shareNames.indexOf(name) === -1;
                });
            };

            this.shareCase = function() {

                var modalInstance = $uibModal.open({
                    templateUrl: 'views/partials/case/share/case.share.modal.html',
                    controller: 'CaseShareModalCtrl',
                    controllerAs: '$modal',
                    resolve: {
                        organisations: function() {
                            return self.getRemainingOrgs();
                        },
                        profiles: function() {
                            return self.profiles;
                        },
                        shares: function() {
                            return self.shares;
                        }
                    }
                });

                modalInstance.result.then(function(shares) {
                    CaseSrv.setShares(self.caseId, shares)
                        .then(function(/*response*/) {
                            self.load();
                            NotificationSrv.log('Case sharings updated successfully', 'success');
                        })
                        .catch(function(err) {
                            if(err && !_.isString(err)) {
                                NotificationSrv.error('Error', 'Case sharings update failed', err.status);
                            }
                        });
                });
            };

            this.removeShare = function(share) {
                var modalInstance = ModalSrv.confirm(
                    'Remove case share',
                    'Are you sure you want to remove this sharing rule?', {
                        okText: 'Yes, remove it',
                        flavor: 'danger'
                    }
                );

                modalInstance.result
                    .then(function() {
                        return CaseSrv.removeShare(self.caseId, share);
                    })
                    .then(function(/*response*/) {
                        self.load();
                        NotificationSrv.log('Case sharings updated successfully', 'success');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Case sharings update failed', err.status);
                        }
                    });
            };

            this.updateShareProfile = function(org, profile) {
                CaseSrv.updateShare(org, { profile: profile })
                    .then(function(/*response*/) {
                        self.load();
                        NotificationSrv.log('Case sharings updated successfully', 'success');
                    })
                    .catch(function(err) {
                        self.load();
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Case sharings update failed', err.status);
                        }
                    });
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/case/CaseStatsCtrl.js`:

```js
/**
 * Controller for About TheHive modal page
 */
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('CaseStatsCtrl',
        function($rootScope, $scope, $stateParams, $timeout, StatSrv, StreamQuerySrv) {
            var self = this;

            this.byResolution = {};
            this.byStatus = {};
            this.byTags = {};

            self.$onInit = function() {
                // Get stats by tags
                StreamQuerySrv('v1', [
                    { _name: 'listCase' },
                    {
                       _name: 'aggregation',
                       _agg: 'field',
                       _field: 'tags',
                       _select: [
                           { _agg: 'count' }
                       ],
                       _order: [ '-count' ],
                       _size: 5
                   }
                ], {
                    scope: $scope,
                    rootId: 'any',
                    objectType: 'case',
                    query: {
                        params: {
                            name: 'case-by-tags-stats'
                        }
                    },
                    onUpdate: function(data) {
                        self.byTags = StatSrv.prepareResult(data);
                    }
                });

                // Get stats by status
                StreamQuerySrv('v1', [
                    { _name: 'listCase' },
                    {
                       _name: 'aggregation',
                       _agg: 'field',
                       _field: 'status',
                       _select: [
                           { _agg: 'count' }
                       ]
                   }
                ], {
                    scope: $scope,
                    rootId: 'any',
                    objectType: 'case',
                    query: {
                        params: {
                            name: 'case-by-status-stats'
                        }
                    },
                    onUpdate: function(data) {
                        self.byStatus = StatSrv.prepareResult(data);
                    }
                });

                // Get stats by resolution status
                StreamQuerySrv('v1', [
                    { _name: 'listCase' },
                    {
                       _name: 'aggregation',
                       _agg: 'field',
                       _field: 'resolutionStatus',
                       _select: [
                           { _agg: 'count' }
                       ]
                   }
                ], {
                    scope: $scope,
                    rootId: 'any',
                    objectType: 'case',
                    query: {
                        params: {
                            name: 'case-by-resolution-status-stats'
                        }
                    },
                    onUpdate: function(data) {
                        self.byResolution = StatSrv.prepareResult(data);
                    }
                });
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/case/CaseTasksCtrl.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveControllers')
        .controller('CaseTasksCtrl', CaseTasksCtrl);

    function CaseTasksCtrl($scope, $state, $stateParams, $q, AuthenticationSrv, ModalUtilsSrv, FilteringSrv, CaseTabsSrv, PaginatedQuerySrv, CaseTaskSrv, NotificationSrv, CortexSrv, AppLayoutSrv) {

        CaseTabsSrv.activateTab($state.current.data.tab);

        $scope.caseId = $stateParams.caseId;
        $scope.state = {
            isNewTask: false,
            showGrouped: !!AppLayoutSrv.layout.groupTasks
        };
        $scope.newTask = {
            status: 'Waiting'
        };
        $scope.taskResponders = null;
        $scope.collapseOptions = {};

        $scope.selection = [];
        $scope.menu = {
            selectAll: false
        };

        this.$onInit = function () {
            $scope.filtering = new FilteringSrv('task', 'task.list', {
                version: 'v1',
                defaults: {
                    showFilters: true,
                    showStats: false,
                    pageSize: 15,
                    sort: ['-flag', '+order', '+startDate', '+title'],
                },
                defaultFilter: []
            });

            $scope.filtering.initContext($scope.caseId)
                .then(function () {
                    $scope.load();

                    $scope.$watch('list.pageSize', function (newValue) {
                        $scope.filtering.setPageSize(newValue);
                    });
                });
        };

        $scope.getAssignableUsers = function (taskId) {
            return [
                { _name: 'getTask', idOrName: taskId },
                { _name: 'assignableUsers' }
            ];
        };

        $scope.load = function () {
            $scope.list = new PaginatedQuerySrv({
                name: 'case-tasks',
                root: $scope.caseId,
                objectType: 'task',
                streamObjectType: 'case_task',
                version: 'v1',
                scope: $scope,
                sort: $scope.filtering.context.sort,
                loadAll: false,
                limitedCount: true,
                pageSize: $scope.filtering.context.pageSize,
                filter: $scope.filtering.buildQuery(),
                baseFilter: {
                    _ne: {
                        _field: 'status',
                        _value: 'Cancel'
                    }
                },
                operations: [
                    { '_name': 'getCase', "idOrName": $scope.caseId },
                    { '_name': 'tasks' }
                ],
                extraData: ['shareCount', 'actionRequired'],
                //extraData: ['isOwner', 'shareCount'],
                onUpdate: function () {
                    $scope.buildTaskGroups($scope.list.values);
                    $scope.resetSelection();
                }
            });
        };

        $scope.resetSelection = function () {
            if ($scope.menu.selectAll) {
                $scope.selectAll();
            } else {
                $scope.selection = [];
                $scope.menu.selectAll = false;
                $scope.updateMenu();
            }
        };

        $scope.updateMenu = function () {
            // Handle flag/unflag menu items
            var temp = _.uniq(_.pluck($scope.selection, 'flag'));
            $scope.menu.unflag = temp.length === 1 && temp[0] === true;
            $scope.menu.flag = temp.length === 1 && temp[0] === false;

            // Handle start menu item
            temp = _.uniq(_.pluck($scope.selection, 'status'));
            $scope.menu.start = temp.length === 1 && temp[0] === 'Waiting';

            // Handle close menu item
            temp = _.uniq(_.pluck($scope.selection, 'status'));
            $scope.menu.close = temp.indexOf('Completed') === -1;

            // Handle reopen menu item
            temp = _.uniq(_.pluck($scope.selection, 'status'));
            $scope.menu.reopen = temp.length === 1 && temp[0] === 'Completed';

            $scope.menu.delete = $scope.selection.length > 0;
        };

        $scope.select = function (task) {
            if (task.selected) {
                $scope.selection.push(task);
            } else {
                $scope.selection = _.reject($scope.selection, function (item) {
                    return item._id === task._id;
                });
            }
            $scope.updateMenu();
        };

        $scope.selectAll = function () {
            var selected = $scope.menu.selectAll;

            _.each($scope.list.values, function (item) {
                // if(SecuritySrv.checkPermissions(['manageCase'], item.extraData.permissions)) {
                item.selected = selected;
                // }
            });

            if (selected) {
                $scope.selection = _.filter($scope.list.values, function (item) {
                    return !!item.selected;
                });
            } else {
                $scope.selection = [];
            }

            $scope.updateMenu();
        };

        $scope.toggleStats = function () {
            $scope.filtering.toggleStats();
        };

        $scope.toggleFilters = function () {
            $scope.filtering.toggleFilters();
        };

        $scope.filter = function () {
            $scope.filtering.filter().then($scope.applyFilters);
        };

        $scope.clearFilters = function () {
            $scope.filtering.clearFilters()
                .then($scope.search);
        };

        $scope.removeFilter = function (index) {
            $scope.filtering.removeFilter(index)
                .then($scope.search);
        };

        $scope.search = function () {
            $scope.load();
            $scope.filtering.storeContext();
        };
        $scope.addFilterValue = function (field, value) {
            $scope.filtering.addFilterValue(field, value);
            $scope.search();
        };

        $scope.filterBy = function (field, value) {
            $scope.filtering.clearFilters()
                .then(function () {
                    $scope.addFilterValue(field, value);
                });
        };

        $scope.filterMyTasks = function () {
            $scope.filtering.clearFilters()
                .then(function () {
                    var currentUser = AuthenticationSrv.currentUser;
                    $scope.filtering.addFilter({
                        field: 'assignee',
                        type: 'user',
                        value: {
                            list: [{
                                text: currentUser.login,
                                label: currentUser.name
                            }]
                        }
                    });
                    $scope.search();
                });
        };

        $scope.toggleGroupedView = function () {
            $scope.state.showGrouped = !$scope.state.showGrouped;

            AppLayoutSrv.groupTasks($scope.state.showGrouped);
        };

        $scope.buildTaskGroups = function (tasks) {
            // Sort tasks by order
            var orderedTasks = _.sortBy(_.map(tasks, function (t) {
                return _.pick(t, 'group', 'order');
            }), 'order');
            var groups = [];

            // Get group names by keeping the group orders
            _.each(orderedTasks, function (task) {
                if (groups.indexOf(task.group) === -1) {
                    groups.push(task.group);
                }
            });

            var groupedTasks = [];
            _.each(groups, function (group) {
                groupedTasks.push({
                    group: group,
                    tasks: _.filter(tasks, function (t) {
                        return t.group === group;
                    })
                });
            });

            $scope.groups = groups;
            $scope.groupedTasks = groupedTasks;
        };

        $scope.showTask = function (taskId) {
            $state.go('app.case.tasks-item', {
                itemId: taskId
            });
        };

        $scope.updateField = function (fieldName, newValue, task) {
            var field = {};
            field[fieldName] = newValue;
            return CaseTaskSrv.update({
                taskId: task._id
            }, field, function () { }, function (response) {
                NotificationSrv.error('taskList', response.data, response.status);
            });
        };

        $scope.addTask = function () {
            CaseTaskSrv.save({
                'caseId': $scope.caseId,
                'flag': false
            }, $scope.newTask, function () {
                $scope.isNewTask = false;
                $scope.newTask.title = '';
                $scope.newTask.group = '';
                NotificationSrv.success('Task has been successfully added');
            }, function (response) {
                NotificationSrv.error('taskList', response.data, response.status);
            });
        };

        $scope.removeTask = function (task) {

            ModalUtilsSrv.confirm('Delete task', 'Are you sure you want to delete the selected task?', {
                okText: 'Yes, remove it',
                flavor: 'danger'
            }).then(function () {
                CaseTaskSrv.update({
                    'taskId': task._id
                }, {
                    status: 'Cancel'
                }, function () {
                    $scope.$emit('tasks:task-removed', task);
                    NotificationSrv.success('Task has been successfully removed');
                }, function (response) {
                    NotificationSrv.error('taskList', response.data, response.status);
                });
            });
        };

        $scope.bulkUpdate = function (ids, patch) {
            return CaseTaskSrv.bulkUpdate(ids, patch)
                .then(function (/*responses*/) {
                    NotificationSrv.log('Selected tasks have been updated successfully', 'success');
                })
                .catch(function (err) {
                    NotificationSrv.error('Bulk update tasks', err.data, err.status);
                });
        }

        $scope.bulkFlag = function (flag) {
            var ids = _.pluck($scope.selection, '_id');

            return $scope.bulkUpdate(ids, { flag: flag });
        }

        $scope.bulkStatus = function (status) {
            var ids = _.pluck($scope.selection, '_id');

            return $scope.bulkUpdate(ids, { status: status });
        }

        $scope.bulkRemove = function () {
            var ids = _.pluck($scope.selection, '_id');

            ModalUtilsSrv.confirm('Delete selected tasks', 'Are you sure you want to delete the selected tasks?', {
                okText: 'Yes, proceed',
                flavor: 'danger'
            }).then(function () {
                return CaseTaskSrv.bulkUpdate(ids, { status: 'Cancel' })
                    .then(function (/*responses*/) {
                        NotificationSrv.log('Selected tasks have been successfully removed', 'success');

                        _.each($scope.selection, function (task) {
                            $scope.$emit('tasks:task-removed', task);
                        });
                    })
                    .catch(function (err) {
                        NotificationSrv.error('Bulk remove tasks', err.data, err.status);
                    });
            }).catch(function (err) {
                if (err && !_.isString(err)) {
                    NotificationSrv.error('Bulk remove tasks', err.data, err.status);
                }
            })
        }

        // open task tab with its details
        $scope.startTask = function (task) {
            var taskId = task._id;

            if (task.status === 'Waiting') {
                $scope.updateTaskStatus(taskId, 'InProgress')
                    .then(function (/*response*/) {
                        $scope.showTask(taskId);
                    });
            } else {
                $scope.showTask(taskId);
            }
        };

        $scope.openTask = function (task) {
            if (task.status === 'Completed') {
                $scope.updateTaskStatus(task._id, 'InProgress')
                    .then(function (/*response*/) {
                        $scope.showTask(task._id);
                    });
            }
        };

        $scope.closeTask = function (task) {
            if (task.status === 'InProgress') {
                $scope.updateTaskStatus(task._id, 'Completed')
                    .then(function () {
                        NotificationSrv.success('Task has been successfully closed');
                    });
            }
        };

        $scope.updateTaskStatus = function (taskId, status) {
            var defer = $q.defer();

            CaseTaskSrv.update({
                'taskId': taskId
            }, {
                'status': status
            }, function (data) {
                defer.resolve(data);
            }, function (response) {
                NotificationSrv.error('taskList', response.data, response.status);
                defer.reject(response);
            });

            return defer.promise;
        };

        $scope.getTaskResponders = function (task, force) {
            if (!force && $scope.taskResponders !== null) {
                return;
            }

            $scope.taskResponders = null;
            CortexSrv.getResponders('case_task', task._id)
                .then(function (responders) {
                    $scope.taskResponders = responders;
                    return CortexSrv.promntForResponder(responders);
                })
                .then(function (response) {
                    if (response && _.isString(response)) {
                        NotificationSrv.log(response, 'warning');
                    } else {
                        return CortexSrv.runResponder(response.id, response.name, 'case_task', _.pick(task, '_id'));
                    }
                })
                .then(function (response) {
                    NotificationSrv.success(['Responder', response.data.responderName, 'started successfully on task', task.title].join(' '));
                })
                .catch(function (err) {
                    if (err && !_.isString(err)) {
                        NotificationSrv.error('taskList', err.data, err.status);
                    }
                });
        };

        // $scope.runResponder = function(responderId, responderName, task) {
        //     CortexSrv.runResponder(responderId, responderName, 'case_task', _.pick(task, '_id'))
        //       .then(function(response) {
        //           NotificationSrv.success(['Responder', response.data.responderName, 'started successfully on task', task.title].join(' '));
        //       })
        //       .catch(function(response) {
        //           if(response && !_.isString(response)) {
        //               NotificationSrv.error('taskList', response.data, response.status);
        //           }
        //       });
        // };
    }
}());

```

`frontend/app/scripts/controllers/case/CaseTasksItemCtrl.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveControllers').controller('CaseTasksItemCtrl',
        function ($q, $scope, $rootScope, $state, $stateParams, $timeout, $uibModal, StreamSrv, PaginatedQuerySrv, SecuritySrv, ModalSrv, CaseSrv, AuthenticationSrv, OrganisationSrv, CaseTabsSrv, CaseTaskSrv, PSearchSrv, TaskLogSrv, NotificationSrv, CortexSrv, StatSrv, task) {
            var caseId = $stateParams.caseId,
                taskId = $stateParams.itemId;

            // Initialize controller
            $scope.task = task;
            $scope.tabName = 'task-' + task._id;
            $scope.taskResponders = null;

            $scope.assignableUsersQuery = [
                {_name: 'getTask', idOrName: task._id},
                {_name: 'assignableUsers'}
            ];

            $scope.loading = false;
            $scope.newLog = {
                message: ''
            };
            $scope.sortOptions = {
                '+date': 'Oldest first',
                '-date': 'Newest first'
            };
            $scope.state = {
                editing: false,
                isCollapsed: false,
                dropdownOpen: false,
                attachmentCollapsed: true,
                logMissing: '',
                sort: '-date'
            };

            $scope.markdownEditorOptions = {
                iconlibrary: 'fa',
                addExtraButtons: true,
                resize: 'vertical'
            };

            $scope.initScope = function () {

                $scope.logs = new PaginatedQuerySrv({
                    name: 'case-task-logs',
                    root: caseId,
                    objectType: 'case_task_log',
                    version: 'v1',
                    scope: $scope,
                    sort: $scope.state.sort,
                    loadAll: false,
                    pageSize: 10,
                    operations: [
                        {
                            '_name': 'getTask',
                            'idOrName': taskId
                        },
                        {
                            '_name': 'logs'
                        }
                    ],
                    extraData: ['actionCount']
                });

                var connectors = $scope.appConfig.connectors;
                if(connectors.cortex && connectors.cortex.enabled) {
                    $scope.actions = new PaginatedQuerySrv({
                        name: 'case-task-actions',
                        version: 'v1',
                        scope: $scope,
                        streamObjectType: 'action',
                        loadAll: true,
                        sort: ['-startDate'],
                        pageSize: 100,
                        operations: [
                            { '_name': 'getTask', 'idOrName': taskId },
                            { '_name': 'actions' }
                        ],
                        guard: function(updates) {
                            return _.find(updates, function(item) {
                                return (item.base.details.objectType === 'Task') && (item.base.details.objectId === taskId);
                            }) !== undefined;
                        }
                    });
                }
            };

            $scope.switchFlag = function () {
                if ($scope.task.flag === undefined || $scope.task.flag === false) {
                    $scope.task.flag = true;
                    $scope.updateField('flag', true);
                } else {
                    $scope.task.flag = false;
                    $scope.updateField('flag', false);
                }
            };

            $scope.updateField = function (fieldName, newValue) {
                var field = {};
                field[fieldName] = newValue;
                return CaseTaskSrv.update({
                    taskId: $scope.task._id
                }, field, function () {}, function (response) {
                    NotificationSrv.error('taskDetails', response.data, response.status);
                });
            };

            $scope.closeTask = function () {
                $scope.task.status = 'Completed';
                $scope.updateField('status', 'Completed');

                CaseTabsSrv.removeTab($scope.tabName);
                $state.go('app.case.tasks', {
                    caseId: $scope.caseId
                });
            };

            $scope.openTask = function() {
                $scope.task.status = 'InProgress';
                $scope.updateField('status', 'InProgress');
            };

            $scope.startTask = function() {
                var taskId = $scope.task._id;

                CaseTaskSrv.update({
                    'taskId': taskId
                }, {
                    'status': 'InProgress'
                }, function(/*data*/) {
                    // $scope.task = data;
                    $scope.reloadTask();
                }, function(response) {
                    NotificationSrv.error('taskDetails', response.data, response.status);
                });
            };

            $scope.showLogEditor = function () {
                $scope.adding = true;
                $rootScope.$broadcast('beforeNewLogShow');
            };

            $scope.cancelAddLog = function() {
                // Switch to editor mode instead of preview mode
                $rootScope.markdownEditorObjects.newLog.hidePreview();
                $scope.adding = false;
            };

            $scope.addLog = function () {
                $scope.loading = true;

                if ($scope.state.attachmentCollapsed || !$scope.newLog.attachment) {
                    delete $scope.newLog.attachment;
                }

                TaskLogSrv.save({
                    'taskId': $scope.task._id
                }, $scope.newLog, function () {
                    if($scope.task.status === 'Waiting') {
                        // Reload the task
                        $scope.reloadTask();
                    }

                    delete $scope.newLog.attachment;
                    $scope.state.attachmentCollapsed = true;
                    $scope.newLog.message = '';

                    $rootScope.markdownEditorObjects.newLog.hidePreview();
                    $scope.adding = false;
                    // removeAllFiles is added by dropzone directive as control
                    $scope.state.removeAllFiles();

                    $scope.loading = false;
                }, function (response) {
                    NotificationSrv.error('taskDetails', response.data, response.status);
                    $scope.loading = false;
                });

                return true;
            };

            $scope.sortBy = function(sort) {
                $scope.state.sort = sort;
                $scope.logs.sort = sort;
                $scope.logs.update();
            };

            $scope.scrollTo = function(hash) {
                $timeout(function() {
                    var el = angular.element(hash)[0];

                    // Scrolling hack using jQuery stuff
                    $('html,body').animate({
                        scrollTop: $(el).offset().top
                    }, 'fast');
                }, 100);
            };

            $scope.getTaskResponders = function(force) {
                if(!force && $scope.taskResponders !== null) {
                   return;
                }

                $scope.taskResponders = null;
                CortexSrv.getResponders('case_task', $scope.task._id)
                  .then(function(responders) {
                      $scope.taskResponders = responders;
                      return CortexSrv.promntForResponder(responders);
                  })
                  .then(function(response) {
                      if(response && _.isString(response)) {
                          NotificationSrv.log(response, 'warning');
                      } else {
                          return CortexSrv.runResponder(response.id, response.name, 'case_task', _.pick($scope.task, '_id'));
                      }
                  })
                  .then(function(response){
                      NotificationSrv.log(['Responder', response.data.responderName, 'started successfully on task', $scope.task.title].join(' '), 'success');
                  })
                  .catch(function(err) {
                      if(err && !_.isString(err)) {
                          NotificationSrv.error('taskDetails', err.data, err.status);
                      }
                  });
            };

            $scope.reloadTask = function() {
                return CaseTaskSrv.getById($scope.task._id)
                    .then(function(data) {
                        $scope.task = data;
                    })
                    .catch(function(response) {
                        NotificationSrv.error('taskDetails', response.data, response.status);
                    });
            };

            $scope.loadShares = function () {
                if(SecuritySrv.checkPermissions(['manageShare'], $scope.userPermissions)) {
                    return CaseTaskSrv.getShares(caseId, taskId)
                        .then(function(response) {

                            // Add action required flag to shares
                            _.each(response.data, function(share) {
                                share.actionRequired = !!$scope.task.extraData.actionRequiredMap[share.organisationName];
                            });

                            $scope.shares = response.data;
                        });
                }
            };

            $scope.removeShare = function(share) {
                var modalInstance = ModalSrv.confirm(
                    'Remove task share',
                    'Are you sure you want to remove this sharing rule?', {
                        okText: 'Yes, remove it',
                        flavor: 'danger'
                    }
                );

                modalInstance.result
                    .then(function() {
                        return CaseTaskSrv.removeShare($scope.task._id, share);
                    })
                    .then(function(/*response*/) {
                        $scope.loadShares();
                        NotificationSrv.log('Task sharings updated successfully', 'success');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Task sharings update failed', err.status);
                        }
                    });
            };

            $scope.addTaskShare = function() {
                var modalInstance = $uibModal.open({
                    animation: true,
                    templateUrl: 'views/components/sharing/sharing-modal.html',
                    controller: 'SharingModalCtrl',
                    controllerAs: '$modal',
                    size: 'lg',
                    resolve: {
                        shares: function() {
                            return CaseSrv.getShares(caseId)
                                .then(function(response) {
                                    var caseShares = response.data;
                                    var taskShares = _.pluck($scope.shares, 'organisationName');

                                    var shares = _.filter(caseShares, function(item) {
                                        return taskShares.indexOf(item.organisationName) === -1;
                                    });

                                    return angular.copy(shares);
                                });
                        },

                    }
                });

                modalInstance.result
                    .then(function(orgs) {
                        return CaseTaskSrv.addShares(taskId, orgs);
                    })
                    .then(function(/*response*/) {
                        $scope.loadShares();
                        NotificationSrv.log('Task sharings updated successfully', 'success');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Task sharings update failed', err.status);
                        }
                    });
            };



            $scope.showAddLog = function(prompt) {
                var modalInstance = $uibModal.open({
                    animation: true,
                    keyboard: false,
                    backdrop: 'static',
                    templateUrl: 'views/partials/case/tasklogs/add-task-log.modal.html',
                    controller: 'AddTaskLogModalCtrl',
                    controllerAs: '$modal',
                    size: 'lg',
                    resolve: {
                        task: task,
                        config: function() {
                            return {
                                prompt: prompt
                            };
                        }
                    }
                });

                return modalInstance.result;
            };

            $scope.markAsDone = function(task) {
                CaseTaskSrv.promtForActionRequired('Require Action', 'Would you like to add a task log before marking the required action as DONE?')
                    .then(function(response) {
                        if(response === 'skip-log') {
                            return $q.resolve();
                        } else {
                            return $scope.showAddLog('Please add a task log');
                        }
                    })
                    .then(function() {
                        return CaseTaskSrv.markAsDone(task._id, $scope.currentUser.organisation);
                    })
                    .then(function() {
                        NotificationSrv.log('The task\'s required action is completed', 'success');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Task required action failed to be marked as done', err.status);
                        }
                    });
            };

            $scope.markAsActionRequired = function(task) {
                CaseTaskSrv.promtForActionRequired('Require Action', 'Would you like to add a task log before requesting action?')
                    .then(function(response) {
                        if(response === 'skip-log') {
                            return $q.resolve();
                        } else {
                            return $scope.showAddLog('Please add a task log');
                        }
                    })
                    .then(function() {
                        return CaseTaskSrv.markAsActionRequired(task._id, $scope.currentUser.organisation);
                    })
                    .then(function() {
                        NotificationSrv.log('The task\'s required action flag has been set', 'success');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Task request action failed', err.status);
                        }
                    });

            };

            $scope.markShareAsActionRequired = function(task, org) {
                CaseTaskSrv.promtForActionRequired('Require Action', 'Would you like to add a task log before marking the required action as DONE?')
                    .then(function(response) {
                        if(response === 'skip-log') {
                            return $q.resolve();
                        } else {
                            return $scope.showAddLog('Please add a task log');
                        }
                    })
                    .then(function() {
                        return CaseTaskSrv.markAsActionRequired(task._id, org);
                    })
                    .then(function() {
                        NotificationSrv.log('The task\'s required action is completed', 'success');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Task required action failed to be marked as done', err.status);
                        }
                    });
            };

            $scope.markShareAsActionDone = function(task, org) {
                CaseTaskSrv.promtForActionRequired('Require Action', 'Would you like to add a task log before marking the required action as DONE?')
                    .then(function(response) {
                        if(response === 'skip-log') {
                            return $q.resolve();
                        } else {
                            return $scope.showAddLog('Please add a task log');
                        }
                    })
                    .then(function() {
                        return CaseTaskSrv.markAsDone(task._id, org);
                    })
                    .then(function() {
                        NotificationSrv.log('The task\'s required action is completed', 'success');
                    })
                    .catch(function(err) {
                        if(err && !_.isString(err)) {
                            NotificationSrv.error('Error', 'Task required action failed to be marked as done', err.status);
                        }
                    });
            };

            this.$onInit = function() {
                // Add tabs
                CaseTabsSrv.addTab($scope.tabName, {
                    name: $scope.tabName,
                    label: task.title,
                    closable: true,
                    state: 'app.case.tasks-item',
                    params: {
                        itemId: task._id
                    }
                });

                // Select tab
                $timeout(function() {
                    CaseTabsSrv.activateTab($scope.tabName);
                    $('html,body').animate({scrollTop: $('body').offset().top}, 'fast');
                }, 0);

                // Add action required listener
                StreamSrv.addListener({
                    rootId: caseId,
                    objectType: 'case_task',
                    scope: $scope,
                    callback: function(updates) {
                        // Update action required indicators in task item page and shares list
                        _.each(updates, function(update) {
                            if(update.base.objectId === $scope.task._id ){

                                var updatedKeys = _.keys(update.base.details);

                                var actionRequiredChange = _.find(updatedKeys, function(key) {
                                    return key.startsWith('actionRequired');
                                });

                                if(actionRequiredChange !== undefined) {
                                    $scope.reloadTask()
                                        .then(function() {
                                            $scope.loadShares();
                                        });
                                }
                            }
                        });
                    }
                });

                // Prepare the scope data
                $scope.initScope(task);

                // if(SecuritySrv.checkPermissions(['manageShare'], $scope.userPermissions)) {
                $scope.loadShares();
                //}

                // $scope.organisations = organisations;
                // $scope.profiles = profiles;
                // $scope.shares = shares;
            };
        }
    );
}());

```

`frontend/app/scripts/controllers/case/CaseTemplatesDialogCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('CaseTemplatesDialogCtrl',
        function($scope, $uibModalInstance, UiSettingsSrv, templates, uiSettings) {
            this.templates = templates;
            this.uiSettings = uiSettings;
            this.state = {
                filter: '',
                selected: null,
                hideEmptyCaseButton: UiSettingsSrv.hideEmptyCaseButton()
            };

            this.selectTemplate = function(template) {
                if(this.state.selected && this.state.selected.id === template.id) {
                    this.state.selected = null;
                } else {
                    this.state.selected = template;
                }
            };

            this.next = function(template) {
                $uibModalInstance.close(template);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/case/CaseUpdateCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers').controller('CaseUpdateCtrl',
        function($scope, $uibModalInstance, TagSrv, TaxonomyCacheSrv, selection) {
            var self = this;

            this.selection = selection;
            this.state = {
                all: false,
                enableTlp: false,
                enablePap: false,
                enableSeverity: false,
                enableAddTags: false,
                enableRemoveTags: false
            };

            this.activeTlp = 'active';
            this.activePap = 'active';
            this.activeSeverity = true;

            this.params = {
                ioc: false,
                tlp: 2,
                pap: 2,
                severity: 2,
                addTagNames: '',
                removeTagNames: ''
            };

            this.toggleAll = function() {

                this.state.all = !this.state.all;

                this.state.enableTlp = this.state.all;
                this.state.enablePap = this.state.all;
                this.state.enableSeverity = this.state.all;
                this.state.enableAddTags = this.state.all;
                this.state.enableRemoveTags = this.state.all;
            };

            this.categorizeObservables = function() {
                var data = {
                    withTags: [],
                    withoutTags: []
                };

                _.each(this.selection, function(item) {
                    if(item.tags.length > 0) {
                        data.withTags.push(item);
                    } else {
                        data.withoutTags.push(item);
                    }
                });

                return data;
            };

            this.buildOperations = function(postData) {
                var flags = _.pick(postData, 'pap', 'tlp', 'severity');

                // Handle updates without tag changes
                if(!postData.addTags && !postData.removeTags) {
                    return [
                        {
                            ids: _.pluck(this.selection, '_id'),
                            patch: flags
                        }
                    ];
                }

                // Handle update with tag changes
                var input = this.categorizeObservables();
                var operations = [];
                if(input.withoutTags.length > 0) {
                    var tags = (postData.addTags || []).filter(function(i) {
                        return (postData.removeTags || []).indexOf(i) === -1;
                    });

                    operations.push({
                        ids: _.pluck(input.withoutTags, '_id'),
                        patch: _.extend({}, flags ,{
                            tags: _.unique(tags)
                        })
                    });
                }

                if(input.withTags.length > 0) {
                    _.each(input.withTags, function(caze) {
                        tags = caze.tags.concat(postData.addTags || []).filter(function(i) {
                            return (postData.removeTags || []).indexOf(i) === -1;
                        });

                        operations.push({
                            ids: [caze._id],
                            patch: _.extend({}, flags ,{
                                tags: _.unique(tags)
                            })
                        });
                    });
                }

                return operations;
            };

            this.save = function() {

                var postData = {};

                if(this.state.enableTlp) {
                    postData.tlp = this.params.tlp;
                }

                if(this.state.enablePap) {
                    postData.pap = this.params.pap;
                }

                if(this.state.enableSeverity) {
                    postData.severity = this.params.severity;
                }

                if(this.state.enableAddTags) {
                    postData.addTags = _.pluck(this.params.addTags, 'text');
                }

                if(this.state.enableRemoveTags) {
                    postData.removeTags = _.pluck(this.params.removeTags, 'text');
                }

                $uibModalInstance.close(this.buildOperations(postData));
            };

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };

            this.getTags = function(query) {
                return TagSrv.autoComplete(query);
            };

            self.fromTagLibrary = function(field) {
                TaxonomyCacheSrv.openTagLibrary()
                    .then(function(tags){
                        if(field === 'add') {
                            self.params.addTags = (self.params.addTags || []).concat(tags);
                            self.toggleAddTags();
                        } else if (field === 'remove') {
                            self.params.removeTags = (self.params.removeTags || []).concat(tags);
                            self.toggleRemoveTags();
                        }
                    })
            };

            this.toggleTlp = function(value) {
                this.params.tlp = value;
                this.activeTlp = 'active';
                this.state.enableTlp = true;
            };

            this.togglePap = function(value) {
                this.params.pap = value;
                this.activePap = 'active';
                this.state.enablePap = true;
            };

            this.toggleSeverity = function(value) {
                this.params.severity = value;
                this.activeSeverity = true;
                this.state.enableSeverity = true;
            };

            this.toggleAddTags = function() {
                this.state.enableAddTags = true;
            };

            this.toggleRemoveTags = function() {
                this.state.enableRemoveTags = true;
            };

            $scope.$watchCollection('$dialog.params.addTags', function(value) {
                self.params.addTagNames = _.pluck(value, 'text').join(',');
            });

            $scope.$watchCollection('$dialog.params.removeTags', function(value) {
                self.params.removeTagNames = _.pluck(value, 'text').join(',');
            });
        }
    );
})();

```

`frontend/app/scripts/controllers/case/ObservableAnalyzeCtrl.js`:

```js
/**
 * Controller in add new artifact modal page
 */
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('ObservableAnalyzeCtrl',
        function($scope, $stateParams, $uibModalInstance, selection, analyzers) {
            var self = this;

            this.selection = selection;
            this.analyzers = analyzers;

            this.$onInit = function() {
                // Get observables data ypes
                this.dataTypes = _.unique(_.pluck(this.selection, 'dataType'));

                var map = {};
                _.each(this.dataTypes, function(dt) {
                    map[dt] = [];
                });

                _.each(this.analyzers, function(a) {
                    _.each(a.dataTypeList, function(dt) {
                        if(map[dt]) {
                            map[dt].push(_.extend({}, {slected: false}, _.pick(a, 'id', 'name', 'version')));
                        }
                    });
                });

                this.analyzerMap = map;
            };

            this.selectAll = function(dataType, flag) {
                _.each(this.analyzerMap[dataType], function(a) {
                    a.selected = flag;
                });
            };

            this.run = function() {
                var operations = [];

                _.each(this.selection, function(observable) {
                    // Get selected analyzers
                    analyzers = _.filter(self.analyzerMap[observable.dataType], function(analyzer) {
                        return !!analyzer.selected;
                    });

                    // Prepare analysis
                    _.each(analyzers, function(analyzer) {
                        operations.push({
                            observableId: observable._id,
                            analyzerId: analyzer.id,
                            analyzerName: analyzer.name
                        });
                    });

                });
                
                $uibModalInstance.close(operations);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss('cancel');
            };

        }
    );

})();

```

`frontend/app/scripts/controllers/case/ObservableCreationCtrl.js`:

```js
/**
 * Controller in add new artifact modal page
 */
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('ObservableCreationCtrl',
        function($scope, $stateParams, $uibModalInstance, TaxonomyCacheSrv, clipboard, CaseArtifactSrv, ObservableTypeSrv, NotificationSrv, TagSrv, params) {

            $scope.activeTlp = 'active';
            $scope.pendingAsync = false;
            $scope.step = 'form';
            $scope.params = params || {
                ioc: false,
                sighted: false,
                ignoreSimilarity: false,
                single: false,
                isUpload: true,
                isZip: false,
                zipPassword: '',
                data: '',
                tlp: 2,
                message: '',
                tags: [],
                tagNames: ''
            };

            $scope.$watchCollection('params.tags', function(value) {
                $scope.params.tagNames = _.pluck(value, 'text').join(',');
            });

            $scope.getDataTypeList = function() {

                ObservableTypeSrv.list()
                    .then(function(response) {
                        $scope.types = _.pluck(response.data, 'name').sort();
                    })
                    .catch(function(err) {
                        NotificationSrv.error('ObservableCreationCtrl', err.data, err.status);
                    });
            };
            $scope.getDataTypeList();
            $scope.updateTlp = function(tlp) {
                $scope.params.tlp = tlp;
            };

            $scope.selectDataType = function(type) {
                $scope.params.dataType = type;
            };

            $scope.countObservables = function() {
                if (!$scope.params.data) {
                    return 0;
                }

                var arr = $scope.params.data.split('\n');

                if (arr.length === 0) {
                    return 0;
                }

                return _.without(_.uniq(_.map(arr, function(data) {
                    return data.trim();
                })), '', null, undefined).length;
            };

            $scope.fromTagLibrary = function() {
                TaxonomyCacheSrv.openTagLibrary()
                    .then(function(tags){
                        $scope.params.tags = $scope.params.tags.concat(tags);
                    })
            };

            $scope.add = function(form) {
                if (!form.$valid) {
                    return;
                }

                var params = $scope.params,
                    count = 1,
                    postData = {
                        dataType: params.dataType,
                        ioc: params.ioc,
                        sighted: params.sighted,
                        ignoreSimilarity: params.ignoreSimilarity,
                        tlp: params.tlp,
                        message: params.message,
                        tags: _.unique(_.pluck(params.tags, 'text'))
                    };

                var isFile = params.dataType === 'file' && params.isUpload;
                var isAttachment = params.dataType === 'file' && !params.isUpload;

                // TODO add support to the attachment case
                if(isAttachment) {
                    // Observable is an existing file
                    postData.attachment = params.attachment;
                    count = postData.length;

                } else if(isFile) {
                    // Observable is an uploaded file
                    postData.attachment = params.attachment;

                    if(params.isZip) {
                        postData.isZip = params.isZip;
                        postData.zipPassword = params.zipPassword;
                    }
                } else {
                    // Observable is anything else
                    if(params.single === true) {
                        postData.data = params.data;
                    } else {
                        postData.data = params.data.split('\n');
                        count = postData.length;
                    }
                }

                $scope.pendingAsync = true;
                CaseArtifactSrv.api().save({
                    caseId: $stateParams.caseId
                }, postData, $scope.handleSaveSuccess, $scope.handleSaveFailure);
            };

            $scope.getFailedObservables = function(failures) {
                if(!_.isArray(failures)) {
                    failures = [failures];
                }

                return _.map(failures, function(observable) {
                    return {
                        data: observable.object.dataType === 'file' ? observable.object.attachment.name : observable.object.data,
                        type: observable.type
                    };
                });
            };

            $scope.handleSaveSuccess = function(response) {
                var success = 0,
                    failure = 0;

                if (response.status === 207) {
                    success = response.data.success.length;
                    failure = response.data.failure.length;

                    $scope.failedObservables = $scope.getFailedObservables(response.data.failure);

                    $scope.step = 'error';
                    $scope.pendingAsync = false;

                    NotificationSrv.log('Observables have been successfully created', 'success');

                } else {
                    success = angular.isObject(response.data) ? 1 : response.data.length;

                    NotificationSrv.log('Observables have been successfully created', 'success');

                    $uibModalInstance.close(response);
                }
            };

            $scope.handleSaveFailure = function(response) {
                $scope.pendingAsync = false;

                if (response.status === 400 && (response.data.type === 'ConflictError' || _.isArray(response.data))) {
                    $scope.failedObservables = $scope.getFailedObservables(response.data);

                    $scope.step = 'error';
                } else {
										if(response.data.type) {
                        NotificationSrv.error('ObservableCreationCtrl', response.data.message, response.status);
                    } else {
                        NotificationSrv.error('ObservableCreationCtrl', 'An unexpected error occurred while creating the observables', response.status);
                    }

                    //$uibModalInstance.close(response);
                }

            };

            $scope.copyToClipboard = function() {
                var copied = _.pluck($scope.failedObservables, 'data');

                clipboard.copyText(copied.join('\n'));
            };

            $scope.cancel = function() {
                $uibModalInstance.dismiss('cancel');
            };

            $scope.isFile = function() {
                if ($scope.params.dataType) {
                    return $scope.params.dataType.endsWith('file');
                } else {
                    return false;
                }
            };

            $scope.getTags = function(query) {
                return TagSrv.autoComplete(query);
            };
        }
    );

})();

```

`frontend/app/scripts/controllers/case/ObservableUpdateCtrl.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveControllers').controller('ObservableUpdateCtrl',
        function ($scope, $uibModalInstance, TagSrv, TaxonomyCacheSrv, selection, dataTypes) {
            var self = this;

            this.selection = selection;
            this.dataTypes = _.pluck(_.filter(dataTypes, function (item) {
                return !item.isAttachment
            }), 'name').sort();

            this.$onInit = function () {
                this.state = {
                    all: false,
                    enableDataType: false,
                    enableTlp: false,
                    enableIoc: false,
                    enableSighted: false,
                    enableIgnoreSimilarity: false,
                    enableAddTags: false,
                    enableRemoveTags: false
                };

                this.activeTlp = 'active';
                this.params = {
                    dataType: null,
                    ioc: false,
                    sighted: false,
                    ignoreSimilarity: false,
                    tlp: 2,
                    addTagNames: '',
                    removeTagNames: ''
                };

                var selectionTypes = _.unique(_.pluck(this.selection, 'dataType'));

                this.canUpdateDataType = selectionTypes.length === 1 && this.dataTypes.indexOf(selectionTypes[0]) !== -1;
            };

            this.toggleAll = function () {
                this.state.all = !this.state.all;

                if (this.canUpdateDataType) {
                    this.state.enableDataType = this.state.all;
                }

                this.state.enableTlp = this.state.all;
                this.state.enableIoc = this.state.all;
                this.state.enableSighted = this.state.all;
                this.state.enableIgnoreSimilarity = this.state.all;
                this.state.enableAddTags = this.state.all;
                this.state.enableRemoveTags = this.state.all;
            };

            this.categorizeObservables = function () {
                var data = {
                    withTags: [],
                    withoutTags: []
                };

                _.each(this.selection, function (item) {
                    if (item.tags.length > 0) {
                        data.withTags.push(item);
                    } else {
                        data.withoutTags.push(item);
                    }
                });

                return data;
            };

            this.buildOperations = function (postData) {
                var flags = {};

                if (this.canUpdateDataType) {
                    flags = _.pick(postData, 'dataType', 'ioc', 'sighted', 'ignoreSimilarity', 'tlp');
                } else {
                    flags = _.pick(postData, 'ioc', 'sighted', 'ignoreSimilarity', 'tlp');
                }

                // Handle updates without tag changes
                if (!postData.addTags && !postData.removeTags) {
                    return [
                        {
                            ids: _.pluck(this.selection, '_id'),
                            patch: flags
                        }
                    ];
                }

                // Handle update with tag changes
                var input = this.categorizeObservables();
                var operations = [];
                if (input.withoutTags.length > 0) {
                    var tags = (postData.addTags || []).filter(function (i) {
                        return (postData.removeTags || []).indexOf(i) === -1;
                    });

                    operations.push({
                        ids: _.pluck(input.withoutTags, '_id'),
                        patch: _.extend({}, flags, {
                            tags: _.unique(tags)
                        })
                    });
                }

                if (input.withTags.length > 0) {
                    _.each(input.withTags, function (observable) {
                        tags = observable.tags.concat(postData.addTags || []).filter(function (i) {
                            return (postData.removeTags || []).indexOf(i) === -1;
                        });

                        operations.push({
                            ids: [observable._id],
                            patch: _.extend({}, flags, {
                                tags: _.unique(tags)
                            })
                        });
                    });
                }

                return operations;
            };

            this.save = function () {

                var postData = {};

                if (this.state.enableDataType && this.canUpdateDataType) {
                    postData.dataType = this.params.dataType;
                }

                if (this.state.enableIoc) {
                    postData.ioc = this.params.ioc;
                }

                if (this.state.enableSighted) {
                    postData.sighted = this.params.sighted;
                }

                if (this.state.enableIgnoreSimilarity) {
                    postData.ignoreSimilarity = this.params.ignoreSimilarity;
                }

                if (this.state.enableTlp) {
                    postData.tlp = this.params.tlp;
                }

                if (this.state.enableAddTags) {
                    postData.addTags = _.pluck(this.params.addTags, 'text');
                }

                if (this.state.enableRemoveTags) {
                    postData.removeTags = _.pluck(this.params.removeTags, 'text');
                }

                $uibModalInstance.close(this.buildOperations(postData));
            };

            this.cancel = function () {
                $uibModalInstance.dismiss();
            };

            this.getTags = function (query) {
                return TagSrv.autoComplete(query);
            };

            self.fromTagLibrary = function (field) {
                TaxonomyCacheSrv.openTagLibrary()
                    .then(function (tags) {
                        if (field === 'add') {
                            self.params.addTags = (self.params.addTags || []).concat(tags);
                            self.toggleAddTags();
                        } else if (field === 'remove') {
                            self.params.removeTags = (self.params.removeTags || []).concat(tags);
                            self.toggleRemoveTags();
                        }
                    })
            };

            this.toggleDataType = function () {
                if (!this.params.dataType || this.params.dataType.length === 0) {
                    this.params.dataType = null;
                    this.state.enableDataType = false;
                } else {
                    this.state.enableDataType = true;
                }
            };

            this.toogleIoc = function () {
                this.params.ioc = !this.params.ioc;
                this.state.enableIoc = true;
            };

            this.toogleSighted = function () {
                this.params.sighted = !this.params.sighted;
                this.state.enableSighted = true;
            };

            this.toogleIgnoreSimilarity = function () {
                this.params.ignoreSimilarity = !this.params.ignoreSimilarity;
                this.state.enableIgnoreSimilarity = true;
            };

            this.toggleTlp = function (value) {
                this.params.tlp = value;
                this.activeTlp = 'active';
                this.state.enableTlp = true;
            };

            this.toggleAddTags = function () {
                this.state.enableAddTags = true;
            };

            this.toggleRemoveTags = function () {
                this.state.enableRemoveTags = true;
            };

            $scope.$watchCollection('$dialog.params.addTags', function (value) {
                self.params.addTagNames = _.pluck(value, 'text').join(',');
            });

            $scope.$watchCollection('$dialog.params.removeTags', function (value) {
                self.params.removeTagNames = _.pluck(value, 'text').join(',');
            });
        }
    );
})();

```

`frontend/app/scripts/controllers/case/ObservablesStatsCtrl.js`:

```js
/**
 * Controller for About TheHive modal page
 */
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('ObservablesStatsCtrl',
        function($rootScope, $scope, $stateParams, $timeout, StatSrv, StreamQuerySrv) {
            var self = this;

            this.byType = {};
            this.byIoc = {};
            this.byTags = {};

            this.iocLabels = {
                'true': 'IOC',
                'false': 'Not IOC'
            };

            this.iocValues = {
                'true': true,
                'false': false
            };

            self.$onInit = function() {
                var caseId = $stateParams.caseId;

                // Get stats by tags
                StreamQuerySrv('v1', [
                    { _name: 'getCase', idOrName: caseId },
                    { _name: 'observables' },
                    {
                       _name: 'aggregation',
                       _agg: 'field',
                       _field: 'tags',
                       _select: [
                           { _agg: 'count' }
                       ],
                       _order: [ '-count' ],
                       _size: 10
                   }
                ], {
                    scope: $scope,
                    rootId: caseId,
                    objectType: 'observable',
                    query: {
                        params: {
                            name: 'observables-by-tags-stats-' + caseId
                        }
                    },
                    onUpdate: function(data) {
                        self.byTags = StatSrv.prepareResult(data);
                    }
                });


                // Get stats by type
                StreamQuerySrv('v1', [
                    { _name: 'getCase', idOrName: caseId },
                    { _name: 'observables' },
                    {
                       _name: 'aggregation',
                       _agg: 'field',
                       _field: 'dataType',
                       _select: [
                           { _agg: 'count' }
                       ]
                   }
                ], {
                    scope: $scope,
                    rootId: caseId,
                    objectType: 'observable',
                    query: {
                        params: {
                            name: 'observables-by-type-stats-' + caseId
                        }
                    },
                    onUpdate: function(data) {
                        self.byType = StatSrv.prepareResult(data);
                    }
                });

                // Get stats by ioc
                StreamQuerySrv('v1', [
                    { _name: 'getCase', idOrName: caseId },
                    { _name: 'observables' },
                    {
                       _name: 'aggregation',
                       _agg: 'field',
                       _field: 'ioc',
                       _select: [
                           { _agg: 'count' }
                       ]
                   }
                ], {
                    scope: $scope,
                    rootId: caseId,
                    objectType: 'observable',
                    query: {
                        params: {
                            name: 'observables-by-ioc-stats-' + caseId
                        }
                    },
                    onUpdate: function(data) {
                        self.byIoc = StatSrv.prepareResult(data);
                    }
                });
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/case/procedure/AddProcedureModalCtrl.js`:

```js
/**
 * Controller for About TheHive modal page
 */
(function () {
    'use strict';

    angular.module('theHiveControllers').controller('AddProcedureModalCtrl', function ($rootScope, $scope, $uibModalInstance, NotificationSrv, ProcedureSrv, AttackPatternSrv, caseId) {
        var self = this;

        this.caseId = caseId;

        this.close = function () {
            $uibModalInstance.close();
        };

        this.cancel = function () {
            if ($rootScope.markdownEditorObjects && $rootScope.markdownEditorObjects.procedure) {
                $rootScope.markdownEditorObjects.procedure.hidePreview();
            }

            $uibModalInstance.dismiss();
        };

        this.addProcedure = function () {
            self.state.loading = true;

            ProcedureSrv.create({
                caseId: self.caseId,
                tactic: self.procedure.tactic,
                description: self.procedure.description,
                patternId: self.procedure.patternId,
                occurDate: self.procedure.occurDate
            }).then(function (/*response*/) {
                self.state.loading = false;
                $uibModalInstance.close();
                NotificationSrv.log('Tactic, Technique and Procedure added successfully', 'success');
            }).catch(function (err) {
                NotificationSrv.error('Add TTP', err.data, err.status);
                self.state.loading = false;
            });
        };

        this.showTechniques = function () {
            AttackPatternSrv.getByTactic(self.procedure.tactic)
                .then(function (techniques) {
                    self.state.techniques = techniques;

                    self.procedure.patternId = null;
                });
        };

        this.$onInit = function () {
            this.markdownEditorOptions = {
                iconlibrary: 'fa',
                addExtraButtons: true,
                resize: 'vertical'
            };

            this.procedure = {
                tactic: null,
                description: null,
                patternId: null
            };

            this.tactics = AttackPatternSrv.tactics;

            this.state = {
                loading: false,
                selectedTactic: null,
                techniques: null
            };

            $scope.$broadcast('beforeProcedureModalShow');
        };
    }
    );
})();

```

`frontend/app/scripts/controllers/case/share/CaseShareModalCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers')
        .controller('CaseShareModalCtrl', function($uibModalInstance, organisations, profiles, shares) {
            var self = this;

            this.organisations = organisations;
            this.profiles = profiles;
            this.shares = shares;

            this.formData = {
                organisations: [],
                profile: null,
                tasks: 'none',
                observables: 'none'
            };

            this.options = ['all', 'none'];

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };

            this.save = function() {
                var shares = [];

                _.each(self.formData.organisations, function(org) {
                    shares.push({
                        organisationName: org,
                        profile: self.formData.profile,
                        tasks: self.formData.tasks,
                        observables: self.formData.observables
                    });
                });

                $uibModalInstance.close(shares);
            };
        });
})();

```

`frontend/app/scripts/controllers/case/tasklogs/AddTaskLogModalCtrl.js`:

```js
/**
 * Controller for About TheHive modal page
 */
(function() {
    'use strict';

    angular.module('theHiveControllers').controller('AddTaskLogModalCtrl', function($rootScope, $scope, $uibModalInstance, TaskLogSrv, NotificationSrv, task, config) {
            var self = this;

            this.task = task;
            this.config = config;

            this.close = function() {
                $uibModalInstance.close();
            };

            this.cancel = function() {
                $rootScope.markdownEditorObjects.newLog.hidePreview();

                $uibModalInstance.dismiss();
            };

            this.addLog = function() {
                // this.close();
                if (this.state.attachmentCollapsed || !this.data.attachment) {
                    delete this.data.attachment;
                }

                TaskLogSrv.save({
                    'taskId': self.task._id
                }, self.data, function () {
                    // if(self.task.status === 'Waiting') {
                    //     // Reload the task
                    //     $scope.reloadTask();
                    // }
                    //
                    delete self.data.attachment;
                    self.state.attachmentCollapsed = true;
                    self.data.message = '';

                    $rootScope.markdownEditorObjects.newLog.hidePreview();
                    // $scope.adding = false;
                    // removeAllFiles is added by dropzone directive as control
                    self.state.removeAllFiles();

                    self.state.loading = false;

                    self.close();
                }, function (response) {
                    NotificationSrv.error('Add Task Log', response.data, response.status);
                    self.state.loading = false;
                });

            };

            this.$onInit = function() {
                this.markdownEditorOptions = {
                    iconlibrary: 'fa',
                    addExtraButtons: true,
                    resize: 'vertical'
                };

                this.data = {
                    message: null,
                    attachment: null
                };

                this.state = {
                    attachmentCollapsed: true,
                    loading: false
                };

                $scope.$broadcast('beforeNewTaskLogShow');
            };
        }
    );
})();

```

`frontend/app/scripts/controllers/cortex/CortexInstanceDialogCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .controller('CortexInstanceDialogCtrl', CortexInstanceDialogCtrl);

        function CortexInstanceDialogCtrl($uibModalInstance, servers) {
            this.servers = servers;
            this.selected = null;

            this.ok = function() {
                $uibModalInstance.close(this.selected);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };
        }
})();

```

`frontend/app/scripts/controllers/cortex/ResponderActionDialogCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .controller('ResponderActionDialogCtrl', ResponderActionDialogCtrl);

        function ResponderActionDialogCtrl($uibModalInstance, action) {
            var self = this;

            this.action = action;
            this.report = (JSON.parse(action.report) || {}).full;

            this.close = function() {
                $uibModalInstance.dismiss();
            };
        }
})();

```

`frontend/app/scripts/controllers/dashboard/DashboardViewCtrl.js`:

```js
(function () {
    'use strict';

    angular
        .module('theHiveControllers')
        .controller('DashboardViewCtrl', function ($scope, $q, $interval, $timeout, $uibModal, AuthenticationSrv, DashboardSrv, NotificationSrv, ModalUtilsSrv, UtilsSrv, dashboard, metadata) {
            var self = this;

            this.currentUser = AuthenticationSrv.currentUser;
            this.createdBy = dashboard.createdBy;
            this.dashboardStatus = dashboard.status;
            this.metadata = metadata;
            this.toolbox = DashboardSrv.toolbox;
            this.dashboardPeriods = DashboardSrv.dashboardPeriods;
            this.autoRefresh = null;
            this.authRefreshRunner = null;

            this.buildDashboardPeriodFilter = function (period) {
                return period === 'custom' ?
                    DashboardSrv.buildPeriodQuery(period, 'createdAt', this.definition.customPeriod.fromDate, this.definition.customPeriod.toDate) :
                    DashboardSrv.buildPeriodQuery(period, 'createdAt');
            };

            this.loadDashboard = function (dashboard) {
                this.dashboard = dashboard;
                this.definition = JSON.parse(dashboard.definition) || {
                    period: 'all',
                    items: [
                        {
                            type: 'container',
                            items: []
                        }
                    ]
                };
                this.periodFilter = this.buildDashboardPeriodFilter(this.definition.period);
            };

            this.loadDashboard(dashboard);

            $scope.$watch('$vm.autoRefresh', function (value) {
                if (value === self.authRefreshRunner || self.options.editLayout === true) {
                    return;
                }

                if (value === null) {
                    $interval.cancel(self.authRefreshRunner);
                } else {
                    $interval.cancel(self.authRefreshRunner);
                    self.authRefreshRunner = $interval(function () {
                        $scope.$broadcast('refresh-chart', self.periodFilter);
                    }, value * 1000);
                }
            });

            this.canEditDashboard = function () {
                return (this.createdBy === this.currentUser.login) || this.dashboardStatus === 'Shared';
            };

            this.options = {
                dashboardAllowedTypes: ['container'],
                containerAllowedTypes: ['bar', 'line', 'donut', 'counter', 'text', 'multiline'],
                maxColumns: 3,
                cls: DashboardSrv.typeClasses,
                labels: {
                    container: 'Row',
                    bar: 'Bar',
                    donut: 'Donut',
                    line: 'Line',
                    counter: 'Counter',
                    text: 'Text',
                    multiline: 'Multi Lines'
                },
                editLayout: !_.find(this.definition.items, function (row) {
                    return row.items.length > 0;
                }) && this.canEditDashboard()
            };

            this.applyPeriod = function (period) {
                this.definition.period = period;
                this.periodFilter = this.buildDashboardPeriodFilter(period);

                $scope.$broadcast('refresh-chart', this.periodFilter);
            };

            this.removeContainer = function (index) {
                var row = this.definition.items[index];

                var promise;
                if (row.items.length === 0) {
                    // If the container is empty, don't ask for confirmation
                    promise = $q.resolve();
                } else {
                    promise = ModalUtilsSrv.confirm('Remove widget', 'Are you sure you want to remove this item', {
                        okText: 'Yes, remove it',
                        flavor: 'danger'
                    });
                }

                promise.then(function () {
                    self.definition.items.splice(index, 1);
                });
            };

            this.saveDashboard = function () {
                var copy = {
                    definition: angular.toJson(this.definition)
                };

                DashboardSrv.update(this.dashboard.id, copy)
                    .then(function (/*response*/) {
                        self.options.editLayout = false;
                        self.resizeCharts();
                        NotificationSrv.log('The dashboard has been successfully updated', 'success');
                    })
                    .catch(function (err) {
                        NotificationSrv.error('DashboardEditCtrl', err.data, err.status);
                    });
            };

            this.removeItem = function (rowIndex, colIndex) {

                ModalUtilsSrv.confirm('Remove widget', 'Are you sure you want to remove this item', {
                    okText: 'Yes, remove it',
                    flavor: 'danger'
                }).then(function () {
                    var row = self.definition.items[rowIndex];
                    row.items.splice(colIndex, 1);

                    $timeout(function () {
                        $scope.$broadcast('resize-chart-' + rowIndex);
                    }, 0);
                });

            };

            this.itemInserted = function (item, rows/*, rowIndex, index*/) {
                if (!item.id) {
                    item.id = UtilsSrv.guid();
                }

                for (var i = 0; i < rows.length; i++) {
                    $scope.$broadcast('resize-chart-' + i);
                }

                if (this.options.containerAllowedTypes.indexOf(item.type) !== -1 && !item.options.entity) {
                    // The item is a widget
                    $timeout(function () {
                        $scope.$broadcast('edit-chart-' + item.id);
                    }, 0);
                }

                return item;
            };

            this.itemDragStarted = function (colIndex, row) {
                row.items.splice(colIndex, 1);
            };

            this.exportDashboard = function () {
                DashboardSrv.exportDashboard(this.dashboard);
            };

            this.resizeCharts = function () {
                $timeout(function () {
                    for (var i = 0; i < self.definition.items.length; i++) {
                        $scope.$broadcast('resize-chart-' + i);
                    }
                }, 100);
            };

            this.enableEditMode = function () {
                this.options.editLayout = true;
                this.resizeCharts();
            };

            this.enableViewMode = function () {
                DashboardSrv.get(this.dashboard.id)
                    .then(function (response) {
                        self.loadDashboard(response.data);
                        self.options.editLayout = false;
                        self.resizeCharts();
                    }, function (err) {
                        NotificationSrv.error('DashboardViewCtrl', err.data, err.status);
                    });
            };


        });
})();

```

`frontend/app/scripts/controllers/dashboard/DashboardsCtrl.js`:

```js
(function () {
    'use strict';

    angular
        .module('theHiveControllers')
        .controller('DashboardImportCtrl', function ($scope, $uibModalInstance) {
            var self = this;
            this.formData = {
                fileContent: {}
            };

            $scope.$watch('vm.formData.attachment', function (file) {
                if (!file) {
                    self.formData.fileContent = {};
                    return;
                }
                var aReader = new FileReader();
                aReader.readAsText(self.formData.attachment, 'UTF-8');
                aReader.onload = function (evt) {
                    $scope.$apply(function () {
                        self.formData.fileContent = JSON.parse(aReader.result);
                    });
                }
                aReader.onerror = function (evt) {
                    $scope.$apply(function () {
                        self.formData.fileContent = {};
                    });
                }
            });

            this.ok = function () {
                var dashboard = _.pick(this.formData.fileContent, 'title', 'description', 'status');
                dashboard.definition = JSON.stringify(this.formData.fileContent.definition || {});

                $uibModalInstance.close(dashboard);
            };

            this.cancel = function () {
                $uibModalInstance.dismiss('cancel');
            };
        })
        .controller('DashboardModalCtrl', function ($uibModalInstance, AuthenticationSrv, $state, statuses, dashboard) {
            this.dashboard = dashboard;
            this.statuses = statuses;
            this.currentUser = AuthenticationSrv.currentUser;

            this.cancel = function () {
                $uibModalInstance.dismiss();
            };

            this.ok = function () {
                return $uibModalInstance.close(dashboard);
            };
        })
        .controller('DashboardsCtrl', function ($scope, $state, $uibModal, PaginatedQuerySrv, FilteringSrv, ModalUtilsSrv, NotificationSrv, DashboardSrv, AuthenticationSrv) {
            this.dashboards = [];
            var self = this;

            this.currentUser = AuthenticationSrv.currentUser;

            this.$onInit = function () {
                self.filtering = new FilteringSrv('dashboard', 'dashboard.list', {
                    version: 'v0',
                    defaults: {
                        showFilters: true,
                        showStats: false,
                        pageSize: 15,
                        sort: ['+title']
                    },
                    defaultFilter: []
                });

                self.filtering.initContext('list')
                    .then(function () {
                        self.load();

                        $scope.$watch('$vm.list.pageSize', function (newValue) {
                            self.filtering.setPageSize(newValue);
                        });
                    });
            }

            this.load = function () {

                self.list = new PaginatedQuerySrv({
                    name: 'dashboard-list',
                    version: 'v0',
                    skipStream: true,
                    sort: self.filtering.context.sort,
                    loadAll: false,
                    pageSize: self.filtering.context.pageSize,
                    filter: this.filtering.buildQuery(),
                    operations: [
                        { '_name': 'listDashboard' }
                    ],
                    onFailure: function (err) {
                        if (err && err.status === 400) {
                            self.filtering.resetContext();
                            self.load();
                        }
                    }
                });
            };

            this.openDashboardModal = function (dashboard) {
                return $uibModal.open({
                    templateUrl: 'views/partials/dashboard/create.dialog.html',
                    controller: 'DashboardModalCtrl',
                    controllerAs: '$vm',
                    size: 'lg',
                    resolve: {
                        statuses: function () {
                            return ['Private', 'Shared'];
                        },
                        dashboard: function () {
                            return dashboard;
                        }
                    }
                });
            };

            this.addDashboard = function () {
                var modalInstance = this.openDashboardModal({
                    title: null,
                    description: null,
                    status: 'Private',
                    definition: JSON.stringify(DashboardSrv.defaultDashboard)
                });

                modalInstance.result
                    .then(function (dashboard) {
                        return DashboardSrv.create(dashboard);
                    })
                    .then(function (response) {
                        $state.go('app.dashboards-view', { id: response.data.id });

                        NotificationSrv.log('The dashboard has been successfully created', 'success');
                    })
                    .catch(function (err) {
                        if (err && err.status) {
                            NotificationSrv.error('DashboardsCtrl', err.data, err.status);
                        }
                    });
            };

            this.duplicateDashboard = function (dashboard) {
                var copy = _.pick(dashboard, 'title', 'description', 'status', 'definition');
                copy.title = 'Copy of ' + copy.title;

                this.openDashboardModal(copy)
                    .result.then(function (dashboard) {
                        return DashboardSrv.create(dashboard);
                    })
                    .then(function (response) {
                        $state.go('app.dashboards-view', { id: response.data.id });

                        NotificationSrv.log('The dashboard has been successfully created', 'success');
                    })
                    .catch(function (err) {
                        if (err && err.status) {
                            NotificationSrv.error('DashboardsCtrl', err.data, err.status);
                        }
                    });
            };

            this.editDashboard = function (dashboard) {
                var copy = _.extend({}, dashboard);

                this.openDashboardModal(copy).result
                    .then(function (dashboard) {

                        if (dashboard.createdBy === self.currentUser.login) {
                            return DashboardSrv.update(dashboard.id, _.omit(dashboard, 'id', 'definition'));
                        } else {
                            return DashboardSrv.update(dashboard.id, _.omit(dashboard, 'id', 'status', 'definition'));
                        }


                    })
                    .then(function (response) {
                        self.load()

                        NotificationSrv.log('The dashboard has been successfully updated', 'success');
                    })
                    .catch(function (err) {
                        if (err && err.status) {
                            NotificationSrv.error('DashboardsCtrl', err.data, err.status);
                        }
                    });
            };

            this.deleteDashboard = function (id) {
                ModalUtilsSrv.confirm('Remove dashboard', 'Are you sure you want to remove this dashboard', {
                    okText: 'Yes, remove it',
                    flavor: 'danger'
                })
                    .then(function () {
                        return DashboardSrv.remove(id);
                    })
                    .then(function (response) {
                        self.load();

                        NotificationSrv.log('The dashboard has been successfully removed', 'success');
                    });
            };

            this.exportDashboard = function (dashboard) {
                DashboardSrv.exportDashboard(dashboard);
            }

            this.importDashboard = function () {
                var modalInstance = $uibModal.open({
                    animation: true,
                    templateUrl: 'views/partials/dashboard/import.dialog.html',
                    controller: 'DashboardImportCtrl',
                    controllerAs: 'vm',
                    size: 'lg'
                });

                modalInstance.result.then(function (dashboard) {
                    return DashboardSrv.create(dashboard);
                })
                    .then(function (response) {
                        $state.go('app.dashboards-view', { id: response.data.id });

                        NotificationSrv.log('The dashboard has been successfully imported', 'success');
                    })
                    .catch(function (err) {
                        if (err && err.status) {
                            NotificationSrv.error('DashboardsCtrl', err.data, err.status);
                        }
                    });
            }

            // Filtering
            this.toggleFilters = function () {
                this.filtering.toggleFilters();
            };

            this.filter = function () {
                self.filtering.filter().then(this.applyFilters);
            };

            this.clearFilters = function () {
                this.filtering.clearFilters()
                    .then(self.search);
            };

            this.removeFilter = function (index) {
                self.filtering.removeFilter(index)
                    .then(self.search);
            };

            this.search = function () {
                self.load();
                self.filtering.storeContext();
            };
            this.addFilterValue = function (field, value) {
                this.filtering.addFilterValue(field, value);
                this.search();
            };

            this.filterBy = function (field, value) {
                self.filtering.clearFilters()
                    .then(function () {
                        self.addFilterValue(field, value);
                    });
            };

            this.sortBy = function (sort) {
                self.list.sort = sort;
                self.list.update();
                self.filtering.setSort(sort);
            };

            this.sortByField = function (field) {
                var context = this.filtering.context;
                var currentSort = Array.isArray(context.sort) ? context.sort[0] : context.sort;
                var sort = null;

                if (currentSort.substr(1) !== field) {
                    sort = ['+' + field];
                } else {
                    sort = [(currentSort === '+' + field) ? '-' + field : '+' + field];
                }

                self.list.sort = sort;
                self.list.update();
                self.filtering.setSort(sort);
            };
        });
})();

```

`frontend/app/scripts/controllers/misc/ResponderSelectorCtrl.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveControllers')
        .controller('ResponderSelectorCtrl', function($uibModalInstance, responders) {
            this.responders = responders || [];
            this.selectAll = false;
            this.state = {
                filter: ''
            };

            this.next = function(responder) {
                $uibModalInstance.close(responder);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };
        });
})();

```

`frontend/app/scripts/controllers/misc/ServerInstanceDialogCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveControllers')
        .controller('ServerInstanceDialogCtrl', ServerInstanceDialogCtrl);

        function ServerInstanceDialogCtrl($uibModalInstance, servers) {
            var self = this;
            
            this.servers = servers;
            this.selected = null;

            this.ok = function() {
                $uibModalInstance.close(this.selected);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };
        }        
})();

```

`frontend/app/scripts/controllers/misc/TaxonomySelectionModalCtrl.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .controller('TaxonomySelectionModalCtrl', function($uibModalInstance, taxonomies) {
            var self = this;

            this.taxonomies = angular.copy(taxonomies);
            this.selectedTags = [];

            this.formData = {
                selectedTaxonomy: null,
                selectedTags: []
            };

            this.selectTaxonomy = function(taxonomy) {
                self.formData.selectedTaxonomy = taxonomy;
                self.search = '';
            }

            this.selectTag = function(tag) {
                tag.selected = !!!tag.selected;

                if(tag.selected === true) {
                    // Add to selection
                    self.formData.selectedTags.push(tag);
                } else {
                    // Remove from selection
                    self.formData.selectedTags = _.without(self.formData.selectedTags, tag);
                }
            }

            this.clearSelection = function() {
                _.each(self.formData.selectedTags, function(tag) {
                    tag.selected = false;
                });

                self.formData.selectedTags = [];
            }

            this.addSelectedTags = function() {
                if (!self.formData.selectedTaxonomy || self.formData.selectedTags.length === 0) {
                    return;
                }

                $uibModalInstance.close(self.formData.selectedTags);
            };

            this.cancel = function() {
                $uibModalInstance.dismiss();
            };
        });
})();

```

`frontend/app/scripts/directives/affixer.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('affixer', function($document, $window) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                var top = attrs.affixerOffset;
                var topOffset = element[0].offsetTop - top;

                function affixElement() {
                    if ($window.pageYOffset > topOffset) {
                        element.css('position', 'fixed');
                        element.css('top', top + 'px');
                    } else {
                        element.css('position', '');
                        element.css('top', '');
                    }
                }

                angular.element($window).bind('scroll', affixElement);
            }
        };
    });
})();

```

`frontend/app/scripts/directives/alert-duration.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('alertDuration', function() {
        return {
            restrict: 'E',
            scope: {
                start: '=',
                end: '=',
                icon: '@',
                indicator: '='
            },
            templateUrl: 'views/directives/alert-duration.html'
        };
    });
})();

```

`frontend/app/scripts/directives/auto-focus.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('autoFocus', function($timeout) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                if (attrs.autoFocus) {
                    scope.$on(attrs.autoFocus, function() {
                        $timeout(function() {
                            element[0].focus();
                        });
                    });
                } else {
                    $timeout(function() {
                        element[0].focus();
                    });
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/case-duration.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('caseDuration', function() {
        return {
            restrict: 'E',
            scope: {
                start: '=',
                end: '=',
                icon: '@',
                indicator: '='
            },
            templateUrl: 'views/directives/case-duration.html'
        };
    });
})();

```

`frontend/app/scripts/directives/charts/c3Chart.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('c3', function(DashboardSrv) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                chart: '=',
                resizeOn: '@',
                error: '=',
                height: '<?',
                hideActions: '<?',
                onSaveCsv: '&?'
            },
            templateUrl: 'views/directives/charts/c3.html',
            link: function(scope, element) {
                var binto = $(element).find('.c3-chart')[0];

                scope.initChart = function(chart) {
                    if (!_.isEmpty(chart)) {
                        scope.chart.bindto = binto;
                        scope.chart.color = {
                            pattern: DashboardSrv.colorsPattern
                        };
                        scope.chart.size = {
                            height: scope.height || 300
                        };
                        scope.c3 = c3.generate(scope.chart);
                    }
                };

                scope.save = function() {
                    saveSvgAsPng(($(element).find('.c3-chart > svg')[0]), "chart.png", {
                        backgroundColor: '#FFF'
                    });
                };

                scope.$watch('chart', function(newValue) {
                    scope.initChart(newValue);
                });

                if(scope.resizeOn) {
                    scope.$on(scope.resizeOn, function() {
                        if(scope.c3) {
                            scope.c3.resize();
                        }
                    });
                }
            }
        };
    });

})();

```

`frontend/app/scripts/directives/compare-to.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('compareTo', function() {
            return {
                require: 'ngModel',
                scope: {
                    otherModelValue: '=compareTo'
                },
                link: function(scope, element, attributes, ngModel) {

                    ngModel.$validators.compareTo = function(modelValue) {
                        return modelValue === scope.otherModelValue;
                    };

                    scope.$watch('otherModelValue', function() {
                        ngModel.$validate();
                    });
                }
            };
        });
})();

```

`frontend/app/scripts/directives/dashboard/bar.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('dashboardBar', function($http, $state, DashboardSrv, NotificationSrv) {
        return {
            restrict: 'E',
            scope: {
                filter: '=?',
                options: '=',
                entity: '=',
                autoload: '=',
                mode: '=',
                refreshOn: '@',
                resizeOn: '@',
                metadata: '='
            },
            template: '<c3 chart="chart" resize-on="{{resizeOn}}" error="error" on-save-csv="getCsv()"></c3>',
            link: function(scope) {
                scope.error = false;
                scope.chart = {};

                scope.intervals = DashboardSrv.timeIntervals;
                scope.interval = scope.intervals[2];

                scope.load = function() {
                    if(!scope.entity) {
                        scope.error = true;
                        return;
                    }

                    scope.prepareSeriesNames = function() {
                        if(!scope.options.field) {
                            return {};
                        }

                        var field = scope.entity.attributes[scope.options.field];

                        if(field.values.length === 0) {
                            // This is not an enumerated field
                            // Labels and colors customization is not available
                            return {};
                        }

                        var names = scope.options.names || {};

                        _.each(field.values, function(val, index) {
                            if(!names[val]) {
                                names[val] = field.labels[index] || val;
                            }
                        });

                        return names;
                    };

                    var query = DashboardSrv.buildChartQuery(scope.filter, scope.options.query);

                    var statsPromise = $http.post('./api' + scope.entity.path + '/_stats', {
                        query: query,
                        stats: [{
                            _agg: 'time',
                            _fields: [scope.options.dateField],
                            _interval: scope.options.interval || scope.interval.code,
                            _select: [{
                                _agg: 'field',
                                _field: scope.options.field,
                                _select: [{
                                    _agg: 'count'
                                }]
                            }]
                        }]
                    });

                    statsPromise.then(function(response) {
                        scope.error = false;
                        var len = _.keys(response.data).length,
                            data = {_date: (new Array(len)).fill(0)};

                        var rawData = {};
                        _.each(response.data, function(value, key) {
                            rawData[key] = value[scope.options.dateField];
                        });

                        _.each(rawData, function(value) {
                            _.each(_.keys(value), function(key){
                                data[key] = (new Array(len)).fill(0);
                            });
                        });

                        var i = 0;
                        var orderedDates = _.sortBy(_.keys(rawData));

                        _.each(orderedDates, function(key) {
                            var value = rawData[key];
                            data._date[i] = moment(key * 1).format('YYYY-MM-DD');

                            _.each(_.keys(value), function(item) {
                                data[item][i] = value[item].count;
                            });

                            i++;
                        });


                        scope.options.names = scope.prepareSeriesNames();
                        scope.colors = {};

                        scope.data = data;

                        var chart = {
                            data: {
                                x: '_date',
                                json: scope.data,
                                type: 'bar',
                                names: scope.options.names || {},
                                colors: scope.options.colors || {},
                                groups: scope.options.stacked === true ? [_.without(_.keys(data), '_date')] : []
                            },
                            bar: {
                                width: {
                                    ratio: 1 - Math.exp(-len/20)
                                }
                            },
                            axis: {
                                x: {
                                    type: 'timeseries',
                                    tick: {
                                        format: '%Y-%m-%d',
                                        rotate: 90,
                                        height: 50
                                    }
                                }
                            },
                            zoom: {
                                enabled: scope.options.zoom || false
                            }
                        };

                        scope.chart = chart;
                    }, function(err) {
                        scope.error = true;
                        NotificationSrv.error('dashboardBar', 'Failed to fetch data, please edit the widget definition', err.status);
                    });
                };

                scope.getCsv = function() {
                    var dates = scope.data._date;
                    var keys = _.keys(scope.data);
                    var headers = _.extend({_date: 'Date'}, scope.names);

                    var csv = [{data: _.map(keys, function(key){
                        return headers[key] || key;
                    }).join(';')}];

                    var row = [];
                    for(var i=0; i<dates.length; i++) {
                        row = _.map(keys, function(key) {
                            return scope.data[key][i];
                        });

                        csv.push({data: row.join(';')});
                    }

                    return csv;
                };

                if (scope.autoload === true) {
                    scope.load();
                }

                if (!_.isEmpty(scope.refreshOn)) {
                    scope.$on(scope.refreshOn, function(event, filter) {
                        scope.filter = filter;
                        scope.load();
                    });
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/dashboard/counter.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('dashboardCounter', function($q, $http, $state, DashboardSrv, NotificationSrv, GlobalSearchSrv) {
        return {
            restrict: 'E',
            scope: {
                filter: '=?',
                options: '=',
                entity: '=',
                autoload: '=',
                mode: '=',
                refreshOn: '@',
                metadata: '='
            },
            templateUrl: 'views/directives/dashboard/counter/view.html',
            link: function(scope) {
                scope.error = false;
                scope.data = null;
                scope.globalQuery = null;

                scope.load = function() {
                    if(!scope.entity) {
                        scope.error = true;
                        return;
                    }

                    var query = DashboardSrv.buildChartQuery(scope.filter, scope.options.query);
                    scope.globalQuery = query;

                    var statsPromise = $http.post('./api' + scope.entity.path + '/_stats', {
                        query: query,
                        stats: _.map(scope.options.series || [], function(serie, index) {
                            var s = {
                                _agg: serie.agg,
                                _name: 'agg_' + (index + 1),
                                _query: serie.query || {}
                            };

                            if(serie.agg !== 'count') {
                                s._field = serie.field;
                            }

                            return s;
                        })
                    });

                    statsPromise.then(function(response) {
                        scope.error = false;
                        var data = response.data;

                        scope.data = _.map(scope.options.series || [], function(serie, index) {
                            var name = 'agg_' + (index + 1);
                            return {
                                serie: serie,
                                agg: serie.agg,
                                name: name,
                                label: serie.label,
                                value: data[name] || 0
                            };
                        });

                    }, function(err) {
                        scope.error = true;
                        NotificationSrv.error('dashboardBar', 'Failed to fetch data, please edit the widget definition', err.status);
                    });
                };

                scope.openSearch = function(item) {
                    if(scope.mode === 'edit') {
                        return;
                    }

                    var timeFrameFilter = [];
                    if(scope.filter) {
                        timeFrameFilter.push({
                            field: scope.filter._between._field,
                            type: 'date',
                            value: {
                                from: moment(scope.filter._between._from),
                                to: moment(scope.filter._between._to)
                            }
                        });
                    }

                    var filters = (scope.options.filters || [])
                        .concat(item.serie.filters || [])
                        .concat(timeFrameFilter || []);

                    $q.resolve(GlobalSearchSrv.saveSection(scope.options.entity, {
                        search: filters.length === 0 ? '*' : null,
                        filters: filters
                    })).then(function() {
                        $state.go('app.search');
                    });

                };

                if (scope.autoload === true) {
                    scope.load();
                }

                if (!_.isEmpty(scope.refreshOn)) {
                    scope.$on(scope.refreshOn, function(event, filter) {
                        scope.filter = filter;
                        scope.load();
                    });
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/dashboard/donut.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('dashboardDonut', function($q, StatSrv, $state, DashboardSrv, NotificationSrv, GlobalSearchSrv) {
        return {
            restrict: 'E',
            scope: {
                filter: '=?',
                options: '=',
                entity: '=',
                autoload: '=',
                mode: '=',
                refreshOn: '@',
                resizeOn: '@',
                metadata: '='
            },
            template: '<c3 chart="chart" resize-on="{{resizeOn}}" error="error" on-save-csv="getCsv()"></c3>',
            link: function(scope) {
                scope.error = false;
                scope.chart = {};

                scope.prepareSeriesNames = function() {
                    if(!scope.options.field) {
                        return {};
                    }

                    var field = scope.entity.attributes[scope.options.field];

                    if(field.values.length === 0) {
                        // This is not an enumerated field
                        // Labels and colors customization is not available
                        return {};
                    }

                    var names = scope.options.names || {};

                    _.each(field.values, function(val, index) {
                        if(!names[val]) {
                            names[val] = field.labels[index] || val;
                        }
                    });

                    return names;
                };

                scope.load = function() {
                    if(!scope.entity) {
                        scope.error = true;
                        return;
                    }

                    var query = DashboardSrv.buildChartQuery(scope.filter, scope.options.query);

                    var statConfig = {
                        query: query,
                        objectType: scope.entity.path,
                        field: scope.options.field,
                        sort: scope.options.sort ? [scope.options.sort] : '-_count',
                        limit: scope.options.limit || 10
                    };

                    scope.options.names = scope.prepareSeriesNames();

                    StatSrv.getPromise(statConfig).then(
                        function(response) {
                            scope.error = false;
                            var data = {};
                            var total = response.data.count;

                            delete response.data.count;

                            _.each(response.data, function(val, key) {
                                data[key] = val.count;
                            });

                            scope.data = data;

                            scope.chart = {
                                data: {
                                    json: scope.data,
                                    type: 'donut',
                                    names: scope.options.names || {},
                                    colors: scope.options.colors || {},
                                    onclick: function(d) {
                                        if(scope.mode === 'edit') {
                                            return;
                                        }

                                        var fieldDef = scope.entity.attributes[scope.options.field];

                                        var data = {
                                            field: scope.options.field,
                                            type: fieldDef.type,
                                            value: GlobalSearchSrv.buildDefaultFilterValue(fieldDef, d)
                                        };

                                        var timeFrameFilter = [];
                                        if(scope.filter) {
                                            timeFrameFilter.push({
                                                field: scope.filter._between._field,
                                                type: 'date',
                                                value: {
                                                    from: moment(scope.filter._between._from),
                                                    to: moment(scope.filter._between._to)
                                                }
                                            });
                                        }

                                        var filters = (scope.options.filters || [])
                                            .concat([data])
                                            .concat(timeFrameFilter);

                                        $q.resolve(GlobalSearchSrv.saveSection(scope.options.entity, {
                                            search: null,
                                            filters: filters
                                        })).then(function() {
                                            $state.go('app.search');
                                        });
                                    }
                                },
                                donut: {
                                    title: 'Total: ' + total,
                                    label: {
                                        format: function(value) {
                                            return value;
                                        }
                                    }
                                }
                            };
                        },
                        function(/*err*/) {
                            scope.error = true;
                            NotificationSrv.log('Failed to fetch data, please edit the widget definition', 'error');
                        }
                    );
                };

                scope.getCsv = function() {
                    var csv = [];
                    _.each(scope.data, function(val, key) {
                        csv.push({data: key  + ';' + val});
                    });
                    return csv;
                };

                if (scope.autoload === true) {
                    scope.load();
                }

                if (!_.isEmpty(scope.refreshOn)) {
                    scope.$on(scope.refreshOn, function(event, filter) {
                        scope.filter = filter;
                        scope.load();
                    });
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/dashboard/filter-editor.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('filterEditor', function($q, AuthenticationSrv, TaxonomyCacheSrv, UserSrv, TagSrv, UtilsSrv) {
        return {
            restrict: 'E',
            scope: {
                filter: '=?',
                entity: '=',
                metadata: '='
            },
            templateUrl: 'views/directives/dashboard/filter-editor.html',
            link: function(scope) {
                scope.operatorMap = {
                    empty: 'Is Empty',
                    any: 'Any Of',
                    none: 'None Of',
                    all: 'All Of'
                };

                scope.dateOperator = {
                    empty: 'Empty',
                    custom: 'Custom',
                    today: 'Today',
                    last7days: 'Last 7 days',
                    last30days: 'Last 30 days',
                    last3months: 'Last 3 months',
                    last6months: 'Last 6 months',
                    lastyear: 'Last year'
                };

                scope.setDateFilterOperator = function(filter, operator) {
                    operator = operator || 'custom';

                    var dateRange = UtilsSrv.getDateRange(operator);

                    if(operator === 'custom') {
                        filter.value = {
                            operator: operator,
                            from: dateRange.from,
                            to: dateRange.to
                        };
                    } else {
                        filter.value = {
                            operator: operator,
                            from: null,
                            to: null
                        };
                    }

                };

                scope.editorFor = function(filter) {
                    if (filter.type === null) {
                        return;
                    }
                    var field = scope.metadata[scope.entity].attributes[filter.field];

                    if(!field) {
                        return;
                    }

                    if(field.name === 'tags') {
                        return field.name;
                    }

                    var type = field.type;

                    if ((type === 'string' || type === 'number' || type === 'integer'  || type === 'float' ) && field.values.length > 0) {
                        return 'enumeration';
                    }

                    return filter.type;
                };

                scope.fromTagLibrary = function(filter) {
                    TaxonomyCacheSrv.openTagLibrary()
                        .then(function(tags){
                            filter.value.list = filter.value.list.concat(tags);
                        })
                }

                scope.promiseFor = function(filter, query) {
                    var field = scope.metadata[scope.entity].attributes[filter.field];

                    var promise = null;

                    if(field.name === 'tags') {
                        return TagSrv.autoComplete(query);
                    } else if(field.type === 'user') {
                        promise = AuthenticationSrv.current()
                            .then(function(user) {
                                return UserSrv.autoComplete(user.organisation, query);
                            });
                    } else if (field.values.length > 0) {
                        promise = $q.resolve(
                            _.map(field.values, function(item, index) {
                                return {
                                    text: item,
                                    label: field.labels[index] || item
                                };
                            })
                        );
                    } else {
                        promise = $q.resolve([]);
                    }

                    return promise.then(function(response) {
                        var list = [];

                        list = _.filter(response, function(item) {
                            var regex = new RegExp(query, 'gi');
                            return regex.test(item.label);
                        });

                        return $q.resolve(list);
                    });
                };
            }
        };
    });
})();

```

`frontend/app/scripts/directives/dashboard/item.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('dashboardItem', function(DashboardSrv, UserSrv, $uibModal, $timeout) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                rowIndex: '=',
                colIndex: '=',
                component: '=',
                metadata: '=',
                filter: '=?',
                autoload: '=',
                refreshOn: '@',
                resizeOn: '@',
                mode: '=',
                showEdit: '=',
                showRemove: '=',
                onRemove: '&'
            },
            templateUrl: 'views/directives/dashboard/item.html',
            link: function(scope/*, element*/) {
                scope.typeClasses = DashboardSrv.typeClasses;
                scope.timeIntervals = DashboardSrv.timeIntervals;
                scope.aggregations = DashboardSrv.aggregations;
                scope.serieTypes = DashboardSrv.serieTypes;
                scope.sortOptions = DashboardSrv.sortOptions;
                scope.skipFields = DashboardSrv.skipFields;
                scope.pickFields = DashboardSrv.pickFields;
                scope.fieldsForAggregation = DashboardSrv.fieldsForAggregation;

                scope.layout = {
                    activeTab: 0
                };
                scope.query = null;

                if(scope.component.id) {
                    scope.$on('edit-chart-' + scope.component.id, function(/*data*/) {
                        scope.editItem();
                    });
                }

                scope.editItem = function() {
                    var modalInstance = $uibModal.open({
                        scope: scope,
                        controller: ['$scope', '$uibModalInstance', function($scope, $uibModalInstance) {
                            $scope.cancel = function() {
                                $uibModalInstance.dismiss();
                            };

                            $scope.save = function() {
                                $uibModalInstance.close($scope.component.options);
                            };
                        }],
                        templateUrl: 'views/directives/dashboard/edit.dialog.html',
                        size: 'lg'
                    });

                    modalInstance.result.then(function(definition) {
                        var entity = scope.component.options.entity;

                        //if(!entity) {
                        if(!DashboardSrv.hasMinimalConfiguration(scope.component)) {
                            return;
                        }

                        // Set the computed query
                        definition.query = DashboardSrv.buildFiltersQuery(entity ? scope.metadata[entity].attributes : null, scope.component.options.filters);

                        // Set the computed querie of series if available
                        _.each(definition.series, function(serie) {
                            if(serie.filters) {
                                serie.query = DashboardSrv.buildFiltersQuery(scope.metadata[entity || serie.entity].attributes, serie.filters);
                            }
                        });

                        scope.component.options = definition;

                        $timeout(function() {
                            scope.$broadcast(scope.refreshOn, scope.filter);
                        }, 500);
                    });
                };

                scope.addFilter = function() {
                    scope.component.options.filters = scope.component.options.filters || [];

                    scope.component.options.filters.push({
                        field: null,
                        type: null
                    });
                };

                scope.removeFilter = function(index) {
                    scope.component.options.filters.splice(index, 1);
                };

                scope.setFilterField = function(filter, entity) {
                    var field = scope.metadata[entity].attributes[filter.field];

                    if(!field) {
                        return;
                    }

                    filter.type = field.type;

                    if (field.type === 'date') {
                        filter.value = {
                            from: null,
                            to: null
                        };
                    } else {
                        filter.value = null;
                    }
                };

                scope.addSerie = function() {
                    scope.component.options.series = scope.component.options.series || [];

                    scope.component.options.series.push({
                        agg: null,
                        field: null
                    });
                };

                scope.addSerieFilter = function(serie) {
                    serie.filters = serie.filters || [];

                    serie.filters.push({
                        field: null,
                        type: null
                    });
                };

                scope.removeSerieFilter = function(serie, index) {
                    serie.filters.splice(index, 1);
                };


                scope.removeSerie = function(index) {
                    scope.component.options.series.splice(index, 1);
                };

                scope.showQuery = function() {
                    scope.query = DashboardSrv.buildFiltersQuery(scope.metadata[scope.component.options.entity], scope.component.options.filters);
                };
            }
        };
    });
})();

```

`frontend/app/scripts/directives/dashboard/line.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('dashboardLine', function($http, $state, DashboardSrv, NotificationSrv) {
        return {
            restrict: 'E',
            scope: {
                filter: '=?',
                options: '=',
                entity: '=',
                autoload: '=',
                mode: '=',
                refreshOn: '@',
                resizeOn: '@',
                metadata: '='
            },
            template: '<c3 chart="chart" resize-on="{{resizeOn}}" error="error" on-save-csv="getCsv()"></c3>',
            link: function(scope) {
                scope.error = false;
                scope.chart = {};

                scope.intervals = DashboardSrv.timeIntervals;
                scope.interval = scope.intervals[2];

                scope.load = function() {
                    if(!scope.entity) {
                        scope.error = true;
                        return;
                    }

                    var query = DashboardSrv.buildChartQuery(scope.filter, scope.options.query);

                    var statsPromise = $http.post('./api' + scope.entity.path + '/_stats', {
                        query: query,
                        stats: [{
                            _agg: 'time',
                            _fields: [scope.options.field],
                            _interval: scope.options.interval || scope.interval.code,
                            _select: _.map(scope.options.series || [], function(serie, index) {
                                var s = {
                                    _agg: serie.agg,
                                    _name: 'agg_' + (index + 1),
                                    _query: serie.query || {}
                                };

                                if(serie.agg !== 'count') {
                                    s._field = serie.field;
                                }

                                return s;
                            })
                        }]
                    });

                    statsPromise.then(function(response) {
                        scope.error = false;
                        var labels = _.keys(response.data).map(function(d) {
                            return moment(d * 1).format('YYYY-MM-DD');
                        });
                        var len = labels.length,
                            data = {_date: (new Array(len)).fill(0)},
                            rawData = {};

                        _.each(response.data, function(value, key) {
                            rawData[key] = value[scope.options.field];
                        });

                        _.each(rawData, function(value) {
                            _.each(_.keys(value), function(key){
                                data[key] = (new Array(len)).fill(0);
                            });
                        });

                        var i = 0;
                        var orderedDates = _.sortBy(_.keys(rawData));

                        _.each(orderedDates, function(key) {
                            var value = rawData[key];
                            data._date[i] = moment(key * 1).format('YYYY-MM-DD');

                            _.each(_.keys(value), function(item) {
                                data[item][i] = value[item];
                            });

                            i++;
                        });

                        scope.types = {};
                        scope.names = {};
                        scope.axes = {};
                        scope.colors = {};

                        var serieTypes = _.uniq(_.pluck(scope.options.series, 'type')).length;

                        _.each(scope.options.series, function(serie, index) {
                            var key = serie.field,
                                agg = serie.agg,
                                dataKey = agg === 'count' ? 'count' : (agg + '_' + key),
                                columnKey = 'agg_' + (index + 1);

                            scope.types[columnKey] = serie.type || 'line';
                            scope.names[columnKey] = serie.label || (agg === 'count' ? 'count' : (agg + ' of ' + key));
                            scope.axes[columnKey] = serieTypes === 1 ? 'y' : ((scope.types[columnKey] === 'bar') ? 'y2' : 'y');
                            scope.colors[columnKey] = serie.color;
                        });

                        // Compute stack groups
                        var groups = {};
                        _.each(scope.types, function(value, key) {
                            if (groups[value]) {
                                groups[value].push(key);
                            } else {
                                groups[value] = [key];
                            }
                        });
                        scope.groups = scope.options.stacked === true ? _.values(groups) : {};

                        scope.data = data;

                        var chart = {
                            data: {
                                x: '_date',
                                json: scope.data,
                                names: scope.names || {},
                                type: scope.type || 'bar',
                                types: scope.types || {},
                                axes: scope.axes || {},
                                colors: scope.colors || {},
                                groups: scope.groups || []
                            },
                            bar: {
                                width: {
                                    ratio: 1 - Math.exp(-len/20)
                                }
                            },
                            axis: {
                                x: {
                                    type: 'timeseries',
                                    tick: {
                                        format: '%Y-%m-%d',
                                        rotate: 90,
                                        height: 50
                                    }
                                },
                                y2: {
                                    show: _.values(scope.axes).indexOf('y2') !== -1
                                }
                            },
                            zoom: {
                                enabled: scope.options.zoom || false
                            }
                        };

                        scope.chart = chart;
                    }, function(err) {
                        scope.error = true;                        
                        NotificationSrv.error('dashboardBar', 'Failed to fetch data, please edit the widget definition', err.status);
                    });
                };

                scope.getCsv = function() {
                    var dates = scope.data._date;
                    var keys = _.keys(scope.data);
                    var headers = _.extend({_date: 'Date'}, scope.names);

                    var csv = [{data: _.map(keys, function(key){
                        return headers[key] || key;
                    }).join(';')}];

                    var row = [];
                    for(var i=0; i<dates.length; i++) {
                        row = _.map(keys, function(key) {
                            return scope.data[key][i];
                        });

                        csv.push({data: row.join(';')});
                    }

                    return csv;
                };

                if (scope.autoload === true) {
                    scope.load();
                }

                if (!_.isEmpty(scope.refreshOn)) {
                    scope.$on(scope.refreshOn, function(event, filter) {
                        scope.filter = filter;
                        scope.load();
                    });
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/dashboard/multiline.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('dashboardMultiline', function($http, $state, DashboardSrv, NotificationSrv) {
        return {
            restrict: 'E',
            scope: {
                filter: '=?',
                options: '=',
                entity: '=',
                autoload: '=',
                mode: '=',
                refreshOn: '@',
                resizeOn: '@',
                metadata: '='
            },
            template: '<c3 chart="chart" resize-on="{{resizeOn}}" error="error" on-save-csv="getCsv()"></c3>',
            link: function(scope) {
                scope.error = false;
                scope.chart = {};

                scope.intervals = DashboardSrv.timeIntervals;
                scope.interval = scope.intervals[2];

                scope.buildSelect = function(serie, index) {
                    var s = {
                        _agg: serie.agg,
                        _name: 'agg_' + (index + 1),
                        _query: serie.query || {}
                    };

                    if(serie.agg !== 'count') {
                        s._field = serie.field;
                    }

                    return s;
                };

                scope.buildSerie = function(serie, q, index) {
                    return {
                        model: serie.entity,
                        query: q,
                        stats: [{
                            _agg: 'time',
                            _fields: [serie.dateField],
                            _interval: scope.options.interval || scope.interval.code,
                            _select: [scope.buildSelect(serie, index)]
                        }]
                    };
                };

                scope.load = function() {
                    if(!scope.options.series || scope.options.series.length === 0) {
                        scope.error = true;
                        return;
                    }

                    var query = DashboardSrv.buildChartQuery(scope.filter, scope.options.query);
                    var postData = {
                        stats: _.map(scope.options.series, function(serie, index) {
                            return scope.buildSerie(serie, query, index);
                        })
                    };

                    var statsPromise = $http.post('./api/_stats', postData);

                    statsPromise.then(function(response) {
                        scope.error = false;
                        var labels = _.keys(response.data).map(function(d) {
                            return moment(d * 1).format('YYYY-MM-DD');
                        });
                        var len = labels.length,
                            data = {_date: (new Array(len)).fill(0)},
                            rawData = {};

                        _.each(response.data, function(value, key) {
                            //rawData[key] = value[scope.options.field]
                            rawData[key] = {};
                            _.each(_.values(value), function(val) {
                                _.extend(rawData[key], val);
                            });
                        });

                        _.each(rawData, function(value) {
                            _.each(_.keys(value), function(key){
                                data[key] = (new Array(len)).fill(0);
                            });
                        });

                        var i = 0;
                        var orderedDates = _.sortBy(_.keys(rawData));

                        _.each(orderedDates, function(key) {
                            var value = rawData[key];
                            data._date[i] = moment(key * 1).format('YYYY-MM-DD');

                            _.each(_.keys(value), function(item) {
                                data[item][i] = value[item];
                            });

                            i++;
                        });

                        scope.types = {};
                        scope.names = {};
                        scope.axes = {};
                        scope.colors = {};

                        var serieTypes = _.uniq(_.pluck(scope.options.series, 'type')).length;

                        _.each(scope.options.series, function(serie, index) {
                            var key = serie.field,
                                agg = serie.agg,
                                columnKey = 'agg_' + (index + 1);

                            scope.types[columnKey] = serie.type || 'line';
                            scope.names[columnKey] = serie.label || (agg === 'count' ? 'count' : (agg + ' of ' + key));
                            scope.axes[columnKey] = serieTypes === 1 ? 'y' : ((scope.types[columnKey] === 'bar') ? 'y2' : 'y');
                            scope.colors[columnKey] = serie.color;
                        });

                        // Compute stack groups
                        var groups = {};
                        _.each(scope.types, function(value, key) {
                            if (groups[value]) {
                                groups[value].push(key);
                            } else {
                                groups[value] = [key];
                            }
                        });
                        scope.groups = scope.options.stacked === true ? _.values(groups) : {};

                        scope.data = data;

                        var chart = {
                            data: {
                                x: '_date',
                                json: scope.data,
                                names: scope.names || {},
                                type: scope.type || 'bar',
                                types: scope.types || {},
                                axes: scope.axes || {},
                                colors: scope.colors || {},
                                groups: scope.groups || []
                            },
                            bar: {
                                width: {
                                    ratio: 1 - Math.exp(-len/20)
                                }
                            },
                            axis: {
                                x: {
                                    type: 'timeseries',
                                    tick: {
                                        format: '%Y-%m-%d',
                                        rotate: 90,
                                        height: 50
                                    }
                                },
                                y2: {
                                    show: _.values(scope.axes).indexOf('y2') !== -1
                                }
                            },
                            zoom: {
                                enabled: scope.options.zoom || false
                            }
                        };

                        scope.chart = chart;
                    }, function(err) {
                        scope.error = true;
                        NotificationSrv.error('dashboardBar', 'Failed to fetch data, please edit the widget definition', err.status);
                    });
                };

                scope.getCsv = function() {
                    var dates = scope.data._date;
                    var keys = _.keys(scope.data);
                    var headers = _.extend({_date: 'Date'}, scope.names);

                    var csv = [{data: _.map(keys, function(key){
                        return headers[key] || key;
                    }).join(';')}];

                    var row = [];
                    for(var i=0; i<dates.length; i++) {
                        row = _.map(keys, function(key) {
                            return scope.data[key][i];
                        });

                        csv.push({data: row.join(';')});
                    }

                    return csv;
                };

                if (scope.autoload === true) {
                    scope.load();
                }

                if (!_.isEmpty(scope.refreshOn)) {
                    scope.$on(scope.refreshOn, function(event, filter) {
                        scope.filter = filter;
                        scope.load();
                    });
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/dashboard/text.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('dashboardText', function($q, $http, $state, DashboardSrv, GlobalSearchSrv, NotificationSrv) {
        return {
            restrict: 'E',
            scope: {
                filter: '=?',
                options: '=',
                entity: '=',
                autoload: '=',
                mode: '=',
                refreshOn: '@',
                resizeOn: '@',
                metadata: '='
            },
            templateUrl: 'views/directives/dashboard/text/view.html',
            link: function(scope, elem) {

                scope.error = false;
                scope.data = null;
                scope.globalQuery = null;

                scope.load = function() {
                    if(!scope.options.series || scope.options.series.length === 0) {
                        scope.error = true;
                        return;
                    }

                    var query = DashboardSrv.buildChartQuery(scope.filter, scope.options.query);
                    scope.globalQuery = query;

                    var stats = {
                        stats: _.map(scope.options.series || [], function(serie, index) {
                            var s = {
                                _agg: serie.agg,
                                _name: serie.name || 'agg_' + (index + 1),
                                _query: serie.query || {}
                            };

                            if(serie.agg !== 'count') {
                                s._field = serie.field;
                            }

                            return {
                                model: serie.entity,
                                query: query,
                                stats: [s]
                            };
                        })
                    };

                    var statsPromise = $http.post('./api/_stats', stats);

                    statsPromise.then(function(response) {
                        scope.error = false;
                        scope.data = response.data;

                        var template = scope.options.template;
                        Object.keys(scope.data).forEach(function(key){
                            var regex = new RegExp('{{' + key + '}}', 'gi');

                            template = template.replace(regex, scope.data[key]);
                        });

                        scope.content = template;

                    }, function(err) {
                        scope.error = true;
                        NotificationSrv.error('dashboardBar', 'Failed to fetch data, please edit the widget definition', err.status);
                    });
                };

                scope.copyHTML = function() {
                    var html = elem[0].querySelector('.widget-content').innerHTML;
                    function listener(e) {
                        e.clipboardData.setData('text/html', html);
                        e.clipboardData.setData('text/plain', html);
                        e.preventDefault();
                    }
                    document.addEventListener('copy', listener);
                    document.execCommand('copy');
                    document.removeEventListener('copy', listener);
                }

                if (scope.autoload === true) {
                    scope.load();
                }

                if (!_.isEmpty(scope.refreshOn)) {
                    scope.$on(scope.refreshOn, function(event, filter) {
                        scope.filter = filter;
                        scope.load();
                    });
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/dateTimePicker.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('dateTimePicker', function($interval, moment) {

        function updateTime(scope) {
            if (scope.dateNow) {
                var now = moment();
                scope.humanDate = now.format('DD-MM-YYYY HH:mm');

                if (!angular.isDefined(scope.timeUpdater)) {
                    scope.timeUpdater = $interval(function() {
                        updateTime(scope);
                    }, 60000);
                }
            } else if (angular.isDefined(scope.timeUpdater)) {
                $interval.cancel(scope.timeUpdater);
                scope.timeUpdater = undefined;
            }
        }

        function link(scope, element) {
            $(element).find('.input-datetime').datetimepicker({
                format: 'dd-mm-yyyy hh:ii',
                weekStart: 1,
                startView: 1,
                todayBtn: true,
                language: 'fr',
                autoclose: true
            });

            scope.dateNow = true;
            scope.timeUpdater = undefined;
            scope.$watch('dateNow', function() {
                updateTime(scope);
            });
            scope.$watch('humanDate', function() {
                //scope.isoDate = moment(scope.humanDate, 'DD-MM-YYYY HH:mm').format('YYYYMMDDTHHmmssZZ');
                //scope.isoDate = moment(scope.humanDate, 'DD-MM-YYYY HH:mm');
                var m = moment(scope.humanDate, 'DD-MM-YYYY HH:mm');
                if (m.isValid()) {
                    scope.isoDate = m.valueOf();
                }
            });
        }

        return {
            restrict: 'EA',
            link: link,
            templateUrl: 'views/directives/date-time-picker.html',
            scope: {
                isoDate: '=date'
            }
        };
    });
})();

```

`frontend/app/scripts/directives/dt-picker.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('dtPicker', function() {
        return {
            restrict: 'E',
            scope: {
                'date': '=',
                placeholder: '@?',
                required: '='
            },
            templateUrl: 'views/directives/dt-picker.html',
            link: function(scope, elem) {
                var dtEl = $(elem).find('.input-datetime');
                /*var dtPicker = */
                dtEl.datetimepicker({
                    format: 'dd-mm-yyyy',
                    weekStart: 1,
                    startView: 2,
                    minView: 2,
                    autoclose: true
                });

                if(scope.date){
                    scope.dateValue = moment(scope.date).format('DD-MM-YYYY');
                }

                scope.$watch('date', function(date) {
                    if(date) {
                        scope.dateValue = moment(scope.date).format('DD-MM-YYYY');
                    } else {
                        scope.dateValue = null;
                    }
                });

                scope.$watch('dateValue', function(dateValue) {
                    var m = moment(dateValue, 'DD-MM-YYYY');
                    if (m.isValid()) {
                        scope.date = m.toDate();
                    } else {
                        scope.date = null;
                        $(elem).find('input').val(null);
                    }
                });

                scope.clear = function() {
                    scope.dateValue = null;
                };

                elem.on('$destroy', function() {
                    dtEl.datetimepicker('remove');
                });
            }
        };
    });

})();

```

`frontend/app/scripts/directives/entityLink.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('entityLink', function($compile, EntitySrv, $window) {
        return {
            compile: function(tElement, tAttr, transclude) {
                var contents = tElement.contents().remove();
                var compiledContents;
                return function(scope, iElement) {

                    scope.openEntity = EntitySrv.open;
                    scope.entityUrl = EntitySrv.link;
                    scope.openLink = function(link) {
                        if (scope.target) {
                            scope.target.location.href = link;
                        } else {
                            $window.location.href = link;
                        }
                    };

                    if (angular.isDefined(scope.value)) {
                        if (!compiledContents) {
                            // Get the link function with the contents frome top
                            // level template with
                            // the transclude
                            compiledContents = $compile(contents, transclude);
                        }
                        // Call the link function to link the given scope and
                        // a Clone Attach Function,
                        // http://docs.angularjs.org./api/ng.$compile :
                        // "Calling the linking function returns the element of the
                        // template.
                        // It is either the original element passed in,
                        // or the clone of the element if the cloneAttachFn is
                        // provided."
                        compiledContents(scope, function(clone) {
                            // Appending the cloned template to the instance
                            // element, "iElement",
                            // on which the directive is to used.
                            iElement.append(clone);
                        });
                    }
                };
            },
            restrict: 'E',
            templateUrl: 'views/directives/entity-link.html',
            scope: {
                'value': '=',
                'target': '='
            }
        };
    });
})();

```

`frontend/app/scripts/directives/fileChooser.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('fileChooser', function() {
        return {
            'restrict': 'A',
            'link': function(scope, element) {
                var dropzone;
                element.addClass('dropzone');
                var template = element[0].innerHTML;
                $(element[0].children[0]).remove();
                // create a Dropzone for the element with the given options
                dropzone = new Dropzone(element[0], {
                    'url': 'dummy',
                    'autoProcessQueue': false,
                    'maxFiles': 1,
                    'createImageThumbnails': (angular.isString(scope.preview)) ? (scope.preview === 'true') : true,
                    'acceptedFiles': (angular.isString(scope.accept)) ? scope.accept : undefined,
                    'previewTemplate': template
                });

                dropzone.on('addedfile', function(file) {
                    scope.$apply(function() {
                        scope.filemodel = file;
                    });
                });
                dropzone.on('removedfile', function() {
                    var files = this.files;

                    if(files && files.length !== 1) {
                        setTimeout(function() {
                            scope.$apply(function() {
                                delete scope.filemodel;
                            });
                        }, 0);
                    } else {
                        scope.$apply(function() {
                            scope.filemodel = files[0];
                        });
                    }
                });
                dropzone.on('maxfilesexceeded', function(file) {
                    this.removeFile(file);
                });
                if (angular.isDefined(scope.control)) {
                    scope.control.removeAllFiles = function() {
                        dropzone.removeAllFiles();
                    };
                }
                //  else {
                //     console.log('Don\'t add removeAllFiles function as control object is not defined');
                // }
            },
            'templateUrl': 'views/directives/dropzone.html',
            'scope': {
                'filemodel': '=',
                'control': '=',
                'preview': '@?',
                'accept': '@?'
            }
        };
    });

})();

```

`frontend/app/scripts/directives/filter-box.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('filterBox', function() {
            return {
                restrict: 'E',
                templateUrl: 'views/directives/filter-box.html',
                scope: {
                    collection: '=',
                    query: '=?'
                },
                link: function(scope) {
                    scope.query = scope.query || '';

                    scope.clear = function() {
                        scope.query = '';
                        scope.collection.filter = {};
                        scope.collection.update();
                    };

                    scope.filter = function() {
                        if (!scope.query.trim()) {
                            scope.collection.filter = {};
                        } else {
                            scope.collection.filter = {
                                _string: scope.query
                            };
                        }

                        scope.collection.update();
                    };
                }
            };
        });
})();

```

`frontend/app/scripts/directives/fixed-height.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('fixedHeight', function($window, $timeout) {
        return {
            restrict: 'A',
            link: function(scope, elem) {

                $timeout(function() {
                    var windowHeight = $(window).height();
                    var footerHeight = $('.main-footer').outerHeight();
                    var headerHeight = $('.main-header').height();

                    elem.css('min-height', (windowHeight - headerHeight - footerHeight) + "px");
                }, 500);

                angular.element($window).bind('resize', function() {
                    var windowHeight = $(window).height();
                    var footerHeight = $('.main-footer').outerHeight();
                    var headerHeight = $('.main-header').height();

                    elem.css('min-height', (windowHeight - headerHeight - footerHeight) + "px");
                });

            }
        };
    });

})();

```

`frontend/app/scripts/directives/flow/flow-item.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveDirectives')
        .directive('flowItem', function($uibModal, $state, $window, HtmlSanitizer, UserSrv, AttackPatternSrv) {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    data: '=',
                    type: '@',
                    target: '='
                },
                link: function(scope /*, element, attrs*/ ) {
                    scope.base = scope.data.base;
                    scope.summary = scope.data.summary || {};

                    scope.operationUrl = 'views/directives/flow/operation.html';
                    scope.getContentUrl = function() {
                        return 'views/directives/flow/' + scope.type + '.html';
                    };
                    scope.gtime = function(startdate) {
                        return moment(startdate).toDate().getTime();
                    };
                    scope.isImage = function(contentType) {
                        return angular.isString(contentType) && contentType.indexOf('image') === 0;
                    };
                    scope.showImage = function(attachmentId, attachmentName) {
                        $uibModal.open({
                            template: '<img style="width:100%" src="./api/datastore/' + HtmlSanitizer.sanitize(attachmentId) + '" alt="' + HtmlSanitizer.sanitize(attachmentName) + '"></img>',
                            size: 'lg'
                        });
                    };
                    scope.getUserInfo = UserSrv.getCache;

                    scope.openState = function(state, params) {
                        scope.openLink($state.href(state, params));
                    };

                    scope.openLink = function(link) {
                        if (scope.target) {
                            scope.target.location.href = link;
                        } else {
                            $window.location.href = link;
                        }
                    };

                    scope.isBulkOperation = function() {
                        var operation = scope.base.operation;
                        var type = scope.base.objectType;

                        var typeSummary = scope.data.summary[type];

                        if(typeSummary[operation] !== 1 || _.keys(typeSummary).length > 1 || _.keys(scope.data.summary).length > 1) {
                            return true;
                        }

                        return false;
                    };

                    scope.tactics = AttackPatternSrv.tactics.values;

                    scope.bulk = scope.isBulkOperation();
                },
                templateUrl: 'views/directives/flow/flow-item.html'
            };
        });
})();

```

`frontend/app/scripts/directives/flow/flow.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveDirectives')
        .directive('flow', function(AuditSrv, AnalyzerInfoSrv, UserSrv) {
            return {
                restrict: 'E',
                templateUrl: 'views/directives/flow/flow.html',
                controller: function($scope, $window) {
                    this.$onInit = function() {
                        var rootId = '';
                        if (angular.isString($scope.root)) {
                            rootId = $scope.root;
                        } else {
                            rootId = 'any';
                        }

                        this.values = AuditSrv(rootId, parseInt($scope.max), $scope);
                    }

                    if ($window.opener) {
                        $scope.targetWindow = $window.opener;
                    }
                },
                controllerAs: '$flow',
                scope: {
                    'root': '@?',
                    'max': '@?'
                },
                link: function(scope) {
                    scope.getAnalyzerInfo = AnalyzerInfoSrv;
                    scope.getUserInfo = UserSrv.getCache;
                },
            };
        });
})();

```

`frontend/app/scripts/directives/if-not-permission.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('ifNotPermission', function(AuthenticationSrv, SecuritySrv) {
        return {
            restrict: 'A',
            scope: false,
            link: function(scope, element, attrs) {
                var restrictedPermissions = _.map((attrs.ifNotPermission || '').split(','), function(item){
                    return s.trim(item);
                });

                if(attrs.allowed !== undefined) {
                    // Check the list of specified allowed permissions
                    if(SecuritySrv.checkPermissions(restrictedPermissions, attrs.allowed)) {
                        element.remove();
                    }
                } else if(AuthenticationSrv.hasPermission(restrictedPermissions)){
                    // Check the user defined permissions
                    element.remove();
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/if-permission.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('ifPermission', function(AuthenticationSrv, SecuritySrv) {
        return {
            restrict: 'A',
            scope: false,
            link: function(scope, element, attrs) {
                var requiredPermissions = _.map((attrs.ifPermission || '').split(','), function(item){
                    return s.trim(item);
                });

                if(attrs.allowed !== undefined) {
                    // Check the list of specified allowed permissions
                    if(!SecuritySrv.checkPermissions(requiredPermissions, attrs.allowed)) {
                        element.remove();
                    }
                } else if(!AuthenticationSrv.hasPermission(requiredPermissions)){
                    // Check the user defined permissions
                    element.remove();
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/logEntry.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('logEntry', function($uibModal, HtmlSanitizer, PaginatedQuerySrv, TaskLogSrv, UserSrv, NotificationSrv) {
            return {
                templateUrl: 'views/directives/log-entry.html',
                controller: function($scope, CortexSrv, PaginatedQuerySrv) {
                    $scope.showActions = false;
                    $scope.actions = null;
                    $scope.logResponders = null;
                    $scope.getLogResponders = function(taskLog, force) {
                        if(!force && $scope.logResponders !== null) {
                           return;
                        }

                        $scope.logResponders = null;
                        CortexSrv.getResponders('case_task_log', taskLog._id)
                            .then(function(responders) {
                                $scope.logResponders = responders;
                                return CortexSrv.promntForResponder(responders);
                            })
                            .then(function(response) {
                                if(response && _.isString(response)) {
                                    NotificationSrv.log(response, 'warning');
                                } else {
                                    return CortexSrv.runResponder(response.id, response.name, 'case_task_log', _.pick(taskLog, '_id'));
                                }
                            })
                            .then(function(response){
                                NotificationSrv.log(['Responder', response.data.responderName, 'started successfully on task log'].join(' '), 'success');
                            })
                            .catch(function(err) {
                                if(err && !_.isString(err)) {
                                    NotificationSrv.error('logEntry', err.data, err.status);
                                }
                            });
                    };

                    $scope.getActions = function(logId) {
                        $scope.actions = new PaginatedQuerySrv({
                            name: 'task-log-actions',
                            version: 'v1',
                            scope: $scope,
                            streamObjectType: 'action',
                            loadAll: true,
                            sort: ['-startDate'],
                            pageSize: 100,
                            operations: [
                                { '_name': 'getLog', 'idOrName': logId },
                                { '_name': 'actions' }
                            ],
                            guard: function(updates) {
                                return _.find(updates, function(item) {
                                    return (item.base.details.objectType === 'Log') && (item.base.details.objectId === logId);
                                }) !== undefined;
                            }
                        });
                    };
                },
                link: function(scope) {

                    // drop log
                    scope.dropLog = function() {
                        scope.deleteModal = $uibModal.open({
                            scope: scope,
                            templateUrl: 'views/directives/log-entry-delete.html',
                            size: ''
                        });
                    };

                    scope.confirmDropLog = function() {
                        TaskLogSrv.delete({
                            logId: scope.log._id
                        }).$promise.then(function() {
                            scope.deleteModal.dismiss();
                        });
                    };

                    scope.cancelDropLog = function() {
                        scope.deleteModal.dismiss();
                    };

                    scope.updateLog = function() {
                        return TaskLogSrv.update({
                            logId: scope.log._id
                        }, {message: scope.log.message}, function() {}, function(response) {
                            NotificationSrv.error('CaseTaskLog', response.data, response.status);
                        });
                    };

                    scope.isImage = function(contentType) {
                        return angular.isString(contentType) && contentType.indexOf('image') === 0;
                    };
                    scope.showImage = function() {
                        var fileName = HtmlSanitizer.sanitize(scope.log.attachment.name);
                        var fileId = HtmlSanitizer.sanitize(scope.log.attachment.id);

                        $uibModal.open({
                            template: '<img style="width:100%" src="./api/datastore/' + fileId + '" alt="' + fileName + '"></img>',
                            size: 'lg'
                        });
                    };
                    scope.getUserInfo = UserSrv.getCache;
                },
                restrict: 'EA',
                scope: {
                    log: '=',
                    appConfig: '=',
                    permissions: '='
                }
            };
        });
})();

```

`frontend/app/scripts/directives/mini-report-list.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('miniReportList', function() {
            return {
                restrict: 'E',
                templateUrl: 'views/directives/mini-report-list.html',
                scope: {
                    observable: '=',
                    reports: '=',
                    onItemClicked: '&'
                },
                link: function(scope) {
                    scope.taxonomies = [];

                    scope.$watch('reports', function(data) {
                        var keys = _.keys(data);
                        var taxonomies = [];

                        _.each(keys, function(key) {
                            taxonomies = taxonomies.concat(_.map(data[key].taxonomies || [], function(item) {
                                item.id = key;
                                return item;
                            }));
                        });

                        scope.taxonomies = taxonomies;
                    });
                }
            };
        });
})();

```

`frontend/app/scripts/directives/page-sizer.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('pageSizer', function() {
            return {
                restrict: 'E',
                templateUrl: 'views/directives/page-sizer.html',
                scope: {
                    collection: '=',
                    sizes: '=?',
                    cls: '@?'
                },
                link: function(scope) {
                    if (!scope.sizes) {
                        scope.sizes = [10, 30, 100];
                    }
                }
            };
        });
})();

```

`frontend/app/scripts/directives/permission-list.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('permissionList', function() {
            return {
                restrict: 'E',
                templateUrl: 'views/directives/permission-list.html',
                scope: {
                    permissions: '=',
                    showLabel: '=',
                    label: '='
                }
            };
        });
})();

```

`frontend/app/scripts/directives/psearch.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('psearch', function() {
            return {
                'restrict': 'E',
                'templateUrl': 'views/directives/psearch.html',
                'scope': {
                    'control': '='
                }
            };
        });
})();

```

`frontend/app/scripts/directives/report-observables.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('reportObservables', function($q, $filter, $uibModal) {
        return {
            restrict: 'E',
            scope: {
                origin: '=',
                observables: '=',
                analyzer: '=',
                caseId: '=',
                permissions: '=',
                onRefresh: '&?'
            },
            templateUrl: 'views/directives/report-observables.html',
            link: function(scope) {
                scope.$watch('observables', function() {
                    scope.selected = 0;
                    scope.groups = _.groupBy(scope.observables, 'dataType');
                    scope.pagination = {
                        pageSize: 10,
                        currentPage: 1,
                        filter: '',
                        data: scope.observables
                    };

                    _.each(scope.observables, function(item) {
                        item.imported = !!item.stats.observableId;
                    });
                });
            },
            controller: function($scope) {
                $scope.filterArtifacts = function(type) {
                    $scope.pagination.filter = type;
                    $scope.pagination.currentPage = 1;

                    if(type !== '') {
                        $scope.pagination.data = $scope.groups[type];
                    } else {
                        $scope.pagination.data = $scope.observables;
                    }
                };

                $scope.selectObservable = function(observable) {
                    if(!!observable.stats.imported) {
                        return;
                    }
                    if(observable.selected === true) {
                        $scope.selected++;
                    } else {
                        $scope.selected--;
                    }
                };

                $scope.selectAll = function() {
                    var type = $scope.pagination.filter;
                    _.each(type === '' ? $scope.observables : $scope.groups[type], function(item) {
                        //if(!item.id && !item.selected) {
                        if(!item.imported && !item.selected) {
                            item.selected = true;
                            $scope.selected++;
                        }
                    });
                };

                $scope.clearSelection = function() {
                    _.each($scope.observables, function(item) {
                        delete item.selected;
                    });
                    $scope.selected = 0;
                };

                $scope.import = function() {
                    var toImport = _.groupBy(_.filter($scope.observables, function(item) {
                        return item.selected === true;
                    }), 'dataType');

                    var message = [
                        '### Discovered from:',
                        '- Observable: **['+ $scope.origin.dataType + '] - ' + $filter('fang')($scope.origin.data) + '**',
                        '- Analyzer: **'+ $scope.analyzer + '**'
                    ].join('\n');

                    _.each(toImport, function(list, key) {
                        var params = {
                            dataType: key,
                            single: list.length === 1,
                            ioc: false,
                            sighted: false,
                            ignoreSimilarity: false,
                            tlp: 2,
                            message: message,
                            tags: [{text: 'src:' + $scope.analyzer}]
                        };

                        if(key === 'file') {
                            params.attachment = _.pluck(list, 'attachment');
                            params.isUpload = false;
                        } else {
                            params.data = _.pluck(list, 'data').join('\n');
                        }

                        var modal = $uibModal.open({
                            animation: 'true',
                            templateUrl: 'views/partials/observables/observable.creation.html',
                            controller: 'ObservableCreationCtrl',
                            size: 'lg',
                            resolve: {
                                params: function() {
                                    return params;
                                }
                            }
                        });

                        modal.result
                          .then(function(/*response*/) {
                              _.each(list, function(item) {
                                  //item.id = true;
                                  item.imported = true;
                                  item.selected = false;
                              });

                              if($scope.onRefresh) {
                                  $scope.onRefresh();
                              }
                          });
                    });


                };
            }
        };
    });

})();

```

`frontend/app/scripts/directives/report.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('report', function ($templateRequest, $q, $compile) {
            function updateReport(a, b, scope) {
                if (!angular.isDefined(scope.content) || !angular.isDefined(scope.name)) {
                    scope.element.html('');
                    return;
                }

                var reportUrl = './api/connector/cortex/analyzer/template/content/' + scope.name;

                // find report template
                $templateRequest(reportUrl, true)
                    .then(function (tmpl) {
                        scope.element.append($compile(tmpl)(scope));
                    }, function (/*response*/) {
                        $templateRequest('views/reports/default.html', true)
                            .then(function (tmpl) {
                                scope.element.append($compile(tmpl)(scope));
                            });
                    });
            }

            return {
                restrict: 'E',
                scope: {
                    name: '=',
                    artifact: '=',
                    status: '=',
                    content: '=',
                    success: '='
                },
                link: function (scope, element) {
                    scope.element = element;
                    scope.$watchGroup(['name', 'content', 'status'], updateReport);
                }
            };
        });
})();

```

`frontend/app/scripts/directives/responder-actions.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('responderActions', function() {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                actions: '=',
                header: '@'
            },
            templateUrl: 'views/directives/responder-actions.html',
            controller: function($scope, $uibModal) {

                $scope.$watchCollection('actions.values', function(list) {
                    if(!list) {
                        return;
                    }

                    _.each(_.isArray(list) ? list : list.values, function(action) {
                        if (action.status === 'Failure') {
                            action.errorMessage = (JSON.parse(action.report) || {}).errorMessage;
                        }
                    });
                });


                $scope.showResponderJob = function(action) {
                    $uibModal.open({
                        scope: $scope,
                        templateUrl: 'views/partials/cortex/responder-action-dialog.html',
                        controller: 'ResponderActionDialogCtrl',
                        controllerAs: '$dialog',
                        size: 'max',
                        resolve: {
                            action: function() {
                                return action;
                            }
                        }
                    });
                };
            }
        };
    });
})();

```

`frontend/app/scripts/directives/search/search-item.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveDirectives')
        .directive('searchItem', function($uibModal, HtmlSanitizer, UserSrv) {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    'value': '=',
                    'type': '@',
                    'icon': '@',
                    onTitleClicked: '&'
                },
                link: function(scope /*, element, attrs*/ ) {
                    scope.getContentUrl = function() {
                        return 'views/directives/search/' + scope.type + '.html';
                    };
                    scope.isImage = function(contentType) {
                        return angular.isString(contentType) && contentType.indexOf('image') === 0;
                    };
                    scope.showImage = function(attachmentId, attachmentName) {
                        $uibModal.open({
                            template: '<img style="width:100%" src="./api/datastore/' + HtmlSanitizer.sanitize(attachmentId) + '" alt="' + HtmlSanitizer.sanitize(attachmentName) + '"></img>',
                            size: 'lg'
                        });
                    };
                    scope.getUserInfo = UserSrv.getCache;
                },
                templateUrl: 'views/directives/search/search-item.html'
            };
        });
})();

```

`frontend/app/scripts/directives/severity.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('severity', function(UtilsSrv) {
        return {
            restrict: 'E',
            scope: {
                value: '=',
                active: '=?',
                onUpdate: '&'
            },
            templateUrl: 'views/directives/severity.html',
            link: UtilsSrv.updatableLink,
            controller: function($scope) {
                if ($scope.value === undefined || $scope.value === null || $scope.value === '') {
                    $scope.value = 2;
                }
            }
        };
    });
})();

```

`frontend/app/scripts/directives/tag-colour.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveDirectives').directive('tagColour', function ($timeout, TaxonomyCacheSrv, TagSrv) {
        return {
            restrict: 'A',
            scope: {
                tag: '='
            },
            link: function (scope, element/*, attrs*/) {
                if (!scope.tag) {
                    return;
                }

                scope.bgColour = TaxonomyCacheSrv.getColour(scope.tag) ||
                    TaxonomyCacheSrv.getColour('_freetags_:' + scope.tag) ||
                    TagSrv.tagsDefaultColour ||
                    '#000000';

                $timeout(function () {
                    angular.element(element[0]).attr('style', 'background-color:' + scope.bgColour);
                });
            }
        };
    });
})();

```

`frontend/app/scripts/directives/tag-item.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveDirectives').directive('tagItem', function (TaxonomyCacheSrv, TagSrv) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                value: '=',
                colour: '='
            },
            templateUrl: 'views/directives/tag-item.html',
            link: function (scope/*, element, attrs*/) {
                if (!scope.value) {
                    return;
                }
                if (_.isString(scope.value)) {
                    scope.tag = scope.value;
                    scope.bgColor = scope.colour ||
                        TaxonomyCacheSrv.getColour(scope.value) ||
                        TaxonomyCacheSrv.getColour('_freetags_:' + scope.value) ||
                        TagSrv.tagsDefaultColour ||
                        '#000000';
                } else {
                    scope.tag = _.without([
                        scope.value.namespace,
                        ':',
                        scope.value.predicate,
                        scope.value.value ? ("=\"" + scope.value.value + "\"") : null
                    ], null).join('');
                    scope.bgColor = scope.value.colour ||
                        scope.colour ||
                        TagSrv.tagsDefaultColour ||
                        '#000000';
                }

                scope.$watch('colour', function (value) {
                    if (!value) {
                        return;
                    }
                    scope.bgColor = value;
                });

                scope.$watch('value', function (value) {
                    if (!value) {
                        return;
                    }

                    if (_.isString(value)) {
                        scope.tag = value;
                    } else {
                        scope.tag = _.without([
                            value.namespace,
                            ':',
                            value.predicate,
                            value.value ? ("=\"" + value.value + "\"") : null
                        ], null).join('');
                    }
                });
            }
        };
    });

})();

```

`frontend/app/scripts/directives/tag-list.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('tagList', function() {
        return {
            restrict: 'E',
            scope: {
                data: '='
            },
            templateUrl: 'views/directives/tag-list.html'
        };
    });

})();

```

`frontend/app/scripts/directives/task-progress.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('taskProgress', function() {
            return {
                restrict: 'E',
                scope: {
                    'tasks': '='
                },
                link: function(scope) {
                    if(scope.tasks) {
                        if (scope.tasks.total === 0) {
                            scope.completed = 'width: 0%';
                            scope.progress = 'width: 0%';
                            scope.waiting = 'width: 0%';
                            scope.cancel = 'width: 0%';
                        } else {
                            scope.completed = 'width: ' + (((scope.tasks.Completed || 0) / scope.tasks.total) * 100) + '%';
                            scope.progress = 'width: ' + (((scope.tasks.InProgress || 0) / scope.tasks.total) * 100) + '%';
                            scope.waiting = 'width: ' + (((scope.tasks.Waiting || 0) / scope.tasks.total) * 100) + '%';
                            scope.cancel = 'width: ' + (((scope.tasks.Cancel || 0) / scope.tasks.total) * 100) + '%';
                        }
                    }
                },
                'templateUrl': 'views/directives/task-progress.html'
            };
        });

})();

```

`frontend/app/scripts/directives/tlp.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('tlp', function(UtilsSrv) {
        return {
            restrict: 'E',
            scope: {
                value: '=',
                format: '=?',
                onUpdate: '&',
                namespace: '@'
            },
            'link': UtilsSrv.updatableLink,
            'templateUrl': 'views/directives/tlp.html',
            controller: function($scope) {
                if ($scope.value === null || $scope.value === undefined) {
                    $scope.value = 2;
                }
            }
        };
    });

})();

```

`frontend/app/scripts/directives/updatable.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatable', function(UtilsSrv) {
            return {
                'restrict': 'E',
                'link': UtilsSrv.updatableLink,
                'transclude': true,
                'templateUrl': 'views/directives/updatable.html',
                'scope': {
                    'value': '=?',
                    'onUpdate': '&',
                    'active': '=?'
                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableBoolean.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableBoolean', function(UtilsSrv) {
            return {
                'restrict': 'E',
                'link': UtilsSrv.updatableLink,
                'templateUrl': 'views/directives/updatable-boolean.html',
                'scope': {
                    'value': '=?',
                    'onUpdate': '&',
                    'active': '=?',
                    'placeholder': '@',
                    'trueText': '@?',
                    'falseText': '@?',
                    'clearable': '<?'
                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableColour.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableColour', function(UtilsSrv) {
            return {
                'restrict': 'E',
                'link': UtilsSrv.updatableLink,
                'templateUrl': 'views/directives/updatable-colour.html',
                'scope': {
                    'value': '=?',
                    'onUpdate': '&',
                    'active': '=?',
                    'placeholder': '@',
                    'clearable': '<?'
                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableDataDropdown.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableDataDropdown', function(UtilsSrv) {
            return {
                'restrict': 'E',
                'link': UtilsSrv.updatableLink,
                'templateUrl': 'views/directives/updatable-data-dropdown.html',
                'scope': {
                    'value': '=?',
                    'onUpdate': '&',
                    'active': '=?',
                    'placeholder': '@',
                    'clearable': '<?'

                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableDate.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableDate', function($interval, UtilsSrv) {
            function updateTime(scope) {
                if (scope.dateNow) {
                    var now = moment();
                    // now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
                    scope.humanDate = now.format('DD-MM-YYYY HH:mm');
                    if (!angular.isDefined(scope.timeUpdater)) {
                        scope.timeUpdater = $interval(function() {
                            updateTime(scope);
                        }, 60000);
                    }
                } else if (angular.isDefined(scope.timeUpdater)) {
                    $interval.cancel(scope.timeUpdater);
                    scope.timeUpdater = undefined;
                }
            }

            return {
                'restrict': 'E',
                'link': function(scope, element, attrs, ctrl, transclude) {
                    UtilsSrv.updatableLink(scope, element, attrs, ctrl, transclude);

                    scope.clear = function() {
                        scope.value = null;
                        scope.humanDate = null;
                    };

                    $(element).find('.input-datetime').datetimepicker({
                        format: 'dd-mm-yyyy hh:ii',
                        weekStart: 1,
                        startView: 1,
                        todayBtn: true,
                        autoclose: true
                    });
                    scope.dateNow = false;
                    scope.timeUpdater = undefined;
                    if (angular.isNumber(scope.value)) {
                        var m = moment(scope.value);
                        if (m.isValid()) {
                            scope.humanDate = m.format('DD-MM-YYYY HH:mm');
                        }
                    }
                    scope.$watch('dateNow', function() {
                        updateTime(scope);
                    });
                    scope.$watch('humanDate', function() {
                        if (angular.isString(scope.humanDate)) {
                            var m = moment(scope.humanDate, 'DD-MM-YYYY HH:mm');
                            if (m.isValid()) {
                                scope.value = m.valueOf();
                            }
                        }
                    });
                },
                'templateUrl': 'views/directives/updatable-date.html',
                'scope': {
                    'value': '=?',
                    'onUpdate': '&',
                    'active': '=?',
                    'clearable': '<?'
                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableSelect.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableSelect', function(UtilsSrv) {
            return {
                'restrict': 'E',
                'link': UtilsSrv.updatableLink,
                'templateUrl': 'views/directives/updatable-select.html',
                'scope': {
                    'options': '=?',
                    'value': '=?',
                    'onUpdate': '&',
                    'active': '=?',
                    'placeholder': '@',
                    'clearable': '<?'
                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableSimpleText.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableSimpleText', function(UtilsSrv) {
            return {
                'restrict': 'E',
                'link': UtilsSrv.updatableLink,
                'templateUrl': 'views/directives/updatable-simple-text.html',
                'scope': {
                    'inputType': '@',
                    'value': '=?',
                    'onUpdate': '&',
                    'active': '=?',
                    'placeholder': '@',
                    'clearable': '<?'
                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableTag.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableTag', function(UtilsSrv) {
            return {
                'restrict': 'E',
                'link': UtilsSrv.updatableLink,
                'templateUrl': 'views/directives/updatable-tag.html',
                'scope': {
                    'value': '=?',
                    'colour': '<?',
                    'onUpdate': '&'
                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableTagList.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableTagList', function(UtilsSrv, $uibModal, $filter, NotificationSrv, TaxonomyCacheSrv) {
            return {
                restrict: 'E',
                link: UtilsSrv.updatableLink,
                templateUrl: 'views/directives/updatable-tag-list.html',
                scope: {
                    value: '=?',
                    onUpdate: '&',
                    active: '=?',
                    source: '=',
                    clearable: '<?'
                },
                controllerAs: '$cmp',
                controller: function($scope) {
                    this.state = {
                        type: null,
                    };

                    this.fromLibrary = function() {
                        this.state.type = 'library';

                        var modalInstance = $uibModal.open({
                            controller: 'TaxonomySelectionModalCtrl',
                            controllerAs: '$modal',
                            animation: true,
                            templateUrl: 'views/partials/misc/taxonomy-selection.modal.html',
                            size: 'lg',
                            resolve: {
                                taxonomies: function() {
                                    return TaxonomyCacheSrv.all();
                                }
                            }
                        });

                        modalInstance.result
                            .then(function(selectedTags) {
                                var filterFn = $filter('tagValue'),
                                    tags = [];

                                _.each(selectedTags, function(tag) {
                                    tags.push({
                                        text: filterFn(tag)
                                    });
                                });

                                $scope.value = $scope.value.concat(tags);
                            })
                            .catch(function(err) {
                                if (err && !_.isString(err)) {
                                    NotificationSrv.error('Tag selection', err.data, err.status);
                                }
                            });
                    };

                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableTags.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableTags', function(UtilsSrv) {
            return {
                'restrict': 'E',
                'link': UtilsSrv.updatableLink,
                'templateUrl': 'views/directives/updatable-tags.html',
                'scope': {
                    'value': '=?',
                    'onUpdate': '&',
                    'active': '=?',
                    'source': '=',
                    'clearable': '<?'
                }
            };
        });
})();

```

`frontend/app/scripts/directives/updatableText.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives').directive('updatableText', function(UtilsSrv) {
        return {
            'restrict': 'E',
            'link': UtilsSrv.updatableLink,
            'templateUrl': 'views/directives/updatable-text.html',
            'scope': {
                'value': '=?',
                'onUpdate': '&',
                'active': '=?',
                'clearable': '<?'
            }
        };
    });
})();

```

`frontend/app/scripts/directives/updatableUser.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('updatableUser', function (UserSrv, QuerySrv, UtilsSrv, AuthenticationSrv, NotificationSrv) {
            return {
                restrict: 'E',
                link: function (scope, element, attrs, ctrl, transclude) {
                    var cached = false;

                    UtilsSrv.updatableLink(scope, element, attrs, ctrl, transclude);

                    scope.setValue = function (value) {
                        scope.value = value;
                    };
                    scope.getUserInfo = UserSrv.getCache;

                    scope.$watch('updatable.updating', function (value) {

                        if (value === true && !cached) {
                            var assignableUsers = [];

                            if (_.isFunction(scope.query)) {
                                assignableUsers = scope.query.apply(this, scope.queryParams);
                            } else {
                                assignableUsers = scope.query;
                            }

                            QuerySrv.call('v1', assignableUsers, {
                                filter: {
                                    _field: 'locked',
                                    _value: false
                                },
                                sort: ['+name']
                            })
                                .then(function (users) {
                                    scope.userList = users;
                                })
                                .catch(function (err) {
                                    NotificationSrv.error('Fetching users', err.data, err.status);
                                });

                            cached = true;
                        }
                    });
                },
                templateUrl: 'views/directives/updatable-user.html',
                scope: {
                    value: '=?',
                    query: '=',
                    blankText: '@',
                    queryParams: '=',
                    onUpdate: '&',
                    active: '=?',
                    clearable: '<?'
                }
            };
        });
})();

```

`frontend/app/scripts/directives/user.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('user', function(UserSrv) {
            return {
                scope: {
                    user: '=userId',
                    iconOnly: '=',
                    iconSize: '@'
                },
                templateUrl: 'views/directives/user.html',
                link: function(scope) {
                    scope.userInfo = UserSrv.getCache;
                    scope.initials = '';

                    scope.$watch('userData.name', function(value) {
                        if(!value) {
                            return;
                        }

                        scope.initials = value.split(' ')
                            .map(function(item) {
                                return item[0];
                            })
                            .join('')
                            .substr(0, 3)
                            .toUpperCase();
                    });

                    scope.$watch('user', function(value) {
                        if(!value) {
                            return;
                        }
                        scope.userInfo(value).then(function(userData) {
                            scope.userData = userData;                            
                        });
                    });
                }
            };
        });
})();

```

`frontend/app/scripts/directives/userinfo.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveDirectives')
        .directive('userInfo', function(UserSrv) {
            return {
                scope: {
                    user: '=value',
                    field: '@'
                },
                replace: true,
                template: '<span>{{display}}</span>',
                link: function(scope) {
                    scope.display = '';
                    scope.userInfo = UserSrv.getCache;

                    scope.$watch('user', function(value) {
                        if(!value) {
                            return;
                        }
                        scope.userInfo(value).then(function(userData) {
                            if(userData) {
                                scope.display = userData[scope.field];
                            }
                        });
                    });
                }
            };
        });
})();

```

`frontend/app/scripts/directives/utils/autofocus.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveDirectives')
        .directive('autofocus', function ($timeout) {
            return {
                restrict: 'A',
                link: function ($scope, $element, attr) {

                    $scope.$on(attr.autofocus, function() {
                        $timeout(function() {
                            $element[0].focus();
                        }, 0);

                    });
                }
            }
        });
})();

```

`frontend/app/scripts/filters/custom-field-value.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('customFieldValue', function(UiSettingsSrv) {
        return function(customField) {
            if(!customField) {
                return '';
            }

            var format = UiSettingsSrv.defaultDateFormat()

            switch(customField.type) {
                case 'date':
                    return moment(customField.value).format(format);
                default:
                    return customField.value;
            }
        };
    });
})();

```

`frontend/app/scripts/filters/duration.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveFilters').filter('duration', function () {
        return function (start, end) {
            if (!start) {
                return '';
            }

            if(end) {
                // Compute duration between end and start
                var duration = moment(end).diff(moment(start));

                return moment.duration(duration, 'milliseconds').humanize();
            } else {
                // Compute duration till now
                return moment(start).fromNow(true);
            }
        };
    });
})();

```

`frontend/app/scripts/filters/ellipsis.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveFilters').filter('ellipsis', function () {
        return function (value, max, tail) {
            if (!value) {
                return '';
            }

            max = parseInt(max, 10);
            if (!max) {
                return value;
            }
            if (value.length <= max) {
                return value;
            }

            value = value.substr(0, max);

            return value + (tail || '…');
        };
    });
})();

```

`frontend/app/scripts/filters/fang.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('fang', function(UtilsSrv) {
        return function(value) {
            if(!value) {
                return '';
            }

            return UtilsSrv.fangValue(value);
        };
    });
})();

```

`frontend/app/scripts/filters/filesize.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveFilters')
        .filter('filesize', function() {
            return function(size) {
                if (isNaN(size)) {
                    size = 0;
                }

                if (size < 1024) {
                    return size + ' Bytes';
                }

                size /= 1024;

                if (size < 1024) {
                    return size.toFixed(2) + ' KB';
                }

                size /= 1024;

                if (size < 1024) {
                    return size.toFixed(2) + ' MB';
                }

                size /= 1024;

                if (size < 1024) {
                    return size.toFixed(2) + ' GB';
                }

                size /= 1024;

                return size.toFixed(2) + ' TB';
            };
        });
})();

```

`frontend/app/scripts/filters/filter-value.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveFilters').filter('filterValue', function(UtilsSrv, UiSettingsSrv) {
        return function(value) {
            var dateFormat = UiSettingsSrv.defaultDateFormat();

            if (angular.isArray(value)) {
                return _.map(value, function(item) {
                    return item.label || item.text;
                }).join(', ');
            } else if(angular.isObject(value) && value.from !== undefined && value.to !== undefined) {
                var result = [];

                result.push({
                    custom: 'Custom',
                    today: 'Today',
                    last7days: 'Last 7 days',
                    last30days: 'Last 30 days',
                    last3months: 'Last 3 months',
                    last6months: 'Last 6 months',
                    lastyear: 'Last year'
                }[value.operator] || 'Custom');

                var start, end;

                if(value.operator && value.operator !== 'custom') {
                    var dateRange = UtilsSrv.getDateRange(value.operator);

                    start = dateRange.from;
                    end = dateRange.to;
                } else {
                    start = value.from;
                    end = value.to;
                }

                if(start !== null) {
                    result.push('From: ' + moment(start).hour(0).minutes(0).seconds(0).format(dateFormat));
                }

                if(end !== null) {
                    result.push('To: ' + moment(end).hour(23).minutes(59).seconds(59).format(dateFormat));
                }

                return result.join(', ');
            } else if(angular.isObject(value) && value.list !== undefined) {
                return _.map(value.list, function(item) {
                    return item.label || item.text;
                }).join(', ');
            } else if(angular.isObject(value) && value.operator !== undefined) {
                return [value.operator, value.value].join(' ');
            }

            return value !== undefined && value !== null ? value : 'Any';
        };
    });

})();

```

`frontend/app/scripts/filters/flattern-object.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveFilters').filter('flattern', function() {
        var flattern = function(obj, path, result) {
            var key,
                val,
                _path;
            path = path || [];
            result = result || {};
            for (key in obj) {
                val = obj[key];
                _path = path.concat([key]);
                if (val instanceof Object) {
                    flattern(val, _path, result);
                } else {
                    result[_path.join('.')] = val;
                }
            }

            return result;
        };

        return flattern;
    });
})();

```

`frontend/app/scripts/filters/getField.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('getField', function() {
        return function(obj, param) {
            if (obj !== undefined && obj !== null) {
                return obj[param];
            } else {
                return '';
            }
        };
    });
})();

```

`frontend/app/scripts/filters/hash-type.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('hashType', function() {
        return function(value) {
            if(!value) {
                return '';
            }

            if(value.length === 64) {
                return '**SHA256:** ' + value;
            } else if (value.length === 40) {
                return '**SHA1:** ' + value;
            } else if(value.length === 32) {
                return '**MD5:** ' + value;
            }

            return value;
        };
    });
})();

```

`frontend/app/scripts/filters/limited-count.js`:

```js
(function () {
    'use strict';

    angular.module('theHiveFilters')
        .filter('limitedCount', function () {
            return function (count) {
                if (isNaN(count))
                    return 0

                if (count < 0)
                    return (-1 * count) + '+';

                return count;
            };
        });
})();

```

`frontend/app/scripts/filters/md5.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('md5', function() {
        return function(value) {
            if(!value) {
                return '';
            }

            return CryptoJS.MD5(value).toString();
        };
    });
})();

```

`frontend/app/scripts/filters/offset.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('offset', function() {
        return function(input, start) {
            if (!input) {
                return;
            }
            start = parseInt(start, 10);
            return input.slice(start);
        };
    });
})();

```

`frontend/app/scripts/filters/order-object-by.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters')
        .filter('orderObjectBy', function() {
            return function(items, field, reverse) {
                var filtered = [];
                angular.forEach(items, function(item) {
                    filtered.push(item);
                });
                filtered.sort(function(a, b) {
                    return (a[field] > b[field] ? 1 : -1);
                });
                if (reverse) {
                    filtered.reverse();
                }
                return filtered;
            };
        });
})();

```

`frontend/app/scripts/filters/percent.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('percentage', function($filter) {
        return function(input, decimals) {
            return $filter('number')(input * 100, decimals) + '%';
        };
    });
})();

```

`frontend/app/scripts/filters/sha256.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('sha256', function() {
        return function(value) {
            if(!value) {
                return '';
            }

            return CryptoJS.SHA256(value).toString();
        };
    });
})();

```

`frontend/app/scripts/filters/shortDate.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('shortDate', function(UiSettingsSrv) {
        return function(str) {
            var format = UiSettingsSrv.defaultDateFormat() || 'MM/DD/YY H:mm';

            if (angular.isString(str) && str.length > 0) {
                return moment(str, ['YYYYMMDDTHHmmZZ', 'DD-MM-YYYY HH:mm']).format(format);
            } else if (angular.isNumber(str)) {
                return moment(str).format(format);
            } else {
                return '';
            }

        };
    });
})();

```

`frontend/app/scripts/filters/showDate.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveFilters').filter('showDate', function() {
        return function(str, format) {
            var fmt = format || 'ddd, MMM Do, YYYY H:mm Z';

            if (angular.isString(str) && str.length > 0) {
                return moment(str, ['YYYYMMDDTHHmmZZ', 'DD-MM-YYYY HH:mm']).format(fmt);
            } else if (angular.isNumber(str)) {
                return moment(str).format(fmt);
            } else {
                return '';
            }

        };
    });
})();

```

`frontend/app/scripts/filters/tag-value.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveFilters').filter('tagValue', function () {
        return function (tag) {
            if (!tag) {
                return '';
            }

            return _.without([
                tag.namespace,
                ':',
                tag.predicate,
                tag.value ? ("=\"" + tag.value + "\"") : null
            ], null).join('');
        };
    });
})();

```

`frontend/app/scripts/filters/urlencode.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveFilters').filter('escape', function() {
        return window.encodeURIComponent;
    });
})();

```

`frontend/app/scripts/services/AnalyzerInfoSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').factory('AnalyzerInfoSrv', function(AnalyzerSrv) {
        var analyzerCache = {};
        return function(id) {
            if (angular.isDefined(analyzerCache[id])) {
                return analyzerCache[id];
            } else {
                analyzerCache[id] = AnalyzerSrv.get({
                    'analyzerId': id
                });
                return analyzerCache[id];
            }
        };
    });
})();

```

`frontend/app/scripts/services/EntitySrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').factory('EntitySrv', function($state) {
        var buildState = function(entity) {
            var state = {};
            if (entity._type === 'case') {
                state.name = 'app.case.details';
                state.params = {
                    caseId: entity.id
                };
            } else if (entity._type === 'Case') {
                state.name = 'app.case.details';
                state.params = {
                    caseId: entity._id
                };
            } else if (entity._type === 'case_artifact') {
                state.name = 'app.case.observables-item';
                state.params = {
                    caseId: entity.case.id,
                    itemId: entity.id
                };
            } else if (entity._type === 'observable') {
                state.name = 'app.case.observables-item';
                state.params = {
                    caseId: entity.case.id,
                    itemId: entity.id
                };
            } else if (entity._type === 'case_artifact_job') {
                state.name = 'app.case.observables-item';
                state.params = {
                    caseId: entity.case_artifact.case.id,
                    itemId: entity.case_artifact.id
                };
            } else if (entity._type === 'case_task') {
                state.name = 'app.case.tasks-item';
                state.params = {
                    caseId: entity.case.id,
                    itemId: entity.id
                };
            } else if (entity._type === 'Task') {
                state.name = 'app.case.tasks-item';
                state.params = {
                    caseId: entity.extraData.case._id,
                    itemId: entity._id
                };
            }

            return state;
        };

        var es = {
            'link': function(entity) {
                var state = buildState(entity);

                if (state.name) {
                    return $state.href(state.name, state.params);
                } else {
                    return 'unknown';
                }
            },
            'open': function(entity) {
                var state = buildState(entity);
                $state.go(state.name, state.params);
            }
        };
        return es;
    });
})();

```

`frontend/app/scripts/services/api/AlertingSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .factory('AlertingSrv', function ($q, $http, $rootScope, StatSrv, StreamSrv, PSearchSrv, PaginatedQuerySrv) {

            var baseUrl = './api/alert';

            var similarityFilters = {
                'none': {
                    label: 'None',
                    filters: []
                },
                'open-cases': {
                    label: 'Open Cases',
                    filters: [{
                        field: 'status',
                        type: 'enumeration',
                        value: {
                            list: [{
                                text: 'Open',
                                label: 'Open'
                            }]
                        }
                    }]
                },
                'open-cases-last-7days': {
                    label: 'Open Cases in the last 7 days',
                    filters: [{
                        field: 'status',
                        type: 'enumeration',
                        value: {
                            list: [{
                                text: 'Open',
                                label: 'Open'
                            }]
                        }
                    }, {
                        field: '_createdAt',
                        type: 'date',
                        value: {
                            operator: 'last7days',
                            from: null,
                            to: null
                        }
                    }]
                },
                'open-cases-last-30days': {
                    label: 'Open Cases in the last 30 days',
                    filters: [{
                        field: 'status',
                        type: 'enumeration',
                        value: {
                            list: [{
                                text: 'Open',
                                label: 'Open'
                            }]
                        }
                    }, {
                        field: '_createdAt',
                        type: 'date',
                        value: {
                            operator: 'last30days',
                            from: null,
                            to: null
                        }
                    }]
                },
                'open-cases-last-3months': {
                    label: 'Open Cases in the last 3 months',
                    filters: [{
                        field: 'status',
                        type: 'enumeration',
                        value: {
                            list: [{
                                text: 'Open',
                                label: 'Open'
                            }]
                        }
                    }, {
                        field: '_createdAt',
                        type: 'date',
                        value: {
                            operator: 'last3months',
                            from: null,
                            to: null
                        }
                    }]
                },
                'open-cases-last-year': {
                    label: 'Open Cases in the last year',
                    filters: [{
                        field: 'status',
                        type: 'enumeration',
                        value: {
                            list: [{
                                text: 'Open',
                                label: 'Open'
                            }]
                        }
                    }, {
                        field: '_createdAt',
                        type: 'date',
                        value: {
                            operator: 'lastyear',
                            from: null,
                            to: null
                        }
                    }]
                },
                'resolved-cases': {
                    label: 'Resolved cases',
                    filters: [{
                        field: 'status',
                        type: 'enumeration',
                        value: {
                            list: [{
                                text: 'Resolved',
                                label: 'Resolved'
                            }]
                        }
                    }]
                }
            };

            var factory = {
                getSimilarityFilters: function () {
                    return similarityFilters;
                },
                getSimilarityFilter: function (name) {
                    return (similarityFilters[name] || {}).filters;
                },
                list: function (config, callback) {
                    return new PaginatedQuerySrv({
                        name: 'alerts',
                        root: undefined,
                        objectType: 'alert',
                        version: 'v1',
                        scope: config.scope,
                        sort: config.sort || ['-date'],
                        loadAll: config.loadAll || false,
                        pageSize: config.pageSize || 10,
                        filter: config.filter || undefined,
                        onUpdate: callback || undefined,
                        limitedCount: config.limitedCount || false,
                        operations: [
                            { '_name': 'listAlert' }
                        ],
                        extraData: ['importDate', 'caseNumber']
                    });
                },

                get: function (alertId) {
                    return $http.get('./api/v1/alert/' + alertId)
                        .then(function (response) {
                            return response.data;
                        });
                },

                create: function (alertId, data) {
                    return $http.post(baseUrl + '/' + alertId + '/createCase', data || {});
                },

                update: function (alertId, updates) {
                    return $http.patch(baseUrl + '/' + alertId, updates);
                },

                mergeInto: function (alertId, caseId) {
                    return $http.post(baseUrl + '/' + alertId + '/merge/' + caseId);
                },

                bulkMergeInto: function (alertIds, caseId) {
                    return $http.post(baseUrl + '/merge/_bulk', {
                        caseId: caseId,
                        alertIds: alertIds
                    });
                },

                canMarkAsRead: function (event) {
                    return !!!event.read;
                },

                canMarkAsUnread: function (event) {
                    return !!event.read;
                },

                markAsRead: function (alertId) {
                    return $http.post(baseUrl + '/' + alertId + '/markAsRead');
                },

                markAsUnread: function (alertId) {
                    return $http.post(baseUrl + '/' + alertId + '/markAsUnread');
                },

                follow: function (alertId) {
                    return $http.post(baseUrl + '/' + alertId + '/follow');
                },

                unfollow: function (alertId) {
                    return $http.post(baseUrl + '/' + alertId + '/unfollow');
                },

                forceRemove: function (alertId) {
                    return $http.delete(baseUrl + '/' + alertId, {
                        params: {
                            force: 1
                        }
                    });
                },

                bulkRemove: function (alertIds) {
                    return $http.post(baseUrl + '/delete/_bulk', {
                        ids: alertIds
                    }, {
                        params: {
                            force: 1
                        }
                    });
                },

                stats: function (scope) {
                    var field = 'status',
                        result = {},
                        statConfig = {
                            query: {},
                            objectType: 'alert',
                            field: field,
                            result: result
                        };

                    StreamSrv.addListener({
                        rootId: 'any',
                        objectType: 'alert',
                        scope: scope,
                        callback: function () {
                            StatSrv.get(statConfig);
                        }
                    });

                    return StatSrv.get(statConfig);
                }

            };

            return factory;
        });

})();

```

`frontend/app/scripts/services/api/AnalyzerSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .factory('AnalyzerSrv', function ($resource, $q) {
            var analyzers = null,
                resource = $resource('./api/connector/cortex/analyzer/:analyzerId', {}, {
                    query: {
                        method: 'GET',
                        url: './api/connector/cortex/analyzer',
                        isArray: true
                    },
                    get: {
                        isArray: true
                    },
                    update: {
                        method: 'PATCH'
                    }
                });

            var factory = {
                clearCache: function () {
                    analyzers = null;
                },
                query: function () {
                    var deferred = $q.defer();

                    if (analyzers === null) {

                        resource.query({
                            range: 'all'
                        }, {}, function (response) {

                            analyzers = _.indexBy(_.map(response, function(item) {
                                return item.toJSON();
                            }), 'name');

                            deferred.resolve(analyzers);
                        }, function (rejection) {
                            deferred.reject(rejection);
                        });

                    } else {
                        deferred.resolve(analyzers);
                    }

                    return deferred.promise;
                },

                get: function(analyzerId) {
                    var deferred = $q.defer();

                    if(analyzers !== null && analyzers[analyzerId]) {
                        deferred.resolve(analyzers[analyzerId]);
                    } else {
                        resource.get({
                            'analyzerId': analyzerId
                        }, function (data) {
                            deferred.resolve(data);
                        }, function (rejection) {
                            deferred.reject(rejection);
                        });
                    }

                    return deferred.promise;
                },

                forDataType: function(dataType) {
                    var deferred = $q.defer();

                    factory.query()
                        .then(function(all) {
                            var filtered = {};
                            _.each(all, function(value, key) {
                                if(value.dataTypeList && value.dataTypeList.indexOf(dataType) !== -1) {
                                    filtered[key] = angular.copy(value);
                                    filtered[key].active = true;
                                }
                            });

                            deferred.resolve(filtered);
                        });

                    return deferred.promise;
                },

                serversFor: function(analyzerIds) {
                    var deferred = $q.defer();

                    factory.query()
                        .then(function(all) {
                            var cortexIds = [];

                            _.each(all, function(value, key) {
                                if(analyzerIds.indexOf(key) > -1){
                                    cortexIds = cortexIds.concat(value.cortexIds);
                                }
                            });

                            deferred.resolve(_.uniq(cortexIds));
                        });

                    return deferred.promise;
                }
            };

            return factory;
        });
})();

```

`frontend/app/scripts/services/api/AnalyzerTemplateSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('AnalyzerTemplateSrv', function($resource, $http) {
            var baseUrl = './api/connector/cortex/analyzer/template';
            var resource = $resource(baseUrl, {}, {
                query: {
                    method: 'POST',
                    url: baseUrl + '/_search',
                    isArray: true
                }
            });

            return {
                get: function() {
                    return resource;
                },

                list: function() {
                    return $http.post(baseUrl + '/_search', {
                        range: 'all'
                    });
                },

                save: function(tpl) {
                    if(tpl.id) {
                        return $http.patch(baseUrl + '/' + tpl.id, _.omit(tpl, 'id'), {});
                    } else {
                        return $http.post(baseUrl, tpl, {});
                    }
                },

                delete: function(tplId) {
                    return $http.delete(baseUrl + '/' + tplId);
                },

                import: function(post) {
                    var postData = {
                        templates: post.attachment
                    };

                    return $http({
                        method: 'POST',
                        url: baseUrl + '/_import',
                        headers: {
                            'Content-Type': undefined
                        },
                        transformRequest: function (data) {
                            var formData = new FormData(),
                                copy = angular.copy(data, {});

                            angular.forEach(data, function (value, key) {
                                if (Object.getPrototypeOf(value) instanceof Blob || Object.getPrototypeOf(value) instanceof File) {
                                    formData.append(key, value);
                                    delete copy[key];
                                }
                            });

                            return formData;
                        },
                        data: postData

                    });
                }
            };

        });
})();

```

`frontend/app/scripts/services/api/AttackPatternSrv.js`:

```js

(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('AttackPatternSrv', function($http, $q, QuerySrv) {
            var self = this;
            var baseUrl = './api/v1/pattern';

            this.tacticsCache = {};

            this.tactics = {
                keys: [
                    'reconnaissance',
                    'resource-development',
                    'initial-access',
                    'execution',
                    'persistence',
                    'privilege-escalation',
                    'defense-evasion',
                    'credential-access',
                    'discovery',
                    'lateral-movement',
                    'collection',
                    'command-and-control',
                    'exfiltration',
                    'impact'
                ],
                values: {
                    'reconnaissance': {
                        label: 'Reconnaissance',
                        color: '#D1BBD7'
                    },
                    'resource-development': {
                        label: 'Resource Development',
                        color: '#AE76A3'
                    },
                    'initial-access': {
                        label: 'Initial Access',
                        color: '#882E72'
                    },
                    'execution': {
                        label: 'Execution',
                        color: '#1965B0'
                    },
                    'persistence': {
                        label: 'Persistence',
                        color: '#5289C7'
                    },
                    'privilege-escalation': {
                        label: 'Privilege Escalation',
                        color: '#7BAFDE'
                    },
                    'defense-evasion': {
                        label: 'Defense Evasion',
                        color: '#4EB256'
                    },
                    'credential-access': {
                        label: 'Credential Access',
                        color: '#90C987'
                    },
                    'discovery': {
                        label: 'Discovery',
                        color: '#CAE0AB'
                    },
                    'lateral-movement': {
                        label: 'Lateral Movement',
                        color: '#F7F056'
                    },
                    'collection': {
                        label: 'Collection',
                        color: '#F6C141'
                    },
                    'command-and-control': {
                        label: 'Command and Control',
                        color: '#F1932D'
                    },
                    'exfiltration': {
                        label: 'Exfiltration',
                        color: '#E8601C'
                    },
                    'impact': {
                        label: 'Impact',
                        color: '#DC050C'
                    }
                }
            };

            this.list = function() {
                return QuerySrv.call('v1', [
                    { _name: 'listPattern' }
                ], {
                    name:'list-attack-patterns'
                });
            };

            this.getByTactic = function(tactic) {
                var defer = $q.defer();

                if(self.tacticsCache[tactic]) {
                    console.log('get techniques from cache for ', tactic);

                    defer.resolve(self.tacticsCache[tactic]);
                } else {
                    console.log('get techniques from server for ', tactic);

                    QuerySrv.call('v1', [
                        { _name: 'listPattern'}
                    ], {
                        name:'list-attack-patterns-for-' + tactic,
                        filter: {
                            _and: [
                                {
                                    _field: 'patternType',
                                    _value: 'attack-pattern'
                                }, {
                                    _like: {
                                        _field: 'tactics',
                                        _value: tactic
                                    }
                                },
                                {
                                    _field: 'revoked',
                                    _value: false
                                }
                            ]
                        },
                        sort: ['+patternId'],
                        page: {
                            from: 0,
                            to: 100,
                            extraData: ['parent']
                        }
                    }).then(function(techniques) {

                        _.each(techniques, function(technique) {
                            technique.isSubTechnique = !!technique.extraData.parent;
                        });

                        self.tacticsCache[tactic] = techniques;

                        defer.resolve(techniques);
                    });
                }

                return defer.promise;
            };

            this.get = function(id) {

                var defer = $q.defer();

                QuerySrv.call('v1', [{
                    '_name': 'getPattern',
                    'idOrName': id
                }], {
                    name:'get-attach-pattern-' + id,
                    page: {
                        from: 0,
                        to: 1,
                        extraData: [
                            'parent',
                            'children'
                        ]
                    }
                }).then(function(response) {
                    defer.resolve(response[0]);
                }).catch(function(err){
                    defer.reject(err);
                });

                return defer.promise;
            };

            this.import = function(post) {
                var postData = {
                    file: post.attachment
                };

                return $http({
                    method: 'POST',
                    url: baseUrl + '/import/attack',
                    headers: {
                        'Content-Type': undefined
                    },
                    transformRequest: function (data) {
                        var formData = new FormData(),
                            copy = angular.copy(data, {});

                        angular.forEach(data, function (value, key) {
                            if (Object.getPrototypeOf(value) instanceof Blob || Object.getPrototypeOf(value) instanceof File) {
                                formData.append(key, value);
                                delete copy[key];
                            }
                        });

                        return formData;
                    },
                    data: postData
                });
            };
        });

})();

```

`frontend/app/scripts/services/api/AuditSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('AuditSrv', function($http, StreamSrv, NotificationSrv) {
            return function(rootId, max, scope) {
                var ret = [];
                if (!isFinite(max)) {
                    max = 10;
                }

                $http.get('./api/flow', {
                    'params': {
                        'rootId': rootId,
                        'count': max
                    }
                }).then(function(response) {
                    var data = response.data;

                    angular.forEach(data, function(d) {
                        ret.push(d);
                    });
                    var fnSameRequestId = function(message) {
                        return function(m) { 
                            return m.base.requestId === message.base.requestId;
                        };
                    };

                    var eventConfig = {
                        rootId: rootId,
                        objectType: 'any',
                        scope: scope,
                        callback: function(messages) {
                            for (var i = messages.length - 1, messageAdded = 0; i >= 0 && messageAdded < max; i--) {
                                var message = messages[i];
                                var alreadyInFlow = _.find(ret, fnSameRequestId(message)) !== undefined;
                                if (!alreadyInFlow && message.base.objectType !== 'user') {
                                    var index = messageAdded;
                                    ret.splice(index, 0, message);
                                    if (ret.length > max) {
                                        ret.pop();
                                    }
                                    messageAdded += 1;
                                } else if(alreadyInFlow && message.base.objectType === 'case_artifact_job') {
                                    ret[messageAdded] = message;
                                } else if(alreadyInFlow && message.base.objectType === 'action') {
                                    ret[messageAdded] = message;
                                }

                            }
                        }
                    };

                    StreamSrv.addListener(eventConfig);
                }).catch(function(data, status) {
                    NotificationSrv.error('AuditSrv', data, status);
                });
                return ret;
            };
        });
})();

```

`frontend/app/scripts/services/api/AuthenticationSrv.js`:

```js
(function() {
    'use strict';
    angular
        .module('theHiveServices')
        .factory('AuthenticationSrv', function($http, $q, UtilsSrv, SecuritySrv, UserSrv) {
            var self = {
                currentUser: null,
                homeState: null,
                login: function(username, password, code) {
                    var post = {
                        user: username,
                        password: password
                    };

                    if(code) {
                        post.code = code;
                    }

                    return $http.post('./api/login', post);
                },
                logout: function(success, failure) {
                    $http
                        .post('./api/v1/logout')
                        .then(function(data, status, headers, config) {
                            self.currentUser = null;

                            if (angular.isFunction(success)) {
                                success(data, status, headers, config);
                            }
                        })
                        .catch(function(data, status, headers, config) {
                            if (angular.isFunction(failure)) {
                                failure(data, status, headers, config);
                            }
                        });
                },
                current: function(organisation) {
                    var result = {};

                    var options = {};
                    if(organisation) {
                        options.headers = {
                            'X-Organisation': organisation
                        };
                    }

                    return $http
                        .get('./api/v1/user/current', options)
                        .then(function(response) {
                            var userData = response.data;

                            self.currentUser = userData;
                            self.currentUser.homeState = self.getHomePage();

                            UserSrv.updateCache(self.currentUser.login, self.currentUser);
                            UtilsSrv.shallowClearAndCopy(self.currentUser, result);

                            return $q.resolve(result);
                        })
                        .catch(function(err) {
                            self.currentUser = null;
                            return $q.reject(err);
                        });
                },
                isSuperAdmin: function() {
                    var user = self.currentUser;

                    return user && user.organisation === 'admin';
                },
                getHomePage: function() {
                    if(self.isSuperAdmin()) {
                        if(self.hasPermission('manageOrganisation')) {
                            return 'app.administration.organisations';
                        } else if(self.hasPermission('manageProfile')) {
                            return 'app.administration.profiles';
                        } else if (self.hasPermission('manageCustomField')) {
                            return 'app.administration.custom-fields';
                        } else if(self.hasPermission('manageAnalyzerTemplate')) {
                            return 'app.administration.analyzer-templates';
                        } else if(self.hasPermission('manageObservableTemplate')) {
                            return 'app.administration.observables';
                        } else if(self.hasPermission('managePlatform')) {
                            return 'app.administration.platform';
                        } else if(self.hasPermission('manageTaxonomy')) {
                            return 'app.administration.taxonomies';
                        } else if(self.hasPermission('managePattern')) {
                            return 'app.administration.attackPatterns';
                        }
                    } else {
                        return 'app.cases';
                    }
                },
                hasPermission: function(permissions) {
                    var user = self.currentUser;

                    if (!user) {
                        return false;
                    }

                    //return !_.isEmpty(_.intersection(user.permissions, permissions));

                    return SecuritySrv.checkPermissions(user.permissions, permissions);
                }
            };

            return self;
        });
})();

```

`frontend/app/scripts/services/api/CaseSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('CaseSrv', function($q, $http, $resource, QuerySrv) {

            var resource = $resource('./api/case/:caseId', {}, {
                update: {
                    method: 'PATCH'
                },
                links: {
                    method: 'GET',
                    url: './api/case/:caseId/links',
                    isArray: true
                },
                // merge: {
                //     method: 'POST',
                //     url: './api/case/:caseId/_merge/:mergedCaseId',
                //     params: {
                //         caseId: '@caseId',
                //         mergedCaseId: '@mergedCaseId',
                //     }
                // },
                forceRemove: {
                    method: 'DELETE',
                    url: './api/case/:caseId/force',
                    params: {
                        caseId: '@caseId'
                    }
                },
                query: {
                    method: 'POST',
                    url: './api/case/_search',
                    isArray: true
                },
                // alerts: {
                //     method: 'POST',
                //     url: './api/alert/_search',
                //     isArray: true
                // }
            });

            this.get = resource.get;
            this.alerts = resource.alerts;
            this.save = resource.save;
            this.forceRemove = resource.forceRemove;
            this.links = resource.links;
            this.update = resource.update;
            this.merge = resource.merge;
            this.query = resource.query;

            this.alerts = function(id) {
                var defer = $q.defer();

                QuerySrv.call('v1', [{
                    '_name': 'getCase',
                    'idOrName': id
                }, {'_name': 'alerts'}], {
                    name:'get-case-alerts' + id
                }).then(function(response) {
                    defer.resolve(response);
                }).catch(function(err){
                    defer.reject(err);
                });

                return defer.promise;
            };

            this.getById = function(id, withStats) {
                var defer = $q.defer();

                QuerySrv.call('v1', [{
                    '_name': 'getCase',
                    'idOrName': id
                }], {
                    name:'get-case-' + id,
                    page: {
                        from: 0,
                        to: 1,
                        extraData: withStats ? [
                            "observableStats",
                            "taskStats",
                            "alerts",
                            "isOwner",
                            "shareCount",
                            "permissions"
                        ] : []
                    }
                }).then(function(response) {
                    defer.resolve(response[0]);
                }).catch(function(err){
                    defer.reject(err);
                });

                return defer.promise;
            };

            this.merge = function(ids) {
                return $http.post('./api/v1/case/_merge/' + ids.join(','));
            };

            this.bulkUpdate = function(ids, update) {
                return $http.patch('./api/case/_bulk', _.extend({ids: ids}, update));
            };

            this.getShares = function(id) {
                return $http.get('./api/case/' + id + '/shares');
            };

            this.setShares = function(id, shares) {
                return $http.post('./api/case/' + id + '/shares', {
                    "shares": shares
                });
            };

            this.updateShare = function(org, patch) {
                return $http.patch('./api/case/share/' + org, patch);
            };

            this.removeShare = function(id, share) {
                return $http.delete('./api/case/'+id+'/shares', {
                    data: {
                        organisations: [share.organisationName]
                    },
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
            };

            this.removeCustomField = function(customfFieldValueId) {
                return $http.delete('./api/v1/case/customField/' + customfFieldValueId)
            }
        });

})();

```

`frontend/app/scripts/services/api/CaseTaskSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('CaseTaskSrv', function($resource, $http, $q, QuerySrv, ModalSrv) {
            var resource = $resource('./api/case/:caseId/task/:taskId', {}, {
                update: {
                    method: 'PATCH'
                }
            });

            this.get = resource.get;
            this.update = resource.update;
            this.query = resource.query;
            this.save = resource.save;

            this.getById = function(id) {
                var defer = $q.defer();

                QuerySrv.call('v1', [{
                    _name: 'getTask',
                    idOrName: id
                }], {
                    name: 'get-task-' + id,
                    page: {
                        from: 0,
                        to: 1,
                        extraData: ['actionRequired', 'actionRequiredMap']
                    }
                }).then(function(response) {
                    defer.resolve(response[0]);
                }).catch(function(err){
                    defer.reject(err);
                });

                return defer.promise;
            };

            this.getActionRequiredMap = function(taskId) {
                return $http.get('./api/v1/task/' + taskId + '/actionRequired');
            };

            this.markAsDone = function(taskId, org) {
                return $http.put('./api/v1/task/' + taskId + '/actionDone/' + org);
            };

            this.markAsActionRequired = function(taskId, org) {
                return $http.put('./api/v1/task/' + taskId + '/actionRequired/' + org);
            };

            this.getShares = function(caseId, taskId) {
                return $http.get('./api/case/' + caseId + '/task/' + taskId + '/shares');
            };

            this.addShares = function(taskId, organisations) {
                return $http.post('./api/case/task/' + taskId + '/shares', {
                    organisations: organisations
                });
            };

            this.bulkUpdate = function(ids, update) {
                return $http.patch('./api/v1/task/_bulk', _.extend({ids: ids}, update));
            };

            this.removeShare = function(id, share) {
                return $http.delete('./api/task/'+id+'/shares', {
                    data: {
                        organisations: [share.organisationName]
                    },
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
            };

            this.promtForActionRequired = function(title, prompt) {
               var defer = $q.defer();

               var confirmModal = ModalSrv.confirm(
                   title,
                   prompt, {
                       okText: 'Yes, add log',
                       actions: [
                           {
                               flavor: 'default',
                               text: 'Proceed without log',
                               dismiss: 'skip-log'
                           }
                       ]
                   }
               );

               confirmModal.result
                   .then(function(/*response*/) {
                       defer.resolve('add-log');
                   })
                   .catch(function(err) {
                       if(err === 'skip-log') {
                           defer.resolve(err);
                       } else {
                           defer.reject(err);
                       }
                   });

               return defer.promise;
           };

        });
})();

```

`frontend/app/scripts/services/api/CaseTemplateSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').service('CaseTemplateSrv', function($q, $http, AuthenticationSrv, OrganisationSrv) {
        this.list = function() {
            var currentUser = AuthenticationSrv.currentUser;
            return OrganisationSrv.caseTemplates(currentUser.organisation);
        };

        this.get = function(id) {
            var defer = $q.defer();
            $http.get('./api/case/template/' + id)
                .then(function(response) {
                    defer.resolve(response.data);
                }).catch(function(err) {
                    defer.reject(err);
                });
            return defer.promise;
        };

        this.delete = function(id) {
            return $http.delete('./api/case/template/' + id);
        };

        this.create = function(template) {
            return $http.post('./api/case/template', template);
        };

        this.update = function(id, template) {
            return $http.patch('./api/case/template/' + id, template);
        };
    });
})();

```

`frontend/app/scripts/services/api/CortexSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').service('CortexSrv', function($q, $http, $rootScope, $uibModal, QuerySrv, PaginatedQuerySrv, StreamSrv, AnalyzerSrv, PSearchSrv, ModalUtilsSrv) {
        var self = this;
        var baseUrl = './api/connector/cortex';

        this.listJobs = function(scope, caseId, observableId, callback) {
            return new PaginatedQuerySrv({
                name: 'observable-jobs-' + observableId,
                version: 'v1',
                scope: scope,
                streamObjectType: 'case_artifact_job',
                loadAll: false,
                sort: ['-startDate'],
                pageSize: 200,
                onUpdate: callback || angular.noop,
                operations: [
                    { '_name': 'getObservable', 'idOrName': observableId },
                    { '_name': 'jobs' }
                ],
                guard: function(updates) {
                    return _.find(updates, function(item) {
                        return (item.base.details.objectType === 'Observable') && (item.base.details.objectId === observableId);
                    }) !== undefined;
                }
            });
        }

        this.getJobs = function(caseId, observableId, analyzerId, limit) {

            return QuerySrv.query('v1', [
                {
                    '_name': 'getObservable',
                    'idOrName': observableId
                },
                {
                    '_name': 'jobs'
                },
                {
                    '_name': 'filter',
                    '_or': [
                        {
                            'analyzerId': analyzerId
                        },
                        {
                            '_like': {
                                '_field': 'analyzerDefinition',
                                '_value': analyzerId
                            }
                        }
                    ]
                },
                {
                    '_name': 'sort',
                    '_fields': [
                        {
                            'startDate': 'desc'
                        }
                    ]
                },
                {
                    '_name': 'page',
                    'from': 0,
                    'to': limit || 10
                }
            ], {
                params: {
                    name: 'observable-jobs-' + observableId
                }
            });
        };

        this.getJob = function(jobId, nstats) {
            if (nstats) {
                return $http.get(baseUrl + '/job/' + jobId, {
                    params: {
                        nstats: true
                    }
                });
            }
            return $http.get(baseUrl + '/job/' + jobId);

        };

        this.createJob = function(job) {
            return $http.post(baseUrl + '/job', job);
        };

        this.getServers = function(analyzerIds) {
            return AnalyzerSrv.serversFor(analyzerIds).then(function(servers) {
                if (servers.length === 1) {
                    return $q.resolve(servers[0]);
                } else {
                    return self.promptForInstance(servers);
                }
            });
        };

        this.promptForInstance = function(servers) {
            var modalInstance = $uibModal.open({
                templateUrl: 'views/partials/cortex/choose-instance-dialog.html',
                controller: 'ServerInstanceDialogCtrl',
                controllerAs: 'vm',
                size: '',
                resolve: {
                    servers: function() {
                        return servers;
                    }
                }
            });

            return modalInstance.result;
        };

        this.promntForResponder = function(responders) {
            if(!responders || responders.length ===0) {
                return $q.resolve('No responders available');
            }

            var modalInstance = $uibModal.open({
                animation: 'true',
                templateUrl: 'views/partials/misc/responder.selector.html',
                controller: 'ResponderSelectorCtrl',
                controllerAs: '$dialog',
                size: 'lg',
                resolve: {
                    responders: function() {
                        return responders;
                    }
                }
            });

            return modalInstance.result;
        };

        this.getResponders = function(type, id) {
            //return $http.get(baseUrl + '/responder')
            return $http.get(baseUrl + '/responder/' + type + '/' + id)
              .then(function(response) {
                  return $q.resolve(response.data);
              })
              .catch(function(err) {
                  return $q.reject(err);
              });
        };

        this.runResponder = function(responderId, responderName, type, object) {
            var post = {
              responderId: responderId,
              objectType: type,
              objectId: object._id
            };

            return ModalUtilsSrv.confirm('Run responder ' + responderName, 'Are you sure you want to run responser ' + responderName + '?', {
                okText: 'Yes, run it'
            }).then(function() {
                return $http.post(baseUrl + '/action', post);
            });

        };
    });

})();

```

`frontend/app/scripts/services/api/CustomFieldsSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .service('CustomFieldsSrv', function ($http, $q) {
            var self = this;

            this.cache = null;

            this.removeField = function (field) {
                return $http.delete('./api/customField/' + field.id);
            };

            this.usage = function (field) {
                return $http.get('./api/customFields/' + field.id + '/use');
            };

            this.list = function () {
                return $http.get('./api/customField');
            };

            this.get = function (idOrReference) {
                return $http.get('./api/customField/' + idOrReference);
            };

            this.create = function (field) {
                //return $http.post('./api/customField', self._convert(field));
                return $http.post('./api/customField', field);
            };

            this.update = function (id, field) {
                //return $http.patch('./api/customField/'+id, self._convert(field));
                return $http.patch('./api/customField/' + id, field);
            };

            this.remove = function (id) {
                return $http.delete('./api/customField/' + id);
            };

            this.clearCache = function () {
                self.cache = null;
            };

            this.getCache = function (name) {
                return self.cache[name];
            };

            this.all = function () {
                var deferred = $q.defer();

                if (self.cache === null) {
                    $http.get('./api/customField')
                        .then(function (response) {
                            self.cache = {};

                            _.each(response.data, function (field) {
                                self.cache[field.reference] = field;
                            });

                            deferred.resolve(self.cache);
                        });
                } else {
                    deferred.resolve(self.cache);
                }

                return deferred.promise;
            };

        });
})();

```

`frontend/app/scripts/services/api/DashboardSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices').service('DashboardSrv', function (QueryBuilderSrv, localStorageService, $q, AuthenticationSrv, $http) {
        var baseUrl = './api/dashboard';
        var self = this;

        this.metadata = {
            v0: null,
            v1: null
        };

        this.defaultDashboard = {
            period: 'all',
            items: [
                {
                    type: 'container',
                    items: []
                }
            ]
        };

        this.dashboardPeriods = [
            {
                type: 'all',
                label: 'All time'
            },
            {
                type: 'last3Months',
                label: 'Last 3 months'
            },
            {
                type: 'last30Days',
                label: 'Last 30 days'
            },
            {
                type: 'last7Days',
                label: 'Last 7 days'
            }
        ];

        this.timeIntervals = [{
            code: '1d',
            label: 'By day'
        }, {
            code: '1w',
            label: 'By week'
        }, {
            code: '1M',
            label: 'By month'
        }, {
            code: '1y',
            label: 'By year'
        }];

        this.aggregations = [{
            id: 'count',
            label: 'count'
        }, {
            id: 'sum',
            label: 'sum'
        }, {
            id: 'avg',
            label: 'avg'
        }, {
            id: 'min',
            label: 'min'
        }, {
            id: 'max',
            label: 'max'
        }];

        this.serieTypes = ['line', 'area', 'spline', 'area-spline', 'bar'];

        this.typeClasses = {
            container: 'fa-window-maximize',
            bar: 'fa-bar-chart',
            donut: 'fa-pie-chart',
            line: 'fa-line-chart',
            multiline: 'fa-area-chart',
            counter: 'fa-calculator',
            text: 'fa-file'
        };

        this.sortOptions = [{
            name: '+_count',
            label: 'Ascendant (Smaller first)'
        }, {
            name: '-_count',
            label: 'Descendant (Bigger first)'
        }];

        this.colorsPattern = [
            '#0675a4', '#f46c54', '#fbcd35', '#3cbcb4', '#305868', '#a42414', '#25c4f1', '#ac7b1d', '#ecec24', '#8cc47c', '#a1a4ac', '#043444', '#ad8d8d'
        ];

        this.toolbox = [
            {
                type: 'container',
                items: []
            },
            {
                type: 'bar',
                options: {}
            },
            {
                type: 'line',
                options: {
                    title: null,
                    entity: null,
                    field: null
                }
            },
            {
                type: 'multiline',
                options: {
                    title: null,
                    entity: null
                }
            },
            {
                type: 'text',
                options: {
                    title: null,
                    template: null,
                    entity: null
                }
            },
            {
                type: 'donut',
                options: {
                    title: null,
                    entity: null,
                    field: null
                }
            },
            {
                type: 'counter',
                options: {
                    title: null
                }
            }
        ];

        this.skipFields = function (fields, types) {
            return _.filter(fields, function (item) {
                return types.indexOf(item.type) === -1;
            });
        };

        this.pickFields = function (fields, types) {
            return _.filter(fields, function (item) {
                return types.indexOf(item.type) !== -1;
            });
        };

        this.fieldsForAggregation = function (fields, agg) {
            if (agg === 'count') {
                return [];
            } else if (agg === 'sum' || agg === 'avg') {
                return self.pickFields(fields, ['number', 'integer', 'float']);
            } else {
                return fields;
            }
        };

        this.renderers = {
            severity: function () { }
        };

        this.create = function (dashboard) {
            return $http.post(baseUrl, dashboard);
        };

        this.update = function (id, dashboard) {
            var db = _.pick(dashboard, 'id', 'title', 'description', 'status', 'definition');

            return $http.patch(baseUrl + '/' + id, db);
        };

        this.list = function () {
            return $http.post(baseUrl + '/_search', {
                range: 'all',
                sort: ['-status', '-updatedAt', '-createdAt'],
                query: {
                    _and: [
                        {
                            _not: { status: 'Deleted' }
                        },
                        {
                            _or: [{ status: 'Shared' }, { createdBy: AuthenticationSrv.currentUser.login }]
                        }
                    ]
                }
            });
        };

        this.get = function (id) {
            return $http.get(baseUrl + '/' + id);
        };

        this.remove = function (id) {
            return $http.delete(baseUrl + '/' + id);
        };

        this._objectifyBy = function (collection, field) {
            var obj = {};

            _.each(collection, function (item) {
                obj[item[field]] = item;
            });

            return obj;
        };

        this.getMetadata = function (version) {
            var defer = $q.defer();

            if (!version) {
                version = 'v0';
            }

            if (this.metadata[version] !== null) {
                defer.resolve(this.metadata[version]);
            } else {
                $http
                    .get('./api/' + version + '/describe/_all')
                    .then(function (response) {
                        var data = response.data;
                        var metadata = {
                            entities: _.keys(data).sort()
                        };

                        _.each(metadata.entities, function (entity) {
                            metadata[entity] = _.omit(data[entity], 'attributes');
                            metadata[entity].attributes = self._objectifyBy(data[entity].attributes, 'name');
                            metadata[entity].attributeKeys = _.keys(metadata[entity].attributes).sort();
                        });

                        self.metadata[version] = metadata;

                        defer.resolve(metadata);
                    })
                    .catch(function (err) {
                        defer.reject(err);
                    });
            }

            return defer.promise;
        };

        this.hasMinimalConfiguration = function (component) {
            switch (component.type) {
                case 'multiline':
                case 'text':
                    return component.options.series.length === _.without(_.pluck(component.options.series, 'entity'), undefined).length;
                default:
                    return !!component.options.entity;
            }
        };

        this.buildFiltersQuery = function (fields, filters) {
            return QueryBuilderSrv.buildFiltersQuery(fields, filters);
        };

        this.buildChartQuery = function (filter, query) {
            var criteria = _.filter(_.without([filter, query], null, undefined, '', '*'), function (c) { return !_.isEmpty(c); });

            if (criteria.length === 0) {
                return {};
            } else {
                return criteria.length === 1 ? criteria[0] : { _and: criteria };
            }
        };

        this.buildPeriodQuery = function (period, field, start, end) {
            if (!period && !start && !end) {
                return null;
            }

            var today = moment().hours(0).minutes(0).seconds(0).milliseconds(0),
                from,
                to = moment(today).hours(23).minutes(59).seconds(59).milliseconds(999);

            if (period === 'last7Days') {
                from = moment(today).subtract(7, 'days');
            } else if (period === 'last30Days') {
                from = moment(today).subtract(30, 'days');
            } else if (period === 'last3Months') {
                from = moment(today).subtract(3, 'months');
            } else if (period === 'custom') {
                from = start && start !== null ? moment(start).valueOf() : null;
                to = end && end !== null ? moment(end).hours(23).minutes(59).seconds(59).milliseconds(999).valueOf() : null;

                if (from !== null && to !== null) {
                    return {
                        _between: { _field: field, _from: from, _to: to }
                    };
                } else if (from !== null) {
                    return {
                        _gt: { _field: field, _value: from }
                    };
                } else {
                    return {
                        _lt: { _field: field, _value: to }
                    };
                }
            }

            return period === 'all' ? null : {
                _between: { _field: field, _from: from.valueOf(), _to: to.valueOf() }
            };
        };

        this.exportDashboard = function (dashboard) {
            var fileName = dashboard.title.replace(/\s/gi, '_') + '.json';
            var content = _.omit(dashboard,
                '_type',
                'id',
                'createdAt',
                'updatedAt',
                'createdBy',
                'updatedBy');

            content.definition = JSON.parse(content.definition);

            // Create a blob of the data
            var fileToSave = new Blob([JSON.stringify(content)], {
                type: 'application/json',
                name: fileName
            });

            // Save the file
            saveAs(fileToSave, fileName);
        };
    });
})();

```

`frontend/app/scripts/services/api/JobSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('JobSrv', function($resource) {
            return $resource('./api/case/artifact/:artifactId/job/:analyzerId', {}, {}, {});
        });
})();

```

`frontend/app/scripts/services/api/ListSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').factory('ListSrv', function($resource) {
        return $resource('./api/list/:listId', {}, {
            query: {
                method: 'GET',
                isArray: false
            },
            add: {
                method: 'PUT'
            },
            update: {
                url: './api/list/:itemId',
                method: 'PATCH'
            },
            exists: {
                url: './api/list/:listId/_exists',
                method: 'POST',
            }
        });
    });
})();

```

`frontend/app/scripts/services/api/MispSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('MispSrv', function($q, $http, $rootScope, $uibModal, StatSrv, StreamSrv, PSearchSrv) {

            var baseUrl = './api/connector/misp';

            var factory = {

                list: function(config, callback) {
                    return PSearchSrv(undefined, 'connector/misp', {
                        scope: config.scope,
                        sort: config.sort || '-publishDate',
                        loadAll: config.loadAll || false,
                        pageSize: config.pageSize || 10,
                        filter: config.filter || '',
                        onUpdate: callback || angular.noop,
                        streamObjectType: 'misp'
                    });
                },

                get: function(mispId) {
                    return $http.get(baseUrl + '/get/' + mispId);
                },

                create: function(mispId) {
                    return $http.post(baseUrl + '/case/' + mispId, {});
                },

                ignore: function(mispId) {
                    return $http.get(baseUrl + '/ignore/' + mispId);
                },

                follow: function(mispId) {
                    return $http.get(baseUrl + '/follow/' + mispId);
                },

                unfollow: function(mispId) {
                    return $http.get(baseUrl + '/unfollow/' + mispId);
                },

                onSuccess: function() {
                    $rootScope.$broadcast('misp:status-updated', true);
                },

                onFailure: function() {
                    $rootScope.$broadcast('misp:status-updated', false);
                },

                stats: function(scope) {
                    var field = 'eventStatus',
                        result = {},
                        statConfig = {
                            query: {},
                            objectType: 'connector/misp',
                            field: field,
                            result: result,
                            success: factory.onSuccess,
                            error: factory.onFailure
                        };



                    StreamSrv.addListener({
                        rootId: 'any',
                        objectType: 'misp',
                        scope: scope,
                        callback: function() {
                            StatSrv.get(statConfig);
                        }
                    });

                    return StatSrv.get(statConfig);
                },

                sources: function(query) {
                    var defer = $q.defer();

                    StatSrv.getPromise({
                        objectType: 'connector/misp',
                        field: 'org',
                        limit: 1000
                    }).then(function(response) {
                        var sources = [];

                        sources = _.map(_.filter(_.keys(response.data), function(source) {
                            var regex = new RegExp(query, 'gi');
                            return regex.test(source);
                        }), function(source) {
                            return {text: source};
                        });

                        defer.resolve(sources);
                    });

                    return defer.promise;
                },

                statuses: function(query) {
                    var defer = $q.defer();

                    $q.resolve([
                        {text: 'New'},
                        {text: 'Update'},
                        {text: 'Imported'},
                        {text: 'Ignore'}
                    ]).then(function(response) {
                        var statuses = [];

                        statuses = _.filter(response, function(status) {
                            var regex = new RegExp(query, 'gi');
                            return regex.test(status.text);
                        });

                        defer.resolve(statuses);
                    });

                    return defer.promise;
                },

                export: function(caseId, server) {
                    return $http.post(baseUrl + '/export/' + caseId + '/' + server, {});
                }
            };

            return factory;
        });

})();

```

`frontend/app/scripts/services/api/ObservableTypeSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('ObservableTypeSrv', function($http) {
            var self = this;
            var baseUrl = './api/observable/type';

            this.list = function() {
                return $http.get(baseUrl, {
                    params: {
                        range: 'all'
                    }
                });
            };

            this.get = function(name) {
                return $http.get(baseUrl + '/' + name);
            };

            this.map = function() {
                return self.list()
                    .then(function(response) {
                        return _.indexBy(response.data, '_id');
                    });
            };

            this.create = function(type) {
                return $http.post(baseUrl, type);
            };

            this.update = function(id, type) {
                return $http.patch(baseUrl + '/' + id, type);
            };

            this.remove = function(id) {
                return $http.delete(baseUrl + '/' + id);
            };
        });

})();

```

`frontend/app/scripts/services/api/OrganisationSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('OrganisationSrv', function($q, $http, QuerySrv) {
            var self = this;
            var baseUrl = './api/organisation';

            self.defaultOrg = 'admin';

            self.isDefaultOrg = function(org) {
                return org.name === self.defaultOrg;
            };

            self.list = function() {
                return $http.get(baseUrl);
            };

            self.links = function(orgId) {
                return $http.get(baseUrl + '/' + orgId + '/links')
                    .then(function(response) {
                        return $q.resolve(response.data);
                    });
            };

            self.setLinks = function(orgId, links) {
                return $http.put(baseUrl + '/' + orgId + '/links', {
                    organisations: links || []
                })
                    .then(function(response) {
                        return $q.resolve(response.data);
                    });
            };

            self.get = function(orgId) {
                return $http.get(baseUrl + '/' + orgId)
                    .then(function(response) {
                        return $q.resolve(response.data);
                    });
            };

            self.create = function(data) {
                return $http.post(baseUrl + '/', data || {});
            };

            self.update = function(orgId, updates) {
                return $http.patch(baseUrl + '/' + orgId, updates);
            };

            self.users = function(orgId) {
                return QuerySrv.query('v1', [{
                        '_name': 'getOrganisation',
                        'idOrName': orgId
                    },
                    {
                        '_name': 'users'
                    }
                ], {
                    params: {
                        name: 'users'
                    }
                }).then(function(response) {
                    return $q.resolve(response.data);
                });
            };

            self.caseTemplates = function(orgId) {
                return QuerySrv.query('v0', [{
                        '_name': 'getOrganisation',
                        'idOrName': orgId
                    },
                    {
                        '_name': 'caseTemplates'
                    }
                ], {
                    params: {
                        name: 'caseTemplates'
                    }
                }).then(function(response) {
                    return $q.resolve(response.data);
                });
            };
        });

})();

```

`frontend/app/scripts/services/api/PlatformSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .service('PlatformSrv', function ($http) {

            this.getIndexStatus = function () {
                return $http.get('./api/v1/admin/index/status')
            }

            this.runReindex = function (indexName) {
                return $http.post('./api/v1/admin/index/' + indexName + '/reindex');
            }

            this.runRebuildIndex = function (indexName) {
                return $http.post('./api/v1/admin/index/' + indexName + '/rebuild');
            }

            this.getCheckStats = function () {
                return $http.get('./api/v1/admin/check/stats')
            }

            this.runCheck = function (checkName) {
                return $http.get('./api/v1/admin/check/' + checkName + '/trigger');
            }

        });
})();

```

`frontend/app/scripts/services/api/ProcedureSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('ProcedureSrv', function($q, $http) {
            var self = this;
            var baseUrl = './api/v1/procedure';

            self.get = function(procedureId) {
                return $http.get(baseUrl + '/' + procedureId)
                    .then(function(response) {
                        return $q.resolve(response.data);
                    });
            };

            self.create = function(data) {
                return $http.post(baseUrl, data || {});
            };

            self.update = function(procedureId, updates) {
                return $http.patch(baseUrl + '/' + procedureId, updates);
            };

            self.remove = function(procedureId, updates) {
                return $http.delete(baseUrl + '/' + procedureId, updates);
            };

        });

})();

```

`frontend/app/scripts/services/api/ProfileSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .service('ProfileSrv', function ($http) {
            var self = this;
            var baseUrl = './api/profile';

            this.adminProfile = 'admin';

            this.permissions = {
                admin: {
                    hints: 'Permissions for administration user profiles',
                    keys: [
                        'manageOrganisation',
                        'manageProfile',
                        'manageUser',
                        'manageCustomField',
                        'manageConfig',
                        'manageAnalyzerTemplate',
                        'manageObservableTemplate',
                        'manageTaxonomy',
                        'managePattern',
                        'managePlatform'
                    ],
                    labels: {
                        manageOrganisation: 'Manage organisations',
                        manageProfile: 'Manage profiles',
                        manageUser: 'Manage users',
                        manageCustomField: 'Manage custom fields',
                        manageConfig: 'Manage configurations',
                        manageAnalyzerTemplate: 'Manage analyzer templates',
                        manageObservableTemplate: 'Manage observable types',
                        manageTaxonomy: 'Manage taxonomies',
                        managePattern: 'Manage attack patterns',
                        managePlatform: 'Manage the platform'
                    }
                },
                org: {
                    hints: 'Permissions for organisation user profiles',
                    keys: [
                        'manageUser',
                        'manageCaseTemplate',
                        'manageTag',
                        'manageAlert',
                        'manageCase',
                        'manageShare',
                        'manageObservable',
                        'manageTask',
                        'manageProcedure',
                        'manageAction',
                        'manageAnalyse',
                        'accessTheHiveFS'
                    ],
                    labels: {
                        manageUser: 'Manage users',
                        manageCaseTemplate: 'Manage case templates',
                        manageTag: 'Manage custom tags',
                        manageAlert: 'Manage alert',
                        manageCase: 'Manage case',
                        manageShare: 'Manage sharing',
                        manageObservable: 'Manage observables',
                        manageTask: 'Manage tasks',
                        manageProcedure: 'Manage TTPs',
                        manageAction: 'Run Cortex responders',
                        manageAnalyse: 'Run Cortex analyzer',
                        accessTheHiveFS: 'Access to TheHiveFS service'
                    }
                }
            };

            this.list = function () {
                return $http.get(baseUrl, {
                    params: {
                        range: 'all'
                    }
                });
            };

            this.get = function (name) {
                return $http.get(baseUrl + '/' + name);
            };

            this.map = function () {
                return self.list()
                    .then(function (response) {
                        return _.indexBy(response.data, 'name');
                    });
            };

            this.create = function (profile) {
                return $http.post(baseUrl, profile);
            };

            this.update = function (id, profile) {
                return $http.patch(baseUrl + '/' + id, profile);
            };

            this.remove = function (id) {
                return $http.delete(baseUrl + '/' + id);
            };
        });

})();

```

`frontend/app/scripts/services/api/TagSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .service('TagSrv', function (QuerySrv, $q, VersionSrv, $http) {

            var self = this;

            this.tagsDefaultColour = '#000000';

            this.getFreeTags = function () {
                var defer = $q.defer();

                VersionSrv.get()
                    .then(function (appConfig) {
                        var defaultColour = appConfig.config.freeTagDefaultColour;

                        self.tagsDefaultColour = defaultColour;

                        return QuerySrv.query('v1', [
                            { _name: 'freetags' },
                            { _name: 'filter', _ne: { '_field': 'colour', '_value': defaultColour } }
                        ], {
                            params: {
                                name: 'freetags-cache'
                            }
                        })
                    })

                    .then(function (response) {
                        defer.resolve(response.data);
                    });

                return defer.promise;
            };

            this.updateTag = function (id, patch) {
                return $http.patch('./api/v1/tag/' + id, patch);
            }

            this.removeTag = function (id) {
                return $http.delete('./api/v1/tag/' + id);
            }

            this.autoComplete = function (term) {
                var defer = $q.defer();

                var operations = [
                    { _name: 'tagAutoComplete', freeTag: term, limit: 20 }
                ]

                QuerySrv.call('v1', operations, {
                    name: 'tags-auto-complete'
                }).then(function (response) {
                    defer.resolve(_.map(response, function (tag) {
                        return { text: tag };
                    }));
                });

                return defer.promise;
            };

        });
})();

```

`frontend/app/scripts/services/api/TaskLogSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').factory('TaskLogSrv', function(FileResource) {
        return FileResource('./api/case/task/:taskId/log/:logId', {}, {
            update: {
                method: 'PATCH'
            }
        });
    });
})();

```

`frontend/app/scripts/services/api/TaxonomyCacheSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .service('TaxonomyCacheSrv', function ($http, $q, $filter, $uibModal, VersionSrv, TagSrv, QuerySrv) {
            var self = this;

            this.cache = null;
            this.tagsCache = null;

            this.list = function () {
                return QuerySrv.call('v1', [
                    { _name: 'listTaxonomy' }
                ], {
                    name: 'list-taxonomies-cache',
                    filter: {
                        name: 'filter',
                        _field: 'enabled',
                        _value: true
                    }
                });
            };

            this.clearCache = function () {
                self.cache = null;
                self.tagsCache = null;
            };

            this.getCache = function (name) {
                return self.cache[name];
            };

            this.getColour = function (tag) {
                return self.tagsCache[tag];
            };

            this.cacheTagColors = function (tags) {
                var fn = $filter('tagValue');

                _.each(tags, function (tag) {
                    var name = fn(tag);

                    if (!_.isEmpty(name)) {
                        self.tagsCache[name] = tag.colour;
                    }
                });
            };

            this.refreshFreeTags = function () {
                return TagSrv.getFreeTags()
                    .then(function (freeTags) {
                        self.cacheTagColors(freeTags);
                    });
            }

            this.all = function (reload) {
                var deferred = $q.defer();

                if (self.cache === null || reload === true) {
                    self.list()
                        .then(function (response) {
                            self.cache = {};
                            self.tagsCache = {};

                            _.each(response, function (taxonomy) {
                                self.cache[taxonomy.namespace] = taxonomy;

                                self.cacheTagColors(taxonomy.tags);
                            });
                        })
                        .then(function () {
                            return TagSrv.getFreeTags();
                        })
                        .then(function (freeTags) {
                            self.cacheTagColors(freeTags);

                            deferred.resolve(self.cache);
                        });
                } else {
                    deferred.resolve(self.cache);
                }

                return deferred.promise;
            };

            self.openTagLibrary = function () {
                var defer = $q.defer();

                var modalInstance = $uibModal.open({
                    controller: 'TaxonomySelectionModalCtrl',
                    controllerAs: '$modal',
                    animation: true,
                    templateUrl: 'views/partials/misc/taxonomy-selection.modal.html',
                    size: 'lg',
                    resolve: {
                        taxonomies: function () {
                            return self.all();
                        }
                    }
                });

                modalInstance.result
                    .then(function (selectedTags) {
                        var filterFn = $filter('tagValue'),
                            tags = [];

                        _.each(selectedTags, function (tag) {
                            tags.push({
                                text: filterFn(tag)
                            });
                        });

                        //$scope.tags = $scope.tags.concat(tags);
                        defer.resolve(tags);
                    })
                    .catch(function (err) {
                        if (err && !_.isString(err)) {
                            NotificationSrv.error('Tag selection', err.data, err.status);
                        }
                        defer.rejeect(err);
                    });

                return defer.promise;
            };
        });
})();

```

`frontend/app/scripts/services/api/TaxonomySrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('TaxonomySrv', function($http, QuerySrv) {
            var baseUrl = './api/v1/taxonomy';

            this.list = function() {
                return QuerySrv.call('v1', [
                    { _name: 'listTaxonomy' }
                ], {
                    name:'list-taxonomies'
                });
            };

            this.get = function(name) {
                return $http.get(baseUrl + '/' + name);
            };

            this.toggleActive = function(id, active) {
                return $http.put([baseUrl, id, !!active ? 'activate' : 'deactivate'].join('/'));
            };

            this.create = function(profile) {
                return $http.post(baseUrl, profile);
            };

            this.update = function(id, profile) {
                return $http.patch(baseUrl + '/' + id, profile);
            };

            this.remove = function(id) {
                return $http.delete(baseUrl + '/' + id);
            };

            this.import = function(post) {
                var postData = {
                    file: post.attachment
                };

                return $http({
                    method: 'POST',
                    url: baseUrl + '/import-zip',
                    headers: {
                        'Content-Type': undefined
                    },
                    transformRequest: function (data) {
                        var formData = new FormData(),
                            copy = angular.copy(data, {});

                        angular.forEach(data, function (value, key) {
                            if (Object.getPrototypeOf(value) instanceof Blob || Object.getPrototypeOf(value) instanceof File) {
                                formData.append(key, value);
                                delete copy[key];
                            }
                        });

                        return formData;
                    },
                    data: postData
                });
            };
        });

})();

```

`frontend/app/scripts/services/api/UiSettingsSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').service('UiSettingsSrv', function($http, $q) {
        var baseUrl = './api/config/organisation/';
        var self = this;

        this.settings = null;

        this.keys = [
            'hideEmptyCaseButton',
            'disallowMergeAlertInResolvedSimilarCases',
            'defaultAlertSimilarCaseFilter',
            'defaultDateFormat'
        ];

        this.clearCache = function() {
            self.settings = null;
        };

        this.get = function(name) {
            return self.settings[name];
        };

        this.save = function(name, value) {
            return $http.put(baseUrl + 'ui.' + name, {value: value});
        };

        this.all = function(force) {
            var deferred = $q.defer();

            if(self.settings === null || force) {

                self.settings = {};

                $http.get('./api/config/organisation?path=ui')
                    .then(function(response) {
                        var data = response.data;

                        self.settings = data;
                        deferred.resolve(data);
                    })
                    .catch(function(response) {
                        deferred.reject(response);
                    });
            } else {
                deferred.resolve(self.settings);
            }

            return deferred.promise;
        };

        this.keys.forEach(function(key) {
            var camelcased = s.camelize(key.replace(/\./gi, '_'));
            self[camelcased] = function() {
                return (self.settings || {})[key];
            };
        });
    });
})();

```

`frontend/app/scripts/services/api/UserSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('UserSrv', function($http, $q, $uibModal, QuerySrv) {

            var self = this;

            this.userCache = {};

            this.query = function(config) {
                return $http.post('./api/v1/user/_search', config)
                    .then(function(response) {
                        return $q.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });
            };

            this.get = function(user) {
                if (!user) {
                    return;
                }
                return $http
                    .get('./api/v1/user/' + user)
                    .then(function(response) {
                        return $q.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });
            };

            this.save = function(user) {
                return $http
                    .post('./api/v1/user', user)
                    .then(function(response) {
                        return $q.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });
            };

            this.update = function(id, user) {
                var defer = $q.defer();

                $http
                    .patch('./api/v1/user/' + id, user)
                    .then(function(response) {
                        defer.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });

                return defer.promise;
            };

            this.remove = function(id, organisation) {
                return $http
                    .delete('./api/v1/user/' + id + '/force', {
                        params: {organisation: organisation}
                    })
                    .then(function(response) {
                        return $q.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });
            };

            this.changePass = function(id, currentPassword, password) {
                return $http
                    .post('./api/v1/user/' + id + '/password/change', {
                        currentPassword: currentPassword,
                        password: password
                    })
                    .then(function(response) {
                        return $q.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });
            };

            this.setPass = function(id, password) {
                return $http
                    .post('./api/v1/user/' + id + '/password/set', {
                        password: password
                    })
                    .then(function(response) {
                        return $q.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });
            };

            this.setKey = function(id) {
                return $http
                    .post('./api/v1/user/' + id + '/key/renew')
                    .then(function(response) {
                        return $q.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });
            };

            this.revokeKey = function(id) {
                return $http
                    .delete('./api/v1/user/' + id + '/key')
                    .then(function(response) {
                        return $q.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });
            };

            this.getUserInfo = function(login) {
                var defer = $q.defer();

                if (login === 'init') {
                    defer.resolve({
                        name: 'System'
                    });
                } else {
                    if (!login) {
                        defer.reject(undefined);
                        return;
                    }

                    self.get(login)
                        .then(function(user) {
                            defer.resolve(user);
                        })
                        .catch(function(err) {
                            err.data.name = '***unknown***';
                            defer.reject(err);
                        });
                }

                return defer.promise;
            };

            this.getKey = function(userId) {
                return $http
                    .get('./api/v1/user/' + userId + '/key')
                    .then(function(response) {
                        return $q.resolve(response.data);
                    })
                    .catch(function(err) {
                        return $q.reject(err);
                    });
            };

            this.fetchMfaSecret = function() {
                return $http
                    .post('./api/v1/auth/totp/set', {});
            };

            this.setMfa = function(code) {
                return $http
                    .post('./api/v1/auth/totp/set', {
                        code: code
                    });
            };

            this.resetMfa = function(user) {
                var url = './api/v1/auth/totp/unset';

                return $http.post(user ? (url+'/'+ user) : url );
            };

            this.list = function(organisation, options) {
                var operations = [{
                        '_name': 'getOrganisation',
                        'idOrName': organisation
                    },
                    {
                        '_name': 'users'
                    }
                ];

                var queryConfig = {};

                // Apply filter is defined
                if (options && options.filter) {
                    queryConfig.filter = options.filter;
                }

                // Apply sort is defined
                if (options && options.sort) {
                    queryConfig.sort = options.sort;
                }

                return QuerySrv.call('v1', operations, queryConfig);
            };

            this.autoComplete = function(organisation, query) {
                // TODO nadouani filter on server side
                return this.list(organisation, {
                    filter: {
                        _is: {
                            locked: false
                        }
                    }
                })
                .then(function(data) {
                    return _.map(data, function(user) {
                        return {
                            label: user.name,
                            text: user.login
                        };
                    });
                })
                .then(function(users) {
                    return _.filter(users, function(user) {
                        var regex = new RegExp(query, 'gi');

                        return regex.test(user.label);
                    });
                });
            };

            this.getCache = function(userId) {
                if (angular.isDefined(self.userCache[userId])) {
                    return $q.resolve(self.userCache[userId]);
                } else {
                    var defer = $q.defer();

                    self.getUserInfo(userId)
                        .then(function(userInfo) {
                            self.userCache[userId] = userInfo;
                            defer.resolve(userInfo);
                        })
                        .catch(function( /*err*/ ) {
                            defer.resolve(undefined);
                        });

                    return defer.promise;
                }
            };

            this.clearCache = function() {
                self.userCache = {};
            };

            this.removeCache = function(userId) {
                delete self.userCache[userId];
            };

            this.updateCache = function(userId, userData) {
                self.userCache[userId] = userData;
            };


            /**
             * Cache the details of all the visible users
             */
            this.loadCache = function() {
                var defer = $q.defer();

                QuerySrv.call('v1', [
                    {'_name': 'listOrganisation'},
                    {'_name': 'users'},
                    ], {
                        name: 'users'
                    })
                    .then(function(users) {
                        _.each(users, function(u) {
                            self.updateCache(u.login, u);
                        });
                        defer.resolve();
                    }).catch(function(err){
                        defer.reject(err);
                    });

                return defer.promise;
            };

            this.openModal = function(user, organisation) {
                var modalInstance = $uibModal.open({
                    templateUrl: 'views/partials/admin/organisation/user.modal.html',
                    controller: 'OrgUserModalCtrl',
                    controllerAs: '$modal',
                    size: 'lg',
                    resolve: {
                        organisation: $q.resolve(organisation),
                        user: angular.copy(user) || {},
                        profiles: function(ProfileSrv) {
                            return ProfileSrv.map();
                        },
                        isEdit: !!user
                    }
                });

                return modalInstance.result;
            };

        });
})();

```

`frontend/app/scripts/services/api/VersionSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('VersionSrv', function($http, $q, $interval) {
            var cache = null;

            var factory =  {
                startMonitoring: function(callback) {
                    $interval(function() {
                        factory.get(true)
                          .then(function(appConfig) {
                              if(callback) {
                                  callback(appConfig);
                              }
                          });
                    }, 60000);
                },
                get: function(force) {
                    var deferred = $q.defer();

                    if(!force && cache !== null) {
                        deferred.resolve(cache);
                    } else {
                        $http.get('./api/status').then(function(response) {
                            cache = response.data;
                            deferred.resolve(cache);
                        }, function(rejection) {
                            deferred.reject(rejection);
                        });
                    }

                    return deferred.promise;
                },

                hasCortexConnector: function() {
                    try {
                        var service = cache.connectors.cortex;

                        return service.enabled;
                    } catch (err) {
                        return false;
                    }
                },

                hasCortex: function() {
                    try {
                        var service = cache.connectors.cortex;

                        return service.enabled && _.pluck(service.servers, 'status').indexOf('OK') !== -1;
                    } catch (err) {
                        return false;
                    }
                },

                mispUrls: function() {
                    var urls = {};
                    var misp = cache.connectors.misp;

                    if(!misp) {
                        return {};
                    }

                    (misp.servers || []).forEach(function(item) {
                        urls[item.name] = item.url;
                    });
                    return urls;
                }
            };

            return factory;
        });
})();

```

`frontend/app/scripts/services/common/Constants.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .value('duScrollOffset', 30)
        .value('CaseResolutionStatus', {
            Indeterminate: 'Indeterminate',
            FalsePositive: 'False Positive',
            TruePositive: 'True Positive',
            Duplicated: 'Duplicate',
            Other: 'Other'
        })
        .value('CaseImpactStatus', {
            NoImpact: 'No Impact',
            WithImpact: 'With impact',
            NotApplicable: 'Not Applicable'
        })
        .value('Severity', {
            keys: {
                Critical: 4,
                High: 3,
                Medium: 2,
                Low: 1
            },
            values: ['Unknown', 'Low', 'Medium', 'High', 'Critical']
        })
        .value('AlertStatus', {
            values: ['New', 'Updated', 'Ignored', 'Imported']
        })
        .value('Tlp', {
            keys: {
                Red: 3,
                Amber: 2,
                Green: 1,
                White: 0
            },
            values: ['White', 'Green', 'Amber', 'Red']
        });
})();

```

`frontend/app/scripts/services/common/HtmlSanitizeSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('HtmlSanitizer', function($sanitize) {
            var entityMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': '&quot;',
                "'": '&#39;',
                "/": '&#x2F;'
            };

            this.sanitize = function(str) {
                return $sanitize(String(str).replace(/[&<>"'\/]/g, function(s) {
                    return entityMap[s];
                }));
            };
        });
})();

```

`frontend/app/scripts/services/common/QueryBuilderSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').service('QueryBuilderSrv', function(UtilsSrv) {
        var self = this;

        this._buildQueryFromDefaultFilter = function(fieldDef, filter) {
            return {
                _field: filter.field,
                _value: filter.value
            };
        };

        this._buildQueryFromBooleanFilter = function(fieldDef, filter) {
            if(filter.value === null) {
                return undefined;
            }

            return {
                _field: filter.field,
                _value: filter.value
            };
        };

        this._buildQueryFromNumberFilter = function(fieldDef, filter) {
            if (!filter || !filter.value) {
                return null;
            }
            var operator = filter.value.operator || 'eq';

            if(operator === 'empty') {
                return {
                    _not: {
                        _contains: filter.field
                    }
                };
            }

            var criterion = {};
            criterion[filter.field] = filter.value.value;

            switch(operator) {
                case '<':
                    return {'_lt': criterion};
                case '<=':
                    return {'_lte': criterion};
                case '>':
                    return {'_gt': criterion};
                case '>=':
                    return {'_gte': criterion};
                case '!=':
                    return {'_not': criterion};
                default:
                    return {'_field': filter.field, '_value': filter.value.value};
            }
        };

        this._buildQueryFromFreeTextFilter = function(fieldDef, filter) {
            if (!filter || !filter.value) {
                return null;
            }
            var operator = filter.value.operator || 'any';

            if(operator === 'empty') {
                return {
                    _not: {
                        _contains: filter.field
                    }
                };
            } else {
                var values = _.pluck(filter.value.list, 'text');

                if(values.length > 0) {
                    var criterions = _.map(values, function(val) {
                        return {_like: {
                            _field: filter.field,
                            _value: val
                        }};
                    });

                    var criteria = {};
                    switch(operator) {
                        case 'all':
                            criteria = criterions.length === 1 ? criterions[0] : { _and: criterions };
                            break;
                        case 'none':
                            criteria = {
                                _not: criterions.length === 1 ? criterions[0] : { _or: criterions }
                            };
                            break;
                        default:
                            criteria = criterions.length === 1 ? criterions[0] : { _or: criterions };
                    }

                    return criteria;
                }
            }



            return null;
        };

        this._buildQueryFromTagsFilter = function(fieldDef, filter) {
            if (!filter || !filter.value) {
                return null;
            }
            var operator = filter.value.operator || 'any';

            if(operator === 'empty') {
                return {
                    _not: {
                        _contains: filter.field
                    }
                };
            } else {
                var values = _.pluck(filter.value.list, 'text');

                if(values.length > 0) {
                    var criterions = _.map(values, function(val) {
                        return {
                            _like: {
                                _field: filter.field,
                                _value: val
                            }
                        };
                    });

                    var criteria = {};
                    switch(operator) {
                        case 'all':
                            criteria = criterions.length === 1 ? criterions[0] : { _and: criterions };
                            break;
                        case 'none':
                            criteria = {
                                _not: criterions.length === 1 ? criterions[0] : { _or: criterions }
                            };
                            break;
                        //case 'any':
                        default:
                            criteria = criterions.length === 1 ? criterions[0] : { _or: criterions };
                    }

                    return criteria;
                }
            }



            return null;
        };

        this._buildQueryFromListFilter = function(fieldDef, filter) {
            if (!filter || !filter.value) {
                return null;
            }
            var operator = filter.value.operator || 'any';

            if(operator === 'empty') {
                return {
                    _not: {
                        _contains: filter.field
                    }
                };
            }

            var values = _.pluck(filter.value.list, 'text');

            if(values.length > 0) {
                var criterions = _.map(values, function(val) {
                    return {_field: filter.field, _value: val};
                });

                var criteria = {};
                switch(operator) {
                    case 'all':
                        criteria = criterions.length === 1 ? criterions[0] : { _and: criterions };
                        break;
                    case 'none':
                        criteria = {
                            _not: criterions.length === 1 ? criterions[0] : { _or: criterions }
                        };
                        break;
                    //case 'any':
                    default:
                        criteria = criterions.length === 1 ? criterions[0] : { _or: criterions };
                }

                return criteria;
            }

            return null;
        };

        this._buildQueryFromDateFilter = function(fieldDef, filter) {
            var value = filter.value,
                operator = filter.value.operator || 'custom',
                start,
                end;

            if(operator === 'empty') {
                return {
                    _not: {
                        _contains: filter.field
                    }
                };
            }

            if(operator === 'custom') {
                if(value.from && value.from !== null) {
                    start = _.isString(value.from) ? (new Date(value.from)).getTime() : value.from.getTime();
                } else {
                    start = null;
                }

                if(value.to && value.to !== null) {
                    end = _.isString(value.to) ? (new Date(value.to)).setHours(23, 59, 59, 999) : value.to.setHours(23, 59, 59, 999);
                } else {
                    end = null;
                }
            } else {
                var dateRange = UtilsSrv.getDateRange(operator);

                start = dateRange.from.getTime();
                end = dateRange.to.getTime();
            }

            if (start !== null && end !== null) {
                return {
                    _between: { _field: filter.field, _from: start, _to: end }
                };
            } else if (start !== null) {
                var gt = {};
                gt[filter.field] = start;

                return {
                    _gt: gt
                };
            } else {
                var lt = {};
                lt[filter.field] = end;

                return {
                    _lt: lt
                };
            }

            return null;
        };

        this._buildQueryFromFilter = function(fieldDef, filter) {
            if (filter.type === 'date') {
                return this._buildQueryFromDateFilter(fieldDef, filter);
            } else if(filter.type === 'boolean') {
                return this._buildQueryFromBooleanFilter(fieldDef, filter);
            } else if(filter.field === 'tags') {
                return this._buildQueryFromTagsFilter(fieldDef, filter);
            } else if(filter.type === 'user' || filter.field === 'tags' || filter.type === 'enumeration') {
                return this._buildQueryFromListFilter(fieldDef, filter);
            } else if(filter.type === 'string' && fieldDef.values.length === 0) {
                // TODO implemtent like operator
                return this._buildQueryFromFreeTextFilter(fieldDef, filter);
            } else if(filter.value.list || fieldDef.values.length > 0) {
                return this._buildQueryFromListFilter(fieldDef, filter);
            } else if(filter.type === 'number' || filter.type === 'integer' || filter.type === 'float') {
                return this._buildQueryFromNumberFilter(fieldDef, filter);
            }



            return {
                _string: filter.field + ':"' + filter.value +'"'
            };
        };

        this.buildFiltersQuery = function(fields, filters) {
            var criterias =
                _.map(filters, function(filter) {
                    return self._buildQueryFromFilter(fields[filter.field], filter);
                }) || [];

            criterias = _.without(criterias, null, undefined, {});

            return criterias.length === 0 ? {} : criterias.length === 1 ? criterias[0] : { _and: criterias };
        };
    });
})();

```

`frontend/app/scripts/services/common/QuerySrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .service('QuerySrv', function ($http, $q) {
            var self = this;

            this._buildSort = function (sort) {

                var input = _.isArray(sort) ? sort : [sort];

                return _.map(input, function (item) {
                    var ret = {};

                    if (item.startsWith('-')) {
                        ret[item.slice(1)] = 'desc';
                    } else if (item.startsWith('+')) {
                        ret[item.slice(1)] = 'asc';
                    }

                    return ret;
                });
            };

            this.query = function (version, operations, config) {
                return $http.post('./api/' + version + '/query', {
                    query: operations
                }, config || {});
            };


            /**
             * List objects using the Query API
             *
             * @param  {type} version           API version
             * @param  {type} selectorOperation Initial operations
             * @param  {type} options           Options object defining filters, sort, pagination and addition $http options
             * @return {type}                   Promise resolving to the list of the searched objects
             */
            this.call = function (version, selectorOperation, options) {
                var operations = [].concat(selectorOperation);
                var config = {};

                // Apply filter is defined
                if (options && options.filter && !_.isEmpty(options.filter)) {
                    operations.push(
                        _.extend({ '_name': 'filter' }, options.filter)
                    );
                }

                // Apply sort is defined
                if (options && options.sort) {
                    operations.push(
                        _.extend({ '_name': 'sort' }, { '_fields': this._buildSort(options.sort) })
                    );
                }

                // Apply pagination if isDefined
                if (options && options.page) {
                    operations.push(
                        _.extend({ '_name': 'page' }, options.page)
                    );
                }

                if (options && options.name) {
                    config.params = {
                        name: options.name
                    };
                }

                if (options && options.config) {
                    config = _.extend({}, config, options.config);
                }

                return self.query(version, operations, config)
                    .then(function (response) {
                        return $q.resolve(response.data);
                    });
            };


            /**
             * Count objects using the Query API
             *
             * @param  {type} version           API version
             * @param  {type} selectorOperation Initial operations
             * @param  {type} options           Options object defining filters and addition $http options
             * @return {type}                   Promise resolving to the total of the searched objects
             */
            this.count = function (version, selectorOperation, options) {
                var operations = [].concat(selectorOperation);
                var config = {};

                // Apply filter is defined
                if (options && options.filter && !_.isEmpty(options.filter)) {
                    operations.push(
                        _.extend({ '_name': 'filter' }, options.filter)
                    );
                }

                if (options && options.name) {
                    config.params = {
                        name: options.name + '.count'
                    };
                }

                if (options && options.config) {
                    config = _.extend({}, config, options.config);
                }

                // Add count
                operations.push({ '_name': options.limitedCount ? 'limitedCount' : 'count' });

                return self.query(version, operations, config)
                    .then(function (response) {
                        return $q.resolve(response.data);
                    });
            };
        });
})();

```

`frontend/app/scripts/services/common/SecuritySrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('SecuritySrv', function() {

            this.checkPermissions = function(allowedPermissions, permissions) {
                if(_.isString(permissions)) {
                    permissions = permissions.split(',') || [];
                }
                return !_.isEmpty(_.intersection(allowedPermissions, permissions));
            };

        });
})();

```

`frontend/app/scripts/services/common/UtilsSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .factory('UtilsSrv', function ($location) {
            var sensitiveTypes = ['url', 'ip', 'mail', 'domain', 'filename'];

            var service = {
                guid: function () {
                    function s4() {
                        return Math.floor((1 + Math.random()) * 0x10000)
                            .toString(16)
                            .substring(1);
                    }
                    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                        s4() + '-' + s4() + s4() + s4();
                },
                objectify: function (arr, property) {
                    return _.map(arr, function (str) {
                        var obj = {};
                        obj[property] = str;
                        return obj;
                    });
                },

                fangValue: function (value) {
                    return value
                        .replace(/\[\.\]/g, ".")
                        .replace(/hxxp/gi, "http")
                        .replace(/\./g, "[.]")
                        .replace(/http/gi, "hxxp");
                },

                fang: function (observable) {
                    if (sensitiveTypes.indexOf(observable.dataType) === -1) {
                        return observable.data;
                    }

                    return service.fangValue(observable.data);
                },

                unfang: function (observable) {
                    return observable.data
                        .replace(/\[\.\]/g, ".")
                        .replace(/hxxp/gi, "http");
                },

                shallowClearAndCopy: function (src, dst) {
                    dst = dst || {};

                    angular.forEach(dst, function (value, key) {
                        delete dst[key];
                    });

                    for (var key in src) {
                        if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {
                            dst[key] = src[key];
                        }
                    }
                    return dst;
                },

                updatableLink: function (scope, element, attrs) {
                    scope.updatable = {
                        'updating': false
                    };
                    scope.oldValue = scope.value;
                    if (!angular.isDefined(scope.active)) {
                        scope.active = false;
                    }
                    scope.edit = function () {
                        scope.updatable.updating = true;
                    };
                    scope.update = function (newValue) {
                        if (angular.isDefined(newValue)) {
                            scope.value = newValue;
                        }
                        if (angular.isDefined(attrs.onUpdate)) {
                            var updateResult = scope.onUpdate({
                                'newValue': scope.value
                            });
                            if (angular.isDefined(updateResult) && angular.isDefined(updateResult.$promise)) {
                                updateResult = updateResult.$promise;
                            }
                            if (angular.isObject(updateResult) && angular.isFunction(updateResult.then)) {
                                updateResult.then(function () {
                                    scope.oldValue = scope.value;
                                    scope.active = false;
                                    scope.format = 'static';
                                }, function () {
                                    scope.value = scope.oldValue;
                                });
                            } else {
                                scope.oldValue = scope.value;
                                scope.active = false;
                                scope.format = 'static';
                            }
                        }
                        scope.updatable.updating = false;
                    };
                    scope.cancel = function () {
                        scope.value = scope.oldValue;
                        scope.updatable.updating = false;
                    };
                    scope.clear = function () {
                        scope.value = null;
                    };
                },

                extractQueryParam: function (paramName, queryString) {
                    if (!queryString || !paramName) {
                        return;
                    }

                    var param = $location.search()[paramName];

                    if (param) {
                        return param;
                    } else {
                        var parsedQuery = _.find(queryString.split('&'), function (str) {
                            return str.startsWith(paramName + '=');
                        });
                        return parsedQuery ? parsedQuery.substr(paramName.length + 1) : undefined;
                    }
                },

                getDateRange: function (operator) {
                    var from;

                    switch (operator) {
                        case 'last7days':
                            from = moment().subtract(7, 'days');
                            break;
                        case 'last30days':
                            from = moment().subtract(30, 'days');
                            break;
                        case 'last3months':
                            from = moment().subtract(3, 'months');
                            break;
                        case 'last6months':
                            from = moment().subtract(6, 'months');
                            break;
                        case 'lastyear':
                            from = moment().subtract(1, 'years');
                            break;
                        case 'today':
                        default:
                            from = moment();
                            break;
                    }

                    var to = moment();

                    return {
                        from: from.hour(0).minutes(0).seconds(0).toDate(),
                        to: to.hour(23).minutes(59).seconds(59).toDate()
                    };
                },

                hasAddDeleteEvents: function (updates) {
                    if (!updates || updates.length === 0)
                        return;

                    return _.without(_.map(updates, function (u) {
                        return u.base.operation;
                    }), 'Update').length > 0;
                }
            };

            return service;
        });
})();

```

`frontend/app/scripts/services/common/data/CaseArtifactSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('CaseArtifactSrv', function($http, FileResource) {
            var api = null;

            this.api = function() {
                if(api === null) {
                    return FileResource('./api/case/:caseId/artifact/:artifactId', {}, {
                        update: {
                            method: 'PATCH'
                        },
                        similar: {
                            url: './api/case/artifact/:artifactId/similar',
                            isArray: true
                        }
                    });
                }

                return api;
            };

            this.similar = function(observableId, options) {
                return $http.get('./api/case/artifact/'+observableId+'/similar', {
                        params: options
                    })
                    .then(function(response) {                        
                        return _.filter(response.data, function(item) {
                            return item.stats && item.stats.case;
                        });
                    });
            };

            this.bulkUpdate = function(ids, update) {
                return $http.patch('./api/case/artifact/_bulk', _.extend({ids: ids}, update));
            };

            this.getShares = function(caseId, observableId) {
                return $http.get('./api/case/' + caseId + '/observable/' + observableId + '/shares');
            };

            this.addShares = function(observableId, organisations) {
                return $http.post('./api/case/artifact/' + observableId + '/shares', {
                    organisations: organisations
                });
            };

            this.removeShare = function(id, share) {
                return $http.delete('./api/observable/'+id+'/shares', {
                    data: {
                        organisations: [share.organisationName]
                    },
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
            };

        });
})();

```

`frontend/app/scripts/services/common/data/FileResource.js`:

```js
(function() {
    'use strict';

    angular.module('theHiveServices').factory('FileResource',
        function($resource, $http) {
            function setUrlParams(url, params) {
                angular.forEach(params, function(_, urlParam) {
                    var val = params[urlParam];
                    if (angular.isString(val)) {
                        var encodedVal = encodeURIComponent(val);
                        url = url.replace(new RegExp(':' + urlParam + '(\\W|$)', 'g'), function(match, p1) {
                            return encodedVal + p1;
                        });
                    } else {
                        url = url.replace(new RegExp('(\/?):' + urlParam + '(\\W|$)', 'g'), function(match,
                            leadingSlashes, tail) {
                            if (tail.charAt(0) === '/') {
                                return tail;
                            } else {
                                return leadingSlashes + tail;
                            }
                        });
                    }
                });
                // remove all undefined parameters
                url = url.replace(/:\w+/, '');
                // then replace collapse `/.` if found in the last URL path
                // segment before
                // the query
                // E.g. `http://url.com/id./format?q=x` becomes
                // `http://url.com/id.format?q=x`
                url = url.replace(/\/\.(?=\w+($|\?))/, '.');
                // replace escaped `/\.` with `/.`
                url = url.replace(/\/\\\./, '/.');

                // strip trailing slash
                if (url.substr(-1) === '/') {
                    return url.substr(0, url.length - 1);
                } else {
                    return url;
                }
            }

            return function(url, paramDefaults, actions, options) {
                var res = $resource(url, paramDefaults, actions, options);

                res.save = function(parameters, postData, success, error) {
                    return $http({
                        method: 'POST',
                        url: setUrlParams(url, parameters),
                        headers: {
                            'Content-Type': undefined
                        },
                        transformRequest: function(data) {
                            var formData = new FormData(),
                                copy = angular.copy(data, {}),
                                _json = {};

                            angular.forEach(data, function(value, key) {
                                if(Object.getPrototypeOf(value) instanceof Blob || Object.getPrototypeOf(value) instanceof File) {
                                    formData.append(key, value);
                                    delete copy[key];
                                } else {
                                    _json[key] = value;
                                }
                            });

                            formData.append("_json", angular.toJson(_json));

                            return formData;
                        },
                        data: postData

                    }).then(success, error);

                };
                return res;
            };
        }
    );

})();

```

`frontend/app/scripts/services/common/data/PSearchSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('PSearchSrv', function(SearchSrv, StreamSrv) {
            function update(objectType, control, updates) {
                var range = '';
                if (control.loadAll) {
                    range = 'all';
                } else {
                    var end = control.currentPage * control.pageSize;
                    var start = end - control.pageSize;
                    range = start + '-' + end;
                }
                var filter;
                if (angular.isString(control.filter) && control.filter.length > 0 &&
                    angular.isString(control.baseFilter) && control.baseFilter.length > 0) {
                    filter = {
                        _string: '(' + control.filter + ') AND (' + control.baseFilter + ')'
                    };
                } else {
                    filter = _.without([control.filter, control.baseFilter], null, undefined, {}, '');
                    filter = filter.length === 0 ? {
                        '_any': '*'
                    } : {
                        _and: filter
                    };
                }
                SearchSrv(function(data, total) {
                    if (control.loadAll) {
                        control.allValues = data;
                        changePage(control);
                    } else {
                        control.values = data;
                        if (angular.isFunction(control.onUpdate)) {
                            control.onUpdate(updates);
                        }
                    }
                    control.total = total;
                }, filter, objectType, range, control.sort, control.nparent, control.nstats);
            }

            function changePage(control) {
                if (control.loadAll) {
                    control.values.length = 0;
                    var end = control.currentPage * control.pageSize;
                    var start = end - control.pageSize;
                    angular.forEach(control.allValues.slice(start, end), function(d) {
                        control.values.push(d);
                    });
                } else {
                    control.update();
                }

                if (angular.isFunction(control.onUpdate)) {
                    control.onUpdate();
                }
            }

            /**
             * [function description]
             * @param  {String} root
             * @param  {String} objectType
             * @param  {Object} control
             *
             * @return {Object}
             */
            return function(root, objectType, control) {
                control.values = [];
                control.allValues = [];
                control.total = 0;
                control.currentPage = 1;
                control.update = function() {
                    update(objectType, control);
                };
                control.changePage = function() {
                    changePage(control);
                };
                if (!angular.isNumber(control.pageSize)) {
                    control.pageSize = 10;
                }
                if (control.loadAll !== true) {
                    control.loadAll = false;
                }

                if (!angular.isString(root)) {
                    root = 'any';
                }

                if (control.skipStream !== true) {
                    var streamCfg = {
                        scope: control.scope,
                        rootId: root,
                        objectType: control.streamObjectType || objectType,
                        callback: function(updates) {
                            if(!control.guard || control.guard(updates)) {
                                update(objectType, control, updates);
                            }
                        }
                    };

                    StreamSrv.addListener(streamCfg);
                }

                update(objectType, control);
                return control;
            };
        });
})();

```

`frontend/app/scripts/services/common/data/PaginatedQuerySrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .service('PaginatedQuerySrv', function ($filter, StreamSrv, QuerySrv) {

            return function (options) {
                var self = this;

                // Internal fields
                this.values = [];
                this.allValues = [];
                this.total = 0;
                this.currentPage = 1;
                this.filterHash = null;

                // Save options
                this.options = options;
                this.root = options.root || 'any';
                this.objectType = options.objectType;
                this.version = options.version;
                this.scope = options.scope;
                this.loadAll = !!options.loadAll;
                this.pageSize = options.pageSize || 10;
                this.pageOptions = options.pageOptions || {};
                this.limitedCount = options.limitedCount || false;
                this.baseFilter = options.baseFilter;
                this.filter = options.filter;
                this.sort = options.sort;
                this.onUpdate = options.onUpdate;
                this.onFailure = options.onFailure;
                this.skipStream = options.skipStream;
                this.streamObjectType = options.streamObjectType || options.objectType;
                this.guard = options.guard || undefined;
                this.withStats = options.withStats || undefined;
                this.extraData = options.extraData || undefined;
                this.name = options.name || undefined;
                this.config = options.config || {};
                this.loading = false;
                this.loadingCount = false;

                this.operations = options.operations;

                // Create a listener if the option is enabled
                if (this.skipStream !== true) {
                    var streamCfg = {
                        scope: self.scope,
                        rootId: self.root,
                        objectType: self.streamObjectType,
                        callback: function (updates) {
                            if (!self.guard || self.guard(updates)) {
                                self.update(updates, true);
                            }
                        }
                    };

                    StreamSrv.addListener(streamCfg);
                }

                /*
                Function to change the page
                */
                this.changePage = function () {
                    if (this.loadAll) {
                        this.values.length = 0;
                        var end = this.currentPage * this.pageSize;
                        var start = end - this.pageSize;
                        angular.forEach(this.allValues.slice(start, end), function (d) {
                            self.values.push(d);
                        });

                        if (angular.isFunction(this.onUpdate)) {
                            this.onUpdate(this.allValues);
                        }
                    } else {
                        this.update();
                    }
                };

                /*
                Function to compute the range of the page
                */
                this.getPage = function () {
                    if (this.loadAll) {
                        return;
                    }

                    var to = this.currentPage * this.pageSize;
                    var from = to - this.pageSize;
                    //range = start + '-' + end;

                    return _.extend(
                        {
                            from: from,
                            to: to
                        },
                        self.extraData ? { extraData: self.extraData } : {},
                        self.pageOptions ? self.pageOptions : {}
                    );
                };


                /**
                 * Prepare the filters collection to the Query service
                 *
                 * @return {type}  filters definition
                 */
                this.getFilter = function () {
                    if (!this.baseFilter && !this.filter) {
                        return;
                    }

                    var predicates = _.filter([this.baseFilter, this.filter], function (item) {
                        return !_.isEmpty(item);
                    });

                    if (predicates.length === 0) {
                        return [];
                    }

                    return predicates.length === 1 ? predicates[0] : { '_and': predicates };
                };

                /**
                 * Prepare the sort attributes to the Query service
                 *
                 * @return {type}  sort definition
                 */
                this.getSort = function () {
                    return self.sort;
                };

                /*
                Function to change the page
                */
                this.update = function (updates, forceCount) {
                    var filters = self.getFilter();

                    // Get the list
                    this.loading = true;
                    QuerySrv.call(this.version, this.operations, {
                        filter: filters,
                        sort: self.getSort(),
                        page: self.getPage(),
                        config: self.config,
                        withParent: false,
                        name: self.name
                    })
                        .then(function (data) {
                            if (self.loadAll) {
                                self.allValues = data;

                                self.total = data.length;

                                self.changePage();
                            } else {
                                self.values = data;
                                if (angular.isFunction(self.onUpdate)) {
                                    self.onUpdate(updates);
                                }
                            }
                        })
                        .catch(function (err) {
                            if (self.onFailure) {
                                self.onFailure(err);
                            }
                        })
                        .finally(function () {
                            self.loading = false;
                        });

                    // get the total if not cached
                    var hash = $filter('md5')(JSON.stringify(this.filter));
                    if (forceCount || (!!!this.loadAll && this.filterHash !== hash)) {
                        this.filterHash = hash;

                        // Compute the total again
                        self.loadingCount = true;
                        QuerySrv.count('v1', this.operations, {
                            filter: filters,
                            name: self.name,
                            config: self.config,
                            limitedCount: self.limitedCount
                        }).then(function (total) {
                            self.total = total;
                        }).finally(function () {
                            self.loadingCount = false;
                        });
                    }

                };

                // Call the initial load
                this.update();
            };

        });

})();

```

`frontend/app/scripts/services/common/data/SearchSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('SearchSrv', function($http, NotificationSrv) {
            return function(cb, filter, objectType, range, sort, nparent, nstats) {
                var url;

                // Compute API url
                if (!angular.isString(objectType) || objectType === 'any') {
                    url = './api/_search';
                } else {
                    var entity = objectType.replace(/_/g, '/');
                    if(entity[0] === '/') {
                        entity = entity.substr(1);
                    }

                    url = './api/' + entity + '/_search';
                }

                // Compute API url's query params
                var params = '';
                if (angular.isString(range)) {
                    params = params + '&range=' + encodeURIComponent(range);
                }
                if (angular.isString(sort)) {
                    params = params + '&sort=' + encodeURIComponent(sort);
                } else if (angular.isArray(sort)) {
                    var sortFields = _.map(sort, function(s) {
                        return 'sort=' + encodeURIComponent(s);
                    });

                    params = params + '&' + sortFields.join('&');
                }
                if (angular.isNumber(nparent)) {
                    params = params + '&nparent=' + nparent;
                }
                if (nstats === true) {
                    params = params + '&nstats=' + nstats;
                }

                // Call the API url
                $http.post(url + '?' + params.substr(1), {
                    'query': filter
                }).then(function(response) {
                    cb(response.data, parseInt(response.headers('X-Total')));
                }).catch(function(err) {
                    var message = err.data.type || err.data.message;
                    NotificationSrv.error('SearchSrv', message, err.status);
                });
            };
        });

})();

```

`frontend/app/scripts/services/common/data/StatSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('StatSrv', function($http, NotificationSrv, UtilsSrv) {
            function getPromise(config) {
                var stats = [];

                if (config.field) {
                    var agg = {
                        _agg: 'field',
                        _field: config.field,
                        _select: [{
                            _agg: 'count'
                        }]
                    };

                    if (config.sort) {
                        agg._order = config.sort;
                    }

                    if (config.limit) {
                        agg._size = config.limit;
                    }

                    stats.push(agg);
                }

                if(!config.skipTotal) {
                  stats.push({
                      _agg: 'count'
                  });
                }

                var entity = config.objectType.replace(/_/g, '/');
                if(entity[0] === '/') {
                    entity = entity.substr(1);
                }

                return $http.post('./api/' + entity + '/_stats', {
                        query: config.query,
                        stats: stats
                    })
                    .then(function(ret) {
                        return ret;
                    });
            }


            function get(config) {
                var result;

                if (!angular.isObject(config.result)) {
                    result = {};
                } else {
                    result = config.result;
                }

                getPromise(config).then(function(r) {
                    UtilsSrv.shallowClearAndCopy(r.data, result);
                    if (angular.isFunction(config.success)) {
                        config.success(r.data, r.status, r.headers, r.config);
                    }
                }).catch(function(r) {
                    if (angular.isFunction(config.error)) {
                        config.error(r.data, r.status, r.headers, r.config);
                    } else {
                        NotificationSrv.error('StatSrv', r.data, r.status);
                    }
                });
                return result;
            }

            function prepareResult(rawStats) {
                var total = rawStats.count;

                var keys = _.without(_.keys(rawStats), 'count');
                var columns = keys.map(function(key) {
                    return {
                        key: key,
                        count: rawStats[key].count
                    };
                });

                return {
                    total: total,
                    details: _.sortBy(columns, 'count').reverse()
                };
            }

            return {
                'get': get,
                'getPromise': getPromise,
                'prepareResult': prepareResult
            };
        });
})();

```

`frontend/app/scripts/services/common/data/StreamQuerySrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices')
        .factory('StreamQuerySrv', function ($http, StreamSrv, QuerySrv) {
            return function (version, operations, config) {
                StreamSrv.addListener({
                    scope: config.scope,
                    rootId: config.rootId,
                    objectType: config.objectType,
                    callback: function (updates) {
                        if (!config.guard || config.guard(updates)) {
                            QuerySrv.query(version, operations, config.query)
                                .then(function (response) {
                                    config.onUpdate(response.data);
                                });
                        }
                    }
                });

                QuerySrv.query(version, operations, config.query)
                    .then(function (response) {
                        config.onUpdate(response.data);
                    });
            };
        });
})();

```

`frontend/app/scripts/services/common/data/StreamSrv.js`:

```js
(function () {
    'use strict';
    angular.module('theHiveServices').factory('StreamSrv', function ($q, $rootScope, $http, $timeout, UserSrv, AuthenticationSrv, AfkSrv, NotificationSrv, VersionSrv) {

        var self = {
            isPolling: false,
            streamId: null,
            httpRequestCanceller: $q.defer(),
            disabled: true,

            init: function () {
                self.streamId = null;
                self.disabled = false;
                self.requestStream();
            },

            runCallbacks: function (id, objectType, message) {
                $rootScope.$broadcast('stream:' + id + '-' + objectType, message);
            },

            handleStreamResponse: function (data) {
                if (!data || data.length === 0) {
                    return;
                }

                var byRootIds = {};
                var byObjectTypes = {};
                var byRootIdsWithObjectTypes = {};
                var bySecondaryObjectTypes = {};

                angular.forEach(data, function (message) {
                    var rootId = message.base.rootId;
                    var objectType = message.base.objectType;
                    var rootIdWithObjectType = rootId + '|' + objectType;
                    var secondaryObjectTypes = message.summary ? _.without(_.keys(message.summary), objectType) : [];

                    if (rootId in byRootIds) {
                        byRootIds[rootId].push(message);
                    } else {
                        byRootIds[rootId] = [message];
                    }

                    if (objectType in byObjectTypes) {
                        byObjectTypes[objectType].push(message);
                    } else {
                        byObjectTypes[objectType] = [message];
                    }

                    if (rootIdWithObjectType in byRootIdsWithObjectTypes) {
                        byRootIdsWithObjectTypes[rootIdWithObjectType].push(message);
                    } else {
                        byRootIdsWithObjectTypes[rootIdWithObjectType] = [message];
                    }

                    _.each(secondaryObjectTypes, function (type) {
                        if (type in bySecondaryObjectTypes) {
                            bySecondaryObjectTypes[type].push(message);
                        } else {
                            bySecondaryObjectTypes[type] = [message];
                        }
                    });

                });

                angular.forEach(byRootIds, function (messages, rootId) {
                    self.runCallbacks(rootId, 'any', messages);
                });
                angular.forEach(byObjectTypes, function (messages, objectType) {
                    self.runCallbacks('any', objectType, messages);
                });

                // Trigger strem event for sub object types
                angular.forEach(bySecondaryObjectTypes, function (messages, objectType) {
                    self.runCallbacks('any', objectType, messages);
                });

                angular.forEach(byRootIdsWithObjectTypes, function (messages, rootIdWithObjectType) {
                    var temp = rootIdWithObjectType.split('|', 2),
                        rootId = temp[0],
                        objectType = temp[1];

                    self.runCallbacks(rootId, objectType, messages);
                });

                self.runCallbacks('any', 'any', data);
            },

            cancelPoll: function () {
                if (self.httpRequestCanceller) {
                    self.httpRequestCanceller.resolve('cancel');
                }

                self.disabled = true;
            },

            poll: function () {
                // Skip polling is a poll is already running
                if (self.streamId === null || self.isPolling === true) {
                    return;
                }

                // Flag polling start
                self.isPolling = true;

                // Initiate stream canceller
                self.httpRequestCanceller = $q.defer();

                // Poll stream changes
                self.pollPromise = $http.get('./api/stream/' + self.streamId, {
                    timeout: self.httpRequestCanceller.promise
                }).then(function (res) {
                    // Flag polling end
                    self.isPolling = false;

                    // Handle stream data and callbacks
                    self.handleStreamResponse(res.data);

                    // Check if the session will expire soon
                    if (res.status === 220) {
                        AfkSrv.prompt().then(function () {
                            UserSrv.getUserInfo(AuthenticationSrv.currentUser.login)
                                .then(function () {

                                }, function (response) {
                                    NotificationSrv.error('StreamSrv', response.data, response.status);
                                });
                        });
                    }

                    VersionSrv.get().then(function (appConfig) {
                        var pollingDuration;
                        try {
                            pollingDuration = appConfig.config.pollingDuration
                        } catch (error) {
                            pollingDuration = 0
                        }

                        $timeout(function () {
                            self.poll();
                        }, pollingDuration);
                    })


                }).catch(function (err) {
                    // Initialize the stream;
                    self.isPolling = false;

                    if (err && err.xhrStatus === 'abort') {
                        return;
                    }

                    if (err.status !== 404) {
                        NotificationSrv.error('StreamSrv', err.data, err.status);

                        if (err.status === 401) {
                            return;
                        }
                    }

                    self.init();
                });
            },


            requestStream: function () {
                if (self.streamId !== null) {
                    return;
                }

                $http.post('./api/stream').then(function (response) {
                    var streamId = response.data;

                    self.streamId = streamId;
                    self.poll(self.streamId);
                }).catch(function (err) {
                    NotificationSrv.error('StreamSrv', err.data, err.status);
                });
            },

            /**
             * @param config {Object} This configuration object has the following attributes
             * <li>rootId</li>
             * <li>objectType {String}</li>
             * <li>scope {Object}</li>
             * <li>callback {Function}</li>
             */
            addListener: function (config) {
                if (!config.scope) {
                    console.error('No scope provided, use the old listen method', config);
                    self.listen(config.rootId, config.objectType, config.callback);
                    return;
                }

                var eventName = 'stream:' + config.rootId + '-' + config.objectType;
                config.scope.$on(eventName, function (event, data) {
                    if (!self.disabled) {
                        config.callback(data);
                    }
                });
            }
        };

        return self;
    });
})();

```

`frontend/app/scripts/services/common/data/StreamStatSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('StreamStatSrv', function($http, StreamSrv, StatSrv) {
            /**
             * @param config {Object} This configuration object has the following attributes
             * <li>rootId</li>
             * <li>query {Object}</li>
             * <li>objectType {String}</li>
             * <li>field {String}</li>
             * <li>result {Object}</li>
             * <li>success {Function}</li>
             * <li>error {Function}</li>
             */
            return function(config) {
                StreamSrv.addListener({
                    rootId: config.rootId,
                    objectType: config.objectType,
                    scope: config.scope,
                    callback:function() {
                        StatSrv.get(config);
                    }
                });

                return StatSrv.get(config);
            };
        });
})();

```

`frontend/app/scripts/services/common/ui/AppLayoutSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('AppLayoutSrv', function($state, $window, $rootScope, localStorageService) {
            var key = 'app-layout';

            this.layout = {};

            this.init = function() {
                this.layout = localStorageService.get(key) || {
                    showFlow: true,
                    caseCustomFieldColumns: 3,
                    alertCustomFieldColumns: 2
                };

                this.saveLayout();
            };

            this.saveLayout = function() {
                localStorageService.set(key, this.layout);
                $rootScope.appLayout = this.layout;
            };

            this.getLayout = function() {
                return this.layout;
            };

            this.showFlow = function(show) {
                this.layout.showFlow = show;
                this.saveLayout();
            };

            this.groupTasks = function(group) {
                this.layout.groupTasks = group;
                this.saveLayout();
            };

            this.caseCustomFields = function(columns) {
                this.layout.caseCustomFieldColumns = columns;
                this.saveLayout();
            };

            this.alertCustomFields = function(columns) {
                this.layout.alertCustomFieldColumns = columns;
                this.saveLayout();
            };

            this.detachFlow = function(/*root*/) {
                this.showFlow(false);
                $window.open($state.href('live'), 'TheHiveLive', 'width=500,height=700,menubar=no,status=no,toolbar=no,location=no,scrollbars=yes');
            };
        });
})();

```

`frontend/app/scripts/services/common/ui/FilteringSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .service('FilteringSrv', function($q, DashboardSrv, QueryBuilderSrv, localStorageService) {
            return function(entity, sectionName, config) {
                var self = this;

                this.entity = entity;
                this.state = undefined;
                this.sectionName = sectionName;
                this.config = config;
                this.defaults = config.defaults || {};
                this.defaultFilter = config.defaultFilter || {};
                this.attributeKeys = [];

                this.initContext = function(state) {
                    self.state = state;
                    return DashboardSrv.getMetadata(this.config.version || 'v0')
                        .then(function(response) {
                            self.metadata = response;
                            self.attributes = angular.copy(response[self.entity].attributes);

                            _.each(self.config.excludes || [], function(exclude) {
                                delete self.attributes[exclude];
                            });

                            self.attributeKeys = _.keys(self.attributes).sort();
                        })
                        .then(function() {
                            var storedContext = localStorageService.get(self.sectionName);
                            if (storedContext && storedContext.state && storedContext.state === state) {
                                self.context = storedContext;
                                return;
                            } else {
                                self.context = {
                                    state: state,
                                    showFilters: self.defaults.showFilters || false,
                                    showStats: self.defaults.showStats || false,
                                    showAdvanced: self.defaults.showAdvanced || true,
                                    pageSize: self.defaults.pageSize || 15,
                                    sort: self.defaults.sort || [],
                                    filters: self.defaultFilter || []
                                };

                                self.storeContext();
                            }
                        });
                };

                this.buildQuery = function() {
                    return QueryBuilderSrv.buildFiltersQuery(this.attributes, this.context.filters);
                };

                this.addFilter = function(filter) {
                    this.context.filters.push(filter || {
                        field: null,
                        type: null
                    });
                };

                this.clearFilters = function() {
                    this.context.filters = [];
                    return $q.resolve();
                };

                this.removeFilter = function(index) {
                    this.context.filters.splice(index, 1);
                    return $q.resolve();
                };

                this.setFilterField = function(filter) {
                    var field = this.attributes[filter.field];

                    if (!field) {
                        return;
                    }

                    filter.type = field.type;

                    if (field.type === 'date') {
                        filter.value = {
                            from: null,
                            to: null
                        };
                    } else {
                        filter.value = null;
                    }
                };

                this.filterFields = function() {
                    return _.filter(this.attributes, function(value, key) {
                        return !key.startsWith('computed.');
                    });
                };

                this.countSorts = function() {
                    return self.context.sort.length;
                };

                this.toggleStats = function() {
                    self.context.showStats = !self.context.showStats;
                    self.storeContext();
                };

                this.toggleFilters = function() {
                    self.context.showFilters = !self.context.showFilters;
                    self.storeContext();
                };

                this.toggleAdvanced = function() {
                    self.context.showAdvanced = !self.context.showAdvanced;
                    self.storeContext();
                };

                this.setPageSize = function(pageSize) {
                    self.context.pageSize = pageSize;
                    self.storeContext();
                };

                this.setSort = function(sorts) {
                    self.context.sort = sorts;
                    self.storeContext();
                };

                this.storeContext = function() {
                    localStorageService.set(self.sectionName, self.context);
                };

                this.resetContext = function() {
                    self.context = {
                        state: self.state,
                        showFilters: self.defaults.showFilters || false,
                        showStats: self.defaults.showStats || false,
                        pageSize: self.defaults.pageSize || 15,
                        sort: self.defaults.sort || [],
                        filters: self.defaultFilter || []
                    };

                    self.storeContext();
                };

                this.addFilterValue = function (field, value) {
                    var filterDef = self.attributes[field];

                    if(!filterDef) {
                        return;
                    }

                    var date,
                        type = filterDef.type,
                        filter = {
                            field: field,
                            type: filterDef.type
                        };

                    switch(type) {
                        case 'date':
                            date = moment(value);
                            filter.value = {
                                from: date.hour(0).minutes(0).seconds(0).toDate(),
                                to: date.hour(23).minutes(59).seconds(59).toDate()
                            };
                            break;
                        case 'tags':
                        case 'string':
                            filter.value = {
                                list: [{
                                    text: value,
                                    label: value
                                }]
                            };
                            break;
                        case 'number':
                        case 'enumeration':
                            if(!_.isArray(value)) {

                            }

                            filter.value = {
                                list: _.map(_.isArray(value) ? value : [value], function(item) {
                                    return {
                                        text: item,
                                        label: filterDef.labels[filterDef.values.indexOf(item)] || item
                                    };
                                })
                            };
                            break;
                        case 'boolean':
                            filter.value = value;
                            break;
                        case 'integer':
                        case 'float':
                            filter.value = {
                                operator: '=',
                                value: value
                            };
                            break;
                        case 'user':
                            break;
                    }

                    var pos = _.findIndex(this.context.filters, function(item) {
                        return item.field === field;
                    });

                    if(pos>-1) {
                        this.context.filters.splice(pos, 1);
                        this.context.filters.push(filter);
                    } else {
                        this.context.filters.push(filter);
                    }

                    return;
                };
            };
        });
})();

```

`frontend/app/scripts/services/common/ui/ModalUtilsSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').service('ModalUtilsSrv', function($uibModal) {

        this.confirm = function(title, message, config) {
            var modal = $uibModal.open({
                templateUrl: 'views/partials/utils/confirm.modal.html',
                controller: ['$uibModalInstance', 'title', 'message', 'config', function($uibModalInstance, title, message, config) {
                    this.title = title;
                    this.message = message;
                    this.config = config;

                    this.cancel = function() {
                        $uibModalInstance.dismiss();
                    };
                    this.confirm = function() {
                        $uibModalInstance.close();
                    };
                }],
                controllerAs: '$modal',
                resolve: {
                    title: function() {
                        return title;
                    },
                    message: function() {
                        return message;
                    },
                    config: function() {
                        return config || {};
                    }
                }
            });

            return modal.result;
        };
    });
})();

```

`frontend/app/scripts/services/common/ui/NotificationSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('NotificationSrv', function($state, HtmlSanitizer, Notification) {

            function log(message, type) {
                Notification[type || 'error'](HtmlSanitizer.sanitize(message));
            }

            return {
                'success': function(message) {
                    log(message, 'success');
                },
                'log': log,
                'error': function(moduleName, data, status) {
                    if (status === 401) {
                        $state.go('login');
                    } else if (status === 520) {
                        $state.go('maintenance');
                    } else if (angular.isString(data) && data !== '') {
                        log(moduleName + ': ' + data, 'error');
                    } else if (angular.isObject(data)) {
                        log(moduleName + ': ' + data.message, 'error');
                    }
                }
            };
        });
})();

```

`frontend/app/scripts/services/common/ui/modal/ModalSrv.js`:

```js
(function() {
    'use strict';

    function ModalConfirmCtrl($scope, $uibModalInstance, title, message, config) {
        this.title = title;
        this.message = message;
        this.config = config;

        this.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };
        this.confirm = function() {
            $uibModalInstance.close('ok');
        };
        this.dismiss = function(value) {
            $uibModalInstance.dismiss(value);
        };
    }

    angular.module('theHiveServices')
        .service('ModalSrv', function($uibModal) {

            this.confirm = function(title, message, config) {
                return $uibModal.open({
                    keyboard: false,
                    backdrop: 'static',
                    controller: ModalConfirmCtrl,
                    templateUrl: 'views/components/common/modal/modal.confirm.html',
                    controllerAs: '$modal',
                    resolve: {
                        title: function() {
                            return title;
                        },
                        message: function() {
                            return message;
                        },
                        config: function() {
                            return config || {};
                        }
                    }
                });
            };

        });
})();

```

`frontend/app/scripts/services/ui/AfkSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('AfkSrv', function($rootScope, $q, $uibModal, $http) {
            var current = null;

            return {
                /**
                 * Ask the user if he's away from keybord
                 *
                 * @return {Promise}
                 */
                prompt: function() {
                    var defer = $q.defer();

                    $http.get('./api/stream/status').then(function(response) {

                        if(response.data.warning === true) {
                            if(current !== null) {
                                defer.reject();
                            } else {
                                var scope = $rootScope.$new(true);

                                scope.ok = function() {
                                    defer.resolve();
                                    current.close();
                                    current = null;
                                };

                                current = $uibModal.open({
                                    scope: scope,
                                    templateUrl: 'views/partials/afk-modal.html',
                                    size: ''
                                });
                            }
                        } else if(current !== null) {
                            defer.reject();
                            current.close();
                            current = null;
                        }

                    });

                    return defer.promise;
                }
            };
        });
})();

```

`frontend/app/scripts/services/ui/CaseTabsSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').service('CaseTabsSrv', function() {

        var tabs = {
            'details': {
                name: 'details',
                active: true,
                label: 'Details',
                state: 'app.case.details'
            },
            'tasks': {
                name: 'tasks',
                active: false,
                label: 'Tasks',
                state: 'app.case.tasks'
            },
            'observables': {
                name: 'observables',
                active: false,
                label: 'Observables',
                state: 'app.case.observables'
            },
            'procedures': {
                name: 'procedures',
                active: false,
                label: 'TTPs',
                state: 'app.case.procedures'
            }
        };

        this.activeIndex = 0;

        this.initTabs = function() {
            angular.forEach(tabs, function(tab, key) {
                if (tab.closable === true) {
                    delete tabs[key];
                }
            });
        };

        this.getTabs = function() {
            return tabs;
        };

        this.getTab = function(name) {
            return tabs[name];
        };

        this.activateTab = function(tab) {
            angular.forEach(tabs, function(tab) {
                tab.active = false;
            });

            if (tabs[tab]) {
                tabs[tab].active = true;
                this.activeIndex = Object.keys(tabs).indexOf(tab);
            } else {
                tabs.details.active = true;
                this.activeIndex = 0;
            }
        };

        this.addTab = function(tab, options) {
            options.closable = true;

            tabs[tab] = options;
            this.activeIndex = Object.keys(tabs).length - 1;
        };

        this.removeTab = function(tab) {
            var tabItem = tabs[tab];

            if (!tabItem) {
                return;
            }

            var currentIsActive = tabItem.active;

            delete tabs[tab];

            if (currentIsActive) {
                return true;
            } else {
                return false;
            }

        };

    });
})();

```

`frontend/app/scripts/services/ui/ChartSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices')
        .factory('ChartSrv', function() {

            return {
                timeIntervals: [{
                    code: '1d',
                    label: 'By day'
                }, {
                    code: '1w',
                    label: 'By week'
                }, {
                    code: '1M',
                    label: 'By month'
                }, {
                    code: '1y',
                    label: 'By year'
                }],

                aggregations: [{
                    id: 'sum',
                    label: 'sum'
                }, {
                    id: 'min',
                    label: 'min'
                }, {
                    id: 'max',
                    label: 'max'
                }, {
                    id: 'avg',
                    label: 'avg'
                }]
            };
        });
})();

```

`frontend/app/scripts/services/ui/GlobalSearchSrv.js`:

```js
(function() {
    'use strict';
    angular.module('theHiveServices').service('GlobalSearchSrv', function(localStorageService) {
        this.save = function(config) {
            localStorageService.set('search-section', config);
        };

        this.saveSection = function(entity, config) {
            var cfg = this.restore();

            cfg.entity = entity;
            cfg[entity] = _.extend(cfg[entity], config);

            this.save(cfg);
        };

        this.getSection = function(entity) {
            var cfg = this.restore();

            return cfg[entity] || {};
        };

        this.restore = function() {
            return localStorageService.get('search-section') || {
                entity: 'case',
                case: {
                    search: null,
                    filters: []
                },
                case_task: {
                    search: null,
                    filters: []
                },
                case_task_log: {
                    search: null,
                    filters: []
                },
                case_artifact: {
                    search: null,
                    filters: []
                },
                alert: {
                    search: null,
                    filters: []
                },
                case_artifact_job: {
                    search: null,
                    filters: []
                },
                audit: {
                    search: null,
                    filters: []
                }
            };
        };

        this.buildDefaultFilterValue = function(fieldDef, value) {

            var valueId = value.id;
            var valueName = value.name;

            if(valueId.startsWith('"') && valueId.endsWith('"')) {
                valueId = valueId.slice (1, valueId.length-1);
            }
            if(valueName.startsWith('"') && valueName.endsWith('"')) {
                valueName = valueName.slice (1, valueName.length-1);
            }

            if(fieldDef.type === 'string' || fieldDef.name === 'tags' || fieldDef.type === 'user' || fieldDef.values.length > 0) {
                return {
                    operator: 'any',
                    list: [{
                        text: (fieldDef.type === 'number' || fieldDef.type === 'integer') ? Number.parseInt(valueId) : valueId, label:valueName
                    }]
                };
            } else {
                switch(fieldDef.type) {
                    case 'number':
                    case 'integer':
                        return {
                            value: Number.parseInt(valueId)
                        };
                    case 'boolean':
                        return valueId === 'true';
                    default:
                      return valueId;
                }
                return valueId;
            }

        };
    });
})();

```

`frontend/app/scripts/thirdparty/theme.js`:

```js
// jshint ignore: start
/*! AdminLTE app.js
 * ================
 * Main JS application file for AdminLTE v2. This file
 * should be included in all pages. It controls some layout
 * options and implements exclusive AdminLTE plugins.
 *
 * @Author  Almsaeed Studio
 * @Support <http://www.almsaeedstudio.com>
 * @Email   <support@almsaeedstudio.com>
 * @version 2.3.3
 * @license MIT <http://opensource.org/licenses/MIT>
 */

//Make sure jQuery has been loaded before app.js
if (typeof jQuery === "undefined") {
  throw new Error("AdminLTE requires jQuery");
}

/* AdminLTE
 *
 * @type Object
 * @description $.AdminLTE is the main object for the template's app.
 *              It's used for implementing functions and options related
 *              to the template. Keeping everything wrapped in an object
 *              prevents conflict with other plugins and is a better
 *              way to organize our code.
 */
$.AdminLTE = {};

/* --------------------
 * - AdminLTE Options -
 * --------------------
 * Modify these options to suit your implementation
 */
$.AdminLTE.options = {
  //Add slimscroll to navbar menus
  //This requires you to load the slimscroll plugin
  //in every page before app.js
  navbarMenuSlimscroll: true,
  navbarMenuSlimscrollWidth: "3px", //The width of the scroll bar
  navbarMenuHeight: "200px", //The height of the inner menu
  //General animation speed for JS animated elements such as box collapse/expand and
  //sidebar treeview slide up/down. This options accepts an integer as milliseconds,
  //'fast', 'normal', or 'slow'
  animationSpeed: 500,
  //Sidebar push menu toggle button selector
  sidebarToggleSelector: "[data-toggle='offcanvas']",
  //Activate sidebar push menu
  sidebarPushMenu: true,
  //Activate sidebar slimscroll if the fixed layout is set (requires SlimScroll Plugin)
  sidebarSlimScroll: true,
  //Enable sidebar expand on hover effect for sidebar mini
  //This option is forced to true if both the fixed layout and sidebar mini
  //are used together
  sidebarExpandOnHover: false,
  //BoxRefresh Plugin
  enableBoxRefresh: true,
  //Bootstrap.js tooltip
  enableBSToppltip: true,
  BSTooltipSelector: "[data-toggle='tooltip']",
  //Enable Fast Click. Fastclick.js creates a more
  //native touch experience with touch devices. If you
  //choose to enable the plugin, make sure you load the script
  //before AdminLTE's app.js
  enableFastclick: true,
  //Control Sidebar Options
  enableControlSidebar: true,
  controlSidebarOptions: {
    //Which button should trigger the open/close event
    toggleBtnSelector: "[data-toggle='control-sidebar']",
    //The sidebar selector
    selector: ".control-sidebar",
    //Enable slide over content
    slide: true
  },
  //Box Widget Plugin. Enable this plugin
  //to allow boxes to be collapsed and/or removed
  enableBoxWidget: true,
  //Box Widget plugin options
  boxWidgetOptions: {
    boxWidgetIcons: {
      //Collapse icon
      collapse: 'fa-minus',
      //Open icon
      open: 'fa-plus',
      //Remove icon
      remove: 'fa-times'
    },
    boxWidgetSelectors: {
      //Remove button selector
      remove: '[data-widget="remove"]',
      //Collapse button selector
      collapse: '[data-widget="collapse"]'
    }
  },
  //Direct Chat plugin options
  directChat: {
    //Enable direct chat by default
    enable: true,
    //The button to open and close the chat contacts pane
    contactToggleSelector: '[data-widget="chat-pane-toggle"]'
  },
  //Define the set of colors to use globally around the website
  colors: {
    lightBlue: "#3c8dbc",
    red: "#f56954",
    green: "#00a65a",
    aqua: "#00c0ef",
    yellow: "#f39c12",
    blue: "#0073b7",
    navy: "#001F3F",
    teal: "#39CCCC",
    olive: "#3D9970",
    lime: "#01FF70",
    orange: "#FF851B",
    fuchsia: "#F012BE",
    purple: "#8E24AA",
    maroon: "#D81B60",
    black: "#222222",
    gray: "#d2d6de"
  },
  //The standard screen sizes that bootstrap uses.
  //If you change these in the variables.less file, change
  //them here too.
  screenSizes: {
    xs: 480,
    sm: 768,
    md: 992,
    lg: 1200
  }
};

/* ------------------
 * - Implementation -
 * ------------------
 * The next block of code implements AdminLTE's
 * functions and plugins as specified by the
 * options above.
 */
$(function () {
  "use strict";

  //Fix for IE page transitions
  $("body").removeClass("hold-transition");

  //Extend options if external options exist
  if (typeof AdminLTEOptions !== "undefined") {
    $.extend(true,
        $.AdminLTE.options,
        AdminLTEOptions);
  }

  //Easy access to options
  var o = $.AdminLTE.options;

  //Set up the object
  _init();

  //Activate the layout maker
  $.AdminLTE.layout.activate();

  //Enable sidebar tree view controls
  $.AdminLTE.tree('.sidebar');

  //Enable control sidebar
  if (o.enableControlSidebar) {
    $.AdminLTE.controlSidebar.activate();
  }

  //Add slimscroll to navbar dropdown
  if (o.navbarMenuSlimscroll && typeof $.fn.slimscroll != 'undefined') {
    $(".navbar .menu").slimscroll({
      height: o.navbarMenuHeight,
      alwaysVisible: false,
      size: o.navbarMenuSlimscrollWidth
    }).css("width", "100%");
  }

  //Activate sidebar push menu
  if (o.sidebarPushMenu) {
    $.AdminLTE.pushMenu.activate(o.sidebarToggleSelector);
  }

  //Activate Bootstrap tooltip
  if (o.enableBSToppltip) {
    $('body').tooltip({
      selector: o.BSTooltipSelector
    });
  }

  //Activate box widget
  if (o.enableBoxWidget) {
    $.AdminLTE.boxWidget.activate();
  }

  //Activate fast click
  if (o.enableFastclick && typeof FastClick != 'undefined') {
    FastClick.attach(document.body);
  }

  //Activate direct chat widget
  if (o.directChat.enable) {
    $(document).on('click', o.directChat.contactToggleSelector, function () {
      var box = $(this).parents('.direct-chat').first();
      box.toggleClass('direct-chat-contacts-open');
    });
  }

  /*
   * INITIALIZE BUTTON TOGGLE
   * ------------------------
   */
  $('.btn-group[data-toggle="btn-toggle"]').each(function () {
    var group = $(this);
    $(this).find(".btn").on('click', function (e) {
      group.find(".btn.active").removeClass("active");
      $(this).addClass("active");
      e.preventDefault();
    });

  });
});

/* ----------------------------------
 * - Initialize the AdminLTE Object -
 * ----------------------------------
 * All AdminLTE functions are implemented below.
 */
function _init() {
  'use strict';
  /* Layout
   * ======
   * Fixes the layout height in case min-height fails.
   *
   * @type Object
   * @usage $.AdminLTE.layout.activate()
   *        $.AdminLTE.layout.fix()
   *        $.AdminLTE.layout.fixSidebar()
   */
  $.AdminLTE.layout = {
    activate: function () {
      var _this = this;
      _this.fix();
      _this.fixSidebar();
      $(window, ".wrapper").resize(function () {
        _this.fix();
        _this.fixSidebar();
      });
    },
    fix: function () {
      //Get window height and the wrapper height
      var neg = $('.main-header').outerHeight() + $('.main-footer').outerHeight();
      var window_height = $(window).height();
      var sidebar_height = $(".sidebar").height();
      //Set the min-height of the content and sidebar based on the
      //the height of the document.
      if ($("body").hasClass("fixed")) {
        $(".content-wrapper, .right-side").css('min-height', window_height - $('.main-footer').outerHeight());
      } else {
        var postSetWidth;
        if (window_height >= sidebar_height) {
          $(".content-wrapper, .right-side").css('min-height', window_height - neg);
          postSetWidth = window_height - neg;
        } else {
          $(".content-wrapper, .right-side").css('min-height', sidebar_height);
          postSetWidth = sidebar_height;
        }

        //Fix for the control sidebar height
        var controlSidebar = $($.AdminLTE.options.controlSidebarOptions.selector);
        if (typeof controlSidebar !== "undefined") {
          if (controlSidebar.height() > postSetWidth)
            $(".content-wrapper, .right-side").css('min-height', controlSidebar.height());
        }

      }
    },
    fixSidebar: function () {
      //Make sure the body tag has the .fixed class
      if (!$("body").hasClass("fixed")) {
        if (typeof $.fn.slimScroll != 'undefined') {
          $(".sidebar").slimScroll({destroy: true}).height("auto");
        }
        return;
      } else if (typeof $.fn.slimScroll == 'undefined' && window.console) {
        window.console.error("Error: the fixed layout requires the slimscroll plugin!");
      }
      //Enable slimscroll for fixed layout
      if ($.AdminLTE.options.sidebarSlimScroll) {
        if (typeof $.fn.slimScroll != 'undefined') {
          //Destroy if it exists
          $(".sidebar").slimScroll({destroy: true}).height("auto");
          //Add slimscroll
          $(".sidebar").slimscroll({
            height: ($(window).height() - $(".main-header").height()) + "px",
            color: "rgba(0,0,0,0.2)",
            size: "3px"
          });
        }
      }
    }
  };

  /* PushMenu()
   * ==========
   * Adds the push menu functionality to the sidebar.
   *
   * @type Function
   * @usage: $.AdminLTE.pushMenu("[data-toggle='offcanvas']")
   */
  $.AdminLTE.pushMenu = {
    activate: function (toggleBtn) {
      //Get the screen sizes
      var screenSizes = $.AdminLTE.options.screenSizes;

      //Enable sidebar toggle
      $(document).on('click', toggleBtn, function (e) {
        e.preventDefault();

        //Enable sidebar push menu
        if ($(window).width() > (screenSizes.sm - 1)) {
          if ($("body").hasClass('sidebar-collapse')) {
            $("body").removeClass('sidebar-collapse').trigger('expanded.pushMenu');
          } else {
            $("body").addClass('sidebar-collapse').trigger('collapsed.pushMenu');
          }
        }
        //Handle sidebar push menu for small screens
        else {
          if ($("body").hasClass('sidebar-open')) {
            $("body").removeClass('sidebar-open').removeClass('sidebar-collapse').trigger('collapsed.pushMenu');
          } else {
            $("body").addClass('sidebar-open').trigger('expanded.pushMenu');
          }
        }
      });

      $(".content-wrapper").click(function () {
        //Enable hide menu when clicking on the content-wrapper on small screens
        if ($(window).width() <= (screenSizes.sm - 1) && $("body").hasClass("sidebar-open")) {
          $("body").removeClass('sidebar-open');
        }
      });

      //Enable expand on hover for sidebar mini
      if ($.AdminLTE.options.sidebarExpandOnHover
          || ($('body').hasClass('fixed')
          && $('body').hasClass('sidebar-mini'))) {
        this.expandOnHover();
      }
    },
    expandOnHover: function () {
      var _this = this;
      var screenWidth = $.AdminLTE.options.screenSizes.sm - 1;
      //Expand sidebar on hover
      $('.main-sidebar').hover(function () {
        if ($('body').hasClass('sidebar-mini')
            && $("body").hasClass('sidebar-collapse')
            && $(window).width() > screenWidth) {
          _this.expand();
        }
      }, function () {
        if ($('body').hasClass('sidebar-mini')
            && $('body').hasClass('sidebar-expanded-on-hover')
            && $(window).width() > screenWidth) {
          _this.collapse();
        }
      });
    },
    expand: function () {
      $("body").removeClass('sidebar-collapse').addClass('sidebar-expanded-on-hover');
    },
    collapse: function () {
      if ($('body').hasClass('sidebar-expanded-on-hover')) {
        $('body').removeClass('sidebar-expanded-on-hover').addClass('sidebar-collapse');
      }
    }
  };

  /* Tree()
   * ======
   * Converts the sidebar into a multilevel
   * tree view menu.
   *
   * @type Function
   * @Usage: $.AdminLTE.tree('.sidebar')
   */
  $.AdminLTE.tree = function (menu) {
    var _this = this;
    var animationSpeed = $.AdminLTE.options.animationSpeed;
    $(document).on('click', menu + ' li a', function (e) {
      //Get the clicked link and the next element
      var $this = $(this);
      var checkElement = $this.next();

      //Check if the next element is a menu and is visible
      if ((checkElement.is('.treeview-menu')) && (checkElement.is(':visible')) && (!$('body').hasClass('sidebar-collapse'))) {
        //Close the menu
        checkElement.slideUp(animationSpeed, function () {
          checkElement.removeClass('menu-open');
          //Fix the layout in case the sidebar stretches over the height of the window
          //_this.layout.fix();
        });
        checkElement.parent("li").removeClass("active");
      }
      //If the menu is not visible
      else if ((checkElement.is('.treeview-menu')) && (!checkElement.is(':visible'))) {
        //Get the parent menu
        var parent = $this.parents('ul').first();
        //Close all open menus within the parent
        var ul = parent.find('ul:visible').slideUp(animationSpeed);
        //Remove the menu-open class from the parent
        ul.removeClass('menu-open');
        //Get the parent li
        var parent_li = $this.parent("li");

        //Open the target menu and add the menu-open class
        checkElement.slideDown(animationSpeed, function () {
          //Add the class active to the parent li
          checkElement.addClass('menu-open');
          parent.find('li.active').removeClass('active');
          parent_li.addClass('active');
          //Fix the layout in case the sidebar stretches over the height of the window
          _this.layout.fix();
        });
      }
      //if this isn't a link, prevent the page from being redirected
      if (checkElement.is('.treeview-menu')) {
        e.preventDefault();
      }
    });
  };

  /* ControlSidebar
   * ==============
   * Adds functionality to the right sidebar
   *
   * @type Object
   * @usage $.AdminLTE.controlSidebar.activate(options)
   */
  $.AdminLTE.controlSidebar = {
    //instantiate the object
    activate: function () {
      //Get the object
      var _this = this;
      //Update options
      var o = $.AdminLTE.options.controlSidebarOptions;
      //Get the sidebar
      var sidebar = $(o.selector);
      //The toggle button
      var btn = $(o.toggleBtnSelector);

      //Listen to the click event
      btn.on('click', function (e) {
        e.preventDefault();
        //If the sidebar is not open
        if (!sidebar.hasClass('control-sidebar-open')
            && !$('body').hasClass('control-sidebar-open')) {
          //Open the sidebar
          _this.open(sidebar, o.slide);
        } else {
          _this.close(sidebar, o.slide);
        }
      });

      //If the body has a boxed layout, fix the sidebar bg position
      var bg = $(".control-sidebar-bg");
      _this._fix(bg);

      //If the body has a fixed layout, make the control sidebar fixed
      if ($('body').hasClass('fixed')) {
        _this._fixForFixed(sidebar);
      } else {
        //If the content height is less than the sidebar's height, force max height
        if ($('.content-wrapper, .right-side').height() < sidebar.height()) {
          _this._fixForContent(sidebar);
        }
      }
    },
    //Open the control sidebar
    open: function (sidebar, slide) {
      //Slide over content
      if (slide) {
        sidebar.addClass('control-sidebar-open');
      } else {
        //Push the content by adding the open class to the body instead
        //of the sidebar itself
        $('body').addClass('control-sidebar-open');
      }
    },
    //Close the control sidebar
    close: function (sidebar, slide) {
      if (slide) {
        sidebar.removeClass('control-sidebar-open');
      } else {
        $('body').removeClass('control-sidebar-open');
      }
    },
    _fix: function (sidebar) {
      var _this = this;
      if ($("body").hasClass('layout-boxed')) {
        sidebar.css('position', 'absolute');
        sidebar.height($(".wrapper").height());
        $(window).resize(function () {
          _this._fix(sidebar);
        });
      } else {
        sidebar.css({
          'position': 'fixed',
          'height': 'auto'
        });
      }
    },
    _fixForFixed: function (sidebar) {
      sidebar.css({
        'position': 'fixed',
        'max-height': '100%',
        'overflow': 'auto',
        'padding-bottom': '50px'
      });
    },
    _fixForContent: function (sidebar) {
      $(".content-wrapper, .right-side").css('min-height', sidebar.height());
    }
  };

  /* BoxWidget
   * =========
   * BoxWidget is a plugin to handle collapsing and
   * removing boxes from the screen.
   *
   * @type Object
   * @usage $.AdminLTE.boxWidget.activate()
   *        Set all your options in the main $.AdminLTE.options object
   */
  $.AdminLTE.boxWidget = {
    selectors: $.AdminLTE.options.boxWidgetOptions.boxWidgetSelectors,
    icons: $.AdminLTE.options.boxWidgetOptions.boxWidgetIcons,
    animationSpeed: $.AdminLTE.options.animationSpeed,
    activate: function (_box) {
      var _this = this;
      if (!_box) {
        _box = document; // activate all boxes per default
      }
      //Listen for collapse event triggers
      $(_box).on('click', _this.selectors.collapse, function (e) {
        e.preventDefault();
        _this.collapse($(this));
      });

      //Listen for remove event triggers
      $(_box).on('click', _this.selectors.remove, function (e) {
        e.preventDefault();
        _this.remove($(this));
      });
    },
    collapse: function (element) {
      var _this = this;
      //Find the box parent
      var box = element.parents(".box").first();
      //Find the body and the footer
      var box_content = box.find("> .box-body, > .box-footer, > form  >.box-body, > form > .box-footer");
      if (!box.hasClass("collapsed-box")) {
        //Convert minus into plus
        element.children(":first")
            .removeClass(_this.icons.collapse)
            .addClass(_this.icons.open);
        //Hide the content
        box_content.slideUp(_this.animationSpeed, function () {
          box.addClass("collapsed-box");
        });
      } else {
        //Convert plus into minus
        element.children(":first")
            .removeClass(_this.icons.open)
            .addClass(_this.icons.collapse);
        //Show the content
        box_content.slideDown(_this.animationSpeed, function () {
          box.removeClass("collapsed-box");
        });
      }
    },
    remove: function (element) {
      //Find the box parent
      var box = element.parents(".box").first();
      box.slideUp(this.animationSpeed);
    }
  };
}

/* ------------------
 * - Custom Plugins -
 * ------------------
 * All custom plugins are defined below.
 */

/*
 * BOX REFRESH BUTTON
 * ------------------
 * This is a custom plugin to use with the component BOX. It allows you to add
 * a refresh button to the box. It converts the box's state to a loading state.
 *
 * @type plugin
 * @usage $("#box-widget").boxRefresh( options );
 */
(function ($) {

  "use strict";

  $.fn.boxRefresh = function (options) {

    // Render options
    var settings = $.extend({
      //Refresh button selector
      trigger: ".refresh-btn",
      //File source to be loaded (e.g: ajax/src.php)
      source: "",
      //Callbacks
      onLoadStart: function (box) {
        return box;
      }, //Right after the button has been clicked
      onLoadDone: function (box) {
        return box;
      } //When the source has been loaded

    }, options);

    //The overlay
    var overlay = $('<div class="overlay"><div class="fa fa-refresh fa-spin"></div></div>');

    return this.each(function () {
      //if a source is specified
      if (settings.source === "") {
        if (window.console) {
          window.console.log("Please specify a source first - boxRefresh()");
        }
        return;
      }
      //the box
      var box = $(this);
      //the button
      var rBtn = box.find(settings.trigger).first();

      //On trigger click
      rBtn.on('click', function (e) {
        e.preventDefault();
        //Add loading overlay
        start(box);

        //Perform ajax call
        box.find(".box-body").load(settings.source, function () {
          done(box);
        });
      });
    });

    function start(box) {
      //Add overlay and loading img
      box.append(overlay);

      settings.onLoadStart.call(box);
    }

    function done(box) {
      //Remove overlay and loading img
      box.find(overlay).remove();

      settings.onLoadDone.call(box);
    }

  };

})(jQuery);

 /*
 * EXPLICIT BOX CONTROLS
 * -----------------------
 * This is a custom plugin to use with the component BOX. It allows you to activate
 * a box inserted in the DOM after the app.js was loaded, toggle and remove box.
 *
 * @type plugin
 * @usage $("#box-widget").activateBox();
 * @usage $("#box-widget").toggleBox();
 * @usage $("#box-widget").removeBox();
 */
(function ($) {

  'use strict';

  $.fn.activateBox = function () {
    $.AdminLTE.boxWidget.activate(this);
  };

  $.fn.toggleBox = function(){
    var button = $($.AdminLTE.boxWidget.selectors.collapse, this);
    $.AdminLTE.boxWidget.collapse(button);
  };

  $.fn.removeBox = function(){
    var button = $($.AdminLTE.boxWidget.selectors.remove, this);
    $.AdminLTE.boxWidget.remove(button);
  };

})(jQuery);

/*
 * TODO LIST CUSTOM PLUGIN
 * -----------------------
 * This plugin depends on iCheck plugin for checkbox and radio inputs
 *
 * @type plugin
 * @usage $("#todo-widget").todolist( options );
 */
(function ($) {

  'use strict';

  $.fn.todolist = function (options) {
    // Render options
    var settings = $.extend({
      //When the user checks the input
      onCheck: function (ele) {
        return ele;
      },
      //When the user unchecks the input
      onUncheck: function (ele) {
        return ele;
      }
    }, options);

    return this.each(function () {

      if (typeof $.fn.iCheck != 'undefined') {
        $('input', this).on('ifChecked', function () {
          var ele = $(this).parents("li").first();
          ele.toggleClass("done");
          settings.onCheck.call(ele);
        });

        $('input', this).on('ifUnchecked', function () {
          var ele = $(this).parents("li").first();
          ele.toggleClass("done");
          settings.onUncheck.call(ele);
        });
      } else {
        $('input', this).on('change', function () {
          var ele = $(this).parents("li").first();
          ele.toggleClass("done");
          if ($('input', ele).is(":checked")) {
            settings.onCheck.call(ele);
          } else {
            settings.onUncheck.call(ele);
          }
        });
      }
    });
  };
}(jQuery));

```

`frontend/app/scripts/utils/highlight.min.js`:

```js
// jshint ignore: start
!function(e){"undefined"!=typeof exports?e(exports):(window.hljs=e({}),"function"==typeof define&&define.amd&&define("hljs",[],function(){return window.hljs}))}(function(e){function t(e){return e.replace(/&/gm,"&amp;").replace(/</gm,"&lt;").replace(/>/gm,"&gt;")}function r(e){return e.nodeName.toLowerCase()}function a(e,t){var r=e&&e.exec(t);return r&&0==r.index}function n(e){return/^(no-?highlight|plain|text)$/i.test(e)}function i(e){var t,r,a,i=e.className+" ";if(i+=e.parentNode?e.parentNode.className:"",r=/\blang(?:uage)?-([\w-]+)\b/i.exec(i))return y(r[1])?r[1]:"no-highlight";for(i=i.split(/\s+/),t=0,a=i.length;a>t;t++)if(y(i[t])||n(i[t]))return i[t]}function s(e,t){var r,a={};for(r in e)a[r]=e[r];if(t)for(r in t)a[r]=t[r];return a}function c(e){var t=[];return function a(e,n){for(var i=e.firstChild;i;i=i.nextSibling)3==i.nodeType?n+=i.nodeValue.length:1==i.nodeType&&(t.push({event:"start",offset:n,node:i}),n=a(i,n),r(i).match(/br|hr|img|input/)||t.push({event:"stop",offset:n,node:i}));return n}(e,0),t}function o(e,a,n){function i(){return e.length&&a.length?e[0].offset!=a[0].offset?e[0].offset<a[0].offset?e:a:"start"==a[0].event?e:a:e.length?e:a}function s(e){function a(e){return" "+e.nodeName+'="'+t(e.value)+'"'}u+="<"+r(e)+Array.prototype.map.call(e.attributes,a).join("")+">"}function c(e){u+="</"+r(e)+">"}function o(e){("start"==e.event?s:c)(e.node)}for(var l=0,u="",d=[];e.length||a.length;){var b=i();if(u+=t(n.substr(l,b[0].offset-l)),l=b[0].offset,b==e){d.reverse().forEach(c);do o(b.splice(0,1)[0]),b=i();while(b==e&&b.length&&b[0].offset==l);d.reverse().forEach(s)}else"start"==b[0].event?d.push(b[0].node):d.pop(),o(b.splice(0,1)[0])}return u+t(n.substr(l))}function l(e){function t(e){return e&&e.source||e}function r(r,a){return new RegExp(t(r),"m"+(e.cI?"i":"")+(a?"g":""))}function a(n,i){if(!n.compiled){if(n.compiled=!0,n.k=n.k||n.bK,n.k){var c={},o=function(t,r){e.cI&&(r=r.toLowerCase()),r.split(" ").forEach(function(e){var r=e.split("|");c[r[0]]=[t,r[1]?Number(r[1]):1]})};"string"==typeof n.k?o("keyword",n.k):Object.keys(n.k).forEach(function(e){o(e,n.k[e])}),n.k=c}n.lR=r(n.l||/\b\w+\b/,!0),i&&(n.bK&&(n.b="\\b("+n.bK.split(" ").join("|")+")\\b"),n.b||(n.b=/\B|\b/),n.bR=r(n.b),n.e||n.eW||(n.e=/\B|\b/),n.e&&(n.eR=r(n.e)),n.tE=t(n.e)||"",n.eW&&i.tE&&(n.tE+=(n.e?"|":"")+i.tE)),n.i&&(n.iR=r(n.i)),void 0===n.r&&(n.r=1),n.c||(n.c=[]);var l=[];n.c.forEach(function(e){e.v?e.v.forEach(function(t){l.push(s(e,t))}):l.push("self"==e?n:e)}),n.c=l,n.c.forEach(function(e){a(e,n)}),n.starts&&a(n.starts,i);var u=n.c.map(function(e){return e.bK?"\\.?("+e.b+")\\.?":e.b}).concat([n.tE,n.i]).map(t).filter(Boolean);n.t=u.length?r(u.join("|"),!0):{exec:function(){return null}}}}a(e)}function u(e,r,n,i){function s(e,t){for(var r=0;r<t.c.length;r++)if(a(t.c[r].bR,e))return t.c[r]}function c(e,t){if(a(e.eR,t)){for(;e.endsParent&&e.parent;)e=e.parent;return e}return e.eW?c(e.parent,t):void 0}function o(e,t){return!n&&a(t.iR,e)}function b(e,t){var r=v.cI?t[0].toLowerCase():t[0];return e.k.hasOwnProperty(r)&&e.k[r]}function p(e,t,r,a){var n=a?"":w.classPrefix,i='<span class="'+n,s=r?"":"</span>";return i+=e+'">',i+t+s}function m(){if(!x.k)return t(E);var e="",r=0;x.lR.lastIndex=0;for(var a=x.lR.exec(E);a;){e+=t(E.substr(r,a.index-r));var n=b(x,a);n?(B+=n[1],e+=p(n[0],t(a[0]))):e+=t(a[0]),r=x.lR.lastIndex,a=x.lR.exec(E)}return e+t(E.substr(r))}function f(){var e="string"==typeof x.sL;if(e&&!N[x.sL])return t(E);var r=e?u(x.sL,E,!0,C[x.sL]):d(E,x.sL.length?x.sL:void 0);return x.r>0&&(B+=r.r),e&&(C[x.sL]=r.top),p(r.language,r.value,!1,!0)}function g(){return void 0!==x.sL?f():m()}function h(e,r){var a=e.cN?p(e.cN,"",!0):"";e.rB?(M+=a,E=""):e.eB?(M+=t(r)+a,E=""):(M+=a,E=r),x=Object.create(e,{parent:{value:x}})}function _(e,r){if(E+=e,void 0===r)return M+=g(),0;var a=s(r,x);if(a)return M+=g(),h(a,r),a.rB?0:r.length;var n=c(x,r);if(n){var i=x;i.rE||i.eE||(E+=r),M+=g();do x.cN&&(M+="</span>"),B+=x.r,x=x.parent;while(x!=n.parent);return i.eE&&(M+=t(r)),E="",n.starts&&h(n.starts,""),i.rE?0:r.length}if(o(r,x))throw new Error('Illegal lexeme "'+r+'" for mode "'+(x.cN||"<unnamed>")+'"');return E+=r,r.length||1}var v=y(e);if(!v)throw new Error('Unknown language: "'+e+'"');l(v);var k,x=i||v,C={},M="";for(k=x;k!=v;k=k.parent)k.cN&&(M=p(k.cN,"",!0)+M);var E="",B=0;try{for(var $,z,L=0;;){if(x.t.lastIndex=L,$=x.t.exec(r),!$)break;z=_(r.substr(L,$.index-L),$[0]),L=$.index+z}for(_(r.substr(L)),k=x;k.parent;k=k.parent)k.cN&&(M+="</span>");return{r:B,value:M,language:e,top:x}}catch(q){if(-1!=q.message.indexOf("Illegal"))return{r:0,value:t(r)};throw q}}function d(e,r){r=r||w.languages||Object.keys(N);var a={r:0,value:t(e)},n=a;return r.forEach(function(t){if(y(t)){var r=u(t,e,!1);r.language=t,r.r>n.r&&(n=r),r.r>a.r&&(n=a,a=r)}}),n.language&&(a.second_best=n),a}function b(e){return w.tabReplace&&(e=e.replace(/^((<[^>]+>|\t)+)/gm,function(e,t){return t.replace(/\t/g,w.tabReplace)})),w.useBR&&(e=e.replace(/\n/g,"<br>")),e}function p(e,t,r){var a=t?k[t]:r,n=[e.trim()];return e.match(/\bhljs\b/)||n.push("hljs"),-1===e.indexOf(a)&&n.push(a),n.join(" ").trim()}function m(e){var t=i(e);if(!n(t)){var r;w.useBR?(r=document.createElementNS("http://www.w3.org/1999/xhtml","div"),r.innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ \/]*>/g,"\n")):r=e;var a=r.textContent,s=t?u(t,a,!0):d(a),l=c(r);if(l.length){var m=document.createElementNS("http://www.w3.org/1999/xhtml","div");m.innerHTML=s.value,s.value=o(l,c(m),a)}s.value=b(s.value),e.innerHTML=s.value,e.className=p(e.className,t,s.language),e.result={language:s.language,re:s.r},s.second_best&&(e.second_best={language:s.second_best.language,re:s.second_best.r})}}function f(e){w=s(w,e)}function g(){if(!g.called){g.called=!0;var e=document.querySelectorAll("pre code");Array.prototype.forEach.call(e,m)}}function h(){addEventListener("DOMContentLoaded",g,!1),addEventListener("load",g,!1)}function _(t,r){var a=N[t]=r(e);a.aliases&&a.aliases.forEach(function(e){k[e]=t})}function v(){return Object.keys(N)}function y(e){return e=(e||"").toLowerCase(),N[e]||N[k[e]]}var w={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0},N={},k={};return e.highlight=u,e.highlightAuto=d,e.fixMarkup=b,e.highlightBlock=m,e.configure=f,e.initHighlighting=g,e.initHighlightingOnLoad=h,e.registerLanguage=_,e.listLanguages=v,e.getLanguage=y,e.inherit=s,e.IR="[a-zA-Z]\\w*",e.UIR="[a-zA-Z_]\\w*",e.NR="\\b\\d+(\\.\\d+)?",e.CNR="(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",e.BNR="\\b(0b[01]+)",e.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",e.BE={b:"\\\\[\\s\\S]",r:0},e.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[e.BE]},e.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[e.BE]},e.PWM={b:/\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\b/},e.C=function(t,r,a){var n=e.inherit({cN:"comment",b:t,e:r,c:[]},a||{});return n.c.push(e.PWM),n.c.push({cN:"doctag",b:"(?:TODO|FIXME|NOTE|BUG|XXX):",r:0}),n},e.CLCM=e.C("//","$"),e.CBCM=e.C("/\\*","\\*/"),e.HCM=e.C("#","$"),e.NM={cN:"number",b:e.NR,r:0},e.CNM={cN:"number",b:e.CNR,r:0},e.BNM={cN:"number",b:e.BNR,r:0},e.CSSNM={cN:"number",b:e.NR+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",r:0},e.RM={cN:"regexp",b:/\//,e:/\/[gimuy]*/,i:/\n/,c:[e.BE,{b:/\[/,e:/\]/,r:0,c:[e.BE]}]},e.TM={cN:"title",b:e.IR,r:0},e.UTM={cN:"title",b:e.UIR,r:0},e.registerLanguage("apache",function(e){var t={cN:"number",b:"[\\$%]\\d+"};return{aliases:["apacheconf"],cI:!0,c:[e.HCM,{cN:"tag",b:"</?",e:">"},{cN:"keyword",b:/\w+/,r:0,k:{common:"order deny allow setenv rewriterule rewriteengine rewritecond documentroot sethandler errordocument loadmodule options header listen serverroot servername"},starts:{e:/$/,r:0,k:{literal:"on off all"},c:[{cN:"sqbracket",b:"\\s\\[",e:"\\]$"},{cN:"cbracket",b:"[\\$%]\\{",e:"\\}",c:["self",t]},t,e.QSM]}}],i:/\S/}}),e.registerLanguage("bash",function(e){var t={cN:"variable",v:[{b:/\$[\w\d#@][\w\d_]*/},{b:/\$\{(.*?)}/}]},r={cN:"string",b:/"/,e:/"/,c:[e.BE,t,{cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]}]},a={cN:"string",b:/'/,e:/'/};return{aliases:["sh","zsh"],l:/-?[a-z\.]+/,k:{keyword:"if then else elif fi for while in do done case esac function",literal:"true false",built_in:"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp",operator:"-ne -eq -lt -gt -f -d -e -s -l -a"},c:[{cN:"shebang",b:/^#![^\n]+sh\s*$/,r:10},{cN:"function",b:/\w[\w\d_]*\s*\(\s*\)\s*\{/,rB:!0,c:[e.inherit(e.TM,{b:/\w[\w\d_]*/})],r:0},e.HCM,e.NM,r,a,t]}}),e.registerLanguage("coffeescript",function(e){var t={keyword:"in if for while finally new do return else break catch instanceof throw try this switch continue typeof delete debugger super then unless until loop of by when and or is isnt not",literal:"true false null undefined yes no on off",built_in:"npm require console print module global window document"},r="[A-Za-z$_][0-9A-Za-z$_]*",a={cN:"subst",b:/#\{/,e:/}/,k:t},n=[e.BNM,e.inherit(e.CNM,{starts:{e:"(\\s*/)?",r:0}}),{cN:"string",v:[{b:/'''/,e:/'''/,c:[e.BE]},{b:/'/,e:/'/,c:[e.BE]},{b:/"""/,e:/"""/,c:[e.BE,a]},{b:/"/,e:/"/,c:[e.BE,a]}]},{cN:"regexp",v:[{b:"///",e:"///",c:[a,e.HCM]},{b:"//[gim]*",r:0},{b:/\/(?![ *])(\\\/|.)*?\/[gim]*(?=\W|$)/}]},{cN:"property",b:"@"+r},{b:"`",e:"`",eB:!0,eE:!0,sL:"javascript"}];a.c=n;var i=e.inherit(e.TM,{b:r}),s="(\\(.*\\))?\\s*\\B[-=]>",c={cN:"params",b:"\\([^\\(]",rB:!0,c:[{b:/\(/,e:/\)/,k:t,c:["self"].concat(n)}]};return{aliases:["coffee","cson","iced"],k:t,i:/\/\*/,c:n.concat([e.C("###","###"),e.HCM,{cN:"function",b:"^\\s*"+r+"\\s*=\\s*"+s,e:"[-=]>",rB:!0,c:[i,c]},{b:/[:\(,=]\s*/,r:0,c:[{cN:"function",b:s,e:"[-=]>",rB:!0,c:[c]}]},{cN:"class",bK:"class",e:"$",i:/[:="\[\]]/,c:[{bK:"extends",eW:!0,i:/[:="\[\]]/,c:[i]},i]},{cN:"attribute",b:r+":",e:":",rB:!0,rE:!0,r:0}])}}),e.registerLanguage("cpp",function(e){var t={cN:"keyword",b:"\\b[a-z\\d_]*_t\\b"},r={cN:"string",v:[e.inherit(e.QSM,{b:'((u8?|U)|L)?"'}),{b:'(u8?|U)?R"',e:'"',c:[e.BE]},{b:"'\\\\?.",e:"'",i:"."}]},a={cN:"number",v:[{b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},{b:e.CNR}]},n={cN:"preprocessor",b:"#",e:"$",k:"if else elif endif define undef warning error line pragma ifdef ifndef",c:[{b:/\\\n/,r:0},{bK:"include",e:"$",c:[r,{cN:"string",b:"<",e:">",i:"\\n"}]},r,a,e.CLCM,e.CBCM]},i=e.IR+"\\s*\\(",s={keyword:"int float while private char catch export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const struct for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using class asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue inline delete alignof constexpr decltype noexcept static_assert thread_local restrict _Bool complex _Complex _Imaginary atomic_bool atomic_char atomic_schar atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong atomic_ullong",built_in:"std string cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf",literal:"true false nullptr NULL"};return{aliases:["c","cc","h","c++","h++","hpp"],k:s,i:"</",c:[t,e.CLCM,e.CBCM,a,r,n,{b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:s,c:["self",t]},{b:e.IR+"::",k:s},{bK:"new throw return else",r:0},{cN:"function",b:"("+e.IR+"[\\*&\\s]+)+"+i,rB:!0,e:/[{;=]/,eE:!0,k:s,i:/[^\w\s\*&]/,c:[{b:i,rB:!0,c:[e.TM],r:0},{cN:"params",b:/\(/,e:/\)/,k:s,r:0,c:[e.CLCM,e.CBCM,r,a]},e.CLCM,e.CBCM,n]}]}}),e.registerLanguage("cs",function(e){var t="abstract as base bool break byte case catch char checked const continue decimal dynamic default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in int interface internal is lock long null when object operator out override params private protected public readonly ref sbyte sealed short sizeof stackalloc static string struct switch this true try typeof uint ulong unchecked unsafe ushort using virtual volatile void while async protected public private internal ascending descending from get group into join let orderby partial select set value var where yield",r=e.IR+"(<"+e.IR+">)?";return{aliases:["csharp"],k:t,i:/::/,c:[e.C("///","$",{rB:!0,c:[{cN:"xmlDocTag",v:[{b:"///",r:0},{b:"<!--|-->"},{b:"</?",e:">"}]}]}),e.CLCM,e.CBCM,{cN:"preprocessor",b:"#",e:"$",k:"if else elif endif define undef warning error line region endregion pragma checksum"},{cN:"string",b:'@"',e:'"',c:[{b:'""'}]},e.ASM,e.QSM,e.CNM,{bK:"class interface",e:/[{;=]/,i:/[^\s:]/,c:[e.TM,e.CLCM,e.CBCM]},{bK:"namespace",e:/[{;=]/,i:/[^\s:]/,c:[{cN:"title",b:"[a-zA-Z](\\.?\\w)*",r:0},e.CLCM,e.CBCM]},{bK:"new return throw await",r:0},{cN:"function",b:"("+r+"\\s+)+"+e.IR+"\\s*\\(",rB:!0,e:/[{;=]/,eE:!0,k:t,c:[{b:e.IR+"\\s*\\(",rB:!0,c:[e.TM],r:0},{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,k:t,r:0,c:[e.ASM,e.QSM,e.CNM,e.CBCM]},e.CLCM,e.CBCM]}]}}),e.registerLanguage("css",function(e){var t="[a-zA-Z-][a-zA-Z0-9_-]*",r={cN:"function",b:t+"\\(",rB:!0,eE:!0,e:"\\("},a={cN:"rule",b:/[A-Z\_\.\-]+\s*:/,rB:!0,e:";",eW:!0,c:[{cN:"attribute",b:/\S/,e:":",eE:!0,starts:{cN:"value",eW:!0,eE:!0,c:[r,e.CSSNM,e.QSM,e.ASM,e.CBCM,{cN:"hexcolor",b:"#[0-9A-Fa-f]+"},{cN:"important",b:"!important"}]}}]};return{cI:!0,i:/[=\/|'\$]/,c:[e.CBCM,{cN:"id",b:/\#[A-Za-z0-9_-]+/},{cN:"class",b:/\.[A-Za-z0-9_-]+/},{cN:"attr_selector",b:/\[/,e:/\]/,i:"$"},{cN:"pseudo",b:/:(:)?[a-zA-Z0-9\_\-\+\(\)"']+/},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:"font-face page"},{cN:"at_rule",b:"@",e:"[{;]",c:[{cN:"keyword",b:/\S+/},{b:/\s/,eW:!0,eE:!0,r:0,c:[r,e.ASM,e.QSM,e.CSSNM]}]},{cN:"tag",b:t,r:0},{cN:"rules",b:"{",e:"}",i:/\S/,c:[e.CBCM,a]}]}}),e.registerLanguage("diff",function(e){return{aliases:["patch"],c:[{cN:"chunk",r:10,v:[{b:/^@@ +\-\d+,\d+ +\+\d+,\d+ +@@$/},{b:/^\*\*\* +\d+,\d+ +\*\*\*\*$/},{b:/^\-\-\- +\d+,\d+ +\-\-\-\-$/}]},{cN:"header",v:[{b:/Index: /,e:/$/},{b:/=====/,e:/=====$/},{b:/^\-\-\-/,e:/$/},{b:/^\*{3} /,e:/$/},{b:/^\+\+\+/,e:/$/},{b:/\*{5}/,e:/\*{5}$/}]},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"change",b:"^\\!",e:"$"}]}}),e.registerLanguage("http",function(e){return{aliases:["https"],i:"\\S",c:[{cN:"status",b:"^HTTP/[0-9\\.]+",e:"$",c:[{cN:"number",b:"\\b\\d{3}\\b"}]},{cN:"request",b:"^[A-Z]+ (.*?) HTTP/[0-9\\.]+$",rB:!0,e:"$",c:[{cN:"string",b:" ",e:" ",eB:!0,eE:!0}]},{cN:"attribute",b:"^\\w",e:": ",eE:!0,i:"\\n|\\s|=",starts:{cN:"string",e:"$"}},{b:"\\n\\n",starts:{sL:[],eW:!0}}]}}),e.registerLanguage("ini",function(e){var t={cN:"string",c:[e.BE],v:[{b:"'''",e:"'''",r:10},{b:'"""',e:'"""',r:10},{b:'"',e:'"'},{b:"'",e:"'"}]};return{aliases:["toml"],cI:!0,i:/\S/,c:[e.C(";","$"),e.HCM,{cN:"title",b:/^\s*\[+/,e:/\]+/},{cN:"setting",b:/^[a-z0-9\[\]_-]+\s*=\s*/,e:"$",c:[{cN:"value",eW:!0,k:"on off true false yes no",c:[{cN:"variable",v:[{b:/\$[\w\d"][\w\d_]*/},{b:/\$\{(.*?)}/}]},t,{cN:"number",b:/([\+\-]+)?[\d]+_[\d_]+/},e.NM],r:0}]}]}}),e.registerLanguage("java",function(e){var t=e.UIR+"(<"+e.UIR+">)?",r="false synchronized int abstract float private char boolean static null if const for true while long strictfp finally protected import native final void enum else break transient catch instanceof byte super volatile case assert short package default double public try this switch continue throws protected public private",a="\\b(0[bB]([01]+[01_]+[01]+|[01]+)|0[xX]([a-fA-F0-9]+[a-fA-F0-9_]+[a-fA-F0-9]+|[a-fA-F0-9]+)|(([\\d]+[\\d_]+[\\d]+|[\\d]+)(\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))?|\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))([eE][-+]?\\d+)?)[lLfF]?",n={cN:"number",b:a,r:0};return{aliases:["jsp"],k:r,i:/<\/|#/,c:[e.C("/\\*\\*","\\*/",{r:0,c:[{cN:"doctag",b:"@[A-Za-z]+"}]}),e.CLCM,e.CBCM,e.ASM,e.QSM,{cN:"class",bK:"class interface",e:/[{;=]/,eE:!0,k:"class interface",i:/[:"\[\]]/,c:[{bK:"extends implements"},e.UTM]},{bK:"new throw return else",r:0},{cN:"function",b:"("+t+"\\s+)+"+e.UIR+"\\s*\\(",rB:!0,e:/[{;=]/,eE:!0,k:r,c:[{b:e.UIR+"\\s*\\(",rB:!0,r:0,c:[e.UTM]},{cN:"params",b:/\(/,e:/\)/,k:r,r:0,c:[e.ASM,e.QSM,e.CNM,e.CBCM]},e.CLCM,e.CBCM]},n,{cN:"annotation",b:"@[A-Za-z]+"}]}}),e.registerLanguage("javascript",function(e){return{aliases:["js"],k:{keyword:"in of if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const export super debugger as async await",literal:"true false null undefined NaN Infinity",built_in:"eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect Promise"},c:[{cN:"pi",r:10,b:/^\s*['"]use (strict|asm)['"]/},e.ASM,e.QSM,{cN:"string",b:"`",e:"`",c:[e.BE,{cN:"subst",b:"\\$\\{",e:"\\}"}]},e.CLCM,e.CBCM,{cN:"number",v:[{b:"\\b(0[bB][01]+)"},{b:"\\b(0[oO][0-7]+)"},{b:e.CNR}],r:0},{b:"("+e.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[e.CLCM,e.CBCM,e.RM,{b:/</,e:/>\s*[);\]]/,r:0,sL:"xml"}],r:0},{cN:"function",bK:"function",e:/\{/,eE:!0,c:[e.inherit(e.TM,{b:/[A-Za-z$_][0-9A-Za-z$_]*/}),{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,c:[e.CLCM,e.CBCM]}],i:/\[|%/},{b:/\$[(.]/},{b:"\\."+e.IR,r:0},{bK:"import",e:"[;$]",k:"import from as",c:[e.ASM,e.QSM]},{cN:"class",bK:"class",e:/[{;=]/,eE:!0,i:/[:"\[\]]/,c:[{bK:"extends"},e.UTM]}],i:/#/}}),e.registerLanguage("json",function(e){var t={literal:"true false null"},r=[e.QSM,e.CNM],a={cN:"value",e:",",eW:!0,eE:!0,c:r,k:t},n={b:"{",e:"}",c:[{cN:"attribute",b:'\\s*"',e:'"\\s*:\\s*',eB:!0,eE:!0,c:[e.BE],i:"\\n",starts:a}],i:"\\S"},i={b:"\\[",e:"\\]",c:[e.inherit(a,{cN:null})],i:"\\S"};return r.splice(r.length,0,n,i),{c:r,k:t,i:"\\S"}}),e.registerLanguage("makefile",function(e){var t={cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]};return{aliases:["mk","mak"],c:[e.HCM,{b:/^\w+\s*\W*=/,rB:!0,r:0,starts:{cN:"constant",e:/\s*\W*=/,eE:!0,starts:{e:/$/,r:0,c:[t]}}},{cN:"title",b:/^[\w]+:\s*$/},{cN:"phony",b:/^\.PHONY:/,e:/$/,k:".PHONY",l:/[\.\w]+/},{b:/^\t+/,e:/$/,r:0,c:[e.QSM,t]}]}}),e.registerLanguage("xml",function(e){var t="[A-Za-z0-9\\._:-]+",r={b:/<\?(php)?(?!\w)/,e:/\?>/,sL:"php"},a={eW:!0,i:/</,r:0,c:[r,{cN:"attribute",b:t,r:0},{b:"=",r:0,c:[{cN:"value",c:[r],v:[{b:/"/,e:/"/},{b:/'/,e:/'/},{b:/[^\s\/>]+/}]}]}]};return{aliases:["html","xhtml","rss","atom","xsl","plist"],cI:!0,c:[{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},e.C("<!--","-->",{r:10}),{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style(?=\\s|>|$)",e:">",k:{title:"style"},c:[a],starts:{e:"</style>",rE:!0,sL:"css"}},{cN:"tag",b:"<script(?=\\s|>|$)",e:">",k:{title:"script"},c:[a],starts:{e:"</script>",rE:!0,sL:["actionscript","javascript","handlebars"]}},r,{cN:"pi",b:/<\?\w+/,e:/\?>/,r:10},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:/[^ \/><\n\t]+/,r:0},a]}]}}),e.registerLanguage("markdown",function(e){return{aliases:["md","mkdown","mkd"],c:[{cN:"header",v:[{b:"^#{1,6}",e:"$"},{b:"^.+?\\n[=-]{2,}$"}]},{b:"<",e:">",sL:"xml",r:0},{cN:"bullet",b:"^([*+-]|(\\d+\\.))\\s+"},{cN:"strong",b:"[*_]{2}.+?[*_]{2}"},{cN:"emphasis",v:[{b:"\\*.+?\\*"},{b:"_.+?_",r:0}]},{cN:"blockquote",b:"^>\\s+",e:"$"},{cN:"code",v:[{b:"`.+?`"},{b:"^( {4}|	)",e:"$",r:0}]},{cN:"horizontal_rule",b:"^[-\\*]{3,}",e:"$"},{b:"\\[.+?\\][\\(\\[].*?[\\)\\]]",rB:!0,c:[{cN:"link_label",b:"\\[",e:"\\]",eB:!0,rE:!0,r:0},{cN:"link_url",b:"\\]\\(",e:"\\)",eB:!0,eE:!0},{cN:"link_reference",b:"\\]\\[",e:"\\]",eB:!0,eE:!0}],r:10},{b:"^\\[.+\\]:",rB:!0,c:[{cN:"link_reference",b:"\\[",e:"\\]:",eB:!0,eE:!0,starts:{cN:"link_url",e:"$"}}]}]}}),e.registerLanguage("nginx",function(e){var t={cN:"variable",v:[{b:/\$\d+/},{b:/\$\{/,e:/}/},{b:"[\\$\\@]"+e.UIR}]},r={eW:!0,l:"[a-z/_]+",k:{built_in:"on off yes no true false none blocked debug info notice warn error crit select break last permanent redirect kqueue rtsig epoll poll /dev/poll"},r:0,i:"=>",c:[e.HCM,{cN:"string",c:[e.BE,t],v:[{b:/"/,e:/"/},{b:/'/,e:/'/}]},{cN:"url",b:"([a-z]+):/",e:"\\s",eW:!0,eE:!0,c:[t]},{cN:"regexp",c:[e.BE,t],v:[{b:"\\s\\^",e:"\\s|{|;",rE:!0},{b:"~\\*?\\s+",e:"\\s|{|;",rE:!0},{b:"\\*(\\.[a-z\\-]+)+"},{b:"([a-z\\-]+\\.)+\\*"}]},{cN:"number",b:"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b"},{cN:"number",b:"\\b\\d+[kKmMgGdshdwy]*\\b",r:0},t]};return{aliases:["nginxconf"],c:[e.HCM,{b:e.UIR+"\\s",e:";|{",rB:!0,c:[{cN:"title",b:e.UIR,starts:r}],r:0}],i:"[^\\s\\}]"}}),e.registerLanguage("objectivec",function(e){var t={cN:"built_in",b:"(AV|CA|CF|CG|CI|MK|MP|NS|UI)\\w+"},r={keyword:"int float while char export sizeof typedef const struct for union unsigned long volatile static bool mutable if do return goto void enum else break extern asm case short default double register explicit signed typename this switch continue wchar_t inline readonly assign readwrite self @synchronized id typeof nonatomic super unichar IBOutlet IBAction strong weak copy in out inout bycopy byref oneway __strong __weak __block __autoreleasing @private @protected @public @try @property @end @throw @catch @finally @autoreleasepool @synthesize @dynamic @selector @optional @required",literal:"false true FALSE TRUE nil YES NO NULL",built_in:"BOOL dispatch_once_t dispatch_queue_t dispatch_sync dispatch_async dispatch_once"},a=/[a-zA-Z@][a-zA-Z0-9_]*/,n="@interface @class @protocol @implementation";return{aliases:["mm","objc","obj-c"],k:r,l:a,i:"</",c:[t,e.CLCM,e.CBCM,e.CNM,e.QSM,{cN:"string",v:[{b:'@"',e:'"',i:"\\n",c:[e.BE]},{b:"'",e:"[^\\\\]'",i:"[^\\\\][^']"}]},{cN:"preprocessor",b:"#",e:"$",c:[{cN:"title",v:[{b:'"',e:'"'},{b:"<",e:">"}]}]},{cN:"class",b:"("+n.split(" ").join("|")+")\\b",e:"({|$)",eE:!0,k:n,l:a,c:[e.UTM]},{cN:"variable",b:"\\."+e.UIR,r:0}]}}),e.registerLanguage("perl",function(e){var t="getpwent getservent quotemeta msgrcv scalar kill dbmclose undef lc ma syswrite tr send umask sysopen shmwrite vec qx utime local oct semctl localtime readpipe do return format read sprintf dbmopen pop getpgrp not getpwnam rewinddir qqfileno qw endprotoent wait sethostent bless s|0 opendir continue each sleep endgrent shutdown dump chomp connect getsockname die socketpair close flock exists index shmgetsub for endpwent redo lstat msgctl setpgrp abs exit select print ref gethostbyaddr unshift fcntl syscall goto getnetbyaddr join gmtime symlink semget splice x|0 getpeername recv log setsockopt cos last reverse gethostbyname getgrnam study formline endhostent times chop length gethostent getnetent pack getprotoent getservbyname rand mkdir pos chmod y|0 substr endnetent printf next open msgsnd readdir use unlink getsockopt getpriority rindex wantarray hex system getservbyport endservent int chr untie rmdir prototype tell listen fork shmread ucfirst setprotoent else sysseek link getgrgid shmctl waitpid unpack getnetbyname reset chdir grep split require caller lcfirst until warn while values shift telldir getpwuid my getprotobynumber delete and sort uc defined srand accept package seekdir getprotobyname semop our rename seek if q|0 chroot sysread setpwent no crypt getc chown sqrt write setnetent setpriority foreach tie sin msgget map stat getlogin unless elsif truncate exec keys glob tied closedirioctl socket readlink eval xor readline binmode setservent eof ord bind alarm pipe atan2 getgrent exp time push setgrent gt lt or ne m|0 break given say state when",r={cN:"subst",b:"[$@]\\{",e:"\\}",k:t},a={b:"->{",e:"}"},n={cN:"variable",v:[{b:/\$\d/},{b:/[\$%@](\^\w\b|#\w+(::\w+)*|{\w+}|\w+(::\w*)*)/},{b:/[\$%@][^\s\w{]/,r:0}]},i=[e.BE,r,n],s=[n,e.HCM,e.C("^\\=\\w","\\=cut",{eW:!0}),a,{cN:"string",c:i,v:[{b:"q[qwxr]?\\s*\\(",e:"\\)",r:5},{b:"q[qwxr]?\\s*\\[",e:"\\]",r:5},{b:"q[qwxr]?\\s*\\{",e:"\\}",r:5},{b:"q[qwxr]?\\s*\\|",e:"\\|",r:5},{b:"q[qwxr]?\\s*\\<",e:"\\>",r:5},{b:"qw\\s+q",e:"q",r:5},{b:"'",e:"'",c:[e.BE]},{b:'"',e:'"'},{b:"`",e:"`",c:[e.BE]},{b:"{\\w+}",c:[],r:0},{b:"-?\\w+\\s*\\=\\>",c:[],r:0}]},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{b:"(\\/\\/|"+e.RSR+"|\\b(split|return|print|reverse|grep)\\b)\\s*",k:"split return print reverse grep",r:0,c:[e.HCM,{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[e.BE],r:0}]},{cN:"sub",bK:"sub",e:"(\\s*\\(.*?\\))?[;{]",r:5},{cN:"operator",b:"-\\w\\b",r:0},{b:"^__DATA__$",e:"^__END__$",sL:"mojolicious",c:[{b:"^@@.*",e:"$",cN:"comment"}]}];return r.c=s,a.c=s,{aliases:["pl"],k:t,c:s}}),e.registerLanguage("php",function(e){var t={cN:"variable",b:"\\$+[a-zA-Z_-ÿ][a-zA-Z0-9_-ÿ]*"},r={cN:"preprocessor",b:/<\?(php)?|\?>/},a={cN:"string",c:[e.BE,r],v:[{b:'b"',e:'"'},{b:"b'",e:"'"},e.inherit(e.ASM,{i:null}),e.inherit(e.QSM,{i:null})]},n={v:[e.BNM,e.CNM]};return{aliases:["php3","php4","php5","php6"],cI:!0,k:"and include_once list abstract global private echo interface as static endswitch array null if endwhile or const for endforeach self var while isset public protected exit foreach throw elseif include __FILE__ empty require_once do xor return parent clone use __CLASS__ __LINE__ else break print eval new catch __METHOD__ case exception default die require __FUNCTION__ enddeclare final try switch continue endfor endif declare unset true false trait goto instanceof insteadof __DIR__ __NAMESPACE__ yield finally",c:[e.CLCM,e.HCM,e.C("/\\*","\\*/",{c:[{cN:"doctag",b:"@[A-Za-z]+"},r]}),e.C("__halt_compiler.+?;",!1,{eW:!0,k:"__halt_compiler",l:e.UIR}),{cN:"string",b:/<<<['"]?\w+['"]?$/,e:/^\w+;?$/,c:[e.BE,{cN:"subst",v:[{b:/\$\w+/},{b:/\{\$/,e:/\}/}]}]},r,t,{b:/(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/},{cN:"function",bK:"function",e:/[;{]/,eE:!0,i:"\\$|\\[|%",c:[e.UTM,{cN:"params",b:"\\(",e:"\\)",c:["self",t,e.CBCM,a,n]}]},{cN:"class",bK:"class interface",e:"{",eE:!0,i:/[:\(\$"]/,c:[{bK:"extends implements"},e.UTM]},{bK:"namespace",e:";",i:/[\.']/,c:[e.UTM]},{bK:"use",e:";",c:[e.UTM]},{b:"=>"},a,n]}}),e.registerLanguage("python",function(e){var t={cN:"prompt",b:/^(>>>|\.\.\.) /},r={cN:"string",c:[e.BE],v:[{b:/(u|b)?r?'''/,e:/'''/,c:[t],r:10},{b:/(u|b)?r?"""/,e:/"""/,c:[t],r:10},{b:/(u|r|ur)'/,e:/'/,r:10},{b:/(u|r|ur)"/,e:/"/,r:10},{b:/(b|br)'/,e:/'/},{b:/(b|br)"/,e:/"/},e.ASM,e.QSM]},a={cN:"number",r:0,v:[{b:e.BNR+"[lLjJ]?"},{b:"\\b(0o[0-7]+)[lLjJ]?"},{b:e.CNR+"[lLjJ]?"}]},n={cN:"params",b:/\(/,e:/\)/,c:["self",t,a,r]};return{aliases:["py","gyp"],k:{keyword:"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda async await nonlocal|10 None True False",built_in:"Ellipsis NotImplemented"},i:/(<\/|->|\?)/,c:[t,a,r,e.HCM,{v:[{cN:"function",bK:"def",r:10},{cN:"class",bK:"class"}],e:/:/,i:/[${=;\n,]/,c:[e.UTM,n]},{cN:"decorator",b:/^[\t ]*@/,e:/$/},{b:/\b(print|exec)\(/}]}}),e.registerLanguage("ruby",function(e){var t="[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?",r="and false then defined module in return redo if BEGIN retry end for true self when next until do begin unless END rescue nil else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor",a={cN:"doctag",b:"@[A-Za-z]+"},n={cN:"value",b:"#<",e:">"},i=[e.C("#","$",{c:[a]}),e.C("^\\=begin","^\\=end",{c:[a],r:10}),e.C("^__END__","\\n$")],s={cN:"subst",b:"#\\{",e:"}",k:r},c={cN:"string",c:[e.BE,s],v:[{b:/'/,e:/'/},{b:/"/,e:/"/},{b:/`/,e:/`/},{b:"%[qQwWx]?\\(",e:"\\)"},{b:"%[qQwWx]?\\[",e:"\\]"},{b:"%[qQwWx]?{",e:"}"},{b:"%[qQwWx]?<",e:">"},{b:"%[qQwWx]?/",e:"/"},{b:"%[qQwWx]?%",e:"%"},{b:"%[qQwWx]?-",e:"-"},{b:"%[qQwWx]?\\|",e:"\\|"},{b:/\B\?(\\\d{1,3}|\\x[A-Fa-f0-9]{1,2}|\\u[A-Fa-f0-9]{4}|\\?\S)\b/}]},o={cN:"params",b:"\\(",e:"\\)",k:r},l=[c,n,{cN:"class",bK:"class module",e:"$|;",i:/=/,c:[e.inherit(e.TM,{b:"[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?"}),{cN:"inheritance",b:"<\\s*",c:[{cN:"parent",b:"("+e.IR+"::)?"+e.IR}]}].concat(i)},{cN:"function",bK:"def",e:"$|;",c:[e.inherit(e.TM,{b:t}),o].concat(i)},{cN:"constant",b:"(::)?(\\b[A-Z]\\w*(::)?)+",r:0},{cN:"symbol",b:e.UIR+"(\\!|\\?)?:",r:0},{cN:"symbol",b:":",c:[c,{b:t}],r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"variable",b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},{b:"("+e.RSR+")\\s*",c:[n,{cN:"regexp",c:[e.BE,s],i:/\n/,v:[{b:"/",e:"/[a-z]*"},{b:"%r{",e:"}[a-z]*"},{b:"%r\\(",e:"\\)[a-z]*"},{b:"%r!",e:"![a-z]*"},{b:"%r\\[",e:"\\][a-z]*"}]}].concat(i),r:0}].concat(i);s.c=l,o.c=l;var u="[>?]>",d="[\\w#]+\\(\\w+\\):\\d+:\\d+>",b="(\\w+-)?\\d+\\.\\d+\\.\\d(p\\d+)?[^>]+>",p=[{b:/^\s*=>/,cN:"status",starts:{e:"$",c:l}},{cN:"prompt",b:"^("+u+"|"+d+"|"+b+")",starts:{e:"$",c:l}}];return{aliases:["rb","gemspec","podspec","thor","irb"],k:r,i:/\/\*/,c:i.concat(p).concat(l)}}),e.registerLanguage("sql",function(e){var t=e.C("--","$");return{cI:!0,i:/[<>{}*]/,c:[{cN:"operator",bK:"begin end start commit rollback savepoint lock alter create drop rename call delete do handler insert load replace select truncate update set show pragma grant merge describe use explain help declare prepare execute deallocate release unlock purge reset change stop analyze cache flush optimize repair kill install uninstall checksum restore check backup revoke",e:/;/,eW:!0,k:{keyword:"abort abs absolute acc acce accep accept access accessed accessible account acos action activate add addtime admin administer advanced advise aes_decrypt aes_encrypt after agent aggregate ali alia alias allocate allow alter always analyze ancillary and any anydata anydataset anyschema anytype apply archive archived archivelog are as asc ascii asin assembly assertion associate asynchronous at atan atn2 attr attri attrib attribu attribut attribute attributes audit authenticated authentication authid authors auto autoallocate autodblink autoextend automatic availability avg backup badfile basicfile before begin beginning benchmark between bfile bfile_base big bigfile bin binary_double binary_float binlog bit_and bit_count bit_length bit_or bit_xor bitmap blob_base block blocksize body both bound buffer_cache buffer_pool build bulk by byte byteordermark bytes c cache caching call calling cancel capacity cascade cascaded case cast catalog category ceil ceiling chain change changed char_base char_length character_length characters characterset charindex charset charsetform charsetid check checksum checksum_agg child choose chr chunk class cleanup clear client clob clob_base clone close cluster_id cluster_probability cluster_set clustering coalesce coercibility col collate collation collect colu colum column column_value columns columns_updated comment commit compact compatibility compiled complete composite_limit compound compress compute concat concat_ws concurrent confirm conn connec connect connect_by_iscycle connect_by_isleaf connect_by_root connect_time connection consider consistent constant constraint constraints constructor container content contents context contributors controlfile conv convert convert_tz corr corr_k corr_s corresponding corruption cos cost count count_big counted covar_pop covar_samp cpu_per_call cpu_per_session crc32 create creation critical cross cube cume_dist curdate current current_date current_time current_timestamp current_user cursor curtime customdatum cycle d data database databases datafile datafiles datalength date_add date_cache date_format date_sub dateadd datediff datefromparts datename datepart datetime2fromparts day day_to_second dayname dayofmonth dayofweek dayofyear days db_role_change dbtimezone ddl deallocate declare decode decompose decrement decrypt deduplicate def defa defau defaul default defaults deferred defi defin define degrees delayed delegate delete delete_all delimited demand dense_rank depth dequeue des_decrypt des_encrypt des_key_file desc descr descri describ describe descriptor deterministic diagnostics difference dimension direct_load directory disable disable_all disallow disassociate discardfile disconnect diskgroup distinct distinctrow distribute distributed div do document domain dotnet double downgrade drop dumpfile duplicate duration e each edition editionable editions element ellipsis else elsif elt empty enable enable_all enclosed encode encoding encrypt end end-exec endian enforced engine engines enqueue enterprise entityescaping eomonth error errors escaped evalname evaluate event eventdata events except exception exceptions exchange exclude excluding execu execut execute exempt exists exit exp expire explain export export_set extended extent external external_1 external_2 externally extract f failed failed_login_attempts failover failure far fast feature_set feature_value fetch field fields file file_name_convert filesystem_like_logging final finish first first_value fixed flash_cache flashback floor flush following follows for forall force form forma format found found_rows freelist freelists freepools fresh from from_base64 from_days ftp full function g general generated get get_format get_lock getdate getutcdate global global_name globally go goto grant grants greatest group group_concat group_id grouping grouping_id groups gtid_subtract guarantee guard handler hash hashkeys having hea head headi headin heading heap help hex hierarchy high high_priority hosts hour http i id ident_current ident_incr ident_seed identified identity idle_time if ifnull ignore iif ilike ilm immediate import in include including increment index indexes indexing indextype indicator indices inet6_aton inet6_ntoa inet_aton inet_ntoa infile initial initialized initially initrans inmemory inner innodb input insert install instance instantiable instr interface interleaved intersect into invalidate invisible is is_free_lock is_ipv4 is_ipv4_compat is_not is_not_null is_used_lock isdate isnull isolation iterate java join json json_exists k keep keep_duplicates key keys kill l language large last last_day last_insert_id last_value lax lcase lead leading least leaves left len lenght length less level levels library like like2 like4 likec limit lines link list listagg little ln load load_file lob lobs local localtime localtimestamp locate locator lock locked log log10 log2 logfile logfiles logging logical logical_reads_per_call logoff logon logs long loop low low_priority lower lpad lrtrim ltrim m main make_set makedate maketime managed management manual map mapping mask master master_pos_wait match matched materialized max maxextents maximize maxinstances maxlen maxlogfiles maxloghistory maxlogmembers maxsize maxtrans md5 measures median medium member memcompress memory merge microsecond mid migration min minextents minimum mining minus minute minvalue missing mod mode model modification modify module monitoring month months mount move movement multiset mutex n name name_const names nan national native natural nav nchar nclob nested never new newline next nextval no no_write_to_binlog noarchivelog noaudit nobadfile nocheck nocompress nocopy nocycle nodelay nodiscardfile noentityescaping noguarantee nokeep nologfile nomapping nomaxvalue nominimize nominvalue nomonitoring none noneditionable nonschema noorder nopr nopro noprom nopromp noprompt norely noresetlogs noreverse normal norowdependencies noschemacheck noswitch not nothing notice notrim novalidate now nowait nth_value nullif nulls num numb numbe nvarchar nvarchar2 object ocicoll ocidate ocidatetime ociduration ociinterval ociloblocator ocinumber ociref ocirefcursor ocirowid ocistring ocitype oct octet_length of off offline offset oid oidindex old on online only opaque open operations operator optimal optimize option optionally or oracle oracle_date oradata ord ordaudio orddicom orddoc order ordimage ordinality ordvideo organization orlany orlvary out outer outfile outline output over overflow overriding p package pad parallel parallel_enable parameters parent parse partial partition partitions pascal passing password password_grace_time password_lock_time password_reuse_max password_reuse_time password_verify_function patch path patindex pctincrease pctthreshold pctused pctversion percent percent_rank percentile_cont percentile_disc performance period period_add period_diff permanent physical pi pipe pipelined pivot pluggable plugin policy position post_transaction pow power pragma prebuilt precedes preceding precision prediction prediction_cost prediction_details prediction_probability prediction_set prepare present preserve prior priority private private_sga privileges procedural procedure procedure_analyze processlist profiles project prompt protection public publishingservername purge quarter query quick quiesce quota quotename radians raise rand range rank raw read reads readsize rebuild record records recover recovery recursive recycle redo reduced ref reference referenced references referencing refresh regexp_like register regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy reject rekey relational relative relaylog release release_lock relies_on relocate rely rem remainder rename repair repeat replace replicate replication required reset resetlogs resize resource respect restore restricted result result_cache resumable resume retention return returning returns reuse reverse revoke right rlike role roles rollback rolling rollup round row row_count rowdependencies rowid rownum rows rtrim rules safe salt sample save savepoint sb1 sb2 sb4 scan schema schemacheck scn scope scroll sdo_georaster sdo_topo_geometry search sec_to_time second section securefile security seed segment select self sequence sequential serializable server servererror session session_user sessions_per_user set sets settings sha sha1 sha2 share shared shared_pool short show shrink shutdown si_averagecolor si_colorhistogram si_featurelist si_positionalcolor si_stillimage si_texture siblings sid sign sin size size_t sizes skip slave sleep smalldatetimefromparts smallfile snapshot some soname sort soundex source space sparse spfile split sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_small_result sql_variant_property sqlcode sqldata sqlerror sqlname sqlstate sqrt square standalone standby start starting startup statement static statistics stats_binomial_test stats_crosstab stats_ks_test stats_mode stats_mw_test stats_one_way_anova stats_t_test_ stats_t_test_indep stats_t_test_one stats_t_test_paired stats_wsr_test status std stddev stddev_pop stddev_samp stdev stop storage store stored str str_to_date straight_join strcmp strict string struct stuff style subdate subpartition subpartitions substitutable substr substring subtime subtring_index subtype success sum suspend switch switchoffset switchover sync synchronous synonym sys sys_xmlagg sysasm sysaux sysdate sysdatetimeoffset sysdba sysoper system system_user sysutcdatetime t table tables tablespace tan tdo template temporary terminated tertiary_weights test than then thread through tier ties time time_format time_zone timediff timefromparts timeout timestamp timestampadd timestampdiff timezone_abbr timezone_minute timezone_region to to_base64 to_date to_days to_seconds todatetimeoffset trace tracking transaction transactional translate translation treat trigger trigger_nestlevel triggers trim truncate try_cast try_convert try_parse type ub1 ub2 ub4 ucase unarchived unbounded uncompress under undo unhex unicode uniform uninstall union unique unix_timestamp unknown unlimited unlock unpivot unrecoverable unsafe unsigned until untrusted unusable unused update updated upgrade upped upper upsert url urowid usable usage use use_stored_outlines user user_data user_resources users using utc_date utc_timestamp uuid uuid_short validate validate_password_strength validation valist value values var var_samp varcharc vari varia variab variabl variable variables variance varp varraw varrawc varray verify version versions view virtual visible void wait wallet warning warnings week weekday weekofyear wellformed when whene whenev wheneve whenever where while whitespace with within without work wrapped xdb xml xmlagg xmlattributes xmlcast xmlcolattval xmlelement xmlexists xmlforest xmlindex xmlnamespaces xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltype xor year year_to_month years yearweek",
literal:"true false null",built_in:"array bigint binary bit blob boolean char character date dec decimal float int int8 integer interval number numeric real record serial serial8 smallint text varchar varying void"},c:[{cN:"string",b:"'",e:"'",c:[e.BE,{b:"''"}]},{cN:"string",b:'"',e:'"',c:[e.BE,{b:'""'}]},{cN:"string",b:"`",e:"`",c:[e.BE]},e.CNM,e.CBCM,t]},e.CBCM,t]}}),e});

```

`frontend/app/scripts/utils/saveSvgAsPng.js`:

```js
// jshint ignore: start
(function() {
  var out$ = typeof exports != 'undefined' && exports || this;

  var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';

  function isExternal(url) {
    return url && url.lastIndexOf('http',0) == 0 && url.lastIndexOf(window.location.host) == -1;
  }

  function inlineImages(el, callback) {
    var images = el.querySelectorAll('image');
    var left = images.length;
    if (left == 0) {
      callback();
    }
    for (var i = 0; i < images.length; i++) {
      (function(image) {
        var href = image.getAttributeNS("http://www.w3.org/1999/xlink", "href");
        if (href) {
          if (isExternal(href.value)) {
            console.warn("Cannot render embedded images linking to external hosts: "+href.value);
            return;
          }
        }
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var img = new Image();
        href = href || image.getAttribute('href');
        img.src = href;
        img.onload = function() {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          image.setAttributeNS("http://www.w3.org/1999/xlink", "href", canvas.toDataURL('image/png'));
          left--;
          if (left == 0) {
            callback();
          }
        }
        img.onerror = function() {
          left--;
          if (left == 0) {
            callback();
          }
        }
      })(images[i]);
    }
  }

  function styles(el, selectorRemap) {
    var css = "";
    var sheets = document.styleSheets;
    for (var i = 0; i < sheets.length; i++) {
      if (isExternal(sheets[i].href)) {
        console.warn("Cannot include styles from other hosts: "+sheets[i].href);
        continue;
      }
      var rules = sheets[i].cssRules;
      if (rules != null) {
        for (var j = 0; j < rules.length; j++) {
          var rule = rules[j];
          if (typeof(rule.style) != "undefined") {
            var match = null;
            try {
              match = el.querySelector(rule.selectorText);
            } catch(err) {
              console.warn('Invalid CSS selector "' + rule.selectorText + '"', err);
            }
            if (match) {
              var selector = selectorRemap ? selectorRemap(rule.selectorText) : rule.selectorText;
              css += selector + " { " + rule.style.cssText + " }\n";
            } else if(rule.cssText.match(/^@font-face/)) {
              css += rule.cssText + '\n';
            }
          }
        }
      }
    }

    css += 'svg {font-family: \'Helvetica\'; font-size: 10px;}';
    return css;
  }

  function getDimension(el, clone, dim) {
    return (clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim))) ||
      el.getBoundingClientRect()[dim] ||
      parseInt(clone.style[dim]) ||
      parseInt(window.getComputedStyle(el).getPropertyValue(dim));
  }

  out$.svgAsDataUri = function(el, options, cb) {
    options = options || {};
    options.scale = options.scale || 1;
    var xmlns = "http://www.w3.org/2000/xmlns/";

    inlineImages(el, function() {
      var outer = document.createElement("div");
      var clone = el.cloneNode(true);
      var width, height, viewBoxWidth, viewBoxHeight;
      if(el.tagName == 'svg') {
        width = getDimension(el, clone, 'width');
        height = getDimension(el, clone, 'height');
        if (typeof width === "undefined" || width === null || isNaN(parseFloat(width))) {
          width = 0;
        }
        if (typeof height === "undefined" || height === null || isNaN(parseFloat(height))) {
          height = 0;
        }
        viewBoxWidth = el.viewBox.baseVal && el.viewBox.baseVal.width !== 0 ? el.viewBox.baseVal.width : width;
        viewBoxHeight = el.viewBox.baseVal && el.viewBox.baseVal.height !== 0 ? el.viewBox.baseVal.height : height;
      } else {
        var box = el.getBBox();
        width = box.x + box.width;
        height = box.y + box.height;
        clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\(.*?\)/, ''));
        viewBoxWidth = width;
        viewBoxHeight =  height;

        var svg = document.createElementNS('http://www.w3.org/2000/svg','svg')
        svg.appendChild(clone)
        clone = svg;
      }

      clone.setAttribute("version", "1.1");
      clone.setAttributeNS(xmlns, "xmlns", "http://www.w3.org/2000/svg");
      clone.setAttributeNS(xmlns, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      clone.setAttribute("width", width * options.scale);
      clone.setAttribute("height", height * options.scale);
      clone.setAttribute("viewBox", "0 0 " + viewBoxWidth + " " + viewBoxHeight);
      clone.setAttribute("class", "c3");

      outer.appendChild(clone);

      var css = styles(el, options.selectorRemap);

      if(options.backgroundColor) {
        css += 'svg {background-color: ' + options.backgroundColor +'}';
      }

      var s = document.createElement('style');
      s.setAttribute('type', 'text/css');
      s.innerHTML = "<![CDATA[\n" + css + "\n]]>";
      var defs = document.createElement('defs');
      defs.appendChild(s);
      clone.insertBefore(defs, clone.firstChild);

      var svg = doctype + outer.innerHTML;
      // encode then decode to handle `btoa` on Unicode; see MDN for `btoa`.
      var uri = 'data:image/svg+xml;base64,' + window.btoa(unescape(encodeURIComponent(svg)));
      if (cb) {
        cb(uri);
      }
    });
  }

  out$.saveSvgAsPng = function(el, name, options) {
    options = options || {};
    out$.svgAsDataUri(el, options, function(uri) {
      var image = new Image();
      image.onload = function() {
        var canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0);

        var a = document.createElement('a');
        a.download = name;
        a.href = canvas.toDataURL('image/png');
        document.body.appendChild(a);
        a.addEventListener("click", function(e) {
          a.parentNode.removeChild(a);
        });
        a.click();
      }
      image.src = uri;
    });
  }
})();

```

`frontend/app/styles/case-item.css`:

```css
div.case-collection:nth-of-type(odd) {
    background-color: #f9f9f9;
}

div.case-item {
    margin-bottom: 1px;
    display: flex;
    justify-content: space-around;
    align-items: stretch;
}

div.case-item>div {
    padding: 5px;
}

div.case-item>div.case-tlp {
    width: 8px;
}

div.case-item>div.case-details {
    flex: 1;
}

div.case-item>div.case-owner {
    width: 50px;
}

div.case-item>div.case-severity {
    width: 40px;
}

div.case-item>div.case-date {
    width: 120px;
}

div.case-item>div.case-observables-count {
    width: 30px;
}

div.case-item>div.case-observables-list {
    width: 450px;
}
div.case-item>div.case-similarity {
    width: 140px;
}
div.case-item>div.case-similarity-match {
    width: 150px;
}
div.case-item>div.case-similarity-merge {
    width: 150px;
    text-align: center;
}

```

`frontend/app/styles/case-template.css`:

```css
.customfield-item {
    background-color: #f9f9f9;
    padding: 10px;
    margin-bottom: 5px;
}

.task-item {
    background-color: #f9f9f9;
    margin-bottom: 5px;
}

```

`frontend/app/styles/case.css`:

```css
.links-container {
    display: flex;
    flex-wrap: wrap;
}
.link {
    margin-right: 5px;
    border-radius: 3px;
    padding: 5px;
}
span.link-id {
    width: 100px;
}
.has-error .radio-group label {
    border-color: #a94442;
}

.indicent-header {
    width: 330px;
}

.indicent-header h2 {
    font-size: 12px;
    text-align: center;
}

.merge-hints {
    padding-left: 35px;
}

.indicent-header h2.background {
    position: relative;
    z-index: 1;
}

.indicent-header h2.background:before {
    border-top: 2px solid #dfdfdf;
    border-left: 2px solid #dfdfdf;
    border-right: 2px solid #dfdfdf;
    content:"";
    margin: 0 auto;
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1;
}

.indicent-header h2.background span{
    background: #fff;
    font-weight: normal;
    color: #999;
    padding: 0 15px;

}

.merge-dialog .merge-case {
    background-color: #f5f5f5;
    padding: 10px;
    overflow: hidden;
}

.merge-dialog .search-field ul.dropdown-menu {
    width: 100%;
    left: 0 !important;
}

.merge-dialog .search-field .input-group-addon {
    line-height: 1;
}

.tags-list,
table.case-list .case-tags {
    font-size: 12px !important;
}

table.case-list .case-tags .label,
.case-tags .label,
.tags-list .label  {
    font-size: 12px !important;
    font-weight: normal;
}
table.data-list .btn-icon,
table.case-list .btn-icon {
    padding: 6px;
    padding-top: 0;
}

pre.error-trace {
    color: #a94442;
    border: none;
    font-size: 10px;
    word-wrap: break-word;
    word-break: break-all;
    white-space: pre-wrap;
    background-color: #f9f1f1;
}

td.case-status {
    text-align: center;
}

```

`frontend/app/styles/components/tag.css`:

```css
.label.label-tag {
    border-left-width: 8px;
    border-left-style: solid;
    /* border-top-left-radius: 0px;
    border-bottom-left-radius: 0px; */
}

```

`frontend/app/styles/custom-fields.css`:

```css
.custom-field-input dd {
    overflow-x: auto;
}

```

`frontend/app/styles/dashboard.css`:

```css
body,
.c3 svg {
    font-family: "Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif;
}

.dashboards-list .dashboard-item {
    padding: 5px;
    /*border-bottom: 1px dashed #ccc;*/
}
.dashboards-list .dashboard-item:nth-child(even) {
    background: #f9f9f9;
}
.dashboards-list .dashboard-item:nth-child(odd) {
    background: #FFF;
}

.dashboards-list .dashboard-item .media-right {
    vertical-align: middle;
}

.dashboard-content * {
    min-width: 0;
}

.dashboard-content {
    margin-top: 20px;
    padding-left: 0;
}
.dashboard-content > li {
    list-style: none;
}
.dashboard-content > .dndDraggingSource {
    display: none;
}
.dashboard-content > .dndPlaceholder {
    background-color: #f9f9f9;
    border: 1px dashed #aacbed;
    display: block;
    margin-top: 10px;
    min-height: 110px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 20px;
}
.dashboard-content > .dndPlaceholder:after {
    color: #999999;
    content: "Drop row here";
}

.dashboard-content .c3-chart {
    width: 100% !important;
    overflow: hidden;
}
.dashboard-content .c3-chart svg {
    width: 100% !important;
}

.dashboard-row {
    display: flex;
    flex-direction: column;
}
.chart-container {
    min-height: 100px;
    background-color: #f9f9f9;
    border: 1px dashed #aacbed;
    margin-top: 10px;
    padding: 15px;
}

.chart-container-dropzone {
    min-height: 50px;
    display: flex;
    justify-content: space-around;
    align-items: stretch;
}

.chart-container-dropzone > .dndDraggingSource {
    display: none;
}

.chart-container-dropzone > .dndPlaceholder {
    background-color: #eeeeee;
    display: flex;
    justify-content: center;
    align-items: center;
    line-height: 110px;
    font-size: 20px;
}
.chart-container-dropzone > .dndPlaceholder:after {
    color: #999999;
    content: "Drop item here";
}

.chart-container-dropzone > * {
    -webkit-box-flex: 1;      /* OLD - iOS 6-, Safari 3.1-6 */
    -moz-box-flex: 1;         /* OLD - Firefox 19- */
    width: 20%;               /* For old syntax, otherwise collapses. */
    -webkit-flex: 1;          /* Chrome */
    -ms-flex: 1;              /* IE 10 */
    flex: 1;
    margin: 0 5px;
}

.dashboard-view .chart-container-dropzone > *:first-child {
    margin-left: 0;
}

.dashboard-view .chart-container-dropzone > *:last-child{
    margin-right: 0px;
}

dashboard-item .box {
    margin-bottom: 0;
}

.dashboard-row {
    margin-bottom: 10px;
}

.dashboard-row .c3-container {
    display: -webkit-flex;
    display: -webkit-box;
    display: -moz-box;
    display: -ms-flexbox;
    display: flex;
    flex-direction: column;
}

.dashboard-row .c3-container .c3-chart {
    flex: 1;
}

 .dashboard-serie {
     background-color: #f9f9f9;
     margin-bottom: 15px;
     padding: 10px;
}

.dashboard-serie > .form-inline {
    display: flex;
    justify-content: flex-start;
    align-items: stretch;
}

.dashboard-serie > .form-inline > div {
    margin: 0 4px;
}

.dashboard-serie > .form-inline input {
    width: 100%
}

.dashboard-serie > .form-inline select {
    max-width: 200px;
}

.dashboard-period > div{
    height: 34px;
    display: flex;
    justify-content: flex-start;
    align-items: stretch;
}

.dashboard-period .label{
    display:flex;
    align-items:center;
    justify-content: center;
}

.dashboard-edit.left-toolbox {
    padding-left: 120px;
}
.dashboard-edit.right-toolbox {
    padding-right: 120px;
}

.dashboard-toolbox {
    background-color: #fff;
    position: absolute;
    width: 110px;
    padding: 10px;
    text-align: center;
}

.dashboard-toolbox.right-toolbox {
    right: 15px;
}
.dashboard-toolbox.left-toolbox {
    left: 15px;
}

.dashboard-toolbox > div {
    margin: auto;
    margin-bottom: 4px;
}
.dashboard-toolbox > div:last-child {
    margin-bottom: 0;
}
.c3-container .c3-error {
    height:300px;
    display:flex;
    justify-content:center;
    align-items:center;
}
.c3-container .c3-error > div {
    flex: 1;
}

```

`frontend/app/styles/directives/page-sizer.css`:

```css
.page-sizer {
    display:flex;
    align-items: center;
    width: 150px;
}

.page-sizer .page-sizer-label {
    flex: auto;
    white-space: nowrap;
}

.page-sizer select {
    flex: auto;
}

```

`frontend/app/styles/directives/user.css`:

```css
.avatar .avatar-icon {
    border-radius: 50px;
}

.avatar .avatar-name {
    margin-left: 8px;
}

.avatar .avatar-icon {
    position: absolute;
}

.avatar div.avatar-icon {
    background-color: #ccc;
    font-weight: bold;
    float: left;
    text-align: center;
    color: #000;
}

.avatar.avatar-xs {
    line-height: 30px;
}

.avatar.avatar-m {
    line-height: 40px;
}

.avatar.avatar-xs .avatar-icon {
    width: 30px;
    height: 30px;
    line-height: 30px;
    font-size: 12px;
}

.avatar.avatar-m .avatar-icon {
    width: 40px;
    height: 40px;
    line-height: 40px;
}

.avatar.avatar-xs .avatar-name {
    margin-left: 35px;
}

.avatar.avatar-m .avatar-name {
    margin-left:45px;
}

.avatar-input {
	width: 0.1px;
	height: 0.1px;
	opacity: 0;
	overflow: hidden;
	position: absolute;
	z-index: -1;
}

```

`frontend/app/styles/filters.css`:

```css
.active-filters {
    clear: both;
}
.active-filters > ul {
    list-style: none;
    overflow: hidden;
    margin-left: 0;
    padding-left: 0;
}
.active-filters > ul li {
    float: left;
    padding: 5px;
    margin-bottom: 5px;
}

.active-filters > ul li:first-child {
    padding-left: 0;
}

.active-filters > ul li.filter-item {
    margin-right: 15px;
    border-radius: 3px;
    background-color: #eee;
}

.active-filters > ul li.filter-item .filter-close {
    padding-left: 10px;
}

.active-filters .filter-value {
    max-width: 200px;
}

.active-filters .kv-label .default {
    background-color: #eee;
}

.filter-panel {
    padding: 10px;
    background-color: #f5f5f5;
    border-left: 4px solid #337ab7;
}

.filter-panel hr.filter-separator {
    padding: 0 50px;
    border: none;
    border-top: 1px dashed #ccc;
    color: #ccc;
    text-align: center;
}

.stats-panel .stats-item-wrapper {
    padding: 5px;
    background-color: #f5f5f5;
}

.stats-panel .box {
    margin-bottom: 0;
}

.similar-case-list .progress {
    height: 2px;
    opacity: 1;
}

.similar-case-list .has-feedback .form-control {
    padding-right: 25px;
}

.similar-case-list .case-item.filter-panel {
    padding: 5px 0;
    margin-bottom: 5px !important;
    border: none !important;
}

.similar-case-list .case-item.filter-panel .form-group {
    margin-bottom: 0 !important;
}

```

`frontend/app/styles/flex-table.css`:

```css
/* div.flex-header {
  background-color: #fff;
  border-bottom: 2px solid #ecf0f5;
  font-size: 16px;
  padding-top: 8px;
  padding-bottom: 8px;
}

div.flex-row:hover {
  border: 1px dotted #3c8dbc !important;
}

div.flex-row,
div.flex-header {
  display: flex;
  justify-content: space-between;
  align-items: stretch;
}
div.flex-row:nth-child(odd),
div.flex-header:nth-child(odd) {
  background: #f9f9f9;
  border: 1px dotted #f9f9f9;
}
div.flex-row:nth-child(even),
div.flex-header:nth-child(even) {
  background: #ecf0f5;
  border: 1px dotted #ecf0f5;
}
div.flex-row > div.flex-col,
div.flex-header > div.flex-col {
  margin: 0 5px;
  padding: 4px;
}
div.flex-row > div.flex-col .label.label-lg,
div.flex-header > div.flex-col .label.label-lg {
  font-size: 13px;
  font-weight: normal;
  line-height: 1;
}
div.flex-row > div.flex-col > *,
div.flex-header > div.flex-col > * {
  flex: 1;
}
div.flex-row > div.flex-col > span.label,
div.flex-header > div.flex-col > span.label {
  flex: none;
}
div.flex-row > div.flex-col.vertical,
div.flex-header > div.flex-col.vertical {
  display: flex;
  align-items: center;
}
div.flex-row > div.flex-col.vertical.centered,
div.flex-header > div.flex-col.vertical.centered {
  justify-content: center;
}
div.flex-row > div.flex-col:first-child,
div.flex-header > div.flex-col:first-child {
  margin-left: 0;
}
div.flex-row > div.flex-col:last-child,
div.flex-header > div.flex-col:last-child {
  margin-right: 0;
}
div.flex-row > div.flex-col.flex-1,
div.flex-header > div.flex-col.flex-1 {
  flex: 1;
}
div.flex-row > div.flex-col.flex-2,
div.flex-header > div.flex-col.flex-2 {
  flex: 2;
}
div.flex-row > div.flex-col.flex-3,
div.flex-header > div.flex-col.flex-3 {
  flex: 3;
}
div.flex-row > div.flex-col.flex-4,
div.flex-header > div.flex-col.flex-4 {
  flex: 4;
}
div.flex-row > div.flex-col.flex-5,
div.flex-header > div.flex-col.flex-5 {
  flex: 5;
}
div.flex-row > div.flex-col.flex-w-80,
div.flex-header > div.flex-col.flex-w-80 {
  width: 80px;
}
div.flex-row > div.flex-col.flex-w-100,
div.flex-header > div.flex-col.flex-w-100 {
  width: 100px;
}
div.flex-row > div.flex-col.flex-w-120,
div.flex-header > div.flex-col.flex-w-120 {
  width: 120px;
}
div.flex-row > div.flex-col.flex-w-150,
div.flex-header > div.flex-col.flex-w-150 {
  width: 150px;
}
div.flex-row > div.flex-col.flex-w-200,
div.flex-header > div.flex-col.flex-w-200 {
  width: 200px;
}
div.flex-row > div.flex-col.flex-icon,
div.flex-header > div.flex-col.flex-icon {
  padding-left: 10px;
  padding-right: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}
div.flex-row > div.flex-col.flex-icon i,
div.flex-header > div.flex-col.flex-icon i {
  margin-right: 5px;
} */

div.flex-header {
    background-color: #fff;
    border-bottom: 2px solid #ecf0f5;
    font-size: 16px;
    padding-top: 8px;
    padding-bottom: 8px;
}
div.flex-row:hover {
    border: 1px dotted #3c8dbc !important;
}
div.flex-row, div.flex-header {
    display: flex;
    justify-content: space-between;
    align-items: stretch;
}
div.flex-row:nth-child(odd), div.flex-header:nth-child(odd) {
    background: #f9f9f9;
    border: 1px dotted #f9f9f9;
}
div.flex-row:nth-child(even), div.flex-header:nth-child(even) {
    background: #ecf0f5;
    border: 1px dotted #ecf0f5;
}
div.flex-row > div.flex-col, div.flex-header > div.flex-col {
    margin: 0 5px;
    padding: 4px;
}
div.flex-row > div.flex-col .label.label-lg, div.flex-header > div.flex-col .label.label-lg {
    font-size: 13px;
    font-weight: normal;
    line-height: 1;
}
div.flex-row > div.flex-col > *, div.flex-header > div.flex-col > * {
    flex: 1;
}
div.flex-row > div.flex-col > span.label, div.flex-header > div.flex-col > span.label {
    flex: none;
}
div.flex-row > div.flex-col.vertical, div.flex-header > div.flex-col.vertical {
    display: flex;
    align-items: center;
}
div.flex-row > div.flex-col.vertical.centered, div.flex-header > div.flex-col.vertical.centered {
    justify-content: center;
}
div.flex-row > div.flex-col:first-child, div.flex-header > div.flex-col:first-child {
    margin-left: 0;
}
div.flex-row > div.flex-col:last-child, div.flex-header > div.flex-col:last-child {
    margin-right: 0;
}
div.flex-row > div.flex-col.flex-1, div.flex-header > div.flex-col.flex-1 {
    flex: 1;
}
div.flex-row > div.flex-col.flex-2, div.flex-header > div.flex-col.flex-2 {
    flex: 2;
}
div.flex-row > div.flex-col.flex-3, div.flex-header > div.flex-col.flex-3 {
    flex: 3;
}
div.flex-row > div.flex-col.flex-4, div.flex-header > div.flex-col.flex-4 {
    flex: 4;
}
div.flex-row > div.flex-col.flex-5, div.flex-header > div.flex-col.flex-5 {
    flex: 5;
}
div.flex-row > div.flex-col.flex-w-80, div.flex-header > div.flex-col.flex-w-80 {
    width: 80px;
}
div.flex-row > div.flex-col.flex-w-100, div.flex-header > div.flex-col.flex-w-100 {
    width: 100px;
}
div.flex-row > div.flex-col.flex-w-120, div.flex-header > div.flex-col.flex-w-120 {
    width: 120px;
}
div.flex-row > div.flex-col.flex-w-150, div.flex-header > div.flex-col.flex-w-150 {
    width: 150px;
}
div.flex-row > div.flex-col.flex-w-200, div.flex-header > div.flex-col.flex-w-200 {
    width: 200px;
}
div.flex-row > div.flex-col.flex-icon, div.flex-header > div.flex-col.flex-icon {
    padding-left: 10px;
    padding-right: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
}
div.flex-row > div.flex-col.flex-icon i, div.flex-header > div.flex-col.flex-icon i {
    margin-right: 5px;
}

```

`frontend/app/styles/flow.css`:

```css
.flow-item {
    padding: 5px 10px;
    background-color: #FFF;
    border-bottom: 1px solid lightgrey;
}

.flow-item:hover {
    background-color: #F8F8F8;
}

.flow-item .flow-item-breadcrumbs {
    margin: 5px 0;
}

.flow-item .operation-type i {
    margin-right: 5px;
}

.flow-item .flow-item-title {
    font-weight: bold;
    padding: 5px 0;
    /*white-space: pre-wrap;*/
}
.flow-item .flow-item-bulk {
    margin-left: 22px;
    color: #777;
    font-weight: normal;
}

.flow-item .flow-item-title > i {
    color: grey;
    margin-right: 5px;
}

.flow-item .flow-item-updates {
    margin-left: 10px;
}

.flow-item .flow-item-updates .img-thumbnail{
    width: 150px;
}

.flow-item span.label {
    margin-right:2px;
    display: inline;
}

```

`frontend/app/styles/fonts/SIL Open Font License.txt`:

```txt
Copyright 2010, 2012 Adobe Systems Incorporated (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe Systems Incorporated in the United States and/or other countries.

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL

-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.

The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the copyright statement(s).

"Original Version" refers to the collection of Font Software components as distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.

"Author" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.

5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.
```

`frontend/app/styles/label.css`:

```css
.kv-label {
	display: table;
    margin-top: 0;
    margin-left: 0;
}
.kv-label>span {
	color: #ffffff;
	display: table-cell;
	font-weight: 400;
	line-height: 1;
	padding: .3em .6em;
	text-align: center;
	vertical-align: baseline;
	white-space: nowrap;
}
.kv-label span.kv-label-key {
    /* border-bottom-left-radius: 0.25em;
    border-top-left-radius: .25em; */
    border-left-color: #3c8dbc;
    border-left-width: 3px;
    border-left-style: solid;
}
.kv-label span.kv-label-val {
    border-bottom-right-radius: 0.25em;
    border-top-right-radius: .25em;
    border-left: 1px dashed #3c8dbc;

	overflow: hidden;
	text-overflow: ellipsis;
	max-width: 200px;
}

.kv-label.kv-label-addon span.kv-label-val {
	border-bottom-right-radius: 0;
    border-top-right-radius: 0;
}

.kv-label.kv-label-addon span:last-child {
	border-bottom-right-radius: 0.25em;
	border-top-right-radius: .25em;
}

.kv-label>span.primary {
	background-color: #3c8dbc;
    color: #fff;
}
.kv-label>span.default {
    background-color: #d2d6de;
    color: #444;
}


.kv-label .tooltip-inner{
	word-wrap: break-word;
	text-align: left;
	white-space: pre-line;
}

```

`frontend/app/styles/main.css`:

```css
body {
    background-color: #ecf0f5;
}

a, body {
    overflow: hidden;
}

a.noline {
    text-decoration: none !important;
}

body {
    overflow-y: auto;
}

.navbar {
    position: fixed;
    right: 0;
    left: 0;
    top: 0;
    z-index: 1030;
}

.navbar-brand {
    padding: 6px 20px !important;
}

.navbar-brand>img {
    display: inline;
    width: 100px;
    height: 36px;
}

.main-navbar .nav>li>a {
    padding: 15px 8px;
}

.main-navbar .nav>li>a.profile {
    padding: 10px 8px;
}

.main-navbar .input-group-addon {
    padding-left: 6px;
    padding-right: 6px;
}

.modal-max {
    width: 90%;
}

.clickable {
    cursor: pointer;
}

.not-clickable {
    cursor: default;
}

.container-main {
    padding-top: 80px;
}

.marked>table, .markdown>table {
    margin: 0 !important;
}

.short-report .label {
    margin-right: 5px;
}

.empty-message {
    background-color: #f5f5f5;
    color: #AAA;
    font-size: 18px;
    text-align: center;
    padding: 40px;
}
.loading-message {
    background-color: #f5f5f5;
    color: #AAA;
    font-size: 18px;
    text-align: center;
    padding: 40px;
}

.tpad50 {
    padding-top: 50px
}

.text-default {
    color: #333;
}

.text-20 {
    font-size: 20px;
}

.pointer {
    cursor: pointer;
}

pre.clearpre {
    background-color: transparent;
    border: 0px;
}

.navbar-nav>li.hdivider {
    height: 30px;
    margin-top: 12px;
    border-left: 1px solid #CCC;
    opacity: 0.5;
}

.divider-vertical {
    height: 50px;
    margin: 0 9px;
    border-left: 1px solid #F2F2F2;
    border-right: 1px solid #FFF;
}

pre.clearpre {
    background-color: transparent;
    border: 0px;
}

.modal-footer.text-left {
    text-align: left !important;
}

.alert-container {
    position: absolute;
    margin-right: auto;
    top: 0px;
    left: 0px;
    right: 0px;
    z-index: 1040;
    width: 50%;
}

/** Login page **/
.login-form {
    width: 600px;
    margin: auto;
    margin-top: 40px;
    background-color: #eee;
}

.or-separator {
    display: flex;
    align-items: center;
    text-align: center;
    color: #afafaf;
}
.or-separator::before,
.or-separator::after {
    content: '';
    flex: 1;
    border-bottom: 1px solid #cfcfcf;
}
.or-separator::before {
    margin-right: .25em;
}
.or-separator::after {
    margin-left: .25em;
}
/***************************/

.flexwrap {
    display: flex !important;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-items: flex-start;
}

.wrap {
    word-wrap: break-word;
    word-break: break-all;
}

.nowrap {
    white-space: nowrap;
}

.pad20 {
    padding: 20px;
}

.vpad20 {
    padding-top: 20px;
    padding-bottom: 20px;
}

.hpad20 {
    padding-left: 20px;
    padding-right: 20px;
}

.pad10 {
    padding: 10px;
}

.vpad10 {
    padding-top: 10px;
    padding-bottom: 10px;
}

.hpad10 {
    padding-left: 10px;
    padding-right: 10px;
}

.pad5 {
    padding: 5px;
}

.vpad5 {
    padding-top: 5px;
    padding-bottom: 5px;
}

.hpad5 {
    padding-left: 5px;
    padding-right: 5px;
}

.rm2 {
    margin-right: 2px;
}

.lm2 {
    margin-left: 2px;
}

.rm5 {
    margin-right: 5px;
}

.lm5 {
    margin-left: 5px;
}

.tm5 {
    margin-top: 5px;
}

.bm5 {
    margin-bottom: 5px;
}

.rm10 {
    margin-right: 10px;
}

.lm10 {
    margin-left: 10px;
}

.tm10 {
    margin-top: 10px;
}

.bm10 {
    margin-bottom: 10px;
}

.has-error .dropzone {
    border-color: #a94442;
}

.label {
    font-weight: normal !important;
}

.label.label-lg {
    font-size: 100% !important;
    font-weight: normal !important;
}

.list-group-item .label.label-lg {
    font-size: 12px !important;
}

.progress.progress-bar-sm {
    height: 4px;
}

.progress.progress-bar-sm .progress-bar {
    line-height: 4px;
}

.progress.task-progress .progress-bar {
    opacity: 0.8;
    height: 4px;
}

.btn-canceled, .progress-bar-default {
    background-color: #777;
}

.btn-clear:active {
    box-shadow: none;
}

dl.dl-horizontal>dt.pull-left {
    text-align: left !important;
}

dl.dl-horizontal.clear {
    overflow: hidden !important;
}

dl.dl-horizontal>dt, dl.dl-horizontal>dd {
    line-height: 28px;
}

dl.dl-horizontal {
    margin-bottom: 10px;
}

ul.observable-reports-summary li {
    padding-bottom: 3px;
    padding-left: 2px !important;
    padding-right: 2px !important;
}

.form-control.form-control-wrapper {
    padding: 0;
    margin: 0;
    border: none;
}

.case-page .main-tabset {
    margin-bottom: 0;
}

.case-page .main-tabset .tab-content {
    display: none;
}

.case-page .case-page-content {
    background-color: #FFF;
    padding: 10px 10px 10px 10px;
}

.case-details dt,
.case-custom-fields dt {
    width: 200px !important;
}

.case-details dd,
.case-custom-fields dd {
    margin-left: 205px !important;
}

.case-custom-fields dt {
    background-color: #f9f9f9;
    padding-left: 5px;
    border-left: 2px solid #337ab7;
}

.case-custom-fields dt a {
    display: none;
}

.case-custom-fields dt:hover a {
    display: block;
}

.case-custom-fields dd {
    margin-left: 205px;
}

.scrollable {
    height: 100%;
    overflow: auto;
}

.dropzone {
    height: auto;
    min-height: 5em;
    padding: 5px;
    background-color: #fafafa;
}

.dropzone .dz-message {
    margin: 0 !important;
    border: 3px dashed #337ab7 !important;
    line-height: 4em;
}

.dropzone .dz-message span {
    position: inherit !important;
}

.div-hover {
    background: #fff;
}

.div-hover:hover {
    background: #f5f5f5;
}

.text-disabled {
    color: #dfdfdf;
}

.text-yellow {
    color: rgb(231, 147, 0);
}

.text-tlp-na {
    color: #428BCA;
}

.text-tlp-white {
    color: #5BC0CE;
}

.text-tlp-green {
    color: #5CB85C;
}

.text-tlp-amber {
    color: #F0AD4E;
}

.text-tlp-red {
    color: #D9534F;
}

.border-left-tlp-na {
    border-left: 6px solid #428BCA;
}

.border-left-tlp-white, .border-left-tlp-0 {
    border-left: 6px solid #5BC0CE;
}

.border-left-tlp-green, .border-left-tlp-1 {
    border-left: 6px solid #5CB85C;
}

.border-left-tlp-amber, .border-left-tlp-2 {
    border-left: 6px solid #F0AD4E;
}

.border-left-tlp-red, .border-left-tlp-3 {
    border-left: 6px solid #D9534F;
}

.bg-tlp-na {
    background-color: #428BCA !important;
}

.bg-tlp-white, .bg-tlp-0 {
    background-color: #5BC0CE !important;
}

.bg-tlp-green, .bg-tlp-1 {
    background-color: #5CB85C !important;
}

.bg-tlp-amber, .bg-tlp-2 {
    background-color: #F0AD4E !important;
}

.bg-tlp-red, .bg-tlp-3 {
    background-color: #D9534F !important;
}

.updatable-waiting .updatable-value {
    background-color: gray;
}

.updatable-success .updatable-value {
    background-color: green;
}

.updatable-failure .updatable-value {
    background-color: red;
}

.updatable-value {
    white-space: pre-wrap;
    display: inline-block;
    vertical-align: text-top;
}

.main-fadein.ng-enter {
    animation: fadeIn 0.5s;
}

.selection-filter.ng-enter {
    animation: fadeIn 0.5s;
}

.selection-filter.ng-leave {
    animation: fadeOut 0.2s;
}

.selection.ng-enter {
    animation: fadeIn 0.5s;
}

.selection.ng-leave {}

.selection-options.ng-enter {
    animation: fadeInDown 0.5s;
}

.selection-options.ng-leave {}

.flow.ng-enter {
    animation: fadeInRight 0.5s;
}

.flow.ng-leave {}

.flow.ng-move {
    animation: slideOutDown 0.5s;
}

.left-border {
    border-left: 1px solid lightgrey;
}

.spin {
    -webkit-animation: spin 1s infinite linear;
    -moz-animation: spin 1s infinite linear;
    -o-animation: spin 1s infinite linear;
    animation: spin 1s infinite linear;
    -webkit-transform-origin: 50% 58%;
    transform-origin: 50% 58%;
    -ms-transform-origin: 50% 58%;
    /* IE 9 */
}

tr.task-row .task-delete {
    text-align: center;
}

tr.task-row:hover .task-delete {
    display: inline !important;
}

tr.task-row .task-delete {
    display: none;
}

tr.task-row .tast-status {
    text-align: center;
}

td.vmiddle {
    vertical-align: middle !important;
}

.search-list pre {
    /* max-height: 120px; */
    /* overflow-y: scroll; */
    font-size: 10px !important;
    margin: 0 !important;
}

.search-list pre,
.observable-report pre {
    display: block;
    padding: 9.5px;
    margin: 0 0 10px;
    font-size: 13px;
    line-height: 1.42857143;
    word-break: break-all;
    word-wrap: break-word;
    background-color: #f5f5f5;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: #333;
    color: #fff;
}

@-moz-keyframes spin {
    from {
        -moz-transform: rotate(0deg);
    }
    to {
        -moz-transform: rotate(360deg);
    }
}

@-webkit-keyframes spin {
    from {
        -webkit-transform: rotate(0deg);
    }
    to {
        -webkit-transform: rotate(360deg);
    }
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

table.valigned td {
    vertical-align: middle !important;
}

table tr.tr-warning {
    background-color: #fcf8e3 !important;
}

table tr.tr-warning>td {
    background-color: #fcf8e3;
}

.box.box-navy {
    border-top-color: #001f3f;
}

.tags-list {
    font-size: 12px !important;
}

.tags-list .label {
    font-size: inherit !important;
    font-weight: normal;
}

tags-input .tags {
    border-radius: 0;
    box-shadow: none;
}

tags-input .tags:focus,
tags-input .host:focus {
    outline: none;
}
tags-input .tags.focuced {
    border-color: #3c8dbc;
    box-shadow: none;
    outline: none;
}

tags-input.input-sm .tags {
    border-radius: 0;
    height: 30px;
    line-height: 30px;
}

tags-input.input-sm .tags.focused {
    border-color: #3c8dbc;
    box-shadow: none;
}

footer.main-footer {
    padding: 2px;
    line-height: 40px;
}

footer .footer-logo {
    height: 40px;
    border-radius: 50%;
}

footer .footer-logo.logo-ok {
    background-color: #00a65a;
}

footer .footer-logo.logo-error {
    background-color: #dd4b39;
}

footer .footer-logo.logo-error {
    background-color: #dd4b39;
}

footer .footer-logo.logo-warning {
    background-color: #f39c12;
}

report:empty {
    display: none;
}

span.action-button {
    font-size: 14px;
}

table tr td.task-actions span.action-button {
    width: 60px;
    display: inline-block;
}

.misp-export .status-label {
    display: block;
}

.scroll-dropdown {
    max-height: 200px;
    overflow-y: auto;
}

.scroll-dropdown-2x {
    max-height: 400px;
    overflow-y: auto;
}

.dropdown-menu.align-right {
    left: auto;
    right: 0;
}

.description-pane{
    /* max-height: 550px; */
    overflow-y: auto;
}

.table.tasks-table>tbody+tbody {
  border: none;
}

.table.tasks-table .filter-panel {
  margin-left:40px;
  margin-right:40px;
}

.text-separator {
  font-size: 18px;
  text-align: center;
  font-weight: bold;
}

.template-selector {
  max-height: 300px;
  overflow-y: auto;
}

.label-critical {
    background-color: #8a0000 !important;
    /*background: rgba(0,0,0,0.2) !important;*/
}

.task-flags.inline div,
.observable-flags.inline div {
    display: inline;
}

@media (max-width: 991px) {
    .main-header .navbar-right a {
        color: #777;
    }
}

.icon-bar {
    background-color: #FFF;
}


table.tbody-stripped > tbody:nth-child(2n+1) > tr > td,
table.tbody-stripped > tbody:nth-child(2n+1) > tr > th {
   background-color: #f9f9f9;
}

table.tbody-stripped > tbody > tr:first-child > td {
    /* padding-bottom:0; */
}

/* table.tbody-stripped > tbody > tr:nth-child(2n) > td { */
table.tbody-stripped > tbody > tr:not(:first-child) > td {
    padding-top:0;
    border-top: none;
}

table.tbody-stripped>tbody+tbody {
    border: none;
}

table.tbody-stripped > tbody > tr > td {

}

.ellipsable {
    overflow: hidden;
	text-overflow: ellipsis;
}

/* Customise tags input */

tags-input.ti-tag-selector .tags .tag-item {
    background-color: #d2d6de;
    color: #444;
    border: none;
    padding: 0;
    padding-right: 5px;
    line-height: 26px;
}

tags-input.ti-tag-selector.ti-input-sm .tags .tag-item {
    line-height: 22px;
}

tags-input.ti-tag-selector .tags .tag-item span.tag-item-border{
    position: relative;
    left:0;
    width: 8px;
    background-color: red;
    display: inline-block;
    border-top-left-radius: .25em;
    border-bottom-left-radius: .25em;
}

tags-input.ti-tag-selector.ti-input-sm .tags .tag-item span.tag-item-border{
    position: relative;
    left:0;
    width: 8px;
    background-color: red;
    display: inline-block;
    border-top-left-radius: .25em;
    border-bottom-left-radius: .25em;
}

.vtop {
    vertical-align: top;
}

```

`frontend/app/styles/procedure.css`:

```css
.ttp-item {
    margin-bottom: 6px;
    border: 1px solid #f5f5f5;
}

.ttp-tactic {
    width: 250px;
    vertical-align: middle;
}
.ttp-name {
    flex: 1;
}
.ttp-action {
    width: 100px;
    text-align: right
}
.ttp-date {
    width: 140px;
}
.ttp-user {
    width: 200px;
}

.ttp-item .ttp-header {
    display: flex;
    align-items: stretch;
    justify-content: space-between;
    flex-direction: row;
    border-bottom: 1px solid #f5f5f5;
    background-color: #fcfcfc;
}
.ttp-item .ttp-header > div {
    padding: 2px 10px;
    vertical-align: middle;
}

.ttp-item .ttp-header .ttp-tactic {
    background-color: #f5f5f5;
    border-left: 4px solid #337ab7;
    color: #337ab7;
    display: flex;
    align-items: center;
}
.ttp-item .ttp-header .ttp-tactic > div {
    flex: 1
}
.ttp-item .ttp-header .ttp-name {
    flex: 1;
    display: flex;
    align-items: center;
}
.ttp-item .ttp-header .ttp-name > div {
    flex: 1
}
.ttp-item .ttp-header .ttp-date {
    display: flex;
    align-items: center;
}
.ttp-item .ttp-header .ttp-actions {
    display: flex;
    align-items: center;
}

.ttp-item .ttp-body {
    padding: 10px;
}

.ttp-item-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-direction: row;
    margin-bottom: 10px;
    border-bottom: 1px solid #f5f5f5;
}

.ttp-item-header > div {
    font-weight: bold;
    padding: 4px 10px;
}

.procedure-techniques-list {
    height: 40vh;
    overflow-y: scroll;
    border-radius: 0;
    box-shadow: none;
    border: 1px solid #d2d6de;
}

.procedure-techniques-list .tooltip {
    width: 600px;
    text-align: left;
}
.procedure-techniques-list .tooltip-inner {
    max-width: 100%;
    text-align: left;
}

.procedure-techniques-list .procedure-techniques-item {
    display: block;
    padding: 2px 5px;
}

.procedure-techniques-list .procedure-techniques-item:hover {
    background-color: #f5f5f5;
}

.procedure-techniques-list .procedure-techniques-item.active,
.procedure-techniques-list .procedure-techniques-item.active:hover {
    background-color: #3c8dbc;
    color: #fff;
}

.procedure-techniques-list .procedure-techniques-item.active a{
    color: #fff;
}

.procedure-technique {
    display: block;
}

.procedure-technique.sub-technique {
    margin-left: 30px;
}

```

`frontend/app/styles/search.css`:

```css
.entity-bar {
    display: flex;
    flex-flow: row;
    align-items: stretch;
    justify-content: space-between;
}

.entity-bar .entity-item {
    /* border: 1px solid #f5f5f5; */
    background-color: #f5f5f5;
    flex: 1;
    text-align: center;
    padding-top: 15px;
    padding-bottom: 15px;
    margin-left: 5px;
    margin-right: 5px;
    font-size: 16px;
    cursor: pointer;
    color: #777;
}

.entity-bar .entity-item.active {
    /* border: 1px solid #3c8dbc; */
    color: #fff;
    background-color: #3c8dbc;
}

.entity-bar .entity-item:first-child {
  margin-left: 0;
}

.entity-bar .entity-item:last-child {
  margin-right: 0;
}

.entity-bar .entity-item .entity-item-icon {
    font-size: 28px;
}

.hr-line-dashed {
    border-top: 1px dashed #CCC;
    color: #ffffff;
    background-color: #ffffff;
    height: 1px;
    margin: 10px 0;
}

.search-item-content {
    display: flex;
    align-items: stretch;
    justify-content: flex-start;
}

.search-item-icon {
    width: 80px;
    font-size: 26px;
    flex: none;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #EEE;
    margin-right: 5px;
}

.search-item-details {
    flex: auto;
}

.search-item-title a,
.search-item-title span.title{
    font-size: 18px;
    font-weight: bold;
    text-decoration: none;
}

.log-entry .file-box,
.search-item-details .file-box {
    float: left;
    width: 220px;
}

.log-entry .file-box .file,
.search-item-details .file-box .file {
    border: 1px solid #e7eaec;
    padding: 0;
    background-color: #ffffff;
    position: relative;
    margin-bottom: 20px;
    margin-right: 20px;
}

.log-entry .file-box .icon,
.log-entry .file-box .image,
.search-item-details .file-box .icon,
.search-item-details .file-box .image {
    padding: 15px 10px;
    text-align: center;
    height: 100px;
    overflow: hidden;
}

.log-entry .file-box .icon i,
.search-item-details .file-box .icon i {
    font-size: 70px;
    color: #dadada;
}

.log-entry .file-box .file .file-name,
.search-item-details .file-box .file .file-name {
    padding: 10px;
    background-color: #f8f8f8;
    border-top: 1px solid #e7eaec;
}

```

`frontend/app/styles/updatable.css`:

```css
.updatable-input .updatable-value {
    vertical-align: top;
    white-space: pre-wrap;
}

.updatable-input .updatable-input-value-wrapper {
    position: relative;
    display: inline-block;
    border-bottom: 1px solid #fff;
    padding-right: 20px;
}

.updatable-input .updatable-input-value-wrapper:hover {
    border-bottom: 1px solid #337ab7;
    cursor: pointer;
}

.updatable-input .updatable-input-value-wrapper .updatable-input-icon {
    display: none;
    float: right;
    margin-left: 10px;
    color: #337ab7;
}

.updatable-input .updatable-input-value-wrapper .updatable-input-icon.lg {
    line-height: 18px;
}

.updatable-input .updatable-input-value-wrapper:hover .updatable-input-icon {
    display: inline-block;
    position: absolute;
    top: 0;
    right: 0;
}

.updatable-input.updatable-input-text .updatable-input-markdown {
    cursor: auto;
    min-height: 21px;
}

```

`frontend/app/styles/vendors/AdminLTE-fonts.css`:

```css
/* cyrillic-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 300;
  src: local('Source Sans Pro Light'), local('SourceSansPro-Light'), url('../fonts/SourceSansPro-Light.otf') format('truetype');
  unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
}
/* cyrillic */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 300;
  src: local('Source Sans Pro Light'), local('SourceSansPro-Light'), url('../fonts/SourceSansPro-Light.otf') format('truetype');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 300;
  src: local('Source Sans Pro Light'), local('SourceSansPro-Light'), url('../fonts/SourceSansPro-Light.otf') format('truetype');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 300;
  src: local('Source Sans Pro Light'), local('SourceSansPro-Light'), url('../fonts/SourceSansPro-Light.otf') format('truetype');
  unicode-range: U+0370-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 300;
  src: local('Source Sans Pro Light'), local('SourceSansPro-Light'), url('../fonts/SourceSansPro-Light.otf') format('truetype');
  unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 300;
  src: local('Source Sans Pro Light'), local('SourceSansPro-Light'), url('../fonts/SourceSansPro-Light.otf') format('truetype');
  unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 300;
  src: local('Source Sans Pro Light'), local('SourceSansPro-Light'), url('../fonts/SourceSansPro-Light.otf') format('truetype');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}
/* cyrillic-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Sans Pro Regular'), local('SourceSansPro-Regular'), url('../fonts/SourceSansPro-Regular.otf') format('truetype');
  unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
}
/* cyrillic */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Sans Pro Regular'), local('SourceSansPro-Regular'), url('../fonts/SourceSansPro-Regular.otf') format('truetype');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Sans Pro Regular'), local('SourceSansPro-Regular'), url('../fonts/SourceSansPro-Regular.otf') format('truetype');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Sans Pro Regular'), local('SourceSansPro-Regular'), url('../fonts/SourceSansPro-Regular.otf') format('truetype');
  unicode-range: U+0370-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Sans Pro Regular'), local('SourceSansPro-Regular'), url('../fonts/SourceSansPro-Regular.otf') format('truetype');
  unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Sans Pro Regular'), local('SourceSansPro-Regular'), url('../fonts/SourceSansPro-Regular.otf') format('truetype');
  unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Sans Pro Regular'), local('SourceSansPro-Regular'), url('../fonts/SourceSansPro-Regular.otf') format('truetype');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}
/* cyrillic-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold'), local('SourceSansPro-SemiBold'), url('../fonts/SourceSansPro-Semibold.otf') format('truetype');
  unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
}
/* cyrillic */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold'), local('SourceSansPro-SemiBold'), url('../fonts/SourceSansPro-Semibold.otf') format('truetype');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold'), local('SourceSansPro-SemiBold'), url('../fonts/SourceSansPro-Semibold.otf') format('truetype');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold'), local('SourceSansPro-SemiBold'), url('../fonts/SourceSansPro-Semibold.otf') format('truetype');
  unicode-range: U+0370-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold'), local('SourceSansPro-SemiBold'), url('../fonts/SourceSansPro-Semibold.otf') format('truetype');
  unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold'), local('SourceSansPro-SemiBold'), url('../fonts/SourceSansPro-Semibold.otf') format('truetype');
  unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold'), local('SourceSansPro-SemiBold'), url('../fonts/SourceSansPro-Semibold.otf') format('truetype');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}
/* cyrillic-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 700;
  src: local('Source Sans Pro Bold'), local('SourceSansPro-Bold'), url('../fonts/SourceSansPro-Bold.otf') format('truetype');
  unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
}
/* cyrillic */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 700;
  src: local('Source Sans Pro Bold'), local('SourceSansPro-Bold'), url('../fonts/SourceSansPro-Bold.otf') format('truetype');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 700;
  src: local('Source Sans Pro Bold'), local('SourceSansPro-Bold'), url('../fonts/SourceSansPro-Bold.otf') format('truetype');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 700;
  src: local('Source Sans Pro Bold'), local('SourceSansPro-Bold'), url('../fonts/SourceSansPro-Bold.otf') format('truetype');
  unicode-range: U+0370-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 700;
  src: local('Source Sans Pro Bold'), local('SourceSansPro-Bold'), url('../fonts/SourceSansPro-Bold.otf') format('truetype');
  unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 700;
  src: local('Source Sans Pro Bold'), local('SourceSansPro-Bold'), url('../fonts/SourceSansPro-Bold.otf') format('truetype');
  unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 700;
  src: local('Source Sans Pro Bold'), local('SourceSansPro-Bold'), url('../fonts/SourceSansPro-Bold.otf') format('truetype');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}
/* cyrillic-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 300;
  src: local('Source Sans Pro Light Italic'), local('SourceSansPro-LightItalic'), url('../fonts/SourceSansPro-LightIt.otf') format('truetype');
  unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
}
/* cyrillic */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 300;
  src: local('Source Sans Pro Light Italic'), local('SourceSansPro-LightItalic'), url('../fonts/SourceSansPro-LightIt.otf') format('truetype');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 300;
  src: local('Source Sans Pro Light Italic'), local('SourceSansPro-LightItalic'), url('../fonts/SourceSansPro-LightIt.otf') format('truetype');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 300;
  src: local('Source Sans Pro Light Italic'), local('SourceSansPro-LightItalic'), url('../fonts/SourceSansPro-LightIt.otf') format('truetype');
  unicode-range: U+0370-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 300;
  src: local('Source Sans Pro Light Italic'), local('SourceSansPro-LightItalic'), url('../fonts/SourceSansPro-LightIt.otf') format('truetype');
  unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 300;
  src: local('Source Sans Pro Light Italic'), local('SourceSansPro-LightItalic'), url('../fonts/SourceSansPro-LightIt.otf') format('truetype');
  unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 300;
  src: local('Source Sans Pro Light Italic'), local('SourceSansPro-LightItalic'), url('../fonts/SourceSansPro-LightIt.otf') format('truetype');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}
/* cyrillic-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 400;
  src: local('Source Sans Pro Italic'), local('SourceSansPro-Italic'), url('../fonts/SourceSansPro-It.otf') format('truetype');
  unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
}
/* cyrillic */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 400;
  src: local('Source Sans Pro Italic'), local('SourceSansPro-Italic'), url('../fonts/SourceSansPro-It.otf') format('truetype');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 400;
  src: local('Source Sans Pro Italic'), local('SourceSansPro-Italic'), url('../fonts/SourceSansPro-It.otf') format('truetype');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 400;
  src: local('Source Sans Pro Italic'), local('SourceSansPro-Italic'), url('../fonts/SourceSansPro-It.otf') format('truetype');
  unicode-range: U+0370-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 400;
  src: local('Source Sans Pro Italic'), local('SourceSansPro-Italic'), url('../fonts/SourceSansPro-It.otf') format('truetype');
  unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 400;
  src: local('Source Sans Pro Italic'), local('SourceSansPro-Italic'), url('../fonts/SourceSansPro-It.otf') format('truetype');
  unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 400;
  src: local('Source Sans Pro Italic'), local('SourceSansPro-Italic'), url('../fonts/SourceSansPro-It.otf') format('truetype');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}
/* cyrillic-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold Italic'), local('SourceSansPro-SemiBoldItalic'), url('../fonts/SourceSansPro-SemiboldIt.otf') format('truetype');
  unicode-range: U+0460-052F, U+20B4, U+2DE0-2DFF, U+A640-A69F;
}
/* cyrillic */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold Italic'), local('SourceSansPro-SemiBoldItalic'), url('../fonts/SourceSansPro-SemiboldIt.otf') format('truetype');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold Italic'), local('SourceSansPro-SemiBoldItalic'), url('../fonts/SourceSansPro-SemiboldIt.otf') format('truetype');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold Italic'), local('SourceSansPro-SemiBoldItalic'), url('../fonts/SourceSansPro-SemiboldIt.otf') format('truetype');
  unicode-range: U+0370-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold Italic'), local('SourceSansPro-SemiBoldItalic'), url('../fonts/SourceSansPro-SemiboldIt.otf') format('truetype');
  unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold Italic'), local('SourceSansPro-SemiBoldItalic'), url('../fonts/SourceSansPro-SemiboldIt.otf') format('truetype');
  unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Source Sans Pro';
  font-style: italic;
  font-weight: 600;
  src: local('Source Sans Pro SemiBold Italic'), local('SourceSansPro-SemiBoldItalic'), url('../fonts/SourceSansPro-SemiboldIt.otf') format('truetype');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}

```

`frontend/app/styles/vendors/AdminLTE-skin-blue.css`:

```css
/*
 * Skin: Blue
 * ----------
 */
.skin-blue .main-header .navbar {
  background-color: #3c8dbc;
}
.skin-blue .main-header .navbar .nav > li > a {
  color: #ffffff;
}
.skin-blue .main-header .navbar .nav > li > a:hover,
.skin-blue .main-header .navbar .nav > li > a:active,
.skin-blue .main-header .navbar .nav > li > a:focus,
.skin-blue .main-header .navbar .nav .open > a,
.skin-blue .main-header .navbar .nav .open > a:hover,
.skin-blue .main-header .navbar .nav .open > a:focus,
.skin-blue .main-header .navbar .nav > .active > a {
  background: rgba(0, 0, 0, 0.1);
  color: #f6f6f6;
}
.skin-blue .main-header .navbar .sidebar-toggle {
  color: #ffffff;
}
.skin-blue .main-header .navbar .sidebar-toggle:hover {
  color: #f6f6f6;
  background: rgba(0, 0, 0, 0.1);
}
.skin-blue .main-header .navbar .sidebar-toggle {
  color: #fff;
}
.skin-blue .main-header .navbar .sidebar-toggle:hover {
  background-color: #367fa9;
}
@media (max-width: 767px) {
  .skin-blue .main-header .navbar .dropdown-menu li.divider {
    background-color: rgba(255, 255, 255, 0.1);
  }
  .skin-blue .main-header .navbar .dropdown-menu li a {
    color: #fff;
  }
  .skin-blue .main-header .navbar .dropdown-menu li a:hover {
    background: #367fa9;
  }
}
.skin-blue .main-header .logo {
  background-color: #367fa9;
  color: #ffffff;
  border-bottom: 0 solid transparent;
}
.skin-blue .main-header .logo:hover {
  background-color: #357ca5;
}
.skin-blue .main-header li.user-header {
  background-color: #3c8dbc;
}
.skin-blue .content-header {
  background: transparent;
}
.skin-blue .wrapper,
.skin-blue .main-sidebar,
.skin-blue .left-side {
  background-color: #222d32;
}
.skin-blue .user-panel > .info,
.skin-blue .user-panel > .info > a {
  color: #fff;
}
.skin-blue .sidebar-menu > li.header {
  color: #4b646f;
  background: #1a2226;
}
.skin-blue .sidebar-menu > li > a {
  border-left: 3px solid transparent;
}
.skin-blue .sidebar-menu > li:hover > a,
.skin-blue .sidebar-menu > li.active > a {
  color: #ffffff;
  background: #1e282c;
  border-left-color: #3c8dbc;
}
.skin-blue .sidebar-menu > li > .treeview-menu {
  margin: 0 1px;
  background: #2c3b41;
}
.skin-blue .sidebar a {
  color: #b8c7ce;
}
.skin-blue .sidebar a:hover {
  text-decoration: none;
}
.skin-blue .treeview-menu > li > a {
  color: #8aa4af;
}
.skin-blue .treeview-menu > li.active > a,
.skin-blue .treeview-menu > li > a:hover {
  color: #ffffff;
}
.skin-blue .sidebar-form {
  border-radius: 3px;
  border: 1px solid #374850;
  margin: 10px 10px;
}
.skin-blue .sidebar-form input[type="text"],
.skin-blue .sidebar-form .btn {
  box-shadow: none;
  background-color: #374850;
  border: 1px solid transparent;
  height: 35px;
}
.skin-blue .sidebar-form input[type="text"] {
  color: #666;
  border-top-left-radius: 2px;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 2px;
}
.skin-blue .sidebar-form input[type="text"]:focus,
.skin-blue .sidebar-form input[type="text"]:focus + .input-group-btn .btn {
  background-color: #fff;
  color: #666;
}
.skin-blue .sidebar-form input[type="text"]:focus + .input-group-btn .btn {
  border-left-color: #fff;
}
.skin-blue .sidebar-form .btn {
  color: #999;
  border-top-left-radius: 0;
  border-top-right-radius: 2px;
  border-bottom-right-radius: 2px;
  border-bottom-left-radius: 0;
}
.skin-blue.layout-top-nav .main-header > .logo {
  background-color: #3c8dbc;
  color: #ffffff;
  border-bottom: 0 solid transparent;
}
.skin-blue.layout-top-nav .main-header > .logo:hover {
  background-color: #3b8ab8;
}

```

`frontend/app/styles/vendors/AdminLTE.css`:

```css
@import url(AdminLTE-fonts.css);
/*!
 *   AdminLTE v2.3.7
 *   Author: Almsaeed Studio
 *	 Website: Almsaeed Studio <http://almsaeedstudio.com>
 *   License: Open source - MIT
 *           Please visit http://opensource.org/licenses/MIT for more information
!*/
/*
 * Core: General Layout Style
 * -------------------------
 */
html,
body {
  min-height: 100%;
}
.layout-boxed html,
.layout-boxed body {
  height: 100%;
}
body {
  /*-webkit-font-smoothing: antialiased;*/
  /*-moz-osx-font-smoothing: grayscale;*/
  font-family: 'Source Sans Pro', 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-weight: 400;
  overflow-x: hidden;
  overflow-y: auto;
}
/* Layout */
.wrapper {
  min-height: 100%;
  position: relative;
  overflow: hidden;
}
.wrapper:before,
.wrapper:after {
  content: " ";
  display: table;
}
.wrapper:after {
  clear: both;
}
.layout-boxed .wrapper {
  max-width: 1250px;
  margin: 0 auto;
  min-height: 100%;
  box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
  position: relative;
}
.layout-boxed {
  background: url('../img/boxed-bg.jpg') repeat fixed;
}
/*
 * Content Wrapper - contains the main content
 * ```.right-side has been deprecated as of v2.0.0 in favor of .content-wrapper  ```
 */
.content-wrapper,
.right-side,
.main-footer {
  -webkit-transition: -webkit-transform 0.3s ease-in-out, margin 0.3s ease-in-out;
  -moz-transition: -moz-transform 0.3s ease-in-out, margin 0.3s ease-in-out;
  -o-transition: -o-transform 0.3s ease-in-out, margin 0.3s ease-in-out;
  transition: transform 0.3s ease-in-out, margin 0.3s ease-in-out;
  margin-left: 230px;
  z-index: 820;
}
.layout-top-nav .content-wrapper,
.layout-top-nav .right-side,
.layout-top-nav .main-footer {
  margin-left: 0;
}
@media (max-width: 767px) {
  .content-wrapper,
  .right-side,
  .main-footer {
    margin-left: 0;
  }
}
@media (min-width: 768px) {
  .sidebar-collapse .content-wrapper,
  .sidebar-collapse .right-side,
  .sidebar-collapse .main-footer {
    margin-left: 0;
  }
}
@media (max-width: 767px) {
  .sidebar-open .content-wrapper,
  .sidebar-open .right-side,
  .sidebar-open .main-footer {
    -webkit-transform: translate(230px, 0);
    -ms-transform: translate(230px, 0);
    -o-transform: translate(230px, 0);
    transform: translate(230px, 0);
  }
}
.content-wrapper,
.right-side {
  min-height: 100%;
  background-color: #ecf0f5;
  z-index: 800;
}
.main-footer {
  background: #fff;
  padding: 15px;
  color: #444;
  border-top: 1px solid #d2d6de;
}
/* Fixed layout */
.fixed .main-header,
.fixed .main-sidebar,
.fixed .left-side {
  position: fixed;
}
.fixed .main-header {
  top: 0;
  right: 0;
  left: 0;
}
.fixed .content-wrapper,
.fixed .right-side {
  padding-top: 50px;
}
@media (max-width: 767px) {
  .fixed .content-wrapper,
  .fixed .right-side {
    padding-top: 100px;
  }
}
.fixed.layout-boxed .wrapper {
  max-width: 100%;
}
body.hold-transition .content-wrapper,
body.hold-transition .right-side,
body.hold-transition .main-footer,
body.hold-transition .main-sidebar,
body.hold-transition .left-side,
body.hold-transition .main-header .navbar,
body.hold-transition .main-header .logo {
  /* Fix for IE */
  -webkit-transition: none;
  -o-transition: none;
  transition: none;
}
/* Content */
.content {
  min-height: 250px;
  padding: 15px;
  margin-right: auto;
  margin-left: auto;
  padding-left: 15px;
  padding-right: 15px;
}
/* H1 - H6 font */
h1,
h2,
h3,
h4,
h5,
h6,
.h1,
.h2,
.h3,
.h4,
.h5,
.h6 {
  font-family: 'Source Sans Pro', sans-serif;
}
/* General Links */
a {
  color: #3c8dbc;
}
a:hover,
a:active,
a:focus {
  outline: none;
  text-decoration: none;
  color: #72afd2;
}
/* Page Header */
.page-header {
  margin: 10px 0 20px 0;
  font-size: 22px;
}
.page-header > small {
  color: #666;
  display: block;
  margin-top: 5px;
}
/*
 * Component: Main Header
 * ----------------------
 */
.main-header {
  position: relative;
  max-height: 100px;
  z-index: 1030;
}
.main-header .navbar {
  -webkit-transition: margin-left 0.3s ease-in-out;
  -o-transition: margin-left 0.3s ease-in-out;
  transition: margin-left 0.3s ease-in-out;
  margin-bottom: 0;
  margin-left: 230px;
  border: none;
  min-height: 50px;
  border-radius: 0;
}
.layout-top-nav .main-header .navbar {
  margin-left: 0;
}
.main-header #navbar-search-input.form-control {
  background: rgba(255, 255, 255, 0.2);
  border-color: transparent;
}
.main-header #navbar-search-input.form-control:focus,
.main-header #navbar-search-input.form-control:active {
  border-color: rgba(0, 0, 0, 0.1);
  background: rgba(255, 255, 255, 0.9);
}
.main-header #navbar-search-input.form-control::-moz-placeholder {
  color: #ccc;
  opacity: 1;
}
.main-header #navbar-search-input.form-control:-ms-input-placeholder {
  color: #ccc;
}
.main-header #navbar-search-input.form-control::-webkit-input-placeholder {
  color: #ccc;
}
.main-header .navbar-custom-menu,
.main-header .navbar-right {
  float: right;
}
@media (max-width: 991px) {
  .main-header .navbar-custom-menu a,
  .main-header .navbar-right a {
    color: inherit;
    background: transparent;
  }
}
@media (max-width: 767px) {
  .main-header .navbar-right {
    float: none;
  }
  .navbar-collapse .main-header .navbar-right {
    margin: 7.5px -15px;
  }
  .main-header .navbar-right > li {
    color: inherit;
    border: 0;
  }
}
.main-header .sidebar-toggle {
  float: left;
  background-color: transparent;
  background-image: none;
  padding: 15px 15px;
  font-family: fontAwesome;
}
.main-header .sidebar-toggle:before {
  content: "\f0c9";
}
.main-header .sidebar-toggle:hover {
  color: #fff;
}
.main-header .sidebar-toggle:focus,
.main-header .sidebar-toggle:active {
  background: transparent;
}
.main-header .sidebar-toggle .icon-bar {
  display: none;
}
.main-header .navbar .nav > li.user > a > .fa,
.main-header .navbar .nav > li.user > a > .glyphicon,
.main-header .navbar .nav > li.user > a > .ion {
  margin-right: 5px;
}
.main-header .navbar .nav > li > a > .label {
  position: absolute;
  top: 9px;
  right: 7px;
  text-align: center;
  font-size: 9px;
  padding: 2px 3px;
  line-height: .9;
}
.main-header .logo {
  -webkit-transition: width 0.3s ease-in-out;
  -o-transition: width 0.3s ease-in-out;
  transition: width 0.3s ease-in-out;
  display: block;
  float: left;
  height: 50px;
  font-size: 20px;
  line-height: 50px;
  text-align: center;
  width: 230px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  padding: 0 15px;
  font-weight: 300;
  overflow: hidden;
}
.main-header .logo .logo-lg {
  display: block;
}
.main-header .logo .logo-mini {
  display: none;
}
.main-header .navbar-brand {
  color: #fff;
}
.content-header {
  position: relative;
  padding: 15px 15px 0 15px;
}
.content-header > h1 {
  margin: 0;
  font-size: 24px;
}
.content-header > h1 > small {
  font-size: 15px;
  display: inline-block;
  padding-left: 4px;
  font-weight: 300;
}
.content-header > .breadcrumb {
  float: right;
  background: transparent;
  margin-top: 0;
  margin-bottom: 0;
  font-size: 12px;
  padding: 7px 5px;
  position: absolute;
  top: 15px;
  right: 10px;
  border-radius: 2px;
}
.content-header > .breadcrumb > li > a {
  color: #444;
  text-decoration: none;
  display: inline-block;
}
.content-header > .breadcrumb > li > a > .fa,
.content-header > .breadcrumb > li > a > .glyphicon,
.content-header > .breadcrumb > li > a > .ion {
  margin-right: 5px;
}
.content-header > .breadcrumb > li + li:before {
  content: '>\00a0';
}
@media (max-width: 991px) {
  .content-header > .breadcrumb {
    position: relative;
    margin-top: 5px;
    top: 0;
    right: 0;
    float: none;
    background: #d2d6de;
    padding-left: 10px;
  }
  .content-header > .breadcrumb li:before {
    color: #97a0b3;
  }
}
.navbar-toggle {
  color: #fff;
  border: 0;
  margin: 0;
  padding: 15px 15px;
}
@media (max-width: 991px) {
  .navbar-custom-menu .navbar-nav > li {
    float: left;
  }
  .navbar-custom-menu .navbar-nav {
    margin: 0;
    float: left;
  }
  .navbar-custom-menu .navbar-nav > li > a {
    padding-top: 15px;
    padding-bottom: 15px;
    line-height: 20px;
  }
}
@media (max-width: 767px) {
  .main-header {
    position: relative;
  }
  .main-header .logo,
  .main-header .navbar {
    width: 100%;
    float: none;
  }
  .main-header .navbar {
    margin: 0;
  }
  .main-header .navbar-custom-menu {
    float: right;
  }
}
@media (max-width: 991px) {
  .navbar-collapse.pull-left {
    float: none !important;
  }
  .navbar-collapse.pull-left + .navbar-custom-menu {
    display: block;
    position: absolute;
    top: 0;
    right: 40px;
  }
}
/*
 * Component: Sidebar
 * ------------------
 */
.main-sidebar,
.left-side {
  position: absolute;
  top: 0;
  left: 0;
  padding-top: 50px;
  min-height: 100%;
  width: 230px;
  z-index: 810;
  -webkit-transition: -webkit-transform 0.3s ease-in-out, width 0.3s ease-in-out;
  -moz-transition: -moz-transform 0.3s ease-in-out, width 0.3s ease-in-out;
  -o-transition: -o-transform 0.3s ease-in-out, width 0.3s ease-in-out;
  transition: transform 0.3s ease-in-out, width 0.3s ease-in-out;
}
@media (max-width: 767px) {
  .main-sidebar,
  .left-side {
    padding-top: 100px;
  }
}
@media (max-width: 767px) {
  .main-sidebar,
  .left-side {
    -webkit-transform: translate(-230px, 0);
    -ms-transform: translate(-230px, 0);
    -o-transform: translate(-230px, 0);
    transform: translate(-230px, 0);
  }
}
@media (min-width: 768px) {
  .sidebar-collapse .main-sidebar,
  .sidebar-collapse .left-side {
    -webkit-transform: translate(-230px, 0);
    -ms-transform: translate(-230px, 0);
    -o-transform: translate(-230px, 0);
    transform: translate(-230px, 0);
  }
}
@media (max-width: 767px) {
  .sidebar-open .main-sidebar,
  .sidebar-open .left-side {
    -webkit-transform: translate(0, 0);
    -ms-transform: translate(0, 0);
    -o-transform: translate(0, 0);
    transform: translate(0, 0);
  }
}
.sidebar {
  padding-bottom: 10px;
}
.sidebar-form input:focus {
  border-color: transparent;
}
.user-panel {
  position: relative;
  width: 100%;
  padding: 10px;
  overflow: hidden;
}
.user-panel:before,
.user-panel:after {
  content: " ";
  display: table;
}
.user-panel:after {
  clear: both;
}
.user-panel > .image > img {
  width: 100%;
  max-width: 45px;
  height: auto;
}
.user-panel > .info {
  padding: 5px 5px 5px 15px;
  line-height: 1;
  position: absolute;
  left: 55px;
}
.user-panel > .info > p {
  font-weight: 600;
  margin-bottom: 9px;
}
.user-panel > .info > a {
  text-decoration: none;
  padding-right: 5px;
  margin-top: 3px;
  font-size: 11px;
}
.user-panel > .info > a > .fa,
.user-panel > .info > a > .ion,
.user-panel > .info > a > .glyphicon {
  margin-right: 3px;
}
.sidebar-menu {
  list-style: none;
  margin: 0;
  padding: 0;
}
.sidebar-menu > li {
  position: relative;
  margin: 0;
  padding: 0;
}
.sidebar-menu > li > a {
  padding: 12px 5px 12px 15px;
  display: block;
}
.sidebar-menu > li > a > .fa,
.sidebar-menu > li > a > .glyphicon,
.sidebar-menu > li > a > .ion {
  width: 20px;
}
.sidebar-menu > li .label,
.sidebar-menu > li .badge {
  margin-right: 5px;
}
.sidebar-menu > li .badge {
  margin-top: 3px;
}
.sidebar-menu li.header {
  padding: 10px 25px 10px 15px;
  font-size: 12px;
}
.sidebar-menu li > a > .fa-angle-left,
.sidebar-menu li > a > .pull-right-container > .fa-angle-left {
  width: auto;
  height: auto;
  padding: 0;
  margin-right: 10px;
}
.sidebar-menu li.active > a > .fa-angle-left,
.sidebar-menu li.active > a > .pull-right-container > .fa-angle-left {
  -webkit-transform: rotate(-90deg);
  -ms-transform: rotate(-90deg);
  -o-transform: rotate(-90deg);
  transform: rotate(-90deg);
}
.sidebar-menu li.active > .treeview-menu {
  display: block;
}
.sidebar-menu .treeview-menu {
  display: none;
  list-style: none;
  padding: 0;
  margin: 0;
  padding-left: 5px;
}
.sidebar-menu .treeview-menu .treeview-menu {
  padding-left: 20px;
}
.sidebar-menu .treeview-menu > li {
  margin: 0;
}
.sidebar-menu .treeview-menu > li > a {
  padding: 5px 5px 5px 15px;
  display: block;
  font-size: 14px;
}
.sidebar-menu .treeview-menu > li > a > .fa,
.sidebar-menu .treeview-menu > li > a > .glyphicon,
.sidebar-menu .treeview-menu > li > a > .ion {
  width: 20px;
}
.sidebar-menu .treeview-menu > li > a > .pull-right-container > .fa-angle-left,
.sidebar-menu .treeview-menu > li > a > .pull-right-container > .fa-angle-down,
.sidebar-menu .treeview-menu > li > a > .fa-angle-left,
.sidebar-menu .treeview-menu > li > a > .fa-angle-down {
  width: auto;
}
/*
 * Component: Sidebar Mini
 */
@media (min-width: 768px) {
  .sidebar-mini.sidebar-collapse .content-wrapper,
  .sidebar-mini.sidebar-collapse .right-side,
  .sidebar-mini.sidebar-collapse .main-footer {
    margin-left: 50px !important;
    z-index: 840;
  }
  .sidebar-mini.sidebar-collapse .main-sidebar {
    -webkit-transform: translate(0, 0);
    -ms-transform: translate(0, 0);
    -o-transform: translate(0, 0);
    transform: translate(0, 0);
    width: 50px !important;
    z-index: 850;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li {
    position: relative;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li > a {
    margin-right: 0;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li > a > span {
    border-top-right-radius: 4px;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li:not(.treeview) > a > span {
    border-bottom-right-radius: 4px;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li > .treeview-menu {
    padding-top: 5px;
    padding-bottom: 5px;
    border-bottom-right-radius: 4px;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li:hover > a > span:not(.pull-right),
  .sidebar-mini.sidebar-collapse .sidebar-menu > li:hover > .treeview-menu {
    display: block !important;
    position: absolute;
    width: 180px;
    left: 50px;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li:hover > a > span {
    top: 0;
    margin-left: -3px;
    padding: 12px 5px 12px 20px;
    background-color: inherit;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li:hover > a > .pull-right-container {
    float: right;
    width: auto!important;
    left: 200px!important;
    top: 10px!important;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li:hover > a > .pull-right-container > .label:not(:first-of-type) {
    display: none;
  }
  .sidebar-mini.sidebar-collapse .sidebar-menu > li:hover > .treeview-menu {
    top: 44px;
    margin-left: 0;
  }
  .sidebar-mini.sidebar-collapse .main-sidebar .user-panel > .info,
  .sidebar-mini.sidebar-collapse .sidebar-form,
  .sidebar-mini.sidebar-collapse .sidebar-menu > li > a > span,
  .sidebar-mini.sidebar-collapse .sidebar-menu > li > .treeview-menu,
  .sidebar-mini.sidebar-collapse .sidebar-menu > li > a > .pull-right,
  .sidebar-mini.sidebar-collapse .sidebar-menu li.header {
    display: none !important;
    -webkit-transform: translateZ(0);
  }
  .sidebar-mini.sidebar-collapse .main-header .logo {
    width: 50px;
  }
  .sidebar-mini.sidebar-collapse .main-header .logo > .logo-mini {
    display: block;
    margin-left: -15px;
    margin-right: -15px;
    font-size: 18px;
  }
  .sidebar-mini.sidebar-collapse .main-header .logo > .logo-lg {
    display: none;
  }
  .sidebar-mini.sidebar-collapse .main-header .navbar {
    margin-left: 50px;
  }
}
.sidebar-menu,
.main-sidebar .user-panel,
.sidebar-menu > li.header {
  white-space: nowrap;
  overflow: hidden;
}
.sidebar-menu:hover {
  overflow: visible;
}
.sidebar-form,
.sidebar-menu > li.header {
  overflow: hidden;
  text-overflow: clip;
}
.sidebar-menu li > a {
  position: relative;
}
.sidebar-menu li > a > .pull-right-container {
  position: absolute;
  right: 10px;
  top: 50%;
  margin-top: -7px;
}
/*
 * Component: Control sidebar. By default, this is the right sidebar.
 */
.control-sidebar-bg {
  position: fixed;
  z-index: 1000;
  bottom: 0;
}
.control-sidebar-bg,
.control-sidebar {
  top: 0;
  right: -230px;
  width: 230px;
  -webkit-transition: right 0.3s ease-in-out;
  -o-transition: right 0.3s ease-in-out;
  transition: right 0.3s ease-in-out;
}
.control-sidebar {
  position: absolute;
  padding-top: 50px;
  z-index: 1010;
}
@media (max-width: 768px) {
  .control-sidebar {
    padding-top: 100px;
  }
}
.control-sidebar > .tab-content {
  padding: 10px 15px;
}
.control-sidebar.control-sidebar-open,
.control-sidebar.control-sidebar-open + .control-sidebar-bg {
  right: 0;
}
.control-sidebar-open .control-sidebar-bg,
.control-sidebar-open .control-sidebar {
  right: 0;
}
@media (min-width: 768px) {
  .control-sidebar-open .content-wrapper,
  .control-sidebar-open .right-side,
  .control-sidebar-open .main-footer {
    margin-right: 230px;
  }
}
.nav-tabs.control-sidebar-tabs > li:first-of-type > a,
.nav-tabs.control-sidebar-tabs > li:first-of-type > a:hover,
.nav-tabs.control-sidebar-tabs > li:first-of-type > a:focus {
  border-left-width: 0;
}
.nav-tabs.control-sidebar-tabs > li > a {
  border-radius: 0;
}
.nav-tabs.control-sidebar-tabs > li > a,
.nav-tabs.control-sidebar-tabs > li > a:hover {
  border-top: none;
  border-right: none;
  border-left: 1px solid transparent;
  border-bottom: 1px solid transparent;
}
.nav-tabs.control-sidebar-tabs > li > a .icon {
  font-size: 16px;
}
.nav-tabs.control-sidebar-tabs > li.active > a,
.nav-tabs.control-sidebar-tabs > li.active > a:hover,
.nav-tabs.control-sidebar-tabs > li.active > a:focus,
.nav-tabs.control-sidebar-tabs > li.active > a:active {
  border-top: none;
  border-right: none;
  border-bottom: none;
}
@media (max-width: 768px) {
  .nav-tabs.control-sidebar-tabs {
    display: table;
  }
  .nav-tabs.control-sidebar-tabs > li {
    display: table-cell;
  }
}
.control-sidebar-heading {
  font-weight: 400;
  font-size: 16px;
  padding: 10px 0;
  margin-bottom: 10px;
}
.control-sidebar-subheading {
  display: block;
  font-weight: 400;
  font-size: 14px;
}
.control-sidebar-menu {
  list-style: none;
  padding: 0;
  margin: 0 -15px;
}
.control-sidebar-menu > li > a {
  display: block;
  padding: 10px 15px;
}
.control-sidebar-menu > li > a:before,
.control-sidebar-menu > li > a:after {
  content: " ";
  display: table;
}
.control-sidebar-menu > li > a:after {
  clear: both;
}
.control-sidebar-menu > li > a > .control-sidebar-subheading {
  margin-top: 0;
}
.control-sidebar-menu .menu-icon {
  float: left;
  width: 35px;
  height: 35px;
  border-radius: 50%;
  text-align: center;
  line-height: 35px;
}
.control-sidebar-menu .menu-info {
  margin-left: 45px;
  margin-top: 3px;
}
.control-sidebar-menu .menu-info > .control-sidebar-subheading {
  margin: 0;
}
.control-sidebar-menu .menu-info > p {
  margin: 0;
  font-size: 11px;
}
.control-sidebar-menu .progress {
  margin: 0;
}
.control-sidebar-dark {
  color: #b8c7ce;
}
.control-sidebar-dark,
.control-sidebar-dark + .control-sidebar-bg {
  background: #222d32;
}
.control-sidebar-dark .nav-tabs.control-sidebar-tabs {
  border-bottom: #1c2529;
}
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li > a {
  background: #181f23;
  color: #b8c7ce;
}
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li > a,
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li > a:hover,
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li > a:focus {
  border-left-color: #141a1d;
  border-bottom-color: #141a1d;
}
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li > a:hover,
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li > a:focus,
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li > a:active {
  background: #1c2529;
}
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li > a:hover {
  color: #fff;
}
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li.active > a,
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li.active > a:hover,
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li.active > a:focus,
.control-sidebar-dark .nav-tabs.control-sidebar-tabs > li.active > a:active {
  background: #222d32;
  color: #fff;
}
.control-sidebar-dark .control-sidebar-heading,
.control-sidebar-dark .control-sidebar-subheading {
  color: #fff;
}
.control-sidebar-dark .control-sidebar-menu > li > a:hover {
  background: #1e282c;
}
.control-sidebar-dark .control-sidebar-menu > li > a .menu-info > p {
  color: #b8c7ce;
}
.control-sidebar-light {
  color: #5e5e5e;
}
.control-sidebar-light,
.control-sidebar-light + .control-sidebar-bg {
  background: #f9fafc;
  border-left: 1px solid #d2d6de;
}
.control-sidebar-light .nav-tabs.control-sidebar-tabs {
  border-bottom: #d2d6de;
}
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li > a {
  background: #e8ecf4;
  color: #444444;
}
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li > a,
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li > a:hover,
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li > a:focus {
  border-left-color: #d2d6de;
  border-bottom-color: #d2d6de;
}
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li > a:hover,
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li > a:focus,
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li > a:active {
  background: #eff1f7;
}
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li.active > a,
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li.active > a:hover,
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li.active > a:focus,
.control-sidebar-light .nav-tabs.control-sidebar-tabs > li.active > a:active {
  background: #f9fafc;
  color: #111;
}
.control-sidebar-light .control-sidebar-heading,
.control-sidebar-light .control-sidebar-subheading {
  color: #111;
}
.control-sidebar-light .control-sidebar-menu {
  margin-left: -14px;
}
.control-sidebar-light .control-sidebar-menu > li > a:hover {
  background: #f4f4f5;
}
.control-sidebar-light .control-sidebar-menu > li > a .menu-info > p {
  color: #5e5e5e;
}
/*
 * Component: Dropdown menus
 * -------------------------
 */
/*Dropdowns in general*/
.dropdown-menu {
  box-shadow: none;
  border-color: #eee;
}
.dropdown-menu > li > a {
  color: #777;
}
.dropdown-menu > li > a > .glyphicon,
.dropdown-menu > li > a > .fa,
.dropdown-menu > li > a > .ion {
  margin-right: 10px;
}
.dropdown-menu > li > a:hover {
  background-color: #e1e3e9;
  color: #333;
}
.dropdown-menu > .divider {
  background-color: #eee;
}
.navbar-nav > .notifications-menu > .dropdown-menu,
.navbar-nav > .messages-menu > .dropdown-menu,
.navbar-nav > .tasks-menu > .dropdown-menu {
  width: 280px;
  padding: 0 0 0 0;
  margin: 0;
  top: 100%;
}
.navbar-nav > .notifications-menu > .dropdown-menu > li,
.navbar-nav > .messages-menu > .dropdown-menu > li,
.navbar-nav > .tasks-menu > .dropdown-menu > li {
  position: relative;
}
.navbar-nav > .notifications-menu > .dropdown-menu > li.header,
.navbar-nav > .messages-menu > .dropdown-menu > li.header,
.navbar-nav > .tasks-menu > .dropdown-menu > li.header {
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
  background-color: #ffffff;
  padding: 7px 10px;
  border-bottom: 1px solid #f4f4f4;
  color: #444444;
  font-size: 14px;
}
.navbar-nav > .notifications-menu > .dropdown-menu > li.footer > a,
.navbar-nav > .messages-menu > .dropdown-menu > li.footer > a,
.navbar-nav > .tasks-menu > .dropdown-menu > li.footer > a {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  border-bottom-right-radius: 4px;
  border-bottom-left-radius: 4px;
  font-size: 12px;
  background-color: #fff;
  padding: 7px 10px;
  border-bottom: 1px solid #eeeeee;
  color: #444 !important;
  text-align: center;
}
@media (max-width: 991px) {
  .navbar-nav > .notifications-menu > .dropdown-menu > li.footer > a,
  .navbar-nav > .messages-menu > .dropdown-menu > li.footer > a,
  .navbar-nav > .tasks-menu > .dropdown-menu > li.footer > a {
    background: #fff !important;
    color: #444 !important;
  }
}
.navbar-nav > .notifications-menu > .dropdown-menu > li.footer > a:hover,
.navbar-nav > .messages-menu > .dropdown-menu > li.footer > a:hover,
.navbar-nav > .tasks-menu > .dropdown-menu > li.footer > a:hover {
  text-decoration: none;
  font-weight: normal;
}
.navbar-nav > .notifications-menu > .dropdown-menu > li .menu,
.navbar-nav > .messages-menu > .dropdown-menu > li .menu,
.navbar-nav > .tasks-menu > .dropdown-menu > li .menu {
  max-height: 200px;
  margin: 0;
  padding: 0;
  list-style: none;
  overflow-x: hidden;
}
.navbar-nav > .notifications-menu > .dropdown-menu > li .menu > li > a,
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a,
.navbar-nav > .tasks-menu > .dropdown-menu > li .menu > li > a {
  display: block;
  white-space: nowrap;
  /* Prevent text from breaking */
  border-bottom: 1px solid #f4f4f4;
}
.navbar-nav > .notifications-menu > .dropdown-menu > li .menu > li > a:hover,
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a:hover,
.navbar-nav > .tasks-menu > .dropdown-menu > li .menu > li > a:hover {
  background: #f4f4f4;
  text-decoration: none;
}
.navbar-nav > .notifications-menu > .dropdown-menu > li .menu > li > a {
  color: #444444;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 10px;
}
.navbar-nav > .notifications-menu > .dropdown-menu > li .menu > li > a > .glyphicon,
.navbar-nav > .notifications-menu > .dropdown-menu > li .menu > li > a > .fa,
.navbar-nav > .notifications-menu > .dropdown-menu > li .menu > li > a > .ion {
  width: 20px;
}
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a {
  margin: 0;
  padding: 10px 10px;
}
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a > div > img {
  margin: auto 10px auto auto;
  width: 40px;
  height: 40px;
}
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a > h4 {
  padding: 0;
  margin: 0 0 0 45px;
  color: #444444;
  font-size: 15px;
  position: relative;
}
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a > h4 > small {
  color: #999999;
  font-size: 10px;
  position: absolute;
  top: 0;
  right: 0;
}
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a > p {
  margin: 0 0 0 45px;
  font-size: 12px;
  color: #888888;
}
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a:before,
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a:after {
  content: " ";
  display: table;
}
.navbar-nav > .messages-menu > .dropdown-menu > li .menu > li > a:after {
  clear: both;
}
.navbar-nav > .tasks-menu > .dropdown-menu > li .menu > li > a {
  padding: 10px;
}
.navbar-nav > .tasks-menu > .dropdown-menu > li .menu > li > a > h3 {
  font-size: 14px;
  padding: 0;
  margin: 0 0 10px 0;
  color: #666666;
}
.navbar-nav > .tasks-menu > .dropdown-menu > li .menu > li > a > .progress {
  padding: 0;
  margin: 0;
}
.navbar-nav > .user-menu > .dropdown-menu {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
  padding: 1px 0 0 0;
  border-top-width: 0;
  width: 280px;
}
.navbar-nav > .user-menu > .dropdown-menu,
.navbar-nav > .user-menu > .dropdown-menu > .user-body {
  border-bottom-right-radius: 4px;
  border-bottom-left-radius: 4px;
}
.navbar-nav > .user-menu > .dropdown-menu > li.user-header {
  height: 175px;
  padding: 10px;
  text-align: center;
}
.navbar-nav > .user-menu > .dropdown-menu > li.user-header > img {
  z-index: 5;
  height: 90px;
  width: 90px;
  border: 3px solid;
  border-color: transparent;
  border-color: rgba(255, 255, 255, 0.2);
}
.navbar-nav > .user-menu > .dropdown-menu > li.user-header > p {
  z-index: 5;
  color: #fff;
  color: rgba(255, 255, 255, 0.8);
  font-size: 17px;
  margin-top: 10px;
}
.navbar-nav > .user-menu > .dropdown-menu > li.user-header > p > small {
  display: block;
  font-size: 12px;
}
.navbar-nav > .user-menu > .dropdown-menu > .user-body {
  padding: 15px;
  border-bottom: 1px solid #f4f4f4;
  border-top: 1px solid #dddddd;
}
.navbar-nav > .user-menu > .dropdown-menu > .user-body:before,
.navbar-nav > .user-menu > .dropdown-menu > .user-body:after {
  content: " ";
  display: table;
}
.navbar-nav > .user-menu > .dropdown-menu > .user-body:after {
  clear: both;
}
.navbar-nav > .user-menu > .dropdown-menu > .user-body a {
  color: #444 !important;
}
@media (max-width: 991px) {
  .navbar-nav > .user-menu > .dropdown-menu > .user-body a {
    background: #fff !important;
    color: #444 !important;
  }
}
.navbar-nav > .user-menu > .dropdown-menu > .user-footer {
  background-color: #f9f9f9;
  padding: 10px;
}
.navbar-nav > .user-menu > .dropdown-menu > .user-footer:before,
.navbar-nav > .user-menu > .dropdown-menu > .user-footer:after {
  content: " ";
  display: table;
}
.navbar-nav > .user-menu > .dropdown-menu > .user-footer:after {
  clear: both;
}
.navbar-nav > .user-menu > .dropdown-menu > .user-footer .btn-default {
  color: #666666;
}
@media (max-width: 991px) {
  .navbar-nav > .user-menu > .dropdown-menu > .user-footer .btn-default:hover {
    background-color: #f9f9f9;
  }
}
.navbar-nav > .user-menu .user-image {
  float: left;
  width: 25px;
  height: 25px;
  border-radius: 50%;
  margin-right: 10px;
  margin-top: -2px;
}
@media (max-width: 767px) {
  .navbar-nav > .user-menu .user-image {
    float: none;
    margin-right: 0;
    margin-top: -8px;
    line-height: 10px;
  }
}
/* Add fade animation to dropdown menus by appending
 the class .animated-dropdown-menu to the .dropdown-menu ul (or ol)*/
.open:not(.dropup) > .animated-dropdown-menu {
  backface-visibility: visible !important;
  -webkit-animation: flipInX 0.7s both;
  -o-animation: flipInX 0.7s both;
  animation: flipInX 0.7s both;
}
@keyframes flipInX {
  0% {
    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    transition-timing-function: ease-in;
    opacity: 0;
  }
  40% {
    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    transition-timing-function: ease-in;
  }
  60% {
    transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
    opacity: 1;
  }
  80% {
    transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
  }
  100% {
    transform: perspective(400px);
  }
}
@-webkit-keyframes flipInX {
  0% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    -webkit-transition-timing-function: ease-in;
    opacity: 0;
  }
  40% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    -webkit-transition-timing-function: ease-in;
  }
  60% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
    opacity: 1;
  }
  80% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
  }
  100% {
    -webkit-transform: perspective(400px);
  }
}
/* Fix dropdown menu in navbars */
.navbar-custom-menu > .navbar-nav > li {
  position: relative;
}
.navbar-custom-menu > .navbar-nav > li > .dropdown-menu {
  position: absolute;
  right: 0;
  left: auto;
}
@media (max-width: 991px) {
  .navbar-custom-menu > .navbar-nav {
    float: right;
  }
  .navbar-custom-menu > .navbar-nav > li {
    position: static;
  }
  .navbar-custom-menu > .navbar-nav > li > .dropdown-menu {
    position: absolute;
    right: 5%;
    left: auto;
    border: 1px solid #ddd;
    background: #fff;
  }
}
/*
 * Component: Form
 * ---------------
 */
.form-control {
  border-radius: 0;
  box-shadow: none;
  border-color: #d2d6de;
}
.form-control:focus {
  border-color: #3c8dbc;
  box-shadow: none;
}
.form-control::-moz-placeholder,
.form-control:-ms-input-placeholder,
.form-control::-webkit-input-placeholder {
  color: #bbb;
  opacity: 1;
}
.form-control:not(select) {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}
.form-group.has-success label {
  color: #00a65a;
}
.form-group.has-success .form-control,
.form-group.has-success .input-group-addon {
  border-color: #00a65a;
  box-shadow: none;
}
.form-group.has-success .help-block {
  color: #00a65a;
}
.form-group.has-warning label {
  color: #f39c12;
}
.form-group.has-warning .form-control,
.form-group.has-warning .input-group-addon {
  border-color: #f39c12;
  box-shadow: none;
}
.form-group.has-warning .help-block {
  color: #f39c12;
}
.form-group.has-error label {
  color: #dd4b39;
}
.form-group.has-error .form-control,
.form-group.has-error .input-group-addon {
  border-color: #dd4b39;
  box-shadow: none;
}
.form-group.has-error .help-block {
  color: #dd4b39;
}
/* Input group */
.input-group .input-group-addon {
  border-radius: 0;
  border-color: #d2d6de;
  background-color: #fff;
}
/* button groups */
.btn-group-vertical .btn.btn-flat:first-of-type,
.btn-group-vertical .btn.btn-flat:last-of-type {
  border-radius: 0;
}
.icheck > label {
  padding-left: 0;
}
/* support Font Awesome icons in form-control */
.form-control-feedback.fa {
  line-height: 34px;
}
.input-lg + .form-control-feedback.fa,
.input-group-lg + .form-control-feedback.fa,
.form-group-lg .form-control + .form-control-feedback.fa {
  line-height: 46px;
}
.input-sm + .form-control-feedback.fa,
.input-group-sm + .form-control-feedback.fa,
.form-group-sm .form-control + .form-control-feedback.fa {
  line-height: 30px;
}
/*
 * Component: Progress Bar
 * -----------------------
 */
.progress,
.progress > .progress-bar {
  -webkit-box-shadow: none;
  box-shadow: none;
}
.progress,
.progress > .progress-bar,
.progress .progress-bar,
.progress > .progress-bar .progress-bar {
  border-radius: 1px;
}
/* size variation */
.progress.sm,
.progress-sm {
  height: 10px;
}
.progress.sm,
.progress-sm,
.progress.sm .progress-bar,
.progress-sm .progress-bar {
  border-radius: 1px;
}
.progress.xs,
.progress-xs {
  height: 7px;
}
.progress.xs,
.progress-xs,
.progress.xs .progress-bar,
.progress-xs .progress-bar {
  border-radius: 1px;
}
.progress.xxs,
.progress-xxs {
  height: 3px;
}
.progress.xxs,
.progress-xxs,
.progress.xxs .progress-bar,
.progress-xxs .progress-bar {
  border-radius: 1px;
}
/* Vertical bars */
.progress.vertical {
  position: relative;
  width: 30px;
  height: 200px;
  display: inline-block;
  margin-right: 10px;
}
.progress.vertical > .progress-bar {
  width: 100%;
  position: absolute;
  bottom: 0;
}
.progress.vertical.sm,
.progress.vertical.progress-sm {
  width: 20px;
}
.progress.vertical.xs,
.progress.vertical.progress-xs {
  width: 10px;
}
.progress.vertical.xxs,
.progress.vertical.progress-xxs {
  width: 3px;
}
.progress-group .progress-text {
  font-weight: 600;
}
.progress-group .progress-number {
  float: right;
}
/* Remove margins from progress bars when put in a table */
.table tr > td .progress {
  margin: 0;
}
.progress-bar-light-blue,
.progress-bar-primary {
  background-color: #3c8dbc;
}
.progress-striped .progress-bar-light-blue,
.progress-striped .progress-bar-primary {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-green,
.progress-bar-success {
  background-color: #00a65a;
}
.progress-striped .progress-bar-green,
.progress-striped .progress-bar-success {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-aqua,
.progress-bar-info {
  background-color: #00c0ef;
}
.progress-striped .progress-bar-aqua,
.progress-striped .progress-bar-info {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-yellow,
.progress-bar-warning {
  background-color: #f39c12;
}
.progress-striped .progress-bar-yellow,
.progress-striped .progress-bar-warning {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-red,
.progress-bar-danger {
  background-color: #dd4b39;
}
.progress-striped .progress-bar-red,
.progress-striped .progress-bar-danger {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
/*
 * Component: Small Box
 * --------------------
 */
.small-box {
  border-radius: 2px;
  position: relative;
  display: block;
  margin-bottom: 20px;
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
}
.small-box > .inner {
  padding: 10px;
}
.small-box > .small-box-footer {
  position: relative;
  text-align: center;
  padding: 3px 0;
  color: #fff;
  color: rgba(255, 255, 255, 0.8);
  display: block;
  z-index: 10;
  background: rgba(0, 0, 0, 0.1);
  text-decoration: none;
}
.small-box > .small-box-footer:hover {
  color: #fff;
  background: rgba(0, 0, 0, 0.15);
}
.small-box h3 {
  font-size: 38px;
  font-weight: bold;
  margin: 0 0 10px 0;
  white-space: nowrap;
  padding: 0;
}
.small-box p {
  font-size: 15px;
}
.small-box p > small {
  display: block;
  color: #f9f9f9;
  font-size: 13px;
  margin-top: 5px;
}
.small-box h3,
.small-box p {
  z-index: 5;
}
.small-box .icon {
  -webkit-transition: all 0.3s linear;
  -o-transition: all 0.3s linear;
  transition: all 0.3s linear;
  position: absolute;
  top: -10px;
  right: 10px;
  z-index: 0;
  font-size: 90px;
  color: rgba(0, 0, 0, 0.15);
}
.small-box:hover {
  text-decoration: none;
  color: #f9f9f9;
}
.small-box:hover .icon {
  font-size: 95px;
}
@media (max-width: 767px) {
  .small-box {
    text-align: center;
  }
  .small-box .icon {
    display: none;
  }
  .small-box p {
    font-size: 12px;
  }
}
/*
 * Component: Box
 * --------------
 */
.box {
  position: relative;
  border-radius: 3px;
  background: #ffffff;
  border-top: 3px solid #d2d6de;
  margin-bottom: 20px;
  width: 100%;
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
}
.box.box-primary {
  border-top-color: #3c8dbc;
}
.box.box-info {
  border-top-color: #00c0ef;
}
.box.box-danger {
  border-top-color: #dd4b39;
}
.box.box-warning {
  border-top-color: #f39c12;
}
.box.box-success {
  border-top-color: #00a65a;
}
.box.box-default {
  border-top-color: #d2d6de;
}
.box.collapsed-box .box-body,
.box.collapsed-box .box-footer {
  display: none;
}
.box .nav-stacked > li {
  border-bottom: 1px solid #f4f4f4;
  margin: 0;
}
.box .nav-stacked > li:last-of-type {
  border-bottom: none;
}
.box.height-control .box-body {
  max-height: 300px;
  overflow: auto;
}
.box .border-right {
  border-right: 1px solid #f4f4f4;
}
.box .border-left {
  border-left: 1px solid #f4f4f4;
}
.box.box-solid {
  border-top: 0;
}
.box.box-solid > .box-header .btn.btn-default {
  background: transparent;
}
.box.box-solid > .box-header .btn:hover,
.box.box-solid > .box-header a:hover {
  background: rgba(0, 0, 0, 0.1);
}
.box.box-solid.box-default {
  border: 1px solid #d2d6de;
}
.box.box-solid.box-default > .box-header {
  color: #444444;
  background: #d2d6de;
  background-color: #d2d6de;
}
.box.box-solid.box-default > .box-header a,
.box.box-solid.box-default > .box-header .btn {
  color: #444444;
}
.box.box-solid.box-primary {
  border: 1px solid #3c8dbc;
}
.box.box-solid.box-primary > .box-header {
  color: #ffffff;
  background: #3c8dbc;
  background-color: #3c8dbc;
}
.box.box-solid.box-primary > .box-header a,
.box.box-solid.box-primary > .box-header .btn {
  color: #ffffff;
}
.box.box-solid.box-info {
  border: 1px solid #00c0ef;
}
.box.box-solid.box-info > .box-header {
  color: #ffffff;
  background: #00c0ef;
  background-color: #00c0ef;
}
.box.box-solid.box-info > .box-header a,
.box.box-solid.box-info > .box-header .btn {
  color: #ffffff;
}
.box.box-solid.box-danger {
  border: 1px solid #dd4b39;
}
.box.box-solid.box-danger > .box-header {
  color: #ffffff;
  background: #dd4b39;
  background-color: #dd4b39;
}
.box.box-solid.box-danger > .box-header a,
.box.box-solid.box-danger > .box-header .btn {
  color: #ffffff;
}
.box.box-solid.box-warning {
  border: 1px solid #f39c12;
}
.box.box-solid.box-warning > .box-header {
  color: #ffffff;
  background: #f39c12;
  background-color: #f39c12;
}
.box.box-solid.box-warning > .box-header a,
.box.box-solid.box-warning > .box-header .btn {
  color: #ffffff;
}
.box.box-solid.box-success {
  border: 1px solid #00a65a;
}
.box.box-solid.box-success > .box-header {
  color: #ffffff;
  background: #00a65a;
  background-color: #00a65a;
}
.box.box-solid.box-success > .box-header a,
.box.box-solid.box-success > .box-header .btn {
  color: #ffffff;
}
.box.box-solid > .box-header > .box-tools .btn {
  border: 0;
  box-shadow: none;
}
.box.box-solid[class*='bg'] > .box-header {
  color: #fff;
}
.box .box-group > .box {
  margin-bottom: 5px;
}
.box .knob-label {
  text-align: center;
  color: #333;
  font-weight: 100;
  font-size: 12px;
  margin-bottom: 0.3em;
}
.box > .overlay,
.overlay-wrapper > .overlay,
.box > .loading-img,
.overlay-wrapper > .loading-img {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
.box .overlay,
.overlay-wrapper .overlay {
  z-index: 50;
  background: rgba(255, 255, 255, 0.7);
  border-radius: 3px;
}
.box .overlay > .fa,
.overlay-wrapper .overlay > .fa {
  position: absolute;
  top: 50%;
  left: 50%;
  margin-left: -15px;
  margin-top: -15px;
  color: #000;
  font-size: 30px;
}
.box .overlay.dark,
.overlay-wrapper .overlay.dark {
  background: rgba(0, 0, 0, 0.5);
}
.box-header:before,
.box-body:before,
.box-footer:before,
.box-header:after,
.box-body:after,
.box-footer:after {
  content: " ";
  display: table;
}
.box-header:after,
.box-body:after,
.box-footer:after {
  clear: both;
}
.box-header {
  color: #444;
  display: block;
  padding: 10px;
  position: relative;
}
.box-header.with-border {
  border-bottom: 1px solid #f4f4f4;
}
.collapsed-box .box-header.with-border {
  border-bottom: none;
}
.box-header > .fa,
.box-header > .glyphicon,
.box-header > .ion,
.box-header .box-title {
  display: inline-block;
  font-size: 18px;
  margin: 0;
  line-height: 1;
}
.box-header > .fa,
.box-header > .glyphicon,
.box-header > .ion {
  margin-right: 5px;
}
.box-header > .box-tools {
  position: absolute;
  right: 10px;
  top: 5px;
}
.box-header > .box-tools [data-toggle="tooltip"] {
  position: relative;
}
.box-header > .box-tools.pull-right .dropdown-menu {
  right: 0;
  left: auto;
}
.btn-box-tool {
  padding: 5px;
  font-size: 12px;
  background: transparent;
  color: #97a0b3;
}
.open .btn-box-tool,
.btn-box-tool:hover {
  color: #606c84;
}
.btn-box-tool.btn:active {
  box-shadow: none;
}
.box-body {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  border-bottom-right-radius: 3px;
  border-bottom-left-radius: 3px;
  padding: 10px;
}
.no-header .box-body {
  border-top-right-radius: 3px;
  border-top-left-radius: 3px;
}
.box-body > .table {
  margin-bottom: 0;
}
.box-body .fc {
  margin-top: 5px;
}
.box-body .full-width-chart {
  margin: -19px;
}
.box-body.no-padding .full-width-chart {
  margin: -9px;
}
.box-body .box-pane {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 3px;
}
.box-body .box-pane-right {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  border-bottom-right-radius: 3px;
  border-bottom-left-radius: 0;
}
.box-footer {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  border-bottom-right-radius: 3px;
  border-bottom-left-radius: 3px;
  border-top: 1px solid #f4f4f4;
  padding: 10px;
  background-color: #ffffff;
}
.chart-legend {
  margin: 10px 0;
}
@media (max-width: 991px) {
  .chart-legend > li {
    float: left;
    margin-right: 10px;
  }
}
.box-comments {
  background: #f7f7f7;
}
.box-comments .box-comment {
  padding: 8px 0;
  border-bottom: 1px solid #eee;
}
.box-comments .box-comment:before,
.box-comments .box-comment:after {
  content: " ";
  display: table;
}
.box-comments .box-comment:after {
  clear: both;
}
.box-comments .box-comment:last-of-type {
  border-bottom: 0;
}
.box-comments .box-comment:first-of-type {
  padding-top: 0;
}
.box-comments .box-comment img {
  float: left;
}
.box-comments .comment-text {
  margin-left: 40px;
  color: #555;
}
.box-comments .username {
  color: #444;
  display: block;
  font-weight: 600;
}
.box-comments .text-muted {
  font-weight: 400;
  font-size: 12px;
}
/* Widget: TODO LIST */
.todo-list {
  margin: 0;
  padding: 0;
  list-style: none;
  overflow: auto;
}
.todo-list > li {
  border-radius: 2px;
  padding: 10px;
  background: #f4f4f4;
  margin-bottom: 2px;
  border-left: 2px solid #e6e7e8;
  color: #444;
}
.todo-list > li:last-of-type {
  margin-bottom: 0;
}
.todo-list > li > input[type='checkbox'] {
  margin: 0 10px 0 5px;
}
.todo-list > li .text {
  display: inline-block;
  margin-left: 5px;
  font-weight: 600;
}
.todo-list > li .label {
  margin-left: 10px;
  font-size: 9px;
}
.todo-list > li .tools {
  display: none;
  float: right;
  color: #dd4b39;
}
.todo-list > li .tools > .fa,
.todo-list > li .tools > .glyphicon,
.todo-list > li .tools > .ion {
  margin-right: 5px;
  cursor: pointer;
}
.todo-list > li:hover .tools {
  display: inline-block;
}
.todo-list > li.done {
  color: #999;
}
.todo-list > li.done .text {
  text-decoration: line-through;
  font-weight: 500;
}
.todo-list > li.done .label {
  background: #d2d6de !important;
}
.todo-list .danger {
  border-left-color: #dd4b39;
}
.todo-list .warning {
  border-left-color: #f39c12;
}
.todo-list .info {
  border-left-color: #00c0ef;
}
.todo-list .success {
  border-left-color: #00a65a;
}
.todo-list .primary {
  border-left-color: #3c8dbc;
}
.todo-list .handle {
  display: inline-block;
  cursor: move;
  margin: 0 5px;
}
/* Chat widget (DEPRECATED - this will be removed in the next major release. Use Direct Chat instead)*/
.chat {
  padding: 5px 20px 5px 10px;
}
.chat .item {
  margin-bottom: 10px;
}
.chat .item:before,
.chat .item:after {
  content: " ";
  display: table;
}
.chat .item:after {
  clear: both;
}
.chat .item > img {
  width: 40px;
  height: 40px;
  border: 2px solid transparent;
  border-radius: 50%;
}
.chat .item > .online {
  border: 2px solid #00a65a;
}
.chat .item > .offline {
  border: 2px solid #dd4b39;
}
.chat .item > .message {
  margin-left: 55px;
  margin-top: -40px;
}
.chat .item > .message > .name {
  display: block;
  font-weight: 600;
}
.chat .item > .attachment {
  border-radius: 3px;
  background: #f4f4f4;
  margin-left: 65px;
  margin-right: 15px;
  padding: 10px;
}
.chat .item > .attachment > h4 {
  margin: 0 0 5px 0;
  font-weight: 600;
  font-size: 14px;
}
.chat .item > .attachment > p,
.chat .item > .attachment > .filename {
  font-weight: 600;
  font-size: 13px;
  font-style: italic;
  margin: 0;
}
.chat .item > .attachment:before,
.chat .item > .attachment:after {
  content: " ";
  display: table;
}
.chat .item > .attachment:after {
  clear: both;
}
.box-input {
  max-width: 200px;
}
.modal .panel-body {
  color: #444;
}
/*
 * Component: Info Box
 * -------------------
 */
.info-box {
  display: block;
  min-height: 90px;
  background: #fff;
  width: 100%;
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
  border-radius: 2px;
  margin-bottom: 15px;
}
.info-box small {
  font-size: 14px;
}
.info-box .progress {
  background: rgba(0, 0, 0, 0.2);
  margin: 5px -10px 5px -10px;
  height: 2px;
}
.info-box .progress,
.info-box .progress .progress-bar {
  border-radius: 0;
}
.info-box .progress .progress-bar {
  background: #fff;
}
.info-box-icon {
  border-top-left-radius: 2px;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 2px;
  display: block;
  float: left;
  height: 90px;
  width: 90px;
  text-align: center;
  font-size: 45px;
  line-height: 90px;
  background: rgba(0, 0, 0, 0.2);
}
.info-box-icon > img {
  max-width: 100%;
}
.info-box-content {
  padding: 5px 10px;
  margin-left: 90px;
}
.info-box-number {
  display: block;
  font-weight: bold;
  font-size: 18px;
}
.progress-description,
.info-box-text {
  display: block;
  font-size: 14px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.info-box-text {
  text-transform: uppercase;
}
.info-box-more {
  display: block;
}
.progress-description {
  margin: 0;
}
/*
 * Component: Timeline
 * -------------------
 */
.timeline {
  position: relative;
  margin: 0 0 30px 0;
  padding: 0;
  list-style: none;
}
.timeline:before {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  width: 4px;
  background: #ddd;
  left: 31px;
  margin: 0;
  border-radius: 2px;
}
.timeline > li {
  position: relative;
  margin-right: 10px;
  margin-bottom: 15px;
}
.timeline > li:before,
.timeline > li:after {
  content: " ";
  display: table;
}
.timeline > li:after {
  clear: both;
}
.timeline > li > .timeline-item {
  -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
  border-radius: 3px;
  margin-top: 0;
  background: #fff;
  color: #444;
  margin-left: 60px;
  margin-right: 15px;
  padding: 0;
  position: relative;
}
.timeline > li > .timeline-item > .time {
  color: #999;
  float: right;
  padding: 10px;
  font-size: 12px;
}
.timeline > li > .timeline-item > .timeline-header {
  margin: 0;
  color: #555;
  border-bottom: 1px solid #f4f4f4;
  padding: 10px;
  font-size: 16px;
  line-height: 1.1;
}
.timeline > li > .timeline-item > .timeline-header > a {
  font-weight: 600;
}
.timeline > li > .timeline-item > .timeline-body,
.timeline > li > .timeline-item > .timeline-footer {
  padding: 10px;
}
.timeline > li > .fa,
.timeline > li > .glyphicon,
.timeline > li > .ion {
  width: 30px;
  height: 30px;
  font-size: 15px;
  line-height: 30px;
  position: absolute;
  color: #666;
  background: #d2d6de;
  border-radius: 50%;
  text-align: center;
  left: 18px;
  top: 0;
}
.timeline > .time-label > span {
  font-weight: 600;
  padding: 5px;
  display: inline-block;
  background-color: #fff;
  border-radius: 4px;
}
.timeline-inverse > li > .timeline-item {
  background: #f0f0f0;
  border: 1px solid #ddd;
  -webkit-box-shadow: none;
  box-shadow: none;
}
.timeline-inverse > li > .timeline-item > .timeline-header {
  border-bottom-color: #ddd;
}
/*
 * Component: Button
 * -----------------
 */
.btn {
  border-radius: 3px;
  -webkit-box-shadow: none;
  box-shadow: none;
  border: 1px solid transparent;
}
.btn.uppercase {
  text-transform: uppercase;
}
.btn.btn-flat {
  border-radius: 0;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  border-width: 1px;
}
.btn:active {
  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
  -moz-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn:focus {
  outline: none;
}
.btn.btn-file {
  position: relative;
  overflow: hidden;
}
.btn.btn-file > input[type='file'] {
  position: absolute;
  top: 0;
  right: 0;
  min-width: 100%;
  min-height: 100%;
  font-size: 100px;
  text-align: right;
  opacity: 0;
  filter: alpha(opacity=0);
  outline: none;
  background: white;
  cursor: inherit;
  display: block;
}
.btn-default {
  background-color: #f4f4f4;
  color: #444;
  border-color: #ddd;
}
.btn-default:hover,
.btn-default:active,
.btn-default.hover {
  background-color: #e7e7e7;
}
.btn-primary {
  background-color: #3c8dbc;
  border-color: #367fa9;
}
.btn-primary:hover,
.btn-primary:active,
.btn-primary.hover {
  background-color: #367fa9;
}
.btn-success {
  background-color: #00a65a;
  border-color: #008d4c;
}
.btn-success:hover,
.btn-success:active,
.btn-success.hover {
  background-color: #008d4c;
}
.btn-info {
  background-color: #00c0ef;
  border-color: #00acd6;
}
.btn-info:hover,
.btn-info:active,
.btn-info.hover {
  background-color: #00acd6;
}
.btn-danger {
  background-color: #dd4b39;
  border-color: #d73925;
}
.btn-danger:hover,
.btn-danger:active,
.btn-danger.hover {
  background-color: #d73925;
}
.btn-warning {
  background-color: #f39c12;
  border-color: #e08e0b;
}
.btn-warning:hover,
.btn-warning:active,
.btn-warning.hover {
  background-color: #e08e0b;
}
.btn-outline {
  border: 1px solid #fff;
  background: transparent;
  color: #fff;
}
.btn-outline:hover,
.btn-outline:focus,
.btn-outline:active {
  color: rgba(255, 255, 255, 0.7);
  border-color: rgba(255, 255, 255, 0.7);
}
.btn-link {
  -webkit-box-shadow: none;
  box-shadow: none;
}
.btn[class*='bg-']:hover {
  -webkit-box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.2);
  box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.2);
}
.btn-app {
  border-radius: 3px;
  position: relative;
  padding: 15px 5px;
  margin: 0 0 10px 10px;
  min-width: 80px;
  height: 60px;
  text-align: center;
  color: #666;
  border: 1px solid #ddd;
  background-color: #f4f4f4;
  font-size: 12px;
}
.btn-app > .fa,
.btn-app > .glyphicon,
.btn-app > .ion {
  font-size: 20px;
  display: block;
}
.btn-app:hover {
  background: #f4f4f4;
  color: #444;
  border-color: #aaa;
}
.btn-app:active,
.btn-app:focus {
  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
  -moz-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn-app > .badge {
  position: absolute;
  top: -3px;
  right: -10px;
  font-size: 10px;
  font-weight: 400;
}
/*
 * Component: Callout
 * ------------------
 */
.callout {
  border-radius: 3px;
  margin: 0 0 20px 0;
  padding: 15px 30px 15px 15px;
  border-left: 5px solid #eee;
}
.callout a {
  color: #fff;
  text-decoration: underline;
}
.callout a:hover {
  color: #eee;
}
.callout h4 {
  margin-top: 0;
  font-weight: 600;
}
.callout p:last-child {
  margin-bottom: 0;
}
.callout code,
.callout .highlight {
  background-color: #fff;
}
.callout.callout-danger {
  border-color: #c23321;
}
.callout.callout-warning {
  border-color: #c87f0a;
}
.callout.callout-info {
  border-color: #0097bc;
}
.callout.callout-success {
  border-color: #00733e;
}
/*
 * Component: alert
 * ----------------
 */
.alert {
  border-radius: 3px;
}
.alert h4 {
  font-weight: 600;
}
.alert .icon {
  margin-right: 10px;
}
.alert .close {
  color: #000;
  opacity: 0.2;
  filter: alpha(opacity=20);
}
.alert .close:hover {
  opacity: 0.5;
  filter: alpha(opacity=50);
}
.alert a {
  color: #fff;
  text-decoration: underline;
}
.alert-success {
  border-color: #008d4c;
}
.alert-danger,
.alert-error {
  border-color: #d73925;
}
.alert-warning {
  border-color: #e08e0b;
}
.alert-info {
  border-color: #00acd6;
}
/*
 * Component: Nav
 * --------------
 */
.nav > li > a:hover,
.nav > li > a:active,
.nav > li > a:focus {
  color: #444;
  background: #f7f7f7;
}
/* NAV PILLS */
.nav-pills > li > a {
  border-radius: 0;
  border-top: 3px solid transparent;
  color: #444;
}
.nav-pills > li > a > .fa,
.nav-pills > li > a > .glyphicon,
.nav-pills > li > a > .ion {
  margin-right: 5px;
}
.nav-pills > li.active > a,
.nav-pills > li.active > a:hover,
.nav-pills > li.active > a:focus {
  border-top-color: #3c8dbc;
}
.nav-pills > li.active > a {
  font-weight: 600;
}
/* NAV STACKED */
.nav-stacked > li > a {
  border-radius: 0;
  border-top: 0;
  border-left: 3px solid transparent;
  color: #444;
}
.nav-stacked > li.active > a,
.nav-stacked > li.active > a:hover {
  background: transparent;
  color: #444;
  border-top: 0;
  border-left-color: #3c8dbc;
}
.nav-stacked > li.header {
  border-bottom: 1px solid #ddd;
  color: #777;
  margin-bottom: 10px;
  padding: 5px 10px;
  text-transform: uppercase;
}
/* NAV TABS */
.nav-tabs-custom {
  margin-bottom: 20px;
  background: #fff;
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
  border-radius: 3px;
}
.nav-tabs-custom > .nav-tabs {
  margin: 0;
  border-bottom-color: #f4f4f4;
  border-top-right-radius: 3px;
  border-top-left-radius: 3px;
}
.nav-tabs-custom > .nav-tabs > li {
  border-top: 3px solid transparent;
  margin-bottom: -2px;
  margin-right: 5px;
}
.nav-tabs-custom > .nav-tabs > li > a {
  color: #444;
  border-radius: 0;
}
.nav-tabs-custom > .nav-tabs > li > a.text-muted {
  color: #999;
}
.nav-tabs-custom > .nav-tabs > li > a,
.nav-tabs-custom > .nav-tabs > li > a:hover {
  background: transparent;
  margin: 0;
}
.nav-tabs-custom > .nav-tabs > li > a:hover {
  color: #999;
}
.nav-tabs-custom > .nav-tabs > li:not(.active) > a:hover,
.nav-tabs-custom > .nav-tabs > li:not(.active) > a:focus,
.nav-tabs-custom > .nav-tabs > li:not(.active) > a:active {
  border-color: transparent;
}
.nav-tabs-custom > .nav-tabs > li.active {
  border-top-color: #3c8dbc;
}
.nav-tabs-custom > .nav-tabs > li.active > a,
.nav-tabs-custom > .nav-tabs > li.active:hover > a {
  background-color: #fff;
  color: #444;
}
.nav-tabs-custom > .nav-tabs > li.active > a {
  border-top-color: transparent;
  border-left-color: #f4f4f4;
  border-right-color: #f4f4f4;
}
.nav-tabs-custom > .nav-tabs > li:first-of-type {
  margin-left: 0;
}
.nav-tabs-custom > .nav-tabs > li:first-of-type.active > a {
  border-left-color: transparent;
}
.nav-tabs-custom > .nav-tabs.pull-right {
  float: none !important;
}
.nav-tabs-custom > .nav-tabs.pull-right > li {
  float: right;
}
.nav-tabs-custom > .nav-tabs.pull-right > li:first-of-type {
  margin-right: 0;
}
.nav-tabs-custom > .nav-tabs.pull-right > li:first-of-type > a {
  border-left-width: 1px;
}
.nav-tabs-custom > .nav-tabs.pull-right > li:first-of-type.active > a {
  border-left-color: #f4f4f4;
  border-right-color: transparent;
}
.nav-tabs-custom > .nav-tabs > li.header {
  line-height: 35px;
  padding: 0 10px;
  font-size: 20px;
  color: #444;
}
.nav-tabs-custom > .nav-tabs > li.header > .fa,
.nav-tabs-custom > .nav-tabs > li.header > .glyphicon,
.nav-tabs-custom > .nav-tabs > li.header > .ion {
  margin-right: 5px;
}
.nav-tabs-custom > .tab-content {
  background: #fff;
  padding: 10px;
  border-bottom-right-radius: 3px;
  border-bottom-left-radius: 3px;
}
.nav-tabs-custom .dropdown.open > a:active,
.nav-tabs-custom .dropdown.open > a:focus {
  background: transparent;
  color: #999;
}
.nav-tabs-custom.tab-primary > .nav-tabs > li.active {
  border-top-color: #3c8dbc;
}
.nav-tabs-custom.tab-info > .nav-tabs > li.active {
  border-top-color: #00c0ef;
}
.nav-tabs-custom.tab-danger > .nav-tabs > li.active {
  border-top-color: #dd4b39;
}
.nav-tabs-custom.tab-warning > .nav-tabs > li.active {
  border-top-color: #f39c12;
}
.nav-tabs-custom.tab-success > .nav-tabs > li.active {
  border-top-color: #00a65a;
}
.nav-tabs-custom.tab-default > .nav-tabs > li.active {
  border-top-color: #d2d6de;
}
/* PAGINATION */
.pagination > li > a {
  background: #fafafa;
  color: #666;
}
.pagination.pagination-flat > li > a {
  border-radius: 0 !important;
}
/*
 * Component: Products List
 * ------------------------
 */
.products-list {
  list-style: none;
  margin: 0;
  padding: 0;
}
.products-list > .item {
  border-radius: 3px;
  -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
  padding: 10px 0;
  background: #fff;
}
.products-list > .item:before,
.products-list > .item:after {
  content: " ";
  display: table;
}
.products-list > .item:after {
  clear: both;
}
.products-list .product-img {
  float: left;
}
.products-list .product-img img {
  width: 50px;
  height: 50px;
}
.products-list .product-info {
  margin-left: 60px;
}
.products-list .product-title {
  font-weight: 600;
}
.products-list .product-description {
  display: block;
  color: #999;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.product-list-in-box > .item {
  -webkit-box-shadow: none;
  box-shadow: none;
  border-radius: 0;
  border-bottom: 1px solid #f4f4f4;
}
.product-list-in-box > .item:last-of-type {
  border-bottom-width: 0;
}
/*
 * Component: Table
 * ----------------
 */
.table > thead > tr > th,
.table > tbody > tr > th,
.table > tfoot > tr > th,
.table > thead > tr > td,
.table > tbody > tr > td,
.table > tfoot > tr > td {
  border-top: 1px solid #f4f4f4;
}
.table > thead > tr > th {
  border-bottom: 2px solid #f4f4f4;
}
.table tr td .progress {
  margin-top: 5px;
}
.table-bordered {
  border: 1px solid #f4f4f4;
}
.table-bordered > thead > tr > th,
.table-bordered > tbody > tr > th,
.table-bordered > tfoot > tr > th,
.table-bordered > thead > tr > td,
.table-bordered > tbody > tr > td,
.table-bordered > tfoot > tr > td {
  border: 1px solid #f4f4f4;
}
.table-bordered > thead > tr > th,
.table-bordered > thead > tr > td {
  border-bottom-width: 2px;
}
.table.no-border,
.table.no-border td,
.table.no-border th {
  border: 0;
}
/* .text-center in tables */
table.text-center,
table.text-center td,
table.text-center th {
  text-align: center;
}
.table.align th {
  text-align: left;
}
.table.align td {
  text-align: right;
}
/*
 * Component: Label
 * ----------------
 */
.label-default {
  background-color: #d2d6de;
  color: #444;
}
/*
 * Component: Direct Chat
 * ----------------------
 */
.direct-chat .box-body {
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
  position: relative;
  overflow-x: hidden;
  padding: 0;
}
.direct-chat.chat-pane-open .direct-chat-contacts {
  -webkit-transform: translate(0, 0);
  -ms-transform: translate(0, 0);
  -o-transform: translate(0, 0);
  transform: translate(0, 0);
}
.direct-chat-messages {
  -webkit-transform: translate(0, 0);
  -ms-transform: translate(0, 0);
  -o-transform: translate(0, 0);
  transform: translate(0, 0);
  padding: 10px;
  height: 250px;
  overflow: auto;
}
.direct-chat-msg,
.direct-chat-text {
  display: block;
}
.direct-chat-msg {
  margin-bottom: 10px;
}
.direct-chat-msg:before,
.direct-chat-msg:after {
  content: " ";
  display: table;
}
.direct-chat-msg:after {
  clear: both;
}
.direct-chat-messages,
.direct-chat-contacts {
  -webkit-transition: -webkit-transform 0.5s ease-in-out;
  -moz-transition: -moz-transform 0.5s ease-in-out;
  -o-transition: -o-transform 0.5s ease-in-out;
  transition: transform 0.5s ease-in-out;
}
.direct-chat-text {
  border-radius: 5px;
  position: relative;
  padding: 5px 10px;
  background: #d2d6de;
  border: 1px solid #d2d6de;
  margin: 5px 0 0 50px;
  color: #444444;
}
.direct-chat-text:after,
.direct-chat-text:before {
  position: absolute;
  right: 100%;
  top: 15px;
  border: solid transparent;
  border-right-color: #d2d6de;
  content: ' ';
  height: 0;
  width: 0;
  pointer-events: none;
}
.direct-chat-text:after {
  border-width: 5px;
  margin-top: -5px;
}
.direct-chat-text:before {
  border-width: 6px;
  margin-top: -6px;
}
.right .direct-chat-text {
  margin-right: 50px;
  margin-left: 0;
}
.right .direct-chat-text:after,
.right .direct-chat-text:before {
  right: auto;
  left: 100%;
  border-right-color: transparent;
  border-left-color: #d2d6de;
}
.direct-chat-img {
  border-radius: 50%;
  float: left;
  width: 40px;
  height: 40px;
}
.right .direct-chat-img {
  float: right;
}
.direct-chat-info {
  display: block;
  margin-bottom: 2px;
  font-size: 12px;
}
.direct-chat-name {
  font-weight: 600;
}
.direct-chat-timestamp {
  color: #999;
}
.direct-chat-contacts-open .direct-chat-contacts {
  -webkit-transform: translate(0, 0);
  -ms-transform: translate(0, 0);
  -o-transform: translate(0, 0);
  transform: translate(0, 0);
}
.direct-chat-contacts {
  -webkit-transform: translate(101%, 0);
  -ms-transform: translate(101%, 0);
  -o-transform: translate(101%, 0);
  transform: translate(101%, 0);
  position: absolute;
  top: 0;
  bottom: 0;
  height: 250px;
  width: 100%;
  background: #222d32;
  color: #fff;
  overflow: auto;
}
.contacts-list > li {
  border-bottom: 1px solid rgba(0, 0, 0, 0.2);
  padding: 10px;
  margin: 0;
}
.contacts-list > li:before,
.contacts-list > li:after {
  content: " ";
  display: table;
}
.contacts-list > li:after {
  clear: both;
}
.contacts-list > li:last-of-type {
  border-bottom: none;
}
.contacts-list-img {
  border-radius: 50%;
  width: 40px;
  float: left;
}
.contacts-list-info {
  margin-left: 45px;
  color: #fff;
}
.contacts-list-name,
.contacts-list-status {
  display: block;
}
.contacts-list-name {
  font-weight: 600;
}
.contacts-list-status {
  font-size: 12px;
}
.contacts-list-date {
  color: #aaa;
  font-weight: normal;
}
.contacts-list-msg {
  color: #999;
}
.direct-chat-danger .right > .direct-chat-text {
  background: #dd4b39;
  border-color: #dd4b39;
  color: #ffffff;
}
.direct-chat-danger .right > .direct-chat-text:after,
.direct-chat-danger .right > .direct-chat-text:before {
  border-left-color: #dd4b39;
}
.direct-chat-primary .right > .direct-chat-text {
  background: #3c8dbc;
  border-color: #3c8dbc;
  color: #ffffff;
}
.direct-chat-primary .right > .direct-chat-text:after,
.direct-chat-primary .right > .direct-chat-text:before {
  border-left-color: #3c8dbc;
}
.direct-chat-warning .right > .direct-chat-text {
  background: #f39c12;
  border-color: #f39c12;
  color: #ffffff;
}
.direct-chat-warning .right > .direct-chat-text:after,
.direct-chat-warning .right > .direct-chat-text:before {
  border-left-color: #f39c12;
}
.direct-chat-info .right > .direct-chat-text {
  background: #00c0ef;
  border-color: #00c0ef;
  color: #ffffff;
}
.direct-chat-info .right > .direct-chat-text:after,
.direct-chat-info .right > .direct-chat-text:before {
  border-left-color: #00c0ef;
}
.direct-chat-success .right > .direct-chat-text {
  background: #00a65a;
  border-color: #00a65a;
  color: #ffffff;
}
.direct-chat-success .right > .direct-chat-text:after,
.direct-chat-success .right > .direct-chat-text:before {
  border-left-color: #00a65a;
}
/*
 * Component: Users List
 * ---------------------
 */
.users-list > li {
  width: 25%;
  float: left;
  padding: 10px;
  text-align: center;
}
.users-list > li img {
  border-radius: 50%;
  max-width: 100%;
  height: auto;
}
.users-list > li > a:hover,
.users-list > li > a:hover .users-list-name {
  color: #999;
}
.users-list-name,
.users-list-date {
  display: block;
}
.users-list-name {
  font-weight: 600;
  color: #444;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.users-list-date {
  color: #999;
  font-size: 12px;
}
/*
 * Component: Carousel
 * -------------------
 */
.carousel-control.left,
.carousel-control.right {
  background-image: none;
}
.carousel-control > .fa {
  font-size: 40px;
  position: absolute;
  top: 50%;
  z-index: 5;
  display: inline-block;
  margin-top: -20px;
}
/*
 * Component: modal
 * ----------------
 */
.modal {
  background: rgba(0, 0, 0, 0.3);
}
.modal-content {
  border-radius: 0;
  -webkit-box-shadow: 0 2px 3px rgba(0, 0, 0, 0.125);
  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.125);
  border: 0;
}
@media (min-width: 768px) {
  .modal-content {
    -webkit-box-shadow: 0 2px 3px rgba(0, 0, 0, 0.125);
    box-shadow: 0 2px 3px rgba(0, 0, 0, 0.125);
  }
}
.modal-header {
  border-bottom-color: #f4f4f4;
}
.modal-footer {
  border-top-color: #f4f4f4;
}
.modal-primary .modal-header,
.modal-primary .modal-footer {
  border-color: #307095;
}
.modal-warning .modal-header,
.modal-warning .modal-footer {
  border-color: #c87f0a;
}
.modal-info .modal-header,
.modal-info .modal-footer {
  border-color: #0097bc;
}
.modal-success .modal-header,
.modal-success .modal-footer {
  border-color: #00733e;
}
.modal-danger .modal-header,
.modal-danger .modal-footer {
  border-color: #c23321;
}
/*
 * Component: Social Widgets
 * -------------------------
 */
.box-widget {
  border: none;
  position: relative;
}
.widget-user .widget-user-header {
  padding: 20px;
  height: 120px;
  border-top-right-radius: 3px;
  border-top-left-radius: 3px;
}
.widget-user .widget-user-username {
  margin-top: 0;
  margin-bottom: 5px;
  font-size: 25px;
  font-weight: 300;
  text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
}
.widget-user .widget-user-desc {
  margin-top: 0;
}
.widget-user .widget-user-image {
  position: absolute;
  top: 65px;
  left: 50%;
  margin-left: -45px;
}
.widget-user .widget-user-image > img {
  width: 90px;
  height: auto;
  border: 3px solid #fff;
}
.widget-user .box-footer {
  padding-top: 30px;
}
.widget-user-2 .widget-user-header {
  padding: 20px;
  border-top-right-radius: 3px;
  border-top-left-radius: 3px;
}
.widget-user-2 .widget-user-username {
  margin-top: 5px;
  margin-bottom: 5px;
  font-size: 25px;
  font-weight: 300;
}
.widget-user-2 .widget-user-desc {
  margin-top: 0;
}
.widget-user-2 .widget-user-username,
.widget-user-2 .widget-user-desc {
  margin-left: 75px;
}
.widget-user-2 .widget-user-image > img {
  width: 65px;
  height: auto;
  float: left;
}
/*
 * Page: Mailbox
 * -------------
 */
.mailbox-messages > .table {
  margin: 0;
}
.mailbox-controls {
  padding: 5px;
}
.mailbox-controls.with-border {
  border-bottom: 1px solid #f4f4f4;
}
.mailbox-read-info {
  border-bottom: 1px solid #f4f4f4;
  padding: 10px;
}
.mailbox-read-info h3 {
  font-size: 20px;
  margin: 0;
}
.mailbox-read-info h5 {
  margin: 0;
  padding: 5px 0 0 0;
}
.mailbox-read-time {
  color: #999;
  font-size: 13px;
}
.mailbox-read-message {
  padding: 10px;
}
.mailbox-attachments li {
  float: left;
  width: 200px;
  border: 1px solid #eee;
  margin-bottom: 10px;
  margin-right: 10px;
}
.mailbox-attachment-name {
  font-weight: bold;
  color: #666;
}
.mailbox-attachment-icon,
.mailbox-attachment-info,
.mailbox-attachment-size {
  display: block;
}
.mailbox-attachment-info {
  padding: 10px;
  background: #f4f4f4;
}
.mailbox-attachment-size {
  color: #999;
  font-size: 12px;
}
.mailbox-attachment-icon {
  text-align: center;
  font-size: 65px;
  color: #666;
  padding: 20px 10px;
}
.mailbox-attachment-icon.has-img {
  padding: 0;
}
.mailbox-attachment-icon.has-img > img {
  max-width: 100%;
  height: auto;
}
/*
 * Page: Lock Screen
 * -----------------
 */
/* ADD THIS CLASS TO THE <BODY> TAG */
.lockscreen {
  background: #d2d6de;
}
.lockscreen-logo {
  font-size: 35px;
  text-align: center;
  margin-bottom: 25px;
  font-weight: 300;
}
.lockscreen-logo a {
  color: #444;
}
.lockscreen-wrapper {
  max-width: 400px;
  margin: 0 auto;
  margin-top: 10%;
}
/* User name [optional] */
.lockscreen .lockscreen-name {
  text-align: center;
  font-weight: 600;
}
/* Will contain the image and the sign in form */
.lockscreen-item {
  border-radius: 4px;
  padding: 0;
  background: #fff;
  position: relative;
  margin: 10px auto 30px auto;
  width: 290px;
}
/* User image */
.lockscreen-image {
  border-radius: 50%;
  position: absolute;
  left: -10px;
  top: -25px;
  background: #fff;
  padding: 5px;
  z-index: 10;
}
.lockscreen-image > img {
  border-radius: 50%;
  width: 70px;
  height: 70px;
}
/* Contains the password input and the login button */
.lockscreen-credentials {
  margin-left: 70px;
}
.lockscreen-credentials .form-control {
  border: 0;
}
.lockscreen-credentials .btn {
  background-color: #fff;
  border: 0;
  padding: 0 10px;
}
.lockscreen-footer {
  margin-top: 10px;
}
/*
 * Page: Login & Register
 * ----------------------
 */
.login-logo,
.register-logo {
  font-size: 35px;
  text-align: center;
  margin-bottom: 25px;
  font-weight: 300;
}
.login-logo a,
.register-logo a {
  color: #444;
}
.login-page,
.register-page {
  background: #d2d6de;
}
.login-box,
.register-box {
  width: 360px;
  margin: 7% auto;
}
@media (max-width: 768px) {
  .login-box,
  .register-box {
    width: 90%;
    margin-top: 20px;
  }
}
.login-box-body,
.register-box-body {
  background: #fff;
  padding: 20px;
  border-top: 0;
  color: #666;
}
.login-box-body .form-control-feedback,
.register-box-body .form-control-feedback {
  color: #777;
}
.login-box-msg,
.register-box-msg {
  margin: 0;
  text-align: center;
  padding: 0 20px 20px 20px;
}
.social-auth-links {
  margin: 10px 0;
}

.sso-login-box {
    margin-top: 20px;
    text-align: center;
}
/*
 * Page: 400 and 500 error pages
 * ------------------------------
 */
.error-page {
  width: 600px;
  margin: 20px auto 0 auto;
}
@media (max-width: 991px) {
  .error-page {
    width: 100%;
  }
}
.error-page > .headline {
  float: left;
  font-size: 100px;
  font-weight: 300;
}
@media (max-width: 991px) {
  .error-page > .headline {
    float: none;
    text-align: center;
  }
}
.error-page > .error-content {
  margin-left: 190px;
  display: block;
}
@media (max-width: 991px) {
  .error-page > .error-content {
    margin-left: 0;
  }
}
.error-page > .error-content > h3 {
  font-weight: 300;
  font-size: 25px;
}
@media (max-width: 991px) {
  .error-page > .error-content > h3 {
    text-align: center;
  }
}
/*
 * Page: Invoice
 * -------------
 */
.invoice {
  position: relative;
  background: #fff;
  border: 1px solid #f4f4f4;
  padding: 20px;
  margin: 10px 25px;
}
.invoice-title {
  margin-top: 0;
}
/*
 * Page: Profile
 * -------------
 */
.profile-user-img {
  margin: 0 auto;
  width: 100px;
  padding: 3px;
  border: 3px solid #d2d6de;
}
.profile-username {
  font-size: 21px;
  margin-top: 5px;
}
.post {
  border-bottom: 1px solid #d2d6de;
  margin-bottom: 15px;
  padding-bottom: 15px;
  color: #666;
}
.post:last-of-type {
  border-bottom: 0;
  margin-bottom: 0;
  padding-bottom: 0;
}
.post .user-block {
  margin-bottom: 15px;
}
/*
 * Social Buttons for Bootstrap
 *
 * Copyright 2013-2015 Panayiotis Lipiridis
 * Licensed under the MIT License
 *
 * https://github.com/lipis/bootstrap-social
 */
.btn-social {
  position: relative;
  padding-left: 44px;
  text-align: left;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.btn-social > :first-child {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 32px;
  line-height: 34px;
  font-size: 1.6em;
  text-align: center;
  border-right: 1px solid rgba(0, 0, 0, 0.2);
}
.btn-social.btn-lg {
  padding-left: 61px;
}
.btn-social.btn-lg > :first-child {
  line-height: 45px;
  width: 45px;
  font-size: 1.8em;
}
.btn-social.btn-sm {
  padding-left: 38px;
}
.btn-social.btn-sm > :first-child {
  line-height: 28px;
  width: 28px;
  font-size: 1.4em;
}
.btn-social.btn-xs {
  padding-left: 30px;
}
.btn-social.btn-xs > :first-child {
  line-height: 20px;
  width: 20px;
  font-size: 1.2em;
}
.btn-social-icon {
  position: relative;
  padding-left: 44px;
  text-align: left;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  height: 34px;
  width: 34px;
  padding: 0;
}
.btn-social-icon > :first-child {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 32px;
  line-height: 34px;
  font-size: 1.6em;
  text-align: center;
  border-right: 1px solid rgba(0, 0, 0, 0.2);
}
.btn-social-icon.btn-lg {
  padding-left: 61px;
}
.btn-social-icon.btn-lg > :first-child {
  line-height: 45px;
  width: 45px;
  font-size: 1.8em;
}
.btn-social-icon.btn-sm {
  padding-left: 38px;
}
.btn-social-icon.btn-sm > :first-child {
  line-height: 28px;
  width: 28px;
  font-size: 1.4em;
}
.btn-social-icon.btn-xs {
  padding-left: 30px;
}
.btn-social-icon.btn-xs > :first-child {
  line-height: 20px;
  width: 20px;
  font-size: 1.2em;
}
.btn-social-icon > :first-child {
  border: none;
  text-align: center;
  width: 100%;
}
.btn-social-icon.btn-lg {
  height: 45px;
  width: 45px;
  padding-left: 0;
  padding-right: 0;
}
.btn-social-icon.btn-sm {
  height: 30px;
  width: 30px;
  padding-left: 0;
  padding-right: 0;
}
.btn-social-icon.btn-xs {
  height: 22px;
  width: 22px;
  padding-left: 0;
  padding-right: 0;
}
.btn-adn {
  color: #ffffff;
  background-color: #d87a68;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-adn:focus,
.btn-adn.focus {
  color: #ffffff;
  background-color: #ce563f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-adn:hover {
  color: #ffffff;
  background-color: #ce563f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-adn:active,
.btn-adn.active,
.open > .dropdown-toggle.btn-adn {
  color: #ffffff;
  background-color: #ce563f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-adn:active,
.btn-adn.active,
.open > .dropdown-toggle.btn-adn {
  background-image: none;
}
.btn-adn .badge {
  color: #d87a68;
  background-color: #ffffff;
}
.btn-bitbucket {
  color: #ffffff;
  background-color: #205081;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-bitbucket:focus,
.btn-bitbucket.focus {
  color: #ffffff;
  background-color: #163758;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-bitbucket:hover {
  color: #ffffff;
  background-color: #163758;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-bitbucket:active,
.btn-bitbucket.active,
.open > .dropdown-toggle.btn-bitbucket {
  color: #ffffff;
  background-color: #163758;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-bitbucket:active,
.btn-bitbucket.active,
.open > .dropdown-toggle.btn-bitbucket {
  background-image: none;
}
.btn-bitbucket .badge {
  color: #205081;
  background-color: #ffffff;
}
.btn-dropbox {
  color: #ffffff;
  background-color: #1087dd;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-dropbox:focus,
.btn-dropbox.focus {
  color: #ffffff;
  background-color: #0d6aad;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-dropbox:hover {
  color: #ffffff;
  background-color: #0d6aad;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-dropbox:active,
.btn-dropbox.active,
.open > .dropdown-toggle.btn-dropbox {
  color: #ffffff;
  background-color: #0d6aad;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-dropbox:active,
.btn-dropbox.active,
.open > .dropdown-toggle.btn-dropbox {
  background-image: none;
}
.btn-dropbox .badge {
  color: #1087dd;
  background-color: #ffffff;
}
.btn-facebook {
  color: #ffffff;
  background-color: #3b5998;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-facebook:focus,
.btn-facebook.focus {
  color: #ffffff;
  background-color: #2d4373;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-facebook:hover {
  color: #ffffff;
  background-color: #2d4373;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-facebook:active,
.btn-facebook.active,
.open > .dropdown-toggle.btn-facebook {
  color: #ffffff;
  background-color: #2d4373;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-facebook:active,
.btn-facebook.active,
.open > .dropdown-toggle.btn-facebook {
  background-image: none;
}
.btn-facebook .badge {
  color: #3b5998;
  background-color: #ffffff;
}
.btn-flickr {
  color: #ffffff;
  background-color: #ff0084;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-flickr:focus,
.btn-flickr.focus {
  color: #ffffff;
  background-color: #cc006a;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-flickr:hover {
  color: #ffffff;
  background-color: #cc006a;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-flickr:active,
.btn-flickr.active,
.open > .dropdown-toggle.btn-flickr {
  color: #ffffff;
  background-color: #cc006a;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-flickr:active,
.btn-flickr.active,
.open > .dropdown-toggle.btn-flickr {
  background-image: none;
}
.btn-flickr .badge {
  color: #ff0084;
  background-color: #ffffff;
}
.btn-foursquare {
  color: #ffffff;
  background-color: #f94877;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-foursquare:focus,
.btn-foursquare.focus {
  color: #ffffff;
  background-color: #f71752;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-foursquare:hover {
  color: #ffffff;
  background-color: #f71752;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-foursquare:active,
.btn-foursquare.active,
.open > .dropdown-toggle.btn-foursquare {
  color: #ffffff;
  background-color: #f71752;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-foursquare:active,
.btn-foursquare.active,
.open > .dropdown-toggle.btn-foursquare {
  background-image: none;
}
.btn-foursquare .badge {
  color: #f94877;
  background-color: #ffffff;
}
.btn-github {
  color: #ffffff;
  background-color: #444444;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-github:focus,
.btn-github.focus {
  color: #ffffff;
  background-color: #2b2b2b;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-github:hover {
  color: #ffffff;
  background-color: #2b2b2b;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-github:active,
.btn-github.active,
.open > .dropdown-toggle.btn-github {
  color: #ffffff;
  background-color: #2b2b2b;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-github:active,
.btn-github.active,
.open > .dropdown-toggle.btn-github {
  background-image: none;
}
.btn-github .badge {
  color: #444444;
  background-color: #ffffff;
}
.btn-google {
  color: #ffffff;
  background-color: #dd4b39;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-google:focus,
.btn-google.focus {
  color: #ffffff;
  background-color: #c23321;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-google:hover {
  color: #ffffff;
  background-color: #c23321;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-google:active,
.btn-google.active,
.open > .dropdown-toggle.btn-google {
  color: #ffffff;
  background-color: #c23321;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-google:active,
.btn-google.active,
.open > .dropdown-toggle.btn-google {
  background-image: none;
}
.btn-google .badge {
  color: #dd4b39;
  background-color: #ffffff;
}
.btn-instagram {
  color: #ffffff;
  background-color: #3f729b;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-instagram:focus,
.btn-instagram.focus {
  color: #ffffff;
  background-color: #305777;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-instagram:hover {
  color: #ffffff;
  background-color: #305777;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-instagram:active,
.btn-instagram.active,
.open > .dropdown-toggle.btn-instagram {
  color: #ffffff;
  background-color: #305777;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-instagram:active,
.btn-instagram.active,
.open > .dropdown-toggle.btn-instagram {
  background-image: none;
}
.btn-instagram .badge {
  color: #3f729b;
  background-color: #ffffff;
}
.btn-linkedin {
  color: #ffffff;
  background-color: #007bb6;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-linkedin:focus,
.btn-linkedin.focus {
  color: #ffffff;
  background-color: #005983;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-linkedin:hover {
  color: #ffffff;
  background-color: #005983;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-linkedin:active,
.btn-linkedin.active,
.open > .dropdown-toggle.btn-linkedin {
  color: #ffffff;
  background-color: #005983;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-linkedin:active,
.btn-linkedin.active,
.open > .dropdown-toggle.btn-linkedin {
  background-image: none;
}
.btn-linkedin .badge {
  color: #007bb6;
  background-color: #ffffff;
}
.btn-microsoft {
  color: #ffffff;
  background-color: #2672ec;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-microsoft:focus,
.btn-microsoft.focus {
  color: #ffffff;
  background-color: #125acd;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-microsoft:hover {
  color: #ffffff;
  background-color: #125acd;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-microsoft:active,
.btn-microsoft.active,
.open > .dropdown-toggle.btn-microsoft {
  color: #ffffff;
  background-color: #125acd;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-microsoft:active,
.btn-microsoft.active,
.open > .dropdown-toggle.btn-microsoft {
  background-image: none;
}
.btn-microsoft .badge {
  color: #2672ec;
  background-color: #ffffff;
}
.btn-openid {
  color: #ffffff;
  background-color: #f7931e;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-openid:focus,
.btn-openid.focus {
  color: #ffffff;
  background-color: #da7908;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-openid:hover {
  color: #ffffff;
  background-color: #da7908;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-openid:active,
.btn-openid.active,
.open > .dropdown-toggle.btn-openid {
  color: #ffffff;
  background-color: #da7908;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-openid:active,
.btn-openid.active,
.open > .dropdown-toggle.btn-openid {
  background-image: none;
}
.btn-openid .badge {
  color: #f7931e;
  background-color: #ffffff;
}
.btn-pinterest {
  color: #ffffff;
  background-color: #cb2027;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-pinterest:focus,
.btn-pinterest.focus {
  color: #ffffff;
  background-color: #9f191f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-pinterest:hover {
  color: #ffffff;
  background-color: #9f191f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-pinterest:active,
.btn-pinterest.active,
.open > .dropdown-toggle.btn-pinterest {
  color: #ffffff;
  background-color: #9f191f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-pinterest:active,
.btn-pinterest.active,
.open > .dropdown-toggle.btn-pinterest {
  background-image: none;
}
.btn-pinterest .badge {
  color: #cb2027;
  background-color: #ffffff;
}
.btn-reddit {
  color: #000000;
  background-color: #eff7ff;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-reddit:focus,
.btn-reddit.focus {
  color: #000000;
  background-color: #bcddff;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-reddit:hover {
  color: #000000;
  background-color: #bcddff;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-reddit:active,
.btn-reddit.active,
.open > .dropdown-toggle.btn-reddit {
  color: #000000;
  background-color: #bcddff;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-reddit:active,
.btn-reddit.active,
.open > .dropdown-toggle.btn-reddit {
  background-image: none;
}
.btn-reddit .badge {
  color: #eff7ff;
  background-color: #000000;
}
.btn-soundcloud {
  color: #ffffff;
  background-color: #ff5500;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-soundcloud:focus,
.btn-soundcloud.focus {
  color: #ffffff;
  background-color: #cc4400;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-soundcloud:hover {
  color: #ffffff;
  background-color: #cc4400;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-soundcloud:active,
.btn-soundcloud.active,
.open > .dropdown-toggle.btn-soundcloud {
  color: #ffffff;
  background-color: #cc4400;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-soundcloud:active,
.btn-soundcloud.active,
.open > .dropdown-toggle.btn-soundcloud {
  background-image: none;
}
.btn-soundcloud .badge {
  color: #ff5500;
  background-color: #ffffff;
}
.btn-tumblr {
  color: #ffffff;
  background-color: #2c4762;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-tumblr:focus,
.btn-tumblr.focus {
  color: #ffffff;
  background-color: #1c2d3f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-tumblr:hover {
  color: #ffffff;
  background-color: #1c2d3f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-tumblr:active,
.btn-tumblr.active,
.open > .dropdown-toggle.btn-tumblr {
  color: #ffffff;
  background-color: #1c2d3f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-tumblr:active,
.btn-tumblr.active,
.open > .dropdown-toggle.btn-tumblr {
  background-image: none;
}
.btn-tumblr .badge {
  color: #2c4762;
  background-color: #ffffff;
}
.btn-twitter {
  color: #ffffff;
  background-color: #55acee;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-twitter:focus,
.btn-twitter.focus {
  color: #ffffff;
  background-color: #2795e9;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-twitter:hover {
  color: #ffffff;
  background-color: #2795e9;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-twitter:active,
.btn-twitter.active,
.open > .dropdown-toggle.btn-twitter {
  color: #ffffff;
  background-color: #2795e9;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-twitter:active,
.btn-twitter.active,
.open > .dropdown-toggle.btn-twitter {
  background-image: none;
}
.btn-twitter .badge {
  color: #55acee;
  background-color: #ffffff;
}
.btn-vimeo {
  color: #ffffff;
  background-color: #1ab7ea;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-vimeo:focus,
.btn-vimeo.focus {
  color: #ffffff;
  background-color: #1295bf;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-vimeo:hover {
  color: #ffffff;
  background-color: #1295bf;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-vimeo:active,
.btn-vimeo.active,
.open > .dropdown-toggle.btn-vimeo {
  color: #ffffff;
  background-color: #1295bf;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-vimeo:active,
.btn-vimeo.active,
.open > .dropdown-toggle.btn-vimeo {
  background-image: none;
}
.btn-vimeo .badge {
  color: #1ab7ea;
  background-color: #ffffff;
}
.btn-vk {
  color: #ffffff;
  background-color: #587ea3;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-vk:focus,
.btn-vk.focus {
  color: #ffffff;
  background-color: #466482;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-vk:hover {
  color: #ffffff;
  background-color: #466482;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-vk:active,
.btn-vk.active,
.open > .dropdown-toggle.btn-vk {
  color: #ffffff;
  background-color: #466482;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-vk:active,
.btn-vk.active,
.open > .dropdown-toggle.btn-vk {
  background-image: none;
}
.btn-vk .badge {
  color: #587ea3;
  background-color: #ffffff;
}
.btn-yahoo {
  color: #ffffff;
  background-color: #720e9e;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-yahoo:focus,
.btn-yahoo.focus {
  color: #ffffff;
  background-color: #500a6f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-yahoo:hover {
  color: #ffffff;
  background-color: #500a6f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-yahoo:active,
.btn-yahoo.active,
.open > .dropdown-toggle.btn-yahoo {
  color: #ffffff;
  background-color: #500a6f;
  border-color: rgba(0, 0, 0, 0.2);
}
.btn-yahoo:active,
.btn-yahoo.active,
.open > .dropdown-toggle.btn-yahoo {
  background-image: none;
}
.btn-yahoo .badge {
  color: #720e9e;
  background-color: #ffffff;
}
/*
 * Plugin: Full Calendar
 * ---------------------
 */
.fc-button {
  background: #f4f4f4;
  background-image: none;
  color: #444;
  border-color: #ddd;
  border-bottom-color: #ddd;
}
.fc-button:hover,
.fc-button:active,
.fc-button.hover {
  background-color: #e9e9e9;
}
.fc-header-title h2 {
  font-size: 15px;
  line-height: 1.6em;
  color: #666;
  margin-left: 10px;
}
.fc-header-right {
  padding-right: 10px;
}
.fc-header-left {
  padding-left: 10px;
}
.fc-widget-header {
  background: #fafafa;
}
.fc-grid {
  width: 100%;
  border: 0;
}
.fc-widget-header:first-of-type,
.fc-widget-content:first-of-type {
  border-left: 0;
  border-right: 0;
}
.fc-widget-header:last-of-type,
.fc-widget-content:last-of-type {
  border-right: 0;
}
.fc-toolbar {
  padding: 10px;
  margin: 0;
}
.fc-day-number {
  font-size: 20px;
  font-weight: 300;
  padding-right: 10px;
}
.fc-color-picker {
  list-style: none;
  margin: 0;
  padding: 0;
}
.fc-color-picker > li {
  float: left;
  font-size: 30px;
  margin-right: 5px;
  line-height: 30px;
}
.fc-color-picker > li .fa {
  -webkit-transition: -webkit-transform linear 0.3s;
  -moz-transition: -moz-transform linear 0.3s;
  -o-transition: -o-transform linear 0.3s;
  transition: transform linear 0.3s;
}
.fc-color-picker > li .fa:hover {
  -webkit-transform: rotate(30deg);
  -ms-transform: rotate(30deg);
  -o-transform: rotate(30deg);
  transform: rotate(30deg);
}
#add-new-event {
  -webkit-transition: all linear 0.3s;
  -o-transition: all linear 0.3s;
  transition: all linear 0.3s;
}
.external-event {
  padding: 5px 10px;
  font-weight: bold;
  margin-bottom: 4px;
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
  text-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
  border-radius: 3px;
  cursor: move;
}
.external-event:hover {
  box-shadow: inset 0 0 90px rgba(0, 0, 0, 0.2);
}
/*
 * Plugin: Select2
 * ---------------
 */
.select2-container--default.select2-container--focus,
.select2-selection.select2-container--focus,
.select2-container--default:focus,
.select2-selection:focus,
.select2-container--default:active,
.select2-selection:active {
  outline: none;
}
.select2-container--default .select2-selection--single,
.select2-selection .select2-selection--single {
  border: 1px solid #d2d6de;
  border-radius: 0;
  padding: 6px 12px;
  height: 34px;
}
.select2-container--default.select2-container--open {
  border-color: #3c8dbc;
}
.select2-dropdown {
  border: 1px solid #d2d6de;
  border-radius: 0;
}
.select2-container--default .select2-results__option--highlighted[aria-selected] {
  background-color: #3c8dbc;
  color: white;
}
.select2-results__option {
  padding: 6px 12px;
  user-select: none;
  -webkit-user-select: none;
}
.select2-container .select2-selection--single .select2-selection__rendered {
  padding-left: 0;
  padding-right: 0;
  height: auto;
  margin-top: -4px;
}
.select2-container[dir="rtl"] .select2-selection--single .select2-selection__rendered {
  padding-right: 6px;
  padding-left: 20px;
}
.select2-container--default .select2-selection--single .select2-selection__arrow {
  height: 28px;
  right: 3px;
}
.select2-container--default .select2-selection--single .select2-selection__arrow b {
  margin-top: 0;
}
.select2-dropdown .select2-search__field,
.select2-search--inline .select2-search__field {
  border: 1px solid #d2d6de;
}
.select2-dropdown .select2-search__field:focus,
.select2-search--inline .select2-search__field:focus {
  outline: none;
  border: 1px solid #3c8dbc;
}
.select2-container--default .select2-results__option[aria-disabled=true] {
  color: #999;
}
.select2-container--default .select2-results__option[aria-selected=true] {
  background-color: #ddd;
}
.select2-container--default .select2-results__option[aria-selected=true],
.select2-container--default .select2-results__option[aria-selected=true]:hover {
  color: #444;
}
.select2-container--default .select2-selection--multiple {
  border: 1px solid #d2d6de;
  border-radius: 0;
}
.select2-container--default .select2-selection--multiple:focus {
  border-color: #3c8dbc;
}
.select2-container--default.select2-container--focus .select2-selection--multiple {
  border-color: #d2d6de;
}
.select2-container--default .select2-selection--multiple .select2-selection__choice {
  background-color: #3c8dbc;
  border-color: #367fa9;
  padding: 1px 10px;
  color: #fff;
}
.select2-container--default .select2-selection--multiple .select2-selection__choice__remove {
  margin-right: 5px;
  color: rgba(255, 255, 255, 0.7);
}
.select2-container--default .select2-selection--multiple .select2-selection__choice__remove:hover {
  color: #fff;
}
.select2-container .select2-selection--single .select2-selection__rendered {
  padding-right: 10px;
}
/*
 * General: Miscellaneous
 * ----------------------
 */
.pad {
  padding: 10px;
}
.margin {
  margin: 10px;
}
.margin-bottom {
  margin-bottom: 20px;
}
.margin-bottom-none {
  margin-bottom: 0;
}
.margin-r-5 {
  margin-right: 5px;
}
.inline {
  display: inline;
}
.description-block {
  display: block;
  margin: 10px 0;
  text-align: center;
}
.description-block.margin-bottom {
  margin-bottom: 25px;
}
.description-block > .description-header {
  margin: 0;
  padding: 0;
  font-weight: 600;
  font-size: 16px;
}
.description-block > .description-text {
  text-transform: uppercase;
}
.bg-red,
.bg-yellow,
.bg-aqua,
.bg-blue,
.bg-light-blue,
.bg-green,
.bg-navy,
.bg-teal,
.bg-olive,
.bg-lime,
.bg-orange,
.bg-fuchsia,
.bg-purple,
.bg-maroon,
.bg-black,
.bg-red-active,
.bg-yellow-active,
.bg-aqua-active,
.bg-blue-active,
.bg-light-blue-active,
.bg-green-active,
.bg-navy-active,
.bg-teal-active,
.bg-olive-active,
.bg-lime-active,
.bg-orange-active,
.bg-fuchsia-active,
.bg-purple-active,
.bg-maroon-active,
.bg-black-active,
.callout.callout-danger,
.callout.callout-warning,
.callout.callout-info,
.callout.callout-success,
.alert-success,
.alert-danger,
.alert-error,
.alert-warning,
.alert-info,
.label-danger,
.label-info,
.label-warning,
.label-primary,
.label-success,
.modal-primary .modal-body,
.modal-primary .modal-header,
.modal-primary .modal-footer,
.modal-warning .modal-body,
.modal-warning .modal-header,
.modal-warning .modal-footer,
.modal-info .modal-body,
.modal-info .modal-header,
.modal-info .modal-footer,
.modal-success .modal-body,
.modal-success .modal-header,
.modal-success .modal-footer,
.modal-danger .modal-body,
.modal-danger .modal-header,
.modal-danger .modal-footer {
  color: #fff !important;
}
.bg-gray {
  color: #000;
  background-color: #d2d6de !important;
}
.bg-gray-light {
  background-color: #f7f7f7;
}
.bg-black {
  background-color: #111111 !important;
}
.bg-red,
.callout.callout-danger,
.alert-danger,
.alert-error,
.label-danger,
.modal-danger .modal-body {
  background-color: #dd4b39 !important;
}
.bg-yellow,
.callout.callout-warning,
.alert-warning,
.label-warning,
.modal-warning .modal-body {
  background-color: #f39c12 !important;
}
.bg-aqua,
.callout.callout-info,
.alert-info,
.label-info,
.modal-info .modal-body {
  background-color: #00c0ef !important;
}
.bg-blue {
  background-color: #0073b7 !important;
}
.bg-light-blue,
.label-primary,
.modal-primary .modal-body {
  background-color: #3c8dbc !important;
}
.bg-green,
.callout.callout-success,
.alert-success,
.label-success,
.modal-success .modal-body {
  background-color: #00a65a !important;
}
.bg-navy {
  background-color: #001f3f !important;
}
.bg-teal {
  background-color: #39cccc !important;
}
.bg-olive {
  background-color: #3d9970 !important;
}
.bg-lime {
  background-color: #01ff70 !important;
}
.bg-orange {
  background-color: #ff851b !important;
}
.bg-fuchsia {
  background-color: #f012be !important;
}
.bg-purple {
  background-color: #605ca8 !important;
}
.bg-maroon {
  background-color: #d81b60 !important;
}
.bg-gray-active {
  color: #000;
  background-color: #b5bbc8 !important;
}
.bg-black-active {
  background-color: #000000 !important;
}
.bg-red-active,
.modal-danger .modal-header,
.modal-danger .modal-footer {
  background-color: #d33724 !important;
}
.bg-yellow-active,
.modal-warning .modal-header,
.modal-warning .modal-footer {
  background-color: #db8b0b !important;
}
.bg-aqua-active,
.modal-info .modal-header,
.modal-info .modal-footer {
  background-color: #00a7d0 !important;
}
.bg-blue-active {
  background-color: #005384 !important;
}
.bg-light-blue-active,
.modal-primary .modal-header,
.modal-primary .modal-footer {
  background-color: #357ca5 !important;
}
.bg-green-active,
.modal-success .modal-header,
.modal-success .modal-footer {
  background-color: #008d4c !important;
}
.bg-navy-active {
  background-color: #001a35 !important;
}
.bg-teal-active {
  background-color: #30bbbb !important;
}
.bg-olive-active {
  background-color: #368763 !important;
}
.bg-lime-active {
  background-color: #00e765 !important;
}
.bg-orange-active {
  background-color: #ff7701 !important;
}
.bg-fuchsia-active {
  background-color: #db0ead !important;
}
.bg-purple-active {
  background-color: #555299 !important;
}
.bg-maroon-active {
  background-color: #ca195a !important;
}
[class^="bg-"].disabled {
  opacity: 0.65;
  filter: alpha(opacity=65);
}
.text-red {
  color: #dd4b39 !important;
}
.text-yellow {
  color: #f39c12 !important;
}
.text-aqua {
  color: #00c0ef !important;
}
.text-blue {
  color: #0073b7 !important;
}
.text-black {
  color: #111111 !important;
}
.text-light-blue {
  color: #3c8dbc !important;
}
.text-green {
  color: #00a65a !important;
}
.text-gray {
  color: #d2d6de !important;
}
.text-navy {
  color: #001f3f !important;
}
.text-teal {
  color: #39cccc !important;
}
.text-olive {
  color: #3d9970 !important;
}
.text-lime {
  color: #01ff70 !important;
}
.text-orange {
  color: #ff851b !important;
}
.text-fuchsia {
  color: #f012be !important;
}
.text-purple {
  color: #605ca8 !important;
}
.text-maroon {
  color: #d81b60 !important;
}
.link-muted {
  color: #7a869d;
}
.link-muted:hover,
.link-muted:focus {
  color: #606c84;
}
.link-black {
  color: #666;
}
.link-black:hover,
.link-black:focus {
  color: #999;
}
.hide {
  display: none !important;
}
.no-border {
  border: 0 !important;
}
.no-padding {
  padding: 0 !important;
}
.no-margin {
  margin: 0 !important;
}
.no-shadow {
  box-shadow: none !important;
}
.list-unstyled,
.chart-legend,
.contacts-list,
.users-list,
.mailbox-attachments {
  list-style: none;
  margin: 0;
  padding: 0;
}
.list-group-unbordered > .list-group-item {
  border-left: 0;
  border-right: 0;
  border-radius: 0;
  padding-left: 0;
  padding-right: 0;
}
.flat {
  border-radius: 0 !important;
}
.text-bold,
.text-bold.table td,
.text-bold.table th {
  font-weight: 700;
}
.text-sm {
  font-size: 12px;
}
.jqstooltip {
  padding: 5px !important;
  width: auto !important;
  height: auto !important;
}
.bg-teal-gradient {
  background: #39cccc !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #39cccc), color-stop(1, #7adddd)) !important;
  background: -ms-linear-gradient(bottom, #39cccc, #7adddd) !important;
  background: -moz-linear-gradient(center bottom, #39cccc 0%, #7adddd 100%) !important;
  background: -o-linear-gradient(#7adddd, #39cccc) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#7adddd', endColorstr='#39cccc', GradientType=0) !important;
  color: #fff;
}
.bg-light-blue-gradient {
  background: #3c8dbc !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #3c8dbc), color-stop(1, #67a8ce)) !important;
  background: -ms-linear-gradient(bottom, #3c8dbc, #67a8ce) !important;
  background: -moz-linear-gradient(center bottom, #3c8dbc 0%, #67a8ce 100%) !important;
  background: -o-linear-gradient(#67a8ce, #3c8dbc) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#67a8ce', endColorstr='#3c8dbc', GradientType=0) !important;
  color: #fff;
}
.bg-blue-gradient {
  background: #0073b7 !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #0073b7), color-stop(1, #0089db)) !important;
  background: -ms-linear-gradient(bottom, #0073b7, #0089db) !important;
  background: -moz-linear-gradient(center bottom, #0073b7 0%, #0089db 100%) !important;
  background: -o-linear-gradient(#0089db, #0073b7) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#0089db', endColorstr='#0073b7', GradientType=0) !important;
  color: #fff;
}
.bg-aqua-gradient {
  background: #00c0ef !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #00c0ef), color-stop(1, #14d1ff)) !important;
  background: -ms-linear-gradient(bottom, #00c0ef, #14d1ff) !important;
  background: -moz-linear-gradient(center bottom, #00c0ef 0%, #14d1ff 100%) !important;
  background: -o-linear-gradient(#14d1ff, #00c0ef) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#14d1ff', endColorstr='#00c0ef', GradientType=0) !important;
  color: #fff;
}
.bg-yellow-gradient {
  background: #f39c12 !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #f39c12), color-stop(1, #f7bc60)) !important;
  background: -ms-linear-gradient(bottom, #f39c12, #f7bc60) !important;
  background: -moz-linear-gradient(center bottom, #f39c12 0%, #f7bc60 100%) !important;
  background: -o-linear-gradient(#f7bc60, #f39c12) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#f7bc60', endColorstr='#f39c12', GradientType=0) !important;
  color: #fff;
}
.bg-purple-gradient {
  background: #605ca8 !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #605ca8), color-stop(1, #9491c4)) !important;
  background: -ms-linear-gradient(bottom, #605ca8, #9491c4) !important;
  background: -moz-linear-gradient(center bottom, #605ca8 0%, #9491c4 100%) !important;
  background: -o-linear-gradient(#9491c4, #605ca8) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#9491c4', endColorstr='#605ca8', GradientType=0) !important;
  color: #fff;
}
.bg-green-gradient {
  background: #00a65a !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #00a65a), color-stop(1, #00ca6d)) !important;
  background: -ms-linear-gradient(bottom, #00a65a, #00ca6d) !important;
  background: -moz-linear-gradient(center bottom, #00a65a 0%, #00ca6d 100%) !important;
  background: -o-linear-gradient(#00ca6d, #00a65a) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00ca6d', endColorstr='#00a65a', GradientType=0) !important;
  color: #fff;
}
.bg-red-gradient {
  background: #dd4b39 !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #dd4b39), color-stop(1, #e47365)) !important;
  background: -ms-linear-gradient(bottom, #dd4b39, #e47365) !important;
  background: -moz-linear-gradient(center bottom, #dd4b39 0%, #e47365 100%) !important;
  background: -o-linear-gradient(#e47365, #dd4b39) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#e47365', endColorstr='#dd4b39', GradientType=0) !important;
  color: #fff;
}
.bg-black-gradient {
  background: #111111 !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #111111), color-stop(1, #2b2b2b)) !important;
  background: -ms-linear-gradient(bottom, #111111, #2b2b2b) !important;
  background: -moz-linear-gradient(center bottom, #111111 0%, #2b2b2b 100%) !important;
  background: -o-linear-gradient(#2b2b2b, #111111) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#2b2b2b', endColorstr='#111111', GradientType=0) !important;
  color: #fff;
}
.bg-maroon-gradient {
  background: #d81b60 !important;
  background: -webkit-gradient(linear, left bottom, left top, color-stop(0, #d81b60), color-stop(1, #e73f7c)) !important;
  background: -ms-linear-gradient(bottom, #d81b60, #e73f7c) !important;
  background: -moz-linear-gradient(center bottom, #d81b60 0%, #e73f7c 100%) !important;
  background: -o-linear-gradient(#e73f7c, #d81b60) !important;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#e73f7c', endColorstr='#d81b60', GradientType=0) !important;
  color: #fff;
}
.description-block .description-icon {
  font-size: 16px;
}
.no-pad-top {
  padding-top: 0;
}
.position-static {
  position: static !important;
}
.list-header {
  font-size: 15px;
  padding: 10px 4px;
  font-weight: bold;
  color: #666;
}
.list-seperator {
  height: 1px;
  background: #f4f4f4;
  margin: 15px 0 9px 0;
}
.list-link > a {
  padding: 4px;
  color: #777;
}
.list-link > a:hover {
  color: #222;
}
.font-light {
  font-weight: 300;
}
.user-block:before,
.user-block:after {
  content: " ";
  display: table;
}
.user-block:after {
  clear: both;
}
.user-block img {
  width: 40px;
  height: 40px;
  float: left;
}
.user-block .username,
.user-block .description,
.user-block .comment {
  display: block;
  margin-left: 50px;
}
.user-block .username {
  font-size: 16px;
  font-weight: 600;
}
.user-block .description {
  color: #999;
  font-size: 13px;
}
.user-block.user-block-sm .username,
.user-block.user-block-sm .description,
.user-block.user-block-sm .comment {
  margin-left: 40px;
}
.user-block.user-block-sm .username {
  font-size: 14px;
}
.img-sm,
.img-md,
.img-lg,
.box-comments .box-comment img,
.user-block.user-block-sm img {
  float: left;
}
.img-sm,
.box-comments .box-comment img,
.user-block.user-block-sm img {
  width: 30px !important;
  height: 30px !important;
}
.img-sm + .img-push {
  margin-left: 40px;
}
.img-md {
  width: 60px;
  height: 60px;
}
.img-md + .img-push {
  margin-left: 70px;
}
.img-lg {
  width: 100px;
  height: 100px;
}
.img-lg + .img-push {
  margin-left: 110px;
}
.img-bordered {
  border: 3px solid #d2d6de;
  padding: 3px;
}
.img-bordered-sm {
  border: 2px solid #d2d6de;
  padding: 2px;
}
.attachment-block {
  border: 1px solid #f4f4f4;
  padding: 5px;
  margin-bottom: 10px;
  background: #f7f7f7;
}
.attachment-block .attachment-img {
  max-width: 100px;
  max-height: 100px;
  height: auto;
  float: left;
}
.attachment-block .attachment-pushed {
  margin-left: 110px;
}
.attachment-block .attachment-heading {
  margin: 0;
}
.attachment-block .attachment-text {
  color: #555;
}
.connectedSortable {
  min-height: 100px;
}
.ui-helper-hidden-accessible {
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}
.sort-highlight {
  background: #f4f4f4;
  border: 1px dashed #ddd;
  margin-bottom: 10px;
}
.full-opacity-hover {
  opacity: 0.65;
  filter: alpha(opacity=65);
}
.full-opacity-hover:hover {
  opacity: 1;
  filter: alpha(opacity=100);
}
.chart {
  position: relative;
  overflow: hidden;
  width: 100%;
}
.chart svg,
.chart canvas {
  width: 100% !important;
}
/*
 * Misc: print
 * -----------
 */
@media print {
  .no-print,
  .main-sidebar,
  .left-side,
  .main-header,
  .content-header {
    display: none !important;
  }
  .content-wrapper,
  .right-side,
  .main-footer {
    margin-left: 0 !important;
    min-height: 0 !important;
    -webkit-transform: translate(0, 0) !important;
    -ms-transform: translate(0, 0) !important;
    -o-transform: translate(0, 0) !important;
    transform: translate(0, 0) !important;
  }
  .fixed .content-wrapper,
  .fixed .right-side {
    padding-top: 0 !important;
  }
  .invoice {
    width: 100%;
    border: 0;
    margin: 0;
    padding: 0;
  }
  .invoice-col {
    float: left;
    width: 33.3333333%;
  }
  .table-responsive {
    overflow: auto;
  }
  .table-responsive > .table tr th,
  .table-responsive > .table tr td {
    white-space: normal !important;
  }
}

```

`frontend/app/views/app.case.html`:

```html
<div class="row case-page">
    <div ng-Class="{ 'col-md-9': appLayout.showFlow, 'col-md-12': !appLayout.showFlow}">
        <div class="row">
            <div class="col-md-12" ng-include="'views/partials/case/case.panelinfo.html'"></div>
        </div>
        <div class="row">
            <div class="col-md-12">
                <uib-tabset type="tabs" active="tabSrv.activeIndex" class="nav-tabs-custom main-tabset">
                    <uib-tab ng-click="openTab(name)" ng-init="tab = tabs[name];" ng-repeat="name in notSorted(tabs)">
                        <uib-tab-heading ng-switch on="name">
                            <span ng-switch-when="details">
                                <i class="glyphicon glyphicon-folder-open"></i>&nbsp;&nbsp;
                                {{tab.label}}
                            </span>

                            <span ng-switch-when="tasks">
                                <i class="glyphicon glyphicon-tasks"></i>&nbsp;&nbsp;{{tab.label}}&nbsp;&nbsp;
                                <span class="badge">{{tasksCount}}</span>
                            </span>

                            <span ng-switch-when="observables">
                                <i class="glyphicon glyphicon-pushpin"></i>&nbsp;&nbsp; Observables&nbsp;&nbsp;
                                <span class="badge badge-primary">{{observablesCount}}</span>
                            </span>

                            <span ng-switch-when="procedures">
                                <i class="glyphicon glyphicon-knight"></i>&nbsp;&nbsp; TTPs&nbsp;&nbsp;
                            </span>

                            <span ng-switch-default>
                                <span ng-switch on="name[0]">
                                    <span ng-switch-when="t">
                                        <i class="glyphicon glyphicon-tasks"></i> <strong>&nbsp;&nbsp;{{tab.label |
                                            limitTo:25}}&nbsp;&nbsp;</strong>
                                    </span>
                                    <span ng-switch-when="o">
                                        <i class="glyphicon glyphicon-pushpin" ng-switch-when="o"></i>
                                        <strong>&nbsp;&nbsp;{{tab.label | fang | limitTo:25}}&nbsp;&nbsp;</strong>
                                    </span>
                                    <span ng-switch-default>
                                        <strong>&nbsp;&nbsp;{{tab.label | limitTo:25}}&nbsp;&nbsp;</strong>
                                    </span>
                                </span>

                                <a href ng-click="removeTab(name)" ng-if="tab.closable">
                                    <i class="text-muted glyphicon glyphicon-remove-circle" ng-class="textTask"
                                        ng-mouseout="textTask='text-muted'" ng-mouseover="textTask='text-danger'"></i>
                                </a>
                            </span>
                        </uib-tab-heading>
                    </uib-tab>
                </uib-tabset>
                <div ui-view class="case-page-content"></div>
            </div>
        </div>

    </div>

    <div ng-show="appLayout.showFlow" class="col-md-3">
        <div class="box">
            <div class="box-header">
                <h3 class="box-title">&nbsp;</h3>
                <div class="box-tools pull-right">
                    <span class="ml-xs" tooltip="Open in new window">
                        <a class="text-muted" href ng-click="layoutSrv.detachFlow()">
                            <i class="fa fa-external-link"></i> Open in new window
                        </a>
                    </span>

                    <span class="ml-xs" tooltip="Hide">
                        <a class="text-muted" href ng-click="layoutSrv.showFlow(false)">
                            <i class="fa fa-minus"></i> Hide
                        </a>
                    </span>
                </div>
            </div>
            <div class="box-body no-padding">
                <flow ng-if="caze._id" root="{{caze._id}}"></flow>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/app.html`:

```html
<app-container class="wrapper"></app-container>

```

`frontend/app/views/components/alert/observable-list.component.html`:

```html
<div class="alert-observable-list">

    <div ng-include="'views/components/alert/observables/toolbar.html'"></div>

    <div class="mt-xs filter-panel" ng-include="'views/components/alert/observables/filters.html'"
        ng-show="$cmp.filtering.context.showFilters"></div>

    <div class="row mt-xs">
        <div class="col-md-12 clearfix">

            <filters-preview filters="$cmp.filtering.context.filters" on-clear-item="$cmp.removeFilter(field)"
                on-clear-all="$cmp.clearFilters()"></filters-preview>
        </div>
    </div>

    <div class="row">

        <div class="col-md-12" ng-show="$cmp.list.total === 0 && $cmp.list.values.length === 0">
            <div class="empty-message">No records</div>
        </div>

        <div class="col-md-12" ng-show="!$cmp.list.loading && $cmp.list.values.length !== 0">
            <psearch control="$cmp.list"></psearch>

            <table class="table table-striped">
                <thead>
                    <tr>
                        <th style="width:50px;">Flags</th>
                        <th style="width:100px;">Type</th>
                        <th>Data</th>
                        <th style="width: 120px">Date Added</th>
                    </tr>
                </thead>
                <tbody>
                    <tr ng-repeat="observable in $cmp.list.values">
                        <td class="nowrap">
                            <observable-flags observable="observable" inline="true"
                                on-filter="$cmp.addFilterValue(fieldName, value)"></observable-flags>
                        </td>
                        <td>
                            <a href
                                ng-click="$cmp.addFilterValue('dataType', observable.dataType)">{{observable.dataType}}</a>
                        </td>
                        <td class="wrap">
                            <div class="wrap" ng-if="observable.dataType !== 'file'"
                                uib-tooltip="{{observable.message}}" tooltip-placement="top-left">
                                {{observable.data | fang | ellipsis:250}}
                            </div>
                            <div class="wrap" ng-if="observable.dataType === 'file' && observable.attachment"
                                uib-tooltip="{{observable.message}}" tooltip-placement="top-left">
                                {{observable.attachment.name}} ({{observable.attachment.size}} bytes)
                            </div>
                            <div class="wrap" ng-if="observable.dataType === 'file' && observable.remoteAttachment"
                                uib-tooltip="{{observable.message}}" tooltip-placement="top-left">
                                {{observable.remoteAttachment.filename}}
                            </div>
                            <div class="case-tags flexwrap mt-xxs" ng-if="observable.tags.length > 0">
                                <strong><i class="fa fa-tags mr-xxxs"></i></strong>
                                <tag-item ng-repeat="tag in observable.tags track by $index"
                                    ng-click="$cmp.addFilterValue('tags', tag)" value="tag"></tag-item>
                            </div>
                        </td>
                        <td>
                            <a href
                                ng-click="$cmp.addFilterValue('_createdAt', observable._createdAt)">{{observable._createdAt
                                | shortDate}}</a>
                        </td>
                    </tr>
                </tbody>
            </table>

            <psearch control="$cmp.list"></psearch>
        </div>
    </div>
</div>

```

`frontend/app/views/components/alert/observables/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>
        <form ng-submit="$cmp.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $cmp.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$cmp.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item.name as item.name for (key, item) in $cmp.filtering.attributes"
                            ng-change="$cmp.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$cmp.filtering.metadata" filter="filter" entity="$cmp.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$cmp.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$cmp.clearFilters()" ng-if="$cmp.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$cmp.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/components/alert/observables/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">
            <div class="pull-left">
                <h4>
                    <datalist-header title="List of observables" list="$cmp.list" total="$cmp.observablesCount">
                    </datalist-header>
                </h4>

            </div>

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$cmp.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm"
                    ng-class="{true: 'btn-primary', false:'btn-default'}[$cmp.filtering.context.showFilters]"
                    type="button" ng-click="$cmp.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/components/alert/similar-case-list.component.html`:

```html
<div class="similar-case-list">

    <div ng-include="'views/components/alert/similarity/toolbar.html'"></div>

    <div class="mt-xs filter-panel" ng-include="'views/components/alert/similarity/filters.html'"
        ng-show="$cmp.filtering.context.showFilters"></div>

    <div class="row mt-xs">
        <div class="col-md-12 clearfix">

            <filters-preview filters="$cmp.filtering.context.filters" on-clear-item="$cmp.removeFilter(field)"
                on-clear-all="$cmp.clearFilters()"></filters-preview>
        </div>
    </div>

    <div class="row">

        <div class="col-md-12" ng-show="$cmp.list.total === 0">
            <div class="empty-message">No records</div>
        </div>

        <div class="col-md-12" ng-show="$cmp.list.total > 0">
            <!-- Client side pagination -->
            <div class="text-center" ng-show="$cmp.filteredCases.length > $cmp.pagination.pageSize">
                <ul uib-pagination class="pagination-sm" boundary-links="true" max-size="5" rotate="false"
                    total-items="$cmp.filteredCases.length" items-per-page="$cmp.pagination.pageSize"
                    ng-model="$cmp.pagination.currentPage"></ul>
            </div>

            <!-- Table header -->
            <div class="case-item">
                <div class="case-details text-bold">
                    <a href class="text-default" ng-click="$cmp.sortByField('fTitle')">
                        Title
                        <i ng-show="$cmp.sortField !== '+fTitle' && $cmp.sortField !== '-fTitle'"
                            class="fa fa-sort"></i>
                        <i ng-show="$cmp.sortField === '+fTitle'" class="fa fa-caret-up"></i>
                        <i ng-show="$cmp.sortField === '-fTitle'" class="fa fa-caret-down"></i>
                    </a>
                </div>
                <div class="case-date text-bold">
                    <a href class="text-default" ng-click="$cmp.sortByField('sCreatedAt')">
                        Created At
                        <i ng-show="$cmp.sortField !== '+sCreatedAt' && $cmp.sortField !== '-sCreatedAt'"
                            class="fa fa-sort"></i>
                        <i ng-show="$cmp.sortField === '+sCreatedAt'" class="fa fa-caret-up"></i>
                        <i ng-show="$cmp.sortField === '-sCreatedAt'" class="fa fa-caret-down"></i>
                    </a>
                </div>
                <div class="case-similarity text-bold">
                    <a href class="text-default" ng-click="$cmp.sortByField('fObservables')">
                        Observables
                        <i ng-show="$cmp.sortField !== '+fObservables' && $cmp.sortField !== '-fObservables'"
                            class="fa fa-sort"></i>
                        <i ng-show="$cmp.sortField === '+fObservables'" class="fa fa-caret-up"></i>
                        <i ng-show="$cmp.sortField === '-fObservables'" class="fa fa-caret-down"></i>
                    </a>
                </div>
                <div class="case-similarity text-bold">
                    <a href class="text-default" ng-click="$cmp.sortByField('fIocs')">
                        IOCs
                        <i ng-show="$cmp.sortField !== '+fIocs' && $cmp.sortField !== '-fIocs'" class="fa fa-sort"></i>
                        <i ng-show="$cmp.sortField === '+fIocs'" class="fa fa-caret-up"></i>
                        <i ng-show="$cmp.sortField === '-fIocs'" class="fa fa-caret-down"></i>
                    </a>
                </div>
                <div class="case-similarity-match text-bold">Matches</div>
                <div class="case-similarity-merge text-bold">Action</div>
            </div>

            <!-- Table filter -->
            <div class="case-item filter-panel">
                <div class="case-details text-bold">
                    <div class="form-group has-feedback has-clear">
                        <input type="text" class="form-control input-sm" ng-model="$cmp.similarityFilters.fTitle"
                            placeholder="Filter by title">
                        <a class="fa fa-times-circle form-control-feedback form-control-clear text-muted"
                            ng-click="$cmp.similarityFilters.fTitle = undefined"
                            style="pointer-events: auto;cursor: pointer;"></a>
                    </div>
                </div>
                <div class="case-date text-bold"></div>
                <div class="case-similarity text-bold">
                    <div class="form-group has-feedback has-clear">
                        <input type="number" class="form-control input-sm" ng-model="$cmp.rateFilters.fObservables"
                            placeholder="% min.">
                        <a class="fa fa-times-circle form-control-feedback form-control-clear text-muted"
                            ng-click="$cmp.rateFilters.fObservables = undefined"
                            style="pointer-events: auto;cursor: pointer;"></a>
                    </div>
                </div>
                <div class="case-similarity text-bold">
                    <div class="form-group has-feedback has-clear">
                        <input type="number" class="form-control input-sm" ng-model="$cmp.rateFilters.fIocs"
                            placeholder="% min." step="1" min="0">
                        <a class="fa fa-times-circle form-control-feedback form-control-clear text-muted"
                            ng-click="$cmp.rateFilters.fIocs = undefined"
                            style="pointer-events: auto;cursor: pointer;"></a>
                    </div>
                </div>
                <div class="case-similarity-match text-bold">
                    <div>
                        <multiselect ng-model="$cmp.matchFilters.fMatches" options="$cmp.matches" show-select-all="true"
                            show-unselect-all="true" classes-btn="'btn-default btn-block btn-sm'"></multiselect>
                    </div>
                </div>
                <div class="case-similarity-merge text-bold">
                    <div class="text-center">
                        <a class="btn btn-link btn-clear btn-sm" ng-click="$cmp.clearLocalFilters()"><i
                                class="fa fa-times"></i> Clear Filters</a>
                    </div>
                </div>
            </div>

            <!-- Table data -->
            <div class="case-collection"
                ng-repeat="item in ($cmp.filteredCases = ($cmp.list.allValues | filter:$cmp.similarityFilters | filter:$cmp.matchFilter() | filter:$cmp.greaterThan('fObservables') | filter:$cmp.greaterThan('fIocs')) | orderBy:$cmp.sortField | limitTo:$cmp.pagination.pageSize:($cmp.pagination.currentPage-1)*$cmp.pagination.pageSize)">
                <div class="case-item">
                    <!-- case tlp -->
                    <div class="case-tlp bg-tlp-{{item.case.tlp}} clickable"
                        ng-click="$cmp.addFilterValue('tlp', item.case.tlp)"></div>

                    <!-- case title and main details -->
                    <div class="case-details">
                        <div class="case-title">
                            <a ui-sref="app.case.details({caseId: item.case._id})" target="_blank">#{{item.case.number}}
                                - {{item.case.title}}</a>
                        </div>
                        <div class="case-tags flexwrap mt-xxs">
                            <span class="mr-xxxs text-muted"><i class="fa fa-tags"></i></span>
                            <strong class="text-muted mr-xxxs"
                                ng-if="!item.case.tags || item.case.tags.length === 0">None</strong>
                            <tag-item ng-repeat="tag in item.case.tags track by $index"
                                ng-click="$cmp.addFilterValue('tags', tag)" class="pointer" value="tag"></tag-item>
                        </div>
                        <div class="text-success" ng-show="item.case.status !== 'Open'">
                            <small>
                                (Closed at {{item.case.endDate | shortDate}} as
                                <strong>{{$cmp.CaseResolutionStatus[item.case.resolutionStatus]}}</strong>)
                            </small>
                        </div>
                        <div class="text-danger" ng-if="item.case.mergeFrom">
                            <small>
                                Merged from <a href ui-sref="app.case.details({caseId: item.case.mergeFrom[0]})"> Case
                                    #{{item.case.stats.mergeFrom[0].caseId}}</a> and
                                <a href ui-sref="app.case.details({caseId: item.case.mergeFrom[1]})"> Case
                                    #{{utem.stats.mergeFrom[1].caseId}}</a>
                            </small>
                        </div>
                    </div>

                    <div class="case-severity">
                        <div class="clickable" ng-click="$cmp.addFilterValue('severity', item.case.severity)">
                            <severity active="false" value="item.case.severity"></severity>
                        </div>
                    </div>

                    <div class="case-date">
                        <a href ng-click="$cmp.addFilterValue('_createdAt', item.case._createdAt)">
                            <span uib-tooltip="{{item.case._createdAt | shortDate}}" tooltip-popup-delay="500"
                                tooltip-placement="bottom">{{item.case._createdAt | shortDate}}</span>
                        </a>
                    </div>

                    <div class="case-similarity">
                        <div>
                            <a href ng-click="$cmp.rateFilters.fObservables = item.fObservables"><strong>{{item.fObservables
                                    | number:0}} %</strong></a> ({{item.similarObservableCount}} /
                            {{item.observableCount}})
                            <uib-progressbar class="progress progress-sm" max="item.observableCount"
                                value="item.similarObservableCount" type="primary"></uib-progressbar>
                        </div>
                    </div>
                    <div class="case-similarity">
                        <div ng-if="item.iocCount > 0">
                            <a href ng-click="$cmp.rateFilters.fIocs = item.fIocs"><strong>{{item.fIocs | number:0}}
                                    %</strong></a> ({{item.similarIocCount}} / {{item.iocCount}})
                            <uib-progressbar class="progress progress-sm" max="item.iocCount"
                                value="item.similarIocCount" type="danger"></uib-progressbar>
                        </div>
                        <div ng-if="item.iocCount === 0">
                            <em>N/A</em>
                        </div>
                    </div>
                    <div class="case-similarity-match">
                        <div>
                            <div ng-repeat="(match, count) in item.observableTypes track by $index">{{match}}
                                ({{count}})</div>
                        </div>
                    </div>

                    <div class="case-similarity-merge text-center">
                        <button class="btn btn-sm btn-primary" ng-click="$cmp.merge(item.case._id)"
                            ng-if="!!!$cmp.readonly && !($cmp.state.disallowMerge && item.case.status === 'Resolved')">Merge
                            in this case</button>
                    </div>
                </div>
            </div>

        </div>

    </div>
</div>

```

`frontend/app/views/components/alert/similarity/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>
        <form ng-submit="$cmp.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $cmp.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$cmp.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item.name as item.name for (key, item) in $cmp.filtering.attributes"
                            ng-change="$cmp.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$cmp.filtering.metadata" filter="filter" entity="$cmp.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$cmp.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$cmp.clearFilters()" ng-if="$cmp.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$cmp.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/components/alert/similarity/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <div class="btn-group" uib-dropdown>
                <button class="btn btn-primary btn-sm dropdown-toggle" uib-dropdown-toggle type="button">
                    <i class="fa fa-filter"></i>
                    Quick Filters
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a ng-click="$cmp.applyDefaultFilter()"><i class="fa fa-filter"></i> Default filter</a>
                    </li>
                    <li class="divider"></li>
                    <li>
                        <a ng-click="$cmp.filterBy('status', 'Open')"><i class="fa fa-folder-open-o"></i> Open cases</a>
                    </li>
                    <li>
                        <a ng-click="$cmp.filterBy('status', 'Resolved')"><i class="fa fa-folder-o"></i> Closed cases</a>
                    </li>
                    <li class="divider"></li>
                    <li>
                        <a ng-click="$cmp.filterBy('resolutionStatus', 'TruePositive')"><i class="fa fa-exclamation-circle"></i> Closed - True Positive</a>
                    </li>
                    <li>
                        <a ng-click="$cmp.filterBy('resolutionStatus', 'Indeterminate')"><i class="fa fa-question-circle-o "></i> Closed - Indeterminate</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group pull-right" role="group">
                <!-- <page-sizer collection="$cmp.list" sizes="[1, 2, 3, 10, 15, 30, 100]"></page-sizer> -->
                <div class="page-sizer">
                    <select class="form-control input-sm"
                        ng-model="$cmp.pagination.pageSize"
                        ng-options="v for v in [10,15,30,50]"></select>
                    <span class="page-sizer-label nowrap ml-xxs">per page</span>
                </div>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$cmp.filtering.context.showFilters]" type="button" ng-click="$cmp.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/components/app-container.component.html`:

```html
<header class="main-header"></header>
<!--<main-sidebar class="main-sidebar"></main-sidebar>-->
<div class="content-wrapper" fixed-height>
	<div class="container-fluid container-main" ng-if="currentUser.login">

        <div class="text-danger" ng-repeat="schema in appConfig.schemaStatus" ng-if="schema.error">
            <div class="callout callout-danger">
                <h4>Error in {{schema.name}} schema: expected version {{schema.expectedVersion}}, got {{schema.currentVersion}}</h4>
                <p>Please contact the administrator</p>
            </div>
        </div>

        <ui-view />

	</div>
</div>
<footer class="main-footer">
	<div class="container-fluid">
		<div class="pull-right hidden-xs">
			<span>
				<strong>Version</strong>: {{appConfig.versions.TheHive}}
			</span>
			<!--
				show appConfig.connectors.cortex.status (OK, WARNING or ERROR)
				and in tooltip the list of appConfig.connectors.cortex.server (property name, status and version)
			-->
			<span ng-if="appConfig.connectors.cortex.enabled" uib-tooltip="Cortex integration enabled">
				<img class="footer-logo logo-{{appConfig.connectors.cortex.status | lowercase}}" src="images/cortex-logo.svg"/>
			</span>
			<!--
				show appConfig.connectors.misp.status (OK, WARNING or ERROR)
				and in tooltip the list of appConfig.connectors.misp.server (property name, status and version)
			-->
			<span ng-if="appConfig.connectors.misp.enabled" uib-tooltip="MISP integration enabled">
				<img class="footer-logo logo-{{appConfig.connectors.misp.status | lowercase}}" src="images/misp-logo.svg"/>
			</span>
		</div>
		<div>
			<strong><a href="http://www.thehive-project.org" target="_blank">TheHive Project</a> 2016-2021, <a href="https://www.gnu.org/licenses/agpl-3.0.en.html" target="_blank">AGPL-V3</a></strong>
		</div>
	</div>
</footer>
<!--
<control-sidebar class="control-sidebar control-sidebar-dark"></control-sidebar>
<div class="control-sidebar-bg"></div>
-->

```

`frontend/app/views/components/common/custom-field-input.component.html`:

```html
<dl class="dl-horizontal custom-field-input">
    <dt class="pull-left">
        <span uib-tooltip="{{$ctrl.field.description}}">{{$ctrl.field.name}}</span>
        <a ng-if="$ctrl.removable" class="pull-right mr-xxxs" href ng-click="$ctrl.removeCustomField($ctrl.id)" uib-tooltip="Delete">
            <i class="fa fa-trash text-danger"></i>
        </a>
    </dt>
    <dd ng-if="$ctrl.editable && $ctrl.field.options.length > 0">
        <updatable-select
            options="$ctrl.field.options"
            on-update="$ctrl.updateField(newValue)"
            value="$ctrl.value" clearable="true"></updatable-select>
    </dd>
    <dd ng-if="$ctrl.editable && $ctrl.field.options.length === 0" ng-switch="$ctrl.field.type">
        <div class="custom-field-input-wrapper">
            <updatable-simple-text ng-switch-when="string"
                input-type="text" on-update="$ctrl.updateField(newValue)" value="$ctrl.value" clearable="true"></updatable-simple-text>

            <updatable-date ng-switch-when="date" on-update="$ctrl.updateField(newValue)" value="$ctrl.value" clearable="true"></updatable-date>

            <updatable-simple-text ng-switch-when="integer"
                input-type="integer"
                on-update="$ctrl.updateField(newValue)"
                value="$ctrl.value" clearable="true"></updatable-simple-text>

            <updatable-simple-text ng-switch-when="float"
               input-type="float"
               on-update="$ctrl.updateField(newValue)"
               value="$ctrl.value" clearable="true"></updatable-simple-text>

            <updatable-boolean ng-switch-when="boolean"
                input-type="number"
                on-update="$ctrl.updateField(newValue)"
                value="$ctrl.value" clearable="true"></updatable-boolean>

            <span ng-switch-default>Not Editable</span>
        </div>
    </dd>
    <dd ng-if="!$ctrl.editable" ng-switch="$ctrl.field.type">
        <span ng-switch-when="date">{{$ctrl.value | shortDate}}</span>
        <span ng-switch-default>
            {{$ctrl.value}}
            <em class="text-warning" ng-if="!$ctrl.value">Not Specified</em>
        </span>
    </dd>
</dl>

```

`frontend/app/views/components/common/custom-field-labels.component.html`:

```html
<div class="case-tags flexwrap">
    <span class="mr-xxxs text-muted"><i class="fa fa-code"></i></span>

    <strong class="text-muted mr-xxxs" ng-if="!$cmp.customFields || $cmp.definedValues === 0 ">None</strong>

    <span class="kv-label mb-xxxs mr-xxxs pointer"
        ng-repeat="cf in $cmp.customFields | orderBy:'order' track by $index"
        ng-click="$cmp.fieldClicked('customFields.' + cf.name, cf.value)"
        ng-if="cf.value !== undefined && cf.value !== null">

        <span class="kv-label-key default" uib-tooltip="{{cf.description}}" tooltip-placement="top">{{$cmp.fieldsCache[cf.name].name || cf.name}}</span>
        <span class="kv-label-val value default" uib-tooltip="{{cf | customFieldValue}}" tooltip-placement="top">{{cf | customFieldValue}}</span>
    </span>
</div>

```

`frontend/app/views/components/common/datalist-header.component.html`:

```html
<span>
    <span class="mr-xxxs">{{$ctrl.title}}</span>
    <span ng-if="!$ctrl.list.loadingCount">({{$ctrl.list.total | limitedCount}}</span>
    <span ng-if="$ctrl.list.loadingCount">(<i class="fa fa-spinner fa-pulse"></i></span>
    <span ng-if="$ctrl.total !== null"> of {{$ctrl.total}})</span>
    <span ng-if="$ctrl.total === null"> of <i class="fa fa-spinner fa-pulse"></i>)</span>
    <em class="ml-xxxs text-muted" ng-show="$ctrl.list.loading"><i class="fa fa-spinner fa-pulse"></i> Fetching
        data...</em>
    <em class="ml-xxxs text-muted" ng-show="!$ctrl.list.loading && $ctrl.list.loadingCount"><i
            class="fa fa-spinner fa-pulse"></i> Counting records...</em>
</span>

```

`frontend/app/views/components/common/modal/modal.confirm.html`:

```html
<form ng-submit="$modal.confirm()">
  <div class="modal-header bg-{{$modal.config.flavor || 'primary'}}">
    <h3 class="modal-title">{{$modal.title}}</h3>
  </div>
  <div class="modal-body">
    <p>{{$modal.message}}</p>
  </div>
  <div class="modal-footer text-left">
    <button class="btn btn-default pull-left" ng-click="$modal.cancel()" type="button">{{$modal.config.cancelText || 'Cancel'}}</button>

    <button ng-repeat="action in $modal.config.actions" class="btn btn-{{action.flavor || 'default'}}" type="button" ng-click="$modal.dismiss(action.dismiss)">{{action.text}}</button>

    <button class="btn btn-{{$modal.config.flavor || 'primary'}} pull-right" type="submit" auto-focus>{{$modal.config.okText || 'Ok'}}</button>
  </div>
</form>

```

`frontend/app/views/components/common/observable-flags.component.html`:

```html
<div class="observable-flags" ng-class="{'inline': $ctrl.inline}">
    <!-- TLP -->
    <div ng-if="!!!$ctrl.hideTlp" class="observable-tlp clickable" uib-tooltip="{{ {
        0: 'TLP:WHITE',
        1: 'TLP:GREEN',
        2: 'TLP:AMBER',
        3: 'TLP:RED',
    }[$ctrl.observable.tlp] }}" tooltip-popup-delay="500" tooltip-placement="tlp"
        ng-click="$ctrl.filterBy('tlp', $ctrl.observable.tlp)">
        <i class="fa" ng-class="{
            0: 'text-tlp-default fa-circle-o',
            1: 'text-tlp-green fa-circle',
            2: 'text-tlp-amber fa-circle',
            3: 'text-tlp-red fa-circle',
        }[$ctrl.observable.tlp]"></i>
    </div>

    <!-- IOC flag -->
    <div ng-if="!!$ctrl.observable.ioc" class="observable-ioc clickable" uib-tooltip="is an IOC" tooltip-popup-delay="500" tooltip-placement="bottom"
        ng-click="$ctrl.filterBy('ioc', true)">
        <i class="fa fa-star"></i>
    </div>
    <div ng-if="!!!$ctrl.observable.ioc" class="observable-ioc clickable"
        ng-click="$ctrl.filterBy('ioc', false)">
        <i class="fa fa-star text-disabled"></i>
    </div>

    <!-- Sighted flag -->
    <div ng-if="!!$ctrl.observable.sighted" class="observable-ioc clickable" uib-tooltip="has been sighted" tooltip-popup-delay="500" tooltip-placement="bottom"
        ng-click="$ctrl.filterBy('sighted', true)">
        <i class="fa fa-toggle-on"></i>
    </div>
    <div ng-if="!!!$ctrl.observable.sighted" class="observable-ioc clickable"
        ng-click="$ctrl.filterBy('sighted', false)">
        <i class="fa fa-toggle-on text-disabled"></i>
    </div>

    <!-- Seen flag -->
    <div ng-if="!!!$ctrl.hideSeen && $ctrl.observable.extraData.seen.seen > 0" class="observable-seen" uib-tooltip="{{$ctrl.observable.extraData.seen.seen}} related observable(s)" tooltip-popup-delay="500" tooltip-placement="bottom">
        <i ng-class="{'text-danger': $ctrl.observable.extraData.seen.ioc}" class="fa fa-eye"></i>
    </div>
    <div ng-if="!!!$ctrl.hideSeen && !($ctrl.observable.extraData.seen.seen > 0)" class="observable-seen">
        <i class="fa fa-eye-slash text-disabled"></i>
    </div>

    <!-- Ignore Similarity flag -->
    <div ng-if="!!!$ctrl.hideSimilarity && !!$ctrl.observable.ignoreSimilarity" class="observable-ioc clickable" uib-tooltip="ignored for similarity" tooltip-popup-delay="500" tooltip-placement="bottom"
        ng-click="$ctrl.filterBy('ignoreSimilarity', true)">
        <i class="fa fa-chain-broken"></i>
    </div>
    <div ng-if="!!!$ctrl.hideSimilarity && !!!$ctrl.observable.ignoreSimilarity" class="observable-ioc clickable"
        ng-click="$ctrl.filterBy('ignoreSimilarity', false)">
        <i class="fa fa-chain-broken text-disabled"></i>
    </div>



    <!-- <span
      uib-tooltip="{{artifact.extraData.seen.seen}} related artifact(s)"
      tooltip-placement="bottom"
      ng-if="artifact.extraData.seen.seen > 0"
      class="glyphicon glyphicon-eye-open"
      ></span> -->

</div>

```

`frontend/app/views/components/common/tag.component.html`:

```html
<span class="label label-tag label-default label-lg" style="border-left-color:{{$ctrl.bgColor}};">{{$ctrl.tag}}</span>

```

`frontend/app/views/components/common/task-flags.component.html`:

```html
<div class="task-flags" ng-class="{'inline': $ctrl.inline}">
    <!-- TLP -->
    <div class="task-status clickable" uib-tooltip="{{$ctrl.task.status}}" tooltip-popup-delay="500" tooltip-placement="bottom"
        ng-click="$ctrl.filterBy('status', $ctrl.task.status)">
        <i ng-class="{
            'Waiting': 'glyphicon glyphicon-pause text-primary',
            'InProgress': 'glyphicon glyphicon-hourglass text-yellow',
            'Completed': 'glyphicon glyphicon-ok text-success',
        }[$ctrl.task.status]"></i>
    </div>

    <!-- Flag -->
    <div ng-if="!!$ctrl.task.flag" class="task-flag clickable" uib-tooltip="Is flagged" tooltip-popup-delay="500" tooltip-placement="bottom"
        ng-click="$ctrl.filterBy('flag', true)">
        <i class="glyphicon glyphicon-flag text-yellow"></i>
    </div>
    <div ng-if="!!!$ctrl.task.flag" class="task-flag clickable"
        ng-click="$ctrl.filterBy('flag', false)">
        <i class="glyphicon glyphicon-flag text-disabled"></i>
    </div>

    <!-- Assignee -->
    <div ng-if="!!$ctrl.task.assignee" class="task-assignee" uib-tooltip="Is Assigned" tooltip-popup-delay="500" tooltip-placement="bottom">
        <i class="glyphicon glyphicon-user text-muted"></i>
    </div>
    <div ng-if="!!!$ctrl.task.assignee" class="task-flag clickable" uib-tooltip="Not assigned" tooltip-popup-delay="500" tooltip-placement="bottom">
        <i class="glyphicon glyphicon-user text-disabled"></i>
    </div>

</div>

```

`frontend/app/views/components/control-sidebar.component.html`:

```html
<!-- Create the tabs -->
<ul class="nav nav-tabs nav-justified control-sidebar-tabs">
	<li class="active"><a href="#control-sidebar-home-tab" data-toggle="tab"><i class="fa fa-home"></i></a></li>
	<li><a href="#control-sidebar-settings-tab" data-toggle="tab"><i class="fa fa-gears"></i></a></li>
</ul>
<!-- Tab panes -->
<div class="tab-content">
	<!-- Home tab content -->
	<div class="tab-pane active" id="control-sidebar-home-tab">
		<h3 class="control-sidebar-heading">Recent Activity</h3>
		<ul class="control-sidebar-menu">
			<li>
				<a href="javascript::;">
					<i class="menu-icon fa fa-birthday-cake bg-red"></i>

					<div class="menu-info">
						<h4 class="control-sidebar-subheading">Langdon's Birthday</h4>

						<p>Will be 23 on April 24th</p>
					</div>
				</a>
			</li>
		</ul>
		<!-- /.control-sidebar-menu -->

		<h3 class="control-sidebar-heading">Tasks Progress</h3>
		<ul class="control-sidebar-menu">
			<li>
				<a href="javascript::;">
					<h4 class="control-sidebar-subheading">
						Custom Template Design
						<span class="label label-danger pull-right">70%</span>
					</h4>

					<div class="progress progress-xxs">
						<div class="progress-bar progress-bar-danger" style="width: 70%"></div>
					</div>
				</a>
			</li>
		</ul>
		<!-- /.control-sidebar-menu -->

	</div>
	<!-- /.tab-pane -->
	<!-- Stats tab content -->
	<div class="tab-pane" id="control-sidebar-stats-tab">Stats Tab Content</div>
	<!-- /.tab-pane -->
	<!-- Settings tab content -->
	<div class="tab-pane" id="control-sidebar-settings-tab">
		<form method="post">
			<h3 class="control-sidebar-heading">General Settings</h3>

			<div class="form-group">
				<label class="control-sidebar-subheading">Report panel usage</label>
				<input type="checkbox" class="pull-right" checked>
				<p>Some information about this general settings option</p>
			</div>
			<!-- /.form-group -->
		</form>
	</div>
	<!-- /.tab-pane -->
</div>
```

`frontend/app/views/components/header.component.html`:

```html
<nav class="navbar navbar-static-top main-navbar bg-navy" ng-if="!hideStatusBar" ng-show="currentUser.login">
    <div class="container-fluid">
        <div class="navbar-header">
            <button aria-expanded="false" class="navbar-toggle collapsed" data-target="#th-navbar-collapse" data-toggle="collapse" type="button">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" ui-sref="{{currentUser.homeState}}">
                <img alt="TheHive" src="images/logo.white.svg">
            </a>
        </div>

        <div class="collapse navbar-collapse" id="th-navbar-collapse">
            <ul class="nav navbar-nav" ng-if="!isSuperAdmin()">
                <li ui-sref-active="active" if-permission="manageCase">
                    <a href ng-click="createNewCase()" ng-if="!templates || templates.length === 0">
                        <i class="fa fa-plus"></i>
                        <span class="hpad5">New Case</span>
                    </a>
                    <a href ng-click="openTemplateSelector()" ng-if="templates && templates.length > 0">
                        <i class="fa fa-plus"></i>
                        <span class="hpad5">New Case</span>
                    </a>
                </li>
                <li ui-sref-active="active">
                    <a ui-sref="app.main({viewId: 'mytasks'})">My tasks
                        <span class="badge alert-danger">{{myCurrentTasksCount || 0}}</span>
                    </a>
                </li>
                <li ui-sref-active="active">
                    <a ui-sref="app.main({viewId: 'waitingtasks'})">Waiting tasks
                        <span class="badge alert-danger">{{waitingTasksCount || 0}}</span>
                    </a>
                </li>
                <li ui-sref-active="active">
                    <a href ui-sref="app.alert-list">
                        Alerts
                        <span class="badge alert-danger">{{unreadAlertCount || 0}}</span>
                    </a>
                </li>
                <li class="hdivider hidden-xs"></li>
                <li ui-sref-active="active">
                    <a ui-sref="app.dashboards">
                        <i class="fa fa-bar-chart"></i> Dashboards
                    </a>
                </li>
                <li class="hdivider hidden-xs"></li>
                <li ui-sref-active="active">
                    <a ui-sref="app.search">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li ng-if="async > 0" class="hidden-xs">
                    <a>{{async}}
                        <i class="fa fa-circle-o-notch fa-spin"></i>
                    </a>
                </li>

                <!-- Super Admin menu -->
                <li ng-if="!isSuperAdmin()">
                    <form ng-submit="search(querystring)" style="margin-top : 10px">
                        <div class="input-group" style="width: 100px">
                            <span class="input-group-addon">
                                <i class="glyphicon glyphicon-search"></i>
                            </span>
                            <input class="input-sm form-control" ng-model="querystring" placeholder="CaseId" style="width: 80px" tooltype="Enter a case number" type="number"></input>
                        </div>
                    </form>
                </li>
                <li class="dropdown" uib-dropdown ng-if="isSuperAdmin()">
                    <a class="dropdown-toggle" uib-dropdown-toggle href>
                        <i class="fa fa-cog"></i>
                        <span class="hpad5">Admin</span>
                        <b class="caret"></b>
                    </a>
                    <ul class="dropdown-menu" uib-dropdown-menu>
                        <li if-permission="manageOrganisation">
                            <a ui-sref="app.administration.organisations">
                                <i class="fa fa-building-o"></i>
                                <span class="hpad5">Organisations</span>
                            </a>
                        </li>
                        <li if-permission="manageProfile">
                            <a ui-sref="app.administration.profiles">
                                <i class="fa fa-users"></i>
                                <span class="hpad5">Profiles</span>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li if-permission="manageCustomField">
                            <a ui-sref="app.administration.custom-fields">
                                <i class="fa fa-edit"></i>
                                <span class="hpad5">Case custom fields</span>
                            </a>
                        </li>
                        <li if-permission="manageObservableTemplate">
                            <a ui-sref="app.administration.observables">
                                <i class="glyphicon glyphicon-pushpin"></i>
                                <span class="hpad5">Observable types</span>
                            </a>
                        </li>
                        <li if-permission="manageAnalyzerTemplate" ng-if="hasCortexConnector">
                            <a ui-sref="app.administration.analyzer-templates">
                                <i class="fa fa-file-text"></i>
                                <span class="hpad5">Analyzer templates</span>
                            </a>
                        </li>
                        <li if-permission="manageTaxonomy">
                            <a ui-sref="app.administration.taxonomies">
                                <i class="fa fa-tags"></i>
                                <span class="hpad5">Taxonomies</span>
                            </a>
                        </li>
                        <li if-permission="managePattern">
                            <a ui-sref="app.administration.attackPatterns">
                                <i class="fa fa-tags"></i>
                                <span class="hpad5">ATT&CK Patterns</span>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li if-permission="managePlatform">
                            <a ui-sref="app.administration.platform">
                                <i class="fa fa-wrench"></i>
                                <span class="hpad5">Platform Status</span>
                            </a>
                        </li>
                    </ul>
                </li>

                <li class="dropdown" ng-if="!isSuperAdmin()" if-permission="manageUser,manageCaseTemplate">
                    <a ui-sref="app.administration.organisations-details({'organisation': currentUser.organisation})">
                        <i class="fa fa-building-o"></i>
                        <span class="hpad5">Organisation</span>
                    </a>
                </li>

                <!-- User menu -->
                <li class="dropdown" uib-dropdown>
                    <a class="profile dropdown-toggle" uib-dropdown-toggle href>
                        <user user-id="currentUser.login"></user>
                    </a>
                    <ul class="dropdown-menu" uib-dropdown-menu>
                        <li>
                            <a ui-sref="app.settings">
                              <i class="fa fa-address-book"></i> Settings
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href ng-click="aboutTheHive()">
                              <i class="fa fa-question-circle"></i> About
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href ng-click="logout()">
                              <i class="fa fa-sign-out"></i> Logout
                            </a>
                        </li>
                    </ul>
                </li>
                <li ng-if="currentUser.organisations.length > 1">
                    <a href ng-click="switchOrg()">
                      <i class="fa fa-random"></i>
                    </a>
                </li>
            </ul>
        </div>

    </div>
</nav>

```

`frontend/app/views/components/list/stats-item.component.html`:

```html
<div class="box box-primary">
    <div class="box-header with-border">
        <h3 class="box-title">{{$cmp.title}}</h3>
        <div class="box-tools pull-right">
            <div class="btn-group">
                <label class="btn btn-sm btn-default" ng-model="$cmp.mode" uib-btn-radio="'table'"><i class="fa fa-table"></i></label>
                <label class="btn btn-sm btn-default" ng-model="$cmp.mode" uib-btn-radio="'chart'"><i class="fa fa-pie-chart"></i></label>
            </div>
        </div>
    </div>
    <div class="box-body">
        <div class="empty-message" ng-if="!$cmp.data || ($cmp.data.length === 0)">
            No Data
        </div>
        <table ng-if="$cmp.mode === 'table'" class="table table-condensed">
            <tr ng-repeat="item in $cmp.data">
                <td class="active">{{$cmp.labels[item.key] || item.key}}</td>
                <td>
                    <a href ng-click="$cmp.onClick(item.key)">{{item.count}}</a>
                </td>
            </tr>
        </table>
        <donut-Chart ng-if="$cmp.mode === 'chart' && $cmp.data.length > 0" labels="$cmp.labels" data="$cmp.data" title="Cases by Status"
            on-item-clicked="$cmp.onClick(value)"></donut-chart>
    </div>
</div>

```

`frontend/app/views/components/main-sidebar.component.html`:

```html
<section class="sidebar">

	<!-- Sidebar Menu -->
	<ul class="sidebar-menu">
		<li class="header">MAIN MENU</li>		
		<li class="active"><a ui-sref="home"><i class="fa fa-link"></i> <span>Home</span></a></li>
		<li><a ui-sref="calendar"><i class="fa fa-link"></i> <span>Calendar</span></a></li>
		<li class="treeview">
			<a href="#"><i class="fa fa-link"></i> <span>Multilevel</span> <i class="fa fa-angle-left pull-right"></i></a>
			<ul class="treeview-menu">
				<li><a href="#">Link in level 2</a></li>
				<li><a href="#">Link in level 2</a></li>
			</ul>
		</li>
	</ul>
	<!-- /.sidebar-menu -->
</section>

```

`frontend/app/views/components/org/case-template/case-templates.html`:

```html
<div ng-include="'views/components/org/case-template/toolbar.html'"></div>

<div class="mt-xs filter-panel" ng-include="'views/components/org/case-template/filters.html'" ng-show="$vm.filtering.context.showFilters"></div>

<!-- Filters preview  -->
<div class="row mt-xs">
    <div class="col-md-12 clearfix">
        <div class="pull-left">
            <h4>
                Case Template List ({{$vm.list.values.length || 0}} of {{$vm.list.total}})
            </h4>
        </div>

        <filters-preview filters="$vm.filtering.context.filters"
            on-clear-item="$vm.removeFilter(field)"
            on-clear-all="$vm.clearFilters()"></filters-preview>
    </div>
</div>

<!-- Datalist  -->
<div class="row mt-xs">
    <div class="col-md-12 mv-s" ng-show="$vm.list.total === 0">
        <div class="empty-message">No records</div>
    </div>

    <div class="col-md-12" ng-show="$vm.list.total > 0">
        <psearch control="$vm.list"></psearch>

        <table class="table table-striped case-list">
            <thead>
                <tr>
                    <th style="width: 10px;" class="p-0"></th>
                    <th>
                      <a href class="text-default" ng-click="$vm.sortByField('displayName')">
                        Display Name
                        <i ng-show="$vm.filtering.context.sort.indexOf('+displayName') === -1 && $vm.filtering.context.sort.indexOf('-displayName') === -1" class="fa fa-sort"></i>
                        <i ng-show="$vm.filtering.context.sort.indexOf('+displayName') !== -1" class="fa fa-caret-up"></i>
                        <i ng-show="$vm.filtering.context.sort.indexOf('-displayName') !== -1" class="fa fa-caret-down"></i>
                      </a>
                    </th>
                    <th width="150px">
                        <a href class="text-default" ng-click="$vm.sortByField('name')">
                          Name
                          <i ng-show="$vm.filtering.context.sort.indexOf('+name') === -1 && $vm.filtering.context.sort.indexOf('-name') === -1" class="fa fa-sort"></i>
                          <i ng-show="$vm.filtering.context.sort.indexOf('+name') !== -1" class="fa fa-caret-up"></i>
                          <i ng-show="$vm.filtering.context.sort.indexOf('-name') !== -1" class="fa fa-caret-down"></i>
                        </a>
                    </th>
                    <th width="80px">
                        <a href class="text-default" ng-click="$vm.sortByField('severity')">
                          Severity
                          <i ng-show="$vm.filtering.context.sort.indexOf('+severity') === -1 && $vm.filtering.context.sort.indexOf('-severity') === -1" class="fa fa-sort"></i>
                          <i ng-show="$vm.filtering.context.sort.indexOf('+severity') !== -1" class="fa fa-caret-up"></i>
                          <i ng-show="$vm.filtering.context.sort.indexOf('-severity') !== -1" class="fa fa-caret-down"></i>
                        </a>
                    </th>

                    <th width="80px">
                        Tasks
                    </th>
                    <th width="120px">
                        Custom Fields
                    </th>
                    <th style="width: 60px;">By</th>
                    <th style="width: 150px">
                        Dates
                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_createdAt')" uib-tooltip="Sort by creation date">
                            C.
                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') === -1 && $vm.filtering.context.sort.indexOf('-_createdAt') === -1" class="fa fa-sort"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') !== -1" class="fa fa-caret-up"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('-_createdAt') !== -1" class="fa fa-caret-down"></i>
                        </a>
                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_updatedAt')" uib-tooltip="Sort by last update date">
                            U.
                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') === -1 && $vm.filtering.context.sort.indexOf('-_updatedAt') === -1" class="fa fa-sort"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') !== -1" class="fa fa-caret-up"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('-_updatedAt') !== -1" class="fa fa-caret-down"></i>
                        </a>
                    </th>
                    <th style="width: 120px">Actions</th>
                </tr>
            </thead>

            <tbody>
                <tr ng-class="{true:'tr-warning'}[template.flag]" ng-repeat="template in $vm.list.values">
                    <td class="p-0 bg-tlp-{{template.tlp}} clickable" ng-click="$vm.addFilterValue('tlp', template.tlp)"></td>
                    <td>
                        <span>{{template.displayName || template.name}}</span>
                        <div class="case-tags flexwrap mt-xxs">
                            <span class="mr-xxxs text-muted"><i class="fa fa-tags"></i></span>
                            <strong class="text-muted mr-xxxs" ng-if="!template.tags || template.tags.length === 0">None</strong>
                            <tag-item ng-repeat="tag in template.tags track by $index" class="pointer"
                                ng-click="$vm.addFilterValue('tags', tag)" value="tag"></tag-item>
                        </div>
                    </td>
                    <td>
                        <div class="case-title wrap">
                            <a ng-click="">{{template.name}}</a>
                        </div>
                        <!-- <custom-field-labels ng-if="$vm.filtering.context.showAdvanced" custom-fields="template.customFields" on-field-click="$vm.addFilterValue(name, value)"></custom-field-labels> -->
                    </td>

                    <td class="center">
                        <div class="clickable" ng-click="$vm.addFilterValue('severity', template.severity)">
                            <severity active="false" value="template.severity"></severity>
                        </div>
                    </td>
                    <td>
                        <span>{{template.tasks.length || 0}}</span>
                    </td>
                    <td>
                        <span>{{template.customFields.length || 0}}</span>
                    </td>
                    <td class="nowrap">
                        <user user-id="template._createdBy" icon-only="true" icon-size="m"></user>
                    </td>
                    <td>
                        <div ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_createdAt') !== -1 || $vm.filtering.context.sort.indexOf('-_createdAt') !== -1}">
                            C. <a href ng-click="$vm.addFilterValue('_createdAt', template._createdAt)">{{template._createdAt | shortDate}}</a>
                        </div>
                        <div ng-if="template._updatedAt > 0" ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_updatedAt') !== -1 || $vm.filtering.context.sort.indexOf('-_updatedAt') !== -1}">
                            U. <a href ng-click="$vm.addFilterValue('_updatedAt', template._updatedAt)">{{template._updatedAt | shortDate}}</a>
                        </div>
                    </td>
                    <td class="text-center">
                        <a href class="btn btn-icon btn-clear" ng-click="$vm.showTemplate(template)">
                            <i class="text-info fa fa-edit"></i>
                        </a>
                        <a href class="btn btn-icon btn-clear" ng-click="$vm.exportTemplate(template)">
                            <i class="fa fa-download"></i>
                        </a>
                        <a href class="btn btn-icon btn-clear" ng-click="$vm.deleteTemplate(template)">
                            <i class="text-info fa fa-trash text-danger"></i>
                        </a>
                    </td>
                </tr>
            </tbody>
        </table>

        <psearch control="$vm.list"></psearch>
    </div>
</div>

```

`frontend/app/views/components/org/case-template/case-templates.task.html`:

```html
<form class="form-horizontal" name="taskForm" ng-submit="addTask()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">{{action}} task</h3>
    </div>
    <div class="modal-body">
        <div class="form-group" ng-class="{ 'has-error' : taskForm.name.$invalid && !taskForm.name.$pristine }">
            <label class="col-md-3 control-label">Task title
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-md-9">
                <input class="form-control" ng-model="task.title" placeholder="Task title" required type="text">
            </div>
        </div>

        <div class="form-group" ng-class="{ 'has-error' : taskForm.group.$invalid && !taskForm.group.$pristine }">
            <label class="col-md-3 control-label">Task group
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-md-9">
                <input class="form-control" ng-model="task.group" placeholder="Task group" required type="text"
                    uib-typeahead="g for g in groups | filter:$viewValue"
                    typeahead-min-length="0">
            </div>
        </div>

        <div class="form-group" ng-class="{ 'has-error' : taskForm.description.$invalid && !taskForm.description.$pristine }">
            <label class="col-md-3 control-label">Task description</label>
            <div class="col-md-9">
                <textarea name="content" class="content-box" markdown-editor="{'iconlibrary': 'fa', addExtraButtons: true, resize: 'vertical'}" rows="10" ng-model="task.description"></textarea>

                <p class="help-block small">Task's default description</p>
            </div>
        </div>

        <div class="form-group">
            <label class="col-md-3 control-label">Assignee</label>
            <div class="col-md-9">
                <select class="form-control" ng-model="task.owner"
                    ng-options="item.login as item.name for item in users | orderBy:'login'">
                    <option value="" selected>-- Select assignee --</option>
                </select>
            </div>
        </div>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
        <button class="btn btn-primary pull-right" ng-disabled="taskForm.$invalid" type="submit">{{action}} task</button>
    </div>
</form>

```

`frontend/app/views/components/org/case-template/custom-fields.html`:

```html
<div class="case-template-section">
    <div class="mb-xs">
        <div class="btn-group">
            <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.addCustomFieldRow()">
                <i class="mr-xxxs fa fa-plus"></i>Add custom field
            </button>
        </div>
    </div>

    <div class="empty-message" ng-if="$vm.templateCustomFields.length === 0">
        No custom fields have been added. <a href class="mr-xxxs" ng-click="$vm.addCustomFieldRow()">Add a custom field</a>
    </div>

    <div ng-if="$vm.templateCustomFields.length !== 0" ui-sortable="$vm.sortableFields" ng-model="$vm.templateCustomFields">
        <div class="customfield-item" ng-repeat="cf in $vm.templateCustomFields">
            <div class="row">
                <div class="col-sm-12">
                    <span class="drag-handle text-primary clickable mr-xxs">
                        <i class="fa fa-bars"></i>
                    </span>
                    <a href ng-click="$vm.removeCustomField(cf)"><span class="pull-right text-danger"><i class="fa fa-trash"></i> Delete</span></a>
                </div>
                <div class="col-sm-6">
                    <select class="form-control" ng-model="cf.name" ng-options="item.reference as item.name for (key, item) in $vm.fields | orderObjectBy:'name'" required></select>
                </div>
                <div class="col-sm-6" ng-if="$vm.fields[cf.name].options.length > 0">
                    <select class="form-control" ng-model="cf.value" ng-options="v for v in $vm.fields[cf.name].options">
                        <option value=""></option>
                    </select>
                </div>
                <div class="col-sm-6" ng-if="$vm.fields[cf.name].options.length === 0" ng-switch="$vm.fields[cf.name].type">
                    <input ng-switch-when="string" type="text" class="form-control" ng-model="cf.value">
                    <input ng-switch-when="integer" type="number" class="form-control" ng-model="cf.value">
                    <input ng-switch-when="float" type="number" step=".01" class="form-control" ng-model="cf.value">
                    <select ng-switch-when="boolean" class="form-control" ng-model="cf.value" ng-options="v for v in [true, false]">
                        <option value=""></option>
                    </select>
                    <dt-picker ng-switch-when="date" date="cf.value"></dt-picker>
                </div>
                <div class="col-sm-12">
                    <i class="pl-xxss fa fa-question-circle" aria-hidden="true"></i> <small>{{$vm.fields[cf.name].description || 'No description'}}</small>
                </div>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/components/org/case-template/details.html`:

```html
<div class="row">
    <div class="col-sm-4">
        <div class="form-group">
            <label class="control-label">Template name<i class="fa fa-asterisk text-danger"></i></label>
            <input autocomplete="off" class="form-control" name="name" ng-model="$vm.template.name" placeholder="Template name" required type="text" />
            <p class="help-block small">This name should be unique</p>
        </div>

    </div>
    <div class="col-sm-4">
        <div class="form-group">
            <label class="control-label">Display name</label>
            <input autocomplete="off" class="form-control" name="displayName" ng-model="$vm.template.displayName" placeholder="Display name" type="text" />
            <p class="help-block small">This is a display name of the template</p>
        </div>

    </div>
    <div class="col-sm-4">
        <div class="form-group">
            <label class="control-label">Title prefix</label>
            <input class="form-control" name="titlePrefix" ng-model="$vm.template.titlePrefix" placeholder="Case title prefix" type="text" />
            <p class="help-block small">This is used to prefix the case name</p>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-sm-4">
        <div class="form-group">
            <label class="control-label">Severity
                <i class="fa fa10asterisk text-danger"></i>
            </label>
            <div>
                <a class="clearfix" href ng-click="activeSev = true" ng-init="activeSev = true">
                    <severity active="activeSev" style="float:left; font-size:16px" value="$vm.template.severity"></severity>
                </a>
                <p class="help-block small vpad5">This will be the default case severity</p>
            </div>
        </div>
    </div>
    <div class="col-sm-4">
        <div class="form-group">
            <label class="control-label">TLP
                <i class="fa fa10asterisk text-danger"></i>
            </label>
            <div>
                <a class="clearfix" href ng-click="activeTlp='active'" ng-init="activeTlp='active'">
                    <tlp format="activeTlp" on-update="updateTlp(newValue)" style="float:left; font-size:16px" value="$vm.template.tlp"></tlp>
                </a>
            </div>
            <div>
                <p class="help-block small vpad5">This will be the default case TLP</p>
            </div>
        </div>
    </div>
    <div class="col-sm-4">
        <div class="form-group">
            <label class="control-label">PAP
                <i class="fa fa10asterisk text-danger"></i>
            </label>
                <div>
                    <a class="clearfix" href ng-click="activePap='active'" ng-init="activePap='active'">
                        <tlp format="activePap" on-update="updatePap(newValue)" style="float:left; font-size:16px" value="$vm.template.pap" namespace="PAP"></tlp>
                    </a>
                </div>
                <div>
                    <p class="help-block small vpad5">This will be the default case PAP</p>
                </div>

            </div>
        </div>
    </div>
</div>

<div class="form-group">
    <label class="control-label">Tags</label>

        <div class="input-group">
            <tags-input class="ti-tag-selector" min-length="2" name="tags" ng-model="$vm.tags" placeholder="Tags" replace-spaces-with-dashes="false" template="views/directives/tag-input-item.html">
                <auto-complete min-length="3" debounce-delay="400" source="$vm.getTags($query)"></auto-complete>
            </tags-input>

            <span class="input-group-btn vtop">
                <button type="button" class="btn btn-block btn-primary" ng-click="$vm.fromTagLibrary()" uib-tooltip="Add tag from library" tooltip-placement="left">
                    <span class="fa fa-plus"></span>
                </button>
            </span>
        </div>
        <p class="help-block small">These will be the default case tags</p>
    </div>
</div>
<div class="form-group" ng-class="{ 'has-error' : templateEditForm.description.$invalid && !templateEditForm.description.$pristine }">
    <label class="control-label">Description
        <i class="fa fa-asterisk text-danger"></i>
    </label>
    <textarea class="form-control" name="description" ng-model="$vm.template.description" placeholder="Case description" required rows="3"></textarea>
    <p class="help-block small">This will be the default case description</p>
    <p class="help-block" ng-show="templateEditForm.description.$invalid && !templateEditForm.description.$pristine">The case description is required.</p>
</div>

```

`frontend/app/views/components/org/case-template/details.modal.html`:

```html
<form name="templateEditForm" ng-submit="$vm.saveTemplate()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">{{$vm.action}} case template</h3>
    </div>
    <div class="modal-body">
        <uib-tabset active="active" class="nav-tabs-custom">
            <uib-tab index="0">
                <uib-tab-heading>
                    <span>
                        <i class="mr-xxs glyphicon glyphicon-folder-open"></i>
                        Basic Information
                    </span>
                </uib-tab-heading>
                <div>
                    <div class="mt-xs" ng-include="'views/components/org/case-template/details.html'"></div>
                </div>
            </uib-tab>
            <uib-tab index="1">
                <uib-tab-heading>
                    <span>
                        <i class="mr-xxs glyphicon glyphicon-tasks"></i>
                        Tasks <span class="badge badge-default">{{$vm.template.tasks.length || 0}}</span>
                    </span>
                </uib-tab-heading>
                <div>
                    <div class="mt-xs" ng-include="'views/components/org/case-template/tasks.html'"></div>
                </div>
            </uib-tab>
            <uib-tab index="2">
                <uib-tab-heading>
                    <span>
                        <i class="mr-xxs fa fa-tags"></i>
                        Custom Fields <span class="badge badge-default">{{$vm.templateCustomFields.length || 0}}</span>
                    </span>
                </uib-tab-heading>
                <div>
                    <div class="mt-xs" ng-include="'views/components/org/case-template/custom-fields.html'"></div>
                </div>
            </uib-tab>
        </uib-tabset>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$vm.cancel()" type="button">Cancel</button>
        <span class="ml-xxs"><i class="fa fa-asterisk text-danger mr-xxxs"></i>Required field</span>
        <button class="btn btn-primary pull-right" ng-disabled="templateEditForm.$invalid" type="submit">Save template</button>
    </div>
</form>

```

`frontend/app/views/components/org/case-template/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>

        <form ng-submit="$vm.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $vm.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$vm.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in $vm.filtering.attributeKeys"
                            ng-change="$vm.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$vm.filtering.metadata" filter="filter" entity="$vm.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$vm.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$vm.clearFilters()" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/components/org/case-template/import.html`:

```html
<form class="form-horizontal" name="form" ng-submit="vm.ok()">
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Import Case Template</h3>
    </div>
    <div class="modal-body">
        <div class="form-group">
            <div class="col-sm-12">
                <input type="hidden" name="attachment" ng-model="vm.formData.attachment.status" required>
                <div file-chooser="" filemodel="vm.formData.attachment"></div>
            </div>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-warning pull-left" type="button" ng-click="vm.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="form.$invalid">Yes, Import</button>
    </div>
</form>

```

`frontend/app/views/components/org/case-template/tasks.html`:

```html
<div class="case-template-section">
    <div class="mb-xs">
        <div class="btn-group">
            <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.addTask()">
                <i class="mr-xxxs fa fa-plus"></i>Add task
            </button>
        </div>
    </div>

    <div class="empty-message" ng-if="!$vm.template.tasks || $vm.template.tasks.length === 0">
        No tasks have been specified. <a href class="mr-xxxs" ng-click="$vm.addTask()">Add a task</a>
    </div>
    <div ng-if="$vm.template.tasks.length !== 0" ui-sortable="$vm.sortableOptions" ng-model="$vm.template.tasks">
        <div class="task-item" ng-init="isCollapsed=true"
            ng-repeat="t in $vm.template.tasks | orderBy:'order' track by $index">
            <div class="panel-heading">
                <span class="drag-handle text-primary clickable mr-xxs">
                    <i class="fa fa-bars"></i>
                </span>
                <span>
                    <a href ng-click="isCollapsed=!isCollapsed">
                        <i class="fa" ng-class="{'fa-caret-down': isCollapsed, 'fa-caret-up': !isCollapsed}"></i>
                    </a>
                </span>
                <span class="hpad5">[{{t.group || 'default'}}] {{t.title}}</span>
                <span class="mr-xxs" ng-if="t.owner">(Assigned to <em>
                        <user-info value="t.owner" field="name"></user-info>
                    </em>)</span>

                <span class="pull-right">
                    <a class="text-default" href ng-click="$vm.editTask(t)">
                        <i class="fa fa-pencil"></i>&nbsp;Edit</a>
                    <span class="hpad5"></span>
                    <a class="text-danger" href ng-click="$vm.removeTask(t)">
                        <i class="fa fa-trash"></i>&nbsp;Delete</a>
                </span>
            </div>
            <div class="panel-body" ng-hide="isCollapsed">
                <p marked="t.description" ng-show="t.description != ''"></p>
                <p class="text-warning" ng-show="!t.description || t.description===''">
                    <em>No description specified</em>
                </p>
            </div>
        </div>
    </div>

</div>

```

`frontend/app/views/components/org/case-template/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <div class="btn-group">
                <button class="btn btn-sm btn-primary" ng-click="$vm.newTemplate()">
                    <i class="mr-xxxs fa fa-plus"></i>New template
                </button>
            </div>
            <div class="btn-group">
                <button class="btn btn-sm btn-default" ng-click="$vm.importTemplate()">
                    <i class="mr-xxxs fa fa-upload"></i>Import template
                </button>
            </div>

            <div class="btn-group" uib-dropdown>
                <button class="btn btn-primary btn-sm dropdown-toggle" uib-dropdown-toggle type="button">
                    <i class="mr-xxxs fa fa-sort"></i>
                    Sort by
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a ng-click="$vm.sortBy(['+displayName'])">Ascendant display name</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-displayName'])">Descendent display name</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-_createdAt'])">Newest first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['+_createdAt'])">Oldest first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-_updatedAt'])">Most recently updated first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['+_updatedAt'])">Least recently updated first</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]" type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/components/org/config.list.html`:

```html
<div class="row">
    <div class="col-md-12">
        <form name="settingsForm" class="mt-xs form-horizontal" ng-submit="$ctrl.save(settingsForm)" novalidate>
            <div class="form-group">
                <label class="col-lg-3 col-md-4 control-label">Hide <em>Empty Case</em> button</label>
                <div class="col-lg-9 col-md-8">
                    <div class="checkbox">
                        <label>
                          <input name="hideEmptyCaseButton" type="checkbox" ng-model="$ctrl.configs['hideEmptyCaseButton']"> Check this to disallow creating empty cases
                        </label>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label class="col-lg-3 col-md-4 control-label">Merge alerts into closed cases</label>
                <div class="col-lg-9 col-md-6">
                    <div class="checkbox">
                        <label>
                          <input name="disallowMergeAlertInResolvedSimilarCases" type="checkbox"
                              ng-model="$ctrl.configs['disallowMergeAlertInResolvedSimilarCases']"> Check this to disallow merging alerts into closed cases
                        </label>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label class="col-lg-3 col-md-4 control-label">Select the default filter of alert case similarity panel</label>
                <div class="col-lg-6 col-md-8">
                    <select class="form-control" name="defaultAlertSimilarCaseFilter"
                        ng-options="k as o.label for (k, o) in $ctrl.alertSimilarityFilters"
                        ng-model="$ctrl.configs['defaultAlertSimilarCaseFilter']">
                    </select>
                </div>
            </div>

            <div class="form-group">
                <label class="col-lg-3 col-md-4 control-label">Define the default date format used to display dates</label>
                <div class="col-lg-6 col-md-8">
                    <input class="form-control" type="text" name="defaultDateFormat" ng-model="$ctrl.configs['defaultDateFormat']">
                    <span>Result preview: <code>{{$ctrl.date | amDateFormat:$ctrl.configs['defaultDateFormat']}}</code></span>

                    <div class="mt-xxs">
                        <label>More examples:</label>
                        <ul class="list-unstyled">
                            <li><em class="text-bold">YYYY-MM-DD HH:mm</em> results in <code>{{$ctrl.date | amDateFormat:'YYYY-MM-DD HH:mm'}}</code></li>
                            <li><em class="text-bold">DD/MM/YYYY HH:mm</em> results in <code>{{$ctrl.date | amDateFormat:'DD/MM/YYYY HH:mm'}}</code></li>
                            <li><em class="text-bold">DD.MM.YY HH:mm:ss</em> results in <code>{{$ctrl.date | amDateFormat:'DD.MM.YY HH:mm:ss'}}</code></li>
                            <li><em class="text-bold">MM-DD-YYYY HH:mm:ssZ</em> results in <code>{{$ctrl.date | amDateFormat:'MM-DD-YYYY HH:mm:ssZ'}}</code></li>
                            <li><em class="text-bold">ddd, MMM Do, YYYY H:mm Z</em> results in <code>{{$ctrl.date | amDateFormat:'ddd, MMM Do, YYYY H:mm Z'}}</code></li>
                        </ul>
                        <div class="mt-xxs">
                            <span>For more details about the format <a href="https://momentjs.com/docs/#/displaying/format/" target="_blank">click here</a></span>
                        </div>

                    </div>
                </div>
            </div>

            <!-- defaultDateFormat -->

            <div class="mt-s">
                <button class="btn btn-primary pull-right" ng-disabled="settingsForm.$invalid" type="submit">Save</button>
            </div>
        </form>
    </div>
</div>

```

`frontend/app/views/components/org/custom-tags/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>

        <form ng-submit="$vm.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $vm.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$vm.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in $vm.filtering.attributeKeys"
                            ng-change="$vm.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$vm.filtering.metadata" filter="filter" entity="$vm.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$vm.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$vm.clearFilters()" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/components/org/custom-tags/tag-list.html`:

```html
<div ng-include="'views/components/org/custom-tags/toolbar.html'"></div>

<div class="mt-xs filter-panel" ng-include="'views/components/org/custom-tags/filters.html'"
    ng-show="$vm.filtering.context.showFilters"></div>

<!-- Filters preview  -->
<div class="row mt-xs">
    <div class="col-md-12 clearfix">
        <div class="pull-left">
            <h4>
                <datalist-header title="List of custom tags" list="$vm.list" total="$vm.freetagsCount">
                </datalist-header>
            </h4>
        </div>

        <filters-preview filters="$vm.filtering.context.filters" on-clear-item="$vm.removeFilter(field)"
            on-clear-all="$vm.clearFilters()"></filters-preview>
    </div>
</div>

<!-- Datalist  -->
<div class="row mt-xs">
    <div class="col-md-12 mv-s" ng-show="$vm.list.total === 0 && $vm.list.values.length === 0">
        <div class="empty-message">No records</div>
    </div>

    <div class="col-md-12" ng-show="$vm.list.values.length !== 0">
        <psearch control="$vm.list"></psearch>

        <table class="table table-striped case-tags">
            <thead>
                <tr>
                    <th>
                        <a href class="text-default" ng-click="$vm.sortByField('predicate')">
                            Name
                            <i ng-show="$vm.filtering.context.sort.indexOf('+predicate') === -1 && $vm.filtering.context.sort.indexOf('-predicate') === -1"
                                class="fa fa-sort"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('+predicate') !== -1"
                                class="fa fa-caret-up"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('-predicate') !== -1"
                                class="fa fa-caret-down"></i>
                        </a>
                    </th>
                    <th width="250px">
                        Colour
                    </th>
                    <th width="100px">Cases</th>
                    <th width="100px">Alerts</th>
                    <th width="100px">Observables</th>
                    <th width="100px">Templates</th>
                    <th style="width: 60px;">By</th>
                    <th style="width: 150px">
                        Dates

                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_createdAt')"
                            uib-tooltip="Sort by creation date">
                            C.
                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') === -1 && $vm.filtering.context.sort.indexOf('-_createdAt') === -1"
                                class="fa fa-sort"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') !== -1"
                                class="fa fa-caret-up"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('-_createdAt') !== -1"
                                class="fa fa-caret-down"></i>
                        </a>
                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_updatedAt')"
                            uib-tooltip="Sort by last update date">
                            U.
                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') === -1 && $vm.filtering.context.sort.indexOf('-_updatedAt') === -1"
                                class="fa fa-sort"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') !== -1"
                                class="fa fa-caret-up"></i>
                            <i ng-show="$vm.filtering.context.sort.indexOf('-_updatedAt') !== -1"
                                class="fa fa-caret-down"></i>
                        </a>
                    </th>
                    <th style="width: 60px">Actions</th>
                </tr>
            </thead>

            <tbody>
                <tr ng-repeat="tag in $vm.list.values">
                    <td>
                        <!-- <tag-item class="label-lg" value="tag.predicate" colour="tag.colour"></tag-item> -->
                        <updatable-tag value="tag.predicate" colour="tag.colour"
                            on-update="$vm.updateTag(tag._id, newValue)"></updatable-tag>
                    </td>
                    <td>
                        <updatable-colour value="tag.colour" on-update="$vm.updateColour(tag._id, newValue)">
                        </updatable-colour>
                    </td>
                    <td>{{tag.extraData.usage.case | limitedCount}}</td>
                    <td>{{tag.extraData.usage.alert | limitedCount}}</td>
                    <td>{{tag.extraData.usage.observable | limitedCount}}</td>
                    <td>{{tag.extraData.usage.caseTemplate | limitedCount}}</td>
                    <td class="nowrap">
                        <user user-id="tag._createdBy" icon-only="true" icon-size="m"></user>
                    </td>
                    <td>
                        <div
                            ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_createdAt') !== -1 || $vm.filtering.context.sort.indexOf('-_createdAt') !== -1}">
                            C. <a href ng-click="$vm.addFilterValue('_createdAt', tag._createdAt)">{{tag._createdAt |
                                shortDate}}</a>
                        </div>
                        <div ng-if="tag._updatedAt > 0"
                            ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_updatedAt') !== -1 || $vm.filtering.context.sort.indexOf('-_updatedAt') !== -1}">
                            U. <a href ng-click="$vm.addFilterValue('_updatedAt', tag._updatedAt)">{{tag._updatedAt |
                                shortDate}}</a>
                        </div>
                    </td>
                    <td class="text-center">
                        <!-- <a href class="btn btn-icon btn-clear" ng-click="$vm.showTemplate(template)">
                            <i class="text-info fa fa-edit"></i>
                        </a> -->
                        <a href class="btn btn-icon btn-clear" ng-click="$vm.deleteTag(tag)">
                            <i class="text-info fa fa-trash text-danger"></i>
                        </a>
                    </td>
                </tr>
            </tbody>
        </table>

        <psearch control="$vm.list"></psearch>
    </div>
</div>

```

`frontend/app/views/components/org/custom-tags/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]" type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/components/org/orgSwitch.modal.html`:

```html
<form ng-submit="$modal.confirm()">
    <div class="modal-header bg-primary">
        <h3 class="modal-title"><i class="fa fa-random"></i> Switch organisation</h3>
    </div>
    <div class="modal-body">
        <p class="mb-xs">
            Please select the organisation you want to switch to:
        </p>

        <div class="form-group has-feedback has-feedback-left" ng-if="$dialog.currentUser.organisations.length > 5">
            <input type="text" class="input input-lg form-control" placeholder="Filter organisations" ng-model="$modal.filter" autocomplete="off">
            <i class="form-control-feedback glyphicon glyphicon-search"></i>
        </div>


        <ul class="nav nav-pills nav-stacked">
            <div class="list-group">
                <a href ng-click="$dialog.selectOrg(item.organisationId)" class="list-group-item"
                    ng-class="{'active': $dialog.currentUser.organisation === item.organisation}"
                    ng-repeat="item in $dialog.currentUser.organisations | filter:$modal.filter track by $index">
                    <h4 class="list-group-item-heading">{{item.organisation}} <em class="pull-right" ng-if="$dialog.currentUser.organisation === item.organisation">(current)</em></h4>
                    <p class="list-group-item-text">Profile: <strong>{{item.profile}}</strong></p>
                </a>
            </div>
        </ul>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$dialog.cancel()" type="button">Cancel</button>
    </div>
</form>

```

`frontend/app/views/components/org/user.list.html`:

```html
<!-- <p class="lead mb-xs clearfix">
  <a class="btn btn-primary pull-right" href ng-click="$ctrl.openModal('create', {})"><i class="fa fa-plus"></i> Add user</a>
</p> -->

<div class="row" ng-if="$ctrl.users.total === 0">
    <div class="col-md-12">
        <div class="empty-message">No users defined.</div>
    </div>
</div>

<div class="row" ng-if="$ctrl.users.total > 0">
    <div class="col-md-12">
        <psearch control="$ctrl.users"></psearch>

        <table class="table table-striped case-list valigned">
            <thead>
                <tr>
                    <th style="width: 80px">Status</th>
                    <th>
                        <a href class="text-default" ng-click="$ctrl.sortByField('login')">
                            Login
                            <i ng-show="$ctrl.sort.indexOf('+login') === -1 && $ctrl.sort.indexOf('-login') === -1"
                                class="fa fa-sort"></i>
                            <i ng-show="$ctrl.sort.indexOf('+login') !== -1" class="fa fa-caret-up"></i>
                            <i ng-show="$ctrl.sort.indexOf('-login') !== -1" class="fa fa-caret-down"></i>
                        </a>
                    </th>
                    <th style="width: 150px">
                        <a href class="text-default" ng-click="$ctrl.sortByField('name')">
                            Full Name
                            <i ng-show="$ctrl.sort.indexOf('+name') === -1 && $ctrl.sort.indexOf('-name') === -1"
                                class="fa fa-sort"></i>
                            <i ng-show="$ctrl.sort.indexOf('+name') !== -1" class="fa fa-caret-up"></i>
                            <i ng-show="$ctrl.sort.indexOf('-name') !== -1" class="fa fa-caret-down"></i>
                        </a>
                    </th>
                    <th style="width: 140px">
                        <a href class="text-default" ng-click="$ctrl.sortByField('profile')">
                            Profile
                            <i ng-show="$ctrl.sort.indexOf('+profile') === -1 && $ctrl.sort.indexOf('-profile') === -1"
                                class="fa fa-sort"></i>
                            <i ng-show="$ctrl.sort.indexOf('+profile') !== -1" class="fa fa-caret-up"></i>
                            <i ng-show="$ctrl.sort.indexOf('-profile') !== -1" class="fa fa-caret-down"></i>
                        </a>
                    </th>
                    <th>Password</th>
                    <th>API Key</th>
                    <th class="text-center" style="width: 100px" ng-if="$ctrl.mfaEnabled">MFA</th>
                    <th class="text-center" style="width: 150px">
                        Dates
                        <a href class="text-default" ng-click="$ctrl.sortByField('_createdAt')">
                            C.
                            <i ng-show="$ctrl.sort.indexOf('+_createdAt') === -1 && $ctrl.sort.indexOf('-_createdAt') === -1"
                                class="fa fa-sort"></i>
                            <i ng-show="$ctrl.sort.indexOf('+_createdAt') !== -1" class="fa fa-caret-up"></i>
                            <i ng-show="$ctrl.sort.indexOf('-_createdAt') !== -1" class="fa fa-caret-down"></i>
                        </a>
                        <a href class="text-default" ng-click="$ctrl.sortByField('_updatedAt')">
                            U.
                            <i ng-show="$ctrl.sort.indexOf('+_updatedAt') === -1 && $ctrl.sort.indexOf('-_updatedAt') === -1"
                                class="fa fa-sort"></i>
                            <i ng-show="$ctrl.sort.indexOf('+_updatedAt') !== -1" class="fa fa-caret-up"></i>
                            <i ng-show="$ctrl.sort.indexOf('-_updatedAt') !== -1" class="fa fa-caret-down"></i>
                        </a>
                    </th>
                    <th style="width: 100px"></th>
                </tr>
            </thead>
            <tbody>
                <tr ng-repeat="user in $ctrl.users.values track by user._id">
                    <td>
                        <span class="label label-default label-lg"
                            ng-class="{false: 'label-success', true: 'label-danger'}[user.locked]">{{user.locked ===
                            false ? 'Active' : 'Locked'}}</span>
                    </td>
                    <td>{{user.login}}</td>
                    <td>{{user.name}}</td>
                    <td>
                        <span popover-trigger="'mouseenter'" uib-popover-template="'permissionsPopoverTemplate.html'"
                            popover-title="Permissions">
                            {{user.profile}}
                        </span>
                    </td>
                    <td>
                        <span>
                            <span class="btn btn-sm btn-default" ng-class="{ true: 'disabled', false: ''}[user.locked]"
                                ng-click="$ctrl.showPassword(user, true)"
                                ng-hide="$ctrl.showPwdForm[user._id]">{{user.hasPassword ? 'Edit password' : 'New
                                password'}}</span>
                            <form ng-show="$ctrl.showPwdForm[user._id]"
                                ng-submit="$ctrl.setPassword(user, newValue); $ctrl.showPassword(user, false);">
                                <div class="input-group input-group-sm">
                                    <input auto-focus="user-showPassword-{{user._id}}" class="form-control input-sm"
                                        ng-model="newValue" type="password">
                                    <span class="input-group-btn">
                                        <button class="btn btn-default" type="submit">
                                            <i class="fa fa-check text-success"></i>
                                        </button>
                                        <button class="btn btn-default" type="button"
                                            ng-click="$ctrl.showPassword(user, false)">
                                            <i class="fa fa-times text-danger"></i>
                                        </button>
                                    </span>
                                </div>
                            </form>
                        </span>
                    </td>
                    <td>
                        <span ng-if="!user.hasKey">
                            <span class="btn btn-sm btn-default" ng-class="{true: 'disabled'}[user.locked]"
                                ng-click="$ctrl.createKey(user)">Create API Key</span>
                        </span>
                        <span ng-if="user.hasKey">
                            <div class="input-group input-group-sm">
                                <span class="input-group-btn">
                                    <span class="btn btn-sm btn-default" ng-class="{true: 'disabled'}[user.locked]"
                                        ng-click="$ctrl.createKey(user)">Renew</span>
                                    <span class="btn btn-sm btn-danger" ng-class="{true: 'disabled'}[user.locked]"
                                        ng-click="$ctrl.revokeKey(user)">Revoke</span>
                                    <span class="btn btn-sm btn-primary" ng-class="{true: 'disabled'}[user.locked]"
                                        ng-click="$ctrl.getKey(user)"
                                        ng-if="!$ctrl.userKeyCache[user._id]">Reveal</span>
                                </span>
                                <input class="form-control" readonly ng-model="$ctrl.userKeyCache[user._id]"
                                    ng-if="$ctrl.userKeyCache[user._id]">
                                <span class="input-group-btn" ng-if="$ctrl.userKeyCache[user._id]">
                                    <button class="btn btn-primary" type="button" ng-click="$ctrl.copyKey(user)">
                                        <i class="fa fa-copy"></i>
                                    </button>
                                </span>
                            </div>
                        </span>
                    </td>
                    <td class="text-center" ng-if="$ctrl.mfaEnabled">
                        <span ng-if="!user.hasMFA">
                            No
                        </span>
                        <span ng-if="user.hasMFA">
                            <button type="button" class="btn btn-danger btn-sm"
                                ng-click="$ctrl.resetMfa(user)">Reset</button>
                        </span>
                    </td>
                    <td>
                        <div
                            ng-class="{'text-bold': $ctrl.sort.indexOf('+_createdAt') !== -1 || $ctrl.sort.indexOf('-_createdAt') !== -1}">
                            C. <a href ng-click="$ctrl.addFilterValue('_createdAt', user._createdAt)">{{user._createdAt
                                | shortDate}}</a>
                        </div>
                        <div ng-if="user._updatedAt > 0"
                            ng-class="{'text-bold': $ctrl.sort.indexOf('+_updatedAt') !== -1 || $ctrl.sort.indexOf('-_updatedAt') !== -1}">
                            U. <a href ng-click="$ctrl.addFilterValue('_updatedAt', user._updatedAt)">{{user._updatedAt
                                | shortDate}}</a>
                        </div>
                    </td>
                    <td>
                        <span class="clickable mr-xxs text-primary" ng-click="$ctrl.editUser(user)"
                            uib-tooltip="Edit User">
                            <i class="text-20 fa fa-edit"></i>
                        </span>

                        <span class="clickable mr-xxs text-primary"
                            ng-if="!user.locked && user._id !== $ctrl.currentUser._id"
                            ng-click="$ctrl.lockUser(user, true)" uib-tooltip="Lock User">
                            <i class="text-20 fa fa-lock"></i>
                        </span>

                        <span class="clickable mr-xxs text-primary"
                            ng-if="user.locked && user._id !== $ctrl.currentUser._id"
                            ng-click="$ctrl.lockUser(user, false)" uib-tooltip="Unlock User">
                            <i class="text-20 fa fa-unlock-alt"></i>
                        </span>

                        <span class="clickable mr-xxs text-danger" ng-if="user._id !== $ctrl.currentUser._id"
                            ng-click="$ctrl.removeUser(user)" uib-tooltip="Delete User">
                            <i class="text-20 fa fa-trash"></i>
                        </span>
                    </td>
                </tr>
            </tbody>
        </table>

        <psearch control="$ctrl.users"></psearch>
    </div>
</div>
<script type="text/ng-template" id="permissionsPopoverTemplate.html">
    <div class="wrap">
        <em ng-if="user.permissions.length === 0" class="text-muted">No Permissions</em>
        <span class="label label-default mr-xxs" ng-repeat="permission in user.permissions">{{permission}}</span>
    </div>
</script>

```

`frontend/app/views/components/search/filters-preview.component.html`:

```html
<div class="active-filters flexwrap mv-xs" ng-if="$ctrl.filters.length > 0">
    <span class="mr-xxxs text-muted">{{$ctrl.filters.length}} filter(s) applied:</span>

    <span class="kv-label kv-label-addon mb-xxxs mr-xxxs"
        ng-repeat="filter in $ctrl.filters track by $index">
        <span class="kv-label-key default"><strong>{{filter.field || '???'}}</strong></span>
        <span class="kv-label-val default" uib-tooltip="{{filter.value | filterValue}}" tooltip-placement="top">{{filter.value | filterValue}}</span>

        <span class="default" ng-click="$ctrl.clearItem($index)">
            <i class="filter-close fa fa-times text-danger"></i>
        </span>
    </span>

    <span class="ml-xs">
        <a href ng-click="$ctrl.clearAll()">Clear filters</a>
    </span>

</div>

```

`frontend/app/views/components/sharing/sharing-list.html`:

```html
<div>
    <div ng-if="!$ctrl.shares || $ctrl.shares.length === 0">
        <div class="empty-message">No records</div>
    </div>

    <div ng-if="$ctrl.shares.length > 0">

        <table class="table table-striped">
            <thead>
                <th width="20"></th>
                <th>Organisation</th>
                <th width="250">Profile</th>
                <th width="160">Shared At</th>
                <th width="160" class="text-right" if-permission="manageShare" allowed="{{$ctrl.permissions}}">Actions</th>
            </thead>
            <tbody>
                <tr ng-repeat="share in $ctrl.shares | orderBy:'organisationName'"
                    ng-class="{true:'tr-warning'}[share.owner]">
                    <td class="text-center">
                        <i class="fa fa-star" ng-if="share.owner" uib-tooltip="Owner of the share" tooltip-placement="right-middle"></i>
                    </td>
                    <td>{{share.organisationName}}</td>
                    <td ng-if="$ctrl.readOnly">
                        <span>{{share.profileName}}</span>
                    </td>
                    <td ng-if="!$ctrl.readOnly">
                        <span if-not-permission="manageShare" allowed="{{$ctrl.permissions}}">{{share.profileName}}</span>
                        <span if-permission="manageShare" allowed="{{$ctrl.permissions}}">
                            <span ng-if="share.owner === true">{{share.profileName}}</span>
                            <span ng-if="share.owner !== true">
                                <updatable-select options="$ctrl.profiles" value="share.profileName" on-update="$ctrl.updateProfile(share._id, newValue)"></updatable-select>
                            </span>
                        </span>
                    </td>
                    <td>{{share.createdAt | shortDate}}</td>
                    <td class="text-right" if-permission="manageShare" allowed="{{$ctrl.permissions}}">
                        <span class="clickable text-danger" ng-if="share.owner !== true" ng-click="$ctrl.remove(share)">
                            <i class="fa fa-trash"></i> Delete
                        </span>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

```

`frontend/app/views/components/sharing/sharing-modal.html`:

```html
<form class="" ng-submit="$modal.save()">
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Select organisations</h3>
    </div>
    <div class="modal-body">
        <table class="table table-striped">
            <thead>
                <th width="40" class="text-center">
                    <input type="checkbox" ng-model="$modal.selectAll" ng-change="$modal.toggleAll()">
                </th>
                <th>Organisation</th>
                <th>Profile</th>
            </thead>
            <tbody>
                <tr class="clickable" ng-repeat="share in $modal.shares track by $index" ng-click="share.selected = !share.selected">
                    <td class="text-center">
                        <input type="checkbox" ng-model="share.selected">
                    </td>
                    <td>{{share.organisationName}}</td>
                    <td>{{share.profileName}}</td>
                </tr>
            </tbody>
        </table>
    </div>
    <div class="modal-footer text-left">
        <button type="button" class="btn btn-default" ng-click="$modal.cancel()">Cancel</button>
        <button type="submit" class="btn btn-primary pull-right" ng-disabled="shareForm.$invalid">Save</button>
    </div>
</form>

```

`frontend/app/views/components/sharing/task/sharing-list.html`:

```html
<div>
    <div ng-if="!$ctrl.shares || $ctrl.shares.length === 0">
        <div class="empty-message">No records</div>
    </div>

    <div ng-if="$ctrl.shares.length > 0">

        <table class="table table-striped">
            <thead>
                <th width="20"></th>
                <th>Organisation</th>
                <th width="250">Profile</th>
                <th width="160">Shared At</th>
                <th width="150" class="text-right" if-permission="manageTask" allowed="{{$ctrl.permissions}}"></th>
                <th width="80" class="text-right" if-permission="manageShare" allowed="{{$ctrl.permissions}}">Actions</th>
            </thead>
            <tbody>
                <tr ng-repeat="share in $ctrl.shares | orderBy:'organisationName'"
                    ng-class="{true:'tr-warning'}[share.owner]">
                    <td class="text-center">
                        <i class="fa fa-star" ng-if="share.owner" uib-tooltip="Owner of the share" tooltip-placement="right-middle"></i>
                    </td>
                    <td ng-class="{'text-danger': !!share.actionRequired}">
                        <span ng-if="!!share.actionRequired" class="noline mr-xxxs" uib-tooltip="Action Required" tooltip-placement="right-middle">
                            <i class="fa fa-exclamation-triangle"></i>
                        </span>
                        {{share.organisationName}}
                    </td>
                    <td ng-if="$ctrl.readOnly">
                        <span>{{share.profileName}}</span>
                    </td>
                    <td ng-if="!$ctrl.readOnly">
                        <span if-not-permission="manageShare" allowed="{{$ctrl.permissions}}">{{share.profileName}}</span>
                        <span if-permission="manageShare" allowed="{{$ctrl.permissions}}">
                            <span ng-if="share.owner === true">{{share.profileName}}</span>
                            <span ng-if="share.owner !== true">
                                <updatable-select options="$ctrl.profiles" value="share.profileName" on-update="$ctrl.updateProfile(share._id, newValue)"></updatable-select>
                            </span>
                        </span>
                    </td>
                    <td>{{share.createdAt | shortDate}}</td>
                    <td class="text-right" if-permission="manageTask" allowed="{{$ctrl.permissions}}">
                        <span ng-if="!!!share.actionRequired" class="clickable text-primary" ng-click="$ctrl.requireAction(share.organisationName)">
                            <i class="fa fa-exclamation-triangle"></i> Require Action
                        </span>
                        <span ng-if="!!share.actionRequired" class="clickable text-danger" ng-click="$ctrl.cancelRequireAction(share.organisationName)">
                            <i class="fa fa-exclamation-triangle"></i> Cancel Request
                        </span>
                    </td>

                    <td class="text-right" if-permission="manageShare" allowed="{{$ctrl.permissions}}">
                        <span class="clickable text-danger" ng-if="share.owner !== true" ng-click="$ctrl.remove(share)">
                            <i class="fa fa-trash"></i> Delete
                        </span>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

```

`frontend/app/views/directives/alert-duration.html`:

```html
<span>
    <strong ng-if="end" class="text-success" uib-tooltip="Imported after">
        <i class="fa" ng-class="icon"></i> {{indicator ? 'During ' : ''}}{{start | duration:end}}
    </strong>
    <strong ng-if="!end" class="text-danger" uib-tooltip="Created since">
        <i class="fa" ng-class="icon"></i> {{start | duration}} {{indicator ? 'ago' : ''}}
    </strong>
</span>

```

`frontend/app/views/directives/artifact-labels.html`:

```html
<div ng-if="active == true">
	<tags-input ng-model="value.labels" class="ti-input-sm" placeholder="Add a label"
				replace-spaces-with-dashes="false" min-length="2" ></tags-input>
</div>

<span ng-if="active != true" ng-switch="value">
	<span class="label label-primary" style="margin-right:5px; display:inline-block"  ng-repeat="l in value.labels"><i class="glyphicon glyphicon-tag"></i> <span ng-bind="l"></span></span>
</span>
```

`frontend/app/views/directives/case-duration.html`:

```html
<span>
    <strong ng-if="end" class="text-success" uib-tooltip="Closed after">
        <i class="fa" ng-class="icon"></i> {{indicator ? 'During ' : ''}}{{start | duration:end}}
    </strong>
    <strong ng-if="!end" class="text-danger" uib-tooltip="Open since">
        <i class="fa" ng-class="icon"></i> {{start | duration}} {{indicator ? 'ago' : ''}}
    </strong>
</span>

```

`frontend/app/views/directives/charts/c3.html`:

```html
<div class="c3-container">
    <div class="c3-error" ng-if="error">
        <div class="text-center">
            <h4 class="text-danger">
                <div class="mb-xxs"><i class="fa fa-2x fa-exclamation-triangle"></i></div>
                <div>Failed to fetch data, please edit the widget definition</div>
            </h4>
        </div>
    </div>
    <div class="clearfix" ng-show="!error && chart && !hideActions">
        <a class="pull-right ml-xxs" href ng-csv="onSaveCsv"><i class="fa fa-file-text-o mr-xxxs"></i>CSV</a>
        <a class="pull-right ml-xxs" href ng-click="save()"><i class="fa fa-file-image-o mr-xxxs"></i>Image</a>
        <strong class="text-primary pull-right">Save as</strong>
    </div>
    <div class="c3-chart" ng-show="!error">
        <div styles="height:300px;" class="text-center"><i class="fa fa-spinner fa-spin fa-2x"></i><br>Loading...</div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/bar/basic.html`:

```html
<div class="form-group">
    <label>Title</label>
    <input type="text" class="form-control" placeholder="Ex: cases per TLP" ng-model="component.options.title">
</div>
<div class="row">
    <div class="col-sm-4">
        <div class="form-group">
            <label>Entity</label>
            <select class="form-control" ng-model="component.options.entity"
                ng-options="item as metadata[item].label for item in metadata.entities"></select>
        </div>
    </div>
    <div class="col-sm-4">
        <div class="form-group">
            <label>Date Field</label>
            <select class="form-control" ng-model="component.options.dateField"
                ng-options="item.name as item.name for item in pickFields(metadata[component.options.entity].attributes, ['date']) | orderBy:'name'"></select>
        </div>
    </div>
    <div class="col-sm-4">
        <div class="form-group">
            <label>Interval</label>
            <select class="form-control" ng-model="component.options.interval"
                ng-options="item.code as item.label for item in timeIntervals"></select>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-sm-4">
        <div class="form-group">
            <label>Category Field</label>
            <select class="form-control" ng-model="component.options.field"
                ng-options="item.name as item.name for item in skipFields(metadata[component.options.entity].attributes, ['date', 'text']) | orderBy:'name'"></select>
        </div>
    </div>
    <div class="col-sm-4">
        <div class="form-group">
            <label>Bar types</label>
            <div class="checkbox">

                <label>
                    <input type="checkbox" ng-model="component.options.stacked"> Stack the categories
                </label>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/bar/edit.html`:

```html
<uib-tabset class="nav-tabs-custom" active="layout.activeTab">
    <uib-tab index="0">
        <uib-tab-heading>
            <i class="fa fa-bars"></i> Basic
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/bar/basic.html'"></ng-include>
    </uib-tab>
    <uib-tab index="1">
        <uib-tab-heading>
            <i class="fa fa-filter"></i> Filters
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/filters.html'"></ng-include>
    </uib-tab>
    <uib-tab index="2" ng-if="metadata[component.options.entity].attributes[component.options.field].values.length > 0">
        <uib-tab-heading>
            <i class="fa fa-paint-brush"></i> Customize
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/customize.html'"></ng-include>
    </uib-tab>
</uib-tabset>

```

`frontend/app/views/directives/dashboard/counter/basic.html`:

```html
<div class="form-group">
    <label>Title</label>
    <input type="text" class="form-control" placeholder="Ex: cases per TLP" ng-model="component.options.title">
</div>
<div class="row">
    <div class="col-sm-6">
        <div class="form-group">
            <label>Entity</label>
            <select class="form-control" ng-model="component.options.entity"
                ng-options="item as metadata[item].label for item in metadata.entities"></select>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/counter/edit.html`:

```html
<uib-tabset class="nav-tabs-custom" active="layout.activeTab">
    <uib-tab index="0">
        <uib-tab-heading>
            <i class="fa fa-bars"></i> Basic
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/counter/basic.html'"></ng-include>
    </uib-tab>
    <uib-tab index="1">
        <uib-tab-heading>
            <i class="fa fa-sort"></i> Series
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/counter/series.html'"></ng-include>
    </uib-tab>
    <uib-tab index="2">
        <uib-tab-heading>
            <i class="fa fa-filter"></i> Filters
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/filters.html'"></ng-include>
    </uib-tab>
</uib-tabset>

```

`frontend/app/views/directives/dashboard/counter/series.html`:

```html
<div ng-if="!component.options.series || component.options.series.length === 0" class="empty-message">
    No series defined. <a href ng-click="addSerie()">Add a serie</a>
</div>

<div class="mb-xxxs dashboard-serie" ng-repeat="serie in component.options.series track by $index">
    <div class="form-inline">
        <div class="input-group">
            <span class="input-group-btn">
                <button class="btn btn-default" type="button" ng-click="removeSerie($index)">
                    <i class="fa fa-times text-danger"></i>
                </button>
            </span>
            <select class="form-control" ng-model="serie.agg"
                ng-options="item.label as item.id for (key, item) in aggregations" ng-change="setSerieAgg(serie)">
                <option value="" disabled selected></option>
            </select>
        </div>
        <div class="form-group">
            <select class="form-control" ng-model="serie.field" ng-disabled="serie.agg === 'count'"
                ng-options="item.name as item.name for (key, item) in fieldsForAggregation(metadata[component.options.entity].attributes, serie.agg)">
                <option value="" disabled selected>-- Select field --</option>
            </select>
        </div>
        <div class="form-group">
            <input class="form-control" type="text" ng-model="serie.label" placeholder="Customize label">
        </div>
    </div>
    <div class="ml-m mt-xs">
        <ng-include src="'views/directives/dashboard/serie.filters.html'"></ng-include>
    </div>
</div>


<div ng-if="component.options.series && component.options.series.length > 0" class="mv-xs">
    <a href ng-click="addSerie()">
        <i class="fa fa-plus"></i> Add a serie
    </a>
</div>

```

`frontend/app/views/directives/dashboard/counter/view.html`:

```html
<div class="c3-container">
    <div class="c3-error" ng-if="error">
        <div class="text-center">
            <h4 class="text-danger">
                <div class="mb-xxs"><i class="fa fa-2x fa-exclamation-triangle"></i></div>
                <div>Failed to fetch data, please edit the widget definition</div>
            </h4>
        </div>
    </div>
    <div ng-if="!error" class="row" ng-repeat="item in data">        
        <div class="col-md-4 text-right">
            <h2 ng-if="item.agg !== 'count'">{{item.value | number}}</h2>
            <h2 ng-if="item.agg === 'count'"><a href ng-click="openSearch(item)">{{item.value | number}}</a></h2>
        </div>
        <div class="col-md-8">
            <h2><small>{{item.label}}</small></h2>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/customize.html`:

```html

<div class="empty-message" ng-if="!component.options.entity || !component.options.field">
    Please select entity and field in <a href ng-click="layout.activeTab = 0">Basic tab</a>
</div>

<!-- <div class="empty-message" ng-if="metadata[component.options.entity].attributes[component.options.field].values.length === 0">
    You can customize the categories' labels and colors. <a href ng-click="addColor()">Add entry</a>
</div> -->

<div class="row mb-xxs" ng-repeat="val in metadata[component.options.entity].attributes[component.options.field].values track by $index">
    <div class="col-sm-4">
        <div class="form-control">
            <label>{{val}}</label>
        </div>
    </div>
    <div class="col-sm-4">
        <input type="text" class="form-control" ng-model="component.options.names[val]" placeholder="Label">
    </div>
    <div class="col-sm-4">
        <div class="input-group">
            <input type="text" class="form-control" ng-model="component.options.colors[val]" placeholder="Color" size="8">
            <span class="input-group-btn">
                <button colorpicker colorpicker-close-on-select class="btn btn-default" ng-model="component.options.colors[val]" type="button">
                    <i class="fa fa-stop" style="color: {{component.options.colors[val]}};" ng-class="{'fa-stop': serie.color, 'fa-ellipsis-h': !component.options.colors[val]}"></i>
                </button>
            </span>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/donut/basic.html`:

```html
<div class="form-group">
    <label>Title</label>
    <input type="text" class="form-control" placeholder="Ex: cases per TLP" ng-model="component.options.title">
</div>
<div class="row">
    <div class="col-sm-6">
        <div class="form-group">
            <label>Entity</label>
            <select class="form-control" ng-model="component.options.entity"
                ng-options="item as metadata[item].label for item in metadata.entities"></select>
        </div>
    </div>
    <div class="col-sm-6">
        <div class="form-group">
            <label>Aggregation Field</label>
            <select class="form-control" ng-model="component.options.field"
                ng-options="item.name as item.name for item in skipFields(metadata[component.options.entity].attributes, ['date', 'text']) | orderBy:'name'"></select>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/donut/edit.html`:

```html
<uib-tabset class="nav-tabs-custom" active="layout.activeTab">
    <uib-tab index="0">
        <uib-tab-heading>
            <i class="fa fa-bars"></i> Basic
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/donut/basic.html'"></ng-include>
    </uib-tab>
    <uib-tab index="1">
        <uib-tab-heading>
            <i class="fa fa-sort"></i> Sort
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/donut/sort.html'"></ng-include>
    </uib-tab>
    <uib-tab index="2">
        <uib-tab-heading>
            <i class="fa fa-filter"></i> Filters
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/filters.html'"></ng-include>
    </uib-tab>
    <uib-tab index="3" ng-if="metadata[component.options.entity].attributes[component.options.field].values.length > 0">
        <uib-tab-heading>
            <i class="fa fa-paint-brush"></i> Customize
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/customize.html'"></ng-include>
    </uib-tab>
</uib-tabset>

```

`frontend/app/views/directives/dashboard/donut/sort.html`:

```html
<div class="row">
    <div class="col-sm-6">
        <div class="form-group">
            <label>Sort by</label>
            <select class="form-control" ng-model="component.options.sort"
                ng-options="item.name as item.label for item in sortOptions | orderBy:'name'"></select>
        </div>
    </div>
    <div class="col-sm-6">
        <div class="form-group">
            <label>Limit</label>
            <input type="number" class="form-control" ng-model="component.options.limit">
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/edit.dialog.html`:

```html
<form>
    <div class="chart-edit-dialog modal-header bg-primary">
        <h3 class="modal-title">
            <i class="mr-xxs fa" ng-class="typeClasses[component.type]"></i>
            {{component.options.title || 'No title'}}
        </h3>
    </div>
    <div class="modal-body" ng-include="'views/directives/dashboard/'+component.type+'/edit.html'"></div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
        <button class="btn btn-primary pull-right" ng-click="save()">Apply</button>
    </div>
</form>

```

`frontend/app/views/directives/dashboard/filter-editor.html`:

```html
<div ng-switch="editorFor(filter)">
    <!-- <input ng-switch-when="number" type="number" class="form-control" ng-model="filter.value"> -->
    <input ng-switch-when="text" type="text" class="form-control" ng-model="filter.value">

    <div ng-switch-when="number|integer|float" ng-switch-when-separator="|" class="row">
        <div class="col-xs-2 ph-0" uib-dropdown>
            <button type="button" class="btn btn-block btn-default dropdown-toggle" uib-dropdown-toggle>
                {{operatorMap[filter.value.operator] || '='}} <span class="caret"></span>
            </button>
            <ul class="dropdown-menu" uib-dropdown-menu>
                <li><a href ng-click="filter.value.operator = 'empty'">is empty</a></li>
                <li><a href ng-click="filter.value.operator = '='">=</a></li>
                <li><a href ng-click="filter.value.operator = '!='">!=</a></li>
                <li><a href ng-click="filter.value.operator = '<'">&lt;</a></li>
                <li><a href ng-click="filter.value.operator = '<='">&lt;=</a></li>
                <li><a href ng-click="filter.value.operator = '>'">&gt;</a></li>
                <li><a href ng-click="filter.value.operator = '>='">&gt;=</a></li>
            </ul>
        </div>
        <div class="col-xs-10 pl-xxxs" ng-show="filter.value.operator !== 'empty'">
            <input type="number" step=".01" class="form-control" ng-model="filter.value.value">
        </div>
    </div>

    <div ng-switch-when="tags" class="row">
        <div class="col-xs-2 ph-0" uib-dropdown>
            <button type="button" class="btn btn-block btn-default dropdown-toggle" uib-dropdown-toggle>
                {{operatorMap[filter.value.operator || 'any']}} <span class="caret"></span>
            </button>
            <ul class="dropdown-menu" uib-dropdown-menu>
                <li><a href ng-click="filter.value.operator = 'empty'">is empty</a></li>
                <li><a href ng-click="filter.value.operator = 'any'">any of</a></li>
                <li><a href ng-click="filter.value.operator = 'all'">all of</a></li>
                <li><a href ng-click="filter.value.operator = 'none'">none of</a></li>
            </ul>
        </div>
        <div class="col-xs-10 pl-xxxs clear" ng-show="filter.value.operator !== 'empty'">
            <div class="input-group">
                <tags-input class="form-control-wrapper ti-tag-selector"
                    ng-model="filter.value.list"
                    placeholder="ex: Enter a tag"
                    replace-spaces-with-dashes="false"
                    template="views/directives/tag-input-item.html">
                        <auto-complete source="promiseFor(filter, $query)" min-length="3" debounce-delay="400"></auto-complete>
                </tags-input>

                <span class="input-group-btn vtop">
                    <button type="button" class="btn btn-block btn-default" ng-click="fromTagLibrary(filter)" uib-tooltip="Add tag from library" tooltip-placement="left">
                        <span class="fa fa-plus"></span>
                    </button>
                </span>
            </div>
        </div>
    </div>

    <div ng-switch-when="user" class="row">
        <div class="col-xs-2 ph-0" uib-dropdown>
            <button type="button" class="btn btn-block btn-default dropdown-toggle" uib-dropdown-toggle>
                {{operatorMap[filter.value.operator || 'any']}} <span class="caret"></span>
            </button>
            <ul class="dropdown-menu" uib-dropdown-menu>
                <li><a href ng-click="filter.value.operator = 'empty'">is empty</a></li>
                <li><a href ng-click="filter.value.operator = 'any'">any of</a></li>
                <li><a href ng-click="filter.value.operator = 'all'">all of</a></li>
                <li><a href ng-click="filter.value.operator = 'none'">none of</a></li>
            </ul>
        </div>
        <div class="col-xs-10 pl-xxxs" ng-show="filter.value.operator !== 'empty'">
            <tags-input class="form-control-wrapper" min-length="2" ng-model="filter.value.list"
                placeholder="ex: Firstname Lastname"
                replace-spaces-with-dashes="false"
                add-from-autocomplete-only="true"
                display-property="label">
                    <auto-complete load-on-down-arrow="true" source="promiseFor(filter, $query)" display-property="label"></auto-complete>
                </tags-input>
        </div>
    </div>

    <div ng-switch-when="string" class="row">
        <div class="col-xs-2 ph-0" uib-dropdown>
            <button type="button" class="btn btn-block btn-default dropdown-toggle" uib-dropdown-toggle>
                {{operatorMap[filter.value.operator || 'any']}} <span class="caret"></span>
            </button>
            <ul class="dropdown-menu" uib-dropdown-menu>
                <li><a href ng-click="filter.value.operator = 'empty'">is empty</a></li>
                <li><a href ng-click="filter.value.operator = 'any'">any of</a></li>
                <li><a href ng-click="filter.value.operator = 'all'">all of</a></li>
                <li><a href ng-click="filter.value.operator = 'none'">none of</a></li>
            </ul>
        </div>
        <div class="col-xs-10 pl-xxxs" ng-show="filter.value.operator !== 'empty'">
            <tags-input class="form-control-wrapper" min-length="2"
                ng-model="filter.value.list"
                placeholder="Enter a {{filter.field}}"
                replace-spaces-with-dashes="false"></tags-input>
        </div>
    </div>

    <div ng-switch-when="enumeration" class="row">
        <div class="col-xs-2 ph-0" uib-dropdown>
            <button type="button" class="btn btn-block btn-default dropdown-toggle" uib-dropdown-toggle>
                {{operatorMap[filter.value.operator || 'any']}}<span class="caret"></span>
            </button>
            <ul class="dropdown-menu" uib-dropdown-menu>
                <li><a href ng-click="filter.value.operator = 'empty'">is empty</a></li>
                <li><a href ng-click="filter.value.operator = 'any'">any of</a></li>
                <li><a href ng-click="filter.value.operator = 'all'">all of</a></li>
                <li><a href ng-click="filter.value.operator = 'none'">none of</a></li>
            </ul>
        </div>
        <div class="col-xs-10 pl-xxxs" ng-show="filter.value.operator !== 'empty'">
            <tags-input class="form-control-wrapper" min-length="2" ng-model="filter.value.list"
                replace-spaces-with-dashes="false"
                add-from-autocomplete-only="true"
                placeholder="Enter a {{filter.field}}"
                display-property="label">
                <auto-complete load-on-focus="true" load-on-down-arrow="true" min-length="1"
                    source="promiseFor(filter, $query)"
                    display-property="label"></auto-complete>
            </tags-input>
        </div>

    </div>

    <div ng-switch-when="boolean" class="row">
        <div class="col-xs-12 pl-0 btn-group">
            <label uib-btn-radio="true" class="btn btn-default" name="{{filter.field}}" ng-model="filter.value">Yes</label>
            <label uib-btn-radio="false" class="btn btn-default" name="{{filter.field}}" ng-model="filter.value">No</label>
            <label uib-btn-radio="null" class="btn btn-default" name="{{filter.field}}" ng-model="filter.value">Any</label>
        </div>
    </div>

    <div ng-switch-when="date" class="row">
        <div class="ph-0" uib-dropdown ng-class="{
            'col-xs-2': !filter.value.operator || filter.value.operator === 'custom',
            'col-xs-4': filter.value.operator && filter.value.operator !== 'custom'
        }">
            <button type="button" class="btn btn-block btn-default dropdown-toggle" uib-dropdown-toggle>
                {{dateOperator[filter.value.operator || 'custom']}} <span class="caret"></span>
            </button>
            <ul class="dropdown-menu" uib-dropdown-menu>
                <li><a href ng-click="setDateFilterOperator(filter, 'empty')">Empty</a></li>
                <li><a href ng-click="setDateFilterOperator(filter, 'custom')">Custom</a></li>
                <li><a href ng-click="setDateFilterOperator(filter, 'today')">Today</a></li>
                <li><a href ng-click="setDateFilterOperator(filter, 'last7days')">Last 7 days</a></li>
                <li><a href ng-click="setDateFilterOperator(filter, 'last30days')">Last 30 days</a></li>
                <li><a href ng-click="setDateFilterOperator(filter, 'last3months')">Last 3 months</a></li>
                <li><a href ng-click="setDateFilterOperator(filter, 'last6months')">Last 6 months</a></li>
                <li><a href ng-click="setDateFilterOperator(filter, 'lastyear')">Last year</a></li>
            </ul>
        </div>
        <div class="col-xs-5 pl-xxxs" ng-show="!filter.value.operator || filter.value.operator === 'custom'">
            <dt-picker date="filter.value.from" placeholder="from"></dt-picker>
        </div>
        <div class="col-xs-5 pl-0" ng-show="!filter.value.operator || filter.value.operator === 'custom'">
            <dt-picker date="filter.value.to" placeholder="to"></dt-picker>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/filters.html`:

```html
<div ng-if="!component.options.filters || component.options.filters.length === 0" class="empty-message">
    No filters defined. <a href ng-click="addFilter()">Add a filter</a>
</div>
<div class="row mb-xxxs" ng-repeat="filter in component.options.filters track by $index">
    <div class="col-sm-4">
        <div class="input-group">
            <span class="input-group-btn">
                <button class="btn btn-default" type="button" ng-click="removeFilter($index)">
                    <i class="fa fa-times text-danger"></i>
                </button>
            </span>
            <select class="form-control" ng-model="filter.field"
                ng-options="item for item in metadata[component.options.entity].attributeKeys"
                ng-change="setFilterField(filter, component.options.entity)"></select>
        </div>
    </div>
    <!-- <div class="col-sm-8" ng-include="'views/directives/dashboard/filter-editor.html'"></div> -->
    <div class="col-sm-8">
        <filter-editor metadata="metadata" filter="filter" entity="component.options.entity"></filter-editor>
    </div>
</div>
<div ng-if="component.options.filters && component.options.filters.length > 0" class="mv-xs">
    <a href ng-click="addFilter()">
        <i class="fa fa-plus"></i> Add a filter
    </a>
</div>

```

`frontend/app/views/directives/dashboard/item.html`:

```html
<div class="box box-primary">
    <div class="box-header with-border">
        <h3 class="box-title">
            <i class="mr-xxs fa" ng-class="typeClasses[component.type]"></i>{{component.options.title || 'No title'}}
        </h3>

        <div class="box-tools pull-right">
            <a href class="btn btn-box-tool" ng-click="editItem()" ng-if="showEdit">
                <i class="fa fa-pencil"></i> Edit
            </a>
            <a href class="btn btn-box-tool" ng-click="onRemove({rowIndex: rowIndex, colIndex: colIndex})" ng-if="showRemove">
                <i class="fa fa-times"></i> Remove
            </a>

        </div>
        <!-- <div class="box-tools pull-right" ng-if="mode === 'edit'">
            <button type="button" class="btn btn-box-tool" >
                <i class="fa fa-save"></i> Save
            </button>
        </div> -->
    </div>
    <div class="box-body" ng-switch="component.type">
        <dashboard-donut ng-switch-when="donut"
            entity="metadata[component.options.entity]"
            options="component.options"
            filter="filter"
            autoload="autoload"
            refresh-on="{{refreshOn}}"
            resize-on="{{resizeOn}}"
            mode="mode"></dashboard-donut>

        <dashboard-bar ng-switch-when="bar"
            entity="metadata[component.options.entity]"
            options="component.options"
            filter="filter"
            autoload="autoload"
            refresh-on="{{refreshOn}}"
            resize-on="{{resizeOn}}"
            mode="mode"></dashboard-bar>

        <dashboard-line ng-switch-when="line"
            entity="metadata[component.options.entity]"
            options="component.options"
            filter="filter"
            autoload="autoload"
            refresh-on="{{refreshOn}}"
            resize-on="{{resizeOn}}"
            mode="mode"></dashboard-line>

        <dashboard-multiline ng-switch-when="multiline"
            entity="metadata[component.options.entity]"
            options="component.options"
            filter="filter"
            autoload="autoload"
            refresh-on="{{refreshOn}}"
            resize-on="{{resizeOn}}"
            mode="mode"></dashboard-multiline>

        <dashboard-text ng-switch-when="text"
            entity="metadata[component.options.entity]"
            options="component.options"
            filter="filter"
            autoload="autoload"
            refresh-on="{{refreshOn}}"
            mode="mode"></dashboard-text>

        <dashboard-counter ng-switch-when="counter"
            entity="metadata[component.options.entity]"
            options="component.options"
            filter="filter"
            autoload="autoload"
            refresh-on="{{refreshOn}}"
            mode="mode"></dashboard-counter>

        <div ng-switch-default>Unhandled chart type</div>

    </div>
</div>

```

`frontend/app/views/directives/dashboard/line/basic.html`:

```html
<div class="form-group">
    <label>Title</label>
    <input type="text" class="form-control" placeholder="Ex: cases per TLP" ng-model="component.options.title">
</div>
<div class="row">
    <div class="col-sm-4">
        <div class="form-group">
            <label>Entity</label>
            <select class="form-control" ng-model="component.options.entity"
                ng-options="item as metadata[item].label for item in metadata.entities"></select>
        </div>
    </div>
    <div class="col-sm-4">
        <div class="form-group">
            <label>Date Field</label>
            <select class="form-control" ng-model="component.options.field"
                ng-options="item.name as item.name for item in pickFields(metadata[component.options.entity].attributes, ['date']) | orderBy:'name'"></select>
        </div>
    </div>
    <div class="col-sm-4">
        <div class="form-group">
            <label>Interval</label>
            <select class="form-control" ng-model="component.options.interval"
                ng-options="item.code as item.label for item in timeIntervals"></select>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/line/edit.html`:

```html
<uib-tabset class="nav-tabs-custom" active="layout.activeTab">
    <uib-tab index="0">
        <uib-tab-heading>
            <i class="fa fa-bars"></i> Basic
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/line/basic.html'"></ng-include>
    </uib-tab>
    <uib-tab index="1">
        <uib-tab-heading>
            <i class="fa fa-sort"></i> Series
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/line/series.html'"></ng-include>        
    </uib-tab>
    <uib-tab index="2">
        <uib-tab-heading>
            <i class="fa fa-filter"></i> Filters
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/filters.html'"></ng-include>
    </uib-tab>
</uib-tabset>

```

`frontend/app/views/directives/dashboard/line/series.html`:

```html
<div ng-if="!component.options.series || component.options.series.length === 0" class="empty-message">
    No series defined. <a href ng-click="addSerie()">Add a serie</a>
</div>
<div class="mb-xxxs dashboard-serie" ng-repeat="serie in component.options.series track by $index">
    <div class="form-inline">
        <div class="input-group">
            <span class="input-group-btn">
                <button class="btn btn-default" type="button" ng-click="removeSerie($index)">
                    <i class="fa fa-times text-danger"></i>
                </button>
            </span>
            <select class="form-control" ng-model="serie.agg"
                ng-options="item.label as item.id for (key, item) in aggregations" ng-change="setSerieAgg(serie)">
                <option value="" disabled selected></option>
            </select>
        </div>
        <div class="form-group">
            <select class="form-control" ng-model="serie.field" ng-disabled="serie.agg === 'count'"
                ng-options="item.name as item.name for (key, item) in fieldsForAggregation(metadata[component.options.entity].attributes, serie.agg)">
                <option value="" disabled selected>-- Select field --</option>
            </select>
        </div>
        <div class="form-group">
            <select class="form-control" ng-model="serie.type" ng-options="item for item in serieTypes"></select>
        </div>

        <div class="form-group">
            <input class="form-control" type="text" ng-model="serie.label" placeholder="Label">
        </div>
        <div class="input-group">
            <input type="text" class="form-control" ng-model="serie.color" placeholder="Color" size="8">
            <span class="input-group-btn">
                <button colorpicker colorpicker-close-on-select class="btn btn-default" ng-model="serie.color"
                    type="button">
                    <i class="fa fa-stop" style="color: {{serie.color}};"
                        ng-class="{'fa-stop': serie.color, 'fa-ellipsis-h': !serie.color}"></i>
                </button>
            </span>
        </div>
    </div>
    <div class="ml-m mt-xs">
        <ng-include src="'views/directives/dashboard/serie.filters.html'"></ng-include>
    </div>
</div>
<div ng-if="component.options.series && component.options.series.length > 1" class="mv-xs">
    <div class="checkbox">
        <label>
            <input type="checkbox" ng-model="component.options.stacked"> Stack the series by type
        </label>
    </div>
</div>

<div ng-if="component.options.series && component.options.series.length > 0" class="mv-xs">
    <a href ng-click="addSerie()">
        <i class="fa fa-plus"></i> Add a serie
    </a>
</div>

```

`frontend/app/views/directives/dashboard/multiline/basic.html`:

```html
<div class="form-group">
    <label>Title</label>
    <input type="text" class="form-control" placeholder="Ex: cases per TLP" ng-model="component.options.title">
</div>
<div class="row">    
    <div class="col-sm-4">
        <div class="form-group">
            <label>Interval</label>
            <select class="form-control" ng-model="component.options.interval"
                ng-options="item.code as item.label for item in timeIntervals"></select>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/multiline/edit.html`:

```html
<uib-tabset class="nav-tabs-custom" active="layout.activeTab">
    <uib-tab index="0">
        <uib-tab-heading>
            <i class="fa fa-bars"></i> Basic
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/multiline/basic.html'"></ng-include>
    </uib-tab>
    <uib-tab index="1">
        <uib-tab-heading>
            <i class="fa fa-sort"></i> Series
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/multiline/series.html'"></ng-include>
    </uib-tab>
</uib-tabset>

```

`frontend/app/views/directives/dashboard/multiline/serie.filters.html`:

```html
<div ng-if="serie.filters.length > 0">
    <strong>Serie's filter</strong>
</div>
<div class="row mb-xxxs" ng-repeat="filter in serie.filters track by $index">
    <div class="col-sm-4">
        <div class="input-group">
            <span class="input-group-btn">
                <button class="btn btn-default" type="button" ng-click="removeSerieFilter(serie, $index)">
                    <i class="fa fa-times text-danger"></i>
                </button>
            </span>
            <select class="form-control" ng-model="filter.field"
                ng-options="item for item in metadata[serie.entity].attributeKeys"
                ng-change="setFilterField(filter, serie.entity)"></select>
        </div>
    </div>
    <!-- <div class="col-sm-8" ng-include="'views/directives/dashboard/filter-editor.html'"></div> -->
    <div class="col-sm-8">
        <filter-editor metadata="metadata" filter="filter" entity="serie.entity"></filter-editor>
    </div>
</div>
<div class="mt-xxs">
    <a href ng-click="addSerieFilter(serie)">
        <i class="fa fa-plus"></i> Add a filter
    </a>
</div>

```

`frontend/app/views/directives/dashboard/multiline/series.html`:

```html
<div ng-if="!component.options.series || component.options.series.length === 0" class="empty-message">
    No series defined. <a href ng-click="addSerie()">Add a serie</a>
</div>
<div class="mb-xxxs dashboard-serie" ng-repeat="serie in component.options.series track by $index">
    <div class="form-inline mb-xxxs">
        <div class="input-group">
            <span class="input-group-btn">
                <button class="btn btn-default" type="button" ng-click="removeSerie($index)">
                    <i class="fa fa-times text-danger"></i>
                </button>
            </span>
            <div class="form-group">
                <select class="form-control" ng-model="serie.entity"
                    ng-options="item as metadata[item].label for item in metadata.entities"></select>
            </div>
        </div>
        <div class="form-group">
            <select class="form-control" ng-model="serie.dateField"
                ng-options="item.name as item.name for item in pickFields(metadata[serie.entity].attributes, ['date']) | orderBy:'name'"></select>
        </div>
    </div>
    <div class="form-inline">

        <div class="form-group">
            <select class="form-control" ng-model="serie.agg"
                ng-options="item.label as item.id for (key, item) in aggregations" ng-change="setSerieAgg(serie)">
                <option value="" disabled selected></option>
            </select>
        </div>
        <div class="form-group">
            <select class="form-control" ng-model="serie.field" ng-disabled="serie.agg === 'count'"
                ng-options="item.name as item.name for (key, item) in fieldsForAggregation(metadata[serie.entity].attributes, serie.agg)">
                <option value="" disabled selected>-- Select field --</option>
            </select>
        </div>
        <div class="form-group">
            <select class="form-control" ng-model="serie.type" ng-options="item for item in serieTypes"></select>
        </div>

        <div class="form-group">
            <input class="form-control" type="text" ng-model="serie.label" placeholder="Label">
        </div>
        <div class="input-group">
            <input type="text" class="form-control" ng-model="serie.color" placeholder="Color" size="8">
            <span class="input-group-btn">
                <button colorpicker colorpicker-close-on-select class="btn btn-default" ng-model="serie.color"
                    type="button">
                    <i class="fa fa-stop" style="color: {{serie.color}};"
                        ng-class="{'fa-stop': serie.color, 'fa-ellipsis-h': !serie.color}"></i>
                </button>
            </span>
        </div>
    </div>
    <div class="ml-m mt-xs">
        <ng-include src="'views/directives/dashboard/multiline/serie.filters.html'"></ng-include>
    </div>
</div>
<div ng-if="component.options.series && component.options.series.length > 1" class="mv-xs">
    <div class="checkbox">
        <label>
            <input type="checkbox" ng-model="component.options.stacked"> Stack the series by type
        </label>
    </div>
</div>

<div ng-if="component.options.series && component.options.series.length > 0" class="mv-xs">
    <a href ng-click="addSerie()">
        <i class="fa fa-plus"></i> Add a serie
    </a>
</div>

```

`frontend/app/views/directives/dashboard/serie.filters.html`:

```html
<div ng-if="serie.filters.length > 0">
    <strong>Serie's filter</strong>
</div>
<div class="row mb-xxxs" ng-repeat="filter in serie.filters track by $index">
    <div class="col-sm-4">
        <div class="input-group">
            <span class="input-group-btn">
                <button class="btn btn-default" type="button" ng-click="removeSerieFilter(serie, $index)">
                    <i class="fa fa-times text-danger"></i>
                </button>
            </span>
            <select class="form-control" ng-model="filter.field"
                ng-options="item for item in metadata[component.options.entity].attributeKeys"
                ng-change="setFilterField(filter, component.options.entity)"></select>
        </div>
    </div>
    <!-- <div class="col-sm-8" ng-include="'views/directives/dashboard/filter-editor.html'"></div> -->
    <div class="col-sm-8">
        <filter-editor metadata="metadata" filter="filter" entity="component.options.entity"></filter-editor>
    </div>
</div>
<div class="mt-xxs">
    <a href ng-click="addSerieFilter(serie)">
        <i class="fa fa-plus"></i> Add a filter
    </a>
</div>

```

`frontend/app/views/directives/dashboard/text/basic.html`:

```html
<div class="form-group">
    <label>Title</label>
    <input type="text" class="form-control" placeholder="Ex: Summary" ng-model="component.options.title">
</div>
<div class="row">
    <div class="col-sm-12">
        <div class="form-group">
            <label>Template</label>
            <textarea class="content-box" name="template"
              placeholder="Close summary" markdown-editor="{
                'fullscreen': {enable: false},
                'iconlibrary': 'fa',
                addExtraButtons: true,
                resize: 'vertical'}" rows="6" ng-model="component.options.template" required></textarea>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/dashboard/text/edit.html`:

```html
<uib-tabset class="nav-tabs-custom" active="layout.activeTab">
    <uib-tab index="0">
        <uib-tab-heading>
            <i class="fa fa-bars"></i> Basic
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/text/basic.html'"></ng-include>
    </uib-tab>
    <uib-tab index="1">
        <uib-tab-heading>
            <i class="fa fa-sort"></i> Series
        </uib-tab-heading>
        <ng-include src="'views/directives/dashboard/text/series.html'"></ng-include>
    </uib-tab>
</uib-tabset>

```

`frontend/app/views/directives/dashboard/text/serie.filters.html`:

```html
<div ng-if="serie.filters.length > 0">
    <strong>Serie's filter</strong>
</div>
<div class="row mb-xxxs" ng-repeat="filter in serie.filters track by $index">
    <div class="col-sm-4">
        <div class="input-group">
            <span class="input-group-btn">
                <button class="btn btn-default" type="button" ng-click="removeSerieFilter(serie, $index)">
                    <i class="fa fa-times text-danger"></i>
                </button>
            </span>
            <select class="form-control" ng-model="filter.field"
                ng-options="item for item in metadata[serie.entity].attributeKeys"
                ng-change="setFilterField(filter, serie.entity)"></select>
        </div>
    </div>
    <div class="col-sm-8">
        <filter-editor metadata="metadata" filter="filter" entity="serie.entity"></filter-editor>
    </div>
</div>
<div class="mt-xxs">
    <a href ng-click="addSerieFilter(serie)">
        <i class="fa fa-plus"></i> Add a filter
    </a>
</div>

```

`frontend/app/views/directives/dashboard/text/series.html`:

```html
<div ng-if="!component.options.series || component.options.series.length === 0" class="empty-message">
    No series defined. <a href ng-click="addSerie()">Add a serie</a>
</div>
<div class="mb-xxxs dashboard-serie" ng-repeat="serie in component.options.series track by $index">
    <div class="form-inline mb-xxxs">
        <div class="input-group">
            <span class="input-group-btn">
                <button class="btn btn-default" type="button" ng-click="removeSerie($index)">
                    <i class="fa fa-times text-danger"></i>
                </button>
            </span>
            <div class="form-group">
                <select class="form-control" ng-model="serie.entity"
                    ng-options="item as metadata[item].label for item in metadata.entities"></select>
            </div>
        </div>
        <div class="form-group">
            <select class="form-control" ng-model="serie.agg"
                ng-options="item.label as item.id for (key, item) in aggregations" ng-change="setSerieAgg(serie)">
                <option value="" disabled selected></option>
            </select>
        </div>
        <div class="form-group">
            <select class="form-control" ng-model="serie.field" ng-disabled="serie.agg === 'count'"
                ng-options="item.name as item.name for (key, item) in fieldsForAggregation(metadata[serie.entity].attributes, serie.agg)">
                <option value="" disabled selected>-- Select field --</option>
            </select>
        </div>
        <div class="form-group">
            <input class="form-control" type="text" ng-model="serie.name" placeholder="Variable name">
        </div>
    </div>
    <div class="ml-m mt-xs">
        <ng-include src="'views/directives/dashboard/text/serie.filters.html'"></ng-include>
    </div>
</div>
<div ng-if="component.options.series && component.options.series.length > 0" class="mv-xs">
    <a href ng-click="addSerie()">
        <i class="fa fa-plus"></i> Add a serie
    </a>
</div>

```

`frontend/app/views/directives/dashboard/text/view.html`:

```html
<div class="c3-container">
    <div class="c3-error" ng-if="error">
        <div class="text-center">
            <h4 class="text-danger">
                <div class="mb-xxs"><i class="fa fa-2x fa-exclamation-triangle"></i></div>
                <div>Failed to fetch data, please edit the widget definition</div>
            </h4>
        </div>
    </div>
    <div ng-if="!error" class="row">
        <div class="col-sm-12">
            <div class="clearfix" ng-show="content">
                <a class="pull-right ml-xxs" href ng-click="copyHTML()"><i class="fa fa-file-text-o mr-xxxs"></i>HTML</a>
                <strong class="text-primary pull-right">Copy</strong>
            </div>
            <div marked="content" class="markdown widget-content"></div>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/date-time-picker.html`:

```html
<div class="input-group">
	<input type="datetime" class="input-datetime form-control input-sm" ng-click="dateNow=false" ng-model="humanDate" />
	<span class="input-group-btn">
		<button type="button" class="btn btn-sm btn-primary" ng-model="dateNow" uib-btn-checkbox>now</button>
	</span>
</div>

```

`frontend/app/views/directives/dropzone.html`:

```html
<div>
	<span data-dz-name></span>
	<span data-dz-size></span>
	<button data-dz-remove class="btn btn-xs btn-danger delete">
		<i class="glyphicon glyphicon-remove-circle"></i>
		<span>Remove</span>
	</button>
</div>
<div ng-hide="filemodel != undefined" class="dz-clickable dz-message" style="border: 1px dashed red; height: 4em;">
	<span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">Drop file or click</span>
</div>

```

`frontend/app/views/directives/dt-picker.html`:

```html
<div class="input-group">
    <input class="input-datetime form-control" ng-model="dateValue" type="text" placeholder="{{placeholder}}" ng-required="required"/>
    <span class="input-group-btn">
        <button class="btn btn-default" type="button" ng-click="clear()"><i class="text-danger fa fa-times"></i></button>
    </span>
</div>

```

`frontend/app/views/directives/entity-link.html`:

```html
<!-- <span ng-if="value._type == 'alert'">
    <a class="text-muted wrap" href ng-click="onClickEvent({value: value})">
        <i class="glyphicon glyphicon-folder-open"></i>
        &nbsp;{{value.title}}&nbsp;
    </a>
</span> -->
<span ng-if="value._type == 'case'">
    <a class="text-muted wrap" href ng-click="openLink(entityUrl(value))">
        <i class="glyphicon glyphicon-folder-open"></i>
        &nbsp;#{{value.caseId || value.number}} - {{value.title}}&nbsp;
    </a>
</span>
<span ng-if="value._type == 'Case'">
    <a class="text-muted wrap" href ng-click="openLink(entityUrl(value))">
        <i class="glyphicon glyphicon-folder-open"></i>
        &nbsp;#{{value.caseId || value.number}} - {{value.title}}&nbsp;
    </a>
</span>
<span ng-if="value._type == 'case_task'">
    <entity-link value="value.case" target="target"></entity-link>
    <a class="text-muted wrap" href ng-click="openLink(entityUrl(value))">
        <i class=" glyphicon glyphicon-tasks"></i>
        &nbsp;{{value.title}}
    </a>
</span>
<span ng-if="value._type == 'Task'">
    <entity-link value="value.extraData.case" target="target"></entity-link>
    <a class="text-muted wrap" href ng-click="openLink(entityUrl(value))">
        <i class=" glyphicon glyphicon-tasks"></i>
        &nbsp;{{value.title}}
    </a>
</span>
<span ng-if="value._type == 'case_task_log'">
    <entity-link value="value.case_task" target="target"></entity-link>
    <i class="text-muted wrap" class="glyphicon glyphicon-comment"></i>
</span>
<span ng-if="value._type == 'case_artifact' && value.case">
    <!-- <entity-link ng-if="value.alert" value="value.alert" target="target"></entity-link> -->
    <!-- <entity-link ng-if="value.case" value="value.case" target="target"></entity-link> -->
    <entity-link value="value.case" target="target"></entity-link>
    <a class="text-muted wrap" href ng-click="openLink(entityUrl(value))">
        <i class="glyphicon glyphicon-pushpin"></i>
        &nbsp;{{value.data | ellipsis:100}}{{value.attachment.name}}
    </a>
</span>
<span ng-if="value._type == 'case_artifact_job'">
    <entity-link value="value.case_artifact" target="target"></entity-link>
</span>

<span ng-if="value._type == 'case_artifact_job_log'">
    <entity-link value="value.case_artifact_job" target="target"></entity-link>
    <i class="text-muted wrap" class=" glyphicon glyphicon-plus"></i>
</span>

<span ng-if="value._type == 'Procedure'">
    <entity-link value="value.case" target="target"></entity-link>
</span>

<span ng-if="value._type == 'analyzer'">
    <i class="text-muted wrap" class=" glyphicon glyphicon-cog"></i>
    ANALYZER / TODO
</span>

```

`frontend/app/views/directives/filter-box.html`:

```html
<div class="filter-box">
    <form ng-submit="filter()">
        <div class="input-group">
            <input type="text" class="form-control input-sm" ng-model="query" placeholder="Filter" size="50">
            <span class="input-group-btn">
                <button class="btn btn-default btn-sm" type="button" ng-click="clear()">
                    <i class="text-danger glyphicon glyphicon-remove"></i>
                </button>
                <button class="btn btn-default btn-sm" type="submit" ng-click="filter()">
                    <i class="text-default glyphicon glyphicon-search"></i>
                </button>
            </span>
        </div>
    </form>
</div>

```

`frontend/app/views/directives/flow/action.html`:

```html
<div class="flow-observable-job">
    <div class="flow-item-title wrap">
        <i class="glyphicon glyphicon-cog"></i>
        <span ng-if="base.operation === 'Creation'">
            Action: <em>{{base.details.responderName}}</em> started
        </span>
        <span ng-if="base.operation === 'Update'">
            Action <em>{{base.details.responderName}}</em> terminated
        </span>
    </div>
    <div class="flow-item-updates wrap">
        <span ng-repeat="(k, v) in base.details" ng-switch="k">
            <div ng-switch-when="startDate">
                {{k}}: <em>{{v | shortDate}}</em>
            </div>
            <div ng-switch-when="endDate">
                {{k}}: <em>{{v | shortDate}}</em>
            </div>
            <div ng-switch-default>
                {{k}}: <em>{{v | limitTo: 250}}</em>
            </div>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/flow/alert.html`:

```html
<div class="flow-alert">
    <div class="flow-item-title wrap">
        <i class="fa fa-download"></i>
        <span ng-show="bulk">Alert updates</span>
        <span ng-show="!bulk">[{{base.object.source}}] {{base.object.title}}</span>
    </div>

    <div class="flow-item-updates wrap" ng-show="bulk">
        <div class="flow-item-bulk" ng-show="summary.alert.Creation">
            <ng-pluralize count="summary.alert.Creation"
                when="{'one': '{} new alert has been added', 'other': '{} new alerts have been added'}"></ng-pluralize>
        </div>
        <div class="flow-item-bulk" ng-show="summary.alert.Update">
            <ng-pluralize count="summary.alert.Update"
                when="{'one': '{} existing alert has been updated', 'other': '{} existing alerts have been updated'}">
            </ng-pluralize>
        </div>
        <div class="flow-item-bulk" ng-show="summary.alert.Delete">
            <ng-pluralize count="summary.alert.Delete"
                when="{'one': '{} existing alert has been permanently deleted', 'other': '{} existing alerts have been permanently deleted'}">
            </ng-pluralize>
        </div>
        <div>
            <a class="small" href ng-click="openState('app.alert-list')">See all</a>
        </div>
    </div>

    <div class="flow-item-updates wrap" ng-hide="bulk">
        <span ng-repeat="(k,v) in base.details" ng-switch="k"
            ng-if="['caseTemplate', 'title', 'follow', 'lastSyncDate'].indexOf(k) === -1">
            <div ng-switch-when="artifacts">
                {{k}}:
                <em>{{v.length}}</em>
            </div>
            <div ng-switch-when="severity">
                {{k}}: <severity active="false" value="v"></severity>
            </div>
            <div ng-switch-when="status">
                {{k}}: <span class="clickable label label-default" ng-class="{
                  'label-danger': v === 'New',
                  'label-warning': v === 'Update'}">{{::v}}</span>
            </div>
            <div ng-switch-when="case">
                {{k}}: <a href ui-sref="app.case.details({caseId: v})">{{v}}</a>
            </div>
            <div ng-switch-when="description">
                description: <em>{{v | limitTo: 250}}</em>
            </div>
            <div ng-switch-when="tags">
                {{k}}:
                <span ng-repeat="tag in v">
                    <tag-item value="tag"></tag-item>
                </span>
                <span ng-if="v.length === 0">
                    <em>None</em>
                </span>
            </div>
            <div ng-switch-when="tlp">
                {{k}}: <tlp format="'static'" value="v"></tlp>
            </div>
            <div ng-switch-default>
                {{k}}:
                <em>{{v | limitTo: 250}}</em>
            </div>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/flow/case.html`:

```html
<div class="flow-case" ng-switch="base.operation">
    <div class="flow-item-title wrap">
        <i class="glyphicon glyphicon-folder-open"></i>{{base.object.title || base.details.title}}
        <div class="flow-item-bulk" ng-if="summary.case_task">
            <em ng-if="summary.case.Creation">This case contains <ng-pluralize count="summary.case_task.Creation"
             when="{'one': '1 task', 'other': '{} tasks'}"></ng-pluralize></em>

             <em ng-if="summary.case.Update"><ng-pluralize count="summary.case_task.Update"
              when="{'one': '1 task has', 'other': '{} tasks have'}"></ng-pluralize> been updated</em>

             <!-- <a class="small" ui-sref="app.case.tasks({caseId: base.object.id})">See all</a> -->
             <a class="small" href ng-click="openState('app.case.tasks', {caseId: base.object.id})">See all</a>
        </div>
        <div class="flow-item-bulk" ng-if="summary.case_artifact">
            <em ng-if="summary.case.Creation">This case contains <ng-pluralize count="summary.case_artifact.Creation"
             when="{'one': '1 observable', 'other': '{} observables'}"></ng-pluralize></em>
             <a class="small" href ng-click="openState('app.case.observables', {caseId: base.object.id})">See all</a>
        </div>
    </div>
    <div class="flow-item-updates wrap" ng-switch-when="Creation">
        <div>description: {{base.object.description | limitTo: 250}}</div>
    </div>
    <div class="flow-item-updates wrap" ng-switch-default>
        <span ng-repeat="(k, v) in base.details" ng-switch="k">
            <div ng-switch-when="severity">
                {{k}}: <severity active="false" value="v"></severity>
            </div>
            <div ng-switch-when="tags">
                {{k}}:
                <span ng-repeat="tag in v track by $index">
                    <tag-item value="tag"></tag-item>
                </span>
                <span ng-if="v.length === 0">
                    <em>None</em>
                </span>
            </div>
            <div ng-switch-when="startDate">
                {{k}}: <em>{{v | shortDate}}</em>
            </div>
            <div ng-switch-when="endDate">
                {{k}}: <em>{{v | shortDate}}</em>
            </div>
            <div ng-switch-when="tlp">
                {{k}}: <tlp format="'static'" value="v"></tlp>
            </div>
            <div ng-switch-when="pap">
                {{k}}: <tlp format="'static'" value="v" namespace="PAP"></tlp>
            </div>
            <div ng-switch-when="owner">
                {{k}}:
                <em><user-info value="v" field="name"></user-info></em>
            </div>
            <div ng-switch-default>
                {{k}}: <em>{{v | limitTo: 250}}</em>
            </div>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/flow/caseTemplate.html`:

```html
<div class="flow-organisation" ng-switch="base.operation">
    <div class="flow-item-title wrap">
        <i class="fa fa-file-text"></i>
        {{base.details.name}}
    </div>

    <div class="flow-item-updates wrap" ng-switch-when="Creation">
        Case template {{base.details.name}} added
    </div>

    <div class="flow-item-updates wrap" ng-switch-when="Delete">
        Case template {{base.details.name}} removed
    </div>

    <div class="flow-item-updates wrap" ng-switch-default>
        <span ng-repeat="(k, v) in base.details" ng-switch="k">
            <span ng-switch-default>
                {{k}}: <em>{{v}}</em>
            </span>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/flow/dashboard.html`:

```html
<div class="flow-dashboard" ng-switch="base.operation">
    <div class="flow-item-title wrap">
        <i class="fa fa-tachometer"></i>
        {{base.details.title}}
    </div>

    <div class="flow-item-updates wrap" ng-switch-when="Creation">
        Dashboard {{base.details.title}} added
    </div>

    <div class="flow-item-updates wrap" ng-switch-when="Delete">
        Dashboard {{base.details.title}} removed
    </div>
</div>

```

`frontend/app/views/directives/flow/flow-item.html`:

```html
<div class="flow-item-content">
    <div class="flow-item-summary" ng-include="operationUrl"></div>
    <div class="flow-item-details" ng-include="getContentUrl()"></div>
    <div class="flow-item-breadcrumbs">
        <entity-link class="small" target="target" value="data.base.object"></entity-link>
    </div>
    <!-- <pre ng-if="isBulkOperation()">{{data.summary | json}}</pre> -->
</div>

```

`frontend/app/views/directives/flow/flow.html`:

```html
<div class="flow">
  	<div class="flow-item" ng-repeat="value in $flow.values" ng-switch="value.base.objectType">
        <flow-item target="targetWindow" type="user" data="value" ng-switch-when="user"></flow-item>
        <flow-item target="targetWindow" type="case" data="value" ng-switch-when="case"></flow-item>
        <flow-item target="targetWindow" type="task" data="value" ng-switch-when="case_task"></flow-item>
        <flow-item target="targetWindow" type="task-log" data="value" ng-switch-when="case_task_log"></flow-item>
        <flow-item target="targetWindow" type="observable" data="value" ng-switch-when="case_artifact"></flow-item>
        <flow-item target="targetWindow" type="observable-job" data="value" ng-switch-when="case_artifact_job"></flow-item>
        <flow-item target="targetWindow" type="alert" data="value" ng-switch-when="alert"></flow-item>
        <flow-item target="targetWindow" type="action" data="value" ng-switch-when="action"></flow-item>
        <flow-item target="targetWindow" type="caseTemplate" data="value" ng-switch-when="casetemplate"></flow-item>
        <flow-item target="targetWindow" type="organisation" data="value" ng-switch-when="organisation"></flow-item>
        <flow-item target="targetWindow" type="dashboard" data="value" ng-switch-when="dashboard"></flow-item>
        <flow-item target="targetWindow" type="procedure" data="value" ng-switch-when="procedure"></flow-item>
	</div>
</div>

```

`frontend/app/views/directives/flow/observable-job.html`:

```html
<div class="flow-observable-job">
    <div class="flow-item-title wrap">
        <i class="glyphicon glyphicon-cog"></i>
        <span ng-if="base.operation === 'Creation'">
            Job: <em>{{base.object.analyzerName || base.object.analyzerId}}</em> started
        </span>
        <span ng-if="base.operation === 'Update'">
            Job <em>{{base.object.analyzerName || base.object.analyzerId}}</em> terminated
        </span>
    </div>
    <div class="flow-item-updates wrap">
        <span ng-repeat="(k, v) in base.details" ng-switch="k">
            <div ng-switch-when="startDate">
                {{k}}: <em>{{v | shortDate}}</em>
            </div>
            <div ng-switch-when="endDate">
                {{k}}: <em>{{v | shortDate}}</em>
            </div>
            <div ng-switch-default>
                {{k}}: <em>{{v | limitTo: 250}}</em>
            </div>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/flow/observable.html`:

```html
<div class="flow-observable" ng-switch="base.operation">
    <div class="flow-item-title wrap">
        <i class="glyphicon glyphicon-pushpin"></i>
        <span>{{base.object.dataType || base.details.dataType}}:
        </span>
        <span class="wrap" ng-bind="base.object.data | fang | ellipsis:100" ng-if="!base.object.attachment.name"></span>
        <span class="wrap" ng-bind="base.object.attachment.name" ng-if="base.object.attachment.name"></span>

        <span class="wrap" ng-bind="(base.details.data || base.details.attachment.name) | fang | ellipsis:100"
            ng-if="base.operation === 'Delete'"></span>

        <span ng-if="base.operation == 'Creation'">
            <tlp value="base.object.tlp"></tlp>
        </span>

        <div class="flow-item-bulk" ng-if="isBulkOperation()">
            <em>{{summary.case_artifact.Creation}} other observables have also been {{base.operation === 'Creation' ?
                'added' : 'updated'}}</em>
            <a class="small" href ng-click="openState('app.case.observables', {caseId: base.object.case.id})">See
                all</a>
        </div>
    </div>

    <div class="flow-item-updates wrap" ng-switch-when="Creation">
        <div ng-if="base.object.message">description: {{base.object.message| limitTo: 250}}</div>
        <div ng-if="base.object.tags.length > 0">
            Tags:
            <span ng-repeat="tag in base.object.tags">
                <tag-item value="tag"></tag-item>
            </span>
        </div>
    </div>

    <div class="flow-item-updates wrap" ng-switch-default>
        <span ng-repeat="(k,v) in base.details" ng-switch="k">
            <div ng-switch-when="tlp">
                {{k}}: <tlp format="'static'" value="v"></tlp>
            </div>
            <div ng-switch-when="tags">
                {{k}}:
                <span ng-repeat="tag in v">
                    <tag-item value="tag"></tag-item>
                </span>
                <span ng-if="v.length === 0">
                    <em>None</em>
                </span>
            </div>

            <div ng-switch-when="attachment">
                {{k}}: <em>{{v.name}}</em>
            </div>

            <div ng-switch-default>
                {{k}}:
                <em>{{v}}</em>
            </div>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/flow/operation.html`:

```html
<div class="flow-operation small">
    <span class="operation-type" ng-switch="base.operation">
        <span ng-switch-when="Delete"><i class="text-danger glyphicon glyphicon-remove"></i><span> Deleted by </span></span>
        <span ng-switch-when="Creation"><i class="text-info glyphicon glyphicon-plus"></i><span> Added by </span></span>
        <span ng-switch-when="Update">
            <span ng-switch="base.details.status">
                <span ng-switch-when="Cancel"><i class="text-danger glyphicon glyphicon-remove"></i><span> Deleted by </span></span>
                <span ng-switch-when="Completed"><i class="text-success glyphicon glyphicon-ok"></i><span> Completed by </span></span>
                <span ng-switch-when="Resolved"><i class="text-success glyphicon glyphicon-ok"></i><span> Closed by </span></span>
                <span ng-switch-default><i class="text-success glyphicon glyphicon-refresh"></i><span>Updated by </span></span>
            </span>
        </span>
    </span>
    <!-- <user user-id="base.createdBy" icon-only="false" icon-size="xs"></user>{{base | json}} -->
    <user-info class="operation-user" value="base.createdBy" field="name"></user-info>

    <span class="operation-timer pull-right">
        <i class="text-default glyphicon glyphicon-time"></i>
    	<timer interval="30000" start-time="gtime(base.startDate)">
            {{millis  | amDurationFormat : 'milliseconds'}}
    	</timer>
    </span>
</div>

```

`frontend/app/views/directives/flow/organisation.html`:

```html
<div class="flow-organisation" ng-switch="base.operation">
    <div class="flow-item-title wrap">
        <i class="fa fa-building-o"></i>
        {{base.details.name}}
    </div>

    <div class="flow-item-updates wrap" ng-switch-when="Creation">
        Organisation {{base.details.name}} added
    </div>

    <div class="flow-item-updates wrap" ng-switch-when="Delete">
        Organisation {{base.details.name}} removed
    </div>

    <div class="flow-item-updates wrap" ng-switch-default>
        <span ng-repeat="(k, v) in base.details" ng-switch="k">
            <span ng-switch-default>
                {{k}}: <em>{{v}}</em>
            </span>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/flow/procedure.html`:

```html
<div class="flow-task" ng-switch="base.operation">
    <div class="flow-item-title">
        <i class="glyphicon glyphicon-knight"></i>{{tactics[base.object.tactic].label}} - {{base.object.pattern.patternId}}: {{base.object.pattern.name}}
    </div>
    <div class="flow-item-updates" ng-switch-when="Creation">
        <div>
            occureDate: <span><em>{{base.details.occurDate | shortDate}}</em></span>
        </div>
        <div>
            description: <span><em>{{(base.details.procedure || '-')| limitTo: 250}}</em></span>
        </div>
    </div>
    <div class="flow-item-updates" ng-switch-default>
        <span ng-repeat="(k, v) in base.details" ng-switch="k">
            <div ng-switch-when="occurDate">
                {{k}}:
                <em>{{v | shortDate}}</em>
            </div>
            <div ng-switch-default>
                {{k}}:
                <em>{{v | limitTo: 250}}</em>
            </div>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/flow/task-log.html`:

```html
<div class="flow-task-log log-entry">
    <div class="flow-item-title wrap">
        <i class="glyphicon glyphicon-comment"></i>        
        <user-info value="base.createdBy" field="name"></user-info>
    </div>
    <div class="flow-item-updates wrap">
        <span ng-bind="base.details.message| limitTo: 250"></span>
        <span class="text-muted" ng-if="base.details.message.length > 250">...</span>
    </div>

    <div class="flow-item-updates vpad10 clearfix" ng-if="base.object.attachment.name" ng-init="hasImage = isImage(base.object.attachment.contentType)">
        <div class="file-box">
            <div class="file">
                <div class="image" ng-show="hasImage">
                    <img class="btn img-responsive img-thumbnail" ng-src="./api/datastore/{{base.object.attachment.id}}"
                        alt="{{base.object.attachment.name}}"
                        ng-click="showImage(base.object.attachment.id, base.object.attachment.name)"></img>
                </div>

                <a href="./api/datastore/{{base.object.attachment.id}}?name={{base.object.attachment.name | escape}}" target="_blank">
                    <div class="icon" ng-hide="isImage(base.object.attachment.contentType)">
                        <i class="glyphicon glyphicon-file"></i>
                    </div>
                    <div class="file-name">
                        {{base.object.attachment.name}}
                    </div>
                </a>
            </div>
        </div>
    </div>

</div>

```

`frontend/app/views/directives/flow/task.html`:

```html
<div class="flow-task" ng-switch="base.operation">
    <div class="flow-item-title">
        <i class="glyphicon glyphicon-tasks"></i>{{base.object.title}}
        <span ng-if="base.operation === 'Update' && base.details.flag !== undefined">
            <i class="glyphicon glyphicon-flag" ng-class="{'text-yellow': base.details.flag, 'text-muted': !base.details.flag}"></i>
        </span>
    </div>
    <div class="flow-item-updates" ng-switch-when="Creation">
        <span ng-bind="base.object.description| limitTo: 250"></span>
    </div>
    <div class="flow-item-updates" ng-switch-default>
        <span ng-repeat="(k, v) in base.details" ng-switch="k">
            <div ng-switch-when="owner">
                {{k}}:
                <em><user-info value="v" field="name"></user-info></em>
            </div>
            <div ng-switch-when="startDate">
                {{k}}:
                <em>{{v | shortDate}}</em>
            </div>
            <div ng-switch-when="endDate">
                {{k}}:
                <em>{{v | shortDate}}</em>
            </div>
            <div ng-switch-default>
                {{k}}:
                <em>{{v | limitTo: 250}}</em>
            </div>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/flow/user.html`:

```html
<div class="flow-user" ng-switch="base.operation">
    <div class="flow-item-title wrap">
        <i class="glyphicon glyphicon-user"></i>
        {{base.object.name}}
    </div>

    <div class="flow-item-updates wrap" ng-switch-when="Creation">
        User {{base.object.name}} added
    </div>

    <div class="flow-item-updates wrap" ng-switch-when="Delete">
        User {{base.object.name}} removed
    </div>

    <div class="flow-item-updates wrap" ng-switch-default>
        <span ng-repeat="(k, v) in base.details" ng-switch="k">
            <span ng-switch-when="password">
                password changed
            </span>
            <span ng-switch-default>
                {{k}}: <em>{{v}}</em>
            </span>
        </span>
    </div>
</div>

```

`frontend/app/views/directives/log-entry-delete.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">Delete log</h3>
</div>
<div class="modal-body">
    <p>
        You are about to delete a task log. If you do so, its contents will be permanently lost.
    </p>
    <p>
        Do you want to proceed?
    </p>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="cancelDropLog()" type="button">Cancel</button>
    <button class="btn btn-danger pull-right" ng-click="confirmDropLog()">Confirm</button>
</div>

```

`frontend/app/views/directives/log-entry.html`:

```html
<hr/>

<div class="log-entry">
    <div class="row mb-xxs">
        <div class="col-md-6">
            <user user-id="log.owner" icon-size="xs"></user>
        </div>
        <div class="col-md-6">
            <span class="pull-right ml-xs" ng-if="appConfig.connectors.cortex.enabled" if-permission="manageAction" allowed="{{permissions}}">
                <a href class="text-primary noline nowrap" ng-click="getLogResponders(log, true)">
                    <i class="fa fa-cog"></i>
                    Responders
                </a>
                <!-- <ul class="dropdown-menu align-right" uib-dropdown-menu>
                  <li ng-if="logResponders && logResponders.length === 0">
                    <a href ng-click="getLogResponders(task.id, true)">
                      <strong><i class="fa fa-refresh mr-xxs"></i> No responders available</strong>
                    </a>
                  </li>
                  <li ng-repeat="responder in logResponders">
                    <a href ng-click="runResponder(responder.id, responder.name, log)">
                      <strong>{{responder.name}}</strong>
                      <br>
                      <small>{{responder.description}}</small></a>
                  </li>
                </ul> -->
            </span>
            <span class="pull-right" if-permission="manageTask" allowed="{{permissions}}">
                <a href ng-click="dropLog()" uib-tooltip="Delete log" class="text-danger">
                    <i class="fa fa-trash"></i> Delete
                </a>
            </span>
            <span class="text-muted mr-xs pull-right">
                <i class="fa fa-calendar"></i>
                {{log.date | shortDate}}
            </span>
        </div>
    </div>

    <div class="row">
        <div class="col-md-12">
            <div class="description-pane" if-permission="manageTask" allowed="{{permissions}}">
                <updatable-text on-update="updateLog()" value="log.message"></updatable-text>
            </div>
            <div class="description-pane" if-not-permission="manageTask" allowed="{{permissions}}">
                <div marked="log.message" class="markdown"></div>
            </div>
        </div>
        <div class="col-md-12" ng-show="log.attachment != undefined">
            <div class="clearfix mt-xxs">
                <div class="file-box">
                    <div class="file">
                        <div class="image" ng-show="isImage(log.attachment.contentType)">
                            <img class="btn img-responsive" ng-src="./api/datastore/{{log.attachment.id}}" alt="{{log.attachment.name}}" class="img-thumbnail" width="200px" ng-click="showImage()"></img>
                        </div>

                        <a href="./api/datastore/{{log.attachment.id}}?name={{log.attachment.name | escape}}" target="_blank">
                            <div class="icon" ng-hide="isImage(log.attachment.contentType)">
                                <i class="glyphicon glyphicon-file"></i>
                            </div>
                            <div class="file-name">
                                {{log.attachment.name}}
                            </div>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row" ng-if="log.extraData.actionCount > 0">
        <div class="col-md-12">
           <a href ng-show="showActions" ng-click="showActions=false">Hide Responder Jobs ({{log.extraData.actionCount}})</a>
           <a href ng-show="!showActions" ng-click="showActions=true; getActions(log._id)">Show Responder Jobs ({{log.extraData.actionCount}})</a>
        </div>
        <div class="col-md-12" ng-show="showActions && actions">
          <responder-actions header="" actions="actions"></responder-actions>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/mini-report-list.html`:

```html
<div class="tags-list flexwrap mt-xxs" ng-if="taxonomies.length > 0">
    <span class="mr-xxxs text-muted"><i class="fa fa-cog"></i></span>
    <span class="label mb-xxxs mr-xxxs clickable label-default"
        ng-repeat="taxonomy in taxonomies"
        ng-class="{'info': 'label-info',
            'safe': 'label-success',
            'suspicious': 'label-warning',
            'malicious': 'label-danger'
        }[taxonomy.level]"
        ng-click="onItemClicked({observable: observable, analyzerId: taxonomy.id})">
        {{taxonomy.namespace}}:{{taxonomy.predicate}}{{(taxonomy.value != undefined && taxonomy.value!= null) ? '="'+taxonomy.value+'"': ''}}
    </span>
</div>

<div ng-if="taxonomies.length === 0">
    <span class="mr-xxxs text-muted"><i class="fa fa-cog"></i></span>
    <em class="text-muted mr-xxxs">No reports available</em>
</div>

```

`frontend/app/views/directives/page-sizer.html`:

```html
<div class="page-sizer">
    <select class="form-control input-sm" ng-class="cls"
        ng-model="collection.pageSize"
        ng-change="collection.update()"
        ng-options="v for v in sizes"></select>
    <span class="page-sizer-label nowrap ml-xxs">per page</span>
</div>

```

`frontend/app/views/directives/permission-list.html`:

```html
<div class="wrap">
    <em ng-if="permissions.length === 0" class="text-muted">No Permissions</em>
    <strong ng-if="showLabel && permissions.length > 0">{{label || 'Permissions'}}: </strong>
    <span class="label label-default mr-xxs" ng-repeat="permission in permissions">{{permission}}</span>
</div>

```

`frontend/app/views/directives/psearch.html`:

```html
<div class="text-center list-pagination">
    <div class="text-center" ng-if="control.total > 0 && control.total > control.pageSize">
        <ul uib-pagination total-items="control.total" ng-change="control.changePage()" ng-model="control.currentPage"
            class="pagination-sm" boundary-links="true" items-per-page="control.pageSize" max-size="5" rotate="false">
        </ul>
    </div>

    <div class="text-center" ng-if="control.total < 0 && (-1*control.total) > control.pageSize">
        <ul uib-pagination total-items="-1*control.total" ng-change="control.changePage()"
            ng-model="control.currentPage" class="pagination-sm" boundary-links="true" items-per-page="control.pageSize"
            max-size="5" rotate="false"></ul>
    </div>
</div>

```

`frontend/app/views/directives/report-observables.html`:

```html
<div class="">
    <div class="empty-message" ng-if="observables.length === 0">
        No observables found
    </div>
    <div ng-if="observables.length > 0">
        <div class="mb-xs" ng-if="groups">
            <span class="label label-lg label-default mr-xxs clickable"
                ng-click="filterArtifacts('');"
                ng-class="{'label-primary': pagination.filter===''}">All ({{observables.length || 0}})</span>

            <span class="label label-lg label-default mr-xxs clickable"
                ng-repeat="(type, list) in groups"
                ng-click="filterArtifacts(type)"
                ng-class="{'label-primary': pagination.filter===type}">{{type}} ({{list.length}})</span>
        </div>
        <div class="mv-xxs" if-permission="manageObservable" allowed="{{permissions}}">
            <strong class="text-muted">{{selected}} items selected</strong>
            <a class="ml-xs" href ng-click="selectAll()"><i class="fa fa-check"></i> Select all</a>
            <span ng-if="selected > 0">
                <a class="ml-xs" href ng-click="clearSelection()"><i class="fa fa-times"></i> Clear Selection</a>
                <span class="ml-xs">|</span>
                <a class="ml-xs" href ng-click="import()"><i class="fa fa-plus"></i> Import Selection</a>
            </span>
        </div>

        <table class="table table-striped">
            <thead>
                <tr>
                    <th style="width:10px;"></th>
                    <th style="width:80px;">Flags</th>
                    <th style="width:80px;">Imported</th>
                    <th style="width:150px;">Type</th>
                    <th>Data</th>
                    <th style="width:80px;"></th>
                </tr>
            </thead>
            <tbody>
                <tr ng-repeat="observable in pagination.data | orderBy:'id':true |
                        offset: (pagination.currentPage-1)*pagination.pageSize |
                        limitTo: pagination.pageSize ">
                    <td>
                        <input type="checkbox" ng-model="observable.selected" ng-change="selectObservable(observable)" ng-disabled="!!observable.imported">
                    </td>
                    <td>
                        <observable-flags observable="observable" inline="true" hide-seen="true" hide-similarity="true"></observable-flags>
                    </td>
                    <td align="center">
                        <span uib-tooltip="Observable already imported" tooltip-popup-delay="500" tooltip-placement="right" ng-if="!!observable.imported" class="fa fa-check"></span>
                    </td>
                    <td>{{observable.dataType}}</td>
                    <td class="wrap">
                        <div ng-switch="observable.dataType" uib-tooltip="{{observable.message}}" tooltip-placement="top-left">
                            <span ng-switch-when="file">{{observable.attachment.name | fang}}</span>
                            <span ng-switch-default>{{observable.data | fang | ellipsis:250}}</span>
                        </div>
                        <div class="case-tags flexwrap mt-xxs">
                            <span class="mr-xxxs text-muted"><i class="fa fa-tags"></i></span>
                            <strong class="text-muted mr-xxxs" ng-if="!observable.tags || observable.tags.length === 0">None</strong>
                            <tag-item class="pointer" ng-repeat="tag in observable.tags track by $index" value="tag"></tag-item>
                        </div>
                    </td>
                    <td class="wrap">
                        <a ng-if="!!observable.stats.observableId" href ui-sref="app.case.observables-item({caseId: caseId, itemId: observable.stats.observableId})"><i class="fa fa-search"></i> View</a>
                    </td>
                </tr>
            </tbody>
        </table>

        <div class="text-center" ng-show="pagination.data.length > pagination.pageSize">
            <ul uib-pagination class="pagination-sm" boundary-links="true"  max-size="5" rotate="false"
                total-items="pagination.data.length"
                items-per-page="pagination.pageSize"
                ng-change="loadPage()"
                ng-model="pagination.currentPage"></ul>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/responder-actions.html`:

```html
<div class="responder-actions">
    <h4 class="text-primary">{{header}}</h4>
    <table class="table table-striped">
        <thead>
            <tr>
                <th width="80" class="text-center">Status</th>
                <th>Name</th>
                <th width="200">Cortex Server</th>
                <th width="120">Date</th>
                <th width="40" class="text-center">Actions</th>
            </tr>
        </thead>
        <tbody>
            <tr ng-repeat="action in actions.values">
                <td class="text-center">
                    <span class="label label-default" ng-class="{
                    'Success': 'label-success',
                    'InProgress': 'label-warning',
                    'Failure': 'label-danger'}[action.status]">{{action.status}}</span>
                </td>
                <td>
                    <div>{{action.responderName}}</div>
                    <div ng-if="action.status === 'Failure'" class="text-danger wrap mt-xxs">
                        <a class="text-danger" href ng-click="action.showError = !!!action.showError">{{action.showError ? 'Hide' : 'Show'}} error</a>
                        <pre ng-show="action.showError" class="error-trace">{{action.errorMessage}}</pre>
                    </div>
                </td>
                <td>{{action.cortexId}}</td>
                <td>{{action.startDate | shortDate}}</td>
                <td class="text-center">                    
                    <a href class="noline" ng-click="showResponderJob(action)" ng-if="action.status !== 'Failure'" uib-tooltip="Show action report" tooltip-placement="left-middle"><i class="fa fa-search"></i></a>
                </td>
            </tr>
        </tbody>
    </table>
</div>

```

`frontend/app/views/directives/search/alert.html`:

```html
<div class="search-item-title">
    <!-- <a href ui-sref="app.case.details({caseId: value.id})">
        {{value.title}}
    </a> -->
    <span ng-if="!value.case" ng-click="onTitleClicked({value: value})">
      <a href>{{value.title}}</a>
    </span>
    <span ng-if="value.case" ui-sref="app.case.details({caseId: value.case})">
        <a href>{{::value.title}}</a>
    </span>
</div>
<div>
    <span>
        <i class="fa fa-calendar"></i> Date:
        <strong class="text-muted">{{value.date | shortDate}}</strong>
    </span>
    <span class="ml-xxs">
        <i class="fa fa-certificate"></i> Type:
        <strong class="text-muted">{{value.type}}</strong>
    </span>
    <span class="ml-xxs">
        <i class="fa fa-barcode"></i> Reference:
        <strong class="text-muted">{{value.sourceRef}}</strong>
    </span>
    <span class="ml-xxs">
        <i class="fa fa-bullseye"></i> Source:
        <strong class="text-muted">{{value.source}}</strong>
    </span>
    <span class="ml-xxs">
        <i class="glyphicon glyphicon-pushpin"></i> Attributes:
        <strong class="text-muted">{{value.artifacts.length}}</strong>
    </span>
</div>
<div class="mt-xs wrap" ng-if="value.tags.length>0">
    <strong>Tags:</strong><tag-list data="value.tags"></tag-list>
</div>
<div class="mt-xs wrap">
    <strong>Status:</strong>
    <div>
      <span class="label label-default" ng-class="{'label-danger': value.status==='New', 'label-warning': value.status === 'Updated'}">{{value.status}}</span>
    </div>
</div>
<div class="mt-xs wrap">
    <strong>Description:</strong>
    <div>
        <span ng-bind="value.description| limitTo: 250"></span>
    </div>
</div>

```

`frontend/app/views/directives/search/audit.html`:

```html
<div class="mb-xs">
    <i class="glyphicon glyphicon-user"></i>
    by <user-info value="value.createdBy" field="name"></user-info>

    <i class="glyphicon glyphicon-calendar ml-xxs"></i>
    Occurred on <span ng-bind="value.startDate | shortDate"> </span>
</div>

<div ng-switch="value.objectType">
    <div ng-switch-when="user">
        <div class="search-item-title">
            <a href>
            {{value.operation}} of {{value.objectType}} <br>
            <em class="text-muted"><span>{{value.stats.name}}</span></em>
            </a>
        </div>
    </div>
    <div ng-switch-when="case" ui-sref="app.case.details({caseId: value.objectId})">
        <div class="search-item-title">
            <a href>
            {{value.operation}} of {{value.objectType}} <br>
            <em class="text-muted"><span>{{value.stats.title || value.details.title}}</span></em>
            </a>
        </div>
        <div>
            <i class="glyphicon glyphicon-user"></i>
            <user-info value="value.stats.owner" field="name"></user-info>

            <i class="glyphicon glyphicon-calendar ml-xxs"></i>
            <span ng-bind="value.stats.startDate | shortDate"></span>

            <span ng-if="value.stats.endDate" class="text-success">
                (
                <strong>Closed</strong>
                on
                {{value.stats.endDate | shortDate}}
                as
                <strong>{{value.stats.resolutionStatus}}</strong>)
            </span>
        </div>
    </div>
    <div ng-switch-when="case_task">
        <div class="search-item-title">
            <a href>
            {{value.operation}} of task <br>
            <em class="text-muted"><span>{{value.stats.title || value.details.title}}</span></em>
            </a>
        </div>
    </div>
    <div ng-switch-when="case_task_log">
        <div class="search-item-title">
            <a href>
            {{value.operation}} of task log
            </a>
        </div>
    </div>
    <div ng-switch-when="case_artifact" ui-sref="app.case.observables-item({caseId: value.stats.case.id, itemId: value.stats.id})">
        <div class="search-item-title">
            <a href>
            {{value.operation}} of observable <br>
            <em class="text-muted"><span>{{value.stats.data}}</span></em>
            </a>
        </div>
    </div>
    <div ng-switch-when="case_artifact_job">
        <div class="search-item-title">
            <a href>
            {{value.operation}} of observable job <br>
            <em class="text-muted"><span>{{value.stats.analyzerName}}</span></em>
            </a>
        </div>
    </div>
    <div ng-switch-when="alert">
        <div class="search-item-title">
            <a href>
            {{value.operation}} of alert<br>
            <em class="text-muted"><span>{{value.stats.title}}</span></em>
            </a>
        </div>
        <div>
            <span>
                <i class="fa fa-calendar"></i> Date:
                <strong class="text-muted">{{value.stats.date | shortDate}}</strong>
            </span>
            <span class="ml-xxs">
                <i class="fa fa-certificate"></i> Type:
                <strong class="text-muted">{{value.stats.type}}</strong>
            </span>
            <span class="ml-xxs">
                <i class="fa fa-barcode"></i> Reference:
                <strong class="text-muted">{{value.stats.sourceRef}}</strong>
            </span>
            <span class="ml-xxs">
                <i class="fa fa-bullseye"></i> Source:
                <strong class="text-muted">{{value.stats.source}}</strong>
            </span>
        </div>
    </div>
</div>
<div class="mt-xs wrap">
    <strong>Details (<a href ng-show="!value.show" ng-click="value.show = true">Expand</a><a href ng-show="value.show" ng-click="value.show = false">Collapse</a>)</strong>
    <pre ng-show="value.show">{{value.details | flattern | json}}</pre>
</div>

```

`frontend/app/views/directives/search/case.html`:

```html
<div class="search-item-title">
    <a href ui-sref="app.case.details({caseId: value.id})">
        {{value.title}}
    </a>
</div>
<div>
    <i class="glyphicon glyphicon-user"></i>
    <user-info value="value.owner" field="name"></user-info>

    <i class="glyphicon glyphicon-calendar ml-xxs"></i>
    <span ng-bind="value.startDate | shortDate"></span>

    <span ng-if="value.endDate" class="text-success">
        (
        <strong>Closed</strong>
        on
        {{value.endDate | shortDate}}
        as
        <strong>{{value.resolutionStatus}}</strong>)
    </span>
</div>
<div class="mt-xs wrap" ng-if="value.tags.length>0">
    <strong>Tags:</strong><tag-list data="value.tags"></tag-list>
</div>
<div class="mt-xs wrap">
    <strong>Status:</strong>
    <div>
      <span class="label label-default" ng-class="{'label-success': value.status === 'Resolved'}">{{value.status}}</span>
    </div>
</div>
<div class="mt-xs wrap">
    <span ng-bind="value.description| limitTo: 250"></span>
</div>

```

`frontend/app/views/directives/search/observable-job.html`:

```html
<div class="search-item-title">
    <a href ui-sref="app.case.observables-item({caseId: value.case_artifact.case.id, itemId: value.case_artifact.id})">
        Job <em><span ng-bind="value.analyzerName"></span></em>
    </a>
</div>
<div>
    <i class="glyphicon glyphicon-user"></i>
    <user-info value="base.createdBy" field="name"></user-info>

    <i class="glyphicon glyphicon-calendar ml-xxs"></i>
    Started on <span ng-bind="value.startDate | shortDate"> </span>

    <span ng-if="value.endDate" class="text-success">
        (
        <strong>Finished</strong>
        on
        {{value.endDate | shortDate}}
        as
        <strong>{{value.status}}</strong>)
    </span>
</div>
<div class="mt-xs wrap">
    <strong ng-bind="value.case_artifact.dataType"></strong>:
    <em>
        <span ng-if="!value.case_artifact.attachment.name" ng-bind="value.case_artifact.data | fang"></span>
        <span ng-if="value.case_artifact.attachment.name" ng-bind="value.case_artifact.attachment.name"></span>
    </em>
</div>

```

`frontend/app/views/directives/search/observable.html`:

```html
<div ng-if="value.case" class="search-item-title">
    <a href ui-sref="app.case.observables-item({caseId: value.case.id, itemId: value.id})">
        [<span ng-bind="value.dataType"></span>]:
        <em>
            <span ng-if="!value.attachment.name" ng-bind="value.data"></span>
            <span ng-if="value.attachment.name" ng-bind="value.attachment.name"></span>
        </em>
    </a>
</div>
<div ng-if="value.alert" class="search-item-title">
    <span ng-if="value.alert" ng-click="onTitleClicked({value: value.alert})">
        <a href>
            [<span ng-bind="value.dataType"></span>]:
            <em>
                <span ng-if="!value.attachment.name" ng-bind="value.data"></span>
                <span ng-if="value.attachment.name" ng-bind="value.attachment.name"></span>
            </em>
        </a>
    </span>
</div>
<div>
    <i class="glyphicon glyphicon-user"></i>
    <user-info value="value.createdBy" field="name"></user-info>

    <i class="glyphicon glyphicon-calendar ml-xxs"></i>
    <span ng-bind="value.startDate | shortDate"></span>

    <span ng-if="value.alert">
        <i class="fa fa-certificate ml-xxs"></i> Type:
        <span>{{value.alert.type}}</span>

        <i class="fa fa-barcode ml-xxs"></i> Reference:
        <span>{{value.alert.sourceRef}}</span>

        <i class="fa fa-bullseye ml-xxs"></i> Source:
        <span>{{value.alert.source}}</span>
    </span>
</div>

<div class="mt-xs wrap" ng-if="value.alert">
    <strong>Alert:</strong><br>
    <span>{{value.alert.title}}</span>
</div>

<div class="mt-xs wrap" ng-if="value.tags.length>0">
    <strong>Tags:</strong>
    <tag-list data="value.tags"></tag-list>
</div>
<div class="mt-xs wrap">
    <span ng-bind="(value.message || 'No Description') | limitTo: 250"></span>
</div>

```

`frontend/app/views/directives/search/search-item.html`:

```html
<div>    
    <div class="search-item-content">
        <div class="search-item-icon"><i class="{{icon}} text-muted"></i></div>
        <div class="search-item-details mv-xxs">
            <div class="search-item-data" ng-include="getContentUrl()"></div>
            <div class="search-item-breadcrumbs mt-xxs">
                <entity-link class=" small" target="targetWindow" value="value"></entity-link>
            </div>
        </div>
    </div>
    <div class="hr-line-dashed"></div>
</div>

```

`frontend/app/views/directives/search/task-log.html`:

```html
<div class="search-item-title">
    <a href ui-sref="app.case.tasks-item({caseId: value.case_task.case.id, itemId: value.case_task.id})">
        Message by {{value.owner}}
    </a>
</div>
<div>
    <i class="glyphicon glyphicon-calendar"></i>
    <span ng-bind="value.startDate | shortDate"></span>

    <i class="glyphicon glyphicon-pushpin ml-xxs"></i>
    <span class="wrap" ng-bind="value.case_task.title"></span>
</div>
<div class="mt-xs wrap" ng-if="!value.attachment.name">
    <span ng-bind="value.message | limitTo: 250"></span>
</div>

<div class="mt-xs wrap" ng-if="value.attachment.name">
    <div>
        <span ng-bind="value.message | limitTo: 250"></span>
    </div>
    <div class="mt-xs attachment">
        <div class="file-box">
            <div class="file">
                <a href="./api/datastore/{{value.attachment.id}}?name={{value.attachment.name | escape}}" target="_blank">
                    <div class="image" ng-show="isImage(value.attachment.contentType)">
                        <img class="btn img-responsive img-thumbnail" src="./api/datastore/{{value.attachment.id}}" alt="{{value.attachment.name}}"></img>
                    </div>

                    <div class="icon" ng-hide="isImage(value.attachment.contentType)">
                        <i class="glyphicon glyphicon-file"></i>
                    </div>
                    <div class="file-name">
                        {{value.attachment.name}}
                    </div>
                </a>

            </div>
        </div>

        <div class="clearfix"></div>
    </div>
</div>

```

`frontend/app/views/directives/search/task.html`:

```html
<div class="search-item-title">
    <a href ui-sref="app.case.tasks-item({caseId: value.case.id, itemId: value.id})">
        {{value.title}}
    </a>
</div>
<div>
    <i class="glyphicon glyphicon-user"></i>
    <user-info value="value.owner" field="name"></user-info>

    <i class="glyphicon glyphicon-calendar ml-xxs" ng-if="value.startDate"></i>
    <span ng-bind="value.startDate | shortDate"></span>
</div>
<div class="mt-xs wrap">
    <span ng-bind="(value.description || 'No Description') | limitTo: 250"></span>
</div>
<div class="mt-xs wrap">
    <strong>Status:</strong>
    <div>
      <span class="label label-default" ng-class="{
        'label-danger': value.status === 'Waiting',
        'label-warning': value.status === 'InProgress',
        'label-success': value.status === 'Completed'
      }">{{value.status}}</span>
    </div>
</div>

```

`frontend/app/views/directives/severity.html`:

```html
<div ng-if="active == true">
	<span class="clickable label" ng-class="{ true:'label-info', false:'label-default' }[value == 1]" ng-click="update(1)">L</span>
	<span class="clickable label" ng-class="{ true:'label-warning', false:'label-default' }[value == 2 || !value]" ng-click="update(2)">M</span>
	<span class="clickable label" ng-class="{ true:'label-danger', false:'label-default' }[value == 3]" ng-click="update(3)">H</span>
	<span class="clickable label" ng-class="{ true:'label-critical', false:'label-default' }[value == 4]" ng-click="update(4)">C</span>
</div>
<span ng-if="active != true" ng-switch="value">
	<span ng-switch-when="1" class="label label-info">L</span>
	<span ng-switch-when="2" class="label label-warning">M</span>
	<span ng-switch-when="3" class="label label-danger">H</span>
	<span ng-switch-when="4" class="label label-critical">C</span>
	<span ng-switch-default class="label label-primary">?</span>
</span>

```

`frontend/app/views/directives/tag-input-item.html`:

```html
<span class="tag-item-border" tag-colour tag="$getDisplayText()">&nbsp;</span>
<span ng-bind="$getDisplayText()"></span>
<a class="remove-button" ng-click="$removeTag()" ng-bind="::$$removeTagSymbol"></a>

```

`frontend/app/views/directives/tag-item.html`:

```html
<span class="label label-default label-tag mb-xxxs mr-xxxs"
    style="border-left-color:{{bgColor}};">{{tag}}
</span>

```

`frontend/app/views/directives/tag-list.html`:

```html
<div class="tags-list flexwrap">
    <tag-item ng-repeat="tag in data track by $index" value="tag"></tag-item>
</div>

```

`frontend/app/views/directives/task-progress.html`:

```html
<div class="progress task-progress progress-bar-sm mv-0">
    <div class="progress-bar progress-bar-danger" style="{{waiting}}" uib-tooltip="{{tasks.Waiting}} Waiting"></div>
    <div class="progress-bar progress-bar-success" style="{{completed}}" uib-tooltip="{{tasks.Completed}} Completed"></div>
    <div class="progress-bar progress-bar-warning" style="{{progress}}" uib-tooltip="{{tasks.InProgress}} In Progress"></div>
    <div class="progress-bar progress-bar-default" style="{{cancel}}" uib-tooltip="{{tasks.Cancel}} Canceled"></div>
</div>

```

`frontend/app/views/directives/tlp.html`:

```html
<div ng-if="format === 'active'">
	<span class="label" ng-class="{ true:'label-info', false:'label-default' }[value == 0]" ng-click="update(0)">WHITE</span>
	<span class="label" ng-class="{ true:'label-success', false:'label-default' }[value == 1]" ng-click="update(1)">GREEN</span>
	<span class="label" ng-class="{ true:'label-warning', false:'label-default' }[value == 2]" ng-click="update(2)">AMBER</span>
	<span class="label" ng-class="{ true:'label-danger', false:'label-default' }[value == 3]" ng-click="update(3)">RED</span>
</div>
<span ng-if="format === 'static'" ng-switch="value">
	<span ng-switch-when="0" class="label label-info">{{namespace || 'TLP'}}:WHITE</span>
	<span ng-switch-when="1" class="label label-success">{{namespace || 'TLP'}}:GREEN</span>
	<span ng-switch-when="2" class="label label-warning">{{namespace || 'TLP'}}:AMBER</span>
	<span ng-switch-when="3" class="label label-danger">{{namespace || 'TLP'}}:RED</span>
</span>
<span ng-if="format !== 'active' && format !== 'static'">
	<span ng-switch-when="0" class="text-tlp-default fa fa-circle-o hpad10" uib-tooltip="{{namespace || 'TLP'}}:WHITE"></span>
	<span ng-switch-when="1" class="text-tlp-green fa fa-circle hpad10" uib-tooltip="{{namespace || 'TLP'}}:GREEN"></span>
	<span ng-switch-when="2" class="text-tlp-amber fa fa-circle hpad10" uib-tooltip="{{namespace || 'TLP'}}:AMBER"></span>
	<span ng-switch-when="3"  class="text-tlp-red fa fa-circle hpad10" uib-tooltip="{{namespace || 'TLP'}}:RED"></span>
</span>

```

`frontend/app/views/directives/updatable-boolean.html`:

```html
<div class="updatable-input updatable-input-boolean">
	<span class="updatable-input-value-wrapper" ng-hide="updatable.updating" ng-click="edit()">
		<span ng-if="value!==null && value !==''" class="updatable-value">{{value ? trueText || 'True' : falseText || 'False'}}</span>
		<span ng-if="value === null || value === undefined" class="updatable-value text-warning"><em>Not Specified</em></span>

		<small class="updatable-input-icon">
			<i class="glyphicon glyphicon-pencil"></i>
		</small>
	</span>

	<form ng-submit="update()" ng-show="updatable.updating">
		<div class="input-group input-group-sm">
			<select class="form-control input-sm" ng-model="value" ng-options="v for v in [true, false]" ng-change="update()"></select>
			<span class="input-group-btn">
				<button class="btn btn-sm btn-default" type="submit">
					<i class="text-success glyphicon glyphicon-ok"></i>
				</button>
				<button class="btn btn-sm btn-default" type="button" ng-click="cancel()">
					<i class="text-danger glyphicon glyphicon-remove"></i>
				</button>
				<button class="btn btn-sm btn-default" type="button" ng-click="clear()" ng-if="clearable === true">
					<i class="text-danger glyphicon glyphicon-erase"></i>
				</button>
	        </span>
		</div>
	</form>
</div>

```

`frontend/app/views/directives/updatable-colour.html`:

```html
<div class="updatable-input updatable-input-select">
	<span class="updatable-input-value-wrapper" ng-hide="updatable.updating" ng-click="edit()">
		<span ng-if="value!==null && value !==''" class="updatable-value"><i class="fa fa-stop" style="color: {{value}};"></i> {{value}}</span>
		<span ng-if="value === null || value === undefined || value === ''" class="updatable-value text-warning"><em>Not Specified</em></span>

		<small class="updatable-input-icon">
			<i class="glyphicon glyphicon-pencil"></i>
		</small>
	</span>

	<form ng-submit="update()" ng-show="updatable.updating">
		<div class="input-group input-group-sm">
            <input type="text" class="form-control" ng-model="value" placeholder="Colour" size="8">

			<span class="input-group-btn">
                <button colorpicker colorpicker-close-on-select class="btn btn-default" ng-model="value" type="button">
                    <i class="fa fa-stop" style="color: {{value}};" ng-class="{'fa-stop': value, 'fa-ellipsis-h': !value}"></i>
                </button>
				<button class="btn btn-sm btn-default" type="submit">
					<i class="text-success glyphicon glyphicon-ok"></i>
				</button>
				<button class="btn btn-sm btn-default" type="button" ng-click="cancel()">
					<i class="text-danger glyphicon glyphicon-remove"></i>
				</button>
				<button class="btn btn-sm btn-default" type="button" ng-click="clear()" ng-if="clearable === true">
					<i class="text-danger glyphicon glyphicon-erase"></i>
				</button>
	        </span>
		</div>
	</form>
</div>

```

`frontend/app/views/directives/updatable-date.html`:

```html
<div class="updatable-input updatable-input-date">
    <span class="updatable-input-value-wrapper" ng-hide="updatable.updating" ng-click="edit()">
        <span ng-if="value!==null && value !==''" class="updatable-value">{{value | shortDate}}</span>
        <span ng-if="value===null || value ===''" class="updatable-value text-warning"><em>Not Specified</em></span>

        <small class="updatable-input-icon">
            <i class="glyphicon glyphicon-pencil"></i>
        </small>
    </span>

    <form ng-submit="update()" ng-show="updatable.updating">
    	<div class="input-group input-group-sm">
    		<input class="input-datetime form-control input-sm" ng-click="dateNow=false" ng-model="humanDate" type="datetime"/>
    		<span class="input-group-btn">
                <span uib-btn-checkbox="" class="btn btn-sm btn-primary" ng-model="dateNow">
    				Now
    			</span>
    			<button class="btn btn-sm btn-default" type="submit">
    				<i class="text-success glyphicon glyphicon-ok"></i>
    			</button>
                <button class="btn btn-sm btn-default" type="button" ng-click="cancel()">
    				<i class="text-danger glyphicon glyphicon-remove"></i>
    			</button>
                <button class="btn btn-sm btn-default" type="button" ng-click="clear()" ng-if="clearable === true">
					<i class="text-danger glyphicon glyphicon-erase"></i>
				</button>
            </span>
    	</div>
    </form>
</div>

```

`frontend/app/views/directives/updatable-select.html`:

```html
<div class="updatable-input updatable-input-select">
	<span class="updatable-input-value-wrapper" ng-hide="updatable.updating" ng-click="edit()">
		<span ng-if="value!==null && value !==''" class="updatable-value">{{value}}</span>
		<span ng-if="value === null || value === undefined || value === ''" class="updatable-value text-warning"><em>Not Specified</em></span>

		<small class="updatable-input-icon">
			<i class="glyphicon glyphicon-pencil"></i>
		</small>
	</span>

	<form ng-submit="update()" ng-show="updatable.updating">
		<div class="input-group input-group-sm">
			<select class="form-control input-sm" ng-model="value" ng-options="v for v in options" ng-change="update()"></select>
			<span class="input-group-btn">
				<button class="btn btn-sm btn-default" type="submit">
					<i class="text-success glyphicon glyphicon-ok"></i>
				</button>
				<button class="btn btn-sm btn-default" type="button" ng-click="cancel()">
					<i class="text-danger glyphicon glyphicon-remove"></i>
				</button>
				<button class="btn btn-sm btn-default" type="button" ng-click="clear()" ng-if="clearable === true">
					<i class="text-danger glyphicon glyphicon-erase"></i>
				</button>
	        </span>
		</div>
	</form>
</div>

```

`frontend/app/views/directives/updatable-simple-text.html`:

```html
<div class="updatable-input updatable-input-text">
	<span class="updatable-input-value-wrapper" ng-hide="updatable.updating" ng-click="edit()">
		<span ng-if="value!==null && value !==''" class="updatable-value">{{value}}</span>
		<span ng-if="value===null || value ===''" class="updatable-value text-warning"><em>Not Specified</em></span>

		<small class="updatable-input-icon">
			<i class="glyphicon glyphicon-pencil"></i>
		</small>
	</span>

	<form ng-submit="update()" ng-show="updatable.updating">
		<div class="input-group input-group-sm">

			<input type="{{ {'float': 'number', 'integer': 'number', 'text': 'text'}[inputType] }}" step="{{ {'float':'.01', 'integer': '1'}[inputType] }}" class="form-control input-sm" placeholder="{{placeholder}}" ng-model="value" autofocus="autofocus">

			<span class="input-group-btn">
				<button class="btn btn-sm btn-default" type="submit">
					<i class="text-success glyphicon glyphicon-ok"></i>
				</button>
				<button class="btn btn-sm btn-default" type="button" ng-click="cancel()">
					<i class="text-danger glyphicon glyphicon-remove"></i>
				</button>
				<button class="btn btn-sm btn-default" type="button" ng-click="clear()" ng-if="clearable === true">
					<i class="text-danger glyphicon glyphicon-erase"></i>
				</button>
	        </span>
		</div>
	</form>
</div>

```

`frontend/app/views/directives/updatable-tag-list.html`:

```html
<div class="updatable-input updatable-input-tags-list">
    <span class="updatable-input-value-wrapper" ng-hide="updatable.updating" ng-click="edit()"
        ng-class="{'tags-list flexwrap': value.length > 0}">
        <span class="updatable-value text-warning" ng-show="!value || value.length === 0"><em>Not Specified</em></span>

        <tag-item ng-repeat="tag in value" value="tag.text"></tag-item>

        <small class="updatable-input-icon" ng-class="{'lg': value.length > 0}">
            <i class="glyphicon glyphicon-pencil"></i>
        </small>
    </span>

    <span ng-show="updatable.updating">
        <div class="form-group">
            <tags-input class="ti-input-sm ti-tag-selector" min-length="2" ng-model="value" placeholder="Add tags"
                replace-spaces-with-dashes="false" template="views/directives/tag-input-item.html"
                tag-class="label-primary">
                <auto-complete ng-if="source" min-length="3" debounce-delay="400" source="source($query)">
                </auto-complete>
            </tags-input>
        </div>
        <div class="btn-group btn-group-sm">
            <button type="button" class="btn btn-sm btn-default" ng-click='update()'>
                <i class="text-success glyphicon glyphicon-ok"></i>
            </button>
            <button type="button" class="btn btn-sm btn-default" ng-click='cancel()'>
                <i class="text-danger glyphicon glyphicon-remove"></i>
            </button>
            <button class="btn btn-sm btn-default" type="button" ng-click="clear()" ng-if="clearable === true">
                <i class="text-danger glyphicon glyphicon-erase"></i>
            </button>
        </div>

        <div class="btn-group btn-group-sm pull-right">
            <button class="btn btn-sm btn-default" type="button" ng-click="$cmp.fromLibrary()">
                <i class="glyphicon glyphicon-plus"></i> Add from Library
            </button>
        </div>
    </span>
</div>

```

`frontend/app/views/directives/updatable-tag.html`:

```html
<div class="updatable-input updatable-input-text">
	<span class="updatable-input-value-wrapper pb-xxxs" ng-hide="updatable.updating" ng-click="edit()">
		<span ng-if="value!==null && value !==''" class="updatable-value"><tag-item value="value" colour="colour"></tag-item></span>
		<span ng-if="value===null || value ===''" class="updatable-value text-warning"><em>Not Specified</em></span>

		<small class="updatable-input-icon">
			<i class="glyphicon glyphicon-pencil"></i>
		</small>
	</span>

	<form ng-submit="update()" ng-show="updatable.updating">
		<div class="input-group input-group-sm">

			<input type="text" class="form-control input-sm" ng-model="value" autofocus="autofocus" required>

			<span class="input-group-btn">
				<button class="btn btn-sm btn-default" type="submit" ng-disabled="!value">
					<i class="text-success glyphicon glyphicon-ok"></i>
				</button>
				<button class="btn btn-sm btn-default" type="button" ng-click="cancel()">
					<i class="text-danger glyphicon glyphicon-remove"></i>
				</button>
	        </span>
		</div>
	</form>
</div>

```

`frontend/app/views/directives/updatable-tags.html`:

```html
<div class="updatable-input updatable-input-tags">
    <span class="updatable-input-value-wrapper" ng-hide="updatable.updating" ng-click="edit()"
        ng-class="{'tags-list flexwrap': value.length > 0}">
        <span class="updatable-value text-warning" ng-show="!value || value.length === 0"><em>Not Specified</em></span>

        <span ng-repeat="tag in value" class="label label-primary mb-xxxs mr-xxxs">{{tag.text}}</span>

        <small class="updatable-input-icon" ng-class="{'lg': value.length > 0}">
            <i class="glyphicon glyphicon-pencil"></i>
        </small>
    </span>

    <span ng-show="updatable.updating">
        <div class="form-group">
            <tags-input class="ti-input-sm" min-length="2" ng-model="value" placeholder="Add labels" replace-spaces-with-dashes="false">
                <auto-complete ng-if="source" min-length="3" debounce-delay="400" source="source($query)"></auto-complete>
            </tags-input>
        </div>
        <div class="btn-group btn-group-sm">
            <button type="button" class="btn btn-sm btn-default" ng-click='update()'>
                <i class="text-success glyphicon glyphicon-ok"></i>
            </button>
            <button type="button" class="btn btn-sm btn-default" ng-click='cancel()'>
                <i class="text-danger glyphicon glyphicon-remove"></i>
            </button>
            <button class="btn btn-sm btn-default" type="button" ng-click="clear()" ng-if="clearable === true">
                <i class="text-danger glyphicon glyphicon-erase"></i>
            </button>
        </div>
    </span>
</div>

```

`frontend/app/views/directives/updatable-text.html`:

```html
<div class="updatable-input updatable-input-text">
    <!-- Display empty text -->
    <span ng-if="!updatable.updating && (!value || value.length ===0 )" class="updatable-input-value-wrapper" ng-click="edit()">
        <span class="updatable-value text-warning"><em>Not Specified</em></span>

        <small class="updatable-input-icon">
            <i class="glyphicon glyphicon-pencil"></i>
        </small>
    </span>

    <!-- Display empty text -->
    <span ng-if="!updatable.updating && value.length >0" class="updatable-input-value-wrapper updatable-input-markdown">
        <small class="updatable-input-icon clickable" ng-click="edit()">
            <i class="glyphicon glyphicon-pencil"></i>
        </small>

        <div marked="value" class="markdown"></div>
    </span>

    <div class="form-group" ng-show="updatable.updating">
        <textarea name="content" class="content-box" markdown-editor="{'iconlibrary': 'fa', addExtraButtons: true, resize: 'vertical'}" rows="10" ng-model="value"></textarea>

        <div class="mt-xxxs">
            <div class="btn-group btn-group-sm">
                <button type="button" class="btn btn-sm btn-default" ng-click='update()'>
                    <i class="text-success glyphicon glyphicon-ok"></i>
                </button>
                <button type="button" class="btn btn-sm btn-default" ng-click='cancel()'>
                    <i class="text-danger glyphicon glyphicon-remove"></i>
                </button>
                <button class="btn btn-sm btn-default" type="button" ng-click="clear()" ng-if="clearable === true">
					<i class="text-danger glyphicon glyphicon-erase"></i>
				</button>
            </div>
            <a class="pull-right" href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank">
                <i class="fa fa-question-circle"></i> Markdown Reference</a>
        </div>
    </div>
</div>

```

`frontend/app/views/directives/updatable-user.html`:

```html
<div class="updatable-input updatable-input-user">
    <span class="updatable-input-value-wrapper" ng-hide="updatable.updating" ng-click="edit()">
        <span ng-if="!!!value" class="updatable-value text-warning"><em>{{blankText || 'Not Specified'}}</em></span>
        <user-info ng-if="!!value" class="updatable-value" value="value" field="name"></user-info>

        <small class="updatable-input-icon">
            <i class="glyphicon glyphicon-pencil"></i>
        </small>
    </span>
    <span ng-init="updatable.dropdownOpen=false" ng-show="updatable.updating">
        <div class="btn-group" uib-dropdown is-open="updatable.dropdownOpen">
            <button class="btn btn-default btn-sm dropdown-toggle" uib-dropdown-toggle type="button">
                <user-info value="value" field="name"></user-info>
                <span class="caret"></span>
            </button>
            <button class="btn btn-default btn-sm" ng-click='updatable.updating = false' type="button">
                <i class="text-danger glyphicon glyphicon-remove"></i>
            </button>
            <button class="btn btn-sm btn-default" type="button" ng-click="clear()" ng-if="clearable === true">
                <i class="text-danger glyphicon glyphicon-erase"></i>
            </button>
            <ul class="dropdown-menu scroll-dropdown" uib-dropdown-menu>
                <li ng-repeat="user in userList">
                    <a ng-click="update(user.login)">{{user.organisation}}/{{user.name}}</a>
                </li>
            </ul>
        </div>
    </span>
</div>

```

`frontend/app/views/directives/updatable.html`:

```html
<span ng-hide="updatable.updating">
    <span class="updatable-value" style="vertical-align:top">{{value}}</span>
    <small ng-show="active">
        <a target="_self" tooltip-popup-delay='500' uib-tooltip="edit">
            <i class="glyphicon glyphicon-pencil" ng-click="edit()"></i>
        </a>
    </small>
</span>
<span ng-show="updatable.updating">
    <span ng-transclude></span>
    <a href ng-click='update()' target="_self" tooltip-placement="top" tooltip-popup-delay='500' uib-tooltip="save">
        <i class="text-success glyphicon glyphicon-ok"></i>
    </a>
    <a href ng-click='cancel()' target="_self" tooltip-placement="top" tooltip-popup-delay='500' uib-tooltip="cancel">
        <i class="text-danger glyphicon glyphicon-remove"></i>
    </a>
</span>

```

`frontend/app/views/directives/user.html`:

```html
<div class="clearfix avatar avatar-{{iconSize || 'xs'}}">
    <img ng-if="userData.avatar" class="avatar-icon"
        alt="{{userData.organisation}}/{{userData.name}}"
        uib-tooltip="{{userData.organisation}}/{{userData.name}}"
        data-ng-src=".{{userData.avatar}}"/>
    <div ng-if="!userData.avatar" class="avatar-icon" uib-tooltip="{{userData.organisation}}/{{userData.name}}">{{initials}}</div>
    <span ng-if="!iconOnly" class="avatar-name">{{userData.organisation}}/{{userData.name}}</span>
</div>

```

`frontend/app/views/login.html`:

```html
<div class="container-fluid mt-xs">
    <div class="text-danger" ng-repeat="schema in appConfig.schemaStatus" ng-if="schema.error">
        <div class="callout callout-danger">
            <h4>Error in {{schema.name}} schema: expected version {{schema.expectedVersion}}, got {{schema.currentVersion}}</h4>
            <p>Please contact the administrator</p>
        </div>
    </div>
</div>

<div class="login-box">
    <div class="login-logo">
        <img src="images/logo.svg" height="70"/>
    </div>
    <div class="login-box-body">
        <p class="login-box-msg">Sign in to start your session</p>
        <form name="loginForm">
            <div class="form-group has-feedback has-feedback-left">
                 <input type="text" class="form-control" placeholder="Login" ng-model="params.username" autocomplete="off" required>
                 <i class="form-control-feedback glyphicon glyphicon-user"></i>
            </div>
            <div class="form-group has-feedback has-feedback-left">
                <input type="password" class="input form-control" placeholder="Password" ng-model="params.password" autocomplete="off" required>
                <i class="form-control-feedback glyphicon glyphicon-lock "></i>
            </div>
            <div class="mv-s" ng-if="params.requireMfa === true">
                <div class="text-danger text-center">
                    Please provide MFA code
                </div>
                <div class="form-group has-feedback has-feedback-left">
                    <input type="text" class="input form-control" placeholder="Code" ng-model="params.mfaCode" autocomplete="off" ng-required="params.requireMfa">
                    <i class="form-control-feedback glyphicon glyphicon-qrcode"></i>
                </div>
            </div>

            <div class="row">
                <div class="col-xs-12">
                    <button type="submit" ng-click="login()" class="btn btn-primary btn-block" ng-disabled="loginForm.$invalid">Sign In</button>
                </div>
            </div>

            <div ng-if="::ssoEnabled()">
                <div class="mt-s or-separator">OR</div>

                <div class="mv-xs">
                    <a class="btn btn-success btn-m btn-block" href="./api/ssoLogin">Sign In with SSO</a>
                </div>

                <div class="text-danger wrap" ng-if="ssoError">
                    {{ssoError}}
                </div>

            </div>
        </form>
    </div>

    <div class="text-center mv-xs text-muted">
        <small>Version: {{version}}</small>
    </div>
</div>

```

`frontend/app/views/maintenance.html`:

```html
<div class="container-fluid">
    <div class="row mt-m">
        <div class="col-md-8 col-md-offset-2">
            <alert close="closeAlert($index)" ng-repeat="alert in alerts" type="{{alert.type}}">{{alert.message}}</alert>
        </div>
    </div>

    <!-- Update Database -->
    <div class="row" ng-hide="showUserForm">
        <div class="col-md-8 col-md-offset-2">

            <div class="alert alert-warning center-block" role="alert">
                <p class="text-center">TheHive needs to update its database</p>
                <br>
                <div class="text-center">
                    <button type="button" class="btn btn-sm btn-default" ng-click="migrate()" ng-hide="migrating">Update Database</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Updating Database -->
    <div class="row">
        <div class="col-md-8 col-md-offset-2">
            <div ng-hide="showUserForm" ng-repeat="status in migrationStatus">
                {{status.tableName}} ({{status.current}} / {{status.total}})
                <uib-progress>
                    <uib-bar type="info" value="status.current * 100 / status.total">{{status.current}}</uib-bar>
                </uib-progress>
            </div>
        </div>
    </div>

    <!-- Add Administrator account -->
    <div class="row" ng-show="showUserForm">
        <div class="col-md-8 col-md-offset-2">
            <div class="panel panel-default">
                <div class="panel-heading"><h4>Create administrator account</h4></div>
                <div class="panel-body">
                    <form class="form-horizontal" ng-submit="createInitialUser()">
                        <div class="form-group">
                            <label class="col-sm-2 control-label">Login</label>
                            <div class="col-sm-10">
                                <input class="form-control" ng-model="newUser.login" placeholder="Login" type="text" autocomplete="off">
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="col-sm-2 control-label">Name</label>
                            <div class="col-sm-10">
                                <input class="form-control" ng-model="newUser.name" placeholder="Name" type="text" autocomplete="off">
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="col-sm-2 control-label">Password</label>
                            <div class="col-sm-10">
                                <input class="form-control" ng-model="newUser.password" placeholder="Password" type="password" autocomplete="off">
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="text-center">
                                <div class="col-sm-offset-2 col-sm-10">
                                    <button class="btn btn-primary" type="submit">Create</button>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/about.html`:

```html
<div class="modal-body">
    <div class="vpad20 text-center">
        <img alt="TheHive" height="60" src="images/logo.svg" />
    </div>
    <div class="row" ng-repeat="(module, ver) in version">
        <div class="col-md-6"><strong class="pull-right">{{module}}</strong></div>
        <div class="col-md-6">{{ver}}</div>
    </div>

    <div class="row mt-xs" ng-repeat="(key, connector) in connectors" ng-if="connector.enabled">
        <div class="col-md-6"><strong class="pull-right">{{key | uppercase}}</strong></div>
        <div class="col-md-6">
            <div ng-repeat="server in connector.servers">
                <strong>{{server.name}}</strong> - <span>{{server.version || 'Unknown version'}}</span>

                (<strong
                    ng-class="{'OK': 'text-success', 'ERROR': 'text-danger', 'AUTH_ERROR': 'text-danger'}[server.status]">{{server.status}}</strong>)
            </div>
        </div>
    </div>
    <div class="row mt-s">
        <div class="col-md-12 text-center">
            <strong>
                <a href="https://thehive-project.org" target="_blank">TheHive Project</a> 2016-2021,
                <a href="https://www.gnu.org/licenses/agpl-3.0.en.html" target="_blank">AGPL-V3</a>
            </strong>
        </div>
    </div>
</div>
<div class="modal-footer">
    <div class="text-center">
        <div class="btn btn-primary" ng-click="close()">
            Close
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/analyzer-template-delete.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">Remove report template</h3>
</div>
<div class="modal-body">
    <p>
        Are you sure you want to delete the {{vm.template.reportType}} report template for analyzer <strong>{{vm.template.analyzerId}}</strong>.
    </p>
    <p>
        This action cannot be undone.
    </p>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="vm.cancel()" type="button">Cancel</button>
    <button class="btn btn-danger pull-right" ng-click="vm.ok()">Yes, Delete the report template</button>
</div>

```

`frontend/app/views/partials/admin/analyzer-template-dialog.html`:

```html
<form class="form-horizontal" name="tplForm" ng-submit="vm.saveTemplate()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">{{vm.analyzer.template.id ? 'Update' : 'Add'}} analyzer template</h3>
    </div>
    <div class="modal-body">
        <div class="form-group">
            <label class="col-sm-2 control-label">Analyzer</label>
            <div class="col-sm-10">
                <p class="form-control-static">{{vm.formData.analyzerId}}</p>
            </div>
        </div>
        <div class="form-group">
            <label class="col-sm-2 control-label">
                Template
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-10">
                <div ui-ace="vm.editorOptions"
                    ng-model="vm.formData.content" style="height: 400px;"></div>
            </div>
        </div>

    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="vm.cancel()" type="button">Cancel</button>
        <button class="btn btn-primary pull-right" ng-disabled="tplForm.$invalid" type="submit">Save template</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/analyzer-template-import.html`:

```html
<form class="form-horizontal" name="form" ng-submit="vm.ok()">
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Import analyzer templates</h3>
    </div>
    <div class="modal-body">
        <div class="form-group">
            <label class="col-sm-2 control-label">Templates archive</label>
            <div class="col-sm-10">
                <input type="hidden" name="attachment" ng-model="vm.formData.attachment.status" required>
                <div file-chooser="" filemodel="vm.formData.attachment"></div>
            </div>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-warning pull-left" type="button" ng-click="vm.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="form.$invalid">Yes, Import template archive</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/analyzer-templates.html`:

```html
<div class="box">
    <div class="box-header">
        <h3 class="box-title">Analyzer template management</h3>
    </div>
    <div class="box-body">
        <div class="row mb-s">
            <div class="col-md-12 clearfix">
                <div class="pull-left">
                    <!-- Single button -->
                    <div class="btn-group">
                        <button type="button" class="btn btn-sm btn-primary" ng-click="vm.import()">
                            <span class="fa fa-upload"></span> Import templates
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="filter-panel mb-xs">
            <h4>Download the official templates archive</h4>
            <p>You can download the latest archive of the official analyzer templates <a target="_blank" href="http://download.thehive-project.org/report-templates.zip?version={{vm.appConfig.versions.TheHive}}">from here</a></p>
        </div>
        <div class="row mv-s" ng-show="vm.analyzerCount === 0">
            <div class="col-md-12">
                <div class="empty-message">No analyzer templates found.</div>
            </div>
        </div>
        <div class="row" ng-show="vm.analyzerCount > 0">
            <div class="col-md-12">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th width="200px">Long template</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr ng-repeat="analyzerId in vm.analyzerIds | orderBy:'toString()'" ng-init="analyzer=vm.analyzers[analyzerId]">
                            <td>
                                {{::analyzer.name || analyzer.id}}<br>
                                <small class="text-muted">{{::analyzer.description}}</small>
                            </td>
                            <td class="vmiddle">
                                <div class="btn-group btn-group-sm" ng-if="analyzer.template.id">
                                    <button type="button" class="btn btn-default" ng-click="vm.showTemplate(vm.analyzers[analyzerId])">View Template</button>
                                    <button type="button" class="btn btn-danger" ng-click="vm.deleteTemplate(analyzer.template)"><i class="fa fa-times"></i></button>
                                </div>
                                <div class="btn-group btn-group-sm" ng-if="!analyzer.template.id">
                                    <button type="button" class="btn btn-default" ng-click="vm.showTemplate(analyzer)">Default template</button>
                                </div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

    </div>
</div>

```

`frontend/app/views/partials/admin/attack/import.html`:

```html
<form class="" name="form" ng-submit="$vm.ok()">
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Import MITRE ATT&CK patterns</h3>
    </div>
    <div class="modal-body">

        <div class="filter-panel mb-s">
            <h4>Download the official MITRE ATT&CK library</h4>
            <p>You can download the latest archive of the official MITRE ATT&CK patterns <a target="_blank"
                    href="https://raw.githubusercontent.com/mitre/cti/master/enterprise-attack/enterprise-attack.json?version=TheHive-{{$vm.appConfig.versions.TheHive}}">from
                    here</a></p>
        </div>

        <div class="form-group">
            <label class="control-label">MITRE ATT&CK patterns</label>
            <input type="hidden" name="attachment" ng-model="$vm.formData.attachment.status" required>
            <div file-chooser="" filemodel="$vm.formData.attachment"></div>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-default pull-left" type="button" ng-click="$vm.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="form.$invalid || $vm.loading">Yes, Import
            it</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/attack/list.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="box">
            <div class="box-header with-border">
                <h3 class="box-title">List of ATT&CK patterns ({{$vm.list.values.length || 0}} of {{$vm.list.total}})</h3>
            </div>
            <div class="box-body">
                <div ng-include="'views/partials/admin/attack/list/toolbar.html'"></div>

                <div class="mt-xs filter-panel" ng-include="'views/partials/admin/attack/list/filters.html'" ng-show="$vm.filtering.context.showFilters"></div>

                <div class="row mt-xs">
                    <div class="col-md-12 clearfix">

                        <filters-preview filters="$vm.filtering.context.filters"
                            on-clear-item="$vm.removeFilter(field)"
                            on-clear-all="$vm.clearFilters()"></filters-preview>
                    </div>
                </div>

                <div class="row mv-s" ng-show="$vm.loading === false && $vm.list.values.length === 0">
                    <div class="col-md-12">
                        <div class="empty-message">No ATT&CK patterns found.</div>
                    </div>
                </div>

                <div class="row mv-s" ng-show="$vm.loading === true">
                    <div class="col-md-12">
                        <div class="loading-message">
                            <i class="fa fa-circle-o-notch fa-spin fa-fw"></i>
                            <span>loading patterns...</span>
                        </div>
                    </div>
                </div>

                <!-- Datalist  -->
                <div class="row mt-s" ng-if="$vm.loading === false && $vm.list.values.length > 0">
                    <psearch control="$vm.list"></psearch>

                    <div class="col-md-12">
                        <table class="table table-striped case-list">
                            <thead>
                                <tr>
                                    <th width="100">ID</th>
                                    <th width="200">Name</th>
                                    <th width="200">Sub-Technique of</th>
                                    <th width="200">Tactics</th>
                                    <th>Description</th>
                                    <th width="120"></th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr ng-repeat="pattern in $vm.list.values">
                                    <td>
                                        <a href ng-click="$vm.show(pattern.patternId)">{{::pattern.patternId}}</a>
                                    </td>
                                    <td ng-class="{'text-danger': pattern.revoked}">{{::pattern.name}}</td>
                                    <td>
                                        <span ng-if="!pattern.extraData.parent">-</span>
                                        <span ng-if="::pattern.extraData.parent">
                                            <a href ng-click="$vm.show(pattern.extraData.parent.patternId)" class="mr-xxs">{{::pattern.extraData.parent.patternId}}</a>
                                            <a href ng-click="$vm.addFilterValue('parent', pattern.extraData.parent.patternId)"><i class="fa fa-filter"></i></a>
                                        </span>

                                    </td>
                                    <td>
                                        <div ng-repeat="tactic in ::pattern.tactics" class="mb-xxs">
                                            <span class="label label-default clickable" ng-click="$vm.addFilterValue('tactics', tactic)">{{tactic}}</span>
                                        </div>
                                    </td>
                                    <td class="wrap">
                                        {{::pattern.description | limitTo:250}}...
                                    </td>
                                    <td class="clearfix">
                                        <div class="pull-right">
                                            <a class="btn btn-icon btn-clear" href="{{::pattern.url}}" target="_blank">
                                                <i class="text-primary fa fa-external-link"></i>
                                            </a>

                                            <a class="btn btn-icon btn-clear" href  ng-click="$vm.show(pattern.patternId)" uib-tooltip="Show pattern">
                                                <i class="text-primary fa fa-search"></i>
                                            </a>
<!--
                                            <a class="btn btn-icon btn-clear" href  ng-click="$vm.remove(pattern)" uib-tooltip="Delete pattern">
                                                <i class="text-danger fa fa-trash"></i>
                                            </a> -->
                                        </div>

                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <psearch control="$vm.list"></psearch>
                </div>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/attack/list/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>
        <form ng-submit="$vm.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $vm.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$vm.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in $vm.filtering.attributeKeys"
                            ng-change="$vm.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$vm.filtering.metadata" filter="filter" entity="$vm.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$vm.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$vm.clearFilters()" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/partials/admin/attack/list/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">
            <div class="btn-group">
                <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.import()">
                    <i class="fa fa-plus"></i>
                    Import MITRE ATT&CK Patterns
                </button>
            </div>
            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]" type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/attack/view.html`:

```html
<form class="form">
    <div class="modal-header" ng-class="{'bg-primary': !!!$modal.pattern.revoked, 'bg-danger': !!$modal.pattern.revoked}">
        <h3 class="modal-title">{{$modal.pattern.isSubTechnique ? ($modal.pattern.parentName + ': ') : ''}}{{::$modal.pattern.name}}
            <span ng-if="$modal.pattern.revoked" class="label label-danger">Revoked</span>
        </h3>
    </div>

    <div class="modal-body">
        <div class="row">
            <div class="col-sm-4">
                <div class="form-group">
                    <label>{{::$modal.pattern.isSubTechnique ? 'Sub-technique' : 'Technique'}} Name</label>
                    <div>{{::$modal.pattern.name}}</div>
                </div>
            </div>
            <div class="col-sm-4" ng-if="::$modal.pattern.isSubTechnique">
                <div class="form-group">
                    <label>Sub-Technique of</label>
                    <div>{{::$modal.pattern.parentName || '-'}}</div>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="form-group">
                    <label>URL</label>
                    <div>
                        <a href="{{::$modal.pattern.url}}" target="_blank">
                            {{::$modal.pattern.url}}<i class="fa fa-external-link ml-xxxs"></i>
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-sm-4">
                <div class="form-group">
                    <label>Tactics</label>
                    <div ng-if="::$modal.pattern.tactics.length === 0">
                        <em class="text-muted">None</em>
                    </div>
                    <div ng-repeat="tactic in ::$modal.pattern.tactics" class="mb-xxs">
                        <span class="label label-default">{{tactic}}</span>
                    </div>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="form-group">
                    <label>Data Sources</label>
                    <div ng-if="::$modal.pattern.dataSources.length === 0">
                        <em class="text-muted">None</em>
                    </div>
                    <div ng-repeat="ds in ::$modal.pattern.dataSources" class="mb-xxs">
                        <span class="label label-default">{{ds}}</span>
                    </div>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="form-group">
                    <label>Platforms</label>
                    <div ng-if="::$modal.pattern.platforms.length === 0">
                        <em class="text-muted">None</em>
                    </div>
                    <div ng-repeat="platform in ::$modal.pattern.platforms" class="mb-xxs">
                        <span class="label label-default">{{platform}}</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-sm-4">
                <div class="form-group">
                    <label>Defense Bypassed</label>
                    <div ng-if="::$modal.pattern.defenseBypassed.length === 0">
                        <em class="text-muted">None</em>
                    </div>
                    <div ng-repeat="defense in ::$modal.pattern.defenseBypassed" class="mb-xxs">
                        <span class="label label-default">{{defense}}</span>
                    </div>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="form-group">
                    <label>Permissions Required</label>
                    <div ng-if="::$modal.pattern.permissionsRequired.length === 0">
                        <em class="text-muted">None</em>
                    </div>
                    <div ng-repeat="perm in ::$modal.pattern.permissionsRequired" class="mb-xxs">
                        <span class="label label-default">{{perm}}</span>
                    </div>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="form-group">
                    <label>System Requirements</label>
                    <div ng-if="::$modal.pattern.systemRequirements.length === 0">
                        <em class="text-muted">None</em>
                    </div>
                    <div ng-repeat="req in ::$modal.pattern.systemRequirements" class="mb-xxs">
                        <span class="label label-default">{{req}}</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-sm-4">
                <div class="form-group">
                    <label>Remote Support</label>
                    <div>{{!!$modal.pattern.remoteSupport}}</div>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="form-group">
                    <label>Capec ID</label>
                    <div ng-if="$modal.pattern.capecId">
                        {{::$modal.pattern.capecId}}
                    </div>
                    <div ng-if="!$modal.pattern.capecId">
                        <em class="text-muted">None</em>
                    </div>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="form-group">
                    <label>Capec URL</label>
                    <div ng-if="$modal.pattern.capecUrl">
                        <a href="{{::$modal.pattern.capecUrl}}" target="_blank">
                            {{::$modal.pattern.capecUrl}} <i class="fa fa-external-link ml-xxxs"></i>
                        </a>
                    </div>
                    <div ng-if="!$modal.pattern.capecUrl">
                        <em class="text-muted">None</em>
                    </div>
                </div>
            </div>
        </div>

        <div class="form-group">
            <label>Description</label>
            <div ng-if="$modal.pattern.description">
                {{::$modal.pattern.description}}
            </div>
            <div ng-if="!$modal.pattern.description">
                <em class="text-muted">None</em>
            </div>
        </div>

        <div class="row" ng-if="$modal.pattern.extraData.children.length > 0">
            <div class="col-sm-12">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th class="pl-0" width="200">ID</th>
                            <th>Name</th>
                            <th>Tactics</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr ng-repeat="p in $modal.pattern.extraData.children">
                            <td>
                                {{::p.patternId}}
                                <a class="ml-xxs" href="{{::p.url}}" target="_blank">
                                    <i class="text-primary fa fa-external-link"></i>
                                </a>
                            </td>
                            <td>{{::p.name}}</td>
                            <td>
                                <span ng-repeat="tactic in p.tactics" class="label label-default mr-xxxs mb-xxxs">{{tactic}}</span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-primary pull-right"
            ng-class="{'btn-primary': !!!$modal.pattern.revoked, 'btn-danger': !!$modal.pattern.revoked}"
            type="button" ng-click="$modal.cancel()">Close</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/custom-field-dialog.html`:

```html
<form class="form-horizontal" name="fieldsForm" ng-submit="$vm.saveField(fieldsForm)" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">{{$vm.customField.id ? 'Update' : 'Add'}} custom field</h3>
    </div>
    <div class="modal-body">
        <div class="form-group" ng-class="{ 'has-error' : fieldsForm.name.$invalid && !fieldsForm.name.$pristine }">
            <label class="col-sm-3 control-label">
                Name
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <input class="form-control" name="name"
                    placeholder="Field's display name, Ex: CVSS, Threat actor, Business risk"
                    ng-model="$vm.customField.name"
                    ng-keyup="$vm.onNamechanged(fieldsForm)"
                    required type="text">
                <p class="help-block" ng-show="fieldsForm.name.$invalid && !fieldsForm.name.$pristine">This field is required.</p>
            </div>
        </div>

        <div class="form-group" ng-class="{ 'has-error' : fieldsForm.reference.$invalid && fieldsForm.reference.$dirty }">
            <label class="col-sm-3 control-label">
                Internal Reference
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <input class="form-control" name="reference" type="text"
                    placeholder="Internal name, Ex: cvss, threatActor, businessRisk"
                    ng-model="$vm.customField.reference"
                    ng-keyup="$vm.clearUniqueNameError(fieldsForm)"
                    ng-pattern="$vm.config.referencePattern"
                    ng-readonly="!!$vm.customField.id"
                    required>
                <p class="help-block" ng-show="fieldsForm.reference.$error.unique">There is already a field with this reference. It should be unique.</p>
                <p class="help-block" ng-show="fieldsForm.reference.$error.required && fieldsForm.reference.$dirty">This field is required.</p>
                <p class="help-block" ng-show="fieldsForm.reference.$error.pattern && fieldsForm.reference.$dirty">This field is should satisfy the following pattern: {{$vm.config.referencePattern}}</p>
            </div>
        </div>

        <div class="form-group" ng-class="{ 'has-error' : fieldsForm.description.$invalid && !fieldsForm.description.$pristine }">
            <label class="col-sm-3 control-label">
                Description
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <input class="form-control" name="description" ng-model="$vm.customField.description" placeholder="A brief description of the custom field" required type="text">
                <p class="help-block" ng-show="fieldsForm.description.$invalid && !fieldsForm.description.$pristine">This field is required.</p>
            </div>
        </div>
        <div class="form-group" ng-class="{ 'has-error' : fieldsForm.type.$invalid && !fieldsForm.type.$pristine }">
            <label class="col-sm-3 control-label">
                Type
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <select class="form-control" name="type" ng-model="$vm.customField.type"
                    ng-options="fieldType for fieldType in $vm.config.types"
                    placeholder="Field's type" required></select>
                <p class="help-block" ng-show="fieldsForm.type.$invalid && !fieldsForm.type.$pristine">This field is required.</p>
            </div>
        </div>

        <div class="form-group" ng-show="$vm.customField.type === 'string' || $vm.customField.type === 'integer'  || $vm.customField.type === 'float'">
            <label class="col-sm-3 control-label">
                Possible values
            </label>
            <div class="col-sm-9">
                <textarea class="form-control" name="options" ng-model="$vm.customField.options" rows="5" placeholder="Possible values, one per line" type="text"></textarea>
            </div>
        </div>

        <div class="form-group">
            <label class="col-sm-3 control-label">&nbsp;</label>
            <div class="col-sm-9">
                <div class="checkbox">
                    <label>
                        <input name="mandatory" type="checkbox" ng-model="$vm.customField.mandatory"> Is mandatory
                    </label>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$vm.cancel()" type="button">Cancel</button>
        <button class="btn btn-primary pull-right" ng-disabled="fieldsForm.$invalid" type="submit">Save field</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/custom-fields.html`:

```html
<div class="box">
    <div class="box-header">
        <h3 class="box-title">Case custom fields ({{$vm.customFields.length}})</h3>
    </div>
    <div class="box-body">

        <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.showFieldDialog({})">Add custom field</button>

        <div class="row mt-xs">
            <div class="col-md-12" ng-if="$vm.customFields.length === 0">
                <div class="empty-message">No custom fields defined yet</div>
            </div>
            <div class="col-md-12" ng-if="$vm.customFields.length !== 0">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th width="80">Type <a ng-click="$vm.sortBy('type')"><i class="fa fa-sort" ng-class="{'fa-sort-up': $vm.state.sort==='type' && !$vm.state.asc, 'fa-sort-down': $vm.state.sort==='type' && $vm.state.asc}"></i></a></th>
                            <th width="250">Name <a ng-click="$vm.sortBy('name')"><i class="fa fa-sort" ng-class="{'fa-sort-up': $vm.state.sort==='name' && !$vm.state.asc, 'fa-sort-down': $vm.state.sort==='name' && $vm.state.asc}"></i></a></th>
                            <th width="250">Internal Reference <a ng-click="$vm.sortBy('reference')"><i class="fa fa-sort" ng-class="{'fa-sort-up': $vm.state.sort==='reference' && !$vm.state.asc, 'fa-sort-down': $vm.state.sort==='reference' && $vm.state.asc}"></i></a></th>
                            <th>Description</th>
                            <th width="100" class="text-center">Mandatory</th>
                            <th width="200">Options</th>
                            <th width="160" class="text-center">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr ng-repeat="field in $vm.customFields | orderBy:$vm.state.sort:!$vm.state.asc">
                            <td align="center">
                                <span class="label label-default">{{field.type | uppercase}}</span>
                            </td>
                            <td><a href ng-click="$vm.showFieldDialog(field)">{{field.name}}</a></td>
                            <td>{{field.reference}}</td>
                            <td>{{field.description || 'N/A'}}</td>
                            <td align="center">{{field.mandatory === true ? 'Yes': 'No'}}</td>
                            <td ng-if="field.options.length === 0">
                                <em>None</em>
                            </td>
                            <td ng-if="field.options.length > 0">
                                <ul class="list list-unstyled" ng-repeat="option in field.options track by $index">
                                    <li>{{option}}</li>
                                </ul>
                            </td>
                            <td align="center">
                                <button class="btn btn-xs btn-primary" ng-click="$vm.showFieldDialog(field)"><i class="fa fa-pencil"></i> Edit</button>
                                <button class="btn btn-xs btn-danger" ng-click="$vm.deleteField(field)"><i class="fa fa-trash"></i> Delete</button>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

        </div>

        <div class="vpad10"></div>

    </div>
</div>

```

`frontend/app/views/partials/admin/observables.html`:

```html
<div class="box">
    <div class="box-header">
        <h3 class="box-title">Observable types management</h3>
    </div>
    <div class="box-body">
        <div class="row">
            <div class="col-md-6">
                <form class="mv-s" name="dtForm" ng-submit="$vm.addArtifactDataTypeList()">
                    <div class="input-group input-group-sm">
                        <input class="form-control" ng-model="$vm.params.newDataType" placeholder="Specify the datatype to add. Ex: domain, ip, email" required>
                        <span class="input-group-btn">
                            <button type="submit" class="btn btn-primary btn-flat" ng-disabled="dtForm.$invalid">Add dataType</button>
                        </span>
                    </div>
                </form>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>dataType</th>
                            <th width="80">Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr ng-repeat="datatype in $vm.dataTypeList | orderBy:'name'">
                            <td>{{datatype.name || datatype.value}}</td>
                            <td>
                                <a href ng-click="$vm.deleteArtifactDataType(datatype)">
                                    <i class="text-danger glyphicon glyphicon-trash"></i>
                                </a>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/organisation/details.html`:

```html
<div class="row case-page">
    <div class="col-md-12">
        <div class="row">
            <div class="col-md-12">
                <div class="box box-default">
                    <div class="box-header with-border">
                        <h3 class="box-title">
                            <span class="wrap">[Organisation] - {{$vm.org.name}}</span>
                        </h3>
                        <div class="box-tools pull-right" ng-if="isSuperAdmin()">
                            <span class="ml-xs">
                                <a ui-sref="app.administration.organisations">
                                    <i class="fa fa-chevron-left"></i> Back to list
                                </a>
                            </span>
                        </div>
                    </div>

                    <div class="box-body">
                        <div class="org-description text-muted mb-xxs">
                            {{$vm.org.description || 'No description'}}
                        </div>
                        <div class="org-summary">
                            <span class="mr-xxs" ng-if="isSuperAdmin()">
                                <i class="glyphicon glyphicon-user"></i>
                                <user-info value="$vm.org.createdBy" field="name"></user-info>
                            </span>
                            <span>
                                <i class="glyphicon glyphicon-calendar"></i>
                                <span class="mr-xxxs">{{$vm.org.createdAt | shortDate}}</span>
                            </span>
                            <span ng-if="$vm.org.links.length > 0">
                                <i class="fa fa-link"></i>
                                <span class="label label-default mr-xxs" ng-repeat="link in $vm.org.links | orderBy">{{link}}</span>
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <uib-tabset active="active" class="nav-tabs-custom">
                    <uib-tab index="0" if-permission="manageUser">
                        <uib-tab-heading>
                            <span>
                                <i class="mr-xxs fa fa-users"></i>
                                Users
                            </span>
                        </uib-tab-heading>
                        <div if-permission="manageUser">
                            <div class="row">
                                <div class="col-md-12">
                                    <div class="btn-toolbar" role="toolbar">
                                        <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.showUserDialog()">
                                            <i class="fa fa-plus"></i>
                                            Create new user
                                        </button>
                                        <div class="btn-group" uib-dropdown>
                                            <button class="btn btn-sm btn-primary dropdown-toggle" uib-dropdown-toggle type="button">
                                                <i class="fa fa-filter"></i>
                                                Quick Filters
                                                <span class="caret"></span>
                                            </button>
                                            <ul class="dropdown-menu" uib-dropdown-menu>
                                                <li>
                                                    <a class="clickable" ng-click="$vm.filterBy('locked', false)"><i class="fa fa-unlock-alt"></i> Active users</a>
                                                </li>
                                                <li>
                                                    <a class="clickable" ng-click="$vm.filterBy('locked', true)"><i class="fa fa-lock"></i> Locked users</a>
                                                </li>
                                            </ul>
                                        </div>

                                        <div class="btn-group pull-right" role="group">
                                            <page-sizer collection="$vm.users" sizes="[10, 15, 30, 100]"></page-sizer>
                                        </div>

                                        <div class="btn-group pull-right" role="group">
                                            <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]" type="button" ng-click="$vm.toggleFilters()">
                                                <i class="fa fa-search"></i> Filters
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-12">
                                    <div class="mt-s filter-panel" ng-include="'views/partials/admin/organisation/list/filters.html'" ng-show="$vm.filtering.context.showFilters"></div>


                                    <div class="row mt-s">
                                        <div class="col-md-12 clearfix">
                                            <div class="pull-left">
                                                <h4>
                                                    User List ({{$vm.users.values.length || 0}} of {{$vm.users.total}})
                                                </h4>
                                            </div>

                                            <filters-preview filters="$vm.filtering.context.filters"
                                                on-clear-item="$vm.removeFilter(field)"
                                                on-clear-all="$vm.clearFilters()"></filters-preview>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <org-user-list users="$vm.users"
                                on-reload="$vm.loadUsers()"
                                on-edit="$vm.showUserDialog(user)"
                                on-sort="$vm.sortByField(field)"
                                on-filter="$vm.addFilterValue(field, value)"
                                sort="$vm.filtering.context.sort"
                                set-password-enabled="$vm.canSetPass"
                                mfa-enabled="$vm.canChangeMfa"></org-user-list>
                        </div>
                    </uib-tab>
                    <uib-tab index="1" if-permission="manageCaseTemplate">
                        <uib-tab-heading>
                            <span>
                                <i class="mr-xxs fa fa-file-text"></i>
                                Case Templates
                            </span>
                        </uib-tab-heading>
                        <div if-permission="manageCaseTemplate">
                            <org-case-template-list fields="$vm.fields" templates="$vm.templates" organisation="$vm.org"></org-case-template-list>
                        </div>
                    </uib-tab>
                    <uib-tab index="2" if-permission="manageTag">
                        <uib-tab-heading>
                            <span>
                                <i class="mr-xxs fa fa-tag"></i>
                                Custom Tags
                            </span>
                        </uib-tab-heading>
                        <div if-permission="manageTag">
                            <org-custom-tags-list organisation="$vm.org"></org-custom-tags-list>
                        </div>
                    </uib-tab>
                    <uib-tab index="3" if-permission="manageConfig">
                        <uib-tab-heading>
                            <span>
                                <i class="mr-xxs fa fa-cogs"></i>
                                UI Configuration
                            </span>
                        </uib-tab-heading>
                        <div if-permission="manageConfig">
                            <org-config-list ui-config="$vm.uiConfig"></org-config-list>
                        </div>
                    </uib-tab>
                    <!-- <uib-tab index="1" if-permission="manageOrganisation">
                        <uib-tab-heading>
                            <span>
                                <i class="mr-xxs fa fa-link"></i>
                                Links
                            </span>
                        </uib-tab-heading>
                        <div if-permission="manageOrganisation">
                            <org-case-template-list fields="$vm.fields" templates="$vm.templates"></org-case-template-list>
                        </div>
                    </uib-tab> -->
                </uib-tabset>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/organisation/list.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="box">
            <div class="box-header with-border">
                <h3 class="box-title">List of organisations ({{$vm.list.values.length || 0}} of {{$vm.list.total}})</h3>
            </div>
            <div class="box-body">
                <div ng-include="'views/partials/admin/organisation/list/toolbar.html'"></div>

                <div class="mt-xs filter-panel" ng-include="'views/partials/admin/organisation/list/filters.html'" ng-show="$vm.filtering.context.showFilters"></div>

                <!-- Filters preview  -->
                <div class="row mt-xs">
                    <div class="col-md-12 clearfix">
                        <filters-preview filters="$vm.filtering.context.filters"
                            on-clear-item="$vm.removeFilter(field)"
                            on-clear-all="$vm.clearFilters()"></filters-preview>
                    </div>
                </div>

                <!-- Datalist  -->
                <div class="row mt-s">
                    <div class="col-md-12">
                        <psearch control="$vm.list"></psearch>

                        <table class="table table-striped case-list">
                            <thead>
                                <tr>
                                    <th>
                                        <a href class="text-default" ng-click="$vm.sortByField('name')">
                                            Name
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+name') === -1 && $vm.filtering.context.sort.indexOf('-name') === -1" class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+name') !== -1" class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-name') !== -1" class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 300px">
                                        <a href class="text-default" ng-click="$vm.sortByField('_createdBy')">
                                            Created By
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdBy') === -1 && $vm.filtering.context.sort.indexOf('-_createdBy') === -1" class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdBy') !== -1" class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-_createdBy') !== -1" class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 160px">
                                        Dates

                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_createdAt')" uib-tooltip="Sort by creation date">
                                            C.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') === -1 && $vm.filtering.context.sort.indexOf('-_createdAt') === -1" class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') !== -1" class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-_createdAt') !== -1" class="fa fa-caret-down"></i>
                                        </a>
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_updatedAt')" uib-tooltip="Sort by last update date">
                                            U.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') === -1 && $vm.filtering.context.sort.indexOf('-_updatedAt') === -1" class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') !== -1" class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-_updatedAt') !== -1" class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 250px"></th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr ng-repeat="org in $vm.list.values">
                                    <td>
                                        <div class="org-name">
                                            <a ui-sref="app.administration.organisations-details({organisation: org.name})">{{::org.name}}</a>
                                        </div>
                                        <div class="org-description text-muted">
                                            {{::org.description || 'No description'}}
                                        </div>
                                        <div class="mt-xs" ng-if="org.links.length > 0">
                                            <span class="text-muted mr-xxs">Linked organisations:</span>
                                            <span class="label label-default mr-xxs" ng-repeat="link in ::org.links | orderBy">{{link}}</span>
                                        </div>
                                        <div class="mt-xs" ng-if="org.links.length === 0">
                                            <span class="text-muted mr-xxs">Linked organisations:</span>
                                            <span class="text-warning"><em>None</em></span>
                                        </div>
                                    </td>

                                    <td class="clearfix">
                                      <user user-id="org._createdBy" icon-only="false" icon-size="m"></user>
                                    </td>
                                    <td>
                                        <div ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_createdAt') !== -1 || $vm.filtering.context.sort.indexOf('-_createdAt') !== -1}">
                                            C. <a href ng-click="$vm.addFilterValue('_createdAt', org._createdAt)">{{org._createdAt | shortDate}}</a>
                                        </div>
                                        <div ng-if="org._updatedAt > 0" ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_updatedAt') !== -1 || $vm.filtering.context.sort.indexOf('-_updatedAt') !== -1}">
                                            U. <a href ng-click="$vm.addFilterValue('_updatedAt', org._updatedAt)">{{org._updatedAt | shortDate}}</a>
                                        </div>
                                    </td>
                                    <td>
                                        <span class="mr-xs text-primary">
                                            <a ui-sref="app.administration.organisations-details({organisation: org.name})">
                                                <i class="fa fa-cog"></i> Configure
                                            </a>
                                        </span>
                                        <span class="clickable mr-xs text-primary" ng-click="$vm.showNewOrg('edit', org)">
                                            <i class="fa fa-edit"></i> Edit</span>
                                        <span class="clickable mr-xs text-primary" ng-click="$vm.showLinks(org)" ng-if="org.name !== 'admin'">
                                            <i class="fa fa-link"></i> Link</span>
                                        <!-- <a class="btn btn-xs btn-icon btn-clear" href ng-click="$vm.showNewOrg('edit', org)" >
                                            <i class="text-info text-20 fa fa-edit"></i>
                                        </a> -->
                                    </td>
                                </tr>
                            </tbody>
                        </table>

                        <psearch control="$vm.list"></psearch>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/organisation/list/create.modal.html`:

```html
<form class="form-horizontal" name="form" ng-submit="$modal.ok()">
  <div class="modal-header bg-primary">
    <h3 class="modal-title">{{{'edit': 'Edit', 'add': 'Create' }[$modal.mode]}} organisation</h3>
  </div>
  <div class="modal-body">
    <div class="form-group">
      <label class="col-sm-2 control-label">Name
        <i class="fa fa-asterisk text-danger"></i>
      </label>
      <div class="col-sm-10">
        <input type="text" class="form-control" ng-model="$modal.formData.name" ng-disabled="!!!$modal.nameIsEditable" required placeholder="Organisation's name">
      </div>
    </div>
    <div class="form-group">
      <label class="col-sm-2 control-label">Description
        <i class="fa fa-asterisk text-danger"></i>
      </label>
      <div class="col-sm-10">
        <input type="text" class="form-control" ng-model="$modal.formData.description" required placeholder="Organisation's description">
      </div>
    </div>
  </div>
  <div class="modal-footer">
    <button class="btn btn-default pull-left" type="button" ng-click="$modal.cancel()">Cancel</button>
    <span class="btn pull-left"><i class="fa fa-asterisk text-danger"></i>&nbsp;Required field</span>
    <button class="btn btn-primary pull-right" type="submit" ng-disabled="form.$invalid">Save</button>
  </div>
</form>

```

`frontend/app/views/partials/admin/organisation/list/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>
        <form ng-submit="$vm.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $vm.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$vm.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in $vm.filtering.attributeKeys"
                            ng-change="$vm.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$vm.filtering.metadata" filter="filter" entity="$vm.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$vm.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$vm.clearFilters()" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/partials/admin/organisation/list/link.modal.html`:

```html
<form class="form-horizontal" name="form" ng-submit="$modal.ok()">
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Manage organisation links</h3>
    </div>
    <div class="modal-body">
        <div ng-show="$modal.organisations.length === 0">
            <div class="empty-message">No organisation can be linked</div>
        </div>

        <div ng-show="$modal.organisations.length > 0">
            <p>
                Please select the organisation(s) you want to make visible to users of organisation <strong>{{$modal.organisation.name}}</strong>
            </p>


            <table class="table table-hover">
                <thead>
                    <th width="40" class="text-center">
                        <input type="checkbox" ng-change="$modal.toggleLinkAll()" ng-model="$modal.allSelected">
                    </th>
                    <th>
                        Organisation
                    </th>
                    <th width="220">
                        Added at
                    </th>
                </thead>
                <tbody>
                    <tr ng-repeat="org in $modal.organisations" ng-click="$modal.toggleLink(org)">
                        <td width="40" class="text-center">
                            <input type="checkbox" ng-model="org.linked">
                        </td>
                        <td>
                            {{org.name}}
                        </td>
                        <td>
                            {{org.createdAt | shortDate}}
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-default pull-left" type="button" ng-click="$modal.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="$modal.initialHash === $modal.hash">Save</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/organisation/list/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <div class="btn-group">
                <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.showNewOrg('add')">
                    <i class="fa fa-plus"></i>
                    New Organisation
                </button>
            </div>

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]" type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/organisation/user.modal.html`:

```html
<form class="form-horizontal" name="userForm" ng-submit="$modal.saveUser(userForm)" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">{{$modal.isEdit ? 'Update' : 'Add'}} user</h3>
    </div>
    <div class="modal-body">
        <div class="form-group">
            <label class="col-sm-3 control-label">
                Organisation
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <input class="form-control" name="organisation"
                    ng-disabled="true"
                    ng-model="$modal.formData.organisation"
                    required type="text">
            </div>
        </div>
        <div class="form-group" ng-class="{ 'has-error' : userForm.login.$invalid && !userForm.login.$pristine }">
            <label class="col-sm-3 control-label">
                Login
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <input class="form-control" name="login"
                    placeholder="User's email address"
                    ng-disabled="$modal.isEdit"
                    ng-model="$modal.formData.login"
                    required type="email">
                <p class="help-block" ng-show="userForm.login.$error.required && !userForm.login.$pristine">This field is required.</p>
                <p class="help-block" ng-show="userForm.login.$error.email && !userForm.login.$pristine">This field must be a valid email.</p>
            </div>
        </div>

        <div class="form-group" ng-class="{ 'has-error' : userForm.name.$invalid && !userForm.name.$pristine }">
            <label class="col-sm-3 control-label">
                Full name
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <input class="form-control" name="name"
                    placeholder="User's name"
                    ng-model="$modal.formData.name"
                    required type="text">
                <p class="help-block" ng-show="userForm.name.$invalid && !userForm.name.$pristine">This field is required.</p>
            </div>
        </div>

        <div class="form-group">
            <label class="col-sm-3 control-label">
                Profile
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <select class="form-control" ng-model="$modal.formData.profile"
                    ng-options="name for (name, profile) in $modal.profiles"
                    ng-change="permissions = $modal.profiles[$modal.formData.profile.name].permissions">
                        <option value="" disabled selected>-- Select profile --</option>
                </select>
                <permission-list  ng-init="permissions = $modal.profiles[$modal.formData.profile.name].permissions"
                    permissions="permissions"
                    show-label="true"
                    label="Permissions"></permission-list>
            </div>
        </div>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$modal.cancel()" type="button">Cancel</button>
        <span class="hpad10">
            <i class="fa fa-asterisk text-danger"></i>&nbsp;Required field</span>
        <button class="btn btn-primary pull-right" ng-disabled="userForm.$invalid" type="submit">Save user</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/platform/status.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="box">
            <div class="box-header">
                <h3 class="box-title">Platform Status</h3>
            </div>

            <div class="box-body">
                <div class="row mb-xs">
                    <div class="col-md-12">
                        <div class="btn-toolbar" role="toolbar">
                            <div class="btn-group">
                                <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.exportReport()">
                                    <i class="fa fa-save"></i>
                                    Export status report
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <h4 class="text-primary mt-m">Database Schema status</h4>
                <div class="flex-table">
                    <div class="flex-header mt-xs">
                        <div class="flex-col flex-w-120 text-center">Status</div>
                        <div class="flex-col flex-2">Schema name</div>
                        <div class="flex-col flex-1">Schema version</div>
                    </div>
                    <div ng-repeat="schema in $vm.appConfig.schemaStatus" class="flex-table">
                        <div class="flex-row mt-xs">
                            <div class="flex-col flex-w-120 vertical centered">
                                <span class="label label-lg label-default" ng-class="{
                                        true: 'label-success',
                                        false: 'label-danger'}[schema.error === null]">{{schema.error === null ? 'OK' :
                                    'ERROR'}}</span>
                            </div>
                            <div class="flex-col flex-2">
                                <h4 class="media-heading text-primary">
                                    {{schema.name}}
                                </h4>
                                <div ng-if="schema.error" class="text-danger">
                                    <p>{{schema.error}}</p>
                                </div>
                            </div>

                            <div class="flex-col flex-1 vertical">
                                {{schema.currentVersion}}
                            </div>
                        </div>
                    </div>
                </div>

                <h4 class="text-primary mt-m">Data index status <small class="ml-m clickable"
                        ng-click="$vm.loadIndexStatus()"><i class="fa fa-refresh"></i> Reload</small></h4>
                <div class="empty-message" ng-if="$vm.loading.index">Loading index status...</div>
                <div class="flex-table" ng-show="!$vm.loading.index" ng-repeat="index in $vm.indexStatus.index">
                    <div class="flex-header mt-xs">
                        <div class="flex-col flex-3">
                            Index: <strong>{{index.name | uppercase}}</strong>

                            <a href class="text-primary mh-s" ng-click="$vm.reindex(index.name)">
                                <i class="fa fa-cog mr-xxxs"></i> Reindex the data
                            </a>
                            <a href class="text-danger" ng-click="$vm.rebuildIndex('all')">
                                <i class="fa fa-trash mr-xxxs"></i> Drop and rebuild the index
                            </a>

                        </div>
                        <div class="flex-col flex-1"># Entities</div>
                    </div>
                    <div class="flex-table" ng-repeat="item in index.indices">
                        <div class="flex-row mt-xs">
                            <div class="flex-col flex-3 vertical">
                                <h4 class="media-heading text-primary">
                                    {{item.name}}
                                </h4>
                            </div>

                            <div class="flex-col flex-1 vertical">
                                <span class="label label-lg label-default">
                                    {{item.count}}
                                </span>
                            </div>
                        </div>
                    </div>
                </div>


                <h4 class="text-primary mt-m">Database integrity check</h4>
                <div class="empty-message" ng-if="$vm.loading.check">Loading data health stats...</div>
                <div class="flex-table" ng-show="!$vm.loading.check">
                    <div class="flex-header mt-xs">
                        <div class="flex-col flex-1">Control name</div>
                        <div class="flex-col flex-w-100"></div>
                    </div>
                    <div ng-repeat="(checkName, data) in $vm.checkStats" class="flex-table">
                        <div class="flex-row mt-xs">
                            <div class="flex-col flex-1 vertical">
                                <h4 class="media-heading text-primary">
                                    {{checkName}}
                                </h4>
                            </div>

                            <div class="flex-col flex-w-100">
                                <a href class="text-primary" ng-click="$vm.checkControl(checkName)"><i
                                        class="fa fa-cog mr-xxxs"></i> Trigger</a>
                            </div>
                        </div>
                    </div>
                </div>


            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/profile/list.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="box">
            <div class="box-header with-border">
                <h3 class="box-title">List of profiles</h3>
            </div>
            <div class="box-body">
                <div ng-include="'views/partials/admin/profile/list/toolbar.html'"></div>

                <!-- Datalist  -->
                <div class="row mt-s">
                    <div class="col-md-12">
                        <table class="table table-striped case-list">
                            <thead>
                                <tr>
                                    <th style="width: 300px">Name</th>
                                    <th>Permissions</th>
                                    <th style="width: 150px"></th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr ng-repeat="profile in $vm.list | orderBy:'name'">
                                    <td>
                                        <div class="profile-name">
                                            {{::profile.name}}
                                        </div>
                                    </td>
                                    <td class="wrap">
                                        <span class="label label-default mr-xxs mb-xxs" ng-repeat="permission in profile.permissions | orderBy:identity">{{permission}}</span>
                                        <em class="text-warning" ng-if="!profile.permissions || profile.permissions.length === 0">No permissions</em>
                                    </td>
                                    <td class="text-left nowrap" ng-if="$vm.canDelete(profile)">
                                        <span class="clickable mr-xs text-primary nowrap" ng-click="$vm.showProfile('edit', profile)">
                                            <i class="fa fa-edit"></i>Edit</span>

                                        <span class="clickable mr-xs text-danger nowrap" ng-click="$vm.removeProfile(profile)">
                                            <i class="fa fa-trash"></i>Delete</span>
                                    </td>
                                    <td class="text-left" ng-if="!$vm.canDelete(profile)">
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/profile/list/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">
            <div class="btn-group">
                <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.showProfile('add')">
                    <i class="fa fa-plus"></i>
                    New Profile
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/profile/profile.modal.html`:

```html
<form class="form-horizontal" name="profileForm" ng-submit="$modal.ok()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">{{$modal.isEdit ? 'Update' : 'Add'}} profile</h3>
    </div>
    <div class="modal-body">
        <div class="form-group">
            <label class="col-sm-3 control-label">
                Profile type
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <div class="btn-group">
                    <label class="btn btn-primary" ng-model="$modal.formData.isAdmin" uib-btn-radio="true">Administration Profile</label>
                    <label class="btn btn-primary" ng-model="$modal.formData.isAdmin" uib-btn-radio="false">Organisation Profile</label>
                </div>
                <p class="help-block">{{$modal.permissions[$modal.formData.isAdmin ? 'admin' : 'org'].hints}}</p>
            </div>
        </div>
        <div class="form-group">
            <label class="col-sm-3 control-label">
                Name
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <input class="form-control" name="name"
                    ng-disabled="$modal.isEdit"
                    ng-model="$modal.formData.name"
                    required type="text">
            </div>
        </div>

        <div class="form-group">
            <label class="col-sm-3 control-label">
                Permissions
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-9">
                <select class="form-control" ng-model="$modal.formData.permissions"
                    ng-options="permission as ($modal.permissions[$modal.formData.isAdmin ? 'admin' : 'org'].labels[permission]) for permission in $modal.permissions[$modal.formData.isAdmin ? 'admin' : 'org'].keys" multiple size="15">
                </select>
                <div class="wrap">
                    Selected ({{$modal.formData.permissions.length || 0}})
                </div>
            </div>
        </div>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$modal.cancel()" type="button">Cancel</button>
        <span class="hpad10">
            <i class="fa fa-asterisk text-danger"></i>&nbsp;Required field</span>
        <button class="btn btn-primary pull-right" ng-disabled="profileForm.$invalid" type="submit">Save profile</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/taxonomy/import.html`:

```html
<form class="" name="form" ng-submit="$vm.ok()">
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Import taxonomies archive</h3>
    </div>
    <div class="modal-body">

        <div class="filter-panel mb-s">
            <h4>Download the official MISP taxonomies archive</h4>
            <p>You can download the latest archive of the official MISP Taxonomies <a target="_blank"
                    href="https://github.com/MISP/misp-taxonomies/archive/main.zip?version=TheHive-{{$vm.appConfig.versions.TheHive}}">from
                    here</a></p>
        </div>

        <div class="form-group">
            <label class="control-label">Taxonomies archive</label>
            <input type="hidden" name="attachment" ng-model="$vm.formData.attachment.status" required>
            <div file-chooser="" filemodel="$vm.formData.attachment"></div>

            <p class="help-block">
                The taxonomies archive must be a valid ZIP file containing at least one file names
                <em>machinetag.json</em>
            </p>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-default pull-left" type="button" ng-click="$vm.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="form.$invalid || !!$vm.loading">Yes,
            Import it</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/taxonomy/list.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="box">
            <div class="box-header with-border">
                <!-- <h3 class="box-title">List of taxonomies</h3> -->
                <datalist-header title="List of taxonomies" list="$vm.list" total="$vm.allTaxonomyCount">
                </datalist-header>
            </div>
            <div class="box-body">
                <div ng-include="'views/partials/admin/taxonomy/list/toolbar.html'"></div>

                <div class="mt-xs filter-panel" ng-include="'views/partials/admin/taxonomy/list/filters.html'"
                    ng-show="$vm.filtering.context.showFilters"></div>

                <div class="row mt-xs">
                    <div class="col-md-12 clearfix">

                        <filters-preview filters="$vm.filtering.context.filters" on-clear-item="$vm.removeFilter(field)"
                            on-clear-all="$vm.clearFilters()"></filters-preview>
                    </div>
                </div>

                <div class="row mv-s" ng-show="$vm.loading === false && $vm.list.values.length === 0">
                    <div class="col-md-12">
                        <div class="empty-message">No taxnomies found.</div>
                    </div>
                </div>

                <div class="row mv-s" ng-show="$vm.loading === true">
                    <div class="col-md-12">
                        <div class="loading-message">
                            <i class="fa fa-circle-o-notch fa-spin fa-fw"></i>
                            <span>loading taxonomies...</span>
                        </div>
                    </div>
                </div>

                <!-- Datalist  -->
                <div class="row mt-s" ng-if="$vm.loading === false && $vm.list.values.length > 0">
                    <psearch control="$vm.list"></psearch>

                    <div class="col-md-12">
                        <table class="table table-striped case-list">
                            <thead>
                                <tr>
                                    <th width="10"></th>
                                    <th width="300">Namespace</th>
                                    <th>Description</th>
                                    <th width="100" class="text-center">Version</th>
                                    <th width="80" class="text-center"># Tags</th>
                                    <th width="120"></th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr ng-repeat="taxonomy in $vm.list.values">
                                    <td>
                                        <span class="clickable"
                                            ng-click="$vm.addFilterValue('enabled', !!taxonomy.extraData.enabled)">
                                            <i class="fa" ng-class="{
                                                    true: 'text-tlp-green fa-circle',
                                                    false: 'text-tlp-red fa-circle',
                                                }[!!taxonomy.extraData.enabled]"></i>
                                        </span>
                                    </td>
                                    <td>
                                        <div class="taxonomy-name">
                                            <a href ng-click="$vm.show(taxonomy)">{{::taxonomy.namespace}}</a>
                                        </div>
                                    </td>
                                    <td class="wrap">
                                        {{::taxonomy.description}}
                                    </td>
                                    <td class="text-center">
                                        {{::taxonomy.version}}
                                    </td>
                                    <td class="text-center">
                                        {{::taxonomy.tags.length}}
                                    </td>
                                    <td class="clearfix">
                                        <div class="pull-right">
                                            <a class="btn btn-icon btn-clear" href ng-click="$vm.toggleActive(taxonomy)"
                                                uib-tooltip="{{!!taxonomy.extraData.enabled ? 'Disable taxonomy' : 'Enable taxonomy'}}">

                                                <i class="fa" ng-class="{
                                                    true: 'fa-times-circle text-danger',
                                                    false: 'fa-check-circle text-success'
                                                }[!!taxonomy.extraData.enabled]"></i>
                                            </a>

                                            <a class="btn btn-icon btn-clear" href ng-click="$vm.show(taxonomy)"
                                                uib-tooltip="Edit taxonomy">
                                                <i class="text-primary fa fa-search"></i>
                                            </a>

                                            <a class="btn btn-icon btn-clear" href ng-click="$vm.remove(taxonomy)"
                                                uib-tooltip="Delete taxonomy">
                                                <i class="text-danger fa fa-trash"></i>
                                            </a>
                                        </div>

                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <psearch control="$vm.list"></psearch>
                </div>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/taxonomy/list/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>
        <form ng-submit="$vm.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $vm.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$vm.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in $vm.filtering.attributeKeys"
                            ng-change="$vm.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$vm.filtering.metadata" filter="filter" entity="$vm.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$vm.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$vm.clearFilters()" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/partials/admin/taxonomy/list/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">
            <div class="btn-group">
                <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.import()">
                    <i class="fa fa-plus"></i>
                    Import taxonomies
                </button>
            </div>
            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]" type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/admin/taxonomy/view.html`:

```html
<form class="form">

    <div class="modal-header bg-primary">
        <h3 class="modal-title">{{::$modal.taxonomy.namespace}} taxonomy</h3>
    </div>

    <div class="modal-body">
        <div class="row">
            <div class="col-sm-6">
                <div class="form-group">
                    <label>Namespace</label>
                    <div>{{::$modal.taxonomy.namespace}}</div>
                </div>
            </div>
            <div class="col-sm-6">
                <div class="form-group">
                    <label>Version</label>
                    <div>{{::$modal.taxonomy.version}}</div>
                </div>
            </div>
        </div>

        <div class="form-group">
            <label>Description</label>
            <div>{{::$modal.taxonomy.description}}</div>
        </div>

        <div class="row">
            <div class="col-sm-12">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th class="pl-0" width="200">Tag</th>
                            <th>Predicate</th>
                            <th>Value</th>
                            <th width="100">Color</th>
                            <th width="10"></th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr ng-repeat="tag in $modal.taxonomy.tags">
                            <td>
                                <tag-item class="label-lg" value="tag"></tag-item>
                            </td>
                            <td>{{::tag.predicate}}</td>
                            <td>{{::tag.value || '-'}}</td>
                            <td>{{::tag.colour}}</td>
                            <td>
                                <span ng-if="::tag.description" uib-tooltip="{{::tag.description}}"
                                    tooltip-placement="left">
                                    <i class="fa fa-question-circle"></i>
                                </span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-default pull-left" type="button" ng-click="$modal.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="button" ng-click="$modal.cancel()">Close</button>
    </div>
</form>

```

`frontend/app/views/partials/admin/ui-settings.html`:

```html
<div class="row">
    <div class="col-md-12">
        <form name="settingsForm" class="form-horizontal" ng-submit="$vm.save(settingsForm)" novalidate>
            <div class="box">
                <div class="box-header">
                    <h3 class="box-title">UI Settings</h3>
                </div>
                <div class="box-body">

                    <div class="form-group">
                        <label class="col-md-3 control-label">Hide <em>Empty Case</em> button</label>
                        <div class="col-md-9">
                            <div class="checkbox">
                                <label>
                                  <input name="hideEmptyCaseButton" type="checkbox" ng-model="$vm.configs.hideEmptyCaseButton"> Check this to disallow creating empty cases
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="mt-s">
                        <button class="btn btn-primary pull-right" ng-disabled="settingsForm.$invalid" type="submit">Save</button>
                    </div>

                </div>
            </div>
        </form>
    </div>
</div>

```

`frontend/app/views/partials/afk-modal.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">Session expiration</h3>
</div>
<div class="modal-body">
    <div class="vpad20">
        The session is about to expire. If you are still connected, please click OK.
    </div>
</div>
<div class="modal-footer text-center">
    <button class="btn btn-primary" ng-click="ok()">OK</button>
</div>

```

`frontend/app/views/partials/alert/custom.fields.html`:

```html
<div class="case-custom-fields">
    <div ng-if="dialog.event.customFields.length === 0">
        <em>No additional information has been specified</em>
    </div>

    <div class="row">
        <div ng-repeat="customField in (dialog.event.customFields | orderBy:'order') track by $index" ng-init="fieldDef = dialog.customFieldsCache.getCache(customField.name);">
            <div class="clearfix" ng-if="$index % (appLayout.alertCustomFieldColumns || 2) == 0"></div>
            <div class="{{'col-xs-' + (12/(appLayout.alertCustomFieldColumns || 2))}}">
                <custom-field-input
                    index="$index"
                    editable="dialog.canEdit"
                    field="fieldDef"
                    on-update="dialog.updateField(fieldName, value)"
                    value="customField.value"></custom-field-input>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/alert/event.dialog.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">
        Alert Preview <span class="label label-default"
            ng-class="{'label-danger': !!!dialog.event.read}">{{dialog.event.caseId ? 'Imported' : 'New'}}</span>
    </h3>
</div>
<div class="modal-body">
    <div class="row text-center" ng-show="dialog.loading">
        <div class="m-s">
            <i class="fa fa-3x fa-spinner fa-spin"></i>
        </div>
        Loading...
    </div>
    <div class="row" ng-hide="dialog.loading">
        <div class="col-md-12">
            <div class="alert-details">
                <h4 class="text-primary">
                    <severity value="dialog.event.severity"></severity>
                    <span>{{dialog.event.title}}</span>
                </h4>
                <div class="mt-xxs">
                    <span>
                        <strong><i class="fa fa-copy"></i> ID: </strong>
                        <span class="clickable"><a
                                ng-click="dialog.copyId(dialog.event._id)">{{dialog.event._id}}</a></span>
                    </span>
                    <span class="ml-xxs">
                        <strong><i class="fa fa-calendar"></i> Date: </strong>
                        <span>{{dialog.event.date | shortDate}}</span>
                    </span>
                    <span class="ml-xxs">
                        <strong><i class="fa fa-certificate"></i> Type: </strong>
                        <span>{{dialog.event.type}}</span>
                    </span>
                    <span class="ml-xxs">
                        <strong><i class="fa fa-barcode"></i> Reference: </strong>
                        <span>{{dialog.event.sourceRef}}</span>
                    </span>
                    <span class="ml-xxs">
                        <strong><i class="fa fa-bullseye"></i> Source: </strong>
                        <span>{{dialog.event.source}}</span>
                    </span>
                </div>
                <!-- <div class="case-tags flexwrap mt-xxs">
                    <strong><i class="fa fa-tags mr-xxxs"></i></strong>
                    <strong class="text-muted mr-xxxs"
                        ng-if="!dialog.event.tags || dialog.event.tags.length === 0">None</strong>
                    <tag-item ng-repeat="tag in dialog.event.tags track by $index" value="tag"></tag-item>
                </div> -->

                <div class="mt-xs">
                    <h4 class="vpad10 text-primary">
                        Basic Information
                    </h4>
                    <dl class="dl-horizontal">
                        <dt class="pull-left">Tags</dt>
                        <dd ng-if="dialog.canEdit && !dialog.readonly">
                            <updatable-tag-list on-update="dialog.updateField('tags', dialog.getTags(newValue))"
                                value="dialog.event.tags" source="dialog.getAlertTags"></updatable-tag-list>
                        </dd>
                        <dd ng-if="!dialog.canEdit || dialog.readonly">
                            <tag-list data="dialog.event.tags"></tag-list>
                        </dd>
                    </dl>
                </div>

                <div class="mt-xs">
                    <h4 class="vpad10 text-primary">
                        Description
                    </h4>
                    <div class="description-pane" ng-if="!dialog.canEdit || dialog.readonly">
                        <div marked="dialog.event.description" class="markdown"></div>
                    </div>

                    <div class="description-pane" ng-if="dialog.canEdit && !dialog.readonly">
                        <updatable-text on-update="dialog.updateField('description', newValue)"
                            value="dialog.event.description"></updatable-text>
                    </div>
                </div>

                <div class="mt-xs">
                    <h4 class="vpad10 text-primary">
                        Additional fields

                        <span uib-dropdown class="ml-m">
                            <a href class="dropdown-toggle" uib-dropdown-toggle>
                                <small><i class="fa fa-columns"></i> Layout</small>
                            </a>
                            <ul class="dropdown-menu scroll-dropdown" uib-dropdown-menu>
                                <li ng-class="{'active': appLayout.alertCustomFieldColumns === 1}">
                                    <a ng-click="layoutSrv.alertCustomFields(1)">1 column</a>
                                </li>
                                <li ng-class="{'active': appLayout.alertCustomFieldColumns === 2}">
                                    <a ng-click="layoutSrv.alertCustomFields(2)">2 columns</a>
                                </li>
                                <li ng-class="{'active': appLayout.alertCustomFieldColumns === 3}">
                                    <a ng-click="layoutSrv.alertCustomFields(3)">3 columns</a>
                                </li>
                            </ul>
                        </span>
                    </h4>
                    <div ng-include="'views/partials/alert/custom.fields.html'"></div>
                </div>
            </div>


            <uib-tabset active="active" class="mt-xs nav-tabs-custom">
                <uib-tab index="0">
                    <uib-tab-heading>
                        <span>
                            <i class="mr-xxs glyphicon glyphicon-pushpin"></i>
                            Observables <span class="ml-xxs badge">{{dialog.counts.observables}}</span>
                        </span>
                    </uib-tab-heading>
                    <div>
                        <alert-observable-list alert-id="dialog.eventId"
                            on-list-load="dialog.updateObservableCount(count)"></alert-observable-list>
                    </div>
                </uib-tab>
                <uib-tab index="1">
                    <uib-tab-heading>
                        <span>
                            <i class="mr-xxs glyphicon glyphicon-link"></i>
                            Similar cases <span class="ml-xxs badge">{{dialog.counts.similarCases}}</span>
                        </span>
                    </uib-tab-heading>
                    <div>
                        <alert-similar-case-list alert-id="dialog.event._id" readonly="dialog.readonly"
                            on-list-load="dialog.updateSimilarCasesCount(count)"
                            on-merge-into-case="dialog.mergeIntoCase(caseId)"></alert-similar-case-list>
                    </div>
                </uib-tab>
            </uib-tabset>

        </div>
    </div>

</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="dialog.cancel()" type="button">Cancel</button>



    <button class="btn btn-default" type="button" ng-if="dialog.canMarkAsRead(dialog.event) && !dialog.readonly"
        ng-disabled="dialog.loading" ng-click="dialog.markAsRead(dialog.event)">
        <i class="fa fa-envelope"></i> Mark as read
    </button>
    <button class="btn btn-default" type="button" ng-if="dialog.canMarkAsUnread(dialog.event) && !dialog.readonly"
        ng-disabled="dialog.loading" ng-click="dialog.markAsRead(dialog.event)">
        <i class="fa fa-envelope-open-o"></i> Mark as unread
    </button>

    <button class="btn btn-default" type="button" ng-if="!dialog.readonly" ng-disabled="dialog.loading"
        ng-click="dialog.follow()">
        <i class="fa" ng-class="{'fa-eye': dialog.event.follow, 'fa-eye-slash': !dialog.event.follow}"></i>
        {{dialog.event.follow ? 'Ignore new updates' : 'Track new updates'}}
    </button>

    <button class="btn btn-default" type="button" ng-if="!dialog.readonly" ng-disabled="dialog.loading"
        ng-click="dialog.merge()">
        <i class="fa fa-compress"></i> Merge into case
    </button>

    <button ng-if="!dialog.readonly" class="btn btn-danger" type="button" ng-disabled="dialog.loading"
        ng-click="dialog.delete()">
        <i class="fa fa-trash"></i> Delete
    </button>

    <form ng-if="!dialog.readonly" name="eventForm" class="form-horizontal pull-right mr-xs" style="width:450px;"
        ng-submit="dialog.import()">
        <div class="form-group">
            <label class="col-sm-4 control-label">Import alert as</label>
            <div class="col-sm-8 input-group">
                <select class="form-control" ng-model="dialog.event.caseTemplate"
                    ng-options="template for template in dialog.templates | orderBy:displayName | orderBy:name">
                    <option value="" ng-if="dialog.templates.length === 0 || !!!dialog.hideEmptyCaseButton">-- Empty
                        case --
                    </option>
                </select>
                <span class="input-group-btn">
                    <button class="btn btn-primary" type="submit"
                        ng-disabled="dialog.loading || (!dialog.event.caseTemplate && !!dialog.hideEmptyCaseButton && dialog.templates.length > 0)"><i
                            class="fa fa-download"></i> Yes, Import</button>
                </span>
            </div>

        </div>
    </form>

    <!-- <div class="btn-group pull-right dropup" ng-disabled="dialog.loading">
        <button type="button" class="btn btn-primary">Import event</button>
        <button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        <span class="caret"></span>
      </button>
        <ul class="dropdown-menu">
            <li ng-repeat="tpl in dialog.templates">
                <a href>{{tpl}}</a>
            </li>
        </ul>
    </div> -->

</div>

```

`frontend/app/views/partials/alert/event.similarity.html`:

```html
<div class="mv-s">
    <span class="label label-lg label-default mr-xxs clickable"
        ng-click="dialog.filterSimilarCases('');"
        ng-class="{'label-primary': dialog.currentSimilarFilter===''}">All ({{dialog.event.similarCases.length || 0}})</span>

    <span class="label label-lg label-default mr-xxs clickable"
        ng-repeat="statsItem in dialog.similarCasesStats"
        ng-if="statsItem.value > 0"
        ng-click="dialog.filterSimilarCases(statsItem.key)"
        ng-class="{'label-primary': dialog.currentSimilarFilter===statsItem.key}">{{dialog.CaseResolutionStatus[statsItem.key] || statsItem.key}} ({{statsItem.value}})</span>
</div>

<div class="case-item">
    <div class="case-details text-bold">Title</div>
    <div class="case-date text-bold">Date</div>
    <div class="case-similarity text-bold">Observables</div>
    <div class="case-similarity text-bold">IOCs</div>
    <div class="case-similarity-merge text-bold">Action</div>
</div>

<div class="case-collection" ng-repeat="item in filteredLinks = (dialog.event.similarCases | filter:dialog.similarityFilters | orderBy:dialog.similaritySorts) ">
    <div class="case-item" >
        <!-- case severity -->
        <div class="case-tlp bg-tlp-{{item.tlp}}"></div>

        <!-- case title and main details -->
        <div class="case-details">
            <div class="case-title">
                <a ui-sref="app.case.details({caseId: item.id})" target="_blank">#{{item.caseId}} - {{item.title}}</a>
            </div>
            <div class="case-tags flexwrap mt-xxs">
                <span class="mr-xxxs text-muted"><i class="fa fa-tags"></i></span>
                <strong class="text-muted mr-xxxs" ng-if="!item.tags || item.tags.length === 0">None</strong>
                <span ng-repeat="tag in item.tags track by $index" class="label label-primary mb-xxxs mr-xxxs pointer">{{tag}}</span>
            </div>
            <div class="text-success" ng-show="item.status !== 'Open'">
                <small>
                    (Closed at {{item.endDate | shortDate}} as <strong>{{dialog.CaseResolutionStatus[item.resolutionStatus]}}</strong>)
                </small>
            </div>
            <div class="text-danger" ng-if="item.mergeFrom">
                <small>
                    Merged from <a href ui-sref="app.case.details({caseId: item.mergeFrom[0]})"> Case #{{item.stats.mergeFrom[0].caseId}}</a> and
                    <a href ui-sref="app.case.details({caseId: item.mergeFrom[1]})"> Case #{{utem.stats.mergeFrom[1].caseId}}</a>
                </small>
            </div>
        </div>

        <div class="case-severity">
            <div class="clickable">
                <severity active="false" value="item.severity"></severity>
            </div>
        </div>

        <div class="case-date">
            <span uib-tooltip="{{item.startDate | shortDate}}" tooltip-popup-delay="500" tooltip-placement="bottom">{{item.startDate | shortDate}}</span>
        </div>

        <div class="case-similarity">
            <div>
                <strong>{{(item.similarArtifactCount / item.artifactCount) | percentage:0}}</strong> ({{item.similarArtifactCount}} / {{item.artifactCount}})
                <uib-progressbar class="progress progress-sm" max="item.artifactCount" value="item.similarArtifactCount" type="primary"></uib-progressbar>
            </div>
        </div>
        <div class="case-similarity">
            <div ng-if="item.iocCount > 0">
                <strong>{{(item.similarIocCount / item.iocCount) | percentage:0}}</strong> ({{item.similarIocCount}} / {{item.iocCount}})
                <uib-progressbar class="progress progress-sm" max="item.iocCount" value="item.similarIocCount" type="danger"></uib-progressbar>
            </div>
            <div ng-if="item.iocCount === 0">
                <em>N/A</em>
            </div>
        </div>

        <div class="case-similarity-merge text-center">
            <button class="btn btn-sm btn-primary" ng-click="dialog.mergeIntoCase(item.id)">Merge in this case</button>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/alert/list.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="box">
            <div class="box-header with-border">
                <h3 class="box-title">
                    <datalist-header title="List of alerts" list="$vm.list" total="$vm.alertCountAll"></datalist-header>
                </h3>
            </div>
            <div class="box-body">
                <div ng-include="'views/partials/alert/list/toolbar.html'"></div>

                <div class="mt-xs stats-panel" ng-include="'views/partials/alert/list/mini-stats.html'"
                    ng-if="$vm.filtering.context.showStats"></div>

                <div class="mt-xs filter-panel" ng-include="'views/partials/alert/list/filters.html'"
                    ng-show="$vm.filtering.context.showFilters"></div>

                <!-- Filters preview  -->
                <div class="row mt-xs">
                    <div class="col-md-12 clearfix">
                        <filters-preview filters="$vm.filtering.context.filters" on-clear-item="$vm.removeFilter(field)"
                            on-clear-all="$vm.clearFilters()"></filters-preview>
                    </div>
                </div>

                <!-- Datalist  -->
                <div class="row mt-xs">

                    <div class="col-md-12 mv-s" ng-show="$vm.list.total === 0 && $vm.list.values.length === 0">
                        <div class="empty-message">No records</div>
                    </div>

                    <div class="col-md-12" ng-show="$vm.list.values.length !== 0">
                        <psearch control="$vm.list"></psearch>

                        <table class="table tbody-stripped case-list">
                            <thead>
                                <tr>
                                    <th width="20px" if-permission="manageAlert">
                                        <input type="checkbox" ng-model="$vm.menu.selectAll"
                                            ng-change="$vm.selectAll()">
                                    </th>
                                    <th width="80px">
                                        <a href class="text-default" ng-click="$vm.sortByField('severity')">
                                            Severity
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+severity') === -1 && $vm.filtering.context.sort.indexOf('-severity') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+severity') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-severity') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th width="80px" class="text-center">
                                        <a href class="text-default" ng-click="$vm.sortByField('read')">
                                            Read
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+read') === -1 && $vm.filtering.context.sort.indexOf('-read') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+read') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-read') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th>
                                        Title
                                    </th>
                                    <th width="80px" class="text-center">
                                        # Case
                                    </th>
                                    <th width="80px">
                                        <a href class="text-default" ng-click="$vm.sortByField('type')">
                                            Type
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+type') === -1 && $vm.filtering.context.sort.indexOf('-type') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+type') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-type') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>

                                    <th width="150px">
                                        <a href class="text-default" ng-click="$vm.sortByField('source')">
                                            Source
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+source') === -1 && $vm.filtering.context.sort.indexOf('-source') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+source') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-source') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th width="150px">
                                        <a href class="text-default" ng-click="$vm.sortByField('sourceRef')">
                                            Reference
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+sourceRef') === -1 && $vm.filtering.context.sort.indexOf('-sourceRef') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+sourceRef') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-sourceRef') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>

                                    <th width="80px">
                                        Observables
                                    </th>
                                    <th style="width: 150px">
                                        Dates

                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('date')"
                                            uib-tooltip="Sort by occur date">
                                            O.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+date') === -1 && $vm.filtering.context.sort.indexOf('-date') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+date') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-date') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_createdAt')"
                                            uib-tooltip="Sort by creation date">
                                            C.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') === -1 && $vm.filtering.context.sort.indexOf('-_createdAt') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-_createdAt') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_updatedAt')"
                                            uib-tooltip="Sort by last update date">
                                            U.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') === -1 && $vm.filtering.context.sort.indexOf('-_updatedAt') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-_updatedAt') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 160px"></th>
                                </tr>
                            </thead>

                            <tbody ng-repeat="event in $vm.list.values">
                                <tr>
                                    <td if-permission="manageAlert">
                                        <input type="checkbox" ng-model="event.selected" ng-change="$vm.select(event)">
                                    </td>

                                    <td class="text-center">
                                        <div class="clickable"
                                            ng-click="$vm.addFilterValue('severity', event.severity)">
                                            <severity active="false" value="event.severity"></severity>
                                        </div>
                                    </td>
                                    <td align="center">
                                        <span class="clickable label label-default"
                                            ng-class="{'label-danger': !!!event.read}"
                                            ng-click="$vm.addFilterValue('read', !!event.read)">{{event.read ?
                                            'Read' :
                                            'Unread'}}</span>
                                    </td>
                                    <td class="wrap">
                                        <div class="case-title">
                                            <span>
                                                <span ng-if="!event.caseId">{{::event.title}}</span>
                                                <span ng-if="event.caseId"
                                                    ui-sref="app.case.details({caseId: event.caseId})">
                                                    <a href>{{::event.title}}</a>
                                                </span>
                                            </span>
                                        </div>
                                    </td>
                                    <td>
                                        <div ng-if="!!!event.caseId" class="text-center">
                                            <span class="clickable label label-default"
                                                ng-click="$vm.addFilterValue('imported', !!event.caseId)">None</span>
                                        </div>
                                        <div ng-if="!!event.caseId" class="text-center">
                                            <a href ui-sref="app.case.details({caseId: event.caseId})"
                                                uib-tooltip="View case">#{{event.extraData.caseNumber}}</a>
                                        </div>

                                    </td>
                                    <td>
                                        <span>
                                            <a href
                                                ng-click="$vm.addFilterValue('type', event.type)">{{::event.type}}</a></span>
                                    </td>

                                    <td>
                                        <a href
                                            ng-click="$vm.addFilterValue('source', event.source)">{{event.source}}</a>
                                    </td>
                                    <td class="wrap">
                                        <strong>
                                            <span>{{::event.sourceRef}}</span>

                                            <span ng-if="event.externalLink" class="pl-xxs">
                                                <a ng-href="{{event.externalLink}}" target="_blank"
                                                    uib-tooltip="Open alert's external link">
                                                    <i class="fa fa-external-link"></i>
                                                </a>
                                            </span>
                                        </strong>

                                    </td>
                                    <td class="text-center">{{::event.observableCount || 0}}</td>
                                    <td rowspan="3">
                                        <div
                                            ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+date') !== -1 || $vm.filtering.context.sort.indexOf('-date') !== -1}">
                                            O. <a href ng-click="$vm.addFilterValue('date', event.date)">{{event.date |
                                                shortDate}}</a>
                                        </div>
                                        <div
                                            ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_createdAt') !== -1 || $vm.filtering.context.sort.indexOf('-_createdAt') !== -1}">
                                            C. <a href
                                                ng-click="$vm.addFilterValue('_createdAt', event._createdAt)">{{event._createdAt
                                                | shortDate}}</a>
                                        </div>
                                        <div ng-if="event._updatedAt > 0"
                                            ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_updatedAt') !== -1 || $vm.filtering.context.sort.indexOf('-_updatedAt') !== -1}">
                                            U. <a href
                                                ng-click="$vm.addFilterValue('_updatedAt', event._updatedAt)">{{event._updatedAt
                                                | shortDate}}</a>
                                        </div>

                                        <div ng-if="!!event.caseId">
                                            <alert-duration start="event._createdAt" end="event.extraData.importDate"
                                                icon="fa-clock-o"></alert-duration>
                                        </div>
                                    </td>
                                    <td class="clearfix">
                                        <div class="pull-right" if-permission="manageAlert">
                                            <a class="btn btn-icon btn-clear" href ng-click="$vm.follow(event)"
                                                uib-tooltip="{{event.follow ? 'Ignore new updates' : 'Track new updates'}}">
                                                <i class="text-info fa"
                                                    ng-class="{'fa-eye': event.follow, 'fa-eye-slash': !event.follow}"></i>
                                            </a>
                                            <a class="btn btn-icon btn-clear" href ng-click="$vm.markAsRead(event)"
                                                uib-tooltip="Mark as read" ng-if="$vm.canMarkAsRead(event)">
                                                <i class="text-info fa fa-envelope"></i>
                                            </a>
                                            <a class="btn btn-icon btn-clear" href ng-click="$vm.markAsRead(event)"
                                                uib-tooltip="Mark as unread" ng-if="$vm.canMarkAsUnread(event)">
                                                <i class="text-info fa fa-envelope-open-o"></i>
                                            </a>
                                            <a class="btn btn-icon btn-clear" href
                                                ng-click="$vm.getResponders(event, true)" uib-tooltip="Run responders"
                                                ng-if="appConfig.connectors.cortex.enabled"
                                                if-permission="manageAction">
                                                <i class="text-info fa fa-cog"></i>
                                            </a>
                                        </div>

                                        <div class="pull-right">
                                            <a class="btn btn-icon btn-clear" href ng-click="$vm.import(event, false)"
                                                uib-tooltip="Preview and Import" ng-if="!event.caseId">
                                                <i class="text-info fa fa-file-text-o"></i>
                                            </a>
                                            <a class="btn btn-icon btn-clear" href ng-click="$vm.import(event, true)"
                                                uib-tooltip="Preview" ng-if="!!event.caseId">
                                                <i class="text-info fa fa-file-text-o"></i>
                                            </a>
                                            <!-- <a class="btn btn-icon btn-clear" href
                                                ui-sref="app.case.details({caseId: event.caseId})"
                                                uib-tooltip="View case" ng-if="event.caseId">
                                                <i class="text-info fa fa-search"></i>
                                            </a> -->
                                        </div>
                                    </td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td colspan="8">
                                        <div class="case-tags flexwrap">
                                            <span class="mr-xxxs text-muted"><i class="fa fa-tags"></i></span>
                                            <strong class="text-muted mr-xxxs"
                                                ng-if="!event.tags || event.tags.length === 0">None</strong>
                                            <tag-item ng-repeat="tag in event.tags track by $index" class="pointer"
                                                ng-click="$vm.addFilterValue('tags', tag)" value="tag"></tag-item>
                                        </div>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr ng-if="$vm.filtering.context.showAdvanced">
                                    <td></td>
                                    <td colspan="8">
                                        <custom-field-labels custom-fields="event.customFields"
                                            on-field-click="$vm.addFilterValue(name, value)">
                                            <custom-field-labels>
                                    </td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>

                        <psearch control="$vm.list"></psearch>
                    </div>
                </div>



            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/alert/list/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>

        <form ng-submit="$vm.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $vm.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$vm.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in $vm.filtering.attributeKeys"
                            ng-change="$vm.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$vm.filtering.metadata" filter="filter" entity="$vm.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$vm.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$vm.clearFilters()" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/partials/alert/list/mini-stats.html`:

```html
<div class="row" ng-controller="AlertStatsCtrl as statsCtrl">
    <div class="col-md-4">
        <div class="stats-item-wrapper">
            <stats-item title="Alerts by Status" mode="'chart'" field="read" data="statsCtrl.byStatus.details" labels="statsCtrl.readAlerts" values="statsCtrl.readValues" on-item-clicked="$vm.addFilterValue(field, value)">
            </stats-item>

        </div>
    </div>

    <div class="col-md-4">
        <div class="stats-item-wrapper">
            <stats-item title="Top 5 Types" mode="'chart'" field="type" data="statsCtrl.byType.details" on-item-clicked="$vm.addFilterValue(field, value)">
            </stats-item>
        </div>
    </div>

    <div class="col-md-4">
        <div class="stats-item-wrapper">
            <stats-item title="Top 5 tags" mode="'chart'" field="tags" data="statsCtrl.byTags.details" on-item-clicked="$vm.addFilterValue(field, value)">
            </stats-item>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/alert/list/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <div class="btn-group" uib-dropdown if-permission="manageAlert">
                <button type="button" class="btn btn-sm btn-default" uib-dropdown-toggle ng-disabled="$vm.selection.length === 0">
                    <ng-pluralize count="$vm.selection.length" when="{'0': 'No event selected', 'one': '{} selected event', 'other': '{} selected events'}"></ng-pluralize>
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <!--
                        <li>
                            <a ng-click="$vm.bulkImport()">Import</a>
                        </li>
                        -->
                    <li ng-show="$vm.menu.follow">
                        <a href ng-click="$vm.bulkFollow(true)"><i class="fa fa-eye"></i> Track new updates</a>
                    </li>
                    <li ng-show="$vm.menu.unfollow">
                        <a href ng-click="$vm.bulkFollow(false)"><i class="fa fa-eye-slash"></i> Ignore new updates</a>
                    </li>
                    <li ng-show="$vm.menu.markAsRead">
                        <a href ng-click="$vm.bulkMarkAsRead(true)"><i class="fa fa-envelope-open-o"></i> Mark as read</a>
                    </li>
                    <li ng-show="$vm.menu.markAsUnread">
                        <a href ng-click="$vm.bulkMarkAsRead(false)"><i class="fa fa-envelope"></i> Mark as unread</a>
                    </li>
                    <li ng-show="$vm.menu.delete">
                        <a href ng-click="$vm.bulkDelete()" class="text-danger">
                            <i class="fa fa-trash-o"></i> Delete
                        </a>
                    </li>
                    <li class="divider" ng-show="$vm.menu.createNewCase"></li>
                    <li ng-show="$vm.menu.createNewCase">
                        <a href ng-click="$vm.createNewCase()"><i class="fa fa-file-o"></i> New case from selection</a>
                    </li>
                    <li ng-show="$vm.menu.mergeInCase">
                        <a href ng-click="$vm.mergeInCase()"><i class="fa fa-compress"></i> Merge selection into case</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group" uib-dropdown>
                <button class="btn btn-sm btn-primary dropdown-toggle" uib-dropdown-toggle type="button">
                    <i class="fa fa-filter"></i>
                    Quick Filters
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a class="clickable" ng-click="$vm.filterBy('read', true)"><i class="fa fa-envelope-open-o"></i> Read events</a>
                    </li>
                    <li>
                        <a class="clickable" ng-click="$vm.filterBy('read', false)"><i class="fa fa-envelope"></i> Unread events</a>
                    </li>
                    <li>
                        <a class="clickable" ng-click="$vm.filterByStatus(true)"><i class="fa fa-download"></i> Imported events</a>
                    </li>
                    <li>
                        <a class="clickable" ng-click="$vm.filterBy('follow', true)"><i class="fa fa-eye"></i> Followed events</a>
                    </li>
                    <li>
                        <a class="clickable" ng-click="$vm.filterBy('follow', false)"><i class="fa fa-eye-slash"></i> Ignored events</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group" uib-dropdown>
                <button class="btn btn-sm btn-primary dropdown-toggle" uib-dropdown-toggle type="button">
                    <i class="fa fa-sort"></i>
                    Sort by
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a ng-click="$vm.sortBy(['-date'])">Newest first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['+date'])">Oldest first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-severity'])">High Severity first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['+severity'])">Low Severity first</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]" type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showStats]" type="button" ng-click="$vm.toggleStats()">
                    <i class="fa fa-bar-chart"></i> Stats
                </button>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[!!$vm.filtering.context.showAdvanced]" type="button" ng-click="$vm.toggleAdvanced()">
                    <i class="fa fa-code"></i> Custom Fields
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/case/case.add.field.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">Add custom field to Case #{{caze.number}}</h3>
</div>
<div class="modal-body">
    <div class="vpad20">
        You are about to add the <strong uib-tooltip="{{data.description}}">{{data.name}}</strong> custom field to the case <strong>#{{caze.number}}: {{caze.title}}</strong>
        <br/>
        <br/>
        Are you sure you want to continue ?
    </div>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
    <button class="btn btn-primary pull-right" type="button" ng-click="confirm()">Confirm</button>
</div>

```

`frontend/app/views/partials/case/case.alerts.html`:

```html
<div class="row" ng-show="alerts.length === 0">
    <div class="col-md-12">
        <div class=" empty-message">No records</div>
    </div>
</div>

<div class="case-links" ng-show="alerts.length > 0"
    ng-init="filteredLinks = (alerts | filter:filtering | orderBy:sorting.field)">
    <div class="mv-s" ng-if="alertStats">
        <span class="label label-lg label-default mr-xxs clickable" ng-click="filterBy('');"
            ng-class="{'label-primary': currentFilter===''}">All ({{alerts.length || 0}})</span>

        <span><strong>Type:</strong></span>
        <span class="label label-lg label-default mr-xxs clickable" ng-repeat="statsItem in alertStats.type"
            ng-click="filterBy('type', statsItem.key)"
            ng-class="{'label-primary': currentFilter===statsItem.key}">{{statsItem.key}} ({{statsItem.value}})</span>

        <span><strong>Source:</strong></span>
        <span class="label label-lg label-default mr-xxs clickable" ng-repeat="statsItem in alertStats.source"
            ng-click="filterBy('source', statsItem.key)"
            ng-class="{'label-primary': currentFilter===statsItem.key}">{{statsItem.key}} ({{statsItem.value}})</span>
    </div>

    <div class="row" ng-show="filteredAlerts.length === 0">
        <div class="col-md-12">
            <div class=" empty-message">No records</div>
        </div>
    </div>

    <table class="table tbody-stripped case-list" ng-show="alerts.length > 0">
        <thead>
            <tr>
                <th width="150px">
                    <a href class="text-default" ng-click="sortBy('sourceRef')">
                        Reference
                        <i ng-show="sorting.field !== '+sourceRef' && sorting.field !== '-sourceRef'"
                            class="fa fa-sort"></i>
                        <i ng-show="sorting.field === '+sourceRef'" class="fa fa-caret-up"></i>
                        <i ng-show="sorting.field === '-sourceRef'" class="fa fa-caret-down"></i>
                    </a>
                </th>
                <th width="160px">
                    <a href class="text-default" ng-click="sortBy('type')">
                        Type
                        <i ng-show="sorting.field !== '+type' && sorting.field !== '-type'" class="fa fa-sort"></i>
                        <i ng-show="sorting.field === '+type'" class="fa fa-caret-up"></i>
                        <i ng-show="sorting.field === '-type'" class="fa fa-caret-down"></i>
                    </a>
                </th>
                <th>
                    <a href class="text-default" ng-click="sortBy('title')">
                        Title
                        <i ng-show="sorting.field !== '+title' && sorting.field !== '-title'" class="fa fa-sort"></i>
                        <i ng-show="sorting.field === '+title'" class="fa fa-caret-up"></i>
                        <i ng-show="sorting.field === '-title'" class="fa fa-caret-down"></i>
                    </a>
                </th>
                <th width="150px">
                    <a href class="text-default" ng-click="sortBy('source')">
                        Source
                        <i ng-show="sorting.field !== '+source' && sorting.field !== '-source'" class="fa fa-sort"></i>
                        <i ng-show="sorting.field === '+source'" class="fa fa-caret-up"></i>
                        <i ng-show="sorting.field === '-source'" class="fa fa-caret-down"></i>
                    </a>
                </th>
                <th width="80px">
                    <a href class="text-default" ng-click="sortBy('severity')">
                        Severity
                        <i ng-show="sorting.field !== '+severity' && sorting.field !== '-severity'"
                            class="fa fa-sort"></i>
                        <i ng-show="sorting.field === '+severity'" class="fa fa-caret-up"></i>
                        <i ng-show="sorting.field === '-severity'" class="fa fa-caret-down"></i>
                    </a>
                </th>
                <th width="80px">
                    Attributes
                </th>
                <th style="width: 160px">
                    <a href class="text-default" ng-click="sortBy('date')">
                        Date
                        <i ng-show="sorting.field !== '+date' && sorting.field !== '-date'" class="fa fa-sort"></i>
                        <i ng-show="sorting.field === '+date'" class="fa fa-caret-up"></i>
                        <i ng-show="sorting.field === '-date'" class="fa fa-caret-down"></i>
                    </a>
                </th>
                <th style="width: 60px"></th>
            </tr>
        </thead>
        <tbody ng-repeat="event in filteredAlerts = (alerts | filter:filtering | orderBy:sorting.field)">
            <tr>
                <td class="wrap">
                    <strong>
                        <span>{{::event.sourceRef}}</span>
                        <span ng-if="event.type === 'misp'" class="pl-xxs">
                            <a ng-href="{{mispUrls[event.source]}}/events/{{event.sourceRef}}" target="_blank">
                                <i class="fa fa-external-link"></i>
                            </a>
                        </span>
                    </strong>
                </td>
                <td>
                    <span>{{::event.type}}</span>
                </td>
                <td class="wrap">
                    <div class="case-title">
                        <span>{{::event.title}}</span>
                    </div>
                </td>
                <td>{{::event.source}}</td>
                <td class="text-center">
                    <div>
                        <severity active="false" value="event.severity"></severity>
                    </div>
                </td>
                <td class="text-center">{{::event.observableCount || 0}}</td>
                <td>{{event.date | shortDate}}</td>
                <td>
                    <a class="btn btn-xs btn-icon btn-clear" href ng-click="previewEvent(event)" uib-tooltip="Preview">
                        <i class="text-info text-20 fa fa-file-text-o"></i>
                    </a>
                </td>
            </tr>
            <tr>
                <td colspan="7">
                    <div class="case-tags flexwrap">
                        <span class="mr-xxxs text-muted"><i class="fa fa-tags"></i></span>
                        <strong class="text-muted mr-xxxs" ng-if="!event.tags || event.tags.length === 0">None</strong>
                        <span ng-repeat="tag in event.tags track by $index"
                            class="label label-primary mb-xxxs mr-xxxs pointer">{{tag}}</span>
                    </div>
                </td>
                <td></td>
            </tr>
            <tr>
                <td colspan="7">
                    <custom-field-labels custom-fields="event.customFields">
                        <custom-field-labels>
                </td>
                <td></td>
            </tr>
        </tbody>
    </table>
</div>

```

`frontend/app/views/partials/case/case.bulk.delete.confirm.html`:

```html
<form name="removeForm" ng-submit="$dialog.confirm()">
    <div class="modal-header bg-danger">
        <h3 class="modal-title">Permanently remove selected cases</h3>
    </div>
    <div class="modal-body">
        <p>Are you sure you want to permanently delete the following <b>{{$dialog.selection.length}}</b> case(s)?</p>

        <div class="mt-xs">
            <table class="table table-striped">
                <tr ng-repeat="item in $dialog.selection">
                    <td>#{{item.number}} - {{item.title}}</td>
                </tr>
            </table>
        </div>

        <div class="mt-xs">
            <p><b>To confirm, please type the number of cases to delete.</b></p>

            <input class="form-control input-lg" name="count" type="number" placeholder="{{$dialog.count}}"
                ng-required ng-model="$dialog.typedCount">

            <p><b class="text-danger">This action might take a while and cannot be undone.</b></p>
        </div>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$dialog.cancel()" ng-disabled="$dialog.loading" type="button">Cancel</button>
        <button class="btn btn-danger pull-right" type="submit"
            ng-disabled="$dialog.loading || removeForm.$invalid || ($dialog.count != $dialog.typedCount)">
            Yes, confirm.
        </button>
    </div>
</form>

```

`frontend/app/views/partials/case/case.close.html`:

```html
<form class="form-horizontal" name="caseCloseForm" ng-submit="closeCase(caseCloseForm.$valid);" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Close Case #{{caze.number}}</h3>
    </div>
    <div class="modal-body">
        <div ng-show="!tasksValid">
            <div align="center" class="alert alert-danger">
                <i class="glyphicon glyphicon-exclamation-sign"></i>
                This case contains the following open or unassigned tasks. Closing the case will permanently remove the unassigned ones.
                <br>
                This action cannot be undone.
            </div>
            <table class="table table-hover">
                <thead>
                    <tr>
                        <th style="width: 40px"></th>
                        <th>Task</th>
                        <th style="width: 250px">Assignee</th>
                    </tr>
                </thead>
                <tbody ng-repeat="task in tasks">
                    <tr ng-if="task.status == 'Completed'">
                        <td align="center">
                            <i class="text-success glyphicon glyphicon-ok"></i>
                        </td>
                        <td>{{task.title}}</td>
                        <td><user-info value="task.owner" field="name"></user-info><br>{{task.startDate | shortDate}}</td>
                    </tr>

                    <tr ng-if="task.status == 'InProgress'" ng-class="{true:'warning'}[task.flag]">
                        <td align="center">
                            <i class=" glyphicon" ng-class="{true:'text-yellow glyphicon-flag', false:'text-primary glyphicon-play'}[task.flag]"></i>
                        </td>
                        <td>{{task.title}}</td>
                        <td><user-info value="task.owner" field="name"></user-info><br>{{task.startDate | shortDate}}</td>
                    </tr>

                    <tr ng-if="task.status == 'Waiting'">
                        <td align="center"></td>
                        <td>{{task.title}}</td>
                        <td>
                            <em>Not assigned</em>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div ng-show="tasksValid === true">
            <div align="center" class="alert alert-danger">
                <i class="glyphicon glyphicon-exclamation-sign"></i>
                You are about to close Case #{{caze.number}}. Are you sure you want to continue ?
            </div>

            <div class="row">
                <div class="col-sm-9 col-sm-offset-3">
                    <div class="indicent-header">
                        <h2 class="background"><span>Incident</span></h2>
                    </div>
                </div>
            </div>
            <div class="form-group">
                <label class="col-sm-3 control-label">Status
                    <i class="fa fa-asterisk text-danger"></i>
                </label>
                <div class="col-sm-9">
                    <div class="btn-toolbar" role="toolbar">
                        <div class="btn-group">
                            <label uib-btn-radio="'TruePositive'" class="btn btn-default" name="resolutionStatus" ng-model="formData.resolutionStatus">{{CaseResolutionStatus.TruePositive}}</label>
                            <label uib-btn-radio="'FalsePositive'" class="btn btn-default" name="resolutionStatus " ng-model="formData.resolutionStatus">{{CaseResolutionStatus.FalsePositive}}</label>
                            <label uib-btn-radio="'Indeterminate'" class="btn btn-default" name="resolutionStatus" ng-model="formData.resolutionStatus">{{CaseResolutionStatus.Indeterminate}}</label>
                        </div>
                        <div class="btn-group" role="group">
                            <label uib-btn-radio="'Other'" class="btn btn-default" name="resolutionStatus" ng-model="formData.resolutionStatus">{{CaseResolutionStatus.Other}}</label>
                        </div>
                    </div>
                    <p class="help-block" ng-switch="formData.resolutionStatus">
                        <i class="fa fa-question-circle"></i>
                        <span ng-switch-when="TruePositive">
                            Investigation clearly demonstrates that there is something malicious (scam, phishing, malspam, malware, cybersquatting...)
                        </span>
                        <span ng-switch-when="FalsePositive">
                            Investigation shows that there is nothing malicious (email with clean attachment ...)
                        </span>
                        <span ng-switch-when="Indeterminate">
                            There aren't enough elements to tell that there is something malicious (original message has been deleted and not transmitted, IOC lookup with 0 hits ...)
                        </span>
                        <span ng-switch-when="Other">
                            Everything that does not require an investigation (not an incident)
                        </span>
                    </p>
                </div>
            </div>
            <div class="form-group" ng-show="formData.resolutionStatus==='TruePositive'" ng-class="{ 'has-error' : caseCloseForm.tempImpactStatus.$invalid}">
                <label class="col-sm-3 control-label">Impact
                    <i class="fa fa-asterisk text-danger"></i>
                </label>
                <div class="col-sm-9">
                    <input type="hidden" name="tempImpactStatus" ng-model="formData.impactStatus" ng-required="formData.resolutionStatus==='TruePositive'" />
                    <div class="btn-group radio-group">
                        <label uib-btn-radio="'WithImpact'" class="btn btn-default" name="impactStatus" ng-model="formData.impactStatus">Yes</label>
                        <label uib-btn-radio="'NoImpact'" class="btn btn-default" name="impactStatus" ng-model="formData.impactStatus">No</label>
                    </div>
                    <p class="help-block" ng-switch="formData.impactStatus" ng-show="formData.impactStatus">
                        <i class="fa fa-question-circle"></i>
                        <span ng-switch-when="WithImpact">
                            Something altered availability, integrity or confidentiality
                        </span>
                        <span ng-switch-when="NoImpact">
                            Security measures blocked the attack or infection
                        </span>
                    </p>
                    <p class="help-block" ng-show="caseCloseForm.tempImpactStatus.$invalid">This field is required</p>
                </div>
            </div>
            <div class="form-group" ng-class="{ 'has-error' : caseCloseForm.summary.$invalid && !caseCloseForm.summary.$pristine }">
                <label class="col-sm-3 control-label">Summary
                    <i class="fa fa-asterisk text-danger"></i>
                </label>
                <div class="col-sm-9">
                    <textarea class="content-box" name="summary" placeholder="Close summary" markdown-editor="{'fullscreen': {enable: false}, 'iconlibrary': 'fa', addExtraButtons: true, resize: 'vertical'}" rows="6" ng-model="formData.summary" required></textarea>
                    <p class="help-block" ng-show="caseCloseForm.summary.$invalid && !caseCloseForm.summary.$pristine">The case summary is required.</p>
                </div>
            </div>
            <!-- Custom Fields -->
            <div class="form-group" ng-repeat="cf in mandatoryFields" ng-init="fieldDef = customFieldsSrv.getCache(cf.name);"
                ng-class="{ 'has-error' : caseCloseForm['customFields.' + cf.name].$invalid && !caseCloseForm['customFields.' + cf.name].$pristine }">
                <label class="col-sm-3 control-label" uib-tooltip="{{fieldDef.description}}">{{fieldDef.name}}
                    <i class="fa fa-asterisk text-danger"></i>
                </label>

                <div class="col-sm-3" ng-if="fieldDef.options.length > 0">
                    <select class="form-control" name="{{'customFields.' + cf.name}}" ng-model="cf.value" ng-options="v for v in fieldDef.options" required>
                        <option value=""></option>
                    </select>
                    <p class="help-block" ng-show="caseCloseForm['customFields.' + cf.name].$invalid && !caseCloseForm['customFields.' + cf.name].$pristine">This field is required.</p>
                </div>
                <div class="col-sm-3" ng-if="fieldDef.options.length === 0" ng-switch="cf.type">
                    <input ng-switch-when="string" name="{{'customFields.' + cf.name}}" type="text" class="form-control" ng-model="cf.value" required>
                    <input ng-switch-when="integer" name="{{'customFields.' + cf.name}}" type="number" step="1" class="form-control" ng-model="cf.value" required>
                    <input ng-switch-when="float" name="{{'customFields.' + cf.name}}" type="number" step=".01" class="form-control" ng-model="cf.value" required>
                    <select ng-switch-when="boolean" name="{{'customFields.' + cf.name}}" class="form-control" ng-model="cf.value" ng-options="v for v in [true, false]" required>
                        <option value=""></option>
                    </select>
                    <dt-picker ng-switch-when="date" name="{{'customFields.' + cf.name}}" date="cf.value" required="true"></dt-picker>
                    <p class="help-block" ng-show="caseCloseForm['customFields.' + cf.name].$invalid && !caseCloseForm['customFields.' + cf.name].$pristine">This field is required.</p>
                </div>

            </div>
        </div>

    </div>
    <div class="modal-footer text-left" ng-show="!tasksValid">
        <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
        <button class="btn btn-primary pull-right" ng-disabled="tasksValid" type="button" ng-click="confirmTaskClose()">Close tasks and case</button>
    </div>
    <div class="modal-footer text-left" ng-show="tasksValid === true">
        <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
        <span class="btn"><i class="fa fa-asterisk text-danger"></i>&nbsp;Required field</span>
        <button class="btn btn-primary pull-right" ng-disabled="caseCloseForm.$invalid" type="submit">Close case</button>
    </div>
</form>

```

`frontend/app/views/partials/case/case.creation.html`:

```html
<form name="caseCreateForm" ng-submit="createNewCase(caseCreateForm.$valid);" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Create a new case</h3>
    </div>
    <div class="modal-body">
        <h4 class="vpad10 text-primary">Case details</h4>
        <div class="row">
            <div class="col-md-6">
                <div class="form-group" ng-class="{ 'has-error' : caseCreateForm.title.$invalid && !caseCreateForm.title.$pristine }">
                    <label class="control-label">Title
                        <i class="fa fa-asterisk text-danger"></i>
                    </label>
                    <div>
                        <input class="form-control input-sm" name="title" ng-if="!fromTemplate" ng-model="newCase.title" placeholder="Title" required type="text"/>

                        <div class="input-group" ng-if="fromTemplate">
                            <span class="input-group-addon">{{template.titlePrefix}}</span>
                            <input class="form-control input-sm" name="title" ng-model="newCase.title" placeholder="Title" required type="text"/>
                        </div>

                        <p class="help-block" ng-show="caseCreateForm.title.$invalid && !caseCreateForm.title.$pristine">The case title is required.</p>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="form-group" ng-class="{ 'has-error' : caseCreateForm.startDate.$invalid && !caseCreateForm.startDate.$pristine }">
                    <label class="control-label">Date
                        <i class="fa fa-asterisk text-danger"></i>
                    </label>
                    <div>
                        <date-time-picker date="newCase.startDate" name="startDate"></date-time-picker>
                        <p class="help-block" ng-show="caseCreateForm.startDate.$invalid && !caseCreateForm.startDate.$pristine">The case start date is required.</p>
                    </div>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-md-4">
                <div class="form-group">
                    <label class="control-label">Severity
                        <i class="fa fa-asterisk text-danger"></i>
                    </label>
                    <div>
                        <severity active="active" value="newCase.severity"></severity>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="form-group">
                    <label class="control-label">TLP
                        <i class="fa fa-asterisk text-danger"></i>
                    </label>
                    <div>
                        <a href ng-click="activeTlp='active'">
                            <tlp format="activeTlp" on-update="updateTlp(newValue)" value="newCase.tlp"></tlp>
                        </a>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="form-group">
                    <label class="control-label">PAP
                        <i class="fa fa-asterisk text-danger"></i>
                    </label>
                    <div>
                        <a href ng-click="activePap='active'">
                            <tlp format="activePap" on-update="updatePap(newValue)" value="newCase.pap" namespace="PAP"></tlp>
                        </a>
                    </div>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-md-12">
                <div class="form-group">
                    <label class="control-label">Tags</label>

                    <div class="input-group">
                        <tags-input class="ti-input-sm input-sm form-control form-control-wrapper ti-tag-selector"
                            name="tags"
                            placeholder="Case tags"
                            min-length="2"
                            ng-model="tags"
                            template="views/directives/tag-input-item.html"
                            replace-spaces-with-dashes="false">
                                <auto-complete min-length="3" debounce-delay="400" source="getTags($query)"></auto-complete>
                        </tags-input>

                        <span class="input-group-btn vtop">
                            <button type="button" class="btn btn-block btn-sm btn-primary" ng-click="fromTagLibrary()" uib-tooltip="Add tag from library" tooltip-placement="left">
                                <span class="fa fa-plus"></span>
                            </button>
                        </span>
                    </div>
                </div>
            </div>

        </div>

        <div class="row">
            <div class="col-sm-12">
                <div class="form-group" ng-class="{ 'has-error' : caseCreateForm.description.$invalid && !caseCreateForm.description.$pristine }">
                    <label class="control-label">Description
                        <i class="fa fa-asterisk text-danger"></i>
                    </label>
                    <div>
                        <textarea class="form-control" name="description" ng-model="newCase.description" placeholder="Case description" required rows="3"></textarea>
                        <p class="help-block" ng-show="caseCreateForm.description.$invalid && !caseCreateForm.description.$pristine">The case description is required.</p>
                    </div>
                </div>
            </div>
        </div>

        <div if-permission="manageTask">
            <h4 class="vpad10 text-primary">Case tasks
                <small ng-if="fromTemplate">(from template: {{template.displayName || template.name}} )</small>
            </h4>
            <div class="row" ng-if="!fromTemplate">
                <div class="col-md-12">
                    <div class="input-group input-group-sm">
                        <input class="form-control task-input" name="task-input" ng-model="temp.task" placeholder="Task title" type="text" />
                        <span class="input-group-btn">
                            <button class="btn btn-primary" type="button" ng-disabled="!temp.task" ng-click="addTask(temp.task)">Add task</button>
                        </span>
                    </div>
                </div>
            </div>
            <div class="row vpad5" ng-if="tasks.length === 0">
                <div class="col-md-12">
                    <div class="empty-message">
                        No tasks have been specified
                    </div>
                </div>
            </div>
            <div class="row vpad5" ng-if="tasks.length !== 0" ng-repeat="t in tasks">
                <div class="col-md-12">
                    <span>
                        <a ng-click="removeTask(t)" ng-if="!fromTemplate" style="cursor:pointer;"><i class="fa fa-times text-danger"></i></a>
                        <span class="hpad10">{{t}}</span>
                    </span>
                </div>
            </div>
        </div>

    </div>

    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
        <span class="btn">
            <i class="fa fa-asterisk text-danger"></i>&nbsp;Required field</span>
        <button class="btn btn-primary pull-right" ng-disabled="caseCreateForm.$invalid || pendingAsync" type="submit">
            <i class="fa fa-plus"></i>&nbsp;Create case</button>
    </div>
</form>

```

`frontend/app/views/partials/case/case.delete.confirm.html`:

```html
<div class="modal-header bg-danger">
    <h3 class="modal-title">Permanently remove case #{{caze.number}}</h3>
</div>
<div class="modal-body">
    <p>Are you sure you want to permanently delete this case?</p>
    <p class="text-danger"><b>This action might take a while and cannot be undone.</b></p>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="cancel()" ng-disabled="loading" type="button">Cancel</button>
    <button class="btn btn-danger pull-right" ng-click="confirm()" ng-disabled="loading" type="button">
        Yes, remove it.
    </button>
</div>

```

`frontend/app/views/partials/case/case.details.html`:

```html
<div class="row case-details">
    <div class="col-md-8">
        <h4 class="vpad10 text-primary">Basic Information</h4>
        <dl class="dl-horizontal clear">
            <dt class="pull-left">Title
            </dt>
            <dd ng-if="canEdit">
                <updatable-simple-text on-update="updateField('title', newValue)" value="caze.title"></updatable-simple-text>
            </dd>
            <dd ng-if="!canEdit">
                {{caze.title}}
            </dd>
        </dl>

        <dl class="dl-horizontal clear">
            <dt class="pull-left">Severity</dt>
            <dd ng-if="canEdit">
                <a class="noline" href ng-click="activeSev = true" ng-init="activeSev = false">
                    <severity active="activeSev" on-update="updateField('severity', newValue)" value="caze.severity"></severity>
                </a>
            </dd>
            <dd ng-if="!canEdit">
                <severity active="false" value="caze.severity"></severity>
            </dd>
        </dl>

        <dl class="dl-horizontal clear">
            <dt class="pull-left">TLP</dt>
            <dd ng-if="canEdit">
                <a class="noline" href ng-click="activeTlp = 'active'" ng-init="activeTlp = 'static'">
                    <tlp format="activeTlp" on-update="updateField('tlp', newValue)" style="float:left;" value="caze.tlp"></tlp>
                </a>
            </dd>
            <dd ng-if="!canEdit">
                <tlp format="'static'" value="caze.tlp"></tlp>
            </dd>
        </dl>

        <dl class="dl-horizontal clear">
            <dt class="pull-left">PAP</dt>
            <dd ng-if="canEdit">
                <a class="noline" href ng-click="activePap = 'active'" ng-init="activePap = 'static'">
                    <tlp format="activePap" on-update="updateField('pap', newValue)" style="float:left;" value="caze.pap" namespace="PAP"></tlp>
                </a>
            </dd>
            <dd ng-if="!canEdit">
                <tlp format="'static'" value="caze.pap" namespace="PAP"></tlp>
            </dd>
        </dl>

        <dl class="dl-horizontal">
            <dt class="pull-left">Assignee</dt>
            <dd ng-if="canEdit">
                <updatable-user on-update="updateField('owner', newValue)" value="caze.assignee" query="assignableUsersQuery"/>
            </dd>
            <dd ng-if="!canEdit">
                <user-info value="caze.assignee" field="name"></user-info>
            </dd>
        </dl>

        <dl class="dl-horizontal clear">
            <dt class="pull-left">Date</dt>
            <dd ng-if="canEdit">
                <updatable-date on-update="updateField('startDate', newValue)" value="caze.startDate"></updatable-date>
            </dd>
            <dd ng-if="!canEdit">
                {{caze.startDate | shortDate}}
            </dd>
        </dl>

        <dl class="dl-horizontal">
            <dt class="pull-left">Tags</dt>
            <dd ng-if="canEdit">
                <updatable-tag-list on-update="updateField('tags', getTags(newValue))" value="caze.tags" source="getCaseTags"></updatable-tag-list>
            </dd>
            <dd ng-if="!canEdit">
                <tag-list data="caze.tags"></tag-list>
            </dd>
        </dl>

        <dl class="dl-horizontal clear" ng-show="isCaseClosed()">
            <dt class="pull-left text-success">Close date</dt>
            <dd class="text-success" ng-if="canEdit">
                <updatable-date on-update="updateField('endDate', newValue)" value="caze.endDate"></updatable-date>
            </dd>
            <dd class="text-success" ng-if="!canEdit">
                {{caze.endDate | shortDate}}
            </dd>
        </dl>
    </div>
    <div class="col-md-4">
        <ng-include src="'views/partials/case/details/related.cases.html'"></ng-include>
    </div>
</div>
<div class="row">
    <div class="col-xs-12">
        <ng-include src="'views/partials/case/details/custom.fields.html'"></ng-include>
    </div>
</div>
<div class="vpad10">
     <h4 class="vpad10 text-primary">Description</h4>
     <div class="description-pane" ng-if="canEdit">
         <updatable-text on-update="updateField('description', newValue)" value="caze.description"></updatable-text>
     </div>
     <div class="description-pane" ng-if="!canEdit">
        <div marked="caze.description" class="markdown"></div>
     </div>
</div>
<div class="vpad10" ng-show="isCaseClosed()">
     <h4 class="vpad10 text-primary">Summary</h4>
     <div class="description-pane" ng-if="canEdit">
         <updatable-text on-update="updateField('summary', newValue)" value="caze.summary"></updatable-text>
     </div>
     <div class="description-pane" ng-if="!canEdit">
        <div marked="caze.summary" class="markdown"></div>
     </div>
</div>
<div class="case-actions vpad10" ng-if="actions.values.length">
    <responder-actions header="Responder Jobs" actions="actions"></responder-actions>
</div>
<div class="case-attachments vpad10" ng-if="attachments.values.length > 0">
    <h4 class="vpad10 text-primary">Attachments</h4>
    <table class="table table-striped">
        <thead>
            <tr>
                <th>Filename</th>
                <th>Date</th>
                <th>Type</th>
                <th>Size</th>
                <th style="text-align:center">Download</th>
            </tr>
        </thead>
        <tbody>
            <tr ng-repeat="attachment in attachments.values" style="cursor: pointer;" tooltip-placement="bottom" tooltip-popup-delay="500" uib-tooltip="{{attachment.message}}">
                <td ng-click="openAttachment(attachment)">{{attachment.attachment.name}}</td>
                <td ng-click="openAttachment(attachment)">{{attachment.date | shortDate}}</td>
                <td ng-click="openAttachment(attachment)">{{attachment.attachment.contentType}}</td>
                <td ng-click="openAttachment(attachment)">{{attachment.attachment.size}}</td>
                <td style="text-align:center">
                    <a href="./api/datastore/{{attachment.attachment.id}}?name={{attachment.attachment.name | escape}}" target="_blank">
                        <i class="glyphicon glyphicon-download"></i>
                    </a>
                </td>
            </tr>
        </tbody>
    </table>
</div>

```

`frontend/app/views/partials/case/case.links.html`:

```html
<div class="row" ng-show="links.length === 0">
    <div class="col-md-12">
        <div class=" empty-message">No records</div>
    </div>
</div>

<div class="case-links" ng-show="links.length > 0" ng-init="filteredLinks = (links | filter:filtering | orderBy:sorting.field)">
    <div class="mv-s" ng-if="linkStats">
        <span class="label label-lg label-default mr-xxs clickable"
            ng-click="filterLinks('');"
            ng-class="{'label-primary': currentFilter===''}">All ({{links.length || 0}})</span>

        <span class="label label-lg label-default mr-xxs clickable"
            ng-repeat="statsItem in linkStats"
            ng-click="filterLinks(statsItem.key)"
            ng-class="{'label-primary': currentFilter===statsItem.key}">{{CaseResolutionStatus[statsItem.key] || statsItem.key}} ({{statsItem.value}})</span>
    </div>

    <div class="row" ng-show="filteredLinks.length === 0">
        <div class="col-md-12">
            <div class=" empty-message">No records</div>
        </div>
    </div>

    <div class="case-item" ng-show="filteredLinks.length !== 0">
        <div class="case-details text-bold">
          <a href class="text-default" ng-click="sortBy('title')">
            Title
            <i ng-show="sorting.field !== '+title' && sorting.field !== '-title'" class="fa fa-sort"></i>
            <i ng-show="sorting.field === '+title'" class="fa fa-caret-up"></i>
            <i ng-show="sorting.field === '-title'" class="fa fa-caret-down"></i>
          </a>
        </div>
        <div class="case-date text-bold">
          <a href class="text-default" ng-click="sortBy('startDate')">
            Date
            <i ng-show="sorting.field !== '+startDate' && sorting.field !== '-startDate'" class="fa fa-sort"></i>
            <i ng-show="sorting.field === '+startDate'" class="fa fa-caret-up"></i>
            <i ng-show="sorting.field === '-startDate'" class="fa fa-caret-down"></i>
          </a>
        </div>
        <div class="case-observables-list text-bold">
          <a href class="text-default" ng-click="sortBy('linksCount')">
            Linked observables
            <i ng-show="sorting.field !== '+linksCount' && sorting.field !== '-linksCount'" class="fa fa-sort"></i>
            <i ng-show="sorting.field === '+linksCount'" class="fa fa-caret-up"></i>
            <i ng-show="sorting.field === '-linksCount'" class="fa fa-caret-down"></i>
          </a>
        </div>
    </div>
    <div class="case-collection" ng-repeat="item in filteredLinks = (links | filter:filtering | orderBy:sorting.field)">
        <div class="case-item" >
            <!-- case severity -->
            <div class="case-tlp bg-tlp-{{item.tlp}}"></div>

            <!-- case title and main details -->
            <div class="case-details">
                <div class="case-title">
                    <a ui-sref="app.case.details({caseId: item.id})">#{{item.caseId}} - {{item.title}}</a>
                </div>
                <div class="case-tags flexwrap mt-xxs">
                    <span class="mr-xxxs text-muted"><i class="fa fa-tags"></i></span>
                    <strong class="text-muted mr-xxxs" ng-if="!item.tags || item.tags.length === 0">None</strong>
                    <tag-item ng-repeat="tag in item.tags track by $index" value="tag"></tag-item>
                </div>
                <div class="text-success" ng-show="item.status !== 'Open'">
                    <small>
                        (Closed at {{item.endDate | shortDate}} as <strong>{{CaseResolutionStatus[item.resolutionStatus]}}</strong>)
                    </small>
                </div>
                <div class="text-danger" ng-if="item.mergeFrom">
                    <small>
                        Merged from <a href ui-sref="app.case.details({caseId: item.mergeFrom[0]})"> Case #{{item.stats.mergeFrom[0].caseId}}</a> and
                        <a href ui-sref="app.case.details({caseId: item.mergeFrom[1]})"> Case #{{utem.stats.mergeFrom[1].caseId}}</a>
                    </small>
                </div>
            </div>

            <div class="case-severity">
                <div class="clickable">
                    <severity active="false" value="item.severity"></severity>
                </div>
            </div>

            <div class="case-date" ng-switch="item.status">
                <span uib-tooltip="{{item.startDate | shortDate}}" tooltip-popup-delay="500" tooltip-placement="bottom">{{item.startDate | shortDate}}</span><br/>
                <case-duration ng-switch-when="Resolved" start="item.startDate" end="item.endDate" icon="fa-clock-o"></case-duration>
                <case-duration ng-switch-when="Open" start="item.startDate" icon="fa-clock-o"></case-duration>
            </div>

            <div class="case-observables-count">
                <span class="badge">{{item.linksCount}}</span>
            </div>

            <div class="case-observables-list">
                <div ng-repeat="observable in item.linkedWith | limitTo:displayOptions[item.id]" class="wrap">
                    <observable-flags observable="observable" inline="true" hide-seen="true" hide-similarity="true"></observable-flags>

                    <a href ui-sref="app.case.observables-item({caseId: item.id, itemId: observable.id})">
                        <strong>[{{observable.dataType}}]</strong>:
                        <span ng-if="observable.attachment"></span>{{observable.attachment.name}}
                        <span ng-if="!observable.attachment"></span>{{observable.data | fang}}
                    </a>
                </div>
                <div class="mt-xs" ng-if="item.linkedWith.length > 5">
                    <a class="text-muted" ng-show="displayOptions[item.id]===5" href ng-click="displayOptions[item.id]=null"><strong>Show more links ({{item.linkedWith.length - 5}})</strong></a>
                    <a class="text-muted" ng-show="displayOptions[item.id]===null" href ng-click="displayOptions[item.id]=5"><strong>Show less links</strong></a>
                </div>
            </div>
        </div>
    </div>

</div>

```

`frontend/app/views/partials/case/case.list.html`:

```html
<div class="row">
    <div ng-Class="{ 'col-md-9': appLayout.showFlow, 'col-md-12': !appLayout.showFlow}">
        <div class="box">
            <div class="box-header with-border">
                <h3 class="box-title">
                    <datalist-header title="List of cases" list="$vm.list" total="$vm.caseCountAll"></datalist-header>
                </h3>
                <div class="box-tools pull-right" ng-show="!appLayout.showFlow">
                    <span class="ml-xs" tooltip="Open in new window">
                        <a class="text-muted" href ng-click="layoutSrv.showFlow(true)">
                            <i class="fa fa-plus"></i> Show live stream
                        </a>
                    </span>
                </div>
            </div>
            <div class="box-body">
                <div ng-include="'views/partials/case/list/toolbar.html'"></div>

                <div class="mt-xs stats-panel" ng-include="'views/partials/case/list/mini-stats.html'"
                    ng-if="$vm.filtering.context.showStats"></div>

                <div class="mt-xs filter-panel" ng-include="'views/partials/case/list/filters.html'"
                    ng-show="$vm.filtering.context.showFilters"></div>

                <div class="row mt-xs">
                    <div class="col-md-12 clearfix">

                        <filters-preview filters="$vm.filtering.context.filters" on-clear-item="$vm.removeFilter(field)"
                            on-clear-all="$vm.clearFilters()"></filters-preview>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12 mv-s" ng-show="$vm.list.total === 0 && $vm.list.values.length === 0">
                        <div class="empty-message">No records</div>
                    </div>

                    <div class="col-md-12" ng-show="$vm.list.values.length !== 0">
                        <psearch control="$vm.list"></psearch>

                        <table class="table table-striped case-list">
                            <thead>
                                <tr>
                                    <th style="width: 10px;" class="p-0"></th>
                                    <th width="20px">
                                        <input if-permission="manageCase" type="checkbox" ng-model="$vm.menu.selectAll"
                                            ng-change="$vm.selectAll()">
                                    </th>
                                    <th width="100px">
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('status')"
                                            uib-tooltip="Sort by status">
                                            Status
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+status') === -1 && $vm.filtering.context.sort.indexOf('-status') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+status') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-status') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th>
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('number')"
                                            uib-tooltip="Sort by number">
                                            # Number
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+number') === -1 && $vm.filtering.context.sort.indexOf('-number') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+number') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-number') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('title')"
                                            uib-tooltip="Sort by title">
                                            Title
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+title') === -1 && $vm.filtering.context.sort.indexOf('-title') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+title') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-title') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 70px;"></th>
                                    <th style="width: 90px;text-align:center;">
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('severity')"
                                            uib-tooltip="Sort by severity">
                                            Severity
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+severity') === -1 && $vm.filtering.context.sort.indexOf('-severity') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+severity') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-severity') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 150px;">Details</th>
                                    <th style="width: 90px;">
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('assignee')"
                                            uib-tooltip="Sort by assignee">
                                            Assignee
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+assignee') === -1 && $vm.filtering.context.sort.indexOf('-assignee') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+assignee') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-assignee') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 150px">
                                        Dates

                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('startDate')"
                                            uib-tooltip="Sort by start date">
                                            S.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+startDate') === -1 && $vm.filtering.context.sort.indexOf('-startDate') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+startDate') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-startDate') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_createdAt')"
                                            uib-tooltip="Sort by creation date">
                                            C.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') === -1 && $vm.filtering.context.sort.indexOf('-_createdAt') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_createdAt') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-_createdAt') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('_updatedAt')"
                                            uib-tooltip="Sort by last update date">
                                            U.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') === -1 && $vm.filtering.context.sort.indexOf('-_updatedAt') === -1"
                                                class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+_updatedAt') !== -1"
                                                class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-_updatedAt') !== -1"
                                                class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 20px;" ng-if="appConfig.connectors.cortex.enabled"></th>
                                </tr>
                            </thead>

                            <tbody>
                                <tr ng-class="{true:'tr-warning'}[currentCase.flag]"
                                    ng-repeat="currentCase in $vm.list.values">
                                    <td class="p-0 bg-tlp-{{currentCase.tlp}} clickable"
                                        ng-click="$vm.addFilterValue('tlp', currentCase.tlp)"></td>
                                    <td>
                                        <input if-permission="manageCase"
                                            allowed="{{currentCase.extraData.permissions.join(',')}}" type="checkbox"
                                            ng-model="currentCase.selected" ng-change="$vm.select(currentCase)">
                                    </td>
                                    <td class="case-status">
                                        <div class="mb-xxxs">
                                            <span class="label label-default clickable" ng-class="{
                                                'Resolved': 'label-success',
                                                'Open': 'label-danger'
                                            }[currentCase.status]"
                                                ng-click="$vm.addFilterValue('status', currentCase.status)">{{currentCase.status
                                                === 'Resolved' ? 'Closed' : currentCase.status}}</span>
                                        </div>
                                        <div ng-switch="currentCase.status">
                                            <case-duration ng-switch-when="Resolved" start="currentCase.startDate"
                                                end="currentCase.endDate" icon="fa-clock-o"></case-duration>
                                            <case-duration ng-switch-when="Open" start="currentCase.startDate"
                                                icon="fa-clock-o"></case-duration>
                                        </div>
                                    </td>
                                    <td>
                                        <div class="case-title wrap">
                                            <span class="mr-xxs text-primary"
                                                ng-if="!!!currentCase.extraData.isOwner"><i class="fa fa-share-square"
                                                    uib-tooltip="Shared from another organisation"
                                                    tooltip-placement="right"></i></span>
                                            <span class="mr-xxs text-primary" ng-if="!!currentCase.extraData.isOwner"><i
                                                    class="fa fa-building-o" uib-tooltip="Created by my organisation"
                                                    tooltip-placement="right"></i></span>
                                            <a ui-sref="app.case.details({caseId: currentCase._id})">#{{currentCase.number}}
                                                - {{currentCase.title}}</a>
                                        </div>
                                        <div class="case-tags flexwrap mt-xxs">
                                            <span class="mr-xxxs text-muted"><i class="fa fa-tags"></i></span>
                                            <strong class="text-muted mr-xxxs"
                                                ng-if="!currentCase.tags || currentCase.tags.length === 0">None</strong>
                                            <tag-item ng-repeat="tag in currentCase.tags track by $index"
                                                class="pointer" ng-click="$vm.addFilterValue('tags', tag)" value="tag">
                                            </tag-item>
                                        </div>

                                        <custom-field-labels ng-if="$vm.filtering.context.showAdvanced"
                                            custom-fields="currentCase.customFields"
                                            on-field-click="$vm.addFilterValue(name, value)"></custom-field-labels>

                                        <div class="text-success" ng-show="currentCase.status !== 'Open'">
                                            <small>
                                                (Closed at {{currentCase.endDate | shortDate}} as <strong><a href
                                                        ng-click="$vm.filterByResolutionStatus(currentCase.resolutionStatus)">{{$vm.CaseResolutionStatus[currentCase.resolutionStatus]}}</a></strong>)
                                            </small>
                                        </div>
                                        <div class="text-danger" ng-if="currentCase.mergeFrom">
                                            <small>
                                                Merged from <a href
                                                    ui-sref="app.case.details({caseId: currentCase.mergeFrom[0]})"> Case
                                                    #{{currentCase.stats.mergeFrom[0].number}}</a> and
                                                <a href ui-sref="app.case.details({caseId: currentCase.mergeFrom[1]})">
                                                    Case #{{currentCase.stats.mergeFrom[1].number}}</a>
                                            </small>
                                        </div>
                                    </td>
                                    <td align="center">

                                        <div ng-if="currentCase.extraData.shareCount > 0">
                                            <a href ui-sref="app.case.sharing({caseId: currentCase._id})" class="noline"
                                                uib-tooltip="{{ {
                                                        true: 'Current organisation has shared this Case with ' + currentCase.extraData.shareCount + ' organisation(s)',
                                                        false: 'This Case has been shared by its owner with ' + currentCase.extraData.shareCount + ' organisation(s)'
                                                    }[currentCase.extraData.isOwner] }}"
                                                tooltip-placement="left-middle">

                                                <i class="fa fa-users"></i>
                                                ({{currentCase.extraData.shareCount || 0}})
                                            </a>
                                        </div>
                                    </td>
                                    <td align="center">
                                        <div class="clickable"
                                            ng-click="$vm.addFilterValue('severity', currentCase.severity)">
                                            <severity active="false" value="currentCase.severity"></severity>
                                        </div>
                                    </td>
                                    <td>
                                        <div ng-class="{'text-danger': !!currentCase.extraData.actionRequired}"
                                            class="clearfix">
                                            <a href ng-click="$vm.addFilterValue('actionRequired', true)">
                                                <span ng-if="!!currentCase.extraData.actionRequired"
                                                    class="text-danger noline mr-xxxs" uib-tooltip="Action Required"
                                                    tooltip-placement="left-middle">
                                                    <i class="fa fa-exclamation-triangle"></i>
                                                </span>
                                            </a>

                                            <a ui-sref="app.case.tasks({caseId: currentCase._id})"
                                                ng-class="{'text-danger': !!currentCase.extraData.actionRequired}">
                                                <span>Tasks</span>
                                                <strong class="pull-right">{{currentCase.extraData.taskStats.total |
                                                    limitedCount}}</strong>
                                            </a>
                                        </div>
                                        <task-progress class="mt-0" ng-show="currentCase.extraData.taskStats.total > 0"
                                            tasks="currentCase.extraData.taskStats"></task-progress>

                                        <div class="clearfix mt-xxs">

                                            <a ui-sref="app.case.observables({caseId: currentCase._id})">
                                                <span>Observables</span>
                                                <strong class="pull-right">{{currentCase.extraData.observableStats.total
                                                    |
                                                    limitedCount}}</strong>
                                            </a>
                                        </div>

                                        <div class="clearfix mt-xxs">
                                            <a ui-sref="app.case.procedures({caseId: currentCase._id})">
                                                <span>TTPs</span>
                                                <strong class="pull-right">{{currentCase.extraData.procedureCount ||
                                                    0}}</strong>
                                            </a>
                                        </div>

                                    </td>
                                    <td class="nowrap">
                                        <user user-id="currentCase.assignee" icon-only="true" icon-size="m"></user>
                                    </td>
                                    <td>
                                        <div
                                            ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+startDate') !== -1 || $vm.filtering.context.sort.indexOf('-startDate') !== -1}">
                                            S. <a href
                                                ng-click="$vm.addFilterValue('startDate', currentCase.startDate)">{{currentCase.startDate
                                                | shortDate}}</a>
                                        </div>
                                        <div
                                            ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_createdAt') !== -1 || $vm.filtering.context.sort.indexOf('-_createdAt') !== -1}">
                                            C. <a href
                                                ng-click="$vm.addFilterValue('_createdAt', currentCase._createdAt)">{{currentCase._createdAt
                                                | shortDate}}</a>
                                        </div>
                                        <div ng-if="currentCase._updatedAt > 0"
                                            ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+_updatedAt') !== -1 || $vm.filtering.context.sort.indexOf('-_updatedAt') !== -1}">
                                            U. <a href
                                                ng-click="$vm.addFilterValue('_updatedAt', currentCase._updatedAt)">{{currentCase._updatedAt
                                                | shortDate}}</a>
                                        </div>
                                    </td>
                                    <td class="text-center">
                                        <!-- <a href class="text-primary noline nowrap" ng-click="$vm.getCaseResponders(currentCase, true)" uib-dropdown-toggle> -->
                                        <a href class="btn btn-icon btn-clear"
                                            ng-click="$vm.getCaseResponders(currentCase, true)"
                                            ng-if="appConfig.connectors.cortex.enabled" if-permission="manageAction"
                                            allowed="{{currentCase.extraData.permissions.join(',')}}">
                                            <i class="text-info fa fa-cog"></i>
                                        </a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>

                        <psearch control="$vm.list"></psearch>

                    </div>
                </div>
            </div>
        </div>
    </div>

    <div ng-show="appLayout.showFlow" class="col-md-3">
        <div class=" box">
            <div class="box-header">
                <h3 class="box-title">&nbsp;</h3>
                <div class="box-tools pull-right">
                    <span class="ml-xs" tooltip="Open in new window">
                        <a class="text-muted" href ng-click="layoutSrv.detachFlow()">
                            <i class="fa fa-external-link"></i> Open in new window
                        </a>
                    </span>

                    <span class="ml-xs" tooltip="Hide">
                        <a class="text-muted" href ng-click="layoutSrv.showFlow(false)">
                            <i class="fa fa-minus"></i> Hide
                        </a>
                    </span>
                </div>
            </div>
            <div class="box-body no-padding">
                <flow max="10"></flow>
            </div>
        </div>
    </div>

</div>

```

`frontend/app/views/partials/case/case.merge.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">{{dialog.title | ellipsis:50}}</h3>
</div>
<div class="modal-body merge-dialog">
    <div class="input-group input-group-lg search-field">
        <span class="input-group-addon">
            <label class="radio-inline">
                <input type="radio" name="search-type" ng-model="dialog.search.type" value="title" ng-change="dialog.onTypeChange('title')"> By Title
            </label>
            <label class="radio-inline">
                <input type="radio" name="search-type" ng-model="dialog.search.type" value="number" ng-change="dialog.onTypeChange('number')"> By Number
            </label>
        </span>
        <input type="{{dialog.search.type === 'number' ? 'number' : 'text'}}"
            placeholder="{{dialog.search.placeholder}}"
            ng-model="dialog.search.input"
            uib-typeahead="caze as dialog.format(caze) for caze in dialog.getCaseList(dialog.search.type, $viewValue)"
            typeahead-wait-ms="500"
            typeahead-min-length="dialog.search.minInputLength"
            typeahead-on-select="dialog.onSelect($item)"
            class="form-control">
    </div>

    <div class="empty-message mv-s" ng-show="dialog.search.cases.length === 0">
        Please search for the case to be merged with: <br>
        <strong>{{dialog.prompt}}</strong>
    </div>
    <div class="mv-s merge-case" ng-repeat="c in dialog.search.cases">
        <div class="alert alert-warning" ng-show="c.mergeInto">
            WARNING: This case has already been merged with another case
        </div>
        <h4>{{c.title}}</h4>
        <div>
            <span>
                <i class="glyphicon glyphicon-user"></i>
                <user-info value="c.assignee" field="name"></user-info>
            </span>
            <span class="ml-xxs">
                <i class="glyphicon glyphicon-calendar"></i>
                <span>{{c.startDate | shortDate}}</span>&nbsp;&nbsp;
            <span ng-show="isCaseClosed()" class="text-success">(Closed at
                    {{c.endDate | shortDate}}
                    as
                    <strong>{{CaseResolutionStatus[c.resolutionStatus]}}</strong>)</span>
            </span>
        </div>
        <div class="mt-xs wrap" ng-if="c.tags.length>0">
            <strong>Tags:</strong>
            <tag-list data="c.tags"></tag-list>
        </div>
        <div class="mt-xs wrap">
            <div marked="c.description" class="markdown"></div>
        </div>
    </div>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="dialog.cancel()" type="button">Cancel</button>
    <button class="btn btn-primary pull-right" ng-click="dialog.merge()" ng-disabled="dialog.search.cases.length < 1"
        type="button">Merge</button>
</div>

```

`frontend/app/views/partials/case/case.observables.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">
            <div class="btn-group" if-permission="manageObservable" allowed="{{userPermissions}}" uib-dropdown is-open="status.isopen">
                <button class="btn btn-sm btn-default dropdown-toggle" uib-dropdown-toggle ng-disabled="selection.artifacts.length == 0" type="button">
                    <ng-pluralize count="selection.artifacts.length" when="{'0': 'No observable selected', 'one': '{} selected observable', 'other': '{} selected observables'}"></ng-pluralize>
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a ng-click="bulkEdit()"><i class="fa fa-edit"></i> Edit</a>
                    </li>

                    <li ng-if="analysisEnabled" if-permission="manageAnalyse" allowed="{{userPermissions}}">
                        <a ng-click="bulkAnalyze();"><i class="glyphicon glyphicon-fire"></i> Run analyzers</a>
                    </li>

                    <li class="divider"></li>
                    <li>
                        <a href ng-click="removeObservables()">
                            <i class="fa fa-trash"></i> Delete
                        </a>
                    </li>
                </ul>
            </div>

            <div class="btn-group" if-permission="manageObservable" allowed="{{userPermissions}}">
                <button class="btn btn-sm btn-primary" ng-click="addArtifact()">
                    <i class="glyphicon glyphicon-plus"></i>
                    Add observable(s)
                </button>
            </div>

            <div class="btn-group">
                <button class="btn btn-sm btn-default" ng-disabled="selection.artifacts.length == 0" ng-click="showExport()">
                    <i class="fa fa-download"></i>
                    Export
                </button>
            </div>

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="artifacts" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[filtering.context.showFilters]" type="button" ng-click="toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[filtering.context.showStats]" type="button" ng-click="toggleStats()">
                    <i class="fa fa-bar-chart"></i> Stats
                </button>
            </div>
        </div>
    </div>
</div>

<div class="mt-xs stats-panel" ng-include="'views/partials/observables/list/mini-stats.html'" ng-if="filtering.context.showStats"></div>

<div class="mt-xs filter-panel" ng-include="'views/partials/observables/list/filters.html'" ng-show="filtering.context.showFilters"></div>

<!-- Main page : Table + Text/CSV -->
<div class="mt-xs row">
    <div class="selection" ng-if="showExportPanel">
        <div ng-include="'views/partials/observables/list/export.html'"></div>
    </div>
    <div class="selection" ng-if="!showExportPanel">
        <div ng-include="'views/partials/observables/list/observables.html'"></div>
    </div>
</div>

```

`frontend/app/views/partials/case/case.observables.item.html`:

```html
<!-- Observable details header-->
<div class="row" ng-show="artifact.data != undefined">
    <div class="col-md-12">
        <h4>
            <span class="text-muted fa " ng-class="{true:'text-primary fa-star'}[artifact.ioc]" tooltip-placement="bottom" tooltip-popup-delay="500" uib-tooltip="is an IOC"></span>
            [<span ng-bind="artifact.dataType" style="text-transform: uppercase;"></span>]: <em><span class="wrap">{{artifact.data | fang}}</span></em>
        </h4>
    </div>
</div>
<div class="row" ng-show="artifact.attachment != undefined">
    <div class="col-md-8">
        <h4>
            [<span ng-bind="artifact.dataType" style="text-transform: uppercase;"></span>]: <em><span class="wrap" ng-bind="artifact.attachment.name"></span></em>
        </h4>
    </div>
    <div class="col-md-3 text-center">
        <div>
            <a href="./api/datastorezip/{{artifact.attachment.id}}?name={{artifact.attachment.name | escape}}" target="_blank">
                <i class="glyphicon glyphicon-download"></i>
                <span class="wrap">{{artifact.attachment.name | ellipsis:30}}</span>
            </a>
        </div>
        <div>
            <small class="text-danger">Zip are protected with password "{{protectDownloadsWith}}"</small>
        </div>
    </div>
</div>
<div class="row">
    <!-- Observable analysers short reports -->
    <!-- <mini-report-list observable="artifact" reports="artifact.reports" on-item-clicked="showReport(observable, analyzerId)"></mini-report-list> -->
    <div class="col-md-12 flexwrap">
        <mini-report-list observable="artifact" reports="artifact.reports"></mini-report-list>
    </div>
</div>

<div class="clearfix">
    <div class="col-md-6 col-md-offset-3"><hr></div>
</div>

<!-- Observable details and links sections -->
<div ng-include="'views/partials/observables/details/summary.html'"></div>

<!-- Observable responder jobs -->
<div ng-include="'views/partials/observables/details/responders.html'"></div>

<!-- Observable analyzer jobs -->
<div ng-include="'views/partials/observables/details/analysers.html'"></div>

<!-- Observable sharing rules -->
<div ng-include="'views/partials/observables/details/sharing.html'"></div>

```

`frontend/app/views/partials/case/case.panelinfo.html`:

```html
<div class="box box-default">
    <div class="box-header with-border">
        <h3 class="box-title text-primary">
            <!-- <severity value="caze.severity"></severity> -->
            <span class="mr-xxs" ng-if="!!!caze.extraData.isOwner" uib-tooltip="Shared from another organisation" tooltip-placement="right">
                <i class="fa fa-share-square"></i>
            </span>
            <span class="mr-xxs" ng-if="!!caze.extraData.isOwner" uib-tooltip="Created by my organisation" tooltip-placement="right">
                <i class="fa fa-building-o"></i>
            </span>
            <span class="wrap">Case #
                {{caze.number}}
                -
                {{caze.title}}</span>
        </h3>
        <div class="box-tools pull-right" ng-show="!appLayout.showFlow">
            <span class="ml-xs" tooltip="Open in new window">
                <a class="text-muted" href ng-click="layoutSrv.showFlow(true)">
                    <i class="fa fa-plus"></i> Show live stream
                </a>
            </span>
        </div>
    </div>

    <div class="box-body">
        <span uib-tooltip="Creation by">
            <i class="glyphicon glyphicon-user"></i>
            <user-info value="caze._createdBy" field="name"></user-info>
        </span>

        <span class="ml-xxs" uib-tooltip="Created at">
            <i class="fa fa-calendar"></i>
            <span class="mr-xxxs">{{caze._createdAt | shortDate}}</span>
        </span>

        <span class="text-success" uib-tooltip="Closed at" ng-show="isCaseClosed()">
            <span><i class="fa fa-calendar-times-o"></i></span>
            <span>{{caze.endDate | shortDate}} as </span>
            <strong>{{CaseResolutionStatus[caze.resolutionStatus]}}</strong>
            <span ng-show="isCaseTruePositive()"> with <strong>{{caze.impactStatus === 'NoImpact' ? 'No Impact' : 'Impact'}}</strong></span>
        </span>

        <span class="ml-xxs" ng-switch="caze.status">
            <case-duration ng-switch-when="Resolved" start="caze.startDate" end="caze.endDate" icon="fa-clock-o"></case-duration>
            <case-duration ng-switch-when="Open" start="caze.startDate" icon="fa-clock-o"></case-duration>
        </span>

        <span class="ml-xxs text-danger" ng-show="links.length > 0" uib-tooltip="Related to">
            <i class="glyphicon glyphicon-link"></i>
            <strong>
                <a class="text-danger" href ui-sref="app.case.links({caseId:caze._id})">
                  <ng-pluralize count="links.length" when="{'one': '1 case', 'other': '{} cases'}"></ng-pluralize>
                </a>
            </strong>
        </span>

        <span class="ml-xxs text-danger" ng-show="alertCount > 0"uib-tooltip="Related to">
            <i class="glyphicon glyphicon-link"></i>
            <strong>
                <a class="text-danger" href ui-sref="app.case.alerts({caseId:caze._id})">
                  <ng-pluralize count="alertCount" when="{'one': '1 alert', 'other': '{} alerts'}"></ng-pluralize>
                </a>
            </strong>
        </span>

        <!-- Right side -->

        <div class="pull-right" if-permission="manageCase" allowed="{{userPermissions}}">
            <span class="ml-xxs pull-right" uib-dropdown ng-if="appConfig.connectors.cortex.enabled" if-permission="manageAction" allowed="{{userPermissions}}">
                <span class="mr-xxs text-primary">|</span>

                <a href class="text-primary noline" ng-click="getCaseResponders(true)">
                    <i class="text-info fa fa-cog"></i>
                    Responders
                </a>

                <!-- <a href class="text-primary noline" ng-click="getCaseResponders(true)" uib-dropdown-toggle>
                    <i class="text-primary fa fa-cog"></i>
                    Responders
                    <i class="text-primary fa fa-angle-down"></i>
                </a> -->
                <!-- <ul class="dropdown-menu" uib-dropdown-menu>
                  <li ng-if="caseResponders && caseResponders.length === 0">
                    <a href ng-click="getCaseResponders(true)">
                      <strong><i class="fa fa-refresh mr-xxs"></i> No responders available</strong>
                    </a>
                  </li>
                  <li ng-repeat="responder in caseResponders">
                    <a href ng-click="runResponder(responder.id, responder.name)">
                      <strong>{{responder.name}}</strong>
                      <br>
                      <small>{{responder.description}}</small></a>
                  </li>
                </ul> -->
            </span>

            <span class="ml-xxs pull-right" ng-if="appConfig.connectors.misp.enabled" if-permission="manageShare" allowed="{{userPermissions}}">
                <span class="mr-xxs text-primary">|</span>
                <a href ng-click="exportToMisp()" class="text-primary noline" uib-tooltip="Export case">
                    <i class="text-primary fa fa-share"></i>
                    Export ({{existingExports}})
                </a>
            </span>

            <span class="ml-xxs pull-right">
                <a href ng-click="removeCase()" class="text-danger noline" uib-tooltip="Permanently Remove case">
                    <i class="text-danger fa fa-times"></i>
                    Remove
                </a>
            </span>

            <span class="ml-xxs pull-right">
                <a href ng-click="mergeCase()" class="text-primary noline" uib-tooltip="Merge case">
                    <i class="text-primary fa fa-compress"></i>
                    Merge
                </a>
            </span>

            <span class="ml-xxs pull-right" ng-if="!caze.flag || caze.flag == undefined">
                <a href ng-click="switchFlag()" class="text-muted noline" uib-tooltip="Flag case">
                    <i class="text-muted fa fa-flag" ng-class="setFlag" ng-mouseout="setFlag='text-muted'" ng-mouseover="setFlag='text-yellow'"></i>
                    Flag
                </a>
            </span>
            <span class="ml-xxs pull-right" ng-if="caze.flag">
                <a href ng-click="switchFlag()" class="text-yellow noline" uib-tooltip="Unflag case">
                    <i class="text-yellow fa fa-flag" ng-show="caze.flag"></i>
                    Unflag
                </a>
            </span>
            <span class="ml-xxs pull-right" ng-hide="isCaseClosed()">
                <a href ng-click="openCloseDialog()" class="text-muted noline" uib-tooltip="Close case">
                    <i class="text-muted fa fa-check-circle-o" ng-class="CloseCase" ng-mouseout="CloseCase='text-muted glyphicon-ok-circle'" ng-mouseover="CloseCase='text-success glyphicon-ok-sign'"></i>
                    Close
                </a>
            </span>
            <span class="ml-xxs pull-right" ng-show="isCaseClosed()">
                <a href ng-click="reopenCase()" class="text-success noline" uib-tooltip="Reopen case">
                    <i class="text-success fa fa-check-circle"></i>
                    Reopen
                </a>
            </span>

            <span class="ml-xxs text-primary pull-right">|</span>
        </div>

        <div class="pull-right">
            <span class="ml-xxs pull-right">
                <a href ui-sref="app.case.sharing({caseId: caze._id})" class="noline">
                    <i class="fa fa-users"></i>
                    Sharing ({{caze.extraData.shareCount || 0}})
                </a>
            </span>
        </div>
    </div>
</div>

<div class="alert alert-warning text-center" ng-show="caze.mergeInto">
    <h4 class="mb-0">
        This case has been closed as a duplicate and merged into <br>
        <div class="mt-xs text-primary"><a href ui-sref="app.case.details({caseId: caze.mergeInto})">Case #{{caze.stats.mergeInto.caseId}}: {{caze.stats.mergeInto.title}}</a></div>
    </h4>
</div>

```

`frontend/app/views/partials/case/case.procedures.html`:

```html
<div ng-include="'views/partials/case/procedures/toolbar.html'"></div>

<div class="mt-xs filter-panel" ng-include="'views/partials/case/procedures/filters.html'"
    ng-show="$vm.filtering.context.showFilters"></div>

<!-- Filters preview  -->
<div class="row mt-xs">
    <div class="col-md-12 clearfix">
        <div class="pull-left">
            <h4>
                Tactics, Techniques and Procedures ({{$vm.list.values.length || 0}} of {{$vm.list.total}})
            </h4>
        </div>

        <filters-preview filters="$vm.filtering.context.filters" on-clear-item="$vm.removeFilter(field)"
            on-clear-all="$vm.clearFilters()"></filters-preview>
    </div>
</div>

<!-- Datalist  -->
<div class="row mt-xs">
    <div class="col-md-12 mv-s" ng-show="$vm.list.total === 0">
        <div class="empty-message">No records</div>
    </div>

    <div class="col-md-12" ng-show="$vm.list.total > 0">
        <psearch control="$vm.list"></psearch>

        <div class="ttp-item-header">
            <div class="ttp-tactic">
                <a href class="text-default" ng-click="$vm.sortByField('tactic')">
                    Tactic
                    <i ng-show="$vm.filtering.context.sort.indexOf('+tactic') === -1 && $vm.filtering.context.sort.indexOf('-tactic') === -1"
                        class="fa fa-sort"></i>
                    <i ng-show="$vm.filtering.context.sort.indexOf('+tactic') !== -1" class="fa fa-caret-up"></i>
                    <i ng-show="$vm.filtering.context.sort.indexOf('-tactic') !== -1" class="fa fa-caret-down"></i>
                </a>
            </div>
            <div class="ttp-name">
                <a href class="text-default" ng-click="$vm.sortByField('patternId')">
                    Technique
                    <i ng-show="$vm.filtering.context.sort.indexOf('+patternId') === -1 && $vm.filtering.context.sort.indexOf('-patternId') === -1"
                        class="fa fa-sort"></i>
                    <i ng-show="$vm.filtering.context.sort.indexOf('+patternId') !== -1" class="fa fa-caret-up"></i>
                    <i ng-show="$vm.filtering.context.sort.indexOf('-patternId') !== -1" class="fa fa-caret-down"></i>
                </a>
            </div>
            <!-- <div class="ttp-user">Created By</div> -->
            <div class="ttp-date">
                <a href class="text-default" ng-click="$vm.sortByField('occurDate')">
                    Occur Date
                    <i ng-show="$vm.filtering.context.sort.indexOf('+occurDate') === -1 && $vm.filtering.context.sort.indexOf('-occurDate') === -1"
                        class="fa fa-sort"></i>
                    <i ng-show="$vm.filtering.context.sort.indexOf('+occurDate') !== -1" class="fa fa-caret-up"></i>
                    <i ng-show="$vm.filtering.context.sort.indexOf('-occurDate') !== -1" class="fa fa-caret-down"></i>
                </a>
            </div>
            <div class="ttp-action text-right">Actions</div>
        </div>

        <div class="ttp-item" ng-repeat="proc in $vm.list.values">
            <div class="ttp-header">
                <div class="ttp-tactic clickable" ng-click="$vm.expanded[proc._id] = !$vm.expanded[proc._id]"
                    style="border-color: {{$vm.tactics[proc.tactic].color}}">
                    <div>
                        <a class="mr-xxs">
                            <i class="fa"
                                ng-class="{true: 'fa-chevron-up', false: 'fa-chevron-down'}[!!$vm.expanded[proc._id]]"></i>
                        </a>

                        {{$vm.tactics[proc.tactic].label}}

                        <a href class="pull-right" ng-click="$vm.addFilterValue('tactic', proc.tactic)"><i
                                class="fa fa-filter"></i></a>
                    </div>
                </div>
                <div class="ttp-name" ng-if="proc.extraData.patternParent">
                    <div>
                        <a href ng-click="$vm.showPattern(proc.patternId)">{{proc.patternId}}</a> -
                        {{proc.extraData.patternParent.name}}:{{proc.extraData.pattern.name}}

                        <a href class="pull-right" ng-click="$vm.addFilterValue('patternId', proc.patternId)"><i
                                class="fa fa-filter"></i></a>
                    </div>
                </div>
                <div class="ttp-name" ng-if="!proc.extraData.patternParent">
                    <div>
                        <a href ng-click="$vm.showPattern(proc.patternId)">{{proc.patternId}}</a> -
                        {{proc.extraData.pattern.name}}

                        <a href class="pull-right" ng-click="$vm.addFilterValue('patternId', proc.patternId)"><i
                                class="fa fa-filter"></i></a>
                    </div>
                </div>

                <!-- <div class="ttp-user">
                    <user user-id="proc._createdBy" icon-only="false" icon-size="m"></user>
                </div> -->
                <div class="ttp-date">
                    <a href ng-click="$vm.addFilterValue('occurDate', proc.occurDate)">
                        <span uib-tooltip="{{proc.occurDate | shortDate}}" tooltip-popup-delay="500"
                            tooltip-placement="bottom">{{proc.occurDate | shortDate}}</span>
                    </a>
                </div>
                <div class="ttp-action">
                    <a class="btn btn-icon btn-clear text-danger" href ng-click="$vm.remove(proc)"
                        uib-tooltip="Delete TTP" if-permission="manageProcedure" allowed="{{userPermissions}}">
                        <i class="fa fa-trash"></i>
                    </a>
                </div>
            </div>
            <div class="ttp-body" ng-show="$vm.expanded[proc._id]">
                <div class="row mb-xs">
                    <div class="col-sm-3">
                        <label>Created By</label>
                        <div>
                            <user-info value="proc._createdBy" field="organisation"></user-info>/<user-info
                                value="proc._createdBy" field="name"></user-info>
                        </div>
                    </div>
                    <div class="col-sm-3">
                        <label>Created At</label>
                        <div>
                            <span>{{proc._createdAt | shortDate}}</span>
                        </div>
                    </div>
                    <div class="col-sm-3">
                        <label>Updated At</label>
                        <div>
                            <span>{{(proc._updatedAt | shortDate) || '-'}}</span>
                        </div>
                    </div>
                    <div class="col-sm-3">
                        <label>Occured At</label>
                        <div if-permission="manageProcedure" allowed="{{userPermissions}}">
                            <updatable-date on-update="$vm.updateField(proc, 'occurDate', true)" value="proc.occurDate"
                                clearable="false"></updatable-date>
                        </div>
                        <div class="description-pane" if-not-permission="manageProcedure" allowed="{{userPermissions}}">
                            <span>{{(proc.occurDate | shortDate) || '-'}}</span>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-12">
                        <label>Procedure</label>
                        <div class="description-pane" if-permission="manageProcedure" allowed="{{userPermissions}}">
                            <updatable-text on-update="$vm.updateField(proc, 'description')" value="proc.description">
                            </updatable-text>
                        </div>
                        <div class="description-pane" if-not-permission="manageProcedure" allowed="{{userPermissions}}">
                            <div ng-if="!proc.description">
                                <em class="text-warning">Not Specified</em>
                            </div>
                            <div marked="proc.description" class="markdown"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <psearch control="$vm.list"></psearch>
    </div>
</div>

```

`frontend/app/views/partials/case/case.reopen.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">Reopen Case #{{caze.number}}</h3>
</div>
<div class="modal-body">
    <div class="vpad20">
        You are about to reopen the case <strong>#{{caze.number}}: {{caze.title}}</strong>
        <br/>
        <br/>
        Are you sure you want to continue ?
    </div>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
    <button class="btn btn-primary pull-right" type="button" ng-click="confirm()">Confirm</button>
</div>

```

`frontend/app/views/partials/case/case.sharing.html`:

```html
<div class="row mb-s" if-permission="manageShare" allowed="{{userPermissions}}">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">
            <div class="btn-group">
                <button class="btn btn-sm btn-primary" ng-click="$vm.shareCase()" ng-disabled="!$vm.enableAddButton">
                    <i class="fa fa-plus"></i>
                    Add share
                </button>
            </div>
        </div>
    </div>
</div>

<div class="row" ng-if="$vm.shares.length === 0">
    <div class="col-md-12">
        <div class=" empty-message">No records</div>
    </div>
</div>

<div class="row" ng-if="$vm.shares.length > 0">
    <div class="col-md-12">
        <p>
            The current case is shared with the following organisation(s)
        </p>

        <sharing-list
            shares="$vm.shares"
            organisations="$vm.organisations"
            profiles="$vm.profiles"
            on-delete="$vm.removeShare(share)"
            on-update-profile="$vm.updateShareProfile(org, profile)"
            permissions="userPermissions"
            ></sharing-list>
    </div>
</div>

```

`frontend/app/views/partials/case/case.tasks.html`:

```html
<div ng-include="'views/partials/case/tasks/toolbar.html'"></div>

<div class="mt-s filter-panel" ng-include="'views/partials/case/tasks/filters.html'"
    ng-show="filtering.context.showFilters"></div>

<!-- Filters preview  -->
<div class="row mt-s">
    <div class="col-md-12 clearfix">
        <div class="pull-left">
            <h4>
                <datalist-header title="List of tasks" list="list" total="tasksCount"></datalist-header>
            </h4>
        </div>

        <filters-preview filters="filtering.context.filters" on-clear-item="removeFilter(field)"
            on-clear-all="clearFilters()"></filters-preview>
    </div>
</div>

<div class="row mv-s" ng-show="list.total === 0 && list.values.length === 0">
    <div class="col-md-12">
        <div class="empty-message">No task found for this case.</div>
    </div>
</div>

<div class="row mb-xxs" ng-if="canEdit" ng-show="state.isNewTask">
    <div class="col-md-12">
        <form name="form" ng-submit="addTask(); state.isNewTask = false;" class="filter-panel">
            <div class="row">
                <div class="col-sm-3">
                    <div class="form-group">
                        <input name="group" class="form-control" ng-model="newTask.group" type="text"
                            placeholder="Task group" uib-typeahead="g for g in groups | filter:$viewValue"
                            typeahead-min-length="0">
                    </div>
                </div>
                <div class="col-sm-9">
                    <div class="input-group input-group">
                        <input name="title" class="form-control" ng-model="newTask.title" type="text"
                            placeholder="Task title" required>
                        <span class="input-group-btn">
                            <button class="btn btn-default" ng-disabled="form.$invalid" type="submit">
                                <i class="text-success glyphicon glyphicon-ok"></i>
                            </button>
                            <button class="btn btn-default" ng-click="state.isNewTask = false" type="button">
                                <i class="text-danger glyphicon glyphicon-remove"></i>
                            </button>
                        </span>
                    </div>
                </div>
            </div>
        </form>
    </div>
</div>

<div class="row" ng-if="list.values.length !== 0">
    <div class="col-md-12">

        <psearch control="list"></psearch>

        <!-- Show flat table -->
        <div ng-if="!state.showGrouped">
            <table class="table table-hover valigned tasks-table data-list">
                <thead>
                    <tr>
                        <th width="20px">
                            <input if-permission="manageTask" allowed="{{userPermissions}}" type="checkbox"
                                ng-model="menu.selectAll" ng-change="selectAll()">
                        </th>
                        <th style="width: 70px"></th>
                        <th style="width: 150px">Group</th>
                        <th style="width: 15px"></th>
                        <th>Task</th>
                        <th style="width: 70px;"></th>
                        <th style="width: 150px">Date</th>
                        <th style="width: 150px">Assignee</th>
                        <th style="width: 100px" class="text-right" if-permission="manageTask"
                            allowed="{{userPermissions}}">Actions</th>
                    </tr>
                </thead>
                <tbody ng-repeat="task in list.values">
                    <tr class="task-row" ng-class="{'warning': task.flag == true}">
                        <td>
                            <input if-permission="manageTask" allowed="{{userPermissions}}" type="checkbox"
                                ng-model="task.selected" ng-change="select(task)">
                        </td>
                        <td class="task-status" align="center" ng-switch="task.status">
                            <task-flags task="task" on-filter="addFilterValue(fieldName, value)" inline="true">
                            </task-flags>
                        </td>
                        <td ng-if="canEdit">
                            <updatable-select options="groups" on-update="updateField('group', newValue, task)"
                                value="task.group"></updatable-select>
                        </td>
                        <td>
                            <a href class="pull-right" ng-click="addFilterValue('group', task.group)"><i
                                    class="fa fa-filter"></i></a>
                        </td>
                        <td ng-if="!canEdit">
                            {{task.group}}
                        </td>
                        <td>
                            <div>
                                <!-- FIXME -->
                                <!-- <span class="mr-xxs text-primary clickable" ng-if="!!!task.extraData.isOwner"><i class="fa fa-share-square"
                                  uib-tooltip="Shared from another organisation" tooltip-placement="right"></i></span>
                              <span class="mr-xxs text-primary clickable" ng-if="!!task.extraData.isOwner"><i class="fa fa-building-o"
                                  uib-tooltip="Created by my organisation" tooltip-placement="right"></i></span> -->
                                <a href ng-click="collapseOptions[task._id] = !collapseOptions[task._id]"
                                    ng-show="task.description" uib-tooltip="Show/Hide description"
                                    tooltip-placement="right">
                                    <i class="fa" ng-class="{
                                        true: 'fa-chevron-up',
                                        false: 'fa-chevron-down'
                                    }[!!collapseOptions[task._id]]"></i>
                                </a>
                                <a href ui-sref="app.case.tasks-item({caseId: caseId, itemId:task._id})"
                                    ng-class="{'text-danger': !!task.extraData.actionRequired}">
                                    <span ng-if="!!task.extraData.actionRequired" class="text-danger noline mr-xxxs"
                                        uib-tooltip="Action Required" tooltip-placement="left-middle">
                                        <i class="fa fa-exclamation-triangle"></i>
                                    </span>
                                    {{task.title}}
                                </a>
                            </div>
                            <div ng-show="task.status === 'Completed'" class="text-success">
                                Closed after <em>{{(task.endDate - task.startDate) | amDurationFormat :
                                    'milliseconds'}}</em>
                            </div>
                            <div ng-show="task.status === 'InProgress'" class="text-warning">
                                Started <em am-time-ago="task.startDate"></em>
                            </div>
                        </td>
                        <td align="center">
                            <div ng-if="task.extraData.shareCount > 0">
                                <a href ui-sref="app.case.tasks-item({caseId: caseId, itemId:task._id})" class="noline"
                                    tooltip-placement="left-middle">

                                    <i class="fa fa-users"></i>
                                    ({{task.extraData.shareCount || 0}})
                                </a>
                            </div>

                        </td>
                        <td>{{task.startDate | shortDate}}</td>
                        <td ng-if="canEdit">
                            <span ng-show="task.assignee">
                                <updatable-user blank-text="Not Assigned"
                                    on-update="updateField('owner', newValue, task)" value="task.assignee"
                                    query="getAssignableUsers" query-params="[task._id]" />
                            </span>
                            <span ng-show="!task.assignee">
                                <updatable-user blank-text="Not Assigned"
                                    on-update="updateField('owner', newValue, task)" value="notassigned"
                                    query="getAssignableUsers" query-params="[task._id]" />
                            </span>
                        </td>
                        <td ng-if="!canEdit">
                            <span ng-show="task.assignee">
                                <user-info value="task.assignee" field="name"></user-info>
                            </span>
                            <span ng-show="!task.assignee">
                                <em class="text-warning">Not Assigned</em>
                            </span>
                        </td>
                        <!--  class="task-delete" -->
                        <td align="right" class="task-actions" if-permission="manageTask" allowed="{{userPermissions}}">

                            <a class="btn btn-icon btn-clear" ng-click="removeTask(task)" uib-tooltip="Delete">
                                <i class="fa fa-trash text-danger"></i>
                            </a>
                            <a class="btn btn-icon btn-clear" ng-show="task.status == 'Completed'"
                                ng-click="openTask(task)" uib-tooltip="Reopen">
                                <i class="fa fa-play text-success"></i>
                            </a>
                            <a class="btn btn-icon btn-clear" ng-show="task.status == 'InProgress'"
                                ng-click="closeTask(task)" uib-tooltip="Close">
                                <i class="fa fa-check-circle-o text-muted"></i>
                            </a>
                            <a class="btn btn-icon btn-clear" ng-show="task.status == 'Waiting'"
                                ng-click="startTask(task)" uib-tooltip="Start">
                                <i class="fa fa-play text-primary"></i>
                            </a>
                            <a href class="btn btn-icon btn-clear" ng-click="getTaskResponders(task, true)"
                                ng-if="appConfig.connectors.cortex.enabled" if-permission="manageAction"
                                allowed="{{userPermissions}}">
                                <i class="text-primary fa fa-cog"></i>
                            </a>
                        </td>
                    </tr>

                    <tr ng-if="task.description && collapseOptions[task._id]">
                        <td colspan="10" class="wrap">
                            <div marked="task.description" class="mt-xxs filter-panel markdown"></div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Show group table -->
        <div ng-if="state.showGrouped">
            <div class="panel panel-default" ng-repeat="group in groupedTasks">
                <div class="panel-heading">
                    <strong>{{group.group || 'Not Specified'}}</strong> <small>({{group.tasks.length}} task(s))</small>
                </div>
                <div class="panel-body p-0">
                    <table class="table table-hover valigned tasks-table data-list">
                        <thead>
                            <tr>
                                <th width="20px">
                                    <input if-permission="manageTask" allowed="{{userPermissions}}" type="checkbox"
                                        ng-model="menu.selectAll" ng-change="selectAll()">
                                </th>
                                <th style="width: 70px"></th>
                                <th style="width: 150px">Group</th>
                                <th style="width: 15px"></th>
                                <th>Task</th>
                                <th style="width: 70px;"></th>
                                <th style="width: 150px">Date</th>
                                <th style="width: 150px">Assignee</th>
                                <th style="width: 100px" class="text-right" if-permission="manageTask"
                                    allowed="{{userPermissions}}">Actions</th>
                            </tr>
                        </thead>
                        <tbody ng-repeat="task in group.tasks">
                            <tr class="task-row" ng-class="{'warning': task.flag == true}">
                                <td>
                                    <input if-permission="manageTask" allowed="{{userPermissions}}" type="checkbox"
                                        ng-model="task.selected" ng-change="select(task)">
                                </td>

                                <td class="task-status" align="center" ng-switch="task.status">
                                    <task-flags task="task" on-filter="addFilterValue(fieldName, value)" inline="true">
                                    </task-flags>
                                    <!-- <i ng-switch-when="Completed" class="text-success glyphicon glyphicon-ok" uib-tooltip="Completed"></i>
                                    <i ng-switch-when="InProgress" class="glyphicon" ng-class="{true:'text-yellow glyphicon-flag', false:'text-primary glyphicon-play'}[task.flag]" uib-tooltip="In Porgress"></i>
                                    <i ng-switch-when="Waiting" class="glyphicon" ng-class="{true:'text-yellow glyphicon-flag'}[task.flag]"></i> -->
                                </td>
                                <td ng-if="canEdit">
                                    <updatable-select options="groups" on-update="updateField('group', newValue, task)"
                                        value="task.group"></updatable-select>
                                </td>
                                <td ng-if="!canEdit">
                                    {{task.group}}
                                </td>
                                <td>
                                    <a href class="pull-right" ng-click="addFilterValue('group', task.group)"><i
                                            class="fa fa-filter"></i></a>
                                </td>
                                <td>
                                    <div>
                                        <a href ng-click="collapseOptions[task._id] = !collapseOptions[task._id]"
                                            ng-show="task.description" uib-tooltip="Show/Hide description"
                                            tooltip-placement="right">
                                            <i class="fa" ng-class="{
                                          true: 'fa-chevron-up',
                                          false: 'fa-chevron-down'
                                        }[!!collapseOptions[task._id]]"></i>
                                        </a>
                                        <a href ng-class="{'text-danger': !!task.extraData.actionRequired}"
                                            ng-click="addFilterValue('actionRequired', true)">
                                            <span ng-if="!!task.extraData.actionRequired"
                                                class="text-danger noline mr-xxxs" uib-tooltip="Action Required"
                                                tooltip-placement="left-middle">
                                                <i class="fa fa-exclamation-triangle"></i>
                                            </span>
                                        </a>
                                        <a href ui-sref="app.case.tasks-item({caseId: caseId, itemId:task._id})"
                                            ng-class="{'text-danger': !!task.extraData.actionRequired}">
                                            {{task.title}}
                                        </a>
                                    </div>
                                    <div ng-show="task.status === 'Completed'" class="text-success">
                                        Closed after <em>{{(task.endDate - task.startDate) | amDurationFormat :
                                            'milliseconds'}}</em>
                                    </div>
                                    <div ng-show="task.status === 'InProgress'" class="text-warning">
                                        Started <em am-time-ago="task.startDate"></em>
                                    </div>
                                </td>
                                <td align="center">
                                    <div ng-if="task.extraData.shareCount > 0">
                                        <a href ui-sref="app.case.tasks-item({caseId: caseId, itemId:task._id})"
                                            class="noline" tooltip-placement="left-middle">

                                            <i class="fa fa-users"></i>
                                            ({{task.extraData.shareCount || 0}})
                                        </a>
                                    </div>
                                </td>
                                <td>{{task.startDate | shortDate}}</td>
                                <td ng-if="canEdit">
                                    <span ng-show="task.assignee">
                                        <updatable-user blank-text="Not Assigned"
                                            on-update="updateField('owner', newValue, task)" value="task.assignee"
                                            query="getAssignableUsers" query-params="[task._id]" />
                                    </span>
                                    <span ng-show="!task.assignee">
                                        <updatable-user blank-text="Not Assigned"
                                            on-update="updateField('owner', newValue, task)" value="notassigned"
                                            query="getAssignableUsers" query-params="[task._id]" />
                                    </span>
                                </td>
                                <td ng-if="!canEdit">
                                    <span ng-show="task.assignee">
                                        <user-info value="task.assignee" field="name"></user-info>
                                    </span>
                                    <span ng-show="!task.assignee">
                                        <em class="text-warning">Not Assigned</em>
                                    </span>
                                </td>
                                <!--  class="task-delete" -->
                                <td align="right" class="task-actions" if-permission="manageTask"
                                    allowed="{{userPermissions}}">

                                    <a class="btn btn-icon btn-clear" ng-click="removeTask(task)" uib-tooltip="Delete">
                                        <i class="fa fa-trash text-danger"></i>
                                    </a>
                                    <a class="btn btn-icon btn-clear" ng-show="task.status == 'Completed'"
                                        ng-click="openTask(task)" uib-tooltip="Reopen">
                                        <i class="fa fa-play text-success"></i>
                                    </a>
                                    <a class="btn btn-icon btn-clear" ng-show="task.status == 'InProgress'"
                                        ng-click="closeTask(task)" uib-tooltip="Close">
                                        <i class="fa fa-check-circle-o text-muted"></i>
                                    </a>
                                    <a class="btn btn-icon btn-clear" ng-show="task.status == 'Waiting'"
                                        ng-click="startTask(task)" uib-tooltip="Start">
                                        <i class="fa fa-play text-primary"></i>
                                    </a>
                                    <a href class="btn btn-icon btn-clear" ng-click="getTaskResponders(task, true)"
                                        ng-if="appConfig.connectors.cortex.enabled" if-permission="manageAction"
                                        allowed="{{userPermissions}}">
                                        <i class="text-primary fa fa-cog"></i>
                                    </a>
                                </td>
                            </tr>
                            <tr ng-if="task.description && collapseOptions[task._id]">
                                <td colspan="10" class="wrap">
                                    <div marked="task.description" class="mt-xxs filter-panel markdown"></div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <psearch control="list"></psearch>
    </div>
</div>

```

`frontend/app/views/partials/case/case.tasks.item.html`:

```html
<div class="vpad10">
    <div class="mb-xs" ng-if="task.extraData.actionRequired === true">
        <div class="alert bg-yellow">
            <h4>
                <i class="icon fa fa-exclamation-triangle"></i> Action Required!
            </h4>
            <div>
                This task requires an action from your organisation.
                <button if-permission="manageTask" allowed="{{userPermissions}}" class="ml-m btn btn-sm btn-default"
                    ng-click="markAsDone(task)">Mark as Done</button>
            </div>
        </div>
    </div>
    <h4 class="mb-xs text-primary">
        Basic Information

        <div class="task-actions pull-right" if-permission="manageTask" allowed="{{userPermissions}}">
            <!-- <span if-permission="manageShare" allowed="{{userPermissions}}"> -->
            <span>
                <a href ng-click="scrollTo('#task-sharings')">
                    <span class="mr-xxs action-button">
                        <i class="fa fa-users"></i> Sharing ({{shares.length || 0}})
                    </span>
                </a>

                <span class="mr-xxs text-primary">|</span>
            </span>

            <a href ng-if="!!!task.extraData.actionRequired" ng-click="markAsActionRequired(task)">
                <span class="mr-xxs action-button text-primary">
                    <i class="fa fa-exclamation-triangle"></i> Require Action
                </span>
            </a>

            <a href ng-click="switchFlag()">
                <span class="mr-xxs action-button" ng-class="{true: 'text-yellow', false: 'text-muted'}[task.flag]">
                    <i class="fa fa-flag"></i> {{task.flag ? 'Unflag' : 'Flag'}}
                </span>
            </a>

            <a href ng-click="startTask(task)">
                <span ng-show="task.status == 'Waiting'" class="action-button text-primary">
                    <i class="fa fa-play"></i> Start
                </span>
            </a>

            <a href ng-click="openTask(task)">
                <span ng-show="task.status == 'Completed'" class="action-button text-success">
                    <i class="fa fa-check-circle"></i> Reopen
                </span>
            </a>

            <a href ng-click="closeTask(task)">
                <span ng-show="task.status == 'InProgress'" class="action-button text-muted">
                    <i class="fa fa-check-circle-o"></i> Close
                </span>
            </a>

            <span class="action-button" uib-dropdown ng-if="appConfig.connectors.cortex.enabled"
                if-permission="manageAction" allowed="{{userPermissions}}">

                <span class="mh-xxs text-primary">|</span>

                <a href class="text-primary noline" ng-click="getTaskResponders(true)">
                    <i class="text-primary fa fa-cog"></i>
                    Responders
                </a>
                <!--
                <ul class="dropdown-menu dropdown-menu-right" uib-dropdown-menu>
                  <li ng-if="taskResponders && taskResponders.length === 0">
                    <a href ng-click="getTaskResponders(true)">
                      <strong><i class="fa fa-refresh mr-xxs"></i> No responders available</strong>
                    </a>
                  </li>
                  <li ng-repeat="responder in taskResponders">
                    <a href ng-click="runResponder(responder.id, responder.name)">
                      <strong>{{responder.name}}</strong>
                      <br>
                      <small>{{responder.description}}</small></a>
                  </li>
                </ul> -->
            </span>

        </div>
    </h4>
</div>

<div class="row">
    <div class="col-md-6">
        <dl class="dl-horizontal">
            <dt class="pull-left">Title</dt>
            <dd ng-if="canEdit">
                <updatable-simple-text on-update="updateField('title', newValue)" value="task.title" />
            </dd>
            <dd ng-if="!canEdit">
                {{task.title}}
            </dd>
        </dl>

        <dl class="dl-horizontal">
            <dt class="pull-left">Group</dt>
            <dd ng-if="canEdit">
                <updatable-simple-text on-update="updateField('group', newValue)" value="task.group" />
            </dd>
            <dd ng-if="!canEdit">
                {{task.group}}
            </dd>
        </dl>

        <dl class="dl-horizontal">
            <dt class="pull-left">Assignee</dt>
            <dd ng-if="canEdit">
                <updatable-user blank-text="Not Assigned" on-update="updateField('owner', newValue)"
                    value="task.assignee" query="assignableUsersQuery" />
            </dd>
            <dd ng-if="!canEdit">
                <user-info value="task.assignee" field="name"></user-info>
            </dd>
        </dl>
    </div>

    <div class="col-md-6">
        <dl class="dl-horizontal">
            <dt class="pull-left">Start date</dt>
            <dd ng-if="canEdit && task.status !== 'Waiting'">
                <updatable-date on-update="updateField('startDate', newValue)" value="task.startDate" />
            </dd>
            <dd ng-if="!canEdit && task.status !== 'Waiting'">
                <span ng-bind="task.startDate | shortDate"></span>
            </dd>
            <dd ng-if="task.status === 'Waiting'">
                <em class="text-warning">Not started yet</em>
            </dd>
        </dl>

        <dl class="dl-horizontal" ng-show="task.status == 'Completed'">
            <dt class="pull-left">Close date</dt>
            <dd>
                <span ng-bind="task.endDate | shortDate"></span>
            </dd>
        </dl>

        <dl class="dl-horizontal" ng-class="{'Completed': 'text-success', 'InProgress': 'text-warning'}[task.status]">
            <dt class="pull-left">Duration</dt>
            <dd ng-switch="task.status">
                <span ng-switch-when="Completed">
                    Closed after <em ng-bind="(task.endDate - task.startDate) | amDurationFormat : 'milliseconds'"></em>
                </span>
                <span ng-switch-when="InProgress">
                    Started <em am-time-ago="task.startDate"></em>
                </span>
                <span ng-switch-default>
                    <em class="text-warning">Not started yet</em>
                </span>
            </dd>
        </dl>

        <dl class="dl-horizontal" ng-show="task.status !== 'Completed'">
            <dt class="pull-left">Status
            </dt>
            <dd>
                <span ng-bind="task.status"></span>
            </dd>
        </dl>
    </div>

    <div class="col-md-12">
        <h4 class="vpad10 text-primary">Description</h4>
        <div ng-if="canEdit" class="description-pane">
            <updatable-text on-update="updateField('description', newValue)" placeholder="Task description"
                value="task.description"></updatable-text>
        </div>
        <div ng-if="!canEdit" class="description-pane">
            <div marked="task.description" class="markdown"></div>
            <em ng-if="!task.description" class="text-warning">Not specified</em>
        </div>
    </div>

    <!-- New Log -->
    <div class="col-md-12">
        <h4 class="vpad10 text-primary">Task logs</h4>

        <div class="row clearfix" ng-show="!adding">
            <div class="col-md-12">
                <div class="btn-toolbar" role="toolbar">
                    <div class="btn-group" uib-dropdown if-permission="manageTask" allowed="{{userPermissions}}">
                        <button class="btn btn-sm btn-primary" ng-click="showLogEditor()">
                            <i class="fa fa-plus"></i>
                            Add new task log</button>
                    </div>
                    <div class="btn-group" uib-dropdown>
                        <button class="btn btn-primary btn-sm dropdown-toggle" uib-dropdown-toggle type="button">
                            <i class="fa fa-sort"></i>
                            Sort by: {{sortOptions[state.sort]}}
                            <span class="caret"></span>
                        </button>
                        <ul class="dropdown-menu" uib-dropdown-menu>
                            <li ng-repeat="(key, value) in sortOptions">
                                <a ng-click="sortBy(key)">{{value}}</a>
                            </li>
                        </ul>
                    </div>
                    <div class="btn-group pull-right" role="group">
                        <page-sizer collection="logs" sizes="[10, 15, 30, 100]"></page-sizer>
                    </div>
                </div>

            </div>
        </div>
        <div class="row" ng-show="adding">
            <div class="col-md-12">
                <div class="clearfix">
                    <a class="pull-right" href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet"
                        target="_blank"><i class="fa fa-question-circle"></i> Markdown Reference</a>
                </div>
                <textarea name="newLog" autofocus="beforeNewLogShow" class="content-box"
                    markdown-editor="markdownEditorOptions" rows="10" ng-model="newLog.message"></textarea>
                <div control="state" file-chooser="" filemodel="newLog.attachment" ng-show="!state.attachmentCollapsed"
                    preview="false"></div>
                <div class="btn-toolbar mt-xxs">
                    <button class="btn btn-sm btn-default" ng-click="cancelAddLog();"
                        ng-disabled="loading">Cancel</button>
                    <button class="btn btn-sm btn-primary pull-right" ng-click="addLog();"
                        ng-disabled="loading || newLog.message.length === 0">
                        <i class="glyphicon glyphicon-comment"></i>
                        Add log
                    </button>
                    <button uib-btn-checkbox btn-checkbox-false="true" btn-checkbox-true="false"
                        class="btn btn-sm btn-default pull-right" ng-model="state.attachmentCollapsed"
                        ng-disabled="loading">
                        <i class="text-default glyphicon glyphicon-paperclip"></i>
                        {{state.attachmentCollapsed ? 'Add' : 'Discard'}}
                        attachment
                    </button>
                </div>
            </div>
        </div>

        <!-- Log list -->
        <div class="row mv-s" ng-show="logs.total === 0">
            <div class="col-md-12">
                <div class="empty-message">No records</div>
            </div>
        </div>

        <psearch control="logs"></psearch>
        <div ng-repeat="log in logs.values">
            <log-entry log="log" app-config="appConfig" permissions="userPermissions"></log-entry>
        </div>
        <psearch control="logs"></psearch>
    </div>

    <!-- <div class="col-md-12" id="task-sharings" if-permission="manageShare" allowed="{{userPermissions}}"> -->
    <div class="col-md-12" id="task-sharings">
        <h4 class="vpad10 text-primary">Task sharing</h4>
        <div class="btn-toolbar" role="toolbar" if-permission="manageShare" allowed="{{userPermissions}}">
            <div class="btn-group">
                <button class="btn btn-sm btn-primary" ng-click="addTaskShare()">
                    <i class="fa fa-plus"></i>
                    Add share
                </button>
            </div>
        </div>
        <div class="mv-s">
            <task-sharing-list task="task" shares="shares" read-only="true"
                on-require-action="markShareAsActionRequired(task, org)"
                on-cancel-require-action="markShareAsActionDone(task, org)" on-delete="removeShare(share)"
                permissions="userPermissions"></task-sharing-list>
        </div>
    </div>

    <div class="col-md-12">
        <div class="task-actions vpad10" ng-if="actions.values.length">
            <responder-actions header="Responder Jobs" actions="actions"></responder-actions>
        </div>
    </div>

</div>

```

`frontend/app/views/partials/case/case.templates.selector.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">Create new Case</h3>
</div>
<div class="modal-body">
    <div class="mv-xs" ng-if="!!!dialog.state.hideEmptyCaseButton">
        <button class="btn btn-block btn-primary btn-lg" ng-click="dialog.next()">
            Empty Case
        </button>

        <p class="mv-m text-separator text-muted">OR</p>
    </div>

    <div class="box box-default">
        <div class="box-header">
            <h3 class="box-title">Select a template</h3>
            <div class="box-tools pull-right">
                <div class="has-feedback">
                    <input type="text" ng-model="dialog.state.filter" class="form-control input-sm"
                        placeholder="Filter templates" autofocus>
                    <span class="glyphicon glyphicon-search form-control-feedback"></span>
                </div>
            </div>
        </div>
        <div class="box-body template-selector">
            <div class="empty-message" ng-if="dialog.filteredTemplate.length === 0">
                No templates found
            </div>
            <table class="table table-hover table-striped">
                <tbody>
                    <tr ng-repeat="template in dialog.filteredTemplate = (dialog.templates | filter:dialog.state.filter | orderBy:'displayName' | orderBy:'name')"
                        class="clickable" ng-class="{'active': dialog.state.selected === template.id}"
                        ng-click="dialog.next(template)">
                        <td>
                            <strong>{{template.displayName || template.name}}</strong><br>
                            <p class="list-group-item-text text-muted">{{template.description | ellipsis:200}}</p>
                        </td>
                    </tr>
                </tbody>
            </table>

        </div>
    </div>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="dialog.cancel()" type="button">Cancel</button>
</div>

```

`frontend/app/views/partials/case/case.update.html`:

```html
<form class="form-horizontal" name="caseForm" ng-submit="$dialog.save(caseForm);" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Update case(s)</h3>
    </div>

    <div class="modal-body">
        <p class="mb-xs">
            Select the changes you want to apply to the selected cases. (<a href ng-click="$dialog.toggleAll()">{{$dialog.state.all ? 'Uncheck All' : 'Check all'}}</a>)
        </p>

        <div class="form-group">
            <label class="col-md-3 control-label">TLP <input class="ml-xxs" type="checkbox" ng-model="$dialog.state.enableTlp"></label>
            <div class="col-md-9">
                <p class="form-control-static">
                    <a href ng-click="$dialog.activeTlp = 'active'">
                        <tlp value="$dialog.params.tlp" format="$dialog.activeTlp" on-update="$dialog.toggleTlp(newValue)" class="form-control-static"></tlp>
                    </a>
                </p>
            </div>
        </div>

        <div class="form-group">
            <label class="col-md-3 control-label">PAP <input class="ml-xxs" type="checkbox" ng-model="$dialog.state.enablePap"></label>
            <div class="col-md-9">
                <p class="form-control-static">
                    <a href ng-click="$dialog.activePap = 'active'">
                        <tlp value="$dialog.params.pap" format="$dialog.activePap" namespace="PAP" on-update="$dialog.togglePap(newValue)" class="form-control-static"></tlp>
                    </a>
                </p>
            </div>
        </div>

        <div class="form-group">
            <label class="col-md-3 control-label">Severity <input class="ml-xxs" type="checkbox" ng-model="$dialog.state.enableSeverity"></label>
            <div class="col-md-9">
                <p class="form-control-static">
                    <a href ng-click="$dialog.activeSeverity = true">
                        <severity active="$dialog.activeSeverity" on-update="$dialog.toggleSeverity(newValue)" value="$dialog.params.severity"></severity>
                    </a>
                </p>
            </div>
        </div>

        <div class="form-group" ng-class="{ 'has-error' : caseForm.addTags.$invalid && !caseForm.addTagsInput.$pristine }">
            <label class="col-md-3 control-label">Add Tags <input class="ml-xxs" type="checkbox" ng-model="$dialog.state.enableAddTags"></label>
            <div class="col-md-9">
                <input type="hidden" name="addTags" ng-model="$dialog.params.addTagNames" ng-required="$dialog.state.enableAddTags"/>

                <div class="input-group">
                    <tags-input name="addTagsInput" ng-model="$dialog.params.addTags" class="ti-input-sm ti-tag-selector"
                        placeholder="Add tags" replace-spaces-with-dashes="false" min-length="2"
                        on-tag-added="$dialog.toggleAddTags()" template="views/directives/tag-input-item.html">
                        <auto-complete min-length="3" debounce-delay="400" source="$dialog.getTags($query)"></auto-complete>
                    </tags-input>

                    <span class="input-group-btn vtop">
                        <button type="button" class="btn btn-block btn-sm btn-primary" ng-click="$dialog.fromTagLibrary('add')" uib-tooltip="Add tag from library" tooltip-placement="left">
                            <span class="fa fa-plus"></span>
                        </button>
                    </span>
                </div>

            </div>
        </div>

        <div class="form-group" ng-class="{ 'has-error' : caseForm.removeTags.$invalid && !caseForm.removeTagsInput.$pristine }">
            <label class="col-md-3 control-label">Remove Tags <input class="ml-xxs" type="checkbox" ng-model="$dialog.state.enableRemoveTags"></label>
            <div class="col-md-9">
                <input type="hidden" name="removeTags" ng-model="$dialog.params.removeTagNames" ng-required="$dialog.state.enableRemoveTags"/>
                <div class="input-group">
                    <tags-input name="removeTagsInput" ng-model="$dialog.params.removeTags" class="ti-input-sm ti-tag-selector"
                        placeholder="Remove tags" replace-spaces-with-dashes="false" min-length="2"
                        on-tag-added="$dialog.toggleRemoveTags()" template="views/directives/tag-input-item.html">
                        <auto-complete min-length="3" debounce-delay="400" source="$dialog.getTags($query)"></auto-complete>
                    </tags-input>

                    <span class="input-group-btn vtop">
                        <button type="button" class="btn btn-block btn-sm btn-primary" ng-click="$dialog.fromTagLibrary('remove')" uib-tooltip="Add tag from library" tooltip-placement="left">
                            <span class="fa fa-plus"></span>
                        </button>
                    </span>
                </div>
            </div>
        </div>
    </div>



    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$dialog.cancel()" type="button">Cancel</button>
        <button class="btn btn-primary pull-right" ng-disabled="caseForm.$invalid" type="submit">Update case(s)</button>
    </div>
</form>

```

`frontend/app/views/partials/case/details/custom.fields.html`:

```html
<div class="case-custom-fields" ng-controller="CaseCustomFieldsCtrl">
    <h4 class="vpad10 text-primary">
        Additional information
        <span uib-dropdown class="ml-m" ng-if="canEdit && customFieldsAvailable">
            <a href class="dropdown-toggle" uib-dropdown-toggle>
                <small><i class="fa fa-plus"></i> Add</small>
            </a>
            <ul class="dropdown-menu scroll-dropdown" uib-dropdown-menu>
                <li ng-repeat="key in keys(allCustomFields) | orderBy">
                    <a ng-click="addCustomField(allCustomFields[key])">{{allCustomFields[key].name}}</a>
                </li>
            </ul>
        </span>

        <span uib-dropdown class="ml-m">
            <a href class="dropdown-toggle" uib-dropdown-toggle>
                <small><i class="fa fa-columns"></i> Layout</small>
            </a>
            <ul class="dropdown-menu scroll-dropdown" uib-dropdown-menu>
                <li ng-class="{'active': appLayout.caseCustomFieldColumns === 1}">
                    <a ng-click="layoutSrv.caseCustomFields(1)">1 column</a>
                </li>
                <li ng-class="{'active': appLayout.caseCustomFieldColumns === 2}">
                    <a ng-click="layoutSrv.caseCustomFields(2)">2 columns</a>
                </li>
                <li ng-class="{'active': appLayout.caseCustomFieldColumns === 3}">
                    <a ng-click="layoutSrv.caseCustomFields(3)">3 columns</a>
                </li>
            </ul>
        </span>
    </h4>

    <div ng-if="caze.customFields.length === 0">
        <em>No additional information have been specified</em>
    </div>

    <div class="row">
        <div ng-repeat="customField in (caze.customFields | orderBy:'order') track by $index">
            <div class="clearfix" ng-if="$index % (appLayout.caseCustomFieldColumns || 3) == 0"></div>
            <div class="{{'col-xs-' + (12/(appLayout.caseCustomFieldColumns || 3))}}">
                <custom-field-input
                    index="$index"
                    editable="canEdit"
                    removable="canEdit"
                    field="customFieldsCache[customField.name]"
                    on-update="updateField(fieldName, value)"
                    on-remove="removeField(fieldId)"
                    value="customField.value"
                    id="customField._id"></custom-field-input>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/case/details/related.cases.html`:

```html
<div class="case-links" ng-show="links.length > 0">
    <h4 class="vpad10 text-primary">Related cases</h4>

    <div>
        <h5>Newest (<a href ui-sref="app.case.details({caseId:links[0].id})">Case # {{newestLink.caseId}} - {{newestLink.title}}</a>)</h5>
        <div>
            Created on <strong>{{newestLink.startDate | shortDate:'YYYY-MM-DD'}}</strong>
        </div>
        <div>
            Shares <strong><ng-pluralize count="newestLink.linksCount" when="{'one': '1 observable', 'other': '{} observables'}"></ng-pluralize></strong>
            <strong ng-if="newestLink.iocCount > 0" class="text-danger">
                (<ng-pluralize count="newestLink.iocCount" when="{'0': 'No IOCs', 'one': '1 IOC', 'other': '{} IOCs'}"></ng-pluralize>)
            </strong>
        </div>
        <div ng-if="newestLink.tags.length > 0">
            Tagged as <tag-list data="newestLink.tags"></tag-list>
        </div>
        <div class="hr-line-dashed"></div>
    </div>

    <div ng-show="links.length > 1">
        <h5>Oldest (<a href ui-sref="app.case.details({caseId:oldestLink.id})">Case # {{oldestLink.caseId}} - {{oldestLink.title}}</a>)</h5>
        <div>
            Created on <strong>{{oldestLink.startDate | shortDate:'YYYY-MM-DD'}}</strong>
        </div>
        <div>
            Shares
            <strong><ng-pluralize count="oldestLink.linksCount" when="{'one': '1 observable', 'other': '{} observables'}"></ng-pluralize></strong>
            <strong ng-if="oldestLink.iocCount > 0" class="text-danger">
                (<ng-pluralize count="oldestLink.iocCount" when="{'one': '1 IOC', 'other': '{} IOCs'}"></ng-pluralize>)
            </strong>
        </div>
        <div ng-if="oldestLink.tags.length > 0">
            Tagged as <tag-list data="oldestLink.tags"></tag-list>
        </div>
        <div class="hr-line-dashed"></div>
    </div>

    <div class="mt-xs">
        <a href ui-sref="app.case.links({caseId:caze._id})">
            See all (<ng-pluralize count="links.length" when="{'one': '1 related case', 'other': '{} related cases'}"></ng-pluralize>)
        </a>
    </div>
</div>

```

`frontend/app/views/partials/case/list/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>
        <form ng-submit="$vm.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $vm.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$vm.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in $vm.filtering.attributeKeys"
                            ng-change="$vm.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$vm.filtering.metadata" filter="filter" entity="$vm.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$vm.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$vm.clearFilters()" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/partials/case/list/mini-stats.html`:

```html
<div class="row" ng-controller="CaseStatsCtrl as statsCtrl">
    <div class="col-md-4">
        <div class="stats-item-wrapper">
            <stats-item title="Case by Status" mode="'chart'" field="status" data="statsCtrl.byStatus.details" on-item-clicked="$vm.addFilterValue(field, value)">
            </stats-item>
        </div>
    </div>

    <div class="col-md-4">
        <div class="stats-item-wrapper">
            <stats-item title="Case by Resolution" mode="'chart'" field="resolutionStatus" data="statsCtrl.byResolution.details" on-item-clicked="$vm.addFilterValue(field, value)">
            </stats-item>
        </div>
    </div>

    <div class="col-md-4">
        <div class="stats-item-wrapper">
            <stats-item title="Top 5 tags" mode="'chart'" field="tags" data="statsCtrl.byTags.details" on-item-clicked="$vm.addFilterValue(field, value)">
            </stats-item>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/case/list/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <div class="btn-group" uib-dropdown if-permission="manageCase">
                <button type="button" class="btn btn-sm btn-default" uib-dropdown-toggle
                    ng-disabled="$vm.selection.length === 0">
                    <ng-pluralize count="$vm.selection.length"
                        when="{'0': 'No case selected', 'one': '{} selected case', 'other': '{} selected cases'}">
                    </ng-pluralize>
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a href ng-click="$vm.bulkEdit()"><i class="fa fa-edit"></i> Edit</a>
                    </li>
                    <li class="divider"></li>
                    <li ng-if="$vm.menu.flag">
                        <a href ng-click="$vm.bulkFlag(true)"><i class="fa fa-flag"></i> Add flag</a>
                    </li>
                    <li ng-if="$vm.menu.unflag">
                        <a href ng-click="$vm.bulkFlag(false)"><i class="fa fa-flag-o"></i> Remove flag</a>
                    </li>
                    <li ng-if="$vm.menu.reopen">
                        <a href ng-click="$vm.bulkReopen()"><i class="fa fa-folder-open"></i> Reopen</a>
                    </li>
                    <li ng-if="$vm.menu.close">
                        <a href ng-click="$vm.bulkClose()"><i class="fa fa-folder"></i> Close</a>
                    </li>
                    <li ng-if="$vm.menu.delete" class="divider"></li>
                    <li>
                        <a href ng-click="$vm.bulkRemove()"><i class="fa fa-trash"></i> Delete</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group" uib-dropdown>
                <button class="btn btn-primary btn-sm dropdown-toggle" uib-dropdown-toggle type="button">
                    <i class="fa fa-filter"></i>
                    Quick Filters
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a ng-click="$vm.filterByStatus('Open')"><i class="fa fa-folder-open-o"></i> Open cases</a>
                    </li>
                    <li>
                        <a ng-click="$vm.filterByStatus('Resolved')"><i class="fa fa-folder-o"></i> Closed cases</a>
                    </li>
                    <li class="divider"></li>
                    <li>
                        <a ng-click="$vm.filterMyOpenCases()"><i class="fa fa-folder-open"></i> My open cases</a>
                    </li>
                    <li>
                        <a ng-click="$vm.filterMyCases()"><i class="fa fa-user"></i> My cases</a>
                    </li>
                    <li class="divider"></li>
                    <li>
                        <a ng-click="$vm.filterMyOrgCases()"><i class="fa fa-building-o"></i> Owned by my org</a>
                    </li>
                    <li>
                        <a ng-click="$vm.filterSharedWithMyOrg()"><i class="fa fa-share-square"></i> Shared with my
                            org</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group" uib-dropdown>
                <button class="btn btn-primary btn-sm dropdown-toggle" uib-dropdown-toggle type="button">
                    <i class="fa fa-sort"></i>
                    Sort by
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a ng-click="$vm.sortBy(['-flag', '-startDate'])">Newest first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-flag', '+startDate'])">Oldest first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-flag', '-severity'])">High Severity first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-flag', '+severity'])">Low Severity first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-flag', '+assignee'])">Ascendant assignee</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-flag', '-assignee'])">Descendant assignee</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm"
                    ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]"
                    type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm"
                    ng-class="{true: 'btn-primary', false:'btn-default'}[!!$vm.filtering.context.showStats]"
                    type="button" ng-click="$vm.toggleStats()">
                    <i class="fa fa-bar-chart"></i> Stats
                </button>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm"
                    ng-class="{true: 'btn-primary', false:'btn-default'}[!!$vm.filtering.context.showAdvanced]"
                    type="button" ng-click="$vm.toggleAdvanced()">
                    <i class="fa fa-code"></i> Custom Fields
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/case/procedures/add-procedure.modal.html`:

```html
<form name="procedureForm" class="procedure-modal" ng-submit="$modal.addProcedure()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Add Tactic, Technique and Procedure</h3>
    </div>
    <div class="modal-body">

        <div class="row">
            <div class="col-sm-6">
                <div class="form-group"
                    ng-class="{ 'has-error' : procedureForm.tactic.$invalid && !procedureForm.tactic.$pristine }">
                    <label>
                        Tactic
                        <i class="fa fa-asterisk text-danger"></i>
                    </label>
                    <select class="form-control" name="tactic" ng-model="$modal.procedure.tactic"
                        autofocus="beforeProcedureModalShow"
                        ng-options="tactic as $modal.tactics.values[tactic].label for tactic in $modal.tactics.keys"
                        required ng-change="$modal.showTechniques()">
                    </select>
                    <p class="help-block" ng-show="procedureForm.tactic.$invalid && !procedureForm.tactic.$pristine">
                        This field is required.</p>
                </div>
            </div>
            <div class="col-sm-6">
                <div class="form-group"
                    ng-class="{ 'has-error' : procedureForm.occureDate.$invalid && !procedureForm.occureDate.$pristine }">
                    <label>
                        Occur Date
                        <i class="fa fa-asterisk text-danger"></i>
                    </label>
                    <div>
                        <date-time-picker date="$modal.procedure.occurDate" name="occurDate"></date-time-picker>
                        <p class="help-block"
                            ng-show="procedureForm.occureDate.$invalid && !procedureForm.occureDate.$pristine">The field
                            is required.</p>
                    </div>
                </div>
            </div>
        </div>


        <div class="form-group"
            ng-class="{ 'has-error' : procedureForm.pattern.$invalid && !procedureForm.pattern.$pristine }">
            <label>
                Technique
                <i class="fa fa-asterisk text-danger"></i>
            </label>

            <div ng-show="!$modal.procedure.tactic" class="text-muted">
                Please select a tactic above.
            </div>

            <div ng-show="$modal.procedure.tactic">
                <input type="text" class="form-control mv-xxxs" placeholder="Filter techniques"
                    ng-model="$modal.state.search">
                <input type="hidden" ng-model="$modal.procedure.patternId" required>
                <div class="procedure-techniques-list p-xxs">

                    <div ng-repeat="technique in $modal.state.techniques | filter:$modal.state.search">
                        <div class="procedure-techniques-item"
                            ng-class="{'active': $modal.procedure.patternId === technique.patternId}"
                            ng-click="$modal.procedure.patternId = technique.patternId">
                            <div class="radio">
                                <label class="procedure-technique"
                                    ng-class="{'sub-technique': technique.isSubTechnique}">
                                    <input type="radio" name="pattern" ng-value="technique.patternId"
                                        ng-model="$modal.procedure.patternId">

                                    <span ng-if="!!!technique.isSubTechnique">{{technique.patternId}} -
                                        {{technique.name}}</span>
                                    <span ng-if="!!technique.isSubTechnique">{{technique.patternId}} -
                                        {{technique.extraData.parent.name}}:{{technique.name}}</span>

                                    <span class="pull-right ml-xxs">
                                        <a href="{{technique.url}}" target="_blank">
                                            <i class="fa fa-external-link"></i>
                                        </a>
                                    </span>
                                    <span class="pull-right">
                                        <i class="fa fa-question-circle" uib-tooltip="{{technique.description}}"
                                            tooltip-placement="left-center"></i>
                                    </span>

                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                <p class="help-block" ng-show="procedureForm.pattern.$invalid && !procedureForm.pattern.$pristine">This
                    field is required.</p>
            </div>



        </div>

        <div class="mv-xxs" ng-if="!$modal.showProcedure">
            <a href ng-click="$modal.showProcedure = true"><i class="fa fa-plus"></i> Add Procedure</a>
        </div>

        <div class="form-group" ng-if="$modal.showProcedure"
            ng-class="{ 'has-error' : procedureForm.description.$invalid && !procedureForm.description.$pristine }">
            <label>Procedure</label>
            <div>
                <div class="clearfix">
                    <a class="pull-right" href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet"
                        target="_blank">
                        <i class="fa fa-question-circle"></i> Markdown Reference
                    </a>
                </div>

                <textarea name="procedure" class="content-box" markdown-editor="$modal.markdownEditorOptions" rows="10"
                    ng-model="$modal.procedure.description" required></textarea>

                <p class="help-block"
                    ng-show="procedureForm.description.$invalid && !procedureForm.description.$pristine">This field is
                    required.</p>
            </div>
        </div>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$modal.cancel()" type="button">Cancel</button>

        <button class="btn btn-primary pull-right" type="submit"
            ng-disabled="$modal.state.loading || procedureForm.$invalid">
            Add TTP
        </button>
    </div>
</form>

```

`frontend/app/views/partials/case/procedures/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>

        <form ng-submit="$vm.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $vm.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$vm.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in $vm.filtering.attributeKeys"
                            ng-change="$vm.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$vm.filtering.metadata" filter="filter" entity="$vm.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$vm.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$vm.clearFilters()" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/partials/case/procedures/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <div class="btn-group" if-permission="manageProcedure" allowed="{{userPermissions}}">
                <button class="btn btn-sm btn-primary" ng-click="$vm.addProcedure()">
                    <i class="glyphicon glyphicon-plus"></i>
                    Add TTP
                </button>
            </div>

            <div class="btn-group" uib-dropdown>
                <button class="btn btn-sm btn-primary dropdown-toggle" uib-dropdown-toggle type="button">
                    <i class="fa fa-sort"></i>
                    Sort by
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a ng-click="$vm.sortBy(['-_createdAt'])">Newest first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['+_createdAt'])">Oldest first</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['-_updatedAt'])">Recently updated</a>
                    </li>
                    <li>
                        <a ng-click="$vm.sortBy(['+_updatedAt'])">Least recently updated</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm"
                    ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]"
                    type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/case/share/case.share.modal.html`:

```html
<form name="shareForm" ng-submit="$modal.save()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Share case</h3>
    </div>
    <div class="modal-body">

        <p>
            Select the organisations you would like to share the case with.
        </p>

        <div class="form-group" ng-class="{ 'has-error' : shareForm.organisations.$invalid && !shareForm.organisations.$pristine }">
            <label>
                Organisation
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <select class="form-control" name="organisations" ng-model="$modal.formData.organisations"
                ng-options="organisation for organisation in $modal.organisations" multiple size="10" required>
            </select>
            <p class="help-block" ng-show="shareForm.organisations.$invalid && !shareForm.organisations.$pristine">This field is required.</p>
        </div>

        <div class="form-group" ng-class="{ 'has-error' : shareForm.profile.$invalid && !shareForm.profile.$pristine }">
            <label>
                Profile
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <select class="form-control" name="profile" ng-model="$modal.formData.profile" ng-options="profile for profile in $modal.profiles" required>
                    <option value="" disabled selected>-- Select profile --</option>
            </select>
            <p class="help-block" ng-show="shareForm.profile.$invalid && !shareForm.profile.$pristine">This field is required.</p>
        </div>

        <div class="form-group">
            <label>
                Tasks
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <select class="form-control" name="tasks" ng-model="$modal.formData.tasks"
                ng-options="item for item in $modal.options">
            </select>
        </div>

        <div class="form-group">
            <label>
                Observables
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <select class="form-control" name="observables" ng-model="$modal.formData.observables"
                ng-options="item for item in $modal.options">
            </select>
        </div>

    </div>
    <div class="modal-footer">
        <button class="btn btn-default pull-left" type="button" ng-click="$modal.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="shareForm.$invalid">Save</button>
    </div>
</form>

```

`frontend/app/views/partials/case/tasklogs/add-task-log.modal.html`:

```html
<form class="task-log-dialog" ng-submit="$modal.addLog()">
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Add task log</h3>
    </div>
    <div class="modal-body">
        <!-- Intro message -->
        <p ng-if="!$modal.config.isHtml">{{$modal.config.prompt}}</p>
        <p ng-if="$modal.config.isHtml" ng-bind-html="$modal.config.prompt"></p>

        <!-- Task log form -->
        <div class="task log">
            <div class="clearfix">
                <a class="pull-right" href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank">
                    <i class="fa fa-question-circle"></i> Markdown Reference
                </a>
            </div>

            <textarea name="newLog" autofocus="beforeNewTaskLogShow" class="content-box" markdown-editor="$modal.markdownEditorOptions" rows="10" ng-model="$modal.data.message"></textarea>

            <div class="mt-xxxs" control="$modal.state"
                file-chooser="" filemodel="$modal.data.attachment" ng-show="!$modal.state.attachmentCollapsed" preview="false"></div>
        </div>

    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$modal.cancel()" type="button">Cancel</button>

        <button class="btn btn-primary pull-right" type="submit" ng-disabled="$modal.state.loading || !$modal.data.message || $modal.data.message.length === 0">
            <i class="glyphicon glyphicon-comment"></i> Add log
        </button>

        <button uib-btn-checkbox btn-checkbox-false="true" btn-checkbox-true="false"
            class="btn btn-default pull-right"
            ng-model="$modal.state.attachmentCollapsed" ng-disabled="$modal.state.loading" type="button">
            <i class="text-default glyphicon glyphicon-paperclip"></i>
            {{$modal.state.attachmentCollapsed ? 'Add' : 'Discard'}}
            attachment
        </button>
    </div>
</form>

```

`frontend/app/views/partials/case/tasks/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>
        <form ng-submit="search()">
            <div class="row mb-xxxs" ng-repeat="filter in filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item.name as item.name for (key, item) in filtering.attributes"
                            ng-change="filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="filtering.metadata" filter="filter" entity="filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="clearFilters()" ng-if="filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>
    </div>
</div>

```

`frontend/app/views/partials/case/tasks/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <div class="btn-group" uib-dropdown if-permission="manageTask" allowed="{{userPermissions}}">
                <button type="button" class="btn btn-sm btn-default" uib-dropdown-toggle
                    ng-disabled="selection.length === 0">
                    <ng-pluralize count="selection.length"
                        when="{'0': 'No tasks selected', 'one': '{} selected task', 'other': '{} selected tasks'}">
                    </ng-pluralize>
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li ng-if="menu.flag">
                        <a href ng-click="bulkFlag(true)"><i class="fa fa-flag"></i> Add flag</a>
                    </li>
                    <li ng-if="menu.unflag">
                        <a href ng-click="bulkFlag(false)"><i class="fa fa-flag-o"></i> Remove flag</a>
                    </li>
                    <li ng-if="menu.start">
                        <a href ng-click="bulkStatus('InProgress')"><i class="fa fa-play"></i> Start</a>
                    </li>
                    <li ng-if="menu.reopen">
                        <a href ng-click="bulkStatus('InProgress')"><i class="fa fa-folder-open"></i> Reopen</a>
                    </li>
                    <li ng-if="menu.close">
                        <a href ng-click="bulkStatus('Completed')"><i class="fa fa-folder"></i> Close</a>
                    </li>
                    <li ng-if="menu.delete" class="divider"></li>
                    <li>
                        <a href ng-click="bulkRemove()"><i class="fa fa-trash"></i> Delete</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group" if-permission="manageTask" allowed="{{userPermissions}}">
                <button class="btn btn-sm btn-primary" ng-click="state.isNewTask = true">
                    <i class="glyphicon glyphicon-plus"></i>
                    Add Task
                </button>
            </div>

            <div class="btn-group" uib-dropdown>
                <button class="btn btn-primary btn-sm dropdown-toggle" uib-dropdown-toggle type="button">
                    <i class="fa fa-filter"></i>
                    Quick Filters
                    <span class="caret"></span>
                </button>
                <ul class="dropdown-menu" uib-dropdown-menu>
                    <li>
                        <a ng-click="filterMyTasks()"><i class="fa fa-user"></i> My tasks</a>
                    </li>
                    <li class="divider"></li>
                    <li>
                        <a ng-click="filterBy('status', 'InProgress')"><i class="glyphicon glyphicon-play"></i> In
                            progress tasks</a>
                    </li>
                    <li>
                        <a ng-click="filterBy('status', 'Waiting')"><i class="fa fa-hourglass-o"></i> Waiting tasks</a>
                    </li>
                    <li>
                        <a ng-click="filterBy('status', 'Completed')"><i class="fa fa-check"></i> Completed tasks</a>
                    </li>
                    <li class="divider"></li>
                    <li>
                        <a ng-click="filterBy('flag', true)"><i class="fa fa-folder-open"></i> Flagged tasks</a>
                    </li>
                </ul>
            </div>

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm"
                    ng-class="{true: 'btn-primary', false:'btn-default'}[filtering.context.showFilters]" type="button"
                    ng-click="toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
            <div class="btn-group pull-right">
                <button class="btn btn-sm btn-default" ng-click="toggleGroupedView()">
                    <i class="glyphicon glyphicon-th-list"></i>
                    Show {{state.showGrouped ? 'as a List' : 'Groups'}}
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/cortex/choose-instance-dialog.html`:

```html
<form class="form-horizontal" name="form" ng-submit="vm.ok()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Select Cortex server</h3>
    </div>
    <div class="modal-body">
        <div class="form-group">
            <label class="col-sm-4 control-label">
                Cortex Server
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-8">
                <select class="form-control" ng-model="vm.selected" ng-options="s for s in vm.servers" required>
                    <option value="">-- choose server --</option>
                </select>
            </div>
        </div>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="vm.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="form.$invalid">Yes, select this server</button>
    </div>
</form>

```

`frontend/app/views/partials/cortex/responder-action-dialog.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">Report of {{$dialog.action.responderName || $dialog.action.responderId}} responder</h3>
</div>
<div class="modal-body observable-report">
    <pre>{{ $dialog.report | json}}</pre>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-primary pull-right" type="button" ng-click="$dialog.close()">Close</button>
</div>

```

`frontend/app/views/partials/dashboard/container.html`:

```html
<div class="chart-container">
    <div class="chart-container-header mb-xxs clearfix">
        <span class="pull-right">
            <a href class="text-danger" ng-click="$vm.removeContainer($index)"><i class="fa fa-times"></i> Remove</a>
        </span>
    </div>
    <div class="chart-container-dropzone"
        dnd-list="item.items"
        dnd-allowed-types="$vm.options.containerAllowedTypes">
        <!-- dnd-disable-if="item.items.length >= $vm.options.maxColumns" -->

            <dashboard-item ng-repeat="component in item.items"
                dnd-draggable="component"
                dnd-type="component.type"
                dnd-effect-allowed="move"
                dnd-moved="item.items.splice($index, 1)"

                type="{{component.type}}"
                autoload="false"
                mode="edit"
                options="component.options">

            </dashboard-item>
    </div>
</div>

```

`frontend/app/views/partials/dashboard/create.dialog.html`:

```html
<form class="form-horizontal" name="form" ng-submit="$vm.ok()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">{{ $vm.dashboard.id ? 'Update dashboard' : 'New Dashboard' }}</h3>
    </div>
    <div class="modal-body">
        <div class="form-group">
            <label class="col-sm-2 control-label">
                Title
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-10">
                <input class="form-control" ng-model="$vm.dashboard.title" required>
            </div>
        </div>
        <div class="form-group">
            <label class="col-sm-2 control-label">
                Description
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-10">
                <textarea class="form-control" ng-model="$vm.dashboard.description" rows="6" required></textarea>
            </div>
        </div>
        <div class="form-group">
            <label class="col-sm-2 control-label">
                Visibility
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-10">
                <select class="form-control" ng-model="$vm.dashboard.status" ng-options="s for s in $vm.statuses"
                    required ng-disabled="$vm.dashboard.id && ($vm.dashboard.createdBy !== $vm.currentUser.login)">
                    <option value="">-- select an option --</option>
                </select>
            </div>
        </div>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$vm.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="form.$invalid">{{ $vm.dashboard.id ?
            'Update' : 'Create' }}</button>
    </div>
</form>

```

`frontend/app/views/partials/dashboard/import.dialog.html`:

```html
<form class="form-horizontal" name="form" ng-submit="vm.ok()">
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Import Dashboard</h3>
    </div>
    <div class="modal-body">
        <div class="form-group">
            <div class="col-sm-12">
                <input type="hidden" name="attachment" ng-model="vm.formData.attachment.status" required>
                <div file-chooser="" filemodel="vm.formData.attachment"></div>
            </div>
        </div>        
    </div>
    <div class="modal-footer">
        <button class="btn btn-warning pull-left" type="button" ng-click="vm.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="form.$invalid">Yes, Import dashboard</button>
    </div>
</form>

```

`frontend/app/views/partials/dashboard/list.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="box">
            <div class="box-header with-border">
                <h3 class="box-title">
                    Dashboard List ({{$vm.list.values.length || 0}} of {{$vm.list.total}})
                </h3>
            </div>
            <div class="box-body">
                <div ng-include="'views/partials/dashboard/list/toolbar.html'"></div>

                <div class="mt-xs filter-panel" ng-include="'views/partials/dashboard/list/filters.html'" ng-show="$vm.filtering.context.showFilters"></div>

                <!-- Filters preview  -->
                <div class="row mt-xs">
                    <div class="col-md-12 clearfix">
                        <filters-preview filters="$vm.filtering.context.filters"
                            on-clear-item="$vm.removeFilter(field)"
                            on-clear-all="$vm.clearFilters()"></filters-preview>
                    </div>
                </div>

                <!-- Datalist  -->
                <div class="row mt-xs">
                    <div class="col-md-12 mv-s" ng-show="$vm.list.total === 0">
                        <div class="empty-message">No records</div>
                    </div>

                    <div class="col-md-12" ng-show="$vm.list.total > 0">
                        <psearch control="$vm.list"></psearch>

                        <table class="table table-striped case-list">
                            <thead>
                                <tr>
                                    <th width="80px">
                                        <a href class="text-default" ng-click="$vm.sortByField('status')">
                                            Status
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+status') === -1 && $vm.filtering.context.sort.indexOf('-status') === -1" class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+status') !== -1" class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-status') !== -1" class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th>
                                        <a href class="text-default" ng-click="$vm.sortByField('title')">
                                            Title
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+title') === -1 && $vm.filtering.context.sort.indexOf('-title') === -1" class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+title') !== -1" class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-title') !== -1" class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 180px;">
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('createdBy')" uib-tooltip="Sort by owner">
                                            Owned By
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+createdBy') === -1 && $vm.filtering.context.sort.indexOf('-createdBy') === -1" class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+createdBy') !== -1" class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-createdBy') !== -1" class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 150px">
                                        Dates
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('createdAt')" uib-tooltip="Sort by creation date">
                                            C.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+createdAt') === -1 && $vm.filtering.context.sort.indexOf('-createdAt') === -1" class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+createdAt') !== -1" class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-createdAt') !== -1" class="fa fa-caret-down"></i>
                                        </a>
                                        <a href class="text-default ml-xxxs" ng-click="$vm.sortByField('updatedAt')" uib-tooltip="Sort by last update date">
                                            U.
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+updatedAt') === -1 && $vm.filtering.context.sort.indexOf('-updatedAt') === -1" class="fa fa-sort"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('+updatedAt') !== -1" class="fa fa-caret-up"></i>
                                            <i ng-show="$vm.filtering.context.sort.indexOf('-updatedAt') !== -1" class="fa fa-caret-down"></i>
                                        </a>
                                    </th>
                                    <th style="width: 160px"></th>
                                </tr>
                            </thead>

                            <tbody>
                                <tr ng-repeat="item in $vm.list.values">

                                    <td class="wrap">
                                        <span class="label label-default clickable" ng-click="$vm.addFilterValue('status', item.status)">{{item.status}}</span>
                                    </td>

                                    <td class="wrap">
                                        <h4 class="mt-0">
                                            <a href ui-sref="app.dashboards-view({id: item._id})">{{item.title}}</a>
                                        </h4>
                                        <span class="text-muted">{{item.description}}</span>
                                    </td>
                                    <td class="nowrap">
                                        <user user-id="item.createdBy" icon-size="m"></user>
                                    </td>
                                    <td>
                                        <div ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+createdAt') !== -1 || $vm.filtering.context.sort.indexOf('-createdAt') !== -1}">
                                            C. <a href ng-click="$vm.addFilterValue('createdAt', item.createdAt)">{{item.createdAt | shortDate}}</a>
                                        </div>
                                        <div ng-if="item.updatedAt > 0" ng-class="{'text-bold': $vm.filtering.context.sort.indexOf('+updatedAt') !== -1 || $vm.filtering.context.sort.indexOf('-updatedAt') !== -1}">
                                            U. <a href ng-click="$vm.addFilterValue('updatedAt', item.updatedAt)">{{item.updatedAt | shortDate}}</a>
                                        </div>
                                    </td>
                                    <td>
                                        <div class="media-right ph-xs text-center">
                                            <a href ui-sref="app.dashboards-view({id: item._id})"><i class="fa fa-area-chart"></i> <br />View</a>
                                        </div>
                                        <div class="media-right ph-xs text-center">
                                            <a href ng-click="$vm.editDashboard(item)"><i class="fa fa-pencil"></i> <br />Edit</a>
                                        </div>
                                        <div class="media-right ph-xs text-center">
                                            <a href ng-click="$vm.duplicateDashboard(item)"><i class="fa fa-copy"></i> <br />Copy</a>
                                        </div>
                                        <div class="media-right ph-xs text-center">
                                            <a href ng-click="$vm.exportDashboard(item)"><i class="fa fa-download"></i> <br />Export</a>
                                        </div>
                                        <div class="media-right ph-xs text-center">
                                            <a href class="text-danger" ng-click="$vm.deleteDashboard(item._id)">
                                                <i class="fa fa-trash"></i> <br />Delete
                                            </a>
                                        </div>
                                    </td>
                                </tr>
                            </tbody>
                        </table>

                        <psearch control="$vm.list"></psearch>
                    </div>
                </div>



            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/dashboard/list/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>

        <form ng-submit="$vm.search()">
            <div class="row mb-xxxs" ng-repeat="filter in $vm.filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="$vm.removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in $vm.filtering.attributeKeys"
                            ng-change="$vm.filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="$vm.filtering.metadata" filter="filter" entity="$vm.filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="$vm.filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="$vm.clearFilters()" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="$vm.filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>

    </div>
</div>

```

`frontend/app/views/partials/dashboard/list/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <button class="btn btn-sm btn-primary" type="button" ng-click="$vm.addDashboard()">Create new Dashboard</button>

            <button class="btn btn-sm btn-default" type="button" ng-click="$vm.importDashboard()">Import Dashboard</button>

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]" type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/dashboard/view.html`:

```html
<div class="box">
    <div class="box-header with-border">
        <h3 class="box-title">
            {{$vm.dashboard.title}}
        </h3>
        <div class="box-tools pull-right">
            <a href class="mr-xxs btn btn-sm btn-primary" ng-click="$vm.enableEditMode()" ng-show="!!$vm.dashboard.writable && !$vm.options.editLayout">
                <i class="fa fa-pencil"></i> Edit
            </a>
            <a href class="mr-xxs btn btn-default btn-sm" ng-click="$vm.exportDashboard()" ng-show="!$vm.options.editLayout">
                <i class="fa fa-download"></i> Export
            </a>

            <div class="btn-group" ng-show="!$vm.options.editLayout">
                <label class="btn btn-sm btn-default" ng-model="$vm.autoRefresh" uib-btn-radio="null">Auto Refresh - Off</label>
                <label class="btn btn-sm btn-default" ng-model="$vm.autoRefresh" uib-btn-radio="60">1m</label>
                <label class="btn btn-sm btn-default" ng-model="$vm.autoRefresh" uib-btn-radio="300">5m</label>
                <label class="btn btn-sm btn-default" ng-model="$vm.autoRefresh" uib-btn-radio="600">10m</label>
                <label class="btn btn-sm btn-default" ng-model="$vm.autoRefresh" uib-btn-radio="900">15m</label>
            </div>

            <a class="btn btn-box-tool" ui-sref="app.dashboards()">
                <i class="fa fa-chevron-left"></i> Back to list
            </a>

        </div>
    </div>
    <div class="box-body">
        <div class="box-tools">
            <div class="dashboard-period pull-left">
                <div class="mv-xxxs">
                    <span class="label label-lg mr-xs text-black">Select period</span>
                    <span class="label label-lg label-default mr-xxs clickable"
                        ng-repeat="period in $vm.dashboardPeriods"
                        ng-click="$vm.applyPeriod(period.type)"
                        ng-class="{'label-primary': $vm.definition.period === period.type}">{{period.label}}</span>
                    <span class="label label-lg label-default mr-xxs clickable"
                        ng-click="$vm.definition.period = 'custom'"
                        ng-class="{'label-primary': $vm.definition.period === 'custom'}">Custom period</span>
                </div>
            </div>
            <div class="mv-xxxs form-inline pull-left" ng-show="$vm.definition.period === 'custom'">
                <div class="form-group hpad10">
                    <label>From</label>
                    <dt-picker date="$vm.definition.customPeriod.fromDate"></dt-picker>
                </div>
                <div class="form-group hpad10">
                    <label>To</label>
                    <dt-picker date="$vm.definition.customPeriod.toDate"></dt-picker>
                </div>
                <button type="button" class="btn btn-primary" ng-click="$vm.applyPeriod('custom')">
                    <i class="fa fa-search"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<div class="dashboard-toolbox right-toolbox" affixer affixer-offset="70" ng-show="$vm.options.editLayout">
    <div class="btn btn-app" ng-click="$vm.saveDashboard()">
        <i class="fa fa-save"></i> Save
    </div>
    <div class="btn btn-app" ng-click="$vm.enableViewMode()">
        <i class="fa fa-times text-danger"></i> Cancel
    </div>
    <hr>
    <div class="btn btn-app" ng-repeat="item in $vm.toolbox"
        dnd-draggable="item"
        dnd-type="item.type"
        dnd-effect-allowed="copy">
        <i class="fa" ng-class="$vm.options.cls[item.type]"></i> {{$vm.options.labels[item.type]}}
    </div>
</div>

<div class="dashboard-content right-toolbox"
    dnd-list="$vm.definition.items"
    dnd-disable-if="!$vm.options.editLayout"
    dnd-allowed-types="$vm.options.dashboardAllowedTypes"
    ng-class="{'dashboard-edit': $vm.options.editLayout, 'dashboard-view': !$vm.options.editLayout}">

    <div class="dashboard-row" ng-repeat="(rowIndex, row) in $vm.definition.items"
        dnd-draggable="row"
        dnd-type="row.type"
        dnd-effect-allowed="move"
        dnd-disable-if="!$vm.options.editLayout"
        dnd-moved="$vm.definition.items.splice($index, 1)"
        ng-class="{'chart-container': $vm.options.editLayout}">

        <div class="chart-container-header mb-xxs clearfix" ng-show="$vm.options.editLayout">
            <span class="pull-right">
                <a href class="text-danger" ng-click="$vm.removeContainer($index)">
                    <i class="fa fa-times"></i> Remove ({{row.items.length}})
                </a>
            </span>
        </div>

        <div class="chart-container-dropzone"
            dnd-list="row.items"
            dnd-allowed-types="$vm.options.containerAllowedTypes"
            dnd-disable-if="row.items.length >= $vm.options.maxColumns"
            dnd-drop="$vm.itemInserted(item, $vm.definition.items, rowIndex, index)">
            <dashboard-item ng-repeat="(colIndex, component) in row.items"
                autoload="true"
                mode="$vm.options.editLayout ? 'edit' : 'view'"
                row-index="rowIndex"
                col-index="colIndex"
                component="component"
                metadata="$vm.metadata"
                filter="$vm.periodFilter"
                refresh-on="refresh-chart"
                resize-on="resize-chart-{{rowIndex}}"
                show-edit="$vm.options.editLayout"
                show-remove="$vm.options.editLayout"
                on-remove="$vm.removeItem(rowIndex, colIndex)"

                dnd-disable-if="!$vm.options.editLayout"
                dnd-draggable="component"
                dnd-type="component.type"
                dnd-effect-allowed="move"
                dnd-dragstart="$vm.itemDragStarted(colIndex, row)">
            </dashboard-item>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/live.html`:

```html
<div class="content-wrapper">
	<div class="row">
		<div class="col-md-12 pv-s">
			<h4 class="text-center">
				<img src="images/logo.svg" height="50"/>
				<span class="ml-xxs label label-danger">LIVE</span>
			</h4>
		</div>
	</div>
	<div class="row">
		<div class="col-md-12" style="border-left:1px;border-left-style:solid;border-left-color:lightgrey;">
			<flow></flow>
		</div>
	</div>
</div>

```

`frontend/app/views/partials/main/index-mytasks.html`:

```html
<psearch control="$vm.list"></psearch>

<div class="empty-message" ng-show="$vm.list.total === 0">No records</div>

<table class="table table-striped table-hover" ng-show="$vm.list.total > 0">
    <thead>
        <tr>
            <th width="70px"></th>
            <th class="text-center" style="width: 60px;">Severity</th>
            <th style="width: 200px;">Group</th>
            <th>Task</th>
            <th width="250px;">Date</th>
        </tr>
    </thead>

    <tbody>
        <tr class="pointer task-row"
            ng-repeat="item in $vm.list.values"
            ng-class="{'warning': (item.flag == true)}"
            ng-click="$vm.openEntity(value)">
            <td>
                <task-flags task="item" inline="true"></task-flags>
            </td>
            <td class="text-center">
                <severity active="false" value="item.extraData.case.severity"></severity>
            </td>
            <td>{{item.group}}</td>
            <td>
                <div>
                    <span class="text-primary mr-xxxs" ng-if="item.flag">
                        <i class="glyphicon glyphicon-flag"></i>
                    </span>

                    <a href ui-sref="app.case.tasks-item({caseId: item.extraData.case._id, itemId:item._id})" ng-class="{'text-danger': !!item.extraData.actionRequired}">
                        <span ng-if="!!item.extraData.actionRequired" class="text-danger noline mr-xxxs" uib-tooltip="Action Required" tooltip-placement="left-middle">
                            <i class="fa fa-exclamation-triangle"></i>
                        </span>
                        {{item.title}}
                    </a>
                </div>
                <div ng-show="item.status === 'InProgress'" class="text-warning">
                        Started <em am-time-ago="item.startDate"></em>
                </div>
                <div>
                    <small><entity-link value="item.extraData.case"></entity-link></small>
                </div>
            </td>
            <td>
                {{item.startDate | shortDate}}
            </td>
        </tr>
    </tbody>

</table>

<psearch control="$vm.list"></psearch>

```

`frontend/app/views/partials/main/index-waitingtasks.html`:

```html
<psearch control="$vm.list"></psearch>

<div class="empty-message" ng-show="$vm.list.total === 0">No records</div>

<table class="table table-striped table-hover" ng-show="$vm.list.total > 0">
    <thead>
        <tr>
            <th width="70px"></th>
            <th class="text-center" style="width: 60px;">Severity</th>
            <th width="200px;">Group</th>
            <th>Task</th>
            <th width="100px;">Action</th>
        </tr>
    </thead>

    <tbody>
        <tr class="task-row" ng-repeat="item in $vm.list.values">
            <td>
                <task-flags task="item" inline="true"></task-flags>
            </td>
            <td class="text-center">
                <severity active="false" value="item.extraData.case.severity"></severity>
            </td>
            <td>{{item.group}}</td>
            <td>
                <div>
                    <span class="text-primary mr-xxxs" ng-if="item.flag">
                        <i class="glyphicon glyphicon-flag"></i>
                    </span>

                    <a href ui-sref="app.case.tasks-item({caseId: item.extraData.case._id, itemId:item._id})"
                        ng-class="{'text-danger': !!item.extraData.actionRequired}">
                        <span ng-if="!!item.extraData.actionRequired" class="text-danger noline mr-xxxs"
                            uib-tooltip="Action Required" tooltip-placement="left-middle">
                            <i class="fa fa-exclamation-triangle"></i>
                        </span>
                        {{item.title}}
                    </a>
                </div>
                <div>
                    <small>
                        <entity-link value="item.extraData.case"></entity-link>
                    </small>
                </div>
            </td>
            <td>
                <button type="button" class="btn btn-sm btn-primary" ng-click="$vm.openWTask(item)">Take</button>
            </td>
        </tr>
    </tbody>

</table>

<psearch control="$vm.list"></psearch>

```

`frontend/app/views/partials/main/list.html`:

```html
<div class="row">
    <div ng-Class="{ 'col-md-9': $vm.appLayout.showFlow, 'col-md-12': !$vm.appLayout.showFlow}">
        <div class="box">
            <div class="box-header with-border">
                <h3 class="box-title" ng-if="$vm.view.data == 'mytasks'">My tasks ({{$vm.list.total}})</h3>
                <h3 class="box-title" ng-if="$vm.view.data == 'waitingtasks'">Waiting tasks ({{$vm.list.total}})</h3>

                <div class="box-tools pull-right" ng-show="!$vm.appLayout.showFlow">
                    <span class="ml-xs" tooltip="Open in new window">
                        <a class="text-muted" href ng-click="$vm.layoutSrv.showFlow(true)">
                            <i class="fa fa-plus"></i> Show live stream
                        </a>
                    </span>
                </div>
            </div>
            <div class="box-body">
                <div ng-include="'views/partials/main/toolbar.html'"></div>

                <div class="mt-s filter-panel" ng-include="'views/partials/case/list/filters.html'" ng-show="$vm.filtering.context.showFilters"></div>

                <!-- Filters preview  -->
                <div class="row mt-s">
                    <div class="col-md-12 clearfix">
                        <filters-preview filters="$vm.filtering.context.filters"
                            on-clear-item="$vm.removeFilter(field)"
                            on-clear-all="$vm.clearFilters()"></filters-preview>
                    </div>
                </div>

                <div ng-switch="$vm.view.data">
                    <div class="main-fadein" ng-switch-when="waitingtasks">
                        <div ng-include="'views/partials/main/index-waitingtasks.html'"></div>
                    </div>

                    <div class="main-fadein" ng-switch-default>
                        <div ng-include="'views/partials/main/index-mytasks.html'"></div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <div ng-show="$vm.appLayout.showFlow" class="col-md-3">
        <div class=" box">
            <div class="box-header">
                <h3 class="box-title">&nbsp;</h3>
                <div class="box-tools pull-right">
                    <span class="ml-xs" tooltip="Open in new window">
                        <a class="text-muted" href ng-click="$vm.layoutSrv.detachFlow()">
                            <i class="fa fa-external-link"></i> Open in new window
                        </a>
                    </span>

                    <span class="ml-xs" tooltip="Hide">
                        <a class="text-muted" href ng-click="$vm.layoutSrv.showFlow(false)">
                            <i class="fa fa-minus"></i> Hide
                        </a>
                    </span>
                </div>
            </div>
            <div class="box-body no-padding">
                <flow max="10"></flow>
            </div>
        </div>
    </div>

</div>

```

`frontend/app/views/partials/main/toolbar.html`:

```html
<div class="row">
    <div class="col-md-12">
        <div class="btn-toolbar" role="toolbar">

            <div class="btn-group pull-right" role="group">
                <page-sizer collection="$vm.list" sizes="[10, 15, 30, 100]"></page-sizer>
            </div>

            <div class="btn-group pull-right" role="group">
                <button class="btn btn-sm" ng-class="{true: 'btn-primary', false:'btn-default'}[$vm.filtering.context.showFilters]" type="button" ng-click="$vm.toggleFilters()">
                    <i class="fa fa-search"></i> Filters
                </button>
            </div>

        </div>
    </div>
</div>

```

`frontend/app/views/partials/misc/responder.selector.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">Run responders</h3>
</div>
<div class="modal-body">
    <p class="mb-xxs">
        Please select the responder you want to run
    </p>

    <div class="row mb-xxs">
        <div class="col-sm-12">
            <div class="has-feedback">
                <input type="text" ng-model="$dialog.state.filter" class="form-control" placeholder="Filter responders" autofocus>
                <span class="glyphicon glyphicon-search form-control-feedback"></span>
            </div>
        </div>
    </div>

    <div class="template-selector">
        <table class="table table-hover table-striped">
            <tbody>
                <tr ng-repeat="responder in $dialog.filteredResponders = ($dialog.responders | filter:$dialog.state.filter)"
                class="clickable"
                ng-class="{'active': $dialog.state.selected === responder.id}"
                ng-click="$dialog.next(responder)">
                    <td>
                        <strong>{{responder.name}}</strong><br>
                        <p class="list-group-item-text text-muted">{{responder.description}}</p>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>

</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="$dialog.cancel()" type="button">Cancel</button>
</div>

```

`frontend/app/views/partials/misc/taxonomy-selection.modal.html`:

```html
<form name="tagsForm" ng-submit="$modal.addSelectedTags()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Select tags from library</h3>
    </div>
    <div class="modal-body">

        <div class="mb-xs">
            <div class="clearfix">
                <label>
                    Selected tags ({{$modal.formData.selectedTags.length}})
                </label>
                <a class="pull-right" href ng-click="$modal.clearSelection()">Clear selection</a>
            </div>

            <div class="empty-message" ng-if="$modal.formData.selectedTags.length === 0">No tags selected</div>

            <div ng-if="$modal.formData.selectedTags.length > 0">
                <div class="empty-message">
                    <div class="tags-list flexwrap">
                        <tag-item ng-repeat="tag in $modal.formData.selectedTags track by $index" value="tag"
                            class="clickable" ng-click="$modal.selectTag(tag)"></tag-item>
                    </div>
                </div>
                <p class="help-block">Click on a tag to unselect it</p>
            </div>
        </div>

        <div class="mv-xxs" ng-if="!$modal.formData.selectedTaxonomy">
            <label>
                Choose taxonomy
            </label>
            <div class="list-group">
                <a href class="list-group-item" ng-repeat="taxonomy in $modal.taxonomies"
                    ng-click="$modal.selectTaxonomy(taxonomy)" class="clearfix">
                    <span class="badge" uib-tooltip="{{taxonomy.description}}" tooltip-placement="left"
                        tooltip-append-to-body="true"><i class="fa fa-question"></i></span>
                    <span>{{taxonomy.namespace}} </span>
                    <small class="pull-right mr-m"><em class="text-muted">({{taxonomy.tags.length || 0}}
                            tags)</em></small>
                </a>
            </div>
        </div>

        <div ng-if="$modal.formData.selectedTaxonomy">
            <div class="clearfix">
                <label>
                    Choose tags from taxonomy: {{$modal.formData.selectedTaxonomy.namespace}}
                </label>
                <a class="pull-right" href ng-click="$modal.formData.selectedTaxonomy = undefined">Show all
                    taxonomies</a>
            </div>

            <div class="row mb-xxs">
                <div class="col-sm-12">
                    <div class="has-feedback">
                        <input type="text" ng-model="$modal.search" class="form-control" placeholder="Filter tags"
                            autofocus>
                        <span class="glyphicon glyphicon-search form-control-feedback"></span>
                    </div>
                </div>
            </div>

            <div style="height: 300px; max-height: 300px; overflow-y: scroll;">
                <div class="list-group">
                    <a href class="list-group-item"
                        ng-repeat="tag in $modal.formData.selectedTaxonomy.tags | filter:$modal.search"
                        ng-click="$modal.selectTag(tag)">
                        <span class="mr-xs"
                            ng-class="{'text-primary': !!tag.selected, 'text-disabled': !!!tag.selected}">
                            <i class="fa fa-check"></i>
                        </span>

                        <span class="badge" ng-if="::tag.description" uib-tooltip="{{::tag.description}}"
                            tooltip-placement="left" tooltip-append-to-body="true">
                            <i class="fa fa-question"></i>
                        </span>

                        <tag-item value="tag"></tag-item>
                    </a>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-default pull-left" type="button" ng-click="$modal.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="$modal.formData.selectedTags === 0">Add
            Selected tags</button>
    </div>
</form>

```

`frontend/app/views/partials/misp/case.export.confirm.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">MISP Export</h3>
</div>
<div class="modal-body misp-export">
    <div ng-if="dialog.mode !== 'error'">
        <p>
            You are about to export the case <strong>{{dialog.caze.title}}</strong> to one of the following MISP servers:
        </p>

        <table class="mt-m table table-striped valigned">
            <tbody class="pv-xs" ng-repeat="server in dialog.servers">
                <tr>
                    <td width="100">
                        <h4>
                            <span class="mr-xs status-label label" ng-class="{
                                'OK': 'label-success',
                                'ERROR': 'label-danger'}[server.status]">{{server.status}}</span>
                        </h4>
                    </td>
                    <td>
                        <h4>{{server.name}}</h4>
                    </td>
                    <td width="150">
                        <button class="btn btn-block pull-right"
                            ng-class="{'btn-primary': dialog.existingExports[server], 'btn-warning': !dialog.existingExports[server]}"
                            ng-click="dialog.export(server)"
                            ng-disabled="dialog.loading || server.status === 'ERROR'">{{dialog.existingExports[server] ? 'Update' : 'Export'}}</button>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>

    <div ng-if="dialog.mode === 'error'">
        <div class="alert alert-danger">
            Failed to export the following observables
        </div>
        <table class="table table-striped">
            <thead>
                <th width="200">Observable</th>
                <th>Reason</th>
            </thead>
            <tbody>
                <tr ng-repeat="o in dialog.failures">
                    <td class="wrap">{{o.data | fang}}</td>
                    <td class="wrap">{{o.message}}</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-default" ng-click="dialog.cancel()" type="button">Cancel</button>
    <button class="btn btn-primary pull-right" ng-if="dialog.mode === 'error'" ng-click="dialog.copyToClipboard()" type="button">
        <i class="fa fa-copy"></i> Copy to clipboard
    </button>
</div>

```

`frontend/app/views/partials/misp/choose-instance-dialog.html`:

```html
<form class="form-horizontal" name="form" ng-submit="vm.ok()" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Select MISP server</h3>
    </div>
    <div class="modal-body">
        <div class="form-group">
            <label class="col-sm-4 control-label">
                MISP Server
                <i class="fa fa-asterisk text-danger"></i>
            </label>
            <div class="col-sm-8">
                <select class="form-control" ng-model="vm.selected" ng-options="s for s in vm.servers" required>
                    <option value="">-- choose server --</option>
                </select>
            </div>
        </div>
    </div>
    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="vm.cancel()">Cancel</button>
        <button class="btn btn-primary pull-right" type="submit" ng-disabled="form.$invalid">Yes, select this server</button>
    </div>
</form>

```

`frontend/app/views/partials/observables/creation/error.html`:

```html
<div class="alert alert-danger">
    Failed to create the following observables
</div>
<table class="table table-striped">
    <thead>
        <th>Observable</th>
        <th>Reason</th>
    </thead>
    <tbody>
        <tr ng-repeat="o in failedObservables">
            <td class="wrap">{{o.data | fang}}</td>
            <td class="nowrap" ng-switch="o.type">
                <span ng-switch-when="CreateError">Already exists</span>
                <span ng-switch-when="ConflictError">Already exists</span>
                <span ng-switch-when="AttributeError">Format error</span>
                <span ng-switch-default>Unexpected error</span>
            </td>
        </tr>
    </tbody>

</table>

```

`frontend/app/views/partials/observables/creation/form.html`:

```html

<div class="form-group" ng-class="{ 'has-error' : observableForm.dataType.$invalid && !observableForm.dataType.$pristine }">
    <label class="col-md-3 control-label">Type <i class="fa fa-asterisk text-danger"></i></label>
    <div class="col-md-9">
        <input type="hidden" name="dataType" ng-model="params.dataType" required>
        <div class="btn-group" uib-dropdown>
            <button type="button" class="btn btn-default" uib-dropdown-toggle>{{params.dataType}}&nbsp;&nbsp;<span class="caret"></span>
            </button>
            <ul class="dropdown-menu" uib-dropdown-menu>
                <li ng-repeat="type in types track by $index">
                    <a ng-click="selectDataType(type)">{{type}}</a>
                </li>
            </ul>
        </div>
    </div>
</div>

<!-- Uploaded File observable -->
<div class="form-group" ng-show="params.isUpload === true && isFile()" ng-class="{ 'has-error' : observableForm.attachment.$invalid }">
    <label class="col-md-3 control-label">File <i class="fa fa-asterisk text-danger"></i></label>
    <div class="col-md-9">
        <input type="hidden" name="attachment" ng-model="params.attachment.status" ng-required="params.isUpload && isFile()">
        <div file-chooser="" filemodel="params.attachment"></div>
        <div ng-show="params.attachment.upload.total === 0" class="mv-xxs p-xxs bg-warning">
            WARNING: This file seems to be empty
        </div>
        <div class="checkbox">
          <label>
              <input type="checkbox" ng-model="params.isZip">&nbsp;The file is a zipped archive
          </label>
        </div>
        <div ng-show="params.isZip">
            <input type="text" class="form-control" ng-model="params.zipPassword" placeholder="Type archive's password if available"> {{params.izZip}}
        </div>
    </div>
</div>

<!-- Existing attachment observable -->
<div class="form-group" ng-show="!params.isUpload && isFile()">
    <label class="col-md-3 control-label">File <i class="fa fa-asterisk text-danger"></i></label>
    <div class="col-md-9">
        <table class="table table-striped">
          <tr>
            <th class="text-center" style="width: 10px">#</th>
            <th>Filename</th>
            <th>Type</th>
            <th>Size</th>
          </tr>
          <tr ng-repeat="a in params.attachment track by $index">
              <td class="text-center">#{{$index+1}}</td>
              <td>{{a.name}}</td>
              <td>{{a.contentType}}</td>
              <td>{{a.size | filesize}}</td>
          </tr>
        </table>
    </div>
</div>

<!-- Non file observable -->
<div class="form-group" ng-show="!isFile()" ng-class="{ 'has-error' : observableForm.data.$invalid && !observableForm.data.$pristine }">
    <label class="col-md-3 control-label">Value <i class="fa fa-asterisk text-danger"></i></label>
    <div class="col-md-9">
        <textarea class="form-control" placeholder="{{params.dataType}}" name="data" ng-model="params.data" rows="5" ng-required="!isFile()"></textarea>
        <div class="radio">
            <label>
                <input type="radio" name="bulk" ng-model="params.single" ng-value="false">
                One observable per line
                <span class="ml-xxxs">
                    (<ng-pluralize count="countObservables()" when="{'0': '0 observables', 'one': '1 unique observable', 'other': '{} unique observables'}"></ng-pluralize>)
                </span>
            </label>
        </div>
        <div class="radio">
            <label>
                <input type="radio" name="bulk" ng-model="params.single" ng-value="true">
                One single multiline observable
            </label>
        </div>
    </div>
</div>

<div class="form-group">
    <label class="col-md-3 control-label">TLP <i class="fa fa-asterisk text-danger"></i></label>
    <div class="col-md-9">
        <p class="form-control-static">
            <a href ng-click="activeTlp='active'">
                <tlp value="params.tlp" format="activeTlp" on-update="updateTlp(newValue)" class="form-control-static"></tlp>
            </a>
        </p>
    </div>
</div>

<div class="form-group">
    <label class="col-md-3 control-label">Is IOC</label>
    <div class="col-md-9">
        <p class="form-control-static">
            <a href ng-click="params.ioc = !params.ioc">
                <i class="text-primary fa" ng-class="{ 'fa-star' : params.ioc, 'fa-star-o' : !params.ioc }"></i>
            </a>
        </p>
    </div>
</div>

<div class="form-group">
    <label class="col-md-3 control-label">Has been sighted</label>
    <div class="col-md-9">
        <p class="form-control-static">
            <a href ng-click="params.sighted = !params.sighted">
                <i class="text-primary fa" ng-class="{ 'fa-toggle-on' : params.sighted, 'fa-toggle-off' : !params.sighted }"></i>
            </a>
        </p>
    </div>
</div>

<div class="form-group">
    <label class="col-md-3 control-label">Ignore for similarity</label>
    <div class="col-md-9">
        <p class="form-control-static">
            <a href ng-click="params.ignoreSimilarity = !params.ignoreSimilarity">
                <i class="text-primary fa" ng-class="{ 'fa-chain-broken' : params.ignoreSimilarity, 'fa-chain' : !params.ignoreSimilarity }"></i>
            </a>
        </p>
    </div>
</div>

<!-- missing.tags -->
<div class="form-group" ng-class="{ 'has-error' : observableForm.tags.$invalid && !observableForm.tagsInput.$pristine }">
    <label class="col-md-3 control-label">
        Tags
        <span><i class="fa fa-asterisk text-danger"></i><i class="fa fa-asterisk text-danger"></i></span>
    </label>
    <div class="col-md-9">
        <input type="hidden" name="tags" ng-model="params.tagNames" ng-required="!params.message.length"/>

        <div class="input-group">
            <tags-input name="tagsInput" template="views/directives/tag-input-item.html" ng-model="params.tags" class="ti-input-sm ti-tag-selector" placeholder="Add tags" replace-spaces-with-dashes="false" min-length="2">
                <auto-complete min-length="3" debounce-delay="400" source="getTags($query)"></auto-complete>
            </tags-input>

            <span class="input-group-btn vtop">
                <button type="button" class="btn btn-block btn-sm btn-primary" ng-click="fromTagLibrary()" uib-tooltip="Add tag from library" tooltip-placement="left">
                    <span class="fa fa-plus"></span>
                </button>
            </span>
        </div>

        <p class="help-block" ng-show="observableForm.tags.$invalid && !observableForm.tagsInput.$pristine">The observable(s) description or tags are required.</p>
    </div>
</div>

<div class="form-group" ng-class="{ 'has-error' : observableForm.description.$invalid && !observableForm.description.$pristine }">
    <label class="col-sm-3 control-label">Description <i class="fa fa-asterisk text-danger"></i><i class="fa fa-asterisk text-danger"></i></label>
    <div class="col-sm-9">
        <textarea class="form-control" name="description" ng-model="params.message" placeholder="Observable(s) description" rows="3" ng-required="!params.tags.length"></textarea>
        <p class="help-block" ng-show="observableForm.description.$invalid && !observableForm.description.$pristine">The observable(s) description or tags are required.</p>
    </div>
</div>

<p class="clearfix">
    <span class="pull-right"><i class="fa fa-asterisk text-danger"></i><i class="fa fa-asterisk text-danger"></i> At least, one required field</span>
    <span class="pull-right mr-xxs"><i class="fa fa-asterisk text-danger"></i> Required field</span>
</p>

```

`frontend/app/views/partials/observables/details/analysers.html`:

```html
<div class="row">
    <div class="col-md-12">
        <h4 class="pv-xxs pr-xxs text-primary">
            Analysis
            <span class="pull-right" if-permission="manageAnalyse" allowed="{{userPermissions}}" ng-if="analysisEnabled">
                <small><a href class="text-primary" ng-click="runAll()">Run all</a></small>
            </span>
        </h4>

        <div ng-if="!jobs || !analyzers || analyzers.length === 0">
            <div class="empty-message">No records</div>
        </div>

        <table class="table table-striped" ng-if="jobs || analyzers.length > 0">
            <thead>
                <th>Analyzer</th>
                <th width="450">Last analysis</th>
                <th width="60" class="text-center" if-permission="manageAnalyse" allowed="{{userPermissions}}" ng-if="analysisEnabled">Actions</th>
            </thead>
            <tbody>
                <tr ng-repeat="(analyzerName, jobs) in analyzerJobs"
                    ng-init="analyzer=analyzers[analyzerName]; analyzers[analyzerName].showRows=false;">
                    <td>
                        <a ng-if="jobs.length > 1" class="noline mr-xxs" href ng-click="analyzers[analyzerName].showRows = !analyzers[analyzerName].showRows">
                            <i class="fa" ng-class="{ true:'fa-minus-square-o', false:'fa-plus-square-o' }[analyzers[analyzerName].showRows]"></i>
                        </a>
                        <span uib-tooltip="{{analyzer.description}}" tooltip-placement="right">{{analyzer.name || jobs[0].analyzerName}}</span>
                        <!--pre>
                          analyzer = {{analyzer}}
                          analyzers = {{analyzers}}
                          jobs = {{jobs}}
                        </pre-->
                        <!-- <div class="text-muted">{{}}</div> -->
                    </td>
                    <!-- <td>
                        <ul class="list-unstyled">
                            <li ng-repeat="cortexId in analyzer.cortexIds">{{cortexId}}</li>
                        </ul>
                    </td> -->
                    <td>
                        <ul class="list-unstyled">
                            <li ng-if="jobs.length === 0"><em>None</em></li>
                            <li ng-repeat="job in jobs" ng-show="analyzer.showRows || $first">
                                <span class="mr-s">
                                    <i class="glyphicon" ng-class="{ Failure:'glyphicon-warning-sign text-warning', Success:'glyphicon-ok text-success', InProgress:'fa fa-cog fa-spin', Waiting:'fa fa-cog fa-spin'}[job.status]"></i>
                                </span>

                                <a href ng-click="showReport(job.id)" uib-tooltip="View report">{{(job.endDate || job.startDate) | shortDate}}</a> ({{job.cortexId}})
                            </li>
                        </ul>
                    </td>
                    <td if-permission="manageAnalyse" allowed="{{userPermissions}}" ng-if="analysisEnabled" class="text-center">
                        <!-- <pre>{{cortexServers | json}}</pre> -->
                        <span class="btn btn-xs" ng-class="{true: 'btn-warning', false: 'btn-danger'}[jobs.length > 0]"
                            ng-click="runAnalyzer(analyzerName)"
                            ng-if="analyzer.cortexIds.length === 1 && analyzer.active">
                            <i class="glyphicon" ng-class="{true: 'glyphicon-repeat', false: 'glyphicon-fire'}[jobs.length > 0]"></i>
                        </span>

                        <div class="btn-group" ng-if="analyzer.cortexIds.length > 1 && analyzer.active" uib-dropdown>
                            <button type="button" class="btn btn-xs dropdown-toggle"
                                ng-class="{true: 'btn-warning', false: 'btn-danger'}[jobs.length > 0]"
                                uib-dropdown-toggle>
                                <span class="mr-xxxs">
                                    <i class="glyphicon" ng-class="{true: 'glyphicon-repeat', false: 'glyphicon-fire'}[jobs.length > 0]"></i>
                                </span>
                                <span class="caret"></span>
                            </button>
                            <ul class="dropdown-menu align-right" uib-dropdown-menu>
                                <li ng-repeat="srv in cortexServers" ng-if="analyzer.cortexIds.indexOf(srv.name) !== -1">
                                    <a href ng-click="runAnalyzer(analyzerName, srv.name)" ng-disabled="srv.status === 'ERROR'">
                                        <div>
                                            <strong>{{srv.name}}</strong>
                                        </div>
                                        <div>
                                            <strong ng-class="{'OK': 'text-success', 'ERROR': 'text-danger'}[srv.status]">Status: {{srv.status}}</strong>
                                        </div>
                                    </a>
                                </li>
                            </ul>
                        </div>

                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<div class="row" id="analysis-report">
    <div class="col-md-6 col-md-offset-3">
        <hr>
    </div>
</div>

<div class="row observable-report" ng-if="report">
    <div class="col-md-12">
        <h4 class="pad10 text-primary">
            Report <small>for {{report.template}} analysis of {{(report.endDate || report.startDate) | shortDate}}</small>
            <span class="pull-right">
                <small><a href class="text-primary" ng-click="showRaw = !showRaw">{{showRaw ? 'Hide': 'Show'}} Raw Report</a></small>
                <small class="mh-xxxs">|</small>
                <small><a href class="text-primary" ng-click="showArtifacts = !showArtifacts">{{showArtifacts ? 'Hide': 'Show'}} observables ({{report.content.artifacts.length || 0}})</a></small>
            </span>
        </h4>
        <div ng-if="showArtifacts" class="">
            <div class="panel panel-info">
                <div class="panel-heading">
                    <strong>Observables</strong> <small>Extracted from analysis report</small>
                </div>
                <div class="panel-body">
                    <report-observables
                        origin="artifact"
                        case-id="caseId"
                        observables="report.content.artifacts"
                        analyzer="report.template"
                        permissions="userPermissions"
                        on-refresh="refreshCurrentJob()"

                        ></report-observables>
                </div>
            </div>
        </div>
        <div ng-if="showRaw">
            <div class="panel" ng-class="{'panel-info': report.content.success, 'panel-danger': !report.content.success}">
                <div class="panel-heading">
                    <strong>Raw report</strong>
                </div>
                <div class="panel-body">
                    <pre>{{(report.content.full || report.content) | json}}</pre>
                </div>
            </div>
        </div>
        <report ng-if="!showRaw" artifact="artifact"
            content="report.content.full || report.content"
            default="jsonhuman"
            name="report.template"
            status="report.status"
            success="report.content.success"
            ></report>
    </div>
</div>

```

`frontend/app/views/partials/observables/details/responders.html`:

```html
<div class="row" ng-if="actions.values.length">
    <div class="col-md-12">
        <responder-actions header="Responder Jobs" actions="actions"></responder-actions>
    </div>
</div>

```

`frontend/app/views/partials/observables/details/sharing.html`:

```html
<div class="row">
    <div class="col-md-12" id="observable-sharings">
         <h4 class="vpad10 text-primary">Sharing</h4>
         <div class="btn-toolbar" role="toolbar" if-permission="manageShare" allowed="{{userPermissions}}">
             <div class="btn-group">
                 <button class="btn btn-sm btn-primary" ng-click="addTaskShare()">
                     <i class="fa fa-plus"></i>
                     Add share
                 </button>
             </div>
         </div>
         <div class="mv-s">
             <sharing-list
                 shares="shares"
                 read-only="true"
                 on-delete="removeShare(share)"
                 permissions="userPermissions"
                 ></sharing-list>
         </div>
    </div>
</div>

```

`frontend/app/views/partials/observables/details/summary.html`:

```html
<div class="row">
    <!-- Observable details information-->
    <div class="col-md-6">
        <h4 class="vpad10 text-primary">
            Basic Information
            <div class="task-actions pull-right">
                <!-- <span if-permission="manageShare" allowed="{{userPermissions}}"> -->
                <span>
                    <a href ng-click="scrollTo('#observable-sharings')">
                        <span class="mr-xxs action-button">
                            <i class="fa fa-users"></i> Sharing
                        </span>
                    </a>
                </span>

                <span class="ml-xxs action-button" if-permission="manageAction" allowed="{{userPermissions}}" ng-if="appConfig.connectors.cortex.enabled">
                    <a href class="text-primary noline nowrap" ng-click="getObsResponders(artifact, true)">
                        <i class="text-primary fa fa-cog"></i>
                        Responders
                    </a>
                </span>
            </div>
        </h4>
        <dl class="dl-horizontal clear">
            <dt class="pull-left">TLP</dt>
            <dd ng-if="canEdit">
                <a class="noline" href ng-init="activeTlp = 'static'" ng-click="activeTlp = 'active'">
                    <tlp value="artifact.tlp" format="activeTlp" on-update="updateField('tlp', newValue)"></tlp>
                </a>
            </dd>
            <dd ng-if="!canEdit">
                <tlp format="'static'" value="artifact.tlp"></tlp>
            </dd>
        </dl>

        <dl class="dl-horizontal clear" ng-if="artifact.attachment && artifact.attachment.hashes">
            <dt class="pull-left">Hash</dt>
            <dd>
                <div ng-repeat="hash in artifact.attachment.hashes" class="wrap" marked="hash | hashType"></div>
            </dd>
        </dl>

        <dl class="dl-horizontal clear" ng-show="artifact.metadata.size">
            <dt class="pull-left">Size</dt>
            <dd>{{artifact.attachment.size}} bytes</dd>
        </dl>

        <dl class="dl-horizontal clear">
            <dt class="pull-left">Date added</dt>
            <dd>{{artifact.startDate | shortDate}}</dd>
        </dl>

        <dl class="dl-horizontal clear">
            <dt class="pull-left">Is IOC</dt>
            <dd ng-if="canEdit">
                <span class="clickable" ng-click="updateField('ioc', !artifact.ioc)">
                    <i class="text-primary fa" ng-class="{'true': 'fa-star', 'false': 'fa-star-o'}[artifact.ioc]"></i>
				</span>
            </dd>
            <dd ng-if="!canEdit">
                <span>
                    <i class="text-primary fa" ng-class="{'true': 'fa-star', 'false': 'fa-star-o'}[artifact.ioc]"></i>
				</span>
            </dd>
        </dl>

        <dl class="dl-horizontal clear">
            <dt class="pull-left">Has been sighted</dt>
            <dd ng-if="canEdit">
                <span class="clickable" ng-click="updateField('sighted', !artifact.sighted)">
                    <i class="text-primary fa" ng-class="{'true': 'fa-toggle-on', 'false': 'fa-toggle-off'}[artifact.sighted]"></i>
                </span>
            </dd>
            <dd ng-if="!canEdit">
                <span>
                    <i class="text-primary fa" ng-class="{'true': 'fa-toggle-on', 'false': 'fa-toggle-off'}[artifact.sighted]"></i>
				</span>
            </dd>
        </dl>

        <dl class="dl-horizontal clear">
            <dt class="pull-left">Ignored for similarity</dt>
            <dd ng-if="canEdit">
                <span class="clickable" ng-click="updateField('ignoreSimilarity', !!!artifact.ignoreSimilarity)">
                    <i class="text-primary fa" ng-class="{'true': 'fa-chain-broken', 'false': 'fa-chain'}[!!artifact.ignoreSimilarity]"></i>
                </span>
            </dd>
            <dd ng-if="!canEdit">
                <span>
                    <i class="text-primary fa" ng-class="{'true': 'fa-chain-broken', 'false': 'fa-chain'}[!!artifact.ignoreSimilarity]"></i>
				</span>
            </dd>
        </dl>

        <dl class="dl-horizontal">
            <dt class="pull-left">Tags</dt>
            <dd ng-if="canEdit">
                <updatable-tag-list on-update="updateField('tags', getLabels(newValue))" value="artifact.tags" source="getTags"></updatable-tag-list>
            </dd>
            <dd ng-if="!canEdit">
                <tag-list ng-if="artifact.tags.length > 0" data="artifact.tags"></tag-list>
                <em ng-if="!artifact.tags || artifact.tags.length === 0" class="text-warning">Not Specified</em>
            </dd>
        </dl>

        <dl class="dl-horizontal clear">
            <dt class="pull-left">Description</dt>
            <dd ng-if="canEdit">
                <updatable-text value="artifact.message" on-update="updateField('message', newValue)" placeholder="Artifact description"></updatable-text>
            </dd>
            <dd ng-if="!canEdit">
                <div ng-if="artifact.message" marked="artifact.message" class="markdown"></div>
                <em ng-if="!artifact.message" class="text-warning">Not Specified</em>
            </dd>
        </dl>
    </div>
    <!-- Observable links -->
    <div class="col-md-6" ng-if="!!!artifact.ignoreSimilarity">
        <h4 class="vpad10 text-primary">Links</h4>

        <div class="empty-message" ng-if="similarArtifacts.length === 0">
            This observable has not been seen in any other case
        </div>

        <div ng-if="similarArtifacts.length > 0">
            <strong>Observable seen in {{similarArtifacts.length}} other case(s)</strong>
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th width="80">Flags</th>
                        <th>Case</th>
                        <th width="120">Date added</th>
                    </tr>
                </thead>
                <tbody>
                    <tr ng-repeat="a in similarArtifacts | limitTo:similarArtifactsLimit" style="cursor: pointer;" ng-click="openArtifact(a)" uib-tooltip="{{a.message}}" tooltip-popup-delay="500" tooltip-placement="bottom">
                        <td>
                            <observable-flags observable="a" inline="true" hide-seen="true" hide-similarity="true"></observable-flags>
                        </td>
                        <td>
                          <!-- [{{a.dataType}}]: {{a.data || a.attachment.name}}<br> -->
                          #{{a.stats.case.caseId}} - {{a.stats.case.title}}
                        </td>
                        <td>{{a.startDate | shortDate}}</td>
                    </tr>
                </tbody>
            </table>
            <div class="mt-xxs text-center" ng-if="similarArtifactsLimit < similarArtifacts.length">
                <a href ng-click="showMoreSimilar()"><i class="fa fa-angle-down"></i> Show more</a>
            </div>
        </div>

    </div>
</div>

```

`frontend/app/views/partials/observables/list/export.html`:

```html
<div class="col-md-12 observable-export">

    <div class="row" ng-controller="CaseObservablesExportCtrl" ng-if="selection.artifacts.length > 0">
        <div class="col-md-12">
            <form class="form-inline mh-l">
				<div class="form-group hpad10">
					<span class="btn btn-sm btn-default" ng-click="hideExport()">
			            <i class="fa fa-chevron-left"></i>
			            Back
			        </span>
				</div>

                <div class="form-group hpad10">
                    <label>File format</label>
                    <div class="btn-group">
                        <label uib-btn-radio="'csv'" class="btn btn-default btn-sm" name="format" ng-model="exportParams.format">CSV</label>
                        <label uib-btn-radio="'txt'" class="btn btn-default btn-sm" name="format" ng-model="exportParams.format">TEXT</label>
                        <label uib-btn-radio="'misp'" class="btn btn-default btn-sm" name="format" ng-model="exportParams.format">MISP</label>
                    </div>
                </div>
                <div class="form-group hpad10">
                    <label>Protect</label>
                    <div class="btn-group">
                        <label uib-btn-radio="'fang'" class="btn btn-default btn-sm" name="protect" ng-model="exportParams.protect">Yes</label>
                        <label uib-btn-radio="'defang'" class="btn btn-default btn-sm" name="protect" ng-model="exportParams.protect">No</label>
                    </div>
                </div>
                <div class="form-group hpad10 pull-right">
                    <button type="button" class="btn btn-success btn-sm" ng-click="copyToClipboard()">
                        <i class="fa fa-copy"></i>
                        Copy to clipboard</button>
                    <button type="button" class="btn btn-success btn-sm" ng-csv="getCSV" filename="{{'observables.' + exportParams.format}}">
                        <i class="fa fa-download"></i>
                        Save to file</button>

                </div>
            </form>

			<div class="mh-l mh-l mt-l mb-s">
				<h4>Preview of the data to export</h4>
			</div>

            <div class="well well-sm mh-l" ng-switch="exportParams.format">
                <table ng-switch-when="txt">
                    <tr style="overflow: hidden" ng-repeat="el in selection.artifacts">
                        <td class="wrap">
							{{getObservableValue(el)}}
                        </td>
                    </tr>
                </table>

                <table ng-switch-when="csv">
                    <tr style="overflow: hidden" ng-repeat="el in selection.artifacts">
                        <td class="wrap">
                            {{getDataType(el)}};{{getObservableValue(el)}}
                        </td>
                    </tr>
                </table>

                <table ng-switch-when="misp">
                    <tr style="overflow: hidden" ng-repeat="el in selection.artifacts">
                        <td width="200">
							*{{getDataType(el)}}
                        </td>
                        <td>
							:{{getObservableValue(el)}}
                        </td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

</div>

```

`frontend/app/views/partials/observables/list/filters.html`:

```html
<div class="row">
    <div class="col-md-12 active-filters">
        <h4>Filters</h4>
        <form ng-submit="search()">
            <div class="row mb-xxxs" ng-repeat="filter in filtering.context.filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in filtering.attributeKeys"
                            ng-change="filtering.setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="filtering.metadata" filter="filter" entity="filtering.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <a href class="btn btn-sm  btn-link btn-clear" ng-click="filtering.addFilter()">
                        <i class="fa fa-plus"></i> Add a filter
                    </a>
                    <a href class="btn btn-sm btn-danger" ng-click="clearFilters()" ng-if="filtering.context.filters.length > 0">
                        <i class="fa fa-times"></i> Clear
                    </a>
                    <button href class="btn btn-sm btn-primary pull-right" type="submit" ng-if="filtering.context.filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>


        <!-- <form class="form-horizontal" name="filtersForm" ng-submit="filter(filtersForm);" novalidate>

            <div class="row">
                <div class="col-md-12">
                    <div class="form-group mb-0">
                        <label class="col-sm-2 control-label">Keyword</label>
                        <div class="col-sm-10">
                            <input class="form-control" ng-model="uiSrv.activeFilters.keyword.value" placeholder="ex: freetext"></input>
                        </div>
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-md-12">
                    <div class="col-sm-10 col-sm-offset-2">
                        <hr class="filter-separator" />
                    </div>
                </div>
            </div>



            <div class="row">
                <div class="col-md-6">
                    <div class="form-group">
                        <label class="col-sm-4 control-label">Type</label>
                        <div class="col-sm-8">
                            <tags-input class="form-control form-control-wrapper" min-length="2" ng-model="uiSrv.activeFilters.dataType.value" placeholder="ex: ip, domain, url" replace-spaces-with-dashes="false"></tags-input>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-sm-4 control-label">Tags</label>
                        <div class="col-sm-8">
                            <tags-input class="form-control form-control-wrapper" min-length="2" ng-model="uiSrv.activeFilters.tags.value" placeholder="ex: misp, malspam, ioc" replace-spaces-with-dashes="false"></tags-input>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-sm-4 control-label">Value</label>
                        <div class="col-sm-8">
                            <input class="form-control" ng-model="uiSrv.activeFilters.data.value" placeholder="ex: example.com, 8.8.8.8"></input>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="form-group">
                        <label class="col-sm-4 control-label">Date</label>
                        <div class="col-sm-8">
                            <div class="row">
                                <div class="col-sm-6">
                                    <dt-picker date="uiSrv.activeFilters.startDate.value.from" placeholder="from"></dt-picker>
                                </div>
                                <div class="col-sm-6">
                                    <dt-picker date="uiSrv.activeFilters.startDate.value.to" placeholder="to"></dt-picker>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-sm-4 control-label">Flags</label>
                        <div class="col-sm-8">
                            <div class="mr-xxs mb-xxxs btn-group">
                                <label uib-btn-radio="true" class="btn btn-default btn-sm" name="ioc" ng-model="uiSrv.activeFilters.ioc.value">IOC</label>
                                <label uib-btn-radio="false" class="btn btn-default btn-sm" name="ioc" ng-model="uiSrv.activeFilters.ioc.value">Not IOC</label>
                                <label uib-btn-radio="null" class="btn btn-default btn-sm" name="ioc" ng-model="uiSrv.activeFilters.ioc.value">Any</label>
                            </div>

                            <div class="btn-group">
                                <label uib-btn-radio="true" class="btn btn-default btn-sm" name="sighted" ng-model="uiSrv.activeFilters.sighted.value">Sighted</label>
                                <label uib-btn-radio="false" class="btn btn-default btn-sm" name="sighted" ng-model="uiSrv.activeFilters.sighted.value">Not sighted</label>
                                <label uib-btn-radio="null" class="btn btn-default btn-sm" name="sighted" ng-model="uiSrv.activeFilters.sighted.value">Any</label>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-sm-4 control-label">Description</label>
                        <div class="col-sm-8">
                            <input class="form-control" ng-model="uiSrv.activeFilters.message.value" placeholder="ex: freetext"></input>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pull-right">
                <button class="btn btn-sm btn-primary" type="submit">Apply filters</button>
            </div>
        </form> -->

    </div>
</div>

```

`frontend/app/views/partials/observables/list/job-report-dialog.html`:

```html
<div class="modal-header bg-primary">
    <h3 class="modal-title">Report of {{$vm.report.job.analyzerName || $vm.report.job.analyzerId}} analysis</h3>
</div>
<div class="modal-body observable-report">
    <report artifact="$vm.observable"
        content="$vm.report.content.full || $vm.report.content"
        report-type="long"
        name="$vm.report.template"
        status="$vm.report.status"
        success="$vm.report.content.success"
        ></report>
</div>
<div class="modal-footer text-left">
    <button class="btn btn-primary pull-right" type="button" ng-click="$vm.close()">Close</button>
</div>

```

`frontend/app/views/partials/observables/list/mini-stats.html`:

```html
<div class="row" ng-controller="ObservablesStatsCtrl as statsCtrl">
    <div class="col-md-4">
        <div class="stats-item-wrapper">
            <stats-item title="Observables by type" mode="'chart'" field="dataType" data="statsCtrl.byType.details" on-item-clicked="addFilterValue(field, value)">
            </stats-item>
        </div>
    </div>

    <div class="col-md-4">
        <div class="stats-item-wrapper">
            <stats-item title="Observables as IOC" mode="'chart'" field="ioc" data="statsCtrl.byIoc.details" labels="statsCtrl.iocLabels" values="statsCtrl.iocValues" on-item-clicked="addFilterValue(field, value)">
            </stats-item>
        </div>
    </div>

    <div class="col-md-4">
        <div class="stats-item-wrapper">
            <stats-item title="Top 5 tags" mode="'chart'" field="tags" data="statsCtrl.byTags.details" on-item-clicked="addFilterValue(field, value)">
            </stats-item>
        </div>
    </div>
</div>

```

`frontend/app/views/partials/observables/list/observables.html`:

```html
<div class="col-md-12 mb-s clearfix">
    <div class="pull-left">
        <h4>
            <datalist-header title="List of observables" list="artifacts" total="observablesCount"></datalist-header>
            <small class="ml-xxs" ng-if="selection.artifacts.length > 0 ">
                ({{selection.artifacts.length}} selected)
            </small>
        </h4>
    </div>
    <filters-preview filters="filtering.context.filters" on-clear-item="removeFilter(field)"
        on-clear-all="clearFilters()"></filters-preview>
</div>

<div class="col-md-12 mv-s" ng-show="artifacts.total === 0 && artifacts.values.length === 0">
    <div class="empty-message">No records.</div>
</div>

<!-- list of artifacts-->
<div class="col-md-12" ng-show="artifacts.values.length !== 0">
    <psearch ng-if="!switchTEList" control="artifacts"></psearch>

    <table class="table table-striped table-hover case-list">
        <thead>
            <tr>
                <!-- <th style="width: 10px;" class="p-0"></th> -->
                <th style="width: 20px">
                    <input type="checkbox" ng-change="selectAll()" ng-model="menu.selectAll"
                        ng-disabled="switchTEList"></input>
                </th>
                <th style="width: 100px">Flags</th>
                <th style="width: 100px">
                    <a href class="text-default ml-xxxs" ng-click="sortByField('dataType')"
                        uib-tooltip="Sort by dataType">
                        Type
                        <i ng-show="filtering.context.sort.indexOf('+dataType') === -1 && filtering.context.sort.indexOf('-dataType') === -1"
                            class="fa fa-sort"></i>
                        <i ng-show="filtering.context.sort.indexOf('+dataType') !== -1" class="fa fa-caret-up"></i>
                        <i ng-show="filtering.context.sort.indexOf('-dataType') !== -1" class="fa fa-caret-down"></i>
                    </a>
                </th>
                <th>
                    <a href class="text-default ml-xxxs" ng-click="sortByField('data')" uib-tooltip="Sort by data">
                        Value/Filename
                        <i ng-show="filtering.context.sort.indexOf('+data') === -1 && filtering.context.sort.indexOf('-data') === -1"
                            class="fa fa-sort"></i>
                        <i ng-show="filtering.context.sort.indexOf('+data') !== -1" class="fa fa-caret-up"></i>
                        <i ng-show="filtering.context.sort.indexOf('-data') !== -1" class="fa fa-caret-down"></i>
                    </a>
                    <!-- <a href class="text-default" ng-click="sortByField('data')">
                    Value/Filename
                    <i ng-show="artifacts.sort !== '+data' && artifacts.sort !== '-data'" class="fa fa-sort"></i>
                    <i ng-show="artifacts.sort === '+data'" class="fa fa-caret-up"></i>
                    <i ng-show="artifacts.sort === '-data'" class="fa fa-caret-down"></i>
                  </a> -->
                </th>
                <th style="width: 70px;"></th>
                <th style="width: 150px">
                    Dates

                    <a href class="text-default ml-xxxs" ng-click="sortByField('startDate')"
                        uib-tooltip="Sort by add date">
                        S.
                        <i ng-show="filtering.context.sort.indexOf('+startDate') === -1 && filtering.context.sort.indexOf('-startDate') === -1"
                            class="fa fa-sort"></i>
                        <i ng-show="filtering.context.sort.indexOf('+startDate') !== -1" class="fa fa-caret-up"></i>
                        <i ng-show="filtering.context.sort.indexOf('-startDate') !== -1" class="fa fa-caret-down"></i>
                    </a>
                    <a href class="text-default ml-xxxs" ng-click="sortByField('_createdAt')"
                        uib-tooltip="Sort by creation date">
                        C.
                        <i ng-show="filtering.context.sort.indexOf('+_createdAt') === -1 && filtering.context.sort.indexOf('-_createdAt') === -1"
                            class="fa fa-sort"></i>
                        <i ng-show="filtering.context.sort.indexOf('+_createdAt') !== -1" class="fa fa-caret-up"></i>
                        <i ng-show="filtering.context.sort.indexOf('-_createdAt') !== -1" class="fa fa-caret-down"></i>
                    </a>
                    <a href class="text-default ml-xxxs" ng-click="sortByField('_updatedAt')"
                        uib-tooltip="Sort by last update date">
                        U.
                        <i ng-show="filtering.context.sort.indexOf('+_updatedAt') === -1 && filtering.context.sort.indexOf('-_updatedAt') === -1"
                            class="fa fa-sort"></i>
                        <i ng-show="filtering.context.sort.indexOf('+_updatedAt') !== -1" class="fa fa-caret-up"></i>
                        <i ng-show="filtering.context.sort.indexOf('-_updatedAt') !== -1" class="fa fa-caret-down"></i>
                    </a>
                </th>
                <th style="width: 40px;" if-permission="manageAction" allowed="{{userPermissions}}"
                    ng-if="appConfig.connectors.cortex.enabled">Actions</th>
            </tr>
        </thead>
        <tbody>
            <tr ng-repeat="artifact in artifacts.values">
                <!-- <td class="p-0 bg-tlp-{{artifact.tlp}} clickable" ng-click="filterByTlp(artifact.tlp)"></td> -->
                <td>
                    <input type="checkbox" ng-model="artifact.selected" ng-change="selectArtifact(artifact)"
                        if-permission="manageObservable" allowed="{{artifact.extraData.permissions.join(',')}}">
                </td>
                <td>
                    <observable-flags observable="artifact" on-filter="addFilterValue(fieldName, value)" inline="true">
                    </observable-flags>
                </td>
                <td>
                    <a href ng-click="addFilterValue('dataType', artifact.dataType)"><span
                            ng-bind="artifact.dataType"></span></a>
                </td>
                <td class="wrap">
                    <!-- FIXME -->
                    <div class="wrap clickable" ng-click="openArtifact(artifact)">
                        <span class="wrap clickable" uib-tooltip="{{artifact.message}}" tooltip-placement="top-left">
                            {{(artifact.data | fang) || (artifact.attachment.name | fang)}}
                        </span>

                    </div>
                    <div class="case-tags flexwrap mt-xxs">
                        <span class="mr-xxxs text-muted"><i class="fa fa-tags"></i></span>
                        <strong class="text-muted mr-xxxs"
                            ng-if="!artifact.tags || artifact.tags.length === 0">None</strong>
                        <tag-item class="pointer" ng-repeat="tag in artifact.tags track by $index"
                            ng-click="addFilterValue('tags', tag)" value="tag"></tag-item>
                    </div>

                    <mini-report-list observable="artifact" reports="artifact.reports"
                        on-item-clicked="showReport(observable, analyzerId)"></mini-report-list>
                </td>
                <td align="center">
                    <a href ng-if="artifact.extraData.shareCount > 0"
                        ui-sref="app.case.observables-item({itemId: artifact._id})" class="noline"
                        tooltip-placement="left-middle">

                        <i class="fa fa-users"></i>
                        ({{artifact.extraData.shareCount || 0}})
                    </a>
                </td>
                <td>
                    <div
                        ng-class="{'text-bold': filtering.context.sort.indexOf('+startDate') !== -1 || filtering.context.sort.indexOf('-startDate') !== -1}">
                        S. <a href ng-click="addFilterValue('startDate', artifact.startDate)">{{artifact.startDate |
                            shortDate}}</a>
                    </div>
                    <div
                        ng-class="{'text-bold': filtering.context.sort.indexOf('+_createdAt') !== -1 || filtering.context.sort.indexOf('-_createdAt') !== -1}">
                        C. <a href ng-click="addFilterValue('_createdAt', artifact._createdAt)">{{artifact._createdAt |
                            shortDate}}</a>
                    </div>
                    <div ng-if="artifact._updatedAt > 0"
                        ng-class="{'text-bold': filtering.context.sort.indexOf('+_updatedAt') !== -1 || filtering.context.sort.indexOf('-_updatedAt') !== -1}">
                        U. <a href ng-click="addFilterValue('_updatedAt', artifact._updatedAt)">{{artifact._updatedAt |
                            shortDate}}</a>
                    </div>
                </td>
                <td align="center" ng-if="appConfig.connectors.cortex.enabled" if-permission="manageAction"
                    allowed="{{userPermissions}}">
                    <span>
                        <a href class="text-primary noline nowrap" ng-click="getObsResponders(artifact, true)"
                            uib-dropdown-toggle>
                            <i class="text-primary fa fa-cog"></i>
                        </a>
                    </span>
                </td>
            </tr>
        </tbody>
    </table>

    <psearch ng-if="!switchTEList" control="artifacts"></psearch>
</div>

```

`frontend/app/views/partials/observables/observable.analyze.html`:

```html
<form class="form-horizontal" name="observableForm" ng-submit="$dialog.run(observableForm);" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Analyzer observable(s)</h3>
    </div>

    <div class="modal-body">
        <p class="mb-xs">
            Select the analyzers you want to run on the selected observables.
        </p>

        <div class="form-group" ng-repeat="dataType in $dialog.dataTypes track by $index">
            <label class="col-md-3 control-label">{{dataType}} analyzers</label>
            <div class="col-md-9">
                <p class="form-control-static" ng-if="$dialog.analyzerMap[dataType].length === 0">
                    <em class="text-muted">No Analyzer Available</em>
                </p>

                <p class="form-control-static" ng-if="$dialog.analyzerMap[dataType].length > 0">
                    <a href ng-click="$dialog.selectAll(dataType, true)">Select all</a> / <a href ng-click="$dialog.selectAll(dataType, false)">Deselect all</a>
                </p>

                <div class="checkbox" ng-repeat="analyzer in $dialog.analyzerMap[dataType]">
                  <label>
                    <input class="mr-xxs" type="checkbox" ng-model="analyzer.selected"/> {{analyzer.name}}
                  </label>
                </div>
            </div>
        </div>
    </div>



    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$dialog.cancel()" type="button">Cancel</button>
        <button class="btn btn-primary pull-right" ng-disabled="observableForm.$invalid" type="submit">Run selected analyzers</button>
    </div>
</form>

```

`frontend/app/views/partials/observables/observable.creation.html`:

```html
<form class="form-horizontal" name="observableForm" ng-submit="add(observableForm);" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Create new observable(s)</h3>
    </div>
    <div class="modal-body" ng-include="'views/partials/observables/creation/form.html'" ng-show="step === 'form'"></div>

    <div class="modal-body" ng-include="'views/partials/observables/creation/error.html'" ng-show="step === 'error'"></div>

    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
        <button class="btn btn-primary pull-right" ng-show="step ==='error'" ng-click="copyToClipboard()" type="button"><i class="fa fa-copy"></i> Copy to clipboard</button>
        <button class="btn btn-primary pull-right" ng-show="step ==='form'" ng-disabled="observableForm.$invalid || pendingAsync" type="submit"><i class="fa fa-plus"></i> Create observable(s)</button>
    </div>
</form>

```

`frontend/app/views/partials/observables/observable.update.html`:

```html
<form class="form-horizontal" name="observableForm" ng-submit="$dialog.save(observableForm);" novalidate>
    <div class="modal-header bg-primary">
        <h3 class="modal-title">Update observable(s)</h3>
    </div>

    <div class="modal-body">
        <p class="mb-xs">
            Select the changes you want to apply to the selected observables. (<a href
                ng-click="$dialog.toggleAll()">{{$dialog.state.all ? 'Uncheck All' : 'Check all'}}</a>)
        </p>

        <div class="form-group" ng-if="$dialog.canUpdateDataType">
            <label class="col-md-3 control-label">Data Type <input class="ml-xxs" type="checkbox"
                    ng-model="$dialog.state.enableDataType"></label>
            <div class="col-md-9">
                <select class="form-control" ng-options="v for v in $dialog.dataTypes"
                    ng-model="$dialog.params.dataType" ng-change="$dialog.toggleDataType(newValue)">
                    <option value=""></option>
                </select>
            </div>
        </div>

        <div class="form-group">
            <label class="col-md-3 control-label">TLP <input class="ml-xxs" type="checkbox"
                    ng-model="$dialog.state.enableTlp"></label>
            <div class="col-md-9">
                <p class="form-control-static">
                    <a href ng-click="$dialog.activeTlp = 'active'">
                        <tlp value="$dialog.params.tlp" format="$dialog.activeTlp"
                            on-update="$dialog.toggleTlp(newValue)" class="form-control-static"></tlp>
                    </a>
                </p>
            </div>
        </div>

        <div class="form-group">
            <label class="col-md-3 control-label">Is IOC <input class="ml-xxs" type="checkbox"
                    ng-model="$dialog.state.enableIoc"></label>
            <div class="col-md-9">
                <p class="form-control-static">
                    <a href ng-click="$dialog.toogleIoc()">
                        <i class="text-primary fa"
                            ng-class="{ 'fa-star' : $dialog.params.ioc, 'fa-star-o' : !$dialog.params.ioc }"></i>
                    </a>
                </p>
            </div>
        </div>

        <div class="form-group">
            <label class="col-md-3 control-label">Has been sighted <input class="ml-xxs" type="checkbox"
                    ng-model="$dialog.state.enableSighted"></label>
            <div class="col-md-9">
                <p class="form-control-static">
                    <a href ng-click="$dialog.toogleSighted()">
                        <i class="text-primary fa"
                            ng-class="{ 'fa-toggle-on' : $dialog.params.sighted, 'fa-toggle-off' : !$dialog.params.sighted }"></i>
                    </a>
                </p>
            </div>
        </div>

        <div class="form-group">
            <label class="col-md-3 control-label">Ignored for similarity <input class="ml-xxs" type="checkbox"
                    ng-model="$dialog.state.enableIgnoreSimilarity"></label>
            <div class="col-md-9">
                <p class="form-control-static">
                    <a href ng-click="$dialog.toogleIgnoreSimilarity()">
                        <i class="text-primary fa"
                            ng-class="{ 'fa-chain-broken' : $dialog.params.ignoreSimilarity, 'fa-chain' : !$dialog.params.ignoreSimilarity }"></i>
                    </a>
                </p>
            </div>
        </div>

        <div class="form-group"
            ng-class="{ 'has-error' : observableForm.addTags.$invalid && !observableForm.addTagsInput.$pristine }">
            <label class="col-md-3 control-label">Add Tags <input class="ml-xxs" type="checkbox"
                    ng-model="$dialog.state.enableAddTags"></label>
            <div class="col-md-9">
                <input type="hidden" name="addTags" ng-model="$dialog.params.addTagNames"
                    ng-required="$dialog.state.enableAddTags" />

                <div class="input-group">
                    <tags-input name="addTagsInput" ng-model="$dialog.params.addTags"
                        class="ti-input-sm ti-tag-selector" placeholder="Add tags" replace-spaces-with-dashes="false"
                        min-length="2" on-tag-added="$dialog.toggleAddTags()"
                        template="views/directives/tag-input-item.html">
                        <auto-complete min-length="3" debounce-delay="400" source="$dialog.getTags($query)">
                        </auto-complete>
                    </tags-input>

                    <span class="input-group-btn vtop">
                        <button type="button" class="btn btn-block btn-sm btn-primary"
                            ng-click="$dialog.fromTagLibrary('add')" uib-tooltip="Add tag from library"
                            tooltip-placement="left">
                            <span class="fa fa-plus"></span>
                        </button>
                    </span>
                </div>

            </div>
        </div>

        <div class="form-group"
            ng-class="{ 'has-error' : observableForm.removeTags.$invalid && !observableForm.removeTagsInput.$pristine }">
            <label class="col-md-3 control-label">Remove Tags <input class="ml-xxs" type="checkbox"
                    ng-model="$dialog.state.enableRemoveTags"></label>
            <div class="col-md-9">
                <input type="hidden" name="removeTags" ng-model="$dialog.params.removeTagNames"
                    ng-required="$dialog.state.enableRemoveTags" />
                <div class="input-group">
                    <tags-input name="removeTagsInput" ng-model="$dialog.params.removeTags"
                        class="ti-input-sm ti-tag-selector" placeholder="Remove tags" replace-spaces-with-dashes="false"
                        min-length="2" on-tag-added="$dialog.toggleRemoveTags()"
                        template="views/directives/tag-input-item.html">
                        <auto-complete min-length="3" debounce-delay="400" source="$dialog.getTags($query)">
                        </auto-complete>
                    </tags-input>

                    <span class="input-group-btn vtop">
                        <button type="button" class="btn btn-block btn-sm btn-primary"
                            ng-click="$dialog.fromTagLibrary('remove')" uib-tooltip="Add tag from library"
                            tooltip-placement="left">
                            <span class="fa fa-plus"></span>
                        </button>
                    </span>
                </div>
            </div>
        </div>

    </div>



    <div class="modal-footer text-left">
        <button class="btn btn-default" ng-click="$dialog.cancel()" type="button">Cancel</button>
        <button class="btn btn-primary pull-right" ng-disabled="observableForm.$invalid" type="submit">Update
            observable(s)</button>
    </div>
</form>

```

`frontend/app/views/partials/personal-settings.html`:

```html
<div class="row">
    <div class="col-md-10 col-md-offset-1">
        <h3>
            <center>Settings</center>
        </h3>

        <!-- Update basic user information -->
        <form name="basicForm" class="form-horizontal" ng-submit="updateBasicInfo(basicForm)" novalidate>
            <div class="box">
                <div class="box-header">
                    <h3 class="box-title">Update basic information</h3>
                </div>
                <div class="box-body">
                    <div class="form-group">
                        <label class="col-md-3 control-label">Username</label>
                        <div class="col-md-9">
                            <input type="text" class="form-control input-sm" ng-model="basicData.username" readonly/>
                        </div>
                    </div>
                    <div class="form-group" ng-class="{ 'has-error' : !basicForm.name.$pristine && basicForm.name.$invalid}">
                        <label class="col-md-3 control-label">Full name
                            <i class="fa fa-asterisk text-danger"></i>
                        </label>
                        <div class="col-md-9">
                            <input type="text" name="name" class="form-control input-sm" placeholder="Full name" ng-model="basicData.name" required/>
                            <div ng-messages="basicForm.name.$error" ng-show="!basicForm.name.$pristine && basicForm.name.$error">
                                <div ng-messages-include="settings-error.html"></div>
                            </div>
                        </div>
                    </div>

                    <div class="form-group" ng-class="{ 'has-error' : basicForm.avatar.$error.maxsize}">
                        <label class="col-md-3 control-label">Avatar</label>
                        <div class="col-md-9">
                            <div ng-show="!basicData.avatarB64 && !basicData.avatar">
                                <div style="width: 100px;">
                                    <img alt="User avatar" src="images/no-avatar.png"/>
                                    <input type="file" class="mt-xxs avatar-input" ng-model="avatarB64" id="avatar-input" name="avatar"
                                        accept="image/jpg|image/png|image/jpeg"
                                        maxsize="500"
                                        base-sixty-four-input
                                        do-not-parse-if-oversize>
                                    <label for="avatar-input" class="mt-xxs btn btn-block btn-sm btn-primary">Choose File</label>
                                </div>
                                <div class="help-block">Images must not exceed 500 KB. Recommended dimensions are 100x100px</div>

                            </div>

                            <div ng-show="basicData.avatar || basicData.avatarB64" style="width: 100px;">
                                <img ng-if="basicData.avatar" alt="User avatar" data-ng-src=".{{basicData.avatar}}"/>
                                <img ng-if="basicData.avatarB64" alt="User avatar" data-ng-src="{{'data:image/jpeg;base64,' + basicData.avatarB64}}"/>
                                <!-- <img alt="User avatar" data-ng-src="{{'data:image/jpeg;base64,' + basicData.avatar}}"/> -->
                                <br>
                                <button class="mt-xxs btn btn-block btn-sm btn-danger" type="button" ng-click="clearAvatar(basicForm)">Clear</button>
                            </div>

                            <div ng-messages="basicForm.avatar.$error" ng-show="!basicForm.avatar.$pristine && basicForm.avatar.$error">
                                <div ng-messages-include="settings-error.html"></div>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="col-md-3 control-label">Profile</label>
                        <div class="col-md-9">
                            <p class="form-control-static">{{currentUser.profile}}</p>
                            <permission-list permissions="currentUser.permissions" showLabel="false"></permission-list>
                        </div>
                    </div>

                    <div class="mt-s">
                        <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
                        <span class="ml-xxs">
                            <i class="fa fa-asterisk text-danger"></i>&nbsp;Required field</span>
                        <button class="btn btn-primary pull-right" ng-disabled="basicForm.$invalid" type="submit">Save</button>
                    </div>

                </div>
            </div>
        </form>

        <!-- Update user password -->
        <form ng-if="canChangePass" class="form-horizontal mt-s" name="passForm" ng-submit="updatePassword(passForm);" novalidate>
            <div class="box">
                <div class="box-header">
                    <h3 class="box-title"><input type="checkbox" ng-model="passData.changePassword" ng-click="clearPassword(passForm, passData.changePassword)">
                        Update password</h3>
                </div>
                <div class="box-body" ng-show="passData.changePassword">
                    <div class="form-group" ng-class="{ 'has-error' : !passForm.currentPassword.$pristine && passForm.currentPassword.$invalid}">
                        <label class="col-md-3 control-label">Old password
                            <i class="fa fa-asterisk text-danger"></i>
                        </label>
                        <div class="col-md-9">
                            <input type="password" name="currentPassword" class="form-control input-sm" placeholder="Current password" autocomplete="off" ng-model="passData.currentPassword" ng-required="passData.changePassword"/>
                            <div ng-messages="passForm.currentPassword.$error" ng-show="!passForm.currentPassword.$pristine && passForm.currentPassword.$error">
                                <div ng-messages-include="settings-error.html"></div>
                            </div>
                        </div>
                    </div>

                    <div class="form-group" ng-class="{ 'has-error' : !passForm.password.$pristine && passForm.password.$invalid}">
                        <label class="col-md-3 control-label">New password
                            <i class="fa fa-asterisk text-danger"></i>
                        </label>
                        <div class="col-md-9">
                            <input type="password" name="password" class="form-control input-sm" placeholder="New password" autocomplete="off" ng-model="passData.password" ng-required="passData.changePassword"/>
                            <div ng-messages="passForm.password.$error" ng-show="!passForm.password.$pristine && passForm.password.$error">
                                <div ng-messages-include="settings-error.html"></div>
                            </div>
                        </div>
                    </div>

                    <div class="form-group" ng-class="{ 'has-error' : !passForm.confirmPassword.$pristine && passForm.confirmPassword.$invalid}">
                        <label class="col-md-3 control-label">Confirm new password
                            <i class="fa fa-asterisk text-danger"></i>
                        </label>
                        <div class="col-md-9">
                            <input type="password" name="confirmPassword" class="form-control input-sm" placeholder="Confirm Password" compare-to="passData.password" autocomplete="off" ng-model="passData.passwordConfirm" ng-required="passData.changePassword"/>
                            <div ng-messages="passForm.confirmPassword.$error" ng-show="!passForm.confirmPassword.$pristine && passForm.confirmPassword.$error">
                                <div ng-messages-include="settings-error.html"></div>
                            </div>
                            <div ng-class="{'has-error': passData.password!=passData.password2, 'has-success': passData.password==passData.password2 && passData.password1!=''}">
                                <div ng-show="passData.password1 != passData.password2">Oops, that's not the same password as the first one</div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-s">
                        <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
                        <span class="ml-xxs">
                            <i class="fa fa-asterisk text-danger"></i>&nbsp;Required field</span>
                        <button class="btn btn-primary pull-right" ng-disabled="passForm.$invalid" type="submit">Save</button>
                    </div>
                </div>
            </div>
        </form>

        <!-- Update API Key -->
        <form ng-if="canChangeKey">
            <div class="box">
                <div class="box-header">
                    <h3 class="box-title">API Key</h3>
                </div>
                <div class="box-body">
                    <div class="callout callout-warning mv-0" ng-if="!currentUser.hasKey">
                        <h4>You don't have any API key.</h4>
                        <p> Please contact your organization's administrator.</p>
                    </div>
                    <div class="form-group" ng-if="currentUser.hasKey">
                        <p>You have an API key defined. You can renew it if needed.</p>
                        <div class="input-group">
                            <span class="input-group-btn">
                                <span class="btn btn-default" ng-click="createKey()">Renew</span>
                                <span class="btn btn-primary" ng-click="getKey()" ng-if="!keyData.key">Reveal</span>
                            </span>
                            <input class="form-control" readonly ng-model="keyData.key" ng-if="keyData.key">
                            <span class="input-group-btn" ng-if="keyData.key">
                                <button class="btn btn-primary" type="button" ng-click="copyKey()">
                                    <i class="fa fa-copy"></i>
                                </button>
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </form>

        <!-- Update mfa -->
        <form ng-if="canChangeMfa" class="mt-s" name="mfaForm" ng-submit="setMfaSettings(mfaForm);" novalidate>
            <div class="box">
                <div class="box-header">
                    <h3 class="box-title">
                        <input type="checkbox" ng-model="mfaData.enabled" ng-change="enableMfa()" ng-disabled="currentUser.hasMFA">
                        Enable Multi-Factor Authentication
                    </h3>
                </div>
                <div class="box-body" ng-show="mfaData.enabled === true">
                    <div ng-if="currentUser.hasMFA === true" class="text-center">
                        Your have enabled Multi-Factor Authentication, do you want to disabled it?
                        <div class="mv-s">
                            <button type="button" class="btn btn-danger" ng-click="resetMfa()">Disable MFA</button>
                        </div>
                    </div>

                    <div ng-if="currentUser.hasMFA === false">
                        <div class="mb-m text-center">
                            Your are going to enable Multi-Factor Authentication.
                            Use the QRCode or the Secret to generate a MFA code and submit it.
                        </div>

                        <div class="row">
                            <div class="col-lg-6 col-lg-offset-3 col-md-8 col-md-offset-2 col-sm-10 col-sm-offset-1">
                                <div class="alert bg-primary">
                                    Need a two-step authenticator app? Download one of the following:
                                    <div>
                                        <i class="fa fa-apple"></i> iOS devices: <a href="https://apps.apple.com/fr/app/authy/id494168017" target="_blank">Authy</a>
                                    </div>
                                    <div>
                                        <i class="fa fa-android"></i> Android devices: <a href="https://play.google.com/store/apps/details?id=com.authy.authy&hl=fr" target="_blank">Authy</a>
                                    </div>
                                    <div>
                                        <i class="fa fa-windiws"></i> Windows devices: <a href="https://www.microsoft.com/en-us/p/microsoft-authenticator/9nblgggzmcj6" target="_blank">Microsoft Authenticator</a>
                                    </div>
                                </div>
                            </div>
                        </div>



                        <div class="text-center" ng-if="mfaData.uri">
                            <qr text="mfaData.uri"></qr>
                        </div>

                        <div class="text-center mv-s" ng-if="mfaData.secret">
                            <h3>{{mfaData.secret}}</h3>
                            <div>
                                <a href ng-click="copySecret(mfaData.secret)"><i class="fa fa-copy"></i> Copy secret </a>
                            </div>
                        </div>

                        <div class="row">

                            <div class="col-xs-offset-3 col-xs-6 form-group" ng-class="{ 'has-error' : !mfaForm.mfaCode.$pristine && mfaForm.mfaCode.$invalid}">
                                <label class="control-label">Code
                                    <i class="fa fa-asterisk text-danger"></i>
                                </label>
                                <input type="number" name="mfaCode" class="form-control input-lg text-center"
                                    placeholder="MFA Code" autocomplete="off"
                                    ng-model="mfaData.code"
                                    ng-required="!currentUser.hasMFA"/>
                                <div ng-messages="mfaForm.mfaCode.$error" ng-show="!mfaForm.mfaCode.$pristine && mfaForm.mfaCode.$error">
                                    <div ng-messages-include="settings-error.html"></div>
                                </div>
                            </div>

                        </div>

                        <div class="mt-s">
                            <button class="btn btn-default" ng-click="cancel()" type="button">Cancel</button>
                            <span class="ml-xxs">
                                <i class="fa fa-asterisk text-danger"></i>&nbsp;Required field</span>
                            <!-- <button class="btn btn-primary pull-right" ng-disabled="mfaForm.$invalid" type="submit">Save</button> -->
                            <button class="btn btn-primary pull-right" ng-disabled="!mfaData.code" type="submit">Save</button>
                        </div>
                    </div>
                </div>
            </div>
        </form>

    </div>
</div>

<script id="settings-error.html" type="text/ng-template">
    <div class="mt-xxs text-danger" ng-message="required">
        This field is required
    </div>
    <div class="mt-xxs text-danger" ng-message="minlength">
        <span translate="error.form.minlength"></span>
    </div>
    <div class="mt-xxs text-danger" ng-message="maxlength">
        <span translate="error.form.maxlength"></span>
    </div>
    <div class="mt-xxs text-danger" ng-message="maxsize">
        Files must not exceed 500 KB
    </div>
    <div class="mt-xxs text-danger" ng-message="compareTo">
        Oops, that's not the same password as the first one
    </div>
    <div class="mt-xxs text-danger" ng-message="mfaInvalid">
        Oops, that's not a valid MFA code
    </div>
</script>

```

`frontend/app/views/partials/search/list.html`:

```html
<div class="box search-list">
    <!-- <div class="box-header">
        <h3 class="box-title">Search result ({{searchResults.total | limitedCount}} records(s) found)</h3>
    </div> -->
    <div class="m-xs text-primary">
        <h3>Search scope</h3>
    </div>
    <div class="m-xs entity-bar">
        <div class="entity-item" ng-repeat="item in toolbar" ng-click="setEntity(item.name)"
            ng-class="{'active': config.entity===item.name}">
            <div class="entity-item-icon">
                <i ng-class="item.icon"></i>
            </div>
            <div class="entity-item-text">
                {{item.label}}
            </div>
        </div>
    </div>
    <div class="m-xs text-primary">
        <h3>Search filters <small ng-show="config.entity !== 'all'">{{config[config.entity].filters.length || 0 }}
                filter(s) applied</small></h3>
    </div>
    <div class="m-xs">
        <!-- <div ng-if="!config[config.entity].search && !config[config.entity].filters.length > 0" class="empty-message">
            No filters defined. <a href ng-click="addFilter()">Add a filter</a>
        </div> -->
        <form ng-submit="search()">
            <!-- <div class="row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="config[config.entity].search = null">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <input type="text" class="form-control" placeholder="Free text search" ng-model="config[config.entity].search">
                    </div>

                    <hr class="filter-separator" ng-if="config[config.entity].filters.length > 0">
                </div>
            </div> -->
            <div class="row">
                <div class="col-sm-12 col-md-12col-lg-8">
                    <p>Please specify your search criterias, by adding your search filters </p>
                </div>
            </div>
            <div class="row mb-xxxs" ng-repeat="filter in config[config.entity].filters track by $index">
                <div class="col-sm-4 col-md-4 col-lg-2">
                    <div class="input-group">
                        <span class="input-group-btn">
                            <button class="btn btn-default" type="button" ng-click="removeFilter($index)">
                                <i class="fa fa-times text-danger"></i>
                            </button>
                        </span>
                        <select class="form-control" ng-model="filter.field"
                            ng-options="item for item in filterFields(config.entity)"
                            ng-change="setFilterField(filter, config.entity)"></select>
                    </div>
                </div>
                <div class="col-sm-8 col-md-8 col-lg-6">
                    <filter-editor metadata="metadata" filter="filter" entity="config.entity"></filter-editor>
                </div>
            </div>
            <div class="mv-xs row">
                <div class="col-sm-12 col-md-12 col-lg-8">
                    <!-- <a href class="btn btn-link btn-clear" ng-click="addFilter()" ng-show="config.entity !== 'all'"> -->
                    <a href class="btn btn-default" ng-click="addFilter()" ng-show="config.entity !== 'all'">
                        <i class="fa fa-plus"></i> Add filter
                    </a>
                    <a href class="btn btn-danger" ng-click="clearFilters()"
                        ng-show="config[config.entity].filters.length > 0">
                        <i class="fa fa-times"></i> Clear filters
                    </a>
                    <button href class="btn btn-primary pull-right" type="submit"
                        ng-show="config[config.entity].filters.length > 0">
                        <i class="fa fa-search"></i> Search
                    </button>
                </div>
            </div>
        </form>
    </div>
    <div class="m-xs text-primary" ng-if="searchResults">
        <h3>Search Result <small>{{searchResults.total | limitedCount}} records(s) found</small></h3>
    </div>
    <div class="box-body">
        <div class="row">
            <psearch control="searchResults"></psearch>
            <div class="col-md-12"
                ng-if="searchResults && (!searchResults.values || searchResults.values.length === 0)">
                <div class="empty-message">
                    No result found.
                </div>
            </div>
            <div class="col-md-12" ng-repeat="value in searchResults.values" ng-switch="value._type">
                <search-item type="case" value="value" ng-switch-when="case" icon="glyphicon glyphicon-folder-open">
                </search-item>
                <search-item type="task" value="value" ng-switch-when="case_task" icon="glyphicon glyphicon-tasks">
                </search-item>
                <search-item type="task-log" value="value" ng-switch-when="case_task_log"
                    icon="glyphicon glyphicon-comment"></search-item>
                <search-item type="observable" value="value" ng-switch-when="case_artifact"
                    icon="glyphicon glyphicon-pushpin" on-title-clicked="importAlert(value)"></search-item>
                <search-item type="observable-job" value="value" ng-switch-when="case_artifact_job"
                    icon="glyphicon glyphicon-cog"></search-item>
                <search-item type="alert" value="value" ng-switch-when="alert" icon="glyphicon glyphicon-alert"
                    on-title-clicked="importAlert(value)"></search-item>
                <search-item type="audit" value="value" ng-switch-when="audit" icon="glyphicon glyphicon-list-alt">
                </search-item>
            </div>
            <psearch control="searchResults"></psearch>
        </div>
    </div>

</div>

```

`frontend/app/views/partials/utils/confirm.modal.html`:

```html
<form ng-submit="$modal.confirm()">
  <div class="modal-header bg-{{$modal.config.flavor || 'primary'}}">
      <h3 class="modal-title">{{$modal.title}}</h3>
  </div>
  <div class="modal-body">
      <p ng-if="!$modal.config.isHtml">{{$modal.message}}</p>
      <p ng-if="$modal.config.isHtml" ng-bind-html="$modal.message"></p>
  </div>
  <div class="modal-footer text-left">
      <button class="btn btn-default" ng-click="$modal.cancel()" type="button">Cancel</button>
      <button class="btn btn-{{$modal.config.flavor || 'primary'}} pull-right" type="submit" auto-focus>{{$modal.config.okText || 'Ok'}}</button>
  </div>
</form>

```

`frontend/app/views/reports/default.html`:

```html
<div class="panel" ng-class="{'panel-info': success, 'panel-danger': !success}">
    <div class="panel-heading">
        <strong>{{(artifact.data || artifact.attachment.name) | fang}}</strong>
    </div>
    <div class="panel-body">
        <div ng-if="!success">{{content.errorMessage}}</div>
        <pre ng-if="success">{{content | json}}</pre>
    </div>
</div>

```

`frontend/bower.json`:

```json
{
  "name": "thehive",
  "version": "4.1.24-1",
  "license": "AGPL-3.0",
  "dependencies": {
    "jquery": "^3.4.1",
    "angular": "1.7.8",
    "angular-animate": "1.7.8",
    "angular-bootstrap": "2.5.0",
    "angular-cookies": "1.7.8",
    "angular-moment": "~0.10.3",
    "angular-resource": "1.7.8",
    "angular-sanitize": "1.7.8",
    "angular-timer": "^1.3.5",
    "angular-touch": "1.7.8",
    "angular-ui-router": "~0.4.3",
    "animate.css": "^3.7.0",
    "bootstrap": "^3",
    "bootstrap-sass-official": "^3",
    "dropzone": "~4.3.0",
    "font-awesome": "fontawesome#^4.7.0",
    "moment": "^2.24.0",
    "ng-csv": "~0.3.6",
    "ng-tags-input": "^3.2.0",
    "roboto-fontface": "^0.10.0",
    "smalot-bootstrap-datetimepicker": "2.4.4",
    "underscore": "^1.9.1",
    "cryptojslib": "~3.1.2",
    "angular-ui-notification": "0.3.6",
    "c3": "~0.4.11",
    "css-spaces": "~0.3.5",
    "angular-messages": "1.7.8",
    "ng-file-upload-shim": "^12.2.13",
    "ng-file-upload": "^12.2.13",
    "es5-shim": "^4.5.13",
    "es6-shim": "^0.35.5",
    "angular-clipboard": "^1.7.0",
    "angular-local-storage": "^0.7.1",
    "angular-markdown-editor-ghiscoding": "1.1.5",
    "angular-highlightjs": "^0.7.1",
    "highlight.js.origin": "^9.15.6",
    "angular-ui-ace": "bower",
    "angular-page-loader": "*",
    "angular-images-resizer": "^2.0.3",
    "angular-base64-upload": "^0.1.19",
    "angular-ui-sortable": "^0.19.0",
    "js-base64": "^2.5.1",
    "angular-scroll": "^1.0.2",
    "underscore.string": "^3.3.5",
    "angular-drag-and-drop-lists": "^2.1.0",
    "angular-bootstrap-colorpicker": "^3.0.32",
    "file-saver": "1.3.4",
    "js-url": "~2.5.3",
    "bootstrap-sass": "bootstrap-sass-official#^3.4.1",
    "angular-bootstrap-multiselect": "https://github.com/bentorfs/angular-bootstrap-multiselect.git#^1.1.11",
    "qrcode.js": "qrcode#^1.0.2",
    "angular-qr": "^0.2.0"
  },
  "devDependencies": {
    "angular-mocks": "1.7.8"
  },
  "resolutions": {
    "angular": "1.7.8",
    "moment": "^2.24.0",
    "jquery": "^3.4.1",
    "angular-highlightjs": "^0.7.1"
  }
}

```

`frontend/package.json`:

```json
{
    "name": "thehive",
    "version": "4.1.24-1",
    "license": "AGPL-3.0",
    "repository": {
        "type": "git",
        "url": "https://github.com/TheHive-Project/TheHive.git"
    },
    "bugs": {
        "url": "https://github.com/TheHive-Project/TheHive/issues"
    },
    "homepage": "https://thehive-project.org/",
    "dependencies": {},
    "devDependencies": {
        "autoprefixer": "^9.7.6",
        "grunt": "^1.1.0",
        "grunt-angular-templates": "^1.2.0",
        "grunt-concurrent": "^3.0.0",
        "grunt-connect-proxy": "^0.2.0",
        "grunt-contrib-clean": "^2.0.0",
        "grunt-contrib-concat": "^1.0.1",
        "grunt-contrib-connect": "^2.1.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-cssmin": "^3.0.0",
        "grunt-contrib-htmlmin": "^3.1.0",
        "grunt-contrib-imagemin": "^4.0.0",
        "grunt-contrib-jshint": "^2.1.0",
        "grunt-contrib-uglify": "^4.0.1",
        "grunt-contrib-watch": "^1.1.0",
        "grunt-filerev": "^2.3.1",
        "grunt-injector": "^1.1.0",
        "grunt-karma": "4.0.0",
        "grunt-newer": "^1.3.0",
        "grunt-ng-annotate": "^4.0.0",
        "grunt-npm-bower": "0.0.4",
        "grunt-postcss": "^0.9.0",
        "grunt-svgmin": "^6.0.0",
        "grunt-usemin": "^3.1.1",
        "grunt-wiredep": "^3.0.1",
        "jit-grunt": "^0.10.0",
        "jshint-stylish": "^2.2.1",
        "karma-jasmine": "3.1.1",
        "karma-phantomjs-launcher": "1.0.4",
        "lodash": "^4.17.15",
        "serve-static": "^1.14.1",
        "time-grunt": "^2.0.0"
    },
    "engines": {
        "node": ">=0.10.0"
    },
    "scripts": {
        "test": "grunt test"
    },
    "browsersList": [
        "last 1 version"
    ]
}

```

`frontend/test/karma.conf.js`:

```js
// Karma configuration
// http://karma-runner.github.io/0.12/config/configuration-file.html
// Generated on 2015-11-27 using
// generator-karma 1.0.0

module.exports = function(config) {
  'use strict';

  config.set({
    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,

    // base path, that will be used to resolve files and exclude
    basePath: '../',

    // testing framework to use (jasmine/mocha/qunit/...)
    // as well as any additional frameworks (requirejs/chai/sinon/...)
    frameworks: [
      "jasmine"
    ],

    // list of files / patterns to load in the browser
    files: [
      // bower:js
      'bower_components/jquery/dist/jquery.js',
      'bower_components/angular/angular.js',
      'bower_components/angular-animate/angular-animate.js',
      'bower_components/angular-bootstrap/ui-bootstrap-tpls.js',
      'bower_components/angular-cookies/angular-cookies.js',
      'bower_components/moment/moment.js',
      'bower_components/angular-moment/angular-moment.js',
      'bower_components/angular-resource/angular-resource.js',
      'bower_components/angular-sanitize/angular-sanitize.js',
      'bower_components/humanize-duration/humanize-duration.js',
      'bower_components/angular-timer/dist/angular-timer.js',
      'bower_components/angular-touch/angular-touch.js',
      'bower_components/angular-ui-router/release/angular-ui-router.js',
      'bower_components/bootstrap/dist/js/bootstrap.js',
      'bower_components/bootstrap-sass-official/assets/javascripts/bootstrap.js',
      'bower_components/dropzone/dist/min/dropzone.min.js',
      'bower_components/ng-csv/build/ng-csv.min.js',
      'bower_components/ng-tags-input/ng-tags-input.js',
      'bower_components/underscore/underscore-umd.js',
      'bower_components/angular-ui-notification/dist/angular-ui-notification.js',
      'bower_components/d3/d3.js',
      'bower_components/c3/c3.js',
      'bower_components/angular-messages/angular-messages.js',
      'bower_components/ng-file-upload/ng-file-upload.js',
      'bower_components/ng-file-upload-shim/ng-file-upload-shim.js',
      'bower_components/es5-shim/es5-shim.js',
      'bower_components/es6-shim/es6-shim.js',
      'bower_components/angular-clipboard/angular-clipboard.js',
      'bower_components/angular-local-storage/dist/angular-local-storage.js',
      'bower_components/angular-highlightjs/build/angular-highlightjs.js',
      'bower_components/marked/lib/marked.js',
      'bower_components/angular-marked/dist/angular-marked.js',
      'bower_components/bootstrap-markdown/js/bootstrap-markdown.js',
      'bower_components/angular-markdown-editor-ghiscoding/src/angular-markdown-editor.js',
      'bower_components/angular-ui-ace/ui-ace.js',
      'bower_components/angular-page-loader/dist/angular-page-loader.js',
      'bower_components/angular-images-resizer/angular-images-resizer.js',
      'bower_components/angular-base64-upload/src/angular-base64-upload.js',
      'bower_components/jquery-ui/jquery-ui.js',
      'bower_components/angular-ui-sortable/sortable.js',
      'bower_components/js-base64/base64.js',
      'bower_components/angular-scroll/angular-scroll.js',
      'bower_components/underscore.string/dist/underscore.string.js',
      'bower_components/angular-drag-and-drop-lists/angular-drag-and-drop-lists.js',
      'bower_components/angular-bootstrap-colorpicker/js/bootstrap-colorpicker-module.js',
      'bower_components/file-saver/FileSaver.js',
      'bower_components/js-url/url.js',
      'bower_components/bootstrap-sass/assets/javascripts/bootstrap.js',
      'bower_components/angular-bootstrap-multiselect/dist/angular-bootstrap-multiselect.js',
      'bower_components/qrcode.js/lib/qrcode.js',
      'bower_components/qrcode/lib/qrcode.js',
      'bower_components/angular-qr/src/angular-qr.js',
      'bower_components/angular-mocks/angular-mocks.js',
      // endbower
      "bower_components/cryptojslib/components/core-min.js",
      "bower_components/cryptojslib/components/sha256-min.js",
      "app/scripts/**/*.js",
      "test/mock/**/*.js",
      "test/spec/**/*.js"
    ],

    // list of files / patterns to exclude
    exclude: [
    ],

    // web server port
    port: 8080,

    // Start these browsers, currently available:
    // - Chrome
    // - ChromeCanary
    // - Firefox
    // - Opera
    // - Safari (only Mac)
    // - PhantomJS
    // - IE (only Windows)
    browsers: [
      "PhantomJS"
    ],

    // Which plugins to enable
    plugins: [
      "karma-phantomjs-launcher",
      "karma-jasmine"
    ],

    // Continuous Integration mode
    // if true, it capture browsers, run tests and exit
    singleRun: false,

    colors: true,

    // level of logging
    // possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG
    logLevel: config.LOG_INFO,

    // Uncomment the following lines if you are using grunt's server to run the tests
    // proxies: {
    //   '/': 'http://localhost:9000/'
    // },
    // URL root prevent conflicts with the site root
    // urlRoot: '_karma_'
  });
};

```

`issues.md`:

```md
## Merge case
Find functional solution to merge several case, potentially shared with multiple organisation.
Implement the service.
Fix the url by the frontend

## Create user
Create an user without any permission should not be possible

## Transaction, authSrv and audit
Audit is not in the same transaction as authSrv operation

```

`migration/src/main/resources/reference.conf`:

```conf
input {
  mainOrganisation: global
  # ElasticSearch
  search {
    # Name of the index
    index: the_hive
    # Address of the ElasticSearch instance
    uri: "http://127.0.0.1:9200"
    # Scroll keepalive
    keepalive: 10h
    # Size of the page for scroll
    pagesize: 10

    maxAttempts = 5
    minBackoff = 10 milliseconds
    maxBackoff = 10 seconds
    randomFactor = 0.2
  }
  filter {
    includeAlertTypes: []
    excludeAlertTypes: []
    includeAlertSources: []
    excludeAlertSources: []
    includeAuditActions: []
    excludeAuditActions: []
    includeAuditObjectTypes: []
    excludeAuditObjectTypes: []
  }

  # Datastore
  datastore {
    name: data
    chunksize: 50k
    hash {
      main: "SHA-256"
      extra: ["SHA-1", "MD5"]
    }
    attachment.password: "malware"
  }
}

output {
  caseNumberShift: 0
  resume: false
  removeData: false
  integrityCheck.enabled: false
  db {
    provider: janusgraph
    janusgraph {
      ## BERJKELEY ##
      # storage.backend: berkeleyje
      # storage.directory: /path/to/database

      ## CASSANDRA ##
      # backend: cql
      # hostname: ["127.0.0.1"]
      # username: "thehive"
      # password: "password"
      # cql {
      #   cluster-name: thp
      #   keyspace: thehive
      #   local-datacenter: dc1
      #   replication-factor: 2
      #   read-consistency-level: ONE
      #   write-consistency-level: ONE
      # }
    }
  }

  storage {
    ## LOCAL FILESYSTEM ##
    # provider: localfs
    # localfs.location: /path/to/files
    ## HDFS ##
    # provider: hdfs
    # hdfs {
    #   root: "hdfs://127.0.0.1:10000"
    #   location: "/thehive"
    #   username: thehive
    # }
  }
}

threadCount: 4
transactionPageSize: 50

from {
  db {
    janusgraph {
      connect {
        maxAttempts = 10
        minBackoff = 1 second
        maxBackoff = 5 seconds
        randomFactor = 0.2
      }
    }
    onConflict {
      maxAttempts = 6
      minBackoff = 100 milliseconds
      maxBackoff = 1 seconds
      randomFactor = 0.2
    }
    chunkSize = 32k
  }
}
to {
  db {
    janusgraph {
      connect {
        maxAttempts = 10
        minBackoff = 1 second
        maxBackoff = 5 seconds
        randomFactor = 0.2
      }
    }
    onConflict {
      maxAttempts = 6
      minBackoff = 100 milliseconds
      maxBackoff = 1 seconds
      randomFactor = 0.2
    }
    chunkSize = 32k
  }
}
batchSize: 100
force: false
```

`migration/src/main/scala/org/thp/thehive/cloner/Cloner.scala`:

```scala
package org.thp.thehive.cloner

import akka.actor.ActorSystem
import com.typesafe.config.{Config, ConfigFactory, ConfigValueFactory}
import org.apache.tinkerpop.gremlin.structure.T
import org.thp.scalligraph.SingleInstance
import org.thp.scalligraph.janus.JanusDatabase
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.connector.cortex.models.CortexSchemaDefinition
import org.thp.thehive.migration.Migrate.getVersion
import org.thp.thehive.models.TheHiveSchemaDefinition
import play.api.libs.logback.LogbackLoggerConfigurator
import play.api.{Configuration, Environment}
import scopt.OParser

import java.io.File
import java.nio.file.{Files, Paths}
import scala.collection.JavaConverters._
import scala.collection.immutable
import scala.util.Success

object Cloner extends App with IntegrityCheckApp {
  def getDatabase(configuration: Configuration)(implicit system: ActorSystem): Database = {
    val janusDatabase = JanusDatabase.openDatabase(configuration, system)
    new JanusDatabase(
      janusDatabase,
      configuration,
      system,
      new SingleInstance(true)
    )
  }

  def addConfig(config: Config, path: String, value: Any): Config =
    config.withValue(path, ConfigValueFactory.fromAnyRef(value))

  val defaultLoggerConfigFile = "/etc/thehive/logback-cloner.xml"
  if (System.getProperty("logger.file") == null && Files.exists(Paths.get(defaultLoggerConfigFile)))
    System.setProperty("logger.file", defaultLoggerConfigFile)

  val builder = OParser.builder[Config]
  val argParser = {
    import builder._
    OParser.sequence(
      programName("cloner"),
      version('v', "version"),
      help('h', "help"),
      head("TheHive cloner tool", getVersion),
      opt[File]('l', "logger-config")
        .valueName("<file>")
        .action { (f, c) =>
          System.setProperty("logger.file", f.getAbsolutePath)
          c
        }
        .text("logback configuration file"),
      opt[File]('c', "config")
        .valueName("<file>")
        .required()
        .action((f, c) => ConfigFactory.parseFileAnySyntax(f).withFallback(c))
        .text("configuration file"),
      opt[Unit]('f', "force")
        .action((_, c) => addConfig(c, "force", true))
    )
  }
  val defaultConfig =
    ConfigFactory
      .parseResources("play/reference-overrides.conf")
      .withFallback(ConfigFactory.defaultReference())
      .resolve()
  OParser.parse(argParser, args, defaultConfig).foreach { config =>
    implicit val actorSystem: ActorSystem = ActorSystem("TheHiveCloner", config)

    try {
      (new LogbackLoggerConfigurator).configure(Environment.simple(), Configuration.empty, Map.empty)

      val sourceDatabase: Database = getDatabase(
        Configuration(
          config
            .getConfig("from")
            .withoutPath("db.janusgraph.index.search")
        )
      )

      val thehiveSchema = new TheHiveSchemaDefinition
      val cortexSchema  = new CortexSchemaDefinition

      {
        val expectedVersion = thehiveSchema.operations.operations.length + 1
        val foundVersion    = sourceDatabase.version(thehiveSchema.name)
        if (foundVersion != expectedVersion) {
          println(s"The schema of TheHive is not valid (expected: $expectedVersion, found: $foundVersion)")
          if (config.getBoolean("force"))
            println("Continuing ...")
          else
            sys.exit(1)
        }
      }
      {
        val expectedVersion = cortexSchema.operations.operations.length + 1
        val foundVersion    = sourceDatabase.version(cortexSchema.name)
        if (foundVersion != expectedVersion) {
          println(s"The schema of Cortex is not valid (expected: $expectedVersion, found: $foundVersion)")
          if (config.getBoolean("force"))
            println("Continuing ...")
          else
            sys.exit(1)
        }
      }

      val destDatabase: Database = getDatabase(
        Configuration(
          config
            .getConfig("to")
        )
      )
      val nonEmpty: Boolean = destDatabase.roTransaction { implicit graph =>
        graph.VV().limit(1).exists
      }
      if (nonEmpty) {
        println("The destination database is not empty.")
        sys.exit(1)
      }

      println("Setting up the database schema ...")
      // don't create initial values
      val models = destDatabase.extraModels ++ thehiveSchema.modelList ++ cortexSchema.modelList
      destDatabase.createSchema(models)
      destDatabase.setVersion(thehiveSchema.name, sourceDatabase.version(thehiveSchema.name))
      destDatabase.setVersion(cortexSchema.name, sourceDatabase.version(cortexSchema.name))

      val batchSize: Int = config.getInt("batchSize")

      println("Copying vertices ...")
      sourceDatabase.roTransaction { from =>
        val vertexIdsBuilder = immutable.Map.newBuilder[AnyRef, AnyRef]

        val allVertices = from.VV().toIterator
        Iterator
          .continually(allVertices)
          .takeWhile(_.hasNext)
          .map(_.take(batchSize))
          .foreach { vv =>
            destDatabase.tryTransaction { to =>
              vv.foreach { vertex =>
                val properties    = T.label +: vertex.label +: vertex.properties[AnyRef]().asScala.flatMap(p => Seq(p.key(), p.value())).toSeq
                val createdVertex = to.underlying.addVertex(properties: _*)
                vertexIdsBuilder += vertex.id() -> createdVertex.id()
              }
              Success(())
            }
          }

        val vertexIds = vertexIdsBuilder.result()
        println("Copying edges ...")
        val allEdges = from.EE().toIterator
        Iterator
          .continually(allEdges)
          .takeWhile(_.hasNext)
          .map(_.take(batchSize))
          .foreach { ee =>
            destDatabase.tryTransaction { to =>
              ee.foreach { edge =>
                val createdEdge = for {
                  inVertex  <- vertexIds.get(edge.inVertex().id()).toIterable.flatMap(to.traversal().V(_).asScala)
                  outVertex <- vertexIds.get(edge.outVertex().id()).toIterable.flatMap(to.traversal().V(_).asScala)
                  properties = edge.properties[AnyRef]().asScala.flatMap(p => Seq(p.key(), p.value())).toSeq
                } yield outVertex.addEdge(edge.label, inVertex, properties: _*)
                if (createdEdge.isEmpty)
                  println(
                    s"Edge ${edge.label()}:${edge.id()} " +
                      s"from ${edge.outVertex().label()}:${edge.outVertex().id()} " +
                      s"to ${edge.inVertex().label()}:${edge.inVertex().id()} " +
                      s"cannot be created"
                  )
              }
              Success(())
            }
          }
      }
      sourceDatabase.close()

      println("Add indices ...")
      destDatabase.addSchemaIndexes(models)
      println("Run checks ...")
      runChecks(destDatabase, Configuration(config))
      destDatabase.close()
    } finally {
      actorSystem.terminate()
      ()
    }
  }
}

```

`migration/src/main/scala/org/thp/thehive/cloner/IntegrityCheckApp.scala`:

```scala
package org.thp.thehive.cloner

import akka.actor.ActorSystem
import akka.actor.typed.ActorRef
import akka.stream.Materializer
import com.google.inject.{Guice, Injector => GInjector}
import net.codingwell.scalaguice.{ScalaModule, ScalaMultibinder}
import org.thp.scalligraph.auth.{UserSrv => UserDB}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services._
import org.thp.thehive.migration.th4.DummyActor
import org.thp.thehive.services._
import play.api.cache.ehcache.EhCacheModule
import play.api.inject.guice.GuiceInjector
import play.api.inject.{ApplicationLifecycle, DefaultApplicationLifecycle, Injector}
import play.api.libs.concurrent.AkkaGuiceSupport
import play.api.{Configuration, Environment}

import javax.inject.Inject
import scala.collection.JavaConverters._
import scala.collection.immutable
import scala.concurrent.ExecutionContext
import scala.concurrent.duration.DurationInt

trait IntegrityCheckApp {
  private def buildApp(configuration: Configuration, db: Database)(implicit actorSystem: ActorSystem): GInjector =
    Guice
      .createInjector(
        (play.api.inject.guice.GuiceableModule.guiceable(new EhCacheModule).guiced(Environment.simple(), configuration, Set.empty) :+
          new ScalaModule with AkkaGuiceSupport {
            override def configure(): Unit = {
              bind[Database].toInstance(db)

              bind[Configuration].toInstance(configuration)
              bind[ActorSystem].toInstance(actorSystem)
              bind[Materializer].toInstance(Materializer(actorSystem))
              bind[ExecutionContext].toInstance(actorSystem.dispatcher)
              bind[Injector].to[GuiceInjector]
              bind[UserDB].to[LocalUserSrv]
              bindActor[DummyActor]("notification-actor")
              bindActor[DummyActor]("config-actor")
              bindActor[DummyActor]("cortex-actor")
              bindActor[DummyActor]("integrity-check-actor")
              bind[ActorRef[CaseNumberActor.Request]].toProvider[CaseNumberActorProvider]

              val integrityCheckOpsBindings = ScalaMultibinder.newSetBinder[IntegrityCheck](binder)
              integrityCheckOpsBindings.addBinding.to[AlertIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[CaseIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[CaseTemplateIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[CustomFieldIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[DataIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ImpactStatusIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[LogIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ObservableIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ObservableTypeIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[OrganisationIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ProfileIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ResolutionStatusIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[TagIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[TaskIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[UserIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[RoleIntegrityCheck]

              bind[Environment].toInstance(Environment.simple())
              bind[ApplicationLifecycle].to[DefaultApplicationLifecycle]
              configuration.get[String]("storage.provider") match {
                case "localfs"  => bind(classOf[StorageSrv]).to(classOf[LocalFileSystemStorageSrv])
                case "database" => bind(classOf[StorageSrv]).to(classOf[DatabaseStorageSrv])
                case "hdfs"     => bind(classOf[StorageSrv]).to(classOf[HadoopStorageSrv])
                case "s3"       => bind(classOf[StorageSrv]).to(classOf[S3StorageSrv])
              }
              ()
            }
          }).asJava
      )

  def runChecks(db: Database, configuration: Configuration)(implicit actorSystem: ActorSystem): Unit =
    buildApp(configuration, db).getInstance(classOf[IntegrityChecks]).runChecks()
}

class IntegrityChecks @Inject() (checks: immutable.Set[IntegrityCheck]) extends MapMerger {
  def runChecks(): Unit =
    checks.foreach { c =>
      println(s"Running check on ${c.name} ...")
      val desupStats = c match {
        case dc: DedupCheck[_] => dc.dedup(KillSwitch.alwaysOn)
        case _                 => Map.empty[String, Long]
      }
      val globalStats = c match {
        case gc: GlobalCheck[_] => gc.runGlobalCheck(24.hours, KillSwitch.alwaysOn)
        case _                  => Map.empty[String, Long]
      }
      val statsStr = (desupStats <+> globalStats)
        .collect {
          case (k, v) if v != 0 => s"$k:$v"
        }
        .mkString(" ")
      if (statsStr.isEmpty)
        println("  no change needed")
      else
        println(s"  $statsStr")

    }
}

```

`migration/src/main/scala/org/thp/thehive/migration/IdMapping.scala`:

```scala
package org.thp.thehive.migration

import org.thp.scalligraph.EntityId

case class IdMapping(inputId: String, outputId: EntityId)

```

`migration/src/main/scala/org/thp/thehive/migration/Input.scala`:

```scala
package org.thp.thehive.migration

import java.text.{ParseException, SimpleDateFormat}
import java.util.Date

import akka.NotUsed
import akka.stream.scaladsl.Source
import com.typesafe.config.Config
import org.thp.thehive.migration.dto._

import scala.collection.JavaConverters._
import scala.concurrent.Future
import scala.util.{Failure, Try}

case class Filter(
    caseDateRange: (Option[Long], Option[Long]),
    caseNumberRange: (Option[Int], Option[Int]),
    alertDateRange: (Option[Long], Option[Long]),
    auditDateRange: (Option[Long], Option[Long]),
    includeAlertTypes: Seq[String],
    excludeAlertTypes: Seq[String],
    includeAlertSources: Seq[String],
    excludeAlertSources: Seq[String],
    includeAuditActions: Seq[String],
    excludeAuditActions: Seq[String],
    includeAuditObjectTypes: Seq[String],
    excludeAuditObjectTypes: Seq[String]
)

object Filter {
  def fromConfig(config: Config): Filter = {
    val now = System.currentTimeMillis()
    lazy val dateFormats = Seq(
      new SimpleDateFormat("yyyyMMddHHmmss"),
      new SimpleDateFormat("yyyyMMddHHmm"),
      new SimpleDateFormat("yyyyMMddHH"),
      new SimpleDateFormat("yyyyMMdd"),
      new SimpleDateFormat("MMdd")
    )
    def parseDate(s: String): Try[Date] =
      dateFormats
        .foldLeft[Try[Date]](Failure(new ParseException(s"Unparseable date: $s", 0))) { (acc, format) =>
          acc.recoverWith { case _ => Try(format.parse(s)) }
        }
        .recoverWith {
          case _ =>
            Failure(
              new ParseException(s"Unparseable date: $s\nExpected format is ${dateFormats.map(_.toPattern).mkString("\"", "\" or \"", "\"")}", 0)
            )
        }
    def readDate(dateConfigName: String, ageConfigName: String): Option[Long] =
      Try(config.getString(dateConfigName))
        .flatMap(parseDate)
        .map(d => d.getTime)
        .orElse {
          Try(config.getDuration(ageConfigName))
            .map(d => now - d.getSeconds * 1000)
        }
        .toOption
    val caseFromDate    = readDate("caseFromDate", "maxCaseAge")
    val caseUntilDate   = readDate("caseUntilDate", "minCaseAge")
    val caseFromNumber  = Try(config.getInt("caseFromNumber")).toOption
    val caseUntilNumber = Try(config.getInt("caseUntilNumber")).toOption
    val alertFromDate   = readDate("alertFromDate", "maxAlertAge")
    val alertUntilDate  = readDate("alertUntilDate", "minAlertAge")
    val auditFromDate   = readDate("auditFromDate", "maxAuditAge")
    val auditUntilDate  = readDate("auditUntilDate", "minAuditAge")

    Filter(
      caseFromDate   -> caseUntilDate,
      caseFromNumber -> caseUntilNumber,
      alertFromDate  -> alertUntilDate,
      auditFromDate  -> auditUntilDate,
      config.getStringList("includeAlertTypes").asScala,
      config.getStringList("excludeAlertTypes").asScala,
      config.getStringList("includeAlertSources").asScala,
      config.getStringList("excludeAlertSources").asScala,
      config.getStringList("includeAuditActions").asScala,
      config.getStringList("excludeAuditActions").asScala,
      config.getStringList("includeAuditObjectTypes").asScala,
      config.getStringList("excludeAuditObjectTypes").asScala
    )
  }
}

trait Input {
  def listOrganisations(filter: Filter): Source[Try[InputOrganisation], NotUsed]
  def countOrganisations(filter: Filter): Future[Long]
  def listCases(filter: Filter): Source[Try[InputCase], NotUsed]
  def countCases(filter: Filter): Future[Long]
  def countCaseObservables(filter: Filter): Future[Long]
  def listCaseObservables(caseId: String): Source[Try[(String, InputObservable)], NotUsed]
  def countCaseTasks(filter: Filter): Future[Long]
  def listCaseTasks(caseId: String): Source[Try[(String, InputTask)], NotUsed]
  def countCaseTaskLogs(filter: Filter): Future[Long]
  def listCaseTaskLogs(caseId: String): Source[Try[(String, InputLog)], NotUsed]
  def listAlerts(filter: Filter): Source[Try[InputAlert], NotUsed]
  def countAlerts(filter: Filter): Future[Long]
  def countAlertObservables(filter: Filter): Future[Long]
  def listAlertObservables(alertId: String): Source[Try[(String, InputObservable)], NotUsed]
  def listUsers(filter: Filter): Source[Try[InputUser], NotUsed]
  def countUsers(filter: Filter): Future[Long]
  def listCustomFields(filter: Filter): Source[Try[InputCustomField], NotUsed]
  def countCustomFields(filter: Filter): Future[Long]
  def listObservableTypes(filter: Filter): Source[Try[InputObservableType], NotUsed]
  def countObservableTypes(filter: Filter): Future[Long]
  def listProfiles(filter: Filter): Source[Try[InputProfile], NotUsed]
  def countProfiles(filter: Filter): Future[Long]
  def listImpactStatus(filter: Filter): Source[Try[InputImpactStatus], NotUsed]
  def countImpactStatus(filter: Filter): Future[Long]
  def listResolutionStatus(filter: Filter): Source[Try[InputResolutionStatus], NotUsed]
  def countResolutionStatus(filter: Filter): Future[Long]
  def listCaseTemplate(filter: Filter): Source[Try[InputCaseTemplate], NotUsed]
  def countCaseTemplate(filter: Filter): Future[Long]
  def listCaseTemplateTask(caseTemplateId: String): Source[Try[(String, InputTask)], NotUsed]
  def countCaseTemplateTask(filter: Filter): Future[Long]
  def listJobs(caseId: String): Source[Try[(String, InputJob)], NotUsed]
  def countJobs(filter: Filter): Future[Long]
  def countJobObservables(filter: Filter): Future[Long]
  def listJobObservables(caseId: String): Source[Try[(String, InputObservable)], NotUsed]
  def countAction(filter: Filter): Future[Long]
  def listActions(entityIds: Seq[String]): Source[Try[(String, InputAction)], NotUsed]
  def countAudits(filter: Filter): Future[Long]
  def listAudits(entityIds: Seq[String], filter: Filter): Source[Try[(String, InputAudit)], NotUsed]
  def countDashboards(filter: Filter): Future[Long]
  def listDashboards(filter: Filter): Source[Try[InputDashboard], NotUsed]
}

```

`migration/src/main/scala/org/thp/thehive/migration/Migrate.scala`:

```scala
package org.thp.thehive.migration

import akka.actor.ActorSystem
import akka.stream.Materializer
import com.typesafe.config.{Config, ConfigFactory, ConfigValueFactory}
import play.api.libs.logback.LogbackLoggerConfigurator
import play.api.{Configuration, Environment}
import scopt.OParser

import java.io.File
import java.nio.file.{Files, Paths}
import scala.collection.JavaConverters._
import scala.concurrent.duration.DurationInt
import scala.concurrent.{blocking, Await, ExecutionContext, Future}

object Migrate extends App with MigrationOps {
  val defaultLoggerConfigFile = "/etc/thehive/logback-migration.xml"
  if (System.getProperty("logger.file") == null && Files.exists(Paths.get(defaultLoggerConfigFile)))
    System.setProperty("logger.file", defaultLoggerConfigFile)
  (new LogbackLoggerConfigurator).configure(Environment.simple(), Configuration.empty, Map.empty)
  var transactionPageSize: Int = 100
  var threadCount: Int         = 3

  def getVersion: String = Option(getClass.getPackage.getImplementationVersion).getOrElse("SNAPSHOT")

  def addConfig(config: Config, path: String, value: Any): Config =
    config.withValue(path, ConfigValueFactory.fromAnyRef(value))

  val builder = OParser.builder[Config]
  val argParser = {
    import builder._
    OParser.sequence(
      programName("migrate"),
      version('v', "version"),
      help('h', "help"),
      head("TheHive migration tool", getVersion),
      opt[File]('l', "logger-config")
        .valueName("<file>")
        .action { (f, c) =>
          System.setProperty("logger.file", f.getAbsolutePath)
          c
        }
        .text("logback configuration file"),
      opt[File]('c', "config")
        .valueName("<file>")
        .action((f, c) => ConfigFactory.parseFileAnySyntax(f).withFallback(c))
        .text("global configuration file"),
      opt[File]('i', "input")
        .valueName("<file>")
        .action((f, c) => addConfig(c, "input", ConfigFactory.parseFileAnySyntax(f).resolve().root().withFallback(c.getConfig("input"))))
        .text("TheHive3 configuration file"),
      opt[File]('o', "output")
        .valueName("<file>")
        .action((f, c) => addConfig(c, "output", ConfigFactory.parseFileAnySyntax(f).resolve().root().withFallback(c.getConfig("output"))))
        .text("TheHive4 configuration file"),
      opt[Unit]('d', "drop-database")
        .action((_, c) => addConfig(c, "output.dropDatabase", true))
        .text("Drop TheHive4 database before migration"),
      opt[Unit]('r', "resume")
        .action((_, c) => addConfig(c, "output.resume", true))
        .text("Resume migration (or migrate on existing database)"),
      opt[String]('m', "main-organisation")
        .valueName("<organisation>")
        .action((o, c) => addConfig(c, "input.mainOrganisation", o)),
      opt[String]('u', "es-uri")
        .valueName("http://ip1:port,ip2:port")
        .text("TheHive3 ElasticSearch URI")
        .action((u, c) => addConfig(c, "input.search.uri", u)),
      opt[String]('e', "es-index")
        .valueName("<index>")
        .text("TheHive3 ElasticSearch index name")
        .action((i, c) => addConfig(c, "input.search.index", i)),
      opt[String]('x', "es-index-version")
        .valueName("<index>")
        .text("TheHive3 ElasticSearch index name version number (default: autodetect)")
        .action((i, c) => addConfig(c, "input.search.indexVersion", i)),
      opt[String]('a', "es-keepalive")
        .valueName("<duration>")
        .text("TheHive3 ElasticSearch keepalive")
        .action((a, c) => addConfig(c, "input.search.keepalive", a)),
      opt[Int]('p', "es-pagesize")
        .text("TheHive3 ElasticSearch page size")
        .action((p, c) => addConfig(c, "input.search.pagesize", p)),
      opt[Boolean]('s', "es-single-type")
        .valueName("<bool>")
        .text("Elasticsearch single type")
        .action((s, c) => addConfig(c, "input.search.singleType", s)),
      opt[Int]('y', "transaction-pagesize")
        .text("page size for each transaction")
        .action((t, c) => addConfig(c, "transactionPageSize", t)),
      opt[Int]('t', "thread-count")
        .text("number of threads")
        .action((t, c) => addConfig(c, "threadCount", t)),
      opt[Unit]('k', "integrity-checks")
        .text("run integrity checks after the migration")
        .action((_, c) => addConfig(c, "output.integrityCheck.enabled", true)),
      /* case age */
      opt[String]("max-case-age")
        .valueName("<duration>")
        .text("migrate only cases whose age is less than <duration>")
        .action((v, c) => addConfig(c, "input.filter.maxCaseAge", v)),
      opt[String]("min-case-age")
        .valueName("<duration>")
        .text("migrate only cases whose age is greater than <duration>")
        .action((v, c) => addConfig(c, "input.filter.minCaseAge", v)),
      opt[String]("case-from-date")
        .valueName("<date>")
        .text("migrate only cases created from <date>")
        .action((v, c) => addConfig(c, "input.filter.caseFromDate", v)),
      opt[String]("case-until-date")
        .valueName("<date>")
        .text("migrate only cases created until <date>")
        .action((v, c) => addConfig(c, "input.filter.caseUntilDate", v)),
      /* case number */
      opt[Int]("case-from-number")
        .valueName("<number>")
        .text("migrate only cases from this case number")
        .action((v, c) => addConfig(c, "input.filter.caseFromNumber", v)),
      opt[Int]("case-until-number")
        .valueName("<number>")
        .text("migrate only cases until this case number")
        .action((v, c) => addConfig(c, "input.filter.caseUntilNumber", v)),
      /* alert age */
      opt[String]("max-alert-age")
        .valueName("<duration>")
        .text("migrate only alerts whose age is less than <duration>")
        .action((v, c) => addConfig(c, "input.filter.maxAlertAge", v)),
      opt[String]("min-alert-age")
        .valueName("<duration>")
        .text("migrate only alerts whose age is greater than <duration>")
        .action((v, c) => addConfig(c, "input.filter.minAlertAge", v)),
      opt[String]("alert-from-date")
        .valueName("<date>")
        .text("migrate only alerts created from <date>")
        .action((v, c) => addConfig(c, "input.filter.alertFromDate", v)),
      opt[String]("alert-until-date")
        .valueName("<date>")
        .text("migrate only alerts created until <date>")
        .action((v, c) => addConfig(c, "input.filter.alertUntilDate", v)),
      opt[Seq[String]]("include-alert-types")
        .valueName("<type>,<type>...")
        .text("migrate only alerts with this types")
        .action((v, c) => addConfig(c, "input.filter.includeAlertTypes", v.asJava)),
      opt[Seq[String]]("exclude-alert-types")
        .valueName("<type>,<type>...")
        .text("don't migrate alerts with this types")
        .action((v, c) => addConfig(c, "input.filter.excludeAlertTypes", v.asJava)),
      opt[Seq[String]]("include-alert-sources")
        .valueName("<source>,<source>...")
        .text("migrate only alerts with this sources")
        .action((v, c) => addConfig(c, "input.filter.includeAlertSources", v.asJava)),
      opt[Seq[String]]("exclude-alert-sources")
        .valueName("<source>,<source>...")
        .text("don't migrate alerts with this sources")
        .action((v, c) => addConfig(c, "input.filter.excludeAlertSources", v.asJava)),
      /* audit age */
      opt[String]("max-audit-age")
        .valueName("<duration>")
        .text("migrate only audits whose age is less than <duration>")
        .action((v, c) => addConfig(c, "input.filter.maxAuditAge", v)),
      opt[String]("min-audit-age")
        .valueName("<duration>")
        .text("migrate only audits whose age is greater than <duration>")
        .action((v, c) => addConfig(c, "input.filter.minAuditAge", v)),
      opt[String]("audit-from-date")
        .valueName("<date>")
        .text("migrate only audits created from <date>")
        .action((v, c) => addConfig(c, "input.filter.auditFromDate", v)),
      opt[String]("audit-until-date")
        .valueName("<date>")
        .text("migrate only audits created until <date>")
        .action((v, c) => addConfig(c, "input.filter.auditUntilDate", v)),
      opt[Seq[String]]("include-audit-actions")
        .text("migration only audits with this action (Update, Creation, Delete)")
        .action((v, c) => addConfig(c, "input.filter.includeAuditActions", v.asJava)),
      opt[Seq[String]]("exclude-audit-actions")
        .text("don't migration audits with this action (Update, Creation, Delete)")
        .action((v, c) => addConfig(c, "input.filter.excludeAuditActions", v.asJava)),
      opt[Seq[String]]("include-audit-objectTypes")
        .text("migration only audits with this objectType (case, case_artifact, case_task, ...)")
        .action((v, c) => addConfig(c, "input.filter.includeAuditObjectTypes", v.asJava)),
      opt[Seq[String]]("exclude-audit-objectTypes")
        .text("don't migration audits with this objectType (case, case_artifact, case_task, ...)")
        .action((v, c) => addConfig(c, "input.filter.excludeAuditObjectTypes", v.asJava)),
      opt[Int]("case-number-shift")
        .text("transpose case number by adding this value")
        .action((v, c) => addConfig(c, "output.caseNumberShift", v)),
      note("Accepted date formats are \"yyyyMMdd[HH[mm[ss]]]\" and \"MMdd\""),
      note(
        "The Format for duration is: <length> <unit>.\n" +
          "Accepted units are:\n" +
          "  DAY:         d, day\n" +
          "  HOUR:        h, hr, hour\n" +
          "  MINUTE:      m, min, minute\n" +
          "  SECOND:      s, sec, second\n" +
          "  MILLISECOND: ms, milli, millisecond"
      )
    )
  }
  val defaultConfig =
    ConfigFactory
      .parseResources("play/reference-overrides.conf")
      .withFallback(ConfigFactory.defaultReference())
      .resolve()
  OParser.parse(argParser, args, defaultConfig).foreach { config =>
    implicit val actorSystem: ActorSystem = ActorSystem("TheHiveMigration", config)
    implicit val ec: ExecutionContext     = actorSystem.dispatcher
    implicit val mat: Materializer        = Materializer(actorSystem)
    transactionPageSize = config.getInt("transactionPageSize")
    threadCount = config.getInt("threadCount")
    var stop = false

    try {
      Future {
        blocking {
          while (!stop) {
            logger.info(migrationStats.showStats())
            migrationStats.flush()
            Thread.sleep(10000) // 10 seconds
          }
        }
      }

      val returnStatus =
        try {
          val input  = th3.Input(Configuration(config.getConfig("input").withFallback(config)))
          val output = th4.Output(Configuration(config.getConfig("output").withFallback(config)))
          val filter = Filter.fromConfig(config.getConfig("input.filter"))

          migrate(input, output, filter).get
          logger.info("Migration finished")
          0
        } catch {
          case e: Throwable =>
            logger.error(s"Migration failed", e)
            1
        } finally {
          stop = true
          Await.ready(actorSystem.terminate(), 1.minute)
          ()
        }
      migrationStats.flush()
      logger.info(migrationStats.toString)
      System.exit(returnStatus)
    } finally {
      actorSystem.terminate()
      ()
    }
  }
}

```

`migration/src/main/scala/org/thp/thehive/migration/MigrationOps.scala`:

```scala
package org.thp.thehive.migration

import akka.NotUsed
import akka.stream.Materializer
import akka.stream.scaladsl.Source
import org.thp.scalligraph.{EntityId, NotFoundError, RichOptionTry}
import org.thp.thehive.migration.dto.{InputAlert, InputAudit, InputCase, InputCaseTemplate}
import play.api.Logger

import java.lang.management.{GarbageCollectorMXBean, ManagementFactory}
import java.text.NumberFormat
import java.util.concurrent.LinkedBlockingQueue
import scala.collection.JavaConverters._
import scala.collection.concurrent.TrieMap
import scala.collection.mutable
import scala.concurrent.ExecutionContext
import scala.util.{Failure, Success, Try}

class MigrationStats() {
  class AVG(var count: Long = 0, var sum: Long = 0) {
    def +=(value: Long): Unit = {
      count += 1
      sum += value
    }
    def ++=(avg: AVG): Unit = {
      count += avg.count
      sum += avg.sum
    }
    def reset(): Unit = {
      count = 0
      sum = 0
    }
    def isEmpty: Boolean          = count == 0L
    override def toString: String = if (isEmpty) "-" else format.format(sum / count / 1000)
  }

  class StatEntry(
      var total: Long = -1,
      var nSuccess: Int = 0,
      var nFailure: Int = 0,
      var nExist: Int = 0,
      global: AVG = new AVG,
      current: AVG = new AVG
  ) {
    def update(isSuccess: Boolean, time: Long): Unit = {
      if (isSuccess) nSuccess += 1
      else nFailure += 1
      current += time
    }

    def failure(): Unit = nFailure += 1

    def exist(): Unit = nExist += 1

    def flush(): Unit = {
      global ++= current
      current.reset()
    }

    def isEmpty: Boolean = nSuccess == 0 && nFailure == 0

    def currentStats: String = {
      val totalTxt = if (total < 0) "" else s"/$total"
      val avg      = if (current.isEmpty) "" else s"(${current}µs)"
      s"${nSuccess + nFailure}$totalTxt$avg"
    }

    def setTotal(v: Long): Unit = total = v

    override def toString: String = {
      val totalTxt = if (total < 0) s"/${nSuccess + nFailure}" else s"/$total"
      val avg      = if (global.isEmpty) "" else s" avg:${global}µs"
      val failureAndExistTxt = if (nFailure > 0 || nExist > 0) {
        val failureTxt = if (nFailure > 0) s"$nFailure failures" else ""
        val existTxt   = if (nExist > 0) s"$nExist exists" else ""
        if (nFailure > 0 && nExist > 0) s" ($failureTxt, $existTxt)" else s" ($failureTxt$existTxt)"
      } else ""
      s"$nSuccess$totalTxt$failureAndExistTxt$avg"
    }
  }

  val logger: Logger                    = Logger("org.thp.thehive.migration.Migration")
  val stats: TrieMap[String, StatEntry] = TrieMap.empty
  var stage: String                     = "initialisation"

  def apply[A](name: String)(body: => Try[A]): Try[A] = {
    val start = System.nanoTime()
    val ret   = body
    val time  = System.nanoTime() - start
    stats.getOrElseUpdate(name, new StatEntry).update(ret.isSuccess, time)
    if (ret.isFailure)
      logger.error(s"$name creation failure: ${ret.failed.get}")
    ret
  }

  def failure(name: String, error: Throwable): Unit = {
    logger.error(s"$name creation failure: $error")
    stats.getOrElseUpdate(name, new StatEntry).failure()
  }

  def exist(name: String): Unit = {
    logger.debug(s"$name already exists")
    stats.getOrElseUpdate(name, new StatEntry).exist()
  }

  def flush(): Unit = stats.foreach(_._2.flush())

  private val runtime: Runtime                 = Runtime.getRuntime
  private val gcs: Seq[GarbageCollectorMXBean] = ManagementFactory.getGarbageCollectorMXBeans.asScala
  private var startPeriod: Long                = System.nanoTime()
  private var previousTotalGCTime: Long        = gcs.map(_.getCollectionTime).sum
  private var previousTotalGCCount: Long       = gcs.map(_.getCollectionCount).sum
  private val format: NumberFormat             = NumberFormat.getInstance()
  def memoryUsage(): String = {
    val now          = System.nanoTime()
    val totalGCTime  = gcs.map(_.getCollectionTime).sum
    val totalGCCount = gcs.map(_.getCollectionCount).sum
    val gcTime       = totalGCTime - previousTotalGCTime
    val gcCount      = totalGCCount - previousTotalGCCount
    val gcPercent    = gcTime * 100 * 1000 * 1000 / (now - startPeriod)
    previousTotalGCTime = totalGCTime
    previousTotalGCCount = totalGCCount
    startPeriod = now
    val freeMem = runtime.freeMemory
    val maxMem  = runtime.maxMemory
    val percent = 100 - (freeMem * 100 / maxMem)
    s"${format.format((maxMem - freeMem) / 1024)}/${format.format(maxMem / 1024)}KiB($percent%) GC:$gcCount (cpu:$gcPercent% ${gcTime}ms)"
  }
  def showStats(): String =
    memoryUsage + "\n" +
      stats
        .toSeq
        .sortBy(_._1)
        .collect {
          case (name, entry) if !entry.isEmpty => s"$name:${entry.currentStats}"
        }
        .mkString(s"[$stage] ", " ", "")

  override def toString: String =
    stats
      .map {
        case (name, entry) => s"$name: $entry"
      }
      .toSeq
      .sorted
      .mkString(s"Stage: $stage\n", "\n", "")

  def setTotal(name: String, count: Long): Unit =
    stats.getOrElseUpdate(name, new StatEntry).setTotal(count)
}

trait MigrationOps {
  lazy val logger: Logger            = Logger(getClass)
  val migrationStats: MigrationStats = new MigrationStats

  implicit class RichSource[A](source: Source[A, NotUsed]) {
    def toIterator(capacity: Int = 3)(implicit mat: Materializer, ec: ExecutionContext): Iterator[A] = {
      val queue = new LinkedBlockingQueue[Option[A]](capacity)
      source
        .runForeach(a => queue.put(Some(a)))
        .onComplete(_ => queue.put(None))
      new Iterator[A] {
        var e: Option[A]              = queue.take()
        override def hasNext: Boolean = e.isDefined
        override def next(): A = { val r = e.get; e = queue.take(); r }
      }
    }
  }

  def mergeSortedIterator[A](it1: Iterator[A], it2: Iterator[A])(implicit ordering: Ordering[A]): Iterator[A] =
    new Iterator[A] {
      var e1: Option[A]                   = get(it1)
      var e2: Option[A]                   = get(it2)
      def get(it: Iterator[A]): Option[A] = if (it.hasNext) Some(it.next()) else None
      def emit1: A = { val r = e1.get; e1 = get(it1); r }
      def emit2: A = { val r = e2.get; e2 = get(it2); r }
      override def hasNext: Boolean = e1.isDefined || e2.isDefined
      override def next(): A =
        if (e1.isDefined)
          if (e2.isDefined)
            if (ordering.lt(e1.get, e2.get)) emit1
            else emit2
          else emit1
        else if (e2.isDefined) emit2
        else throw new NoSuchElementException()
    }

  def transactionPageSize: Int

  def threadCount: Int

  implicit class IdMappingOpsDefs(idMappings: Seq[IdMapping]) {

    def fromInput(id: String): Try[EntityId] =
      idMappings
        .find(_.inputId == id)
        .fold[Try[EntityId]](Failure(NotFoundError(s"Id $id not found")))(m => Success(m.outputId))
  }

  def migrate[TX, A](
      output: Output[TX]
  )(name: String, source: Source[Try[A], NotUsed], create: (TX, A) => Try[IdMapping], exists: (TX, A) => Boolean = (_: TX, _: A) => true)(implicit
      mat: Materializer,
      ec: ExecutionContext
  ): Seq[IdMapping] =
    source
      .toIterator()
      .grouped(transactionPageSize)
      .flatMap { elements =>
        output
          .withTx { tx =>
            Try {
              elements.flatMap {
                case Success(a) if !exists(tx, a) => migrationStats(name)(create(tx, a)).toOption
                case Failure(error) =>
                  migrationStats.failure(name, error)
                  Nil
                case _ =>
                  migrationStats.exist(name)
                  Nil
              }
            }
          }
          .getOrElse(Nil)
      }
      .toList

  def migrateWithParent[TX, A](output: Output[TX])(
      name: String,
      parentIds: Seq[IdMapping],
      source: Source[Try[(String, A)], NotUsed],
      create: (TX, EntityId, A) => Try[IdMapping]
  )(implicit mat: Materializer, ec: ExecutionContext): Seq[IdMapping] =
    source
      .toIterator()
      .grouped(transactionPageSize)
      .flatMap { elements =>
        output
          .withTx { tx =>
            Try {
              elements.flatMap {
                case Success((parentId, a)) =>
                  parentIds
                    .fromInput(parentId)
                    .flatMap(parent => migrationStats(name)(create(tx, parent, a)))
                    .toOption
                case Failure(error) =>
                  migrationStats.failure(name, error)
                  Nil
                case _ =>
                  migrationStats.exist(name)
                  Nil
              }
            }
          }
          .getOrElse(Nil)
      }
      .toList

  def migrateAudit[TX](
      output: Output[TX]
  )(ids: Seq[IdMapping], source: Source[Try[(String, InputAudit)], NotUsed])(implicit mat: Materializer, ec: ExecutionContext): Unit =
    source
      .toIterator()
      .grouped(transactionPageSize)
      .foreach { audits =>
        output.withTx { tx =>
          audits.foreach {
            case Success((contextId, inputAudit)) =>
              migrationStats("Audit") {
                for {
                  cid <- ids.fromInput(contextId)
                  objId = inputAudit.audit.objectId.map(ids.fromInput).flip.getOrElse {
                    logger.warn(s"object Id not found in audit ${inputAudit.audit}")
                    None
                  }
                  _ <- output.createAudit(tx, cid, inputAudit.updateObjectId(objId))
                } yield ()
              }
              ()
            case Failure(error) =>
              migrationStats.failure("Audit", error)
          }
          Success(())
        }
        ()
      }

  def migrateAWholeCaseTemplate[TX](input: Input, output: Output[TX])(
      inputCaseTemplate: InputCaseTemplate
  )(implicit mat: Materializer, ec: ExecutionContext): Unit =
    migrationStats("CaseTemplate")(output.withTx(output.createCaseTemplate(_, inputCaseTemplate)))
      .foreach {
        case caseTemplateId @ IdMapping(inputCaseTemplateId, _) =>
          migrateWithParent(output)(
            "CaseTemplate/Task",
            Seq(caseTemplateId),
            input.listCaseTemplateTask(inputCaseTemplateId),
            output.createCaseTemplateTask
          )
          ()
      }

  def migrateWholeCaseTemplates[TX](input: Input, output: Output[TX], filter: Filter)(implicit
      mat: Materializer,
      ec: ExecutionContext
  ): Unit =
    input
      .listCaseTemplate(filter)
      .toIterator()
      .grouped(transactionPageSize)
      .foreach { cts =>
        output
          .withTx { tx =>
            Try {
              cts.flatMap {
                case Success(ct) if !output.caseTemplateExists(tx, ct) => List(ct)
                case Failure(error) =>
                  migrationStats.failure("CaseTemplate", error)
                  Nil
                case _ =>
                  migrationStats.exist("CaseTemplate")
                  Nil
              }
            }
          }
          .foreach(_.foreach(migrateAWholeCaseTemplate(input, output)))
      }

  def migrateAWholeCase[TX](input: Input, output: Output[TX], filter: Filter)(
      inputCase: InputCase
  )(implicit mat: Materializer, ec: ExecutionContext): Option[IdMapping] =
    migrationStats("Case")(output.withTx(output.createCase(_, inputCase))).map {
      case caseId @ IdMapping(inputCaseId, _) =>
        val caseTaskIds    = migrateWithParent(output)("Case/Task", Seq(caseId), input.listCaseTasks(inputCaseId), output.createCaseTask)
        val caseTaskLogIds = migrateWithParent(output)("Case/Task/Log", caseTaskIds, input.listCaseTaskLogs(inputCaseId), output.createCaseTaskLog)
        val caseObservableIds =
          migrateWithParent(output)("Case/Observable", Seq(caseId), input.listCaseObservables(inputCaseId), output.createCaseObservable)
        val jobIds = migrateWithParent(output)("Job", caseObservableIds, input.listJobs(inputCaseId), output.createJob)
        val jobObservableIds =
          migrateWithParent(output)("Case/Observable/Job/Observable", jobIds, input.listJobObservables(inputCaseId), output.createJobObservable)
        val caseEntitiesIds      = caseTaskIds ++ caseTaskLogIds ++ caseObservableIds ++ jobIds ++ jobObservableIds :+ caseId
        val actionSource         = input.listActions(caseEntitiesIds.map(_.inputId).distinct)
        val actionIds            = migrateWithParent(output)("Action", caseEntitiesIds, actionSource, output.createAction)
        val caseEntitiesAuditIds = caseEntitiesIds ++ actionIds
        val auditSource          = input.listAudits(caseEntitiesAuditIds.map(_.inputId).distinct, filter)
        migrateAudit(output)(caseEntitiesAuditIds, auditSource)
        caseId
    }.toOption

  def migrateAWholeAlert[TX](input: Input, output: Output[TX], filter: Filter)(
      inputAlert: InputAlert
  )(implicit mat: Materializer, ec: ExecutionContext): Option[EntityId] =
    migrationStats("Alert")(output.withTx(output.createAlert(_, inputAlert))).map {
      case alertId @ IdMapping(inputAlertId, outputEntityId) =>
        val alertObservableIds =
          migrateWithParent(output)("Alert/Observable", Seq(alertId), input.listAlertObservables(inputAlertId), output.createAlertObservable)
        val alertEntitiesIds      = alertId +: alertObservableIds
        val actionSource          = input.listActions(alertEntitiesIds.map(_.inputId).distinct)
        val actionIds             = migrateWithParent(output)("Action", alertEntitiesIds, actionSource, output.createAction)
        val alertEntitiesAuditIds = alertEntitiesIds ++ actionIds
        val auditSource           = input.listAudits(alertEntitiesAuditIds.map(_.inputId).distinct, filter)
        migrateAudit(output)(alertEntitiesAuditIds, auditSource)
        outputEntityId
    }.toOption

  def migrateCasesAndAlerts[TX](input: Input, output: Output[TX], filter: Filter)(implicit
      ec: ExecutionContext,
      mat: Materializer
  ): Unit = {
    val pendingAlertCase: mutable.Buffer[(String, EntityId)] = mutable.Buffer.empty

    val ordering: Ordering[Either[InputAlert, InputCase]] = new Ordering[Either[InputAlert, InputCase]] {
      def createdAt(x: Either[InputAlert, InputCase]): Long = x.fold(_.metaData.createdAt.getTime, _.metaData.createdAt.getTime)

      override def compare(x: Either[InputAlert, InputCase], y: Either[InputAlert, InputCase]): Int =
        java.lang.Long.compare(createdAt(x), createdAt(y)) * -1
    }

    val caseIterator = input
      .listCases(filter)
      .toIterator()
      .flatMap {
        case Success(c) if !output.withTx(tx => Try(output.caseExists(tx, c))).fold(_ => false, identity) => List(Right(c))
        case Failure(error) =>
          migrationStats.failure("Case", error)
          Nil
        case _ =>
          migrationStats.exist("Case")
          Nil
      }
    val alertIterator = input
      .listAlerts(filter)
      .toIterator()
      .flatMap {
        case Success(a) if !output.withTx(tx => Try(output.alertExists(tx, a))).fold(_ => false, identity) => List(Left(a))
        case Failure(error) =>
          migrationStats.failure("Alert", error)
          Nil
        case _ =>
          migrationStats.exist("Alert")
          Nil
      }
    val caseIds = mergeSortedIterator(caseIterator, alertIterator)(ordering)
      .grouped(threadCount)
      .foldLeft[Seq[IdMapping]](Nil) {
        case (caseIds, alertsCases) =>
          caseIds ++ alertsCases
            .par
            .flatMap {
              case Right(case0) =>
                migrateAWholeCase(input, output, filter)(case0)
              case Left(alert) =>
                val caseId = alert.caseId.flatMap(cid => caseIds.find(_.inputId == cid)).map(_.outputId)
                migrateAWholeAlert(input, output, filter)(alert.updateCaseId(caseId.map(_.toString)))
                  .map { alertId =>
                    if (caseId.isEmpty && alert.caseId.isDefined)
                      pendingAlertCase.synchronized(pendingAlertCase += (alert.caseId.get -> alertId))
                    None
                  }
                None
            }
      }
    pendingAlertCase.foreach {
      case (cid, alertId) =>
        caseIds.fromInput(cid).toOption match {
          case None         => logger.warn(s"Case ID $cid not found. Link with alert $alertId is ignored")
          case Some(caseId) => output.withTx(output.linkAlertToCase(_, alertId, caseId))
        }
    }
  }

  def migrate[TX](input: Input, output: Output[TX], filter: Filter)(implicit
      ec: ExecutionContext,
      mat: Materializer
  ): Try[Unit] = {

    migrationStats.stage = "Get element count"
    input.countOrganisations(filter).foreach(count => migrationStats.setTotal("Organisation", count))
    input.countCases(filter).foreach(count => migrationStats.setTotal("Case", count))
    input.countCaseObservables(filter).foreach(count => migrationStats.setTotal("Case/Observable", count))
    input.countCaseTasks(filter).foreach(count => migrationStats.setTotal("Case/Task", count))
    input.countCaseTaskLogs(filter).foreach(count => migrationStats.setTotal("Case/Task/Log", count))
    input.countAlerts(filter).foreach(count => migrationStats.setTotal("Alert", count))
    input.countAlertObservables(filter).foreach(count => migrationStats.setTotal("Alert/Observable", count))
    input.countUsers(filter).foreach(count => migrationStats.setTotal("User", count))
    input.countCustomFields(filter).foreach(count => migrationStats.setTotal("CustomField", count))
    input.countObservableTypes(filter).foreach(count => migrationStats.setTotal("ObservableType", count))
    input.countProfiles(filter).foreach(count => migrationStats.setTotal("Profile", count))
    input.countImpactStatus(filter).foreach(count => migrationStats.setTotal("ImpactStatus", count))
    input.countResolutionStatus(filter).foreach(count => migrationStats.setTotal("ResolutionStatus", count))
    input.countCaseTemplate(filter).foreach(count => migrationStats.setTotal("CaseTemplate", count))
    input.countCaseTemplateTask(filter).foreach(count => migrationStats.setTotal("CaseTemplate/Task", count))
    input.countJobs(filter).foreach(count => migrationStats.setTotal("Job", count))
    input.countJobObservables(filter).foreach(count => migrationStats.setTotal("Job/Observable", count))
    input.countAction(filter).foreach(count => migrationStats.setTotal("Action", count))
    input.countAudits(filter).foreach(count => migrationStats.setTotal("Audit", count))

    migrationStats.stage = "Prepare database"
    output.startMigration().flatMap { _ =>
      migrationStats.stage = "Migrate profiles"
      migrate(output)("Profile", input.listProfiles(filter), output.createProfile, output.profileExists)
      migrationStats.stage = "Migrate organisations"
      migrate(output)("Organisation", input.listOrganisations(filter), output.createOrganisation, output.organisationExists)
      migrationStats.stage = "Migrate users"
      migrate(output)("User", input.listUsers(filter), output.createUser, output.userExists)
      migrationStats.stage = "Migrate impact statuses"
      migrate(output)("ImpactStatus", input.listImpactStatus(filter), output.createImpactStatus, output.impactStatusExists)
      migrationStats.stage = "Migrate resolution statuses"
      migrate(output)("ResolutionStatus", input.listResolutionStatus(filter), output.createResolutionStatus, output.resolutionStatusExists)
      migrationStats.stage = "Migrate custom fields"
      migrate(output)("CustomField", input.listCustomFields(filter), output.createCustomField, output.customFieldExists)
      migrationStats.stage = "Migrate observable types"
      migrate(output)("ObservableType", input.listObservableTypes(filter), output.createObservableTypes, output.observableTypeExists)
      migrationStats.stage = "Migrate case templates"
      migrateWholeCaseTemplates(input, output, filter)
      migrationStats.stage = "Migrate dashboards"
      migrate(output)("Dashboard", input.listDashboards(filter), output.createDashboard, output.dashboardExists)
      migrationStats.stage = "Migrate cases and alerts"
      migrateCasesAndAlerts(input, output, filter)
      migrationStats.stage = "Finalisation"
      output.endMigration()
    }
  }
}

```

`migration/src/main/scala/org/thp/thehive/migration/Output.scala`:

```scala
package org.thp.thehive.migration

import org.thp.scalligraph.EntityId
import org.thp.thehive.migration.dto._

import scala.util.Try

trait Output[TX] {
  def startMigration(): Try[Unit]
  def endMigration(): Try[Unit]
  def withTx[R](body: TX => Try[R]): Try[R]
  def profileExists(tx: TX, inputProfile: InputProfile): Boolean
  def createProfile(tx: TX, inputProfile: InputProfile): Try[IdMapping]
  def organisationExists(tx: TX, inputOrganisation: InputOrganisation): Boolean
  def createOrganisation(tx: TX, inputOrganisation: InputOrganisation): Try[IdMapping]
  def userExists(tx: TX, inputUser: InputUser): Boolean
  def createUser(tx: TX, inputUser: InputUser): Try[IdMapping]
  def customFieldExists(tx: TX, inputCustomField: InputCustomField): Boolean
  def createCustomField(tx: TX, inputCustomField: InputCustomField): Try[IdMapping]
  def observableTypeExists(tx: TX, inputObservableType: InputObservableType): Boolean
  def createObservableTypes(tx: TX, inputObservableType: InputObservableType): Try[IdMapping]
  def impactStatusExists(tx: TX, inputImpactStatus: InputImpactStatus): Boolean
  def createImpactStatus(tx: TX, inputImpactStatus: InputImpactStatus): Try[IdMapping]
  def resolutionStatusExists(tx: TX, inputResolutionStatus: InputResolutionStatus): Boolean
  def createResolutionStatus(tx: TX, inputResolutionStatus: InputResolutionStatus): Try[IdMapping]
  def caseTemplateExists(tx: TX, inputCaseTemplate: InputCaseTemplate): Boolean
  def createCaseTemplate(tx: TX, inputCaseTemplate: InputCaseTemplate): Try[IdMapping]
  def createCaseTemplateTask(tx: TX, caseTemplateId: EntityId, inputTask: InputTask): Try[IdMapping]
  def caseExists(tx: TX, inputCase: InputCase): Boolean
  def createCase(tx: TX, inputCase: InputCase): Try[IdMapping]
  def createCaseObservable(tx: TX, caseId: EntityId, inputObservable: InputObservable): Try[IdMapping]
  def createJob(tx: TX, observableId: EntityId, inputJob: InputJob): Try[IdMapping]
  def createJobObservable(tx: TX, jobId: EntityId, inputObservable: InputObservable): Try[IdMapping]
  def createCaseTask(tx: TX, caseId: EntityId, inputTask: InputTask): Try[IdMapping]
  def createCaseTaskLog(tx: TX, taskId: EntityId, inputLog: InputLog): Try[IdMapping]
  def alertExists(tx: TX, inputAlert: InputAlert): Boolean
  def createAlert(tx: TX, inputAlert: InputAlert): Try[IdMapping]
  def linkAlertToCase(tx: TX, alertId: EntityId, caseId: EntityId): Try[Unit]
  def createAlertObservable(tx: TX, alertId: EntityId, inputObservable: InputObservable): Try[IdMapping]
  def createAction(tx: TX, objectId: EntityId, inputAction: InputAction): Try[IdMapping]
  def createAudit(tx: TX, contextId: EntityId, inputAudit: InputAudit): Try[Unit]
  def dashboardExists(tx: TX, inputDashboard: InputDashboard): Boolean
  def createDashboard(tx: TX, inputDashboard: InputDashboard): Try[IdMapping]
}

```

`migration/src/main/scala/org/thp/thehive/migration/ProgressBar.scala`:

```scala
package org.thp.thehive.migration
import java.io.{PrintWriter, StringWriter}

import play.api.Logger

import scala.util.Try

class ProgressBar(terminal: Terminal, message: String, max: Int) {
  private var isDisplayed   = false
  private var current: Long = 0
  private val isTTY         = Try(terminal.getWidth()).isSuccess
  lazy val logger: Logger   = Logger(getClass)

  def inc(increment: Int = 1, extraMessage: String = ""): Unit = {
    current += increment

    val now = System.currentTimeMillis()

    val percent     = current * 100 / max
    val status      = s"[$current/$max:$percent%]"
    val fullMessage = s"$message $extraMessage".replaceAll("[\n\r]", "")
    logger.info(s"$now $current/$max $fullMessage ")
    if (isTTY) {
      val width         = terminal.getWidth()
      val progressWidth = width - status.length - 2
      val currentWidth  = (current * progressWidth / max).toInt
      val progress      = "=" * currentWidth + " " * (progressWidth - currentWidth)
      if (isDisplayed) {
        terminal.up(2)
        terminal.left(width)
        terminal.clearScreen(0)
      } else isDisplayed = true
      terminal.println(fullMessage)
      terminal.println(s"[$progress]$status")
    } else terminal.println(s"$status $fullMessage")
    terminal.flush()
  }

  def message(s: String): Unit = {
    if (isTTY && isDisplayed) {
      terminal.up(2)
      terminal.left(terminal.getWidth())
      terminal.clearScreen(0)
    }
    isDisplayed = false
    terminal.println(s)
  }

  def message(s: String, t: Throwable): Unit = {
    val errors = new StringWriter
    t.printStackTrace(new PrintWriter(errors))
    message(s"$s\n$errors")
  }
}

```

`migration/src/main/scala/org/thp/thehive/migration/QueueIterator.scala`:

```scala
package org.thp.thehive.migration

import akka.stream.StreamDetachedException
import akka.stream.scaladsl.SinkQueueWithCancel
import play.api.Logger

import java.util.NoSuchElementException
import scala.concurrent.Await
import scala.concurrent.duration.{Duration, DurationInt}
import scala.util.control.NonFatal

class QueueIterator[T](queue: SinkQueueWithCancel[T], readTimeout: Duration) extends Iterator[T] {
  lazy val logger: Logger = Logger(getClass)

  private var nextValue: Option[T] = None
  private var isFinished: Boolean  = false
  def getNextValue(): Unit =
    try nextValue = Await.result(queue.pull(), readTimeout)
    catch {
      case _: StreamDetachedException =>
        isFinished = true
        nextValue = None
      case NonFatal(e) =>
        logger.error("Stream fails", e)
        isFinished = true
        nextValue = None
    }
  override def hasNext: Boolean =
    if (isFinished) false
    else {
      if (nextValue.isEmpty)
        getNextValue()
      nextValue.isDefined
    }

  override def next(): T =
    nextValue match {
      case Some(v) =>
        nextValue = None
        v
      case _ if !isFinished =>
        getNextValue()
        nextValue.getOrElse {
          isFinished = true
          throw new NoSuchElementException
        }
      case _ => throw new NoSuchElementException
    }
}

object QueueIterator {
  def apply[T](queue: SinkQueueWithCancel[T], readTimeout: Duration = 10.minute) = new QueueIterator[T](queue, readTimeout)
}

```

`migration/src/main/scala/org/thp/thehive/migration/Terminal.scala`:

```scala
package org.thp.thehive.migration
import java.io.{File, OutputStreamWriter, Writer}

class Terminal(output: Writer) {
  lazy val pathedTput: String = if (new File("/usr/bin/tput").exists) "/usr/bin/tput" else "tput"

  def consoleDim(s: String): Int = {
    import sys.process._
    Seq("bash", "-c", s"$pathedTput $s 2> /dev/tty").!!.trim.toInt
  }
  def getWidth(): Int                = consoleDim("cols")
  def getHeight(): Int               = consoleDim("lines")
  def control(n: Int, c: Char): Unit = output.write(s"\033[" + n + c)

  /**
    * Move up `n` squares
    */
  def up(n: Int): Unit = if (n != 0) control(n, 'A')

  /**
    * Move down `n` squares
    */
  def down(n: Int): Unit = if (n != 0) control(n, 'B')

  /**
    * Move right `n` squares
    */
  def right(n: Int): Unit = if (n != 0) control(n, 'C')

  /**
    * Move left `n` squares
    */
  def left(n: Int): Unit = if (n != 0) control(n, 'D')

  /**
    * Clear the screen
    *
    * n=0: clear from cursor to end of screen
    * n=1: clear from cursor to start of screen
    * n=2: clear entire screen
    */
  def clearScreen(n: Int): Unit = control(n, 'J')

  /**
    * Clear the current line
    *
    * n=0: clear from cursor to end of line
    * n=1: clear from cursor to start of line
    * n=2: clear entire line
    */
  def clearLine(n: Int): Unit = control(n, 'K')

  def flush(): Unit = output.flush()

  def println(s: String): Unit = output.write(s + "\n")
}

object Terminal {

  // Prefer standard tools. Not sure why we need to do this, but for some
  // reason the version installed by gnu-coreutils blows up sometimes giving
  // "unable to perform all requested operations"
  lazy val pathedStty: String = if (new File("/bin/stty").exists) "/bin/stty" else "stty"

  def apply[A](body: Terminal => A): A = {
    stty("-a")
    val initialConfig = stty("-g").trim
    try {
      stty("-icanon min 1 -icrnl -inlcr -ixon")
      sttyFailTolerant("dsusp undef")
      stty("-echo")
//      stty("intr undef")
      body(new Terminal(new OutputStreamWriter(System.out)))
    } finally restore(initialConfig)
  }

  private def sttyCmd(s: String) = {
    import sys.process._
    Seq("bash", "-c", s"$pathedStty $s < /dev/tty"): ProcessBuilder
  }

  def stty(s: String): String = sttyCmd(s).!!

  /*
   * Executes a stty command for which failure is expected, hence the return
   * status can be non-null and errors are ignored.
   * This is appropriate for `stty dsusp undef`, since it's unsupported on Linux
   * (http://man7.org/linux/man-pages/man3/termios.3.html).
   */
  def sttyFailTolerant(s: String): Int = sttyCmd(s ++ " 2> /dev/null").!

  def restore(initialConfig: String): Unit = {
    stty(initialConfig)
    ()
  }
}

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputAction.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.connector.cortex.models.Action

case class InputAction(metaData: MetaData, objectType: String, action: Action)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputAlert.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.Alert

case class InputAlert(
    metaData: MetaData,
    alert: Alert,
    caseId: Option[String],
    organisation: String,
    customFields: Map[String, Option[Any]],
    caseTemplate: Option[String]
) {
  def updateCaseId(caseId: Option[String]): InputAlert = copy(caseId = caseId)
}

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputAttachment.scala`:

```scala
package org.thp.thehive.migration.dto

import akka.NotUsed
import akka.stream.scaladsl.Source
import akka.util.ByteString

case class InputAttachment(name: String, size: Long, contentType: String, hashes: Seq[String], data: Source[ByteString, NotUsed])

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputAudit.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.scalligraph.EntityId
import org.thp.thehive.models.Audit

case class InputAudit(metaData: MetaData, audit: Audit) {
  def updateObjectId(objectId: Option[EntityId]): InputAudit = copy(audit = audit.copy(objectId = objectId.map(_.value)))
}

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputCase.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.Case

case class InputCase(
    `case`: Case,
    organisations: Map[String, String],
    customFields: Map[String, Option[Any]],
    metaData: MetaData
)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputCaseTemplate.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.dto.v1.InputCustomFieldValue
import org.thp.thehive.models.CaseTemplate

case class InputCaseTemplate(
    metaData: MetaData,
    caseTemplate: CaseTemplate,
    organisation: String,
    customFields: Seq[InputCustomFieldValue]
)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputCustomField.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.CustomField

case class InputCustomField(metaData: MetaData, customField: CustomField)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputDashboard.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.Dashboard

case class InputDashboard(metaData: MetaData, organisation: Option[(String, Boolean)], dashboard: Dashboard)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputImpactStatus.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.ImpactStatus

case class InputImpactStatus(metaData: MetaData, impactStatus: ImpactStatus)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputJob.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.connector.cortex.models.Job

case class InputJob(metaData: MetaData, job: Job)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputLog.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.Log

case class InputLog(metaData: MetaData, log: Log, attachments: Seq[InputAttachment])

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputObservable.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.{Observable, ReportTag}

case class InputObservable(
    metaData: MetaData,
    observable: Observable,
    organisations: Set[String],
    dataOrAttachment: Either[String, InputAttachment],
    reportTags: Seq[ReportTag]
)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputObservableType.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.ObservableType

case class InputObservableType(metaData: MetaData, observableType: ObservableType)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputOrganisation.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.Organisation

case class InputOrganisation(metaData: MetaData, organisation: Organisation)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputProfile.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.Profile

case class InputProfile(metaData: MetaData, profile: Profile)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputResolutionStatus.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.ResolutionStatus

case class InputResolutionStatus(metaData: MetaData, resolutionStatus: ResolutionStatus)

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputTask.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.Task

case class InputTask(metaData: MetaData, task: Task, owner: Option[String], organisations: Set[String])

```

`migration/src/main/scala/org/thp/thehive/migration/dto/InputUser.scala`:

```scala
package org.thp.thehive.migration.dto

import org.thp.thehive.models.User

case class InputUser(metaData: MetaData, user: User, organisations: Map[String, String], avatar: Option[InputAttachment])

```

`migration/src/main/scala/org/thp/thehive/migration/dto/MetaData.scala`:

```scala
package org.thp.thehive.migration.dto

import java.util.Date

case class MetaData(id: String, createdBy: String, createdAt: Date, updatedBy: Option[String], updatedAt: Option[Date])

```

`migration/src/main/scala/org/thp/thehive/migration/th3/Conversion.scala`:

```scala
package org.thp.thehive.migration.th3

import akka.NotUsed
import akka.stream.scaladsl.Source
import akka.util.ByteString
import org.thp.scalligraph.utils.Hash
import org.thp.thehive.connector.cortex.models.{Action, Job, JobStatus}
import org.thp.thehive.controllers.v0
import org.thp.thehive.dto.v1.InputCustomFieldValue
import org.thp.thehive.migration.dto._
import org.thp.thehive.models._
import play.api.libs.functional.syntax._
import play.api.libs.json.JsValue.jsValueToJsLookup
import play.api.libs.json._

import java.util.{Base64, Date}
import scala.util.Try

case class Attachment(name: String, hashes: Seq[Hash], size: Long, contentType: String, id: String)
trait Conversion {

  def truncateString(s: String): String = if (s.length < 8191) s else s.take(8191)

  private val attachmentWrites: OWrites[Attachment] = OWrites[Attachment] { attachment =>
    Json.obj(
      "name"        -> attachment.name,
      "hashes"      -> attachment.hashes,
      "size"        -> attachment.size,
      "contentType" -> attachment.contentType,
      "id"          -> attachment.id
    )
  }

  private val attachmentReads: Reads[Attachment] = Reads { json =>
    for {
      name        <- (json \ "name").validate[String].map(truncateString)
      hashes      <- (json \ "hashes").validate[Seq[Hash]]
      size        <- (json \ "size").validate[Long]
      contentType <- (json \ "contentType").validate[String].map(truncateString)
      id          <- (json \ "id").validate[String].map(truncateString)
    } yield Attachment(name, hashes, size, contentType, id)
  }
  implicit val attachmentFormat: OFormat[Attachment] = OFormat(attachmentReads, attachmentWrites)

  def readAttachment(id: String): Source[ByteString, NotUsed]
  val mainOrganisation: String

  implicit val metaDataReads: Reads[MetaData] =
    ((JsPath \ "_id").read[String] and
      (JsPath \ "createdBy").readWithDefault[String]("system@thehive.local").map(normaliseLogin) and
      (JsPath \ "createdAt").readWithDefault[Date](new Date) and
      (JsPath \ "updatedBy").readNullable[String].map(_.map(normaliseLogin)) and
      (JsPath \ "updatedAt").readNullable[Date])(MetaData.apply _)

  implicit val caseReads: Reads[InputCase] = Reads[InputCase] { json =>
    for {
      metaData    <- json.validate[MetaData]
      number      <- (json \ "caseId").validate[Int]
      title       <- (json \ "title").validate[String].map(truncateString)
      description <- (json \ "description").validate[String]
      severity    <- (json \ "severity").validate[Int]
      startDate   <- (json \ "startDate").validate[Date]
      endDate     <- (json \ "endDate").validateOpt[Date]
      flag        <- (json \ "flag").validate[Boolean]
      tlp         <- (json \ "tlp").validate[Int]
      pap         <- (json \ "pap").validateOpt[Int]
      status      <- (json \ "status").validate[CaseStatus.Value]
      summary     <- (json \ "summary").validateOpt[String].map(_.map(truncateString))
      user        <- (json \ "owner").validateOpt[String].map(_.map(truncateString))
      tags             = (json \ "tags").asOpt[Set[String]].getOrElse(Set.empty).filterNot(_.isEmpty)
      metrics          = (json \ "metrics").asOpt[JsObject].getOrElse(JsObject.empty)
      resolutionStatus = (json \ "resolutionStatus").asOpt[String]
      impactStatus     = (json \ "impactStatus").asOpt[String]
      metricsValue = metrics.value.map {
        case (name, value) => name -> Some(value)
      }
      customFields = (json \ "customFields").asOpt[JsObject].getOrElse(JsObject.empty)
      customFieldsValue = customFields.value.map {
        case (name, value) =>
          name -> Some((value \ "string") orElse (value \ "boolean") orElse (value \ "number") orElse (value \ "date") getOrElse JsNull)
      }
    } yield InputCase(
      Case(
        title = title,
        description = description,
        severity = severity,
        startDate = startDate,
        endDate = endDate,
        flag = flag,
        tlp = tlp,
        pap = pap.getOrElse(2),
        status = status,
        summary = summary,
        tags = tags.toSeq,
        number = number,
        organisationIds = Set.empty,
        assignee = user.map(normaliseLogin),
        impactStatus = impactStatus,
        resolutionStatus = resolutionStatus,
        caseTemplate = None
      ), // organisation Ids are filled by output
      Map(mainOrganisation -> Profile.orgAdmin.name),
      (metricsValue ++ customFieldsValue).toMap,
      metaData
    )
  }

  implicit val taxonomiesReads: Reads[Seq[ReportTag]] = Reads.JsObjectReads.map { input =>
    input.fields.flatMap {
      case (origin, value) =>
        (value \ "taxonomies")
          .asOpt[Seq[JsValue]]
          .getOrElse(Nil)
          .flatMap { taxonomy =>
            for {
              namespace <- (taxonomy \ "namespace").asOpt[String]
              predicate <- (taxonomy \ "predicate").asOpt[String]
              value = (taxonomy \ "value").getOrElse(JsNull)
              levelName <- (taxonomy \ "level").asOpt[String]
              level     <- Try(ReportTagLevel.withName(levelName)).toOption
            } yield ReportTag(origin, level, namespace, predicate, value)
          }
    }
  }

  implicit val observableReads: Reads[InputObservable] = Reads[InputObservable] { json =>
    for {
      metaData <- json.validate[MetaData]
      message  <- (json \ "message").validateOpt[String]
      tlp      <- (json \ "tlp").validate[Int]
      ioc      <- (json \ "ioc").validate[Boolean]
      sighted  <- (json \ "sighted").validateOpt[Boolean]
      dataType <- (json \ "dataType").validate[String].map(truncateString)
      tags = (json \ "tags").asOpt[Set[String]].getOrElse(Set.empty)
      taxonomiesList <- Json.parse((json \ "reports").asOpt[String].getOrElse("{}")).validate[Seq[ReportTag]]
      dataOrAttachment <-
        (json \ "data")
          .validate[String]
          .map(Left.apply)
          .orElse(
            (json \ "attachment")
              .validate[Attachment]
              .map(a => Right(InputAttachment(a.name, a.size, a.contentType, a.hashes.map(_.toString), readAttachment(a.id))))
          )
    } yield InputObservable(
      metaData,
      Observable(
        message = message,
        tlp = tlp,
        ioc = ioc,
        sighted = sighted.getOrElse(false),
        ignoreSimilarity = None,
        dataType = dataType,
        tags = tags.toSeq
      ),
      Set(mainOrganisation),
      dataOrAttachment,
      taxonomiesList
    )
  }

  implicit val taskReads: Reads[InputTask] = Reads[InputTask] { json =>
    for {
      metaData    <- json.validate[MetaData]
      title       <- (json \ "title").validate[String].map(truncateString)
      group       <- (json \ "group").validateOpt[String].map(_.map(truncateString))
      description <- (json \ "description").validateOpt[String]
      status      <- (json \ "status").validate[TaskStatus.Value]
      flag        <- (json \ "flag").validate[Boolean]
      startDate   <- (json \ "startDate").validateOpt[Date]
      endDate     <- (json \ "endDate").validateOpt[Date]
      order       <- (json \ "order").validate[Int]
      dueDate     <- (json \ "dueDate").validateOpt[Date]
      owner       <- (json \ "owner").validateOpt[String].map(_.map(truncateString))
    } yield InputTask(
      metaData,
      Task(
        title = title,
        group = group.getOrElse("default"),
        description = description,
        status = status,
        flag = flag,
        startDate = startDate,
        endDate = endDate,
        order = order,
        dueDate = dueDate,
        assignee = owner.map(normaliseLogin)
      ),
      owner.map(normaliseLogin),
      Set(mainOrganisation)
    )
  }

  implicit val logReads: Reads[InputLog] = Reads[InputLog] { json =>
    for {
      metaData <- json.validate[MetaData]
      message  <- (json \ "message").validate[String]
      date     <- (json \ "startDate").validate[Date]
      attachment =
        (json \ "attachment")
          .asOpt[Attachment]
          .map(a => InputAttachment(a.name, a.size, a.contentType, a.hashes.map(_.toString), readAttachment(a.id)))
    } yield InputLog(metaData, Log(message, date), attachment.toSeq)
  }

  implicit val alertReads: Reads[InputAlert] = Reads[InputAlert] { json =>
    for {
      metaData     <- json.validate[MetaData]
      tpe          <- (json \ "type").validate[String].map(truncateString)
      source       <- (json \ "source").validate[String].map(truncateString)
      sourceRef    <- (json \ "sourceRef").validate[String].map(truncateString)
      externalLink <- (json \ "externalLink").validateOpt[String].map(_.map(truncateString))
      title        <- (json \ "title").validate[String].map(truncateString)
      description  <- (json \ "description").validate[String]
      severity     <- (json \ "severity").validate[Int]
      date         <- (json \ "date").validate[Date]
      lastSyncDate <- (json \ "lastSyncDate").validate[Date]
      tlp          <- (json \ "tlp").validate[Int]
      pap          <- (json \ "pap").validateOpt[Int] // not in TH3
      status       <- (json \ "status").validate[String].map(truncateString)
      read = status == "Ignored" || status == "Imported"
      follow <- (json \ "follow").validate[Boolean]
      caseId <- (json \ "case").validateOpt[String]
      tags    = (json \ "tags").asOpt[Set[String]].getOrElse(Set.empty).filterNot(_.isEmpty)
      metrics = (json \ "metrics").asOpt[JsObject].getOrElse(JsObject.empty)
      metricsValue = metrics.value.map {
        case (name, value) => name -> Some(value)
      }
      customFields = (json \ "customFields").asOpt[JsObject].getOrElse(JsObject.empty)
      customFieldsValue = customFields.value.map {
        case (name, value) =>
          name -> Some((value \ "string") orElse (value \ "boolean") orElse (value \ "number") orElse (value \ "date") getOrElse JsNull)
      }
      caseTemplate <- (json \ "caseTemplate").validateOpt[String]
    } yield InputAlert(
      metaData: MetaData,
      Alert(
        `type` = tpe,
        source = source,
        sourceRef = sourceRef,
        externalLink = externalLink,
        title = title,
        description = description,
        severity = severity,
        date = date,
        lastSyncDate = lastSyncDate,
        tlp = tlp,
        pap = pap.getOrElse(2),
        read = read,
        follow = follow,
        tags = tags.toSeq
      ),
      caseId,
      mainOrganisation,
      (metricsValue ++ customFieldsValue).toMap,
      caseTemplate: Option[String]
    )
  }

  def alertObservableReads(metaData: MetaData): Reads[InputObservable] =
    Reads[InputObservable] { json =>
      for {
        dataType <- (json \ "dataType").validate[String].map(truncateString)
        message  <- (json \ "message").validateOpt[String]
        tlp      <- (json \ "tlp").validateOpt[Int]
        tags = (json \ "tags").asOpt[Set[String]].getOrElse(Set.empty)
        ioc <- (json \ "ioc").validateOpt[Boolean]
        dataOrAttachment <-
          (json \ "data")
            .validate[String]
            .map(Left.apply)
            .orElse(
              (json \ "attachment")
                .validate[Attachment]
                .map(a => Right(InputAttachment(a.name, a.size, a.contentType, a.hashes.map(_.toString), readAttachment(a.id))))
            )
      } yield InputObservable(
        metaData,
        Observable(
          message = message,
          tlp = tlp.getOrElse(2),
          ioc = ioc.getOrElse(false),
          sighted = false,
          ignoreSimilarity = None,
          dataType = dataType,
          tags = tags.toSeq
        ),
        Set(mainOrganisation),
        dataOrAttachment,
        Nil
      )

    }

  def normaliseLogin(login: String): String = {
    def validSegment(value: String) = {
      var len   = value.length
      var start = 0
      while (start < len && (value(start) == '.' || value(start) == '-')) start += 1
      while (start < len && (value(len - 1) == '.' || value(len - 1) == '-')) len -= 1
      if (start == len) "empty.name" else value.substring(start, len)
    }
    (login.replaceAll("[^\\w@-]+", ".").replaceFirst("\\W*$", "").split('@') match {
      case Array(l)         => validSegment(l)
      case Array(l, d @ _*) => validSegment(l) + '@' + validSegment(d.mkString("."))
    }).toLowerCase
  }

  implicit val userReads: Reads[InputUser] = Reads[InputUser] { json =>
    for {
      metaData <- json.validate[MetaData]
      login    <- (json \ "_id").validate[String].map(truncateString)
      name     <- (json \ "name").validate[String].map(truncateString)
      apikey   <- (json \ "key").validateOpt[String].map(_.map(truncateString))
      status   <- (json \ "status").validate[String].map(truncateString)
      locked = status == "Locked"
      password <- (json \ "password").validateOpt[String].map(_.map(truncateString))
      role     <- (json \ "roles").validateOpt[Seq[String]].map(_.getOrElse(Nil))
      organisationProfiles =
        if (role.contains("admin")) Map(mainOrganisation -> Profile.orgAdmin.name)
        else if (role.contains("write")) Map(mainOrganisation -> Profile.analyst.name)
        else if (role.contains("read")) Map(mainOrganisation -> Profile.readonly.name)
        else Map(mainOrganisation                            -> Profile.readonly.name)
      avatar =
        (json \ "avatar")
          .asOpt[String]
          .map { base64 =>
            val data = Base64.getDecoder.decode(base64)
            InputAttachment(s"$login.avatar", data.size.toLong, "image/png", Nil, Source.single(ByteString(data)))
          }
    } yield InputUser(metaData, User(normaliseLogin(login), name, apikey, locked, password, None, None, None), organisationProfiles, avatar)
  }

  val metricsReads: Reads[InputCustomField] = Reads[InputCustomField] { json =>
    for {
      valueJson <- (json \ "value").validate[String].map(truncateString)
      value = Json.parse(valueJson)
      name <- (value \ "name").validate[String].map(truncateString)
//      title       <- (value \ "title").validate[String].map(truncateString
      description <- (value \ "description").validate[String]
    } yield InputCustomField(
      MetaData(name, User.init.login, new Date, None, None),
      CustomField(name, name, description, CustomFieldType.integer, mandatory = true, Nil)
    )
  }

  implicit val customFieldReads: Reads[InputCustomField] = Reads[InputCustomField] { json =>
    for {
      //      metaData    <- json.validate[MetaData]
      valueJson <- (json \ "value").validate[String]
      value = Json.parse(valueJson)
      displayName <- (value \ "name").validate[String].map(truncateString)
      name        <- (value \ "reference").validate[String].map(truncateString)
      description <- (value \ "description").validate[String]
      tpe         <- (value \ "type").validate[String].map(truncateString)
      customFieldType = tpe match {
        case "string"  => CustomFieldType.string
        case "number"  => CustomFieldType.integer
        case "integer" => CustomFieldType.integer
        case "float"   => CustomFieldType.float
        case "boolean" => CustomFieldType.boolean
        case "date"    => CustomFieldType.date
      }
      options = (value \ "options").asOpt[Seq[JsValue]].getOrElse(Nil)
    } yield InputCustomField(
      MetaData(name, User.init.login, new Date, None, None),
      CustomField(name, displayName, description, customFieldType, mandatory = false, options)
    )
  } orElse metricsReads

  implicit val observableTypeReads: Reads[InputObservableType] = Reads[InputObservableType] { json =>
    for {
      //      metaData    <- json.validate[MetaData]
      valueJson <- (json \ "value").validate[String].map(truncateString)
      value = Json.parse(valueJson)
      name <- value.validate[String].map(truncateString)
    } yield InputObservableType(MetaData(name, User.init.login, new Date, None, None), ObservableType(name, name == "file"))
  }

  implicit val caseTemplateReads: Reads[InputCaseTemplate] = Reads[InputCaseTemplate] { json =>
    for {
      metaData    <- json.validate[MetaData]
      name        <- (json \ "name").validate[String].map(truncateString)
      description <- (json \ "description").validateOpt[String]
      titlePrefix <- (json \ "titlePrefix").validateOpt[String].map(_.map(truncateString))
      severity    <- (json \ "severity").validateOpt[Int]
      flag = (json \ "flag").asOpt[Boolean].getOrElse(false)
      tlp     <- (json \ "tlp").validateOpt[Int]
      pap     <- (json \ "pap").validateOpt[Int]
      summary <- (json \ "summary").validateOpt[String]
      tags    = (json \ "tags").asOpt[Set[String]].getOrElse(Set.empty)
      metrics = (json \ "metrics").asOpt[JsObject].getOrElse(JsObject.empty)
      metricsValue = metrics.value.map {
        case (name, value) => InputCustomFieldValue(name, Some(value), None)
      }
      customFields <- (json \ "customFields").validateOpt[JsObject]
      customFieldsValue = customFields.getOrElse(JsObject.empty).value.map {
        case (name, value) =>
          InputCustomFieldValue(
            name,
            Some((value \ "string") orElse (value \ "boolean") orElse (value \ "number") orElse (value \ "date") getOrElse JsNull),
            (value \ "order").asOpt[Int]
          )
      }
    } yield InputCaseTemplate(
      metaData,
      CaseTemplate(
        name = name,
        displayName = name,
        titlePrefix = titlePrefix,
        description = description,
        tags = tags.toSeq,
        severity = severity,
        flag = flag,
        tlp = tlp,
        pap = pap,
        summary = summary
      ),
      mainOrganisation,
      (metricsValue ++ customFieldsValue).toSeq
    )
  }

  def caseTemplateTaskReads(metaData: MetaData): Reads[InputTask] =
    Reads[InputTask] { json =>
      for {
        title       <- (json \ "title").validate[String].map(truncateString)
        group       <- (json \ "group").validateOpt[String].map(_.map(truncateString))
        description <- (json \ "description").validateOpt[String]
        status      <- (json \ "status").validateOpt[TaskStatus.Value]
        flag        <- (json \ "flag").validateOpt[Boolean]
        startDate   <- (json \ "startDate").validateOpt[Date]
        endDate     <- (json \ "endDate").validateOpt[Date]
        order       <- (json \ "order").validateOpt[Int]
        dueDate     <- (json \ "dueDate").validateOpt[Date]
        owner       <- (json \ "owner").validateOpt[String]
      } yield InputTask(
        metaData,
        Task(
          title = title,
          group = group.getOrElse("default"),
          description = description,
          status = status.getOrElse(TaskStatus.Waiting),
          flag = flag.getOrElse(false),
          startDate = startDate,
          endDate = endDate,
          order = order.getOrElse(1),
          dueDate = dueDate,
          assignee = owner.map(normaliseLogin)
        ),
        owner.map(normaliseLogin),
        Set(mainOrganisation)
      )
    }

  lazy val jobReads: Reads[InputJob] = Reads[InputJob] { json =>
    for {
      metaData         <- json.validate[MetaData]
      workerId         <- (json \ "analyzerId").validate[String].map(truncateString)
      workerName       <- (json \ "analyzerName").validate[String].map(truncateString)
      workerDefinition <- (json \ "analyzerDefinition").validate[String].map(truncateString)
      status           <- (json \ "status").validate[JobStatus.Value]
      startDate        <- (json \ "createdAt").validate[Date]
      endDate          <- (json \ "endDate").validate[Date]
      reportJson       <- (json \ "report").validateOpt[String]
      report = reportJson.flatMap { j =>
        (Json.parse(j) \ "full").asOpt[JsObject]
      }
      cortexId    <- (json \ "cortexId").validate[String].map(truncateString)
      cortexJobId <- (json \ "cortexJobId").validate[String].map(truncateString)
    } yield InputJob(
      metaData,
      Job(
        workerId,
        workerName,
        workerDefinition,
        status,
        startDate,
        endDate,
        report,
        cortexId,
        cortexJobId,
        Nil
      )
    )
  }

  def jobObservableReads(metaData: MetaData): Reads[InputObservable] =
    Reads[InputObservable] { json =>
      for {
        message <- (json \ "message").validateOpt[String].map(_.map(truncateString)) orElse (json \ "attributes" \ "message").validateOpt[String]
        tlp     <- (json \ "tlp").validate[Int] orElse (json \ "attributes" \ "tlp").validate[Int] orElse JsSuccess(2)
        ioc     <- (json \ "ioc").validate[Boolean] orElse (json \ "attributes" \ "ioc").validate[Boolean] orElse JsSuccess(false)
        sighted <- (json \ "sighted").validate[Boolean] orElse (json \ "attributes" \ "sighted").validate[Boolean] orElse JsSuccess(false)
        dataType <-
          (json \ "dataType").validate[String].map(truncateString) orElse (json \ "type")
            .validate[String]
            .map(truncateString) orElse (json \ "attributes").validate[String].map(truncateString)
        tags <- (json \ "tags").validate[Set[String]] orElse (json \ "attributes" \ "tags").validate[Set[String]] orElse JsSuccess(Set.empty[String])
        dataOrAttachment <- ((json \ "data").validate[String].map(truncateString) orElse (json \ "value").validate[String].map(truncateString))
          .map(Left.apply)
          .orElse(
            (json \ "attachment")
              .validate[Attachment]
              .map(a => Right(InputAttachment(a.name, a.size, a.contentType, a.hashes.map(_.toString), readAttachment(a.id))))
          )
      } yield InputObservable(
        metaData,
        Observable(
          message = message,
          tlp = tlp,
          ioc = ioc,
          sighted = sighted,
          ignoreSimilarity = None,
          dataType = dataType,
          tags = tags.toSeq
        ),
        Set(mainOrganisation),
        dataOrAttachment,
        Nil
      )
    }

  implicit val actionReads: Reads[(String, InputAction)] = Reads[(String, InputAction)] { json =>
    for {
      metaData         <- json.validate[MetaData]
      workerId         <- (json \ "responderId").validate[String].map(truncateString)
      workerName       <- (json \ "responderName").validateOpt[String].map(_.map(truncateString))
      workerDefinition <- (json \ "responderDefinition").validateOpt[String].map(_.map(truncateString))
      status           <- (json \ "status").validate[JobStatus.Value]
      objectType       <- (json \ "objectType").validate[String].map(truncateString)
      objectId         <- (json \ "objectId").validate[String].map(truncateString)
      parameters = JsObject.empty // not in th3
      startDate   <- (json \ "startDate").validate[Date]
      endDate     <- (json \ "endDate").validateOpt[Date]
      report      <- (json \ "report").validateOpt[String]
      cortexId    <- (json \ "cortexId").validateOpt[String].map(_.map(truncateString))
      cortexJobId <- (json \ "cortexJobId").validateOpt[String].map(_.map(truncateString))
      operations  <- (json \ "operations").validateOpt[String]
    } yield objectId -> InputAction(
      metaData,
      v0.Conversion.toObjectType(objectType),
      Action(
        workerId,
        workerName.getOrElse(workerId),
        workerDefinition.getOrElse(workerId),
        status,
        parameters,
        startDate,
        endDate,
        report.flatMap(Json.parse(_).asOpt[JsObject]),
        cortexId.getOrElse("unknown"),
        cortexJobId.getOrElse("unknown"),
        operations.flatMap(Json.parse(_).asOpt[Seq[JsObject]]).getOrElse(Nil)
      )
    )
  }

  implicit val auditReads: Reads[(String, InputAudit)] = Reads[(String, InputAudit)] { json =>
    for {
      metaData   <- json.validate[MetaData]
      requestId  <- (json \ "requestId").validate[String].map(truncateString)
      operation  <- (json \ "operation").validate[String].map(truncateString)
      mainAction <- (json \ "base").validate[Boolean]
      objectId   <- (json \ "objectId").validateOpt[String].map(_.map(truncateString))
      objectType <- (json \ "objectType").validateOpt[String].map(_.map(truncateString))
      details    <- (json \ "details").validateOpt[JsObject]
      rootId     <- (json \ "rootId").validate[String].map(truncateString)
    } yield (
      rootId,
      InputAudit(
        metaData,
        Audit(
          requestId,
          operation match {
            case "Update"   => "update"
            case "Creation" => "create"
            case "Delete"   => "delete"
          },
          mainAction,
          objectId,
          objectType.map(v0.Conversion.toObjectType),
          details.map(_.toString)
        )
      )
    )
  }
  implicit val dashboardReads: Reads[InputDashboard] = Reads[InputDashboard] { json =>
    for {
      metaData         <- json.validate[MetaData]
      title            <- (json \ "title").validate[String]
      description      <- (json \ "description").validate[String]
      definitionString <- (json \ "definition").validate[String]
      definition       <- Json.parse(definitionString).validate[JsObject]
      status           <- (json \ "status").validate[String]
    } yield InputDashboard(metaData, if (status == "Shared") Some(mainOrganisation -> true) else None, Dashboard(title, description, definition))
  }
}

```

`migration/src/main/scala/org/thp/thehive/migration/th3/ElasticClient.scala`:

```scala
package org.thp.thehive.migration.th3

import akka.NotUsed
import akka.actor.{ActorSystem, Scheduler}
import akka.stream.Materializer
import akka.stream.scaladsl.{Sink, Source}
import akka.util.ByteString
import com.typesafe.config.ConfigRenderOptions
import com.typesafe.sslconfig.ssl.{KeyManagerConfig, KeyStoreConfig, TrustManagerConfig, TrustStoreConfig}
import org.thp.client._
import org.thp.scalligraph.utils.FunctionalCondition.When
import org.thp.scalligraph.utils.Retry
import org.thp.scalligraph.{InternalError, NotFoundError}
import play.api.http.HeaderNames
import play.api.libs.json.{JsNumber, JsObject, JsValue, Json}
import play.api.libs.ws.ahc.AhcWSClientConfig
import play.api.libs.ws.{WSClient, WSResponse}
import play.api.{Configuration, Logger}

import java.net.{URI, URLEncoder}
import javax.inject.{Inject, Provider, Singleton}
import scala.concurrent.duration.{DurationInt, DurationLong, FiniteDuration}
import scala.concurrent.{Await, ExecutionContext, Future}
import scala.util.Try

@Singleton
class ElasticClientProvider @Inject() (
    config: Configuration,
    mat: Materializer,
    implicit val actorSystem: ActorSystem
) extends Provider[ElasticClient] {

  override def get(): ElasticClient = {
    lazy val logger = Logger(getClass)
    val ws: WSClient = {

      val trustManager = config.getOptional[String]("search.trustStore.path").map { trustStore =>
        val trustStoreConfig = TrustStoreConfig(None, Some(trustStore))
        config.getOptional[String]("search.trustStore.type").foreach(trustStoreConfig.withStoreType)
        trustStoreConfig.withPassword(config.getOptional[String]("search.trustStore.password"))
        val trustManager = TrustManagerConfig()
        trustManager.withTrustStoreConfigs(List(trustStoreConfig))
        trustManager
      }
      val keyManager = config.getOptional[String]("search.keyStore.path").map { keyStore =>
        val keyStoreConfig = KeyStoreConfig(None, Some(keyStore))
        config.getOptional[String]("search.keyStore.type").foreach(keyStoreConfig.withStoreType)
        keyStoreConfig.withPassword(config.getOptional[String]("search.keyStore.password"))
        val keyManager = KeyManagerConfig()
        keyManager.withKeyStoreConfigs(List(keyStoreConfig))
        keyManager
      }
      val connectionTimeout    = config.getOptional[Int]("search.connectTimeout").map(_.millis)
      val idleTimeout          = config.getOptional[Int]("search.socketTimeout").map(_.millis)
      val requestTimeout       = config.getOptional[Int]("search.connectionRequestTimeout").map(_.millis)
      val followRedirects      = config.getOptional[Boolean]("search.redirectsEnabled")
      val maxNumberOfRedirects = config.getOptional[Int]("search.maxRedirects")

      val wsConfig = Try(Json.parse(config.underlying.getValue("search.wsConfig").render(ConfigRenderOptions.concise())).as[ProxyWSConfig])
        .getOrElse(ProxyWSConfig(AhcWSClientConfig(), None))
        .merge(trustManager) { (cfg, tm) =>
          cfg.copy(wsConfig =
            cfg.wsConfig.copy(wsClientConfig = cfg.wsConfig.wsClientConfig.copy(ssl = cfg.wsConfig.wsClientConfig.ssl.withTrustManagerConfig(tm)))
          )
        }
        .merge(keyManager) { (cfg, km) =>
          cfg.copy(wsConfig =
            cfg.wsConfig.copy(wsClientConfig = cfg.wsConfig.wsClientConfig.copy(ssl = cfg.wsConfig.wsClientConfig.ssl.withKeyManagerConfig(km)))
          )
        }
        .merge(connectionTimeout) { (cfg, ct) =>
          cfg.copy(wsConfig = cfg.wsConfig.copy(wsClientConfig = cfg.wsConfig.wsClientConfig.copy(connectionTimeout = ct)))
        }
        .merge(idleTimeout) { (cfg, it) =>
          cfg.copy(wsConfig = cfg.wsConfig.copy(wsClientConfig = cfg.wsConfig.wsClientConfig.copy(idleTimeout = it)))
        }
        .merge(requestTimeout) { (cfg, rt) =>
          cfg.copy(wsConfig = cfg.wsConfig.copy(wsClientConfig = cfg.wsConfig.wsClientConfig.copy(requestTimeout = rt)))
        }
        .merge(followRedirects) { (cfg, fr) =>
          cfg.copy(wsConfig = cfg.wsConfig.copy(wsClientConfig = cfg.wsConfig.wsClientConfig.copy(followRedirects = fr)))
        }
        .merge(maxNumberOfRedirects) { (cfg, mr) =>
          cfg.copy(wsConfig = cfg.wsConfig.copy(maxNumberOfRedirects = mr))
        }
      new ProxyWS(wsConfig, mat)
    }

    val authentication: Authentication =
      (for {
        user     <- config.getOptional[String]("search.user")
        password <- config.getOptional[String]("search.password")
      } yield PasswordAuthentication(user, password))
        .getOrElse(NoAuthentication)

    val esUri        = config.get[String]("search.uri")
    val pageSize     = config.get[Int]("search.pagesize")
    val keepAlive    = config.getMillis("search.keepalive").millis
    val maxAttempts  = config.get[Int]("search.maxAttempts")
    val minBackoff   = config.get[FiniteDuration]("search.minBackoff")
    val maxBackoff   = config.get[FiniteDuration]("search.maxBackoff")
    val randomFactor = config.get[Double]("search.randomFactor")

    val elasticConfig = new ElasticConfig(
      ws,
      authentication,
      esUri,
      pageSize,
      keepAlive.toMillis + "ms",
      maxAttempts,
      minBackoff,
      maxBackoff,
      randomFactor,
      actorSystem.scheduler
    )
    val elasticVersion = elasticConfig.version
    logger.info(s"Found ElasticSearch $elasticVersion")
    lazy val indexName: String = {
      val indexVersion  = config.getOptional[Int]("search.indexVersion")
      val indexBaseName = config.get[String]("search.index")
      indexVersion.fold {
        (17 to 10 by -1)
          .view
          .map(v => s"${indexBaseName}_$v")
          .find(elasticConfig.exists)
          .getOrElse(sys.error(s"TheHive 3.x index $indexBaseName not found"))
      } { v =>
        val indexName = s"${indexBaseName}_$v"
        if (elasticConfig.exists(indexName)) indexName
        else sys.error(s"TheHive 3.x index $indexName not found")
      }
    }
    logger.info(s"Found Index $indexName")

    val isSingleType = config.getOptional[Boolean]("search.singleType").getOrElse(elasticConfig.isSingleType(indexName))
    logger.info(s"Found index with ${if (isSingleType) "single type" else "multiple types"}")
    if (isSingleType) new ElasticSingleTypeClient(elasticConfig, indexName)
    else new ElasticMultiTypeClient(elasticConfig, indexName)
  }
}

class ElasticConfig(
    ws: WSClient,
    authentication: Authentication,
    esUri: String,
    val pageSize: Int,
    val keepAlive: String,
    maxAttempts: Int,
    minBackoff: FiniteDuration,
    maxBackoff: FiniteDuration,
    randomFactor: Double,
    scheduler: Scheduler
) {
  lazy val logger: Logger           = Logger(getClass)
  def stripUrl(url: String): String = new URI(url).normalize().toASCIIString.replaceAll("/+$", "")

  def post(url: String, body: JsValue, params: (String, String)*)(implicit ec: ExecutionContext): Future[WSResponse] = {
    val encodedParams = params
      .map(p => s"${URLEncoder.encode(p._1, "UTF-8")}=${URLEncoder.encode(p._2, "UTF-8")}")
      .mkString("&")
    logger.debug(s"POST ${stripUrl(s"$esUri/$url?$encodedParams")}\n$body")
    Retry(maxAttempts).withBackoff(minBackoff, maxBackoff, randomFactor)(scheduler, ec) {
      authentication(
        ws.url(stripUrl(s"$esUri/$url?$encodedParams"))
          .withHttpHeaders(HeaderNames.CONTENT_TYPE -> "application/json")
      )
        .post(body)
    }
  }

  def postJson(url: String, body: JsValue, params: (String, String)*)(implicit ec: ExecutionContext): Future[JsValue] =
    post(url, body, params: _*)
      .map {
        case response if response.status == 200 => response.json
        case response                           => throw InternalError(s"Unexpected response from Elasticsearch: ${response.status} ${response.statusText}\n${response.body}")
      }

  def postRaw(url: String, body: JsValue, params: (String, String)*)(implicit ec: ExecutionContext): Future[ByteString] =
    post(url, body, params: _*)
      .map {
        case response if response.status == 200 => response.bodyAsBytes
        case response                           => throw InternalError(s"Unexpected response from Elasticsearch: ${response.status} ${response.statusText}\n${response.body}")
      }

  def delete(url: String, body: JsValue, params: (String, String)*)(implicit ec: ExecutionContext): Future[JsValue] = {
    val encodedParams = params
      .map(p => s"${URLEncoder.encode(p._1, "UTF-8")}=${URLEncoder.encode(p._2, "UTF-8")}")
      .mkString("&")
    authentication(
      ws
        .url(stripUrl(s"$esUri/$url?$encodedParams"))
        .withHttpHeaders(HeaderNames.CONTENT_TYPE -> "application/json")
    )
      .withBody(body)
      .execute("DELETE")
      .map {
        case response if response.status == 200 => response.body[JsValue]
        case response                           => throw InternalError(s"Unexpected response from Elasticsearch: ${response.status} ${response.statusText}\n${response.body}")
      }
  }

  def exists(indexName: String): Boolean =
    Await
      .result(
        authentication(ws.url(stripUrl(s"$esUri/$indexName")))
          .head(),
        10.seconds
      )
      .status == 200

  def isSingleType(indexName: String): Boolean =
    indexName
      .split('_')
      .lastOption
      .flatMap(version => Try(version.toInt).toOption)
      .fold {
        val response = Await
          .result(
            authentication(ws.url(stripUrl(s"$esUri/$indexName")))
              .get(),
            10.seconds
          )
        if (response.status != 200)
          throw InternalError(s"Unexpected response from Elasticsearch: ${response.status} ${response.statusText}\n${response.body}")
        (response.json \ indexName \ "settings" \ "index" \ "mapping" \ "single_type").asOpt[String].fold(version.head > '6')(_.toBoolean)
      }(version => version >= 15)

  def version: String = {
    val response = Await.result(authentication(ws.url(stripUrl(esUri))).get(), 10.seconds)
    if (response.status == 200) (response.json \ "version" \ "number").as[String]
    else throw InternalError(s"Unexpected response from Elasticsearch: ${response.status} ${response.statusText}\n${response.body}")
  }
}

trait ElasticClient {
  val pageSize: Int
  val keepAlive: String
  def search(docType: String, request: JsObject, params: (String, String)*)(implicit ec: ExecutionContext): Future[JsValue]
  def searchRaw(docType: String, request: JsObject, params: (String, String)*)(implicit ec: ExecutionContext): Future[ByteString]
  def scroll(scrollId: String, keepAlive: String)(implicit ec: ExecutionContext): Future[JsValue]
  def clearScroll(scrollId: String)(implicit ec: ExecutionContext): Future[JsValue]

  def apply(docType: String, query: JsObject)(implicit ec: ExecutionContext): Source[JsValue, NotUsed] = {
    val searchWithScroll = new SearchWithScroll(this, docType, query + ("size" -> JsNumber(pageSize)), keepAlive)
    Source.fromGraph(searchWithScroll)
  }

  def count(docType: String, query: JsObject)(implicit ec: ExecutionContext): Future[Long] =
    search(docType, query + ("size" -> JsNumber(0)))
      .map { j =>
        (j \ "hits" \ "total")
          .asOpt[Long]
          .orElse((j \ "hits" \ "total" \ "value").asOpt[Long])
          .getOrElse(-1)
      }

  def get(docType: String, id: String)(implicit ec: ExecutionContext, mat: Materializer): Future[JsValue] = {
    import ElasticDsl._
    apply(docType, searchQuery(idsQuery(id))).runWith(Sink.headOption).map(_.getOrElse(throw NotFoundError(s"Document $id not found")))
  }
}

class ElasticMultiTypeClient(elasticConfig: ElasticConfig, indexName: String) extends ElasticClient {
  override val pageSize: Int     = elasticConfig.pageSize
  override val keepAlive: String = elasticConfig.keepAlive
  override def search(docType: String, request: JsObject, params: (String, String)*)(implicit ec: ExecutionContext): Future[JsValue] =
    elasticConfig.postJson(s"/$indexName/$docType/_search", request, params: _*)
  override def searchRaw(docType: String, request: JsObject, params: (String, String)*)(implicit ec: ExecutionContext): Future[ByteString] =
    elasticConfig.postRaw(s"/$indexName/$docType/_search", request, params: _*)
  override def scroll(scrollId: String, keepAlive: String)(implicit ec: ExecutionContext): Future[JsValue] =
    elasticConfig.postJson("/_search/scroll", Json.obj("scroll_id" -> scrollId, "scroll" -> keepAlive))
  override def clearScroll(scrollId: String)(implicit ec: ExecutionContext): Future[JsValue] =
    elasticConfig.delete("/_search/scroll", Json.obj("scroll_id" -> scrollId))
}

class ElasticSingleTypeClient(elasticConfig: ElasticConfig, indexName: String) extends ElasticClient {
  override val pageSize: Int     = elasticConfig.pageSize
  override val keepAlive: String = elasticConfig.keepAlive
  override def search(docType: String, request: JsObject, params: (String, String)*)(implicit ec: ExecutionContext): Future[JsValue] = {
    import ElasticDsl._
    val query         = (request \ "query").as[JsObject]
    val queryWithType = request + ("query" -> and(termQuery("relations", docType), query))
    elasticConfig.postJson(s"/$indexName/_search", queryWithType, params: _*)
  }
  override def searchRaw(docType: String, request: JsObject, params: (String, String)*)(implicit ec: ExecutionContext): Future[ByteString] = {
    import ElasticDsl._
    val query         = (request \ "query").as[JsObject]
    val queryWithType = request + ("query" -> and(termQuery("relations", docType), query))
    elasticConfig.postRaw(s"/$indexName/_search", queryWithType, params: _*)
  }
  override def scroll(scrollId: String, keepAlive: String)(implicit ec: ExecutionContext): Future[JsValue] =
    elasticConfig.postJson("/_search/scroll", Json.obj("scroll_id" -> scrollId, "scroll" -> keepAlive))
  override def clearScroll(scrollId: String)(implicit ec: ExecutionContext): Future[JsValue] =
    elasticConfig.delete("/_search/scroll", Json.obj("scroll_id" -> scrollId))
}

```

`migration/src/main/scala/org/thp/thehive/migration/th3/ElasticDsl.scala`:

```scala
package org.thp.thehive.migration.th3

import play.api.libs.json.{JsNumber, JsObject, JsString, JsValue, Json}

object ElasticDsl {
  def searchQuery(query: JsObject, sort: String*): JsObject = {
    val order = JsObject(sort.collect {
      case f if f.startsWith("+") => f.drop(1) -> JsString("asc")
      case f if f.startsWith("-") => f.drop(1) -> JsString("desc")
      case f if f.nonEmpty        => f         -> JsString("asc")
    })
    Json.obj("query" -> query, "sort" -> order)
  }
  val matchAll: JsObject                                            = Json.obj("match_all" -> JsObject.empty)
  def termQuery(field: String, value: String): JsObject             = Json.obj("term" -> Json.obj(field -> value))
  def termsQuery(field: String, values: Iterable[String]): JsObject = Json.obj("terms" -> Json.obj(field -> values))
  def idsQuery(ids: String*): JsObject                              = Json.obj("ids" -> Json.obj("values" -> ids))
  def range[N](field: String, from: Option[N], to: Option[N])(implicit ev: N => BigDecimal) =
    Json.obj(
      "range" -> Json.obj(
        field -> JsObject(
          from.map(f => "gte" -> JsNumber(f)).toSeq ++
            to.map(t => "lt" -> JsNumber(t)).toSeq
        )
      )
    )
  def and(queries: JsValue*): JsObject = bool(queries)
  def or(queries: JsValue*): JsObject  = bool(Nil, queries)
  def bool(mustQueries: Seq[JsValue], shouldQueries: Seq[JsValue] = Nil, notQueries: Seq[JsValue] = Nil): JsObject =
    Json.obj(
      "bool" -> Json.obj(
        "must"     -> mustQueries,
        "should"   -> shouldQueries,
        "must_not" -> notQueries
      )
    )
  def hasParentQuery(parentType: String, query: JsObject): JsObject =
    Json.obj(
      "has_parent" -> Json.obj(
        "parent_type" -> parentType,
        "query"       -> query
      )
    )
}

```

`migration/src/main/scala/org/thp/thehive/migration/th3/Input.scala`:

```scala
package org.thp.thehive.migration.th3

import akka.NotUsed
import akka.actor.ActorSystem
import akka.stream.Materializer
import akka.stream.alpakka.json.scaladsl.JsonReader
import akka.stream.scaladsl.Source
import akka.util.ByteString
import com.google.inject.Guice
import net.codingwell.scalaguice.ScalaModule
import org.thp.thehive.migration
import org.thp.thehive.migration.Filter
import org.thp.thehive.migration.dto._
import org.thp.thehive.migration.th3.ElasticDsl._
import org.thp.thehive.models._
import play.api.libs.json._
import play.api.{Configuration, Logger}

import java.util.{Base64, Date}
import javax.inject.{Inject, Singleton}
import scala.collection.immutable
import scala.concurrent.{ExecutionContext, Future}
import scala.reflect.{classTag, ClassTag}
import scala.util.{Failure, Success, Try}

object Input {

  def apply(configuration: Configuration)(implicit actorSystem: ActorSystem): Input =
    Guice
      .createInjector(new ScalaModule {
        override def configure(): Unit = {
          bind[Configuration].toInstance(configuration)
          bind[ActorSystem].toInstance(actorSystem)
          bind[Materializer].toInstance(Materializer(actorSystem))
          bind[ExecutionContext].toInstance(actorSystem.dispatcher)
          bind[ElasticClient].toProvider[ElasticClientProvider]
          ()
        }
      })
      .getInstance(classOf[Input])
}

@Singleton
class Input @Inject() (configuration: Configuration, elasticClient: ElasticClient, implicit val ec: ExecutionContext, implicit val mat: Materializer)
    extends migration.Input
    with Conversion {
  lazy val logger: Logger               = Logger(getClass)
  override val mainOrganisation: String = configuration.get[String]("mainOrganisation")

  implicit class SourceOfJson(source: Source[JsValue, NotUsed]) {

    def read[A: Reads: ClassTag]: Source[Try[A], NotUsed] =
      source.map(json => Try(json.as[A]))

    def readWithParent[A: Reads: ClassTag](parent: JsValue => Try[String]): Source[Try[(String, A)], NotUsed] =
      source.map(json => parent(json).flatMap(p => Try(p -> json.as[A])))
  }

  override def readAttachment(id: String): Source[ByteString, NotUsed] =
    Source.unfoldAsync(0) { chunkNumber =>
      elasticClient
        .get("data", s"${id}_$chunkNumber")
        .map { json =>
          (json \ "binary").asOpt[String].map(s => chunkNumber + 1 -> ByteString(Base64.getDecoder.decode(s)))
        }
        .recover { case _ => None }
    }

  override def listOrganisations(filter: Filter): Source[Try[InputOrganisation], NotUsed] =
    Source.single(
      Success(InputOrganisation(MetaData(mainOrganisation, "system", new Date, None, None), Organisation(mainOrganisation, mainOrganisation)))
    )

  override def countOrganisations(filter: Filter): Future[Long] = Future.successful(1)

  private def caseFilter(filter: Filter): Seq[JsObject] = {
    val dateFilter =
      if (filter.caseDateRange._1.isDefined || filter.caseDateRange._2.isDefined)
        Seq(range("createdAt", filter.caseDateRange._1, filter.caseDateRange._2))
      else Nil
    val numberFilter =
      if (filter.caseNumberRange._1.isDefined || filter.caseNumberRange._2.isDefined)
        Seq(range("caseId", filter.caseNumberRange._1, filter.caseNumberRange._2))
      else Nil
    dateFilter ++ numberFilter
  }

  override def listCases(filter: Filter): Source[Try[InputCase], NotUsed] =
    elasticClient("case", searchQuery(bool(caseFilter(filter)), "-createdAt"))
      .read[InputCase]

  override def countCases(filter: Filter): Future[Long] =
    elasticClient.count("case", searchQuery(bool(caseFilter(filter))))

  override def countCaseObservables(filter: Filter): Future[Long] =
    elasticClient.count("case_artifact", searchQuery(hasParentQuery("case", bool(caseFilter(filter)))))

  override def listCaseObservables(caseId: String): Source[Try[(String, InputObservable)], NotUsed] =
    elasticClient("case_artifact", searchQuery(hasParentQuery("case", idsQuery(caseId))))
      .readWithParent[InputObservable](json => Try((json \ "_parent").as[String]))

  override def countCaseTasks(filter: Filter): Future[Long] =
    elasticClient.count("case_task", searchQuery(hasParentQuery("case", bool(caseFilter(filter)))))

  override def listCaseTasks(caseId: String): Source[Try[(String, InputTask)], NotUsed] =
    elasticClient("case_task", searchQuery(hasParentQuery("case", idsQuery(caseId))))
      .readWithParent[InputTask](json => Try((json \ "_parent").as[String]))

  override def countCaseTaskLogs(filter: Filter): Future[Long] =
    countCaseTaskLogs(bool(caseFilter(filter)))

  override def listCaseTaskLogs(caseId: String): Source[Try[(String, InputLog)], NotUsed] =
    elasticClient(
      "case_task_log",
      searchQuery(
        bool(
          Seq(hasParentQuery("case_task", hasParentQuery("case", idsQuery(caseId)))),
          Nil,
          Seq(termQuery("status", "deleted"))
        )
      )
    )
      .readWithParent[InputLog](json => Try((json \ "_parent").as[String]))

  private def countCaseTaskLogs(caseQuery: JsObject): Future[Long] =
    elasticClient.count(
      "case_task_log",
      searchQuery(
        bool(
          Seq(hasParentQuery("case_task", hasParentQuery("case", caseQuery))),
          Nil,
          Seq(termQuery("status", "deleted"))
        )
      )
    )

  private def alertFilter(filter: Filter): JsObject = {
    val dateFilter =
      if (filter.alertDateRange._1.isDefined || filter.alertDateRange._2.isDefined)
        Seq(range("createdAt", filter.alertDateRange._1, filter.alertDateRange._2))
      else Nil
    val includeFilter = (if (filter.includeAlertTypes.nonEmpty) Seq(termsQuery("type", filter.includeAlertTypes)) else Nil) ++
      (if (filter.includeAlertSources.nonEmpty) Seq(termsQuery("source", filter.includeAlertSources)) else Nil)

    val excludeFilter = (if (filter.excludeAlertTypes.nonEmpty) Seq(termsQuery("type", filter.excludeAlertTypes)) else Nil) ++
      (if (filter.excludeAlertSources.nonEmpty) Seq(termsQuery("source", filter.excludeAlertSources)) else Nil)

    bool(dateFilter ++ includeFilter, Nil, excludeFilter)
  }

  override def listAlerts(filter: Filter): Source[Try[InputAlert], NotUsed] =
    elasticClient("alert", searchQuery(alertFilter(filter), "-createdAt"))
      .read[InputAlert]

  override def countAlerts(filter: Filter): Future[Long] =
    elasticClient.count("alert", searchQuery(alertFilter(filter)))

  override def countAlertObservables(filter: Filter): Future[Long] = Future.failed(new NotImplementedError)

  override def listAlertObservables(alertId: String): Source[Try[(String, InputObservable)], NotUsed] = {
    val dummyMetaData = MetaData("no-id", "init", new Date, None, None)
    Source
      .future(elasticClient.searchRaw("alert", searchQuery(idsQuery(alertId))))
      .via(JsonReader.select("$.hits.hits[*]._source.artifacts[*]"))
      .mapConcat { data =>
        Try(Json.parse(data.toArray[Byte]))
          .flatMap { j =>
            Try(List(alertId -> j.as(alertObservableReads(dummyMetaData))))
              .recover {
                case _ if (j \ "remoteAttachment").isDefined =>
                  logger.warn(s"Pre 2.13 file observables are ignored in MISP alert $alertId")
                  Nil
              }
          }
          .fold(error => List(Failure(error)), _.map(Success(_)))
      }
  }

  override def listUsers(filter: Filter): Source[Try[InputUser], NotUsed] =
    elasticClient("user", searchQuery(matchAll))
      .read[InputUser]

  override def countUsers(filter: Filter): Future[Long] =
    elasticClient.count("user", searchQuery(matchAll))

  override def listCustomFields(filter: Filter): Source[Try[InputCustomField], NotUsed] =
    elasticClient("dblist", searchQuery(or(termQuery("dblist", "case_metrics"), termQuery("dblist", "custom_fields"))))
      .read[InputCustomField]

  override def countCustomFields(filter: Filter): Future[Long] =
    elasticClient.count("dblist", searchQuery(or(termQuery("dblist", "case_metrics"), termQuery("dblist", "custom_fields"))))

  override def listObservableTypes(filter: Filter): Source[Try[InputObservableType], NotUsed] =
    elasticClient("dblist", searchQuery(termQuery("dblist", "list_artifactDataType")))
      .read[InputObservableType]

  override def countObservableTypes(filter: Filter): Future[Long] =
    elasticClient.count("dblist", searchQuery(termQuery("dblist", "list_artifactDataType")))

  override def listProfiles(filter: Filter): Source[Try[InputProfile], NotUsed] =
    Source.empty[Try[InputProfile]]

  override def countProfiles(filter: Filter): Future[Long] = Future.successful(0)

  override def listImpactStatus(filter: Filter): Source[Try[InputImpactStatus], NotUsed] =
    Source.empty[Try[InputImpactStatus]]

  override def countImpactStatus(filter: Filter): Future[Long] = Future.successful(0)

  override def listResolutionStatus(filter: Filter): Source[Try[InputResolutionStatus], NotUsed] =
    Source.empty[Try[InputResolutionStatus]]

  override def countResolutionStatus(filter: Filter): Future[Long] = Future.successful(0)

  override def listCaseTemplate(filter: Filter): Source[Try[InputCaseTemplate], NotUsed] =
    elasticClient("caseTemplate", searchQuery(matchAll))
      .read[InputCaseTemplate]

  override def countCaseTemplate(filter: Filter): Future[Long] =
    elasticClient.count("caseTemplate", searchQuery(matchAll))

  override def countCaseTemplateTask(filter: Filter): Future[Long] = Future.failed(new NotImplementedError)

  def listCaseTemplateTask(caseTemplateId: String): Source[Try[(String, InputTask)], NotUsed] =
    Source
      .futureSource {
        elasticClient
          .get("caseTemplate", caseTemplateId)
          .map { json =>
            val metaData = json.as[MetaData]
            val tasks    = (json \ "tasks").asOpt(Reads.seq(caseTemplateTaskReads(metaData))).getOrElse(Nil)
            Source(tasks.to[immutable.Iterable].map(t => Success(caseTemplateId -> t)))
          }
          .recover {
            case error =>
              Source.single(Failure(error))
          }
      }
      .mapMaterializedValue(_ => NotUsed)

  override def countJobs(filter: Filter): Future[Long] =
    elasticClient.count("case_artifact_job", searchQuery(hasParentQuery("case_artifact", hasParentQuery("case", bool(caseFilter(filter))))))

  override def listJobs(caseId: String): Source[Try[(String, InputJob)], NotUsed] =
    elasticClient("case_artifact_job", searchQuery(hasParentQuery("case_artifact", hasParentQuery("case", idsQuery(caseId)))))
      .readWithParent[InputJob](json => Try((json \ "_parent").as[String]))(jobReads, classTag[InputJob])

  override def countJobObservables(filter: Filter): Future[Long] = Future.failed(new NotImplementedError)

  override def listJobObservables(caseId: String): Source[Try[(String, InputObservable)], NotUsed] =
    elasticClient("case_artifact_job", searchQuery(hasParentQuery("case_artifact", hasParentQuery("case", idsQuery(caseId)))))
      .map { json =>
        Try {
          val metaData = json.as[MetaData]
          (json \ "artifacts").asOpt[Seq[JsValue]].getOrElse(Nil).map(o => Try(metaData.id -> o.as(jobObservableReads(metaData))))
        }
      }
      .mapConcat {
        case Success(o)     => o.toList
        case Failure(error) => List(Failure(error))
      }

  override def countAction(filter: Filter): Future[Long] =
    elasticClient.count("action", searchQuery(matchAll))

  override def listActions(entityIds: Seq[String]): Source[Try[(String, InputAction)], NotUsed] =
    elasticClient("action", searchQuery(termsQuery("objectId", entityIds)))
      .read[(String, InputAction)]

  private def auditFilter(filter: Filter, objectIds: String*): JsObject = {
    val dateFilter =
      if (filter.auditDateRange._1.isDefined || filter.auditDateRange._2.isDefined)
        Seq(range("createdAt", filter.auditDateRange._1, filter.auditDateRange._2))
      else Nil

    val objectIdFilter = if (objectIds.nonEmpty) Seq(termsQuery("objectId", objectIds)) else Nil

    val includeFilter = (if (filter.includeAuditActions.nonEmpty) Seq(termsQuery("operation", filter.includeAuditActions)) else Nil) ++
      (if (filter.includeAuditObjectTypes.nonEmpty) Seq(termsQuery("objectType", filter.includeAuditObjectTypes)) else Nil)

    val excludeFilter = (if (filter.excludeAuditActions.nonEmpty) Seq(termsQuery("operation", filter.excludeAuditActions)) else Nil) ++
      (if (filter.excludeAuditObjectTypes.nonEmpty) Seq(termsQuery("objectType", filter.excludeAuditObjectTypes)) else Nil)

    bool(dateFilter ++ includeFilter ++ objectIdFilter, Nil, excludeFilter)
  }

  override def countAudits(filter: Filter): Future[Long] =
    elasticClient.count("audit", searchQuery(auditFilter(filter)))

  override def listAudits(entityIds: Seq[String], filter: Filter): Source[Try[(String, InputAudit)], NotUsed] =
    elasticClient("audit", searchQuery(auditFilter(filter, entityIds: _*)))
      .read[(String, InputAudit)]

  override def countDashboards(filter: Filter): Future[Long] =
    elasticClient.count("dashboard", searchQuery(matchAll))

  override def listDashboards(filter: Filter): Source[Try[InputDashboard], NotUsed] =
    elasticClient("dashboard", searchQuery(matchAll))
      .read[InputDashboard]
}

```

`migration/src/main/scala/org/thp/thehive/migration/th3/SearchWithScroll.scala`:

```scala
package org.thp.thehive.migration.th3

import akka.stream.stage.{GraphStage, GraphStageLogic, OutHandler}
import akka.stream.{Attributes, Outlet, SourceShape}
import org.thp.scalligraph.SearchError
import play.api.Logger
import play.api.libs.json._

import scala.collection.mutable
import scala.concurrent.ExecutionContext
import scala.util.{Failure, Success, Try}

class SearchWithScroll(client: ElasticClient, docType: String, query: JsObject, keepAliveStr: String)(implicit
    ec: ExecutionContext
) extends GraphStage[SourceShape[JsValue]] {

  private[SearchWithScroll] lazy val logger = Logger(getClass)
  val out: Outlet[JsValue]                  = Outlet[JsValue]("searchHits")
  val shape: SourceShape[JsValue]           = SourceShape.of(out)

  def readHits(searchResponse: JsValue): Seq[JsObject] =
    (searchResponse \ "hits" \ "hits").as[Seq[JsObject]].map { hit =>
      (hit \ "_source").as[JsObject] +
        ("_id" -> (hit \ "_id").as[JsValue]) +
        ("_parent" -> (hit \ "_parent")
          .asOpt[JsValue]
          .orElse((hit \ "_source" \ "relations" \ "parent").asOpt[JsValue])
          .getOrElse(JsNull))
    }
  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) with OutHandler {
      val queue: mutable.Queue[JsValue] = mutable.Queue.empty
      var scrollId: Option[String]      = None
      setHandler(out, this)

      val callback: Try[JsValue] => Unit =
        getAsyncCallback[Try[JsValue]] {
          case Success(searchResponse) =>
            if ((searchResponse \ "timed_out").asOpt[Boolean].contains(true)) {
              logger.warn(s"Search timeout ($docType)")
              failStage(SearchError(s"Request terminated early or timed out ($docType)"))
            } else {
              scrollId = (searchResponse \ "_scroll_id").asOpt[String].orElse(scrollId)
              val hits = readHits(searchResponse)
              if (hits.isEmpty) completeStage()
              else {
                queue ++= hits
                push(out, queue.dequeue())
              }
            }
          case Failure(error) =>
            logger.warn(s"Search error ($docType)", error)
            failStage(SearchError(s"Request terminated early or timed out ($docType)"))
        }.invoke _

      override def onPull(): Unit =
        if (queue.nonEmpty)
          push(out, queue.dequeue())
        else
          scrollId.fold(client.search(docType, query, "scroll" -> keepAliveStr).onComplete(callback)) { sid =>
            client.scroll(sid, keepAliveStr).onComplete(callback)
          }

      override def postStop(): Unit = scrollId.foreach(client.clearScroll(_))
    }
}

```

`migration/src/main/scala/org/thp/thehive/migration/th4/DummyActor.scala`:

```scala
package org.thp.thehive.migration.th4

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.scaladsl.adapter.ClassicActorSystemOps
import akka.actor.{Actor, ActorSystem}
import akka.actor.typed.{ActorRef => TypedActorRef}

import java.util.UUID
import javax.inject.{Inject, Provider}

class DummyActor extends Actor {
  override def receive: Receive = PartialFunction.empty
}

class DummyTypedActorProvider[T] @Inject() (actorSystem: ActorSystem) extends Provider[TypedActorRef[T]] {
  override def get(): TypedActorRef[T] =
    actorSystem
      .toTyped
      .systemActorOf(Behaviors.empty, UUID.randomUUID().toString)
}

```

`migration/src/main/scala/org/thp/thehive/migration/th4/JanusDatabaseProvider.scala`:

```scala
package org.thp.thehive.migration.th4

import akka.actor.ActorSystem
import org.janusgraph.core.JanusGraph
import org.thp.scalligraph.SingleInstance
import org.thp.scalligraph.janus.JanusDatabase
import org.thp.scalligraph.models.{Database, UpdatableSchema}
import play.api.Configuration

import javax.inject.{Inject, Provider, Singleton}
import scala.collection.JavaConverters._
import scala.collection.immutable

@Singleton
class JanusDatabaseProvider @Inject() (configuration: Configuration, system: ActorSystem, schemas: immutable.Set[UpdatableSchema])
    extends Provider[Database] {

  def dropOtherConnections(db: JanusGraph): Unit = {
    val mgmt = db.openManagement()
    mgmt
      .getOpenInstances
      .asScala
      .filterNot(_.endsWith("(current)"))
      .foreach(mgmt.forceCloseInstance)
    mgmt.commit()
  }

  override lazy val get: Database = {
    val janusDatabase = JanusDatabase.openDatabase(configuration, system)
    dropOtherConnections(janusDatabase)
    val db = new JanusDatabase(
      janusDatabase,
      configuration,
      system,
      new SingleInstance(true)
    )
    db.createSchema(schemas.flatMap(_.modelList).toSeq).get
    db
  }
}

```

`migration/src/main/scala/org/thp/thehive/migration/th4/NoAuditSrv.scala`:

```scala
package org.thp.thehive.migration.th4

import akka.actor.ActorRef
import com.google.inject.name.Named
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services.EventSrv
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.Audit
import org.thp.thehive.services.{AuditSrv, UserSrv}

import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Success, Try}

@Singleton
class NoAuditSrv @Inject() (
    userSrvProvider: Provider[UserSrv],
    @Named("notification-actor") notificationActor: ActorRef,
    eventSrv: EventSrv,
    db: Database
) extends AuditSrv(userSrvProvider, notificationActor, eventSrv, db) {

  override def create(audit: Audit, context: Product with Entity, `object`: Option[Product with Entity])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    Success(())

  override def mergeAudits[R](body: => Try[R])(auditCreator: R => Try[Unit])(implicit graph: Graph): Try[R] = body
}

```

`migration/src/main/scala/org/thp/thehive/migration/th4/Output.scala`:

```scala
package org.thp.thehive.migration.th4

import akka.actor.ActorSystem
import akka.actor.typed.{ActorRef, Scheduler}
import akka.stream.Materializer
import com.google.inject.{Guice, Injector => GInjector}
import net.codingwell.scalaguice.{ScalaModule, ScalaMultibinder}
import org.thp.scalligraph._
import org.thp.scalligraph.auth.{AuthContext, AuthContextImpl, UserSrv => UserDB}
import org.thp.scalligraph.janus.JanusDatabase
import org.thp.scalligraph.models._
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.connector.cortex.models.{CortexSchemaDefinition, TheHiveCortexSchemaProvider}
import org.thp.thehive.connector.cortex.services.{ActionSrv, JobSrv}
import org.thp.thehive.dto.v1.InputCustomFieldValue
import org.thp.thehive.migration.IdMapping
import org.thp.thehive.migration.dto._
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services._
import org.thp.thehive.{migration, ClusterSetup}
import play.api.cache.SyncCacheApi
import play.api.cache.ehcache.EhCacheModule
import play.api.inject.guice.GuiceInjector
import play.api.inject.{ApplicationLifecycle, DefaultApplicationLifecycle, Injector}
import play.api.libs.concurrent.{AkkaGuiceSupport, AkkaSchedulerProvider}
import play.api.{Configuration, Environment, Logger}

import javax.inject.{Inject, Provider, Singleton}
import scala.collection.JavaConverters._
import scala.collection.concurrent.TrieMap
import scala.collection.immutable
import scala.concurrent.ExecutionContext
import scala.concurrent.duration.DurationInt
import scala.util.{Failure, Success, Try}

object Output {

  private def buildApp(configuration: Configuration)(implicit actorSystem: ActorSystem): GInjector =
    Guice
      .createInjector(
        (play.api.inject.guice.GuiceableModule.guiceable(new EhCacheModule).guiced(Environment.simple(), configuration, Set.empty) :+
          new ScalaModule with AkkaGuiceSupport {
            override def configure(): Unit = {
              bind[Configuration].toInstance(configuration)
              bind[ActorSystem].toInstance(actorSystem)
              bind[Scheduler].toProvider[AkkaSchedulerProvider]
              bind[Materializer].toInstance(Materializer(actorSystem))
              bind[ExecutionContext].toInstance(actorSystem.dispatcher)
              bind[Injector].to[GuiceInjector]
              bind[UserDB].to[LocalUserSrv]
              bindActor[DummyActor]("notification-actor")
              bindActor[DummyActor]("config-actor")
              bindActor[DummyActor]("cortex-actor")
              bind[ActorRef[IntegrityCheck.Request]].toProvider[DummyTypedActorProvider[IntegrityCheck.Request]]
              bind[ActorRef[CaseNumberActor.Request]].toProvider[CaseNumberActorProvider]
              val integrityCheckOpsBindings = ScalaMultibinder.newSetBinder[IntegrityCheck](binder)
              integrityCheckOpsBindings.addBinding.to[AlertIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[CaseIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[CaseTemplateIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[CustomFieldIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[DataIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ImpactStatusIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[LogIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ObservableIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ObservableTypeIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[OrganisationIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ProfileIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[ResolutionStatusIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[TagIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[TaskIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[UserIntegrityCheck]
              integrityCheckOpsBindings.addBinding.to[RoleIntegrityCheck]

              val schemaBindings = ScalaMultibinder.newSetBinder[UpdatableSchema](binder)
              schemaBindings.addBinding.to[TheHiveSchemaDefinition]
              schemaBindings.addBinding.to[CortexSchemaDefinition]
              bind[SingleInstance].toInstance(new SingleInstance(true))

              bind[AuditSrv].to[NoAuditSrv]
              bind[Database].toProvider[JanusDatabaseProvider]
              bind[Environment].toInstance(Environment.simple())
              bind[ApplicationLifecycle].to[DefaultApplicationLifecycle]
              bind[Schema].toProvider[TheHiveCortexSchemaProvider]
              configuration.get[String]("storage.provider") match {
                case "localfs"  => bind(classOf[StorageSrv]).to(classOf[LocalFileSystemStorageSrv])
                case "database" => bind(classOf[StorageSrv]).to(classOf[DatabaseStorageSrv])
                case "hdfs"     => bind(classOf[StorageSrv]).to(classOf[HadoopStorageSrv])
                case "s3"       => bind(classOf[StorageSrv]).to(classOf[S3StorageSrv])
              }
              bind[ClusterSetup].asEagerSingleton()
              ()
            }
          }).asJava
      )

  def apply(configuration: Configuration)(implicit actorSystem: ActorSystem): Output = {
    if (configuration.getOptional[Boolean]("dropDatabase").contains(true)) {
      Logger(getClass).info("Drop database")
      new JanusDatabase(configuration, actorSystem, fullTextIndexAvailable = false).drop()
    }
    buildApp(configuration).getInstance(classOf[Output])
  }
}

@Singleton
class Output @Inject() (
    configuration: Configuration,
    theHiveSchema: TheHiveSchemaDefinition,
    cortexSchema: CortexSchemaDefinition,
    caseSrv: CaseSrv,
    observableSrvProvider: Provider[ObservableSrv],
    dataSrv: DataSrv,
    reportTagSrv: ReportTagSrv,
    userSrv: UserSrv,
//    tagSrv: TagSrv,
    caseTemplateSrv: CaseTemplateSrv,
    organisationSrv: OrganisationSrv,
    observableTypeSrv: ObservableTypeSrv,
    alertSrv: AlertSrv,
    taskSrv: TaskSrv,
    shareSrv: ShareSrv,
    attachmentSrv: AttachmentSrv,
    profileSrv: ProfileSrv,
    logSrv: LogSrv,
    auditSrv: AuditSrv,
    customFieldSrv: CustomFieldSrv,
    impactStatusSrv: ImpactStatusSrv,
    resolutionStatusSrv: ResolutionStatusSrv,
    jobSrv: JobSrv,
    actionSrv: ActionSrv,
    dashboardSrv: DashboardSrv,
    db: Database,
    cache: SyncCacheApi,
    checks: immutable.Set[IntegrityCheck]
) extends migration.Output[Graph] {
  lazy val logger: Logger      = Logger(getClass)
  val resumeMigration: Boolean = configuration.get[Boolean]("resume")
  val defaultUserDomain: String = userSrv
    .defaultUserDomain
    .getOrElse(
      throw BadConfigurationError("Default user domain is empty in configuration. Please add `auth.defaultUserDomain` in your configuration file.")
    )
  val caseNumberShift: Int = configuration.get[Int]("caseNumberShift")
  val observableDataIsIndexed: Boolean = {
    val v = db match {
      case jdb: JanusDatabase => jdb.fieldIsIndexed("data")
      case _                  => false
    }
    logger.info(s"The field data is ${if (v) "" else "not"} indexed")
    v
  }
  lazy val observableSrv: ObservableSrv                                         = observableSrvProvider.get
  private var profiles: TrieMap[String, Profile with Entity]                    = TrieMap.empty
  private var organisations: TrieMap[String, Organisation with Entity]          = TrieMap.empty
  private var users: TrieMap[String, User with Entity]                          = TrieMap.empty
  private var impactStatuses: TrieMap[String, ImpactStatus with Entity]         = TrieMap.empty
  private var resolutionStatuses: TrieMap[String, ResolutionStatus with Entity] = TrieMap.empty
  private var observableTypes: TrieMap[String, ObservableType with Entity]      = TrieMap.empty
  private var customFields: TrieMap[String, CustomField with Entity]            = TrieMap.empty
  private var caseTemplates: TrieMap[String, CaseTemplate with Entity]          = TrieMap.empty

  override def startMigration(): Try[Unit] = {
    implicit val authContext: AuthContext = LocalUserSrv.getSystemAuthContext
    if (resumeMigration)
      db.addSchemaIndexes(theHiveSchema)
        .flatMap(_ => db.addSchemaIndexes(cortexSchema))
        .flatMap { _ =>
          db.roTransaction { implicit graph =>
            profiles ++= profileSrv.startTraversal.toSeq.map(p => p.name -> p)
            organisations ++= organisationSrv.startTraversal.toSeq.map(o => o.name -> o)
            users ++= userSrv.startTraversal.toSeq.map(u => u.name -> u)
            impactStatuses ++= impactStatusSrv.startTraversal.toSeq.map(s => s.value -> s)
            resolutionStatuses ++= resolutionStatusSrv.startTraversal.toSeq.map(s => s.value -> s)
            observableTypes ++= observableTypeSrv.startTraversal.toSeq.map(o => o.name -> o)
            customFields ++= customFieldSrv.startTraversal.toSeq.map(c => c.name -> c)
            caseTemplates ++= caseTemplateSrv.startTraversal.toSeq.map(c => c.name -> c)
          }
          Success(())
        }
    else {
      db.setVersion(theHiveSchema.name, theHiveSchema.operations.lastVersion)
      db.setVersion(cortexSchema.name, cortexSchema.operations.lastVersion)
      db.tryTransaction { implicit graph =>
        profiles ++= Profile.initialValues.flatMap(p => profileSrv.createEntity(p).map(p.name -> _).toOption)
        resolutionStatuses ++= ResolutionStatus.initialValues.flatMap(p => resolutionStatusSrv.createEntity(p).map(p.value -> _).toOption)
        impactStatuses ++= ImpactStatus.initialValues.flatMap(p => impactStatusSrv.createEntity(p).map(p.value -> _).toOption)
        observableTypes ++= ObservableType.initialValues.flatMap(p => observableTypeSrv.createEntity(p).map(p.name -> _).toOption)
        organisations ++= Organisation.initialValues.flatMap(p => organisationSrv.createEntity(p).map(p.name -> _).toOption)
        users ++= User.initialValues.flatMap(p => userSrv.createEntity(p).map(p.login -> _).toOption)
        Success(())
      }
    }
  }

  override def endMigration(): Try[Unit] = {
    /* free memory */
    profiles = null
    organisations = null
    users = null
    impactStatuses = null
    resolutionStatuses = null
    observableTypes = null
    customFields = null
    caseTemplates = null

    import MapMerger._
    db.addSchemaIndexes(theHiveSchema)
      .flatMap(_ => db.addSchemaIndexes(cortexSchema))
      .foreach { _ =>
        if (configuration.get[Boolean]("integrityCheck.enabled"))
          checks.foreach { c =>
            logger.info(s"Running check on ${c.name} ...")
            val desupStats = c match {
              case dc: DedupCheck[_] => dc.dedup(KillSwitch.alwaysOn)
              case _                 => Map.empty[String, Long]
            }
            val globalStats = c match {
              case gc: GlobalCheck[_] => gc.runGlobalCheck(24.hours, KillSwitch.alwaysOn)
              case _                  => Map.empty[String, Long]
            }
            val statsStr = (desupStats <+> globalStats)
              .collect { case (k, v) if v != 0 => s"$k:$v" }
              .mkString(" ")
            if (statsStr.isEmpty) logger.info(s"Check on ${c.name}: no change needed")
            else logger.info(s"Check on ${c.name}: $statsStr")
          }
      }

    Try(db.close())
  }

  implicit class RichTry[A](t: Try[A]) {
    def logFailure(message: String): Unit = t.failed.foreach(error => logger.warn(s"$message: $error"))
  }

  private def updateMetaData(entity: Entity, metaData: MetaData)(implicit graph: Graph): Unit = {
    val vertex = graph.VV(entity._id).head
    UMapping.date.setProperty(vertex, "_createdAt", metaData.createdAt)
    UMapping.date.optional.setProperty(vertex, "_updatedAt", metaData.updatedAt)
  }

  private def withAuthContext[R](userId: String)(body: AuthContext => R): R = {
    val authContext =
      if (userId.startsWith("init@") || userId == "init") LocalUserSrv.getSystemAuthContext
      else if (userId.contains('@')) AuthContextImpl(userId, userId, EntityName("admin"), "mig-request", Permissions.all)
      else AuthContextImpl(s"$userId@$defaultUserDomain", s"$userId@$defaultUserDomain", EntityName("admin"), "mig-request", Permissions.all)
    body(authContext)
  }

//  private def getTag(tagName: String, organisationId: String)(implicit graph: Graph, authContext: AuthContext): Try[Tag with Entity] =
//    cache.getOrElseUpdate(s"tag-$organisationId-$tagName", 10.minutes) {
//      tagSrv.createEntity(Tag(s"_freetags_$organisationId", tagName, None, None, tagSrv.freeTagColour))
//    }

  override def withTx[R](body: Graph => Try[R]): Try[R] = db.tryTransaction(body)

  override def organisationExists(tx: Graph, inputOrganisation: InputOrganisation): Boolean =
    organisations.contains(inputOrganisation.organisation.name)

  private def getOrganisation(organisationName: String): Try[Organisation with Entity] =
    organisations
      .get(organisationName)
      .fold[Try[Organisation with Entity]](Failure(NotFoundError(s"Organisation $organisationName not found")))(Success.apply)

  override def createOrganisation(graph: Graph, inputOrganisation: InputOrganisation): Try[IdMapping] =
    withAuthContext(inputOrganisation.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create organisation ${inputOrganisation.organisation.name}")
      organisationSrv.create(inputOrganisation.organisation).map { o =>
        updateMetaData(o, inputOrganisation.metaData)
        organisations += (o.name -> o)
        IdMapping(inputOrganisation.metaData.id, o._id)
      }
    }

  override def userExists(graph: Graph, inputUser: InputUser): Boolean = {
    val validLogin =
      if (inputUser.user.login.contains('@')) inputUser.user.login.toLowerCase
      else s"${inputUser.user.login}@$defaultUserDomain".toLowerCase
    users.contains(validLogin)
  }

  private def getUser(login: String): Try[User with Entity] = {
    val validLogin =
      if (login.contains('@')) login.toLowerCase
      else s"$login@$defaultUserDomain".toLowerCase
    users
      .get(if (validLogin.startsWith("init@")) User.system.login else validLogin)
      .fold[Try[User with Entity]](Failure(NotFoundError(s"User $login not found")))(Success.apply)
  }

  override def createUser(graph: Graph, inputUser: InputUser): Try[IdMapping] =
    withAuthContext(inputUser.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create user ${inputUser.user.login}")
      userSrv.checkUser(inputUser.user).flatMap(userSrv.createEntity).map { createdUser =>
        updateMetaData(createdUser, inputUser.metaData)
        inputUser
          .avatar
          .foreach { inputAttachment =>
            attachmentSrv
              .create(inputAttachment.name, inputAttachment.size, inputAttachment.contentType, inputAttachment.data)
              .flatMap { attachment =>
                userSrv.setAvatar(createdUser, attachment)
              }
              .logFailure(s"Unable to set avatar to user ${createdUser.login}")
          }
        inputUser.organisations.foreach {
          case (organisationName, profileName) =>
            (for {
              organisation <- getOrganisation(organisationName)
              profile      <- getProfile(profileName)
              _            <- userSrv.addUserToOrganisation(createdUser, organisation, profile)
            } yield ()).logFailure(s"Unable to put user ${createdUser.login} in organisation $organisationName with profile $profileName")
        }
        users += (createdUser.login -> createdUser)
        IdMapping(inputUser.metaData.id, createdUser._id)
      }
    }

  override def customFieldExists(graph: Graph, inputCustomField: InputCustomField): Boolean =
    customFields.contains(inputCustomField.customField.name)

  private def getCustomField(name: String): Try[CustomField with Entity] =
    customFields.get(name).fold[Try[CustomField with Entity]](Failure(NotFoundError(s"Custom field $name not found")))(Success.apply)

  override def createCustomField(graph: Graph, inputCustomField: InputCustomField): Try[IdMapping] =
    withAuthContext(inputCustomField.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create custom field ${inputCustomField.customField.name}")
      customFieldSrv.create(inputCustomField.customField).map { cf =>
        updateMetaData(cf, inputCustomField.metaData)
        customFields += (cf.name -> cf)
        IdMapping(inputCustomField.customField.name, cf._id)
      }
    }

  override def observableTypeExists(graph: Graph, inputObservableType: InputObservableType): Boolean =
    observableTypes.contains(inputObservableType.observableType.name)

  private def getObservableType(typeName: String)(implicit graph: Graph, authContext: AuthContext): Try[ObservableType with Entity] =
    observableTypes
      .get(typeName)
      .fold[Try[ObservableType with Entity]] {
        observableTypeSrv.createEntity(ObservableType(typeName, isAttachment = false)).map { ot =>
          observableTypes += (typeName -> ot)
          ot
        }
      }(Success.apply)

  override def createObservableTypes(graph: Graph, inputObservableType: InputObservableType): Try[IdMapping] =
    withAuthContext(inputObservableType.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create observable types ${inputObservableType.observableType.name}")
      observableTypeSrv.create(inputObservableType.observableType).map { ot =>
        updateMetaData(ot, inputObservableType.metaData)
        observableTypes += (ot.name -> ot)
        IdMapping(inputObservableType.observableType.name, ot._id)
      }
    }

  override def profileExists(graph: Graph, inputProfile: InputProfile): Boolean = profiles.contains(inputProfile.profile.name)

  private def getProfile(profileName: String)(implicit graph: Graph, authContext: AuthContext): Try[Profile with Entity] =
    profiles
      .get(profileName)
      .fold[Try[Profile with Entity]] {
        profileSrv.createEntity(Profile(profileName, Set.empty)).map { p =>
          profiles += (profileName -> p)
          p
        }
      }(Success.apply)

  override def createProfile(graph: Graph, inputProfile: InputProfile): Try[IdMapping] =
    withAuthContext(inputProfile.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create profile ${inputProfile.profile.name}")
      profileSrv.create(inputProfile.profile).map { profile =>
        updateMetaData(profile, inputProfile.metaData)
        profiles += (profile.name -> profile)
        IdMapping(inputProfile.profile.name, profile._id)
      }
    }

  override def impactStatusExists(graph: Graph, inputImpactStatus: InputImpactStatus): Boolean =
    impactStatuses.contains(inputImpactStatus.impactStatus.value)

  private def getImpactStatus(name: String)(implicit graph: Graph, authContext: AuthContext): Try[ImpactStatus with Entity] =
    impactStatuses
      .get(name)
      .fold[Try[ImpactStatus with Entity]] {
        impactStatusSrv.createEntity(ImpactStatus(name)).map { is =>
          impactStatuses += (name -> is)
          is
        }
      }(Success.apply)

  override def createImpactStatus(graph: Graph, inputImpactStatus: InputImpactStatus): Try[IdMapping] =
    withAuthContext(inputImpactStatus.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create impact status ${inputImpactStatus.impactStatus.value}")
      impactStatusSrv.create(inputImpactStatus.impactStatus).map { status =>
        updateMetaData(status, inputImpactStatus.metaData)
        impactStatuses += (status.value -> status)
        IdMapping(inputImpactStatus.impactStatus.value, status._id)
      }
    }

  override def resolutionStatusExists(graph: Graph, inputResolutionStatus: InputResolutionStatus): Boolean =
    resolutionStatuses.contains(inputResolutionStatus.resolutionStatus.value)

  private def getResolutionStatus(name: String)(implicit graph: Graph, authContext: AuthContext): Try[ResolutionStatus with Entity] =
    resolutionStatuses
      .get(name)
      .fold[Try[ResolutionStatus with Entity]] {
        resolutionStatusSrv.createEntity(ResolutionStatus(name)).map { rs =>
          resolutionStatuses += (name -> rs)
          rs
        }
      }(Success.apply)

  override def createResolutionStatus(graph: Graph, inputResolutionStatus: InputResolutionStatus): Try[IdMapping] =
    withAuthContext(inputResolutionStatus.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create resolution status ${inputResolutionStatus.resolutionStatus.value}")
      resolutionStatusSrv
        .create(inputResolutionStatus.resolutionStatus)
        .map { status =>
          updateMetaData(status, inputResolutionStatus.metaData)
          resolutionStatuses += (status.value -> status)
          IdMapping(inputResolutionStatus.resolutionStatus.value, status._id)
        }
    }

  override def caseTemplateExists(graph: Graph, inputCaseTemplate: InputCaseTemplate): Boolean =
    caseTemplates.contains(inputCaseTemplate.caseTemplate.name)

  private def getCaseTemplate(name: String): Option[CaseTemplate with Entity] = caseTemplates.get(name)

  override def createCaseTemplate(graph: Graph, inputCaseTemplate: InputCaseTemplate): Try[IdMapping] =
    withAuthContext(inputCaseTemplate.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create case template ${inputCaseTemplate.caseTemplate.name}")
      for {
        organisation        <- getOrganisation(inputCaseTemplate.organisation)
        createdCaseTemplate <- caseTemplateSrv.createEntity(inputCaseTemplate.caseTemplate)
        _                   <- caseTemplateSrv.caseTemplateOrganisationSrv.create(CaseTemplateOrganisation(), createdCaseTemplate, organisation)
//        _ <-
//          inputCaseTemplate
//            .caseTemplate
//            .tags
//            .toTry(
//              getTag(_, organisation._id.value).flatMap(t => caseTemplateSrv.caseTemplateTagSrv.create(CaseTemplateTag(), createdCaseTemplate, t))
//            )
        _ = updateMetaData(createdCaseTemplate, inputCaseTemplate.metaData)
        _ = inputCaseTemplate.customFields.foreach {
          case InputCustomFieldValue(name, value, order) =>
            (for {
              cf  <- getCustomField(name)
              ccf <- CustomFieldType.map(cf.`type`).setValue(CaseTemplateCustomField(order = order), value)
              _   <- caseTemplateSrv.caseTemplateCustomFieldSrv.create(ccf, createdCaseTemplate, cf)
            } yield ()).logFailure(s"Unable to set custom field $name=${value.getOrElse("<not set>")}")
        }
        _ = caseTemplates += (inputCaseTemplate.caseTemplate.name -> createdCaseTemplate)
      } yield IdMapping(inputCaseTemplate.metaData.id, createdCaseTemplate._id)
    }

  override def createCaseTemplateTask(graph: Graph, caseTemplateId: EntityId, inputTask: InputTask): Try[IdMapping] =
    withAuthContext(inputTask.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      import CaseTemplateOps._
      logger.debug(s"Create task ${inputTask.task.title} in case template $caseTemplateId")
      val assignee = inputTask.task.assignee.flatMap(u => getUser(u).toOption)
      for {
        (caseTemplate, organisationIds) <-
          caseTemplateSrv.getByIds(caseTemplateId).project(_.by.by(_.organisation._id.fold)).getOrFail("CaseTemplate")
        richTask <- taskSrv.create(inputTask.task.copy(relatedId = caseTemplate._id, organisationIds = organisationIds.toSet), assignee)
        _        <- caseTemplateSrv.caseTemplateTaskSrv.create(CaseTemplateTask(), caseTemplate, richTask.task)
        _ = updateMetaData(richTask.task, inputTask.metaData)
      } yield IdMapping(inputTask.metaData.id, richTask._id)
    }

  override def caseExists(graph: Graph, inputCase: InputCase): Boolean =
    if (!resumeMigration) false
    else
      db.roTransaction { implicit graph =>
        caseSrv.startTraversal.getByNumber(inputCase.`case`.number + caseNumberShift).exists
      }

  private def getCase(caseId: EntityId)(implicit graph: Graph): Try[Case with Entity] =
    cache
      .get[Case with Entity](s"case-$caseId")
      .fold {
        caseSrv.getByIds(caseId).getOrFail("Case").map { c =>
          cache.set(s"case-$caseId", c, 5.minutes)
          c
        }
      }(Success(_))

  override def createCase(graph: Graph, inputCase: InputCase): Try[IdMapping] =
    withAuthContext(inputCase.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create case #${inputCase.`case`.number + caseNumberShift}")
      val organisationIds = inputCase
        .organisations
        .flatMap {
          case (orgName, _) => getOrganisation(orgName).map(_._id).toOption
        }
        .toSet
      val assignee = inputCase
        .`case`
        .assignee
        .flatMap(getUser(_).toOption)
      val caseTemplate = inputCase
        .`case`
        .caseTemplate
        .flatMap(getCaseTemplate)
      val resolutionStatus = inputCase
        .`case`
        .resolutionStatus
        .flatMap(getResolutionStatus(_).toOption)
      val impactStatus = inputCase
        .`case`
        .impactStatus
        .flatMap(getImpactStatus(_).toOption)
      val `case` = inputCase
        .`case`
        .copy(
          assignee = assignee.map(_.login),
          organisationIds = organisationIds,
          caseTemplate = caseTemplate.map(_.name),
          impactStatus = impactStatus.map(_.value),
          resolutionStatus = resolutionStatus.map(_.value),
          number = inputCase.`case`.number + caseNumberShift
        )
      caseSrv.createEntity(`case`).map { createdCase =>
        updateMetaData(createdCase, inputCase.metaData)
        cache.set(s"case-${createdCase._id}", createdCase, 5.minutes)
        assignee
          .foreach { user =>
            caseSrv
              .caseUserSrv
              .create(CaseUser(), createdCase, user)
              .logFailure(s"Unable to assign case #${createdCase.number} to ${user.login}")
          }
        caseTemplate
          .foreach { ct =>
            caseSrv
              .caseCaseTemplateSrv
              .create(CaseCaseTemplate(), createdCase, ct)
              .logFailure(s"Unable to set case template ${ct.name} to case #${createdCase.number}")
          }
//        inputCase.`case`.tags.foreach { tagName =>
//          getTag(tagName, organisationIds.head.value)
//            .flatMap(tag => caseSrv.caseTagSrv.create(CaseTag(), createdCase, tag))
//            .logFailure(s"Unable to add tag $tagName to case #${createdCase.number}")
//        }
        inputCase.customFields.foreach {
          case (name, value) => // TODO Add order
            getCustomField(name)
              .flatMap { cf =>
                CustomFieldType
                  .map(cf.`type`)
                  .setValue(CaseCustomField(), value)
                  .flatMap(ccf => caseSrv.caseCustomFieldSrv.create(ccf, createdCase, cf))
              }
              .logFailure(s"Unable to set custom field $name=${value.getOrElse("<not set>")} to case #${createdCase.number}")
        }
        inputCase.organisations.foldLeft(false) {
          case (ownerSet, (organisationName, profileName)) =>
            val owner = profileName == Profile.orgAdmin.name && !ownerSet
            val shared = for {
              organisation <- getOrganisation(organisationName)
              profile      <- getProfile(profileName)
              _            <- shareSrv.shareCase(owner, createdCase, organisation, profile)
            } yield ()
            shared.logFailure(s"Unable to share case #${createdCase.number} with organisation $organisationName, profile $profileName")
            ownerSet || owner
        }
        resolutionStatus
          .foreach { resolutionStatus =>
            caseSrv
              .caseResolutionStatusSrv
              .create(CaseResolutionStatus(), createdCase, resolutionStatus)
              .logFailure(s"Unable to set resolution status $resolutionStatus to case #${createdCase.number}")
          }
        impactStatus
          .foreach { impactStatus =>
            caseSrv
              .caseImpactStatusSrv
              .create(CaseImpactStatus(), createdCase, impactStatus)
              .logFailure(s"Unable to set impact status $impactStatus to case #${createdCase.number}")
          }

        IdMapping(inputCase.metaData.id, createdCase._id)
      }
    }

  override def createCaseTask(graph: Graph, caseId: EntityId, inputTask: InputTask): Try[IdMapping] =
    withAuthContext(inputTask.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create task ${inputTask.task.title} in case $caseId")
      val assignee      = inputTask.owner.flatMap(getUser(_).toOption)
      val organisations = inputTask.organisations.flatMap(getOrganisation(_).toOption)
      for {
        richTask <- taskSrv.create(inputTask.task.copy(relatedId = caseId, organisationIds = organisations.map(_._id)), assignee)
        _ = cache.set(s"task-${richTask._id}", richTask.task, 1.minute)
        _ = updateMetaData(richTask.task, inputTask.metaData)
        case0 <- getCase(caseId)
        _     <- organisations.toTry(o => shareSrv.shareTask(richTask, case0, o._id))
      } yield IdMapping(inputTask.metaData.id, richTask._id)
    }

  private def getTask(taskId: EntityId)(implicit graph: Graph): Try[Task with Entity] =
    cache
      .get[Task with Entity](s"task-$taskId")
      .fold {
        taskSrv.getOrFail(taskId).map { t =>
          cache.set(s"task-$taskId", t, 1.minute)
          t
        }
      }(Success(_))

  override def createCaseTaskLog(graph: Graph, taskId: EntityId, inputLog: InputLog): Try[IdMapping] =
    withAuthContext(inputLog.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      for {
        task <- getTask(taskId)
        _ = logger.debug(s"Create log in task ${task.title}")
        log <- logSrv.createEntity(inputLog.log.copy(taskId = task._id, organisationIds = task.organisationIds))
        _ = updateMetaData(log, inputLog.metaData)
        _ <- logSrv.taskLogSrv.create(TaskLog(), task, log)
        _ <- inputLog.attachments.toTry { inputAttachment =>
          attachmentSrv.create(inputAttachment.name, inputAttachment.size, inputAttachment.contentType, inputAttachment.data).flatMap { attachment =>
            logSrv.logAttachmentSrv.create(LogAttachment(), log, attachment)
          }
        }
      } yield IdMapping(inputLog.metaData.id, log._id)
    }

  private def getData(value: String)(implicit graph: Graph, authContext: AuthContext): Try[Data with Entity] = {
    val (dataOrHash, fullData) = UseHashToIndex.hashToIndex(value).fold[(String, Option[String])](value -> None)(_ -> Some(value))
    if (observableDataIsIndexed) dataSrv.create(Data(dataOrHash, fullData))
    else dataSrv.createEntity(Data(dataOrHash, fullData))
  }

  private def createSimpleObservable(observable: Observable, observableType: ObservableType with Entity, dataValue: String)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Observable with Entity] =
    for {
      data <- getData(dataValue)
      _ <-
        if (observableType.isAttachment) Failure(BadRequestError("A attachment observable doesn't accept string value"))
        else Success(())
      createdObservable <- observableSrv.createEntity(observable.copy(data = Some(dataValue)))
      _                 <- observableSrv.observableDataSrv.create(ObservableData(), createdObservable, data)
    } yield createdObservable

  private def createAttachmentObservable(
      observable: Observable,
      observableType: ObservableType with Entity,
      inputAttachment: InputAttachment
  )(implicit graph: Graph, authContext: AuthContext): Try[Observable with Entity] =
    for {
      attachment <- attachmentSrv.create(inputAttachment.name, inputAttachment.size, inputAttachment.contentType, inputAttachment.data)
      _ <-
        if (!observableType.isAttachment) Failure(BadRequestError("A text observable doesn't accept attachment"))
        else Success(())
      createdObservable <- observableSrv.createEntity(observable.copy(data = None))
      _                 <- observableSrv.observableAttachmentSrv.create(ObservableAttachment(), createdObservable, attachment)
    } yield createdObservable

  private def createObservable(relatedId: EntityId, inputObservable: InputObservable, organisationIds: Set[EntityId])(implicit
      graph: Graph,
      authContext: AuthContext
  ) =
    for {
      observableType <- getObservableType(inputObservable.observable.dataType)
      observable <-
        inputObservable
          .dataOrAttachment
          .fold(
            data =>
              createSimpleObservable(
                inputObservable.observable.copy(organisationIds = organisationIds, relatedId = relatedId),
                observableType,
                data
              ),
            attachment =>
              createAttachmentObservable(
                inputObservable.observable.copy(organisationIds = organisationIds, relatedId = relatedId),
                observableType,
                attachment
              )
          )
      _ = updateMetaData(observable, inputObservable.metaData)
//      _ = inputObservable.observable.tags.foreach { tagName =>
//        getTag(tagName, organisationIds.head.value)
//          .foreach(tag => observableSrv.observableTagSrv.create(ObservableTag(), observable, tag))
//      }
    } yield observable

  private def getShare(caseId: EntityId, organisationId: EntityId)(implicit graph: Graph): Try[Share with Entity] =
    cache
      .get[Share with Entity](s"share-$caseId-$organisationId")
      .fold {
        import org.thp.thehive.services.CaseOps._
        caseSrv
          .getByIds(caseId)
          .share(organisationId)
          .getOrFail("Share")
          .map { s =>
            cache.set(s"share-$caseId-$organisationId", s, 5.minutes)
            s
          }
      }(Success(_))

  override def createCaseObservable(graph: Graph, caseId: EntityId, inputObservable: InputObservable): Try[IdMapping] =
    withAuthContext(inputObservable.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create observable ${inputObservable.dataOrAttachment.fold(identity, _.name)} in case $caseId")
      for {
        organisationIds <- inputObservable.organisations.toTry(getOrganisation).map(_.map(_._id))
        observable      <- createObservable(caseId, inputObservable, organisationIds.toSet)
        _               <- reportTagSrv.updateTags(observable, inputObservable.reportTags)
        _ = organisationIds.toTry { o =>
          getShare(caseId, o)
            .flatMap(share => shareSrv.shareObservableSrv.create(ShareObservable(), share, observable))
        }
      } yield IdMapping(inputObservable.metaData.id, observable._id)
    }

  override def createJob(graph: Graph, observableId: EntityId, inputJob: InputJob): Try[IdMapping] =
    withAuthContext(inputJob.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create job ${inputJob.job.cortexId}:${inputJob.job.workerName}:${inputJob.job.cortexJobId}")
      for {
        observable <- observableSrv.getOrFail(observableId)
        job        <- jobSrv.create(inputJob.job, observable)
        _ = updateMetaData(job.job, inputJob.metaData)
      } yield IdMapping(inputJob.metaData.id, job._id)
    }

  override def createJobObservable(graph: Graph, jobId: EntityId, inputObservable: InputObservable): Try[IdMapping] =
    withAuthContext(inputObservable.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create observable ${inputObservable.dataOrAttachment.fold(identity, _.name)} in job $jobId")
      for {
        organisations <- inputObservable.organisations.toTry(getOrganisation)
        observable    <- createObservable(jobId, inputObservable, organisations.map(_._id).toSet)
        job           <- jobSrv.getOrFail(jobId)
        _             <- jobSrv.addObservable(job, observable)
      } yield IdMapping(inputObservable.metaData.id, observable._id)
    }

  override def alertExists(graph: Graph, inputAlert: InputAlert): Boolean =
    if (!resumeMigration) false
    else
      db.roTransaction { implicit graph =>
        alertSrv.startTraversal.getBySourceId(inputAlert.alert.`type`, inputAlert.alert.source, inputAlert.alert.sourceRef).exists
      }

  override def createAlert(graph: Graph, inputAlert: InputAlert): Try[IdMapping] =
    withAuthContext(inputAlert.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create alert ${inputAlert.alert.`type`}:${inputAlert.alert.source}:${inputAlert.alert.sourceRef}")
      val `case` = inputAlert.caseId.flatMap(c => getCase(EntityId.read(c)).toOption)

      for {
        organisation <- getOrganisation(inputAlert.organisation)
        createdAlert <- alertSrv.createEntity(inputAlert.alert.copy(organisationId = organisation._id, caseId = `case`.fold(EntityId.empty)(_._id)))
        _            <- `case`.map(alertSrv.alertCaseSrv.create(AlertCase(), createdAlert, _)).flip
//        tags = inputAlert.alert.tags.flatMap(getTag(_, organisation._id.value).toOption)
        _ = cache.set(s"alert-${createdAlert._id}", createdAlert, 5.minutes)
        _ = updateMetaData(createdAlert, inputAlert.metaData)
        _ <- alertSrv.alertOrganisationSrv.create(AlertOrganisation(), createdAlert, organisation)
        _ <-
          inputAlert
            .caseTemplate
            .flatMap(getCaseTemplate)
            .map(ct => alertSrv.alertCaseTemplateSrv.create(AlertCaseTemplate(), createdAlert, ct))
            .flip
//        _ = tags.foreach(t => alertSrv.alertTagSrv.create(AlertTag(), createdAlert, t))
        _ = inputAlert.customFields.foreach {
          case (name, value) => // TODO Add order
            getCustomField(name)
              .flatMap { cf =>
                CustomFieldType
                  .map(cf.`type`)
                  .setValue(AlertCustomField(), value)
                  .flatMap(acf => alertSrv.alertCustomFieldSrv.create(acf, createdAlert, cf))
              }
              .logFailure(s"Unable to set custom field $name=${value
                .getOrElse("<not set>")} to alert ${inputAlert.alert.`type`}:${inputAlert.alert.source}:${inputAlert.alert.sourceRef}")
        }
      } yield IdMapping(inputAlert.metaData.id, createdAlert._id)
    }

  override def linkAlertToCase(graph: Graph, alertId: EntityId, caseId: EntityId): Try[Unit] =
    for {
      c <- getCase(caseId)(graph)
      a <- getAlert(alertId)(graph)
      _ <- alertSrv.alertCaseSrv.create(AlertCase(), a, c)(graph, LocalUserSrv.getSystemAuthContext)
    } yield ()

  private def getAlert(alertId: EntityId)(implicit graph: Graph): Try[Alert with Entity] =
    cache
      .get[Alert with Entity](s"alert-$alertId")
      .fold {
        alertSrv.getByIds(alertId).getOrFail("Alert").map { alert =>
          cache.set(s"alert-$alertId", alert, 5.minutes)
          alert
        }
      }(Success(_))

  override def createAlertObservable(graph: Graph, alertId: EntityId, inputObservable: InputObservable): Try[IdMapping] =
    withAuthContext(inputObservable.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create observable ${inputObservable.dataOrAttachment.fold(identity, _.name)} in alert $alertId")
      for {
        alert      <- getAlert(alertId)
        observable <- createObservable(alert._id, inputObservable, Set(alert.organisationId))
        _          <- alertSrv.alertObservableSrv.create(AlertObservable(), alert, observable)
      } yield IdMapping(inputObservable.metaData.id, observable._id)
    }

  private def getEntity(entityType: String, entityId: EntityId)(implicit graph: Graph): Try[Product with Entity] =
    entityType match {
      case "Task"       => getTask(entityId)
      case "Case"       => getCase(entityId)
      case "Observable" => observableSrv.getOrFail(entityId)
      case "Log"        => logSrv.getOrFail(entityId)
      case "Alert"      => getAlert(entityId)
      case "Job"        => jobSrv.getOrFail(entityId)
      case "Action"     => actionSrv.getOrFail(entityId)
      case _            => Failure(BadRequestError(s"objectType $entityType is not recognised"))
    }

  override def createAction(graph: Graph, objectId: EntityId, inputAction: InputAction): Try[IdMapping] =
    withAuthContext(inputAction.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(
        s"Create action ${inputAction.action.cortexId}:${inputAction.action.workerName}:${inputAction.action.cortexJobId} for ${inputAction.objectType} $objectId"
      )
      for {
        entity <- getEntity(inputAction.objectType, objectId)
        action <- actionSrv.create(inputAction.action, entity)
        _ = updateMetaData(action.action, inputAction.metaData)
      } yield IdMapping(inputAction.metaData.id, action._id)
    }

  override def createAudit(graph: Graph, contextId: EntityId, inputAudit: InputAudit): Try[Unit] =
    withAuthContext(inputAudit.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create audit ${inputAudit.audit.action} on ${inputAudit.audit.objectType} ${inputAudit.audit.objectId}")
      for {
        obj <- (for {
            t <- inputAudit.audit.objectType
            i <- inputAudit.audit.objectId
          } yield getEntity(t, new EntityId(i))).flip
        ctxType = obj.map(_._label).map {
          case "Alert"                                        => "Alert"
          case "Log" | "Task" | "Observable" | "Case" | "Job" => "Case"
          case "User"                                         => "User"
          case "Action"                                       => "Action" // FIXME
          case other =>
            logger.error(s"Unknown object type: $other")
            other
        }
        context      <- ctxType.map(getEntity(_, contextId)).flip
        user         <- getUser(authContext.userId)
        createdAudit <- auditSrv.createEntity(inputAudit.audit)
        _ = updateMetaData(createdAudit, inputAudit.metaData)
        _ <- auditSrv.auditUserSrv.create(AuditUser(), createdAudit, user)
        _ <- obj.map(auditSrv.auditedSrv.create(Audited(), createdAudit, _)).flip
        _ <- context.map(auditSrv.auditContextSrv.create(AuditContext(), createdAudit, _)).flip
      } yield ()
    }

  def dashboardExists(graph: Graph, inputDashboard: InputDashboard): Boolean =
    if (!resumeMigration) false
    else
      db.roTransaction { implicit graph =>
        dashboardSrv.startTraversal.has(_.title, inputDashboard.dashboard.title).exists
      }

  override def createDashboard(graph: Graph, inputDashboard: InputDashboard): Try[IdMapping] =
    withAuthContext(inputDashboard.metaData.createdBy) { implicit authContext =>
      implicit val g: Graph = graph
      logger.debug(s"Create dashboard ${inputDashboard.dashboard.title}")
      for {
        dashboard <- dashboardSrv.create(inputDashboard.dashboard).map(_.dashboard)
        _         <- inputDashboard.organisation.map { case (org, writable) => dashboardSrv.share(dashboard, EntityName(org), writable) }.flip
        _ = updateMetaData(dashboard, inputDashboard.metaData)
      } yield IdMapping(inputDashboard.metaData.id, dashboard._id)
    }
}

```

`migration/src/test/scala/org/thp/thehive/migration/th3/UserNormalisationTest.scala`:

```scala
package org.thp.thehive.migration.th3

import akka.NotUsed
import akka.stream.scaladsl.Source
import akka.util.ByteString
import play.api.test.PlaySpecification

class UserNormalisationTest extends PlaySpecification with Conversion {
  override def readAttachment(id: String): Source[ByteString, NotUsed] = Source.empty
  override val mainOrganisation: String                                = "thehive.local"

  "User migration" should {
    "convert simple name" in {
      normaliseLogin("myLogin") must beEqualTo("mylogin")
    }
    "convert simple name with dash" in {
      normaliseLogin("my-Login") must beEqualTo("my-login")
    }
    "convert email address" in {
      normaliseLogin("Firstname.Lastname@Example.com") must beEqualTo("firstname.lastname@example.com")
    }
    "convert login with special characters" in {
      normaliseLogin("login`with\"special^chars%") must beEqualTo("login.with.special.chars")
    }
    "convert login with only special characters" in {
      normaliseLogin("^'\"éç") must beEqualTo("empty.name")
    }
    "convert login with several @" in {
      normaliseLogin("first@second@third") must beEqualTo("first@second.third")
    }
    "convert invalid email address" in {
      normaliseLogin(".first.@.domain.") must beEqualTo("first@domain")
    }
    "convert empty domain" in {
      normaliseLogin("first@") must beEqualTo("first")
    }
    "convert email with invalid domain" in {
      normaliseLogin("first@```") must beEqualTo("first")
    }
    "convert email with dash" in {
      normaliseLogin("-first-name-@-domain-name-") must beEqualTo("first-name@domain-name")
    }
  }
}

```

`misp/client/src/main/scala/org/thp/misp/client/Base64Flow.scala`:

```scala
package org.thp.misp.client

import akka.NotUsed
import akka.stream.scaladsl.Flow
import akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}
import akka.stream.{Attributes, FlowShape, Inlet, Outlet}
import akka.util.ByteString

import java.util.Base64

object Base64Flow {
  def encode(): Flow[ByteString, ByteString, NotUsed] = Flow.fromGraph(new Base64EncoderFlow)
}

class Base64EncoderFlow extends GraphStage[FlowShape[ByteString, ByteString]] {
  val in: Inlet[ByteString]                             = Inlet[ByteString]("in")
  val out: Outlet[ByteString]                           = Outlet[ByteString]("out")
  override def shape: FlowShape[ByteString, ByteString] = FlowShape.of(in, out)
  val encoder: Base64.Encoder                           = Base64.getEncoder

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) {
      var remainingBytes: ByteString  = ByteString.empty
      var upstreamIsFinished: Boolean = false

      setHandler(
        in,
        new InHandler {
          override def onPush(): Unit = {
            val data = (remainingBytes ++ grab(in)).toArray[Byte]
            val r    = data.length % 3
            if (r == 0)
              push(out, ByteString(encoder.encode(data)))
            else {
              remainingBytes = ByteString(data.drop(data.length - r))
              push(out, ByteString(encoder.encode(data.take(data.length - r))))
            }
          }

          override def onUpstreamFinish(): Unit =
            upstreamIsFinished = true
        }
      )
      setHandler(
        out,
        new OutHandler {
          override def onPull(): Unit =
            if (!upstreamIsFinished)
              pull(in)
            else {
              push(out, ByteString(encoder.encode(remainingBytes.toArray)))
              completeStage
            }
        }
      )
    }
}

```

`misp/client/src/main/scala/org/thp/misp/client/MispClient.scala`:

```scala
package org.thp.misp.client

import akka.NotUsed
import akka.stream.alpakka.json.scaladsl.JsonReader
import akka.stream.scaladsl.{JsonFraming, Source}
import akka.util.ByteString
import org.thp.client.{ApplicationError, Authentication, ProxyWS}
import org.thp.misp.dto._
import org.thp.scalligraph.InternalError
import org.thp.scalligraph.utils.FunctionalCondition._
import play.api.Logger
import play.api.http.Status
import play.api.libs.json._
import play.api.libs.ws.{WSClient, WSRequest}

import java.util.Date
import scala.concurrent.duration.{Duration, DurationInt}
import scala.concurrent.{Await, ExecutionContext, Future}
import scala.util.{Failure, Success, Try}

object MispPurpose extends Enumeration {
  val ImportOnly, ExportOnly, ImportAndExport = Value
}

class MispClient(
    val name: String,
    val baseUrl: String,
    auth: Authentication,
    ws: WSClient,
    maxAttributes: Option[Int],
    maxAge: Option[Duration],
    excludedOrganisations: Seq[String],
    whitelistOrganisations: Seq[String],
    excludedTags: Set[String],
    whitelistTags: Set[String]
) {
  lazy val logger: Logger                              = Logger(getClass)
  val strippedUrl: String                              = baseUrl.replaceFirst("/*$", "")
  private var _currentOrganisationName: Future[String] = getCurrentOrganisationName(ExecutionContext.global)

  def currentOrganisationName: Try[String] =
    _currentOrganisationName.value match {
      case Some(s: Success[_]) => s
      case None                => Try(Await.result(_currentOrganisationName, 1.second)) // Failure(InternalError(s"MISP server $name is not yet inaccessible"))
      case Some(Failure(t)) =>
        _currentOrganisationName = getCurrentOrganisationName(ExecutionContext.global)
        Failure(InternalError(s"MISP server $name is inaccessible", t))
    }

  private def configuredProxy: Option[String] =
    ws match {
      case c: ProxyWS => c.proxy.map(p => s"http://${p.host}:${p.port}")
      case _          => None
    }
  logger.info(s"""Add MISP connection $name
                 |  url:              $baseUrl
                 |  proxy:            ${configuredProxy.getOrElse("<not set>")}
                 |  filters:
                 |    max attributes: ${maxAttributes.getOrElse("<not set>")}
                 |    max age:        ${maxAge.fold("<not set>")(_.toCoarsest.toString)}
                 |    excluded orgs:  ${excludedOrganisations.mkString}
                 |    excluded tags:  ${excludedTags.mkString}
                 |    whitelist tags: ${whitelistTags.mkString}
                 |""".stripMargin)

  private def request(url: String): WSRequest =
    auth(ws.url(s"$strippedUrl/$url").withHttpHeaders("Accept" -> "application/json"))

  private def get(url: String)(implicit ec: ExecutionContext): Future[JsValue] = {
    logger.trace(s"MISP request: GET $url")
    request(url).get().transform {
      case Success(r) if r.status == Status.OK =>
        logger.trace(s"MISP response: ${r.status} ${r.statusText}\n${r.body}")
        Success(r.json)
      case Success(r) =>
        logger.trace(s"MISP response: ${r.status} ${r.statusText}\n${r.body}")
        Try(r.json)
      case Failure(t) =>
        logger.trace(s"MISP error: $t")
        throw t
    }
  }

  private def post(url: String, body: JsValue)(implicit ec: ExecutionContext): Future[JsValue] = {
    logger.trace(s"MISP request: POST $url\n$body")
    request(url).post(body).transform {
      case Success(r) if r.status == Status.OK =>
        logger.trace(s"MISP response: ${r.status} ${r.statusText}\n${r.body}")
        Success(r.json)
      case Success(r) =>
        logger.trace(s"MISP response: ${r.status} ${r.statusText}\n${r.body}")
        Try(r.json)
      case Failure(t) =>
        logger.trace(s"MISP error: $t")
        throw t
    }
  }

  private def post(url: String, body: Source[ByteString, _])(implicit ec: ExecutionContext): Future[JsValue] = {
    logger.trace(s"MISP request: POST $url (stream body)")
    request(url).post(body).transform {
      case Success(r) if r.status == Status.OK =>
        logger.trace(s"MISP response: ${r.status} ${r.statusText}\n${r.body}")
        Success(r.json)
      case Success(r) =>
        logger.trace(s"MISP response: ${r.status} ${r.statusText}\n${r.body}")
        Try(r.json)
      case Failure(t) =>
        logger.trace(s"MISP error: $t")
        throw t
    }
  }

  //
//  private def getStream(url: String)(implicit ec: ExecutionContext): Future[Source[ByteString, Any]] =
//    request(url).withMethod("GET").stream().transform {
//      case Success(r) if r.status == Status.OK => Success(r.bodyAsSource)
//      case Success(r)                          => Try(r.bodyAsSource)
//      case Failure(t)                          => throw t
//    }

  private def postStream(url: String, body: JsValue)(implicit ec: ExecutionContext): Future[Source[ByteString, Any]] = {
    logger.trace(s"MISP request: POST $url\n$body")
    request(url).withMethod("POST").withBody(body).stream().transform {
      case Success(r) if r.status == Status.OK =>
        logger.trace(s"MISP response: ${r.status} ${r.statusText} (stream body)")
        Success(r.bodyAsSource)
      case Success(r) =>
        logger.trace(s"MISP response: ${r.status} ${r.statusText} (stream body)")
        Try(r.bodyAsSource)
      case Failure(t) =>
        logger.trace(s"MISP error: $t")
        throw t
    }
  }

  def getCurrentUser(implicit ec: ExecutionContext): Future[User] = {
    logger.debug("Get current user")
    get("users/view/me")
      .map(u => (u \ "User").as[User])
  }

  def getOrganisation(organisationId: String)(implicit ec: ExecutionContext): Future[Organisation] = {
    logger.debug(s"Get organisation $organisationId")
    get(s"organisations/view/$organisationId")
      .map(o => (o \ "Organisation").as[Organisation])
  }

  def getCurrentOrganisationName(implicit ec: ExecutionContext): Future[String] =
    getCurrentUser.flatMap(user => getOrganisation(user.orgId)).map(_.name)

  def getEvent(eventId: String)(implicit ec: ExecutionContext): Future[Event] = {
    logger.debug(s"Get MISP event $eventId")
    require(eventId.nonEmpty)
    get(s"events/$eventId")
      .map(e => (e \ "Event").as[Event])
  }

  def getVersion(implicit ec: ExecutionContext): Future[String] =
    get("servers/getVersion")
      .map(s => (s \ "version").as[String])

  def getStatus(implicit ec: ExecutionContext): Future[JsObject] =
    getVersion
      .map(version => Json.obj("name" -> name, "version" -> version, "status" -> "OK", "url" -> baseUrl))
      .recover { case _ => Json.obj("name" -> name, "version" -> "", "status" -> "ERROR", "url" -> baseUrl) }

  def searchEvents(publishDate: Option[Date] = None)(implicit ec: ExecutionContext): Source[Event, NotUsed] = {
    val fromDate = (maxAge.map(a => System.currentTimeMillis() - a.toMillis).toSeq ++ publishDate.map(_.getTime))
      .sorted(Ordering[Long].reverse)
      .headOption
      .map(d => "searchtimestamp" -> JsNumber((d / 1000) + 1))
    val tagFilter          = (whitelistTags ++ excludedTags.map("!" + _)).map(JsString.apply)
    val organisationFilter = (whitelistOrganisations ++ excludedOrganisations.map("!" + _)).map(JsString.apply)
    val query = JsObject
      .empty
      .merge(fromDate)(_ + _)
      .when(tagFilter.nonEmpty)(_ + ("searchtag" -> JsArray(tagFilter.toSeq)))
      .when(organisationFilter.nonEmpty)(_ + ("searchorg" -> JsArray(organisationFilter)))
    logger.debug("Search MISP events")
    Source
      .futureSource(postStream("events/index", query))
      .via(JsonFraming.objectScanner(Int.MaxValue))
      .mapConcat { data =>
        val maybeEvent = Try(Json.parse(data.toArray[Byte]).as[Event])
        maybeEvent.fold(error => { logger.warn(s"Event has invalid format: ${data.decodeString("UTF-8")}", error); Nil }, List(_))
      }
      .filter(event => maxAttributes.fold(true)(max => event.attributes.length < max))
      .mapMaterializedValue(_ => NotUsed)
  }

  def searchAttributes(eventId: String, publishDate: Option[Date], deletedOnly: Boolean = false)(implicit
      ec: ExecutionContext
  ): Source[Attribute, NotUsed] = {
    logger.debug(s"Search MISP attributes for event #$eventId ${publishDate.fold("")("from " + _)}")
    Source
      .futureSource(
        postStream(
          "attributes/restSearch/json",
          Json.obj(
            "request" ->
              Json
                .obj("timestamp" -> publishDate.fold(0L)(_.getTime / 1000), "eventid" -> eventId)
                .when(deletedOnly)(_ + ("deleted" -> JsString("only")))
          )
        )
      )
      // add ("deleted" → 1) to see also deleted attributes
      // add ("deleted" → "only") to see only deleted attributes
      .via(JsonReader.select("$.response.Attribute[*]"))
      .mapConcat { data =>
        val maybeAttribute = Try(Json.parse(data.toArray[Byte]).as[Attribute])
        maybeAttribute.fold(error => { logger.warn(s"Attribute has invalid format: ${data.decodeString("UTF-8")}", error); Nil }, List(_))
      }
      .mapAsyncUnordered(2) {
        case attribute @ Attribute(id, "malware-sample" | "attachment", _, _, _, _, _, _, _, None, _, _, _, _) =>
          // TODO need to unzip malware samples ?
          downloadAttachment(id)
            .map {
              case (filename, contentType, src) => attribute.copy(data = Some((filename, contentType, src)))
            }
            .recover { case _ => attribute }
        case attribute => Future.successful(attribute)
      }
      .mapMaterializedValue(_ => NotUsed)
  }

  private val fileNameExtractor = """attachment; filename="(.*)"""".r

  def downloadAttachment(attachmentId: String)(implicit ec: ExecutionContext): Future[(String, String, Source[ByteString, _])] =
    request(s"attributes/download/$attachmentId").stream().transform {
      case Success(r) if r.status == Status.OK =>
        val filename = r
          .headers
          .get("Content-Disposition")
          .flatMap(_.collectFirst { case fileNameExtractor(name) => name })
          .getOrElse("noname")
        val contentType = r.headers.get("Content-Type").flatMap(_.headOption).getOrElse("application/octet-stream")
        Success((filename, contentType, r.bodyAsSource))
      case Success(r) => Failure(ApplicationError(r))
      case Failure(t) => throw t
    }

  def uploadAttachment(eventId: String, comment: String, filename: String, data: Source[ByteString, _])(implicit
      ec: ExecutionContext
  ): Future[JsValue] = {
    val stream = data
      .via(Base64Flow.encode())
      .intersperse(
        ByteString(
          s"""{"request":{"category":"Payload delivery","type":"malware-sample","comment":${JsString(
            comment
          ).toString},"files":[{"filename":${JsString(
            filename
          ).toString},"data":""""
        ),
        ByteString.empty,
        ByteString(""""}]}}""")
      )
    post(s"events/upload_sample/$eventId", stream)
  }

  def createEvent(
      info: String,
      date: Date,
      threatLevel: Int,
      published: Boolean,
      analysis: Int,
      distribution: Int,
      attributes: Seq[Attribute],
      tags: Seq[Tag],
      extendsEvent: Option[String] = None
  )(implicit ec: ExecutionContext): Future[String] = {
    logger.debug(s"Create MISP event $info, with ${attributes.size} attributes")

    val (stringAttributes, fileAttribtutes) = attributes.partition(_.data.isEmpty)
    val event = Json.obj(
      "Event" -> Json.obj(
        "date"            -> Event.simpleDateFormat.format(date),
        "threat_level_id" -> threatLevel.toString,
        "info"            -> info,
        "published"       -> published,
        "analysis"        -> analysis.toString,
        "distribution"    -> distribution,
        "Attribute"       -> stringAttributes,
        "Tag"             -> tags,
        "extends_uuid"    -> extendsEvent
      )
    )
    post("events", event)
      .map { e =>
        (e \ "Event" \ "id").as[String]
      }
      .flatMap { eventId =>
        Future
          .traverse(fileAttribtutes) { attr =>
            uploadAttachment(eventId, attr.comment.getOrElse(attr.value), attr.value, attr.data.get._3)
          }
          .map(_ => eventId)
      }
  }
}

```

`misp/client/src/main/scala/org/thp/misp/dto/Attribute.scala`:

```scala
package org.thp.misp.dto

import akka.stream.scaladsl.Source
import akka.util.ByteString
import play.api.libs.functional.syntax._
import play.api.libs.json.{JsPath, Json, OWrites, Reads}

import java.util.{Base64, Date}

case class Attribute(
    id: String,
    `type`: String,
    category: String,
    toIds: Boolean,
    eventId: String,
    distribution: Int,
    date: Date,
    comment: Option[String],
    deleted: Boolean,
    data: Option[(String, String, Source[ByteString, _])],
    value: String, // TODO need check: option for attachment ?
    firstSeen: Option[Date],
    lastSeen: Option[Date],
    tags: Seq[Tag]
)

object Attribute {

  def parseDate(s: String): Date =
    javax.xml.bind.DatatypeConverter.parseDateTime(s).getTime

  implicit val reads: Reads[Attribute] =
    ((JsPath \ "id").read[String] and
      (JsPath \ "type").read[String] and
      (JsPath \ "category").read[String] and
      (JsPath \ "to_ids").read[Boolean] and
      (JsPath \ "event_id").read[String] and
      (JsPath \ "distribution").read[String].map(_.toInt) and
      (JsPath \ "timestamp").read[String].map(t => new Date(t.toLong * 1000)) and
      (JsPath \ "comment").readNullable[String] and
      (JsPath \ "deleted").read[Boolean] and
      (JsPath \ "data").readNullable[String].map(_.map(s => ("", "", Source.single(ByteString(Base64.getDecoder.decode(s)))))) and // TODO need check
      (JsPath \ "value").read[String] and
      (JsPath \ "first_seen").readNullable[String].map(_.map(parseDate)) and //"2019-06-02T22:14:28.711954+00:00"
      (JsPath \ "last_seen").readNullable[String].map(_.map(parseDate)) and
      (JsPath \ "Tag").readWithDefault[Seq[Tag]](Nil))(Attribute.apply _)

  implicit val writes: OWrites[Attribute] = OWrites[Attribute] { attribute =>
    Json.obj(
      "category" -> attribute.category,
      "type"     -> attribute.`type`,
      "value"    -> attribute.value,
      "comment"  -> attribute.comment,
      "Tag"      -> attribute.tags
    )
  }
}

```

`misp/client/src/main/scala/org/thp/misp/dto/Event.scala`:

```scala
package org.thp.misp.dto

import play.api.libs.functional.syntax._
import play.api.libs.json._

import java.util.Date

case class Event(
    id: String,
    published: Boolean,
    info: String,
    threatLevel: Option[Int], // from string
    analysis: Option[Int],    // from String
    date: Date,
    publishDate: Date,
    org: String,
    orgc: String,
    attributeCount: Option[Int],
    distribution: Int,
    attributes: Seq[Attribute],
    tags: Seq[Tag]
)

object Event {

  import java.text.SimpleDateFormat

  val simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd")
  implicit val reads: Reads[Event] =
    ((JsPath \ "id").read[String] and
      (JsPath \ "published").read[Boolean] and
      (JsPath \ "info").read[String] and
      (JsPath \ "threat_level_id").readNullable[String].map(_.map(_.toInt)) and
      (JsPath \ "analysis").readNullable[String].map(_.map(_.toInt)) and
      (JsPath \ "date").read[String].map(simpleDateFormat.parse) and
      (JsPath \ "publish_timestamp").read[String].map(t => new Date(t.toLong * 1000)) and
      (JsPath \ "Org" \ "name").read[String] and
      (JsPath \ "Orgc" \ "name").read[String] and
      (JsPath \ "attribute_count").readNullable[String].map(_.map(_.toInt)) and
      (JsPath \ "distribution").read[String].map(_.toInt) and
      (JsPath \ "attributes").readWithDefault[Seq[Attribute]](Nil) and
      (JsPath \ "EventTag").read[Seq[JsObject]].map(_.map(eventTag => (eventTag \ "Tag").as[Tag])))(Event.apply _)

  implicit val writes: OWrites[Event] = OWrites[Event] { event =>
    Json.obj(
      "distribution"    -> event.distribution,
      "threat_level_id" -> event.threatLevel,
      "analysis"        -> event.analysis,
      "info"            -> event.info,
      "date"            -> simpleDateFormat.format(event.date),
      "published"       -> false,
      "Tag"             -> event.tags.map(t => JsString(t.name))
    )
  }
}

```

`misp/client/src/main/scala/org/thp/misp/dto/Organisation.scala`:

```scala
package org.thp.misp.dto

import play.api.libs.json.{Json, Reads}

import java.util.UUID

case class Organisation(id: String, name: String, description: Option[String], uuid: UUID)

object Organisation {
  implicit val reads: Reads[Organisation] = Json.reads[Organisation]
}

```

`misp/client/src/main/scala/org/thp/misp/dto/Tag.scala`:

```scala
package org.thp.misp.dto

import play.api.libs.functional.syntax._
import play.api.libs.json._

case class Tag(
    id: Option[String],
    name: String,
    colour: Option[String],
    exportable: Option[Boolean]
)

object Tag {
  implicit val reads: Reads[Tag] =
    ((JsPath \ "id").readNullable[String] and
      (JsPath \ "name").read[String] and
      (JsPath \ "colour").readNullable[String] and
      (JsPath \ "exportable").readNullable[Boolean])(Tag.apply _)

  implicit val writes: Writes[Tag] = Json.writes[Tag]
}

```

`misp/client/src/main/scala/org/thp/misp/dto/User.scala`:

```scala
package org.thp.misp.dto

import play.api.libs.functional.syntax._
import play.api.libs.json.{JsPath, Reads}

case class User(id: String, orgId: String, email: String)

object User {
  implicit val reads: Reads[User] =
    ((JsPath \ "id").read[String] and
      (JsPath \ "org_id").read[String] and
      (JsPath \ "email").read[String])(User.apply _)
}

```

`misp/connector/src/main/resources/play/reference-overrides.conf`:

```conf
akka.actor {
  serializers {
    misp = "org.thp.thehive.connector.misp.services.MispSerializer"
  }

  serialization-bindings {
    "org.thp.thehive.connector.misp.services.MispMessage" = misp
  }
}

```

`misp/connector/src/main/resources/reference.conf`:

```conf
misp {
  checkStatusInterval = 5 minutes
  syncInterval = 1 hour
  syncInitialDelay = 15 minutes
  servers = []
  attribute.mapping = [
    {mispCategory: "Antivirus detection", mispType: "link", type: "url", tags: ["misp.category=\"Antivirus detection\"", "misp.type=\"link\""]},
    # {mispCategory: "Antivirus detection", mispType: "comment", type: "other", tags: ["misp.category=\"Antivirus detection\"", "misp.type=\"comment\""]},
    # {mispCategory: "Antivirus detection", mispType: "text", type: "other", tags: ["misp.category=\"Antivirus detection\"", "misp.type=\"text\""]},
    # {mispCategory: "Antivirus detection", mispType: "hex", type: "other", tags: ["misp.category=\"Antivirus detection\"", "misp.type=\"hex\""]},
    {mispCategory: "Antivirus detection", mispType: "attachment", type: "file", tags: ["misp.category=\"Antivirus detection\"", "misp.type=\"attachment\""]},
    # {mispCategory: "Antivirus detection", mispType: "other", type: "other", tags: ["misp.category=\"Antivirus detection\"", "misp.type=\"other\""]},
    # {mispCategory: "Antivirus detection", mispType: "anonymised", type: "other", tags: ["misp.category=\"Antivirus detection\"", "misp.type=\"anonymised\""]},
    {mispCategory: "Artifacts dropped", mispType: "md5", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"md5\""]},
    {mispCategory: "Artifacts dropped", mispType: "sha1", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"sha1\""]},
    {mispCategory: "Artifacts dropped", mispType: "sha224", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"sha224\""]},
    {mispCategory: "Artifacts dropped", mispType: "sha256", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"sha256\""]},
    {mispCategory: "Artifacts dropped", mispType: "sha384", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"sha384\""]},
    {mispCategory: "Artifacts dropped", mispType: "sha512", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"sha512\""]},
    {mispCategory: "Artifacts dropped", mispType: "sha512/224", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"sha512/224\""]},
    {mispCategory: "Artifacts dropped", mispType: "sha512/256", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"sha512/256\""]},
    {mispCategory: "Artifacts dropped", mispType: "ssdeep", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"ssdeep\""]},
    {mispCategory: "Artifacts dropped", mispType: "imphash", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"imphash\""]},
    {mispCategory: "Artifacts dropped", mispType: "impfuzzy", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"impfuzzy\""]},
    {mispCategory: "Artifacts dropped", mispType: "authentihash", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"authentihash\""]},
    {mispCategory: "Artifacts dropped", mispType: "cdhash", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"cdhash\""]},
    {mispCategory: "Artifacts dropped", mispType: "filename", type: "filename", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"filename\""]},
    {mispCategory: "Artifacts dropped", mispType: "regkey", type: "registry", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"regkey\""]},
    # {mispCategory: "Artifacts dropped", mispType: "pattern-in-file", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"pattern-in-file\""]},
    # {mispCategory: "Artifacts dropped", mispType: "pattern-in-memory", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"pattern-in-memory\""]},
    # {mispCategory: "Artifacts dropped", mispType: "pdb", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"pdb\""]},
    # {mispCategory: "Artifacts dropped", mispType: "stix2-pattern", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"stix2-pattern\""]},
    # {mispCategory: "Artifacts dropped", mispType: "yara", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"yara\""]},
    # {mispCategory: "Artifacts dropped", mispType: "sigma", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"sigma\""]},
    {mispCategory: "Artifacts dropped", mispType: "attachment", type: "file", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"attachment\""]},
    {mispCategory: "Artifacts dropped", mispType: "malware-sample", type: "file", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"malware-sample\""]},
    # {mispCategory: "Artifacts dropped", mispType: "named pipe", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"named pipe\""]},
    # {mispCategory: "Artifacts dropped", mispType: "mutex", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"mutex\""]},
    # {mispCategory: "Artifacts dropped", mispType: "windows-scheduled-task", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"windows-scheduled-task\""]},
    # {mispCategory: "Artifacts dropped", mispType: "windows-service-name", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"windows-service-name\""]},
    # {mispCategory: "Artifacts dropped", mispType: "windows-service-displayname", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"windows-service-displayname\""]},
    # {mispCategory: "Artifacts dropped", mispType: "comment", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"comment\""]},
    # {mispCategory: "Artifacts dropped", mispType: "text", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"text\""]},
    # {mispCategory: "Artifacts dropped", mispType: "hex", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"hex\""]},
    {mispCategory: "Artifacts dropped", mispType: "x509-fingerprint-sha1", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"x509-fingerprint-sha1\""]},
    {mispCategory: "Artifacts dropped", mispType: "x509-fingerprint-md5", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"x509-fingerprint-md5\""]},
    {mispCategory: "Artifacts dropped", mispType: "x509-fingerprint-sha256", type: "hash", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"x509-fingerprint-sha256\""]},
    # {mispCategory: "Artifacts dropped", mispType: "other", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"other\""]},
    # {mispCategory: "Artifacts dropped", mispType: "cookie", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"cookie\""]},
    # {mispCategory: "Artifacts dropped", mispType: "gene", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"gene\""]},
    # {mispCategory: "Artifacts dropped", mispType: "mime-type", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"mime-type\""]},
    # {mispCategory: "Artifacts dropped", mispType: "anonymised", type: "other", tags: ["misp.category=\"Artifacts dropped\"", "misp.type=\"anonymised\""]},
    # {mispCategory: "Attribution", mispType: "threat-actor", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"threat-actor\""]},
    # {mispCategory: "Attribution", mispType: "campaign-name", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"campaign-name\""]},
    # {mispCategory: "Attribution", mispType: "campaign-id", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"campaign-id\""]},
    # {mispCategory: "Attribution", mispType: "whois-registrant-phone", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"whois-registrant-phone\""]},
    # {mispCategory: "Attribution", mispType: "whois-registrant-email", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"whois-registrant-email\""]},
    # {mispCategory: "Attribution", mispType: "whois-registrant-name", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"whois-registrant-name\""]},
    # {mispCategory: "Attribution", mispType: "whois-registrant-org", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"whois-registrant-org\""]},
    # {mispCategory: "Attribution", mispType: "whois-registrar", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"whois-registrar\""]},
    # {mispCategory: "Attribution", mispType: "whois-creation-date", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"whois-creation-date\""]},
    # {mispCategory: "Attribution", mispType: "comment", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"comment\""]},
    # {mispCategory: "Attribution", mispType: "text", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"text\""]},
    {mispCategory: "Attribution", mispType: "x509-fingerprint-sha1", type: "hash", tags: ["misp.category=\"Attribution\"", "misp.type=\"x509-fingerprint-sha1\""]},
    {mispCategory: "Attribution", mispType: "x509-fingerprint-md5", type: "hash", tags: ["misp.category=\"Attribution\"", "misp.type=\"x509-fingerprint-md5\""]},
    {mispCategory: "Attribution", mispType: "x509-fingerprint-sha256", type: "hash", tags: ["misp.category=\"Attribution\"", "misp.type=\"x509-fingerprint-sha256\""]},
    # {mispCategory: "Attribution", mispType: "other", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"other\""]},
    # {mispCategory: "Attribution", mispType: "dns-soa-email", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"dns-soa-email\""]},
    # {mispCategory: "Attribution", mispType: "anonymised", type: "other", tags: ["misp.category=\"Attribution\"", "misp.type=\"anonymised\""]},
    {mispCategory: "External analysis", mispType: "md5", type: "hash", tags: ["misp.category=\"External analysis\"", "misp.type=\"md5\""]},
    {mispCategory: "External analysis", mispType: "sha1", type: "hash", tags: ["misp.category=\"External analysis\"", "misp.type=\"sha1\""]},
    {mispCategory: "External analysis", mispType: "sha256", type: "hash", tags: ["misp.category=\"External analysis\"", "misp.type=\"sha256\""]},
    {mispCategory: "External analysis", mispType: "filename", type: "filename", tags: ["misp.category=\"External analysis\"", "misp.type=\"filename\""]},
    {mispCategory: "External analysis", mispType: "ip-src", type: "ip", tags: ["misp.category=\"External analysis\"", "misp.type=\"ip-src\""]},
    {mispCategory: "External analysis", mispType: "ip-dst", type: "ip", tags: ["misp.category=\"External analysis\"", "misp.type=\"ip-dst\""]},
    # {mispCategory: "External analysis", mispType: "mac-address", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"mac-address\""]},
    # {mispCategory: "External analysis", mispType: "mac-eui-64", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"mac-eui-64\""]},
    {mispCategory: "External analysis", mispType: "hostname", type: "hostname", tags: ["misp.category=\"External analysis\"", "misp.type=\"hostname\""]},
    {mispCategory: "External analysis", mispType: "domain", type: "domain", tags: ["misp.category=\"External analysis\"", "misp.type=\"domain\""]},
    {mispCategory: "External analysis", mispType: "url", type: "url", tags: ["misp.category=\"External analysis\"", "misp.type=\"url\""]},
    # {mispCategory: "External analysis", mispType: "user-agent", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"user-agent\""]},
    {mispCategory: "External analysis", mispType: "regkey", type: "registry", tags: ["misp.category=\"External analysis\"", "misp.type=\"regkey\""]},
    {mispCategory: "External analysis", mispType: "AS", type: "autonomous-system", tags: ["misp.category=\"External analysis\"", "misp.type=\"AS\""]},
    # {mispCategory: "External analysis", mispType: "snort", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"snort\""]},
    # {mispCategory: "External analysis", mispType: "bro", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"bro\""]},
    # {mispCategory: "External analysis", mispType: "zeek", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"zeek\""]},
    # {mispCategory: "External analysis", mispType: "pattern-in-file", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"pattern-in-file\""]},
    # {mispCategory: "External analysis", mispType: "pattern-in-traffic", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"pattern-in-traffic\""]},
    # {mispCategory: "External analysis", mispType: "pattern-in-memory", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"pattern-in-memory\""]},
    # {mispCategory: "External analysis", mispType: "vulnerability", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"vulnerability\""]},
    # {mispCategory: "External analysis", mispType: "weakness", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"weakness\""]},
    {mispCategory: "External analysis", mispType: "attachment", type: "file", tags: ["misp.category=\"External analysis\"", "misp.type=\"attachment\""]},
    {mispCategory: "External analysis", mispType: "malware-sample", type: "file", tags: ["misp.category=\"External analysis\"", "misp.type=\"malware-sample\""]},
    {mispCategory: "External analysis", mispType: "link", type: "url", tags: ["misp.category=\"External analysis\"", "misp.type=\"link\""]},
    # {mispCategory: "External analysis", mispType: "comment", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"comment\""]},
    # {mispCategory: "External analysis", mispType: "text", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"text\""]},
    {mispCategory: "External analysis", mispType: "x509-fingerprint-sha1", type: "hash", tags: ["misp.category=\"External analysis\"", "misp.type=\"x509-fingerprint-sha1\""]},
    {mispCategory: "External analysis", mispType: "x509-fingerprint-md5", type: "hash", tags: ["misp.category=\"External analysis\"", "misp.type=\"x509-fingerprint-md5\""]},
    {mispCategory: "External analysis", mispType: "x509-fingerprint-sha256", type: "hash", tags: ["misp.category=\"External analysis\"", "misp.type=\"x509-fingerprint-sha256\""]},
    {mispCategory: "External analysis", mispType: "ja3-fingerprint-md5", type: "hash", tags: ["misp.category=\"External analysis\"", "misp.type=\"ja3-fingerprint-md5\""]},
    {mispCategory: "External analysis", mispType: "hassh-md5", type: "hash", tags: ["misp.category=\"External analysis\"", "misp.type=\"hassh-md5\""]},
    {mispCategory: "External analysis", mispType: "hasshserver-md5", type: "hash", tags: ["misp.category=\"External analysis\"", "misp.type=\"hasshserver-md5\""]},
    # {mispCategory: "External analysis", mispType: "github-repository", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"github-repository\""]},
    # {mispCategory: "External analysis", mispType: "other", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"other\""]},
    # {mispCategory: "External analysis", mispType: "cortex", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"cortex\""]},
    # {mispCategory: "External analysis", mispType: "anonymised", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"anonymised\""]},
    # {mispCategory: "External analysis", mispType: "community-id", type: "other", tags: ["misp.category=\"External analysis\"", "misp.type=\"community-id\""]},
    # {mispCategory: "Financial fraud", mispType: "btc", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"btc\""]},
    # {mispCategory: "Financial fraud", mispType: "xmr", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"xmr\""]},
    # {mispCategory: "Financial fraud", mispType: "iban", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"iban\""]},
    # {mispCategory: "Financial fraud", mispType: "bic", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"bic\""]},
    # {mispCategory: "Financial fraud", mispType: "bank-account-nr", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"bank-account-nr\""]},
    # {mispCategory: "Financial fraud", mispType: "aba-rtn", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"aba-rtn\""]},
    # {mispCategory: "Financial fraud", mispType: "bin", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"bin\""]},
    # {mispCategory: "Financial fraud", mispType: "cc-number", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"cc-number\""]},
    # {mispCategory: "Financial fraud", mispType: "prtn", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"prtn\""]},
    # {mispCategory: "Financial fraud", mispType: "phone-number", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"phone-number\""]},
    # {mispCategory: "Financial fraud", mispType: "comment", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"comment\""]},
    # {mispCategory: "Financial fraud", mispType: "text", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"text\""]},
    # {mispCategory: "Financial fraud", mispType: "other", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"other\""]},
    # {mispCategory: "Financial fraud", mispType: "hex", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"hex\""]},
    # {mispCategory: "Financial fraud", mispType: "anonymised", type: "other", tags: ["misp.category=\"Financial fraud\"", "misp.type=\"anonymised\""]},
    # {mispCategory: "Internal reference", mispType: "text", type: "other", tags: ["misp.category=\"Internal reference\"", "misp.type=\"text\""]},
    {mispCategory: "Internal reference", mispType: "link", type: "url", tags: ["misp.category=\"Internal reference\"", "misp.type=\"link\""]},
    # {mispCategory: "Internal reference", mispType: "comment", type: "other", tags: ["misp.category=\"Internal reference\"", "misp.type=\"comment\""]},
    # {mispCategory: "Internal reference", mispType: "other", type: "other", tags: ["misp.category=\"Internal reference\"", "misp.type=\"other\""]},
    # {mispCategory: "Internal reference", mispType: "hex", type: "other", tags: ["misp.category=\"Internal reference\"", "misp.type=\"hex\""]},
    # {mispCategory: "Internal reference", mispType: "anonymised", type: "other", tags: ["misp.category=\"Internal reference\"", "misp.type=\"anonymised\""]},
    {mispCategory: "Network activity", mispType: "ip-src", type: "ip", tags: ["misp.category=\"Network activity\"", "misp.type=\"ip-src\""]},
    {mispCategory: "Network activity", mispType: "ip-dst", type: "ip", tags: ["misp.category=\"Network activity\"", "misp.type=\"ip-dst\""]},
    # {mispCategory: "Network activity", mispType: "port", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"port\""]},
    # {mispCategory: "Network activity", mispType: "hostname", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"hostname\""]},
    {mispCategory: "Network activity", mispType: "domain", type: "domain", tags: ["misp.category=\"Network activity\"", "misp.type=\"domain\""]},
    # {mispCategory: "Network activity", mispType: "mac-address", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"mac-address\""]},
    # {mispCategory: "Network activity", mispType: "mac-eui-64", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"mac-eui-64\""]},
    # {mispCategory: "Network activity", mispType: "email-dst", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"email-dst\""]},
    {mispCategory: "Network activity", mispType: "url", type: "url", tags: ["misp.category=\"Network activity\"", "misp.type=\"url\""]},
    {mispCategory: "Network activity", mispType: "uri", type: "url", tags: ["misp.category=\"Network activity\"", "misp.type=\"uri\""]},
    # {mispCategory: "Network activity", mispType: "user-agent", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"user-agent\""]},
    # {mispCategory: "Network activity", mispType: "http-method", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"http-method\""]},
    {mispCategory: "Network activity", mispType: "AS", type: "autonomous-system", tags: ["misp.category=\"Network activity\"", "misp.type=\"AS\""]},
    # {mispCategory: "Network activity", mispType: "snort", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"snort\""]},
    # {mispCategory: "Network activity", mispType: "pattern-in-file", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"pattern-in-file\""]},
    # {mispCategory: "Network activity", mispType: "stix2-pattern", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"stix2-pattern\""]},
    # {mispCategory: "Network activity", mispType: "pattern-in-traffic", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"pattern-in-traffic\""]},
    {mispCategory: "Network activity", mispType: "attachment", type: "file", tags: ["misp.category=\"Network activity\"", "misp.type=\"attachment\""]},
    # {mispCategory: "Network activity", mispType: "comment", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"comment\""]},
    # {mispCategory: "Network activity", mispType: "text", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"text\""]},
    {mispCategory: "Network activity", mispType: "x509-fingerprint-md5", type: "hash", tags: ["misp.category=\"Network activity\"", "misp.type=\"x509-fingerprint-md5\""]},
    {mispCategory: "Network activity", mispType: "x509-fingerprint-sha1", type: "hash", tags: ["misp.category=\"Network activity\"", "misp.type=\"x509-fingerprint-sha1\""]},
    {mispCategory: "Network activity", mispType: "x509-fingerprint-sha256", type: "hash", tags: ["misp.category=\"Network activity\"", "misp.type=\"x509-fingerprint-sha256\""]},
    {mispCategory: "Network activity", mispType: "ja3-fingerprint-md5", type: "hash", tags: ["misp.category=\"Network activity\"", "misp.type=\"ja3-fingerprint-md5\""]},
    {mispCategory: "Network activity", mispType: "hassh-md5", type: "hash", tags: ["misp.category=\"Network activity\"", "misp.type=\"hassh-md5\""]},
    {mispCategory: "Network activity", mispType: "hasshserver-md5", type: "hash", tags: ["misp.category=\"Network activity\"", "misp.type=\"hasshserver-md5\""]},
    # {mispCategory: "Network activity", mispType: "other", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"other\""]},
    # {mispCategory: "Network activity", mispType: "hex", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"hex\""]},
    # {mispCategory: "Network activity", mispType: "cookie", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"cookie\""]},
    # {mispCategory: "Network activity", mispType: "bro", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"bro\""]},
    # {mispCategory: "Network activity", mispType: "zeek", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"zeek\""]},
    # {mispCategory: "Network activity", mispType: "anonymised", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"anonymised\""]},
    # {mispCategory: "Network activity", mispType: "community-id", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"community-id\""]},
    # {mispCategory: "Network activity", mispType: "email-subject", type: "other", tags: ["misp.category=\"Network activity\"", "misp.type=\"email-subject\""]},
    # {mispCategory: "Other", mispType: "comment", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"comment\""]},
    # {mispCategory: "Other", mispType: "text", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"text\""]},
    # {mispCategory: "Other", mispType: "other", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"other\""]},
    # {mispCategory: "Other", mispType: "size-in-bytes", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"size-in-bytes\""]},
    # {mispCategory: "Other", mispType: "counter", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"counter\""]},
    # {mispCategory: "Other", mispType: "datetime", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"datetime\""]},
    # {mispCategory: "Other", mispType: "cpe", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"cpe\""]},
    # {mispCategory: "Other", mispType: "port", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"port\""]},
    # {mispCategory: "Other", mispType: "float", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"float\""]},
    # {mispCategory: "Other", mispType: "hex", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"hex\""]},
    # {mispCategory: "Other", mispType: "phone-number", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"phone-number\""]},
    # {mispCategory: "Other", mispType: "boolean", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"boolean\""]},
    # {mispCategory: "Other", mispType: "anonymised", type: "other", tags: ["misp.category=\"Other\"", "misp.type=\"anonymised\""]},
    {mispCategory: "Payload delivery", mispType: "md5", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"md5\""]},
    {mispCategory: "Payload delivery", mispType: "sha1", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"sha1\""]},
    {mispCategory: "Payload delivery", mispType: "sha224", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"sha224\""]},
    {mispCategory: "Payload delivery", mispType: "sha256", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"sha256\""]},
    {mispCategory: "Payload delivery", mispType: "sha384", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"sha384\""]},
    {mispCategory: "Payload delivery", mispType: "sha512", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"sha512\""]},
    {mispCategory: "Payload delivery", mispType: "sha512/224", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"sha512/224\""]},
    {mispCategory: "Payload delivery", mispType: "sha512/256", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"sha512/256\""]},
    {mispCategory: "Payload delivery", mispType: "ssdeep", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"ssdeep\""]},
    {mispCategory: "Payload delivery", mispType: "imphash", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"imphash\""]},
    {mispCategory: "Payload delivery", mispType: "impfuzzy", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"impfuzzy\""]},
    {mispCategory: "Payload delivery", mispType: "authentihash", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"authentihash\""]},
    {mispCategory: "Payload delivery", mispType: "pehash", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"pehash\""]},
    {mispCategory: "Payload delivery", mispType: "tlsh", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"tlsh\""]},
    {mispCategory: "Payload delivery", mispType: "cdhash", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"cdhash\""]},
    {mispCategory: "Payload delivery", mispType: "filename", type: "filename", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"filename\""]},
    # {mispCategory: "Payload delivery", mispType: "mac-address", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"mac-address\""]},
    # {mispCategory: "Payload delivery", mispType: "mac-eui-64", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"mac-eui-64\""]},
    {mispCategory: "Payload delivery", mispType: "ip-src", type: "ip", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"ip-src\""]},
    {mispCategory: "Payload delivery", mispType: "ip-dst", type: "ip", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"ip-dst\""]},
    {mispCategory: "Payload delivery", mispType: "hostname", type: "hostname", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"hostname\""]},
    {mispCategory: "Payload delivery", mispType: "domain", type: "domain", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"domain\""]},
    {mispCategory: "Payload delivery", mispType: "email-src", type: "mail", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-src\""]},
    {mispCategory: "Payload delivery", mispType: "email-dst", type: "mail", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-dst\""]},
    {mispCategory: "Payload delivery", mispType: "email-subject", type: "mail-subject", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-subject\""]},
    # {mispCategory: "Payload delivery", mispType: "email-attachment", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-attachment\""]},
    # {mispCategory: "Payload delivery", mispType: "email-body", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-body\""]},
    {mispCategory: "Payload delivery", mispType: "url", type: "url", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"url\""]},
    # {mispCategory: "Payload delivery", mispType: "user-agent", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"user-agent\""]},
    {mispCategory: "Payload delivery", mispType: "AS", type: "autonomous-system", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"AS\""]},
    # {mispCategory: "Payload delivery", mispType: "pattern-in-file", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"pattern-in-file\""]},
    # {mispCategory: "Payload delivery", mispType: "pattern-in-traffic", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"pattern-in-traffic\""]},
    # {mispCategory: "Payload delivery", mispType: "stix2-pattern", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"stix2-pattern\""]},
    # {mispCategory: "Payload delivery", mispType: "yara", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"yara\""]},
    # {mispCategory: "Payload delivery", mispType: "sigma", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"sigma\""]},
    # {mispCategory: "Payload delivery", mispType: "mime-type", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"mime-type\""]},
    {mispCategory: "Payload delivery", mispType: "attachment", type: "file", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"attachment\""]},
    {mispCategory: "Payload delivery", mispType: "malware-sample", type: "file", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"malware-sample\""]},
    {mispCategory: "Payload delivery", mispType: "link", type: "url", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"link\""]},
    # {mispCategory: "Payload delivery", mispType: "malware-type", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"malware-type\""]},
    # {mispCategory: "Payload delivery", mispType: "comment", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"comment\""]},
    # {mispCategory: "Payload delivery", mispType: "text", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"text\""]},
    # {mispCategory: "Payload delivery", mispType: "hex", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"hex\""]},
    # {mispCategory: "Payload delivery", mispType: "vulnerability", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"vulnerability\""]},
    # {mispCategory: "Payload delivery", mispType: "weakness", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"weakness\""]},
    {mispCategory: "Payload delivery", mispType: "x509-fingerprint-sha1", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"x509-fingerprint-sha1\""]},
    {mispCategory: "Payload delivery", mispType: "x509-fingerprint-md5", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"x509-fingerprint-md5\""]},
    {mispCategory: "Payload delivery", mispType: "x509-fingerprint-sha256", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"x509-fingerprint-sha256\""]},
    {mispCategory: "Payload delivery", mispType: "ja3-fingerprint-md5", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"ja3-fingerprint-md5\""]},
    {mispCategory: "Payload delivery", mispType: "hassh-md5", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"hassh-md5\""]},
    {mispCategory: "Payload delivery", mispType: "hasshserver-md5", type: "hash", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"hasshserver-md5\""]},
    # {mispCategory: "Payload delivery", mispType: "other", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"other\""]},
    # {mispCategory: "Payload delivery", mispType: "email-dst-display-name", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-dst-display-name\""]},
    # {mispCategory: "Payload delivery", mispType: "email-src-display-name", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-src-display-name\""]},
    # {mispCategory: "Payload delivery", mispType: "email-header", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-header\""]},
    # {mispCategory: "Payload delivery", mispType: "email-reply-to", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-reply-to\""]},
    # {mispCategory: "Payload delivery", mispType: "email-x-mailer", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-x-mailer\""]},
    # {mispCategory: "Payload delivery", mispType: "email-mime-boundary", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-mime-boundary\""]},
    # {mispCategory: "Payload delivery", mispType: "email-thread-index", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-thread-index\""]},
    # {mispCategory: "Payload delivery", mispType: "email-message-id", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"email-message-id\""]},
    # {mispCategory: "Payload delivery", mispType: "mobile-application-id", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"mobile-application-id\""]},
    {mispCategory: "Payload delivery", mispType: "whois-registrant-email", type: "mail", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"whois-registrant-email\""]},
    # {mispCategory: "Payload delivery", mispType: "anonymised", type: "other", tags: ["misp.category=\"Payload delivery\"", "misp.type=\"anonymised\""]},
    {mispCategory: "Payload installation", mispType: "md5", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"md5\""]},
    {mispCategory: "Payload installation", mispType: "sha1", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"sha1\""]},
    {mispCategory: "Payload installation", mispType: "sha224", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"sha224\""]},
    {mispCategory: "Payload installation", mispType: "sha256", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"sha256\""]},
    {mispCategory: "Payload installation", mispType: "sha384", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"sha384\""]},
    {mispCategory: "Payload installation", mispType: "sha512", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"sha512\""]},
    {mispCategory: "Payload installation", mispType: "sha512/224", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"sha512/224\""]},
    {mispCategory: "Payload installation", mispType: "sha512/256", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"sha512/256\""]},
    {mispCategory: "Payload installation", mispType: "ssdeep", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"ssdeep\""]},
    {mispCategory: "Payload installation", mispType: "imphash", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"imphash\""]},
    {mispCategory: "Payload installation", mispType: "impfuzzy", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"impfuzzy\""]},
    {mispCategory: "Payload installation", mispType: "authentihash", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"authentihash\""]},
    {mispCategory: "Payload installation", mispType: "pehash", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"pehash\""]},
    {mispCategory: "Payload installation", mispType: "tlsh", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"tlsh\""]},
    {mispCategory: "Payload installation", mispType: "cdhash", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"cdhash\""]},
    {mispCategory: "Payload installation", mispType: "filename", type: "filename", tags: ["misp.category=\"Payload installation\"", "misp.type=\"filename\""]},
    # {mispCategory: "Payload installation", mispType: "pattern-in-file", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"pattern-in-file\""]},
    # {mispCategory: "Payload installation", mispType: "pattern-in-traffic", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"pattern-in-traffic\""]},
    # {mispCategory: "Payload installation", mispType: "pattern-in-memory", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"pattern-in-memory\""]},
    # {mispCategory: "Payload installation", mispType: "stix2-pattern", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"stix2-pattern\""]},
    # {mispCategory: "Payload installation", mispType: "yara", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"yara\""]},
    # {mispCategory: "Payload installation", mispType: "sigma", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"sigma\""]},
    # {mispCategory: "Payload installation", mispType: "vulnerability", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"vulnerability\""]},
    # {mispCategory: "Payload installation", mispType: "weakness", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"weakness\""]},
    {mispCategory: "Payload installation", mispType: "attachment", type: "file", tags: ["misp.category=\"Payload installation\"", "misp.type=\"attachment\""]},
    {mispCategory: "Payload installation", mispType: "malware-sample", type: "file", tags: ["misp.category=\"Payload installation\"", "misp.type=\"malware-sample\""]},
    # {mispCategory: "Payload installation", mispType: "malware-type", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"malware-type\""]},
    # {mispCategory: "Payload installation", mispType: "comment", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"comment\""]},
    # {mispCategory: "Payload installation", mispType: "text", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"text\""]},
    # {mispCategory: "Payload installation", mispType: "hex", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"hex\""]},
    {mispCategory: "Payload installation", mispType: "x509-fingerprint-sha1", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"x509-fingerprint-sha1\""]},
    {mispCategory: "Payload installation", mispType: "x509-fingerprint-md5", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"x509-fingerprint-md5\""]},
    {mispCategory: "Payload installation", mispType: "x509-fingerprint-sha256", type: "hash", tags: ["misp.category=\"Payload installation\"", "misp.type=\"x509-fingerprint-sha256\""]},
    # {mispCategory: "Payload installation", mispType: "mobile-application-id", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"mobile-application-id\""]},
    # {mispCategory: "Payload installation", mispType: "other", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"other\""]},
    # {mispCategory: "Payload installation", mispType: "mime-type", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"mime-type\""]},
    # {mispCategory: "Payload installation", mispType: "anonymised", type: "other", tags: ["misp.category=\"Payload installation\"", "misp.type=\"anonymised\""]},
    # {mispCategory: "Payload type", mispType: "comment", type: "other", tags: ["misp.category=\"Payload type\"", "misp.type=\"comment\""]},
    # {mispCategory: "Payload type", mispType: "text", type: "other", tags: ["misp.category=\"Payload type\"", "misp.type=\"text\""]},
    # {mispCategory: "Payload type", mispType: "other", type: "other", tags: ["misp.category=\"Payload type\"", "misp.type=\"other\""]},
    # {mispCategory: "Payload type", mispType: "anonymised", type: "other", tags: ["misp.category=\"Payload type\"", "misp.type=\"anonymised\""]},
    {mispCategory: "Persistence mechanism", mispType: "filename", type: "filename", tags: ["misp.category=\"Persistence mechanism\"", "misp.type=\"filename\""]},
    {mispCategory: "Persistence mechanism", mispType: "regkey", type: "registry", tags: ["misp.category=\"Persistence mechanism\"", "misp.type=\"regkey\""]},
    # {mispCategory: "Persistence mechanism", mispType: "comment", type: "other", tags: ["misp.category=\"Persistence mechanism\"", "misp.type=\"comment\""]},
    # {mispCategory: "Persistence mechanism", mispType: "text", type: "other", tags: ["misp.category=\"Persistence mechanism\"", "misp.type=\"text\""]},
    # {mispCategory: "Persistence mechanism", mispType: "other", type: "other", tags: ["misp.category=\"Persistence mechanism\"", "misp.type=\"other\""]},
    # {mispCategory: "Persistence mechanism", mispType: "hex", type: "other", tags: ["misp.category=\"Persistence mechanism\"", "misp.type=\"hex\""]},
    # {mispCategory: "Persistence mechanism", mispType: "anonymised", type: "other", tags: ["misp.category=\"Persistence mechanism\"", "misp.type=\"anonymised\""]},
    # {mispCategory: "Person", mispType: "first-name", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"first-name\""]},
    # {mispCategory: "Person", mispType: "middle-name", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"middle-name\""]},
    # {mispCategory: "Person", mispType: "last-name", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"last-name\""]},
    # {mispCategory: "Person", mispType: "date-of-birth", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"date-of-birth\""]},
    # {mispCategory: "Person", mispType: "place-of-birth", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"place-of-birth\""]},
    # {mispCategory: "Person", mispType: "gender", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"gender\""]},
    # {mispCategory: "Person", mispType: "passport-number", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"passport-number\""]},
    # {mispCategory: "Person", mispType: "passport-country", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"passport-country\""]},
    # {mispCategory: "Person", mispType: "passport-expiration", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"passport-expiration\""]},
    # {mispCategory: "Person", mispType: "redress-number", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"redress-number\""]},
    # {mispCategory: "Person", mispType: "nationality", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"nationality\""]},
    # {mispCategory: "Person", mispType: "visa-number", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"visa-number\""]},
    # {mispCategory: "Person", mispType: "issue-date-of-the-visa", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"issue-date-of-the-visa\""]},
    # {mispCategory: "Person", mispType: "primary-residence", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"primary-residence\""]},
    # {mispCategory: "Person", mispType: "country-of-residence", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"country-of-residence\""]},
    # {mispCategory: "Person", mispType: "special-service-request", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"special-service-request\""]},
    # {mispCategory: "Person", mispType: "frequent-flyer-number", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"frequent-flyer-number\""]},
    # {mispCategory: "Person", mispType: "travel-details", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"travel-details\""]},
    # {mispCategory: "Person", mispType: "payment-details", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"payment-details\""]},
    # {mispCategory: "Person", mispType: "place-port-of-original-embarkation", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"place-port-of-original-embarkation\""]},
    # {mispCategory: "Person", mispType: "place-port-of-clearance", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"place-port-of-clearance\""]},
    # {mispCategory: "Person", mispType: "place-port-of-onward-foreign-destination", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"place-port-of-onward-foreign-destination\""]},
    # {mispCategory: "Person", mispType: "passenger-name-record-locator-number", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"passenger-name-record-locator-number\""]},
    # {mispCategory: "Person", mispType: "comment", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"comment\""]},
    # {mispCategory: "Person", mispType: "text", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"text\""]},
    # {mispCategory: "Person", mispType: "other", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"other\""]},
    # {mispCategory: "Person", mispType: "phone-number", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"phone-number\""]},
    # {mispCategory: "Person", mispType: "identity-card-number", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"identity-card-number\""]},
    # {mispCategory: "Person", mispType: "anonymised", type: "other", tags: ["misp.category=\"Person\"", "misp.type=\"anonymised\""]},
    # {mispCategory: "Social network", mispType: "github-username", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"github-username\""]},
    # {mispCategory: "Social network", mispType: "github-repository", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"github-repository\""]},
    # {mispCategory: "Social network", mispType: "github-organisation", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"github-organisation\""]},
    # {mispCategory: "Social network", mispType: "jabber-id", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"jabber-id\""]},
    # {mispCategory: "Social network", mispType: "twitter-id", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"twitter-id\""]},
    # {mispCategory: "Social network", mispType: "email-src", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"email-src\""]},
    # {mispCategory: "Social network", mispType: "email-dst", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"email-dst\""]},
    # {mispCategory: "Social network", mispType: "comment", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"comment\""]},
    # {mispCategory: "Social network", mispType: "text", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"text\""]},
    # {mispCategory: "Social network", mispType: "other", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"other\""]},
    # {mispCategory: "Social network", mispType: "whois-registrant-email", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"whois-registrant-email\""]},
    # {mispCategory: "Social network", mispType: "anonymised", type: "other", tags: ["misp.category=\"Social network\"", "misp.type=\"anonymised\""]},
    {mispCategory: "Support Tool", mispType: "link", type: "url", tags: ["misp.category=\"Support Tool\"", "misp.type=\"link\""]},
    # {mispCategory: "Support Tool", mispType: "text", type: "other", tags: ["misp.category=\"Support Tool\"", "misp.type=\"text\""]},
    {mispCategory: "Support Tool", mispType: "attachment", type: "file", tags: ["misp.category=\"Support Tool\"", "misp.type=\"attachment\""]},
    # {mispCategory: "Support Tool", mispType: "comment", type: "other", tags: ["misp.category=\"Support Tool\"", "misp.type=\"comment\""]},
    # {mispCategory: "Support Tool", mispType: "other", type: "other", tags: ["misp.category=\"Support Tool\"", "misp.type=\"other\""]},
    # {mispCategory: "Support Tool", mispType: "hex", type: "other", tags: ["misp.category=\"Support Tool\"", "misp.type=\"hex\""]},
    # {mispCategory: "Support Tool", mispType: "anonymised", type: "other", tags: ["misp.category=\"Support Tool\"", "misp.type=\"anonymised\""]},
    # {mispCategory: "Targeting data", mispType: "target-user", type: "other", tags: ["misp.category=\"Targeting data\"", "misp.type=\"target-user\""]},
    # {mispCategory: "Targeting data", mispType: "target-email", type: "other", tags: ["misp.category=\"Targeting data\"", "misp.type=\"target-email\""]},
    # {mispCategory: "Targeting data", mispType: "target-machine", type: "other", tags: ["misp.category=\"Targeting data\"", "misp.type=\"target-machine\""]},
    # {mispCategory: "Targeting data", mispType: "target-org", type: "other", tags: ["misp.category=\"Targeting data\"", "misp.type=\"target-org\""]},
    # {mispCategory: "Targeting data", mispType: "target-location", type: "other", tags: ["misp.category=\"Targeting data\"", "misp.type=\"target-location\""]},
    # {mispCategory: "Targeting data", mispType: "target-external", type: "other", tags: ["misp.category=\"Targeting data\"", "misp.type=\"target-external\""]},
    # {mispCategory: "Targeting data", mispType: "comment", type: "other", tags: ["misp.category=\"Targeting data\"", "misp.type=\"comment\""]},
    # {mispCategory: "Targeting data", mispType: "anonymised", type: "other", tags: ["misp.category=\"Targeting data\"", "misp.type=\"anonymised\""]},
  ]
}
```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/MispModule.scala`:

```scala
package org.thp.thehive.connector.misp

import akka.actor.{ActorRef, PoisonPill}
import akka.cluster.singleton.{ClusterSingletonManager, ClusterSingletonManagerSettings}
import com.google.inject.AbstractModule
import net.codingwell.scalaguice.{ScalaModule, ScalaMultibinder}
import org.thp.thehive.connector.misp.services.{Connector, MispActor, MispActorProvider}
import org.thp.thehive.services.{Connector => TheHiveConnector}
import play.api.libs.concurrent.AkkaGuiceSupport
import play.api.routing.{Router => PlayRouter}
import play.api.{Configuration, Environment, Logger}

class MispModule(environment: Environment, configuration: Configuration) extends AbstractModule with ScalaModule with AkkaGuiceSupport {
  lazy val logger: Logger = Logger(getClass)

  override def configure(): Unit = {
    val routerBindings = ScalaMultibinder.newSetBinder[PlayRouter](binder)
    routerBindings.addBinding.toProvider[MispRouter]
    val connectorBindings = ScalaMultibinder.newSetBinder[TheHiveConnector](binder)
    connectorBindings.addBinding.to[Connector]

    bindActor[MispActor](
      "misp-actor-singleton",
      props =>
        ClusterSingletonManager
          .props(
            singletonProps = props,
            terminationMessage = PoisonPill,
            settings = ClusterSingletonManagerSettings(configuration.get[Configuration]("akka.cluster.singleton").underlying)
          )
    )
    bind[ActorRef]
      .annotatedWithName("misp-actor")
      .toProvider[MispActorProvider]
    ()
  }
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/MispRouter.scala`:

```scala
package org.thp.thehive.connector.misp

import org.thp.thehive.connector.misp.controllers.v0
import play.api.Logger
import play.api.routing.Router

import javax.inject.{Inject, Provider, Singleton}

@Singleton
class MispRouter @Inject() (routerV0: v0.Router) extends Provider[Router] {

  lazy val logger: Logger = Logger(getClass)

  lazy val get: Router =
    //routerV1.withPrefix("/api/misp/v1/") orElse
    routerV0.withPrefix("/api/connector/misp/")
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/controllers/v0/MispCtrl.scala`:

```scala
package org.thp.thehive.connector.misp.controllers.v0

import akka.actor.ActorRef
import com.google.inject.name.Named
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.Entrypoint
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.connector.misp.services.{MispExportSrv, Synchro}
import org.thp.thehive.models.Permissions
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.{AlertSrv, CaseSrv, OrganisationSrv}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.Success

@Singleton
class MispCtrl @Inject() (
    entrypoint: Entrypoint,
    mispExportSrv: MispExportSrv,
    alertSrv: AlertSrv,
    caseSrv: CaseSrv,
    db: Database,
    organisationSrv: OrganisationSrv,
    @Named("misp-actor") mispActor: ActorRef,
    implicit val ec: ExecutionContext
) {

  def sync: Action[AnyContent] =
    entrypoint("sync MISP events")
      .authPermitted(Permissions.manageOrganisation) { _ =>
        mispActor ! Synchro
        Success(Results.NoContent)
      }

  def exportCase(mispId: String, caseIdOrNumber: String): Action[AnyContent] =
    entrypoint("export case into MISP")
      .asyncAuth { implicit authContext =>
        for {
          c <- Future.fromTry(db.roTransaction { implicit graph =>
            caseSrv
              .get(EntityIdOrName(caseIdOrNumber))
              .can(Permissions.manageShare)
              .getOrFail("Case")
          })
          _ <- mispExportSrv.export(mispId, c)
        } yield Results.NoContent
      }

  def cleanMispAlerts: Action[AnyContent] =
    entrypoint("clean MISP alerts")
      .authTransaction(db) { implicit request => implicit graph =>
        alertSrv
          .startTraversal
          .filterByType("misp")
          .visible(organisationSrv)
          .toIterator
          .toTry(alertSrv.remove(_))
          .map(_ => Results.NoContent)
      }
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/controllers/v0/Router.scala`:

```scala
package org.thp.thehive.connector.misp.controllers.v0

import org.thp.scalligraph.NotFoundError
import play.api.routing.Router.Routes
import play.api.routing.SimpleRouter
import play.api.routing.sird._

import javax.inject.{Inject, Singleton}

@Singleton
class Router @Inject() (mispCtrl: MispCtrl) extends SimpleRouter {

  override val routes: Routes = {
    case GET(p"/_syncAlerts") => mispCtrl.sync
//    case GET(p"/_cleanAlerts") => mispCtrl.cleanMispAlerts
//    case GET(p"/_syncAllAlerts")            => syncAllAlerts
//    case GET(p"/_syncArtifacts")            => syncArtifacts
    case POST(p"/export/$caseId/$mispName") => mispCtrl.exportCase(mispName, caseId)
    case r                                  => throw NotFoundError(s"${r.uri} not found")
  }
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/services/AttributeConverter.scala`:

```scala
package org.thp.thehive.connector.misp.services

import org.thp.scalligraph.EntityName
import play.api.libs.json.{Format, Json}

case class AttributeConverter(mispCategory: String, mispType: String, `type`: EntityName, tags: Seq[String])

object AttributeConverter {
  implicit val format: Format[AttributeConverter] = Json.format[AttributeConverter]
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/services/Connector.scala`:

```scala
package org.thp.thehive.connector.misp.services

import akka.actor.ActorSystem
import akka.stream.Materializer
import org.thp.scalligraph.services.config.ApplicationConfig.finiteDurationFormat
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.thehive.models.HealthStatus
import org.thp.thehive.services.{Connector => TheHiveConnector}
import play.api.libs.json.{JsObject, Json}

import javax.inject.{Inject, Singleton}
import scala.concurrent.duration.FiniteDuration
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class Connector @Inject() (appConfig: ApplicationConfig, system: ActorSystem, mat: Materializer, implicit val ec: ExecutionContext)
    extends TheHiveConnector {
  override val name: String = "misp"

  val clientsConfig: ConfigItem[Seq[TheHiveMispClientConfig], Seq[TheHiveMispClient]] =
    appConfig.mapItem[Seq[TheHiveMispClientConfig], Seq[TheHiveMispClient]]("misp.servers", "", _.map(new TheHiveMispClient(_, mat)))
  def clients: Seq[TheHiveMispClient] = clientsConfig.get

  val attributeConvertersConfig: ConfigItem[Seq[AttributeConverter], Seq[AttributeConverter]] =
    appConfig.item[Seq[AttributeConverter]]("misp.attribute.mapping", "Describe how to map MISP attribute to observable")

  def attributeConverter(attributeCategory: String, attributeType: String): Option[AttributeConverter] =
    attributeConvertersConfig.get.reverseIterator.find(a => a.mispCategory == attributeCategory && a.mispType == attributeType)

  def attributeConverter(observableType: String): Option[(String, String)] =
    attributeConvertersConfig.get.reverseIterator.find(_.`type`.value == observableType).map(a => a.mispCategory -> a.mispType)

  val syncIntervalConfig: ConfigItem[FiniteDuration, FiniteDuration] = appConfig.item[FiniteDuration]("misp.syncInterval", "")
  def syncInterval: FiniteDuration                                   = syncIntervalConfig.get

  val syncInitialDelayConfig: ConfigItem[FiniteDuration, FiniteDuration] = appConfig.item[FiniteDuration]("misp.syncInitialDelay", "")
  val syncInitialDelay: FiniteDuration                                   = syncInitialDelayConfig.get

  val statusCheckIntervalConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("misp.checkStatusInterval", "Interval between two checks of misp status")
  def statusCheckInterval: FiniteDuration = statusCheckIntervalConfig.get

  private var cachedStatus: JsObject = Json.obj("enable" -> true, "status" -> "CHECKING")
  override def status: JsObject      = cachedStatus
  private def updateStatus(): Unit =
    Future
      .traverse(clients)(client => client.getStatus)
      .foreach { statusDetails =>
        val distinctStatus = statusDetails.map(s => (s \ "status").as[String]).toSet
        val healthStatus =
          if (distinctStatus.contains("OK"))
            if (distinctStatus.size > 1) "WARNING" else "OK"
          else "ERROR"
        cachedStatus = Json.obj("enabled" -> true, "servers" -> statusDetails, "status" -> healthStatus)
        system.scheduler.scheduleOnce(statusCheckInterval)(updateStatus())
      }
  updateStatus()

  private var cachedHealth: HealthStatus.Value = HealthStatus.Ok
  override def health: HealthStatus.Value      = cachedHealth
  private def updateHealth(): Unit =
    Future
      .traverse(clients)(_.getHealth)
      .foreach { healthStatus =>
        val distinctStatus = healthStatus.toSet
        cachedHealth =
          if (distinctStatus.contains(HealthStatus.Ok))
            if (distinctStatus.size > 1) HealthStatus.Warning else HealthStatus.Ok
          else if (distinctStatus.contains(HealthStatus.Error)) HealthStatus.Error
          else HealthStatus.Warning

        system.scheduler.scheduleOnce(statusCheckInterval)(updateHealth())
      }
  updateHealth()
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/services/MispActor.scala`:

```scala
package org.thp.thehive.connector.misp.services

import akka.actor.{Actor, ActorRef, ActorSystem, Cancellable}
import akka.cluster.singleton.{ClusterSingletonProxy, ClusterSingletonProxySettings}
import play.api.Logger

import javax.inject.{Inject, Named, Provider}

sealed trait MispMessage
case object Synchro extends MispMessage

class MispActor @Inject() (
    connector: Connector,
    mispImportSrv: MispImportSrv
) extends Actor {
  import context.dispatcher

  lazy val logger: Logger = Logger(getClass)

  override def preStart(): Unit = {
    super.preStart()
    logger.info(s"[$self] Starting actor MISP")
    context.become(receive(context.system.scheduler.scheduleOnce(connector.syncInitialDelay, self, Synchro)))
  }

  override def receive: Receive = {
    case other => logger.warn(s"Unknown message $other (${other.getClass})")
  }

  def receive(scheduledSynchronisation: Cancellable): Receive = {
    case Synchro =>
      scheduledSynchronisation.cancel()
      logger.info(s"Synchronising MISP events for ${connector.clients.map(_.name).mkString(",")}")
      connector.clients.filter(_.canImport).foreach { mispClient =>
        mispImportSrv.syncMispEvents(mispClient)
      }
      logger.info("MISP synchronisation is complete")
      context.become(receive(context.system.scheduler.scheduleOnce(connector.syncInterval, self, Synchro)))
  }
}

class MispActorProvider @Inject() (system: ActorSystem, @Named("misp-actor-singleton") mispActorSingleton: ActorRef) extends Provider[ActorRef] {
  override def get(): ActorRef =
    system.actorOf(
      ClusterSingletonProxy.props(
        singletonManagerPath = mispActorSingleton.path.toStringWithoutAddress,
        settings = ClusterSingletonProxySettings(system)
      )
    )
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/services/MispExportSrv.scala`:

```scala
package org.thp.thehive.connector.misp.services

import org.thp.misp.dto.{Attribute, Tag => MispTag}
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AuthorizationError, BadRequestError, NotFoundError}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.{AlertSrv, AttachmentSrv, CaseSrv, OrganisationSrv}
import play.api.Logger

import java.util.Date
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.Try

@Singleton
class MispExportSrv @Inject() (
    connector: Connector,
    caseSrv: CaseSrv,
    attachmentSrv: AttachmentSrv,
    alertSrv: AlertSrv,
    organisationSrv: OrganisationSrv,
    db: Database
) {

  lazy val logger: Logger = Logger(getClass)

  def observableToAttribute(observable: RichObservable, exportTags: Boolean): Option[Attribute] = {
    lazy val mispTags =
      if (exportTags)
        observable.tags.map(t => MispTag(None, t, None, None)) ++ tlpTags.get(observable.tlp) // FIXME Add colour
      else
        tlpTags.get(observable.tlp).toSeq

    observable
      .data
      .collect {
        case data if observable.dataType == "hash" => data.length
      }
      .collect {
        case 32  => "md5"
        case 40  => "sha1"
        case 56  => "sha224"
        case 64  => "sha256"
        case 96  => "sha384"
        case 128 => "sha512"
      }
      .map("Payload delivery" -> _)
      .orElse(connector.attributeConverter(observable.dataType))
      .map {
        case (cat, tpe) =>
          Attribute(
            id = "",
            `type` = tpe,
            category = cat,
            toIds = false,
            eventId = "",
            distribution = 0,
            date = observable.observable._createdAt,
            comment = observable.message,
            deleted = false,
            data = observable.attachment.map(a => (a.name, a.contentType, attachmentSrv.source(a))),
            value = observable.data.getOrElse(observable.attachment.get.name),
            firstSeen = None,
            lastSeen = None,
            tags = mispTags
          )
      }
      .orElse {
        logger.warn(
          s"Observable type ${observable.dataType} can't be converted to MISP attribute. You should add a mapping in `misp.attribute.mapping`"
        )
        None
      }
  }

  def getMispClient(mispId: String): Future[TheHiveMispClient] =
    connector
      .clients
      .find(_.name == mispId)
      .fold[Future[TheHiveMispClient]](Future.failed(NotFoundError(s"MISP server $mispId not found"))) {
        case client if client.canExport => Future.successful(client)
        case _                          => Future.failed(BadRequestError(s"Export on MISP connection $mispId is denied by configuration"))
      }

  def getAlert(`case`: Case with Entity, orgName: String)(implicit graph: Graph): Option[Alert with Entity] =
    caseSrv
      .get(`case`)
      .alert
      .filterBySource(orgName)
      .filterByType("misp")
      .headOption

  def getAttributes(`case`: Case with Entity, exportTags: Boolean)(implicit graph: Graph, authContext: AuthContext): Iterator[Attribute] =
    caseSrv.get(`case`).observables.isIoc.richObservable.toIterator.flatMap(observableToAttribute(_, exportTags))

  def removeDuplicateAttributes(attributes: Iterator[Attribute]): Seq[Attribute] = {
    var attrSet = Set.empty[(String, String, String)]
    val builder = Seq.newBuilder[Attribute]
    attributes.foreach { attr =>
      val tuple = (attr.category, attr.`type`, attr.value)
      if (!attrSet.contains(tuple)) {
        builder += attr
        attrSet += tuple
      }
    }
    builder.result()
  }

  val tlpTags = Map(
    0 -> MispTag(None, "tlp:white", None, None),
    1 -> MispTag(None, "tlp:green", None, None),
    2 -> MispTag(None, "tlp:amber", None, None),
    3 -> MispTag(None, "tlp:red", None, None)
  )
  def createEvent(client: TheHiveMispClient, `case`: Case with Entity, attributes: Seq[Attribute], extendsEvent: Option[String])(implicit
      ec: ExecutionContext
  ): Future[String] = {
    val mispTags =
      if (client.exportCaseTags)
        db.roTransaction { implicit graph =>
          caseSrv.get(`case`._id).tags.toSeq.map(t => MispTag(None, t.toString, Some(t.colour), None)) ++ tlpTags.get(`case`.tlp)
        }
      else tlpTags.get(`case`.tlp).toSeq
    client.createEvent(
      info = `case`.title,
      date = `case`.startDate,
      threatLevel = math.min(4, math.max(1, 4 - `case`.severity)),
      published = false,
      analysis = 0,
      distribution = 0,
      attributes = attributes,
      tags = mispTags,
      extendsEvent = extendsEvent
    )
  }

  def createAlert(client: TheHiveMispClient, `case`: Case with Entity, eventId: String)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichAlert] =
    for {
      org <- organisationSrv.getOrFail(authContext.organisation)
      alert <- client.currentOrganisationName.map { orgName =>
        Alert(
          `type` = "misp",
          source = orgName,
          sourceRef = eventId,
          externalLink = Some(s"${client.baseUrl}/events/$eventId"),
          title = `case`.title,
          description = `case`.description,
          severity = `case`.severity,
          date = `case`.startDate,
          lastSyncDate = new Date(0L),
          tlp = `case`.tlp,
          pap = `case`.pap,
          read = false,
          follow = true,
          tags = Nil,
          caseId = `case`._id
        )
      }
      createdAlert <- alertSrv.create(alert.copy(lastSyncDate = new Date(0L)), org, Set.empty, Nil, None)
      _            <- alertSrv.alertCaseSrv.create(AlertCase(), createdAlert.alert, `case`)
    } yield createdAlert

  def canExport(client: TheHiveMispClient)(implicit authContext: AuthContext): Boolean =
    client.canExport && db.roTransaction { implicit graph =>
      client.organisationFilter(organisationSrv.current).exists
    }

  def export(mispId: String, `case`: Case with Entity)(implicit authContext: AuthContext, ec: ExecutionContext): Future[String] = {
    logger.info(s"Exporting case ${`case`.number} to MISP $mispId")
    for {
      client  <- getMispClient(mispId)
      _       <- if (canExport(client)) Future.successful(()) else Future.failed(AuthorizationError(s"You cannot export case to MISP $mispId"))
      orgName <- Future.fromTry(client.currentOrganisationName)
      maybeAlert = db.roTransaction(implicit graph => getAlert(`case`, orgName))
      _          = logger.debug(maybeAlert.fold("Related MISP event doesn't exist")(a => s"Related MISP event found : ${a.sourceRef}"))
      attributes = db.roTransaction(implicit graph => removeDuplicateAttributes(getAttributes(`case`, client.exportObservableTags)))
      eventId <- createEvent(client, `case`, attributes, maybeAlert.map(_.sourceRef))
      _       <- Future.fromTry(db.tryTransaction(implicit graph => createAlert(client, `case`, eventId)))
    } yield eventId
  }
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/services/MispImportSrv.scala`:

```scala
package org.thp.thehive.connector.misp.services

import akka.stream.Materializer
import akka.stream.scaladsl.{FileIO, Sink, Source}
import akka.util.ByteString
import org.thp.misp.dto.{Attribute, Event, Tag => MispTag}
import org.thp.scalligraph.auth.{AuthContext, UserSrv}
import org.thp.scalligraph.controllers.FFile
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.utils.FunctionalCondition._
import org.thp.scalligraph.{CreateError, EntityId, EntityName, RichSeq}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.{UserSrv => _, _}
import play.api.Logger
import play.api.libs.json._

import java.nio.file.Files
import java.util.Date
import javax.inject.{Inject, Singleton}
import scala.concurrent.duration.DurationInt
import scala.concurrent.{Await, ExecutionContext}
import scala.util.{Failure, Success, Try}

@Singleton
class MispImportSrv @Inject() (
    connector: Connector,
    alertSrv: AlertSrv,
    caseSrv: CaseSrv,
    observableSrv: ObservableSrv,
    organisationSrv: OrganisationSrv,
    observableTypeSrv: ObservableTypeSrv,
    caseTemplateSrv: CaseTemplateSrv,
    db: Database,
    auditSrv: AuditSrv,
    userSrv: UserSrv,
    attachmentSrv: AttachmentSrv,
    implicit val ec: ExecutionContext,
    implicit val mat: Materializer
) {

  lazy val logger: Logger = Logger(getClass)

  def eventToAlert(client: TheHiveMispClient, event: Event, organisationId: EntityId): Try[Alert] =
    client
      .currentOrganisationName
      .map { mispOrganisation =>
        Alert(
          `type` = "misp",
          source = mispOrganisation,
          sourceRef = event.id,
          externalLink = Some(s"${client.strippedUrl}/events/${event.id}"),
          title = s"#${event.id} ${event.info.trim}",
          description = s"Imported from MISP Event #${event.id}, created at ${event.date}",
          severity = event.threatLevel.filter(l => 0 < l && l < 4).fold(2)(4 - _),
          date = event.date,
          lastSyncDate = event.publishDate,
          tlp = event
            .tags
            .collectFirst {
              case MispTag(_, "tlp:white", _, _) => 0
              case MispTag(_, "tlp:green", _, _) => 1
              case MispTag(_, "tlp:amber", _, _) => 2
              case MispTag(_, "tlp:red", _, _)   => 3
            }
            .getOrElse(2),
          pap = 2,
          read = false,
          follow = true,
          organisationId = organisationId,
          tags = s"src:${event.orgc}" +: event.tags.map(_.name),
          caseId = EntityId.empty
        )
      }

  def convertAttributeType(attributeCategory: String, attributeType: String)(implicit
      graph: Graph
  ): Try[(ObservableType with Entity, Seq[String])] = {
    val obsTypeFromConfig = connector
      .attributeConverter(attributeCategory, attributeType)
      .flatMap { attrConv =>
        observableTypeSrv
          .get(attrConv.`type`)
          .headOption
          .map(_ -> attrConv.tags)
      }
    obsTypeFromConfig
      .orElse(observableTypeSrv.get(EntityName(attributeType)).headOption.map(_ -> Nil))
      .fold(observableTypeSrv.getOrFail(EntityName("other")).map(_ -> Seq.empty[String]))(Success(_))
  }

  def attributeToObservable(
      attribute: Attribute
  )(implicit graph: Graph): List[(Observable, Either[String, (String, String, Source[ByteString, _])])] =
    attribute
      .`type`
      .split('|')
      .toSeq
      .toTry(convertAttributeType(attribute.category, _))
      .map {
        case observables
            if observables.exists(o =>
              o._1.isAttachment != (attribute.`type` == "attachment" ||
                attribute.`type` == "malware-sample") ||
                o._1.isAttachment == attribute.data.isEmpty
            ) =>
          logger.error(s"Attribute conversion return incompatible types (${attribute.`type`} / ${observables.map(_._1.name).mkString(",")}")
          Nil
        case Seq((observableType, additionalTags)) if observableType.isAttachment =>
          logger.debug(
            s"attribute ${attribute.category}:${attribute.`type`} (${attribute.tags}) is converted to observable $observableType with tags $additionalTags"
          )
          List(
            (
              Observable(
                message = attribute.comment,
                tlp = 0,
                ioc = false,
                sighted = false,
                ignoreSimilarity = None,
                dataType = observableType.name,
                tags = additionalTags ++ attribute.tags.map(_.name)
              ),
              Right(attribute.data.get)
            )
          )
        case Seq((observableType, additionalTags)) if !observableType.isAttachment =>
          logger.debug(
            s"attribute ${attribute.category}:${attribute.`type`} (${attribute.tags}) is converted to observable $observableType with tags $additionalTags"
          )
          List(
            (
              Observable(
                message = attribute.comment,
                tlp = 0,
                ioc = false,
                sighted = false,
                ignoreSimilarity = None,
                dataType = observableType.name,
                tags = additionalTags ++ attribute.tags.map(_.name)
              ),
              Left(attribute.value)
            )
          )
        case multipleObservables =>
          attribute
            .value
            .split('|')
            .toList
            .zip(multipleObservables)
            .map {
              case (value, (observableType, additionalTags)) =>
                logger.debug(
                  s"attribute ${attribute.category}:${attribute.`type`} (${attribute.tags}) is converted to observable $observableType with tags $additionalTags"
                )
                (
                  Observable(
                    message = attribute.comment,
                    tlp = 0,
                    ioc = false,
                    sighted = false,
                    ignoreSimilarity = None,
                    dataType = observableType.name,
                    tags = additionalTags ++ attribute.tags.map(_.name)
                  ),
                  Left(value)
                )
            }
      }
      .getOrElse {
        logger.warn(s"Don't know how to convert attribute $attribute")
        Nil
      }

  def getLastSyncDate(client: TheHiveMispClient, mispOrganisation: String, organisations: Seq[Organisation with Entity])(implicit
      graph: Graph
  ): Option[Date] = {
    val lastOrgSynchro = client
      .organisationFilter(organisationSrv.startTraversal)
      .notAdmin
      ._id
      .toIterator
      .flatMap { orgId =>
        alertSrv
          .startTraversal
          .filterBySource(mispOrganisation)
          .filterByType("misp")
          .has(_.organisationId, orgId)
          .value(a => a.lastSyncDate)
          .max
          .headOption
      }
      .toSeq

    if (lastOrgSynchro.size == organisations.size && organisations.nonEmpty) Some(lastOrgSynchro.min)
    else None
  }

  def updateOrCreateSimpleObservable(
      alert: Alert with Entity,
      observable: Observable,
      data: String
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    alertSrv
      .createObservable(alert, observable, data)
      .map(_ => ())
      .recoverWith {
        case _: CreateError =>
          for {
            richObservable <-
              observableSrv
                .startTraversal
                .has(_.organisationIds, organisationSrv.currentId)
                .has(_.relatedId, alert._id)
                .has(_.data, data)
                .richObservable
                .getOrFail("Observable")
            _ <-
              observableSrv
                .get(richObservable.observable)
                .when(richObservable.message != observable.message)(_.update(_.message, observable.message))
                .when(richObservable.tlp != observable.tlp)(_.update(_.tlp, observable.tlp))
                .when(richObservable.ioc != observable.ioc)(_.update(_.ioc, observable.ioc))
                .when(richObservable.sighted != observable.sighted)(_.update(_.sighted, observable.sighted))
                .when(richObservable.tags.toSet != observable.tags.toSet)(_.update(_.tags, observable.tags))
                .when(
                  richObservable.message != observable.message ||
                    richObservable.tlp != observable.tlp ||
                    richObservable.ioc != observable.ioc ||
                    richObservable.sighted != observable.sighted ||
                    richObservable.tags.toSet != observable.tags.toSet
                )(_.update(_._updatedAt, Some(new Date)).update(_._updatedBy, Some(authContext.userId)))
                .getOrFail("Observable")
          } yield ()
      }

  def updateOrCreateAttachmentObservable(
      alert: Alert with Entity,
      observable: Observable,
      filename: String,
      contentType: String,
      src: Source[ByteString, _],
      creation: Boolean
  )(implicit graph: Graph, authContext: AuthContext): Try[Observable with Entity] = {
    val file = Files.createTempFile("misp-attachment-", "")
    try {
      Await.result(src.runWith(FileIO.toPath(file)), 1.hour)
      val hash = attachmentSrv.hashers.fromPath(file).head.toString
      val existingObservable =
        if (creation) None
        else
          alertSrv
            .get(alert)
            .observables
            .filterOnType(observable.dataType)
            .filterOnAttachmentName(filename)
            .filterOnAttachmentContentType(contentType)
            .filterOnAttachmentHash(hash)
            .richObservable
            .headOption
      existingObservable match {
        case None =>
          logger.debug(s"Observable ${observable.dataType}:$filename:$contentType doesn't exist, create it")
          alertSrv.createObservable(alert, observable, FFile(filename, file, contentType)).map(_.observable)
        case Some(richObservable) =>
          logger.debug(s"Observable ${observable.dataType}:$filename:$contentType exists, update it")
          for {
            obs <-
              observableSrv
                .get(richObservable.observable)
                .when(richObservable.message != observable.message)(_.update(_.message, observable.message))
                .when(richObservable.tlp != observable.tlp)(_.update(_.tlp, observable.tlp))
                .when(richObservable.ioc != observable.ioc)(_.update(_.ioc, observable.ioc))
                .when(richObservable.sighted != observable.sighted)(_.update(_.sighted, observable.sighted))
                .when(richObservable.tags.toSet != observable.tags.toSet)(_.update(_.tags, observable.tags))
                .getOrFail("Observable")
          } yield obs
      }
    } finally Files.delete(file)
  }

  def importAttributes(
      client: TheHiveMispClient,
      event: Event,
      alert: Alert with Entity,
      `case`: Option[Case with Entity],
      lastSynchro: Option[Date]
  )(implicit
      graph: Graph,
      authContext: AuthContext
  ): Unit = {
    logger.info("Removing old observables")
    val deletedAttributes = client
      .searchAttributes(event.id, lastSynchro, deletedOnly = true)
      .mapConcat(attributeToObservable)
      .runWith(Sink.queue[(Observable, Either[String, (String, String, Source[ByteString, _])])])

    QueueIterator(deletedAttributes)
      .flatMap {
        case (observable, Left(data)) =>
          observableSrv
            .startTraversal
            .has(_.relatedId, alert._id)
            .filterOnType(observable.dataType)
            .filterOnData(data)
            .toIterator
        case (observable, Right((filename, contentType, src))) =>
          val hash = attachmentSrv.hashers.fromBinary(src).head.toString
          observableSrv
            .startTraversal
            .has(_.relatedId, alert._id)
            .filterOnType(observable.dataType)
            .filterOnAttachmentContentType(contentType)
            .filterOnAttachmentName(filename)
            .filterOnAttachmentHash(hash)
            .toIterator
      }
      .foreach(observableSrv.delete(_))

    logger.debug(s"importAttributes ${client.name}#${event.id}")
    val queue =
      client
        .searchAttributes(event.id, lastSynchro)
        .mapConcat(attributeToObservable)
        .fold(
          Map.empty[
            (String, String),
            (Observable, Either[String, (String, String, Source[ByteString, _])])
          ]
        ) {
          case (distinctMap, data @ (obs, Left(d)))          => distinctMap + ((obs.dataType, d) -> data)
          case (distinctMap, data @ (obs, Right((n, _, _)))) => distinctMap + ((obs.dataType, n) -> data)
        }
        .mapConcat { m =>
          m.values.toList
        }
        .runWith(Sink.queue[(Observable, Either[String, (String, String, Source[ByteString, _])])])
    QueueIterator(queue).foreach {
      case (observable, Left(data)) =>
        updateOrCreateSimpleObservable(alert, observable, data)
          .failed
          .foreach(error => logger.error(s"Unable to create observable $observable on alert", error))
        `case`.foreach { c =>
          caseSrv
            .createObservable(c, observable, data)
            .failed
            .foreach(error => logger.error(s"Unable to create observable $observable on case", error))
        }
      case (observable, Right((filename, contentType, src))) =>
        updateOrCreateAttachmentObservable(
          alert,
          observable,
          filename,
          contentType,
          src,
          lastSynchro.isEmpty
        ) match {
          case Success(obs) =>
            for {
              c          <- `case`
              attachment <- observableSrv.get(obs).attachments.headOption
            } yield caseSrv
              .createObservable(c, observable, attachment)
              .failed
              .foreach(error => logger.error(s"Unable to create observable $observable ($filename) on case", error))
          case Failure(error) => logger.error(s"Unable to create observable $observable ($filename) on alert", error)
        }
    }
  }

//  def convertTag(mispTag: MispTag): Tag = tagSrv.parseString(mispTag.name + mispTag.colour.fold("")(c => f"#$c%06X"))

  def updateOrCreateAlert(
      client: TheHiveMispClient,
      organisation: Organisation with Entity,
      mispOrganisation: String,
      event: Event,
      caseTemplate: Option[CaseTemplate with Entity]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Alert with Entity, Option[Case with Entity], JsObject)] = {
    logger.debug(s"updateOrCreateAlert ${client.name}#${event.id} for organisation ${organisation.name}")
    eventToAlert(client, event, organisation._id).flatMap { alert =>
      alertSrv
        .startTraversal
        .getBySourceId("misp", mispOrganisation, event.id)
        .has(_.organisationId, organisation._id)
        .richAlert
        .headOption match {
        case None => // if the related alert doesn't exist, create it
          logger.debug(s"Event ${client.name}#${event.id} has no related alert for organisation ${organisation.name}")
          alertSrv
            .create(alert, organisation, event.tags.map(_.name).toSet, Seq(), caseTemplate)
            .map(ra => (ra.alert, None, ra.toJson.asInstanceOf[JsObject]))
        case Some(richAlert) =>
          logger.debug(s"Event ${client.name}#${event.id} have already been imported for organisation ${organisation.name}, updating the alert")
          val (updatedAlertTraversal, updatedFields) = (
            alertSrv.get(richAlert.alert).update(_.read, false).update(_._updatedAt, Some(new Date)).update(_._updatedBy, Some(authContext.userId)),
            Json.obj("read" -> false)
          )
            .when(richAlert.title != alert.title)(_.update(_.title, alert.title), _ + ("title" -> JsString(alert.title)))
            .when(richAlert.lastSyncDate != alert.lastSyncDate)(
              _.update(_.lastSyncDate, alert.lastSyncDate),
              _ + ("lastSyncDate" -> JsNumber(alert.lastSyncDate.getTime))
            )
            .when(richAlert.description != alert.description)(
              _.update(_.description, alert.description),
              _ + ("description" -> JsString(alert.description))
            )
            .when(richAlert.severity != alert.severity)(_.update(_.severity, alert.severity), _ + ("severity" -> JsNumber(alert.severity)))
            .when(richAlert.date != alert.date)(_.update(_.date, alert.date), _ + ("date" -> JsNumber(alert.date.getTime)))
            .when(richAlert.tlp != alert.tlp)(_.update(_.tlp, alert.tlp), _ + ("tlp" -> JsNumber(alert.tlp)))
            .when(richAlert.pap != alert.pap)(_.update(_.pap, alert.pap), _ + ("pap" -> JsNumber(alert.pap)))
            .when(richAlert.externalLink != alert.externalLink)(
              _.update(_.externalLink, alert.externalLink),
              _ + ("externalLink" -> alert.externalLink.fold[JsValue](JsNull)(JsString.apply))
            )
          val tags = event.tags.map(_.name)
          for {
            (addedTags, removedTags) <- alertSrv.updateTags(richAlert.alert, tags.toSet)
            updatedAlert             <- updatedAlertTraversal.getOrFail("Alert")
            case0 = alertSrv.get(richAlert.alert).`case`.headOption
            updatedFieldWithTags =
              if (addedTags.nonEmpty || removedTags.nonEmpty) updatedFields + ("tags" -> JsArray(tags.map(JsString))) else updatedFields
          } yield (updatedAlert, case0, updatedFieldWithTags)
      }
    }
  }

  def syncMispEvents(client: TheHiveMispClient): Unit =
    client
      .currentOrganisationName
      .fold(
        error => logger.error("Unable to get MISP organisation", error),
        mispOrganisation => {
          val caseTemplate = client.caseTemplate.flatMap { caseTemplateName =>
            db.roTransaction { implicit graph =>
              caseTemplateSrv.get(EntityName(caseTemplateName)).headOption
            }
          }

          logger.debug(s"Get eligible organisations")
          val organisations = db.roTransaction { implicit graph =>
            client.organisationFilter(organisationSrv.startTraversal).notAdmin.toSeq
          }
          val lastSynchro = db.roTransaction { implicit graph =>
            getLastSyncDate(client, mispOrganisation, organisations)
          }

          logger.debug(s"Last synchronisation is $lastSynchro")
          val queue = client
            .searchEvents(publishDate = lastSynchro)
            .runWith(Sink.queue[Event])
          QueueIterator(queue).foreach { event =>
            logger.debug(s"Importing event ${client.name}#${event.id} in organisation(s): ${organisations.mkString(",")}")
            organisations.foreach { organisation =>
              implicit val authContext: AuthContext = userSrv.getSystemAuthContext.changeOrganisation(organisation._id, Profile.admin.permissions)
              db.tryTransaction { implicit graph =>
                auditSrv.mergeAudits {
                  updateOrCreateAlert(client, organisation, mispOrganisation, event, caseTemplate)
                    .map {
                      case (alert, case0, updatedFields) =>
                        importAttributes(client, event, alert, case0, if (alert._updatedBy.isEmpty) None else lastSynchro)
                        (alert, updatedFields)
                    }
                    .recoverWith {
                      case error =>
                        logger.warn(s"Unable to create alert from MISP event ${client.name}#${event.id}", error)
                        Failure(error)
                    }
                } {
                  case (alert, updatedFields) if alert._updatedBy.isDefined => auditSrv.alert.update(alert, updatedFields)
                  case (alert, updatedFields)                               => auditSrv.alert.create(alert, updatedFields)
                }
              }
            }
          }
        }
      )
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/services/MispSerializer.scala`:

```scala
package org.thp.thehive.connector.misp.services

import akka.serialization.Serializer

import java.io.NotSerializableException

class MispSerializer extends Serializer {
  override def identifier: Int = -222314660

  override def includeManifest: Boolean = false

  override def toBinary(o: AnyRef): Array[Byte] =
    o match {
      case Synchro => Array(0)
      case _       => throw new NotSerializableException
    }

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef =
    bytes(0) match {
      case 0 => Synchro
      case _ => throw new NotSerializableException
    }
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/services/QueueIterator.scala`:

```scala
package org.thp.thehive.connector.misp.services

import akka.stream.scaladsl.SinkQueueWithCancel
import play.api.Logger

import java.util.NoSuchElementException
import scala.concurrent.Await
import scala.concurrent.duration.{Duration, DurationInt}
import scala.util.control.NonFatal

class QueueIterator[T](queue: SinkQueueWithCancel[T], readTimeout: Duration) extends Iterator[T] {
  lazy val logger: Logger = Logger(getClass)

  private var nextValue: Option[T] = None
  private var isFinished: Boolean  = false
  def getNextValue(): Unit =
    try nextValue = Await.result(queue.pull(), readTimeout)
    catch {
      case NonFatal(e) =>
        logger.error("Stream fails", e)
        isFinished = true
        nextValue = None
    }
  override def hasNext: Boolean =
    if (isFinished) false
    else {
      if (nextValue.isEmpty)
        getNextValue()
      nextValue.isDefined
    }

  override def next(): T =
    nextValue match {
      case Some(v) =>
        nextValue = None
        v
      case _ if !isFinished =>
        getNextValue()
        nextValue.getOrElse {
          isFinished = true
          throw new NoSuchElementException
        }
      case _ => throw new NoSuchElementException
    }
}

object QueueIterator {
  def apply[T](queue: SinkQueueWithCancel[T], readTimeout: Duration = 1.minute) = new QueueIterator[T](queue, readTimeout)
}

```

`misp/connector/src/main/scala/org/thp/thehive/connector/misp/services/TheHiveMispClient.scala`:

```scala
package org.thp.thehive.connector.misp.services

import akka.stream.Materializer
import org.apache.tinkerpop.gremlin.process.traversal.P
import org.thp.client.{Authentication, ProxyWS, ProxyWSConfig}
import org.thp.misp.client.{MispClient, MispPurpose}
import org.thp.scalligraph.services.config.ApplicationConfig.durationFormat
import org.thp.scalligraph.traversal.Traversal
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.models.{HealthStatus, Organisation}
import play.api.libs.json._
import play.api.libs.ws.WSClient
import play.api.libs.ws.ahc.AhcWSClientConfig

import javax.inject.Inject
import scala.concurrent.duration.Duration
import scala.concurrent.{ExecutionContext, Future}

case class TheHiveMispClientConfig(
    name: String,
    url: String,
    auth: Authentication,
    wsConfig: ProxyWSConfig = ProxyWSConfig(AhcWSClientConfig(), None),
    maxAttributes: Option[Int],
    maxAge: Option[Duration],
    excludedOrganisations: Seq[String] = Nil,
    whitelistOrganisations: Seq[String] = Nil,
    excludedTags: Set[String] = Set.empty,
    whitelistTags: Set[String] = Set.empty,
    purpose: MispPurpose.Value = MispPurpose.ImportAndExport,
    caseTemplate: Option[String],
    observableTags: Seq[String] = Nil,
    exportCaseTags: Boolean = false,
    exportObservableTags: Boolean = false,
    includedTheHiveOrganisations: Seq[String] = Seq("*"),
    excludedTheHiveOrganisations: Seq[String] = Nil
)

object TheHiveMispClientConfig {
  implicit val purposeFormat: Format[MispPurpose.Value] = Json.formatEnum(MispPurpose)

  val reads: Reads[TheHiveMispClientConfig] = {
    for {
      name                         <- (JsPath \ "name").read[String]
      url                          <- (JsPath \ "url").read[String]
      auth                         <- (JsPath \ "auth").read[Authentication]
      wsConfig                     <- (JsPath \ "wsConfig").readWithDefault[ProxyWSConfig](ProxyWSConfig(AhcWSClientConfig(), None))
      maxAttributes                <- (JsPath \ "max-attributes").readNullable[Int]
      maxAge                       <- (JsPath \ "maxAge").readNullable[Duration]
      excludedOrganisations        <- (JsPath \ "exclusion" \ "organisations").readWithDefault[Seq[String]](Nil)
      whitelistOrganisations       <- (JsPath \ "whitelist" \ "organisations").readWithDefault[Seq[String]](Nil)
      excludedTags                 <- (JsPath \ "exclusion" \ "tags").readWithDefault[Set[String]](Set.empty)
      whitelistTags                <- (JsPath \ "whitelist" \ "tags").readWithDefault[Set[String]](Set.empty)
      purpose                      <- (JsPath \ "purpose").readWithDefault[MispPurpose.Value](MispPurpose.ImportAndExport)
      caseTemplate                 <- (JsPath \ "caseTemplate").readNullable[String]
      observableTags               <- (JsPath \ "tags").readWithDefault[Seq[String]](Nil)
      exportCaseTags               <- (JsPath \ "exportCaseTags").readWithDefault[Boolean](false)
      exportObservableTags         <- (JsPath \ "exportObservableTags").readWithDefault[Boolean](false)
      includedTheHiveOrganisations <- (JsPath \ "includedTheHiveOrganisations").readWithDefault[Seq[String]](Seq("*"))
      excludedTheHiveOrganisations <- (JsPath \ "excludedTheHiveOrganisations").readWithDefault[Seq[String]](Nil)
    } yield TheHiveMispClientConfig(
      name,
      url,
      auth,
      wsConfig,
      maxAttributes,
      maxAge,
      excludedOrganisations,
      whitelistOrganisations,
      excludedTags,
      whitelistTags,
      purpose,
      caseTemplate,
      observableTags,
      exportCaseTags,
      exportObservableTags,
      includedTheHiveOrganisations,
      excludedTheHiveOrganisations
    )
  }
  val writes: Writes[TheHiveMispClientConfig] = Writes[TheHiveMispClientConfig] { cfg =>
    Json.obj(
      "name"                         -> cfg.name,
      "url"                          -> cfg.url,
      "auth"                         -> cfg.auth,
      "wsConfig"                     -> cfg.wsConfig,
      "maxAttributes"                -> cfg.maxAttributes,
      "maxAge"                       -> cfg.maxAge,
      "exclusion"                    -> Json.obj("organisations" -> cfg.excludedOrganisations, "tags" -> cfg.excludedTags),
      "whitelistTags"                -> Json.obj("whitelist" -> cfg.whitelistTags),
      "purpose"                      -> cfg.purpose,
      "caseTemplate"                 -> cfg.caseTemplate,
      "tags"                         -> cfg.observableTags,
      "exportCaseTags"               -> cfg.exportCaseTags,
      "includedTheHiveOrganisations" -> cfg.includedTheHiveOrganisations,
      "excludedTheHiveOrganisations" -> cfg.excludedTheHiveOrganisations
    )
  }
  implicit val format: Format[TheHiveMispClientConfig] = Format[TheHiveMispClientConfig](reads, writes)
}

class TheHiveMispClient(
    name: String,
    baseUrl: String,
    auth: Authentication,
    ws: WSClient,
    maxAttributes: Option[Int],
    maxAge: Option[Duration],
    excludedOrganisations: Seq[String],
    whitelistOrganisations: Seq[String],
    excludedTags: Set[String],
    whitelistTags: Set[String],
    purpose: MispPurpose.Value,
    val caseTemplate: Option[String],
    val observableTags: Seq[String],
    val exportCaseTags: Boolean,
    val exportObservableTags: Boolean,
    includedTheHiveOrganisations: Seq[String],
    excludedTheHiveOrganisations: Seq[String]
) extends MispClient(
      name,
      baseUrl,
      auth,
      ws,
      maxAttributes,
      maxAge,
      excludedOrganisations,
      whitelistOrganisations,
      excludedTags,
      whitelistTags
    ) {

  @Inject() def this(config: TheHiveMispClientConfig, mat: Materializer) =
    this(
      config.name,
      config.url,
      config.auth,
      new ProxyWS(config.wsConfig, mat),
      config.maxAttributes,
      config.maxAge,
      config.excludedOrganisations,
      config.whitelistOrganisations,
      config.excludedTags,
      config.whitelistTags,
      config.purpose,
      config.caseTemplate,
      config.observableTags,
      config.exportCaseTags,
      config.exportObservableTags,
      config.includedTheHiveOrganisations,
      config.excludedTheHiveOrganisations
    )

  val (canImport, canExport) = purpose match {
    case MispPurpose.ImportAndExport => (true, true)
    case MispPurpose.ImportOnly      => (true, false)
    case MispPurpose.ExportOnly      => (false, true)
  }

  def organisationFilter(organisationSteps: Traversal.V[Organisation]): Traversal.V[Organisation] = {
    val includedOrgs =
      if (includedTheHiveOrganisations.contains("*") || includedTheHiveOrganisations.isEmpty) organisationSteps
      else organisationSteps.has(_.name, P.within(includedTheHiveOrganisations: _*))
    if (excludedTheHiveOrganisations.isEmpty) includedOrgs
    else includedOrgs.has(_.name, P.without(excludedTheHiveOrganisations: _*))
  }

  override def getStatus(implicit ec: ExecutionContext): Future[JsObject] =
    super.getStatus.map(_ + ("purpose" -> JsString(purpose.toString)) + ("url" -> JsString(baseUrl)))

  def getHealth(implicit ec: ExecutionContext): Future[HealthStatus.Value] =
    getVersion
      .map(_ => HealthStatus.Ok)
      .recover { case _ => HealthStatus.Error }
}

```

`misp/connector/src/test/resources/attributes.json`:

```json
[
  {
    "id": "3",
    "event_id": "1",
    "object_id": "2",
    "object_relation": "malware-sample",
    "category": "Payload delivery",
    "type": "malware-sample",
    "to_ids": true,
    "uuid": "5d600728-0b44-4ec3-8279-0965c0a83866",
    "timestamp": "1566574376",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "",
    "deleted": false,
    "disable_correlation": false,
    "value": "Alert_statistics.json|cda4ed7585956f2bc1318cf85751f0b8",
    "Event": {
      "org_id": "1",
      "distribution": "1",
      "id": "1",
      "info": "test1 -> 1.2",
      "orgc_id": "1",
      "uuid": "5d5fd392-1528-457a-bb8a-0453c0a83866"
    },
    "Object": {
      "id": "2",
      "distribution": "5",
      "sharing_group_id": "0"
    }
  },
  {
    "id": "5",
    "event_id": "1",
    "object_id": "2",
    "object_relation": "md5",
    "category": "Payload delivery",
    "type": "md5",
    "to_ids": true,
    "uuid": "5d600728-5178-4c82-b6e3-0965c0a83866",
    "timestamp": "1566574376",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "",
    "deleted": false,
    "disable_correlation": false,
    "value": "cda4ed7585956f2bc1318cf85751f0b8",
    "Event": {
      "org_id": "1",
      "distribution": "1",
      "id": "1",
      "info": "test1 -> 1.2",
      "orgc_id": "1",
      "uuid": "5d5fd392-1528-457a-bb8a-0453c0a83866"
    },
    "Object": {
      "id": "2",
      "distribution": "5",
      "sharing_group_id": "0"
    }
  },
  {
    "id": "6",
    "event_id": "1",
    "object_id": "2",
    "object_relation": "sha1",
    "category": "Payload delivery",
    "type": "sha1",
    "to_ids": true,
    "uuid": "5d600728-69e0-4d4e-b574-0965c0a83866",
    "timestamp": "1566574376",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "",
    "deleted": false,
    "disable_correlation": false,
    "value": "07f34cedcda85c61e599366a3e6e57eefe95de84",
    "Event": {
      "org_id": "1",
      "distribution": "1",
      "id": "1",
      "info": "test1 -> 1.2",
      "orgc_id": "1",
      "uuid": "5d5fd392-1528-457a-bb8a-0453c0a83866"
    },
    "Object": {
      "id": "2",
      "distribution": "5",
      "sharing_group_id": "0"
    }
  },
  {
    "id": "7",
    "event_id": "1",
    "object_id": "2",
    "object_relation": "sha256",
    "category": "Payload delivery",
    "type": "sha256",
    "to_ids": true,
    "uuid": "5d600728-cf80-4127-923d-0965c0a83866",
    "timestamp": "1566574376",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "",
    "deleted": false,
    "disable_correlation": false,
    "value": "4fcdf1490652c25e4c2d5fae284b1cb73a84fa82bd2d09f545796d6bf18e654a",
    "Event": {
      "org_id": "1",
      "distribution": "1",
      "id": "1",
      "info": "test1 -> 1.2",
      "orgc_id": "1",
      "uuid": "5d5fd392-1528-457a-bb8a-0453c0a83866"
    },
    "Object": {
      "id": "2",
      "distribution": "5",
      "sharing_group_id": "0"
    }
  },
  {
    "id": "8",
    "event_id": "1",
    "object_id": "2",
    "object_relation": "size-in-bytes",
    "category": "Other",
    "type": "size-in-bytes",
    "to_ids": false,
    "uuid": "5d600728-7b50-4f97-a37f-0965c0a83866",
    "timestamp": "1566574376",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "",
    "deleted": false,
    "disable_correlation": true,
    "value": "1647",
    "Event": {
      "org_id": "1",
      "distribution": "1",
      "id": "1",
      "info": "test1 -> 1.2",
      "orgc_id": "1",
      "uuid": "5d5fd392-1528-457a-bb8a-0453c0a83866"
    },
    "Object": {
      "id": "2",
      "distribution": "5",
      "sharing_group_id": "0"
    }
  },
  {
    "id": "9",
    "event_id": "1",
    "object_id": "0",
    "object_relation": null,
    "category": "Payload delivery",
    "type": "attachment",
    "to_ids": false,
    "uuid": "5d60074c-f608-45fa-b032-094fc0a83866",
    "timestamp": "1566574412",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "test",
    "deleted": false,
    "disable_correlation": false,
    "value": "Job_statistics.json",
    "Event": {
      "org_id": "1",
      "distribution": "1",
      "id": "1",
      "info": "test1 -> 1.2",
      "orgc_id": "1",
      "uuid": "5d5fd392-1528-457a-bb8a-0453c0a83866"
    }
  },
  {
    "id": "12",
    "event_id": "1",
    "object_id": "0",
    "object_relation": null,
    "category": "Artifacts dropped",
    "type": "filename",
    "to_ids": false,
    "uuid": "5d63a539-0924-4791-b0c5-3d1bc0a83866",
    "timestamp": "1566811449",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "",
    "deleted": false,
    "disable_correlation": false,
    "value": "plop",
    "Event": {
      "org_id": "1",
      "distribution": "1",
      "id": "1",
      "info": "test1 -> 1.2",
      "orgc_id": "1",
      "uuid": "5d5fd392-1528-457a-bb8a-0453c0a83866"
    },
    "Tag": [
      {
        "id": "1",
        "name": "TH-test",
        "colour": "#36a3a3",
        "numerical_value": null
      }
    ]
  },
  {
    "id": "13",
    "event_id": "3",
    "object_id": "0",
    "object_relation": null,
    "category": "Persistence mechanism",
    "type": "filename",
    "to_ids": true,
    "uuid": "5d6f8017-e118-4bca-afb5-61b0c0a83866",
    "timestamp": "1567588375",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "aze",
    "deleted": false,
    "disable_correlation": false,
    "value": "azeaze",
    "Event": {
      "org_id": "1",
      "distribution": "0",
      "id": "3",
      "info": "c3",
      "orgc_id": "1",
      "uuid": "5d6f8017-e210-4854-b01c-61b0c0a83866"
    }
  },
  {
    "id": "14",
    "event_id": "4",
    "object_id": "0",
    "object_relation": null,
    "category": "Persistence mechanism",
    "type": "filename",
    "to_ids": true,
    "uuid": "5d6fb6af-6f9c-47df-9757-65b1c0a83866",
    "timestamp": "1567602351",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "aze",
    "deleted": false,
    "disable_correlation": false,
    "value": "azeaze",
    "Event": {
      "org_id": "1",
      "distribution": "0",
      "id": "4",
      "info": "c3",
      "orgc_id": "1",
      "uuid": "5d6fb6af-1c60-482d-86db-65b1c0a83866"
    }
  },
  {
    "id": "15",
    "event_id": "5",
    "object_id": "0",
    "object_relation": null,
    "category": "Persistence mechanism",
    "type": "filename",
    "to_ids": true,
    "uuid": "5d6fc22d-6fb8-4c70-a0ab-61ecc0a83866",
    "timestamp": "1567605293",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "aze",
    "deleted": false,
    "disable_correlation": false,
    "value": "azeaze",
    "Event": {
      "org_id": "1",
      "distribution": "0",
      "id": "5",
      "info": "c3",
      "orgc_id": "1",
      "uuid": "5d6fc22d-4c10-49c1-828b-61ecc0a83866"
    },
    "Tag": [
      {
        "id": "2",
        "name": "TH-test-2",
        "colour": "#1ac7c7",
        "numerical_value": null
      }
    ]
  },
  {
    "id": "16",
    "event_id": "5",
    "object_id": "0",
    "object_relation": null,
    "category": "Payload delivery",
    "type": "ip-dst",
    "to_ids": true,
    "uuid": "5d6fc22d-2b5c-424a-87a0-61ecc0a83866",
    "timestamp": "1567605293",
    "distribution": "5",
    "sharing_group_id": "0",
    "comment": "test",
    "deleted": false,
    "disable_correlation": false,
    "value": "8.8.8.8",
    "Event": {
      "org_id": "1",
      "distribution": "0",
      "id": "5",
      "info": "c3",
      "orgc_id": "1",
      "uuid": "5d6fc22d-4c10-49c1-828b-61ecc0a83866"
    },
    "Tag": [
      {
        "id": "1",
        "name": "TH-test",
        "colour": "#36a3a3",
        "numerical_value": null
      }
    ]
  },
  {
    "id": "17",
    "event_id": "5",
    "object_id": "0",
    "object_relation": null,
    "category": "Network activity",
    "type": "ip-src",
    "to_ids": false,
    "uuid": "5d6fd591-79d0-439d-bddd-61b0c0a83866",
    "timestamp": "1567610257",
    "distribution": "0",
    "sharing_group_id": "0",
    "comment": "",
    "deleted": false,
    "disable_correlation": false,
    "value": "1.1.1.1",
    "Event": {
      "org_id": "1",
      "distribution": "0",
      "id": "5",
      "info": "c3",
      "orgc_id": "1",
      "uuid": "5d6fc22d-4c10-49c1-828b-61ecc0a83866"
    },
    "Tag": [
      {
        "id": "2",
        "name": "TH-test-2",
        "colour": "#1ac7c7",
        "numerical_value": null
      }
    ]
  }
]

```

`misp/connector/src/test/resources/events.json`:

```json
[
  {
    "id": "5",
    "org_id": "1",
    "date": "2019-08-07",
    "info": "c3",
    "uuid": "5d6fc22d-4c10-49c1-828b-61ecc0a83866",
    "published": true,
    "analysis": "0",
    "attribute_count": "3",
    "orgc_id": "1",
    "timestamp": "1567610257",
    "distribution": "0",
    "sharing_group_id": "0",
    "proposal_email_lock": false,
    "locked": false,
    "threat_level_id": "2",
    "publish_timestamp": "1567611698",
    "disable_correlation": false,
    "extends_uuid": "5d6fb6af-1c60-482d-86db-65b1c0a83866",
    "Org": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "Orgc": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "EventTag": []
  },
  {
    "id": "4",
    "org_id": "1",
    "date": "2019-08-07",
    "info": "c3",
    "uuid": "5d6fb6af-1c60-482d-86db-65b1c0a83866",
    "published": false,
    "analysis": "0",
    "attribute_count": "1",
    "orgc_id": "1",
    "timestamp": "1567602351",
    "distribution": "0",
    "sharing_group_id": "0",
    "proposal_email_lock": false,
    "locked": false,
    "threat_level_id": "2",
    "publish_timestamp": "0",
    "disable_correlation": false,
    "extends_uuid": null,
    "Org": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "Orgc": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "EventTag": []
  },
  {
    "id": "3",
    "org_id": "1",
    "date": "2019-08-07",
    "info": "c3",
    "uuid": "5d6f8017-e210-4854-b01c-61b0c0a83866",
    "published": false,
    "analysis": "0",
    "attribute_count": "1",
    "orgc_id": "1",
    "timestamp": "1567588375",
    "distribution": "0",
    "sharing_group_id": "0",
    "proposal_email_lock": false,
    "locked": false,
    "threat_level_id": "2",
    "publish_timestamp": "0",
    "disable_correlation": false,
    "extends_uuid": null,
    "Org": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "Orgc": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "EventTag": []
  },
  {
    "id": "2",
    "org_id": "1",
    "date": "2019-08-07",
    "info": "c3",
    "uuid": "5d6eab3c-a4e4-4629-aded-4eacc0a83866",
    "published": false,
    "analysis": "0",
    "attribute_count": "0",
    "orgc_id": "1",
    "timestamp": "1567533884",
    "distribution": "0",
    "sharing_group_id": "0",
    "proposal_email_lock": false,
    "locked": false,
    "threat_level_id": "2",
    "publish_timestamp": "0",
    "disable_correlation": false,
    "extends_uuid": null,
    "Org": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "Orgc": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "EventTag": []
  },
  {
    "id": "1",
    "org_id": "1",
    "date": "2019-08-23",
    "info": "test1 -> 1.2",
    "uuid": "5d5fd392-1528-457a-bb8a-0453c0a83866",
    "published": true,
    "analysis": "1",
    "attribute_count": "11",
    "orgc_id": "1",
    "timestamp": "1566913342",
    "distribution": "1",
    "sharing_group_id": "0",
    "proposal_email_lock": false,
    "locked": false,
    "threat_level_id": "1",
    "publish_timestamp": "1566913355",
    "disable_correlation": false,
    "extends_uuid": "",
    "Org": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "Orgc": {
      "id": "1",
      "name": "ORGNAME",
      "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4"
    },
    "EventTag": [
      {
        "id": "1",
        "event_id": "1",
        "tag_id": "1",
        "local": true,
        "Tag": {
          "id": "1",
          "name": "TH-test",
          "colour": "#36a3a3"
        }
      },
      {
        "id": "2",
        "event_id": "1",
        "tag_id": "2",
        "local": true,
        "Tag": {
          "id": "2",
          "name": "TH-test-2",
          "colour": "#1ac7c7"
        }
      }
    ]
  }
]
```

`misp/connector/src/test/resources/organisation.json`:

```json
{
  "Organisation": {
    "id": "1",
    "name": "ORGNAME",
    "date_created": "2019-08-21 10:53:03",
    "date_modified": "2019-08-21 10:53:03",
    "type": "ADMIN",
    "nationality": "Not specified",
    "sector": null,
    "contacts": null,
    "description": "Automatically generated admin organisation",
    "local": true,
    "uuid": "5d5d066f-cfa4-49da-995c-6d5b68257ab4",
    "restricted_to_domain": [],
    "created_by": "0",
    "user_count": "1"
  }
}

```

`misp/connector/src/test/resources/user.json`:

```json
{
  "User": {
    "id": "1",
    "password": "*****",
    "org_id": "1",
    "email": "admin@admin.test",
    "autoalert": false,
    "authkey": "aTw7pt4HclA4H2rUIy79QVjwtSlBV23w3WUvoEAO",
    "invited_by": "0",
    "gpgkey": null,
    "certif_public": "",
    "nids_sid": "4000000",
    "termsaccepted": false,
    "newsread": "0",
    "role_id": "1",
    "change_pw": "0",
    "contactalert": false,
    "disabled": false,
    "expiration": null,
    "current_login": "1567609904",
    "last_login": "1567605289",
    "force_logout": false,
    "date_created": null,
    "date_modified": "1566557788"
  }
}

```

`misp/connector/src/test/scala/org/thp/thehive/connector/misp/services/MispImportSrvTest.scala`:

```scala
package org.thp.thehive.connector.misp.services

import akka.stream.Materializer
import akka.stream.scaladsl.Sink
import org.thp.misp.dto.{Event, Organisation, Tag, User}
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AppBuilder, EntityId}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models.{Alert, Permissions}
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.{AlertSrv, OrganisationSrv}
import play.api.test.PlaySpecification

import java.util.{Date, UUID}
import scala.concurrent.ExecutionContext
import scala.concurrent.duration.DurationInt

class MispImportSrvTest(implicit ec: ExecutionContext) extends PlaySpecification with TestAppBuilder {
  sequential

  implicit val authContext: AuthContext =
    DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert", permissions = Permissions.all).authContext
  override def appConfigure: AppBuilder =
    super
      .appConfigure
      .bindToProvider[TheHiveMispClient, TestMispClientProvider]

  "MISP client" should {
    "get current user name" in testApp { app =>
      await(app[TheHiveMispClient].getCurrentUser) must beEqualTo(User("1", "1", "admin@admin.test"))
    }

    "get organisation" in testApp { app =>
      await(app[TheHiveMispClient].getOrganisation("1")) must beEqualTo(
        Organisation("1", "ORGNAME", Some("Automatically generated admin organisation"), UUID.fromString("5d5d066f-cfa4-49da-995c-6d5b68257ab4"))
      )
    }

    "get current organisation" in testApp { app =>
      app[TheHiveMispClient].currentOrganisationName must beSuccessfulTry("ORGNAME")
    }

    "retrieve events" in testApp { app =>
      val events = app[TheHiveMispClient]
        .searchEvents(None)
        .runWith(Sink.seq)(app[Materializer])
      val e = await(events)
      Seq(1, 2, 3) must contain(2)
      e must contain(
        Event(
          id = "1",
          published = true,
          info = "test1 -> 1.2",
          threatLevel = Some(1),
          analysis = Some(1),
          date = Event.simpleDateFormat.parse("2019-08-23"),
          publishDate = new Date(1566913355000L),
          org = "ORGNAME",
          orgc = "ORGNAME",
          attributeCount = Some(11),
          distribution = 1,
          attributes = Nil,
          tags = Seq(Tag(Some("1"), "TH-test", Some("#36a3a3"), None), Tag(Some("2"), "TH-test-2", Some("#1ac7c7"), None))
        )
      )
    }
  }

  "MISP service" should {
    "import events" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        app[MispImportSrv].syncMispEvents(app[TheHiveMispClient])
        app[AlertSrv].startTraversal.getBySourceId("misp", "ORGNAME", "1").visible(app[OrganisationSrv]).getOrFail("Alert")
      } must beSuccessfulTry
        .which { alert: Alert =>
          alert must beEqualTo(
            Alert(
              `type` = "misp",
              source = "ORGNAME",
              sourceRef = "1",
              externalLink = Some("https://misp.test/events/1"),
              title = "#1 test1 -> 1.2",
              description = s"Imported from MISP Event #1, created at ${Event.simpleDateFormat.parse("2019-08-23")}",
              severity = 3,
              date = Event.simpleDateFormat.parse("2019-08-23"),
              lastSyncDate = new Date(1566913355000L),
              tlp = 2,
              pap = 2,
              read = false,
              follow = true,
              tags = Seq("src:ORGNAME", "TH-test", "TH-test-2"),
              organisationId = alert.organisationId,
              caseId = EntityId.empty
            )
          )
        }
        .eventually(5, 100.milliseconds)

      val observables = app[Database]
        .roTransaction { implicit graph =>
          app[AlertSrv]
            .startTraversal
            .getBySourceId("misp", "ORGNAME", "1")
            .observables
            .richObservable
            .toList
        }
        .map(o => (o.dataType, o.data, o.tlp, o.message, o.tags.toSet))
      observables must contain(
        ("filename", Some("plop"), 0, Some(""), Set("TH-test", "misp.category=\"Artifacts dropped\"", "misp.type=\"filename\""))
      )
    }
  }
}

```

`misp/connector/src/test/scala/org/thp/thehive/connector/misp/services/TestMispClientProvider.scala`:

```scala
package org.thp.thehive.connector.misp.services

import mockws.MockWS
import org.thp.client.NoAuthentication
import org.thp.misp.client.MispPurpose
import play.api.http.FileMimeTypes
import play.api.libs.json.{JsValue, Json}
import play.api.mvc.{DefaultActionBuilder, Results}
import play.api.test.Helpers.{GET, POST}

import javax.inject.{Inject, Provider}
import scala.concurrent.ExecutionContext
import scala.io.Source

class TestMispClientProvider @Inject() (Action: DefaultActionBuilder, implicit val fileMimeTypes: FileMimeTypes, implicit val ec: ExecutionContext)
    extends Provider[TheHiveMispClient] {
  val baseUrl = "https://misp.test/"

  val ws: MockWS = MockWS {
    case (GET, "https://misp.test/users/view/me")        => Action(Results.Ok.sendResource("user.json"))
    case (GET, "https://misp.test/organisations/view/1") => Action(Results.Ok.sendResource("organisation.json"))
    case (POST, "https://misp.test/events/index")        => Action(Results.Ok.sendResource("events.json"))
    case (POST, "https://misp.test/attributes/restSearch/json") =>
      Action { request =>
        val predicate = request
          .body
          .asJson
          .fold((_: JsValue) => true) {
            json =>
//            println(s"Filter is $json")
              (attr: JsValue) =>
                (json \ "request" \ "timestamp").asOpt[Long].fold(true)(d => (attr \ "timestamp").asOpt[String].exists(_.toLong > d * 1000)) &&
                (json \ "request" \ "eventid").asOpt[String].fold(true)(e => (attr \ "event_id").asOpt[String].filter(_ == "1").contains(e))
          }
        val attributes = readResourceAsJson("/attributes.json").as[Seq[JsValue]].filter { a =>
          val f = predicate(a)
//          println(s"attribute: $a => $f")
          f
        }
        Results.Ok(Json.obj("response" -> Json.obj("Attribute" -> attributes)))
      }
    case (GET, "https://misp.test/attributes/download/3") => Action(Results.Ok.sendResource("user.json"))
    case (GET, "https://misp.test/attributes/download/9") => Action(Results.Ok.sendResource("user.json"))
    case _                                                => Action(Results.NotFound)
  }

  def readResourceAsJson(name: String): JsValue = {
    val dataSource = Source.fromFile(getClass.getResource(name).getPath)
    val data       = dataSource.mkString
    dataSource.close()
    Json.parse(data)
  }

  override def get(): TheHiveMispClient =
    new TheHiveMispClient(
      name = "test",
      baseUrl = baseUrl,
      auth = NoAuthentication,
      ws = ws,
      maxAttributes = None,
      maxAge = None,
      excludedOrganisations = Nil,
      whitelistOrganisations = Nil,
      excludedTags = Set.empty,
      whitelistTags = Set.empty,
      purpose = MispPurpose.ImportAndExport,
      caseTemplate = None,
      observableTags = Seq("TEST"),
      exportCaseTags = true,
      exportObservableTags = true,
      includedTheHiveOrganisations = Seq("*"),
      excludedTheHiveOrganisations = Nil
    )
}

```

`package.sbt`:

```sbt
import Common.remapPath
// Remove conf files
// Install service files
mappings in Universal ~= {
  _.flatMap {
    case (_, "conf/application.conf")           => Nil
    case (file, "conf/application.sample.conf") => Seq(file -> "conf/application.conf")
    case (_, "conf/logback.xml")                => Nil
    case (_, "conf/logback-migration.xml")      => Nil
    case other                                  => Seq(other)
  } ++ Seq(
    file("package/logback.xml")           -> "conf/logback.xml",
    file("package/logback-migration.xml") -> "conf/logback-migration.xml"
  )
}

// Package //
packageName := "thehive4"
maintainer := "TheHive Project <support@thehive-project.org>"
packageSummary := "Scalable, Open Source and Free Security Incident Response Solutions"
packageDescription :=
  """TheHive is a scalable 3-in-1 open source and free security incident response
    | platform designed to make life easier for SOCs, CSIRTs, CERTs and any
    | information security practitioner dealing with security incidents that need to
    | be investigated and acted upon swiftly.""".stripMargin
defaultLinuxInstallLocation := "/opt"
linuxPackageMappings ~= {
  _.map { pm =>
    val mappings = pm
      .mappings
      .map(remapPath("thehive4", "thehive", "/etc", "/opt", "/var/log"))
      .filterNot {
        case (_, path) => path.startsWith("/opt/thehive/conf") || path.startsWith("/usr/bin")
      }
    com.typesafe.sbt.packager.linux.LinuxPackageMapping(mappings, pm.fileData)
  }
}
linuxPackageMappings ++= Seq(
  packageMapping(
    file("package/thehive.service") -> "/usr/lib/systemd/system/thehive.service"
  ).withPerms("644"),
  packageMapping(
    file("package/thehive.default")       -> "/etc/default/thehive",
    file("conf/application.sample.conf")  -> "/etc/thehive/application.conf",
    file("package/logback.xml")           -> "/etc/thehive/logback.xml",
    file("package/logback-migration.xml") -> "/etc/thehive/logback-migration.xml"
  ).withPerms("644").withConfig()
)
daemonUser := "thehive"
bashScriptEnvConfigLocation := None

```

`package/debian/postinst`:

```
#!/bin/sh
set -e
# #######################################
# ## SBT Native Packager Bash Library  ##
# #######################################

# Adding system user
# $1 = user
# $2 = uid
# $3 = group
# $4 = description
# $5 = shell (defaults to /bin/false)
addUser() {
  user="$1"
  if [ -z "$user" ]; then
    echo "usage: addUser user [group] [description] [shell]"
    exit 1
  fi
    uid="$2"
    if [ -z "$uid" ]; then
      uid_flags=""
    else
      uid_flags="--uid $uid"
    fi
    group=${3:-$user}
    descr=${4:-No description}
    shell=${5:-/bin/false}
    if ! getent passwd | grep -q "^$user:"; then
      echo "Creating system user: $user in $group with $descr and shell $shell"
      useradd $uid_flags --gid $group -r --shell $shell -c "$descr" $user
    fi
}

# Adding system group
# $1 = group
# $2 = gid
addGroup() {
  group="$1"
  gid="$2"
  if [ -z "$gid" ]; then
    gid_flags=""
  else
    gid_flags="--gid $gid"
  fi
  if ! getent group | grep -q "^$group:"; then
    echo "Creating system group: $group"
    groupadd $gid_flags -r $group
  fi
}

# Will return true even if deletion fails
# $1 = user
deleteUser() {
  if hash deluser 2>/dev/null; then
    deluser --quiet --system $1 > /dev/null || true
  elif hash userdel 2>/dev/null; then
    userdel $1
  else
    echo "WARNING: Could not delete user $1 . No suitable program (deluser, userdel) found"
  fi
}

# Will return true even if deletion fails
# $1 = group
deleteGroup() {
  if hash delgroup 2>/dev/null; then
    delgroup --quiet --system $1 > /dev/null || true
  elif hash groupdel 2>/dev/null; then
    groupdel $1
  else
   echo "WARNING: Could not delete user $1 . No suitable program (delgroup, groupdel) found"
  fi
}

# #######################################

case "$1" in
  configure)
    # Adding system user/group : thehive and thehive
    addGroup thehive ""
    addUser thehive "" thehive "thehive daemon-user" "/bin/false"
    # Generate secret key
    if ! test -e /etc/thehive/secret.conf; then
      key=$(dd if=/dev/urandom bs=1024 count=1 | tr -dc 'a-zA-Z0-9' | fold -w 64 | head -n 1)
      echo "play.http.secret.key=\"$key\"" > /etc/thehive/secret.conf
    fi

    # Chown definitions created by SBT Native Packager
    mkdir -p /var/log/thehive /opt/thp/thehive/index /opt/thp/thehive/database /opt/thp/thehive/files
    touch /var/log/thehive/application.log
    chown -R thehive:thehive /var/log/thehive /opt/thp/thehive/index /opt/thp/thehive/database /opt/thp/thehive/files
    chown root:thehive /etc/thehive/application.conf /etc/thehive/logback.xml /etc/thehive/secret.conf
    chmod 0640 /etc/thehive/application.conf /etc/thehive/logback.xml /etc/thehive/secret.conf
    test -x /bin/systemctl && /bin/systemctl daemon-reload || /bin/true
    test -n "$2" && service thehive start
    exit 0
  ;;
  abort-upgrade|abort-remove|abort-deconfigure)
  ;;
  *)
    echo "postinst called with unknown argument \`$1'" >&2
    exit 1
  ;;
esac

```

`package/debian/postrm`:

```
#!/bin/sh
set -e
# #######################################
# ## SBT Native Packager Bash Library  ##
# #######################################

# Adding system user
# $1 = user
# $2 = uid
# $3 = group
# $4 = description
# $5 = shell (defaults to /bin/false)
addUser() {
  user="$1"
  if [ -z "$user" ]; then
    echo "usage: addUser user [group] [description] [shell]"
    exit 1
  fi
    uid="$2"
    if [ -z "$uid" ]; then
      uid_flags=""
    else
      uid_flags="--uid $uid"
    fi
    group=${3:-$user}
    descr=${4:-No description}
    shell=${5:-/bin/false}
    if ! getent passwd | grep -q "^$user:"; then
      echo "Creating system user: $user in $group with $descr and shell $shell"
      useradd $uid_flags --gid $group -r --shell $shell -c "$descr" $user
    fi
}

# Adding system group
# $1 = group
# $2 = gid
addGroup() {
  group="$1"
  gid="$2"
  if [ -z "$gid" ]; then
    gid_flags=""
  else
    gid_flags="--gid $gid"
  fi
  if ! getent group | grep -q "^$group:"; then
    echo "Creating system group: $group"
    groupadd $gid_flags -r $group
  fi
}

# Will return true even if deletion fails
# $1 = user
deleteUser() {
  if hash deluser 2>/dev/null; then
    deluser --quiet --system $1 > /dev/null || true
  elif hash userdel 2>/dev/null; then
    userdel $1
  else
    echo "WARNING: Could not delete user $1 . No suitable program (deluser, userdel) found"
  fi
}

# Will return true even if deletion fails
# $1 = group
deleteGroup() {
  if hash delgroup 2>/dev/null; then
    delgroup --quiet --system $1 > /dev/null || true
  elif hash groupdel 2>/dev/null; then
    groupdel $1
  else
   echo "WARNING: Could not delete user $1 . No suitable program (delgroup, groupdel) found"
  fi
}

# #######################################


# Deleting user: ${{user}} and group: ${{group}}
case "$1" in
   remove|failed-upgrade|abort-upgrade|abort-install|disappear)
   ;;
   purge)
	deleteUser thehive
	deleteGroup thehive
   ;;
   upgrade)
   ;;
   *)
      echo "postinst called with unknown argument \`\$1'" >&2
   ;;
esac
# ------------------------------------------------------------------------------------
#   ____                                _             _          _
# / ___|  ___ _ ____   _____ _ __     / \   _ __ ___| |__   ___| |_ _   _ _ __   ___
# \___ \ / _ \ '__\ \ / / _ \ '__|   / _ \ | '__/ __| '_ \ / _ \ __| | | | '_ \ / _ \
#  ___) |  __/ |   \ V /  __/ |     / ___ \| | | (__| | | |  __/ |_| |_| | |_) |  __/
# |____/ \___|_|    \_/ \___|_|    /_/   \_\_|  \___|_| |_|\___|\__|\__, | .__/ \___|
#                                                                   |___/|_|
# ------------------------------------------------------------------------------------

# empty

```

`package/debian/prerm`:

```
#!/bin/sh
set -e
# #######################################
# ## SBT Native Packager Bash Library  ##
# #######################################

# Adding system user
# $1 = user
# $2 = uid
# $3 = group
# $4 = description
# $5 = shell (defaults to /bin/false)
addUser() {
  user="$1"
  if [ -z "$user" ]; then
    echo "usage: addUser user [group] [description] [shell]"
    exit 1
  fi
    uid="$2"
    if [ -z "$uid" ]; then
      uid_flags=""
    else
      uid_flags="--uid $uid"
    fi
    group=${3:-$user}
    descr=${4:-No description}
    shell=${5:-/bin/false}
    if ! getent passwd | grep -q "^$user:"; then
      echo "Creating system user: $user in $group with $descr and shell $shell"
      useradd $uid_flags --gid $group -r --shell $shell -c "$descr" $user
    fi
}

# Adding system group
# $1 = group
# $2 = gid
addGroup() {
  group="$1"
  gid="$2"
  if [ -z "$gid" ]; then
    gid_flags=""
  else
    gid_flags="--gid $gid"
  fi
  if ! getent group | grep -q "^$group:"; then
    echo "Creating system group: $group"
    groupadd $gid_flags -r $group
  fi
}

# Will return true even if deletion fails
# $1 = user
deleteUser() {
  if hash deluser 2>/dev/null; then
    deluser --quiet --system $1 > /dev/null || true
  elif hash userdel 2>/dev/null; then
    userdel $1
  else
    echo "WARNING: Could not delete user $1 . No suitable program (deluser, userdel) found"
  fi
}

# Will return true even if deletion fails
# $1 = group
deleteGroup() {
  if hash delgroup 2>/dev/null; then
    delgroup --quiet --system $1 > /dev/null || true
  elif hash groupdel 2>/dev/null; then
    groupdel $1
  else
   echo "WARNING: Could not delete user $1 . No suitable program (delgroup, groupdel) found"
  fi
}

# #######################################

# ------------------------------------------------------------------------------------
#   ____                                _             _          _
# / ___|  ___ _ ____   _____ _ __     / \   _ __ ___| |__   ___| |_ _   _ _ __   ___
# \___ \ / _ \ '__\ \ / / _ \ '__|   / _ \ | '__/ __| '_ \ / _ \ __| | | | '_ \ / _ \
#  ___) |  __/ |   \ V /  __/ |     / ___ \| | | (__| | | |  __/ |_| |_| | |_) |  __/
# |____/ \___|_|    \_/ \___|_|    /_/   \_\_|  \___|_| |_|\___|\__|\__, | .__/ \___|
#                                                                   |___/|_|
# ------------------------------------------------------------------------------------

#
# Adding service to autostart
# $1 = service name
#
startService() {
    app_name=$1
    initctl reload-configuration
    service $app_name start
}

#
# Removing service from autostart
# $1 = service name
#
stopService() {
    app_name=$1
    service $app_name stop
}

#
# Restarting the service after package upgrade
# $1 = service name
#
restartService() {
    app_name=$1
    initctl reload-configuration
    service $app_name start
}


stopService thehive || echo "thehive wasn't even running!"

```

`package/docker/Dockerfile`:

```
# This Dockerfile is not the one used for official Docker image of TheHive but the result image should be identical
# Official image are generated by sbt (with the command sbt docker:publishLocal)
# This Dockerfile is largely inspired by https://github.com/ilyaglow/dockerfiles/blob/master/thehive/Dockerfile

FROM openjdk:8 as build-env

LABEL MAINTAINER="TheHive Project <support@thehive-project.org>"

ARG THEHIVE_VERSION=develop

RUN apt update && \
  apt install -y apt-transport-https && \
  curl -sL https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash - && \
  export NVM_DIR="${HOME}/.nvm" && \
  . "$NVM_DIR/nvm.sh" && \
  nvm install --lts && \
  apt-get install -y git && \
  npm install -g grunt-cli \
                 bower && \
  git -c advice.detachedHead=false \
      clone \
      --branch=$THEHIVE_VERSION \
      --depth=1 \
      https://github.com/TheHive-Project/TheHive.git && \
  echo '{"allow_root": true}' > /root/.bowerrc && \
  cd TheHive && \
  ./sbt clean stage && \
  mv /TheHive/target/universal/stage /opt/thehive && \
  mv /TheHive/package/docker/entrypoint /opt/thehive/entrypoint && \
  mkdir /var/log/thehive && \
  apt-get purge -y git && \
  rm -rf /TheHive \
         /root/* \
         /root/.nvm \
         /root/.m2 \
         /root/.ivy2 \
         /root/.sbt \
         /var/lib/apt/lists/*

FROM openjdk:8
COPY --from=build-env /opt/thehive /opt/thehive
COPY --from=build-env /var/log/thehive /var/log/thehive

RUN apt update && \
  apt upgrade -y && \
  apt autoclean -y -q && \
  apt autoremove -y -q && \
  rm -rf /var/lib/apt/lists/* && \
  ( type groupadd 1>/dev/null 2>&1 && \
    groupadd -g 1000 thehive || \
    addgroup -g 1000 -S thehive ) && \
  ( type useradd 1>/dev/null 2>&1 && \
    useradd --system --uid 1000 --gid 1000 thehive || \
    adduser -S -u 1000 -G thehive thehive ) && \
  mkdir /etc/thehive && \
  cp /opt/thehive/conf/logback.xml /etc/thehive/logback.xml && \
  chown -R root:root /opt/thehive && \
  touch /var/log/thehive/application.log && \
  chown -R thehive:thehive /var/log/thehive /etc/thehive && \
  chmod +x /opt/thehive/entrypoint

USER thehive

EXPOSE 9000

WORKDIR /opt/thehive

ENTRYPOINT ["/opt/thehive/entrypoint"]

```

`package/docker/entrypoint`:

```
#!/bin/bash
CQL_HOSTNAMES=${TH_CQL_HOSTNAMES:-cassandra}
BDB_DIRECTORY=${TH_BDB_DIRECTORY:-/data/db}
INDEX_DIRECTORY=${TH_INDEX_DIRECTORY:-/data/index}
HDFS_URL=${TH_HDFS_URL}
STORAGE_DIRECTORY=${TH_STORAGE_DIRECTORY:-/data/files}
test "${TH_NO_CONFIG_SECRET}" == 1
CONFIG_SECRET=$?
SECRET=${TH_SECRET}
SHOW_SECRET=${TH_SHOW_SECRET:-0}
test "${TH_NO_CONFIG_DB}" == 1
CONFIG_DB=$?
test "${TH_NO_CONFIG_STORAGE}" == 1
CONFIG_STORAGE=$?
test "${TH_NO_CONFIG_CORTEX}" == 1
CONFIG_CORTEX=$?
CORTEX_HOSTNAMES=${TH_CORTEX_HOSTNAMES:-cortex}
CORTEX_PROTO=${TH_CORTEX_PROTO:-http}
CORTEX_PORT=${TH_CORTEX_PORT:-9001}
test "${TH_NO_CONFIG}" == 1
CONFIG=$?
CONFIG_FILE=${TH_CONFIG_FILE:-/etc/thehive/application.conf}
CORTEX_KEYS=${TH_CORTEX_KEYS}
MIGRATE=${TH_MIGRATE:-0}
CLONER=${TH_CLONER:-0}

function usage {
  cat <<- _EOF_
    Available options:
    --config-file <file>                        | configuration file path
    --no-config                                 | do not try to configure TheHive (add secret and elasticsearch)
    --no-config-secret                          | do not add random secret to configuration
    --secret <secret>                           | secret to secure sessions
    --show-secret                               | show the generated secret
    --no-config-db                              | do not configure database automatically
    --cql-hostnames <host>,<host>,...           | resolve these hostnames to find cassandra instances
    --cql-username <username>                   | username of cassandra database
    --cql-password <password>                   | password of cassandra database
    --bdb-directory <path>                      | location of local database, if cassandra is not used (default: /data/db)
    --no-config-storage                         | do not configure storage automatically
    --hdfs-url <url>                            | url of hdfs name node
    --storage-directory <path>                  | location of local storage, if hdfs is not used (default: /data/files)
    --no-config-cortex                          | do not add Cortex configuration
    --cortex-proto <proto>                      | define protocol to connect to Cortex (default: http)
    --cortex-port <port>                        | define port to connect to Cortex (default: 9001)
    --cortex-hostnames <host>,<host>,...        | resolve this hostname to find Cortex instances
    --cortex-keys <key>,<key>,...               | define Cortex key
    migrate <param> <param> ...                 | run migration tool
    cloner <param> <param> ...                  | run cloner tool
_EOF_
  exit 1
}


STOP=0
while test $# -gt 0 -a "${STOP}" = 0
do
  case "$1" in
    "--config-file")       shift; CONFIG_FILE=$1 ;;
    "--no-config")         CONFIG=0 ;;
    "--no-config-secret")  CONFIG_SECRET=0 ;;
    "--secret")            shift; SECRET=$1 ;;
    "--show-secret")       SHOW_SECRET=1 ;;
    "--no-config-db")      CONFIG_DB=0 ;;
    "--cql-hostnames")     shift; CQL_HOSTNAMES=$1 ;;
    "--cql-username")      shift; CQL_USERNAME=$1 ;;
    "--cql-password")      shift; CQL_PASSWORD=$1 ;;
    "--bdb-directory")     shift; BDB_DIRECTORY=$1 ;;
    "--index-directory")   shift; INDEX_DIRECTORY=$1 ;;
    "--no-config-storage") CONFIG_STORAGE=0 ;;
    "--hdfs-url")          shift; HDFS_URL=$1 ;;
    "--storage-directory") shift; STORAGE_DIRECTORY=$1 ;;
    "--no-config-cortex")  CONFIG_CORTEX=0 ;;
    "--cortex-proto")      shift; CORTEX_PROTO=$1 ;;
    "--cortex-port")       shift; CORTEX_PORT=$1 ;;
    "--cortex-hostnames")  shift; CORTEX_HOSTNAMES=$1 ;;
    "--cortex-keys")       shift; CORTEX_KEYS=$1 ;;
    "--")                  STOP=1 ;;
    "migrate")             MIGRATE=1; STOP=1 ;;
    "cloner")              CLONER=1; STOP=1 ;;
    *)                     echo param is -"$1"-; usage
  esac
  shift
done

if test "${MIGRATE}" = 1
then
  bin/migrate "$@"
  exit $?
fi

if test "${CLONER}" = 1
then
  bin/cloner "$@"
  exit $?
fi

if test "${CONFIG}" = 1
then
  CONFIG_FILE=$(mktemp --tmpdir thehive-XXXXXX.conf)
  if test "${CONFIG_SECRET}" = 1
  then
    if test -z "${SECRET}"
    then
      SECRET=$(dd if=/dev/urandom bs=1024 count=1 | tr -dc 'a-zA-Z0-9' | fold -w 64 | head -n 1)
      test "${SHOW_SECRET}" = 1 && echo "Using secret: ${SECRET}"
    fi
    echo "play.http.secret.key = \"${SECRET}\"" >> "${CONFIG_FILE}"
  fi

  if test "${CONFIG_DB}" = 1
  then
    IFS=',' read -r -a CQL_HOSTS <<< "${CQL_HOSTNAMES}"
    declare -a CQL
    for C in "${CQL_HOSTS[@]}"
    do
      for IP in $(getent ahostsv4 "$C" | awk '{ print $1 }' | sort -u)
      do
        CQL+=("$IP")
      done
    done
    echo "db.janusgraph {" >> "${CONFIG_FILE}"
    if test "${#CQL[@]}" = 0
    then
      echo "Local database in ${BDB_DIRECTORY} is be used"
      mkdir -p "${BDB_DIRECTORY}"
      echo "storage.backend = berkeleyje"             >> "${CONFIG_FILE}"
      echo "storage.directory = \"${BDB_DIRECTORY}\"" >> "${CONFIG_FILE}"
      echo "berkeleyje.freeDisk = 1"                  >> "${CONFIG_FILE}"
      if test -e "${BDB_DIRECTORY}"
      then
        test -w "${BDB_DIRECTORY}" || echo "WARNING the directory used to store database ($BDB_DIRECTORY) is not writable"
      else
        mkdir -p "${BDB_DIRECTORY}" || echo "WARNING the directory used to store database ($BDB_DIRECTORY) is not writable"
      fi
    else
      echo "Using cassandra address = ${CQL[*]}"
      echo "storage.backend = cql"            >> "${CONFIG_FILE}"
      if [[ -n $CQL_USERNAME && -n $CQL_PASSWORD ]]
      then
        echo "storage.username = \"${CQL_USERNAME}\"" >> "${CONFIG_FILE}"
        echo "storage.password = \"${CQL_PASSWORD}\"" >> "${CONFIG_FILE}"
        echo "Using ${CQL_USERNAME} as cassandra username and ${CQL_PASSWORD} as its password"
      fi
      echo "storage.cql.cluster-name = thp"   >> "${CONFIG_FILE}"
      echo "storage.cql.keyspace = thehive"   >> "${CONFIG_FILE}"
      echo "storage.hostname = ["             >> "${CONFIG_FILE}"
      printf '%s\n' "${CQL_HOSTS[@]}"         >> "${CONFIG_FILE}"
      echo "]"                                >> "${CONFIG_FILE}"
      echo "Waiting until Cassandra DB is up"
      sleep 30   # Sleep until cassandra Db is up
    fi
    echo "index.search.backend = lucene"                   >> "${CONFIG_FILE}"
    echo "index.search.directory = \"${INDEX_DIRECTORY}\"" >> "${CONFIG_FILE}"
    if test -e "${INDEX_DIRECTORY}"
    then
      test -w "${INDEX_DIRECTORY}" || echo "WARNING the directory used to store index ($INDEX_DIRECTORY) is not writable"
    else
      mkdir -p "${INDEX_DIRECTORY}" || echo "WARNING the directory used to store index ($INDEX_DIRECTORY) is not writable"
    fi
    echo "}" >> "${CONFIG_FILE}"
  fi

  if test "${CONFIG_STORAGE}" = 1
  then
    echo "storage {" >> "${CONFIG_FILE}"
    if test -n "${HDFS_URL}"
    then
      echo "Using HDFS ${HDFS_URL}"
      echo "provider: hdfs"          >> "${CONFIG_FILE}"
      echo "hdfs {"                  >> "${CONFIG_FILE}"
      echo "root: \"${HDFS_URL}\""   >> "${CONFIG_FILE}"
      echo "location: \"/thehive\""  >> "${CONFIG_FILE}"
      echo "username: thehive"       >> "${CONFIG_FILE}"
      echo "}"                       >> "${CONFIG_FILE}"
    else
      echo "Using local storage in ${STORAGE_DIRECTORY}"
      mkdir -p "${STORAGE_DIRECTORY}"
      echo "provider: localfs"                           >> "${CONFIG_FILE}"
      echo "localfs.directory: \"${STORAGE_DIRECTORY}\"" >> "${CONFIG_FILE}"
      if test -e "${STORAGE_DIRECTORY}"
      then
        test -w "${STORAGE_DIRECTORY}" || echo "WARNING the directory used to store files ($STORAGE_DIRECTORY) is not writable"
      else
        mkdir -p "${STORAGE_DIRECTORY}" || echo "WARNING the directory used to store files ($STORAGE_DIRECTORY) is not writable"
      fi
    fi
    echo "}" >> "${CONFIG_FILE}"
  fi

  if test "${CONFIG_CORTEX}" = 1
  then
    declare -a CORTEX_URLS
    IFS=',' read -r -a CH <<< "${CORTEX_HOSTNAMES}"
    IFS=',' read -r -a CK <<< "${CORTEX_KEYS}"
    for C in "${CH[@]}"
    do
      test -n "${C}" && CORTEX_URLS+=("${CORTEX_PROTO}://${C}:${CORTEX_PORT}")
    done
    if test ${#CORTEX_URLS[@]} -gt 0
    then
      echo "play.modules.enabled += org.thp.thehive.connector.cortex.CortexModule" >> "${CONFIG_FILE}"
      echo "cortex.servers = [" >> "${CONFIG_FILE}"
      I=0
      for C in "${CORTEX_URLS[@]}"
      do
        echo "Add Cortex cortex${I}: ${C}"
        echo "{"                   >> "${CONFIG_FILE}"
        echo "name = cortex${I}"   >> "${CONFIG_FILE}"
        echo "url = \"$C\""        >> "${CONFIG_FILE}"
        echo "auth {"              >> "${CONFIG_FILE}"
        echo "type = \"bearer\""   >> "${CONFIG_FILE}"
        echo "key = \"${CK[$I]}\"" >> "${CONFIG_FILE}"
        echo "}"                   >> "${CONFIG_FILE}"
        echo "}"                   >> "${CONFIG_FILE}"
        I=$((I+1))
      done
      echo "]"  >> "${CONFIG_FILE}"
    fi
  fi

  echo "include file(\"/etc/thehive/application.conf\")" >> "${CONFIG_FILE}"
fi

bin/thehive \
  -Dconfig.file="${CONFIG_FILE}" \
  -Dlogger.file=/etc/thehive/logback.xml \
  -Dpidfile.path=/dev/null \
  "$@"
PID=$!
trap 'kill -SIGTERM "${PID}"; wait "${PID}"; exit 143' SIGTERM SIGINT
wait ${PID}

```

`package/logback-migration.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="false">

    <conversionRule conversionWord="coloredLevel"
                    converterClass="play.api.libs.logback.ColoredLevel"/>

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>/var/log/thehive/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
            <fileNamePattern>/var/log/logs/application.%i.log.zip</fileNamePattern>
            <minIndex>1</minIndex>
            <maxIndex>10</maxIndex>
        </rollingPolicy>
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <maxFileSize>10MB</maxFileSize>
        </triggeringPolicy>
        <encoder>
            <pattern>%date [%level] from %logger in %thread [%X{request}|%X{tx}] %message%n%xException</pattern>
        </encoder>
    </appender>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%coloredLevel %message%n%xException{10}
            </pattern>
        </encoder>
    </appender>

    <appender name="ASYNCFILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
    </appender>

    <appender name="ASYNCSTDOUT" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="STDOUT"/>
    </appender>

    <logger name="org.thp" level="INFO"/>

    <root level="OFF">
        <appender-ref ref="ASYNCFILE"/>
        <appender-ref ref="ASYNCSTDOUT"/>
    </root>

</configuration>

```

`package/logback.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="false">

    <conversionRule conversionWord="coloredLevel"
                    converterClass="play.api.libs.logback.ColoredLevel"/>

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>/var/log/thehive/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
            <fileNamePattern>/var/log/thehive/application.%i.log.zip</fileNamePattern>
            <minIndex>1</minIndex>
            <maxIndex>10</maxIndex>
        </rollingPolicy>
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <maxFileSize>10MB</maxFileSize>
        </triggeringPolicy>
        <encoder>
            <pattern>%date [%level] from %logger in %thread [%X{request}|%X{tx}] %message%n%xException</pattern>
        </encoder>
    </appender>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%coloredLevel %logger{15} [%X{request}|%X{tx}] %message%n%xException{10}
            </pattern>
        </encoder>
    </appender>

    <appender name="ASYNCFILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
    </appender>

    <appender name="ASYNCSTDOUT" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="STDOUT"/>
    </appender>

    <!-- do not set the following logger to TRACE -->
    <logger name="org.thp.scalligraph.traversal" level="INFO"/>
    <logger name="org.reflections8.Reflections" level="ERROR" />
    <logger name="org.janusgraph.graphdb.database.management.ManagementLogger" level="OFF"/>
    <logger name="org.janusgraph.graphdb.database.IndexSerializer" level="ERROR"/>

    <logger name="org.thp" level="INFO"/>

    <root level="INFO">
        <appender-ref ref="ASYNCFILE"/>
        <appender-ref ref="ASYNCSTDOUT"/>
    </root>

</configuration>

```

`package/rpm-release/thehive-rpm.repo`:

```repo
[thehive-project-stable]
name=TheHive Project Repository (stable)
baseurl=https://rpm.thehive-project.org/stable/noarch
gpgcheck=1
repo_gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/GPG-TheHive-Project

[thehive-project-beta]
name=TheHive Project Repository (beta)
baseurl=https://rpm.thehive-project.org/beta/noarch
gpgcheck=1
repo_gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/GPG-TheHive-Project

```

`package/rpm/post`:

```
# Chown definitions created by SBT Native Packager

# Generate secret key
if ! test -e /etc/thehive/secret.conf; then
  key=$(dd if=/dev/urandom bs=1024 count=1 | tr -dc 'a-zA-Z0-9' | fold -w 64 | head -n 1)
  echo "play.http.secret.key=\"$key\"" > /etc/thehive/secret.conf
fi

chown root:thehive /etc/thehive/application.conf /etc/thehive/logback.xml /etc/thehive/secret.conf
chmod 0640 /etc/thehive/application.conf /etc/thehive/logback.xml /etc/thehive/secret.conf
if test -x /bin/systemctl; then
 	/bin/systemctl daemon-reload || /bin/true
 fi

mkdir -p /var/log/thehive /opt/thp/thehive/index /opt/thp/thehive/database /opt/thp/thehive/files
touch /var/log/thehive/application.log
chown -R thehive:thehive /var/log/thehive /opt/thp/thehive/index /opt/thp/thehive/database /opt/thp/thehive/files


```

`package/rpm/postun`:

```
# #######################################
# ## SBT Native Packager Bash Library  ##
# #######################################

# Adding system user
# $1 = user
# $2 = uid
# $3 = group
# $4 = description
# $5 = shell (defaults to /bin/false)
addUser() {
  user="$1"
  if [ -z "$user" ]; then
    echo "usage: addUser user [group] [description] [shell]"
    exit 1
  fi
    uid="$2"
    if [ -z "$uid" ]; then
      uid_flags=""
    else
      uid_flags="--uid $uid"
    fi
    group=${3:-$user}
    descr=${4:-No description}
    shell=${5:-/bin/false}
    if ! getent passwd | grep -q "^$user:"; then
      echo "Creating system user: $user in $group with $descr and shell $shell"
      useradd $uid_flags --gid $group -r --shell $shell -c "$descr" $user
    fi
}

# Adding system group
# $1 = group
# $2 = gid
addGroup() {
  group="$1"
  gid="$2"
  if [ -z "$gid" ]; then
    gid_flags=""
  else
    gid_flags="--gid $gid"
  fi
  if ! getent group | grep -q "^$group:"; then
    echo "Creating system group: $group"
    groupadd $gid_flags -r $group
  fi
}

# Will return true even if deletion fails
# $1 = user
deleteUser() {
  if hash deluser 2>/dev/null; then
    deluser --quiet --system $1 > /dev/null || true
  elif hash userdel 2>/dev/null; then
    userdel $1
  else
    echo "WARNING: Could not delete user $1 . No suitable program (deluser, userdel) found"
  fi
}

# Will return true even if deletion fails
# $1 = group
deleteGroup() {
  if hash delgroup 2>/dev/null; then
    delgroup --quiet --system $1 > /dev/null || true
  elif hash groupdel 2>/dev/null; then
    groupdel $1
  else
   echo "WARNING: Could not delete user $1 . No suitable program (delgroup, groupdel) found"
  fi
}

# #######################################

#
# Adding service to autostart
# $1 = service name
#
startService() {
    app_name=$1
    if hash update-rc.d >/dev/null 2>&1; then
		echo "Adding $app_name to autostart using update-rc.d"
		update-rc.d $app_name defaults
		service $app_name start
    elif hash chkconfig >/dev/null 2>&1; then
		echo "Adding $app_name to autostart using chkconfig"
		chkconfig --add thehive
		chkconfig $app_name on
		service $app_name start
    else
		echo "WARNING: Could not add $app_name to autostart: neither update-rc nor chkconfig found!"
    fi
}

#
# Removing service from autostart
# $1 = service name
#
stopService() {
    app_name=$1
    if hash update-rc.d >/dev/null 2>&1; then
	echo "Removing $app_name from autostart using update-rc.d"
	update-rc.d -f $app_name remove
	service $app_name stop
    elif hash chkconfig >/dev/null 2>&1; then
	echo "Removing $app_name from autostart using chkconfig"
	chkconfig $app_name off
	chkconfig --del $app_name
	service $app_name stop
    else
	echo "WARNING: Could not remove $app_name from autostart: neither update-rc nor chkconfig found!"
    fi

}

#
# Restarting the service after package upgrade
# $1 = service name
#
restartService() {
	app_name=$1
	service $app_name restart
}


# Removing system user/group : thehive and thehive

# Scriptlet syntax: http://fedoraproject.org/wiki/Packaging:ScriptletSnippets#Syntax
# $1 == 1 is upgrade and $1 == 0 is uninstall

if [ $1 -eq 0 ] ;
then
    echo "Try deleting system user and group [thehive:thehive]"
    if getent passwd | grep -q "^thehive:";
    then
	echo "Deleting system user: thehive"
	deleteUser thehive
    fi
    if getent group | grep -q "^thehive:" ;
    then
	echo "Deleting system group: thehive"
	deleteGroup thehive
    fi
else
     restartService thehive || echo "Failed to try-restart thehive"
fi

```

`package/rpm/pre`:

```
# #######################################
# ## SBT Native Packager Bash Library  ##
# #######################################

# Adding system user
# $1 = user
# $2 = uid
# $3 = group
# $4 = description
# $5 = shell (defaults to /bin/false)
addUser() {
  user="$1"
  if [ -z "$user" ]; then
    echo "usage: addUser user [group] [description] [shell]"
    exit 1
  fi
    uid="$2"
    if [ -z "$uid" ]; then
      uid_flags=""
    else
      uid_flags="--uid $uid"
    fi
    group=${3:-$user}
    descr=${4:-No description}
    shell=${5:-/bin/false}
    if ! getent passwd | grep -q "^$user:"; then
      echo "Creating system user: $user in $group with $descr and shell $shell"
      useradd $uid_flags --gid $group -r --shell $shell -c "$descr" $user
    fi
}

# Adding system group
# $1 = group
# $2 = gid
addGroup() {
  group="$1"
  gid="$2"
  if [ -z "$gid" ]; then
    gid_flags=""
  else
    gid_flags="--gid $gid"
  fi
  if ! getent group | grep -q "^$group:"; then
    echo "Creating system group: $group"
    groupadd $gid_flags -r $group
  fi
}

# Will return true even if deletion fails
# $1 = user
deleteUser() {
  if hash deluser 2>/dev/null; then
    deluser --quiet --system $1 > /dev/null || true
  elif hash userdel 2>/dev/null; then
    userdel $1
  else
    echo "WARNING: Could not delete user $1 . No suitable program (deluser, userdel) found"
  fi
}

# Will return true even if deletion fails
# $1 = group
deleteGroup() {
  if hash delgroup 2>/dev/null; then
    delgroup --quiet --system $1 > /dev/null || true
  elif hash groupdel 2>/dev/null; then
    groupdel $1
  else
   echo "WARNING: Could not delete user $1 . No suitable program (delgroup, groupdel) found"
  fi
}

# #######################################


# Scriptlet syntax: http://fedoraproject.org/wiki/Packaging:ScriptletSnippets#Syntax
# $1 == 1 is first installation and $1 == 2 is upgrade
# Adding system user/group : thehive and thehive
addGroup thehive ""
addUser thehive "" thehive "thehive user-daemon" "/bin/false"

if [ -e /etc/sysconfig/thehive ] ;
then
  sed -i 's/PACKAGE_PREFIX\=.*//g' /etc/sysconfig/thehive4
fi

if [ -n "$RPM_INSTALL_PREFIX" ] ;
then
  echo "PACKAGE_PREFIX=${RPM_INSTALL_PREFIX}" >> /etc/sysconfig/thehive4
fi

```

`package/rpm/preun`:

```
#
# Adding service to autostart
# $1 = service name
#
startService() {
    app_name=$1
    if hash update-rc.d >/dev/null 2>&1; then
		echo "Adding $app_name to autostart using update-rc.d"
		update-rc.d $app_name defaults
		service $app_name start
    elif hash chkconfig >/dev/null 2>&1; then
		echo "Adding $app_name to autostart using chkconfig"
		chkconfig --add thehive
		chkconfig $app_name on
		service $app_name start
    else
		echo "WARNING: Could not add $app_name to autostart: neither update-rc nor chkconfig found!"
    fi
}

#
# Removing service from autostart
# $1 = service name
#
stopService() {
    app_name=$1
    if hash update-rc.d >/dev/null 2>&1; then
	echo "Removing $app_name from autostart using update-rc.d"
	update-rc.d -f $app_name remove
	service $app_name stop
    elif hash chkconfig >/dev/null 2>&1; then
	echo "Removing $app_name from autostart using chkconfig"
	chkconfig $app_name off
	chkconfig --del $app_name
	service $app_name stop
    else
	echo "WARNING: Could not remove $app_name from autostart: neither update-rc nor chkconfig found!"
    fi

}

#
# Restarting the service after package upgrade
# $1 = service name
#
restartService() {
	app_name=$1
	service $app_name restart
}


# Scriptlet syntax: http://fedoraproject.org/wiki/Packaging:ScriptletSnippets#Syntax
# $1 == 1 is upgrade and $1 == 0 is uninstall
if [ $1 -eq 0 ] ;
then
    stopService thehive || echo "Could not stop thehive"
fi

```

`package/thehive.default`:

```default
# Environment File for TheHive

# JAVA_OPTS for TheHive service can be set here
#JAVA_OPTS=""

```

`package/thehive.service`:

```service
[Unit]
Description=Scalable, Open Source and Free Security Incident Response Solutions
Documentation=https://thehive-project.org
Wants=network-online.target
After=network-online.target

[Service]
EnvironmentFile=-/etc/default/thehive
WorkingDirectory=/opt/thehive

User=thehive
Group=thehive

ExecStart=/opt/thehive/bin/thehive \
	-Dconfig.file=/etc/thehive/application.conf \
	-Dlogger.file=/etc/thehive/logback.xml \
	-Dpidfile.path=/dev/null

StandardOutput=null
StandardError=null

# Specifies the maximum file descriptor number that can be opened by this process
LimitNOFILE=65536

# Disable timeout logic and wait until process is stopped
TimeoutStopSec=0

# SIGTERM signal is used to stop the Java process
KillSignal=SIGTERM

# Java process is never killed
SendSIGKILL=no

# When a JVM receives a SIGTERM signal it exits with code 143
SuccessExitStatus=143

[Install]
WantedBy=multi-user.target

```

`project/Common.scala`:

```scala
import java.io.File
import scala.util.matching.Regex

object Common {
  def remapPath(oldPath: String, newPath: String, prefixes: String*): ((File, String)) => (File, String) = {
    case (file, path) =>
      file -> prefixes
        .find(p => path.startsWith(s"$p/$oldPath"))
        .fold(path)(p => s"$p/$newPath" + path.drop(p.length + 1 + oldPath.length))
  }

  val stableVersion: Regex = "(\\d+\\.\\d+\\.\\d+)-(\\d+)".r
  val betaVersion: Regex   = "(\\d+\\.\\d+\\.\\d+)-[Rr][Cc](\\d+)-(\\d+)".r
  object snapshotVersion {
    def unapply(version: String): Option[String] =
      if (version.endsWith("-SNAPSHOT")) Some(version.dropRight(9))
      else None
  }
  def versionUsage(version: String): Nothing =
    sys.error(
      s"Invalid version: $version\n" +
        "The accepted formats for version are:\n" +
        " - 1.2.3-4\n" +
        " - 1.2.3-RC4-5\n" +
        " - 1.2.3-4-SNAPSHOT\n" +
        " - 1.2.3-RC4-5-SNAPSHOT"
    )
}

```

`project/Dependencies.scala`:

```scala
import sbt._

object Dependencies {
  val janusVersion        = "0.5.3"
  val akkaVersion: String = play.core.PlayVersion.akkaVersion

  lazy val specs                   = "com.typesafe.play"          %% "play-specs2"                        % play.core.PlayVersion.current
  lazy val playLogback             = "com.typesafe.play"          %% "play-logback"                       % play.core.PlayVersion.current
  lazy val playGuice               = "com.typesafe.play"          %% "play-guice"                         % play.core.PlayVersion.current
  lazy val playFilters             = "com.typesafe.play"          %% "filters-helpers"                    % play.core.PlayVersion.current
  lazy val logbackClassic          = "ch.qos.logback"              % "logback-classic"                    % "1.2.8"
  lazy val playMockws              = "de.leanovate.play-mockws"   %% "play-mockws"                        % "2.8.0"
  lazy val akkaActor               = "com.typesafe.akka"          %% "akka-actor"                         % akkaVersion
  lazy val akkaCluster             = "com.typesafe.akka"          %% "akka-cluster"                       % akkaVersion
  lazy val akkaClusterTools        = "com.typesafe.akka"          %% "akka-cluster-tools"                 % akkaVersion
  lazy val akkaClusterTyped        = "com.typesafe.akka"          %% "akka-cluster-typed"                 % akkaVersion
  lazy val akkaHttp                = "com.typesafe.akka"          %% "akka-http"                          % play.core.PlayVersion.akkaHttpVersion
  lazy val akkaHttpXml             = "com.typesafe.akka"          %% "akka-http-xml"                      % play.core.PlayVersion.akkaHttpVersion
  lazy val janusGraph              = "org.janusgraph"              % "janusgraph"                         % janusVersion
  lazy val janusGraphCore          = "org.janusgraph"              % "janusgraph-core"                    % janusVersion
  lazy val janusGraphBerkeleyDB    = "org.janusgraph"              % "janusgraph-berkeleyje"              % janusVersion
  lazy val janusGraphLucene        = "org.janusgraph"              % "janusgraph-lucene"                  % janusVersion
  lazy val janusGraphElasticSearch = "org.janusgraph"              % "janusgraph-es"                      % janusVersion
  lazy val janusGraphCassandra     = "org.janusgraph"              % "janusgraph-cql"                     % janusVersion
  lazy val janusGraphInMemory      = "org.janusgraph"              % "janusgraph-inmemory"                % janusVersion
  lazy val tinkerpop               = "org.apache.tinkerpop"        % "gremlin-core"                       % "3.4.6" // align with janusgraph
  lazy val scalactic               = "org.scalactic"              %% "scalactic"                          % "3.2.3"
  lazy val scalaGuice              = "net.codingwell"             %% "scala-guice"                        % "4.2.11"
  lazy val shapeless               = "com.chuusai"                %% "shapeless"                          % "2.3.3"
  lazy val bouncyCastle            = "org.bouncycastle"            % "bcprov-jdk15on"                     % "1.68"
  lazy val apacheConfiguration     = "commons-configuration"       % "commons-configuration"              % "1.10"
  lazy val macroParadise           = "org.scalamacros"             % "paradise"                           % "2.1.1" cross CrossVersion.full
  lazy val chimney                 = "io.scalaland"               %% "chimney"                            % "0.6.1"
  lazy val reflections             = "org.reflections"             % "reflections"                        % "0.9.12"
  lazy val hadoopClient            = "org.apache.hadoop"           % "hadoop-client"                      % "3.3.2" exclude ("log4j", "log4j")
  lazy val zip4j                   = "net.lingala.zip4j"           % "zip4j"                              % "2.6.4"
  lazy val alpakka                 = "com.lightbend.akka"         %% "akka-stream-alpakka-json-streaming" % "2.0.2"
  lazy val handlebars              = "com.github.jknack"           % "handlebars"                         % "4.2.0"
  lazy val playMailer              = "com.typesafe.play"          %% "play-mailer"                        % "8.0.1"
  lazy val playMailerGuice         = "com.typesafe.play"          %% "play-mailer-guice"                  % "8.0.1"
  lazy val pbkdf2                  = "io.github.nremond"          %% "pbkdf2-scala"                       % "0.6.5"
  lazy val alpakkaS3               = "com.lightbend.akka"         %% "akka-stream-alpakka-s3"             % "2.0.2"
  lazy val commonCodec             = "commons-codec"               % "commons-codec"                      % "1.15"
  lazy val scopt                   = "com.github.scopt"           %% "scopt"                              % "4.0.0"
  lazy val aix                     = "ai.x"                       %% "play-json-extensions"               % "0.42.0"
  lazy val bloomFilter             = "com.github.alexandrnikitin" %% "bloom-filter"                       % "0.13.1"
  lazy val quartzScheduler         = "org.quartz-scheduler"        % "quartz"                             % "2.3.2"

  def scalaReflect(scalaVersion: String)  = "org.scala-lang" % "scala-reflect"  % scalaVersion
  def scalaCompiler(scalaVersion: String) = "org.scala-lang" % "scala-compiler" % scalaVersion
}

```

`project/FileBuilder.scala`:

```scala
import sbt.Keys.TaskStreams
import sbt._

import scala.sys.process.{Process, ProcessLogger}

object FileBuilder {

  def prefixLogs(log: ProcessLogger, prefix: String): ProcessLogger = new ProcessLogger {
    override def out(s: => String): Unit = log.out(s"{$prefix} $s")
    override def err(s: => String): Unit = log.err(s"{$prefix} $s")
    override def buffer[T](f: => T): T   = log.buffer(f)
  }

  def apply(label: String, inputFiles: PathFinder, outputFiles: PathFinder, command: (File, String), streams: TaskStreams): Set[File] = {
    val log = prefixLogs(streams.log, label)
    val cache = FileFunction.cached(streams.cacheDirectory / label) { _ =>
      streams.log.info(s"$label files have been updated")
      val exitCode = Process(command._2, command._1) ! log
      if (exitCode != 0)
        throw new IllegalStateException(s"$command fails")
      outputFiles.get().toSet
    }
    cache(inputFiles.get().toSet)
  }
}

```

`project/build.properties`:

```properties
sbt.version=1.4.6

```

`project/plugins.sbt`:

```sbt
addSbtPlugin("com.typesafe.play"   % "sbt-plugin"           % "2.8.13")
addSbtPlugin("org.scalameta"       % "sbt-scalafmt"         % "2.3.0")
addSbtPlugin("org.thehive-project" % "sbt-github-changelog" % "0.3.0")

```

`rpm.sbt`:

```sbt
import Common.{betaVersion, snapshotVersion, stableVersion, versionUsage}

version in Rpm := {
  version.value match {
    case stableVersion(v1, _)                   => v1
    case betaVersion(v1, _, _)                  => v1
    case snapshotVersion(stableVersion(v1, _))  => v1
    case snapshotVersion(betaVersion(v1, _, _)) => v1
    case _                                      => versionUsage(version.value)
  }
}
rpmRelease := {
  version.value match {
    case stableVersion(_, v2)                    => v2
    case betaVersion(_, v2, v3)                  => "0." + v3 + "RC" + v2
    case snapshotVersion(stableVersion(_, v2))   => v2 + "-SNAPSHOT"
    case snapshotVersion(betaVersion(_, v2, v3)) => "0." + v3 + "RC" + v2 + "-SNAPSHOT"
    case _                                       => versionUsage(version.value)
  }
}
rpmVendor := organizationName.value
rpmUrl := organizationHomepage.value.map(_.toString)
rpmLicense := Some("AGPL")
rpmRequirements += "java-1.8.0-openjdk-headless"

maintainerScripts in Rpm := maintainerScriptsFromDirectory(
  baseDirectory.value / "package" / "rpm",
  Seq(RpmConstants.Pre, RpmConstants.Post, RpmConstants.Preun, RpmConstants.Postun)
)

linuxPackageSymlinks in Rpm := Nil
rpmPrefix := Some(defaultLinuxInstallLocation.value)

linuxPackageMappings in Rpm := configWithNoReplace((linuxPackageMappings in Rpm).value)

packageBin in Rpm := {
  import scala.sys.process._
  val rpmFile = (packageBin in Rpm).value
  Process(
    "rpm" ::
      "--define" :: "_gpg_name TheHive Project" ::
      "--define" :: "_signature gpg" ::
      "--define" :: "__gpg_check_password_cmd /bin/true" ::
      "--define" :: "__gpg_sign_cmd %{__gpg} gpg --batch --no-verbose --no-armor --use-agent --no-secmem-warning -u \"%{_gpg_name}\" -sbo %{__signature_filename} %{__plaintext_filename}" ::
      "--addsign" :: rpmFile.toString ::
      Nil
  ).!!
  rpmFile
}

```

`sbt`:

```
#!/usr/bin/env bash
#
# A more capable sbt runner, coincidentally also called sbt.
# Author: Paul Phillips <paulp@improving.org>
# https://github.com/paulp/sbt-extras
#
# Generated from http://www.opensource.org/licenses/bsd-license.php
# Copyright (c) 2011, Paul Phillips. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#     * Neither the name of the author nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

set -o pipefail

declare -r sbt_release_version="1.4.6"
declare -r sbt_unreleased_version="1.4.6"

declare -r latest_213="2.13.4"
declare -r latest_212="2.12.12"
declare -r latest_211="2.11.12"
declare -r latest_210="2.10.7"
declare -r latest_29="2.9.3"
declare -r latest_28="2.8.2"

declare -r buildProps="project/build.properties"

declare -r sbt_launch_ivy_release_repo="https://repo.typesafe.com/typesafe/ivy-releases"
declare -r sbt_launch_ivy_snapshot_repo="https://repo.scala-sbt.org/scalasbt/ivy-snapshots"
declare -r sbt_launch_mvn_release_repo="https://repo.scala-sbt.org/scalasbt/maven-releases"
declare -r sbt_launch_mvn_snapshot_repo="https://repo.scala-sbt.org/scalasbt/maven-snapshots"

declare -r default_jvm_opts_common="-Xms512m -Xss2m -XX:MaxInlineLevel=18"
declare -r noshare_opts="-Dsbt.global.base=project/.sbtboot -Dsbt.boot.directory=project/.boot -Dsbt.ivy.home=project/.ivy -Dsbt.coursier.home=project/.coursier"

declare sbt_jar sbt_dir sbt_create sbt_version sbt_script sbt_new
declare sbt_explicit_version
declare verbose noshare batch trace_level

declare java_cmd="java"
declare sbt_launch_dir="$HOME/.sbt/launchers"
declare sbt_launch_repo

# pull -J and -D options to give to java.
declare -a java_args scalac_args sbt_commands residual_args

# args to jvm/sbt via files or environment variables
declare -a extra_jvm_opts extra_sbt_opts

echoerr() { echo >&2 "$@"; }
vlog()    { [[ -n "$verbose" ]] && echoerr "$@"; }
die()     {
  echo "Aborting: $*"
  exit 1
}

setTrapExit() {
  # save stty and trap exit, to ensure echo is re-enabled if we are interrupted.
  SBT_STTY="$(stty -g 2>/dev/null)"
  export SBT_STTY

  # restore stty settings (echo in particular)
  onSbtRunnerExit() {
    [ -t 0 ] || return
    vlog ""
    vlog "restoring stty: $SBT_STTY"
    stty "$SBT_STTY"
  }

  vlog "saving stty: $SBT_STTY"
  trap onSbtRunnerExit EXIT
}

# this seems to cover the bases on OSX, and someone will
# have to tell me about the others.
get_script_path() {
  local path="$1"
  [[ -L "$path" ]] || {
    echo "$path"
    return
  }

  local -r target="$(readlink "$path")"
  if [[ "${target:0:1}" == "/" ]]; then
    echo "$target"
  else
    echo "${path%/*}/$target"
  fi
}

script_path="$(get_script_path "${BASH_SOURCE[0]}")"
declare -r script_path
script_name="${script_path##*/}"
declare -r script_name

init_default_option_file() {
  local overriding_var="${!1}"
  local default_file="$2"
  if [[ ! -r "$default_file" && "$overriding_var" =~ ^@(.*)$ ]]; then
    local envvar_file="${BASH_REMATCH[1]}"
    if [[ -r "$envvar_file" ]]; then
      default_file="$envvar_file"
    fi
  fi
  echo "$default_file"
}

sbt_opts_file="$(init_default_option_file SBT_OPTS .sbtopts)"
sbtx_opts_file="$(init_default_option_file SBTX_OPTS .sbtxopts)"
jvm_opts_file="$(init_default_option_file JVM_OPTS .jvmopts)"

build_props_sbt() {
  [[ -r "$buildProps" ]] &&
    grep '^sbt\.version' "$buildProps" | tr '=\r' ' ' | awk '{ print $2; }'
}

set_sbt_version() {
  sbt_version="${sbt_explicit_version:-$(build_props_sbt)}"
  [[ -n "$sbt_version" ]] || sbt_version=$sbt_release_version
  export sbt_version
}

url_base() {
  local version="$1"

  case "$version" in
    0.7.*)     echo "https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/simple-build-tool" ;;
    0.10.*)    echo "$sbt_launch_ivy_release_repo" ;;
    0.11.[12]) echo "$sbt_launch_ivy_release_repo" ;;
    0.*-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9]) # ie "*-yyyymmdd-hhMMss"
      echo          "$sbt_launch_ivy_snapshot_repo" ;;
    0.*)       echo "$sbt_launch_ivy_release_repo" ;;
    *-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]T[0-9][0-9][0-9][0-9][0-9][0-9]) # ie "*-yyyymmddThhMMss"
      echo          "$sbt_launch_mvn_snapshot_repo" ;;
    *)         echo "$sbt_launch_mvn_release_repo" ;;
  esac
}

make_url() {
  local version="$1"

  local base="${sbt_launch_repo:-$(url_base "$version")}"

  case "$version" in
    0.7.*)     echo "$base/sbt-launch-0.7.7.jar" ;;
    0.10.*)    echo "$base/org.scala-tools.sbt/sbt-launch/$version/sbt-launch.jar" ;;
    0.11.[12]) echo "$base/org.scala-tools.sbt/sbt-launch/$version/sbt-launch.jar" ;;
    0.*)       echo "$base/org.scala-sbt/sbt-launch/$version/sbt-launch.jar" ;;
    *)         echo "$base/org/scala-sbt/sbt-launch/$version/sbt-launch-${version}.jar" ;;
  esac
}

addJava()      {
  vlog "[addJava] arg = '$1'"
  java_args+=("$1")
}
addSbt()       {
  vlog "[addSbt] arg = '$1'"
  sbt_commands+=("$1")
}
addScalac()    {
  vlog "[addScalac] arg = '$1'"
  scalac_args+=("$1")
}
addResidual()  {
  vlog "[residual] arg = '$1'"
  residual_args+=("$1")
}

addResolver() { addSbt "set resolvers += $1"; }

addDebugger() { addJava "-Xdebug" && addJava "-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=$1"; }

setThisBuild() {
  vlog "[addBuild] args = '$*'"
  local key="$1" && shift
  addSbt "set $key in ThisBuild := $*"
}
setScalaVersion() {
  [[ "$1" == *"-SNAPSHOT" ]] && addResolver 'Resolver.sonatypeRepo("snapshots")'
  addSbt "++ $1"
}
setJavaHome() {
  java_cmd="$1/bin/java"
  setThisBuild javaHome "_root_.scala.Some(file(\"$1\"))"
  export JAVA_HOME="$1"
  export JDK_HOME="$1"
  export PATH="$JAVA_HOME/bin:$PATH"
}

getJavaVersion() {
  local -r str=$("$1" -version 2>&1 | grep -E -e '(java|openjdk) version' | awk '{ print $3 }' | tr -d '"')

  # java -version on java8 says 1.8.x
  # but on 9 and 10 it's 9.x.y and 10.x.y.
  if [[ "$str" =~ ^1\.([0-9]+)(\..*)?$ ]]; then
    echo "${BASH_REMATCH[1]}"
  elif [[ "$str" =~ ^([0-9]+)(\..*)?$ ]]; then
    echo "${BASH_REMATCH[1]}"
  elif [[ -n "$str" ]]; then
    echoerr "Can't parse java version from: $str"
  fi
}

checkJava() {
  # Warn if there is a Java version mismatch between PATH and JAVA_HOME/JDK_HOME

  [[ -n "$JAVA_HOME" && -e "$JAVA_HOME/bin/java"    ]] && java="$JAVA_HOME/bin/java"
  [[ -n "$JDK_HOME" && -e "$JDK_HOME/lib/tools.jar" ]] && java="$JDK_HOME/bin/java"

  if [[ -n "$java" ]]; then
    pathJavaVersion=$(getJavaVersion java)
    homeJavaVersion=$(getJavaVersion "$java")
    if [[ "$pathJavaVersion" != "$homeJavaVersion" ]]; then
      echoerr "Warning: Java version mismatch between PATH and JAVA_HOME/JDK_HOME, sbt will use the one in PATH"
      echoerr "  Either: fix your PATH, remove JAVA_HOME/JDK_HOME or use -java-home"
      echoerr "  java version from PATH:               $pathJavaVersion"
      echoerr "  java version from JAVA_HOME/JDK_HOME: $homeJavaVersion"
    fi
  fi
}

java_version() {
  local -r version=$(getJavaVersion "$java_cmd")
  vlog "Detected Java version: $version"
  echo "$version"
}

is_apple_silicon() { [[ "$(uname -s)" == "Darwin" && "$(uname -m)" == "arm64" ]]; }

# MaxPermSize critical on pre-8 JVMs but incurs noisy warning on 8+
default_jvm_opts() {
  local -r v="$(java_version)"
  if [[ $v -ge 10 ]]; then
    if is_apple_silicon; then
      # As of Dec 2020, JVM for Apple Silicon (M1) doesn't support JVMCI
      echo "$default_jvm_opts_common"
    else
      echo "$default_jvm_opts_common -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler"
    fi
  elif [[ $v -ge 8 ]]; then
    echo "$default_jvm_opts_common"
  else
    echo "-XX:MaxPermSize=384m $default_jvm_opts_common"
  fi
}

execRunner() {
  # print the arguments one to a line, quoting any containing spaces
  vlog "# Executing command line:" && {
    for arg; do
      if [[ -n "$arg" ]]; then
        if printf "%s\n" "$arg" | grep -q ' '; then
          printf >&2 "\"%s\"\n" "$arg"
        else
          printf >&2 "%s\n" "$arg"
        fi
      fi
    done
    vlog ""
  }

  setTrapExit

  if [[ -n "$batch" ]]; then
    "$@" </dev/null
  else
    "$@"
  fi
}

jar_url() { make_url "$1"; }

is_cygwin() { [[ "$(uname -a)" == "CYGWIN"* ]]; }

jar_file() {
  is_cygwin &&
    cygpath -w "$sbt_launch_dir/$1/sbt-launch.jar" ||
    echo "$sbt_launch_dir/$1/sbt-launch.jar"
}

download_url() {
  local url="$1"
  local jar="$2"

  mkdir -p "${jar%/*}" && {
    if command -v curl >/dev/null 2>&1; then
      curl --fail --silent --location "$url" --output "$jar"
    elif command -v wget >/dev/null 2>&1; then
      wget -q -O "$jar" "$url"
    fi
  } && [[ -r "$jar" ]]
}

acquire_sbt_jar() {
  {
    sbt_jar="$(jar_file "$sbt_version")"
    [[ -r "$sbt_jar" ]]
  } || {
    sbt_jar="$HOME/.ivy2/local/org.scala-sbt/sbt-launch/$sbt_version/jars/sbt-launch.jar"
    [[ -r "$sbt_jar" ]]
  } || {
    sbt_jar="$(jar_file "$sbt_version")"
    jar_url="$(make_url "$sbt_version")"

    echoerr "Downloading sbt launcher for ${sbt_version}:"
    echoerr "  From  ${jar_url}"
    echoerr "    To  ${sbt_jar}"

    download_url "${jar_url}" "${sbt_jar}"

    case "${sbt_version}" in
      0.*)
        vlog "SBT versions < 1.0 do not have published MD5 checksums, skipping check"
        echo ""
        ;;
      *)   verify_sbt_jar "${sbt_jar}" ;;
    esac
  }
}

verify_sbt_jar() {
  local jar="${1}"
  local md5="${jar}.md5"
  md5url="$(make_url "${sbt_version}").md5"

  echoerr "Downloading sbt launcher ${sbt_version} md5 hash:"
  echoerr "  From  ${md5url}"
  echoerr "    To  ${md5}"

  download_url "${md5url}" "${md5}" >/dev/null 2>&1

  if command -v md5sum >/dev/null 2>&1; then
    if echo "$(cat "${md5}")  ${jar}" | md5sum -c -; then
      rm -rf "${md5}"
      return 0
    else
      echoerr "Checksum does not match"
      return 1
    fi
  elif command -v md5 >/dev/null 2>&1; then
    if [ "$(md5 -q "${jar}")" == "$(cat "${md5}")" ]; then
      rm -rf "${md5}"
      return 0
    else
      echoerr "Checksum does not match"
      return 1
    fi
  elif command -v openssl >/dev/null 2>&1; then
    if [ "$(openssl md5 -r "${jar}" | awk '{print $1}')" == "$(cat "${md5}")" ]; then
      rm -rf "${md5}"
      return 0
    else
      echoerr "Checksum does not match"
      return 1
    fi
  else
    echoerr "Could not find an MD5 command"
    return 1
  fi
}

usage() {
  set_sbt_version
  cat <<EOM
Usage: $script_name [options]

Note that options which are passed along to sbt begin with -- whereas
options to this runner use a single dash. Any sbt command can be scheduled
to run first by prefixing the command with --, so --warn, --error and so on
are not special.

  -h | -help         print this message
  -v                 verbose operation (this runner is chattier)
  -d, -w, -q         aliases for --debug, --warn, --error (q means quiet)
  -x                 debug this script
  -trace <level>     display stack traces with a max of <level> frames (default: -1, traces suppressed)
  -debug-inc         enable debugging log for the incremental compiler
  -no-colors         disable ANSI color codes
  -sbt-create        start sbt even if current directory contains no sbt project
  -sbt-dir   <path>  path to global settings/plugins directory (default: ~/.sbt/<version>)
  -sbt-boot  <path>  path to shared boot directory (default: ~/.sbt/boot in 0.11+)
  -ivy       <path>  path to local Ivy repository (default: ~/.ivy2)
  -no-share          use all local caches; no sharing
  -offline           put sbt in offline mode
  -jvm-debug <port>  Turn on JVM debugging, open at the given port.
  -batch             Disable interactive mode
  -prompt <expr>     Set the sbt prompt; in expr, 's' is the State and 'e' is Extracted
  -script <file>     Run the specified file as a scala script

  # sbt version (default: sbt.version from $buildProps if present, otherwise $sbt_release_version)
  -sbt-version <version>  use the specified version of sbt (default: $sbt_release_version)
  -sbt-force-latest       force the use of the latest release of sbt: $sbt_release_version
  -sbt-dev                use the latest pre-release version of sbt: $sbt_unreleased_version
  -sbt-jar      <path>    use the specified jar as the sbt launcher
  -sbt-launch-dir <path>  directory to hold sbt launchers (default: $sbt_launch_dir)
  -sbt-launch-repo <url>  repo url for downloading sbt launcher jar (default: $(url_base "$sbt_version"))

  # scala version (default: as chosen by sbt)
  -28                        use $latest_28
  -29                        use $latest_29
  -210                       use $latest_210
  -211                       use $latest_211
  -212                       use $latest_212
  -213                       use $latest_213
  -scala-home <path>         use the scala build at the specified directory
  -scala-version <version>   use the specified version of scala
  -binary-version <version>  use the specified scala version when searching for dependencies

  # java version (default: java from PATH, currently $(java -version 2>&1 | grep version))
  -java-home <path>          alternate JAVA_HOME

  # passing options to the jvm - note it does NOT use JAVA_OPTS due to pollution
  # The default set is used if JVM_OPTS is unset and no -jvm-opts file is found
  <default>         $(default_jvm_opts)
  JVM_OPTS          environment variable holding either the jvm args directly, or
                    the reference to a file containing jvm args if given path is prepended by '@' (e.g. '@/etc/jvmopts')
                    Note: "@"-file is overridden by local '.jvmopts' or '-jvm-opts' argument.
  -jvm-opts <path>  file containing jvm args (if not given, .jvmopts in project root is used if present)
  -Dkey=val         pass -Dkey=val directly to the jvm
  -J-X              pass option -X directly to the jvm (-J is stripped)

  # passing options to sbt, OR to this runner
  SBT_OPTS          environment variable holding either the sbt args directly, or
                    the reference to a file containing sbt args if given path is prepended by '@' (e.g. '@/etc/sbtopts')
                    Note: "@"-file is overridden by local '.sbtopts' or '-sbt-opts' argument.
  -sbt-opts <path>  file containing sbt args (if not given, .sbtopts in project root is used if present)
  -S-X              add -X to sbt's scalacOptions (-S is stripped)

  # passing options exclusively to this runner
  SBTX_OPTS         environment variable holding either the sbt-extras args directly, or
                    the reference to a file containing sbt-extras args if given path is prepended by '@' (e.g. '@/etc/sbtxopts')
                    Note: "@"-file is overridden by local '.sbtxopts' or '-sbtx-opts' argument.
  -sbtx-opts <path> file containing sbt-extras args (if not given, .sbtxopts in project root is used if present)
EOM
  exit 0
}

process_args() {
  require_arg() {
    local type="$1"
    local opt="$2"
    local arg="$3"

    if [[ -z "$arg" ]] || [[ "${arg:0:1}" == "-" ]]; then
      die "$opt requires <$type> argument"
    fi
  }
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h |   -help) usage ;;
      -v)           verbose=true && shift ;;
      -d)           addSbt "--debug" && shift ;;
      -w)           addSbt "--warn"  && shift ;;
      -q)           addSbt "--error" && shift ;;
      -x)           shift ;; # currently unused
      -trace)       require_arg integer "$1" "$2" && trace_level="$2" && shift 2 ;;
      -debug-inc)   addJava "-Dxsbt.inc.debug=true" && shift ;;

      -no-colors)   addJava "-Dsbt.log.noformat=true" && addJava "-Dsbt.color=false" && shift ;;
      -sbt-create)  sbt_create=true && shift ;;
      -sbt-dir)     require_arg path "$1" "$2" && sbt_dir="$2" && shift 2 ;;
      -sbt-boot)    require_arg path "$1" "$2" && addJava "-Dsbt.boot.directory=$2" && shift 2 ;;
      -ivy)         require_arg path "$1" "$2" && addJava "-Dsbt.ivy.home=$2" && shift 2 ;;
      -no-share)    noshare=true && shift ;;
      -offline)     addSbt "set offline in Global := true" && shift ;;
      -jvm-debug)   require_arg port "$1" "$2" && addDebugger "$2" && shift 2 ;;
      -batch)       batch=true && shift ;;
      -prompt)      require_arg "expr" "$1" "$2" && setThisBuild shellPrompt "(s => { val e = Project.extract(s) ; $2 })" && shift 2 ;;
      -script)      require_arg file "$1" "$2" && sbt_script="$2" && addJava "-Dsbt.main.class=sbt.ScriptMain" && shift 2 ;;

      -sbt-version) require_arg version "$1" "$2" && sbt_explicit_version="$2" && shift 2 ;;
      -sbt-force-latest) sbt_explicit_version="$sbt_release_version" && shift ;;
      -sbt-dev)     sbt_explicit_version="$sbt_unreleased_version" && shift ;;
      -sbt-jar)     require_arg path "$1" "$2" && sbt_jar="$2" && shift 2 ;;
      -sbt-launch-dir) require_arg path "$1" "$2" && sbt_launch_dir="$2" && shift 2 ;;
      -sbt-launch-repo) require_arg path "$1" "$2" && sbt_launch_repo="$2" && shift 2 ;;

      -28)          setScalaVersion "$latest_28"  && shift ;;
      -29)          setScalaVersion "$latest_29"  && shift ;;
      -210)         setScalaVersion "$latest_210" && shift ;;
      -211)         setScalaVersion "$latest_211" && shift ;;
      -212)         setScalaVersion "$latest_212" && shift ;;
      -213)         setScalaVersion "$latest_213" && shift ;;

      -scala-version) require_arg version "$1" "$2" && setScalaVersion "$2" && shift 2 ;;
      -binary-version) require_arg version "$1" "$2" && setThisBuild scalaBinaryVersion "\"$2\"" && shift 2 ;;
      -scala-home)  require_arg path "$1" "$2" && setThisBuild scalaHome "_root_.scala.Some(file(\"$2\"))" && shift 2 ;;
      -java-home)   require_arg path "$1" "$2" && setJavaHome "$2" && shift 2 ;;
      -sbt-opts)    require_arg path "$1" "$2" && sbt_opts_file="$2" && shift 2 ;;
      -sbtx-opts) require_arg path "$1" "$2" && sbtx_opts_file="$2" && shift 2 ;;
      -jvm-opts)    require_arg path "$1" "$2" && jvm_opts_file="$2" && shift 2 ;;

      -D*)          addJava "$1" && shift ;;
      -J*)          addJava "${1:2}" && shift ;;
      -S*)          addScalac "${1:2}" && shift ;;

      new)          sbt_new=true && : ${sbt_explicit_version:=$sbt_release_version} && addResidual "$1" && shift ;;

      *)            addResidual "$1" && shift ;;
    esac
  done
}

# process the direct command line arguments
process_args "$@"

# skip #-styled comments and blank lines
readConfigFile() {
  local end=false
  until $end; do
    read -r || end=true
    [[ $REPLY =~ ^# ]] || [[ -z $REPLY ]] || echo "$REPLY"
  done <"$1"
}

# if there are file/environment sbt_opts, process again so we
# can supply args to this runner
if [[ -r "$sbt_opts_file" ]]; then
  vlog "Using sbt options defined in file $sbt_opts_file"
  while read -r opt; do extra_sbt_opts+=("$opt"); done < <(readConfigFile "$sbt_opts_file")
elif [[ -n "$SBT_OPTS" && ! ("$SBT_OPTS" =~ ^@.*) ]]; then
  vlog "Using sbt options defined in variable \$SBT_OPTS"
  IFS=" " read -r -a extra_sbt_opts <<<"$SBT_OPTS"
else
  vlog "No extra sbt options have been defined"
fi

# if there are file/environment sbtx_opts, process again so we
# can supply args to this runner
if [[ -r "$sbtx_opts_file" ]]; then
  vlog "Using sbt options defined in file $sbtx_opts_file"
  while read -r opt; do extra_sbt_opts+=("$opt"); done < <(readConfigFile "$sbtx_opts_file")
elif [[ -n "$SBTX_OPTS" && ! ("$SBTX_OPTS" =~ ^@.*) ]]; then
  vlog "Using sbt options defined in variable \$SBTX_OPTS"
  IFS=" " read -r -a extra_sbt_opts <<<"$SBTX_OPTS"
else
  vlog "No extra sbt options have been defined"
fi

[[ -n "${extra_sbt_opts[*]}" ]] && process_args "${extra_sbt_opts[@]}"

# reset "$@" to the residual args
set -- "${residual_args[@]}"
argumentCount=$#

# set sbt version
set_sbt_version

checkJava

# only exists in 0.12+
setTraceLevel() {
  case "$sbt_version" in
    "0.7."* | "0.10."* | "0.11."*) echoerr "Cannot set trace level in sbt version $sbt_version" ;;
    *)                             setThisBuild traceLevel "$trace_level" ;;
  esac
}

# set scalacOptions if we were given any -S opts
[[ ${#scalac_args[@]} -eq 0 ]] || addSbt "set scalacOptions in ThisBuild += \"${scalac_args[*]}\""

[[ -n "$sbt_explicit_version" && -z "$sbt_new" ]] && addJava "-Dsbt.version=$sbt_explicit_version"
vlog "Detected sbt version $sbt_version"

if [[ -n "$sbt_script" ]]; then
  residual_args=("$sbt_script" "${residual_args[@]}")
else
  # no args - alert them there's stuff in here
  ((argumentCount > 0)) || {
    vlog "Starting $script_name: invoke with -help for other options"
    residual_args=(shell)
  }
fi

# verify this is an sbt dir, -create was given or user attempts to run a scala script
[[ -r ./build.sbt || -d ./project || -n "$sbt_create" || -n "$sbt_script" || -n "$sbt_new" ]] || {
  cat <<EOM
$(pwd) doesn't appear to be an sbt project.
If you want to start sbt anyway, run:
  $0 -sbt-create

EOM
  exit 1
}

# pick up completion if present; todo
# shellcheck disable=SC1091
[[ -r .sbt_completion.sh ]] && source .sbt_completion.sh

# directory to store sbt launchers
[[ -d "$sbt_launch_dir" ]] || mkdir -p "$sbt_launch_dir"
[[ -w "$sbt_launch_dir" ]] || sbt_launch_dir="$(mktemp -d -t sbt_extras_launchers.XXXXXX)"

# no jar? download it.
[[ -r "$sbt_jar" ]] || acquire_sbt_jar || {
  # still no jar? uh-oh.
  echo "Could not download and verify the launcher. Obtain the jar manually and place it at $sbt_jar"
  exit 1
}

if [[ -n "$noshare" ]]; then
  for opt in ${noshare_opts}; do
    addJava "$opt"
  done
else
  case "$sbt_version" in
    "0.7."* | "0.10."* | "0.11."* | "0.12."*)
      [[ -n "$sbt_dir" ]] || {
        sbt_dir="$HOME/.sbt/$sbt_version"
        vlog "Using $sbt_dir as sbt dir, -sbt-dir to override."
      }
      ;;
  esac

  if [[ -n "$sbt_dir" ]]; then
    addJava "-Dsbt.global.base=$sbt_dir"
  fi
fi

if [[ -r "$jvm_opts_file" ]]; then
  vlog "Using jvm options defined in file $jvm_opts_file"
  while read -r opt; do extra_jvm_opts+=("$opt"); done < <(readConfigFile "$jvm_opts_file")
elif [[ -n "$JVM_OPTS" && ! ("$JVM_OPTS" =~ ^@.*) ]]; then
  vlog "Using jvm options defined in \$JVM_OPTS variable"
  IFS=" " read -r -a extra_jvm_opts <<<"$JVM_OPTS"
else
  vlog "Using default jvm options"
  IFS=" " read -r -a extra_jvm_opts <<<"$( default_jvm_opts)"
fi

# traceLevel is 0.12+
[[ -n "$trace_level" ]] && setTraceLevel

execRunner "$java_cmd" \
  "${extra_jvm_opts[@]}" \
  "${java_args[@]}" \
  -jar "$sbt_jar" \
  "${sbt_commands[@]}" \
  "${residual_args[@]}"

```

`test/resources/logback-test.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>[%level{4}] %logger{15} - %message%n%xException{10}
            </pattern>
        </encoder>
    </appender>

    <appender name="ASYNCSTDOUT" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="STDOUT"/>
    </appender>

    <logger name="org.thp.thehive.DatabaseBuilder" level="WARN"/>
    <root level="ERROR">
        <appender-ref ref="ASYNCSTDOUT"/>
    </root>

</configuration>


```

`thehive/app/org/thp/thehive/ClusterSetup.scala`:

```scala
package org.thp.thehive

import akka.actor.{Actor, ActorSystem, Props}
import akka.cluster.Cluster
import akka.cluster.ClusterEvent.{InitialStateAsEvents, MemberEvent, _}
import com.google.inject.Injector
import org.thp.scalligraph.SingleInstance
import play.api.{Configuration, Logger}

import javax.inject.{Inject, Singleton}

@Singleton
class ClusterSetup @Inject() (
    configuration: Configuration,
    system: ActorSystem,
    injector: Injector
) extends SingleInstance(configuration.get[Seq[String]]("akka.cluster.seed-nodes").isEmpty) {
  system.actorOf(Props[ClusterListener])
  if (value) {
    val logger: Logger = Logger(getClass)
    logger.info("Initialising cluster")
    val cluster = Cluster(system)
    cluster.join(cluster.system.provider.getDefaultAddress)
  }
  GuiceAkkaExtension(system).set(injector)

}

class ClusterListener extends Actor {
  val cluster: Cluster = Cluster(context.system)
  val logger: Logger   = Logger(getClass)

  override def preStart(): Unit = cluster.subscribe(self, initialStateMode = InitialStateAsEvents, classOf[MemberEvent], classOf[UnreachableMember])
  override def postStop(): Unit = cluster.unsubscribe(self)

  def receive: Receive = {
    case MemberUp(member)                      => logger.info(s"Member is Up: ${member.address}")
    case UnreachableMember(member)             => logger.info(s"Member detected as unreachable: $member")
    case MemberRemoved(member, previousStatus) => logger.info(s"Member is Removed: ${member.address} after $previousStatus")
    case MemberJoined(member)                  => logger.debug(s"Member is joined: $member")
    case MemberWeaklyUp(member)                => logger.debug(s"Member is weaklyUp: $member")
    case MemberLeft(member)                    => logger.debug(s"Member is left: $member")
    case MemberExited(member)                  => logger.debug(s"Member is exited: $member")
    case MemberDowned(member)                  => logger.debug(s"Member is downed: $member")
  }
}

```

`thehive/app/org/thp/thehive/GuiceAkkaExtension.scala`:

```scala
package org.thp.thehive

import akka.actor.{ActorSystem, ClassicActorSystemProvider, ExtendedActorSystem, Extension, ExtensionId, ExtensionIdProvider}
import com.google.inject.Injector

import scala.concurrent.duration.DurationInt
import scala.concurrent.{Await, Promise}

class GuiceAkkaExtension extends Extension {
  private val injectorPromise = Promise[Injector]
  def set(injector: Injector): Unit = {
    injectorPromise.success(injector)
    ()
  }
  lazy val injector: Injector = Await.result(injectorPromise.future, 1.minute)
}

object GuiceAkkaExtension extends ExtensionId[GuiceAkkaExtension] with ExtensionIdProvider {
  override def lookup: ExtensionId[GuiceAkkaExtension]      = GuiceAkkaExtension
  override def createExtension(system: ExtendedActorSystem) = new GuiceAkkaExtension

  /**
    * Java API: retrieve the Count extension for the given system.
    */
  override def get(system: ActorSystem): GuiceAkkaExtension                = super.get(system)
  override def get(system: ClassicActorSystemProvider): GuiceAkkaExtension = super.get(system)
}

```

`thehive/app/org/thp/thehive/TheHiveModule.scala`:

```scala
package org.thp.thehive

import akka.actor.typed.{ActorRef => TypedActorRef}
import akka.actor.{ActorRef, ActorSystem}
import com.google.inject.AbstractModule
import net.codingwell.scalaguice.{ScalaModule, ScalaMultibinder}
import org.quartz.Scheduler
import org.quartz.impl.StdSchedulerFactory
import org.thp.scalligraph.SingleInstance
import org.thp.scalligraph.auth._
import org.thp.scalligraph.janus.{ImmenseTermProcessor, JanusDatabaseProvider}
import org.thp.scalligraph.models.{Database, UpdatableSchema}
import org.thp.scalligraph.query.QueryExecutor
import org.thp.scalligraph.services.config.ConfigActor
import org.thp.scalligraph.services.{IntegrityCheck, _}
import org.thp.thehive.controllers.v0.{QueryExecutorVersion0Provider, TheHiveQueryExecutor => TheHiveQueryExecutorV0}
import org.thp.thehive.controllers.v1.{TheHiveQueryExecutor => TheHiveQueryExecutorV1}
import org.thp.thehive.models.{TheHiveSchemaDefinition, UseHashToIndex}
import org.thp.thehive.services.notification.NotificationActor
import org.thp.thehive.services.notification.notifiers._
import org.thp.thehive.services.notification.triggers._
import org.thp.thehive.services.{Connector, LocalKeyAuthProvider, LocalPasswordAuthProvider, LocalUserSrv, UserSrv => _, _}
import play.api.libs.concurrent.AkkaGuiceSupport
import play.api.routing.{Router => PlayRouter}
import play.api.{Configuration, Environment, Logger}

import javax.inject.{Inject, Provider, Singleton}

class TheHiveModule(environment: Environment, configuration: Configuration) extends AbstractModule with ScalaModule with AkkaGuiceSupport {
  lazy val logger: Logger = Logger(getClass)

  override def configure(): Unit = {
//    bind[UserSrv].to[LocalUserSrv]
    bind(classOf[UserSrv]).to(classOf[LocalUserSrv])
//    bind[AuthSrv].toProvider[MultiAuthSrvProvider]
    bind(classOf[AuthSrv]).toProvider(classOf[TOTPAuthSrvProvider])

    val authBindings = ScalaMultibinder.newSetBinder[AuthSrvProvider](binder)
    authBindings.addBinding.to[ADAuthProvider]
    authBindings.addBinding.to[LdapAuthProvider]
    authBindings.addBinding.to[LocalPasswordAuthProvider]
    authBindings.addBinding.to[LocalKeyAuthProvider]
    authBindings.addBinding.to[BasicAuthProvider]
    authBindings.addBinding.to[HeaderAuthProvider]
    authBindings.addBinding.to[PkiAuthProvider]
    authBindings.addBinding.to[SessionAuthProvider]
    authBindings.addBinding.to[OAuth2Provider]

    val triggerBindings = ScalaMultibinder.newSetBinder[TriggerProvider](binder)
    triggerBindings.addBinding.to[AlertCreatedProvider]
    triggerBindings.addBinding.to[AnyEventProvider]
    triggerBindings.addBinding.to[CaseCreatedProvider]
    triggerBindings.addBinding.to[FilteredEventProvider]
    triggerBindings.addBinding.to[JobFinishedProvider]
    triggerBindings.addBinding.to[LogInMyTaskProvider]
    triggerBindings.addBinding.to[TaskAssignedProvider]
    triggerBindings.addBinding.to[CaseShareProvider]

    val notifierBindings = ScalaMultibinder.newSetBinder[NotifierProvider](binder)
    notifierBindings.addBinding.to[AppendToFileProvider]
    notifierBindings.addBinding.to[EmailerProvider]
    notifierBindings.addBinding.to[MattermostProvider]
    notifierBindings.addBinding.to[WebhookProvider]

    configuration.get[String]("db.provider") match {
      case "janusgraph" => bind[Database].toProvider[JanusDatabaseProvider]
      case other        => sys.error(s"Authentication provider [$other] is not recognized")
    }

    configuration.get[String]("storage.provider") match {
      case "localfs"  => bind(classOf[StorageSrv]).to(classOf[LocalFileSystemStorageSrv])
      case "database" => bind(classOf[StorageSrv]).to(classOf[DatabaseStorageSrv])
      case "hdfs"     => bind(classOf[StorageSrv]).to(classOf[HadoopStorageSrv])
      case "s3"       => bind(classOf[StorageSrv]).to(classOf[S3StorageSrv])
      case other      => sys.error(s"Storage provider [$other] is not recognized")
    }

    val routerBindings = ScalaMultibinder.newSetBinder[PlayRouter](binder)
    routerBindings.addBinding.toProvider[TheHiveRouter]
    val queryExecutorBindings = ScalaMultibinder.newSetBinder[QueryExecutor](binder)
    queryExecutorBindings.addBinding.to[TheHiveQueryExecutorV0]
    queryExecutorBindings.addBinding.to[TheHiveQueryExecutorV1]
    bind[QueryExecutor].annotatedWithName("v0").toProvider[QueryExecutorVersion0Provider]
    ScalaMultibinder.newSetBinder[Connector](binder)
    val schemaBindings = ScalaMultibinder.newSetBinder[UpdatableSchema](binder)
    schemaBindings.addBinding.to[TheHiveSchemaDefinition]

    bindActor[ConfigActor]("config-actor")
    bindActor[NotificationActor]("notification-actor")

    val integrityChecksBindings = ScalaMultibinder.newSetBinder[IntegrityCheck](binder)
    integrityChecksBindings.addBinding.to[ProfileIntegrityCheck]
    integrityChecksBindings.addBinding.to[OrganisationIntegrityCheck]
    integrityChecksBindings.addBinding.to[TagIntegrityCheck]
    integrityChecksBindings.addBinding.to[UserIntegrityCheck]
    integrityChecksBindings.addBinding.to[ImpactStatusIntegrityCheck]
    integrityChecksBindings.addBinding.to[ResolutionStatusIntegrityCheck]
    integrityChecksBindings.addBinding.to[ObservableTypeIntegrityCheck]
    integrityChecksBindings.addBinding.to[CustomFieldIntegrityCheck]
    integrityChecksBindings.addBinding.to[CaseTemplateIntegrityCheck]
    integrityChecksBindings.addBinding.to[DataIntegrityCheck]
    integrityChecksBindings.addBinding.to[CaseIntegrityCheck]
    integrityChecksBindings.addBinding.to[AlertIntegrityCheck]
    integrityChecksBindings.addBinding.to[TaskIntegrityCheck]
    integrityChecksBindings.addBinding.to[ObservableIntegrityCheck]
    integrityChecksBindings.addBinding.to[LogIntegrityCheck]
    integrityChecksBindings.addBinding.to[RoleIntegrityCheck]
    bind[TypedActorRef[IntegrityCheck.Request]].toProvider[IntegrityCheckActorProvider].asEagerSingleton()
    bind[TypedActorRef[CaseNumberActor.Request]].toProvider[CaseNumberActorProvider]

    bind[Scheduler].toProvider[QuartzSchedulerProvider].asEagerSingleton()

    bind[ActorRef].annotatedWithName("flow-actor").toProvider[FlowActorProvider]

    bind[SingleInstance].to[ClusterSetup].asEagerSingleton()

    ImmenseTermProcessor.registerStrategy("observableHashToIndex", _ => UseHashToIndex)
    ()
  }
}

@Singleton
class QuartzSchedulerProvider @Inject() (actorSystem: ActorSystem) extends Provider[Scheduler] {
  override def get(): Scheduler = {
    val factory = new StdSchedulerFactory
    factory.initialize()
    val scheduler = factory.getScheduler()
    actorSystem.registerOnTermination(scheduler.shutdown())
    scheduler.start()
    scheduler
  }
}

```

`thehive/app/org/thp/thehive/TheHiveRouter.scala`:

```scala
package org.thp.thehive

import _root_.controllers.{Assets, ExternalAssets}
import com.google.inject.ProvidedBy
import javax.inject.{Inject, Provider, Singleton}
import org.thp.thehive.controllers.{dav, v0, v1}
import play.api.mvc._
import play.api.routing.sird._
import play.api.routing.{Router, SimpleRouter}
import play.api.{Configuration, Environment, Logger, Mode}

@Singleton
class TheHiveRouter @Inject() (
    routerV0: v0.Router,
    routerV1: v1.Router,
    davRouter: dav.Router,
    assets: AssetGetter,
    actionBuilder: DefaultActionBuilder,
    configuration: Configuration
) extends Provider[Router] {

  lazy val logger: Logger = Logger(getClass)
  lazy val get: Router = routerV1.withPrefix("/api/v1/") orElse
    routerV0.withPrefix("/api/v0/") orElse
    routerV0.withPrefix("/api/") orElse // default version
    davRouter.withPrefix("/fs") orElse
    SimpleRouter {
      case GET(p"/")                                   => actionBuilder(Results.PermanentRedirect(configuration.get[String]("play.http.context").stripSuffix("/") + "/index.html"))
      case GET(p"/$file*") if !file.startsWith("api/") => assets.at(file)
    }
}

@ProvidedBy(classOf[AssetProvider])
class AssetGetter @Inject() (get: String => Action[AnyContent]) {
  def at(name: String): Action[AnyContent] = get(name)
}

class AssetProvider @Inject() (environment: Environment, assets: Assets, extAssets: ExternalAssets) extends Provider[AssetGetter] {
  lazy val logger: Logger = Logger(getClass)

  val devResolver: String => Action[AnyContent] = {
    case name if name.startsWith("bower_components") => extAssets.at("frontend", name)
    case name                                        => extAssets.at("frontend/app", name)
  }

  def prodResolver: String => Action[AnyContent] = name => assets.at("/frontend", name)

  override def get(): AssetGetter = environment.mode match {
    case Mode.Dev => new AssetGetter(devResolver)
    case _        => new AssetGetter(prodResolver)
  }
}

```

`thehive/app/org/thp/thehive/controllers/HttpHeaderParameterEncoding.scala`:

```scala
/*
 * Copyright (C) 2009-2019 Lightbend Inc. <https://www.lightbend.com>
 * Stolen from Play sources for testing purposes
 */

package org.thp.thehive.controllers

import java.lang.{StringBuilder => JStringBuilder}
import java.util.{BitSet => JBitSet}

/**
  * Support for rending HTTP header parameters according to RFC5987.
  */
object HttpHeaderParameterEncoding {

  private val AlphaNum: Seq[Char] = ('a' to 'z') ++ ('A' to 'Z') ++ ('0' to '9')
  // From https://tools.ietf.org/html/rfc5987#section-3.2.1:
  //
  // attr-char     = ALPHA / DIGIT
  // / "!" / "#" / "$" / "&" / "+" / "-" / "."
  // / "^" / "_" / "`" / "|" / "~"
  // ; token except ( "*" / "'" / "%" )
  private val AttrCharPunctuation: Seq[Char] = Seq('!', '#', '$', '&', '+', '-', '.', '^', '_', '`', '|', '~')
  // From https://tools.ietf.org/html/rfc2616#section-2.2
  //
  //   separators     = "(" | ")" | "<" | ">" | "@"
  //                  | "," | ";" | ":" | "\" | <">
  //                  | "/" | "[" | "]" | "?" | "="
  //                  | "{" | "}" | SP | HT
  //
  // Rich: We exclude <">, "\" since they can be used for quoting/escaping and HT since it is
  // rarely used and seems like it should be escaped.
  private val Separators: Seq[Char] =
    Seq('(', ')', '<', '>', '@', ',', ';', ':', '/', '[', ']', '?', '=', '{', '}', ' ')

  /**
    * A subset of the 'qdtext' defined in https://tools.ietf.org/html/rfc2616#section-2.2. These are the
    * characters which can be inside a 'quoted-string' parameter value. These should form a
    * superset of the [[AttrChar]] set defined below. We exclude some characters which are technically
    * valid, but might be problematic, e.g. "\" and "%" could be treated as escape characters by some
    * clients. We can be conservative because we can express these characters clearly as an extended
    * parameter.
    */
  private val PartialQuotedText: JBitSet = charSeqToBitSet(
    AlphaNum ++ AttrCharPunctuation ++
      // we include 'separators' plus some chars excluded from 'attr-char'
      Separators ++ Seq('*', '\'')
  )

  /**
    * The 'attr-char' values defined in https://tools.ietf.org/html/rfc5987#section-3.2.1. Should be a
    * subset of [[PartialQuotedText]] defined above.
    */
  private val AttrChar: JBitSet     = charSeqToBitSet(AlphaNum ++ AttrCharPunctuation)
  private val PlaceholderChar: Char = '?'

  /**
    * Render a parameter name and value, handling character set issues as
    * recommended in RFC5987.
    *
    * Examples:
    * render("filename", "foo.txt") ==> "filename=foo.txt"
    * render("filename", "naïve.txt") ==> "filename=na_ve.txt; filename*=utf8'\'na%C3%AFve.txt"
    */
  def encode(name: String, value: String): String = {
    val builder = new JStringBuilder
    encodeToBuilder(name, value, builder)
    builder.toString
  }

  /**
    * Render a parameter name and value, handling character set issues as
    * recommended in RFC5987.
    *
    * Examples:
    * render("filename", "foo.txt") ==> "filename=foo.txt"
    * render("filename", "naïve.txt") ==> "filename=na_ve.txt; filename*=utf8'\'na%C3%AFve.txt"
    */
  def encodeToBuilder(name: String, value: String, builder: JStringBuilder): Unit = {

    // This flag gets set if we encounter extended characters when rendering the
    // regular parameter value.
    var hasExtendedChars = false

    // Render ASCII parameter
    // E.g. naïve.txt --> "filename=na_ve.txt"

    builder.append(name)
    builder.append("=\"")

    // Iterate over code points here, because we only want one
    // ASCII character or placeholder per logical character. If
    // we use the value's encoded bytes or chars then we might
    // end up with multiple placeholders per logical character.
    value
      .codePoints()
      .forEach(codePoint =>
        // We could support a wider range of characters here by using
        // the 'token' or 'quoted printable' encoding, however it's
        // simpler to use the subset of characters that is also valid
        // for extended attributes.
        if (codePoint >= 0 && codePoint <= 255 && PartialQuotedText.get(codePoint)) {
          builder.append(codePoint.toChar)
          ()
        } else {
          // Set flag because we need to render an extended parameter.
          hasExtendedChars = true
          // Render a placeholder instead of the unsupported character.
          builder.append(PlaceholderChar)
          ()
        }
      )

    builder.append('"')

    // Optionally render extended, UTF-8 encoded parameter
    // E.g. naïve.txt --> "; filename*=utf8''na%C3%AFve.txt"
    //
    // Renders both regular and extended parameters, as suggested by:
    // - https://tools.ietf.org/html/rfc5987#section-4.2
    // - https://tools.ietf.org/html/rfc6266#section-4.3 (for Content-Disposition filename parameter)

    if (hasExtendedChars) {

      def hexDigit(x: Int): Char =
        (if (x < 10) x + '0'
         else {
           x - 10 + 'a'
         }).toChar

      // From https://tools.ietf.org/html/rfc5987#section-3.2.1:
      //
      // Producers MUST use either the "UTF-8" ([RFC3629]) or the "ISO-8859-1"
      // ([ISO-8859-1]) character set.  Extension character sets (mime-

      val CharacterSetName = "utf-8"

      builder.append("; ")
      builder.append(name)

      builder.append("*=")
      builder.append(CharacterSetName)
      builder.append("''")

      // From https://tools.ietf.org/html/rfc5987#section-3.2.1:
      //
      // Inside the value part, characters not contained in attr-char are
      // encoded into an octet sequence using the specified character set.
      // That octet sequence is then percent-encoded as specified in Section
      // 2.1 of [RFC3986].

      val bytes = value.getBytes(CharacterSetName)
      for (b <- bytes) {
        if (AttrChar.get(b & 0xFF)) {
          builder.append(b.toChar)
        } else {
          builder.append('%')
          builder.append(hexDigit((b >> 4) & 0xF))
          builder.append(hexDigit(b & 0xF))
        }
      }
    }
  }

  private def charSeqToBitSet(chars: Seq[Char]): JBitSet = {
    val ints: Seq[Int] = chars.map(_.toInt)
    val max            = ints.fold(0)(Math.max)
    assert(max <= 256) // We should only be dealing with 7 or 8 bit chars
    val bitSet = new JBitSet(max)
    ints.foreach(bitSet.set)
    bitSet
  }

}

```

`thehive/app/org/thp/thehive/controllers/dav/Resource.scala`:

```scala
package org.thp.thehive.controllers.dav

import java.text.SimpleDateFormat
import java.util.Date

import org.thp.scalligraph.models.Entity
import org.thp.thehive.models.Attachment

import scala.xml.{Elem, Node}

trait Resource {
  def url: String
  def displayName: String
  def creationTime: Date
  def lastModified: Date
  def contentLength: Long
  def contentType: Option[String]
  def hasChildren: Boolean
  def etag: Option[String] = None

  protected def setNodeValue(prop: Node, value: Node): Option[Node] =
    prop match {
      case Elem(p, l, at, sc) => Some(Elem(p, l, at, sc, true, value))
    }

  protected def setValue(prop: Node, value: String): Option[Node] =
    setNodeValue(prop, scala.xml.Text(value))

  protected val formatter: SimpleDateFormat = {
    val df = new java.text.SimpleDateFormat("EEE, dd MMM yyyy hh:mm:ss z")
    df.setTimeZone(java.util.TimeZone.getTimeZone("GMT"))
    df
  }

  def property(prop: Node): Option[Node] = prop match {
    case p @ <displayname/>                 => setValue(p, displayName)
    case p @ <creationdate/>                => setValue(p, formatter.format(creationTime))
    case p @ <getlastmodified/>             => setValue(p, formatter.format(lastModified))
    case p @ <getcontentlength/>            => setValue(p, contentLength.toString)
    case p @ <resourcetype/> if hasChildren => setNodeValue(p, <D:collection/>)
    case p @ <resourcetype/>                => Some(p)
    case p @ <getetag/>                     => etag.flatMap(setValue(p, _))
    case p @ <getcontenttype/>              => contentType.flatMap(setValue(p, _))
    case _                                  => None
  }
}

case class StaticResource(url: String) extends Resource {
  override def displayName: String         = url
  override def creationTime: Date          = new Date()
  override def lastModified: Date          = new Date()
  override def contentLength: Long         = 0
  override def hasChildren: Boolean        = true
  override def contentType: Option[String] = None
}

case class EntityResource[E <: Entity](entity: E, id: String) extends Resource {
  override def url: String                 = id
  override def displayName: String         = url
  override def creationTime: Date          = entity._createdAt
  override def lastModified: Date          = entity._updatedAt.getOrElse(entity._createdAt)
  override def contentLength: Long         = 0
  override def hasChildren: Boolean        = true
  override def contentType: Option[String] = None
}

case class AttachmentResource(attachment: Attachment with Entity, emptyId: Boolean) extends Resource {
  override def url: String                 = if (emptyId) "" else attachment.attachmentId
  override def displayName: String         = attachment.name
  override def creationTime: Date          = attachment._createdAt
  override def lastModified: Date          = attachment._updatedAt.getOrElse(attachment._createdAt)
  override def contentLength: Long         = attachment.size
  override def hasChildren: Boolean        = false
  override def etag: Option[String]        = Some(attachment.attachmentId)
  override def contentType: Option[String] = Some(attachment.contentType)
}

```

`thehive/app/org/thp/thehive/controllers/dav/Router.scala`:

```scala
package org.thp.thehive.controllers.dav

import akka.stream.scaladsl.StreamConverters
import akka.util.ByteString
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.thehive.models.Permissions
import org.thp.thehive.services.AttachmentSrv
import play.api.Logger
import play.api.http.{HttpEntity, Status, Writeable}
import play.api.mvc._
import play.api.routing.Router.Routes
import play.api.routing.SimpleRouter
import play.api.routing.sird._

import javax.inject.{Inject, Singleton}
import scala.util.Success
import scala.util.matching.Regex
import scala.xml.{Node, NodeSeq}

@Singleton
class Router @Inject() (entrypoint: Entrypoint, vfs: VFS, db: Database, attachmentSrv: AttachmentSrv) extends SimpleRouter {
  lazy val logger: Logger = Logger(getClass)

  object PROPFIND {

    def unapply(request: RequestHeader): Option[RequestHeader] =
      Some(request).filter(_.method.equalsIgnoreCase("PROPFIND"))
  }

  override def routes: Routes = {
    case OPTIONS(_)                                       => options()
    case PROPFIND(request)                                => dav(request.path)
    case GET(p"/cases/$caseId/observables/$attachmentId") => downloadFile(attachmentId)
    case GET(p"/cases/$caseId/tasks/$attachmentId")       => downloadFile(attachmentId)
    case HEAD(request)                                    => head(request.path)
    case _                                                => debug()
  }

  def debug(): Action[AnyContent] =
    entrypoint("DAV options") { request =>
      logger.debug(s"request ${request.method} ${request.path}")
      request.headers.headers.foreach {
        case (k, v) => logger.debug(s"$k: $v")
      }
      logger.debug(request.body.toString)
      Success(Results.Ok(""))
    }

  def options(): Action[AnyContent] =
    entrypoint("DAV options")
      .auth { _ =>
        Success(
          Results
            .Ok(EmptyResponse())(EmptyResponse.writeable("httpd/unix-directory"))
            .withHeaders(
              "DAV"           -> "1,2 <http://apache.org/dav/propset/fs/1>",
              "MS-Author-Via" -> "DAV",
              "Allow"         -> "OPTIONS,GET,HEAD,POST,PROPFIND"
            )
        )
      }

  def dav(path: String): Action[AnyContent] =
    entrypoint("dav")
      .extract("xml", FieldsParser.xml.on("xml"))
      .authPermittedRoTransaction(db, Permissions.accessTheHiveFS) { implicit request => implicit graph =>
        val pathElements = path.split('/').toList.filterNot(_.isEmpty)
        val baseUrl =
          if (request.uri.endsWith("/")) request.uri
          else request.uri + '/'
        val resources =
          if (request.headers.get("Depth").contains("1")) vfs.get(pathElements) ++ vfs.list(pathElements)
          else vfs.get(pathElements)
        val props: NodeSeq = request.body("xml") \ "prop" \ "_"
        val response = <D:multistatus xmlns:D="DAV:">
          {
          resources.map { resource =>
            val (knownProps, unknownProps) = props.foldLeft(List.empty[Node] -> List.empty[Node]) {
              case ((k, u), p) => resource.property(p).fold((k, p :: u))(v => (v :: k, u))
            }
            val href = if (resource.url.isEmpty) request.uri else baseUrl + resource.url
            <D:response>
              <D:href>{href}</D:href>
              <D:propstat xmlns:D="DAV:">
                <D:prop>{knownProps}</D:prop>
                <D:status>HTTP/1.1 200 OK</D:status>
              </D:propstat>
              <D:propstat xmlns:D="DAV:">
                <D:prop>{unknownProps}</D:prop>
                <D:status>HTTP/1.1 404 Not Found</D:status>
              </D:propstat>
            </D:response>
          }
        }
        </D:multistatus>
        Success(Results.MultiStatus(response))
      }

  val rangeExtract: Regex = "^bytes=(\\d+)-(\\d+)?$".r

  def downloadFile(id: String): Action[AnyContent] =
    entrypoint("download attachment")
      .authPermittedRoTransaction(db, Permissions.accessTheHiveFS) { request => implicit graph =>
        attachmentSrv.getOrFail(EntityIdOrName(id)).map { attachment =>
          val range = request.headers.get("Range")
          range match {
            case Some(rangeExtract(from, maybeTo)) =>
              logger.debug(s"Download attachment $id with range $from-$maybeTo")
              val is = attachmentSrv.stream(attachment)
              is.skip(from.toLong)
              val to            = Option(maybeTo).fold(attachment.size)(_.toLong)
              val source        = StreamConverters.fromInputStream(() => is)
              val contentLength = to - from.toLong
              Result(
                header = ResponseHeader(Status.PARTIAL_CONTENT, Map("Content-Range" -> s"bytes $from-$to/${attachment.size}")),
                body = HttpEntity.Streamed(source.take(contentLength), Some(contentLength), Some(attachment.contentType))
              )
            case _ =>
              logger.debug(s"Download attachment $id")
              Result(
                header = ResponseHeader(Status.OK, Map("Cache-Control" -> "immutable", "ETag" -> s""""$id"""")),
                body = HttpEntity.Streamed(attachmentSrv.source(attachment), None, None)
              )
          }
        }
      }

  def head(path: String): Action[AnyContent] =
    entrypoint("head")
      .authPermittedRoTransaction(db, Permissions.accessTheHiveFS) { implicit request => implicit graph =>
        val pathElements = path.split('/').toList
        vfs
          .get(pathElements)
          .headOption
          .map {
            case AttachmentResource(a, _) =>
              Success(
                Results
                  .Ok(EmptyResponse())(EmptyResponse.writeable(a.contentType))
                  .withHeaders("Accept-Ranges" -> "Bytes", "ETag" -> s""""${a.attachmentId}"""", "Content-Length" -> a.size.toString)
              )
            case _ => Success(Results.Ok(EmptyResponse())(EmptyResponse.writeable("httpd/unix-directory")))
          }
          .getOrElse(Success(Results.NotFound))
      }
}

case class EmptyResponse()

object EmptyResponse {
  def writeable(contentType: String): Writeable[EmptyResponse] = new Writeable[EmptyResponse](_ => ByteString.empty, Some(contentType))
}

```

`thehive/app/org/thp/thehive/controllers/dav/VFS.scala`:

```scala
package org.thp.thehive.controllers.dav

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.{CaseSrv, OrganisationSrv}

import javax.inject.{Inject, Singleton}

@Singleton
class VFS @Inject() (caseSrv: CaseSrv, organisationSrv: OrganisationSrv) {

  def get(path: List[String])(implicit graph: Graph, authContext: AuthContext): Seq[Resource] =
    path match {
      case Nil | "" :: Nil                        => List(StaticResource(""))
      case "cases" :: Nil                         => List(StaticResource(""))
      case "cases" :: cid :: Nil                  => caseSrv.startTraversal.getByNumber(cid.toInt).toSeq.map(EntityResource(_, ""))
      case "cases" :: cid :: "observables" :: Nil => List(StaticResource(""))
      case "cases" :: cid :: "tasks" :: Nil       => List(StaticResource(""))
      case "cases" :: cid :: "observables" :: aid :: Nil =>
        caseSrv
          .startTraversal
          .getByNumber(cid.toInt)
          .observables
          .attachments
          .has(_.attachmentId, aid)
          .toSeq
          .map(AttachmentResource(_, emptyId = true))
      case "cases" :: cid :: "tasks" :: aid :: Nil =>
        caseSrv
          .startTraversal
          .getByNumber(cid.toInt)
          .tasks
          .logs
          .attachments
          .has(_.attachmentId, aid)
          .toSeq
          .map(AttachmentResource(_, emptyId = true))
      case _ => Nil
    }

  def list(path: List[String])(implicit graph: Graph, authContext: AuthContext): Seq[Resource] =
    path match {
      case Nil | "" :: Nil       => List(StaticResource("cases"))
      case "cases" :: Nil        => caseSrv.startTraversal.visible(organisationSrv).toSeq.map(c => EntityResource(c, c.number.toString))
      case "cases" :: cid :: Nil => List(StaticResource("observables"), StaticResource("tasks"))
      case "cases" :: cid :: "observables" :: Nil =>
        caseSrv
          .startTraversal
          .getByNumber(cid.toInt)
          .observables
          .attachments
          .domainMap(AttachmentResource(_, emptyId = false))
          .toSeq
      case "cases" :: cid :: "tasks" :: Nil =>
        caseSrv
          .startTraversal
          .getByNumber(cid.toInt)
          .tasks
          .logs
          .attachments
          .domainMap(AttachmentResource(_, emptyId = false))
          .toSeq
      case _ => Nil
    }
}

```

`thehive/app/org/thp/thehive/controllers/v0/AlertCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import io.scalaland.chimney.dsl._
import org.apache.tinkerpop.gremlin.process.traversal.{Compare, Contains, P}
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers._
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal._
import org.thp.scalligraph.{
  AuthorizationError,
  BadRequestError,
  CreateError,
  EntityId,
  EntityIdOrName,
  EntityName,
  InvalidFormatAttributeError,
  RichOptionTry,
  RichSeq
}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.{InputAlert, InputObservable, OutputSimilarCase}
import org.thp.thehive.dto.v1.InputCustomFieldValue
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.libs.json.{JsArray, JsObject, JsValue, Json}
import play.api.mvc.{Action, AnyContent, Results}

import java.util.function.BiPredicate
import java.util.{Base64, List => JList, Map => JMap}
import javax.inject.{Inject, Named, Singleton}
import scala.collection.JavaConverters._
import scala.util.{Failure, Success, Try}

@Singleton
class AlertCtrl @Inject() (
    override val entrypoint: Entrypoint,
    alertSrv: AlertSrv,
    caseTemplateSrv: CaseTemplateSrv,
    observableTypeSrv: ObservableTypeSrv,
    attachmentSrv: AttachmentSrv,
    auditSrv: AuditSrv,
    userSrv: UserSrv,
    caseSrv: CaseSrv,
    observableSrv: ObservableSrv,
    organisationSrv: OrganisationSrv,
    override val publicData: PublicAlert,
    implicit val db: Database,
    @Named("v0") override val queryExecutor: QueryExecutor
) extends QueryCtrl {
  def create: Action[AnyContent] =
    entrypoint("create alert")
      .extract("alert", FieldsParser[InputAlert])
      .extract("caseTemplate", FieldsParser[String].optional.on("caseTemplate"))
      .extract("observables", FieldsParser[InputObservable].sequence.on("artifacts"))
      .authTransaction(db) { implicit request => implicit graph =>
        val caseTemplateName: Option[String]  = request.body("caseTemplate")
        val inputAlert: InputAlert            = request.body("alert")
        val observables: Seq[InputObservable] = request.body("observables")
        val customFields                      = inputAlert.customFields.map(c => InputCustomFieldValue(c.name, c.value, c.order))
        val caseTemplate                      = caseTemplateName.flatMap(ct => caseTemplateSrv.get(EntityIdOrName(ct)).visible.headOption)
        for {
          organisation <-
            userSrv
              .current
              .organisations(Permissions.manageAlert)
              .get(request.organisation)
              .orFail(AuthorizationError("Operation not permitted"))
          richAlert          <- alertSrv.create(inputAlert.toAlert, organisation, inputAlert.tags, customFields, caseTemplate)
          createdObservables <- auditSrv.mergeAudits(observables.toTry(createObservable(richAlert.alert, _)).map(_.flatten))(_ => Success(()))
        } yield Results.Created((richAlert -> createdObservables).toJson)
      }

  def alertSimilarityRenderer(implicit
      authContext: AuthContext
  ): Traversal.V[Alert] => Traversal[JsArray, JList[JMap[String, Any]], Converter[JsArray, JList[JMap[String, Any]]]] =
    _.similarCases(organisationSrv, caseFilter = None)
      .fold
      .domainMap { similarCases =>
        JsArray {
          similarCases.map {
            case (richCase, similarStats) =>
              val similarCase = richCase
                .into[OutputSimilarCase]
                .withFieldConst(_.artifactCount, similarStats.observable._2)
                .withFieldConst(_.iocCount, similarStats.ioc._2)
                .withFieldConst(_.similarArtifactCount, similarStats.observable._1)
                .withFieldConst(_.similarIocCount, similarStats.ioc._1)
                .withFieldComputed(_._id, _._id.toString)
                .withFieldComputed(_.id, _._id.toString)
                .withFieldRenamed(_.number, _.caseId)
                .withFieldComputed(_.status, _.status.toString)
                .withFieldComputed(_.tags, _.tags.toSet)
                .enableMethodAccessors
                .transform
              Json.toJson(similarCase)
          }
        }
      }

  def get(alertId: String): Action[AnyContent] =
    entrypoint("get alert")
      .extract("similarity", FieldsParser[Boolean].optional.on("similarity"))
      .authRoTransaction(db) { implicit request => implicit graph =>
        val similarity: Option[Boolean] = request.body("similarity")
        val alert =
          alertSrv
            .get(EntityIdOrName(alertId))
            .visible(organisationSrv)
        if (similarity.contains(true))
          alert
            .richAlertWithCustomRenderer(alertSimilarityRenderer(request))
            .getOrFail("Alert")
            .map {
              case (richAlert, similarCases) =>
                val alertWithObservables: (RichAlert, Seq[RichObservable]) =
                  richAlert -> observableSrv.startTraversal.relatedTo(richAlert._id).richObservableWithSeen(organisationSrv).toSeq

                Results.Ok(alertWithObservables.toJson.as[JsObject] + ("similarCases" -> similarCases))
            }
        else
          alert
            .richAlert
            .getOrFail("Alert")
            .map { richAlert =>
              val alertWithObservables: (RichAlert, Seq[RichObservable]) =
                richAlert -> alertSrv.get(richAlert.alert).observables.richObservable.toSeq
              Results.Ok(alertWithObservables.toJson)
            }

      }

  def update(alertIdOrName: String): Action[AnyContent] =
    entrypoint("update alert")
      .extract("alert", FieldsParser.update("alert", publicData.publicProperties))
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("alert")
        alertSrv
          .update(_.get(EntityIdOrName(alertIdOrName)).visible(organisationSrv), propertyUpdaters)
          .flatMap { case (alertSteps, _) => alertSteps.richAlert.getOrFail("Alert") }
          .map { richAlert =>
            val alertWithObservables: (RichAlert, Seq[RichObservable]) = richAlert -> alertSrv.get(richAlert.alert).observables.richObservable.toSeq
            Results.Ok(alertWithObservables.toJson)
          }
      }

  def delete(alertIdOrName: String): Action[AnyContent] =
    entrypoint("delete alert")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        for {
          alert <-
            alertSrv
              .get(EntityIdOrName(alertIdOrName))
              .visible(organisationSrv)
              .getOrFail("Alert")
          _ <- alertSrv.remove(alert)
        } yield Results.NoContent
      }

  def bulkDelete: Action[AnyContent] =
    entrypoint("bulk delete alerts")
      .extract("ids", FieldsParser.string.sequence.on("ids"))
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        val ids: Seq[String] = request.body("ids")
        ids
          .toTry { alertId =>
            for {
              alert <-
                alertSrv
                  .get(EntityIdOrName(alertId))
                  .visible(organisationSrv)
                  .getOrFail("Alert")
              _ <- alertSrv.remove(alert)
            } yield ()
          }
          .map(_ => Results.NoContent)
      }

  def mergeWithCase(alertIdOrName: String, caseIdOrName: String): Action[AnyContent] =
    entrypoint("merge alert with case")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        for {
          alert    <- alertSrv.get(EntityIdOrName(alertIdOrName)).visible(organisationSrv).getOrFail("Alert")
          case0    <- caseSrv.get(EntityIdOrName(caseIdOrName)).can(Permissions.manageCase).getOrFail("Case")
          _        <- alertSrv.mergeInCase(alert, case0)
          richCase <- caseSrv.get(EntityIdOrName(caseIdOrName)).richCase.getOrFail("Case")
        } yield Results.Ok(richCase.toJson)
      }

  def bulkMergeWithCase: Action[AnyContent] =
    entrypoint("bulk merge with case")
      .extract("caseId", FieldsParser.string.on("caseId"))
      .extract("alertIds", FieldsParser.string.sequence.on("alertIds"))
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        val alertIds: Seq[String] = request.body("alertIds")
        val caseId: String        = request.body("caseId")

        val destinationCase = caseSrv
          .get(EntityIdOrName(caseId))
          .can(Permissions.manageCase)
          .getOrFail("Case")

        alertIds
          .foldLeft(destinationCase) { (caseTry, alertId) =>
            for {
              case0 <- caseTry
              alert <-
                alertSrv
                  .get(EntityIdOrName(alertId))
                  .visible(organisationSrv)
                  .getOrFail("Alert")
              updatedCase <- alertSrv.mergeInCase(alert, case0)
            } yield updatedCase
          }
          .flatMap(c => caseSrv.get(c._id).richCase.getOrFail("Case"))
          .map(rc => Results.Ok(rc.toJson))
      }

  def markAsRead(alertId: String): Action[AnyContent] =
    entrypoint("mark alert as read")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        for {
          alert <-
            alertSrv
              .get(EntityIdOrName(alertId))
              .visible(organisationSrv)
              .getOrFail("Alert")
          _ <- alertSrv.markAsRead(alert._id)
          alertWithObservables <-
            alertSrv
              .get(alert)
              .project(_.by(_.richAlert).by(_.observables.richObservable.fold))
              .getOrFail("Alert")
        } yield Results.Ok(alertWithObservables.toJson)
      }

  def markAsUnread(alertId: String): Action[AnyContent] =
    entrypoint("mark alert as unread")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        for {
          alert <-
            alertSrv
              .get(EntityIdOrName(alertId))
              .visible(organisationSrv)
              .getOrFail("Alert")
          _ <- alertSrv.markAsUnread(alert._id)
          alertWithObservables <-
            alertSrv
              .get(alert)
              .project(_.by(_.richAlert).by(_.observables.richObservable.fold))
              .getOrFail("Alert")
        } yield Results.Ok(alertWithObservables.toJson)
      }

  def createCase(alertId: String): Action[AnyContent] =
    entrypoint("create case from alert")
      .extract("caseTemplate", FieldsParser.string.optional.on("caseTemplate"))
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        val caseTemplate: Option[String] = request.body("caseTemplate")
        for {
          organisation <- organisationSrv.current.getOrFail("Organisation")
          alert <-
            alertSrv
              .get(EntityIdOrName(alertId))
              .visible(organisationSrv)
              .richAlert
              .getOrFail("Alert")
          _ <- caseTemplate.map(ct => caseTemplateSrv.get(EntityIdOrName(ct)).visible.existsOrFail).flip
          alertWithCaseTemplate = caseTemplate.fold(alert)(ct => alert.copy(caseTemplate = Some(ct)))
          assignee <- if (request.isPermitted(Permissions.manageCase)) userSrv.current.getOrFail("User").map(Some(_)) else Success(None)
          richCase <- alertSrv.createCase(alertWithCaseTemplate, assignee, organisation)
        } yield Results.Created(richCase.toJson)
      }

  def followAlert(alertId: String): Action[AnyContent] =
    entrypoint("follow alert")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        for {
          alert <-
            alertSrv
              .get(EntityIdOrName(alertId))
              .visible(organisationSrv)
              .getOrFail("Alert")
          _ <- alertSrv.followAlert(alert._id)
          alertWithObservables <-
            alertSrv
              .get(alert)
              .project(_.by(_.richAlert).by(_.observables.richObservable.fold))
              .getOrFail("Alert")
        } yield Results.Ok(alertWithObservables.toJson)
      }

  def unfollowAlert(alertId: String): Action[AnyContent] =
    entrypoint("unfollow alert")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        for {
          alert <-
            alertSrv
              .get(EntityIdOrName(alertId))
              .visible(organisationSrv)
              .getOrFail("Alert")
          _ <- alertSrv.unfollowAlert(alert._id)
          alertWithObservables <-
            alertSrv
              .get(alert)
              .project(_.by(_.richAlert).by(_.observables.richObservable.fold))
              .getOrFail("Alert")
        } yield Results.Ok(alertWithObservables.toJson)
      }

  private def createObservable(alert: Alert with Entity, observable: InputObservable)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Seq[RichObservable]] =
    observableTypeSrv
      .getOrFail(EntityName(observable.dataType))
      .flatMap {
        case attachmentType if attachmentType.isAttachment =>
          observable
            .data
            .map(_.split(';'))
            .toTry {
              case Array(filename, contentType, value) =>
                val data = Base64.getDecoder.decode(value)
                attachmentSrv
                  .create(filename, contentType, data)
                  .flatMap(attachment => alertSrv.createObservable(alert, observable.toObservable, attachment)) match {
                  case Success(o)              => Success(Some(o))
                  case Failure(_: CreateError) => Success(None)
                  case Failure(otherError)     => Failure(otherError)
                }
              case Array(filename, contentType) =>
                attachmentSrv
                  .create(filename, contentType, Array.emptyByteArray)
                  .flatMap(attachment => alertSrv.createObservable(alert, observable.toObservable, attachment)) match {
                  case Success(o)              => Success(Some(o))
                  case Failure(_: CreateError) => Success(None)
                  case Failure(otherError)     => Failure(otherError)
                }
              case data =>
                Failure(InvalidFormatAttributeError("artifacts.data", "filename;contentType;base64value", Set.empty, FString(data.mkString(";"))))
            }
            .map(_.flatten)
        case _ =>
          observable
            .data
            .toTry { data =>
              alertSrv.createObservable(alert, observable.toObservable, data) match {
                case Success(o)              => Success(Some(o))
                case Failure(_: CreateError) => Success(None)
                case Failure(otherError)     => Failure(otherError)
              }
            }
            .map(_.flatten)
      }
}

@Singleton
class PublicAlert @Inject() (
    alertSrv: AlertSrv,
    organisationSrv: OrganisationSrv,
    customFieldSrv: CustomFieldSrv,
    observableSrv: ObservableSrv,
    db: Database
) extends PublicData {
  override val entityName: String = "alert"
  override val initialQuery: Query =
    Query
      .init[Traversal.V[Alert]](
        "listAlert",
        (graph, authContext) => alertSrv.startTraversal(graph).visible(organisationSrv)(authContext)
      )
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Alert]](
    "getAlert",
    (idOrName, graph, authContext) => alertSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Alert], IteratorOutput](
      "page",
      (range, alertSteps, _) =>
        alertSteps
          .richPage(range.from, range.to, withTotal = true, limitedCountThreshold) { alerts =>
            alerts.project(_.by(_.richAlert).by(_.observables.richObservable.fold))
          }
    )
  override val outputQuery: Query = Query.output[RichAlert, Traversal.V[Alert]](_.richAlert)
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[Alert], Traversal.V[Case]]("cases", (alertSteps, _) => alertSteps.`case`),
    Query[Traversal.V[Alert], Traversal.V[Observable]](
      "observables",
      (alertSteps, authContext) =>
        observableSrv.startTraversal(alertSteps.graph).has(_.relatedId, P.within(alertSteps._id.toSeq: _*)).visible(organisationSrv)(authContext)
    ),
    Query[
      Traversal.V[Alert],
      Traversal[(RichAlert, Seq[RichObservable]), JMap[String, Any], Converter[(RichAlert, Seq[RichObservable]), JMap[String, Any]]]
    ](
      "withObservables",
      (alertSteps, _) =>
        alertSteps
          .project(
            _.by(_.richAlert)
              .by(_.observables.richObservable.fold)
          )
    ),
    Query.output[(RichAlert, Seq[RichObservable])]
  )

  def statusFilter(status: String): Traversal.V[Alert] => Traversal.V[Alert] =
    status match {
      case "New"      => _.isEmptyId(_.caseId).has(_.read, false)
      case "Updated"  => _.nonEmptyId(_.caseId).has(_.read, false)
      case "Ignored"  => _.isEmptyId(_.caseId).has(_.read, true)
      case "Imported" => _.nonEmptyId(_.caseId).has(_.read, true)
      case _          => _.empty
    }

  def statusNotFilter(status: String): Traversal.V[Alert] => Traversal.V[Alert] =
    status match {
      case "New"      => _.or(_.nonEmptyId(_.caseId), _.has(_.read, true))
      case "Updated"  => _.or(_.isEmptyId(_.caseId), _.has(_.read, true))
      case "Ignored"  => _.or(_.nonEmptyId(_.caseId), _.has(_.read, false))
      case "Imported" => _.or(_.isEmptyId(_.caseId), _.has(_.read, false))
      case _          => identity
    }

  override val publicProperties: PublicProperties =
    PublicPropertyListBuilder[Alert]
      .property("type", UMapping.string)(_.field.updatable)
      .property("source", UMapping.string)(_.field.updatable)
      .property("sourceRef", UMapping.string)(_.field.updatable)
      .property("title", UMapping.string)(_.field.updatable)
      .property("description", UMapping.string)(_.field.updatable)
      .property("severity", UMapping.int)(_.field.updatable)
      .property("date", UMapping.date)(_.field.updatable)
      .property("lastSyncDate", UMapping.date.optional)(_.field.updatable)
      .property("tags", UMapping.string.set)(
        _.field
          .custom { (_, value, vertex, graph, authContext) =>
            alertSrv
              .get(vertex)(graph)
              .getOrFail("Alert")
              .flatMap(alert => alertSrv.updateTags(alert, value)(graph, authContext))
              .map(_ => Json.obj("tags" -> value))
          }
      )
      .property("flag", UMapping.boolean)(_.field.updatable)
      .property("tlp", UMapping.int)(_.field.updatable)
      .property("pap", UMapping.int)(_.field.updatable)
      .property("read", UMapping.boolean)(_.field.updatable)
      .property("follow", UMapping.boolean)(_.field.updatable)
      .property("status", UMapping.string)(
        _.select { alerts =>
          val readAndCase = alerts.project(
            _.byValue(_.read)
              .by(_.`case`.limit(1).count)
          )
          readAndCase.graphMap[String, String, IdentityConverter[String]](
            jmap =>
              readAndCase.converter.apply(jmap) match {
                case (false, caseCount) if caseCount == 0L => "New"
                case (false, _)                            => "Updated"
                case (true, caseCount) if caseCount == 0L  => "Ignored"
                case (true, _)                             => "Imported"
              },
            Converter.identity[String]
          )
        }
          .filter[String] {
            case (_, alerts, _, Right(predicate)) =>
              predicate.getBiPredicate.asInstanceOf[BiPredicate[_, _]] match {
                case Compare.eq       => statusFilter(predicate.getValue)(alerts)
                case Compare.neq      => statusNotFilter(predicate.getValue)(alerts)
                case Contains.within  => alerts.or(predicate.getValue.asInstanceOf[JList[String]].asScala.map(statusFilter): _*)
                case Contains.without => predicate.getValue.asInstanceOf[JList[String]].asScala.map(statusNotFilter).foldRight(alerts)(_ apply _)
                case p =>
                  logger.error(s"The predicate $p is not supported for alert status")
                  alerts.empty
              }
            case (_, alerts, _, Left(true)) => alerts
            case (_, alerts, _, _)          => alerts.empty
          }
          .readonly
      )
      .property("summary", UMapping.string.optional)(_.field.updatable)
      .property("user", UMapping.string)(_.field.updatable)
      .property("customFields", UMapping.jsonNative)(_.subSelect {
        case (FPathElem(_, FPathElem(idOrName, _)), alerts) =>
          alerts.customFieldJsonValue(customFieldSrv, EntityIdOrName(idOrName))
        case (_, alerts) => alerts.customFields.nameJsonValue.fold.domainMap(JsObject(_))
      }
        .filter[JsValue] {
          case (FPathElem(_, FPathElem(name, _)), alerts, _, predicate) =>
            predicate match {
              case Right(predicate) => alerts.customFieldFilter(customFieldSrv, EntityIdOrName(name), predicate)
              case Left(true)       => alerts.hasCustomField(customFieldSrv, EntityIdOrName(name))
              case Left(false)      => alerts.hasNotCustomField(customFieldSrv, EntityIdOrName(name))
            }
          case (_, caseTraversal, _, _) => caseTraversal.empty
        }
        .custom {
          case (FPathElem(_, FPathElem(name, _)), value, vertex, graph, authContext) =>
            for {
              c <- alertSrv.getByIds(EntityId(vertex.id))(graph).getOrFail("Alert")
              _ <- alertSrv.setOrCreateCustomField(c, InputCustomFieldValue(name, Some(value), None))(graph, authContext)
            } yield Json.obj(s"customField.$name" -> value)
          case (FPathElem(_, FPathEmpty), values: JsObject, vertex, graph, authContext) =>
            for {
              c   <- alertSrv.get(vertex)(graph).getOrFail("Alert")
              cfv <- values.fields.toTry { case (n, v) => customFieldSrv.getOrFail(EntityIdOrName(n))(graph).map(_ -> v) }
              _   <- alertSrv.updateCustomField(c, cfv)(graph, authContext)
            } yield Json.obj("customFields" -> values)
          case _ => Failure(BadRequestError("Invalid custom fields format"))
        })
      .property("case", db.idMapping)(_.select(_.`case`._id).readonly)
      .property("imported", UMapping.boolean)(
        _.select(_.imported)
          .filter[Boolean]((_, alertTraversal, _, predicate) =>
            predicate.fold(
              b => if (b) alertTraversal else alertTraversal.empty,
              p =>
                if (p.getValue) alertTraversal.nonEmptyId(_.caseId)
                else alertTraversal.isEmptyId(_.caseId)
            )
          )
          .readonly
      )
      .property("importDate", UMapping.date.optional)(_.select(_.importDate).readonly)
      .property("computed.handlingDuration", UMapping.long)(_.select(_.handlingDuration).readonly)
      .property("computed.handlingDurationInSeconds", UMapping.long)(_.select(_.handlingDuration.math("_ / 1000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInMinutes", UMapping.long)(_.select(_.handlingDuration.math("_ / 60000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInHours", UMapping.long)(_.select(_.handlingDuration.math("_ / 3600000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInDays", UMapping.long)(_.select(_.handlingDuration.math("_ / 86400000").domainMap(_.toLong)).readonly)
      .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/AttachmentCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import akka.stream.scaladsl.FileIO
import net.lingala.zip4j.ZipFile
import net.lingala.zip4j.model.ZipParameters
import net.lingala.zip4j.model.enums.{CompressionLevel, EncryptionMethod}
import org.thp.scalligraph.controllers.Entrypoint
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{EntityIdOrName, NotFoundError}
import org.thp.thehive.controllers.HttpHeaderParameterEncoding
import org.thp.thehive.services.AttachmentOps._
import org.thp.thehive.services.AttachmentSrv
import play.api.http.HttpEntity
import play.api.mvc._

import java.nio.file.Files
import javax.inject.{Inject, Singleton}
import scala.concurrent.ExecutionContext
import scala.util.{Failure, Try}

@Singleton
class AttachmentCtrl @Inject() (
    entrypoint: Entrypoint,
    appConfig: ApplicationConfig,
    attachmentSrv: AttachmentSrv,
    db: Database,
    ec: ExecutionContext
) {
  val forbiddenChar: Seq[Char] = Seq('/', '\n', '\r', '\t', '\u0000', '\f', '`', '?', '*', '\\', '<', '>', '|', '\"', ':', ';')

  val passwordConfig: ConfigItem[String, String] = appConfig.item[String]("datastore.attachment.password", "Password used to protect attachment ZIP")

  def download(id: String, name: Option[String]): Action[AnyContent] =
    entrypoint("download attachment")
      .authRoTransaction(db) { implicit authContext => implicit graph =>
        val filename = name.getOrElse(id).map(c => if (forbiddenChar.contains(c)) '_' else c)
        attachmentSrv
          .get(EntityIdOrName(id))
          .visible
          .getOrFail("Attachment")
          .filter(attachmentSrv.exists)
          .map { attachment =>
            Result(
              header = ResponseHeader(
                200,
                Map(
                  "Content-Disposition"       -> s"""attachment; ${HttpHeaderParameterEncoding.encode("filename", filename)}""",
                  "Content-Transfer-Encoding" -> "binary"
                )
              ),
              body = HttpEntity.Streamed(attachmentSrv.source(attachment), None, None)
            )
          }
          .recoverWith {
            case _: NoSuchElementException => Failure(NotFoundError(s"Attachment $id not found"))
          }
      }

  def downloadZip(id: String, name: Option[String]): Action[AnyContent] =
    entrypoint("download attachment")
      .authRoTransaction(db) { implicit authContext => implicit graph =>
        val filename = name.getOrElse(id).map(c => if (forbiddenChar.contains(c)) '_' else c)
        attachmentSrv
          .get(EntityIdOrName(id))
          .visible
          .getOrFail("Attachment")
          .filter(attachmentSrv.exists)
          .flatMap { attachment =>
            Try {
              val f = Files.createTempFile("downloadzip-", id)
              Files.delete(f)
              val zipFile   = new ZipFile(f.toFile, password.toCharArray)
              val zipParams = new ZipParameters
              zipParams.setCompressionLevel(CompressionLevel.FASTEST)
              zipParams.setEncryptFiles(true)
              zipParams.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD)
              zipParams.setFileNameInZip(filename)
              //      zipParams.setSourceExternalStream(true)
              val is = attachmentSrv.stream(attachment)
              try zipFile.addStream(is, zipParams)
              finally is.close()
              val source = FileIO.fromPath(f).mapMaterializedValue { fut =>
                fut.andThen { case _ => Files.delete(f) }(ec)
              }
              Result(
                header = ResponseHeader(
                  200,
                  Map(
                    "Content-Disposition"       -> s"""attachment; ${HttpHeaderParameterEncoding.encode("filename", s"$filename.zip")}""",
                    "Content-Type"              -> "application/zip",
                    "Content-Transfer-Encoding" -> "binary",
                    "Content-Length"            -> Files.size(f).toString
                  )
                ),
                body = HttpEntity.Streamed(source, Some(Files.size(f)), Some("application/zip"))
              )
            }
          }
          .recoverWith {
            case _: NoSuchElementException => Failure(NotFoundError(s"Attachment $id not found"))
          }
      }

  def password: String = passwordConfig.get
}

```

`thehive/app/org/thp/thehive/controllers/v0/AuditCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import akka.actor.ActorRef
import akka.pattern.ask
import akka.util.Timeout
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, UMapping}
import org.thp.scalligraph.query.PredicateOps.PredicateOpsDefs
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.models.{Audit, RichAudit}
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services._
import play.api.libs.json.{JsArray, JsObject, Json}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}
import scala.concurrent.ExecutionContext
import scala.concurrent.duration.DurationInt

@Singleton
class AuditCtrl @Inject() (
    override val entrypoint: Entrypoint,
    auditSrv: AuditSrv,
    @Named("flow-actor") flowActor: ActorRef,
    override val publicData: PublicAudit,
    implicit override val db: Database,
    implicit val ec: ExecutionContext,
    @Named("v0") override val queryExecutor: QueryExecutor
) extends AuditRenderer
    with QueryCtrl {
  implicit val timeout: Timeout = Timeout(5.minutes)

  def flow(caseId: Option[String]): Action[AnyContent] =
    entrypoint("audit flow")
      .asyncAuth { implicit request =>
        (flowActor ? FlowId(caseId.filterNot(_ == "any").map(EntityIdOrName(_)))).map {
          case AuditIds(auditIds) if auditIds.isEmpty => Results.Ok(JsArray.empty)
          case AuditIds(auditIds) =>
            val audits = db.roTransaction { implicit graph =>
              auditSrv
                .getByIds(auditIds: _*)
                .richAuditWithCustomRenderer(auditRenderer)
                .toIterator
                .map {
                  case (audit, obj) =>
                    audit
                      .toJson
                      .as[JsObject]
                      .deepMerge(
                        Json.obj(
                          "base"    -> Json.obj("object" -> obj, "rootId" -> audit.context._id),
                          "summary" -> JsObject.empty //jsonSummary(auditSrv, audit.requestId)
                        )
                      )
                }
                .toBuffer
            }
            Results.Ok(JsArray(audits))
        }
      }
}

@Singleton
class PublicAudit @Inject() (auditSrv: AuditSrv, organisationSrv: OrganisationSrv, db: Database) extends PublicData {
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Audit]](
    "getAudit",
    (idOrName, graph, authContext) => auditSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )

  override val entityName: String = "audit"

  override val initialQuery: Query =
    Query.init[Traversal.V[Audit]]("listAudit", (graph, authContext) => auditSrv.startTraversal(graph).visible(organisationSrv)(authContext))

  override def pageQuery(limitedCountThreshold: Long): ParamQuery[org.thp.thehive.controllers.v0.OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Audit], IteratorOutput](
      "page",
      (range, auditSteps, _) => auditSteps.richPage(range.from, range.to, withTotal = true, limitedCountThreshold)(_.richAudit)
    )
  override val outputQuery: Query = Query.output[RichAudit, Traversal.V[Audit]](_.richAudit)

  override val extraQueries: Seq[ParamQuery[_]] = {
    implicit val entityIdParser: FieldsParser[String] = FieldsParser.string.on("id")
    Seq(
      Query.initWithParam[String, Traversal.V[Audit]](
        "listAuditFromObject",
        (objectId, graph, authContext) =>
          if (auditSrv.startTraversal(graph).has(_.objectId, objectId).v[Audit].limit(1).visible(organisationSrv)(authContext).exists)
            auditSrv.startTraversal(graph).has(_.objectId, objectId).v[Audit]
          else
            graph.empty
      )
    )
  }

  override val publicProperties: PublicProperties =
    PublicPropertyListBuilder[Audit]
      .property("operation", UMapping.string)(
        _.select(_.value(_.action).domainMap(actionToOperation))
          .filter[String] {
            case (_, audits, _, Right(p))   => audits.has(_.action, p.mapValue(operationToAction))
            case (_, audits, _, Left(true)) => audits
            case (_, audits, _, _)          => audits.empty
          }
          .readonly
      )
      .property("details", UMapping.string)(_.field.readonly)
      .property("objectType", UMapping.string.optional)(
        _.select(_.value(_.objectType).domainMap(fromObjectType))
          .filter[String] {
            case (_, audits, _, Right(p))   => audits.has(_.objectType, p.mapValue(toObjectType))
            case (_, audits, _, Left(true)) => audits
            case (_, audits, _, _)          => audits.empty
          }
          .readonly
      )
      .property("objectId", UMapping.string.optional)(_.field.readonly)
      .property("base", UMapping.boolean)(_.rename("mainAction").readonly)
      .property("startDate", UMapping.date)(_.rename("_createdAt").readonly)
      .property("requestId", UMapping.string)(_.field.readonly)
      .property("rootId", db.idMapping)(_.select(_.context._id).readonly)
      .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/AuditRenderer.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.models.UMapping
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal._
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.controllers.v1.Conversion.{patternOutput, richProcedureRenderer}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.PatternOps._
import org.thp.thehive.services.ProcedureOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services._
import play.api.libs.json.{JsNumber, JsObject, JsString}

import java.util.{Date, List => JList, Map => JMap}

trait AuditRenderer {

  def caseToJson: Traversal.V[Case] => Traversal[JsObject, JList[JMap[String, Any]], Converter[JsObject, JList[JMap[String, Any]]]] =
    _.richCaseWithoutPerms.option.domainMap[JsObject](_.fold(JsObject.empty)(_.toJson.as[JsObject]))

  def taskToJson: Traversal.V[Task] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    _.project(
      _.by(_.richTaskWithoutActionRequired.option.domainMap(_.fold(JsObject.empty)(_.toJson.as[JsObject])))
        .by(t => caseToJson(t.`case`))
    ).domainMap {
      case (task, case0) => task + ("case" -> case0)
    }

  def alertToJson: Traversal.V[Alert] => Traversal[JsObject, JList[JMap[String, Any]], Converter[JsObject, JList[JMap[String, Any]]]] =
    _.richAlert.option.domainMap(_.fold(JsObject.empty)(_.toJson.as[JsObject]))

  def logToJson: Traversal.V[Log] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    _.project(
      _.by(_.richLog.option.domainMap(_.fold(JsObject.empty)(_.toJson.as[JsObject])))
        .by(l => taskToJson(l.task))
    ).domainMap { case (log, task) => log + ("case_task" -> task) }

  def observableToJson: Traversal.V[Observable] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    _.project(
      _.by(_.richObservable.option.domainMap(_.fold(JsObject.empty)(_.toJson.as[JsObject])))
        .by(_.coalesceMulti(o => caseToJson(o.`case`), o => alertToJson(o.alert)))
    ).domainMap {
      case (obs, caseOrAlert) => obs + ((caseOrAlert \ "_type").asOpt[String].getOrElse("<unknown>") -> caseOrAlert)
    }

  case class Job(
      workerId: String,
      workerName: String,
      workerDefinition: String,
      status: String,
      startDate: Date,
      endDate: Date,
      report: Option[JsObject],
      cortexId: String,
      cortexJobId: String
  )
  def jobToJson
      : Traversal[Vertex, Vertex, IdentityConverter[Vertex]] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    _.project(_.by.by)
      .domainMap {
        case (vertex, _) =>
          JsObject(
            UMapping.string.optional.getProperty(vertex, "workerId").map(v => "analyzerId" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "workerName").map(v => "analyzerName" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "workerDefinition").map(v => "analyzerDefinition" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "status").map(v => "status" -> JsString(v)).toList :::
              UMapping.date.optional.getProperty(vertex, "startDate").map(v => "startDate" -> JsNumber(v.getTime)).toList :::
              UMapping.date.optional.getProperty(vertex, "endDate").map(v => "endDate" -> JsNumber(v.getTime)).toList :::
              UMapping.string.optional.getProperty(vertex, "cortexId").map(v => "cortexId" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "cortexJobId").map(v => "cortexJobId" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "_createdBy").map(v => "_createdBy" -> JsString(v)).toList :::
              UMapping.date.optional.getProperty(vertex, "_createdAt").map(v => "_createdAt" -> JsNumber(v.getTime)).toList :::
              UMapping.string.optional.getProperty(vertex, "_updatedBy").map(v => "_updatedBy" -> JsString(v)).toList :::
              UMapping.date.optional.getProperty(vertex, "_updatedAt").map(v => "_updatedAt" -> JsNumber(v.getTime)).toList :::
              UMapping.string.optional.getProperty(vertex, "_type").map(v => "_type" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "_id").map(v => "_id" -> JsString(v)).toList
          )
      }

  def patternToJson: Traversal.V[Pattern] => Traversal[JsObject, JList[JMap[String, Any]], Converter[JsObject, JList[JMap[String, Any]]]] =
    _.richPattern.option.domainMap(_.fold(JsObject.empty)(_.toJson.as[JsObject]))

  def procedureToJson: Traversal.V[Procedure] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    _.project(
      _.by(_.richProcedure.option.domainMap(_.fold(JsObject.empty)(_.toJson.as[JsObject])))
        .by(t => caseToJson(t.`case`))
        .by(t => patternToJson(t.pattern))
    )
      .domainMap {
        case (procedure, case0, pattern) => procedure + ("case" -> case0) + ("pattern" -> pattern)
      }

  def auditRenderer: Traversal.V[Audit] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    (_: Traversal.V[Audit])
      .coalesceIdent[Vertex](_.`object`, _.identity)
      .chooseValue(
        _.on(_.label)
          .option("Case", t => caseToJson(t.v[Case]))
          .option("Task", t => taskToJson(t.v[Task]))
          .option("Log", t => logToJson(t.v[Log]))
          .option("Observable", t => observableToJson(t.v[Observable]))
          .option("Alert", t => alertToJson(t.v[Alert]))
          .option("Procedure", t => procedureToJson(t.v[Procedure]))
          .option("Job", jobToJson)
          .none(_.constant2[JsObject, JMap[String, Any]](JsObject.empty))
      )

  def jsonSummary(auditSrv: AuditSrv, requestId: String)(implicit graph: Graph): JsObject =
    auditSrv
      .startTraversal
      .has(_.requestId, requestId)
      .has(_.mainAction, false)
      .group(
        _.byValue(_.objectType),
        _.by(_.groupCount(_.byValue(_.action)))
      )
      .headOption
      .fold(JsObject.empty) { m =>
        JsObject(
          m.map {
            case (o, ac) =>
              fromObjectType(o) -> JsObject(ac.map {
                case (a, c) =>
                  actionToOperation(a) -> JsNumber(c)
              })
          }
        )
      }

}

```

`thehive/app/org/thp/thehive/controllers/v0/AuthenticationCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.auth.{AuthSrv, RequestOrganisation}
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AuthorizationError, EntityIdOrName, EntityName}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services.UserSrv
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.concurrent.ExecutionContext
import scala.util.{Failure, Success}
@Singleton
class AuthenticationCtrl @Inject() (
    entrypoint: Entrypoint,
    authSrv: AuthSrv,
    requestOrganisation: RequestOrganisation,
    userSrv: UserSrv,
    db: Database,
    implicit val ec: ExecutionContext
) {

  def logout: Action[AnyContent] =
    entrypoint("logout") { _ =>
      Success(Results.Ok.withNewSession)
    }

  def login: Action[AnyContent] =
    entrypoint("login")
      .extract("login", FieldsParser[String].on("user"))
      .extract("password", FieldsParser[String].on("password"))
      .extract("organisation", FieldsParser[String].optional.on("organisation"))
      .extract("code", FieldsParser[String].optional.on("code")) { implicit request =>
        val login: String                        = request.body("login")
        val password: String                     = request.body("password")
        val organisation: Option[EntityIdOrName] = request.body("organisation").map(EntityIdOrName(_)) orElse requestOrganisation(request)
        val code: Option[String]                 = request.body("code")
        for {
          authContext <- authSrv.authenticate(login, password, organisation, code)
          user        <- db.roTransaction(userSrv.get(EntityName(authContext.userId))(_).richUser(authContext).getOrFail("User"))
          _           <- if (user.locked) Failure(AuthorizationError("Your account is locked")) else Success(())
        } yield authSrv.setSessionUser(authContext)(Results.Ok(user.toJson))
      }
}

```

`thehive/app/org/thp/thehive/controllers/v0/CaseCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.apache.tinkerpop.gremlin.process.traversal.P
import org.thp.scalligraph._
import org.thp.scalligraph.controllers.{Entrypoint, FPathElem, FPathEmpty, FieldsParser}
import org.thp.scalligraph.models.{Database, UMapping}
import org.thp.scalligraph.query.PredicateOps._
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, IteratorOutput, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.{InputCase, InputTask}
import org.thp.thehive.dto.v1.InputCustomFieldValue
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.CustomFieldOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ProcedureOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.libs.json._
import play.api.mvc.{Action, AnyContent, Results}

import java.util.{Map => JMap}
import javax.inject.{Inject, Named, Singleton}
import scala.util.{Failure, Success}

@Singleton
class CaseCtrl @Inject() (
    override val entrypoint: Entrypoint,
    caseSrv: CaseSrv,
    caseTemplateSrv: CaseTemplateSrv,
    userSrv: UserSrv,
    organisationSrv: OrganisationSrv,
    override val publicData: PublicCase,
    @Named("v0") override val queryExecutor: QueryExecutor,
    implicit override val db: Database
) extends CaseRenderer
    with QueryCtrl {
  def create: Action[AnyContent] =
    entrypoint("create case")
      .extract("case", FieldsParser[InputCase])
      .extract("tasks", FieldsParser[InputTask].sequence.on("tasks"))
      .extract("caseTemplate", FieldsParser[String].optional.on("template"))
      .authTransaction(db) { implicit request => implicit graph =>
        val caseTemplateName: Option[String] = request.body("caseTemplate")
        val inputCase: InputCase             = request.body("case")
        val inputTasks: Seq[InputTask]       = request.body("tasks")
        val customFields                     = inputCase.customFields.map(c => InputCustomFieldValue(c.name, c.value, c.order))
        for {
          organisation <-
            userSrv
              .current
              .organisations(Permissions.manageCase)
              .get(request.organisation)
              .orFail(AuthorizationError("Operation not permitted"))
          user         <- inputCase.user.fold(userSrv.current.getOrFail("User"))(userSrv.getByName(_).getOrFail("User"))
          caseTemplate <- caseTemplateName.map(ct => caseTemplateSrv.get(EntityIdOrName(ct)).visible.richCaseTemplate.getOrFail("CaseTemplate")).flip
          richCase <- caseSrv.create(
            caseTemplate.fold(inputCase)(inputCase.withCaseTemplate).toCase,
            Some(user),
            organisation,
            customFields,
            caseTemplate,
            inputTasks.map(_.toTask)
          )
        } yield Results.Created(richCase.toJson)
      }

  def get(caseIdOrNumber: String): Action[AnyContent] =
    entrypoint("get case")
      .extract("stats", FieldsParser.boolean.optional.on("nstats"))
      .authRoTransaction(db) { implicit request => implicit graph =>
        val c = caseSrv
          .get(EntityIdOrName(caseIdOrNumber))
          .visible(organisationSrv)
        val stats: Option[Boolean] = request.body("stats")
        if (stats.contains(true))
          c.richCaseWithCustomRenderer(caseStatsRenderer(request))
            .getOrFail("Case")
            .map {
              case (richCase, stats) => Results.Ok(richCase.toJson.as[JsObject] + ("stats" -> stats))
            }
        else
          c.richCase
            .getOrFail("Case")
            .map(richCase => Results.Ok(richCase.toJson))
      }

  def update(caseIdOrNumber: String): Action[AnyContent] =
    entrypoint("update case")
      .extract("case", FieldsParser.update("case", publicData.publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("case")
        caseSrv
          .update(
            _.get(EntityIdOrName(caseIdOrNumber))
              .can(Permissions.manageCase),
            propertyUpdaters
          )
          .flatMap {
            case (caseSteps, _) =>
              caseSteps
                .richCase
                .getOrFail("Case")
                .map(richCase => Results.Ok(richCase.toJson))
          }
      }

  def bulkUpdate: Action[AnyContent] =
    entrypoint("update case")
      .extract("case", FieldsParser.update("case", publicData.publicProperties))
      .extract("idsOrNumbers", FieldsParser.seq[String].on("ids"))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("case")
        val idsOrNumbers: Seq[String]              = request.body("idsOrNumbers")
        idsOrNumbers
          .toTry { caseIdOrNumber =>
            caseSrv
              .update(
                _.get(EntityIdOrName(caseIdOrNumber)).can(Permissions.manageCase),
                propertyUpdaters
              )
              .flatMap {
                case (caseSteps, _) =>
                  caseSteps
                    .richCase
                    .getOrFail("Case")
              }
          }
          .map(richCases => Results.Ok(richCases.toJson))
      }

  def delete(caseIdOrNumber: String): Action[AnyContent] =
    entrypoint("delete case")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          c <-
            caseSrv
              .get(EntityIdOrName(caseIdOrNumber))
              .can(Permissions.manageCase)
              .getOrFail("Case")
          _ <- caseSrv.delete(c)
        } yield Results.NoContent
      }

  def merge(caseId: String, caseToMerge: String): Action[AnyContent] =
    entrypoint("merge cases")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          caze    <- caseSrv.get(EntityIdOrName(caseId)).visible(organisationSrv).getOrFail("Case")
          toMerge <- caseSrv.get(EntityIdOrName(caseToMerge)).visible(organisationSrv).getOrFail("Case")
          merged  <- caseSrv.merge(Seq(caze, toMerge))
        } yield Results.Created(merged.toJson)
      }

  def linkedCases(caseIdOrNumber: String): Action[AnyContent] =
    entrypoint("case link")
      .auth { implicit request =>
        val src = db.source { implicit graph =>
          caseSrv
            .get(EntityIdOrName(caseIdOrNumber))
            .visible(organisationSrv)
            .linkedCases
            .domainMap {
              case (c, o) =>
                c.toJson.as[JsObject] +
                  ("linkedWith" -> o.toJson) +
                  ("linksCount" -> JsNumber(o.size))
            }
            .toIterator
        }
        Success(Results.Ok.chunked(src.map(_.toString).intersperse("[", ",", "]"), Some("application/json")))
      }
}

@Singleton
class PublicCase @Inject() (
    caseSrv: CaseSrv,
    organisationSrv: OrganisationSrv,
    observableSrv: ObservableSrv,
    userSrv: UserSrv,
    customFieldSrv: CustomFieldSrv,
    implicit val db: Database
) extends PublicData
    with CaseRenderer {
  override val entityName: String = "case"
  override val initialQuery: Query =
    Query.init[Traversal.V[Case]]("listCase", (graph, authContext) => caseSrv.startTraversal(graph).visible(organisationSrv)(authContext))
  override val getQuery: ParamQuery[EntityIdOrName] =
    Query.initWithParam[EntityIdOrName, Traversal.V[Case]](
      "getCase",
      (idOrName, graph, authContext) => caseSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
    )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Case], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, withStats, _), caseSteps, authContext) =>
          caseSteps
            .richPage(from, to, withTotal = true, limitedCountThreshold) {
              case c if withStats =>
                c.richCaseWithCustomRenderer(caseStatsRenderer(authContext))(authContext)
              case c =>
                c.richCase(authContext).domainMap(_ -> JsObject.empty)
            }
      }
    )
  override val outputQuery: Query = Query.outputWithContext[RichCase, Traversal.V[Case]]((caseSteps, authContext) => caseSteps.richCase(authContext))
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[Case], Traversal.V[Observable]](
      "observables",
      (caseSteps, authContext) =>
        // caseSteps.observables(authContext)
        observableSrv.startTraversal(caseSteps.graph).has(_.relatedId, P.within(caseSteps._id.toSeq: _*)).visible(organisationSrv)(authContext)
    ),
    Query[Traversal.V[Case], Traversal.V[Task]](
      "tasks",
      (caseSteps, authContext) => caseSteps.tasks(authContext)
//        taskSrv.startTraversal(caseSteps.graph).has(_.relatedId, P.within(caseSteps._id.toSeq: _*)).visible(organisationSrv)(authContext)
    ),
    Query[Traversal.V[Case], Traversal.V[User]]("assignableUsers", (caseSteps, authContext) => caseSteps.assignableUsers(authContext)),
    Query[Traversal.V[Case], Traversal.V[Organisation]]("organisations", (caseSteps, authContext) => caseSteps.organisations.visible(authContext)),
    Query[Traversal.V[Case], Traversal.V[Alert]]("alerts", (caseSteps, authContext) => caseSteps.alert.visible(organisationSrv)(authContext)),
    Query[Traversal.V[Case], Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]]](
      "linkedCases",
      (caseSteps, authContext) =>
        caseSteps
          .linkedCases(authContext)
          .domainMap {
            case (c, o) =>
              c.toJson.as[JsObject] +
                ("linkedWith" -> o.toJson) +
                ("linksCount" -> JsNumber(o.size))
          }
    )
  )
  override val publicProperties: PublicProperties =
    PublicPropertyListBuilder[Case]
      .property("caseId", UMapping.int)(_.rename("number").readonly)
      .property("title", UMapping.string)(_.field.updatable)
      .property("description", UMapping.string)(_.field.updatable)
      .property("severity", UMapping.int)(_.field.updatable)
      .property("startDate", UMapping.date)(_.field.updatable)
      .property("endDate", UMapping.date.optional)(_.field.updatable)
      .property("tags", UMapping.string.set)(
        _.field
          .custom { (_, value, vertex, graph, authContext) =>
            caseSrv
              .get(vertex)(graph)
              .getOrFail("Case")
              .flatMap(`case` => caseSrv.updateTags(`case`, value)(graph, authContext))
              .map(_ => Json.obj("tags" -> value))
          }
      )
      .property("flag", UMapping.boolean)(_.field.updatable)
      .property("tlp", UMapping.int)(_.field.updatable)
      .property("pap", UMapping.int)(_.field.updatable)
      .property("status", UMapping.enum[CaseStatus.type])(_.field.updatable)
      .property("summary", UMapping.string.optional)(_.field.updatable)
      .property("owner", UMapping.string.optional)(_.rename("assignee").custom { (_, login, vertex, graph, authContext) =>
        for {
          c    <- caseSrv.get(vertex)(graph).getOrFail("Case")
          user <- login.map(u => userSrv.get(EntityIdOrName(u))(graph).getOrFail("User")).flip
          _ <- user match {
            case Some(u) => caseSrv.assign(c, u)(graph, authContext)
            case None    => caseSrv.unassign(c)(graph, authContext)
          }
        } yield Json.obj("owner" -> user.map(_.login))
      })
      .property("resolutionStatus", UMapping.string.optional)(_.field.custom { (_, resolutionStatus, vertex, graph, authContext) =>
        for {
          c <- caseSrv.get(vertex)(graph).getOrFail("Case")
          _ <- resolutionStatus match {
            case Some(s) => caseSrv.setResolutionStatus(c, s)(graph, authContext)
            case None    => caseSrv.unsetResolutionStatus(c)(graph, authContext)
          }
        } yield Json.obj("resolutionStatus" -> resolutionStatus)
      })
      .property("impactStatus", UMapping.string.optional)(_.field.custom { (_, impactStatus, vertex, graph, authContext) =>
        for {
          c <- caseSrv.get(vertex)(graph).getOrFail("Case")
          _ <- impactStatus match {
            case Some(s) => caseSrv.setImpactStatus(c, s)(graph, authContext)
            case None    => caseSrv.unsetImpactStatus(c)(graph, authContext)
          }
        } yield Json.obj("impactStatus" -> impactStatus)
      })
      .property("customFields", UMapping.jsonNative)(_.subSelect {
        case (FPathElem(_, FPathElem(idOrName, _)), caseSteps) =>
          caseSteps.customFieldJsonValue(customFieldSrv, EntityIdOrName(idOrName))
        case (_, caseSteps) => caseSteps.customFields.nameJsonValue.fold.domainMap(JsObject(_))
      }
        .filter[JsValue] {
          case (FPathElem(_, FPathElem(name, _)), caseTraversal, _, predicate) =>
            predicate match {
              case Right(predicate) => caseTraversal.customFieldFilter(customFieldSrv, EntityIdOrName(name), predicate)
              case Left(true)       => caseTraversal.hasCustomField(customFieldSrv, EntityIdOrName(name))
              case Left(false)      => caseTraversal.hasNotCustomField(customFieldSrv, EntityIdOrName(name))
            }
          case (_, caseTraversal, _, _) => caseTraversal.empty
        }
        .custom {
          case (FPathElem(_, FPathElem(name, _)), value, vertex, graph, authContext) =>
            for {
              c <- caseSrv.get(vertex)(graph).getOrFail("Case")
              _ <- caseSrv.setOrCreateCustomField(c, EntityIdOrName(name), Some(value), None)(graph, authContext)
            } yield Json.obj(s"customField.$name" -> value)
          case (FPathElem(_, FPathEmpty), values: JsObject, vertex, graph, authContext) =>
            for {
              c   <- caseSrv.get(vertex)(graph).getOrFail("Case")
              cfv <- values.fields.toTry { case (n, v) => customFieldSrv.getOrFail(EntityIdOrName(n))(graph).map(cf => (cf, v, None)) }
              _   <- caseSrv.updateCustomField(c, cfv)(graph, authContext)
            } yield Json.obj("customFields" -> values)
          case _ => Failure(BadRequestError("Invalid custom fields format"))
        })
      .property("computed.handlingDuration", UMapping.long)(_.select(_.handlingDuration).readonly)
      .property("computed.handlingDurationInSeconds", UMapping.long)(_.select(_.handlingDuration.math("_ / 1000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInMinutes", UMapping.long)(_.select(_.handlingDuration.math("_ / 60000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInHours", UMapping.long)(_.select(_.handlingDuration.math("_ / 3600000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInDays", UMapping.long)(_.select(_.handlingDuration.math("_ / 86400000").domainMap(_.toLong)).readonly)
      .property("viewingOrganisation", UMapping.string)(
        _.select(t => t.value(_.organisationIds).domainMap(organisationSrv.getName(_)(t.graph)))
          .filter[String] {
            case (_, caseTraversal, _, Right(orgNamePredicate)) =>
              val organisationId = orgNamePredicate.mapValue(o => organisationSrv.getId(EntityIdOrName(o))(caseTraversal.graph))
              caseTraversal.has(_.organisationIds, organisationId)
            case (_, caseTraversal, _, Left(true)) =>
              caseTraversal
            case (_, caseTraversal, _, Left(false)) =>
              caseTraversal.empty
          }
          .readonly
      )
      .property("owningOrganisation", UMapping.string)(
        _.select(t => t.value(_.owningOrganisation).domainMap(organisationSrv.getName(_)(t.graph)))
          .filter[String] {
            case (_, caseTraversal, _, Right(orgNamePredicate)) =>
              val organisationId = orgNamePredicate.mapValue(o => organisationSrv.getId(EntityIdOrName(o))(caseTraversal.graph))
              caseTraversal.has(_.owningOrganisation, organisationId)
            case (_, caseTraversal, _, Left(true)) =>
              caseTraversal
            case (_, caseTraversal, _, Left(false)) =>
              caseTraversal.empty
          }
          .readonly
      )
      .property("patternId", UMapping.string.sequence)(_.select(_.procedure.pattern.value(_.patternId)).readonly)
      .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/CaseRenderer.scala`:

```scala
package org.thp.thehive.controllers.v0

import java.lang.{Long => JLong}
import java.util.{Collection => JCollection, List => JList, Map => JMap}

import org.apache.tinkerpop.gremlin.process.traversal.P
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, IdentityConverter, Traversal}
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import play.api.libs.json._

trait CaseRenderer {

  def observableStats: Traversal.V[Share] => Traversal[JsObject, JLong, Converter[JsObject, JLong]] =
    _.observables
      .count
      .domainMap(count => Json.obj("count" -> count))

  def taskStats: Traversal.V[Share] => Traversal[JsObject, JMap[String, JLong], Converter[JsObject, JMap[String, JLong]]] =
    _.tasks
      .active
      .groupCount(_.byValue(_.status))
      .domainMap { statusAgg =>
        val (total, result) = statusAgg.foldLeft(0L -> JsObject.empty) {
          case ((t, r), (k, v)) => (t + v) -> (r + (k.toString -> JsNumber(v.toInt)))
        }
        result + ("total" -> JsNumber(total))
      }

  def alertStats: Traversal.V[Case] => Traversal[Seq[JsObject], JMap[String, JCollection[String]], Converter[Seq[JsObject], JMap[String, JCollection[
    String
  ]]]] =
    _.in[AlertCase]
      .v[Alert]
      .group(_.byValue(_.`type`), _.byValue(_.source))
      .domainMap { alertAgg =>
        (for {
          (tpe, sources) <- alertAgg
          source         <- sources
        } yield Json.obj("type" -> tpe, "source" -> source)).toSeq
      }

  def mergeFromStats: Traversal.V[Case] => Traversal[JsNull.type, JsNull.type, IdentityConverter[JsNull.type]] = _.constant(JsNull)

  def mergeIntoStats: Traversal.V[Case] => Traversal[JsNull.type, JsNull.type, IdentityConverter[JsNull.type]] = _.constant(JsNull)

  def sharedWithStats: Traversal.V[Case] => Traversal[Seq[String], JList[String], Converter.CList[String, String, Converter[String, String]]] =
    _.organisations.value(_.name).fold

  def originStats: Traversal.V[Case] => Traversal[String, String, Converter[String, String]] = _.origin.value(_.name)

  def shareCountStats: Traversal.V[Case] => Traversal[Long, JLong, Converter[Long, JLong]] = _.organisations.count

  def isOwnerStats(implicit authContext: AuthContext): Traversal.V[Case] => Traversal[Boolean, Boolean, Converter.Identity[Boolean]] =
    _.origin
      .current
      .fold
      .count
      .choose(_.is(P.gt(0)), onTrue = true, onFalse = false)

  def caseStatsRenderer(implicit
      authContext: AuthContext
  ): Traversal.V[Case] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    _.project(
      _.by(
        (_: Traversal.V[Case]).coalesce(
          _.share.project(
            _.by(taskStats)
              .by(observableStats)
          ),
          JsObject.empty -> JsObject.empty
        )
      ).by(alertStats)
        .by(mergeFromStats)
        .by(mergeIntoStats)
        //        .by(sharedWithStats(_))
        //        .by(originStats(_))
        .by(isOwnerStats)
        .by(shareCountStats)
    ).domainMap {
      case ((tasks, observables), alerts, mergeFrom, mergeInto, isOwner, shareCount) =>
        Json.obj(
          "tasks"      -> tasks,
          "artifacts"  -> observables,
          "alerts"     -> alerts,
          "mergeFrom"  -> mergeFrom,
          "mergeInto"  -> mergeInto,
          "isOwner"    -> isOwner,
          "shareCount" -> (shareCount - 1)
        )
    }

}

```

`thehive/app/org/thp/thehive/controllers/v0/CaseTemplateCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.scalactic.Accumulation._
import org.thp.scalligraph.controllers._
import org.thp.scalligraph.models.{Database, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.scalligraph.{AttributeCheckingError, BadRequestError, EntityIdOrName, RichSeq}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.{InputCaseTemplate, InputTask}
import org.thp.thehive.models.{CaseTemplate, Permissions, RichCaseTemplate, Task}
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.Logger
import play.api.libs.json.{JsObject, JsValue, Json}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}
import scala.util.Failure

@Singleton
class CaseTemplateCtrl @Inject() (
    override val entrypoint: Entrypoint,
    caseTemplateSrv: CaseTemplateSrv,
    organisationSrv: OrganisationSrv,
    userSrv: UserSrv,
    auditSrv: AuditSrv,
    override val publicData: PublicCaseTemplate,
    implicit override val db: Database,
    @Named("v0") override val queryExecutor: QueryExecutor
) extends QueryCtrl {
  def create: Action[AnyContent] =
    entrypoint("create case template")
      .extract("caseTemplate", FieldsParser[InputCaseTemplate])
      .authTransaction(db) { implicit request => implicit graph =>
        val inputCaseTemplate: InputCaseTemplate = request.body("caseTemplate")
        val customFields                         = inputCaseTemplate.customFields.sortBy(_.order.getOrElse(0)).map(c => c.name -> c.value)
        val tasks                                = inputCaseTemplate.tasks.map(_.toTask)
        for {
          organisation     <- userSrv.current.organisations(Permissions.manageCaseTemplate).get(request.organisation).getOrFail("CaseTemplate")
          richCaseTemplate <- caseTemplateSrv.create(inputCaseTemplate.toCaseTemplate, organisation, tasks, customFields)
        } yield Results.Created(richCaseTemplate.toJson)
      }

  def get(caseTemplateNameOrId: String): Action[AnyContent] =
    entrypoint("get case template")
      .authRoTransaction(db) { implicit request => implicit graph =>
        caseTemplateSrv
          .get(EntityIdOrName(caseTemplateNameOrId))
          .visible
          .richCaseTemplate
          .getOrFail("CaseTemplate")
          .map(richCaseTemplate => Results.Ok(richCaseTemplate.toJson))
      }

  def update(caseTemplateNameOrId: String): Action[AnyContent] =
    entrypoint("update case template")
      .extract("caseTemplate", FieldsParser.update("caseTemplate", publicData.publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("caseTemplate")
        caseTemplateSrv
          .update(
            _.get(EntityIdOrName(caseTemplateNameOrId))
              .can(Permissions.manageCaseTemplate),
            propertyUpdaters
          )
          .flatMap {
            case (caseTemplates, _) =>
              caseTemplates
                .richCaseTemplate
                .getOrFail("CaseTemplate")
                .map(richCaseTemplate => Results.Ok(richCaseTemplate.toJson))
          }
      }

  def delete(caseTemplateNameOrId: String): Action[AnyContent] =
    entrypoint("delete case template")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          organisation <- organisationSrv.getOrFail(request.organisation)
          template     <- caseTemplateSrv.get(EntityIdOrName(caseTemplateNameOrId)).can(Permissions.manageCaseTemplate).getOrFail("CaseTemplate")
          _ = caseTemplateSrv.get(template).remove()
          _ <- auditSrv.caseTemplate.delete(template, organisation)
        } yield Results.Ok
      }
}

@Singleton
class PublicCaseTemplate @Inject() (
    caseTemplateSrv: CaseTemplateSrv,
    organisationSrv: OrganisationSrv,
    customFieldSrv: CustomFieldSrv
) extends PublicData {
  lazy val logger: Logger         = Logger(getClass)
  override val entityName: String = "caseTemplate"
  override val initialQuery: Query =
    Query
      .init[Traversal.V[CaseTemplate]]("listCaseTemplate", (graph, authContext) => organisationSrv.get(authContext.organisation)(graph).caseTemplates)
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[CaseTemplate]](
    "getCaseTemplate",
    (idOrName, graph, authContext) => caseTemplateSrv.get(idOrName)(graph).visible(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[CaseTemplate], IteratorOutput](
      "page",
      (range, caseTemplateSteps, _) => caseTemplateSteps.richPage(range.from, range.to, withTotal = true, limitedCountThreshold)(_.richCaseTemplate)
    )
  override val outputQuery: Query = Query.output[RichCaseTemplate, Traversal.V[CaseTemplate]](_.richCaseTemplate)
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[CaseTemplate], Traversal.V[Task]]("tasks", (caseTemplateSteps, _) => caseTemplateSteps.tasks)
  )
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[CaseTemplate]
    .property("name", UMapping.string)(_.field.updatable)
    .property("displayName", UMapping.string)(_.field.updatable)
    .property("titlePrefix", UMapping.string.optional)(_.field.updatable)
    .property("description", UMapping.string.optional)(_.field.updatable)
    .property("severity", UMapping.int.optional)(_.field.updatable)
    .property("tags", UMapping.string.set)(
      _.field
        .custom { (_, value, vertex, graph, authContext) =>
          caseTemplateSrv
            .get(vertex)(graph)
            .getOrFail("CaseTemplate")
            .flatMap(caseTemplate => caseTemplateSrv.updateTags(caseTemplate, value)(graph, authContext))
            .map(_ => Json.obj("tags" -> value))
        }
    )
    .property("flag", UMapping.boolean)(_.field.updatable)
    .property("tlp", UMapping.int.optional)(_.field.updatable)
    .property("pap", UMapping.int.optional)(_.field.updatable)
    .property("summary", UMapping.string.optional)(_.field.updatable)
    .property("user", UMapping.string)(_.field.updatable)
    .property("customFields", UMapping.jsonNative)(_.subSelect {
      case (FPathElem(_, FPathElem(name, _)), caseTemplateSteps) => caseTemplateSteps.customFieldJsonValue(customFieldSrv, EntityIdOrName(name))
      case (_, caseTemplateSteps)                                => caseTemplateSteps.customFields.nameJsonValue.fold.domainMap(JsObject(_))
    }
      .filter[JsValue] {
        case (FPathElem(_, FPathElem(name, _)), caseTemplateTraversal, _, predicate) =>
          predicate match {
            case Right(predicate) => caseTemplateTraversal.customFieldFilter(customFieldSrv, EntityIdOrName(name), predicate)
            case Left(true)       => caseTemplateTraversal.hasCustomField(customFieldSrv, EntityIdOrName(name))
            case Left(false)      => caseTemplateTraversal.hasNotCustomField(customFieldSrv, EntityIdOrName(name))
          }
        case (_, caseTraversal, _, _) => caseTraversal.empty
      }
      .custom {
        case (FPathElem(_, FPathElem(name, _)), value, vertex, graph, authContext) =>
          for {
            c <- caseTemplateSrv.get(vertex)(graph).getOrFail("CaseTemplate")
            _ <- caseTemplateSrv.setOrCreateCustomField(c, EntityIdOrName(name), Some(value), None)(graph, authContext)
          } yield Json.obj(s"customField.$name" -> value)
        case (FPathElem(_, FPathEmpty), values: JsObject, vertex, graph, authContext) =>
          for {
            c   <- caseTemplateSrv.get(vertex)(graph).getOrFail("CaseTemplate")
            cfv <- values.fields.toTry { case (n, v) => customFieldSrv.getOrFail(EntityIdOrName(n))(graph).map(cf => (cf, v, None)) }
            _   <- caseTemplateSrv.updateCustomField(c, cfv)(graph, authContext)
          } yield Json.obj("customFields" -> values)
        case _ => Failure(BadRequestError("Invalid custom fields format"))
      })
    .property("tasks", UMapping.jsonNative.sequence)(
      _.select(_.tasks.richTaskWithoutActionRequired.domainMap(_.toJson)).custom { //  FIXME select the correct mapping
        (_, value, vertex, graph, authContext) =>
          val fp = FieldsParser[InputTask]

          caseTemplateSrv.get(vertex)(graph).tasks.remove()
          for {
            caseTemplate <- caseTemplateSrv.get(vertex)(graph).getOrFail("CaseTemplate")
            tasks        <- value.validatedBy(t => fp(Field(t))).badMap(AttributeCheckingError(_)).toTry
            createdTasks <- tasks.toTry(task => caseTemplateSrv.createTask(caseTemplate, task.toTask)(graph, authContext))
          } yield Json.obj("tasks" -> createdTasks.map(_.toJson))
      }
    )
    .build

}

```

`thehive/app/org/thp/thehive/controllers/v0/ConfigCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import com.typesafe.config.{ConfigRenderOptions, Config => TypeSafeConfig}
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AuthorizationError, NotFoundError}
import org.thp.thehive.models.Permissions
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.libs.json._
import play.api.mvc.{Action, AnyContent, Result, Results}
import play.api.{ConfigLoader, Configuration, Logger}

import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class ConfigCtrl @Inject() (
    configuration: Configuration,
    appConfig: ApplicationConfig,
    userConfigContext: UserConfigContext,
    organisationConfigContext: OrganisationConfigContext,
    organisationSrv: OrganisationSrv,
    userSrv: UserSrv,
    entrypoint: Entrypoint,
    db: Database
) {

  lazy val logger: Logger = Logger(getClass)

  implicit val configWrites: Writes[ConfigItem[_, _]] = Writes[ConfigItem[_, _]](item =>
    Json.obj(
      "path"         -> item.path,
      "description"  -> item.description,
      "defaultValue" -> item.getDefaultValueJson,
      "value"        -> item.getJson
    )
  )

  implicit val jsonConfigLoader: ConfigLoader[JsValue] = (config: TypeSafeConfig, path: String) =>
    Json.parse(config.getValue(path).render(ConfigRenderOptions.concise()))

  def list: Action[AnyContent] =
    entrypoint("list configuration items")
      .authPermittedTransaction(db, Permissions.manageConfig) { implicit request => implicit graph =>
        if (!organisationSrv.current.isAdmin)
          Failure(AuthorizationError("You must be in `admin` organisation to view global configuration"))
        else
          Success(Results.Ok(Json.toJson(appConfig.list)))
      }

  def set(path: String): Action[AnyContent] =
    entrypoint("set configuration item")
      .extract("value", FieldsParser.json.on("value"))
      .authPermittedTransaction(db, Permissions.manageConfig) { implicit request => implicit graph =>
        if (!organisationSrv.current.isAdmin)
          Failure(AuthorizationError("You must be in `admin` organisation to change global configuration"))
        else {
          logger.info(s"app config value set: $path ${request.body("value")}")
          appConfig.set(path, request.body("value"))(request).map(_ => Results.NoContent)
        }
      }

  def get(path: String): Action[AnyContent] =
    entrypoint("get configuration item")
      .authPermittedTransaction(db, Permissions.manageConfig) { implicit request => implicit graph =>
        if (!organisationSrv.current.isAdmin)
          Failure(AuthorizationError("You must be in `admin` organisation to change global configuration"))
        else
          appConfig.get(path) match {
            case Some(c) => Success(Results.Ok(configWrites.writes(c)))
            case None    => Failure(NotFoundError(s"Configuration item $path not found"))
          }
      }

  def mergeConfig(defaultValue: JsValue, names: Seq[String], value: JsValue): JsValue =
    names
      .headOption
      .fold[JsValue](value) { key =>
        defaultValue
          .asOpt[JsObject]
          .fold(names.foldRight(value)((k, v) => Json.obj(k -> v))) { default =>
            default + (key -> mergeConfig((defaultValue \ key).getOrElse(JsNull), names.tail, value))
          }
      }

  def userList: Action[AnyContent] =
    entrypoint("list user configuration item")
      .extract("path", FieldsParser[String].optional.on("path"))
      .authRoTransaction(db) { implicit request => implicit graph =>
        val defaultValue = configuration.get[JsValue]("user.defaults")
        val userConfiguration = userSrv
          .current
          .config
          .toIterator
          .foldLeft(defaultValue)((default, config) => mergeConfig(default, config.name.split('.').toSeq, config.value))

        request.body("path") match {
          case Some(path: String) =>
            path
              .split('.')
              .foldLeft[JsLookupResult](JsDefined(userConfiguration))((cfg, key) => cfg \ key)
              .toOption
              .fold[Try[Result]](Failure(NotFoundError(s"The configuration $path doesn't exist")))(v => Success(Results.Ok(v)))
          case None =>
            Success(Results.Ok(userConfiguration))
        }
      }

  def userSet(path: String): Action[AnyContent] =
    entrypoint("set user configuration item")
      .extract("value", FieldsParser.json.on("value"))
      .auth { implicit request =>
        val config = appConfig.context(userConfigContext).item[JsValue](path, "")
        logger.info(s"user config value set: $path ${request.body("value")}")
        config.setJson(request, request.body("value")).map { _ =>
          Results.Ok(
            Json.obj(
              "path"         -> config.path,
              "defaultValue" -> config.getDefaultValueJson,
              "value"        -> config.getJson(request)
            )
          )
        }
      }

  def userGet(path: String): Action[AnyContent] =
    entrypoint("get user configuration item")
      .auth { implicit request =>
        Try {
          val config = appConfig.context(userConfigContext).item[JsValue](path, "")
          Results.Ok(
            Json.obj(
              "path"         -> config.path,
              "defaultValue" -> config.getDefaultValueJson,
              "value"        -> config.getJson(request)
            )
          )
        }.recover {
          case _ =>
            Results.Ok(
              Json.obj(
                "path"         -> path,
                "defaultValue" -> JsNull,
                "value"        -> JsNull
              )
            )
        }
      }

  def organisationList: Action[AnyContent] =
    entrypoint("list organisation configuration item")
      .extract("path", FieldsParser[String].optional.on("path"))
      .authRoTransaction(db) { implicit request => implicit graph =>
        val defaultValue = configuration.get[JsValue]("organisation.defaults")
        val orgConfiguration = organisationSrv
          .current
          .config
          .toIterator
          .foldLeft(defaultValue)((default, config) => mergeConfig(default, config.name.split('.').toSeq, config.value))

        request.body("path") match {
          case Some(path: String) =>
            path
              .split('.')
              .foldLeft[JsLookupResult](JsDefined(orgConfiguration))((cfg, key) => cfg \ key)
              .toOption
              .fold[Try[Result]](Failure(NotFoundError(s"The configuration $path doesn't exist")))(v => Success(Results.Ok(v)))
          case None =>
            Success(Results.Ok(orgConfiguration))
        }
      }

  def organisationGet(path: String): Action[AnyContent] =
    entrypoint("get organisation configuration item")
      .auth { implicit request =>
        Try {
          val config = appConfig.context(organisationConfigContext).item[JsValue](path, "")
          Results.Ok(
            Json.obj(
              "path"         -> config.path,
              "defaultValue" -> config.getDefaultValueJson,
              "value"        -> config.getJson(request)
            )
          )
        }.recover {
          case _ =>
            Results.Ok(
              Json.obj(
                "path"         -> path,
                "defaultValue" -> JsNull,
                "value"        -> JsNull
              )
            )
        }
      }

  def organisationSet(path: String): Action[AnyContent] =
    entrypoint("set organisation configuration item")
      .extract("value", FieldsParser.json.on("value"))
      .authPermitted(Permissions.manageConfig) { implicit request =>
        val config = appConfig.context(organisationConfigContext).item[JsValue](path, "")
        logger.info(s"organisation config value set: $path ${request.body("value")}")
        config.setJson(request, request.body("value")).map { _ =>
          Results.Ok(
            Json.obj(
              "path"         -> config.path,
              "defaultValue" -> config.getDefaultValueJson,
              "value"        -> config.getJson(request)
            )
          )
        }
      }
}

```

`thehive/app/org/thp/thehive/controllers/v0/Conversion.scala`:

```scala
package org.thp.thehive.controllers.v0

import io.scalaland.chimney.dsl._
import org.thp.scalligraph.EntityId
import org.thp.scalligraph.auth.{AuthContext, Permission, PermissionDesc}
import org.thp.scalligraph.controllers.Renderer
import org.thp.scalligraph.models.Entity
import org.thp.thehive.dto.v0._
import org.thp.thehive.models._
import play.api.libs.json.{JsObject, JsValue, Json, Writes}

import java.util.Date

object Conversion {
  implicit class RendererOps[F, O](f: F)(implicit renderer: Renderer.Aux[F, O]) {
    def toJson: JsValue = renderer.toOutput(f).toJson
    def toValue: O      = renderer.toOutput(f).toValue
  }

  val adminPermissions: Set[Permission] = Set(Permissions.manageUser, Permissions.manageOrganisation)

  def actionToOperation(action: String): String =
    action match {
      case "create" => "Creation"
      case "update" => "Update"
      case "delete" => "Delete"
      case "merge"  => "Update"
      case _        => "Unknown"
    }

  def operationToAction(operation: String): String =
    operation match {
      case "Creation" => "create"
      case "Update"   => "update"
      case "Delete"   => "delete"
      case _          => "Unknown"
    }

  def fromObjectType(objectType: String): String =
    objectType match {
      case "Task"       => "case_task"
      case "Log"        => "case_task_log"
      case "Observable" => "case_artifact"
      case "Job"        => "case_artifact_job"
      case other        => other.toLowerCase()
    }

  implicit val alertOutput: Renderer.Aux[RichAlert, OutputAlert] = Renderer.toJson[RichAlert, OutputAlert](richAlert =>
    richAlert
      .into[OutputAlert]
      .withFieldComputed(_.customFields, rc => JsObject(rc.customFields.map(cf => cf.name -> Json.obj(cf.typeName -> cf.toJson))))
      .withFieldRenamed(_._createdAt, _.createdAt)
      .withFieldRenamed(_._createdBy, _.createdBy)
      .withFieldRenamed(_._updatedAt, _.updatedAt)
      .withFieldRenamed(_._updatedBy, _.updatedBy)
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.id, _._id.toString)
      .withFieldComputed(_.id, _._id.toString)
      .withFieldConst(_._type, "alert")
      .withFieldComputed(_.tags, _.tags.toSet)
      .withFieldComputed(_.`case`, _.caseId.map(_.toString))
      .withFieldComputed(
        _.status,
        alert =>
          (alert.caseId, alert.read) match {
            case (None, true)  => "Ignored"
            case (None, false) => "New"
            case (_, true)     => "Imported"
            case (_, false)    => "Updated"
          }
      )
      .withFieldConst(_.similarCases, Nil)
      .enableMethodAccessors
      .transform
  )

  implicit val alertWithObservablesOutput: Renderer.Aux[(RichAlert, Seq[RichObservable]), OutputAlert] =
    Renderer.toJson[(RichAlert, Seq[RichObservable]), OutputAlert](richAlertWithObservables =>
      richAlertWithObservables
        ._1
        .into[OutputAlert]
        .withFieldComputed(_.customFields, rc => JsObject(rc.customFields.map(cf => cf.name -> Json.obj(cf.typeName -> cf.toJson))))
        .withFieldComputed(_._id, _._id.toString)
        .withFieldComputed(_.id, _._id.toString)
        .withFieldRenamed(_._createdAt, _.createdAt)
        .withFieldRenamed(_._createdBy, _.createdBy)
        .withFieldRenamed(_._updatedAt, _.updatedAt)
        .withFieldRenamed(_._updatedBy, _.updatedBy)
        .withFieldConst(_._type, "alert")
        .withFieldComputed(_.tags, _.tags.toSet)
        .withFieldComputed(_.`case`, _.caseId.map(_.toString))
        .withFieldComputed(
          _.status,
          alert =>
            (alert.caseId, alert.read) match {
              case (None, true)  => "Ignored"
              case (None, false) => "New"
              case (_, true)     => "Imported"
              case (_, false)    => "Updated"
            }
        )
        .withFieldConst(_.artifacts, richAlertWithObservables._2.map(_.toValue))
        .withFieldConst(_.similarCases, Nil)
        .enableMethodAccessors
        .transform
    )

  implicit class InputAlertOps(inputAlert: InputAlert) {

    def toAlert: Alert =
      inputAlert
        .into[Alert]
        .withFieldComputed(_.severity, _.severity.getOrElse(2))
        .withFieldComputed(_.tlp, _.tlp.getOrElse(2))
        .withFieldComputed(_.pap, _.pap.getOrElse(2))
        .withFieldComputed(_.date, _.date.getOrElse(new Date))
        .withFieldConst(_.read, false)
        .withFieldConst(_.lastSyncDate, new Date)
        .withFieldConst(_.follow, true)
        .withFieldConst(_.tags, inputAlert.tags.toSeq)
        .withFieldConst(_.caseId, EntityId.empty)
        .transform
  }

  implicit val attachmentOutput: Renderer.Aux[Attachment with Entity, OutputAttachment] = Renderer.toJson[Attachment with Entity, OutputAttachment](
    _.asInstanceOf[Attachment]
      .into[OutputAttachment]
      .withFieldComputed(_.hashes, _.hashes.map(_.toString).sortBy(_.length)(Ordering.Int.reverse))
      .withFieldComputed(_.id, _.attachmentId)
      .transform
  )

  implicit val auditOutput: Renderer.Aux[RichAudit, OutputAudit] = Renderer.toJson[RichAudit, OutputAudit](
    _.into[OutputAudit]
      .withFieldComputed(_.operation, a => actionToOperation(a.action))
      .withFieldComputed(_.id, _._id.toString)
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.createdAt, _._createdAt)
      .withFieldComputed(_.createdBy, _._createdBy)
      .withFieldConst(_._type, "audit")
      .withFieldComputed(_.`object`, _.`object`.map(OutputEntity.apply)) //objectToJson))
      .withFieldConst(_.base, true)
      .withFieldComputed(_.details, a => Json.parse(a.details.getOrElse("{}")).as[JsObject])
      .withFieldComputed(_.objectId, a => a.objectId.getOrElse(a.context._id).toString)
      .withFieldComputed(_.objectType, a => fromObjectType(a.objectType.getOrElse(a.context._label)))
      .withFieldComputed(_.rootId, _.context._id.toString)
      .withFieldComputed(_.startDate, _._createdAt)
      .withFieldComputed(
        _.summary,
        a => Map(fromObjectType(a.objectType.getOrElse(a.context._label)) -> Map(actionToOperation(a.action) -> 1))
      )
      .transform
  )

  implicit val caseOutput: Renderer.Aux[RichCase, OutputCase] = Renderer.toJson[RichCase, OutputCase](
    _.into[OutputCase]
      .withFieldComputed(
        _.customFields,
        rc => JsObject(rc.customFields.map(cf => cf.name -> Json.obj(cf.typeName -> cf.toJson, "order" -> cf.order)))
      )
      .withFieldComputed(_.status, _.status.toString)
      .withFieldConst(_._type, "case")
      .withFieldComputed(_.id, _._id.toString)
      .withFieldComputed(_._id, _._id.toString)
      .withFieldRenamed(_.number, _.caseId)
      .withFieldComputed(_.owner, _.assignee)
      .withFieldRenamed(_._updatedAt, _.updatedAt)
      .withFieldRenamed(_._updatedBy, _.updatedBy)
      .withFieldRenamed(_._createdAt, _.createdAt)
      .withFieldRenamed(_._createdBy, _.createdBy)
      .withFieldComputed(_.tags, _.tags.toSet)
      .withFieldConst(_.stats, JsObject.empty)
      .withFieldComputed(_.permissions, _.userPermissions.asInstanceOf[Set[String]]) // Permission is String
      .enableMethodAccessors
      .transform
  )

  implicit class InputCaseOps(inputCase: InputCase) {

    def toCase(implicit authContext: AuthContext): Case =
      inputCase
        .into[Case]
        .withFieldComputed(_.severity, _.severity.getOrElse(2))
        .withFieldComputed(_.startDate, _.startDate.getOrElse(new Date))
        .withFieldComputed(_.flag, _.flag.getOrElse(false))
        .withFieldComputed(_.tlp, _.tlp.getOrElse(2))
        .withFieldComputed(_.pap, _.pap.getOrElse(2))
        .withFieldConst(_.status, CaseStatus.Open)
        .withFieldComputed(_.assignee, c => Some(c.user.getOrElse(authContext.userId)))
        .withFieldComputed(_.tags, _.tags.toSeq)
        .transform

    def withCaseTemplate(caseTemplate: RichCaseTemplate): InputCase =
      InputCase(
        title = caseTemplate.titlePrefix.fold("")(_.replaceAll("(?m)\\s+$", "") + " ") + inputCase.title,
        description = inputCase.description,
        severity = inputCase.severity orElse caseTemplate.severity,
        startDate = inputCase.startDate,
        endDate = inputCase.endDate,
        tags = inputCase.tags,
        flag = inputCase.flag orElse Some(caseTemplate.flag),
        tlp = inputCase.tlp orElse caseTemplate.tlp,
        pap = inputCase.pap orElse caseTemplate.pap,
        status = inputCase.status,
        summary = inputCase.summary orElse caseTemplate.summary,
        user = inputCase.user,
        customFields = inputCase.customFields
      )
  }

  implicit val caseWithStatsOutput: Renderer[(RichCase, JsObject)] =
    Renderer.toJson[(RichCase, JsObject), OutputCase](richCaseWithStats =>
      richCaseWithStats
        ._1
        .into[OutputCase]
        .withFieldComputed(_.customFields, rc => JsObject(rc.customFields.map(cf => cf.name -> Json.obj(cf.typeName -> cf.toJson))))
        .withFieldComputed(_.status, _.status.toString)
        .withFieldConst(_._type, "case")
        .withFieldComputed(_.id, _._id.toString)
        .withFieldComputed(_._id, _._id.toString)
        .withFieldRenamed(_.number, _.caseId)
        .withFieldComputed(_.owner, _.assignee)
        .withFieldRenamed(_._updatedAt, _.updatedAt)
        .withFieldRenamed(_._updatedBy, _.updatedBy)
        .withFieldRenamed(_._createdAt, _.createdAt)
        .withFieldRenamed(_._createdBy, _.createdBy)
        .withFieldComputed(_.tags, _.tags.toSet)
        .withFieldConst(_.stats, richCaseWithStats._2)
        .withFieldComputed(_.permissions, _.userPermissions.asInstanceOf[Set[String]])
        .enableMethodAccessors
        .transform
    )

  implicit class InputCaseTemplateOps(inputCaseTemplate: InputCaseTemplate) {

    def toCaseTemplate: CaseTemplate =
      inputCaseTemplate
        .into[CaseTemplate]
        .withFieldComputed(_.displayName, _.displayName.getOrElse(""))
        .withFieldComputed(_.flag, _.flag.getOrElse(false))
        .transform
  }

  implicit val caseTemplateOutput: Renderer.Aux[RichCaseTemplate, OutputCaseTemplate] = Renderer.toJson[RichCaseTemplate, OutputCaseTemplate](
    _.into[OutputCaseTemplate]
      .withFieldComputed(
        _.customFields,
        rc => JsObject(rc.customFields.map(cf => cf.name -> Json.obj(cf.typeName -> cf.toJson, "order" -> cf.order)))
      )
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.id, _._id.toString)
      .withFieldRenamed(_._updatedAt, _.updatedAt)
      .withFieldRenamed(_._updatedBy, _.updatedBy)
      .withFieldRenamed(_._createdAt, _.createdAt)
      .withFieldRenamed(_._createdBy, _.createdBy)
      .withFieldConst(_.status, "Ok")
      .withFieldConst(_._type, "caseTemplate")
      .withFieldComputed(_.tags, _.tags.toSet)
      .withFieldComputed(_.tasks, _.tasks.map(_.toValue))
      .withFieldConst(_.metrics, JsObject.empty)
      .enableMethodAccessors
      .transform
  )

  implicit val richCustomFieldOutput: Renderer.Aux[RichCustomField, OutputCustomFieldValue] =
    Renderer.toJson[RichCustomField, OutputCustomFieldValue](
      _.into[OutputCustomFieldValue]
        .withFieldComputed(
          _.value,
          _.value.map {
            case d: Date => d.getTime.toString
            case other   => other.toString
          }
        )
        .withFieldComputed(_.tpe, _.typeName)
        .enableMethodAccessors
        .transform
    )

  implicit class InputCustomFieldOps(inputCustomField: InputCustomField) {

    def toCustomField: CustomField =
      inputCustomField
        .into[CustomField]
        .withFieldComputed(_.`type`, icf => CustomFieldType.withName(icf.`type`))
        .withFieldComputed(_.mandatory, _.mandatory.getOrElse(false))
        .withFieldComputed(_.name, _.reference)
        .withFieldComputed(_.displayName, _.name)
        .transform
  }

  implicit val customFieldOutput: Renderer.Aux[CustomField with Entity, OutputCustomField] =
    Renderer.toJson[CustomField with Entity, OutputCustomField](customField =>
      customField
        .asInstanceOf[CustomField]
        .into[OutputCustomField]
        .withFieldComputed(_.`type`, _.`type`.toString)
        .withFieldComputed(_.reference, _.name)
        .withFieldComputed(_.name, _.displayName)
        .withFieldConst(_.id, customField._id.toString)
        .transform
    )

  implicit val dashboardOutput: Renderer.Aux[RichDashboard, OutputDashboard] = Renderer.toJson[RichDashboard, OutputDashboard](dashboard =>
    dashboard
      .into[OutputDashboard]
      .withFieldConst(_.id, dashboard._id.toString)
      .withFieldConst(_._id, dashboard._id.toString)
      .withFieldComputed(_.status, d => if (d.organisationShares.nonEmpty) "Shared" else "Private")
      .withFieldConst(_._type, "dashboard")
      .withFieldConst(_.updatedAt, dashboard._updatedAt)
      .withFieldConst(_.updatedBy, dashboard._updatedBy)
      .withFieldConst(_.createdAt, dashboard._createdAt)
      .withFieldConst(_.createdBy, dashboard._createdBy)
      .withFieldComputed(_.definition, _.definition.toString)
      .enableMethodAccessors
      .transform
  )

  implicit class InputDashboardOps(inputDashboard: InputDashboard) {

    def toDashboard: Dashboard =
      inputDashboard
        .into[Dashboard]
        .withFieldComputed(_.definition, d => Json.parse(d.definition).as[JsObject])
        .transform
  }

  implicit val logOutput: Renderer.Aux[RichLog, OutputLog] = Renderer.toJson[RichLog, OutputLog](richLog =>
    richLog
      .into[OutputLog]
      .withFieldConst(_._type, "case_task_log")
      .withFieldComputed(_.id, _._id.toString)
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.updatedAt, _._updatedAt)
      .withFieldComputed(_.updatedBy, _._updatedBy)
      .withFieldComputed(_.createdAt, _._createdAt)
      .withFieldComputed(_.createdBy, _._createdBy)
      .withFieldComputed(_.message, _.message)
      .withFieldComputed(_.startDate, _._createdAt)
      .withFieldComputed(_.owner, _._createdBy)
      .withFieldConst(_.status, "Ok")
      .withFieldComputed(_.attachment, _.attachments.headOption.map(_.toValue))
      .withFieldConst(_.case_task, None)
      .transform
  )

  implicit val logOutputWithParent: Renderer.Aux[(RichLog, (RichTask, Option[RichCase])), OutputLog] =
    Renderer.toJson[(RichLog, (RichTask, Option[RichCase])), OutputLog] {
      case (richLog, richTask) =>
        richLog
          .into[OutputLog]
          .withFieldConst(_._type, "case_task_log")
          .withFieldComputed(_.id, _._id.toString)
          .withFieldComputed(_._id, _._id.toString)
          .withFieldComputed(_.updatedAt, _._updatedAt)
          .withFieldComputed(_.updatedBy, _._updatedBy)
          .withFieldComputed(_.createdAt, _._createdAt)
          .withFieldComputed(_.createdBy, _._createdBy)
          .withFieldComputed(_.message, _.message)
          .withFieldComputed(_.startDate, _._createdAt)
          .withFieldComputed(_.owner, _._createdBy)
          .withFieldConst(_.status, "Ok")
          .withFieldComputed(_.attachment, _.attachments.headOption.map(_.toValue))
          .withFieldConst(_.case_task, Some(richTask.toValue))
          .transform
    }

  implicit class InputLogOps(inputLog: InputLog) {

    def toLog: Log =
      inputLog
        .into[Log]
        .withFieldConst(_.date, new Date)
        .transform
  }

  implicit class InputObservableOps(inputObservable: InputObservable) {

    def toObservable: Observable =
      inputObservable
        .into[Observable]
        .withFieldComputed(_.tlp, _.tlp.getOrElse(2))
        .withFieldComputed(_.ioc, _.ioc.getOrElse(false))
        .withFieldComputed(_.sighted, _.sighted.getOrElse(false))
        .withFieldConst(_.data, None)
        .withFieldComputed(_.tags, _.tags.toSeq)
        .transform
  }

  implicit val reportTagWrites: Writes[ReportTag] = Writes[ReportTag] { tag =>
    Json.obj("level" -> tag.level.toString, "namespace" -> tag.namespace, "predicate" -> tag.predicate, "value" -> tag.value)
  }

  implicit val observableOutput: Renderer.Aux[RichObservable, OutputObservable] = Renderer.toJson[RichObservable, OutputObservable](
    _.into[OutputObservable]
      .withFieldConst(_._type, "case_artifact")
      .withFieldComputed(_.id, _.observable._id.toString)
      .withFieldComputed(_._id, _.observable._id.toString)
      .withFieldComputed(_.updatedAt, _.observable._updatedAt)
      .withFieldComputed(_.updatedBy, _.observable._updatedBy)
      .withFieldComputed(_.createdAt, _.observable._createdAt)
      .withFieldComputed(_.createdBy, _.observable._createdBy)
      .withFieldComputed(_.startDate, _.observable._createdAt)
      .withFieldComputed(_.attachment, _.attachment.map(_.toValue))
      .withFieldComputed(
        _.reports,
        a =>
          JsObject(
            a.reportTags
              .groupBy(_.origin)
              .map {
                case (origin, tags) =>
                  origin -> Json.obj(
                    "taxonomies" -> tags.map { t =>
                      Json.obj("level" -> t.level.toString, "namespace" -> t.namespace, "predicate" -> t.predicate, "value" -> t.value)
                    }
                  )
              }
          )
      )
      .withFieldConst(_.stats, JsObject.empty)
      .withFieldConst(_.`case`, None)
      .withFieldConst(_.alert, None)
      .enableMethodAccessors
      .transform
  )

  implicit val observableWithExtraOutput: Renderer.Aux[(RichObservable, JsObject, Option[Either[RichCase, RichAlert]]), OutputObservable] =
    Renderer.toJson[(RichObservable, JsObject, Option[Either[RichCase, RichAlert]]), OutputObservable] {
      case (richObservable, stats, caseOrAlert) =>
        richObservable
          .into[OutputObservable]
          .withFieldConst(_._type, "case_artifact")
          .withFieldComputed(_.id, _.observable._id.toString)
          .withFieldComputed(_._id, _.observable._id.toString)
          .withFieldComputed(_.updatedAt, _.observable._updatedAt)
          .withFieldComputed(_.updatedBy, _.observable._updatedBy)
          .withFieldComputed(_.createdAt, _.observable._createdAt)
          .withFieldComputed(_.createdBy, _.observable._createdBy)
          .withFieldComputed(_.startDate, _.observable._createdAt)
          .withFieldComputed(_.attachment, _.attachment.map(_.toValue))
          .withFieldComputed(
            _.reports,
            a =>
              JsObject(a.reportTags.groupBy(_.origin).map {
                case (origin, tags) =>
                  origin -> Json.obj(
                    "taxonomies" -> tags
                      .map(t => Json.obj("level" -> t.level.toString, "namespace" -> t.namespace, "predicate" -> t.predicate, "value" -> t.value))
                  )
              })
          )
          .withFieldConst(_.stats, stats)
          .withFieldConst(_.`case`, caseOrAlert.flatMap(_.swap.map(_.toValue).toOption))
          .withFieldConst(_.alert, caseOrAlert.flatMap(_.map(_.toValue).toOption))
          .enableMethodAccessors
          .transform
    }

  implicit val observableWithStatsOutput: Renderer.Aux[(RichObservable, JsObject), OutputObservable] =
    Renderer.toJson[(RichObservable, JsObject), OutputObservable] {
      case (richObservable, stats) =>
        richObservable
          .into[OutputObservable]
          .withFieldConst(_._type, "case_artifact")
          .withFieldComputed(_.id, _.observable._id.toString)
          .withFieldComputed(_._id, _.observable._id.toString)
          .withFieldComputed(_.updatedAt, _.observable._updatedAt)
          .withFieldComputed(_.updatedBy, _.observable._updatedBy)
          .withFieldComputed(_.createdAt, _.observable._createdAt)
          .withFieldComputed(_.createdBy, _.observable._createdBy)
          .withFieldComputed(_.startDate, _.observable._createdAt)
          .withFieldComputed(_.attachment, _.attachment.map(_.toValue))
          .withFieldComputed(
            _.reports,
            a =>
              JsObject(a.reportTags.groupBy(_.origin).map {
                case (origin, tags) =>
                  origin -> Json.obj(
                    "taxonomies" -> tags
                      .map(t => Json.obj("level" -> t.level.toString, "namespace" -> t.namespace, "predicate" -> t.predicate, "value" -> t.value))
                  )
              })
          )
          .withFieldConst(_.stats, stats)
          .withFieldConst(_.`case`, None)
          .withFieldConst(_.alert, None)
          .enableMethodAccessors
          .transform
    }

  implicit class InputOrganisationOps(inputOrganisation: InputOrganisation) {

    def toOrganisation: Organisation =
      inputOrganisation
        .into[Organisation]
        .transform
  }

  implicit val organisationOutput: Renderer.Aux[Organisation with Entity, OutputOrganisation] =
    Renderer.toJson[Organisation with Entity, OutputOrganisation](organisation =>
      OutputOrganisation(
        organisation.name,
        organisation.description,
        organisation._id.toString,
        organisation._id.toString,
        organisation._createdAt,
        organisation._createdBy,
        organisation._updatedAt,
        organisation._updatedBy,
        "organisation",
        Nil
      )
    )

  implicit val richOrganisationOutput: Renderer.Aux[RichOrganisation, OutputOrganisation] =
    Renderer.toJson[RichOrganisation, OutputOrganisation](organisation =>
      OutputOrganisation(
        organisation.name,
        organisation.description,
        organisation._id.toString,
        organisation._id.toString,
        organisation._createdAt,
        organisation._createdBy,
        organisation._updatedAt,
        organisation._updatedBy,
        "organisation",
        organisation.links.map(_.name)
      )
    )

  implicit val profileOutput: Renderer.Aux[Profile with Entity, OutputProfile] = Renderer.toJson[Profile with Entity, OutputProfile](profile =>
    profile
      .asInstanceOf[Profile]
      .into[OutputProfile]
      .withFieldConst(_._id, profile._id.toString)
      .withFieldConst(_.id, profile._id.toString)
      .withFieldConst(_.updatedAt, profile._updatedAt)
      .withFieldConst(_.updatedBy, profile._updatedBy)
      .withFieldConst(_.createdAt, profile._createdAt)
      .withFieldConst(_.createdBy, profile._createdBy)
      .withFieldConst(_._type, "profile")
      .withFieldComputed(_.permissions, _.permissions.asInstanceOf[Set[String]].toSeq.sorted) // Permission is String
      .withFieldComputed(_.editable, _.isEditable)
      .withFieldComputed(_.isAdmin, p => Permissions.containsRestricted(p.permissions))
      .transform
  )

  implicit class InputProfileOps(inputProfile: InputProfile) {

    def toProfile: Profile =
      inputProfile
        .into[Profile]
        .withFieldComputed(_.permissions, _.permissions.map(Permission.apply))
        .transform
  }

  implicit val shareOutput: Renderer.Aux[RichShare, OutputShare] = Renderer.toJson[RichShare, OutputShare](
    _.into[OutputShare]
      .withFieldComputed(_._id, _.share._id.toString)
      .withFieldComputed(_.caseId, _.caseId.toString)
      .withFieldComputed(_.createdAt, _.share._createdAt)
      .withFieldComputed(_.createdBy, _.share._createdBy)
      .enableMethodAccessors
      .transform
  )

  implicit val tagOutput: Renderer.Aux[Tag with Entity, OutputTag] = Renderer.toJson[Tag with Entity, OutputTag](
    _.asInstanceOf[Tag]
      .into[OutputTag]
      .withFieldComputed(_.namespace, t => if (t.isFreeTag) "_freetags_" else t.namespace)
      .transform
  )

  implicit class InputTaskOps(inputTask: InputTask) {

    def toTask: Task =
      inputTask
        .into[Task]
        .withFieldComputed(_.status, _.status.fold(TaskStatus.Waiting)(TaskStatus.withName))
        .withFieldComputed(_.order, _.order.getOrElse(0))
        .withFieldComputed(_.flag, _.flag.getOrElse(false))
        .withFieldComputed(_.group, _.group.getOrElse("default"))
        .withFieldRenamed(_.owner, _.assignee)
        .transform
  }

  implicit val taskOutput: Renderer.Aux[RichTask, OutputTask] = Renderer.toJson[RichTask, OutputTask](
    _.into[OutputTask]
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.id, _._id.toString)
      .withFieldComputed(_.status, _.status.toString)
      .withFieldConst(_._type, "case_task")
      .withFieldConst(_.`case`, None)
      .withFieldComputed(_.owner, _.assignee)
      .withFieldRenamed(_._updatedAt, _.updatedAt)
      .withFieldRenamed(_._updatedBy, _.updatedBy)
      .withFieldRenamed(_._createdAt, _.createdAt)
      .withFieldRenamed(_._createdBy, _.createdBy)
      .enableMethodAccessors
      .transform
  )

  implicit val taskWithParentOutput: Renderer.Aux[(RichTask, Option[RichCase]), OutputTask] =
    Renderer.toJson[(RichTask, Option[RichCase]), OutputTask] {
      case (richTask, richCase) =>
        richTask
          .into[OutputTask]
          .withFieldComputed(_._id, _._id.toString)
          .withFieldComputed(_.id, _._id.toString)
          .withFieldComputed(_.status, _.status.toString)
          .withFieldConst(_._type, "case_task")
          .withFieldConst(_.`case`, richCase.map(_.toValue))
          .withFieldComputed(_.owner, _.assignee)
          .withFieldRenamed(_._updatedAt, _.updatedAt)
          .withFieldRenamed(_._updatedBy, _.updatedBy)
          .withFieldRenamed(_._createdAt, _.createdAt)
          .withFieldRenamed(_._createdBy, _.createdBy)
          .enableMethodAccessors
          .transform
    }

  implicit class InputUserOps(inputUser: InputUser) {

    def toUser: User =
      inputUser
        .into[User]
        .withFieldComputed(_.id, _.login)
        .withFieldConst(_.apikey, None)
        .withFieldConst(_.password, None)
        .withFieldConst(_.locked, false)
        .withFieldConst(_.totpSecret, None)
        .withFieldConst(_.failedAttempts, None)
        .withFieldConst(_.lastFailed, None)
        //    .withFieldRenamed(_.roles, _.permissions)
        .transform
  }

  implicit val userOutput: Renderer.Aux[RichUser, OutputUser] = Renderer.toJson[RichUser, OutputUser](
    _.into[OutputUser]
      .withFieldComputed(_.roles, u => permissions2Roles(u.permissions))
      .withFieldRenamed(_.login, _.id)
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.hasKey, _.apikey.isDefined)
      .withFieldComputed(_.status, u => if (u.locked) "Locked" else "Ok")
      .withFieldRenamed(_._createdBy, _.createdBy)
      .withFieldRenamed(_._createdAt, _.createdAt)
      .withFieldRenamed(_._updatedBy, _.updatedBy)
      .withFieldRenamed(_._updatedAt, _.updatedAt)
      .withFieldConst(_._type, "user")
      .enableMethodAccessors
      .transform
  )

  implicit val simpleUserOutput: Renderer.Aux[User with Entity, OutputUser] = Renderer.toJson[User with Entity, OutputUser](u =>
    u.asInstanceOf[User]
      .into[OutputUser]
      .withFieldConst(_._id, u._id.toString)
      .withFieldConst(_.id, u._id.toString)
      .withFieldConst(_.organisation, "")
      .withFieldConst(_.roles, Set[String]())
      .withFieldRenamed(_.login, _.id)
      .withFieldComputed(_.hasKey, _.apikey.isDefined)
      .withFieldComputed(_.status, u => if (u.locked) "Locked" else "Ok")
      .withFieldConst(_.createdBy, u._createdBy)
      .withFieldConst(_.createdAt, u._createdAt)
      .withFieldConst(_.updatedBy, u._updatedBy)
      .withFieldConst(_.updatedAt, u._updatedAt)
      .withFieldConst(_._type, "user")
      .transform
  )

  implicit val pageOutput: Renderer.Aux[Page with Entity, OutputPage] = Renderer.toJson[Page with Entity, OutputPage](page =>
    page
      .asInstanceOf[Page]
      .into[OutputPage]
      .withFieldConst(_._id, page._id.toString)
      .withFieldConst(_.id, page._id.toString)
      .withFieldConst(_.createdBy, page._createdBy)
      .withFieldConst(_.createdAt, page._createdAt)
      .withFieldConst(_.updatedBy, page._updatedBy)
      .withFieldConst(_.updatedAt, page._updatedAt)
      .withFieldConst(_._type, "page")
      .withFieldComputed(_.content, _.content)
      .withFieldComputed(_.title, _.title)
      .transform
  )

  implicit val permissionOutput: Renderer.Aux[PermissionDesc, OutputPermission] =
    Renderer.toJson[PermissionDesc, OutputPermission](_.into[OutputPermission].transform)

  implicit val observableTypeOutput: Renderer.Aux[ObservableType with Entity, OutputObservableType] =
    Renderer.toJson[ObservableType with Entity, OutputObservableType](outputObservableType =>
      outputObservableType
        .asInstanceOf[ObservableType]
        .into[OutputObservableType]
        .withFieldConst(_._id, outputObservableType._id.toString)
        .withFieldConst(_.id, outputObservableType._id.toString)
        .withFieldConst(_.createdBy, outputObservableType._createdBy)
        .withFieldConst(_.createdAt, outputObservableType._createdAt)
        .withFieldConst(_.updatedBy, outputObservableType._updatedBy)
        .withFieldConst(_.updatedAt, outputObservableType._updatedAt)
        .withFieldConst(_._type, "observableType")
        .transform
    )

  implicit class InputObservableTypeOps(inputObservableType: InputObservableType) {

    def toObservableType: ObservableType =
      inputObservableType
        .into[ObservableType]
        .withFieldComputed(_.isAttachment, _.isAttachment.getOrElse(false))
        .transform
  }

  implicit class InputPageOps(inputPage: InputPage) {

    def toPage: Page =
      inputPage
        .into[Page]
        .withFieldComputed(_.slug, _.title.replaceAll("[^\\p{Alnum}]+", "_"))
        .withFieldComputed(_.order, _.order.getOrElse(0))
        .transform
  }

  def toObjectType(t: String): String =
    t match {
      case "case"              => "Case"
      case "case_artifact"     => "Observable"
      case "case_task"         => "Task"
      case "case_task_log"     => "Log"
      case "alert"             => "Alert"
      case "case_artifact_job" => "Job"
      case "action"            => "Action"
    }

  def permissions2Roles(permissions: Set[Permission]): Set[String] = {
    val roles =
      if ((permissions & adminPermissions).nonEmpty) Set("admin", "write", "read", "alert")
      else if ((permissions - Permissions.manageAlert).nonEmpty) Set("write", "read")
      else Set("read")
    if (permissions.contains(Permissions.manageAlert)) roles + "alert"
    else roles
  }

}

```

`thehive/app/org/thp/thehive/controllers/v0/CustomFieldCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputCustomField
import org.thp.thehive.models.{CustomField, Permissions}
import org.thp.thehive.services.CustomFieldSrv
import play.api.libs.json.{JsNumber, JsObject}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}
import scala.util.Success

@Singleton
class CustomFieldCtrl @Inject() (
    override val entrypoint: Entrypoint,
    override val db: Database,
    customFieldSrv: CustomFieldSrv,
    override val publicData: PublicCustomField,
    @Named("v0") override val queryExecutor: QueryExecutor
) extends QueryCtrl
    with AuditRenderer {
  def create: Action[AnyContent] =
    entrypoint("create custom field")
      .extract("customField", FieldsParser[InputCustomField])
      .authPermittedTransaction(db, Permissions.manageCustomField) { implicit request => implicit graph =>
        val customField: InputCustomField = request.body("customField")
        customFieldSrv
          .create(customField.toCustomField)
          .map(createdCustomField => Results.Created(createdCustomField.toJson))
      }

  def list: Action[AnyContent] =
    entrypoint("list custom fields")
      .authRoTransaction(db) { _ => implicit graph =>
        val customFields = customFieldSrv
          .startTraversal
          .toSeq
        Success(Results.Ok(customFields.toJson))
      }

  def get(id: String): Action[AnyContent] =
    entrypoint("get custom field")
      .authRoTransaction(db) { _ => implicit graph =>
        customFieldSrv.get(EntityIdOrName(id)).getOrFail("CustomField").map(cf => Results.Ok(cf.toJson))
      }

  def delete(id: String): Action[AnyContent] =
    entrypoint("delete custom field")
      .extract("force", FieldsParser.boolean.optional.on("force"))
      .authPermittedTransaction(db, Permissions.manageCustomField) { implicit request => implicit graph =>
        val force = request.body("force").getOrElse(false)
        for {
          cf <- customFieldSrv.getOrFail(EntityIdOrName(id))
          _  <- customFieldSrv.delete(cf, force)
        } yield Results.NoContent
      }

  def update(id: String): Action[AnyContent] =
    entrypoint("update custom field")
      .extract("customField", FieldsParser.update("customField", publicData.publicProperties))
      .authPermittedTransaction(db, Permissions.manageCustomField) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("customField")

        for {
          updated <- customFieldSrv.update(customFieldSrv.get(EntityIdOrName(id)), propertyUpdaters)
          cf      <- updated._1.getOrFail("CustomField")
        } yield Results.Ok(cf.toJson)
      }

  def useCount(id: String): Action[AnyContent] =
    entrypoint("get use count of custom field")
      .authPermittedTransaction(db, Permissions.manageCustomField) { _ => implicit graph =>
        customFieldSrv.getOrFail(EntityIdOrName(id)).map(customFieldSrv.useCount).map { countMap =>
          val total = countMap.valuesIterator.sum
          val countStats = JsObject(countMap.map {
            case (k, v) => fromObjectType(k) -> JsNumber(v)
          })
          Results.Ok(countStats + ("total" -> JsNumber(total)))
        }
      }
}

@Singleton
class PublicCustomField @Inject() (customFieldSrv: CustomFieldSrv) extends PublicData {
  override val entityName: String  = "CustomField"
  override val initialQuery: Query = Query.init[Traversal.V[CustomField]]("listCustomField", (graph, _) => customFieldSrv.startTraversal(graph))
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[CustomField], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, _, _), customFieldSteps, _) =>
          customFieldSteps.page(from, to, withTotal = true, limitedCountThreshold)
      }
    )
  override val outputQuery: Query = Query.output[CustomField with Entity]
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[CustomField]](
    "getCustomField",
    (idOrName, graph, _) => customFieldSrv.get(idOrName)(graph)
  )
  override val publicProperties: PublicProperties =
    PublicPropertyListBuilder[CustomField]
      .property("name", UMapping.string)(_.rename("displayName").updatable)
      .property("description", UMapping.string)(_.field.updatable)
      .property("reference", UMapping.string)(_.rename("name").readonly)
      .property("mandatory", UMapping.boolean)(_.field.updatable)
      .property("type", UMapping.string)(_.field.updatable)
      .property("options", UMapping.json.sequence)(_.field.updatable)
      .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/DashboardCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.controllers.{Entrypoint, FString, FieldsParser}
import org.thp.scalligraph.models.{Database, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.scalligraph.{EntityIdOrName, InvalidFormatAttributeError}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputDashboard
import org.thp.thehive.models.{Dashboard, RichDashboard}
import org.thp.thehive.services.DashboardOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services.{DashboardSrv, OrganisationSrv, UserSrv}
import play.api.libs.json.Json
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}
import scala.util.{Failure, Success}

@Singleton
class DashboardCtrl @Inject() (
    override val entrypoint: Entrypoint,
    dashboardSrv: DashboardSrv,
    implicit val db: Database,
    override val publicData: PublicDashboard,
    @Named("v0") override val queryExecutor: QueryExecutor
) extends QueryCtrl {
  def create: Action[AnyContent] =
    entrypoint("create dashboard")
      .extract("dashboard", FieldsParser[InputDashboard])
      .authTransaction(db) { implicit request => implicit graph =>
        val dashboard: InputDashboard = request.body("dashboard")
        dashboardSrv
          .create(dashboard.toDashboard)
          .flatMap {
            case richDashboard if dashboard.status == "Shared" =>
              dashboardSrv
                .share(richDashboard.dashboard, request.organisation, writable = true)
                .flatMap(_ => dashboardSrv.get(richDashboard.dashboard).richDashboard.getOrFail("Dashboard"))
            case richDashboard => Success(richDashboard)
          }
          .map(richDashboard => Results.Created(richDashboard.toJson))
      }

  def get(dashboardId: String): Action[AnyContent] =
    entrypoint("get dashboard")
      .authRoTransaction(db) { implicit request => implicit graph =>
        dashboardSrv
          .get(EntityIdOrName(dashboardId))
          .visible
          .richDashboard
          .getOrFail("Dashboard")
          .map(dashboard => Results.Ok(dashboard.toJson))
      }

  def update(dashboardId: String): Action[AnyContent] =
    entrypoint("update dashboard")
      .extract("dashboard", FieldsParser.update("dashboard", publicData.publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("dashboard")
        dashboardSrv
          .update(_.get(EntityIdOrName(dashboardId)).canUpdate, propertyUpdaters) // TODO check permission
          .flatMap { case (dashboardSteps, _) => dashboardSteps.richDashboard.getOrFail("Dashboard") }
          .map(dashboard => Results.Ok(dashboard.toJson))
      }

  def delete(dashboardId: String): Action[AnyContent] =
    entrypoint("delete dashboard")
      .authTransaction(db) { implicit request => implicit graph =>
        dashboardSrv
          .get(EntityIdOrName(dashboardId))
          .canUpdate
          .getOrFail("Dashboard")
          .map { dashboard =>
            dashboardSrv.remove(dashboard)
            Results.NoContent
          }
      }
}

@Singleton
class PublicDashboard @Inject() (
    dashboardSrv: DashboardSrv,
    organisationSrv: OrganisationSrv,
    userSrv: UserSrv
) extends PublicData {
  val entityName: String = "dashboard"

  val initialQuery: Query =
    Query.init[Traversal.V[Dashboard]](
      "listDashboard",
      (graph, authContext) =>
        graph
          .union(
            organisationSrv.filterTraversal(_).get(authContext.organisation).dashboards,
            userSrv.filterTraversal(_).getByName(authContext.userId).dashboards
          )
          .dedup
    )

  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Dashboard]](
    "getDashboard",
    (idOrName, graph, authContext) => dashboardSrv.get(idOrName)(graph).visible(authContext)
  )

  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Dashboard], IteratorOutput](
      "page",
      (range, dashboardSteps, authContext) =>
        dashboardSteps.richPage(range.from, range.to, withTotal = true, limitedCountThreshold)(_.richDashboard(authContext))
    )
  override val outputQuery: Query = Query.outputWithContext[RichDashboard, Traversal.V[Dashboard]](_.richDashboard(_))
  val publicProperties: PublicProperties = PublicPropertyListBuilder[Dashboard]
    .property("title", UMapping.string)(_.field.updatable)
    .property("description", UMapping.string)(_.field.updatable)
    .property("definition", UMapping.string)(_.field.updatable)
    .property("status", UMapping.string)(
      _.select(_.choose(_.organisation, "Shared", "Private"))
        .custom {
          case (_, "Shared", vertex, graph, authContext) =>
            for {
              dashboard <- dashboardSrv.get(vertex)(graph).filter(_.user.current(authContext)).getOrFail("Dashboard")
              _         <- dashboardSrv.share(dashboard, authContext.organisation, writable = true)(graph, authContext)
            } yield Json.obj("status" -> "Shared")

          case (_, "Private", vertex, graph, authContext) =>
            for {
              d <- dashboardSrv.get(vertex)(graph).filter(_.user.current(authContext)).getOrFail("Dashboard")
              _ <- dashboardSrv.unshare(d, authContext.organisation)(graph, authContext)
            } yield Json.obj("status" -> "Private")

          case (_, "Deleted", vertex, graph, authContext) =>
            for {
              d <- dashboardSrv.get(vertex)(graph).filter(_.user.current(authContext)).getOrFail("Dashboard")
              _ <- dashboardSrv.remove(d)(graph, authContext)
            } yield Json.obj("status" -> "Deleted")

          case (_, status, _, _, _) =>
            Failure(InvalidFormatAttributeError("status", "String", Set("Shared", "Private", "Deleted"), FString(status)))
        }
    )
    .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/DescribeCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.controllers.Entrypoint
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.PublicProperty
import org.thp.scalligraph.services.config.ApplicationConfig.durationFormat
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.utils.Hash
import org.thp.scalligraph.{EntityId, NotFoundError}
import org.thp.thehive.services.CustomFieldSrv
import play.api.Logger
import play.api.cache.SyncCacheApi
import play.api.inject.Injector
import play.api.libs.json._
import play.api.mvc.{Action, AnyContent, Results}

import java.lang.{Boolean => JBoolean}
import java.util.Date
import javax.inject.{Inject, Singleton}
import scala.concurrent.duration.Duration
import scala.util.{Failure, Success, Try}

@Singleton
class DescribeCtrl @Inject() (
    cacheApi: SyncCacheApi,
    entrypoint: Entrypoint,
    alertCtrl: AlertCtrl,
    auditCtrl: AuditCtrl,
    caseCtrl: CaseCtrl,
    caseTemplateCtrl: CaseTemplateCtrl,
    customFieldCtrl: CustomFieldCtrl,
    dashboardCtrl: DashboardCtrl,
    logCtrl: LogCtrl,
    observableCtrl: ObservableCtrl,
    observableTypeCtrl: ObservableTypeCtrl,
    organisationCtrl: OrganisationCtrl,
//    pageCtrl: PageCtrl,
    profileCtrl: ProfileCtrl,
    taskCtrl: TaskCtrl,
    userCtrl: UserCtrl,
    customFieldSrv: CustomFieldSrv,
    injector: Injector,
    db: Database,
    applicationConfig: ApplicationConfig
) {

  case class PropertyDescription(name: String, `type`: String, values: Seq[JsValue] = Nil, labels: Seq[String] = Nil)
  val metadata = Seq(
    PropertyDescription("createdBy", "user"),
    PropertyDescription("createdAt", "date"),
    PropertyDescription("updatedBy", "user"),
    PropertyDescription("updatedAt", "date")
  )
  case class EntityDescription(label: String, path: String, attributes: Seq[PropertyDescription]) {
    def toJson: JsObject =
      Json.obj(
        "label"      -> label,
        "path"       -> path,
        "attributes" -> (attributes ++ metadata)
      )
  }

  lazy val logger: Logger = Logger(getClass)

  val cacheExpireConfig: ConfigItem[Duration, Duration] =
    applicationConfig.item[Duration]("describe.cache.expire", "Custom fields refresh in describe")
  def cacheExpire: Duration = cacheExpireConfig.get

  def describeCortexEntity(
      name: String,
      path: String,
      className: String,
      packageName: String = "org.thp.thehive.connector.cortex.controllers.v0"
  ): Option[EntityDescription] =
    Try(
      EntityDescription(
        name,
        path,
        injector
          .instanceOf(getClass.getClassLoader.loadClass(s"$packageName.$className"))
          .asInstanceOf[QueryCtrl]
          .publicData
          .publicProperties
          .list
          .flatMap(propertyToJson(name, _))
      )
    ).toOption

  def entityDescriptions: Seq[EntityDescription] =
    cacheApi.getOrElseUpdate("describe.v0", cacheExpire) {
      Seq(
        EntityDescription("case", "/case", caseCtrl.publicData.publicProperties.list.flatMap(propertyToJson("case", _))),
        EntityDescription("case_task", "/case/task", taskCtrl.publicData.publicProperties.list.flatMap(propertyToJson("case_task", _))),
        EntityDescription("alert", "/alert", alertCtrl.publicData.publicProperties.list.flatMap(propertyToJson("alert", _))),
        EntityDescription(
          "case_artifact",
          "/case/artifact",
          observableCtrl.publicData.publicProperties.list.flatMap(propertyToJson("case_artifact", _))
        ),
        EntityDescription("user", "/user", userCtrl.publicData.publicProperties.list.flatMap(propertyToJson("user", _))),
        EntityDescription("case_task_log", "/case/task/log", logCtrl.publicData.publicProperties.list.flatMap(propertyToJson("case_task_log", _))),
        EntityDescription("audit", "/audit", auditCtrl.publicData.publicProperties.list.flatMap(propertyToJson("audit", _))),
        EntityDescription(
          "caseTemplate",
          "/caseTemplate",
          caseTemplateCtrl.publicData.publicProperties.list.flatMap(propertyToJson("caseTemplate", _))
        ),
        EntityDescription("customField", "/customField", customFieldCtrl.publicData.publicProperties.list.flatMap(propertyToJson("customField", _))),
        EntityDescription(
          "observableType",
          "/observableType",
          observableTypeCtrl.publicData.publicProperties.list.flatMap(propertyToJson("observableType", _))
        ),
        EntityDescription(
          "organisation",
          "/organisation",
          organisationCtrl.publicData.publicProperties.list.flatMap(propertyToJson("organisation", _))
        ),
        EntityDescription("profile", "/profile", profileCtrl.publicData.publicProperties.list.flatMap(propertyToJson("profile", _))),
        EntityDescription("dashboard", "/dashboard", dashboardCtrl.publicData.publicProperties.list.flatMap(propertyToJson("dashboard", _)))
//        EntityDescription("page", "/page", pageCtrl.publicData.publicProperties.list.flatMap(propertyToJson("page", _)))
      ) ++ describeCortexEntity("case_artifact_job", "/connector/cortex/job", "JobCtrl") ++
        describeCortexEntity("action", "/connector/cortex/action", "ActionCtrl")
    }

  implicit val propertyDescriptionWrites: Writes[PropertyDescription] =
    Json.writes[PropertyDescription].transform((_: JsObject) + ("description" -> JsString("")))

  def customFields: Seq[PropertyDescription] = {
    def jsonToString(v: JsValue): String =
      v match {
        case JsString(s)  => s
        case JsBoolean(b) => b.toString
        case JsNumber(v)  => v.toString
        case other        => other.toString
      }
    db.roTransaction { implicit graph =>
      customFieldSrv
        .startTraversal
        .toSeq
        .map(cf => PropertyDescription(s"customFields.${cf.name}", cf.`type`.toString, cf.options, cf.options.map(jsonToString)))
    }
  }

  def customDescription(model: String, propertyName: String): Option[Seq[PropertyDescription]] =
    (model, propertyName) match {
      case (_, "owner") => Some(Seq(PropertyDescription("owner", "user")))
      case ("case", "status") =>
        Some(
          Seq(PropertyDescription("status", "enumeration", Seq(JsString("Open"), JsString("Resolved"), JsString("Deleted"), JsString("Duplicated"))))
        )
      //case ("observable", "status") =>
      //  Some(PropertyDescription("status", "enumeration", Seq(JsString("Ok"))))
      //case ("observable", "dataType") =>
      //  Some(PropertyDescription("status", "enumeration", Seq(JsString("sometesttype", "fqdn", "url", "regexp", "mail", "hash", "registry", "custom-type", "uri_path", "ip", "user-agent", "autonomous-system", "file", "mail_subject", "filename", "other", "domain"))))
      case ("alert", "status") =>
        Some(Seq(PropertyDescription("status", "enumeration", Seq(JsString("New"), JsString("Updated"), JsString("Ignored"), JsString("Imported")))))
      case ("case_task", "status") =>
        Some(
          Seq(
            PropertyDescription("status", "enumeration", Seq(JsString("Waiting"), JsString("InProgress"), JsString("Completed"), JsString("Cancel")))
          )
        )
      case ("case", "impactStatus") =>
        Some(Seq(PropertyDescription("impactStatus", "enumeration", Seq(JsString("NoImpact"), JsString("WithImpact"), JsString("NotApplicable")))))
      case ("case", "resolutionStatus") =>
        Some(
          Seq(
            PropertyDescription(
              "resolutionStatus",
              "enumeration",
              Seq(JsString("FalsePositive"), JsString("Duplicated"), JsString("Indeterminate"), JsString("TruePositive"), JsString("Other"))
            )
          )
        )
      case (_, "tlp") =>
        Some(
          Seq(PropertyDescription("tlp", "number", Seq(JsNumber(0), JsNumber(1), JsNumber(2), JsNumber(3)), Seq("white", "green", "amber", "red")))
        )
      case (_, "pap") =>
        Some(
          Seq(PropertyDescription("pap", "number", Seq(JsNumber(0), JsNumber(1), JsNumber(2), JsNumber(3)), Seq("white", "green", "amber", "red")))
        )
      case (_, "severity") =>
        Some(
          Seq(
            PropertyDescription(
              "severity",
              "number",
              Seq(JsNumber(1), JsNumber(2), JsNumber(3), JsNumber(4)),
              Seq("low", "medium", "high", "critical")
            )
          )
        )
      case (_, "createdBy")    => Some(Seq(PropertyDescription("createdBy", "user")))
      case (_, "updatedBy")    => Some(Seq(PropertyDescription("updatedBy", "user")))
      case (_, "customFields") => Some(customFields)
      case ("case_artifact_job" | "action", "status") =>
        Some(
          Seq(
            PropertyDescription(
              "status",
              "enumeration",
              Seq(JsString("InProgress"), JsString("Success"), JsString("Failure"), JsString("Waiting"), JsString("Deleted"))
            )
          )
        )
      case ("dashboard", "status") =>
        Some(Seq(PropertyDescription("status", "enumeration", Seq(JsString("Shared"), JsString("Private"), JsString("Deleted")))))
      case (_, "patternId") =>
        Some(Seq(PropertyDescription("patternId", "string", Nil)))
      case _ => None
    }

  def propertyToJson(model: String, prop: PublicProperty): Seq[PropertyDescription] =
    customDescription(model, prop.propertyName).getOrElse {
      prop.mapping.domainTypeClass match {
        case c if c == classOf[Boolean] || c == classOf[JBoolean] => Seq(PropertyDescription(prop.propertyName, "boolean"))
        case c if c == classOf[Date]                              => Seq(PropertyDescription(prop.propertyName, "date"))
        case c if c == classOf[Hash]                              => Seq(PropertyDescription(prop.propertyName, "string"))
        case c if classOf[Number].isAssignableFrom(c)             => Seq(PropertyDescription(prop.propertyName, "number"))
        case c if c == classOf[String]                            => Seq(PropertyDescription(prop.propertyName, "string"))
        case c if c == classOf[EntityId]                          => Seq(PropertyDescription(prop.propertyName, "string"))
        case c if c == classOf[JsValue]                           => Seq(PropertyDescription(prop.propertyName, "string"))
        case _ =>
          logger.warn(s"Unrecognized property $prop. Add a custom description")
          Seq(PropertyDescription(prop.propertyName, "unknown"))
      }
    }

  def describe(modelName: String): Action[AnyContent] =
    entrypoint("describe model")
      .auth { _ =>
        entityDescriptions
          .collectFirst {
            case desc if desc.label == modelName => Success(Results.Ok(desc.toJson))
          }
          .getOrElse(Failure(NotFoundError(s"Model $modelName not found")))
      }

  def describeAll: Action[AnyContent] =
    entrypoint("describe all models")
      .auth { _ =>
        val descriptors = entityDescriptions.map(desc => desc.label -> desc.toJson)
        Success(Results.Ok(JsObject(descriptors)))
      }
}

```

`thehive/app/org/thp/thehive/controllers/v0/ListCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.utils.Hasher
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputCustomField
import org.thp.thehive.models.ObservableType
import org.thp.thehive.services.CustomFieldOps._
import org.thp.thehive.services.CustomFieldSrv
import play.api.libs.json.{JsObject, JsString, Json}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success}

@Singleton
class ListCtrl @Inject() (
    entrypoint: Entrypoint,
    db: Database,
    customFieldSrv: CustomFieldSrv
) {

  def list: Action[AnyContent] =
    entrypoint("list")
      .auth { _ =>
        Success(Results.Ok(Json.arr("list_artifactDataType", "case_metrics", "ui_settings")))
      }

  def listItems(listName: String): Action[AnyContent] =
    entrypoint("list list items")
      .auth { _ =>
        val result = listName match {
          case "list_artifactDataType" =>
            val objectTypes = ObservableType.initialValues.toList.map { ot =>
              val id = Hasher("MD5").fromString(ot.name).head.toString // this Traversable.head can't fail
              id -> JsString(ot.name)
            }
            JsObject(objectTypes.toMap)
          case "case_metrics" => JsObject.empty
          case "ui_settings"  => JsObject.empty
          case "custom_fields" =>
            val cf = db
              .roTransaction { implicit grap =>
                customFieldSrv.startTraversal.toSeq
              }
              .map(cf => cf._id.toString -> cf.toJson)
            JsObject(cf)
          case _ => JsObject.empty
        }
        Success(Results.Ok(result))
      }

  // TODO implement those as admin custom fields management seems to use them
  def addItem(listName: String): Action[AnyContent] =
    entrypoint("add item to list")
      .extract("value", FieldsParser.jsObject.on("value"))
      .auth { request =>
        val value: JsObject = request.body("value")
        listName match {
          case "custom_fields" => {
              for {
                inputCustomField <- value.validate[InputCustomField]
              } yield inputCustomField
            } fold (
              errors => Failure(new Exception(errors.mkString)),
              _ => Success(Results.Ok)
            )
          case _ => Success(Results.Locked(""))
        }
      }

  def deleteItem(itemId: String): Action[AnyContent] =
    entrypoint("delete list item") { _ =>
      Success(Results.Locked(""))
    }

  def updateItem(itemId: String): Action[AnyContent] =
    entrypoint("update list item") { _ =>
      Success(Results.Locked(""))
    }

  def itemExists(listName: String): Action[AnyContent] =
    entrypoint("check if item exist in list")
      .extract("key", FieldsParser.string.on("key"))
      .extract("value", FieldsParser.string.on("value"))
      .authRoTransaction(db) { request => implicit graph =>
        listName match {
          case "custom_fields" =>
            val v: String = request.body("value")
            customFieldSrv
              .startTraversal
              .getByName(v)
              .getOrFail("CustomField")
              .map(f => Results.Conflict(Json.obj("found" -> f.toJson)))
              .orElse(Success(Results.Ok))
          case _ => Success(Results.Locked(""))
        }
      }
}

```

`thehive/app/org/thp/thehive/controllers/v0/LogCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputLog
import org.thp.thehive.models.{Log, Permissions, RichLog}
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.{LogSrv, OrganisationSrv, TaskSrv}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}

@Singleton
class LogCtrl @Inject() (
    override val entrypoint: Entrypoint,
    override val db: Database,
    logSrv: LogSrv,
    taskSrv: TaskSrv,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicLog
) extends QueryCtrl {

  def create(taskId: String): Action[AnyContent] =
    entrypoint("create log")
      .extract("log", FieldsParser[InputLog])
      .authTransaction(db) { implicit request => implicit graph =>
        val inputLog: InputLog = request.body("log")
        for {
          task <-
            taskSrv
              .get(EntityIdOrName(taskId))
              .can(Permissions.manageTask)
              .getOrFail("Task")
          createdLog <- logSrv.create(inputLog.toLog, task, inputLog.attachment)
        } yield Results.Created(createdLog.toJson)
      }

  def update(logId: String): Action[AnyContent] =
    entrypoint("update log")
      .extract("log", FieldsParser.update("log", publicData.publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("log")
        logSrv
          .update(
            _.get(EntityIdOrName(logId))
              .can(Permissions.manageTask),
            propertyUpdaters
          )
          .flatMap {
            case (logs, _) =>
              logs
                .richLog
                .getOrFail("Log")
                .map(richLog => Results.Ok(richLog.toJson))
          }
      }

  def delete(logId: String): Action[AnyContent] =
    entrypoint("delete log")
      .authTransaction(db) { implicit req => implicit graph =>
        for {
          log <- logSrv.get(EntityIdOrName(logId)).can(Permissions.manageTask).getOrFail("Log")
          _   <- logSrv.delete(log)
        } yield Results.NoContent
      }
}

@Singleton
class PublicLog @Inject() (logSrv: LogSrv, organisationSrv: OrganisationSrv) extends PublicData {
  override val entityName: String = "log"
  override val initialQuery: Query =
    Query.init[Traversal.V[Log]]("listLog", (graph, authContext) => logSrv.startTraversal(graph).visible(organisationSrv)(authContext))
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Log]](
    "getLog",
    (idOrName, graph, authContext) => logSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Log], IteratorOutput](
      "page",
      {

        case (OutputParam(from, to, _, 0), logSteps, _) => logSteps.richPage(from, to, withTotal = true, limitedCountThreshold)(_.richLog)
        case (OutputParam(from, to, _, _), logSteps, authContext) =>
          logSteps.richPage(from, to, withTotal = true, limitedCountThreshold)(
            _.richLogWithCustomRenderer(
              _.task.richTaskWithCustomRenderer(
                _.`case`.richCase(authContext).option
              )
            )
          )
      }
    )

  override val outputQuery: Query = Query.output[RichLog, Traversal.V[Log]](_.richLog)
  override val publicProperties: PublicProperties =
    PublicPropertyListBuilder[Log]
      .property("message", UMapping.string)(_.field.updatable)
      .property("deleted", UMapping.boolean)(_.field.updatable)
      .property("startDate", UMapping.date)(_.rename("date").readonly)
      .property("status", UMapping.string)(_.select(_.constant("Ok")).readonly)
      .property("attachment.name", UMapping.string.optional)(_.select(_.attachments.value(_.name)).readonly)
      .property("attachment.hashes", UMapping.hash.sequence)(_.select(_.attachments.value(_.hashes)).readonly)
      .property("attachment.size", UMapping.long.optional)(_.select(_.attachments.value(_.size)).readonly)
      .property("attachment.contentType", UMapping.string.optional)(_.select(_.attachments.value(_.contentType)).readonly)
      .property("attachment.id", UMapping.string.optional)(_.select(_.attachments.value(_.attachmentId)).readonly)
      .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/ObservableCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import net.lingala.zip4j.ZipFile
import net.lingala.zip4j.model.FileHeader
import org.thp.scalligraph._
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers._
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query.PredicateOps.PredicateOpsDefs
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.{InputAttachment, InputObservable}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services._
import play.api.Configuration
import play.api.libs.Files.DefaultTemporaryFileCreator
import play.api.libs.json.{JsArray, JsObject, JsValue, Json}
import play.api.mvc.{Action, AnyContent, Results}
import shapeless._

import java.io.FilterInputStream
import java.nio.file.Files
import java.util.Base64
import javax.inject.{Inject, Named, Singleton}
import scala.collection.JavaConverters._
import scala.util.{Failure, Success, Try}

@Singleton
class ObservableCtrl @Inject() (
    configuration: Configuration,
    override val entrypoint: Entrypoint,
    override val db: Database,
    observableSrv: ObservableSrv,
    observableTypeSrv: ObservableTypeSrv,
    caseSrv: CaseSrv,
    organisationSrv: OrganisationSrv,
    alertSrv: AlertSrv,
    attachmentSrv: AttachmentSrv,
    errorHandler: ErrorHandler,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicObservable,
    temporaryFileCreator: DefaultTemporaryFileCreator
) extends ObservableRenderer
    with QueryCtrl {

  type AnyAttachmentType = InputAttachment :+: FFile :+: String :+: CNil

  def createInCase(caseId: String): Action[AnyContent] =
    entrypoint("create artifact in case")
      .extract("artifact", FieldsParser[InputObservable])
      .extract("isZip", FieldsParser.boolean.optional.on("isZip"))
      .extract("zipPassword", FieldsParser.string.optional.on("zipPassword"))
      .auth { implicit request =>
        val inputObservable: InputObservable = request.body("artifact")
        val isZip: Option[Boolean]           = request.body("isZip")
        val zipPassword: Option[String]      = request.body("zipPassword")
        val inputAttachObs                   = if (isZip.contains(true)) getZipFiles(inputObservable, zipPassword) else Seq(inputObservable)

        db
          .roTransaction { implicit graph =>
            for {
              case0 <-
                caseSrv
                  .get(EntityIdOrName(caseId))
                  .can(Permissions.manageObservable)
                  .orFail(AuthorizationError("Operation not permitted"))
              observableType <- observableTypeSrv.getOrFail(EntityName(inputObservable.dataType))
            } yield (case0, observableType)
          }
          .map {
            case (case0, observableType) =>
              val successesAndFailures =
                if (observableType.isAttachment)
                  inputAttachObs
                    .flatMap(obs => obs.attachment.map(createAttachmentObservableInCase(case0, obs, _)))
                else
                  inputAttachObs
                    .flatMap(obs =>
                      obs
                        .data
                        .filter(_.exists(_ != ' '))
                        .filterNot(_.isEmpty)
                        .map(createSimpleObservableInCase(case0, obs, _))
                    )
              val (successes, failures) = successesAndFailures
                .foldLeft[(Seq[JsValue], Seq[JsValue])]((Nil, Nil)) {
                  case ((s, f), Right(o)) => (s :+ o, f)
                  case ((s, f), Left(o))  => (s, f :+ o)
                }
              if (failures.isEmpty) Results.Created(JsArray(successes))
              else Results.MultiStatus(Json.obj("success" -> successes, "failure" -> failures))
          }
      }

  private def createSimpleObservableInCase(
      `case`: Case with Entity,
      inputObservable: InputObservable,
      data: String
  )(implicit authContext: AuthContext): Either[JsValue, JsValue] =
    db
      .tryTransaction { implicit graph =>
        caseSrv.createObservable(`case`, inputObservable.toObservable, data)
      } match {
      case Success(o)     => Right(o.toJson)
      case Failure(error) => Left(errorHandler.toErrorResult(error)._2 + ("object" -> Json.obj("data" -> data)))
    }

  private def createAttachmentObservableInCase(
      `case`: Case with Entity,
      inputObservable: InputObservable,
      fileOrAttachment: Either[FFile, InputAttachment]
  )(implicit authContext: AuthContext): Either[JsValue, JsValue] =
    db
      .tryTransaction { implicit graph =>
        fileOrAttachment match {
          case Left(file) =>
            caseSrv.createObservable(`case`, inputObservable.toObservable, file)
          case Right(attachment) =>
            for {
              attach <- attachmentSrv.duplicate(attachment.name, attachment.contentType, attachment.id)
              obs    <- caseSrv.createObservable(`case`, inputObservable.toObservable, attach)
            } yield obs
        }
      } match {
      case Success(o) => Right(o.toJson)
      case Failure(error) =>
        val filename = fileOrAttachment.fold(_.filename, _.name)
        Left(errorHandler.toErrorResult(error)._2 + ("object" -> Json.obj("data" -> s"file:$filename", "attachment" -> Json.obj("name" -> filename))))
    }

  def createInAlert(alertId: String): Action[AnyContent] =
    entrypoint("create artifact in alert")
      .extract("artifact", FieldsParser[InputObservable])
      .extract("isZip", FieldsParser.boolean.optional.on("isZip"))
      .extract("zipPassword", FieldsParser.string.optional.on("zipPassword"))
      .auth { implicit request =>
        val inputObservable: InputObservable = request.body("artifact")
        val isZip: Option[Boolean]           = request.body("isZip")
        val zipPassword: Option[String]      = request.body("zipPassword")
        val inputAttachObs                   = if (isZip.contains(true)) getZipFiles(inputObservable, zipPassword) else Seq(inputObservable)

        db
          .roTransaction { implicit graph =>
            for {
              alert <-
                alertSrv
                  .get(EntityIdOrName(alertId))
                  .can(organisationSrv, Permissions.manageAlert)
                  .orFail(AuthorizationError("Operation not permitted"))
              observableType <- observableTypeSrv.getOrFail(EntityName(inputObservable.dataType))
            } yield (alert, observableType)
          }
          .map {
            case (alert, observableType) =>
              val successesAndFailures =
                if (observableType.isAttachment)
                  inputAttachObs
                    .flatMap { obs =>
                      (obs.attachment.map(_.fold(Coproduct[AnyAttachmentType](_), Coproduct[AnyAttachmentType](_))) ++
                        obs.data.map(Coproduct[AnyAttachmentType](_)))
                        .map(createAttachmentObservableInAlert(alert, obs, _))
                    }
                else
                  inputAttachObs
                    .flatMap(obs =>
                      obs
                        .data
                        .filter(_.exists(_ != ' '))
                        .filterNot(_.isEmpty)
                        .map(createSimpleObservableInAlert(alert, obs, _))
                    )
              val (successes, failures) = successesAndFailures
                .foldLeft[(Seq[JsValue], Seq[JsValue])]((Nil, Nil)) {
                  case ((s, f), Right(o)) => (s :+ o, f)
                  case ((s, f), Left(o))  => (s, f :+ o)
                }
              if (failures.isEmpty) Results.Created(JsArray(successes))
              else Results.MultiStatus(Json.obj("success" -> successes, "failure" -> failures))
          }
      }

  private def createSimpleObservableInAlert(
      alert: Alert with Entity,
      inputObservable: InputObservable,
      data: String
  )(implicit authContext: AuthContext): Either[JsValue, JsValue] =
    db
      .tryTransaction { implicit graph =>
        alertSrv.createObservable(alert, inputObservable.toObservable, data)
      } match {
      case Success(o)     => Right(o.toJson)
      case Failure(error) => Left(errorHandler.toErrorResult(error)._2 + ("object" -> Json.obj("data" -> data)))
    }

  private def createAttachmentObservableInAlert(
      alert: Alert with Entity,
      inputObservable: InputObservable,
      attachment: AnyAttachmentType
  )(implicit authContext: AuthContext): Either[JsValue, JsValue] =
    db
      .tryTransaction { implicit graph =>
        object createAttachment extends Poly1 {
          implicit val fromFile: Case.Aux[FFile, Try[RichObservable]] = at[FFile] { file =>
            alertSrv.createObservable(alert, inputObservable.toObservable, file)
          }
          implicit val fromAttachment: Case.Aux[InputAttachment, Try[RichObservable]] = at[InputAttachment] { attachment =>
            for {
              attach <- attachmentSrv.duplicate(attachment.name, attachment.contentType, attachment.id)
              obs    <- alertSrv.createObservable(alert, inputObservable.toObservable, attach)
            } yield obs
          }

          implicit val fromString: Case.Aux[String, Try[RichObservable]] = at[String] { data =>
            data.split(';') match {
              case Array(filename, contentType, value) =>
                val data = Base64.getDecoder.decode(value)
                attachmentSrv
                  .create(filename, contentType, data)
                  .flatMap(attachment => alertSrv.createObservable(alert, inputObservable.toObservable, attachment))
              case Array(filename, contentType) =>
                attachmentSrv
                  .create(filename, contentType, Array.emptyByteArray)
                  .flatMap(attachment => alertSrv.createObservable(alert, inputObservable.toObservable, attachment))
              case data =>
                Failure(InvalidFormatAttributeError("artifacts.data", "filename;contentType;base64value", Set.empty, FString(data.mkString(";"))))
            }
          }
        }
        attachment.fold(createAttachment)
      } match {
      case Success(o) => Right(o.toJson)
      case Failure(error) =>
        object attachmentName extends Poly1 {
          implicit val fromFile: Case.Aux[FFile, String]                 = at[FFile](_.filename)
          implicit val fromAttachment: Case.Aux[InputAttachment, String] = at[InputAttachment](_.name)
          implicit val fromString: Case.Aux[String, String] = at[String] { data =>
            if (data.contains(';')) data.takeWhile(_ != ';') else "no name"
          }
        }
        val filename = attachment.fold(attachmentName)
        Left(errorHandler.toErrorResult(error)._2 + ("object" -> Json.obj("data" -> s"file:$filename", "attachment" -> Json.obj("name" -> filename))))
    }

  def get(observableId: String): Action[AnyContent] =
    entrypoint("get observable")
      .authRoTransaction(db) { implicit request => implicit graph =>
        observableSrv
          .get(EntityIdOrName(observableId))
          .visible(organisationSrv)
          .richObservable
          .getOrFail("Observable")
          .map { observable =>
            Results.Ok(observable.toJson)
          }
      }

  def update(observableId: String): Action[AnyContent] =
    entrypoint("update observable")
      .extract("observable", FieldsParser.update("observable", publicData.publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("observable")
        observableSrv
          .update(
            _.get(EntityIdOrName(observableId)).canManage(organisationSrv),
            propertyUpdaters
          )
          .flatMap {
            case (observables, _) =>
              observables
                .richObservable
                .getOrFail("Observable")
                .map(richObservable => Results.Ok(richObservable.toJson))
          }
      }

  def findSimilar(observableId: String): Action[AnyContent] =
    entrypoint("find similar")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val observables = observableSrv
          .get(EntityIdOrName(observableId))
          .visible(organisationSrv)
          .filteredSimilar
          .visible(organisationSrv)
          .richObservableWithCustomRenderer(organisationSrv, observableLinkRenderer)
          .toIterator
          .filterNot(_._2.keys.isEmpty)
          .toSeq

        Success(Results.Ok(observables.toJson))
      }

  def bulkUpdate: Action[AnyContent] =
    entrypoint("bulk update")
      .extract("input", FieldsParser.update("observable", publicData.publicProperties))
      .extract("ids", FieldsParser.seq[String].on("ids"))
      .authTransaction(db) { implicit request => implicit graph =>
        val properties: Seq[PropertyUpdater] = request.body("input")
        val ids: Seq[String]                 = request.body("ids")
        ids
          .toTry { id =>
            observableSrv
              .update(_.get(EntityIdOrName(id)).canManage(organisationSrv), properties)
          }
          .map(_ => Results.NoContent)
      }

  def delete(observableId: String): Action[AnyContent] =
    entrypoint("delete")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          observable <-
            observableSrv
              .get(EntityIdOrName(observableId))
              .canManage(organisationSrv)
              .getOrFail("Observable")
          _ <- observableSrv.delete(observable)
        } yield Results.NoContent
      }

  // extract a file from the archive and make sure its size matches the header (to protect against zip bombs)
  private def extractAndCheckSize(zipFile: ZipFile, header: FileHeader): Option[FFile] = {
    val fileName = header.getFileName
    if (fileName.contains('/')) None
    else {
      val file = temporaryFileCreator.create("zip")

      val input = zipFile.getInputStream(header)
      val size  = header.getUncompressedSize
      val sizedInput: FilterInputStream = new FilterInputStream(input) {
        var totalRead = 0

        override def read(): Int =
          if (totalRead < size) {
            totalRead += 1
            super.read()
          } else throw BadRequestError("Error extracting file: output size doesn't match header")
      }
      Files.delete(file)
      val fileSize = Files.copy(sizedInput, file)
      if (fileSize != size) {
        file.toFile.delete()
        throw InternalError("Error extracting file: output size doesn't match header")
      }
      input.close()
      val contentType = Option(Files.probeContentType(file)).getOrElse("application/octet-stream")
      Some(FFile(header.getFileName, file, contentType))
    }
  }

  private def getZipFiles(observable: InputObservable, zipPassword: Option[String]): Seq[InputObservable] =
    observable.attachment.flatMap(_.swap.toSeq).flatMap { attachment =>
      val zipFile = new ZipFile(attachment.filepath.toFile)
      val files   = zipFile.getFileHeaders.asScala

      if (zipFile.isEncrypted)
        zipFile.setPassword(zipPassword.getOrElse(configuration.get[String]("datastore.attachment.password")).toCharArray)

      files
        .filterNot(_.isDirectory)
        .flatMap(extractAndCheckSize(zipFile, _))
        .map(ffile => observable.copy(attachment = Seq(Left(ffile))))
    }
}

@Singleton
class PublicObservable @Inject() (
    observableTypeSrv: ObservableTypeSrv,
    observableSrv: ObservableSrv,
    organisationSrv: OrganisationSrv
) extends PublicData
    with ObservableRenderer {
  override val entityName: String = "observable"
  override val initialQuery: Query =
    Query.init[Traversal.V[Observable]](
      "listObservable",
      (graph, authContext) => observableSrv.startTraversal(graph).visible(organisationSrv)(authContext)
    )
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Observable]](
    "getObservable",
    (idOrName, graph, authContext) => observableSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Observable], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, withStats, 0), observableSteps, authContext) =>
          observableSteps
            .richPage(from, to, withTotal = true, limitedCountThreshold) {
              case o if withStats =>
                o.richObservableWithCustomRenderer(organisationSrv, observableStatsRenderer(organisationSrv)(authContext))(authContext)
                  .domainMap(ros => (ros._1, ros._2, None: Option[Either[RichCase, RichAlert]]))
              case o =>
                o.richObservable.domainMap(ro => (ro, JsObject.empty, None))
            }
        case (OutputParam(from, to, _, _), observableSteps, authContext) =>
          observableSteps.richPage(from, to, withTotal = true, limitedCountThreshold)(
            _.richObservableWithCustomRenderer(
              organisationSrv,
              o => o.project(_.by(_.`case`.richCase(authContext).option).by(_.alert.richAlert.option))
            )(authContext).domainMap(roc =>
              (
                roc._1,
                JsObject.empty,
                roc._2 match {
                  case (Some(c), _) => Some(Left(c))
                  case (_, Some(a)) => Some(Right(a))
                  case _            => None
                }
              )
            )
          )
      }
    )
  override val outputQuery: Query = Query.output[RichObservable, Traversal.V[Observable]](_.richObservable)
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[Observable], Traversal.V[Organisation]](
      "organisations",
      (observableSteps, authContext) => observableSteps.organisations.visible(authContext)
    ),
    Query[Traversal.V[Observable], Traversal.V[Observable]](
      "similar",
      (observableSteps, authContext) => observableSteps.filteredSimilar.visible(organisationSrv)(authContext)
    ),
    Query[Traversal.V[Observable], Traversal.V[Case]]("case", (observableSteps, _) => observableSteps.`case`),
    Query[Traversal.V[Observable], Traversal.V[Alert]]("alert", (observableSteps, _) => observableSteps.alert),
    Query[Traversal.V[Observable], Traversal.V[Observable]]("fromCase", (observableSteps, _) => observableSteps.filter(_.shares)),
    Query[Traversal.V[Observable], Traversal.V[Observable]]("fromAlert", (observableSteps, _) => observableSteps.filter(_.alert)),
    Query[Traversal.V[Observable], Traversal.V[Observable]](
      "fromJobReport",
      (observableSteps, _) => observableSteps.filter(_.inE("ReportObservable"))
    )
  )
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[Observable]
    .property("status", UMapping.string)(_.select(_.constant("Ok")).readonly)
    .property("startDate", UMapping.date)(_.select(_._createdAt).readonly)
    .property("ioc", UMapping.boolean)(_.field.updatable)
    .property("sighted", UMapping.boolean)(_.field.updatable)
    .property("ignoreSimilarity", UMapping.boolean)(_.field.updatable)
    .property("tags", UMapping.string.set)(
      _.field
        .custom { (_, value, vertex, graph, authContext) =>
          observableSrv
            .get(vertex)(graph)
            .getOrFail("Observable")
            .flatMap(observable => observableSrv.updateTags(observable, value)(graph, authContext))
            .map(_ => Json.obj("tags" -> value))
        }
    )
    .property("message", UMapping.string)(_.field.updatable)
    .property("tlp", UMapping.int)(_.field.updatable)
    .property("dataType", UMapping.string)(_.field.custom { (_, value, vertex, graph, authContext) =>
      val observable = observableSrv.model.converter(vertex)
      for {
        currentDataType <- observableTypeSrv.getByName(observable.dataType)(graph).getOrFail("ObservableType")
        newDataType     <- observableTypeSrv.getByName(value)(graph).getOrFail("ObservableType")
        isSameType = currentDataType.isAttachment == newDataType.isAttachment
        _ <- if (isSameType) Success(()) else Failure(BadRequestError("Can not update dataType: isAttachment does not match"))
        _ <- observableSrv.updateType(observable, newDataType)(graph, authContext)
      } yield Json.obj("dataType" -> value)
    })
    .property("data", UMapping.string.optional)(
      _.select(_.value(_.data))
        .filter[String] {
          case (_, observables, _, Right(predicate)) => observables.has(_.data, predicate.mapValue(v => UseHashToIndex.hashToIndex(v).getOrElse(v)))
          case (_, observables, _, Left(true))       => observables.has(_.data)
          case (_, observables, _, Left(false))      => observables.hasNot(_.data)
        }
        .readonly
    )
    .property("attachment.name", UMapping.string.optional)(_.select(_.attachments.value(_.name)).readonly)
    .property("attachment.hashes", UMapping.hash.sequence)(_.select(_.attachments.value(_.hashes)).readonly)
    .property("attachment.size", UMapping.long.optional)(_.select(_.attachments.value(_.size)).readonly)
    .property("attachment.contentType", UMapping.string.optional)(_.select(_.attachments.value(_.contentType)).readonly)
    .property("attachment.id", UMapping.string.optional)(_.field.readonly)
    .property("relatedId", UMapping.entityId)(_.field.readonly)
    .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/ObservableRenderer.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.models.Observable
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationSrv
import play.api.libs.json.{JsObject, Json}

import java.lang.{Boolean => JBoolean, Long => JLong}
import java.util.{Map => JMap}

trait ObservableRenderer {

  def observableStatsRenderer(organisationSrv: OrganisationSrv)(implicit
      authContext: AuthContext
  ): Traversal.V[Observable] => Traversal[JsObject, JMap[JBoolean, JLong], Converter[JsObject, JMap[JBoolean, JLong]]] =
    _.filteredSimilar
      .visible(organisationSrv)
      .groupCount(_.byValue(_.ioc))
      .domainMap { stats =>
        val nTrue  = stats.getOrElse(true, 0L)
        val nFalse = stats.getOrElse(false, 0L)
        Json.obj(
          "seen" -> (nTrue + nFalse),
          "ioc"  -> (nTrue > 0)
        )
      }

  def observableLinkRenderer: Traversal.V[Observable] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    _.coalesceMulti(
      _.alert.richAlert.domainMap(a => Json.obj("alert" -> a.toJson)),
      _.`case`.richCaseWithoutPerms.domainMap(c => Json.obj("case" -> c.toJson)),
      _.constant2[JsObject, JMap[String, Any]](JsObject.empty)
    )
}

```

`thehive/app/org/thp/thehive/controllers/v0/ObservableTypeCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputObservableType
import org.thp.thehive.models.{ObservableType, Permissions}
import org.thp.thehive.services.ObservableTypeSrv
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}

@Singleton
class ObservableTypeCtrl @Inject() (
    override val entrypoint: Entrypoint,
    override val db: Database,
    observableTypeSrv: ObservableTypeSrv,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicObservableType
) extends QueryCtrl {
  def get(idOrName: String): Action[AnyContent] =
    entrypoint("get observable type").authRoTransaction(db) { _ => implicit graph =>
      observableTypeSrv
        .get(EntityIdOrName(idOrName))
        .getOrFail("Observable")
        .map(ot => Results.Ok(ot.toJson))
    }

  def create: Action[AnyContent] =
    entrypoint("create observable type")
      .extract("observableType", FieldsParser[InputObservableType])
      .authPermittedTransaction(db, Permissions.manageObservableTemplate) { implicit request => implicit graph =>
        val inputObservableType: InputObservableType = request.body("observableType")
        observableTypeSrv
          .create(inputObservableType.toObservableType)
          .map(observableType => Results.Created(observableType.toJson))
      }

  def delete(idOrName: String): Action[AnyContent] =
    entrypoint("delete observable type")
      .authPermittedTransaction(db, Permissions.manageObservableTemplate) { _ => implicit graph =>
        observableTypeSrv.remove(EntityIdOrName(idOrName)).map(_ => Results.NoContent)
      }
}

@Singleton
class PublicObservableType @Inject() (observableTypeSrv: ObservableTypeSrv) extends PublicData {
  override val entityName: String = "ObservableType"
  override val initialQuery: Query =
    Query.init[Traversal.V[ObservableType]]("listObservableType", (graph, _) => observableTypeSrv.startTraversal(graph))
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[ObservableType], IteratorOutput](
      "page",
      (range, observableTypeSteps, _) => observableTypeSteps.richPage(range.from, range.to, withTotal = true, limitedCountThreshold)(identity)
    )
  override val outputQuery: Query = Query.output[ObservableType with Entity]
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[ObservableType]](
    "getObservableType",
    (idOrName, graph, _) => observableTypeSrv.get(idOrName)(graph)
  )
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[ObservableType]
    .property("name", UMapping.string)(_.field.readonly)
    .property("isAttachment", UMapping.boolean)(_.field.readonly)
    .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/OrganisationCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.scalligraph.{EntityIdOrName, EntityName, NotFoundError}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputOrganisation
import org.thp.thehive.models.{CaseTemplate, Organisation, Permissions, User}
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}
import scala.util.{Failure, Success}

@Singleton
class OrganisationCtrl @Inject() (
    override val entrypoint: Entrypoint,
    organisationSrv: OrganisationSrv,
    userSrv: UserSrv,
    implicit override val db: Database,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicOrganisation
) extends QueryCtrl {
  def create: Action[AnyContent] =
    entrypoint("create organisation")
      .extract("organisation", FieldsParser[InputOrganisation])
      .authTransaction(db) { implicit request => implicit graph =>
        val inputOrganisation: InputOrganisation = request.body("organisation")
        for {
          _   <- userSrv.current.organisations(Permissions.manageOrganisation).get(EntityName(Organisation.administration.name)).existsOrFail
          org <- organisationSrv.create(inputOrganisation.toOrganisation)

        } yield Results.Created(org.toJson)
      }

  def get(organisationId: String): Action[AnyContent] =
    entrypoint("get an organisation")
      .authRoTransaction(db) { implicit request => implicit graph =>
        organisationSrv
          .get(EntityIdOrName(organisationId))
          .visible
          .richOrganisation
          .getOrFail("Organisation")
          .map(organisation => Results.Ok(organisation.toJson))
      }

  def list: Action[AnyContent] =
    entrypoint("list organisation")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val organisations = organisationSrv
          .startTraversal
          .visible
          .richOrganisation
          .toSeq

        Success(Results.Ok(organisations.toJson))
      }

  def update(organisationId: String): Action[AnyContent] =
    entrypoint("update organisation")
      .extract("organisation", FieldsParser.update("organisation", publicData.publicProperties))
      .authPermittedTransaction(db, Permissions.manageOrganisation) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("organisation")

        for {
          organisation <- organisationSrv.getOrFail(EntityIdOrName(organisationId))
          _            <- organisationSrv.update(organisationSrv.get(organisation), propertyUpdaters)
        } yield Results.NoContent
      }

  def link(fromOrganisationId: String, toOrganisationId: String): Action[AnyContent] =
    entrypoint("link organisations")
      .authPermittedTransaction(db, Permissions.manageOrganisation) { implicit request => implicit graph =>
        for {
          fromOrg <- organisationSrv.getOrFail(EntityIdOrName(fromOrganisationId))
          toOrg   <- organisationSrv.getOrFail(EntityIdOrName(toOrganisationId))
          _       <- organisationSrv.doubleLink(fromOrg, toOrg)
        } yield Results.Created
      }

  def bulkLink(fromOrganisationId: String): Action[AnyContent] =
    entrypoint("link multiple organisations")
      .extract("organisations", FieldsParser.string.sequence.on("organisations"))
      .authPermittedTransaction(db, Permissions.manageOrganisation) { implicit request => implicit graph =>
        val organisations: Seq[String] = request.body("organisations")

        for {
          fromOrg <- organisationSrv.getOrFail(EntityIdOrName(fromOrganisationId))
          _       <- organisationSrv.updateLink(fromOrg, organisations.map(EntityIdOrName(_)))
        } yield Results.Created
      }

  def unlink(fromOrganisationId: String, toOrganisationId: String): Action[AnyContent] =
    entrypoint("unlink organisations")
      .authPermittedTransaction(db, Permissions.manageOrganisation) { _ => implicit graph =>
        for {
          fromOrg <- organisationSrv.getOrFail(EntityIdOrName(fromOrganisationId))
          toOrg   <- organisationSrv.getOrFail(EntityIdOrName(toOrganisationId))
          _ <-
            if (organisationSrv.linkExists(fromOrg, toOrg)) Success(organisationSrv.doubleUnlink(fromOrg, toOrg))
            else Failure(NotFoundError(s"Organisation $fromOrganisationId is not linked to $toOrganisationId"))
        } yield Results.NoContent
      }

  def listLinks(organisationId: String): Action[AnyContent] =
    entrypoint("list organisation links")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val isInDefaultOrganisation = userSrv.current.organisations.get(EntityName(Organisation.administration.name)).exists
        val organisation =
          if (isInDefaultOrganisation)
            organisationSrv.get(EntityIdOrName(organisationId))
          else
            userSrv
              .current
              .organisations
              .get(EntityIdOrName(organisationId))
        val organisations = organisation.links.toSeq

        Success(Results.Ok(organisations.toJson))
      }
}

@Singleton
class PublicOrganisation @Inject() (organisationSrv: OrganisationSrv) extends PublicData {
  override val entityName: String = "organisation"

  override val initialQuery: Query =
    Query.init[Traversal.V[Organisation]]("listOrganisation", (graph, authContext) => organisationSrv.startTraversal(graph).visible(authContext))
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Organisation], IteratorOutput](
      "page",
      (range, organisationSteps, _) => organisationSteps.page(range.from, range.to, withTotal = true, limitedCountThreshold)
    )
  override val outputQuery: Query = Query.output[Organisation with Entity]
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Organisation]](
    "getOrganisation",
    (idOrName, graph, authContext) => organisationSrv.get(idOrName)(graph).visible(authContext)
  )
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[Organisation], Traversal.V[Organisation]]("visible", (organisationSteps, _) => organisationSteps.visibleOrganisationsFrom),
    Query[Traversal.V[Organisation], Traversal.V[User]]("users", (organisationSteps, _) => organisationSteps.users.dedup),
    Query[Traversal.V[Organisation], Traversal.V[CaseTemplate]]("caseTemplates", (organisationSteps, _) => organisationSteps.caseTemplates)
  )
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[Organisation]
    .property("name", UMapping.string)(_.field.updatable)
    .property("description", UMapping.string)(_.field.updatable)
    .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/PageCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputPage
import org.thp.thehive.models.{Page, Permissions}
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.PageOps._
import org.thp.thehive.services.{OrganisationSrv, PageSrv}
import play.api.mvc._

import javax.inject.{Inject, Named, Singleton}

@Singleton
class PageCtrl @Inject() (
    override val entrypoint: Entrypoint,
    pageSrv: PageSrv,
    override val db: Database,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicPage
) extends QueryCtrl {
  def get(idOrTitle: String): Action[AnyContent] =
    entrypoint("get a page")
      .authRoTransaction(db) { implicit request => implicit graph =>
        pageSrv
          .get(EntityIdOrName(idOrTitle))
          .visible
          .getOrFail("Page")
          .map(p => Results.Ok(p.toJson))
      }

  def create: Action[AnyContent] =
    entrypoint("create a page")
      .extract("page", FieldsParser[InputPage])
      .authPermittedTransaction(db, Permissions.managePage) { implicit request => implicit graph =>
        val page: InputPage = request.body("page")

        pageSrv
          .create(page.toPage)
          .map(p => Results.Created(p.toJson))
      }

  def update(idOrTitle: String): Action[AnyContent] =
    entrypoint("update a page")
      .extract("page", FieldsParser.update("page", publicData.publicProperties))
      .authPermittedTransaction(db, Permissions.managePage) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("page")

        for {
          page    <- pageSrv.get(EntityIdOrName(idOrTitle)).visible.getOrFail("Page")
          updated <- pageSrv.update(page, propertyUpdaters)
        } yield Results.Ok(updated.toJson)
      }

  def delete(idOrTitle: String): Action[AnyContent] =
    entrypoint("delete a page")
      .authPermittedTransaction(db, Permissions.managePage) { implicit request => implicit graph =>
        for {
          page <- pageSrv.get(EntityIdOrName(idOrTitle)).visible.getOrFail("Page")
          _    <- pageSrv.delete(page)
        } yield Results.NoContent
      }
}

@Singleton
class PublicPage @Inject() (pageSrv: PageSrv, organisationSrv: OrganisationSrv) extends PublicData {
  override val entityName: String = "page"
  override val initialQuery: Query =
    Query.init[Traversal.V[Page]]("listPage", (graph, authContext) => organisationSrv.get(authContext.organisation)(graph).pages)
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Page]](
    "getPage",
    (idOrName, graph, authContext) => pageSrv.get(idOrName)(graph).visible(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Page], IteratorOutput](
      "page",
      (range, pageSteps, _) => pageSteps.page(range.from, range.to, withTotal = true, limitedCountThreshold)
    )
  override val outputQuery: Query = Query.output[Page with Entity]
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[Page]
    .property("title", UMapping.string)(_.field.updatable)
    .property("content", UMapping.string.set)(_.field.updatable)
    .build

}

```

`thehive/app/org/thp/thehive/controllers/v0/PermissionCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import javax.inject.{Inject, Singleton}
import org.thp.scalligraph.controllers.Entrypoint
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.models.Permissions
import play.api.mvc.{Action, AnyContent, Results}

import scala.util.Success

@Singleton
class PermissionCtrl @Inject() (entrypoint: Entrypoint) {
  def list: Action[AnyContent] =
    entrypoint("list permissions")
      .auth(_ => Success(Results.Ok(Permissions.list.toJson)))
}

```

`thehive/app/org/thp/thehive/controllers/v0/ProfileCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.scalligraph.{AuthorizationError, EntityIdOrName}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputProfile
import org.thp.thehive.models.{Permissions, Profile}
import org.thp.thehive.services.ProfileOps._
import org.thp.thehive.services.ProfileSrv
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}
import scala.util.Failure

@Singleton
class ProfileCtrl @Inject() (
    override val entrypoint: Entrypoint,
    profileSrv: ProfileSrv,
    override val publicData: PublicProfile,
    implicit val db: Database,
    @Named("v0") override val queryExecutor: QueryExecutor
) extends QueryCtrl {
  def create: Action[AnyContent] =
    entrypoint("create profile")
      .extract("profile", FieldsParser[InputProfile])
      .authTransaction(db) { implicit request => implicit graph =>
        val profile: InputProfile = request.body("profile")
        if (request.isPermitted(Permissions.manageProfile))
          profileSrv.create(profile.toProfile).map(createdProfile => Results.Created(createdProfile.toJson))
        else
          Failure(AuthorizationError("You don't have permission to create profiles"))
      }

  def get(profileId: String): Action[AnyContent] =
    entrypoint("get profile")
      .authRoTransaction(db) { _ => implicit graph =>
        profileSrv
          .getOrFail(EntityIdOrName(profileId))
          .map { profile =>
            Results.Ok(profile.toJson)
          }
      }

  def update(profileId: String): Action[AnyContent] =
    entrypoint("update profile")
      .extract("profile", FieldsParser.update("profile", publicData.publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("profile")
        if (request.isPermitted(Permissions.manageProfile))
          profileSrv
            .update(_.get(EntityIdOrName(profileId)), propertyUpdaters)
            .flatMap { case (profileSteps, _) => profileSteps.getOrFail("Profile") }
            .map(profile => Results.Ok(profile.toJson))
        else
          Failure(AuthorizationError("You don't have permission to update profiles"))
      }

  def delete(profileId: String): Action[AnyContent] =
    entrypoint("delete profile")
      .authPermittedTransaction(db, Permissions.manageProfile) { implicit request => implicit graph =>
        profileSrv
          .getOrFail(EntityIdOrName(profileId))
          .flatMap(profileSrv.remove)
          .map(_ => Results.NoContent)
      }
}

@Singleton
class PublicProfile @Inject() (profileSrv: ProfileSrv) extends PublicData {
  val entityName: String = "profile"

  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Profile]](
    "getProfile",
    (idOrName, graph, _) => profileSrv.get(idOrName)(graph)
  )
  val initialQuery: Query =
    Query.init[Traversal.V[Profile]]("listProfile", (graph, _) => profileSrv.startTraversal(graph))

  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Profile], IteratorOutput](
      "page",
      (range, profileSteps, _) => profileSteps.page(range.from, range.to, withTotal = true, limitedCountThreshold)
    )
  override val outputQuery: Query = Query.output[Profile with Entity]
  val publicProperties: PublicProperties = PublicPropertyListBuilder[Profile]
    .property("name", UMapping.string)(_.field.updatable)
    .property("permissions", UMapping.string.set)(_.field.updatable)
    .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/QueryCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.apache.tinkerpop.gremlin.process.traversal.Order
import org.scalactic.Accumulation._
import org.scalactic.Good
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers._
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.Traversal.Unk
import org.thp.thehive.services.th3.TH3Aggregation
import play.api.Logger
import play.api.libs.json.JsObject
import play.api.mvc.{Action, AnyContent, Results}

import scala.reflect.runtime.{universe => ru}
import scala.util.Try

trait PublicData {
  val entityName: String
  val publicProperties: PublicProperties
  val initialQuery: Query
  def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam]
  val outputQuery: Query
  val getQuery: ParamQuery[EntityIdOrName]
  val extraQueries: Seq[ParamQuery[_]] = Nil
}
trait QueryCtrl {
  lazy val logger: Logger = Logger(getClass)

  val publicData: PublicData
  val entrypoint: Entrypoint
  val queryExecutor: QueryExecutor
  val db: Database

  val filterQuery: FilterQuery = queryExecutor.filterQuery
  val queryType: ru.Type       = publicData.initialQuery.toType(ru.typeOf[Graph])

  val inputFilterParser: FieldsParser[InputQuery[Unk, Unk]] = filterQuery
    .paramParser(queryType)

  val aggregationParser: FieldsParser[Aggregation] =
    TH3Aggregation.fieldsParser(inputFilterParser)

  val sortParser: FieldsParser[InputSort] = FieldsParser("sort") {
    case (_, FAny(s))    => Good(s.flatMap(_.split(',')))
    case (_, FSeq(s))    => s.validatedBy(FieldsParser.string.apply)
    case (_, FString(s)) => Good(s.split(',').toSeq)
    case (_, FUndefined) => Good(Nil)
  }.map("sort") { a =>
    val fields = a.collect {
      case s if s(0) == '-' => s.tail -> Order.desc
      case s if s(0) == '+' => s.tail -> Order.asc
      case s if s.nonEmpty  => s      -> Order.asc
    }
    new InputSort(fields: _*)
  }

  val outputParamParser: FieldsParser[OutputParam] = FieldsParser[OutputParam]("OutputParam") {
    case (_, o: FObject) =>
      for {
        fromTo <-
          FieldsParser
            .string
            .optional
            .on("range")
            .apply(o)
            .map {
              case Some("all") => (0L, Long.MaxValue)
              case Some(r) =>
                val Array(offsetStr, endStr, _*) = (r + "-0").split("-", 3)
                val offset: Long                 = Try(Math.max(0, offsetStr.toLong)).getOrElse(0)
                val end: Long                    = Try(endStr.toLong).getOrElse(offset + 10L)
                if (end <= offset) (offset, offset + 10)
                else (offset, end)
              case None => (0L, 10L)
            }
        withStats   <- FieldsParser.boolean.optional.on("nstats")(o)
        withParents <- FieldsParser.int.optional.on("nparent")(o)
      } yield OutputParam(fromTo._1, fromTo._2, withStats.getOrElse(false), withParents.getOrElse(0))
  }

  val statsParser: FieldsParser[Seq[Query]] = FieldsParser[Seq[Query]]("stats") {
    case (_, field) =>
      for {
        maybeInputFilter <- inputFilterParser.optional(field.get("query"))
        filteredQuery =
          maybeInputFilter
            .map(inputFilter => filterQuery.toQuery(inputFilter))
            .fold(publicData.initialQuery)(publicData.initialQuery.andThen)
        aggs <- aggregationParser.sequence(field.get("stats"))
      } yield aggs.map(a => filteredQuery andThen new AggregationQuery(queryExecutor.publicProperties, filterQuery).toQuery(a))
  }

  def searchParser(initialQuery: Query = publicData.initialQuery): FieldsParser[Query] =
    FieldsParser[Query]("search") {
      case (_, field) =>
        for {
          maybeInputFilter <- inputFilterParser.optional(field.get("query"))
          filteredQuery =
            maybeInputFilter
              .map(inputFilter => filterQuery.toQuery(inputFilter))
              .fold(initialQuery)(initialQuery.andThen)
          inputSort <- sortParser(field.get("sort"))
          sortedQuery = filteredQuery andThen new SortQuery(queryExecutor.publicProperties).toQuery(inputSort)
          outputParam <- outputParamParser.optional(field).map(_.getOrElse(OutputParam(0, 10, withStats = false, withParents = 0)))
          outputQuery = publicData.pageQuery(queryExecutor.limitedCountThreshold).toQuery(outputParam)
        } yield sortedQuery andThen outputQuery
    }

  def search: Action[AnyContent] =
    entrypoint(s"search ${publicData.entityName}")
      .extract("query", searchParser())
      .auth { implicit request =>
        val query: Query = request.body("query")
        queryExecutor.execute(query, request)
      }

  def stats: Action[AnyContent] =
    entrypoint(s"${publicData.entityName} stats")
      .extract("query", statsParser)
      .authRoTransaction(db) { implicit request => graph =>
        val queries: Seq[Query] = request.body("query")
        queries
          .toTry(query => queryExecutor.execute(query, graph, request.authContext))
          .map { outputs =>
            val results = outputs.map(_.toJson).foldLeft(JsObject.empty) {
              case (acc, o: JsObject) => acc deepMerge o
              case (acc, r) =>
                logger.warn(s"Invalid stats result: $r")
                acc
            }
            Results.Ok(results)
          }
      }
}

```

`thehive/app/org/thp/thehive/controllers/v0/Router.scala`:

```scala
package org.thp.thehive.controllers.v0

import play.api.routing.Router.Routes
import play.api.routing.SimpleRouter
import play.api.routing.sird._

import javax.inject.{Inject, Singleton}

@Singleton
class Router @Inject() (
    alertCtrl: AlertCtrl,
    attachmentCtrl: AttachmentCtrl,
    auditCtrl: AuditCtrl,
    authenticationCtrl: AuthenticationCtrl,
    caseCtrl: CaseCtrl,
    caseTemplateCtrl: CaseTemplateCtrl,
    configCtrl: ConfigCtrl,
    customFieldCtrl: CustomFieldCtrl,
    dashboardCtrl: DashboardCtrl,
    describeCtrl: DescribeCtrl,
    listCtrl: ListCtrl,
    logCtrl: LogCtrl,
    observableCtrl: ObservableCtrl,
    observableTypeCtrl: ObservableTypeCtrl,
    organisationCtrl: OrganisationCtrl,
    pageCtrl: PageCtrl,
    permissionCtrl: PermissionCtrl,
    profileCtrl: ProfileCtrl,
    shareCtrl: ShareCtrl,
    statsCtrl: StatsCtrl,
    statusCtrl: StatusCtrl,
    tagCtrl: TagCtrl,
    taskCtrl: TaskCtrl,
    streamCtrl: StreamCtrl,
    userCtrl: UserCtrl
) extends SimpleRouter {

  override def routes: Routes = {
    case POST(p"/case/$caseId/shares")                         => shareCtrl.shareCase(caseId)
    case GET(p"/case/$caseId/shares")                          => shareCtrl.listShareCases(caseId)
    case DELETE(p"/case/$caseId/shares")                       => shareCtrl.removeShares(caseId)
    case DELETE(p"/case/shares")                               => shareCtrl.removeShares()
    case POST(p"/case/task/$taskId/shares")                    => shareCtrl.shareTask(taskId)
    case GET(p"/case/$caseId/task/$taskId/shares")             => shareCtrl.listShareTasks(caseId, taskId)
    case DELETE(p"/task/$taskId/shares")                       => shareCtrl.removeTaskShares(taskId)
    case POST(p"/case/artifact/$observableId/shares")          => shareCtrl.shareObservable(observableId)
    case GET(p"/case/$caseId/observable/$observableId/shares") => shareCtrl.listShareObservables(caseId, observableId)
    case DELETE(p"/observable/$observableId/shares")           => shareCtrl.removeObservableShares(observableId)
    case DELETE(p"/case/share/$shareId")                       => shareCtrl.removeShare(shareId)
    case PATCH(p"/case/share/$shareId")                        => shareCtrl.updateShare(shareId)

    case GET(p"/alert")                         => alertCtrl.search
    case POST(p"/alert/_search")                => alertCtrl.search
    case POST(p"/alert/_stats")                 => alertCtrl.stats
    case POST(p"/alert")                        => alertCtrl.create
    case GET(p"/alert/$alertId")                => alertCtrl.get(alertId)
    case PATCH(p"/alert/$alertId")              => alertCtrl.update(alertId)
    case POST(p"/alert/delete/_bulk")           => alertCtrl.bulkDelete
    case DELETE(p"/alert/$alertId")             => alertCtrl.delete(alertId)
    case POST(p"/alert/merge/_bulk")            => alertCtrl.bulkMergeWithCase
    case POST(p"/alert/$alertId/merge/$caseId") => alertCtrl.mergeWithCase(alertId, caseId)
    case POST(p"/alert/$alertId/markAsRead")    => alertCtrl.markAsRead(alertId)
    case POST(p"/alert/$alertId/markAsUnread")  => alertCtrl.markAsUnread(alertId)
    case POST(p"/alert/$alertId/follow")        => alertCtrl.followAlert(alertId)
    case POST(p"/alert/$alertId/unfollow")      => alertCtrl.unfollowAlert(alertId)
    case POST(p"/alert/$alertId/createCase")    => alertCtrl.createCase(alertId)
    // PATCH    /alert/_bulk                         controllers.AlertCtrl.bulkUpdate

    case GET(p"/datastore/$id" ? q_o"name=$name")    => attachmentCtrl.download(id, name)
    case GET(p"/datastorezip/$id" ? q_o"name=$name") => attachmentCtrl.downloadZip(id, name)

    case GET(p"/audit")                      => auditCtrl.search
    case POST(p"/audit/_search")             => auditCtrl.search
    case POST(p"/audit/_stats")              => auditCtrl.stats
    case GET(p"/audit")                      => auditCtrl.flow(None)
    case GET(p"/flow" ? q_o"rootId=$rootId") => auditCtrl.flow(rootId)

    case POST(p"/login")  => authenticationCtrl.login
    case GET(p"/logout")  => authenticationCtrl.logout
    case POST(p"/logout") => authenticationCtrl.logout

    case GET(p"/case/template")                    => caseTemplateCtrl.search
    case POST(p"/case/template/_search")           => caseTemplateCtrl.search
    case POST(p"/case/template/_stats")            => caseTemplateCtrl.stats
    case POST(p"/case/template")                   => caseTemplateCtrl.create
    case GET(p"/case/template/$caseTemplateId")    => caseTemplateCtrl.get(caseTemplateId)
    case PATCH(p"/case/template/$caseTemplateId")  => caseTemplateCtrl.update(caseTemplateId)
    case DELETE(p"/case/template/$caseTemplateId") => caseTemplateCtrl.delete(caseTemplateId)

    case POST(p"/case/task/log/_search")  => logCtrl.search
    case POST(p"/case/task/log/_stats")   => logCtrl.stats
    case POST(p"/case/task/$taskId/log")  => logCtrl.create(taskId)
    case PATCH(p"/case/task/log/$logId")  => logCtrl.update(logId)
    case DELETE(p"/case/task/log/$logId") => logCtrl.delete(logId)
    //case GET(p"/case/task/$taskId/log") => logCtrl.findInTask(taskId)
    //case POST(p"/case/task/$taskId/log/_search") => logCtrl.findInTask(taskId)
    //    case GET(p"/case/task/log/$logId") => logCtrl.get(logId)

    case GET(p"/case/task")                  => taskCtrl.search
    case POST(p"/case/task/_search")         => taskCtrl.search
    case POST(p"/case/task/_stats")          => taskCtrl.stats
    case POST(p"/case/$caseId/task")         => taskCtrl.create(caseId)
    case GET(p"/case/task/$taskId")          => taskCtrl.get(taskId)
    case PATCH(p"/case/task/$taskId")        => taskCtrl.update(taskId)
    case POST(p"/case/$caseId/task/_search") => taskCtrl.searchInCase(caseId)

    case POST(p"/case/artifact/_search")              => observableCtrl.search
    case POST(p"/case/artifact/_stats")               => observableCtrl.stats
    case POST(p"/case/$caseId/artifact")              => observableCtrl.createInCase(caseId)
    case GET(p"/case/artifact/$observableId")         => observableCtrl.get(observableId)
    case PATCH(p"/case/artifact/_bulk")               => observableCtrl.bulkUpdate
    case PATCH(p"/case/artifact/$observableId")       => observableCtrl.update(observableId)
    case DELETE(p"/case/artifact/$observableId")      => observableCtrl.delete(observableId)
    case POST(p"/alert/$alertId/artifact")            => observableCtrl.createInAlert(alertId)
    case GET(p"/alert/artifact/$observableId")        => observableCtrl.get(observableId)
    case PATCH(p"/alert/artifact/_bulk")              => observableCtrl.bulkUpdate
    case PATCH(p"/alert/artifact/$observableId")      => observableCtrl.update(observableId)
    case DELETE(p"/alert/artifact/$observableId")     => observableCtrl.delete(observableId)
    case GET(p"/case/artifact/$observableId/similar") => observableCtrl.findSimilar(observableId)
    //    case POST(p"/case/:caseId/artifact/_search")    => observableCtrl.findInCase(caseId)

    case GET(p"/case")                          => caseCtrl.search
    case POST(p"/case")                         => caseCtrl.create         // Audit ok
    case GET(p"/case/$caseId")                  => caseCtrl.get(caseId)
    case PATCH(p"/case/_bulk")                  => caseCtrl.bulkUpdate     // Not used by the frontend
    case PATCH(p"/case/$caseId")                => caseCtrl.update(caseId) // Audit ok
    case POST(p"/case/$caseId/_merge/$toMerge") => caseCtrl.merge(caseId, toMerge)
    case POST(p"/case/_search")                 => caseCtrl.search
    case POST(p"/case/_stats")                  => caseCtrl.stats
    case DELETE(p"/case/$caseId")               => caseCtrl.delete(caseId) // Not used by the frontend
    case DELETE(p"/case/$caseId/force")         => caseCtrl.delete(caseId) // Audit ok
    case GET(p"/case/$caseId/links")            => caseCtrl.linkedCases(caseId)

    case GET(p"/config/user")               => configCtrl.userList
    case GET(p"/config/user/$path")         => configCtrl.userGet(path)
    case PUT(p"/config/user/$path")         => configCtrl.userSet(path)
    case GET(p"/config/organisation")       => configCtrl.organisationList
    case GET(p"/config/organisation/$path") => configCtrl.organisationGet(path)
    case PUT(p"/config/organisation/$path") => configCtrl.organisationSet(path)
    case GET(p"/config")                    => configCtrl.list
    case GET(p"/config/$path")              => configCtrl.get(path)
    case PUT(p"/config/$path")              => configCtrl.set(path)

    case GET(p"/customField")           => customFieldCtrl.list
    case POST(p"/customFields/_search") => customFieldCtrl.search
    case POST(p"/customFields/_stats")  => customFieldCtrl.stats
    case POST(p"/customField")          => customFieldCtrl.create
    case GET(p"/customField/$id")       => customFieldCtrl.get(id)
    case PATCH(p"/customField/$id")     => customFieldCtrl.update(id)
    case DELETE(p"/customField/$id")    => customFieldCtrl.delete(id)
    case GET(p"/customFields/$id/use")  => customFieldCtrl.useCount(id)

    case GET(p"/dashboard")                 => dashboardCtrl.search
    case POST(p"/dashboard/_search")        => dashboardCtrl.search
    case POST(p"/dashboard/_stats")         => dashboardCtrl.stats
    case POST(p"/dashboard")                => dashboardCtrl.create
    case GET(p"/dashboard/$dashboardId")    => dashboardCtrl.get(dashboardId)
    case PATCH(p"/dashboard/$dashboardId")  => dashboardCtrl.update(dashboardId)
    case DELETE(p"/dashboard/$dashboardId") => dashboardCtrl.delete(dashboardId)

    case GET(p"/describe/_all")       => describeCtrl.describeAll
    case GET(p"/describe/$modelName") => describeCtrl.describe(modelName)

    case GET(p"/list")                    => listCtrl.list
    case POST(p"/list/$listName")         => listCtrl.addItem(listName)
    case GET(p"/list/$listName")          => listCtrl.listItems(listName)
    case PATCH(p"/list/$itemId")          => listCtrl.updateItem(itemId)
    case DELETE(p"/list/$itemId")         => listCtrl.deleteItem(itemId)
    case POST(p"/list/$listName/_exists") => listCtrl.itemExists(listName)

    case GET(p"/observable/type")              => observableTypeCtrl.search
    case POST(p"/observable/type/_search")     => observableTypeCtrl.search
    case POST(p"/observable/type/_stats")      => observableTypeCtrl.stats
    case POST(p"/observable/type")             => observableTypeCtrl.create
    case GET(p"/observable/type/$idOrName")    => observableTypeCtrl.get(idOrName)
    case DELETE(p"/observable/type/$idOrName") => observableTypeCtrl.delete(idOrName)

    case GET(p"/organisation")                                           => organisationCtrl.list
    case POST(p"/organisation/_search")                                  => organisationCtrl.search
    case POST(p"/organisation/_stats")                                   => organisationCtrl.stats
    case POST(p"/organisation")                                          => organisationCtrl.create
    case GET(p"/organisation/$organisationId")                           => organisationCtrl.get(organisationId)
    case PATCH(p"/organisation/$organisationId")                         => organisationCtrl.update(organisationId)
    case PUT(p"/organisation/$organisationId1/link/$organisationId2")    => organisationCtrl.link(organisationId1, organisationId2)
    case PUT(p"/organisation/$organisationId/links")                     => organisationCtrl.bulkLink(organisationId)
    case GET(p"/organisation/$organisationId/links")                     => organisationCtrl.listLinks(organisationId)
    case DELETE(p"/organisation/$organisationId1/link/$organisationId2") => organisationCtrl.unlink(organisationId1, organisationId2)

    case POST(p"/page/_search")      => pageCtrl.search
    case POST(p"/page/_stats")       => pageCtrl.stats
    case POST(p"/page")              => pageCtrl.create
    case GET(p"/page/$idOrTitle")    => pageCtrl.get(idOrTitle)
    case PATCH(p"/page/$idOrTitle")  => pageCtrl.update(idOrTitle)
    case DELETE(p"/page/$idOrTitle") => pageCtrl.delete(idOrTitle)

    case GET(p"/permission") => permissionCtrl.list

    case GET(p"/profile")               => profileCtrl.search
    case POST(p"/profile/_search")      => profileCtrl.search
    case POST(p"/profile/_stats")       => profileCtrl.stats
    case POST(p"/profile")              => profileCtrl.create
    case GET(p"/profile/$profileId")    => profileCtrl.get(profileId)
    case PATCH(p"/profile/$profileId")  => profileCtrl.update(profileId)
    case DELETE(p"/profile/$profileId") => profileCtrl.delete(profileId)

    case POST(p"/_stats") => statsCtrl.stats

    case GET(p"/status") => statusCtrl.get
    case GET(p"/health") => statusCtrl.health

    case POST(p"/stream")          => streamCtrl.create
    case GET(p"/stream/status")    => streamCtrl.status
    case GET(p"/stream/$streamId") => streamCtrl.get(streamId)

    case GET(p"/tag")          => tagCtrl.search
    case POST(p"/tag/_search") => tagCtrl.search
    case POST(p"/tag/_stats")  => tagCtrl.stats
    case GET(p"/tag/$id")      => tagCtrl.get(id)

    case GET(p"/user")                          => userCtrl.search
    case POST(p"/user/_search")                 => userCtrl.search
    case POST(p"/user/_stats")                  => userCtrl.stats
    case POST(p"/user")                         => userCtrl.create
    case GET(p"/user/current")                  => userCtrl.current
    case GET(p"/user/$userId")                  => userCtrl.get(userId)
    case PATCH(p"/user/$userId")                => userCtrl.update(userId)
    case DELETE(p"/user/$userId")               => userCtrl.lock(userId)
    case DELETE(p"/user/$userId/force")         => userCtrl.delete(userId)
    case POST(p"/user/$userId/password/set")    => userCtrl.setPassword(userId)
    case POST(p"/user/$userId/password/change") => userCtrl.changePassword(userId)
    case GET(p"/user/$userId/key")              => userCtrl.getKey(userId)
    case DELETE(p"/user/$userId/key")           => userCtrl.removeKey(userId)
    case POST(p"/user/$userId/key/renew")       => userCtrl.renewKey(userId)
  }
}

```

`thehive/app/org/thp/thehive/controllers/v0/ShareCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AuthorizationError, BadRequestError, EntityIdOrName, RichSeq}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.{InputShare, ObservablesFilter, TasksFilter}
import org.thp.thehive.models.Permissions
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services._
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class ShareCtrl @Inject() (
    entrypoint: Entrypoint,
    shareSrv: ShareSrv,
    organisationSrv: OrganisationSrv,
    caseSrv: CaseSrv,
    taskSrv: TaskSrv,
    observableSrv: ObservableSrv,
    profileSrv: ProfileSrv,
    implicit val db: Database
) {

  def shareCase(caseId: String): Action[AnyContent] =
    entrypoint("create case shares")
      .extract("shares", FieldsParser[InputShare].sequence.on("shares"))
      .authTransaction(db) { implicit request => implicit graph =>
        val inputShares: Seq[InputShare] = request.body("shares")
        caseSrv
          .get(EntityIdOrName(caseId))
          .can(Permissions.manageShare)
          .getOrFail("Case")
          .flatMap { `case` =>
            inputShares.toTry { inputShare =>
              for {
                organisation <-
                  organisationSrv
                    .get(request.organisation)
                    .visibleOrganisationsFrom
                    .get(EntityIdOrName(inputShare.organisationName))
                    .getOrFail("Organisation")
                profile   <- profileSrv.getOrFail(EntityIdOrName(inputShare.profile))
                share     <- shareSrv.shareCase(owner = false, `case`, organisation, profile)
                richShare <- shareSrv.get(share).richShare.getOrFail("Share")
                _         <- if (inputShare.tasks == TasksFilter.all) shareSrv.shareCaseTasks(share) else Success(Nil)
                _         <- if (inputShare.observables == ObservablesFilter.all) shareSrv.shareCaseObservables(share) else Success(Nil)
              } yield richShare
            }
          }
          .map(shares => Results.Ok(shares.toJson))
      }

  def removeShare(shareId: String): Action[AnyContent] =
    entrypoint("remove share")
      .authTransaction(db) { implicit request => implicit graph =>
        doRemoveShare(EntityIdOrName(shareId)).map(_ => Results.NoContent)
      }

  def removeShares(): Action[AnyContent] =
    entrypoint("remove share")
      .extract("shares", FieldsParser[String].sequence.on("ids"))
      .authTransaction(db) { implicit request => implicit graph =>
        val shareIds: Seq[String] = request.body("shares")
        shareIds.map(EntityIdOrName.apply).toTry(doRemoveShare(_)).map(_ => Results.NoContent)
      }

  def removeShares(caseId: String): Action[AnyContent] =
    entrypoint("remove share")
      .extract("organisations", FieldsParser[String].sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisations: Seq[String] = request.body("organisations")

        val organisationIds = organisations.map(o => organisationSrv.getId(EntityIdOrName(o)))
        if (organisationIds.contains(organisationSrv.currentId))
          Failure(BadRequestError("You cannot remove your own share"))
        else
          caseSrv
            .get(EntityIdOrName(caseId))
            .can(Permissions.manageShare)
            .shares
            .filter(_.organisation.getByIds(organisationIds: _*))
            .has(_.owner, false)
            ._id
            .toSeq
            .toTry(shareSrv.unshareCase)
            .map(_ => Results.NoContent)
      }

  def removeTaskShares(taskId: String): Action[AnyContent] =
    entrypoint("remove share tasks")
      .extract("organisations", FieldsParser[String].sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisations: Seq[String] = request.body("organisations")

        taskSrv
          .getOrFail(EntityIdOrName(taskId))
          .flatMap { task =>
            organisations.toTry { organisationName =>
              organisationSrv
                .getOrFail(EntityIdOrName(organisationName))
                .flatMap(shareSrv.unshareTask(task, _))
            }
          }
          .map(_ => Results.NoContent)
      }

  def removeObservableShares(observableId: String): Action[AnyContent] =
    entrypoint("remove share observables")
      .extract("organisations", FieldsParser[String].sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisations: Seq[String] = request.body("organisations")

        observableSrv
          .getOrFail(EntityIdOrName(observableId))
          .flatMap { observable =>
            organisations.toTry { organisationName =>
              organisationSrv
                .getOrFail(EntityIdOrName(organisationName))
                .flatMap(shareSrv.unshareObservable(observable, _))
            }
          }
          .map(_ => Results.NoContent)
      }

  private def doRemoveShare(shareId: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    if (!shareSrv.get(shareId).`case`.can(Permissions.manageShare).exists)
      Failure(AuthorizationError("You are not authorized to remove share"))
    else if (shareSrv.get(shareId).byOrganisation(authContext.organisation).exists)
      Failure(AuthorizationError("You can't remove your share"))
    else if (shareSrv.get(shareId).has(_.owner, true).exists)
      Failure(AuthorizationError("You can't remove initial shares"))
    else
      shareSrv.unshareCase(shareId)

  def updateShare(shareId: String): Action[AnyContent] =
    entrypoint("update share")
      .extract("profile", FieldsParser.string.on("profile"))
      .authTransaction(db) { implicit request => implicit graph =>
        val profile: String = request.body("profile")
        if (!shareSrv.get(EntityIdOrName(shareId)).`case`.can(Permissions.manageShare).exists)
          Failure(AuthorizationError("You are not authorized to remove share"))
        for {
          richShare <-
            shareSrv
              .get(EntityIdOrName(shareId))
              .filter(_.organisation.visibleOrganisationsTo.visible)
              .richShare
              .getOrFail("Share")
          profile <- profileSrv.getOrFail(EntityIdOrName(profile))
          _       <- shareSrv.updateProfile(richShare.share, profile)
        } yield Results.Ok
      }

  def listShareCases(caseId: String): Action[AnyContent] =
    entrypoint("list case shares")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val shares = caseSrv
          .get(EntityIdOrName(caseId))
          .shares
          .visible
          .filterNot(_.organisation.current)
          .richShare
          .toSeq

        Success(Results.Ok(shares.toJson))
      }

  def listShareTasks(caseId: String, taskId: String): Action[AnyContent] =
    entrypoint("list task shares")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val shares = caseSrv
          .get(EntityIdOrName(caseId))
          .can(Permissions.manageShare)
          .shares
          .filter(_.organisation.filterNot(_.get(request.organisation)).visible)
          .byTask(EntityIdOrName(taskId))
          .richShare
          .toSeq

        Success(Results.Ok(shares.toJson))
      }

  def listShareObservables(caseId: String, observableId: String): Action[AnyContent] =
    entrypoint("list observable shares")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val shares = caseSrv
          .get(EntityIdOrName(caseId))
          .can(Permissions.manageShare)
          .shares
          .filter(_.organisation.filterNot(_.get(request.organisation)).visible)
          .byObservable(EntityIdOrName(observableId))
          .richShare
          .toSeq

        Success(Results.Ok(shares.toJson))
      }

  def shareTask(taskId: String): Action[AnyContent] =
    entrypoint("share task")
      .extract("organisations", FieldsParser.string.sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisationIds: Seq[String] = request.body("organisations")

        for {
          task          <- taskSrv.getOrFail(EntityIdOrName(taskId))
          _             <- taskSrv.get(task).`case`.can(Permissions.manageShare).existsOrFail
          organisations <- organisationIds.map(EntityIdOrName(_)).toTry(organisationSrv.get(_).visible.getOrFail("Organisation"))
          _             <- shareSrv.addTaskShares(task, organisations)
        } yield Results.NoContent
      }

  def shareObservable(observableId: String): Action[AnyContent] =
    entrypoint("share observable")
      .extract("organisations", FieldsParser.string.sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisationIds: Seq[String] = request.body("organisations")
        for {
          observable    <- observableSrv.getOrFail(EntityIdOrName(observableId))
          _             <- observableSrv.get(observable).`case`.can(Permissions.manageShare).existsOrFail
          organisations <- organisationIds.map(EntityIdOrName(_)).toTry(organisationSrv.get(_).visible.getOrFail("Organisation"))
          _             <- shareSrv.addObservableShares(observable, organisations)
        } yield Results.NoContent
      }

}

```

`thehive/app/org/thp/thehive/controllers/v0/StatsCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.scalactic.Accumulation._
import org.thp.scalligraph.AttributeCheckingError
import org.thp.scalligraph.controllers.{Entrypoint, Field, FieldsParser}
import org.thp.scalligraph.models.Database
import play.api.Logger
import play.api.libs.json.JsObject
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}

@Singleton
class StatsCtrl @Inject() (
    entrypoint: Entrypoint,
    caseCtrl: CaseCtrl,
    taskCtrl: TaskCtrl,
    logCtrl: LogCtrl,
    alertCtrl: AlertCtrl,
    userCtrl: UserCtrl,
    caseTemplateCtrl: CaseTemplateCtrl,
    observableCtrl: ObservableCtrl,
    dashboardCtrl: DashboardCtrl,
    organisationCtrl: OrganisationCtrl,
    auditCtrl: AuditCtrl,
    profileCtrl: ProfileCtrl,
    tagCtrl: TagCtrl,
    pageCtrl: PageCtrl,
    queryExecutor: TheHiveQueryExecutor,
    db: Database
) {
  lazy val logger: Logger = Logger(getClass)

  def stats: Action[AnyContent] =
    entrypoint("stats")
      .extract("stats", FieldsParser[Field].sequence.on("stats"))
      .authRoTransaction(db) { implicit request => implicit graph =>
        val stats: Seq[Field] = request.body("stats")
        stats
          .validatedBy { s =>
            for {
              model <- FieldsParser.string(s.get("model"))
              queryCtrl: QueryCtrl = model match {
                case "case"          => caseCtrl
                case "case_task"     => taskCtrl
                case "case_task_log" => logCtrl
                case "alert"         => alertCtrl
                case "user"          => userCtrl
                case "caseTemplate"  => caseTemplateCtrl
                case "case_artifact" => observableCtrl
                case "dashboard"     => dashboardCtrl
                case "organisation"  => organisationCtrl
                case "audit"         => auditCtrl
                case "profile"       => profileCtrl
                case "tag"           => tagCtrl
                case "page"          => pageCtrl
              }
              queries <- queryCtrl.statsParser(s)
            } yield queries
          }
          .badMap(errors => AttributeCheckingError(errors.toSeq))
          .toTry
          .flatMap { queries =>
            queries
              .flatten
              .toTry(query => queryExecutor.execute(query, graph, request.authContext))
              .map { outputs =>
                val results = outputs
                  .map(_.toJson)
                  .foldLeft(JsObject.empty) {
                    case (acc, o: JsObject) => acc deepMerge o
                    case (acc, r) =>
                      logger.warn(s"Invalid stats result: $r")
                      acc
                  }
                Results.Ok(results)
              }
          }
      }
}

```

`thehive/app/org/thp/thehive/controllers/v0/StatusCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.auth.{AuthCapability, AuthSrv, MultiAuthSrv}
import org.thp.scalligraph.controllers.Entrypoint
import org.thp.scalligraph.models.{Database, UpdatableSchema}
import org.thp.scalligraph.services.config.ApplicationConfig.finiteDurationFormat
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.{EntityName, ScalligraphApplicationLoader}
import org.thp.thehive.TheHiveModule
import org.thp.thehive.models.{HealthStatus, User}
import org.thp.thehive.services.{Connector, UserSrv}
import play.api.libs.json.{JsObject, JsString, Json}
import play.api.mvc.{AbstractController, Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.collection.immutable
import scala.concurrent.duration.FiniteDuration
import scala.util.Success

@Singleton
class StatusCtrl @Inject() (
    entrypoint: Entrypoint,
    appConfig: ApplicationConfig,
    authSrv: AuthSrv,
    userSrv: UserSrv,
    connectors: immutable.Set[Connector],
    schemas: immutable.Set[UpdatableSchema],
    db: Database
) {

  val passwordConfig: ConfigItem[String, String] = appConfig.item[String]("datastore.attachment.password", "Password used to protect attachment ZIP")
  def password: String                           = passwordConfig.get
  val streamPollingDurationConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("stream.longPolling.pollingDuration", "amount of time the UI have to wait before polling the stream")
  def streamPollingDuration: FiniteDuration = streamPollingDurationConfig.get

  val tagsDefaultColourConfig = appConfig.item[String]("tags.freeTagColour", "Default free tag colour")

  private def getVersion(c: Class[_]): String = Option(c.getPackage.getImplementationVersion).getOrElse("SNAPSHOT")

  def get: Action[AnyContent] =
    entrypoint("status") { _ =>
      Success(
        Results.Ok(
          Json.obj(
            "versions" -> Json.obj(
              "Scalligraph" -> getVersion(classOf[ScalligraphApplicationLoader]),
              "TheHive"     -> getVersion(classOf[TheHiveModule]),
              "Play"        -> getVersion(classOf[AbstractController])
            ),
            "connectors" -> JsObject(connectors.map(c => c.name -> c.status).toSeq),
            "config" -> Json.obj(
              "protectDownloadsWith" -> password,
              "authType" -> (authSrv match {
                case multiAuthSrv: MultiAuthSrv => Json.toJson(multiAuthSrv.providerNames)
                case _                          => JsString(authSrv.name)
              }),
              "capabilities"    -> authSrv.capabilities.map(c => JsString(c.toString)),
              "ssoAutoLogin"    -> authSrv.capabilities.contains(AuthCapability.sso),
              "pollingDuration" -> streamPollingDuration.toMillis,
              "freeTagDefaultColour" -> tagsDefaultColourConfig.get
            ),
            "schemaStatus" -> schemas.flatMap(_.schemaStatus).map { schemaStatus =>
              Json.obj(
                "name"            -> schemaStatus.name,
                "currentVersion"  -> schemaStatus.currentVersion,
                "expectedVersion" -> schemaStatus.expectedVersion,
                "error"           -> schemaStatus.error.map(_.getMessage)
              )
            }
          )
        )
      )
    }

  def health: Action[AnyContent] =
    entrypoint("health") { _ =>
      val dbStatus = db
        .roTransaction(graph => userSrv.getOrFail(EntityName(User.system.login))(graph))
        .fold(_ => HealthStatus.Error, _ => HealthStatus.Ok)
      val connectorStatus = connectors.map(c => c.health)
      val distinctStatus  = connectorStatus + dbStatus
      val globalStatus =
        if (distinctStatus.contains(HealthStatus.Ok))
          if (distinctStatus.size > 1) HealthStatus.Warning else HealthStatus.Ok
        else if (distinctStatus.contains(HealthStatus.Error)) HealthStatus.Error
        else HealthStatus.Warning

      Success(Results.Ok(globalStatus.toString))
    }
}

```

`thehive/app/org/thp/thehive/controllers/v0/StreamCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.apache.tinkerpop.gremlin.process.traversal.Order
import org.thp.scalligraph.auth.{ExpirationStatus, SessionAuthSrv}
import org.thp.scalligraph.controllers.Entrypoint
import org.thp.scalligraph.models.{Database, Schema}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services._
import play.api.libs.json.{JsArray, JsObject, Json}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.Success

@Singleton
class StreamCtrl @Inject() (
    entrypoint: Entrypoint,
    streamSrv: StreamSrv,
    auditSrv: AuditSrv,
    val caseSrv: CaseSrv,
    val taskSrv: TaskSrv,
    val userSrv: UserSrv,
    implicit val db: Database,
    implicit val schema: Schema,
    implicit val ec: ExecutionContext
) extends AuditRenderer {

  def create: Action[AnyContent] =
    entrypoint("create stream")
      .auth { implicit request =>
        val streamId = streamSrv.create
        Success(Results.Ok(streamId))
      }

  def get(streamId: String): Action[AnyContent] =
    entrypoint("get stream").async { request =>
      if (SessionAuthSrv.isExpired(request))
        Future.successful(Results.Unauthorized)
      else
        streamSrv
          .get(streamId)
          .map {
            case auditIds if auditIds.nonEmpty =>
              db.roTransaction { implicit graph =>
                val audits = auditSrv
                  .getMainByIds(Order.desc, auditIds: _*)
                  .richAuditWithCustomRenderer(auditRenderer)
                  .toIterator
                  .map {
                    case (audit, obj) =>
                      audit
                        .toJson
                        .as[JsObject]
                        .deepMerge(
                          Json.obj(
                            "base"    -> Json.obj("object" -> obj, "rootId" -> audit.context._id),
                            "summary" -> jsonSummary(auditSrv, audit.requestId)
                          )
                        )
                  }
                if (SessionAuthSrv.isWarning(request))
                  new Results.Status(220)(JsArray(audits.toSeq))
                else
                  Results.Ok(JsArray(audits.toSeq))
              }
            case _ if SessionAuthSrv.isWarning(request) => new Results.Status(220)(JsArray.empty)
            case _                                      => Results.Ok(JsArray.empty)
          }
    }

  def status: Action[AnyContent] =
    entrypoint("get stream") { request =>
      val status = SessionAuthSrv.expirationStatus(request) match {
        case Some(ExpirationStatus.Ok(remaining))      => Json.obj("warning" -> false, "remaining" -> remaining.toMillis)
        case Some(ExpirationStatus.Warning(remaining)) => Json.obj("warning" -> true, "remaining" -> remaining.toMillis)
        case Some(ExpirationStatus.Error)              => Json.obj("warning" -> true, "remaining" -> 0)
        case None                                      => Json.obj("warning" -> false, "remaining" -> 1)
      }
      Success(Results.Ok(status))
    }
}

```

`thehive/app/org/thp/thehive/controllers/v0/TagCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.apache.tinkerpop.gremlin.process.traversal.Order
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, Renderer}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, IteratorOutput, Traversal}
import org.thp.scalligraph.utils.FunctionalCondition.When
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.models.Tag
import org.thp.thehive.services.TagOps._
import org.thp.thehive.services.{OrganisationSrv, TagSrv}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}

class TagCtrl @Inject() (
    override val entrypoint: Entrypoint,
    override val db: Database,
    tagSrv: TagSrv,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicTag
) extends QueryCtrl {

  def get(tagId: String): Action[AnyContent] =
    entrypoint("get tag")
      .authRoTransaction(db) { _ => implicit graph =>
        tagSrv
          .getOrFail(EntityIdOrName(tagId))
          .map { tag =>
            Results.Ok(tag.toJson)
          }
      }
}

case class TagHint(freeTag: Option[String], namespace: Option[String], predicate: Option[String], value: Option[String], limit: Option[Long])

@Singleton
class PublicTag @Inject() (tagSrv: TagSrv, organisationSrv: OrganisationSrv) extends PublicData {
  override val entityName: String = "tag"
  override val initialQuery: Query =
    Query.init[Traversal.V[Tag]]("listTag", (graph, authContext) => tagSrv.startTraversal(graph).visible(authContext))
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Tag], IteratorOutput](
      "page",
      (range, tagSteps, _) => tagSteps.page(range.from, range.to, withTotal = true, limitedCountThreshold)
    )
  override val outputQuery: Query = Query.output[Tag with Entity]
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Tag]](
    "getTag",
    (idOrName, graph, _) => tagSrv.get(idOrName)(graph)
  )
  implicit val stringRenderer: Renderer[String] = Renderer.toJson[String, String](identity)
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[Tag], Traversal.V[Tag]]("fromCase", (tagSteps, _) => tagSteps.fromCase),
    Query[Traversal.V[Tag], Traversal.V[Tag]]("fromObservable", (tagSteps, _) => tagSteps.fromObservable),
    Query[Traversal.V[Tag], Traversal.V[Tag]]("fromAlert", (tagSteps, _) => tagSteps.fromAlert),
    Query.initWithParam[TagHint, Traversal[String, Vertex, Converter[String, Vertex]]](
      "tagAutoComplete",
      (tagHint, graph, authContext) =>
        tagHint
          .freeTag
          .fold(tagSrv.startTraversal(graph).autoComplete(tagHint.namespace, tagHint.predicate, tagHint.value)(authContext).visible(authContext))(
            tagSrv.startTraversal(graph).autoComplete(organisationSrv, _)(authContext).sort(_.by("predicate", Order.asc))
          )
          .merge(tagHint.limit)(_.limit(_))
          .displayName
    ),
    Query[Traversal.V[Tag], Traversal[String, Vertex, Converter[String, Vertex]]]("text", (tagSteps, _) => tagSteps.displayName),
    Query.output[String, Traversal[String, Vertex, Converter[String, Vertex]]]
  )
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[Tag]
    .property("namespace", UMapping.string)(_.field.readonly)
    .property("predicate", UMapping.string)(_.field.readonly)
    .property("value", UMapping.string.optional)(_.field.readonly)
    .property("description", UMapping.string.optional)(_.field.readonly)
    .property("text", UMapping.string)(
      _.select(_.displayName)
        .filter[String] {
          case (_, tags, authContext, Right(predicate)) => tags.freetags(organisationSrv)(authContext).has(_.predicate, predicate)
          case (_, tags, _, Left(true))                 => tags
          case (_, tags, _, Left(false))                => tags.empty
        }
        .readonly
    )
    .build
}

```

`thehive/app/org/thp/thehive/controllers/v0/TaskCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.controllers._
import org.thp.scalligraph.models.{Database, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.scalligraph.{EntityIdOrName, RichOptionTry}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputTask
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services._
import play.api.libs.json.Json
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}

@Singleton
class TaskCtrl @Inject() (
    override val entrypoint: Entrypoint,
    override val db: Database,
    taskSrv: TaskSrv,
    caseSrv: CaseSrv,
    organisationSrv: OrganisationSrv,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicTask
) extends QueryCtrl {

  def create(caseId: String): Action[AnyContent] =
    entrypoint("create task")
      .extract("task", FieldsParser[InputTask])
      .authTransaction(db) { implicit request => implicit graph =>
        val inputTask: InputTask = request.body("task")
        for {
          case0       <- caseSrv.get(EntityIdOrName(caseId)).can(Permissions.manageTask).getOrFail("Case")
          createdTask <- caseSrv.createTask(case0, inputTask.toTask)
        } yield Results.Created(createdTask.toJson)
      }

  def get(taskId: String): Action[AnyContent] =
    entrypoint("get task")
      .authRoTransaction(db) { implicit request => implicit graph =>
        taskSrv
          .get(EntityIdOrName(taskId))
          .visible(organisationSrv)
          .richTask
          .getOrFail("Task")
          .map { task =>
            Results.Ok(task.toJson)
          }
      }

  def update(taskId: String): Action[AnyContent] =
    entrypoint("update task")
      .extract("task", FieldsParser.update("task", publicData.publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("task")
        taskSrv
          .update(
            _.get(EntityIdOrName(taskId))
              .can(Permissions.manageTask),
            propertyUpdaters
          )
          .flatMap {
            case (taskSteps, _) =>
              taskSteps
                .richTask
                .getOrFail("Task")
                .map(richTask => Results.Ok(richTask.toJson))
          }
      }

  def searchInCase(caseId: String): Action[AnyContent] = {
    val query = Query.init[Traversal.V[Task]](
      "tasksInCase",
      (graph, authContext) =>
        caseSrv
          .get(EntityIdOrName(caseId))(graph)
          .visible(organisationSrv)(authContext)
          ._id
          .headOption
          .fold[Traversal.V[Task]](graph.empty)(c => taskSrv.startTraversal(graph).relatedTo(c))
    )
    entrypoint("search task in case")
      .extract("query", searchParser(query))
      .auth { implicit request =>
        val query: Query = request.body("query")
        queryExecutor.execute(query, request)
      }
  }
}

@Singleton
class PublicTask @Inject() (taskSrv: TaskSrv, organisationSrv: OrganisationSrv, userSrv: UserSrv) extends PublicData {
  override val entityName: String = "task"
  override val initialQuery: Query =
    Query.init[Traversal.V[Task]](
      "listTask",
      (graph, authContext) => taskSrv.startTraversal(graph).visible(organisationSrv)(authContext)
    )
  //organisationSrv.get(authContext.organisation)(graph).shares.tasks)
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Task], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, _, 0), taskSteps, _) =>
          taskSteps.richPage(from, to, withTotal = true, limitedCountThreshold)(_.richTask.domainMap(_ -> (None: Option[RichCase])))
        case (OutputParam(from, to, _, _), taskSteps, authContext) =>
          taskSteps.richPage(from, to, withTotal = true, limitedCountThreshold)(
            _.richTaskWithCustomRenderer(
              _.`case`.richCase(authContext).domainMap(c => Some(c): Option[RichCase])
            )
          )
      }
    )
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Task]](
    "getTask",
    (idOrName, graph, authContext) => taskSrv.get(idOrName)(graph).inOrganisation(organisationSrv.currentId(graph, authContext))
  )
  override val outputQuery: Query =
    Query.outputWithContext[RichTask, Traversal.V[Task]]((taskSteps, _) => taskSteps.richTask)
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query.output[(RichTask, Option[RichCase])],
    Query[Traversal.V[Task], Traversal.V[User]]("assignableUsers", (taskSteps, authContext) => taskSteps.assignableUsers(authContext)),
    Query.init[Traversal.V[Task]](
      "waitingTasks",
      (graph, authContext) =>
        taskSrv.startTraversal(graph).has(_.status, TaskStatus.Waiting).inOrganisation(organisationSrv.currentId(graph, authContext))
    ),
    Query.init[Traversal.V[Task]]( // DEPRECATED
      "waitingTask",
      (graph, authContext) =>
        taskSrv.startTraversal(graph).has(_.status, TaskStatus.Waiting).inOrganisation(organisationSrv.currentId(graph, authContext))
    ),
    Query.init[Traversal.V[Task]](
      "myTasks",
      (graph, authContext) =>
        taskSrv
          .startTraversal(graph)
          .assignTo(authContext.userId)
          .inOrganisation(organisationSrv.currentId(graph, authContext))
    ),
    Query[Traversal.V[Task], Traversal.V[Log]]("logs", (taskSteps, _) => taskSteps.logs),
    Query[Traversal.V[Task], Traversal.V[Case]]("case", (taskSteps, _) => taskSteps.`case`),
    Query[Traversal.V[Task], Traversal.V[CaseTemplate]]("caseTemplate", (taskSteps, _) => taskSteps.caseTemplate),
    Query[Traversal.V[Task], Traversal.V[Organisation]]("organisations", (taskSteps, authContext) => taskSteps.organisations.visible(authContext))
  )
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[Task]
    .property("title", UMapping.string)(_.field.updatable)
    .property("description", UMapping.string.optional)(_.field.updatable)
    .property("status", UMapping.enum[TaskStatus.type])(_.field.custom { (_, value, vertex, graph, authContext) =>
      for {
        task <- taskSrv.get(vertex)(graph).getOrFail("Task")
        _    <- taskSrv.updateStatus(task, value)(graph, authContext)
      } yield Json.obj("status" -> value)
    })
    .property("flag", UMapping.boolean)(_.field.updatable)
    .property("startDate", UMapping.date.optional)(_.field.updatable)
    .property("endDate", UMapping.date.optional)(_.field.updatable)
    .property("order", UMapping.int)(_.field.updatable)
    .property("dueDate", UMapping.date.optional)(_.field.updatable)
    .property("group", UMapping.string)(_.field.updatable)
    .property("owner", UMapping.string.optional)(
      _.select(_.assignee.value(_.login))
        .custom { (_, login: Option[String], vertex, graph, authContext) =>
          for {
            task <- taskSrv.get(vertex)(graph).getOrFail("Task")
            user <- login.map(l => userSrv.getOrFail(EntityIdOrName(l))(graph)).flip
            _ <- user match {
              case Some(u) => taskSrv.assign(task, u)(graph, authContext)
              case None    => taskSrv.unassign(task)(graph, authContext)
            }
          } yield Json.obj("owner" -> user.map(_.login))
        }
    )
    .build

}

```

`thehive/app/org/thp/thehive/controllers/v0/TheHiveQueryExecutor.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.apache.tinkerpop.gremlin.structure.Vertex
import org.scalactic.Good
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.{FObject, Field, FieldsParser}
import org.thp.scalligraph.models._
import org.thp.scalligraph.query._
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.Traversal
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.utils.RichType
import org.thp.scalligraph.{BadRequestError, EntityId, GlobalQueryExecutor}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.TaskOps._

import javax.inject.{Inject, Provider, Singleton}
import scala.reflect.runtime.{universe => ru}

case class OutputParam(from: Long, to: Long, withStats: Boolean, withParents: Int)

object OutputParam {
  implicit val parser: FieldsParser[OutputParam] = FieldsParser[OutputParam]("OutputParam") {
    case (_, field: FObject) =>
      for {
        from        <- FieldsParser.long.on("from")(field)
        to          <- FieldsParser.long.on("to")(field)
        withStats   <- FieldsParser.boolean.optional.on("withStats")(field)
        withParents <- FieldsParser.int.optional.on("withParents")(field)
      } yield OutputParam(from, to, withStats.getOrElse(false), withParents.getOrElse(0))
  }
}

@Singleton
class TheHiveQueryExecutor @Inject() (
    override val db: Database,
    appConfig: ApplicationConfig,
    alert: PublicAlert,
    audit: PublicAudit,
    `case`: PublicCase,
    caseTemplate: PublicCaseTemplate,
    customField: PublicCustomField,
    observableType: PublicObservableType,
    dashboard: PublicDashboard,
    log: PublicLog,
    observable: PublicObservable,
    organisation: PublicOrganisation,
    page: PublicPage,
    profile: PublicProfile,
    tag: PublicTag,
    task: PublicTask,
    user: PublicUser
) extends QueryExecutor {

  lazy val publicDatas: Seq[PublicData] =
    Seq(alert, audit, `case`, caseTemplate, customField, dashboard, log, observable, observableType, organisation, page, profile, tag, task, user)

  val limitedCountThresholdConfig: ConfigItem[Long, Long] = appConfig.item[Long]("query.limitedCountThreshold", "Maximum number returned by a count")
  override val limitedCountThreshold: Long                = limitedCountThresholdConfig.get

  def metaProperties: PublicProperties =
    PublicPropertyListBuilder
      .forType[Product](_ => true)
      .property("createdBy", UMapping.string)(_.rename("_createdBy").readonly)
      .property("createdAt", UMapping.date)(_.rename("_createdAt").readonly)
      .property("updatedBy", UMapping.string.optional)(_.rename("_updatedBy").readonly)
      .property("updatedAt", UMapping.date.optional)(_.rename("_updatedAt").readonly)
      .build

  override lazy val publicProperties: PublicProperties = publicDatas.foldLeft(metaProperties)(_ ++ _.publicProperties)

  val childTypes: PartialFunction[(ru.Type, String), ru.Type] = {
    case (tpe, "case_task_log") if SubType(tpe, ru.typeOf[Traversal.V[Task]])             => ru.typeOf[Traversal.V[Log]]
    case (tpe, "case_task") if SubType(tpe, ru.typeOf[Traversal.V[Case]])                 => ru.typeOf[Traversal.V[Task]]
    case (tpe, "case_artifact") if SubType(tpe, ru.typeOf[Traversal.V[Case]])             => ru.typeOf[Traversal.V[Observable]]
    case (tpe, "alert_artifact") if SubType(tpe, ru.typeOf[Traversal.V[Alert]])           => ru.typeOf[Traversal.V[Observable]]
    case (tpe, "caseTemplate_task") if SubType(tpe, ru.typeOf[Traversal.V[CaseTemplate]]) => ru.typeOf[Traversal.V[Task]]
  }
  val parentTypes: PartialFunction[(ru.Type, String), ru.Type] = {
    case (tpe, "caseTemplate") if SubType(tpe, ru.typeOf[Traversal.V[Task]]) => ru.typeOf[Traversal.V[CaseTemplate]]
    case (tpe, _) if SubType(tpe, ru.typeOf[Traversal.V[Task]])              => ru.typeOf[Traversal.V[Case]]
    case (tpe, "alert") if SubType(tpe, ru.typeOf[Traversal.V[Observable]])  => ru.typeOf[Traversal.V[Alert]]
    case (tpe, _) if SubType(tpe, ru.typeOf[Traversal.V[Observable]])        => ru.typeOf[Traversal.V[Case]]
    case (tpe, _) if SubType(tpe, ru.typeOf[Traversal.V[Log]])               => ru.typeOf[Traversal.V[Task]]
  }
  override val customFilterQuery: FilterQuery = FilterQuery(publicProperties) { (tpe, globalParser) =>
    FieldsParser("parentChildFilter") {
      case (_, FObjOne("_parent", ParentIdFilter(parentId, parentType))) if parentTypes.isDefinedAt((tpe, parentType)) =>
        Good(new ParentIdInputFilter(parentId))
      case (path, FObjOne("_parent", ParentQueryFilter(parentType, parentFilterField))) if parentTypes.isDefinedAt((tpe, parentType)) =>
        globalParser(parentTypes((tpe, parentType))).apply(path, parentFilterField).map(query => new ParentQueryInputFilter(parentType, query))
      case (path, FObjOne("_child", ChildQueryFilter(childType, childQueryField))) if childTypes.isDefinedAt((tpe, childType)) =>
        globalParser(childTypes((tpe, childType))).apply(path, childQueryField).map(query => new ChildQueryInputFilter(childType, query))
    }
  }

  override lazy val queries: Seq[ParamQuery[_]] =
    publicDatas.map(_.initialQuery) ++
      publicDatas.map(_.getQuery) ++
      publicDatas.map(_.pageQuery(limitedCountThreshold)) ++ // FIXME the value of limitedCountThreshold is read only once. The value is not updated.
      publicDatas.map(_.outputQuery) ++
      publicDatas.flatMap(_.extraQueries) :+
      new Query {
        override val name: String = "audits"
        override def checkFrom(t: ru.Type): Boolean =
          RichType.getTypeArgs(t, ru.typeOf[Traversal[_, _, _]]).drop(1).headOption.exists(_ =:= ru.typeOf[Vertex])
        override def toType(t: ru.Type): ru.Type                                                     = ru.typeOf[Traversal.V[Audit]]
        override def apply(param: Unit, fromType: ru.Type, from: Any, authContext: AuthContext): Any = from.asInstanceOf[Traversal.V[Any]].audits
      } :+
      new Query {
        override val name: String = "auditsFromContext"
        override def checkFrom(t: ru.Type): Boolean =
          RichType.getTypeArgs(t, ru.typeOf[Traversal[_, _, _]]).drop(1).headOption.exists(_ =:= ru.typeOf[Vertex])
        override def toType(t: ru.Type): ru.Type = ru.typeOf[Traversal.V[Audit]]
        override def apply(param: Unit, fromType: ru.Type, from: Any, authContext: AuthContext): Any =
          from.asInstanceOf[Traversal.V[Any]].auditsFromContext
      }
  override val version: (Int, Int) = 0 -> 0
}

object ParentIdFilter {

  def unapply(field: Field): Option[(String, String)] =
    FieldsParser
      .string
      .on("_type")
      .andThen("parentId")(FieldsParser.string.on("_id"))((_, _))
      .apply(field)
      .fold(Some(_), _ => None)
}

class ParentIdInputFilter(parentId: String) extends InputQuery[Traversal.Unk, Traversal.Unk] {
  override def apply(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Unk =
    RichType
      .getTypeArgs(traversalType, ru.typeOf[Traversal[_, _, _]])
      .headOption
      .collect {
        case t if t <:< ru.typeOf[Task] =>
          traversal
            .asInstanceOf[Traversal.V[Task]]
            .has(_.relatedId, EntityId.read(parentId))
            .asInstanceOf[Traversal.Unk]
        case t if t <:< ru.typeOf[Observable] =>
          traversal
            .asInstanceOf[Traversal.V[Observable]]
            .has(_.relatedId, EntityId.read(parentId))
            .asInstanceOf[Traversal.Unk]
        case t if t <:< ru.typeOf[Log] =>
          traversal
            .asInstanceOf[Traversal.V[Log]]
            .has(_.taskId, EntityId.read(parentId))
            .asInstanceOf[Traversal.Unk]
      }
      .getOrElse(throw BadRequestError(s"$traversalType hasn't parent"))
}

object ParentQueryFilter {

  def unapply(field: Field): Option[(String, Field)] =
    FieldsParser
      .string
      .on("_type")
      .map("parentQuery")(parentType => (parentType, field.get("_query")))
      .apply(field)
      .fold(Some(_), _ => None)
}

class ParentQueryInputFilter(parentType: String, parentFilter: InputQuery[Traversal.Unk, Traversal.Unk])
    extends InputQuery[Traversal.Unk, Traversal.Unk] {
  override def apply(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Unk = {
    def filter[F, T: ru.TypeTag](t: Traversal.V[F] => Traversal.V[T]): Traversal.Unk =
      traversal.filter(parent =>
        parentFilter(
          publicProperties,
          ru.typeOf[Traversal.V[T]],
          t(parent.asInstanceOf[Traversal.V[F]]).asInstanceOf[Traversal.Unk],
          authContext
        )
      )

    RichType
      .getTypeArgs(traversalType, ru.typeOf[Traversal[_, _, _]])
      .headOption
      .collect {
        case t if t <:< ru.typeOf[Task] && parentType == "caseTemplate" => filter[Task, CaseTemplate](_.caseTemplate)
        case t if t <:< ru.typeOf[Task]                                 => filter[Task, Case](_.`case`)
        case t if t <:< ru.typeOf[Observable] && parentType == "alert"  => filter[Observable, Alert](_.alert)
        case t if t <:< ru.typeOf[Observable]                           => filter[Observable, Case](_.`case`)
        case t if t <:< ru.typeOf[Log]                                  => filter[Log, Task](_.task)
      }
      .getOrElse(throw BadRequestError(s"$traversalType hasn't parent"))
  }
}

object ChildQueryFilter {
  def unapply(field: Field): Option[(String, Field)] =
    FieldsParser
      .string
      .on("_type")
      .map("childQuery")(childType => (childType, field.get("_query")))
      .apply(field)
      .fold(Some(_), _ => None)
}

class ChildQueryInputFilter(childType: String, childFilter: InputQuery[Traversal.Unk, Traversal.Unk])
    extends InputQuery[Traversal.Unk, Traversal.Unk] {
  override def apply(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Unk = {
    def filter[F, T: ru.TypeTag](t: Traversal.V[F] => Traversal.V[T]): Traversal.Unk =
      traversal.filter(child =>
        childFilter(
          publicProperties,
          ru.typeOf[Traversal.V[T]],
          t(child.asInstanceOf[Traversal.V[F]]).asInstanceOf[Traversal.Unk],
          authContext
        )
      )

    RichType
      .getTypeArgs(traversalType, ru.typeOf[Traversal[_, _, _]])
      .headOption
      .collect {
        case t if t <:< ru.typeOf[Case] && childType == "case_task"                 => filter[Case, Task](_.tasks(authContext))
        case t if t <:< ru.typeOf[Case] && childType == "case_artifact"             => filter[Case, Observable](_.observables(authContext))
        case t if t <:< ru.typeOf[Task] && childType == "case_task_log"             => filter[Task, Log](_.logs)
        case t if t <:< ru.typeOf[Alert] && childType == "alert_artifact"           => filter[Alert, Observable](_.observables)
        case t if t <:< ru.typeOf[CaseTemplate] && childType == "caseTemplate_task" => filter[CaseTemplate, Task](_.tasks)
      }
      .getOrElse(throw BadRequestError(s"$traversalType hasn't child $childType"))
  }
}

@Singleton
class QueryExecutorVersion0Provider @Inject() (globalQueryExecutor: GlobalQueryExecutor) extends Provider[QueryExecutor] {
  override def get(): QueryExecutor = globalQueryExecutor.get(0)
}

```

`thehive/app/org/thp/thehive/controllers/v0/UserCtrl.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.apache.tinkerpop.gremlin.process.traversal.P
import org.thp.scalligraph.auth.AuthSrv
import org.thp.scalligraph.controllers.{Entrypoint, FString, FieldsParser}
import org.thp.scalligraph.models.{Database, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.scalligraph.{AuthorizationError, EntityIdOrName, EntityName, InvalidFormatAttributeError, RichOptionTry}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputUser
import org.thp.thehive.models._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.libs.json.Json
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Named, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class UserCtrl @Inject() (
    override val entrypoint: Entrypoint,
    userSrv: UserSrv,
    profileSrv: ProfileSrv,
    authSrv: AuthSrv,
    organisationSrv: OrganisationSrv,
    auditSrv: AuditSrv,
    override val db: Database,
    @Named("v0") override val queryExecutor: QueryExecutor,
    override val publicData: PublicUser
) extends QueryCtrl {
  def current: Action[AnyContent] =
    entrypoint("current user")
      .authRoTransaction(db) { implicit request => implicit graph =>
        userSrv
          .current
          .richUser
          .getOrFail("User")
          .orElse(
            userSrv
              .current
              .richUser(request, EntityName(Organisation.administration.name))
              .getOrFail("User")
          )
          .map(user => Results.Ok(user.toJson).withHeaders("X-Organisation" -> request.organisation.toString))
          .recover { case _ => Results.Unauthorized.withHeaders("X-Logout" -> "1") }
      }

  def create: Action[AnyContent] =
    entrypoint("create user")
      .extract("user", FieldsParser[InputUser])
      .auth { implicit request =>
        val inputUser: InputUser = request.body("user")
        db.tryTransaction { implicit graph =>
          val organisationIdOrName = inputUser.organisation.map(EntityIdOrName(_)).getOrElse(request.organisation)
          for {
            _            <- userSrv.current.organisations(Permissions.manageUser).get(organisationIdOrName).existsOrFail
            organisation <- organisationSrv.getOrFail(organisationIdOrName)
            profile <-
              if (inputUser.roles.contains("admin")) profileSrv.getOrFail(EntityName(Profile.admin.name))
              else if (inputUser.roles.contains("write")) profileSrv.getOrFail(EntityName(Profile.analyst.name))
              else if (inputUser.roles.contains("read")) profileSrv.getOrFail(EntityName(Profile.readonly.name))
              else profileSrv.getOrFail(EntityName(Profile.readonly.name))
            user <- userSrv.addOrCreateUser(inputUser.toUser, inputUser.avatar, organisation, profile)
          } yield user -> userSrv.canSetPassword(user.user)
        }.flatMap {
          case (user, true) =>
            inputUser
              .password
              .map(password => authSrv.setPassword(user.login, password))
              .flip
              .map(_ => Results.Created(user.toJson))
          case (user, _) => Success(Results.Created(user.toJson))
        }
      }

  def lock(userId: String): Action[AnyContent] =
    entrypoint("lock user")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          user <- userSrv.current.organisations(Permissions.manageUser).users.get(EntityIdOrName(userId)).getOrFail("User")
          _    <- userSrv.lock(user)
        } yield Results.NoContent
      }

  def delete(userId: String): Action[AnyContent] =
    entrypoint("delete user")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          organisation <- userSrv.current.organisations(Permissions.manageUser).get(request.organisation).getOrFail("Organisation")
          user         <- organisationSrv.get(organisation).users.get(EntityIdOrName(userId)).getOrFail("User")
          _            <- userSrv.delete(user, organisation)
        } yield Results.NoContent
      }

  def get(userId: String): Action[AnyContent] =
    entrypoint("get user")
      .authRoTransaction(db) { implicit request => implicit graph =>
        userSrv
          .get(EntityIdOrName(userId))
          .visible
          .richUser
          .getOrFail("User")
          .map(user => Results.Ok(user.toJson))
      }

  def update(userId: String): Action[AnyContent] =
    entrypoint("update user")
      .extract("user", FieldsParser.update("user", publicData.publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("user")
        for {
          user <-
            userSrv
              .update(userSrv.get(EntityIdOrName(userId)), propertyUpdaters) // Authorisation is managed in public properties
              .flatMap { case (user, _) => user.richUser.getOrFail("User") }
        } yield Results.Ok(user.toJson)
      }

  def setPassword(userId: String): Action[AnyContent] =
    entrypoint("set password")
      .extract("password", FieldsParser[String].on("password"))
      .auth { implicit request =>
        for {
          user <- db.roTransaction { implicit graph =>
            if (
              userSrv
                .get(EntityIdOrName(userId))
                .organisations
                .filterNot(_.users(Permissions.manageUser).current)
                .exists && !userSrv.current.organisations(Permissions.manageUser).isAdmin
            ) Failure(AuthorizationError("You are not authorized to set password of this user"))
            else
              userSrv
                .get(EntityIdOrName(userId))
                .getOrFail("User")
          }
          _ <- authSrv.setPassword(userId, request.body("password"))
          _ <- db.tryTransaction(implicit graph => auditSrv.user.update(user, Json.obj("password" -> "<hidden>")))
        } yield Results.NoContent
      }

  def changePassword(userId: String): Action[AnyContent] =
    entrypoint("change password")
      .extract("password", FieldsParser[String].on("password"))
      .extract("currentPassword", FieldsParser[String].on("currentPassword"))
      .auth { implicit request =>
        if (userId == request.userId)
          for {
            user <- db.roTransaction(implicit graph => userSrv.get(EntityIdOrName(userId)).getOrFail("User"))
            _    <- authSrv.changePassword(userId, request.body("currentPassword"), request.body("password"))
            _    <- db.tryTransaction(implicit graph => auditSrv.user.update(user, Json.obj("password" -> "<hidden>")))
          } yield Results.NoContent
        else Failure(AuthorizationError(s"You are not authorized to change password of $userId"))
      }

  def getKey(userId: String): Action[AnyContent] =
    entrypoint("get key")
      .auth { implicit request =>
        for {
          user <- db.roTransaction { implicit graph =>
            userSrv
              .get(EntityIdOrName(userId))
              .getOrFail("User")
              .flatMap { u =>
                userSrv
                  .current
                  .organisations(Permissions.manageUser)
                  .users
                  .getEntity(u)
                  .getOrFail("User")
              }
          }
          key <-
            authSrv
              .getKey(user.login)
        } yield Results.Ok(key)
      }

  def removeKey(userId: String): Action[AnyContent] =
    entrypoint("remove key")
      .auth { implicit request =>
        for {
          user <- db.roTransaction { implicit graph =>
            userSrv
              .get(EntityIdOrName(userId))
              .getOrFail("User")
              .flatMap { u =>
                userSrv
                  .current
                  .organisations(Permissions.manageUser)
                  .users
                  .getEntity(u)
                  .getOrFail("User")
              }
          }
          _ <- authSrv.removeKey(userId)
          _ <- db.tryTransaction(implicit graph => auditSrv.user.update(user, Json.obj("key" -> "<hidden>")))
        } yield Results.NoContent
//          Failure(AuthorizationError(s"User $userId doesn't exist or permission is insufficient"))
      }

  def renewKey(userId: String): Action[AnyContent] =
    entrypoint("renew key")
      .auth { implicit request =>
        for {
          user <- db.roTransaction { implicit graph =>
            userSrv
              .get(EntityIdOrName(userId))
              .getOrFail("User")
              .flatMap { u =>
                userSrv
                  .current
                  .organisations(Permissions.manageUser)
                  .users
                  .getEntity(u)
                  .getOrFail("User")
              }
          }
          key <- authSrv.renewKey(userId)
          _   <- db.tryTransaction(implicit graph => auditSrv.user.update(user, Json.obj("key" -> "<hidden>")))
        } yield Results.Ok(key)
      }
}

@Singleton
class PublicUser @Inject() (userSrv: UserSrv, organisationSrv: OrganisationSrv) extends PublicData {
  override val entityName: String = "user"
  override val initialQuery: Query =
    Query.init[Traversal.V[User]]("listUser", (graph, authContext) => organisationSrv.get(authContext.organisation)(graph).users)
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[User]](
    "getUser",
    (idOrName, graph, authContext) => userSrv.get(idOrName)(graph).visible(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[User], IteratorOutput](
      "page",
      (range, userSteps, authContext) => userSteps.richUser(authContext).page(range.from, range.to, withTotal = true, limitedCountThreshold)
    )
  override val outputQuery: Query =
    Query.outputWithContext[RichUser, Traversal.V[User]]((userSteps, authContext) => userSteps.richUser(authContext))
  override val extraQueries: Seq[ParamQuery[_]] = Seq()
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[User]
    .property("login", UMapping.string)(_.field.readonly)
    .property("name", UMapping.string)(_.field.custom { (_, value, vertex, graph, authContext) =>
      def isCurrentUser: Try[Unit] =
        userSrv.get(vertex)(graph).current(authContext).existsOrFail

      def isUserAdmin: Try[Unit] =
        userSrv
          .current(graph, authContext)
          .organisations(Permissions.manageUser)
          .users
          .getElement(vertex)
          .existsOrFail

      isCurrentUser
        .orElse(isUserAdmin)
        .map { _ =>
          UMapping.string.setProperty(vertex, "name", value)
          Json.obj("name" -> value)
        }
    })
    .property("status", UMapping.string)(
      _.select(_.choose(predicate = _.value(_.locked).is(P.eq(true)), onTrue = "Locked", onFalse = "Ok"))
        .custom { (_, value, vertex, graph, authContext) =>
          userSrv
            .current(graph, authContext)
            .organisations(Permissions.manageUser)
            .users
            .getElement(vertex)
            .orFail(AuthorizationError("Operation not permitted"))
            .flatMap {
              case user if value == "Ok" =>
                userSrv.unlock(user)(graph, authContext)
                Success(Json.obj("status" -> value))
              case user if value == "Locked" =>
                userSrv.lock(user)(graph, authContext)
                Success(Json.obj("status" -> value))
              case _ => Failure(InvalidFormatAttributeError("status", "UserStatus", Set("Ok", "Locked"), FString(value)))
            }
        }
    )
    .property("profile", UMapping.string)(_.authSelect((users, authContext) => users.profile(authContext.organisation).value(_.name)).readonly)
    .build

}

```

`thehive/app/org/thp/thehive/controllers/v1/AdminCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import akka.actor.typed.scaladsl.AskPattern._
import akka.actor.typed.{ActorRef, Scheduler}
import akka.util.Timeout
import ch.qos.logback.classic.{Level, LoggerContext}
import org.slf4j.LoggerFactory
import org.thp.scalligraph.controllers.Entrypoint
import org.thp.scalligraph.models._
import org.thp.thehive.models.Permissions
import org.thp.thehive.services._
import play.api.Logger
import play.api.libs.json.{Json, OWrites}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Provider, Singleton}
import scala.collection.immutable
import scala.concurrent.duration.DurationInt
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success}

@Singleton
class AdminCtrl @Inject() (
    entrypoint: Entrypoint,
    integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]],
    db: Database,
    schemas: immutable.Set[UpdatableSchema],
    implicit val ec: ExecutionContext,
    implicit val scheduler: Scheduler
) {
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get
  implicit val timeout: Timeout                                  = Timeout(5.seconds)
  implicit val checkStatsWrites: OWrites[CheckStats]             = Json.writes[CheckStats]
  implicit val checkStateWrites: OWrites[CheckState] = OWrites[CheckState] { state =>
    Json.obj(
      "needCheck"      -> state.needCheck,
      "duplicateTimer" -> state.dedupTimer.isDefined,
      "duplicateStats" -> state.dedupStats,
      "globalStats"    -> state.globalStats
    )
  }
  lazy val logger: Logger = Logger(getClass)

  def setLogLevel(packageName: String, levelName: String): Action[AnyContent] =
    entrypoint("Update log level")
      .authPermitted(Permissions.managePlatform) { _ =>
        val level = levelName match {
          case "ALL"   => Level.ALL
          case "DEBUG" => Level.DEBUG
          case "INFO"  => Level.INFO
          case "WARN"  => Level.WARN
          case "ERROR" => Level.ERROR
          case "OFF"   => Level.OFF
          case "TRACE" => Level.TRACE
          case _       => Level.INFO
        }
        val loggerContext = LoggerFactory.getILoggerFactory.asInstanceOf[LoggerContext]
        val logger        = loggerContext.getLogger(packageName)
        logger.setLevel(level)
        Success(Results.NoContent)
      }

  def triggerGlobalCheck(name: String): Action[AnyContent] =
    entrypoint("Trigger check")
      .authPermitted(Permissions.managePlatform) { _ =>
        integrityCheckActor ! IntegrityCheck.CheckRequest(name, dedup = false, global = true)
        Success(Results.NoContent)
      }
  def triggerDedup(name: String): Action[AnyContent] =
    entrypoint("Trigger check")
      .authPermitted(Permissions.managePlatform) { _ =>
        integrityCheckActor ! IntegrityCheck.CheckRequest(name, dedup = true, global = false)
        Success(Results.NoContent)
      }

  def cancelCurrentCheck: Action[AnyContent] =
    entrypoint("Cancel current check")
      .authPermitted(Permissions.managePlatform) { _ =>
        integrityCheckActor ! IntegrityCheck.CancelCheck
        Success(Results.NoContent)
      }

  def checkStats: Action[AnyContent] =
    entrypoint("Get check stats")
      .asyncAuthPermitted(Permissions.managePlatform) { _ =>
        integrityCheckActor
          .ask(IntegrityCheck.GetAllCheckStats)
          .mapTo[IntegrityCheck.AllCheckStats]
          .recover {
            case error =>
              logger.error(s"Fail to get check stats", error)
              IntegrityCheck.AllCheckStats(Map.empty)
          }
          .map { results =>
            Results.Ok(Json.toJson(results.stats))
          }
      }

  val labels = Seq(
    "Config",
    "ReportTag",
    "KeyValue",
    "Pattern",
    "Case",
    "Procedure",
    "Alert",
    "Dashboard",
    "Observable",
    "User",
    "AnalyzerTemplate",
    "Taxonomy",
    "CustomField",
    "Data",
    "Organisation",
    "Profile",
    "Task",
    "Action",
    "Log",
    "CaseTemplate",
    "Audit",
    "Tag",
    "Job",
    "Attachment"
  )

  def indexStatus: Action[AnyContent] =
    entrypoint("Get index status")
      .authPermittedRoTransaction(db, Permissions.managePlatform) { _ => graph =>
        val indices = labels.map { label =>
          val count =
            try graph.indexCountQuery(s"""v."_label":$label""")
            catch {
              case error: Throwable =>
                logger.error("Index fetch error", error)
                0L
            }
          Json.obj("name" -> label, "count" -> count)

        }
        val indexCount = Json.obj("name" -> "global", "indices" -> indices)
        Success(Results.Ok(Json.obj("index" -> Seq(indexCount))))
      }

  def reindex(label: String): Action[AnyContent] =
    entrypoint("Reindex data")
      .authPermitted(Permissions.managePlatform) { _ =>
        Future(db.reindexData(label))
        Success(Results.NoContent)
      }

  def rebuild(name: String): Action[AnyContent] =
    entrypoint("Rebuild index")
      .authPermitted(Permissions.managePlatform) { _ =>
        val removalResult =
          if (name == "all") db.removeAllIndex()
          else db.removeIndex(name, IndexType.fulltext, Nil)
        schemas
          .toTry(db.addSchemaIndexes)
          .flatMap(_ => removalResult)
          .map(_ => Results.NoContent)
      }

  private val rangeRegex = "(\\d+)-(\\d+)".r
  private def getOperations(schemaName: String, select: Option[String], filter: Option[String]): Seq[(Operation, Int)] = {
    val ranges = select.fold(Seq(0 until Int.MaxValue))(_.split(',').toSeq.map {
      case rangeRegex(from, to) => from.toInt to to.toInt
      case number               => number.toInt to number.toInt
    })

    val filters = filter.fold(Seq("all"))(_.split(','))

    schemas
      .filter(_.name == schemaName)
      .toSeq
      .flatMap { schema =>
        schema
          .operations
          .operations
          .zipWithIndex
          .filter {
            case (_, i) => ranges.exists(_.contains(i))
          }
          .filter {
            case (_: AddVertexModel, _) =>
              filters.contains("AddVertexModel") || filters
                .contains("schema") || (filters.contains("all") && !filters.contains("!schema") && !filters.contains("!AddVertexModel"))
            case (_: AddEdgeModel, _) =>
              filter.contains("AddEdgeModel") || filter
                .contains("schema") || (filters.contains("all") && !filter.contains("!schema") && !filter.contains("!AddEdgeModel"))
            case (_: AddProperty, _) =>
              filter.contains("AddProperty") || filter
                .contains("schema") || (filters.contains("all") && !filter.contains("!schema") && !filter.contains("!AddProperty"))
            case (_: RemoveProperty, _) =>
              filter.contains("RemoveProperty") || filter
                .contains("schema") || (filters.contains("all") && !filter.contains("!schema") && !filter.contains("!RemoveProperty"))
            case (_: UpdateGraph, _) =>
              filter.contains("UpdateGraph") || filter
                .contains("data") || (filters.contains("all") && !filter.contains("!data") && !filter.contains("!UpdateGraph"))
            case (_: AddIndex, _) =>
              filter.contains("AddIndex") || filter
                .contains("index") || (filters.contains("all") && !filter.contains("!index") && !filter.contains("!AddIndex"))
            case (ReindexData, _) =>
              filter.contains("ReindexData") || filter
                .contains("index") || (filters.contains("all") && !filter.contains("!index") && !filter.contains("!RebuildIndexes"))
            case (NoOperation, _) => false
            case (_: RemoveIndex, _) =>
              filter.contains("RemoveIndex") || filter
                .contains("index") || (filters.contains("all") && !filter.contains("!index") && !filter.contains("!RemoveIndex"))
            case (_: DBOperation[_], _) =>
              filter.contains("DBOperation") || filter
                .contains("data") || (filters.contains("all") && !filter.contains("!data") && !filter.contains("!DBOperation"))
          }
      }
  }

  def schemaRepair(schemaName: String, select: Option[String], filter: Option[String]): Action[AnyContent] =
    entrypoint("Repair schema")
      .authPermitted(Permissions.managePlatform) { _ =>
        val result = getOperations(schemaName, select, filter)
          .map {
            case (operation, index) =>
              logger.info(s"Repair schema: $index=${operation.info}")
              operation.execute(db, logger.info(_)) match {
                case _: Success[_]  => s"${operation.info}: Success"
                case Failure(error) => s"${operation.info}: Failure $error"
              }
          }

        Success(Results.Ok(Json.toJson(result)))
      }

  def schemaInfo(schemaName: String, select: Option[String], filter: Option[String]): Action[AnyContent] =
    entrypoint("Schema info")
      .authPermitted(Permissions.managePlatform) { _ =>
        val output = getOperations(schemaName, select, filter).map {
          case (o, i) => s"$i=${o.info}"
        }
        Success(Results.Ok(Json.toJson(output)))
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/AlertCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, IteratorOutput, Traversal}
import org.thp.scalligraph.{BadRequestError, EntityIdOrName, EntityName, RichOptionTry}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.{InputAlert, InputCustomFieldValue}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.libs.json.{JsValue, Json}
import play.api.mvc.{Action, AnyContent, Results}

import java.util.{Map => JMap}
import javax.inject.{Inject, Singleton}
import scala.reflect.runtime.{universe => ru}
import scala.util.{Failure, Success}

case class SimilarCaseFilter()
@Singleton
class AlertCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    alertSrv: AlertSrv,
    caseSrv: CaseSrv,
    caseTemplateSrv: CaseTemplateSrv,
    userSrv: UserSrv,
    organisationSrv: OrganisationSrv,
    implicit val db: Database
) extends QueryableCtrl
    with AlertRenderer {

  override val entityName: String                 = "alert"
  override val publicProperties: PublicProperties = properties.alert
  override val initialQuery: Query =
    Query.init[Traversal.V[Alert]]("listAlert", (graph, authContext) => alertSrv.startTraversal(graph).visible(organisationSrv)(authContext))

  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Alert]](
    "getAlert",
    (idOrName, graph, authContext) => alertSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Alert], IteratorOutput](
      "page",
      (range, alertSteps, authContext) =>
        alertSteps
          .richPage(range.from, range.to, range.extraData.contains("total"), limitedCountThreshold)(
            _.richAlertWithCustomRenderer(alertStatsRenderer(organisationSrv, range.extraData)(authContext))
          )
    )
  override val outputQuery: Query      = Query.output[RichAlert, Traversal.V[Alert]](_.richAlert)
  val caseProperties: PublicProperties = properties.`case` ++ properties.metaProperties
  implicit val caseFilterParser: FieldsParser[Option[InputQuery[Traversal.Unk, Traversal.Unk]]] =
    FilterQuery.default(caseProperties).paramParser(ru.typeOf[Traversal.V[Case]]).optional.on("caseFilter")
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query.init[Long](
      "countAlert",
      (graph, authContext) =>
        graph.indexCountQuery(s"""v."_label":Alert AND v.organisationId:${organisationSrv.currentId(graph, authContext).value}""")
    ),
    Query.init[Long](
      "countUnreadAlert",
      (graph, authContext) =>
        graph.indexCountQuery(s"""v."_label":Alert AND v.organisationId:${organisationSrv.currentId(graph, authContext).value} AND v.read:false""")
    ),
    Query.init[Long](
      "countImportedAlert",
      (graph, authContext) =>
        graph.indexCountQuery(
          s"""v."_label":Alert AND v.organisationId:${organisationSrv.currentId(graph, authContext).value} AND NOT v.caseId:[* TO 'ZZZZZZZZ']"""
        )
    ),
    Query.initWithParam[InCase, Long](
      "countRelatedAlert",
      (inCase, graph, authContext) =>
        graph.indexCountQuery(
          s"""v."_label":Alert AND """ +
            s"v.organisationId:${organisationSrv.currentId(graph, authContext).value} AND " +
            s"v.caseId:${graph.escapeQueryParameter(inCase.caseId.value)}"
        )
    ),
    Query[Traversal.V[Alert], Traversal.V[Observable]]("observables", (alertSteps, _) => alertSteps.observables),
    Query[Traversal.V[Alert], Traversal.V[Case]]("case", (alertSteps, _) => alertSteps.`case`),
    Query.withParam[Option[InputQuery[Traversal.Unk, Traversal.Unk]], Traversal.V[Alert], Traversal[
      JsValue,
      JMap[String, Any],
      Converter[JsValue, JMap[String, Any]]
    ]](
      "similarCases",
      { (maybeCaseFilterQuery, alertSteps, authContext) =>
        val caseFilter: Option[Traversal.V[Case] => Traversal.V[Case]] =
          maybeCaseFilterQuery.map(f => cases => f(caseProperties, ru.typeOf[Traversal.V[Case]], cases.cast, authContext).cast)
        alertSteps.similarCases(organisationSrv, caseFilter)(authContext).domainMap(Json.toJson(_))
      }
    )
  )

  def create: Action[AnyContent] =
    entrypoint("create alert")
      .extract("alert", FieldsParser[InputAlert])
      .extract("caseTemplate", FieldsParser[String].optional.on("caseTemplate"))
      .authTransaction(db) { implicit request => implicit graph =>
        val caseTemplateName: Option[String] = request.body("caseTemplate")
        val inputAlert: InputAlert           = request.body("alert")
        val caseTemplate                     = caseTemplateName.flatMap(ct => caseTemplateSrv.get(EntityIdOrName(ct)).visible.headOption)
        for {
          organisation <- userSrv.current.organisations(Permissions.manageAlert).getOrFail("Organisation")
          customFields = inputAlert.customFieldValue.map(cf => InputCustomFieldValue(cf.name, cf.value, cf.order))
          richAlert <- alertSrv.create(inputAlert.toAlert, organisation, inputAlert.tags, customFields, caseTemplate)
        } yield Results.Created(richAlert.toJson)
      }

  def get(alertIdOrName: String): Action[AnyContent] =
    entrypoint("get alert")
      .authRoTransaction(db) { implicit request => implicit graph =>
        alertSrv
          .get(EntityIdOrName(alertIdOrName))
          .visible(organisationSrv)
          .richAlert
          .getOrFail("Alert")
          .map(alert => Results.Ok(alert.toJson))
      }

  def update(alertIdOrName: String): Action[AnyContent] =
    entrypoint("update alert")
      .extract("alert", FieldsParser.update("alertUpdate", publicProperties))
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("alert")
        alertSrv
          .update(
            _.get(EntityIdOrName(alertIdOrName))
              .visible(organisationSrv),
            propertyUpdaters
          )
          .map(_ => Results.NoContent)
      }

//  def mergeWithCase(alertId: String, caseId: String) = ???

  def markAsRead(alertIdOrName: String): Action[AnyContent] =
    entrypoint("mark alert as read")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        alertSrv
          .get(EntityIdOrName(alertIdOrName))
          .visible(organisationSrv)
          .getOrFail("Alert")
          .map { alert =>
            alertSrv.markAsRead(alert._id)
            Results.NoContent
          }
      }

  def markAsUnread(alertIdOrName: String): Action[AnyContent] =
    entrypoint("mark alert as unread")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        alertSrv
          .get(EntityIdOrName(alertIdOrName))
          .visible(organisationSrv)
          .getOrFail("Alert")
          .map { alert =>
            alertSrv.markAsUnread(alert._id)
            Results.NoContent
          }
      }

  def createCase(alertIdOrName: String): Action[AnyContent] =
    entrypoint("create case from alert")
      .extract("caseTemplate", FieldsParser.string.optional.on("caseTemplate"))
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        val caseTemplate: Option[String] = request.body("caseTemplate")
        for {
          organisation <- organisationSrv.current.getOrFail("Organisation")
          alert <-
            alertSrv
              .get(EntityIdOrName(alertIdOrName))
              .visible(organisationSrv)
              .richAlert
              .getOrFail("Alert")
          _ <- caseTemplate.map(ct => caseTemplateSrv.get(EntityIdOrName(ct)).visible.existsOrFail).flip
          alertWithCaseTemplate = caseTemplate.fold(alert)(ct => alert.copy(caseTemplate = Some(ct)))
          assignee <- if (request.isPermitted(Permissions.manageCase)) userSrv.current.getOrFail("User").map(Some(_)) else Success(None)
          richCase <- alertSrv.createCase(alertWithCaseTemplate, assignee, organisation)
        } yield Results.Created(richCase.toJson)
      }

  def followAlert(alertIdOrName: String): Action[AnyContent] =
    entrypoint("follow alert")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        alertSrv
          .get(EntityIdOrName(alertIdOrName))
          .visible(organisationSrv)
          .getOrFail("Alert")
          .map { alert =>
            alertSrv.followAlert(alert._id)
            Results.NoContent
          }
      }

  def unfollowAlert(alertIdOrName: String): Action[AnyContent] =
    entrypoint("unfollow alert")
      .authPermittedTransaction(db, Permissions.manageAlert) { implicit request => implicit graph =>
        alertSrv
          .get(EntityIdOrName(alertIdOrName))
          .visible(organisationSrv)
          .getOrFail("Alert")
          .map { alert =>
            alertSrv.unfollowAlert(alert._id)
            Results.NoContent
          }
      }

  def fixCaseLink: Action[AnyContent] =
    entrypoint("fix link between case and alert")
      .extract("alertName", FieldsParser.string.on("alertName"))
      .extract("caseNumber", FieldsParser.string.on("caseNumber"))
      .extract("organisation", FieldsParser.string.on("organisation"))
      .authPermittedTransaction(db, Permissions.managePlatform) { implicit request => implicit graph =>
        val alertName: String    = request.body("alertName")
        val caseNumber: String   = request.body("caseNumber")
        val organisation: String = request.body("organisation")
        for {
          organisation <- organisationSrv.getOrFail(EntityIdOrName(organisation))
          alert        <- alertSrv.startTraversal.has(_.organisationId, organisation._id).get(EntityName(alertName)).getOrFail("Alert")
          _            <- if (alertSrv.get(alert).`case`.exists) Failure(BadRequestError("The alert is already linked to a case")) else Success(())
          c            <- caseSrv.getOrFail(EntityName(caseNumber))
          _            <- alertSrv.alertCaseSrv.create(AlertCase(), alert, c)
          _            <- alertSrv.get(alert).update(_.caseId, c._id).getOrFail("Alert")
        } yield Results.NoContent
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/AlertRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models.{Alert, RichCase, SimilarStats}
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.OrganisationSrv
import play.api.libs.json._

import java.lang.{Integer => JInt}
import java.util.{Date, List => JList, Map => JMap}

trait AlertRenderer extends BaseRenderer[Alert] {
  implicit val similarCaseWrites: Writes[(RichCase, SimilarStats)] = Writes[(RichCase, SimilarStats)] {
    case (richCase, similarStats) =>
      Json.obj(
        "case"                   -> richCase.toJson,
        "similarObservableCount" -> similarStats.observable._1,
        "observableCount"        -> similarStats.observable._2,
        "similarIocCount"        -> similarStats.ioc._1,
        "iocCount"               -> similarStats.ioc._2,
        "observableTypes"        -> similarStats.types
      )
  }
  def similarCasesStats(organisationSrv: OrganisationSrv)(implicit
      authContext: AuthContext
  ): Traversal.V[Alert] => Traversal[JsValue, JList[JMap[String, Any]], Converter[JsValue, JList[JMap[String, Any]]]] = {
    implicit val similarCaseOrdering: Ordering[(RichCase, SimilarStats)] = (x: (RichCase, SimilarStats), y: (RichCase, SimilarStats)) =>
      //negative if x < y
      if (x._1._createdAt after y._1._createdAt) -1
      else if (x._1._createdAt before y._1._createdAt) 1
      else if (x._2.observable._1 > y._2.observable._1) -1
      else if (x._2.observable._1 < y._2.observable._1) 1
      else if (x._2.ioc._1 > y._2.ioc._1) -1
      else if (x._2.ioc._1 < y._2.ioc._1) 1
      else if (x._2.ioc._2 > y._2.ioc._2) -1
      else if (x._2.ioc._2 < y._2.ioc._2) 1
      else 0
    _.similarCases(organisationSrv, caseFilter = None).fold.domainMap(sc => JsArray(sc.sorted.map(Json.toJson(_))))
  }

  def importDate: Traversal.V[Alert] => Traversal[JsValue, JList[Date], Converter[JsValue, JList[Date]]] =
    _.importDate.fold.domainMap(_.headOption.fold[JsValue](JsNull)(d => JsNumber(d.getTime)))

  def caseNumber: Traversal.V[Alert] => Traversal[JsValue, JList[JInt], Converter[JsValue, JList[JInt]]] =
    _.`case`.value(_.number).option.domainMap(_.fold[JsValue](JsNull)(JsNumber(_)))

  def alertStatsRenderer(organisationSrv: OrganisationSrv, extraData: Set[String])(implicit
      authContext: AuthContext
  ): Traversal.V[Alert] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "similarCases") => addData("similarCases", f)(similarCasesStats(organisationSrv))
        case (f, "importDate")   => addData("importDate", f)(importDate)
        case (f, "caseNumber")   => addData("caseNumber", f)(caseNumber)
        case (f, _)              => f
      }
    )
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/AuditCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Schema}
import org.thp.scalligraph.query.{ParamQuery, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models.{Audit, RichAudit}
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services.{AuditSrv, OrganisationSrv}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.util.Success

@Singleton
class AuditCtrl @Inject() (
    entrypoint: Entrypoint,
    db: Database,
    properties: Properties,
    auditSrv: AuditSrv,
    organisationSrv: OrganisationSrv,
    implicit val schema: Schema
) extends QueryableCtrl {

  val entityName: String = "audit"

  val initialQuery: Query =
    Query.init[Traversal.V[Audit]]("listAudit", (graph, authContext) => auditSrv.startTraversal(graph).visible(organisationSrv)(authContext))
  val publicProperties: PublicProperties = properties.audit
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Audit]](
    "getAudit",
    (idOrName, graph, authContext) => auditSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )

  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Audit], IteratorOutput](
      "page",
      (range, auditSteps, _) => auditSteps.richPage(range.from, range.to, range.extraData.contains("total"), limitedCountThreshold)(_.richAudit)
    )
  override val outputQuery: Query = Query.output[RichAudit, Traversal.V[Audit]](_.richAudit)

  override val extraQueries: Seq[ParamQuery[_]] = {
    implicit val entityIdParser: FieldsParser[String] = FieldsParser.string.on("id")
    Seq(
      Query.initWithParam[String, Traversal.V[Audit]](
        "listAuditFromObject",
        (objectId, graph, authContext) =>
          if (auditSrv.startTraversal(graph).has(_.objectId, objectId).v[Audit].limit(1).visible(organisationSrv)(authContext).exists)
            auditSrv.startTraversal(graph).has(_.objectId, objectId).v[Audit]
          else
            graph.empty
      )
    )
  }

  def flow: Action[AnyContent] =
    entrypoint("audit flow")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val audits = auditSrv
          .startTraversal
          .visible(organisationSrv)
          .range(0, 10)
          .richAudit
          .toSeq

        Success(Results.Ok(audits.toJson))
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/AuthenticationCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.auth.{AuthSrv, RequestOrganisation}
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AuthenticationError, AuthorizationError, BadRequestError, EntityIdOrName, MultiFactorCodeRequired}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models.Permissions
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services.{TOTPAuthSrv, UserSrv}
import play.api.libs.json.Json
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class AuthenticationCtrl @Inject() (
    entrypoint: Entrypoint,
    authSrv: AuthSrv,
    requestOrganisation: RequestOrganisation,
    userSrv: UserSrv,
    implicit val db: Database
) {

  def login: Action[AnyContent] =
    entrypoint("login")
      .extract("login", FieldsParser[String].on("user"))
      .extract("password", FieldsParser[String].on("password"))
      .extract("organisation", FieldsParser[String].optional.on("organisation"))
      .extract("code", FieldsParser[String].optional.on("code")) { implicit request =>
        val login: String                        = request.body("login")
        val password: String                     = request.body("password")
        val organisation: Option[EntityIdOrName] = request.body("organisation").map(EntityIdOrName(_)) orElse requestOrganisation(request)
        val code: Option[String]                 = request.body("code")
        for {
          authContext <- authSrv.authenticate(login, password, organisation, code)
          user <- db.roTransaction { implicit graph =>
            userSrv
              .current(graph, authContext)
              .richUserWithCustomRenderer(authContext.organisation, _.organisationWithRole)(authContext)
              .getOrFail("User")
          }
          _ <- if (user._1.locked) Failure(AuthorizationError("Your account is locked")) else Success(())
        } yield authSrv.setSessionUser(authContext)(Results.Ok(user.toJson))
      }

  def logout: Action[AnyContent] =
    entrypoint("logout") { _ =>
      Success(Results.Ok.withNewSession)
    }

  def withTotpAuthSrv[A](body: TOTPAuthSrv => Try[A]): Try[A] =
    authSrv match {
      case totpAuthSrv: TOTPAuthSrv if totpAuthSrv.enabled => body(totpAuthSrv)
      case _                                               => Failure(AuthenticationError("Operation not supported"))
    }

  def totpSetSecret: Action[AnyContent] =
    entrypoint("Set TOTP secret")
      .extract("code", FieldsParser[Int].optional.on("code"))
      .authTransaction(db) { implicit request => implicit graph =>
        withTotpAuthSrv { totpAuthSrv =>
          totpAuthSrv.getSecret(request.userId) match {
            case Some(_) => Failure(BadRequestError("TOTP is already configured"))
            case None =>
              request.session.get("totpSecret") match {
                case None =>
                  val secret = totpAuthSrv.generateSecret()
                  Success(
                    Results
                      .Ok(Json.obj("secret" -> secret, "uri" -> totpAuthSrv.getSecretURI(request.userId, secret).toString))
                      .withSession("totpSecret" -> secret)
                  )
                case Some(secret) =>
                  val code: Option[Int] = request.body("code")
                  code match {
                    case Some(c) if totpAuthSrv.codeIsValid(secret, c) => totpAuthSrv.setSecret(request.userId, secret).map(_ => Results.NoContent)
                    case Some(_)                                       => Failure(AuthenticationError("MFA code is invalid"))
                    case None                                          => Failure(MultiFactorCodeRequired("MFA code is required"))
                  }
              }
          }
        }
      }

  def totpUnsetSecret(userId: Option[String]): Action[AnyContent] =
    entrypoint("Unset TOTP secret")
      .authTransaction(db) { implicit request => implicit graph =>
        withTotpAuthSrv { totpAuthSrv =>
          userSrv
            .getOrFail(EntityIdOrName(userId.getOrElse(request.userId)))
            .flatMap { user =>
              if (request.userId == user.login || userSrv.current.organisations(Permissions.manageUser).users.getEntity(user).exists)
                totpAuthSrv.unsetSecret(user.login)
              else Failure(AuthorizationError("You cannot unset TOTP secret of this user"))
            }
            .map(_ => Results.NoContent)
        }
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/BaseRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import play.api.libs.json.{JsObject, JsValue}

import java.util.{Map => JMap}

trait BaseRenderer[A] {

  type JsConverter = Converter[JsObject, JMap[String, Any]]
  type JsTraversal = Traversal[JsObject, JMap[String, Any], JsConverter]
  def baseRenderer(
      extraData: Set[String],
      traversal: Traversal.V[A],
      mapping: (JsTraversal, String) => JsTraversal
  ): JsTraversal =
    if (extraData.isEmpty) traversal.constant2[JsObject, JMap[String, Any]](JsObject.empty)
    else {
      val dataName = extraData.toSeq
      dataName.foldLeft[JsTraversal](
        traversal.onRawMap[JsObject, JMap[String, Any], JsConverter](_.project(dataName.head, dataName.tail: _*))(_ => JsObject.empty)
      )(mapping)
    }

  def addData[G](name: String, jsTraversal: JsTraversal)(
      f: Traversal.V[A] => Traversal[JsValue, G, Converter[JsValue, G]]
  )(implicit traversal: Traversal.V[A]): JsTraversal = {
    val dataTraversal = f(traversal.start)
    jsTraversal.onRawMap[JsObject, JMap[String, Any], JsConverter](_.by(dataTraversal.raw)) { jmap =>
      jsTraversal.converter(jmap) + (name -> dataTraversal.converter(jmap.get(name).asInstanceOf[G]))
    }
  }

}

```

`thehive/app/org/thp/thehive/controllers/v1/CaseCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.apache.tinkerpop.gremlin.process.traversal.P
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.{ParamQuery, PropertyUpdater, PublicProperties, Query}
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, IteratorOutput, Traversal}
import org.thp.scalligraph.{EntityIdOrName, RichOptionTry, RichSeq}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.{InputCase, InputTask}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.libs.json.{JsNumber, JsObject}
import play.api.mvc.{Action, AnyContent, Results}

import java.util.{Map => JMap}
import javax.inject.{Inject, Singleton}

@Singleton
class CaseCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    caseSrv: CaseSrv,
    caseTemplateSrv: CaseTemplateSrv,
    observableSrv: ObservableSrv,
    userSrv: UserSrv,
    taskSrv: TaskSrv,
    val organisationSrv: OrganisationSrv,
    alertSrv: AlertSrv,
    db: Database,
    appConfig: ApplicationConfig
) extends QueryableCtrl
    with CaseRenderer {

  val limitedCountThresholdConfig: ConfigItem[Long, Long] = appConfig.item[Long]("query.limitedCountThreshold", "Maximum number returned by a count")
  val limitedCountThreshold: Long                         = limitedCountThresholdConfig.get

  override val entityName: String                 = "case"
  override val publicProperties: PublicProperties = properties.`case`
  override val initialQuery: Query =
    Query.init[Traversal.V[Case]]("listCase", (graph, authContext) => caseSrv.startTraversal(graph).visible(organisationSrv)(authContext))
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Case]](
    "getCase",
    (idOrName, graph, authContext) => caseSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Case], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, extraData), caseSteps, authContext) =>
          caseSteps.richPage(from, to, extraData.contains("total"), limitedCountThreshold) {
            _.richCaseWithCustomRenderer(caseStatsRenderer(extraData - "total")(authContext))(authContext)
          }
      }
    )
  override val outputQuery: Query = Query.outputWithContext[RichCase, Traversal.V[Case]]((caseSteps, authContext) => caseSteps.richCase(authContext))
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query.init[Long](
      "countCase",
      (graph, authContext) =>
        graph.indexCountQuery(s"""v."_label":Case AND v.organisationIds:${organisationSrv.currentId(graph, authContext).value}""")
    ),
    Query[Traversal.V[Case], Traversal.V[Observable]](
      "observables",
      (caseSteps, authContext) =>
        // caseSteps.observables(authContext)
        observableSrv.startTraversal(caseSteps.graph).has(_.relatedId, P.within(caseSteps._id.toSeq: _*)).visible(organisationSrv)(authContext)
    ),
    Query[Traversal.V[Case], Traversal.V[Task]](
      "tasks",
      (caseSteps, authContext) =>
        // caseSteps.tasks(authContext)
        taskSrv.startTraversal(caseSteps.graph).has(_.relatedId, P.within(caseSteps._id.toSeq: _*)).visible(organisationSrv)(authContext)
    ),
    Query[Traversal.V[Case], Traversal.V[User]]("assignableUsers", (caseSteps, authContext) => caseSteps.assignableUsers(authContext)),
    Query[Traversal.V[Case], Traversal.V[Organisation]]("organisations", (caseSteps, authContext) => caseSteps.organisations.visible(authContext)),
    Query[Traversal.V[Case], Traversal.V[Alert]](
      "alerts",
      (caseSteps, authContext) =>
//      caseSteps.alert.visible(organisationSrv)(authContext)
        alertSrv.startTraversal(caseSteps.graph).has(_.caseId, P.within(caseSteps._id.toSeq: _*)).visible(organisationSrv)(authContext)
    ),
    Query[Traversal.V[Case], Traversal.V[Share]]("shares", (caseSteps, authContext) => caseSteps.shares.visible(authContext)),
    Query[Traversal.V[Case], Traversal.V[Procedure]]("procedures", (caseSteps, _) => caseSteps.procedure),
    Query[Traversal.V[Case], Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]]](
      "linkedCases",
      (caseSteps, authContext) =>
        caseSteps
          .linkedCases(authContext)
          .domainMap {
            case (c, o) =>
              c.toJson.as[JsObject] +
                ("linkedWith" -> o.toJson) +
                ("linksCount" -> JsNumber(o.size))
          }
    )
  )

  def create: Action[AnyContent] =
    entrypoint("create case")
      .extract("case", FieldsParser[InputCase])
      .extract("caseTemplate", FieldsParser[String].optional.on("caseTemplate"))
      .extract("tasks", FieldsParser[InputTask].sequence.on("tasks"))
      .authTransaction(db) { implicit request => implicit graph =>
        val caseTemplateName: Option[String] = request.body("caseTemplate")
        val inputCase: InputCase             = request.body("case")
        val inputTasks: Seq[InputTask]       = request.body("tasks")
        for {
          caseTemplate <- caseTemplateName.map(ct => caseTemplateSrv.get(EntityIdOrName(ct)).visible.richCaseTemplate.getOrFail("CaseTemplate")).flip
          organisation <- userSrv.current.organisations(Permissions.manageCase).get(request.organisation).getOrFail("Organisation")
          user         <- inputCase.user.fold(userSrv.current.getOrFail("User"))(userSrv.getByName(_).getOrFail("User"))
          richCase <- caseSrv.create(
            caseTemplate.fold(inputCase)(inputCase.withCaseTemplate).toCase,
            Some(user),
            organisation,
            inputCase.customFieldValues,
            caseTemplate,
            inputTasks.map(_.toTask)
          )
        } yield Results.Created(richCase.toJson)
      }

  def get(caseIdOrNumber: String): Action[AnyContent] =
    entrypoint("get case")
      .authRoTransaction(db) { implicit request => implicit graph =>
        caseSrv
          .get(EntityIdOrName(caseIdOrNumber))
          .visible(organisationSrv)
          .richCase
          .getOrFail("Case")
          .map(richCase => Results.Ok(richCase.toJson))
      }

  def update(caseIdOrNumber: String): Action[AnyContent] =
    entrypoint("update case")
      .extract("case", FieldsParser.update("case", publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("case")
        caseSrv
          .update(_.get(EntityIdOrName(caseIdOrNumber)).can(Permissions.manageCase), propertyUpdaters)
          .map(_ => Results.NoContent)
      }

  def delete(caseIdOrNumber: String): Action[AnyContent] =
    entrypoint("delete case")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          c <-
            caseSrv
              .get(EntityIdOrName(caseIdOrNumber))
              .can(Permissions.manageCase)
              .getOrFail("Case")
          _ <- caseSrv.delete(c)
        } yield Results.NoContent
      }

  def deleteCustomField(cfId: String): Action[AnyContent] =
    entrypoint("delete a custom field")
      .authPermittedTransaction(db, Permissions.manageCase) { implicit request => implicit graph =>
        for {
          _ <-
            caseSrv
              .caseCustomFieldSrv
              .get(EntityIdOrName(cfId))
              .filter(_.outV.v[Case].can(Permissions.manageCase))
              .existsOrFail
          _ <- caseSrv.deleteCustomField(EntityIdOrName(cfId))
        } yield Results.NoContent
      }

  def merge(caseIdsOrNumbers: String): Action[AnyContent] =
    entrypoint("merge cases")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          cases <-
            caseIdsOrNumbers
              .split(',')
              .toSeq
              .toTry(c =>
                caseSrv
                  .get(EntityIdOrName(c))
                  .visible(organisationSrv)
                  .getOrFail("Case")
              )
          mergedCase <- caseSrv.merge(cases)
        } yield Results.Created(mergedCase.toJson)
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/CaseRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.models.{Alert, AlertCase, Case}
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.OrganisationSrv
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import play.api.libs.json._

import java.lang.{Long => JLong}
import java.util.{Collection => JCollection, List => JList, Map => JMap}

trait CaseRenderer extends BaseRenderer[Case] {
  val limitedCountThreshold: Long
  val organisationSrv: OrganisationSrv

  def observableStats(implicit authContext: AuthContext): Traversal.V[Case] => Traversal[JsObject, AnyRef, Converter[JsObject, AnyRef]] =
    t =>
      t._id.domainMap { caseId =>
        Json.obj(
          "total" -> t
            .graph
            .indexCountQuery(
              s"""v."_label":Observable AND """ +
                s"v.relatedId:${t.graph.escapeQueryParameter(caseId.value)} AND " +
                s"v.organisationIds:${organisationSrv.currentId(t.graph, authContext).value}"
            )
        )
      }
//    _.share
//      .observables
//      .limitedCount(limitedCountThreshold)
//      .domainMap(count => Json.obj("total" -> count))

  def taskStats(implicit
      authContext: AuthContext
  ): Traversal.V[Case] => Traversal[JsValue, JMap[String, JLong], Converter[JsValue, JMap[String, JLong]]] =
    _.share
      .tasks
      .active
      .groupCount(_.byValue(_.status))
      .domainMap { statusAgg =>
        val (total, result) = statusAgg.foldLeft(0L -> JsObject.empty) {
          case ((t, r), (k, v)) => (t + v) -> (r + (k.toString -> JsNumber(v.toInt)))
        }
        result + ("total" -> JsNumber(total))
      }

  def alertStats: Traversal.V[Case] => Traversal[JsValue, JMap[String, JCollection[String]], Converter[JsValue, JMap[String, JCollection[String]]]] =
    _.in[AlertCase]
      .v[Alert]
      .group(_.byValue(_.`type`), _.byValue(_.source))
      .domainMap { alertAgg =>
        JsArray((for {
          (tpe, sources) <- alertAgg
          source         <- sources
        } yield Json.obj("type" -> tpe, "source" -> source)).toSeq)
      }

  def isOwnerStats(implicit authContext: AuthContext): Traversal.V[Case] => Traversal[JsValue, JList[Vertex], Converter[JsValue, JList[Vertex]]] =
    _.origin.get(authContext.organisation).fold.domainMap(l => JsBoolean(l.nonEmpty))

  def shareCountStats: Traversal.V[Case] => Traversal[JsValue, JLong, Converter[JsValue, JLong]] =
    _.organisations.count.domainMap(c => JsNumber(c - 1))

  def permissions(implicit authContext: AuthContext): Traversal.V[Case] => Traversal[JsValue, JList[String], Converter[JsValue, JList[String]]] =
    _.userPermissions.domainMap(permissions => Json.toJson(permissions))

  def actionRequired(implicit authContext: AuthContext): Traversal.V[Case] => Traversal[JsValue, Boolean, Converter[JsValue, Boolean]] =
    _.isActionRequired.domainMap(JsBoolean(_))

  def procedureCount: Traversal.V[Case] => Traversal[JsNumber, JLong, Converter[JsNumber, JLong]] =
    _.procedure.count.domainMap(JsNumber(_))

  def caseStatsRenderer(extraData: Set[String])(implicit
      authContext: AuthContext
  ): Traversal.V[Case] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "observableStats") => addData("observableStats", f)(observableStats)
        case (f, "taskStats")       => addData("taskStats", f)(taskStats)
        case (f, "alerts")          => addData("alerts", f)(alertStats)
        case (f, "isOwner")         => addData("isOwner", f)(isOwnerStats)
        case (f, "shareCount")      => addData("shareCount", f)(shareCountStats)
        case (f, "permissions")     => addData("permissions", f)(permissions)
        case (f, "actionRequired")  => addData("actionRequired", f)(actionRequired)
        case (f, "procedureCount")  => addData("procedureCount", f)(procedureCount)
        case (f, _)                 => f
      }
    )
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/CaseTemplateCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.{ParamQuery, PropertyUpdater, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputCaseTemplate
import org.thp.thehive.models.{CaseTemplate, Permissions, RichCaseTemplate, Task}
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.{CaseTemplateSrv, OrganisationSrv}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.util.Success

@Singleton
class CaseTemplateCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    caseTemplateSrv: CaseTemplateSrv,
    organisationSrv: OrganisationSrv,
    implicit val db: Database
) extends QueryableCtrl {

  override val entityName: String                 = "caseTemplate"
  override val publicProperties: PublicProperties = properties.caseTemplate
  override val initialQuery: Query =
    Query
      .init[Traversal.V[CaseTemplate]]("listCaseTemplate", (graph, authContext) => organisationSrv.get(authContext.organisation)(graph).caseTemplates)
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[CaseTemplate]](
    "getCaseTemplate",
    (idOrName, graph, authContext) => caseTemplateSrv.get(idOrName)(graph).visible(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[CaseTemplate], IteratorOutput](
      "page",
      (range, caseTemplateSteps, _) =>
        caseTemplateSteps.richPage(range.from, range.to, range.extraData.contains("total"), limitedCountThreshold)(_.richCaseTemplate)
    )
  override val outputQuery: Query = Query.output[RichCaseTemplate, Traversal.V[CaseTemplate]](_.richCaseTemplate)
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[CaseTemplate], Traversal.V[Task]]("tasks", (caseTemplateSteps, _) => caseTemplateSteps.tasks)
  )

  def create: Action[AnyContent] =
    entrypoint("create case template")
      .extract("caseTemplate", FieldsParser[InputCaseTemplate])
      .authTransaction(db) { implicit request => implicit graph =>
        val inputCaseTemplate: InputCaseTemplate = request.body("caseTemplate")
        val tasks                                = inputCaseTemplate.tasks.map(_.toTask)
        val customFields                         = inputCaseTemplate.customFieldValue.map(cf => cf.name -> cf.value)

        for {
          organisation     <- organisationSrv.current.getOrFail("Organisation")
          richCaseTemplate <- caseTemplateSrv.create(inputCaseTemplate.toCaseTemplate, organisation, tasks, customFields)
        } yield Results.Created(richCaseTemplate.toJson)
      }

  def get(caseTemplateNameOrId: String): Action[AnyContent] =
    entrypoint("get case template")
      .authRoTransaction(db) { implicit request => implicit graph =>
        caseTemplateSrv
          .get(EntityIdOrName(caseTemplateNameOrId))
          .visible
          .richCaseTemplate
          .getOrFail("CaseTemplate")
          .map(richCaseTemplate => Results.Ok(richCaseTemplate.toJson))
      }

  def list: Action[AnyContent] =
    entrypoint("list case template")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val caseTemplates = caseTemplateSrv
          .startTraversal
          .visible
          .richCaseTemplate
          .toSeq
        Success(Results.Ok(caseTemplates.toJson))
      }

  def update(caseTemplateNameOrId: String): Action[AnyContent] =
    entrypoint("update case template")
      .extract("caseTemplate", FieldsParser.update("caseTemplate", publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("caseTemplate")
        caseTemplateSrv
          .update(
            _.get(EntityIdOrName(caseTemplateNameOrId))
              .can(Permissions.manageCaseTemplate),
            propertyUpdaters
          )
          .map(_ => Results.NoContent)
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/Conversion.scala`:

```scala
package org.thp.thehive.controllers.v1

import io.scalaland.chimney.dsl._
import org.thp.scalligraph.EntityId
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.Renderer
import org.thp.scalligraph.models.Entity
import org.thp.thehive.dto.v1.{InputTaxonomy, OutputTaxonomy, _}
import org.thp.thehive.models._
import play.api.libs.json.{JsObject, JsValue, Json}

import java.util.Date

object Conversion {
  implicit class RendererOps[V, O](v: V)(implicit renderer: Renderer.Aux[V, O]) {
    def toJson: JsValue = renderer.toOutput(v).toJson
    def toOutput: O     = renderer.toOutput(v).toValue
  }

  implicit val alertOutput: Renderer.Aux[RichAlert, OutputAlert] = Renderer.toJson[RichAlert, OutputAlert](
    _.into[OutputAlert]
      .withFieldConst(_._type, "Alert")
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.caseId, _.caseId.map(_.toString))
      .withFieldComputed(_.customFields, _.customFields.map(_.toOutput).sortBy(_.order))
      .withFieldComputed(_.tags, _.tags.toSet)
      .withFieldConst(_.extraData, JsObject.empty)
      .enableMethodAccessors
      .transform
  )

  implicit val alertWithStatsOutput: Renderer.Aux[(RichAlert, JsObject), OutputAlert] =
    Renderer.toJson[(RichAlert, JsObject), OutputAlert] { alertWithExtraData =>
      alertWithExtraData
        ._1
        .into[OutputAlert]
        .withFieldConst(_._type, "Alert")
        .withFieldComputed(_._id, _._id.toString)
        .withFieldComputed(_.caseId, _.caseId.map(_.toString))
        .withFieldComputed(_.customFields, _.customFields.map(_.toOutput).sortBy(_.order))
        .withFieldComputed(_.tags, _.tags.toSet)
        .withFieldConst(_.extraData, alertWithExtraData._2)
        .enableMethodAccessors
        .transform
    }

  implicit val auditOutput: Renderer.Aux[RichAudit, OutputAudit] = Renderer.toJson[RichAudit, OutputAudit](
    _.into[OutputAudit]
      .withFieldComputed(_.operation, _.action)
      .withFieldComputed(_._id, _._id.toString)
      .withFieldConst(_._type, "Audit")
      .withFieldComputed(_._createdAt, _._createdAt)
      .withFieldComputed(_._createdBy, _._createdBy)
      .withFieldComputed(_.obj, a => a.`object`.map(OutputEntity.apply))
      //        .withFieldComputed(_.obj, a => OutputEntity(a.obj))
      //        .withFieldComputed(
      //          _.summary,
      //          _.summary.mapValues(
      //            opCount =>
      //              opCount.map {
      //                case (op, count) => op.toString → count
      //              }
      //          )
      .withFieldConst(_.attributeName, None) // FIXME
      .withFieldConst(_.oldValue, None)
      .withFieldConst(_.newValue, None)
      .withFieldConst(_.summary, Map.empty[String, Map[String, Int]])
      .transform
  )

  implicit class InputAlertOps(inputAlert: InputAlert) {

    def toAlert: Alert =
      inputAlert
        .into[Alert]
        .withFieldComputed(_.severity, _.severity.getOrElse(2))
        .withFieldComputed(_.tlp, _.tlp.getOrElse(2))
        .withFieldComputed(_.pap, _.pap.getOrElse(2))
        .withFieldConst(_.read, false)
        .withFieldConst(_.lastSyncDate, new Date)
        .withFieldConst(_.follow, true)
        .withFieldConst(_.tags, inputAlert.tags.toSeq)
        .withFieldConst(_.caseId, EntityId.empty)
        .transform
  }

  implicit val caseOutput: Renderer.Aux[RichCase, OutputCase] = Renderer.toJson[RichCase, OutputCase](
    _.into[OutputCase]
      .withFieldConst(_._type, "Case")
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.customFields, _.customFields.map(_.toOutput).sortBy(_.order))
      .withFieldComputed(_.tags, _.tags.toSet)
      .withFieldComputed(_.status, _.status.toString)
      .withFieldConst(_.extraData, JsObject.empty)
      .withFieldComputed(_.assignee, _.assignee)
      .enableMethodAccessors
      .transform
  )

  implicit val caseWithStatsOutput: Renderer.Aux[(RichCase, JsObject), OutputCase] =
    Renderer.toJson[(RichCase, JsObject), OutputCase] { caseWithExtraData =>
      caseWithExtraData
        ._1
        .into[OutputCase]
        .withFieldConst(_._type, "Case")
        .withFieldComputed(_._id, _._id.toString)
        .withFieldComputed(_.customFields, _.customFields.map(_.toOutput).sortBy(_.order))
        .withFieldComputed(_.tags, _.tags.toSet)
        .withFieldComputed(_.status, _.status.toString)
        .withFieldConst(_.extraData, caseWithExtraData._2)
        .withFieldComputed(_.assignee, _.assignee)
        .enableMethodAccessors
        .transform
    }

  implicit class InputCaseOps(inputCase: InputCase) {

    def toCase(implicit authContext: AuthContext): Case =
      inputCase
        .into[Case]
        .withFieldComputed(_.severity, _.severity.getOrElse(2))
        .withFieldComputed(_.startDate, _.startDate.getOrElse(new Date))
        .withFieldComputed(_.flag, _.flag.getOrElse(false))
        .withFieldComputed(_.tlp, _.tlp.getOrElse(2))
        .withFieldComputed(_.pap, _.pap.getOrElse(2))
        .withFieldConst(_.status, CaseStatus.Open)
        .withFieldConst(_.number, 0)
        .withFieldComputed(_.tags, _.tags.toSeq)
        .withFieldComputed(_.assignee, c => Some(c.user.getOrElse(authContext.userId)))
        .withFieldConst(_.impactStatus, None)
        .withFieldConst(_.resolutionStatus, None)
        .transform

    def withCaseTemplate(caseTemplate: RichCaseTemplate): InputCase =
      InputCase(
        title = caseTemplate.titlePrefix.fold("")(_.replaceAll("(?m)\\s+$", "") + " ") + inputCase.title,
        description = inputCase.description,
        severity = inputCase.severity orElse caseTemplate.severity,
        startDate = inputCase.startDate,
        endDate = inputCase.endDate,
        tags = inputCase.tags,
        flag = inputCase.flag orElse Some(caseTemplate.flag),
        tlp = inputCase.tlp orElse caseTemplate.tlp,
        pap = inputCase.pap orElse caseTemplate.pap,
        status = inputCase.status,
        summary = inputCase.summary orElse caseTemplate.summary,
        user = inputCase.user,
        customFieldValues = inputCase.customFieldValues
      )
  }

  implicit class InputCaseTemplateOps(inputCaseTemplate: InputCaseTemplate) {

    def toCaseTemplate: CaseTemplate =
      inputCaseTemplate
        .into[CaseTemplate]
        .withFieldComputed(_.displayName, _.displayName.getOrElse(""))
        .withFieldComputed(_.flag, _.flag.getOrElse(false))
        .transform
  }

  implicit val caseTemplateOutput: Renderer.Aux[RichCaseTemplate, OutputCaseTemplate] = Renderer.toJson[RichCaseTemplate, OutputCaseTemplate](
    _.into[OutputCaseTemplate]
      .withFieldConst(_._type, "CaseTemplate")
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.customFields, _.customFields.map(_.toOutput).sortBy(_.order))
      .withFieldComputed(_.tags, _.tags.toSet)
      .withFieldComputed(_.tasks, _.tasks.map(_.toOutput))
      .enableMethodAccessors
      .transform
  )

  implicit val richCustomFieldOutput: Renderer.Aux[RichCustomField, OutputCustomFieldValue] =
    Renderer.toJson[RichCustomField, OutputCustomFieldValue](
      _.into[OutputCustomFieldValue]
        .withFieldComputed(_._id, _.customFieldValue._id.toString)
        .withFieldComputed(_.value, _.jsValue)
        .withFieldComputed(_.`type`, _.typeName)
        .withFieldComputed(_.order, _.order.getOrElse(0))
        .enableMethodAccessors
        .transform
    )

  implicit val customFieldOutput: Renderer.Aux[CustomField with Entity, OutputCustomField] =
    Renderer.toJson[CustomField with Entity, OutputCustomField](customField =>
      customField
        .asInstanceOf[CustomField]
        .into[OutputCustomField]
        .withFieldConst(_._id, customField._id.toString)
        .withFieldConst(_._type, "CustomField")
        .withFieldConst(_._createdAt, customField._createdAt)
        .withFieldConst(_._createdBy, customField._createdBy)
        .withFieldConst(_._updatedAt, customField._updatedAt)
        .withFieldConst(_._updatedBy, customField._updatedBy)
        .withFieldComputed(_.`type`, _.`type`.toString)
        .withFieldComputed(_.mandatory, _.mandatory)
        .transform
    )

  implicit class InputOrganisationOps(inputOrganisation: InputOrganisation) {

    def toOrganisation: Organisation =
      inputOrganisation
        .into[Organisation]
        .transform
  }

  implicit val richOrganisationRenderer: Renderer.Aux[RichOrganisation, OutputOrganisation] =
    Renderer.toJson[RichOrganisation, OutputOrganisation](organisation =>
      organisation
        .into[OutputOrganisation]
        .withFieldComputed(_._id, _._id.toString)
        .withFieldConst(_._type, "Organisation")
        .withFieldConst(_.name, organisation.name)
        .withFieldConst(_.description, organisation.description)
        .withFieldComputed(_.links, _.links.map(_.name))
        .enableMethodAccessors
        .transform
    )

  implicit val organisationRenderer: Renderer.Aux[Organisation with Entity, OutputOrganisation] =
    Renderer.toJson[Organisation with Entity, OutputOrganisation](organisation =>
      OutputOrganisation(
        organisation._id.toString,
        "organisation",
        organisation._createdBy,
        organisation._updatedBy,
        organisation._createdAt,
        organisation._updatedAt,
        organisation.name,
        organisation.description,
        Nil
      )
    )

  implicit class InputTaskOps(inputTask: InputTask) {

    def toTask: Task =
      inputTask
        .into[Task]
        .withFieldComputed(_.status, _.status.fold(TaskStatus.Waiting)(TaskStatus.withName))
        .withFieldComputed(_.order, _.order.getOrElse(0))
        .withFieldComputed(_.group, _.group.getOrElse("default"))
        .withFieldComputed(_.flag, _.flag.getOrElse(false))
        .transform
  }

  implicit val taskOutput: Renderer.Aux[RichTask, OutputTask] = Renderer.toJson[RichTask, OutputTask](
    _.into[OutputTask]
      .withFieldConst(_._type, "Task")
      .withFieldComputed(_._id, _._id.toString)
      .withFieldComputed(_.status, _.status.toString)
      .withFieldConst(_.extraData, JsObject.empty)
      .enableMethodAccessors
      .transform
  )

  implicit val taskWithStatsOutput: Renderer.Aux[(RichTask, JsObject), OutputTask] =
    Renderer.toJson[(RichTask, JsObject), OutputTask] { taskWithExtraData =>
      taskWithExtraData
        ._1
        .into[OutputTask]
        .withFieldConst(_._type, "Task")
        .withFieldComputed(_._id, _._id.toString)
        .withFieldComputed(_.status, _.status.toString)
        .withFieldConst(_.extraData, taskWithExtraData._2)
        .enableMethodAccessors
        .transform
    }

  implicit class InputTaxonomyOps(inputTaxonomy: InputTaxonomy) {

    def toTaxonomy: Taxonomy =
      inputTaxonomy
        .into[Taxonomy]
        .transform
  }

  implicit val taxonomyOutput: Renderer.Aux[RichTaxonomy, OutputTaxonomy] =
    Renderer.toJson[RichTaxonomy, OutputTaxonomy](
      _.into[OutputTaxonomy]
        .withFieldComputed(_._id, _._id.toString)
        .withFieldConst(_._type, "Taxonomy")
        .withFieldComputed(_.tags, _.tags.map(_.toOutput))
        .withFieldConst(_.extraData, JsObject.empty)
        .enableMethodAccessors
        .transform
    )

  implicit val taxonomyWithStatsOutput: Renderer.Aux[(RichTaxonomy, JsObject), OutputTaxonomy] =
    Renderer.toJson[(RichTaxonomy, JsObject), OutputTaxonomy] { taxoWithExtraData =>
      taxoWithExtraData
        ._1
        .into[OutputTaxonomy]
        .withFieldComputed(_._id, _._id.toString)
        .withFieldConst(_._type, "Taxonomy")
        .withFieldComputed(_.tags, _.tags.map(_.toOutput))
        .withFieldConst(_.extraData, taxoWithExtraData._2)
        .enableMethodAccessors
        .transform
    }

  implicit val tagOutput: Renderer.Aux[Tag with Entity, OutputTag] =
    Renderer.toJson[Tag with Entity, OutputTag](tag =>
      tag
        .asInstanceOf[Tag]
        .into[OutputTag]
        .withFieldConst(_._id, tag._id.toString)
        .withFieldConst(_._updatedAt, tag._updatedAt)
        .withFieldConst(_._updatedBy, tag._updatedBy)
        .withFieldConst(_._createdAt, tag._createdAt)
        .withFieldConst(_._createdBy, tag._createdBy)
        .withFieldConst(_._type, "Tag")
        .withFieldComputed(_.namespace, t => if (t.isFreeTag) "_freetags_" else t.namespace)
        .withFieldConst(_.extraData, JsObject.empty)
        .transform
    )

  implicit val tagWithStatsOutput: Renderer.Aux[(Tag with Entity, JsObject), OutputTag] =
    Renderer.toJson[(Tag with Entity, JsObject), OutputTag] {
      case (tag, stats) =>
        tag
          .asInstanceOf[Tag]
          .into[OutputTag]
          .withFieldConst(_._id, tag._id.toString)
          .withFieldConst(_._updatedAt, tag._updatedAt)
          .withFieldConst(_._updatedBy, tag._updatedBy)
          .withFieldConst(_._createdAt, tag._createdAt)
          .withFieldConst(_._createdBy, tag._createdBy)
          .withFieldConst(_._type, "Tag")
          .withFieldComputed(_.namespace, t => if (t.isFreeTag) "_freetags_" else t.namespace)
          .withFieldConst(_.extraData, stats)
          .transform
    }

  implicit class InputUserOps(inputUser: InputUser) {

    def toUser: User =
      inputUser
        .into[User]
        .withFieldComputed(_.id, _.login)
        .withFieldConst(_.apikey, None)
        .withFieldConst(_.password, None)
        .withFieldConst(_.locked, false)
        .withFieldConst(_.totpSecret, None)
        .withFieldConst(_.failedAttempts, None)
        .withFieldConst(_.lastFailed, None)
        //      .withFieldComputed(_.permissions, _.permissions.flatMap(Permissions.withName)) // FIXME unknown permissions are ignored
        .transform
  }

  implicit val userOutput: Renderer.Aux[RichUser, OutputUser] = Renderer.toJson[RichUser, OutputUser](
    _.into[OutputUser]
      .withFieldComputed(_.permissions, _.permissions.asInstanceOf[Set[String]])
      .withFieldComputed(_.hasKey, _.apikey.isDefined)
      .withFieldComputed(_._id, _._id.toString)
      .withFieldConst(_.organisations, Nil)
      .withFieldComputed(_.avatar, user => user.avatar.map(avatar => s"/api/v1/user/${user._id}/avatar/$avatar"))
      .withFieldConst(_.extraData, JsObject.empty)
      .enableMethodAccessors
      .transform
  )

  implicit val userWithStatsOutput: Renderer.Aux[(RichUser, JsObject), OutputUser] =
    Renderer.toJson[(RichUser, JsObject), OutputUser] { userWithExtraData =>
      userWithExtraData
        ._1
        .into[OutputUser]
        .withFieldComputed(_.permissions, _.permissions.asInstanceOf[Set[String]])
        .withFieldComputed(_.hasKey, _.apikey.isDefined)
        .withFieldComputed(_._id, _._id.toString)
        .withFieldConst(_.organisations, Nil)
        .withFieldComputed(_.avatar, user => user.avatar.map(avatar => s"/api/v1/user/${user._id}/avatar/$avatar"))
        .withFieldConst(_.extraData, userWithExtraData._2)
        .enableMethodAccessors
        .transform
    }

  implicit val userWithOrganisationOutput: Renderer.Aux[(RichUser, Seq[(Organisation with Entity, String)]), OutputUser] =
    Renderer.toJson[(RichUser, Seq[(Organisation with Entity, String)]), OutputUser] { userWithOrganisations =>
      val (user, organisations) = userWithOrganisations
      user
        .into[OutputUser]
        .withFieldComputed(_._id, _._id.toString)
        .withFieldComputed(_.permissions, _.permissions.asInstanceOf[Set[String]])
        .withFieldComputed(_.hasKey, _.apikey.isDefined)
        .withFieldConst(_.organisations, organisations.map { case (org, role) => OutputOrganisationProfile(org._id.toString, org.name, role) })
        .withFieldComputed(_.avatar, user => user.avatar.map(avatar => s"/api/v1/user/${user._id}/avatar/$avatar"))
        .withFieldConst(_.extraData, JsObject.empty)
        .enableMethodAccessors
        .transform
    }

  implicit val shareOutput: Renderer.Aux[RichShare, OutputShare] = Renderer.toJson[RichShare, OutputShare](
    _.into[OutputShare]
      .withFieldComputed(_._id, _.share._id.toString)
      .withFieldConst(_._type, "Share")
      .withFieldComputed(_.caseId, _.caseId.toString)
      .enableMethodAccessors
      .transform
  )

  implicit val profileOutput: Renderer.Aux[Profile with Entity, OutputProfile] = Renderer.toJson[Profile with Entity, OutputProfile](profile =>
    profile
      .asInstanceOf[Profile]
      .into[OutputProfile]
      .withFieldConst(_._id, profile._id.toString)
      .withFieldConst(_._updatedAt, profile._updatedAt)
      .withFieldConst(_._updatedBy, profile._updatedBy)
      .withFieldConst(_._createdAt, profile._createdAt)
      .withFieldConst(_._createdBy, profile._createdBy)
      .withFieldConst(_._type, "Profile")
      .withFieldComputed(_.permissions, _.permissions.asInstanceOf[Set[String]].toSeq.sorted) // Permission is String
      .withFieldComputed(_.editable, _.isEditable)
      .withFieldComputed(_.isAdmin, p => Permissions.containsRestricted(p.permissions))
      .transform
  )

  implicit val dashboardOutput: Renderer.Aux[RichDashboard, OutputDashboard] = Renderer.toJson[RichDashboard, OutputDashboard](dashboard =>
    dashboard
      .into[OutputDashboard]
      .withFieldConst(_._id, dashboard._id.toString)
      .withFieldComputed(_.status, d => if (d.organisationShares.nonEmpty) "Shared" else "Private")
      .withFieldConst(_._type, "Dashboard")
      .withFieldConst(_._updatedAt, dashboard._updatedAt)
      .withFieldConst(_._updatedBy, dashboard._updatedBy)
      .withFieldConst(_._createdAt, dashboard._createdAt)
      .withFieldConst(_._createdBy, dashboard._createdBy)
      .withFieldComputed(_.definition, _.definition.toString)
      .enableMethodAccessors
      .transform
  )

  implicit val attachmentOutput: Renderer.Aux[Attachment with Entity, OutputAttachment] = Renderer.toJson[Attachment with Entity, OutputAttachment](
    _.asInstanceOf[Attachment]
      .into[OutputAttachment]
      .withFieldComputed(_.hashes, _.hashes.map(_.toString).sortBy(_.length)(Ordering.Int.reverse))
      .withFieldComputed(_.id, _.attachmentId)
      .transform
  )

  implicit class InputObservableOps(inputObservable: InputObservable) {
    def toObservable: Observable =
      inputObservable
        .into[Observable]
        .withFieldComputed(_.ioc, _.ioc.getOrElse(false))
        .withFieldComputed(_.sighted, _.sighted.getOrElse(false))
        .withFieldComputed(_.tlp, _.tlp.getOrElse(2))
        .withFieldComputed(_.tags, _.tags.toSeq)
        .withFieldConst(_.data, None)
        .transform
  }

  implicit val observableOutput: Renderer.Aux[RichObservable, OutputObservable] = Renderer.toJson[RichObservable, OutputObservable](richObservable =>
    richObservable
      .into[OutputObservable]
      .withFieldConst(_._type, "Observable")
      .withFieldComputed(_._id, _.observable._id.toString)
      .withFieldComputed(_._updatedAt, _.observable._updatedAt)
      .withFieldComputed(_._updatedBy, _.observable._updatedBy)
      .withFieldComputed(_._createdAt, _.observable._createdAt)
      .withFieldComputed(_._createdBy, _.observable._createdBy)
      .withFieldComputed(_.startDate, _.observable._createdAt)
      .withFieldComputed(_.tags, _.tags.toSet)
      .withFieldComputed(_.attachment, _.attachment.map(_.toOutput))
      .withFieldComputed(
        _.reports,
        a =>
          JsObject(a.reportTags.groupBy(_.origin).map {
            case (origin, tags) =>
              origin -> Json.obj(
                "taxonomies" -> tags
                  .map(t => Json.obj("level" -> t.level.toString, "namespace" -> t.namespace, "predicate" -> t.predicate, "value" -> t.value))
              )
          })
      )
      .withFieldConst(_.extraData, JsObject.empty)
      .enableMethodAccessors
      .transform
  )

  implicit val observableWithExtraData: Renderer.Aux[(RichObservable, JsObject), OutputObservable] =
    Renderer.toJson[(RichObservable, JsObject), OutputObservable] {
      case (richObservable, extraData) =>
        richObservable
          .into[OutputObservable]
          .withFieldConst(_._type, "Observable")
          .withFieldComputed(_._id, _._id.toString)
          .withFieldComputed(_.startDate, _.observable._createdAt)
          .withFieldComputed(_.tags, _.tags.toSet)
          .withFieldComputed(_.attachment, _.attachment.map(_.toOutput))
          .withFieldComputed(
            _.reports,
            a =>
              JsObject(a.reportTags.groupBy(_.origin).map {
                case (origin, tags) =>
                  origin -> Json.obj(
                    "taxonomies" -> tags
                      .map(t => Json.obj("level" -> t.level.toString, "namespace" -> t.namespace, "predicate" -> t.predicate, "value" -> t.value))
                  )
              })
          )
          .withFieldConst(_.extraData, extraData)
          .enableMethodAccessors
          .transform
    }

  implicit val logOutput: Renderer.Aux[RichLog, OutputLog] = Renderer.toJson[RichLog, OutputLog](richLog =>
    richLog
      .into[OutputLog]
      .withFieldConst(_._type, "Log")
      .withFieldComputed(_._id, _._id.toString)
      .withFieldRenamed(_._createdAt, _.date)
      .withFieldComputed(_.attachment, _.attachments.headOption.map(_.toOutput))
      .withFieldRenamed(_._createdBy, _.owner)
      .withFieldConst(_.extraData, JsObject.empty)
      .enableMethodAccessors
      .transform
  )

  implicit val logWithStatsOutput: Renderer.Aux[(RichLog, JsObject), OutputLog] =
    Renderer.toJson[(RichLog, JsObject), OutputLog] { logWithExtraData =>
      logWithExtraData
        ._1
        .into[OutputLog]
        .withFieldConst(_._type, "Log")
        .withFieldComputed(_._id, _._id.toString)
        .withFieldRenamed(_._createdAt, _.date)
        .withFieldComputed(_.attachment, _.attachments.headOption.map(_.toOutput))
        .withFieldRenamed(_._createdBy, _.owner)
        .withFieldConst(_.extraData, logWithExtraData._2)
        .enableMethodAccessors
        .transform
    }

  implicit class InputLogOps(inputLog: InputLog) {

    def toLog: Log =
      inputLog
        .into[Log]
        .withFieldConst(_.date, new Date)
        .transform
  }

  implicit val observableTypeOutput: Renderer.Aux[ObservableType with Entity, OutputObservableType] =
    Renderer.toJson[ObservableType with Entity, OutputObservableType](observableType =>
      observableType
        .asInstanceOf[ObservableType]
        .into[OutputObservableType]
        .withFieldConst(_._id, observableType._id.toString)
        .withFieldConst(_._updatedAt, observableType._updatedAt)
        .withFieldConst(_._updatedBy, observableType._updatedBy)
        .withFieldConst(_._createdAt, observableType._createdAt)
        .withFieldConst(_._createdBy, observableType._createdBy)
        .withFieldConst(_._type, "ObservableType")
        .transform
    )

  implicit class InputObservableTypeOps(inputObservableType: InputObservableType) {
    def toObservableType: ObservableType =
      inputObservableType
        .into[ObservableType]
        .withFieldComputed(_.isAttachment, _.isAttachment.getOrElse(false))
        .transform
  }

  implicit class InputPatternOps(inputPattern: InputPattern) {
    def toPattern: Pattern =
      inputPattern
        .into[Pattern]
        .withFieldRenamed(_.external_id, _.patternId)
        .withFieldComputed(_.tactics, _.kill_chain_phases.map(_.phase_name).toSet)
        .withFieldRenamed(_.`type`, _.patternType)
        .withFieldRenamed(_.capec_id, _.capecId)
        .withFieldRenamed(_.capec_url, _.capecUrl)
        .withFieldRenamed(_.x_mitre_data_sources, _.dataSources)
        .withFieldRenamed(_.x_mitre_defense_bypassed, _.defenseBypassed)
        .withFieldRenamed(_.x_mitre_detection, _.detection)
        .withFieldRenamed(_.x_mitre_permissions_required, _.permissionsRequired)
        .withFieldRenamed(_.x_mitre_platforms, _.platforms)
        .withFieldRenamed(_.x_mitre_remote_support, _.remoteSupport)
        .withFieldRenamed(_.x_mitre_system_requirements, _.systemRequirements)
        .withFieldRenamed(_.x_mitre_version, _.revision)
        .transform
  }

  implicit val patternOutput: Renderer.Aux[RichPattern, OutputPattern] =
    Renderer.toJson[RichPattern, OutputPattern](
      _.into[OutputPattern]
        .withFieldComputed(_._id, _._id.toString)
        .withFieldConst(_._type, "Pattern")
        .withFieldConst(_.extraData, JsObject.empty)
        .enableMethodAccessors
        .transform
    )

  implicit val patternWithStatsOutput: Renderer.Aux[(RichPattern, JsObject), OutputPattern] =
    Renderer.toJson[(RichPattern, JsObject), OutputPattern] { patternWithExtraData =>
      patternWithExtraData
        ._1
        .into[OutputPattern]
        .withFieldComputed(_._id, _._id.toString)
        .withFieldConst(_._type, "Pattern")
        .withFieldConst(_.extraData, patternWithExtraData._2)
        .enableMethodAccessors
        .transform
    }

  implicit class InputProcedureOps(inputProcedure: InputProcedure) {
    def toProcedure: Procedure =
      inputProcedure
        .into[Procedure]
        .transform
  }

  implicit val richProcedureRenderer: Renderer.Aux[RichProcedure, OutputProcedure] =
    Renderer.toJson[RichProcedure, OutputProcedure](
      _.into[OutputProcedure]
        .withFieldComputed(_._id, _._id.toString)
        .withFieldComputed(_.patternId, _.pattern.patternId)
        .withFieldConst(_.extraData, JsObject.empty)
        .enableMethodAccessors
        .transform
    )

  implicit val richProcedureWithStatsRenderer: Renderer.Aux[(RichProcedure, JsObject), OutputProcedure] =
    Renderer.toJson[(RichProcedure, JsObject), OutputProcedure] { procedureWithExtraData =>
      procedureWithExtraData
        ._1
        .into[OutputProcedure]
        .withFieldComputed(_._id, _._id.toString)
        .withFieldComputed(_.patternId, _.pattern.patternId)
        .withFieldConst(_.extraData, procedureWithExtraData._2)
        .enableMethodAccessors
        .transform
    }
}

```

`thehive/app/org/thp/thehive/controllers/v1/CustomFieldCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query.{ParamQuery, PublicProperties, PublicPropertyListBuilder, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.CustomFieldSrv
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.util.Success

@Singleton
class CustomFieldCtrl @Inject() (entrypoint: Entrypoint, db: Database, customFieldSrv: CustomFieldSrv) extends QueryableCtrl {

  override val entityName: String  = "CustomField"
  override val initialQuery: Query = Query.init[Traversal.V[CustomField]]("listCustomField", (graph, _) => customFieldSrv.startTraversal(graph))
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[CustomField], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, _), customFieldSteps, _) =>
          customFieldSteps.page(from, to, withTotal = true, limitedCountThreshold)
      }
    )
  override val outputQuery: Query = Query.output[CustomField with Entity]
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[CustomField]](
    "getCustomField",
    (idOrName, graph, _) => customFieldSrv.get(idOrName)(graph)
  )
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[CustomField]
    .property("name", UMapping.string)(_.rename("displayName").updatable)
    .property("description", UMapping.string)(_.field.updatable)
    .property("reference", UMapping.string)(_.rename("name").readonly)
    .property("mandatory", UMapping.boolean)(_.field.updatable)
    .property("type", UMapping.string)(_.field.updatable)
    .property("options", UMapping.json.sequence)(_.field.updatable)
    .build

  def create: Action[AnyContent] =
    entrypoint("create custom field")
      .extract("customField", FieldsParser[CustomField])
      .authTransaction(db) { implicit request => implicit graph =>
        val customField = request.body("customField")
        customFieldSrv
          .create(customField)
          .map(createdCustomField => Results.Created(createdCustomField.toJson))
      }

  def list: Action[AnyContent] =
    entrypoint("list custom fields")
      .authRoTransaction(db) { _ => implicit graph =>
        val customFields = customFieldSrv
          .startTraversal
          .toSeq
        Success(Results.Ok(customFields.toJson))
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/DashboardCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputDashboard
import org.thp.thehive.models.{Dashboard, RichDashboard}
import org.thp.thehive.services.DashboardOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services.{DashboardSrv, OrganisationSrv, UserSrv}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.util.Success

@Singleton
class DashboardCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    db: Database,
    dashboardSrv: DashboardSrv,
    userSrv: UserSrv,
    organisationSrv: OrganisationSrv
) extends QueryableCtrl {

  override val entityName: String                 = "dashboard"
  override val publicProperties: PublicProperties = properties.dashboard
  override val initialQuery: Query =
    Query.init[Traversal.V[Dashboard]](
      "listDashboard",
      (graph, authContext) =>
        graph
          .union(
            organisationSrv.filterTraversal(_).get(authContext.organisation).dashboards,
            userSrv.filterTraversal(_).getByName(authContext.userId).dashboards
          )
          .dedup
    )

  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Dashboard]](
    "getDashboard",
    (idOrName, graph, authContext) => dashboardSrv.get(idOrName)(graph).visible(authContext)
  )

  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Dashboard], IteratorOutput](
      "page",
      (range, dashboardSteps, authContext) =>
        dashboardSteps.richPage(range.from, range.to, withTotal = true, limitedCountThreshold)(_.richDashboard(authContext))
    )
  override val outputQuery: Query = Query.outputWithContext[RichDashboard, Traversal.V[Dashboard]](_.richDashboard(_))

  def create: Action[AnyContent] =
    entrypoint("create dashboard")
      .extract("dashboard", FieldsParser[InputDashboard])
      .authTransaction(db) { implicit request => implicit graph =>
        val dashboard: InputDashboard = request.body("dashboard")
        dashboardSrv
          .create(dashboard.toDashboard)
          .flatMap {
            case richDashboard if dashboard.status == "Shared" =>
              dashboardSrv
                .share(richDashboard.dashboard, request.organisation, writable = true)
                .flatMap(_ => dashboardSrv.get(richDashboard.dashboard).richDashboard.getOrFail("Dashboard"))
            case richDashboard => Success(richDashboard)
          }
          .map(richDashboard => Results.Created(richDashboard.toJson))
      }

  def get(dashboardId: String): Action[AnyContent] =
    entrypoint("get dashboard")
      .authRoTransaction(db) { implicit request => implicit graph =>
        dashboardSrv
          .get(EntityIdOrName(dashboardId))
          .visible
          .richDashboard
          .getOrFail("Dashboard")
          .map(dashboard => Results.Ok(dashboard.toJson))
      }

  def update(dashboardId: String): Action[AnyContent] =
    entrypoint("update dashboard")
      .extract("dashboard", FieldsParser.update("dashboard", publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("dashboard")
        dashboardSrv
          .update(_.get(EntityIdOrName(dashboardId)).canUpdate, propertyUpdaters) // TODO check permission
          .flatMap { case (dashboardSteps, _) => dashboardSteps.richDashboard.getOrFail("Dashboard") }
          .map(dashboard => Results.Ok(dashboard.toJson))
      }

  def delete(dashboardId: String): Action[AnyContent] =
    entrypoint("delete dashboard")
      .authTransaction(db) { implicit request => implicit graph =>
        dashboardSrv
          .get(EntityIdOrName(dashboardId))
          .canUpdate
          .getOrFail("Dashboard")
          .map { dashboard =>
            dashboardSrv.remove(dashboard)
            Results.NoContent
          }
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/DescribeCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.controllers.Entrypoint
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.PublicProperty
import org.thp.scalligraph.services.config.ApplicationConfig.durationFormat
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.utils.Hash
import org.thp.scalligraph.{EntityId, NotFoundError}
import org.thp.thehive.controllers.v0.{QueryCtrl => QueryCtrlV0}
import org.thp.thehive.services.{CustomFieldSrv, ImpactStatusSrv, ResolutionStatusSrv}
import play.api.Logger
import play.api.cache.SyncCacheApi
import play.api.inject.Injector
import play.api.libs.json._
import play.api.mvc.{Action, AnyContent, Results}

import java.lang.{Boolean => JBoolean}
import java.util.Date
import javax.inject.{Inject, Singleton}
import scala.concurrent.duration.Duration
import scala.util.{Failure, Success, Try}

@Singleton
class DescribeCtrl @Inject() (
    cacheApi: SyncCacheApi,
    entrypoint: Entrypoint,
    alertCtrl: AlertCtrl,
    auditCtrl: AuditCtrl,
    caseCtrl: CaseCtrl,
    caseTemplateCtrl: CaseTemplateCtrl,
    customFieldCtrl: CustomFieldCtrl,
    dashboardCtrl: DashboardCtrl,
    logCtrl: LogCtrl,
    observableCtrl: ObservableCtrl,
    observableTypeCtrl: ObservableTypeCtrl,
    organisationCtrl: OrganisationCtrl,
//    pageCtrl: PageCtrl,
    patternCtrl: PatternCtrl,
    procedureCtrl: ProcedureCtrl,
    profileCtrl: ProfileCtrl,
    tagCtrl: TagCtrl,
    taskCtrl: TaskCtrl,
    taxonomyCtrl: TaxonomyCtrl,
    userCtrl: UserCtrl,
    customFieldSrv: CustomFieldSrv,
    impactStatusSrv: ImpactStatusSrv,
    resolutionStatusSrv: ResolutionStatusSrv,
    injector: Injector,
    db: Database,
    applicationConfig: ApplicationConfig
) {

  case class PropertyDescription(name: String, `type`: String, values: Seq[JsValue] = Nil, labels: Seq[String] = Nil)
  val metadata = Seq(
    PropertyDescription("_createdBy", "user"),
    PropertyDescription("_createdAt", "date"),
    PropertyDescription("_updatedBy", "user"),
    PropertyDescription("_updatedAt", "date")
  )
  case class EntityDescription(label: String, initialQuery: String, attributes: Seq[PropertyDescription]) {
    def toJson: JsObject =
      Json.obj(
        "label"        -> label,
        "initialQuery" -> initialQuery,
        "attributes"   -> (attributes ++ metadata)
      )
  }

  lazy val logger: Logger = Logger(getClass)

  val cacheExpireConfig: ConfigItem[Duration, Duration] =
    applicationConfig.item[Duration]("describe.cache.expire", "Custom fields refresh in describe")
  def cacheExpire: Duration = cacheExpireConfig.get

  def describeCortexEntity(
      name: String,
      initialQuery: String,
      className: String,
      packageName: String = "org.thp.thehive.connector.cortex.controllers.v0"
  ): Option[EntityDescription] =
    Try(
      EntityDescription(
        name,
        initialQuery,
        injector
          .instanceOf(getClass.getClassLoader.loadClass(s"$packageName.$className"))
          .asInstanceOf[QueryCtrlV0]
          .publicData
          .publicProperties
          .list
          .flatMap(propertyToJson(name, _))
      )
    ).toOption

  def entityDescriptions: Seq[EntityDescription] =
    cacheApi.getOrElseUpdate("describe.v1", cacheExpire) {
      Seq(
        EntityDescription("alert", "listAlert", alertCtrl.publicProperties.list.flatMap(propertyToJson("alert", _))),
        EntityDescription("audit", "listAudit", auditCtrl.publicProperties.list.flatMap(propertyToJson("audit", _))),
        EntityDescription("case", "listCase", caseCtrl.publicProperties.list.flatMap(propertyToJson("case", _))),
        EntityDescription("caseTemplate", "listCaseTemplate", caseTemplateCtrl.publicProperties.list.flatMap(propertyToJson("caseTemplate", _))),
        EntityDescription("customField", "listCustomField", customFieldCtrl.publicProperties.list.flatMap(propertyToJson("customField", _))),
        EntityDescription("dashboard", "listDashboard", dashboardCtrl.publicProperties.list.flatMap(propertyToJson("dashboard", _))),
        EntityDescription("log", "listLog", logCtrl.publicProperties.list.flatMap(propertyToJson("case_task_log", _))),
        EntityDescription("observable", "listObservable", observableCtrl.publicProperties.list.flatMap(propertyToJson("observable", _))),
        EntityDescription(
          "observableType",
          "listObservableType",
          observableTypeCtrl.publicProperties.list.flatMap(propertyToJson("observableType", _))
        ),
        EntityDescription("organisation", "listOrganisation", organisationCtrl.publicProperties.list.flatMap(propertyToJson("organisation", _))),
        // EntityDescription("page", "listPage", pageCtrl.publicProperties.list.flatMap(propertyToJson("page", _)))
        EntityDescription("pattern", "listPattern", patternCtrl.publicProperties.list.flatMap(propertyToJson("pattern", _))),
        EntityDescription("procedure", "listProcedure", procedureCtrl.publicProperties.list.flatMap(propertyToJson("procedure", _))),
        EntityDescription("profile", "listProfile", profileCtrl.publicProperties.list.flatMap(propertyToJson("profile", _))),
        EntityDescription("tag", "listTag", tagCtrl.publicProperties.list.flatMap(propertyToJson("tag", _))),
        EntityDescription("task", "listTask", taskCtrl.publicProperties.list.flatMap(propertyToJson("task", _))),
        EntityDescription("taxonomy", "listTaxonomy", taxonomyCtrl.publicProperties.list.flatMap(propertyToJson("taxonomy", _))),
        EntityDescription("user", "listUser", userCtrl.publicProperties.list.flatMap(propertyToJson("user", _)))
      ) ++ describeCortexEntity("job", "listJob", "JobCtrl") ++
        describeCortexEntity("action", "listAction", "ActionCtrl")
    }

  implicit val propertyDescriptionWrites: Writes[PropertyDescription] =
    Json.writes[PropertyDescription].transform((_: JsObject) + ("description" -> JsString("")))

  def customFields: Seq[PropertyDescription] = {
    def jsonToString(v: JsValue): String =
      v match {
        case JsString(s)  => s
        case JsBoolean(b) => b.toString
        case JsNumber(v)  => v.toString
        case other        => other.toString
      }
    db.roTransaction { implicit graph =>
      customFieldSrv
        .startTraversal
        .toSeq
        .map(cf => PropertyDescription(s"customFields.${cf.name}", cf.`type`.toString, cf.options, cf.options.map(jsonToString)))
    }
  }

  def impactStatus: PropertyDescription =
    db.roTransaction { implicit graph =>
      PropertyDescription("impactStatus", "enumeration", impactStatusSrv.startTraversal.toSeq.map(s => JsString(s.value)))
    }

  def resolutionStatus: PropertyDescription =
    db.roTransaction { implicit graph =>
      PropertyDescription("resolutionStatus", "enumeration", resolutionStatusSrv.startTraversal.toSeq.map(s => JsString(s.value)))
    }

  def customDescription(model: String, propertyName: String): Option[Seq[PropertyDescription]] =
    (model, propertyName) match {
      case (_, "assignee") => Some(Seq(PropertyDescription("assignee", "user")))
      case ("case", "status") =>
        Some(
          Seq(PropertyDescription("status", "enumeration", Seq(JsString("Open"), JsString("Resolved"), JsString("Deleted"), JsString("Duplicated"))))
        )
      case ("case", "impactStatus")     => Some(Seq(impactStatus))
      case ("case", "resolutionStatus") => Some(Seq(resolutionStatus))
      case ("dashboard", "status") =>
        Some(Seq(PropertyDescription("status", "enumeration", Seq(JsString("Shared"), JsString("Private"), JsString("Deleted")))))
      case ("task", "status") =>
        Some(
          Seq(
            PropertyDescription("status", "enumeration", Seq(JsString("Waiting"), JsString("InProgress"), JsString("Completed"), JsString("Cancel")))
          )
        )
      case (_, "tlp") =>
        Some(
          Seq(PropertyDescription("tlp", "number", Seq(JsNumber(0), JsNumber(1), JsNumber(2), JsNumber(3)), Seq("white", "green", "amber", "red")))
        )
      case (_, "pap") =>
        Some(
          Seq(PropertyDescription("pap", "number", Seq(JsNumber(0), JsNumber(1), JsNumber(2), JsNumber(3)), Seq("white", "green", "amber", "red")))
        )
      case (_, "severity") =>
        Some(
          Seq(
            PropertyDescription(
              "severity",
              "number",
              Seq(JsNumber(1), JsNumber(2), JsNumber(3), JsNumber(4)),
              Seq("low", "medium", "high", "critical")
            )
          )
        )
      case (_, "_createdBy")   => Some(Seq(PropertyDescription("_createdBy", "user")))
      case (_, "_updatedBy")   => Some(Seq(PropertyDescription("_updatedBy", "user")))
      case (_, "customFields") => Some(customFields)
      case (_, "patternId")    => Some(Seq(PropertyDescription("patternId", "string", Nil)))
      case _                   => None
    }

  def propertyToJson(model: String, prop: PublicProperty): Seq[PropertyDescription] =
    customDescription(model, prop.propertyName).getOrElse {
      prop.mapping.domainTypeClass match {
        case c if c == classOf[Boolean] || c == classOf[JBoolean] => Seq(PropertyDescription(prop.propertyName, "boolean"))
        case c if c == classOf[Date]                              => Seq(PropertyDescription(prop.propertyName, "date"))
        case c if c == classOf[Hash]                              => Seq(PropertyDescription(prop.propertyName, "string"))
        case c if classOf[Number].isAssignableFrom(c)             => Seq(PropertyDescription(prop.propertyName, "number"))
        case c if c == classOf[String]                            => Seq(PropertyDescription(prop.propertyName, "string"))
        case c if c == classOf[EntityId]                          => Seq(PropertyDescription(prop.propertyName, "string"))
        case c if c == classOf[JsValue]                           => Seq(PropertyDescription(prop.propertyName, "string"))
        case _ =>
          logger.warn(s"Unrecognized property ${prop.propertyName}:${prop.mapping.domainTypeClass.getSimpleName}. Add a custom description")
          Seq(PropertyDescription(prop.propertyName, "unknown"))
      }
    }

  def describe(modelName: String): Action[AnyContent] =
    entrypoint("describe model")
      .auth { _ =>
        entityDescriptions
          .collectFirst {
            case desc if desc.label == modelName => Success(Results.Ok(desc.toJson))
          }
          .getOrElse(Failure(NotFoundError(s"Model $modelName not found")))
      }

  def describeAll: Action[AnyContent] =
    entrypoint("describe all models")
      .auth { _ =>
        val descriptors = entityDescriptions.map(desc => desc.label -> desc.toJson)
        Success(Results.Ok(JsObject(descriptors)))
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/LogCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.{ParamQuery, PropertyUpdater, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputLog
import org.thp.thehive.models.{Log, Permissions, RichLog}
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.{LogSrv, OrganisationSrv, TaskSrv}
import play.api.Logger
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}

@Singleton
class LogCtrl @Inject() (
    entrypoint: Entrypoint,
    db: Database,
    properties: Properties,
    logSrv: LogSrv,
    taskSrv: TaskSrv,
    organisationSrv: OrganisationSrv
) extends QueryableCtrl
    with LogRenderer {
  lazy val logger: Logger                         = Logger(getClass)
  override val entityName: String                 = "log"
  override val publicProperties: PublicProperties = properties.log
  override val initialQuery: Query =
    Query.init[Traversal.V[Log]]("listLog", (graph, authContext) => logSrv.startTraversal(graph).visible(organisationSrv)(authContext))
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Log]](
    "getLog",
    (idOrName, graph, authContext) => logSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Log], IteratorOutput](
      "page",
      (range, logSteps, authContext) =>
        logSteps.richPage(range.from, range.to, range.extraData.contains("total"), limitedCountThreshold)(
          _.richLogWithCustomRenderer(logStatsRenderer(range.extraData - "total")(authContext))
        )
    )
  override val outputQuery: Query = Query.output[RichLog, Traversal.V[Log]](_.richLog)

  def create(taskId: String): Action[AnyContent] =
    entrypoint("create log")
      .extract("log", FieldsParser[InputLog])
      .authTransaction(db) { implicit request => implicit graph =>
        val inputLog: InputLog = request.body("log")
        for {
          task <-
            taskSrv
              .get(EntityIdOrName(taskId))
              .can(Permissions.manageTask)
              .getOrFail("Task")
          createdLog <- logSrv.create(inputLog.toLog, task, inputLog.attachment)
        } yield Results.Created(createdLog.toJson)
      }

  def update(logId: String): Action[AnyContent] =
    entrypoint("update log")
      .extract("log", FieldsParser.update("log", properties.log))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("log")
        logSrv
          .update(
            _.get(EntityIdOrName(logId))
              .can(Permissions.manageTask),
            propertyUpdaters
          )
          .map(_ => Results.NoContent)
      }

  def delete(logId: String): Action[AnyContent] =
    entrypoint("delete log")
      .authTransaction(db) { implicit req => implicit graph =>
        for {
          log <- logSrv.get(EntityIdOrName(logId)).can(Permissions.manageTask).getOrFail("Log")
          _   <- logSrv.delete(log)
        } yield Results.NoContent
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/LogRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models.Log
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.TaskOps._
import play.api.libs.json._

import java.lang.{Long => JLong}
import java.util.{List => JList, Map => JMap}

trait LogRenderer extends BaseRenderer[Log] {

  private def caseParent(implicit
      authContext: AuthContext
  ): Traversal.V[Log] => Traversal[JsValue, JList[JMap[String, Any]], Converter[JsValue, JList[JMap[String, Any]]]] =
    _.`case`.richCase.fold.domainMap(_.headOption.fold[JsValue](JsNull)(_.toJson))

  private def taskParent(implicit
      authContext: AuthContext
  ): Traversal.V[Log] => Traversal[JsValue, JMap[String, Any], Converter[JsValue, JMap[String, Any]]] =
    _.task.project(_.by(_.richTask.fold).by(_.`case`.richCase.fold)).domainMap {
      case (task, case0) =>
        task.headOption.fold[JsValue](JsNull)(_.toJson.as[JsObject] + ("case" -> case0.headOption.fold[JsValue](JsNull)(_.toJson)))
    }

  private def taskParentId: Traversal.V[Log] => Traversal[JsValue, JList[Vertex], Converter[JsValue, JList[Vertex]]] =
    _.task.fold.domainMap(_.headOption.fold[JsValue](JsNull)(c => JsString(c._id.toString)))

  private def actionCount: Traversal.V[Log] => Traversal[JsValue, JLong, Converter[JsValue, JLong]] =
    _.in("ActionContext").count.domainMap(JsNumber(_))

  def logStatsRenderer(extraData: Set[String])(implicit
      authContext: AuthContext
  ): Traversal.V[Log] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "case")        => addData("case", f)(caseParent)
        case (f, "task")        => addData("task", f)(taskParent)
        case (f, "taskId")      => addData("taskId", f)(taskParentId)
        case (f, "actionCount") => addData("actionCount", f)(actionCount)
        case (f, _)             => f
      }
    )
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/MonitoringCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.controllers.Entrypoint
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.thehive.models.Permissions
import play.api.libs.json.{Format, JsArray, Json}
import play.api.mvc.{Action, AnyContent, Results}

import java.io.File
import javax.inject.{Inject, Singleton}
import scala.util.Success

@Singleton
class MonitoringCtrl @Inject() (
    appConfig: ApplicationConfig,
    entrypoint: Entrypoint,
    db: Database
) {
  case class PartitionConfig(location: String)

  object PartitionConfig {
    implicit val format: Format[PartitionConfig] = Json.format[PartitionConfig]
  }

  val diskLocationsConfig: ConfigItem[Seq[PartitionConfig], Seq[PartitionConfig]] =
    appConfig.item[Seq[PartitionConfig]]("monitor.disk", "disk locations to monitor")
  def diskLocations: Seq[PartitionConfig] = diskLocationsConfig.get

  def diskUsage: Action[AnyContent] =
    entrypoint("monitor disk usage")
      .authPermitted(Permissions.managePlatform)(_ =>
        for {
          _ <- Success(())
          locations = diskLocations.map { dl =>
            val file = new File(dl.location)
            Json.obj(
              "location"   -> dl.location,
              "freeSpace"  -> file.getFreeSpace,
              "totalSpace" -> file.getTotalSpace
            )
          }
        } yield Results.Ok(JsArray(locations))
      )

}

```

`thehive/app/org/thp/thehive/controllers/v1/ObservableCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import net.lingala.zip4j.ZipFile
import net.lingala.zip4j.model.FileHeader
import org.thp.scalligraph._
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers._
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.query.{ParamQuery, PropertyUpdater, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.{InputAttachment, InputObservable}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services._
import play.api.libs.Files.DefaultTemporaryFileCreator
import play.api.libs.json.{JsArray, JsValue, Json}
import play.api.mvc.{Action, AnyContent, Results}
import play.api.{Configuration, Logger}
import shapeless.{:+:, CNil, Coproduct, Poly1}

import java.io.FilterInputStream
import java.nio.file.Files
import java.util.{Base64, Date}
import javax.inject.{Inject, Singleton}
import scala.collection.JavaConverters._
import scala.util.{Failure, Success, Try}

@Singleton
class ObservableCtrl @Inject() (
    entrypoint: Entrypoint,
    db: Database,
    properties: Properties,
    observableSrv: ObservableSrv,
    observableTypeSrv: ObservableTypeSrv,
    caseSrv: CaseSrv,
    alertSrv: AlertSrv,
    organisationSrv: OrganisationSrv,
    attachmentSrv: AttachmentSrv,
    errorHandler: ErrorHandler,
    temporaryFileCreator: DefaultTemporaryFileCreator,
    configuration: Configuration
) extends QueryableCtrl
    with ObservableRenderer {

  type AnyAttachmentType = InputAttachment :+: FFile :+: String :+: CNil

  lazy val logger: Logger                         = Logger(getClass)
  override val entityName: String                 = "observable"
  override val publicProperties: PublicProperties = properties.observable
  override val initialQuery: Query =
    Query.init[Traversal.V[Observable]](
      "listObservable",
      (graph, authContext) => observableSrv.startTraversal(graph).visible(organisationSrv)(authContext)
    )
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Observable]](
    "getObservable",
    (idOrName, graph, authContext) => observableSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Observable], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, extraData), observableSteps, authContext) =>
          observableSteps.richPage(from, to, extraData.contains("total"), limitedCountThreshold) {
            _.richObservableWithCustomRenderer(organisationSrv, observableStatsRenderer(organisationSrv, extraData - "total")(authContext))(
              authContext
            )
          }
      }
    )
  override val outputQuery: Query = Query.output[RichObservable, Traversal.V[Observable]](_.richObservable)

  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query.initWithParam[InCase, Long](
      "countCaseObservable",
      (inCase, graph, authContext) =>
        graph.indexCountQuery(
          s"""v."_label":Observable AND """ +
            s"relatedId:${graph.escapeQueryParameter(inCase.caseId.value)} AND " +
            s"organisationIds:${organisationSrv.currentId(graph, authContext).value}"
        )
    ),
    Query.initWithParam[InAlert, Long](
      "countAlertObservable",
      (inAlert, graph, authContext) =>
        graph.indexCountQuery(
          s"""v."_label":Observable AND """ +
            s"relatedId:${graph.escapeQueryParameter(inAlert.alertId.value)} AND " +
            s"organisationIds:${organisationSrv.currentId(graph, authContext).value}"
        )
    ),
    Query[Traversal.V[Observable], Traversal.V[Organisation]](
      "organisations",
      (observableSteps, authContext) => observableSteps.organisations.visible(authContext)
    ),
    Query[Traversal.V[Observable], Traversal.V[Observable]](
      "similar",
      (observableSteps, authContext) => observableSteps.filteredSimilar.visible(organisationSrv)(authContext)
    ),
    Query[Traversal.V[Observable], Traversal.V[Case]]("case", (observableSteps, _) => observableSteps.`case`),
    Query[Traversal.V[Observable], Traversal.V[Alert]]("alert", (observableSteps, _) => observableSteps.alert),
    Query[Traversal.V[Observable], Traversal.V[Share]]("shares", (observableSteps, authContext) => observableSteps.shares.visible(authContext)),
    Query[Traversal.V[Observable], Traversal.V[Observable]]("fromCase", (observableSteps, _) => observableSteps.filter(_.shares)),
    Query[Traversal.V[Observable], Traversal.V[Observable]]("fromAlert", (observableSteps, _) => observableSteps.filter(_.alert)),
    Query[Traversal.V[Observable], Traversal.V[Observable]](
      "fromJobReport",
      (observableSteps, _) => observableSteps.filter(_.inE("ReportObservable"))
    )
  )

  def createInCase(caseId: String): Action[AnyContent] =
    entrypoint("create observable in case")
      .extract("observable", FieldsParser[InputObservable])
      .extract("isZip", FieldsParser.boolean.optional.on("isZip"))
      .extract("zipPassword", FieldsParser.string.optional.on("zipPassword"))
      .auth { implicit request =>
        val inputObservable: InputObservable = request.body("observable")
        val isZip: Option[Boolean]           = request.body("isZip")
        val zipPassword: Option[String]      = request.body("zipPassword")
        val inputAttachObs                   = if (isZip.contains(true)) getZipFiles(inputObservable, zipPassword) else Seq(inputObservable)

        db
          .roTransaction { implicit graph =>
            for {
              case0 <-
                caseSrv
                  .get(EntityIdOrName(caseId))
                  .can(Permissions.manageObservable)
                  .orFail(AuthorizationError("Operation not permitted"))
              observableType <- observableTypeSrv.getOrFail(EntityName(inputObservable.dataType))
            } yield (case0, observableType)
          }
          .map {
            case (case0, observableType) =>
              val successesAndFailures =
                if (observableType.isAttachment)
                  inputAttachObs
                    .flatMap(obs => obs.attachment.map(createAttachmentObservableInCase(case0, obs, _)))
                else
                  inputAttachObs
                    .flatMap(obs =>
                      obs
                        .data
                        .filter(_.exists(_ != ' '))
                        .filterNot(_.isEmpty)
                        .map(createSimpleObservableInCase(case0, obs, _))
                    )
              val (successes, failures) = successesAndFailures
                .foldLeft[(Seq[JsValue], Seq[JsValue])]((Nil, Nil)) {
                  case ((s, f), Right(o)) => (s :+ o, f)
                  case ((s, f), Left(o))  => (s, f :+ o)
                }
              if (failures.isEmpty) Results.Created(JsArray(successes))
              else Results.MultiStatus(Json.obj("success" -> successes, "failure" -> failures))
          }
      }

  private def createSimpleObservableInCase(
      `case`: Case with Entity,
      inputObservable: InputObservable,
      data: String
  )(implicit authContext: AuthContext): Either[JsValue, JsValue] =
    db
      .tryTransaction { implicit graph =>
        caseSrv.createObservable(`case`, inputObservable.toObservable, data)
      } match {
      case Success(o)     => Right(o.toJson)
      case Failure(error) => Left(errorHandler.toErrorResult(error)._2 + ("object" -> Json.obj("data" -> data)))
    }

  private def createAttachmentObservableInCase(
      `case`: Case with Entity,
      inputObservable: InputObservable,
      fileOrAttachment: Either[FFile, InputAttachment]
  )(implicit authContext: AuthContext): Either[JsValue, JsValue] =
    db
      .tryTransaction { implicit graph =>
        fileOrAttachment match {
          case Left(file) =>
            caseSrv.createObservable(`case`, inputObservable.toObservable, file)
          case Right(attachment) =>
            for {
              attach <- attachmentSrv.duplicate(attachment.name, attachment.contentType, attachment.id)
              obs    <- caseSrv.createObservable(`case`, inputObservable.toObservable, attach)
            } yield obs
        }
      } match {
      case Success(o) => Right(o.toJson)
      case Failure(error) =>
        val filename = fileOrAttachment.fold(_.filename, _.name)
        Left(errorHandler.toErrorResult(error)._2 + ("object" -> Json.obj("data" -> s"file:$filename", "attachment" -> Json.obj("name" -> filename))))
    }

  def createInAlert(alertId: String): Action[AnyContent] =
    entrypoint("create artifact in alert")
      .extract("artifact", FieldsParser[InputObservable])
      .extract("isZip", FieldsParser.boolean.optional.on("isZip"))
      .extract("zipPassword", FieldsParser.string.optional.on("zipPassword"))
      .auth { implicit request =>
        val inputObservable: InputObservable = request.body("artifact")
        val isZip: Option[Boolean]           = request.body("isZip")
        val zipPassword: Option[String]      = request.body("zipPassword")
        val inputAttachObs                   = if (isZip.contains(true)) getZipFiles(inputObservable, zipPassword) else Seq(inputObservable)

        db
          .roTransaction { implicit graph =>
            for {
              alert <-
                alertSrv
                  .get(EntityIdOrName(alertId))
                  .can(organisationSrv, Permissions.manageAlert)
                  .orFail(AuthorizationError("Operation not permitted"))
              observableType <- observableTypeSrv.getOrFail(EntityName(inputObservable.dataType))
            } yield (alert, observableType)
          }
          .map {
            case (alert, observableType) =>
              val successesAndFailures =
                if (observableType.isAttachment)
                  inputAttachObs
                    .flatMap { obs =>
                      (obs.attachment.map(_.fold(Coproduct[AnyAttachmentType](_), Coproduct[AnyAttachmentType](_))) ++
                        obs.data.map(Coproduct[AnyAttachmentType](_)))
                        .map(createAttachmentObservableInAlert(alert, obs, _))
                    }
                else
                  inputAttachObs
                    .flatMap(obs =>
                      obs
                        .data
                        .filter(_.exists(_ != ' '))
                        .filterNot(_.isEmpty)
                        .map(createSimpleObservableInAlert(alert, obs, _))
                    )
              val (successes, failures) = successesAndFailures
                .foldLeft[(Seq[JsValue], Seq[JsValue])]((Nil, Nil)) {
                  case ((s, f), Right(o)) => (s :+ o, f)
                  case ((s, f), Left(o))  => (s, f :+ o)
                }
              if (failures.isEmpty) Results.Created(JsArray(successes))
              else Results.MultiStatus(Json.obj("success" -> successes, "failure" -> failures))
          }
      }

  private def createSimpleObservableInAlert(
      alert: Alert with Entity,
      inputObservable: InputObservable,
      data: String
  )(implicit authContext: AuthContext): Either[JsValue, JsValue] =
    db
      .tryTransaction { implicit graph =>
        alertSrv.createObservable(alert, inputObservable.toObservable, data)
      } match {
      case Success(o)     => Right(o.toJson)
      case Failure(error) => Left(errorHandler.toErrorResult(error)._2 + ("object" -> Json.obj("data" -> data)))
    }

  private def createAttachmentObservableInAlert(
      alert: Alert with Entity,
      inputObservable: InputObservable,
      attachment: AnyAttachmentType
  )(implicit authContext: AuthContext): Either[JsValue, JsValue] =
    db
      .tryTransaction { implicit graph =>
        object createAttachment extends Poly1 {
          implicit val fromFile: Case.Aux[FFile, Try[RichObservable]] = at[FFile] { file =>
            alertSrv.createObservable(alert, inputObservable.toObservable, file)
          }
          implicit val fromAttachment: Case.Aux[InputAttachment, Try[RichObservable]] = at[InputAttachment] { attachment =>
            for {
              attach <- attachmentSrv.duplicate(attachment.name, attachment.contentType, attachment.id)
              obs    <- alertSrv.createObservable(alert, inputObservable.toObservable, attach)
            } yield obs
          }

          implicit val fromString: Case.Aux[String, Try[RichObservable]] = at[String] { data =>
            data.split(';') match {
              case Array(filename, contentType, value) =>
                val data = Base64.getDecoder.decode(value)
                attachmentSrv
                  .create(filename, contentType, data)
                  .flatMap(attachment => alertSrv.createObservable(alert, inputObservable.toObservable, attachment))
              case Array(filename, contentType) =>
                attachmentSrv
                  .create(filename, contentType, Array.emptyByteArray)
                  .flatMap(attachment => alertSrv.createObservable(alert, inputObservable.toObservable, attachment))
              case data =>
                Failure(InvalidFormatAttributeError("artifacts.data", "filename;contentType;base64value", Set.empty, FString(data.mkString(";"))))
            }
          }
        }
        attachment.fold(createAttachment)
      } match {
      case Success(o) => Right(o.toJson)
      case Failure(error) =>
        object attachmentName extends Poly1 {
          implicit val fromFile: Case.Aux[FFile, String]                 = at[FFile](_.filename)
          implicit val fromAttachment: Case.Aux[InputAttachment, String] = at[InputAttachment](_.name)
          implicit val fromString: Case.Aux[String, String] = at[String] { data =>
            if (data.contains(';')) data.takeWhile(_ != ';') else "no name"
          }
        }
        val filename = attachment.fold(attachmentName)
        Left(errorHandler.toErrorResult(error)._2 + ("object" -> Json.obj("data" -> s"file:$filename", "attachment" -> Json.obj("name" -> filename))))
    }

  def get(observableId: String): Action[AnyContent] =
    entrypoint("get observable")
      .authRoTransaction(db) { implicit request => implicit graph =>
        observableSrv
          .get(EntityIdOrName(observableId))
          .visible(organisationSrv)
          .richObservable
          .getOrFail("Observable")
          .map { observable =>
            Results.Ok(observable.toJson)
          }
      }

  def update(observableId: String): Action[AnyContent] =
    entrypoint("update observable")
      .extract("observable", FieldsParser.update("observable", publicProperties))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("observable")
        observableSrv
          .update(_.get(EntityIdOrName(observableId)).canManage(organisationSrv), propertyUpdaters)
          .map(_ => Results.NoContent)
      }

  def updateAllTypes(fromType: String, toType: String): Action[AnyContent] =
    entrypoint("update all observable types")
      .authPermitted(Permissions.managePlatform) { implicit request =>
        db.roTransaction { implicit graph =>
          for {
            from <- observableTypeSrv.getOrFail(EntityIdOrName(fromType))
            to   <- observableTypeSrv.getOrFail(EntityIdOrName(toType))
            isSameType = from.isAttachment == to.isAttachment
            _ <- if (isSameType) Success(()) else Failure(BadRequestError("Can not update dataType: isAttachment does not match"))
          } yield (from, to)
        }.map {
          case (from, to) =>
            observableSrv
              .pagedTraversal(db, 100, _.has(_.dataType, from.name)) { t =>
                Some(
                  Try(
                    t.update(_.dataType, to.name)
                      .update(_._updatedAt, Some(new Date))
                      .update(_._updatedBy, Some(request.userId))
                      .iterate()
                  )
                )
              }
              .foreach(_.failed.foreach(error => logger.error(s"Error while updating observable type", error)))
            Results.NoContent
        }
      }

  def bulkUpdate: Action[AnyContent] =
    entrypoint("bulk update")
      .extract("input", FieldsParser.update("observable", publicProperties))
      .extract("ids", FieldsParser.seq[String].on("ids"))
      .authTransaction(db) { implicit request => implicit graph =>
        val properties: Seq[PropertyUpdater] = request.body("input")
        val ids: Seq[String]                 = request.body("ids")
        ids
          .toTry { id =>
            observableSrv
              .update(_.get(EntityIdOrName(id)).canManage(organisationSrv), properties)
          }
          .map(_ => Results.NoContent)
      }

  def delete(observableId: String): Action[AnyContent] =
    entrypoint("delete observable")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          observable <-
            observableSrv
              .get(EntityIdOrName(observableId))
              .canManage(organisationSrv)
              .getOrFail("Observable")
          _ <- observableSrv.delete(observable)
        } yield Results.NoContent
      }

  // extract a file from the archive and make sure its size matches the header (to protect against zip bombs)
  private def extractAndCheckSize(zipFile: ZipFile, header: FileHeader): Option[FFile] = {
    val fileName = header.getFileName
    if (fileName.contains('/')) None
    else {
      val file = temporaryFileCreator.create("zip")

      val input = zipFile.getInputStream(header)
      val size  = header.getUncompressedSize
      val sizedInput: FilterInputStream = new FilterInputStream(input) {
        var totalRead = 0

        override def read(): Int =
          if (totalRead < size) {
            totalRead += 1
            super.read()
          } else throw BadRequestError("Error extracting file: output size doesn't match header")
      }
      Files.delete(file)
      val fileSize = Files.copy(sizedInput, file)
      if (fileSize != size) {
        file.toFile.delete()
        throw InternalError("Error extracting file: output size doesn't match header")
      }
      input.close()
      val contentType = Option(Files.probeContentType(file)).getOrElse("application/octet-stream")
      Some(FFile(header.getFileName, file, contentType))
    }
  }

  private def getZipFiles(observable: InputObservable, zipPassword: Option[String]): Seq[InputObservable] =
    observable.attachment.flatMap(_.swap.toSeq).flatMap { attachment =>
      val zipFile = new ZipFile(attachment.filepath.toFile)
      val files   = zipFile.getFileHeaders.asScala

      if (zipFile.isEncrypted)
        zipFile.setPassword(zipPassword.getOrElse(configuration.get[String]("datastore.attachment.password")).toCharArray)

      files
        .filterNot(_.isDirectory)
        .flatMap(extractAndCheckSize(zipFile, _))
        .map(ffile => observable.copy(attachment = Seq(Left(ffile))))
    }
}

```

`thehive/app/org/thp/thehive/controllers/v1/ObservableRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.models.Observable
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.OrganisationSrv
import play.api.libs.json._

import java.lang.{Boolean => JBoolean, Long => JLong}
import java.util.{List => JList, Map => JMap}

trait ObservableRenderer extends BaseRenderer[Observable] {

  def seenStats(organisationSrv: OrganisationSrv)(implicit
      authContext: AuthContext
  ): Traversal.V[Observable] => Traversal[JsValue, JMap[JBoolean, JLong], Converter[JsValue, JMap[JBoolean, JLong]]] =
    _.filteredSimilar
      .visible(organisationSrv)
      .groupCount(_.byValue(_.ioc))
      .domainMap { stats =>
        val nTrue  = stats.getOrElse(true, 0L)
        val nFalse = stats.getOrElse(false, 0L)
        Json.obj(
          "seen" -> (nTrue + nFalse),
          "ioc"  -> (nTrue > 0)
        )
      }

  def sharesStats: Traversal.V[Observable] => Traversal[JsValue, JList[String], Converter[JsValue, JList[String]]] =
    _.organisations.value(_.name).fold.domainMap(Json.toJson(_))

  def shareCount: Traversal.V[Observable] => Traversal[JsValue, JLong, Converter[JsValue, JLong]] =
    _.organisations.count.domainMap(count => JsNumber(count.longValue() - 1))

  def isOwner(implicit
      authContext: AuthContext
  ): Traversal.V[Observable] => Traversal[JsValue, JList[Vertex], Converter[JsValue, JList[Vertex]]] =
    _.origin.get(authContext.organisation).fold.domainMap(l => JsBoolean(l.nonEmpty))

  def observableLinks: Traversal.V[Observable] => Traversal[JsValue, JMap[String, Any], Converter[JsValue, JMap[String, Any]]] =
    _.coalesceMulti(
      _.alert.richAlert.domainMap(a => Json.obj("alert" -> a.toJson)),
      _.`case`.richCaseWithoutPerms.domainMap(c => Json.obj("case" -> c.toJson))
    )

  def permissions(implicit authContext: AuthContext): Traversal.V[Observable] => Traversal[JsValue, Vertex, Converter[JsValue, Vertex]] =
    _.userPermissions.domainMap(permissions => Json.toJson(permissions))

  def observableStatsRenderer(organisationSrv: OrganisationSrv, extraData: Set[String])(implicit
      authContext: AuthContext
  ): Traversal.V[Observable] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "seen")        => addData("seen", f)(seenStats(organisationSrv))
        case (f, "shares")      => addData("shares", f)(sharesStats)
        case (f, "links")       => addData("links", f)(observableLinks)
        case (f, "permissions") => addData("permissions", f)(permissions)
        case (f, "isOwner")     => addData("isOwner", f)(isOwner)
        case (f, "shareCount")  => addData("shareCount", f)(shareCount)
        case (f, _)             => f
      }
    )
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/ObservableTypeCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputObservableType
import org.thp.thehive.models.{ObservableType, Permissions}
import org.thp.thehive.services.ObservableTypeSrv
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}

@Singleton
class ObservableTypeCtrl @Inject() (
    val entrypoint: Entrypoint,
    db: Database,
    observableTypeSrv: ObservableTypeSrv
) extends QueryableCtrl {
  override val entityName: String = "ObservableType"
  override val initialQuery: Query =
    Query.init[Traversal.V[ObservableType]]("listObservableType", (graph, _) => observableTypeSrv.startTraversal(graph))
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[ObservableType], IteratorOutput](
      "page",
      (range, observableTypeSteps, _) => observableTypeSteps.richPage(range.from, range.to, withTotal = true, limitedCountThreshold)(identity)
    )
  override val outputQuery: Query = Query.output[ObservableType with Entity]
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[ObservableType]](
    "getObservableType",
    (idOrName, graph, _) => observableTypeSrv.get(idOrName)(graph)
  )
  override val publicProperties: PublicProperties = PublicPropertyListBuilder[ObservableType]
    .property("name", UMapping.string)(_.field.readonly)
    .property("isAttachment", UMapping.boolean)(_.field.readonly)
    .build

  def get(idOrName: String): Action[AnyContent] =
    entrypoint("get observable type").authRoTransaction(db) { _ => implicit graph =>
      observableTypeSrv
        .get(EntityIdOrName(idOrName))
        .getOrFail("Observable")
        .map(ot => Results.Ok(ot.toJson))
    }

  def create: Action[AnyContent] =
    entrypoint("create observable type")
      .extract("observableType", FieldsParser[InputObservableType])
      .authPermittedTransaction(db, Permissions.manageObservableTemplate) { implicit request => implicit graph =>
        val inputObservableType: InputObservableType = request.body("observableType")
        observableTypeSrv
          .create(inputObservableType.toObservableType)
          .map(observableType => Results.Created(observableType.toJson))
      }

  def delete(idOrName: String): Action[AnyContent] =
    entrypoint("delete observable type")
      .authPermittedTransaction(db, Permissions.manageObservableTemplate) { _ => implicit graph =>
        observableTypeSrv.remove(EntityIdOrName(idOrName)).map(_ => Results.NoContent)
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/OrganisationCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.{ParamQuery, PropertyUpdater, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputOrganisation
import org.thp.thehive.models._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}

@Singleton
class OrganisationCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    organisationSrv: OrganisationSrv,
    userSrv: UserSrv,
    implicit val db: Database
) extends QueryableCtrl {

  override val entityName: String                 = "organisation"
  override val publicProperties: PublicProperties = properties.organisation
  override val initialQuery: Query =
    Query.init[Traversal.V[Organisation]](
      "listOrganisation",
      (graph, authContext) =>
        organisationSrv
          .startTraversal(graph)
          .visible(authContext)
    )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Organisation], IteratorOutput](
      "page",
      (range, organisationSteps, _) =>
        organisationSteps.richPage(range.from, range.to, range.extraData.contains("total"), limitedCountThreshold)(_.richOrganisation)
    )
  override val outputQuery: Query = Query.output[RichOrganisation, Traversal.V[Organisation]](_.richOrganisation)
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Organisation]](
    "getOrganisation",
    (idOrName, graph, authContext) => organisationSrv.get(idOrName)(graph).visible(authContext)
  )
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[Organisation], Traversal.V[Organisation]]("visible", (organisationSteps, _) => organisationSteps.visibleOrganisationsFrom),
    Query[Traversal.V[Organisation], Traversal.V[User]]("users", (organisationSteps, _) => organisationSteps.users.dedup),
    Query[Traversal.V[Organisation], Traversal.V[CaseTemplate]]("caseTemplates", (organisationSteps, _) => organisationSteps.caseTemplates),
    Query[Traversal.V[Organisation], Traversal.V[Alert]]("alerts", (organisationSteps, _) => organisationSteps.alerts)
  )

  def create: Action[AnyContent] =
    entrypoint("create organisation")
      .extract("organisation", FieldsParser[InputOrganisation])
      .authPermittedTransaction(db, Permissions.manageOrganisation) { implicit request => implicit graph =>
        val inputOrganisation: InputOrganisation = request.body("organisation")
        for {
          user         <- userSrv.current.getOrFail("User")
          organisation <- organisationSrv.create(inputOrganisation.toOrganisation, user)
        } yield Results.Created(organisation.toJson)
      }

  def get(organisationId: String): Action[AnyContent] =
    entrypoint("get organisation")
      .authRoTransaction(db) { implicit request => implicit graph =>
        (if (organisationSrv.current.isAdmin)
           organisationSrv.get(EntityIdOrName(organisationId))
         else
           userSrv
             .current
             .organisations
             .visibleOrganisationsFrom
             .get(EntityIdOrName(organisationId)))
          .richOrganisation
          .getOrFail("Organisation")
          .map(organisation => Results.Ok(organisation.toJson))
      }

  def update(organisationId: String): Action[AnyContent] =
    entrypoint("update organisation")
      .extract("organisation", FieldsParser.update("organisation", properties.organisation))
      .authPermittedTransaction(db, Permissions.manageOrganisation) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("organisation")
        for {
          organisation <- organisationSrv.getOrFail(EntityIdOrName(organisationId))
          _            <- organisationSrv.update(organisationSrv.get(organisation), propertyUpdaters)
        } yield Results.NoContent
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/PatternCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.{Entrypoint, FFile, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.query.{ParamQuery, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps.TraversalOpsDefs
import org.thp.scalligraph.traversal.{Graph, IteratorOutput, Traversal}
import org.thp.scalligraph.{BadRequestError, EntityIdOrName}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputPattern
import org.thp.thehive.models.{Pattern, Permissions, RichPattern}
import org.thp.thehive.services.PatternOps._
import org.thp.thehive.services.PatternSrv
import play.api.libs.json.{JsArray, Json}
import play.api.mvc.{Action, AnyContent, Results}

import java.io.FileInputStream
import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class PatternCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    patternSrv: PatternSrv,
    db: Database
) extends QueryableCtrl
    with PatternRenderer {
  override val entityName: String                 = "pattern"
  override val publicProperties: PublicProperties = properties.pattern
  override val initialQuery: Query = Query.init[Traversal.V[Pattern]](
    "listPattern",
    (graph, _) =>
      patternSrv
        .startTraversal(graph)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Pattern], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, extraData), patternSteps, _) =>
          patternSteps.richPage(from, to, extraData.contains("total"), limitedCountThreshold)(
            _.richPatternWithCustomRenderer(patternRenderer(extraData - "total"))
          )
      }
    )
  override val outputQuery: Query = Query.output[RichPattern, Traversal.V[Pattern]](_.richPattern)
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Pattern]](
    "getPattern",
    (idOrName, graph, _) => patternSrv.get(idOrName)(graph)
  )

  def importMitre: Action[AnyContent] =
    entrypoint("import MITRE ATT&CK patterns")
      .extract("file", FieldsParser.file.on("file"))
      .authPermitted(Permissions.managePattern) { implicit request =>
        val file: FFile = request.body("file")

        for {
          inputPatterns <- parseJsonFile(file)
          importedPatterns =
            inputPatterns
              .sortBy(_.external_id.length) // sort to create sub-patterns after their parent
              .foldLeft[JsArray](JsArray.empty) { (array, inputPattern) =>
                array :+ db.tryTransaction { implicit graph =>
                  createFromInput(inputPattern).transform(
                    t => Success(Json.obj("status" -> "Success", "mitreId" -> t.patternId, "patternName" -> t.name)),
                    e => Success(Json.obj("status" -> "Failure", "message" -> e.getMessage))
                  )
                }.get
              }
        } yield Results.Created(importedPatterns)
      }

  def get(patternId: String): Action[AnyContent] =
    entrypoint("get pattern")
      .authRoTransaction(db) { _ => implicit graph =>
        patternSrv
          .get(EntityIdOrName(patternId))
          .richPattern
          .getOrFail("Pattern")
          .map(richPattern => Results.Ok(richPattern.toJson))
      }

  def getCasePatterns(caseId: String): Action[AnyContent] =
    entrypoint("get case patterns")
      .authRoTransaction(db) { implicit request => implicit graph =>
        for {
          patterns <- patternSrv.getCasePatterns(caseId)
        } yield Results.Ok(patterns.toJson)
      }

  def delete(patternId: String): Action[AnyContent] =
    entrypoint("delete pattern")
      .authPermittedTransaction(db, Permissions.managePattern) { implicit request => implicit graph =>
        patternSrv
          .getOrFail(EntityIdOrName(patternId))
          .flatMap(patternSrv.remove)
          .map(_ => Results.NoContent)
      }

  private def parseJsonFile(file: FFile): Try[Seq[InputPattern]] =
    for {
      json <- Try(Json.parse(new FileInputStream(file.filepath.toString)))
    } yield (json \ "objects").as[Seq[InputPattern]]

  private def createFromInput(inputPattern: InputPattern)(implicit graph: Graph, authContext: AuthContext): Try[Pattern with Entity] =
    if (inputPattern.external_id.isEmpty)
      Failure(BadRequestError(s"A pattern with no MITRE id cannot be imported"))
    else if (inputPattern.`type` != "attack-pattern")
      Failure(BadRequestError(s"Only patterns with type attack-pattern are imported, this one is ${inputPattern.`type`}"))
    else if (patternSrv.startTraversal.alreadyImported(inputPattern.external_id))
      // Update a pattern
      for {
        pattern        <- patternSrv.get(EntityIdOrName(inputPattern.external_id)).getOrFail("Pattern")
        updatedPattern <- patternSrv.update(pattern, inputPattern.toPattern)
        _ = if (inputPattern.x_mitre_is_subtechnique) linkPattern(pattern)
      } yield updatedPattern
    else
      // Create a pattern
      for {
        pattern <- patternSrv.createEntity(inputPattern.toPattern)
        _ = if (inputPattern.x_mitre_is_subtechnique) linkPattern(pattern)
      } yield pattern

  private def linkPattern(child: Pattern with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val firstDot = child.patternId.indexOf(".")
    if (firstDot == -1)
      Failure(BadRequestError(s"Invalid sub-pattern patternId ${child.patternId} (must contain a dot"))
    else {
      val parentId = child.patternId.substring(0, firstDot)
      for {
        parent <- patternSrv.startTraversal.getByPatternId(parentId).getOrFail("Pattern")
        _      <- patternSrv.setParent(child, parent)
      } yield ()
    }
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/PatternRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models.Pattern
import org.thp.thehive.services.PatternOps._
import play.api.libs.json._

import java.util.{List => JList, Map => JMap}

trait PatternRenderer extends BaseRenderer[Pattern] {

  private def parent: Traversal.V[Pattern] => Traversal[JsValue, JList[JMap[String, Any]], Converter[JsValue, JList[JMap[String, Any]]]] =
    _.parent.richPattern.fold.domainMap(_.headOption.fold[JsValue](JsNull)(_.toJson))

  private def children: Traversal.V[Pattern] => Traversal[JsValue, JList[JMap[String, Any]], Converter[JsValue, JList[JMap[String, Any]]]] =
    _.children.richPattern.fold.domainMap(_.toJson)

  def patternRenderer(extraData: Set[String]): Traversal.V[Pattern] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "children") => addData("children", f)(children)
        case (f, "parent")   => addData("parent", f)(parent)
        case (f, _)          => f
      }
    )
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/ProcedureCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.{ParamQuery, PropertyUpdater, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps.TraversalOpsDefs
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputProcedure
import org.thp.thehive.models.{Permissions, Procedure, RichProcedure}
import org.thp.thehive.services.ProcedureOps._
import org.thp.thehive.services.ProcedureSrv
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}

@Singleton
class ProcedureCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    procedureSrv: ProcedureSrv,
    db: Database
) extends QueryableCtrl
    with ProcedureRenderer {
  override val entityName: String                 = "procedure"
  override val publicProperties: PublicProperties = properties.procedure
  override val initialQuery: Query = Query.init[Traversal.V[Procedure]](
    "listProcedure",
    (graph, _) =>
      procedureSrv
        .startTraversal(graph)
  )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Procedure], IteratorOutput](
      "page",
      (range, procedureSteps, _) =>
        procedureSteps.richPage(range.from, range.to, range.extraData.contains("total"), limitedCountThreshold)(
          _.richProcedureWithCustomRenderer(procedureStatsRenderer(range.extraData - "total"))
        )
    )
  override val outputQuery: Query = Query.output[RichProcedure, Traversal.V[Procedure]](_.richProcedure)
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Procedure]](
    "getProcedure",
    (idOrName, graph, _) => procedureSrv.get(idOrName)(graph)
  )

  def create: Action[AnyContent] =
    entrypoint("create procedure")
      .extract("procedure", FieldsParser[InputProcedure])
      .authPermittedTransaction(db, Permissions.manageProcedure) { implicit request => implicit graph =>
        val inputProcedure: InputProcedure = request.body("procedure")
        for {
          richProcedure <- procedureSrv.create(inputProcedure.toProcedure, inputProcedure.caseId, inputProcedure.patternId)
        } yield Results.Created(richProcedure.toJson)
      }

  def get(procedureId: String): Action[AnyContent] =
    entrypoint("get procedure")
      .authRoTransaction(db) { _ => implicit graph =>
        procedureSrv
          .get(EntityIdOrName(procedureId))
          .richProcedure
          .getOrFail("Procedure")
          .map(richProcedure => Results.Ok(richProcedure.toJson))
      }

  def update(procedureId: String): Action[AnyContent] =
    entrypoint("update procedure")
      .extract("procedure", FieldsParser.update("procedure", properties.procedure))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("procedure")
        procedureSrv
          .update(
            _.get(EntityIdOrName(procedureId)),
            propertyUpdaters
          )
          .map(_ => Results.NoContent)
      }

  def delete(procedureId: String): Action[AnyContent] =
    entrypoint("delete procedure")
      .authPermittedTransaction(db, Permissions.manageProcedure) { implicit request => implicit graph =>
        procedureSrv
          .getOrFail(EntityIdOrName(procedureId))
          .flatMap(procedureSrv.remove)
          .map(_ => Results.NoContent)
      }

}

```

`thehive/app/org/thp/thehive/controllers/v1/ProcedureRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.traversal.TraversalOps.TraversalOpsDefs
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models.Procedure
import org.thp.thehive.services.PatternOps._
import org.thp.thehive.services.ProcedureOps._
import play.api.libs.json.{JsNull, JsValue}

import java.util.{List => JList, Map => JMap}

trait ProcedureRenderer extends BaseRenderer[Procedure] {
  def patternStats: Traversal.V[Procedure] => Traversal[JsValue, JMap[String, Any], Converter[JsValue, JMap[String, Any]]] =
    _.pattern.richPattern.domainMap(_.toJson)

  def patternParentStats: Traversal.V[Procedure] => Traversal[JsValue, JList[JMap[String, Any]], Converter[JsValue, JList[JMap[String, Any]]]] =
    _.pattern.parent.richPattern.fold.domainMap(_.headOption.fold[JsValue](JsNull)(_.toJson))

  def procedureStatsRenderer(extraData: Set[String]): Traversal.V[Procedure] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "pattern")       => addData("pattern", f)(patternStats)
        case (f, "patternParent") => addData("patternParent", f)(patternParentStats)
        case (f, _)               => f
      }
    )
  }

}

```

`thehive/app/org/thp/thehive/controllers/v1/ProfileCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.query.{ParamQuery, PropertyUpdater, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.scalligraph.{AuthorizationError, EntityIdOrName}
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.InputProfile
import org.thp.thehive.models.{Permissions, Profile}
import org.thp.thehive.services.ProfileOps._
import org.thp.thehive.services.ProfileSrv
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.util.Failure

@Singleton
class ProfileCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    profileSrv: ProfileSrv,
    implicit val db: Database
) extends QueryableCtrl {

  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Profile]](
    "getProfile",
    (idOrName, graph, _) => profileSrv.get(idOrName)(graph)
  )
  val entityName: String                 = "profile"
  val publicProperties: PublicProperties = properties.profile

  val initialQuery: Query =
    Query.init[Traversal.V[Profile]]("listProfile", (graph, _) => profileSrv.startTraversal(graph))

  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Profile], IteratorOutput](
      "page",
      (range, profileSteps, _) => profileSteps.page(range.from, range.to, range.extraData.contains("total"), limitedCountThreshold)
    )
  override val outputQuery: Query = Query.output[Profile with Entity]

  def create: Action[AnyContent] =
    entrypoint("create profile")
      .extract("profile", FieldsParser[InputProfile])
      .authTransaction(db) { implicit request => implicit graph =>
        val profile: InputProfile = request.body("profile")
        if (request.isPermitted(Permissions.manageProfile))
          profileSrv.create(profile.toProfile).map(createdProfile => Results.Created(createdProfile.toJson))
        else
          Failure(AuthorizationError("You don't have permission to create profiles"))
      }

  def get(profileId: String): Action[AnyContent] =
    entrypoint("get profile")
      .authRoTransaction(db) { _ => implicit graph =>
        profileSrv
          .getOrFail(EntityIdOrName(profileId))
          .map { profile =>
            Results.Ok(profile.toJson)
          }
      }

  def update(profileId: String): Action[AnyContent] =
    entrypoint("update profile")
      .extract("profile", FieldsParser.update("profile", properties.profile))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("profile")
        if (request.isPermitted(Permissions.manageProfile))
          profileSrv
            .update(_.get(EntityIdOrName(profileId)), propertyUpdaters)
            .flatMap { case (profileSteps, _) => profileSteps.getOrFail("Profile") }
            .map(profile => Results.Ok(profile.toJson))
        else
          Failure(AuthorizationError("You don't have permission to update profiles"))
      }

  def delete(profileId: String): Action[AnyContent] =
    entrypoint("delete profile")
      .authPermittedTransaction(db, Permissions.manageProfile) { implicit request => implicit graph =>
        profileSrv
          .getOrFail(EntityIdOrName(profileId))
          .flatMap(profileSrv.remove)
          .map(_ => Results.NoContent)
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/Properties.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.apache.tinkerpop.gremlin.structure.T
import org.thp.scalligraph.controllers.{FPathElem, FPathEmpty, FString}
import org.thp.scalligraph.models.{Database, UMapping}
import org.thp.scalligraph.query.PredicateOps._
import org.thp.scalligraph.query.{PublicProperties, PublicPropertyListBuilder}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{BadRequestError, EntityId, EntityIdOrName, InvalidFormatAttributeError, RichSeq}
import org.thp.thehive.dto.v1.InputCustomFieldValue
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.CustomFieldOps._
import org.thp.thehive.services.DashboardOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.PatternOps._
import org.thp.thehive.services.ProcedureOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TagOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.TaxonomyOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.libs.json.{JsObject, JsValue, Json}

import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success}

@Singleton
class Properties @Inject() (
    alertSrv: AlertSrv,
    caseSrv: CaseSrv,
    taskSrv: TaskSrv,
    userSrv: UserSrv,
    dashboardSrv: DashboardSrv,
    caseTemplateSrv: CaseTemplateSrv,
    observableSrv: ObservableSrv,
    observableTypeSrv: ObservableTypeSrv,
    customFieldSrv: CustomFieldSrv,
    organisationSrv: OrganisationSrv,
    db: Database
) {

  lazy val metaProperties: PublicProperties =
    PublicPropertyListBuilder
      .forType[Product](_ => true)
      .property("_id", UMapping.entityId)(
        _.select(_._id)
          .filter[EntityId] {
            case (_, t, _, Right(p))   => t.has(T.id, p.mapValue(_.value))
            case (_, t, _, Left(true)) => t
            case (_, t, _, _)          => t.empty
          }
          .readonly
      )
      .property("_createdBy", UMapping.string)(_.field.readonly)
      .property("_createdAt", UMapping.date)(_.field.readonly)
      .property("_updatedBy", UMapping.string.optional)(_.field.readonly)
      .property("_updatedAt", UMapping.date.optional)(_.field.readonly)
      .build

  lazy val alert: PublicProperties =
    PublicPropertyListBuilder[Alert]
      .property("type", UMapping.string)(_.field.updatable)
      .property("source", UMapping.string)(_.field.updatable)
      .property("sourceRef", UMapping.string)(_.field.updatable)
      .property("title", UMapping.string)(_.field.updatable)
      .property("description", UMapping.string)(_.field.updatable)
      .property("severity", UMapping.int)(_.field.updatable)
      .property("date", UMapping.date)(_.field.updatable)
      .property("lastSyncDate", UMapping.date.optional)(_.field.updatable)
      .property("tags", UMapping.string.set)(
        _.field
          .custom { (_, value, vertex, graph, authContext) =>
            alertSrv
              .get(vertex)(graph)
              .getOrFail("Alert")
              .flatMap(alert => alertSrv.updateTags(alert, value)(graph, authContext))
              .map(_ => Json.obj("tags" -> value))
          }
      )
      .property("flag", UMapping.boolean)(_.field.updatable)
      .property("tlp", UMapping.int)(_.field.updatable)
      .property("pap", UMapping.int)(_.field.updatable)
      .property("read", UMapping.boolean)(_.field.updatable)
      .property("follow", UMapping.boolean)(_.field.updatable)
      .property("read", UMapping.boolean)(_.field.updatable)
      .property("imported", UMapping.boolean)(
        _.select(_.imported)
          .filter[Boolean]((_, alertTraversal, _, predicate) =>
            predicate.fold(
              b => if (b) alertTraversal else alertTraversal.empty,
              p =>
                if (p.getValue) alertTraversal.nonEmptyId(_.caseId)
                else alertTraversal.isEmptyId(_.caseId)
            )
          )
          .readonly
      )
      .property("summary", UMapping.string.optional)(_.field.updatable)
      .property("user", UMapping.string)(_.field.updatable)
      .property("customFields", UMapping.jsonNative)(_.subSelect {
        case (FPathElem(_, FPathElem(idOrName, _)), alerts) =>
          alerts
            .customFieldJsonValue(customFieldSrv, EntityIdOrName(idOrName))
        case (_, alerts) => alerts.customFields.nameJsonValue.fold.domainMap(JsObject(_))
      }
        .filter[JsValue] {
          case (FPathElem(_, FPathElem(name, _)), alerts, _, predicate) =>
            predicate match {
              case Right(predicate) => alerts.customFieldFilter(customFieldSrv, EntityIdOrName(name), predicate)
              case Left(true)       => alerts.hasCustomField(customFieldSrv, EntityIdOrName(name))
              case Left(false)      => alerts.hasNotCustomField(customFieldSrv, EntityIdOrName(name))
            }
          case (_, caseTraversal, _, _) => caseTraversal.empty
        }
        .custom {
          case (FPathElem(_, FPathElem(idOrName, _)), value, vertex, graph, authContext) =>
            for {
              a <- alertSrv.get(vertex)(graph).getOrFail("Alert")
              _ <- alertSrv.setOrCreateCustomField(a, InputCustomFieldValue(idOrName, Some(value), None))(graph, authContext)
            } yield Json.obj(s"customField.$idOrName" -> value)
          case (FPathElem(_, FPathEmpty), values: JsObject, vertex, graph, authContext) =>
            for {
              c   <- alertSrv.get(vertex)(graph).getOrFail("Alert")
              cfv <- values.fields.toTry { case (n, v) => customFieldSrv.getOrFail(EntityIdOrName(n))(graph).map(_ -> v) }
              _   <- alertSrv.updateCustomField(c, cfv)(graph, authContext)
            } yield Json.obj("customFields" -> values)
          case _ => Failure(BadRequestError("Invalid custom fields format"))
        })
      .property("case", db.idMapping)(_.select(_.`case`._id).readonly)
      .property("importDate", UMapping.date.optional)(_.select(_.importDate).readonly)
      .property("computed.handlingDuration", UMapping.long)(_.select(_.handlingDuration).readonly)
      .property("computed.handlingDurationInSeconds", UMapping.long)(_.select(_.handlingDuration.math("_ / 1000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInMinutes", UMapping.long)(_.select(_.handlingDuration.math("_ / 60000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInHours", UMapping.long)(_.select(_.handlingDuration.math("_ / 3600000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInDays", UMapping.long)(_.select(_.handlingDuration.math("_ / 86400000").domainMap(_.toLong)).readonly)
      .build

  lazy val audit: PublicProperties =
    PublicPropertyListBuilder[Audit]
      .property("operation", UMapping.string)(_.rename("action").readonly)
      .property("details", UMapping.string)(_.field.readonly)
      .property("objectType", UMapping.string.optional)(_.field.readonly)
      .property("objectId", UMapping.string.optional)(_.field.readonly)
      .property("base", UMapping.boolean)(_.rename("mainAction").readonly)
      .property("startDate", UMapping.date)(_.rename("_createdAt").readonly)
      .property("requestId", UMapping.string)(_.field.readonly)
      .property("rootId", db.idMapping)(_.select(_.context._id).readonly)
      .build

  lazy val `case`: PublicProperties =
    PublicPropertyListBuilder[Case]
      .property("title", UMapping.string)(_.field.updatable)
      .property("description", UMapping.string)(_.field.updatable)
      .property("severity", UMapping.int)(_.field.updatable)
      .property("startDate", UMapping.date)(_.field.updatable)
      .property("endDate", UMapping.date.optional)(_.field.updatable)
      .property("number", UMapping.int)(_.field.readonly)
      .property("tags", UMapping.string.set)(
        _.field.custom { (_, value, vertex, graph, authContext) =>
          caseSrv
            .get(vertex)(graph)
            .getOrFail("Case")
            .flatMap(`case` => caseSrv.updateTags(`case`, value)(graph, authContext))
            .map(_ => Json.obj("tags" -> value))
        }
      )
      .property("flag", UMapping.boolean)(_.field.updatable)
      .property("tlp", UMapping.int)(_.field.updatable)
      .property("pap", UMapping.int)(_.field.updatable)
      .property("status", UMapping.enum[CaseStatus.type])(_.field.updatable)
      .property("summary", UMapping.string.optional)(_.field.updatable)
      .property("actionRequired", UMapping.boolean)(_.authSelect((t, auth) => t.isActionRequired(auth)).readonly)
      .property("assignee", UMapping.string.optional)(_.field.custom { (_, login, vertex, graph, authContext) =>
        for {
          c    <- caseSrv.get(vertex)(graph).getOrFail("Case")
          user <- login.map(u => userSrv.get(EntityIdOrName(u))(graph).getOrFail("User")).flip
          _ <- user match {
            case Some(u) => caseSrv.assign(c, u)(graph, authContext)
            case None    => caseSrv.unassign(c)(graph, authContext)
          }
        } yield Json.obj("owner" -> user.map(_.login))
      })
      .property("impactStatus", UMapping.string.optional)(_.field.custom { (_, value, vertex, graph, authContext) =>
        caseSrv
          .get(vertex)(graph)
          .getOrFail("Case")
          .flatMap { c =>
            value.fold(caseSrv.unsetImpactStatus(c)(graph, authContext))(caseSrv.setImpactStatus(c, _)(graph, authContext))
          }
          .map(_ => Json.obj("impactStatus" -> value))
      })
      .property("resolutionStatus", UMapping.string.optional)(_.field.custom { (_, value, vertex, graph, authContext) =>
        caseSrv
          .get(vertex)(graph)
          .getOrFail("Case")
          .flatMap { c =>
            value.fold(caseSrv.unsetResolutionStatus(c)(graph, authContext))(caseSrv.setResolutionStatus(c, _)(graph, authContext))
          }
          .map(_ => Json.obj("resolutionStatus" -> value))
      })
      .property("customFields", UMapping.jsonNative)(_.subSelect {
        case (FPathElem(_, FPathElem(idOrName, _)), caseSteps) =>
          caseSteps
            .customFieldJsonValue(customFieldSrv, EntityIdOrName(idOrName))
        case (_, caseSteps) => caseSteps.customFields.nameJsonValue.fold.domainMap(JsObject(_))
      }
        .filter[JsValue] {
          case (FPathElem(_, FPathElem(name, _)), caseTraversal, _, predicate) =>
            predicate match {
              case Right(predicate) => caseTraversal.customFieldFilter(customFieldSrv, EntityIdOrName(name), predicate)
              case Left(true)       => caseTraversal.hasCustomField(customFieldSrv, EntityIdOrName(name))
              case Left(false)      => caseTraversal.hasNotCustomField(customFieldSrv, EntityIdOrName(name))
            }
          case (_, caseTraversal, _, _) => caseTraversal.empty
        }
        .custom {
          case (FPathElem(_, FPathElem(idOrName, _)), value, vertex, graph, authContext) =>
            for {
              c <- caseSrv.get(vertex)(graph).getOrFail("Case")
              _ <- caseSrv.setOrCreateCustomField(c, EntityIdOrName(idOrName), Some(value), None)(graph, authContext)
            } yield Json.obj(s"customField.$idOrName" -> value)
          case (FPathElem(_, FPathEmpty), values: JsObject, vertex, graph, authContext) =>
            for {
              c   <- caseSrv.get(vertex)(graph).getOrFail("Case")
              cfv <- values.fields.toTry { case (n, v) => customFieldSrv.getOrFail(EntityIdOrName(n))(graph).map(cf => (cf, v, None)) }
              _   <- caseSrv.updateCustomField(c, cfv)(graph, authContext)
            } yield Json.obj("customFields" -> values)
          case _ => Failure(BadRequestError("Invalid custom fields format"))
        })
      .property("computed.handlingDuration", UMapping.long)(_.select(_.handlingDuration).readonly)
      .property("computed.handlingDurationInSeconds", UMapping.long)(_.select(_.handlingDuration.math("_ / 1000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInMinutes", UMapping.long)(_.select(_.handlingDuration.math("_ / 60000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInHours", UMapping.long)(_.select(_.handlingDuration.math("_ / 3600000").domainMap(_.toLong)).readonly)
      .property("computed.handlingDurationInDays", UMapping.long)(_.select(_.handlingDuration.math("_ / 86400000").domainMap(_.toLong)).readonly)
      .property("viewingOrganisation", UMapping.string)(
        _.select(t => t.value(_.organisationIds).domainMap(organisationSrv.getName(_)(t.graph)))
          .filter[String] {
            case (_, caseTraversal, _, Right(orgNamePredicate)) =>
              val organisationId = orgNamePredicate.mapValue(o => organisationSrv.getId(EntityIdOrName(o))(caseTraversal.graph))
              caseTraversal.has(_.organisationIds, organisationId)
            case (_, caseTraversal, _, Left(true)) =>
              caseTraversal
            case (_, caseTraversal, _, Left(false)) =>
              caseTraversal.empty
          }
          .readonly
      )
      .property("owningOrganisation", UMapping.string)(
        _.select(t => t.value(_.owningOrganisation).domainMap(organisationSrv.getName(_)(t.graph)))
          .filter[String] {
            case (_, caseTraversal, _, Right(orgNamePredicate)) =>
              val organisationId = orgNamePredicate.mapValue(o => organisationSrv.getId(EntityIdOrName(o))(caseTraversal.graph))
              caseTraversal.has(_.owningOrganisation, organisationId)
            case (_, caseTraversal, _, Left(true)) =>
              caseTraversal
            case (_, caseTraversal, _, Left(false)) =>
              caseTraversal.empty
          }
          .readonly
      )
      .property("patternId", UMapping.string.sequence)(_.select(_.procedure.pattern.value(_.patternId)).readonly)
      .build

  lazy val caseTemplate: PublicProperties =
    PublicPropertyListBuilder[CaseTemplate]
      .property("name", UMapping.string)(_.field.updatable)
      .property("displayName", UMapping.string)(_.field.updatable)
      .property("titlePrefix", UMapping.string.optional)(_.field.updatable)
      .property("description", UMapping.string.optional)(_.field.updatable)
      .property("severity", UMapping.int.optional)(_.field.updatable)
      .property("tags", UMapping.string.set)(
        _.field
          .custom { (_, value, vertex, graph, authContext) =>
            caseTemplateSrv
              .get(vertex)(graph)
              .getOrFail("CaseTemplate")
              .flatMap(caseTemplate => caseTemplateSrv.updateTags(caseTemplate, value)(graph, authContext))
              .map(_ => Json.obj("tags" -> value))
          }
      )
      .property("flag", UMapping.boolean)(_.field.updatable)
      .property("tlp", UMapping.int.optional)(_.field.updatable)
      .property("pap", UMapping.int.optional)(_.field.updatable)
      .property("summary", UMapping.string.optional)(_.field.updatable)
      .property("user", UMapping.string)(_.field.updatable)
      .property("customFields", UMapping.jsonNative)(_.subSelect {
        case (FPathElem(_, FPathElem(idOrName, _)), caseTemplateSteps) =>
          caseTemplateSteps
            .customFieldJsonValue(customFieldSrv, EntityIdOrName(idOrName))
        case (_, caseTemplateSteps) => caseTemplateSteps.customFields.nameJsonValue.fold.domainMap(JsObject(_))
      }
        .filter[JsValue] {
          case (FPathElem(_, FPathElem(name, _)), caseTemplateTraversal, _, predicate) =>
            predicate match {
              case Right(predicate) => caseTemplateTraversal.customFieldFilter(customFieldSrv, EntityIdOrName(name), predicate)
              case Left(true)       => caseTemplateTraversal.hasCustomField(customFieldSrv, EntityIdOrName(name))
              case Left(false)      => caseTemplateTraversal.hasNotCustomField(customFieldSrv, EntityIdOrName(name))
            }
          case (_, caseTraversal, _, _) => caseTraversal.empty
        }
        .custom {
          case (FPathElem(_, FPathElem(idOrName, _)), value, vertex, graph, authContext) =>
            for {
              c <- caseTemplateSrv.get(vertex)(graph).getOrFail("CaseTemplate")
              _ <- caseTemplateSrv.setOrCreateCustomField(c, EntityIdOrName(idOrName), Some(value), None)(graph, authContext)
            } yield Json.obj(s"customField.$idOrName" -> value)
          case (FPathElem(_, FPathEmpty), values: JsObject, vertex, graph, authContext) =>
            for {
              c   <- caseTemplateSrv.get(vertex)(graph).getOrFail("CaseTemplate")
              cfv <- values.fields.toTry { case (n, v) => customFieldSrv.getOrFail(EntityIdOrName(n))(graph).map(cf => (cf, v, None)) }
              _   <- caseTemplateSrv.updateCustomField(c, cfv)(graph, authContext)
            } yield Json.obj("customFields" -> values)
          case _ => Failure(BadRequestError("Invalid custom fields format"))
        })
      .build

  lazy val organisation: PublicProperties =
    PublicPropertyListBuilder[Organisation]
      .property("name", UMapping.string)(_.field.updatable)
      .property("description", UMapping.string)(_.field.updatable)
      .build

  lazy val pattern: PublicProperties =
    PublicPropertyListBuilder[Pattern]
      .property("patternId", UMapping.string)(_.field.readonly)
      .property("name", UMapping.string)(_.field.readonly)
      .property("description", UMapping.string.optional)(_.field.updatable)
      .property("tactics", UMapping.string.set)(_.field.readonly)
      .property("url", UMapping.string)(_.field.updatable)
      .property("patternType", UMapping.string)(_.field.readonly)
      .property("capecId", UMapping.string.optional)(_.field.readonly)
      .property("capecUrl", UMapping.string.optional)(_.field.readonly)
      .property("revoked", UMapping.boolean)(_.field.readonly)
      .property("dataSources", UMapping.string.sequence)(_.field.readonly)
      .property("defenseBypassed", UMapping.string.sequence)(_.field.readonly)
      .property("detection", UMapping.string.optional)(_.field.readonly)
      .property("permissionsRequired", UMapping.string.sequence)(_.field.readonly)
      .property("platforms", UMapping.string.sequence)(_.field.readonly)
      .property("remoteSupport", UMapping.boolean)(_.field.readonly)
      .property("systemRequirements", UMapping.string.sequence)(_.field.readonly)
      .property("version", UMapping.string.optional)(_.field.readonly)
      .property("parent", UMapping.string.optional)(_.select(_.parent.value(_.patternId)).readonly)
      .build

  lazy val procedure: PublicProperties =
    PublicPropertyListBuilder[Procedure]
      .property("description", UMapping.string)(_.field.updatable)
      .property("occurDate", UMapping.date)(_.field.updatable)
      .property("tactic", UMapping.string)(_.field.updatable)
      .property("patternId", UMapping.string)(_.select(_.pattern.value(_.patternId)).readonly)
      .build

  lazy val profile: PublicProperties =
    PublicPropertyListBuilder[Profile]
      .property("name", UMapping.string)(_.field.updatable)
      .property("permissions", UMapping.string.set)(_.field.updatable)
      .build

  lazy val share: PublicProperties =
    PublicPropertyListBuilder[Share]
      .property("caseId", UMapping.entityId)(_.select(_.`case`._id).readonly)
      .property("caseNumber", UMapping.int)(_.select(_.`case`.value(_.number)).readonly)
      .property("organisationId", UMapping.entityId)(_.select(_.organisation._id).readonly)
      .property("organisationName", UMapping.string)(_.select(_.organisation.value(_.name)).readonly)
      .property("profileId", UMapping.entityId)(_.select(_.profile._id).readonly)
      .property("profileName", UMapping.string)(_.select(_.profile.value(_.name)).readonly)
      .property("owner", UMapping.boolean)(_.field.readonly)
      .build

  lazy val task: PublicProperties =
    PublicPropertyListBuilder[Task]
      .property("title", UMapping.string)(_.field.updatable)
      .property("description", UMapping.string.optional)(_.field.updatable)
      .property("status", UMapping.string)(_.field.updatable)
      .property("flag", UMapping.boolean)(_.field.updatable)
      .property("startDate", UMapping.date.optional)(_.field.updatable)
      .property("endDate", UMapping.date.optional)(_.field.updatable)
      .property("order", UMapping.int)(_.field.updatable)
      .property("dueDate", UMapping.date.optional)(_.field.updatable)
      .property("group", UMapping.string)(_.field.updatable)
      .property("assignee", UMapping.string.optional)(_.field.custom {
        case (_, value, vertex, graph, authContext) =>
          taskSrv
            .get(vertex)(graph)
            .getOrFail("Task")
            .flatMap { task =>
              value.fold(taskSrv.unassign(task)(graph, authContext)) { user =>
                userSrv
                  .get(EntityIdOrName(user))(graph)
                  .getOrFail("User")
                  .flatMap(taskSrv.assign(task, _)(graph, authContext))
              }
            }
            .map(_ => Json.obj("assignee" -> value))
      })
      .property("actionRequired", UMapping.boolean)(_.authSelect { (t, authContext) =>
        t.actionRequired(authContext)
      }.readonly)
      .build

  lazy val log: PublicProperties =
    PublicPropertyListBuilder[Log]
      .property("message", UMapping.string)(_.field.updatable)
      .property("deleted", UMapping.boolean)(_.field.updatable)
      .property("date", UMapping.date)(_.field.readonly)
      .property("attachment.name", UMapping.string.optional)(_.select(_.attachments.value(_.name)).readonly)
      .property("attachment.hashes", UMapping.hash.sequence)(_.select(_.attachments.value(_.hashes)).readonly)
      .property("attachment.size", UMapping.long.optional)(_.select(_.attachments.value(_.size)).readonly)
      .property("attachment.contentType", UMapping.string.optional)(_.select(_.attachments.value(_.contentType)).readonly)
      .property("attachment.id", UMapping.string.optional)(_.select(_.attachments.value(_.attachmentId)).readonly)
      .build

  lazy val user: PublicProperties =
    PublicPropertyListBuilder[User]
      .property("login", UMapping.string)(_.field.readonly)
      .property("name", UMapping.string)(_.field.readonly)
      .property("locked", UMapping.boolean)(_.field.readonly)
      .property("avatar", UMapping.string.optional)(_.select(_.avatar.value(_.attachmentId).domainMap(id => s"/api/datastore/$id")).readonly)
      .property("profile", UMapping.string)(_.authSelect((users, authContext) => users.profile(authContext.organisation).value(_.name)).readonly)
      .build

  lazy val observable: PublicProperties =
    PublicPropertyListBuilder[Observable]
      .property("status", UMapping.string)(_.select(_.constant("Ok")).readonly)
      .property("startDate", UMapping.date)(_.select(_._createdAt).readonly)
      .property("ioc", UMapping.boolean)(_.field.updatable)
      .property("sighted", UMapping.boolean)(_.field.updatable)
      .property("ignoreSimilarity", UMapping.boolean)(_.field.updatable)
      .property("tags", UMapping.string.set)(
        _.field.custom { (_, value, vertex, graph, authContext) =>
          observableSrv
            .getOrFail(vertex)(graph)
            .flatMap(observable => observableSrv.updateTags(observable, value)(graph, authContext))
            .map(_ => Json.obj("tags" -> value))
        }
      )
      .property("message", UMapping.string)(_.field.updatable)
      .property("tlp", UMapping.int)(_.field.updatable)
      .property("dataType", UMapping.string)(_.field.custom { (_, value, vertex, graph, authContext) =>
        val observable = observableSrv.model.converter(vertex)
        for {
          currentDataType <- observableTypeSrv.getByName(observable.dataType)(graph).getOrFail("ObservableType")
          newDataType     <- observableTypeSrv.getByName(value)(graph).getOrFail("ObservableType")
          isSameType = currentDataType.isAttachment == newDataType.isAttachment
          _ <- if (isSameType) Success(()) else Failure(BadRequestError("Can not update dataType: isAttachment does not match"))
          _ <- observableSrv.updateType(observable, newDataType)(graph, authContext)
        } yield Json.obj("dataType" -> value)
      })
      .property("data", UMapping.string.optional)(
        _.select(_.value(_.data))
          .filter[String] {
            case (_, observables, _, Right(predicate)) => observables.has(_.data, predicate.mapValue(v => UseHashToIndex.hashToIndex(v).getOrElse(v)))
            case (_, observables, _, Left(true))       => observables.has(_.data)
            case (_, observables, _, Left(false))      => observables.hasNot(_.data)
          }
          .readonly
      )
      .property("attachment.name", UMapping.string.optional)(_.select(_.attachments.value(_.name)).readonly)
      .property("attachment.hashes", UMapping.hash.sequence)(_.select(_.attachments.value(_.hashes)).readonly)
      .property("attachment.size", UMapping.long.optional)(_.select(_.attachments.value(_.size)).readonly)
      .property("attachment.contentType", UMapping.string.optional)(_.select(_.attachments.value(_.contentType)).readonly)
      .property("attachment.id", UMapping.string.optional)(_.field.readonly)
      .build

  lazy val taxonomy: PublicProperties =
    PublicPropertyListBuilder[Taxonomy]
      .property("namespace", UMapping.string)(_.field.readonly)
      .property("description", UMapping.string)(_.field.readonly)
      .property("version", UMapping.int)(_.field.readonly)
      .property("enabled", UMapping.boolean)(_.select(_.enabled).readonly)
      .build

  lazy val tag: PublicProperties =
    PublicPropertyListBuilder[Tag]
      .property("namespace", UMapping.string)(_.field.readonly)
      .property("predicate", UMapping.string)(_.field.updatable)
      .property("value", UMapping.string.optional)(_.field.readonly)
      .property("description", UMapping.string.optional)(_.field.updatable)
      .property("colour", UMapping.string)(_.field.updatable)
      .property("text", UMapping.string)(
        _.select(_.displayName)
          .filter[String] {
            case (_, tags, authContext, Right(predicate)) => tags.freetags(organisationSrv)(authContext).has(_.predicate, predicate)
            case (_, tags, _, Left(true))                 => tags
            case (_, tags, _, Left(false))                => tags.empty
          }
          .readonly
      )
      .build

  lazy val dashboard: PublicProperties = PublicPropertyListBuilder[Dashboard]
    .property("title", UMapping.string)(_.field.updatable)
    .property("description", UMapping.string)(_.field.updatable)
    .property("definition", UMapping.string)(_.field.updatable)
    .property("status", UMapping.string)(
      _.select(_.choose(_.organisation, "Shared", "Private"))
        .custom {
          case (_, "Shared", vertex, graph, authContext) =>
            for {
              dashboard <- dashboardSrv.get(vertex)(graph).filter(_.user.current(authContext)).getOrFail("Dashboard")
              _         <- dashboardSrv.share(dashboard, authContext.organisation, writable = true)(graph, authContext)
            } yield Json.obj("status" -> "Shared")

          case (_, "Private", vertex, graph, authContext) =>
            for {
              d <- dashboardSrv.get(vertex)(graph).filter(_.user.current(authContext)).getOrFail("Dashboard")
              _ <- dashboardSrv.unshare(d, authContext.organisation)(graph, authContext)
            } yield Json.obj("status" -> "Private")

          case (_, "Deleted", vertex, graph, authContext) =>
            for {
              d <- dashboardSrv.get(vertex)(graph).filter(_.user.current(authContext)).getOrFail("Dashboard")
              _ <- dashboardSrv.remove(d)(graph, authContext)
            } yield Json.obj("status" -> "Deleted")

          case (_, status, _, _, _) =>
            Failure(InvalidFormatAttributeError("status", "String", Set("Shared", "Private", "Deleted"), FString(status)))
        }
    )
    .build

}

```

`thehive/app/org/thp/thehive/controllers/v1/QueryableCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.query.{ParamQuery, PublicProperties, Query}

trait QueryableCtrl {
  val entityName: String
  val publicProperties: PublicProperties
  val initialQuery: Query
  def pageQuery(limitedCountThreshold: Long): ParamQuery[_]
  val outputQuery: Query
  val getQuery: ParamQuery[EntityIdOrName]
  val extraQueries: Seq[ParamQuery[_]] = Nil
}

```

`thehive/app/org/thp/thehive/controllers/v1/Router.scala`:

```scala
package org.thp.thehive.controllers.v1

import play.api.routing.Router.Routes
import play.api.routing.SimpleRouter
import play.api.routing.sird._

import javax.inject.{Inject, Singleton}

@Singleton
class Router @Inject() (
    adminCtrl: AdminCtrl,
    authenticationCtrl: AuthenticationCtrl,
    alertCtrl: AlertCtrl,
    // attachmentCtrl: AttachmentCtrl,
    auditCtrl: AuditCtrl,
    caseCtrl: CaseCtrl,
    caseTemplateCtrl: CaseTemplateCtrl,
    // configCtrl: ConfigCtrl,
    customFieldCtrl: CustomFieldCtrl,
    // dashboardCtrl: DashboardCtrl,
    describeCtrl: DescribeCtrl,
    logCtrl: LogCtrl,
    monitoringCtrl: MonitoringCtrl,
    observableCtrl: ObservableCtrl,
    observableTypeCtrl: ObservableTypeCtrl,
    organisationCtrl: OrganisationCtrl,
    // pageCtrl: PageCtrl,
    // permissionCtrl: PermissionCtrl,
    patternCtrl: PatternCtrl,
    procedureCtrl: ProcedureCtrl,
    profileCtrl: ProfileCtrl,
    tagCtrl: TagCtrl,
    taskCtrl: TaskCtrl,
    shareCtrl: ShareCtrl,
    taxonomyCtrl: TaxonomyCtrl,
    // shareCtrl: ShareCtrl,
    userCtrl: UserCtrl,
    statusCtrl: StatusCtrl
    // streamCtrl: StreamCtrl,
) extends SimpleRouter {

  override def routes: Routes = {
    case GET(p"/status") => statusCtrl.get
//    GET  /health                              controllers.StatusCtrl.health

    case GET(p"/admin/check/stats")                                                            => adminCtrl.checkStats
    case GET(p"/admin/check/$name/trigger")                                                    => adminCtrl.triggerGlobalCheck(name)
    case POST(p"/admin/check/$name/global/trigger")                                            => adminCtrl.triggerGlobalCheck(name)
    case POST(p"/admin/check/$name/dedup/trigger")                                             => adminCtrl.triggerDedup(name)
    case POST(p"/admin/check/cancel")                                                          => adminCtrl.cancelCurrentCheck
    case GET(p"/admin/index/status")                                                           => adminCtrl.indexStatus
    case POST(p"/admin/index/$name/reindex")                                                   => adminCtrl.reindex(name)
    case POST(p"/admin/index/$name/rebuild")                                                   => adminCtrl.rebuild(name)
    case GET(p"/admin/log/set/$packageName/$level")                                            => adminCtrl.setLogLevel(packageName, level)
    case POST(p"/admin/schema/repair/$schemaName" ? q_o"select=$select" ? q_o"filter=$filter") => adminCtrl.schemaRepair(schemaName, select, filter)
    case POST(p"/admin/schema/info/$schemaName" ? q_o"select=$select" ? q_o"filter=$filter")   => adminCtrl.schemaInfo(schemaName, select, filter)

//    GET      /logout                              controllers.AuthenticationCtrl.logout()
    case GET(p"/logout")                 => authenticationCtrl.logout
    case POST(p"/logout")                => authenticationCtrl.logout
    case POST(p"/login")                 => authenticationCtrl.login
    case POST(p"/auth/totp/set")         => authenticationCtrl.totpSetSecret
    case POST(p"/auth/totp/unset")       => authenticationCtrl.totpUnsetSecret(None)
    case POST(p"/auth/totp/unset/$user") => authenticationCtrl.totpUnsetSecret(Some(user))

    case POST(p"/case")                     => caseCtrl.create
    case GET(p"/case/$caseId")              => caseCtrl.get(caseId)
    case PATCH(p"/case/$caseId")            => caseCtrl.update(caseId)
    case POST(p"/case/_merge/$caseIds")     => caseCtrl.merge(caseIds)
    case DELETE(p"/case/$caseId")           => caseCtrl.delete(caseId)
    case DELETE(p"/case/customField/$cfId") => caseCtrl.deleteCustomField(cfId)
    //    case PATCH(p"api/case/_bulk") =>                          caseCtrl.bulkUpdate()
//    case POST(p"/case/_stats") =>                        caseCtrl.stats()
//    case GET(p"/case/$caseId/links") =>                  caseCtrl.linkedCases(caseId)

    case POST(p"/case/$caseId/observable")    => observableCtrl.createInCase(caseId)
    case POST(p"/alert/$alertId/artifact")    => observableCtrl.createInAlert(alertId)
    case GET(p"/observable/$observableId")    => observableCtrl.get(observableId)
    case DELETE(p"/observable/$observableId") => observableCtrl.delete(observableId)
    case PATCH(p"/observable/_bulk")          => observableCtrl.bulkUpdate
    case PATCH(p"/observable/$observableId")  => observableCtrl.update(observableId)
//    case GET(p"/observable/$observableId/similar") => observableCtrl.findSimilar(observableId)
    case POST(p"/observable/$observableId/shares")         => shareCtrl.shareObservable(observableId)
    case PUT(p"/observable/type/update/$fromType/$toType") => observableCtrl.updateAllTypes(fromType, toType)

    case GET(p"/caseTemplate")                   => caseTemplateCtrl.list
    case POST(p"/caseTemplate")                  => caseTemplateCtrl.create
    case GET(p"/caseTemplate/$caseTemplateId")   => caseTemplateCtrl.get(caseTemplateId)
    case PATCH(p"/caseTemplate/$caseTemplateId") => caseTemplateCtrl.update(caseTemplateId)
    //case DELETE(p"/caseTemplate/$caseTemplateId") => caseTemplateCtrl.delete(caseTemplateId)

    case POST(p"/user")                                                   => userCtrl.create
    case GET(p"/user/current")                                            => userCtrl.current
    case GET(p"/user/$userId")                                            => userCtrl.get(userId)
    case PATCH(p"/user/$userId")                                          => userCtrl.update(userId)
    case DELETE(p"/user/$userId")                                         => userCtrl.lock(userId)
    case DELETE(p"/user/$userId/force" ? q_o"organisation=$organisation") => userCtrl.delete(userId, organisation)
    case POST(p"/user/$userId/password/set")                              => userCtrl.setPassword(userId)
    case POST(p"/user/$userId/password/change")                           => userCtrl.changePassword(userId)
    case GET(p"/user/$userId/key")                                        => userCtrl.getKey(userId)
    case DELETE(p"/user/$userId/key")                                     => userCtrl.removeKey(userId)
    case POST(p"/user/$userId/key/renew")                                 => userCtrl.renewKey(userId)
    case GET(p"/user/$userId/avatar$file*")                               => userCtrl.avatar(userId)
    case POST(p"/user/$userId/reset")                                     => userCtrl.resetFailedAttempts(userId)

    case POST(p"/organisation")                  => organisationCtrl.create
    case GET(p"/organisation/$organisationId")   => organisationCtrl.get(organisationId)
    case PATCH(p"/organisation/$organisationId") => organisationCtrl.update(organisationId)

    case DELETE(p"/case/shares")                               => shareCtrl.removeShares()
    case POST(p"/case/$caseId/shares")                         => shareCtrl.shareCase(caseId)
    case DELETE(p"/case/$caseId/shares")                       => shareCtrl.removeShares(caseId)
    case DELETE(p"/task/$taskId/shares")                       => shareCtrl.removeTaskShares(taskId)
    case DELETE(p"/observable/$observableId/shares")           => shareCtrl.removeObservableShares(observableId)
    case GET(p"/case/$caseId/shares")                          => shareCtrl.listShareCases(caseId)
    case GET(p"/case/$caseId/task/$taskId/shares")             => shareCtrl.listShareTasks(caseId, taskId)
    case GET(p"/case/$caseId/observable/$observableId/shares") => shareCtrl.listShareObservables(caseId, observableId)
    case POST(p"/case/task/$taskId/shares")                    => shareCtrl.shareTask(taskId)
    case DELETE(p"/case/share/$shareId")                       => shareCtrl.removeShare(shareId)
    case PATCH(p"/case/share/$shareId")                        => shareCtrl.updateShare(shareId)

    case GET(p"/task")                                => taskCtrl.list
    case POST(p"/task")                               => taskCtrl.create
    case GET(p"/task/$taskId")                        => taskCtrl.get(taskId)
    case PATCH(p"/task/_bulk")                        => taskCtrl.bulkUpdate
    case PATCH(p"/task/$taskId")                      => taskCtrl.update(taskId)
    case GET(p"/task/$taskId/actionRequired")         => taskCtrl.isActionRequired(taskId)
    case PUT(p"/task/$taskId/actionRequired/$orgaId") => taskCtrl.actionRequired(taskId, orgaId, required = true)
    case PUT(p"/task/$taskId/actionDone/$orgaId")     => taskCtrl.actionRequired(taskId, orgaId, required = false)
    // POST     /case/:caseId/task/_search           controllers.TaskCtrl.findInCase(caseId)
    // POST     /case/task/_stats                    controllers.TaskCtrl.stats()

    case POST(p"/task/$taskId/log") => logCtrl.create(taskId)
    case PATCH(p"/log/$logId")      => logCtrl.update(logId)
    case DELETE(p"/log/$logId")     => logCtrl.delete(logId)

    case GET(p"/customField")  => customFieldCtrl.list
    case POST(p"/customField") => customFieldCtrl.create

    case POST(p"/alert")                   => alertCtrl.create
    case GET(p"/alert/$alertId")           => alertCtrl.get(alertId)
    case PATCH(p"/alert/$alertId")         => alertCtrl.update(alertId)
    case POST(p"/alert/$alertId/read")     => alertCtrl.markAsRead(alertId)
    case POST(p"/alert/$alertId/unread")   => alertCtrl.markAsUnread(alertId)
    case POST(p"/alert/$alertId/follow")   => alertCtrl.followAlert(alertId)
    case POST(p"/alert/$alertId/unfollow") => alertCtrl.unfollowAlert(alertId)
    case POST(p"/alert/$alertId/case")     => alertCtrl.createCase(alertId)
    case POST(p"/alert/fixCaseLink")       => alertCtrl.fixCaseLink
    // PATCH    /alert/_bulk                         controllers.AlertCtrl.bulkUpdate()
//    DELETE   /alert/:alertId                      controllers.AlertCtrl.delete(alertId)
//    POST     /alert/:alertId/merge/:caseId        controllers.AlertCtrl.mergeWithCase(alertId, caseId)

    case POST(p"/taxonomy")                   => taxonomyCtrl.create
    case POST(p"/taxonomy/import-zip")        => taxonomyCtrl.importZip
    case GET(p"/taxonomy/$taxoId")            => taxonomyCtrl.get(taxoId)
    case PUT(p"/taxonomy/$taxoId/activate")   => taxonomyCtrl.toggleActivation(taxoId, isActive = true)
    case PUT(p"/taxonomy/$taxoId/deactivate") => taxonomyCtrl.toggleActivation(taxoId, isActive = false)
    case DELETE(p"/taxonomy/$taxoId")         => taxonomyCtrl.delete(taxoId)

    case GET(p"/audit") => auditCtrl.flow
    // GET      /flow                                controllers.AuditCtrl.flow(rootId: Option[String], count: Option[Int])
    // GET      /audit                               controllers.AuditCtrl.find()
    // POST     /audit/_search                       controllers.AuditCtrl.find()
    // POST     /audit/_stats                        controllers.AuditCtrl.stats()

    case POST(p"/pattern/import/attack") => patternCtrl.importMitre
    case GET(p"/pattern/$patternId")     => patternCtrl.get(patternId)
    case GET(p"/pattern/case/$caseId")   => patternCtrl.getCasePatterns(caseId)
    case DELETE(p"/pattern/$patternId")  => patternCtrl.delete(patternId)

    case POST(p"/procedure")                => procedureCtrl.create
    case GET(p"/procedure/$procedureId")    => procedureCtrl.get(procedureId)
    case PATCH(p"/procedure/$procedureId")  => procedureCtrl.update(procedureId)
    case DELETE(p"/procedure/$procedureId") => procedureCtrl.delete(procedureId)

    case POST(p"/profile")              => profileCtrl.create
    case GET(p"/profile/$profileId")    => profileCtrl.get(profileId)
    case PATCH(p"/profile/$profileId")  => profileCtrl.update(profileId)
    case DELETE(p"/profile/$profileId") => profileCtrl.delete(profileId)

    case GET(p"/tag/$id")    => tagCtrl.get(id)
    case PATCH(p"/tag/$id")  => tagCtrl.update(id)
    case DELETE(p"/tag/$id") => tagCtrl.delete(id)

    case GET(p"/describe/_all")       => describeCtrl.describeAll
    case GET(p"/describe/$modelName") => describeCtrl.describe(modelName)

    case GET(p"/observable/type/$idOrName")    => observableTypeCtrl.get(idOrName)
    case POST(p"/observable/type")             => observableTypeCtrl.create
    case DELETE(p"/observable/type/$idOrName") => observableTypeCtrl.delete(idOrName)

    case GET(p"/monitor/disk") => monitoringCtrl.diskUsage
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/ShareCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.{ParamQuery, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, IteratorOutput, Traversal}
import org.thp.scalligraph.{AuthorizationError, BadRequestError, EntityIdOrName, RichSeq}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.{InputShare, ObservablesFilter, TasksFilter}
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services._
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.Inject
import scala.util.{Failure, Success, Try}

class ShareCtrl @Inject() (
    entrypoint: Entrypoint,
    shareSrv: ShareSrv,
    properties: Properties,
    organisationSrv: OrganisationSrv,
    caseSrv: CaseSrv,
    taskSrv: TaskSrv,
    observableSrv: ObservableSrv,
    profileSrv: ProfileSrv,
    db: Database
) extends QueryableCtrl {
  override val entityName: String                 = "share"
  override val publicProperties: PublicProperties = properties.share
  override val initialQuery: Query =
    Query.init[Traversal.V[Share]]("listShare", (graph, authContext) => organisationSrv.startTraversal(graph).visible(authContext).shares)
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Share], IteratorOutput](
      "page",
      (range, shareSteps, _) => shareSteps.richPage(range.from, range.to, range.extraData.contains("total"), limitedCountThreshold)(_.richShare)
    )
  override val outputQuery: Query = Query.outputWithContext[RichShare, Traversal.V[Share]]((shareSteps, _) => shareSteps.richShare)
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Share]](
    "getShare",
    (idOrName, graph, authContext) => shareSrv.get(idOrName)(graph).visible(authContext)
  )
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[Share], Traversal.V[Case]]("case", (shareSteps, _) => shareSteps.`case`),
    Query[Traversal.V[Share], Traversal.V[Observable]]("observables", (shareSteps, _) => shareSteps.observables),
    Query[Traversal.V[Share], Traversal.V[Task]]("tasks", (shareSteps, _) => shareSteps.tasks),
    Query[Traversal.V[Share], Traversal.V[Organisation]]("organisation", (shareSteps, _) => shareSteps.organisation)
  )

  def shareCase(caseId: String): Action[AnyContent] =
    entrypoint("create case shares")
      .extract("shares", FieldsParser[InputShare].sequence.on("shares"))
      .authTransaction(db) { implicit request => implicit graph =>
        val inputShares: Seq[InputShare] = request.body("shares")
        caseSrv
          .get(EntityIdOrName(caseId))
          .can(Permissions.manageShare)
          .getOrFail("Case")
          .flatMap { `case` =>
            inputShares.toTry { inputShare =>
              for {
                organisation <-
                  organisationSrv
                    .get(request.organisation)
                    .visibleOrganisationsFrom
                    .get(EntityIdOrName(inputShare.organisationName))
                    .getOrFail("Organisation")
                profile   <- profileSrv.getOrFail(EntityIdOrName(inputShare.profile))
                share     <- shareSrv.shareCase(owner = false, `case`, organisation, profile)
                richShare <- shareSrv.get(share).richShare.getOrFail("Share")
                _         <- if (inputShare.tasks == TasksFilter.all) shareSrv.shareCaseTasks(share) else Success(Nil)
                _         <- if (inputShare.observables == ObservablesFilter.all) shareSrv.shareCaseObservables(share) else Success(Nil)
              } yield richShare
            }
          }
          .map(shares => Results.Ok(shares.toJson))
      }

  def removeShare(shareId: String): Action[AnyContent] =
    entrypoint("remove share")
      .authTransaction(db) { implicit request => implicit graph =>
        doRemoveShare(EntityIdOrName(shareId)).map(_ => Results.NoContent)
      }

  def removeShares(): Action[AnyContent] =
    entrypoint("remove share")
      .extract("shares", FieldsParser[String].sequence.on("ids"))
      .authTransaction(db) { implicit request => implicit graph =>
        val shareIds: Seq[String] = request.body("shares")
        shareIds.map(EntityIdOrName.apply).toTry(doRemoveShare(_)).map(_ => Results.NoContent)
      }

  def removeShares(caseId: String): Action[AnyContent] =
    entrypoint("remove share")
      .extract("organisations", FieldsParser[String].sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisations: Seq[String] = request.body("organisations")
        organisations
          .map(EntityIdOrName(_))
          .toTry { organisationId =>
            for {
              organisation <- organisationSrv.get(organisationId).getOrFail("Organisation")
              _ <-
                if (request.organisation.fold(_ == organisation._id, _ == organisation.name))
                  Failure(BadRequestError("You cannot remove your own share"))
                else Success(())
              shareId <-
                caseSrv
                  .get(EntityIdOrName(caseId))
                  .can(Permissions.manageShare)
                  .share(organisationId)
                  .has(_.owner, false)
                  .orFail(AuthorizationError("Operation not permitted"))
              _ <- shareSrv.delete(shareId)
            } yield ()
          }
          .map(_ => Results.NoContent)
      }

  def removeTaskShares(taskId: String): Action[AnyContent] =
    entrypoint("remove share tasks")
      .extract("organisations", FieldsParser[String].sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisations: Seq[String] = request.body("organisations")

        taskSrv
          .getOrFail(EntityIdOrName(taskId))
          .flatMap { task =>
            organisations.toTry { organisationName =>
              organisationSrv
                .getOrFail(EntityIdOrName(organisationName))
                .flatMap(shareSrv.unshareTask(task, _))
            }
          }
          .map(_ => Results.NoContent)
      }

  def removeObservableShares(observableId: String): Action[AnyContent] =
    entrypoint("remove share observables")
      .extract("organisations", FieldsParser[String].sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisations: Seq[String] = request.body("organisations")

        observableSrv
          .getOrFail(EntityIdOrName(observableId))
          .flatMap { observable =>
            organisations.toTry { organisationName =>
              organisationSrv
                .getOrFail(EntityIdOrName(organisationName))
                .flatMap(shareSrv.unshareObservable(observable, _))
            }
          }
          .map(_ => Results.NoContent)
      }

  private def doRemoveShare(shareId: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    if (!shareSrv.get(shareId).`case`.can(Permissions.manageShare).exists)
      Failure(AuthorizationError("You are not authorized to remove share"))
    else if (shareSrv.get(shareId).byOrganisation(authContext.organisation).exists)
      Failure(AuthorizationError("You can't remove your share"))
    else if (shareSrv.get(shareId).has(_.owner, true).exists)
      Failure(AuthorizationError("You can't remove initial shares"))
    else
      shareSrv.unshareCase(shareId)

  def updateShare(shareId: String): Action[AnyContent] =
    entrypoint("update share")
      .extract("profile", FieldsParser.string.on("profile"))
      .authTransaction(db) { implicit request => implicit graph =>
        val profile: String = request.body("profile")
        if (!shareSrv.get(EntityIdOrName(shareId)).`case`.can(Permissions.manageShare).exists)
          Failure(AuthorizationError("You are not authorized to remove share"))
        for {
          richShare <-
            shareSrv
              .get(EntityIdOrName(shareId))
              .filter(_.organisation.visibleOrganisationsTo.visible)
              .richShare
              .getOrFail("Share")
          profile <- profileSrv.getOrFail(EntityIdOrName(profile))
          _       <- shareSrv.updateProfile(richShare.share, profile)
        } yield Results.Ok
      }

  def listShareCases(caseId: String): Action[AnyContent] =
    entrypoint("list case shares")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val shares = caseSrv
          .get(EntityIdOrName(caseId))
          .shares
          .visible
          .filterNot(_.get(request.organisation))
          .richShare
          .toSeq

        Success(Results.Ok(shares.toJson))
      }

  def listShareTasks(caseId: String, taskId: String): Action[AnyContent] =
    entrypoint("list task shares")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val shares = caseSrv
          .get(EntityIdOrName(caseId))
          .can(Permissions.manageShare)
          .shares
          .visible
          .filterNot(_.get(request.organisation))
          .byTask(EntityIdOrName(taskId))
          .richShare
          .toSeq

        Success(Results.Ok(shares.toJson))
      }

  def listShareObservables(caseId: String, observableId: String): Action[AnyContent] =
    entrypoint("list observable shares")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val shares = caseSrv
          .get(EntityIdOrName(caseId))
          .can(Permissions.manageShare)
          .shares
          .visible
          .filterNot(_.get(request.organisation))
          .byObservable(EntityIdOrName(observableId))
          .richShare
          .toSeq

        Success(Results.Ok(shares.toJson))
      }

  def shareTask(taskId: String): Action[AnyContent] =
    entrypoint("share task")
      .extract("organisations", FieldsParser.string.sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisationIds: Seq[String] = request.body("organisations")

        for {
          task          <- taskSrv.getOrFail(EntityIdOrName(taskId))
          _             <- taskSrv.get(task).`case`.can(Permissions.manageShare).existsOrFail
          organisations <- organisationIds.map(EntityIdOrName(_)).toTry(organisationSrv.get(_).visible.getOrFail("Organisation"))
          _             <- shareSrv.addTaskShares(task, organisations)
        } yield Results.NoContent
      }

  def shareObservable(observableId: String): Action[AnyContent] =
    entrypoint("share observable")
      .extract("organisations", FieldsParser.string.sequence.on("organisations"))
      .authTransaction(db) { implicit request => implicit graph =>
        val organisationIds: Seq[String] = request.body("organisations")
        for {
          observable    <- observableSrv.getOrFail(EntityIdOrName(observableId))
          _             <- observableSrv.get(observable).`case`.can(Permissions.manageShare).existsOrFail
          organisations <- organisationIds.map(EntityIdOrName(_)).toTry(organisationSrv.get(_).visible.getOrFail("Organisation"))
          _             <- shareSrv.addObservableShares(observable, organisations)
        } yield Results.NoContent
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/StatusCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import akka.actor.ActorSystem
import akka.cluster.ClusterEvent.CurrentClusterState
import akka.cluster.{Cluster, Member}
import org.thp.scalligraph.ScalligraphApplicationLoader
import org.thp.scalligraph.auth.{AuthCapability, AuthSrv, MultiAuthSrv}
import org.thp.scalligraph.controllers.Entrypoint
import org.thp.scalligraph.models.UpdatableSchema
import org.thp.scalligraph.services.config.ApplicationConfig.finiteDurationFormat
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.thehive.TheHiveModule
import play.api.libs.json.{JsObject, JsString, Json, Writes}
import play.api.mvc.{AbstractController, Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.collection.immutable
import scala.concurrent.duration.FiniteDuration
import scala.util.Success

@Singleton
class StatusCtrl @Inject() (
    entrypoint: Entrypoint,
    appConfig: ApplicationConfig,
    authSrv: AuthSrv,
    schemas: immutable.Set[UpdatableSchema],
    system: ActorSystem
) {

  private def getVersion(c: Class[_]): String = Option(c.getPackage.getImplementationVersion).getOrElse("SNAPSHOT")

  val passwordConfig: ConfigItem[String, String] = appConfig.item[String]("datastore.attachment.password", "Password used to protect attachment ZIP")
  def password: String                           = passwordConfig.get
  val streamPollingDurationConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("stream.longPolling.pollingDuration", "amount of time the UI have to wait before polling the stream")
  def streamPollingDuration: FiniteDuration = streamPollingDurationConfig.get
  val cluster: Cluster                      = Cluster(system)

  implicit val memberWrites: Writes[Member] = Writes[Member] { member =>
    Json.obj(
      "address" -> member.uniqueAddress.address.toString,
      "status"  -> member.status.toString,
      "roles"   -> member.roles
    )
  }
  implicit val clusterStateWrites: Writes[CurrentClusterState] = Writes[CurrentClusterState] { state =>
    Json.obj(
      "members"                -> state.members,
      "unreachable"            -> state.unreachable,
      "seenBy"                 -> state.seenBy.map(_.toString),
      "leader"                 -> state.leader.map(_.toString),
      "unreachableDataCenters" -> state.unreachableDataCenters
      //"roleLeaderMap"          -> state.roleLeaderMap,
    )
  }

  def get: Action[AnyContent] =
    entrypoint("status") { _ =>
      Success(
        Results.Ok(
          Json.obj(
            "versions" -> Json.obj(
              "Scalligraph" -> getVersion(classOf[ScalligraphApplicationLoader]),
              "TheHive"     -> getVersion(classOf[TheHiveModule]),
              "Play"        -> getVersion(classOf[AbstractController])
            ),
            "connectors" -> JsObject.empty,
            "config" -> Json.obj(
              "protectDownloadsWith" -> password,
              "authType" -> (authSrv match {
                case multiAuthSrv: MultiAuthSrv => Json.toJson(multiAuthSrv.providerNames)
                case _                          => JsString(authSrv.name)
              }),
              "capabilities"    -> authSrv.capabilities.map(c => JsString(c.toString)),
              "ssoAutoLogin"    -> authSrv.capabilities.contains(AuthCapability.sso),
              "pollingDuration" -> streamPollingDuration.toMillis
            ),
            "cluster" -> cluster.state,
            "schemaStatus" -> schemas.flatMap(_.schemaStatus).map { schemaStatus =>
              Json.obj(
                "name"            -> schemaStatus.name,
                "currentVersion"  -> schemaStatus.currentVersion,
                "expectedVersion" -> schemaStatus.expectedVersion,
                "error"           -> schemaStatus.error.map(_.getMessage)
              )
            }
          )
        )
      )
    }
}

```

`thehive/app/org/thp/thehive/controllers/v1/TagCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.apache.tinkerpop.gremlin.process.traversal.Order
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.query._
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, IteratorOutput, Traversal}
import org.thp.scalligraph.utils.FunctionalCondition.When
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models.{Permissions, Tag}
import org.thp.thehive.services.TagOps._
import org.thp.thehive.services.{OrganisationSrv, TagSrv}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.Inject

case class TagHint(freeTag: Option[String], namespace: Option[String], predicate: Option[String], value: Option[String], limit: Option[Long])

class TagCtrl @Inject() (
    entrypoint: Entrypoint,
    db: Database,
    tagSrv: TagSrv,
    val organisationSrv: OrganisationSrv,
    properties: Properties,
    appConfig: ApplicationConfig
) extends QueryableCtrl
    with TagRenderer {

  val limitedCountThresholdConfig: ConfigItem[Long, Long] = appConfig.item[Long]("query.limitedCountThreshold", "Maximum number returned by a count")
  val limitedCountThreshold: Long                         = limitedCountThresholdConfig.get

  override val entityName: String                 = "Tag"
  override val publicProperties: PublicProperties = properties.tag
  override val initialQuery: Query =
    Query.init[Traversal.V[Tag]]("listTag", (graph, authContext) => tagSrv.startTraversal(graph).visible(authContext))
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Tag], IteratorOutput](
      "page",
      (params, tagSteps, authContext) =>
        tagSteps.richPage(params.from, params.to, params.extraData.contains("total"), limitedCountThreshold)(
          _.withCustomRenderer(tagStatsRenderer(params.extraData - "total")(authContext))
        )
    )
  override val outputQuery: Query = Query.output[Tag with Entity]
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Tag]](
    "getTag",
    (idOrName, graph, _) => tagSrv.get(idOrName)(graph)
  )
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query.init[Traversal.V[Tag]]("freetags", (graph, authContext) => tagSrv.startTraversal(graph).freetags(organisationSrv)(authContext)),
    Query.init[Long](
      "countFreetags",
      (graph, authContext) =>
        graph.indexCountQuery(s"""v."_label":Tag AND v.namespace:_freetags_${organisationSrv.currentId(graph, authContext).value}""")
    ),
    Query[Traversal.V[Tag], Traversal.V[Tag]]("freetags", (tagSteps, authContext) => tagSteps.freetags(organisationSrv)(authContext)),
    Query.initWithParam[TagHint, Traversal[String, Vertex, Converter[String, Vertex]]](
      "tagAutoComplete",
      (tagHint, graph, authContext) =>
        tagHint
          .freeTag
          .fold(tagSrv.startTraversal(graph).autoComplete(tagHint.namespace, tagHint.predicate, tagHint.value)(authContext).visible(authContext))(
            tagSrv.startTraversal(graph).autoComplete(organisationSrv, _)(authContext).sort(_.by("predicate", Order.asc))
          )
          .merge(tagHint.limit)(_.limit(_))
          .displayName
    ),
    Query[Traversal.V[Tag], Traversal[String, Vertex, Converter[String, Vertex]]]("text", (tagSteps, _) => tagSteps.displayName),
    Query.output[String, Traversal[String, Vertex, Converter[String, Vertex]]]
  )

  def get(tagId: String): Action[AnyContent] =
    entrypoint("get tag")
      .authRoTransaction(db) { _ => implicit graph =>
        tagSrv
          .getOrFail(EntityIdOrName(tagId))
          .map(tag => Results.Ok(tag.toJson))
      }

  def update(tagId: String): Action[AnyContent] =
    entrypoint("update tag")
      .extract("tag", FieldsParser.update("tag", publicProperties))
      .authPermittedTransaction(db, Permissions.manageTag) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("tag")
        tagSrv
          .update(_.getFreetag(organisationSrv, EntityIdOrName(tagId)), propertyUpdaters)
          .map(_ => Results.NoContent)
      }

  def delete(tagId: String): Action[AnyContent] =
    entrypoint("delete tag")
      .authPermittedTransaction(db, Permissions.manageTag) { implicit request => implicit graph =>
        tagSrv
          .getFreetag(EntityIdOrName(tagId))
          .getOrFail("Tag")
          .flatMap(tagSrv.delete)
          .map(_ => Results.NoContent)
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/TagRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.models.Tag
import org.thp.thehive.services.OrganisationSrv
import org.thp.thehive.services.TagOps._
import play.api.libs.json._

import java.util.{Map => JMap}

trait TagRenderer extends BaseRenderer[Tag] {
  val limitedCountThreshold: Long
  val organisationSrv: OrganisationSrv

  def usageStats(implicit
      authContext: AuthContext
  ): Traversal.V[Tag] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    t =>
      t.project(
        _.by(_.value(_.predicate))
          .by(_.caseTemplate.limitedCount(limitedCountThreshold))
      ).domainMap {
        case (tag, caseTemplateCount) =>
          Json.obj(
            "case" -> t
              .graph
              .indexCountQuery(
                s"""v."_label":Case AND """ +
                  s"v.tags:${t.graph.escapeQueryParameter(tag)} AND " +
                  s"v.organisationIds:${organisationSrv.currentId(t.graph, authContext).value}"
              ),
            "alert" -> t
              .graph
              .indexCountQuery(
                s"""v."_label":Alert AND """ +
                  s"v.tags:${t.graph.escapeQueryParameter(tag)} AND " +
                  s"v.organisationId:${organisationSrv.currentId(t.graph, authContext).value}"
              ),
            "observable" -> t
              .graph
              .indexCountQuery(
                s"""v."_label":Observable AND """ +
                  s"v.tags:${t.graph.escapeQueryParameter(tag)} AND " +
                  s"v.organisationIds:${organisationSrv.currentId(t.graph, authContext).value}"
              ),
            "caseTemplate" -> caseTemplateCount
          )
      }
//  def usageStats(implicit
//      authContext: AuthContext
//  ): Traversal.V[Tag] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
//    _.project(
//      _.by(_.`case`.limitedCount(limitedCountThreshold))
//        .by(_.alert.limitedCount(limitedCountThreshold))
//        .by(_.observable.limitedCount(limitedCountThreshold))
//        .by(_.caseTemplate.limitedCount(limitedCountThreshold))
//    ).domainMap {
//      case (caseCount, alertCount, observableCount, caseTemplateCount) =>
//        Json.obj(
//          "case"         -> caseCount,
//          "alert"        -> alertCount,
//          "observable"   -> observableCount,
//          "caseTemplate" -> caseTemplateCount
//        )
//    }

  def tagStatsRenderer(extraData: Set[String])(implicit
      authContext: AuthContext
  ): Traversal.V[Tag] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "usage") => addData("usage", f)(usageStats)
        case (f, _)       => f
      }
    )
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/TaskCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.{EntityIdOrName, _}
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.{ParamQuery, PropertyUpdater, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputTask
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.{CaseSrv, OrganisationSrv, TaskSrv}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.{Inject, Singleton}
import scala.util.Success

@Singleton
class TaskCtrl @Inject() (
    entrypoint: Entrypoint,
    db: Database,
    properties: Properties,
    taskSrv: TaskSrv,
    caseSrv: CaseSrv,
    organisationSrv: OrganisationSrv
) extends QueryableCtrl
    with TaskRenderer {

  override val entityName: String                 = "task"
  override val publicProperties: PublicProperties = properties.task
  override val initialQuery: Query =
    Query.init[Traversal.V[Task]](
      "listTask",
      (graph, authContext) => taskSrv.startTraversal(graph).visible(organisationSrv)(authContext)
//        organisationSrv.get(authContext.organisation)(graph).shares.tasks)
    )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Task], IteratorOutput](
      "page",
      (range, taskSteps, authContext) =>
        taskSteps.richPage(range.from, range.to, range.extraData.contains("total"), limitedCountThreshold)(
          _.richTaskWithCustomRenderer(taskStatsRenderer(range.extraData)(authContext))
        )
    )
  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[Task]](
    "getTask",
    (idOrName, graph, authContext) => taskSrv.get(idOrName)(graph).visible(organisationSrv)(authContext)
  )
  override val outputQuery: Query =
    Query.outputWithContext[RichTask, Traversal.V[Task]]((taskSteps, _) => taskSteps.richTask)
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query.initWithParam[InCase, Long](
      "countTask",
      (inCase, graph, authContext) =>
        graph.indexCountQuery(
          s"""v."_label":Task AND """ +
            s"v.relatedId:${graph.escapeQueryParameter(inCase.caseId.value)} AND " +
            s"v.organisationIds:${organisationSrv.currentId(graph, authContext).value} AND " +
            "NOT v.status:Cancel"
        )
    ),
    Query.init[Traversal.V[Task]](
      "waitingTasks",
      (graph, authContext) => taskSrv.startTraversal(graph).has(_.status, TaskStatus.Waiting).visible(organisationSrv)(authContext).inCase
    ),
    Query.init[Traversal.V[Task]]( // DEPRECATED
      "waitingTask",
      (graph, authContext) => taskSrv.startTraversal(graph).has(_.status, TaskStatus.Waiting).visible(organisationSrv)(authContext).inCase
    ),
    Query.init[Traversal.V[Task]](
      "myTasks",
      (graph, authContext) =>
        taskSrv
          .startTraversal(graph)
          .assignTo(authContext.userId)
          .visible(organisationSrv)(authContext)
          .inCase
    ),
    Query[Traversal.V[Task], Traversal.V[User]]("assignableUsers", (taskSteps, authContext) => taskSteps.assignableUsers(authContext)),
    Query[Traversal.V[Task], Traversal.V[Log]]("logs", (taskSteps, _) => taskSteps.logs),
    Query[Traversal.V[Task], Traversal.V[Case]]("case", (taskSteps, _) => taskSteps.`case`),
    Query[Traversal.V[Task], Traversal.V[CaseTemplate]]("caseTemplate", (taskSteps, authContext) => taskSteps.caseTemplate.visible(authContext)),
    Query[Traversal.V[Task], Traversal.V[Organisation]]("organisations", (taskSteps, authContext) => taskSteps.organisations.visible(authContext)),
    Query[Traversal.V[Task], Traversal.V[Share]]("shares", (taskSteps, authContext) => taskSteps.shares.visible(authContext))
  )

  def create: Action[AnyContent] =
    entrypoint("create task")
      .extract("task", FieldsParser[InputTask])
      .extract("caseId", FieldsParser[String])
      .authTransaction(db) { implicit request => implicit graph =>
        val inputTask: InputTask = request.body("task")
        val caseId: String       = request.body("caseId")
        for {
          case0       <- caseSrv.get(EntityIdOrName(caseId)).can(Permissions.manageTask).getOrFail("Case")
          createdTask <- caseSrv.createTask(case0, inputTask.toTask)
        } yield Results.Created(createdTask.toJson)
      }

  def get(taskId: String): Action[AnyContent] =
    entrypoint("get task")
      .authRoTransaction(db) { implicit request => implicit graph =>
        taskSrv
          .get(EntityIdOrName(taskId))
          .visible(organisationSrv)
          .richTask
          .getOrFail("Task")
          .map(task => Results.Ok(task.toJson))
      }

  def list: Action[AnyContent] =
    entrypoint("list task")
      .authRoTransaction(db) { implicit request => implicit graph =>
        val tasks = taskSrv
          .startTraversal
          .visible(organisationSrv)
          .richTask
          .toSeq
        Success(Results.Ok(tasks.toJson))
      }

  def update(taskId: String): Action[AnyContent] =
    entrypoint("update task")
      .extract("task", FieldsParser.update("task", properties.task))
      .authTransaction(db) { implicit request => implicit graph =>
        val propertyUpdaters: Seq[PropertyUpdater] = request.body("task")
        taskSrv
          .update(
            _.get(EntityIdOrName(taskId))
              .can(Permissions.manageTask),
            propertyUpdaters
          )
          .map(_ => Results.NoContent)
      }

  def bulkUpdate: Action[AnyContent] =
    entrypoint("bulk update")
      .extract("input", FieldsParser.update("task", publicProperties))
      .extract("ids", FieldsParser.seq[String].on("ids"))
      .authTransaction(db) { implicit request => implicit graph =>
        val properties: Seq[PropertyUpdater] = request.body("input")
        val ids: Seq[String]                 = request.body("ids")
        ids
          .toTry { id =>
            taskSrv
              .update(
                _.get(EntityIdOrName(id))
                  .can(Permissions.manageTask),
                properties
              )
          }
          .map(_ => Results.NoContent)
      }

  def isActionRequired(taskId: String): Action[AnyContent] =
    entrypoint("is action required")
      .authTransaction(db) { implicit request => implicit graph =>
        val actionTraversal = taskSrv.get(EntityIdOrName(taskId)).visible(organisationSrv).actionRequiredMap
        Success(Results.Ok(actionTraversal.toSeq.toMap.toJson))
      }

  def actionRequired(taskId: String, orgaId: String, required: Boolean): Action[AnyContent] =
    entrypoint("action required")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          organisation <- organisationSrv.get(EntityIdOrName(orgaId)).visible.getOrFail("Organisation")
          task         <- taskSrv.get(EntityIdOrName(taskId)).visible(organisationSrv).getOrFail("Task")
          _            <- taskSrv.actionRequired(task, organisation, required)
        } yield Results.NoContent
      }

  def delete(taskId: String): Action[AnyContent] =
    entrypoint("delete task")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          t <-
            taskSrv
              .get(EntityIdOrName(taskId))
              .can(Permissions.manageTask)
              .getOrFail("Task")
          _ <- taskSrv.delete(t)
        } yield Results.NoContent
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/TaskRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models.Task
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.TaskOps._
import play.api.libs.json._

import java.lang.{Boolean => JBoolean, Long => JLong}
import java.util.{List => JList, Map => JMap}

trait TaskRenderer extends BaseRenderer[Task] {

  private def caseParent(implicit
      authContext: AuthContext
  ): Traversal.V[Task] => Traversal[JsValue, JList[JMap[String, Any]], Converter[JsValue, JList[JMap[String, Any]]]] =
    _.`case`.richCase.fold.domainMap(_.headOption.fold[JsValue](JsNull)(_.toJson))

  private def caseParentId: Traversal.V[Task] => Traversal[JsValue, JList[Vertex], Converter[JsValue, JList[Vertex]]] =
    _.`case`.fold.domainMap(_.headOption.fold[JsValue](JsNull)(c => JsString(c._id.toString)))

  private def caseTemplateParent: Traversal.V[Task] => Traversal[JsValue, JList[JMap[String, Any]], Converter[JsValue, JList[JMap[String, Any]]]] =
    _.caseTemplate.richCaseTemplate.fold.domainMap(_.headOption.fold[JsValue](JsNull)(_.toJson))

  private def caseTemplateParentId: Traversal.V[Task] => Traversal[JsValue, JList[Vertex], Converter[JsValue, JList[Vertex]]] =
    _.caseTemplate.fold.domainMap(_.headOption.fold[JsValue](JsNull)(ct => JsString(ct._id.toString)))

  private def shareCount: Traversal.V[Task] => Traversal[JsValue, JLong, Converter[JsValue, JLong]] =
    _.organisations.count.domainMap(count => JsNumber(count - 1))

  private def isOwner(implicit authContext: AuthContext): Traversal.V[Task] => Traversal[JsValue, JList[Vertex], Converter[JsValue, JList[Vertex]]] =
    _.origin.get(authContext.organisation).fold.domainMap(l => JsBoolean(l.nonEmpty))

  private def actionRequired(implicit authContext: AuthContext): Traversal.V[Task] => Traversal[JsValue, JBoolean, Converter[JsValue, JBoolean]] =
    _.actionRequired.domainMap(JsBoolean(_))

  private def actionRequiredMap(implicit
      authContext: AuthContext
  ): Traversal.V[Task] => Traversal[JsValue, JList[JMap[String, Any]], Converter[JsValue, JList[JMap[String, Any]]]] =
    _.actionRequiredMap.fold.domainMap(_.toMap.toJson)

  def taskStatsRenderer(extraData: Set[String])(implicit
      authContext: AuthContext
  ): Traversal.V[Task] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "case")              => addData("case", f)(caseParent)
        case (f, "caseId")            => addData("caseId", f)(caseParentId)
        case (f, "caseTemplate")      => addData("caseTemplate", f)(caseTemplateParent)
        case (f, "caseTemplateId")    => addData("caseTemplateId", f)(caseTemplateParentId)
        case (f, "isOwner")           => addData("isOwner", f)(isOwner)
        case (f, "shareCount")        => addData("shareCount", f)(shareCount)
        case (f, "actionRequired")    => addData("actionRequired", f)(actionRequired)
        case (f, "actionRequiredMap") => addData("actionRequiredMap", f)(actionRequiredMap)
        case (f, _)                   => f
      }
    )
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/TaxonomyCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import net.lingala.zip4j.ZipFile
import net.lingala.zip4j.model.FileHeader
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.{Entrypoint, FFile, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query._
import org.thp.scalligraph.traversal.TraversalOps.TraversalOpsDefs
import org.thp.scalligraph.traversal.{Graph, IteratorOutput, Traversal}
import org.thp.scalligraph.{BadRequestError, EntityIdOrName, RichSeq}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputTaxonomy
import org.thp.thehive.models.{Permissions, RichTaxonomy, Tag, Taxonomy}
import org.thp.thehive.services.TaxonomyOps._
import org.thp.thehive.services.{TagSrv, TaxonomySrv}
import play.api.libs.json.{JsArray, Json}
import play.api.mvc.{Action, AnyContent, Results}

import javax.inject.Inject
import scala.collection.JavaConverters._
import scala.util.{Failure, Success, Try}

class TaxonomyCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    taxonomySrv: TaxonomySrv,
    tagSrv: TagSrv,
    db: Database
) extends QueryableCtrl
    with TaxonomyRenderer {

  override val entityName: String                 = "taxonomy"
  override val publicProperties: PublicProperties = properties.taxonomy
  override val initialQuery: Query =
    Query.init[Traversal.V[Taxonomy]]("listTaxonomy", (graph, authContext) => taxonomySrv.startTraversal(graph).visible(authContext))
  override val getQuery: ParamQuery[EntityIdOrName] =
    Query.initWithParam[EntityIdOrName, Traversal.V[Taxonomy]](
      "getTaxonomy",
      (idOrName, graph, authContext) => taxonomySrv.get(idOrName)(graph).visible(authContext)
    )
  override def pageQuery(limitedCountThreshold: Long): ParamQuery[OutputParam] =
    Query.withParam[OutputParam, Traversal.V[Taxonomy], IteratorOutput](
      "page",
      {
        case (OutputParam(from, to, extraData), taxoSteps, _) =>
          taxoSteps.richPage(from, to, extraData.contains("total"), limitedCountThreshold)(
            _.richTaxonomyWithCustomRenderer(taxoStatsRenderer(extraData - "total"))
          )
      }
    )
  override val outputQuery: Query =
    Query.outputWithContext[RichTaxonomy, Traversal.V[Taxonomy]]((traversal, _) => traversal.richTaxonomy)
  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query[Traversal.V[Taxonomy], Traversal.V[Tag]]("tags", (traversal, _) => traversal.tags)
  )

  def create: Action[AnyContent] =
    entrypoint("import taxonomy")
      .extract("taxonomy", FieldsParser[InputTaxonomy])
      .authPermittedTransaction(db, Permissions.manageTaxonomy) { implicit request => implicit graph =>
        for {
          richTaxonomy <- createFromInput(request.body("taxonomy"))
        } yield Results.Created(richTaxonomy.toJson)
      }

  def importZip: Action[AnyContent] =
    entrypoint("import taxonomies zip")
      .extract("file", FieldsParser.file.on("file"))
      .authPermitted(Permissions.manageTaxonomy) { implicit request =>
        val file: FFile = request.body("file")
        val zipFile     = new ZipFile(file.filepath.toString)
        val headers = zipFile
          .getFileHeaders
          .iterator()
          .asScala

        for {
          inputTaxos <-
            headers
              .filter(h => h.getFileName.endsWith("machinetag.json"))
              .toTry(parseJsonFile(zipFile, _))
          richTaxos = inputTaxos.foldLeft[JsArray](JsArray.empty) { (array, taxo) =>
            val res = db.tryTransaction { implicit graph =>
              createFromInput(taxo)
            } match {
              case Failure(e) =>
                Json.obj("namespace" -> taxo.namespace, "status" -> "Failure", "message" -> e.getMessage)
              case Success(t) =>
                Json.obj("namespace" -> t.namespace, "status" -> "Success", "numberOfTags" -> t.tags.size)
            }
            array :+ res
          }
        } yield Results.Created(richTaxos)
      }

  private def parseJsonFile(zipFile: ZipFile, h: FileHeader): Try[InputTaxonomy] =
    Try(Json.parse(zipFile.getInputStream(h)).as[InputTaxonomy]).recoverWith {
      case _ => Failure(BadRequestError(s"File '${h.getFileName}' does not comply with the MISP taxonomy formatting"))
    }

  private def createFromInput(inputTaxo: InputTaxonomy)(implicit graph: Graph, authContext: AuthContext): Try[RichTaxonomy] = {
    // Create tags
    val predicatesWithValue = inputTaxo.values.map(_.predicate).distinct
    val predicateWithNoTags = inputTaxo.predicates.filterNot(p => predicatesWithValue.contains(p.value))

    val tags = inputTaxo.values.flatMap { value =>
      value
        .entry
        .map { e =>
          Tag(
            inputTaxo.namespace,
            value.predicate,
            Some(e.value),
            e.expanded,
            e.colour.getOrElse(tagSrv.freeTagColour)
          )
        }
    }
    // Create a tag for predicates with no tags associated

    val allTags = tags ++ predicateWithNoTags.map(p => Tag(inputTaxo.namespace, p.value, None, None, p.colour.getOrElse(tagSrv.freeTagColour)))

    if (inputTaxo.namespace.isEmpty)
      Failure(BadRequestError(s"A taxonomy with no namespace cannot be imported"))
    else if (inputTaxo.namespace.startsWith("_freetags"))
      Failure(BadRequestError(s"Namespace _freetags is restricted for TheHive"))
    else if (taxonomySrv.startTraversal.alreadyImported(inputTaxo.namespace))
      // Update the taxonomy, update exisiting tags & create others
      for {
        _           <- allTags.toTry(t => taxonomySrv.updateOrCreateTag(inputTaxo.namespace, t))
        taxonomy    <- taxonomySrv.get(EntityIdOrName(inputTaxo.namespace)).getOrFail("Taxonomy")
        updatedTaxo <- taxonomySrv.update(taxonomy, inputTaxo.toTaxonomy)
      } yield updatedTaxo
    else
      // Create the taxonomy and all its tags
      for {
        tagsEntities <- allTags.toTry(t => tagSrv.create(t))
        richTaxonomy <- taxonomySrv.create(inputTaxo.toTaxonomy, tagsEntities)
      } yield richTaxonomy
  }

  def get(taxonomyId: String): Action[AnyContent] =
    entrypoint("get taxonomy")
      .authRoTransaction(db) { implicit request => implicit graph =>
        taxonomySrv
          .get(EntityIdOrName(taxonomyId))
          .visible
          .richTaxonomy
          .getOrFail("Taxonomy")
          .map(taxonomy => Results.Ok(taxonomy.toJson))
      }

  def toggleActivation(taxonomyId: String, isActive: Boolean): Action[AnyContent] =
    entrypoint("toggle taxonomy")
      .authPermittedTransaction(db, Permissions.manageTaxonomy) { implicit request => implicit graph =>
        val toggleF = if (isActive) taxonomySrv.activate _ else taxonomySrv.deactivate _
        toggleF(EntityIdOrName(taxonomyId)).map(_ => Results.NoContent)
      }

  def delete(taxoId: String): Action[AnyContent] =
    entrypoint("delete taxonomy")
      .authPermittedTransaction(db, Permissions.manageTaxonomy) { implicit request => implicit graph =>
        for {
          taxo <-
            taxonomySrv
              .get(EntityIdOrName(taxoId))
              .visible
              .getOrFail("Taxonomy")
          tags <- Try(taxonomySrv.get(taxo).tags.toSeq)
          _    <- tags.toTry(t => tagSrv.delete(t))
          _    <- taxonomySrv.delete(taxo)
        } yield Results.NoContent
      }

}

```

`thehive/app/org/thp/thehive/controllers/v1/TaxonomyRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.models.Taxonomy
import org.thp.thehive.services.TaxonomyOps._
import play.api.libs.json._

trait TaxonomyRenderer extends BaseRenderer[Taxonomy] {

  def enabledStats: Traversal.V[Taxonomy] => Traversal[JsValue, Boolean, Converter[JsValue, Boolean]] =
    _.enabled.domainMap(l => JsBoolean(l))

  def taxoStatsRenderer(extraData: Set[String]): Traversal.V[Taxonomy] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "enabled") => addData("enabled", f)(enabledStats)
        case (f, _)         => f
      }
    )
  }
}

```

`thehive/app/org/thp/thehive/controllers/v1/TheHiveQueryExecutor.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.EntityId
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.{FObject, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query._
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.Traversal
import org.thp.scalligraph.utils.RichType
import org.thp.thehive.models.Audit
import org.thp.thehive.services.AuditOps._

import javax.inject.{Inject, Singleton}
import scala.reflect.runtime.{universe => ru}

case class InCase(caseId: EntityId)
case class InAlert(alertId: EntityId)

case class OutputParam(from: Long, to: Long, extraData: Set[String])

object OutputParam {
  implicit val parser: FieldsParser[OutputParam] = FieldsParser[OutputParam]("OutputParam") {
    case (_, field: FObject) =>
      for {
        from      <- FieldsParser.long.on("from")(field)
        to        <- FieldsParser.long.on("to")(field)
        extraData <- FieldsParser.string.set.on("extraData")(field)
      } yield OutputParam(from, to, extraData)
  }
}

@Singleton
class TheHiveQueryExecutor @Inject() (
    appConfig: ApplicationConfig,
    alertCtrl: AlertCtrl,
    auditCtrl: AuditCtrl,
    caseCtrl: CaseCtrl,
    caseTemplateCtrl: CaseTemplateCtrl,
    customFieldCtrl: CustomFieldCtrl,
    logCtrl: LogCtrl,
    observableCtrl: ObservableCtrl,
    observableTypeCtrl: ObservableTypeCtrl,
    organisationCtrl: OrganisationCtrl,
    patternCtrl: PatternCtrl,
    procedureCtrl: ProcedureCtrl,
    profileCtrl: ProfileCtrl,
    shareCtrl: ShareCtrl,
    tagCtrl: TagCtrl,
    taskCtrl: TaskCtrl,
    userCtrl: UserCtrl,
    taxonomyCtrl: TaxonomyCtrl,
    dashboardCtrl: DashboardCtrl,
    properties: Properties,
    implicit val db: Database
) extends QueryExecutor {

  lazy val controllers: Seq[QueryableCtrl] =
    Seq(
      alertCtrl,
      auditCtrl,
      caseCtrl,
      caseTemplateCtrl,
      customFieldCtrl,
      dashboardCtrl,
      logCtrl,
      observableCtrl,
      observableTypeCtrl,
      organisationCtrl,
//      pageCtrl,
      patternCtrl,
      procedureCtrl,
      profileCtrl,
      shareCtrl,
      tagCtrl,
      taskCtrl,
      userCtrl,
      taxonomyCtrl
    )

  val limitedCountThresholdConfig: ConfigItem[Long, Long] = appConfig.item[Long]("query.limitedCountThreshold", "Maximum number returned by a count")
  override val limitedCountThreshold: Long                = limitedCountThresholdConfig.get

  override val version: (Int, Int) = 1 -> 1

  override lazy val publicProperties: PublicProperties = controllers.foldLeft(properties.metaProperties)(_ ++ _.publicProperties)

  override lazy val queries: Seq[ParamQuery[_]] =
    controllers.map(_.initialQuery) ++
      controllers.map(_.getQuery) ++
      controllers.map(_.pageQuery(limitedCountThreshold)) ++ // FIXME the value of limitedCountThreshold is read only once. The value is not updated.
      controllers.map(_.outputQuery) ++
      controllers.flatMap(_.extraQueries) :+
      new Query {
        override val name: String = "audits"
        override def checkFrom(t: ru.Type): Boolean =
          RichType.getTypeArgs(t, ru.typeOf[Traversal[_, _, _]]).drop(1).headOption.exists(_ =:= ru.typeOf[Vertex])
        override def toType(t: ru.Type): ru.Type                                                     = ru.typeOf[Traversal.V[Audit]]
        override def apply(param: Unit, fromType: ru.Type, from: Any, authContext: AuthContext): Any = from.asInstanceOf[Traversal.V[Any]].audits
      } :+
      new Query {
        override val name: String = "auditsFromContext"
        override def checkFrom(t: ru.Type): Boolean =
          RichType.getTypeArgs(t, ru.typeOf[Traversal[_, _, _]]).drop(1).headOption.exists(_ =:= ru.typeOf[Vertex])
        override def toType(t: ru.Type): ru.Type = ru.typeOf[Traversal.V[Audit]]
        override def apply(param: Unit, fromType: ru.Type, from: Any, authContext: AuthContext): Any =
          from.asInstanceOf[Traversal.V[Any]].auditsFromContext
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/UserCtrl.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.auth.{AuthSrv, MultiAuthSrv}
import org.thp.scalligraph.controllers.{Entrypoint, FieldsParser}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.{ParamQuery, PublicProperties, Query}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{IteratorOutput, Traversal}
import org.thp.scalligraph.{AuthorizationError, BadRequestError, EntityIdOrName, NotFoundError, NotSupportedError, RichOptionTry}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputUser
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.http.HttpEntity
import play.api.libs.json.{JsNull, JsObject, Json}
import play.api.mvc._

import java.util.{Base64, Date}
import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success, Try}

case class UserOutputParam(from: Long, to: Long, extraData: Set[String], organisation: Option[String])

@Singleton
class UserCtrl @Inject() (
    entrypoint: Entrypoint,
    properties: Properties,
    caseSrv: CaseSrv,
    userSrv: UserSrv,
    authSrv: AuthSrv,
    organisationSrv: OrganisationSrv,
    profileSrv: ProfileSrv,
    auditSrv: AuditSrv,
    attachmentSrv: AttachmentSrv,
    implicit val db: Database
) extends QueryableCtrl
    with UserRenderer {

  override val entityName: String                 = "user"
  override val publicProperties: PublicProperties = properties.user
  lazy val localPasswordAuthSrv: Try[LocalPasswordAuthSrv] = {
    def getLocalPasswordAuthSrv(authSrv: AuthSrv): Option[LocalPasswordAuthSrv] =
      authSrv match {
        case lpas: LocalPasswordAuthSrv => Some(lpas)
        case mas: MultiAuthSrv          => mas.authProviders.flatMap(getLocalPasswordAuthSrv).headOption
        case _                          => None
      }
    getLocalPasswordAuthSrv(authSrv) match {
      case Some(lpas) => Success(lpas)
      case None       => Failure(NotSupportedError("The local password authentication is not enabled"))
    }
  }

  override val initialQuery: Query =
    Query.init[Traversal.V[User]]("listUser", (graph, authContext) => organisationSrv.get(authContext.organisation)(graph).users)

  override val getQuery: ParamQuery[EntityIdOrName] = Query.initWithParam[EntityIdOrName, Traversal.V[User]](
    "getUser",
    (idOrName, graph, authContext) => userSrv.get(idOrName)(graph).visible(authContext)
  )

  override def pageQuery(limitedCountThreshold: Long): ParamQuery[UserOutputParam] =
    Query.withParam[UserOutputParam, Traversal.V[User], IteratorOutput](
      "page",
      {
        case (UserOutputParam(from, to, extraData, organisation), userSteps, authContext) =>
          userSteps.richPage(from, to, extraData.contains("total"), limitedCountThreshold) {
            _.richUserWithCustomRenderer(
              organisation.fold(authContext.organisation)(EntityIdOrName(_)),
              userStatsRenderer(extraData - "Total", localPasswordAuthSrv.toOption)(authContext)
            )(authContext)
          }
      }
    )

  override val outputQuery: Query =
    Query.outputWithContext[RichUser, Traversal.V[User]]((userSteps, authContext) => userSteps.richUser(authContext))

  override val extraQueries: Seq[ParamQuery[_]] = Seq(
    Query.init[Traversal.V[User]]("currentUser", (graph, authContext) => userSrv.current(graph, authContext)),
    Query[Traversal.V[User], Traversal.V[Task]]("tasks", (userSteps, authContext) => userSteps.tasks.visible(organisationSrv)(authContext)),
    Query[Traversal.V[User], Traversal.V[Case]](
      "cases",
      (userSteps, authContext) =>
        caseSrv.startTraversal(userSteps.graph).visible(organisationSrv)(authContext).assignedTo(userSteps.value(_.login).toSeq: _*)
    )
  )
  def current: Action[AnyContent] =
    entrypoint("current user")
      .authRoTransaction(db) { implicit request => implicit graph =>
        userSrv
          .current
          .richUserWithCustomRenderer(request.organisation, _.organisationWithRole)
          .getOrFail("User")
          .map { user =>
            val scope =
              if (user._1.organisation == Organisation.administration.name) "admin"
              else "organisation"
            Results
              .Ok(user.toJson)
              .withHeaders("X-Organisation" -> request.organisation.toString)
              .withHeaders("X-Permissions" -> (Permissions.forScope(scope) & user._1.permissions).mkString(","))
          }
          .recover { case _ => Results.Unauthorized.withHeaders("X-Logout" -> "1") }
      }

  def create: Action[AnyContent] =
    entrypoint("create user")
      .extract("user", FieldsParser[InputUser])
      .auth { implicit request =>
        val inputUser: InputUser = request.body("user")
        db.tryTransaction { implicit graph =>
          val organisationName = inputUser.organisation.map(EntityIdOrName(_)).getOrElse(request.organisation)
          for {
            _            <- userSrv.current.organisations(Permissions.manageUser).get(organisationName).existsOrFail
            organisation <- organisationSrv.getOrFail(organisationName)
            profile      <- profileSrv.getOrFail(EntityIdOrName(inputUser.profile))
            user         <- userSrv.addOrCreateUser(inputUser.toUser, inputUser.avatar, organisation, profile)
          } yield user -> userSrv.canSetPassword(user.user)
        }.flatMap {
          case (user, true) =>
            inputUser
              .password
              .map(password => authSrv.setPassword(user.login, password))
              .flip
              .map(_ => Results.Created(user.toJson))
          case (user, _) => Success(Results.Created(user.toJson))
        }
      }

  def lock(userIdOrName: String): Action[AnyContent] =
    entrypoint("lock user")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          user <- userSrv.current.organisations(Permissions.manageUser).users.get(EntityIdOrName(userIdOrName)).getOrFail("User")
          _    <- userSrv.lock(user)
        } yield Results.NoContent
      }

  def resetFailedAttempts(userIdOrName: String): Action[AnyContent] =
    entrypoint("reset user")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          lpas <- localPasswordAuthSrv
          user <- userSrv.current.organisations(Permissions.manageUser).users.get(EntityIdOrName(userIdOrName)).getOrFail("User")
          _    <- lpas.resetFailedAttempts(user)
        } yield Results.NoContent
      }

  def delete(userIdOrName: String, organisation: Option[String]): Action[AnyContent] =
    entrypoint("delete user")
      .authTransaction(db) { implicit request => implicit graph =>
        for {
          org  <- organisationSrv.getOrFail(organisation.map(EntityIdOrName(_)).getOrElse(request.organisation))
          user <- userSrv.current.organisations(Permissions.manageUser).users.get(EntityIdOrName(userIdOrName)).getOrFail("User")
          _    <- userSrv.delete(user, org)
        } yield Results.NoContent
      }

  def get(userIdOrName: String): Action[AnyContent] =
    entrypoint("get user")
      .authRoTransaction(db) { implicit request => implicit graph =>
        userSrv
          .get(EntityIdOrName(userIdOrName))
          .visible
          .richUser
          .getOrFail("User")
          .map(user => Results.Ok(user.toJson))
      }

  def update(userIdOrName: String): Action[AnyContent] =
    entrypoint("update user")
      .extract("name", FieldsParser.string.optional.on("name"))
      .extract("organisation", FieldsParser.string.optional.on("organisation"))
      .extract("profile", FieldsParser.string.optional.on("profile"))
      .extract("locked", FieldsParser.boolean.optional.on("locked"))
      .extract("avatar", FieldsParser.string.optional.on("avatar"))
      .authTransaction(db) { implicit request => implicit graph =>
        val maybeName: Option[String]         = request.body("name")
        val maybeOrganisation: Option[String] = request.body("organisation")
        val maybeProfile: Option[String]      = request.body("profile")
        val maybeLocked: Option[Boolean]      = request.body("locked")
        val maybeAvatar: Option[String]       = request.body("avatar")
        val isCurrentUser: Boolean =
          userSrv
            .current
            .get(EntityIdOrName(userIdOrName))
            .exists

        val isUserAdmin: Boolean =
          userSrv
            .current
            .organisations(Permissions.manageUser)
            .users
            .get(EntityIdOrName(userIdOrName))
            .exists

        def requireAdmin[A](body: => Try[A]): Try[A] =
          if (isUserAdmin) body else Failure(AuthorizationError("You are not permitted to update this user"))

        userSrv.get(EntityIdOrName(userIdOrName)).visible.getOrFail("User").flatMap {
          case _ if !isCurrentUser && !isUserAdmin => Failure(AuthorizationError("You are not permitted to update this user"))
          case user =>
            auditSrv
              .mergeAudits {
                for {
                  updateName <-
                    maybeName
                      .map(name => userSrv.get(user).update(_.name, name).domainMap(_ => Json.obj("name" -> name)).getOrFail("User"))
                      .flip
                  updateLocked <-
                    maybeLocked
                      .map(locked => requireAdmin(if (locked) userSrv.lock(user) else userSrv.unlock(user)).map(_ => Json.obj("locked" -> locked)))
                      .flip
                  updateProfile <- maybeProfile.map { profileName =>
                    requireAdmin {
                      maybeOrganisation.fold[Try[JsObject]](Failure(BadRequestError("Organisation information is required to update user profile"))) {
                        organisationName =>
                          for {
                            profile      <- profileSrv.getOrFail(EntityIdOrName(profileName))
                            organisation <- organisationSrv.getOrFail(EntityIdOrName(organisationName))
                            _            <- userSrv.setProfile(user, organisation, profile)
                          } yield Json.obj("organisation" -> organisation.name, "profile" -> profile.name)
                      }
                    }
                  }.flip
                  updatedAvatar <- maybeAvatar.map {
                    case "" =>
                      userSrv.unsetAvatar(user)
                      Success(Json.obj("avatar" -> JsNull))
                    case avatar =>
                      attachmentSrv
                        .create(s"${user.login}.avatar", "image/jpeg", Base64.getDecoder.decode(avatar))
                        .flatMap(userSrv.setAvatar(user, _))
                        .map(_ => Json.obj("avatar" -> "[binary data]"))
                  }.flip
                } yield {
                  val updatedProperties = updateName.getOrElse(JsObject.empty) ++
                    updateLocked.getOrElse(JsObject.empty) ++
                    updateProfile.getOrElse(JsObject.empty) ++
                    updatedAvatar.getOrElse(JsObject.empty)
                  if (updatedProperties.fields.nonEmpty)
                    userSrv
                      .get(user)
                      .update(_._updatedBy, Some(request.userId))
                      .update(_._updatedAt, Some(new Date))
                      .iterate()
                  updatedProperties
                }
              }(update => auditSrv.user.update(user, update))
              .map(_ => Results.NoContent)
        }
      }

  def setPassword(userIdOrName: String): Action[AnyContent] =
    entrypoint("set password")
      .extract("password", FieldsParser[String].on("password"))
      .auth { implicit request =>
        for {
          user <- db.roTransaction { implicit graph =>
            if (
              userSrv
                .get(EntityIdOrName(userIdOrName))
                .organisations
                .filterNot(_.users(Permissions.manageUser).current)
                .exists && !userSrv.current.organisations(Permissions.manageUser).isAdmin
            ) Failure(AuthorizationError("You are not authorized to set password of this user"))
            else
              userSrv
                .get(EntityIdOrName(userIdOrName))
                .getOrFail("User")
          }
          _ <- authSrv.setPassword(user.login, request.body("password"))
          _ <- db.tryTransaction(implicit graph => auditSrv.user.update(user, Json.obj("password" -> "<hidden>")))
        } yield Results.NoContent
      }

  def changePassword(userIdOrName: String): Action[AnyContent] =
    entrypoint("change password")
      .extract("password", FieldsParser[String].on("password"))
      .extract("currentPassword", FieldsParser[String].on("currentPassword"))
      .auth { implicit request =>
        for {
          user <- db.roTransaction(implicit graph => userSrv.current.get(EntityIdOrName(userIdOrName)).getOrFail("User"))
          _    <- authSrv.changePassword(user.login, request.body("currentPassword"), request.body("password"))
          _    <- db.tryTransaction(implicit graph => auditSrv.user.update(user, Json.obj("password" -> "<hidden>")))
        } yield Results.NoContent
      }

  def getKey(userIdOrName: String): Action[AnyContent] =
    entrypoint("get key")
      .auth { implicit request =>
        for {
          user <- db.roTransaction { implicit graph =>
            userSrv
              .current
              .organisations(Permissions.manageUser)
              .users
              .get(EntityIdOrName(userIdOrName))
              .getOrFail("User")
              .orElse {
                userSrv
                  .current
                  .get(EntityIdOrName(userIdOrName))
                  .getOrFail("User")
              }
          }
          key <- authSrv.getKey(user.login)
        } yield Results.Ok(key)
      }

  def removeKey(userIdOrName: String): Action[AnyContent] =
    entrypoint("remove key")
      .auth { implicit request =>
        for {
          user <- db.roTransaction { implicit graph =>
            userSrv
              .current
              .organisations(Permissions.manageUser)
              .users
              .get(EntityIdOrName(userIdOrName))
              .getOrFail("User")
          }
          _ <- authSrv.removeKey(user.login)
          _ <- db.tryTransaction(implicit graph => auditSrv.user.update(user, Json.obj("key" -> "<hidden>")))
        } yield Results.NoContent
      //          Failure(AuthorizationError(s"User $userId doesn't exist or permission is insufficient"))
      }

  def renewKey(userIdOrName: String): Action[AnyContent] =
    entrypoint("renew key")
      .auth { implicit request =>
        for {
          user <- db.roTransaction { implicit graph =>
            userSrv
              .current
              .organisations(Permissions.manageUser)
              .users
              .get(EntityIdOrName(userIdOrName))
              .getOrFail("User")
          }
          key <- authSrv.renewKey(user.login)
          _   <- db.tryTransaction(implicit graph => auditSrv.user.update(user, Json.obj("key" -> "<hidden>")))
        } yield Results.Ok(key)
      }

  def avatar(userIdOrName: String): Action[AnyContent] =
    entrypoint("get user avatar")
      .authTransaction(db) { implicit request => implicit graph =>
        userSrv.get(EntityIdOrName(userIdOrName)).visible.avatar.headOption match {
          case Some(avatar) if attachmentSrv.exists(avatar) =>
            Success(
              Result(
                header = ResponseHeader(200),
                body = HttpEntity.Streamed(
                  attachmentSrv.source(avatar),
                  Some(avatar.size),
                  Some(avatar.contentType)
                )
              )
            )
          case _ => Failure(NotFoundError(s"user $userIdOrName has no avatar"))
        }
      }
}

```

`thehive/app/org/thp/thehive/controllers/v1/UserRenderer.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Traversal}
import org.thp.thehive.models.{Permissions, User}
import org.thp.thehive.services.LocalPasswordAuthSrv
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import play.api.libs.json._

import java.util.{Map => JMap}

trait UserRenderer extends BaseRenderer[User] {

  def lockout(
      localPasswordAuthSrv: Option[LocalPasswordAuthSrv]
  )(implicit authContext: AuthContext): Traversal.V[User] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
    _.project(_.by.by(_.organisations.users(Permissions.manageUser).current.option))
      .domainMap {
        case (user, Some(_)) =>
          Json.obj(
            "lastFailed"     -> user.lastFailed,
            "failedAttempts" -> user.failedAttempts,
            "lockedUntil"    -> localPasswordAuthSrv.flatMap(_.lockedUntil(user))
          )
        case _ => JsObject.empty
      }

  def userStatsRenderer(extraData: Set[String], authSrv: Option[LocalPasswordAuthSrv])(implicit
      authContext: AuthContext
  ): Traversal.V[User] => JsTraversal = { implicit traversal =>
    baseRenderer(
      extraData,
      traversal,
      {
        case (f, "lockout") => addData("lockout", f)(lockout(authSrv))
        case (f, _)         => f
      }
    )
  }
}

```

`thehive/app/org/thp/thehive/models/Alert.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph._
import org.thp.scalligraph.models.{DefineIndex, Entity, IndexType}

import java.util.Date

@BuildEdgeEntity[Alert, CustomField]
case class AlertCustomField(
    order: Option[Int] = None,
    stringValue: Option[String] = None,
    booleanValue: Option[Boolean] = None,
    integerValue: Option[Int] = None,
    floatValue: Option[Double] = None,
    dateValue: Option[Date] = None
) extends CustomFieldValue[AlertCustomField] {
  override def order_=(value: Option[Int]): AlertCustomField            = copy(order = value)
  override def stringValue_=(value: Option[String]): AlertCustomField   = copy(stringValue = value)
  override def booleanValue_=(value: Option[Boolean]): AlertCustomField = copy(booleanValue = value)
  override def integerValue_=(value: Option[Int]): AlertCustomField     = copy(integerValue = value)
  override def floatValue_=(value: Option[Double]): AlertCustomField    = copy(floatValue = value)
  override def dateValue_=(value: Option[Date]): AlertCustomField       = copy(dateValue = value)
}

@BuildEdgeEntity[Alert, Observable]
case class AlertObservable()

@BuildEdgeEntity[Alert, Organisation]
case class AlertOrganisation()

@BuildEdgeEntity[Alert, Case]
case class AlertCase()

@BuildEdgeEntity[Alert, CaseTemplate]
case class AlertCaseTemplate()

@BuildEdgeEntity[Alert, Tag]
case class AlertTag()

@BuildVertexEntity
@DefineIndex(IndexType.unique, "type", "source", "sourceRef", "organisationId")
@DefineIndex(IndexType.standard, "type")
@DefineIndex(IndexType.standard, "source")
@DefineIndex(IndexType.standard, "sourceRef")
@DefineIndex(IndexType.fulltext, "title")
@DefineIndex(IndexType.fulltextOnly, "description")
@DefineIndex(IndexType.standard, "severity")
@DefineIndex(IndexType.standard, "date")
@DefineIndex(IndexType.standard, "lastSyncDate")
@DefineIndex(IndexType.standard, "tlp")
@DefineIndex(IndexType.standard, "pap")
@DefineIndex(IndexType.standard, "read")
@DefineIndex(IndexType.standard, "follow")
@DefineIndex(IndexType.standard, "tags")
@DefineIndex(IndexType.standard, "organisationId")
@DefineIndex(IndexType.standard, "caseId")
case class Alert(
    `type`: String,
    source: String,
    sourceRef: String,
    externalLink: Option[String],
    title: String,
    description: String,
    severity: Int,
    date: Date,
    lastSyncDate: Date,
    tlp: Int,
    pap: Int,
    read: Boolean,
    follow: Boolean,
    tags: Seq[String],
    /* filled by the service */
    organisationId: EntityId = EntityId.empty,
    caseId: EntityId = EntityId.empty // empty string means no related case (index optimisation)
)

case class RichAlert(
    alert: Alert with Entity,
    customFields: Seq[RichCustomField],
    caseId: Option[EntityId],
    caseTemplate: Option[String],
    observableCount: Long
) {
  def _id: EntityId                = alert._id
  def _createdAt: Date             = alert._createdAt
  def _createdBy: String           = alert._createdBy
  def _updatedAt: Option[Date]     = alert._updatedAt
  def _updatedBy: Option[String]   = alert._updatedBy
  def `type`: String               = alert.`type`
  def source: String               = alert.source
  def sourceRef: String            = alert.sourceRef
  def externalLink: Option[String] = alert.externalLink
  def title: String                = alert.title
  def description: String          = alert.description
  def severity: Int                = alert.severity
  def date: Date                   = alert.date
  def lastSyncDate: Date           = alert.lastSyncDate
  def tlp: Int                     = alert.tlp
  def pap: Int                     = alert.pap
  def read: Boolean                = alert.read
  def follow: Boolean              = alert.follow
  def tags: Seq[String]            = alert.tags
}

```

`thehive/app/org/thp/thehive/models/Attachment.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.BuildVertexEntity
import org.thp.scalligraph.models.{DefineIndex, IndexType}
import org.thp.scalligraph.utils.Hash

@DefineIndex(IndexType.fulltext, "name")
@DefineIndex(IndexType.standard, "size")
@DefineIndex(IndexType.fulltext, "contentType")
@DefineIndex(IndexType.standard, "hashes")
@DefineIndex(IndexType.standard, "attachmentId")
@BuildVertexEntity
case class Attachment(name: String, size: Long, contentType: String, hashes: Seq[Hash], attachmentId: String)

```

`thehive/app/org/thp/thehive/models/Audit.scala`:

```scala
package org.thp.thehive.models

import org.apache.tinkerpop.gremlin.structure.{Edge, Vertex}
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.{Converter, Graph}
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}

import java.util.Date

@BuildEdgeEntity[Audit, User]
case class AuditUser()

@BuildVertexEntity
@DefineIndex(IndexType.basic, "requestId", "mainAction")
@DefineIndex(IndexType.standard, "requestId")
@DefineIndex(IndexType.standard, "action")
@DefineIndex(IndexType.standard, "mainAction")
@DefineIndex(IndexType.standard, "objectId")
@DefineIndex(IndexType.standard, "objectType")
@DefineIndex(IndexType.standard, "_createdAt")
@DefineIndex(IndexType.standard, "_updatedAt")
case class Audit(
    requestId: String,
    action: String,
    mainAction: Boolean,
    objectId: Option[String],
    objectType: Option[String],
    details: Option[String]
) {
  def objectEntityId: Option[EntityId] = objectId.map(EntityId.read)
}

object Audit {

  def apply(action: String, entity: Entity, details: Option[String] = None)(implicit authContext: AuthContext): Audit =
    Audit(authContext.requestId, action, mainAction = false, Some(entity._id.toString), Some(entity._label), details)

  final val create = "create"
  final val update = "update"
  final val delete = "delete"
  final val merge  = "merge"
}

case class RichAudit(
    _id: EntityId,
    _createdAt: Date,
    _createdBy: String,
    action: String,
    mainAction: Boolean,
    requestId: String,
    objectId: Option[String],
    objectType: Option[String],
    details: Option[String],
    context: Entity,
    visibilityContext: Entity,
    `object`: Option[Entity]
) {
  def objectEntityId: Option[EntityId] = objectId.map(EntityId.read)
}

object RichAudit {

  def apply(
      audit: Audit with Entity,
      context: Product with Entity,
      visibilityContext: Product with Entity,
      `object`: Option[Product with Entity]
  ): RichAudit =
    new RichAudit(
      audit._id,
      audit._createdAt,
      audit._createdBy,
      audit.action,
      audit.mainAction,
      audit.requestId,
      audit.objectId,
      audit.objectType,
      audit.details,
      context,
      visibilityContext,
      `object`
    )
}

case class Audited()

object Audited {

  val model: Model.Edge[Audited] = new EdgeModel { thisModel =>
    override type E = Audited
    override val label: String                                = "Audited"
    override val indexes: Seq[(IndexType.Value, Seq[String])] = Nil

    override val fields: Map[String, Mapping[_, _, _]] = Map.empty
    override val converter: Converter[EEntity, Edge] = (element: Edge) =>
      new Audited with Entity {
        override val _id: EntityId              = EntityId(element.id())
        override val _label: String             = "Audited"
        override val _createdBy: String         = UMapping.string.getProperty(element, "_createdBy")
        override val _updatedBy: Option[String] = UMapping.string.optional.getProperty(element, "_updatedBy")
        override val _createdAt: Date           = UMapping.date.getProperty(element, "_createdAt")
        override val _updatedAt: Option[Date]   = UMapping.date.optional.getProperty(element, "_updatedAt")
      }
    override def addEntity(a: Audited, entity: Entity): EEntity =
      new Audited with Entity {
        override def _id: EntityId              = entity._id
        override def _label: String             = entity._label
        override def _createdBy: String         = entity._createdBy
        override def _updatedBy: Option[String] = entity._updatedBy
        override def _createdAt: Date           = entity._createdAt
        override def _updatedAt: Option[Date]   = entity._updatedAt
      }
    override def create(e: Audited, from: Vertex, to: Vertex)(implicit graph: Graph): Edge = from.addEdge(label, to)
  }
}
case class AuditContext()

object AuditContext extends HasModel {

  override val model: Model.Edge[AuditContext] = new EdgeModel { thisModel =>
    override type E = AuditContext
    override val label: String                                = "AuditContext"
    override val indexes: Seq[(IndexType.Value, Seq[String])] = Nil

    override val fields: Map[String, Mapping[_, _, _]] = Map.empty
    override val converter: Converter[EEntity, Edge] = (element: Edge) =>
      new AuditContext with Entity {
        override val _id: EntityId              = EntityId(element.id())
        override val _label: String             = "AuditContext"
        override val _createdBy: String         = UMapping.string.getProperty(element, "_createdBy")
        override val _updatedBy: Option[String] = UMapping.string.optional.getProperty(element, "_updatedBy")
        override val _createdAt: Date           = UMapping.date.getProperty(element, "_createdAt")
        override val _updatedAt: Option[Date]   = UMapping.date.optional.getProperty(element, "_updatedAt")
      }
    override def addEntity(a: AuditContext, entity: Entity): EEntity =
      new AuditContext with Entity {
        override def _id: EntityId              = entity._id
        override def _label: String             = entity._label
        override def _createdBy: String         = entity._createdBy
        override def _updatedBy: Option[String] = entity._updatedBy
        override def _createdAt: Date           = entity._createdAt
        override def _updatedAt: Option[Date]   = entity._updatedAt
      }
    override def create(e: AuditContext, from: Vertex, to: Vertex)(implicit graph: Graph): Edge =
      from.addEdge(label, to)
  }
}

```

`thehive/app/org/thp/thehive/models/Case.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph._
import org.thp.scalligraph.auth.Permission
import org.thp.scalligraph.models.{DefineIndex, Entity, IndexType}
import play.api.libs.json.{Format, Json}

import java.util.Date

object CaseStatus extends Enumeration {
  val Open, Resolved, Duplicated = Value

  implicit val format: Format[CaseStatus.Value] = Json.formatEnum(CaseStatus)
}

@BuildVertexEntity
@DefineIndex(IndexType.unique, "value")
case class ResolutionStatus(value: String) {
  require(value.nonEmpty, "ResolutionStatus can't be empty")
}

object ResolutionStatus {
  val indeterminate: ResolutionStatus = ResolutionStatus("Indeterminate")
  val falsePositive: ResolutionStatus = ResolutionStatus("FalsePositive")
  val truePositive: ResolutionStatus  = ResolutionStatus("TruePositive")
  val other: ResolutionStatus         = ResolutionStatus("Other")
  val duplicated: ResolutionStatus    = ResolutionStatus("Duplicated")

  val initialValues = Seq(indeterminate, falsePositive, truePositive, other, duplicated)
}

@BuildEdgeEntity[Case, ResolutionStatus]
case class CaseResolutionStatus()

@BuildVertexEntity
@DefineIndex(IndexType.unique, "value")
case class ImpactStatus(value: String) {
  require(value.nonEmpty, "ImpactStatus can't be empty")
}

object ImpactStatus {
  val noImpact: ImpactStatus           = ImpactStatus("NoImpact")
  val withImpact: ImpactStatus         = ImpactStatus("WithImpact")
  val notApplicable: ImpactStatus      = ImpactStatus("NotApplicable")
  val initialValues: Seq[ImpactStatus] = Seq(noImpact, withImpact, notApplicable)
}

@BuildEdgeEntity[Case, ImpactStatus]
case class CaseImpactStatus()

@BuildEdgeEntity[Case, Tag]
case class CaseTag()

@BuildEdgeEntity[Case, Case]
case class MergedFrom()

@BuildEdgeEntity[Case, CustomField]
case class CaseCustomField(
    order: Option[Int] = None,
    stringValue: Option[String] = None,
    booleanValue: Option[Boolean] = None,
    integerValue: Option[Int] = None,
    floatValue: Option[Double] = None,
    dateValue: Option[Date] = None
) extends CustomFieldValue[CaseCustomField] {
  override def order_=(value: Option[Int]): CaseCustomField            = copy(order = value)
  override def stringValue_=(value: Option[String]): CaseCustomField   = copy(stringValue = value)
  override def booleanValue_=(value: Option[Boolean]): CaseCustomField = copy(booleanValue = value)
  override def integerValue_=(value: Option[Int]): CaseCustomField     = copy(integerValue = value)
  override def floatValue_=(value: Option[Double]): CaseCustomField    = copy(floatValue = value)
  override def dateValue_=(value: Option[Date]): CaseCustomField       = copy(dateValue = value)
}

@BuildEdgeEntity[Case, User]
case class CaseUser()

@BuildEdgeEntity[Case, CaseTemplate]
case class CaseCaseTemplate()

@BuildEdgeEntity[Case, Procedure]
case class CaseProcedure()

@BuildVertexEntity
@DefineIndex(IndexType.unique, "number")
@DefineIndex(IndexType.fulltext, "title")
@DefineIndex(IndexType.fulltextOnly, "description")
@DefineIndex(IndexType.standard, "severity")
@DefineIndex(IndexType.standard, "startDate")
@DefineIndex(IndexType.standard, "endDate")
@DefineIndex(IndexType.standard, "flag")
@DefineIndex(IndexType.standard, "tlp")
@DefineIndex(IndexType.standard, "pap")
@DefineIndex(IndexType.standard, "status")
@DefineIndex(IndexType.fulltextOnly, "summary")
@DefineIndex(IndexType.standard, "tags")
@DefineIndex(IndexType.standard, "assignee")
@DefineIndex(IndexType.standard, "organisationIds")
@DefineIndex(IndexType.standard, "impactStatus")
@DefineIndex(IndexType.standard, "resolutionStatus")
@DefineIndex(IndexType.standard, "caseTemplate")
case class Case(
    title: String,
    description: String,
    severity: Int,
    startDate: Date,
    endDate: Option[Date],
    flag: Boolean,
    tlp: Int,
    pap: Int,
    status: CaseStatus.Value,
    summary: Option[String],
    tags: Seq[String],
    impactStatus: Option[String] = None,
    resolutionStatus: Option[String] = None,
    /* filled by the service */
    assignee: Option[String] = None,
    number: Int = 0,
    organisationIds: Set[EntityId] = Set.empty,
    caseTemplate: Option[String] = None,
    owningOrganisation: EntityId = EntityId.empty
)

case class RichCase(
    `case`: Case with Entity,
    customFields: Seq[RichCustomField],
    userPermissions: Set[Permission]
) {
  def _id: EntityId                    = `case`._id
  def _createdBy: String               = `case`._createdBy
  def _updatedBy: Option[String]       = `case`._updatedBy
  def _createdAt: Date                 = `case`._createdAt
  def _updatedAt: Option[Date]         = `case`._updatedAt
  def number: Int                      = `case`.number
  def title: String                    = `case`.title
  def description: String              = `case`.description
  def severity: Int                    = `case`.severity
  def startDate: Date                  = `case`.startDate
  def endDate: Option[Date]            = `case`.endDate
  def flag: Boolean                    = `case`.flag
  def tlp: Int                         = `case`.tlp
  def pap: Int                         = `case`.pap
  def status: CaseStatus.Value         = `case`.status
  def summary: Option[String]          = `case`.summary
  def tags: Seq[String]                = `case`.tags
  def assignee: Option[String]         = `case`.assignee
  def impactStatus: Option[String]     = `case`.impactStatus
  def resolutionStatus: Option[String] = `case`.resolutionStatus
  def caseTemplate: Option[String]     = `case`.caseTemplate
}

object RichCase {

  def apply(
      __id: EntityId,
      __createdBy: String,
      __updatedBy: Option[String],
      __createdAt: Date,
      __updatedAt: Option[Date],
      number: Int,
      title: String,
      description: String,
      severity: Int,
      startDate: Date,
      endDate: Option[Date],
      tags: Seq[String],
      flag: Boolean,
      tlp: Int,
      pap: Int,
      status: CaseStatus.Value,
      summary: Option[String],
      impactStatus: Option[String],
      resolutionStatus: Option[String],
      assignee: Option[String],
      customFields: Seq[RichCustomField],
      userPermissions: Set[Permission],
      organisationIds: Set[EntityId],
      caseTemplate: Option[String] = None,
      owningOrganisation: EntityId = EntityId.empty
  ): RichCase = {
    val `case`: Case with Entity =
      new Case(
        number = number,
        title = title,
        description = description,
        severity = severity,
        startDate = startDate,
        endDate = endDate,
        flag = flag,
        tlp = tlp,
        pap = pap,
        status = status,
        summary = summary,
        organisationIds = organisationIds,
        tags = tags,
        assignee = assignee,
        impactStatus = impactStatus,
        resolutionStatus = resolutionStatus,
        caseTemplate = caseTemplate,
        owningOrganisation = owningOrganisation
      ) with Entity {
        override val _id: EntityId              = __id
        override val _label: String             = "Case"
        override val _createdBy: String         = __createdBy
        override val _updatedBy: Option[String] = __updatedBy
        override val _createdAt: Date           = __createdAt
        override val _updatedAt: Option[Date]   = __updatedAt
      }
    RichCase(`case`, customFields, userPermissions)
  }
}

case class SimilarStats(observable: (Int, Int), ioc: (Int, Int), types: Map[String, Long])

```

`thehive/app/org/thp/thehive/models/CaseTemplate.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}

import java.util.Date

@BuildEdgeEntity[CaseTemplate, Organisation]
case class CaseTemplateOrganisation()

@BuildEdgeEntity[CaseTemplate, CustomField]
case class CaseTemplateCustomField(
    order: Option[Int] = None,
    stringValue: Option[String] = None,
    booleanValue: Option[Boolean] = None,
    integerValue: Option[Int] = None,
    floatValue: Option[Double] = None,
    dateValue: Option[Date] = None
) extends CustomFieldValue[CaseTemplateCustomField] {
  override def order_=(value: Option[Int]): CaseTemplateCustomField            = copy(order = value)
  override def stringValue_=(value: Option[String]): CaseTemplateCustomField   = copy(stringValue = value)
  override def booleanValue_=(value: Option[Boolean]): CaseTemplateCustomField = copy(booleanValue = value)
  override def integerValue_=(value: Option[Int]): CaseTemplateCustomField     = copy(integerValue = value)
  override def floatValue_=(value: Option[Double]): CaseTemplateCustomField    = copy(floatValue = value)
  override def dateValue_=(value: Option[Date]): CaseTemplateCustomField       = copy(dateValue = value)
}

@BuildEdgeEntity[CaseTemplate, Tag]
case class CaseTemplateTag()

@BuildEdgeEntity[CaseTemplate, Task]
case class CaseTemplateTask()

@BuildVertexEntity
case class CaseTemplate(
    name: String,
    displayName: String,
    titlePrefix: Option[String],
    description: Option[String],
    tags: Seq[String],
    severity: Option[Int],
    flag: Boolean,
    tlp: Option[Int],
    pap: Option[Int],
    summary: Option[String]
)

case class RichCaseTemplate(
    caseTemplate: CaseTemplate with Entity,
    organisation: String,
    tasks: Seq[RichTask],
    customFields: Seq[RichCustomField]
) {
  def _id: EntityId               = caseTemplate._id
  def _createdBy: String          = caseTemplate._createdBy
  def _updatedBy: Option[String]  = caseTemplate._updatedBy
  def _createdAt: Date            = caseTemplate._createdAt
  def _updatedAt: Option[Date]    = caseTemplate._updatedAt
  def name: String                = caseTemplate.name
  def displayName: String         = caseTemplate.displayName
  def titlePrefix: Option[String] = caseTemplate.titlePrefix
  def description: Option[String] = caseTemplate.description
  def tags: Seq[String]           = caseTemplate.tags
  def severity: Option[Int]       = caseTemplate.severity
  def flag: Boolean               = caseTemplate.flag
  def tlp: Option[Int]            = caseTemplate.tlp
  def pap: Option[Int]            = caseTemplate.pap
  def summary: Option[String]     = caseTemplate.summary
}

```

`thehive/app/org/thp/thehive/models/Config.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity}
import play.api.libs.json.JsValue

@BuildVertexEntity
case class Config(name: String, value: JsValue)

@BuildEdgeEntity[Organisation, Config]
case class OrganisationConfig()

@BuildEdgeEntity[User, Config]
case class UserConfig()

```

`thehive/app/org/thp/thehive/models/CustomField.scala`:

```scala
package org.thp.thehive.models

import org.apache.tinkerpop.gremlin.structure.Edge
import org.thp.scalligraph._
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.Traversal
import org.thp.scalligraph.traversal.Traversal.{Domain, E}
import org.thp.scalligraph.traversal.TraversalOps._
import play.api.libs.json._

import java.util.{Date, NoSuchElementException}
import scala.util.{Failure, Success, Try}

trait CustomFieldValue[C] extends Product {
  def order: Option[Int]
  def stringValue: Option[String]
  def booleanValue: Option[Boolean]
  def integerValue: Option[Int]
  def floatValue: Option[Double]
  def dateValue: Option[Date]
  def order_=(value: Option[Int]): C
  def stringValue_=(value: Option[String]): C
  def booleanValue_=(value: Option[Boolean]): C
  def integerValue_=(value: Option[Int]): C
  def floatValue_=(value: Option[Double]): C
  def dateValue_=(value: Option[Date]): C
}

class CustomFieldValueEdge(edge: Edge) extends CustomFieldValue[CustomFieldValueEdge] with Entity {
  override def order: Option[Int]            = UMapping.int.optional.getProperty(edge, "order")
  override def stringValue: Option[String]   = UMapping.string.optional.getProperty(edge, "stringValue")
  override def booleanValue: Option[Boolean] = UMapping.boolean.optional.getProperty(edge, "booleanValue")
  override def integerValue: Option[Int]     = UMapping.int.optional.getProperty(edge, "integerValue")
  override def floatValue: Option[Double]    = UMapping.double.optional.getProperty(edge, "floatValue")
  override def dateValue: Option[Date]       = UMapping.date.optional.getProperty(edge, "dateValue")

  override def order_=(value: Option[Int]): CustomFieldValueEdge = {
    UMapping.int.optional.setProperty(edge, "order", value)
    this
  }

  override def stringValue_=(value: Option[String]): CustomFieldValueEdge = {
    UMapping.string.optional.setProperty(edge, "stringValue", value)
    this
  }
  override def booleanValue_=(value: Option[Boolean]): CustomFieldValueEdge = {
    UMapping.boolean.optional.setProperty(edge, "booleanValue", value)
    this
  }
  override def integerValue_=(value: Option[Int]): CustomFieldValueEdge = {
    UMapping.int.optional.setProperty(edge, "integerValue", value)
    this
  }
  override def floatValue_=(value: Option[Double]): CustomFieldValueEdge = {
    UMapping.double.optional.setProperty(edge, "floatValue", value)
    this
  }
  override def dateValue_=(value: Option[Date]): CustomFieldValueEdge = {
    UMapping.date.optional.setProperty(edge, "dateValue", value)
    this
  }
  override def productElement(n: Int): Any  = throw new NoSuchElementException
  override def productArity: Int            = 0
  override def canEqual(that: Any): Boolean = that.isInstanceOf[CustomFieldValueEdge]

  override def _id: EntityId              = EntityId(edge.id())
  override def _label: String             = edge.label()
  override def _createdBy: String         = UMapping.string.getProperty(edge, "_createdBy")
  override def _updatedBy: Option[String] = UMapping.string.optional.getProperty(edge, "_updatedBy")
  override def _createdAt: Date           = UMapping.date.getProperty(edge, "_createdAt")
  override def _updatedAt: Option[Date]   = UMapping.date.optional.getProperty(edge, "_updatedAt")
}

object CustomFieldType extends Enumeration {
  val string, integer, float, boolean, date = Value

  val map: Map[Value, CustomFieldType[_]] = Map(
    string  -> CustomFieldString,
    integer -> CustomFieldInteger,
    float   -> CustomFieldFloat,
    boolean -> CustomFieldBoolean,
    date    -> CustomFieldDate
  )
  def get(name: String): CustomFieldType[_] = map(this.withName(name))
}

sealed abstract class CustomFieldType[T] {
  val name: String
  val writes: Writes[T]

  def setValue[C <: CustomFieldValue[C]](customFieldValue: C, value: Option[Any]): Try[C]

  def getValue(ccf: CustomFieldValue[_]): Option[T]

  def getJsonValue(ccf: CustomFieldValue[_]): JsValue = getValue(ccf).fold[JsValue](JsNull)(writes.writes)

  def getValue[C <: CustomFieldValue[_]](traversal: Traversal.E[C]): Traversal.Domain[T]

  def getJsonValue[C <: CustomFieldValue[_]](traversal: Traversal.E[C]): Traversal.Domain[JsValue] = getValue(traversal).domainMap(writes.writes)

  override def toString: String = name

  protected def setValueFailure(value: Any): Failure[Nothing] =
    Failure(BadRequestError(s"""Invalid value type for custom field.
                               |  Expected: $name
                               |  Found   : $value (${value.getClass})
                             """.stripMargin))
}

object CustomFieldString extends CustomFieldType[String] {
  override val name: String           = "string"
  override val writes: Writes[String] = Writes.StringWrites

  override def setValue[C <: CustomFieldValue[C]](customFieldValue: C, value: Option[Any]): Try[C] =
    value.getOrElse(JsNull) match {
      case v: String     => Success(customFieldValue.stringValue = Some(v))
      case JsString(v)   => Success(customFieldValue.stringValue = Some(v))
      case JsNull | null => Success(customFieldValue.stringValue = None)
      case obj: JsObject =>
        val stringValue = (obj \ "string").asOpt[String]
        val order       = (obj \ "order").asOpt[Int]
        Success((customFieldValue.stringValue = stringValue).order = order)
      case _ => setValueFailure(value)
    }

  override def getValue(ccf: CustomFieldValue[_]): Option[String] = ccf.stringValue

  override def getValue[C <: CustomFieldValue[_]](traversal: E[C]): Traversal.Domain[String] = traversal.value(_.stringValue).castDomain
}

object CustomFieldBoolean extends CustomFieldType[Boolean] {
  override val name: String            = "boolean"
  override val writes: Writes[Boolean] = Writes.BooleanWrites

  override def setValue[C <: CustomFieldValue[C]](customFieldValue: C, value: Option[Any]): Try[C] =
    value.getOrElse(JsNull) match {
      case v: Boolean    => Success(customFieldValue.booleanValue = Some(v))
      case JsBoolean(v)  => Success(customFieldValue.booleanValue = Some(v))
      case JsNull | null => Success(customFieldValue.booleanValue = None)
      case obj: JsObject =>
        val booleanValue = (obj \ "boolean").asOpt[Boolean]
        val order        = (obj \ "order").asOpt[Int]
        Success((customFieldValue.booleanValue = booleanValue).order = order)

      case _ => setValueFailure(value)
    }

  override def getValue(ccf: CustomFieldValue[_]): Option[Boolean] = ccf.booleanValue

  override def getValue[C <: CustomFieldValue[_]](traversal: E[C]): Domain[Boolean] = traversal.value(_.booleanValue).castDomain
}

object CustomFieldInteger extends CustomFieldType[Int] {
  override val name: String        = "integer"
  override val writes: Writes[Int] = Writes.IntWrites

  override def setValue[C <: CustomFieldValue[C]](customFieldValue: C, value: Option[Any]): Try[C] =
    value.getOrElse(JsNull) match {
      case v: Int        => Success(customFieldValue.integerValue = Some(v))
      case v: Double     => Success(customFieldValue.integerValue = Some(v.toInt))
      case JsNumber(n)   => Success(customFieldValue.integerValue = Some(n.toInt))
      case JsNull | null => Success(customFieldValue.integerValue = None)
      case obj: JsObject =>
        val integerValue = (obj \ "integer").asOpt[Int]
        val order        = (obj \ "order").asOpt[Int]
        Success((customFieldValue.integerValue = integerValue).order = order)

      case _ => setValueFailure(value)
    }

  override def getValue(ccf: CustomFieldValue[_]): Option[Int] = ccf.integerValue

  override def getValue[C <: CustomFieldValue[_]](traversal: E[C]): Domain[Int] = traversal.value(_.integerValue).castDomain
}

object CustomFieldFloat extends CustomFieldType[Double] {
  override val name: String           = "float"
  override val writes: Writes[Double] = Writes.DoubleWrites

  override def setValue[C <: CustomFieldValue[C]](customFieldValue: C, value: Option[Any]): Try[C] =
    value.getOrElse(JsNull) match {
      case n: Number     => Success(customFieldValue.floatValue = Some(n.doubleValue()))
      case JsNumber(n)   => Success(customFieldValue.floatValue = Some(n.toDouble))
      case JsNull | null => Success(customFieldValue.floatValue = None)
      case obj: JsObject =>
        val floatValue = (obj \ "float").asOpt[Double]
        val order      = (obj \ "order").asOpt[Int]
        Success((customFieldValue.floatValue = floatValue).order = order)

      case _ => setValueFailure(value)
    }

  override def getValue(ccf: CustomFieldValue[_]): Option[Double] = ccf.floatValue

  override def getValue[C <: CustomFieldValue[_]](traversal: E[C]): Domain[Double] = traversal.value(_.floatValue).castDomain
}

object CustomFieldDate extends CustomFieldType[Date] {
  override val name: String         = "date"
  override val writes: Writes[Date] = Writes[Date](d => JsNumber(d.getTime))

  override def setValue[C <: CustomFieldValue[C]](customFieldValue: C, value: Option[Any]): Try[C] =
    value.getOrElse(JsNull) match {
      case n: Number     => Success(customFieldValue.dateValue = Some(new Date(n.longValue())))
      case JsNumber(n)   => Success(customFieldValue.dateValue = Some(new Date(n.toLong)))
      case v: Date       => Success(customFieldValue.dateValue = Some(v))
      case JsNull | null => Success(customFieldValue.dateValue = None)
      case obj: JsObject =>
        val dateValue = (obj \ "date").asOpt[Long].map(new Date(_))
        val order     = (obj \ "order").asOpt[Int]
        Success((customFieldValue.dateValue = dateValue).order = order)

      case _ => setValueFailure(value)
    }

  override def getValue(ccf: CustomFieldValue[_]): Option[Date] = ccf.dateValue

  override def getValue[C <: CustomFieldValue[_]](traversal: E[C]): Domain[Date] = traversal.value(_.dateValue).castDomain
}

@DefineIndex(IndexType.unique, "name")
@BuildVertexEntity
case class CustomField(
    name: String,
    displayName: String,
    description: String,
    `type`: CustomFieldType.Value,
    mandatory: Boolean,
    options: Seq[JsValue]
)

case class RichCustomField(customField: CustomField with Entity, customFieldValue: CustomFieldValue[_] with Entity) {
  def name: String               = customField.name
  def description: String        = customField.description
  def typeName: String           = customField.`type`.toString
  def value: Option[Any]         = `type`.getValue(customFieldValue)
  def jsValue: JsValue           = `type`.getJsonValue(customFieldValue)
  def order: Option[Int]         = customFieldValue.order
  def `type`: CustomFieldType[_] = CustomFieldType.map(customField.`type`)
  def toJson: JsValue            = value.fold[JsValue](JsNull)(`type`.writes.asInstanceOf[Writes[Any]].writes)
}

```

`thehive/app/org/thp/thehive/models/Dashboard.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityIdOrName}
import play.api.libs.json.JsObject

import java.util.Date

@BuildVertexEntity
case class Dashboard(title: String, description: String, definition: JsObject)

@BuildEdgeEntity[Dashboard, User]
case class DashboardUser()

@BuildEdgeEntity[Organisation, Dashboard]
case class OrganisationDashboard(writable: Boolean)

case class RichDashboard(
    dashboard: Dashboard with Entity,
    organisationShares: Map[String, Boolean],
    writable: Boolean
) {
  def _id: EntityIdOrName        = dashboard._id
  def _createdBy: String         = dashboard._createdBy
  def _updatedBy: Option[String] = dashboard._updatedBy
  def _createdAt: Date           = dashboard._createdAt
  def _updatedAt: Option[Date]   = dashboard._updatedAt
  def title: String              = dashboard.title
  def description: String        = dashboard.description
  def definition: JsObject       = dashboard.definition

}

```

`thehive/app/org/thp/thehive/models/HealthStatus.scala`:

```scala
package org.thp.thehive.models

object HealthStatus extends Enumeration {
  val Ok, Warning, Error = Value
}

```

`thehive/app/org/thp/thehive/models/KeyValue.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.BuildVertexEntity

import java.util.Date

object ValueType extends Enumeration {
  val string, integer, float, boolean, date = Value
}

@BuildVertexEntity
case class KeyValue(
    namespace: String,
    predicate: String,
    level: String,
    `type`: ValueType.Value,
    string: Option[String],
    integer: Option[Int],
    float: Option[Double],
    boolean: Option[Boolean],
    date: Option[Date]
)

```

`thehive/app/org/thp/thehive/models/Log.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.models.{DefineIndex, Entity, IndexType}
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}

import java.util.Date

@BuildEdgeEntity[Log, Attachment]
case class LogAttachment()

@DefineIndex(IndexType.fulltextOnly, "message")
@DefineIndex(IndexType.standard, "date")
@DefineIndex(IndexType.standard, "taskId")
@DefineIndex(IndexType.standard, "organisationIds")
@BuildVertexEntity
case class Log(
    message: String,
    date: Date,
    /* filled by the service */
    taskId: EntityId = EntityId.empty,
    organisationIds: Set[EntityId] = Set.empty
)

case class RichLog(log: Log with Entity, attachments: Seq[Attachment with Entity]) {
  def _id: EntityId              = log._id
  def _createdBy: String         = log._createdBy
  def _updatedBy: Option[String] = log._updatedBy
  def _createdAt: Date           = log._createdAt
  def _updatedAt: Option[Date]   = log._updatedAt
  def date: Date                 = log.date
  def message: String            = log.message
}

```

`thehive/app/org/thp/thehive/models/Observable.scala`:

```scala
package org.thp.thehive.models

import org.apache.tinkerpop.gremlin.structure.{Vertex, VertexProperty}
import org.thp.scalligraph.janus.{ImmenseStringTermFilter, ImmenseTermProcessor}
import org.thp.scalligraph.models.{DefineIndex, Entity, IndexType, UMapping}
import org.thp.scalligraph.utils.Hasher
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}

import java.util.Date

@BuildEdgeEntity[Observable, KeyValue]
case class ObservableKeyValue()

@BuildEdgeEntity[Observable, Attachment]
case class ObservableAttachment()

@BuildEdgeEntity[Observable, Data]
case class ObservableData()

@BuildEdgeEntity[Observable, Tag]
case class ObservableTag()

@DefineIndex(IndexType.fulltextOnly, "message")
@DefineIndex(IndexType.standard, "tlp")
@DefineIndex(IndexType.standard, "ioc")
@DefineIndex(IndexType.standard, "sighted")
@DefineIndex(IndexType.standard, "ignoreSimilarity")
@DefineIndex(IndexType.standard, "dataType")
@DefineIndex(IndexType.standard, "tags")
@DefineIndex(IndexType.standard, "data")
@DefineIndex(IndexType.standard, "attachmentId")
@DefineIndex(IndexType.standard, "relatedId")
@DefineIndex(IndexType.standard, "organisationIds")
@BuildVertexEntity
case class Observable(
    message: Option[String],
    tlp: Int,
    ioc: Boolean,
    sighted: Boolean,
    ignoreSimilarity: Option[Boolean],
    dataType: String,
    tags: Seq[String],
    /* filled by the service */
    data: Option[String] = None,
    attachmentId: Option[String] = None,
    relatedId: EntityId = EntityId.empty,
    organisationIds: Set[EntityId] = Set.empty
)

case class RichObservable(
    observable: Observable with Entity,
    fullData: Option[Data with Entity],
    attachment: Option[Attachment with Entity],
    seen: Option[Boolean],
    reportTags: Seq[ReportTag with Entity]
) {
  def _id: EntityId                                            = observable._id
  def _createdBy: String                                       = observable._createdBy
  def _updatedBy: Option[String]                               = observable._updatedBy
  def _createdAt: Date                                         = observable._createdAt
  def _updatedAt: Option[Date]                                 = observable._updatedAt
  def message: Option[String]                                  = observable.message
  def tlp: Int                                                 = observable.tlp
  def ioc: Boolean                                             = observable.ioc
  def sighted: Boolean                                         = observable.sighted
  def ignoreSimilarity: Option[Boolean]                        = observable.ignoreSimilarity
  def dataOrAttachment: Either[String, Attachment with Entity] = data.toLeft(attachment.get)
  def dataType: String                                         = observable.dataType
  def data: Option[String]                                     = fullData.map(d => d.fullData.getOrElse(d.data)).orElse(observable.data)
  def tags: Seq[String]                                        = observable.tags
}

@DefineIndex(IndexType.unique, "data")
@BuildVertexEntity
case class Data(data: String, fullData: Option[String])

object UseHashToIndex extends ImmenseTermProcessor with ImmenseStringTermFilter {
  override val termSizeLimit: Int = 8191
  private val hasher: Hasher      = Hasher("SHA-256")

  def hashToIndex(value: String): Option[String] =
    if (value.length > termSizeLimit) Some("sha256/" + hasher.fromString(value).head.toString)
    else None

  override def apply[V](vertex: Vertex, property: VertexProperty[V]): Boolean = {
    if (property.key() == "data")
      vertex.label() match {
        case "Observable" =>
          collect(vertex, property).foreach { strProp =>
            val currentValue = strProp.value()
            logger.info(s"""Use hash for observable ~${vertex.id()}:
                           |  dataType=${UMapping.string.getProperty(vertex, "dataType")}
                           |  data=$currentValue
                           |  message=${UMapping.string.optional.getProperty(vertex, "message").getOrElse("<not set>")}
                           |  tags=${UMapping.string.sequence.getProperty(vertex, "message").mkString(", ")}""".stripMargin)
            strProp.remove()
            vertex.property(strProp.key(), "sha256/" + hasher.fromString(currentValue).head.toString)
          }

        case "Data" =>
          collect(vertex, property).foreach { strProp =>
            val currentValue = strProp.value()
            logger.info(s"Use hash and move data for $vertex/${strProp.key()}: $currentValue")
            strProp.remove()
            vertex.property(strProp.key(), hasher.fromString(currentValue).head.toString)
            vertex.property("fullData", currentValue)
          }

        case _ =>
      }
    false
  }
}

```

`thehive/app/org/thp/thehive/models/ObservableType.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.BuildVertexEntity
import org.thp.scalligraph.models.{DefineIndex, IndexType}

@BuildVertexEntity
@DefineIndex(IndexType.unique, "name")
case class ObservableType(name: String, isAttachment: Boolean)

object ObservableType {
  val initialValues: Seq[ObservableType] = Seq(
    ObservableType("url", isAttachment = false),
    ObservableType("other", isAttachment = false),
    ObservableType("user-agent", isAttachment = false),
    ObservableType("regexp", isAttachment = false),
    ObservableType("mail-subject", isAttachment = false),
    ObservableType("registry", isAttachment = false),
    ObservableType("mail", isAttachment = false),
    ObservableType("autonomous-system", isAttachment = false),
    ObservableType("domain", isAttachment = false),
    ObservableType("ip", isAttachment = false),
    ObservableType("uri_path", isAttachment = false),
    ObservableType("filename", isAttachment = false),
    ObservableType("hash", isAttachment = false),
    ObservableType("file", isAttachment = true),
    ObservableType("fqdn", isAttachment = false),
    ObservableType("hostname", isAttachment = false)
  )
}

```

`thehive/app/org/thp/thehive/models/Organisation.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.models.{DefineIndex, Entity, IndexType}
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}

import java.util.Date

@BuildVertexEntity
@DefineIndex(IndexType.unique, "name")
case class Organisation(name: String, description: String)

object Organisation {
  val administration: Organisation     = Organisation("admin", "organisation for administration")
  val initialValues: Seq[Organisation] = Seq(administration)
}

@BuildEdgeEntity[Organisation, Share]
case class OrganisationShare()

@BuildEdgeEntity[Organisation, Organisation]
case class OrganisationOrganisation()

@BuildEdgeEntity[Organisation, Taxonomy]
case class OrganisationTaxonomy()

case class RichOrganisation(organisation: Organisation with Entity, links: Seq[Organisation with Entity]) {
  def name: String               = organisation.name
  def description: String        = organisation.description
  def _id: EntityId              = organisation._id
  def _createdAt: Date           = organisation._createdAt
  def _createdBy: String         = organisation._createdBy
  def _updatedAt: Option[Date]   = organisation._updatedAt
  def _updatedBy: Option[String] = organisation._updatedBy
}

```

`thehive/app/org/thp/thehive/models/Page.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity}

@BuildEdgeEntity[Organisation, Page]
case class OrganisationPage()

@BuildVertexEntity
case class Page(title: String, content: String, slug: String, order: Int, category: String)

```

`thehive/app/org/thp/thehive/models/Pattern.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}

import java.util.Date

@BuildVertexEntity
case class Pattern(
    patternId: String,
    name: String,
    description: Option[String],
    tactics: Set[String],
    url: String,
    patternType: String,
    capecId: Option[String],
    capecUrl: Option[String],
    revoked: Boolean,
    dataSources: Seq[String],
    defenseBypassed: Seq[String],
    detection: Option[String],
    permissionsRequired: Seq[String],
    platforms: Seq[String],
    remoteSupport: Boolean,
    systemRequirements: Seq[String],
    revision: Option[String]
)

@BuildEdgeEntity[Pattern, Pattern]
case class PatternPattern()

case class RichPattern(pattern: Pattern with Entity, parent: Option[Pattern with Entity]) {
  def patternId: String                = pattern.patternId
  def name: String                     = pattern.name
  def description: Option[String]      = pattern.description
  def tactics: Set[String]             = pattern.tactics
  def url: String                      = pattern.url
  def patternType: String              = pattern.patternType
  def capecId: Option[String]          = pattern.capecId
  def capecUrl: Option[String]         = pattern.capecUrl
  def revoked: Boolean                 = pattern.revoked
  def dataSources: Seq[String]         = pattern.dataSources
  def defenseBypassed: Seq[String]     = pattern.defenseBypassed
  def detection: Option[String]        = pattern.detection
  def permissionsRequired: Seq[String] = pattern.permissionsRequired
  def platforms: Seq[String]           = pattern.platforms
  def remoteSupport: Boolean           = pattern.remoteSupport
  def systemRequirements: Seq[String]  = pattern.systemRequirements
  def version: Option[String]          = pattern.revision
  def _id: EntityId                    = pattern._id
  def _createdAt: Date                 = pattern._createdAt
  def _createdBy: String               = pattern._createdBy
  def _updatedAt: Option[Date]         = pattern._updatedAt
  def _updatedBy: Option[String]       = pattern._updatedBy
}

```

`thehive/app/org/thp/thehive/models/Permissions.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.auth.{Permission, PermissionDesc, Permissions => Perms}

object Permissions extends Perms {
  lazy val accessTheHiveFS: PermissionDesc          = PermissionDesc("accessTheHiveFS", "Access to TheHiveFS", "organisation")
  lazy val manageAction: PermissionDesc             = PermissionDesc("manageAction", "Run Cortex responders ", "organisation")
  lazy val manageAlert: PermissionDesc              = PermissionDesc("manageAlert", "Manage alerts", "organisation")
  lazy val manageAnalyse: PermissionDesc            = PermissionDesc("manageAnalyse", "Run Cortex analyzer", "organisation")
  lazy val manageAnalyzerTemplate: PermissionDesc   = PermissionDesc("manageAnalyzerTemplate", "Manage analyzer templates", "admin")
  lazy val manageCase: PermissionDesc               = PermissionDesc("manageCase", "Manage cases", "organisation")
  lazy val manageCaseTemplate: PermissionDesc       = PermissionDesc("manageCaseTemplate", "Manage case templates", "organisation")
  lazy val manageConfig: PermissionDesc             = PermissionDesc("manageConfig", "Manage configurations", "organisation", "admin")
  lazy val manageCustomField: PermissionDesc        = PermissionDesc("manageCustomField", "Manage custom fields", "admin")
  lazy val manageObservable: PermissionDesc         = PermissionDesc("manageObservable", "Manage observables", "organisation")
  lazy val manageObservableTemplate: PermissionDesc = PermissionDesc("manageObservableTemplate", "Manage observable types", "admin")
  lazy val manageOrganisation: PermissionDesc       = PermissionDesc("manageOrganisation", "Manage organisations", "admin")
  lazy val managePage: PermissionDesc               = PermissionDesc("managePage", "Manage pages", "organisation")
  lazy val managePattern: PermissionDesc            = PermissionDesc("managePattern", "Manage patterns", "admin")
  lazy val manageProcedure: PermissionDesc          = PermissionDesc("manageProcedure", "Manage procedures", "organisation")
  lazy val manageProfile: PermissionDesc            = PermissionDesc("manageProfile", "Manage user profiles", "admin")
  lazy val manageShare: PermissionDesc              = PermissionDesc("manageShare", "Manage shares", "organisation")
  lazy val manageTag: PermissionDesc                = PermissionDesc("manageTag", "Manage tags", "organisation")
  lazy val manageTaxonomy: PermissionDesc           = PermissionDesc("manageTaxonomy", "Manage taxonomies", "admin")
  lazy val manageTask: PermissionDesc               = PermissionDesc("manageTask", "Manage tasks", "organisation")
  lazy val manageUser: PermissionDesc               = PermissionDesc("manageUser", "Manage users", "organisation", "admin")
  lazy val managePlatform: PermissionDesc           = PermissionDesc("managePlatform", "Manage TheHive platform", "admin")

  lazy val list: Set[PermissionDesc] =
    Set(
      accessTheHiveFS,
      manageAction,
      manageAlert,
      manageAnalyse,
      manageAnalyzerTemplate,
      manageCase,
      manageCaseTemplate,
      manageConfig,
      manageCustomField,
      manageObservable,
      manageObservableTemplate,
      manageOrganisation,
      managePage,
      managePattern,
      managePlatform,
      manageProcedure,
      manageProfile,
      manageShare,
      manageTag,
      manageTask,
      manageTaxonomy,
      manageUser
    )

  // These permissions are available only if the user is in admin organisation, they are removed for other organisations
  lazy val restrictedPermissions: Set[Permission]               = list.filter(_.scope == Seq("admin")).map(_.permission)
  def containsRestricted(permissions: Set[Permission]): Boolean = permissions.intersect(Permissions.restrictedPermissions).nonEmpty

  // This is the initial admin permissions
  lazy val adminPermissions: Set[Permission] = forScope("admin")
  override val defaultScopes: Seq[String]    = Seq("organisation")
}

```

`thehive/app/org/thp/thehive/models/Procedure.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}

import java.util.Date

@BuildVertexEntity
case class Procedure(
    description: Option[String],
    occurDate: Date,
    tactic: String
    // metadata
)

@BuildEdgeEntity[Procedure, Pattern]
case class ProcedurePattern()

case class RichProcedure(procedure: Procedure with Entity, pattern: Pattern with Entity) {
  def description: Option[String] = procedure.description
  def occurDate: Date             = procedure.occurDate
  def tactic: String              = procedure.tactic
  def _id: EntityId               = procedure._id
  def _createdAt: Date            = procedure._createdAt
  def _createdBy: String          = procedure._createdBy
  def _updatedAt: Option[Date]    = procedure._updatedAt
  def _updatedBy: Option[String]  = procedure._updatedBy

}

```

`thehive/app/org/thp/thehive/models/ReportTag.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity}
import play.api.libs.json.JsValue

object ReportTagLevel extends Enumeration {
  val info, safe, suspicious, malicious = Value
}

@BuildEdgeEntity[Observable, ReportTag]
case class ObservableReportTag()

@BuildVertexEntity
case class ReportTag(origin: String, level: ReportTagLevel.Value, namespace: String, predicate: String, value: JsValue)

```

`thehive/app/org/thp/thehive/models/Role.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.auth.Permission
import org.thp.scalligraph.models.{DefineIndex, IndexType}
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity}

@BuildVertexEntity
case class Role()

@DefineIndex(IndexType.unique, "name")
@BuildVertexEntity
case class Profile(name: String, permissions: Set[Permission]) {
  def isEditable: Boolean = name != Profile.admin.name && name != Profile.orgAdmin.name
}

object Profile {
  val admin: Profile = Profile("admin", Permissions.adminPermissions)

  val analyst: Profile = Profile(
    "analyst",
    Set(
      Permissions.manageCase,
      Permissions.manageObservable,
      Permissions.manageAlert,
      Permissions.manageTask,
      Permissions.manageAction,
      Permissions.manageShare,
      Permissions.manageAnalyse,
      Permissions.managePage,
      Permissions.accessTheHiveFS,
      Permissions.manageProcedure
    )
  )
  val readonly: Profile           = Profile("read-only", Set.empty)
  val orgAdmin: Profile           = Profile("org-admin", Permissions.forScope("organisation"))
  val initialValues: Seq[Profile] = Seq(admin, orgAdmin, analyst, readonly)
}

@BuildEdgeEntity[Role, Profile]
case class RoleProfile()

@BuildEdgeEntity[Role, Organisation]
case class RoleOrganisation()

```

`thehive/app/org/thp/thehive/models/Share.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}

import java.util.Date

@BuildVertexEntity
case class Share(owner: Boolean)

@BuildEdgeEntity[Share, Case]
case class ShareCase()

@BuildEdgeEntity[Share, Observable]
case class ShareObservable()

@BuildEdgeEntity[Share, Task]
case class ShareTask(actionRequired: Boolean = false)

@BuildEdgeEntity[Share, Profile]
case class ShareProfile()

case class RichShare(share: Share with Entity, caseId: EntityId, organisationName: String, profileName: String) {
  def _id: EntityId              = share._id
  def _createdBy: String         = share._createdBy
  def _updatedBy: Option[String] = share._updatedBy
  def _createdAt: Date           = share._createdAt
  def _updatedAt: Option[Date]   = share._updatedAt
  def owner: Boolean             = share.owner
}

```

`thehive/app/org/thp/thehive/models/Tag.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.BuildVertexEntity
import org.thp.scalligraph.models.{DefineIndex, IndexType}

@DefineIndex(IndexType.unique, "namespace", "predicate", "value")
@DefineIndex(IndexType.fulltext, "namespace", "predicate", "value")
@DefineIndex(IndexType.standard, "colour")
@DefineIndex(IndexType.fulltextOnly, "description")
@BuildVertexEntity
case class Tag(
    namespace: String,
    predicate: String,
    value: Option[String],
    description: Option[String],
    colour: String
) {
  override def hashCode(): Int = 31 * (31 * value.## + predicate.##) + namespace.##

  override def equals(obj: Any): Boolean =
    obj match {
      case Tag(n, p, v, _, _) => n == namespace && p == predicate && v == value
      case _                  => false
    }

  lazy val isFreeTag: Boolean = namespace.startsWith("_freetags_")

  override def canEqual(that: Any): Boolean = that.isInstanceOf[Tag]

  override def toString: String =
    (if (namespace.headOption.getOrElse('_') == '_') "" else namespace + ':') +
      (if (predicate.headOption.getOrElse('_') == '_') "" else predicate) +
      value.fold("")(v => f"""="$v"""") // #$colour%06X
}

```

`thehive/app/org/thp/thehive/models/Task.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph._
import org.thp.scalligraph.models.{DefineIndex, Entity, IndexType}
import play.api.libs.json.{Format, Json}

import java.util.Date

object TaskStatus extends Enumeration {
  val Waiting, InProgress, Completed, Cancel = Value

  implicit val format: Format[Value] = Json.formatEnum(TaskStatus)
}

@BuildEdgeEntity[Task, User]
case class TaskUser()

@BuildEdgeEntity[Task, Log]
case class TaskLog()

@BuildVertexEntity
@DefineIndex(IndexType.fulltext, "title")
@DefineIndex(IndexType.standard, "group")
@DefineIndex(IndexType.fulltextOnly, "description")
@DefineIndex(IndexType.standard, "status")
@DefineIndex(IndexType.standard, "flag")
@DefineIndex(IndexType.standard, "startDate")
@DefineIndex(IndexType.standard, "endDate")
@DefineIndex(IndexType.standard, "order")
@DefineIndex(IndexType.standard, "dueDate")
@DefineIndex(IndexType.standard, "assignee")
@DefineIndex(IndexType.standard, "organisationIds")
case class Task(
    title: String,
    group: String,
    description: Option[String],
    status: TaskStatus.Value,
    flag: Boolean,
    startDate: Option[Date],
    endDate: Option[Date],
    order: Int,
    dueDate: Option[Date],
    /* filled by the service */
    assignee: Option[String],
    relatedId: EntityId = EntityId.empty,
    organisationIds: Set[EntityId] = Set.empty
)

case class RichTask(
    task: Task with Entity
) {
  def _id: EntityId               = task._id
  def _createdBy: String          = task._createdBy
  def _updatedBy: Option[String]  = task._updatedBy
  def _createdAt: Date            = task._createdAt
  def _updatedAt: Option[Date]    = task._updatedAt
  def title: String               = task.title
  def group: String               = task.group
  def description: Option[String] = task.description
  def status: TaskStatus.Value    = task.status
  def flag: Boolean               = task.flag
  def startDate: Option[Date]     = task.startDate
  def endDate: Option[Date]       = task.endDate
  def order: Int                  = task.order
  def dueDate: Option[Date]       = task.dueDate
  def assignee: Option[String]    = task.assignee
}

```

`thehive/app/org/thp/thehive/models/Taxonomy.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}

import java.util.Date

@BuildVertexEntity
case class Taxonomy(
    namespace: String,
    description: String,
    version: Int
)

@BuildEdgeEntity[Taxonomy, Tag]
case class TaxonomyTag()

case class RichTaxonomy(
    taxonomy: Taxonomy with Entity,
    tags: Seq[Tag with Entity]
) {
  def _id: EntityId              = taxonomy._id
  def _createdBy: String         = taxonomy._createdBy
  def _updatedBy: Option[String] = taxonomy._updatedBy
  def _createdAt: Date           = taxonomy._createdAt
  def _updatedAt: Option[Date]   = taxonomy._updatedAt
  def namespace: String          = taxonomy.namespace
  def description: String        = taxonomy.description
  def version: Int               = taxonomy.version
}

```

`thehive/app/org/thp/thehive/models/TheHiveSchemaDefinition.scala`:

```scala
package org.thp.thehive.models

import org.apache.tinkerpop.gremlin.process.traversal.{Order, P, TextP}
import org.apache.tinkerpop.gremlin.structure.VertexProperty.Cardinality
import org.janusgraph.core.schema.ConsistencyModifier
import org.janusgraph.graphdb.types.TypeDefinitionCategory
import org.reflections.Reflections
import org.reflections.scanners.SubTypesScanner
import org.reflections.util.ConfigurationBuilder
import org.thp.scalligraph.EntityId
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.janus.JanusDatabase
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.services.LocalUserSrv
import play.api.Logger

import java.lang.reflect.Modifier
import java.util.Date
import javax.inject.{Inject, Singleton}
import scala.collection.JavaConverters._
import scala.reflect.runtime.{universe => ru}
import scala.util.{Success, Try}

@Singleton
class TheHiveSchemaDefinition @Inject() extends Schema with UpdatableSchema {

  // Make sure TypeDefinitionCategory has been initialised before ModifierType to prevent ExceptionInInitializerError
  TypeDefinitionCategory.BACKING_INDEX
  lazy val logger: Logger = Logger(getClass)
  val operations: Operations = Operations("thehive")
    .addProperty[Option[Boolean]]("Observable", "seen")
    .updateGraph("Add manageConfig permission to org-admin profile", "Profile") { traversal =>
      traversal.unsafeHas("name", "org-admin").raw.property("permissions", "manageConfig").iterate()
      Success(())
    }
    .updateGraph("Remove duplicate custom fields", "CustomField") { traversal =>
      traversal.toIterator.foldLeft(Set.empty[String]) { (names, vertex) =>
        val name = vertex.value[String]("name")
        if (names.contains(name)) {
          vertex.remove()
          names
        } else
          names + name
      }
      Success(())
    }
    .noop // .addIndex("CustomField", IndexType.unique, "name")
    .dbOperation[JanusDatabase]("Remove locks") { db =>
      def removePropertyLock(name: String) =
        db.managementTransaction { mgmt =>
          Try(mgmt.setConsistency(mgmt.getPropertyKey(name), ConsistencyModifier.DEFAULT))
            .recover {
              case error => logger.warn(s"Unable to remove lock on property $name: $error")
            }
        }
      // removeIndexLock("CaseNumber")
      removePropertyLock("number")
      // removeIndexLock("DataData")
      removePropertyLock("data")
    }
    .noop // .addIndex("Tag", IndexType.unique, "namespace", "predicate", "value")
    .noop // .addIndex("Audit", IndexType.basic, "requestId", "mainAction")
    .noop // .reindexData
    //=====[release 4.0.0]=====
    .updateGraph("Remove cases with a Deleted status", "Case") { traversal =>
      traversal.unsafeHas("status", "Deleted").remove()
      Success(())
    }
    .addProperty[Option[Boolean]]("Observable", "ignoreSimilarity")
    //=====[release 4.0.1]=====
    .updateGraph("Add accessTheHiveFS permission to analyst and org-admin profiles", "Profile") { traversal =>
      traversal
        .unsafeHas("name", P.within("org-admin", "analyst"))
        .onRaw(_.property(Cardinality.set: Cardinality, "permissions", "accessTheHiveFS", Nil: _*)) // Nil is for disambiguate the overloaded methods
        .iterate()
      Success(())
    }
    //=====[release 4.0.2]=====
    .addProperty[Boolean]("ShareTask", "actionRequired")
    .updateGraph("Add actionRequire property", "Share") { traversal =>
      traversal.outE[ShareTask].raw.property("actionRequired", false).iterate()
      Success(())
    }
    //=====[release 4.0.3]=====
    //=====[release 4.0.4]=====
    //=====[release 4.0.5]=====
    // Taxonomies
    .addVertexModel[String]("Taxonomy")
    .addProperty[String]("Taxonomy", "namespace")
    .addProperty[String]("Taxonomy", "description")
    .addProperty[Int]("Taxonomy", "version")
    .dbOperation[Database]("Add Custom taxonomy vertex for each Organisation") { db =>
      db.tryTransaction { implicit graph =>
        // For each organisation, if there is no custom taxonomy, create it
        graph.V("Organisation").unsafeHas("name", P.neq("admin")).foreach { o =>
          val hasFreetagsTaxonomy = graph
            .V("Organisation", EntityId(o.id))
            .out[OrganisationTaxonomy]
            .v[Taxonomy]
            .unsafeHas("namespace", s"_freetags_${o.id()}")
            .exists
          if (!hasFreetagsTaxonomy) {
            val taxoVertex = graph.addVertex("Taxonomy")
            taxoVertex.property("_label", "Taxonomy")
            taxoVertex.property("_createdBy", "system@thehive.local")
            taxoVertex.property("_createdAt", new Date())
            taxoVertex.property("namespace", s"_freetags_${o.id()}")
            taxoVertex.property("description", "Custom taxonomy")
            taxoVertex.property("version", 1)
            o.addEdge("OrganisationTaxonomy", taxoVertex)
          }
        }
        Success(())
      }
    }
    .updateGraph("Add each tag to its Organisation's FreeTags taxonomy", "Tag") { tags =>
      tags
        .unsafeHas("namespace", TextP.notStartingWith("_freetags_"))
        .project(
          _.by
            .by(
              _.unionFlat(
                _.in("CaseTag").in("ShareCase").in("OrganisationShare"),
                _.in("ObservableTag").unionFlat(_.in("ShareObservable").in("OrganisationShare"), _.in("AlertObservable").out("AlertOrganisation")),
                _.in("AlertTag").out("AlertOrganisation"),
                _.in("CaseTemplateTag").out("CaseTemplateOrganisation")
              )
                .dedup
                .sort(_.by("_createdAt", Order.desc))
                .limit(1)
                .out("OrganisationTaxonomy")
                .unsafeHas("namespace", TextP.startingWith("_freetags_"))
                .option
            )
        )
        .foreach {
          case (tag, Some(freetagsTaxo)) =>
            val tagStr = tagString(
              tag.property[String]("namespace").value(),
              tag.property[String]("predicate").value(),
              tag.property[String]("value").orElse("")
            )
            tag.property("namespace", freetagsTaxo.property[String]("namespace").value)
            tag.property("predicate", tagStr)
            tag.property("value").remove()
            freetagsTaxo.addEdge("TaxonomyTag", tag)
          case (tag, None) =>
            val tagStr = tagString(
              tag.property[String]("namespace").value(),
              tag.property[String]("predicate").value(),
              tag.property[String]("value").orElse("")
            )
            logger.warn(s"Tag $tagStr is not linked to any organisation")
        }
      Success(())
    }
    .updateGraph("Add manageTaxonomy to admin profile", "Profile") { traversal =>
      traversal.unsafeHas("name", "admin").raw.property("permissions", "manageTaxonomy").iterate()
      Success(())
    }
    .updateGraph("Remove colour property for Tags", "Tag") { traversal =>
      traversal.removeProperty("colour").iterate()
      Success(())
    }
    .removeProperty[Int]("Tag", "colour", usedOnlyByThisModel = true)
    .addProperty[String]("Tag", "colour")
    .updateGraph("Add property colour for Tags ", "Tag") { traversal =>
      traversal.raw.property("colour", "#000000").iterate()
      Success(())
    }
    // Patterns
    .updateGraph("Add managePattern permission to admin profile", "Profile") { traversal =>
      traversal.unsafeHas("name", "admin").raw.property("permissions", "managePattern").iterate()
      Success(())
    }
    .noop
//    .updateGraph("Add manageProcedure permission to org-admin and analyst profiles", "Profile") { traversal =>
//      traversal
//        .unsafeHas("name", P.within("org-admin", "analyst"))
//        .raw
//        .property("permissions", "manageProcedure")
//        .iterate()
//      Success(())
//    }
    // Index backend
    /* Alert index  */
    .addProperty[Seq[String]]("Alert", "tags")
    .addProperty[EntityId]("Alert", "organisationId")
    .addProperty[Option[EntityId]]("Alert", "caseId")
    .updateGraph("Add tags, organisationId and caseId in alerts", "Alert") { traversal =>
      traversal
        .unsafeHasNot("organisationId")
        .project(
          _.by
            .by(_.out("AlertTag").valueMap("namespace", "predicate", "value").fold)
            .by(_.out("AlertOrganisation")._id.option)
            .by(_.out("AlertCase")._id.option)
        )
        .foreach {
          case (vertex, tagMaps, Some(organisationId), caseId) =>
            val tags = for {
              tag <- tagMaps.asInstanceOf[Seq[Map[String, String]]]
              namespace = tag.getOrElse("namespace", "_autocreate")
              predicate <- tag.get("predicate")
              value = tag.get("value")
            } yield
              (if (namespace.headOption.getOrElse('_') == '_') "" else namespace + ':') +
                (if (predicate.headOption.getOrElse('_') == '_') "" else predicate) +
                value.fold("")(v => f"""="$v"""")

            tags.foreach(vertex.property(Cardinality.list, "tags", _))
            vertex.property("organisationId", organisationId.value)
            caseId.foreach(cid => vertex.property("caseId", cid.value))
          case _ =>
        }
      Success(())
    }
    /* Case index  */
    .addProperty[Seq[String]]("Case", "tags")
    .addProperty[Option[String]]("Case", "assignee")
    .addProperty[Set[EntityId]]("Case", "organisationIds")
    .addProperty[Option[String]]("Case", "impactStatus")
    .addProperty[Option[String]]("Case", "resolutionStatus")
    .addProperty[Option[String]]("Case", "caseTemplate")
    .updateGraph("Add tags, assignee, organisationIds, impactStatus, resolutionStatus and caseTemplate data in cases", "Case") { traversal =>
      traversal
        .project(
          _.by
            .by(_.out("CaseTag").valueMap("namespace", "predicate", "value").fold)
            .by(_.out("CaseUser").property("login", UMapping.string).option)
            .by(_.in("ShareCase").in("OrganisationShare")._id.fold)
            .by(_.out("CaseImpactStatus").property("value", UMapping.string).option)
            .by(_.out("CaseResolutionStatus").property("value", UMapping.string).option)
            .by(_.out("CaseCaseTemplate").property("name", UMapping.string).option)
        )
        .foreach {
          case (vertex, tagMaps, assignee, organisationIds, impactStatus, resolutionStatus, caseTemplate) =>
            val tags = for {
              tag <- tagMaps.asInstanceOf[Seq[Map[String, String]]]
              namespace = tag.getOrElse("namespace", "_autocreate")
              predicate <- tag.get("predicate")
              value = tag.get("value")
            } yield
              (if (namespace.headOption.getOrElse('_') == '_') "" else namespace + ':') +
                (if (predicate.headOption.getOrElse('_') == '_') "" else predicate) +
                value.fold("")(v => f"""="$v"""")

            tags.foreach(vertex.property(Cardinality.list, "tags", _))
            assignee.foreach(vertex.property("assignee", _))
            organisationIds.foreach(id => vertex.property(Cardinality.set, "organisationIds", id.value))
            impactStatus.foreach(vertex.property("impactStatus", _))
            resolutionStatus.foreach(vertex.property("resolutionStatus", _))
            caseTemplate.foreach(vertex.property("caseTemplate", _))
        }
      Success(())
    }
    /* CaseTemplate index  */
    .addProperty[Seq[String]]("CaseTemplate", "tags")
    .updateGraph("Add tags in caseTemplates", "CaseTemplate") { traversal =>
      traversal
        .project(
          _.by
            .by(_.out("CaseTemplateTag").valueMap("namespace", "predicate", "value").fold)
        )
        .foreach {
          case (vertex, tagMaps) =>
            val tags = for {
              tag <- tagMaps.asInstanceOf[Seq[Map[String, String]]]
              namespace = tag.getOrElse("namespace", "_autocreate")
              predicate <- tag.get("predicate")
              value = tag.get("value")
            } yield
              (if (namespace.headOption.getOrElse('_') == '_') "" else namespace + ':') +
                (if (predicate.headOption.getOrElse('_') == '_') "" else predicate) +
                value.fold("")(v => f"""="$v"""")

            tags.foreach(vertex.property(Cardinality.list, "tags", _))
        }
      Success(())
    }
    /* Log index */
    .addProperty[String]("Log", "taskId")
    .addProperty[Set[EntityId]]("Log", "organisationIds")
    .updateGraph("Add taskId and organisationIds data in logs", "Log") { traversal =>
      traversal
        .unsafeHasNot("organisationIds")
        .project(
          _.by
            .by(_.in("TaskLog")._id.option)
            .by(_.in("TaskLog").in("ShareTask").in("OrganisationShare")._id.fold)
        )
        .foreach {
          case (vertex, taskId, organisationIds) =>
            taskId.foreach(tid => vertex.property("taskId", tid.value))
            organisationIds.foreach(id => vertex.property(Cardinality.set, "organisationIds", id.value))
        }
      Success(())
    }
    /* Observable index */
    .addProperty[String]("Observable", "dataType")
    .addProperty[Seq[String]]("Observable", "tags")
    .addProperty[String]("Observable", "data")
    .addProperty[EntityId]("Observable", "relatedId")
    .addProperty[Set[EntityId]]("Observable", "organisationIds")
    .updateGraph("Add dataType, tags, data, relatedId and organisationIds data in observables", "Observable") { traversal =>
      traversal
        .unsafeHasNot("organisationIds")
        .project(
          _.by
            .by(_.out("ObservableObservableType").property("name", UMapping.string).option)
            .by(_.out("ObservableTag").valueMap("namespace", "predicate", "value").fold)
            .by(_.out("ObservableData").property("data", UMapping.string).option)
            .by(_.out("ObservableAttachment").property("attachmentId", UMapping.string).option)
            .by(_.coalesceIdent(_.in("ShareObservable").out("ShareCase"), _.in("AlertObservable"), _.in("ReportObservable"))._id.option)
            .by(
              _.coalesceIdent(
                _.optional(_.in("ReportObservable").in("ObservableJob")).in("ShareObservable").in("OrganisationShare"),
                _.in("AlertObservable").out("AlertOrganisation")
              )
                ._id
                .fold
            )
        )
        .foreach {
          case (vertex, dataType, tagMaps, data, attachmentId, Some(relatedId), organisationIds) =>
            val tags = for {
              tag <- tagMaps.asInstanceOf[Seq[Map[String, String]]]
              namespace = tag.getOrElse("namespace", "_autocreate")
              predicate <- tag.get("predicate")
              value = tag.get("value")
            } yield
              (if (namespace.headOption.getOrElse('_') == '_') "" else namespace + ':') +
                (if (predicate.headOption.getOrElse('_') == '_') "" else predicate) +
                value.fold("")(v => f"""="$v"""")

            dataType.foreach(vertex.property("dataType", _))
            tags.foreach(vertex.property(Cardinality.list, "tags", _))
            data.foreach(vertex.property("data", _))
            attachmentId.foreach(vertex.property("attachmentId", _))
            vertex.property("relatedId", relatedId.value)
            organisationIds.foreach(id => vertex.property(Cardinality.set, "organisationIds", id.value))
          case _ =>
        }
      Success(())
    }
    /* Task index */
    .addProperty[Option[String]]("Task", "assignee")
    .addProperty[Set[EntityId]]("Task", "organisationIds")
    .addProperty[EntityId]("Task", "relatedId")
    .updateGraph("Add assignee, relatedId and organisationIds data in tasks", "Task") { traversal =>
      traversal
        .unsafeHasNot("organisationIds")
        .project(
          _.by
            .by(_.out("TaskUser").property("login", UMapping.string).option)
            .by(_.coalesceIdent(_.in("ShareTask").out("ShareCase"), _.in("CaseTemplateTask"))._id.option)
            .by(_.coalesceIdent(_.in("ShareTask").in("OrganisationShare"), _.in("CaseTemplateTask").out("CaseTemplateOrganisation"))._id.fold)
        )
        .foreach {
          case (vertex, assignee, Some(relatedId), organisationIds) =>
            assignee.foreach(vertex.property("assignee", _))
            vertex.property("relatedId", relatedId.value)
            organisationIds.foreach(id => vertex.property(Cardinality.set, "organisationIds", id.value))
          case _ =>
        }
      Success(())
    }
    .updateGraph("Add managePlatform permission to admin profile", "Profile") { traversal =>
      traversal.unsafeHas("name", "admin").raw.property("permissions", "managePlatform").iterate()
      Success(())
    }
    .updateGraph("Remove manageTag permission to admin profile", "Profile") { traversal =>
      traversal.unsafeHas("name", "admin").raw.properties[String]("permissions").forEachRemaining(p => if (p.value() == "manageTag") p.remove())
      Success(())
    }
    .updateGraph("Add manageTag permission to org-admin profile", "Profile") { traversal =>
      traversal.unsafeHas("name", "org-admin").raw.property("permissions", "manageTag").iterate()
      Success(())
    }
    .updateGraph("Remove deleted logs and deleted property from logs", "Log") { traversal =>
      traversal.clone().unsafeHas("deleted", "true").remove()
      traversal.removeProperty("deleted")
      Success(())
    }
    .removeProperty[Boolean](model = "Log", propertyName = "deleted", usedOnlyByThisModel = true)
    .updateGraph("Make shared dashboard writable", "Dashboard") { traversal =>
      traversal.outE("OrganisationDashboard").raw.property("writable", true).iterate()
      Success(())
    }
    //=====[release 4.1.0]=====
    .removeIndex("Alert", IndexType.fulltext, "description")
    .removeIndex("Case", IndexType.fulltext, "description", "summary")
    .removeIndex("Log", IndexType.fulltext, "message")
    .removeIndex("Observable", IndexType.fulltext, "message")
    .removeIndex("Log", IndexType.fulltext, "message")
    .removeIndex("Tag", IndexType.fulltext, "description")
    .removeIndex("Task", IndexType.fulltext, "description")
//    .updateGraph("Set caseId in imported alerts", "Alert") { traversal =>
//      traversal
//        .project(
//          _.by
//            .by(_.out("AlertCase")._id.option)
//        )
//        .foreach {
//          case (vertex, caseId) =>
//            caseId.foreach(cid => vertex.property("caseId", cid.value))
//        }
//      Success(())
//    }
    .noop
    //=====[release 4.1.1]=====
//    .updateGraph("Set caseId in imported alerts", "Alert") { traversal =>
//      traversal
//        .project(
//          _.by
//            .by(_.out("AlertCase")._id.option)
//        )
//        .foreach {
//          case (vertex, caseId) =>
//            caseId.foreach(cid => vertex.property("caseId", cid.value))
//        }
//      Success(())
//    }
    .noop
    .updateGraph("Set taskId in logs", "Log") { traversal =>
      traversal
        .project(_.by.by(_.in("TaskLog")._id.option))
        .foreach {
          case (vertex, Some(taskId)) =>
            vertex.property("taskId", taskId.value)
          case _ =>
        }
      Success(())
    }
    //=====[release 4.1.2]=====
    .removeIndex("Audit", IndexType.basic, "requestId", "mainAction")
    .removeIndex("Alert", IndexType.unique, "type", "source", "sourceRef", "organisationId")
    .removeIndex("_label_vertex_index", IndexType.basic)
    .removeIndex("Case", IndexType.basic, "status")
    .removeIndex("Task", IndexType.basic, "status")
    .removeIndex("Alert", IndexType.basic, "type", "source", "sourceRef")
    .updateGraph("Set caseId in imported alerts", "Alert") { traversal =>
      traversal
        .project(
          _.by
            .by(_.out("AlertCase")._id.option)
        )
        .foreach {
          case (vertex, caseId) =>
            vertex.property("caseId", caseId.fold("")(_.value))
        }
      Success(())
    }
    .removeIndex("Alert", IndexType.standard)
    .removeIndex("Attachment", IndexType.standard)
    .removeIndex("Audit", IndexType.standard)
    .removeIndex("Case", IndexType.standard)
    .removeIndex("Log", IndexType.standard)
    .removeIndex("Observable", IndexType.standard)
    .removeIndex("Tag", IndexType.standard)
    .removeIndex("Task", IndexType.standard)
    //=====[release 4.1.3]=====
    .dbOperation[JanusDatabase]("Remove global index if ElasticSearch is used") { db =>
      db.managementTransaction(mgmt => Try(mgmt.get("index.search.backend"))).flatMap {
        case "elasticsearch" => db.removeIndex("global", IndexType.fulltext, Nil)
        case _               => Success(())
      }
    }
    .updateGraph("Add manageProcedure permission to org-admin and analyst profiles", "Profile") { traversal =>
      traversal
        .unsafeHas("name", P.within("org-admin", "analyst"))
        .raw
        .property("permissions", "manageProcedure")
        .iterate()
      Success(())
    }
    .removeIndex("Data", IndexType.unique, "data")
    //=====[release 4.1.4]=====
    .addProperty[EntityId]("Case", "owningOrganisation")
    .updateGraph("Add owning organisation in case", "Case") { traversal =>
      traversal
        .project(
          _.by
            .by(_.in("ShareCase").unsafeHas("owner", true).in("OrganisationShare")._id.option)
        )
        .foreach {
          case (vertex, owningOrganisation) =>
            owningOrganisation.foreach(id => vertex.property("owningOrganisation", id.value))
        }
      Success(())
    }
    //=====[release 4.1.15]=====
    .removeIndex("Tag", IndexType.unique, "namespace", "predicate", "value")
    .removeIndex("Alert", IndexType.unique, "type", "source", "sourceRef", "organisationId")
    .removeIndex("Organisation", IndexType.unique, "name")
    .removeIndex("Customfield", IndexType.unique, "name")
    .removeIndex("Profile", IndexType.unique, "name")
    .removeIndex("ImpactStatus", IndexType.unique, "value")
    .removeIndex("ObservableType", IndexType.unique, "name")
    .removeIndex("User", IndexType.unique, "login")
    .removeIndex("Case", IndexType.unique, "number")
    .removeIndex("ResolutionStatus", IndexType.unique, "value")

  val reflectionClasses = new Reflections(
    new ConfigurationBuilder()
      .forPackages("org.thp.thehive.models")
      .addClassLoader(getClass.getClassLoader)
      .setExpandSuperTypes(true)
      .setScanners(new SubTypesScanner(false))
  )

  override lazy val modelList: Seq[Model] = {
    val rm: ru.Mirror = ru.runtimeMirror(getClass.getClassLoader)
    reflectionClasses
      .getSubTypesOf(classOf[HasModel])
      .asScala
      .filterNot(c => Modifier.isAbstract(c.getModifiers))
      .map { modelClass =>
        val hasModel = rm.reflectModule(rm.classSymbol(modelClass).companion.companion.asModule).instance.asInstanceOf[HasModel]
        logger.debug(s"Loading model ${hasModel.model.label}")
        hasModel.model
      }
      .toSeq
  }

  private def tagString(namespace: String, predicate: String, value: String): String =
    (if (namespace.headOption.getOrElse('_') == '_') "" else namespace + ':') +
      (if (predicate.headOption.getOrElse('_') == '_') "" else predicate) +
      (if (value.isEmpty) "" else f"""="$value"""")

  override val authContext: AuthContext = LocalUserSrv.getSystemAuthContext
}

```

`thehive/app/org/thp/thehive/models/User.scala`:

```scala
package org.thp.thehive.models

import org.thp.scalligraph.auth.{Permission, User => ScalligraphUser}
import org.thp.scalligraph.models._
import org.thp.scalligraph.{BuildEdgeEntity, BuildVertexEntity, EntityId}
import org.thp.thehive.services.LocalPasswordAuthSrv

import java.util.Date

@BuildEdgeEntity[User, Role]
case class UserRole()

@BuildEdgeEntity[User, Attachment]
case class UserAttachment()

@DefineIndex(IndexType.unique, "login")
@BuildVertexEntity
case class User(
    login: String,
    name: String,
    apikey: Option[String],
    locked: Boolean,
    password: Option[String],
    totpSecret: Option[String],
    failedAttempts: Option[Int],
    lastFailed: Option[Date]
) extends ScalligraphUser {
  override val id: String          = login
  override def getUserName: String = name

  override def toString: String = s"User($login,$name,$locked)"
}

object User {
  val initPassword: String = "secret"

  val init: User = User(
    login = "admin@thehive.local",
    name = "Default admin user",
    apikey = None,
    locked = false,
    password = Some(LocalPasswordAuthSrv.hashPassword(initPassword)),
    totpSecret = None,
    failedAttempts = None,
    lastFailed = None
  )

  val system: User =
    User(
      login = "system@thehive.local",
      name = "TheHive system user",
      apikey = None,
      locked = false,
      password = None,
      totpSecret = None,
      failedAttempts = None,
      lastFailed = None
    )

  val initialValues: Seq[User] = Seq(init, system)
}

//    avatar: Array[Byte],
//    preference: JsObject)

case class RichUser(user: User with Entity, avatar: Option[String], profile: String, permissions: Set[Permission], organisation: String) {
  def _id: EntityId              = user._id
  def _createdBy: String         = user._createdBy
  def _updatedBy: Option[String] = user._updatedBy
  def _createdAt: Date           = user._createdAt
  def _updatedAt: Option[Date]   = user._updatedAt
  def login: String              = user.login
  def name: String               = user.name
  def hasPassword: Boolean       = user.password.isDefined
  def hasMFA: Boolean            = user.totpSecret.isDefined
  def apikey: Option[String]     = user.apikey
  def locked: Boolean            = user.locked
}

```

`thehive/app/org/thp/thehive/services/AlertSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.apache.tinkerpop.gremlin.process.traversal.P
import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.controllers.FFile
import org.thp.scalligraph.models._
import org.thp.scalligraph.query.PredicateOps.PredicateOpsDefs
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal._
import org.thp.scalligraph.utils.FunctionalCondition.When
import org.thp.scalligraph.{BadRequestError, CreateError, EntityId, EntityIdOrName, RichOptionTry, RichSeq}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputCustomFieldValue
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.CustomFieldOps._
import org.thp.thehive.services.ObservableOps._
import play.api.libs.json.{JsObject, JsValue, Json}

import java.lang.{Long => JLong}
import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class AlertSrv @Inject() (
    caseSrv: CaseSrv,
    tagSrv: TagSrv,
    organisationSrv: OrganisationSrv,
    customFieldSrv: CustomFieldSrv,
    caseTemplateSrv: CaseTemplateSrv,
    observableSrv: ObservableSrv,
    auditSrv: AuditSrv,
    attachmentSrv: AttachmentSrv,
    integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]]
) extends VertexSrv[Alert] {
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get
  val alertTagSrv                                                = new EdgeSrv[AlertTag, Alert, Tag]
  val alertCustomFieldSrv                                        = new EdgeSrv[AlertCustomField, Alert, CustomField]
  val alertOrganisationSrv                                       = new EdgeSrv[AlertOrganisation, Alert, Organisation]
  val alertCaseSrv                                               = new EdgeSrv[AlertCase, Alert, Case]
  val alertCaseTemplateSrv                                       = new EdgeSrv[AlertCaseTemplate, Alert, CaseTemplate]
  val alertObservableSrv                                         = new EdgeSrv[AlertObservable, Alert, Observable]

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[Alert] =
    name.split(';') match {
      case Array(tpe, source, sourceRef) => startTraversal.getBySourceId(tpe, source, sourceRef)
      case _                             => startTraversal.empty
    }

  def create(
      alert: Alert,
      organisation: Organisation with Entity,
      tagNames: Set[String],
      customFields: Seq[InputCustomFieldValue],
      caseTemplate: Option[CaseTemplate with Entity]
  )(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichAlert] =
    tagNames.toTry(tagSrv.getOrCreate).flatMap(create(alert, organisation, _, customFields, caseTemplate))

  private def create(
      alert: Alert,
      organisation: Organisation with Entity,
      tags: Seq[Tag with Entity],
      customFields: Seq[InputCustomFieldValue],
      caseTemplate: Option[CaseTemplate with Entity]
  )(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichAlert] = {
    val alertAlreadyExist = startTraversal.getBySourceId(alert.`type`, alert.source, alert.sourceRef).inOrganisation(organisation._id).exists
    if (alertAlreadyExist)
      Failure(CreateError(s"Alert ${alert.`type`}:${alert.source}:${alert.sourceRef} already exist in organisation ${organisation.name}"))
    else
      for {
        createdAlert <- createEntity(alert.copy(organisationId = organisation._id))
        _            <- alertOrganisationSrv.create(AlertOrganisation(), createdAlert, organisation)
        _            <- caseTemplate.map(ct => alertCaseTemplateSrv.create(AlertCaseTemplate(), createdAlert, ct)).flip
        _            <- tags.toTry(t => alertTagSrv.create(AlertTag(), createdAlert, t))
        cfs          <- customFields.toTry { cf: InputCustomFieldValue => createCustomField(createdAlert, cf) }
        richAlert = RichAlert(createdAlert, cfs, None, caseTemplate.map(_.name), 0)
        _ <- auditSrv.alert.create(createdAlert, richAlert.toJson)
      } yield richAlert
  }

  override def update(
      traversal: Traversal.V[Alert],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[Alert], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (alerts, updatedFields) =>
        alerts
          .clone()
          .getOrFail("Alert")
          .flatMap(auditSrv.alert.update(_, updatedFields))
    }

  def updateTags(alert: Alert with Entity, tags: Set[String])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[(Seq[Tag with Entity], Seq[Tag with Entity])] =
    for {
      tagsToAdd <- (tags -- alert.tags).toTry(tagSrv.getOrCreate)
      tagsToRemove = get(alert).tags.toSeq.filterNot(t => tags.contains(t.toString))
      _ <- tagsToAdd.toTry(alertTagSrv.create(AlertTag(), alert, _))
      _ = if (tagsToRemove.nonEmpty) get(alert).outE[AlertTag].filter(_.otherV.hasId(tagsToRemove.map(_._id): _*)).remove()
      _ <- get(alert)
        .update(_.tags, tags.toSeq)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("Alert")
      _ <- auditSrv.alert.update(alert, Json.obj("tags" -> tags))
    } yield (tagsToAdd, tagsToRemove)

  def addTags(alert: Alert with Entity, tags: Set[String])(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    updateTags(alert, tags ++ alert.tags).map(_ => ())

  def createObservable(alert: Alert with Entity, observable: Observable, data: String)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichObservable] =
    for {
      createdObservable <- observableSrv.create(observable.copy(organisationIds = Set(organisationSrv.currentId), relatedId = alert._id), data)
      _                 <- alertObservableSrv.create(AlertObservable(), alert, createdObservable.observable)
      _                 <- auditSrv.observableInAlert.create(createdObservable.observable, alert, createdObservable.toJson)
    } yield createdObservable

  def createObservable(alert: Alert with Entity, observable: Observable, attachment: Attachment with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichObservable] =
    for {
      createdObservable <- observableSrv.create(observable.copy(organisationIds = Set(organisationSrv.currentId), relatedId = alert._id), attachment)
      _                 <- alertObservableSrv.create(AlertObservable(), alert, createdObservable.observable)
      _                 <- auditSrv.observableInAlert.create(createdObservable.observable, alert, createdObservable.toJson)
    } yield createdObservable

  def createObservable(alert: Alert with Entity, observable: Observable, file: FFile)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichObservable] =
    attachmentSrv.create(file).flatMap(attachment => createObservable(alert, observable, attachment))

  def createCustomField(
      alert: Alert with Entity,
      inputCf: InputCustomFieldValue
  )(implicit graph: Graph, authContext: AuthContext): Try[RichCustomField] =
    for {
      cf   <- customFieldSrv.getOrFail(EntityIdOrName(inputCf.name))
      ccf  <- CustomFieldType.map(cf.`type`).setValue(AlertCustomField(), inputCf.value).map(_.order_=(inputCf.order))
      ccfe <- alertCustomFieldSrv.create(ccf, alert, cf)
    } yield RichCustomField(cf, ccfe)

  def setOrCreateCustomField(alert: Alert with Entity, cf: InputCustomFieldValue)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] = {
    val cfv = get(alert).customFields(EntityIdOrName(cf.name))
    if (cfv.clone().exists)
      cfv.setValue(cf.value)
    else
      createCustomField(alert, cf).map(_ => ())
  }

//  def getCustomField(alert: Alert with Entity, customFieldName: String)(implicit graph: Graph): Option[RichCustomField] =
//    get(alert).customFields(customFieldName).richCustomField.headOption

  def updateCustomField(
      alert: Alert with Entity,
      customFieldValues: Seq[(CustomField, Any)]
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val customFieldNames = customFieldValues.map(_._1.name)
    get(alert)
      .customFields
      .richCustomField
      .toIterator
      .filterNot(rcf => customFieldNames.contains(rcf.name))
      .foreach(rcf => get(alert).customFields(rcf.customField._id).remove())
    customFieldValues
      .toTry { case (cf, v) => setOrCreateCustomField(alert, InputCustomFieldValue(cf.name, Some(v), None)) }
      .map(_ => ())
  }

  def markAsUnread(alertId: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      alert <- get(alertId)
        .update[Boolean](_.read, false)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("Alert")
      _ <- auditSrv.alert.update(alert, Json.obj("read" -> false))
    } yield ()

  def markAsRead(alertId: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      alert <- get(alertId)
        .update[Boolean](_.read, true)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("Alert")
      _ <- auditSrv.alert.update(alert, Json.obj("read" -> true))
    } yield ()

  def followAlert(alertId: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      alert <- get(alertId)
        .update[Boolean](_.follow, true)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("Alert")
      _ <- auditSrv.alert.update(alert, Json.obj("follow" -> true))
    } yield ()

  def unfollowAlert(alertId: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      alert <- get(alertId)
        .update[Boolean](_.follow, false)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("Alert")
      _ <- auditSrv.alert.update(alert, Json.obj("follow" -> false))
    } yield ()

  def createCase(alert: RichAlert, assignee: Option[User with Entity], organisation: Organisation with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichCase] =
    auditSrv.mergeAudits {
      get(alert.alert).`case`.richCase.getOrFail("Case").orElse {
        for {
          caseTemplate <-
            alert
              .caseTemplate
              .map(ct => caseTemplateSrv.get(EntityIdOrName(ct)).visible.richCaseTemplate.getOrFail("CaseTemplate"))
              .flip
          customField = alert.customFields.map(f => InputCustomFieldValue(f.name, f.value, f.order))
          case0 = Case(
            title = caseTemplate.flatMap(_.titlePrefix).getOrElse("") + alert.title,
            description = alert.description,
            severity = alert.severity,
            startDate = new Date,
            endDate = None,
            flag = false,
            tlp = alert.tlp,
            pap = alert.pap,
            status = CaseStatus.Open,
            summary = None,
            alert.tags
          )

          createdCase <- caseSrv.create(case0, assignee, organisation, customField, caseTemplate, Nil)
          _           <- importObservables(alert.alert, createdCase.`case`)
          _           <- alertCaseSrv.create(AlertCase(), alert.alert, createdCase.`case`)
          _           <- get(alert.alert).update(_.caseId, createdCase._id).getOrFail("Alert")
          _           <- markAsRead(alert._id)
          _ = integrityCheckActor ! IntegrityCheck.EntityAdded("Alert")
        } yield createdCase
      }
    }(richCase => auditSrv.alert.createCase(alert.alert, richCase.`case`, richCase.toJson.as[JsObject]))

  def mergeInCase(alertId: EntityIdOrName, caseId: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Case with Entity] =
    for {
      alert       <- getOrFail(alertId)
      case0       <- caseSrv.getOrFail(caseId)
      updatedCase <- mergeInCase(alert, case0)
    } yield updatedCase

  def mergeInCase(alert: Alert with Entity, `case`: Case with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Case with Entity] =
    if (get(alert).isImported)
      Failure(BadRequestError("Alert is already imported"))
    else
      auditSrv
        .mergeAudits {
          // No audit for markAsRead and observables
          // Audits for customFields, description and tags
          val description = `case`.description + s"\n  \n#### Merged with alert #${alert.sourceRef} ${alert.title}\n\n${alert.description.trim}"
          for {
            _ <- markAsRead(alert._id)
            _ <- importObservables(alert, `case`)
            _ <- importCustomFields(alert, `case`)
            _ <- caseSrv.addTags(`case`, alert.tags.toSet)
            _ <- alertCaseSrv.create(AlertCase(), alert, `case`)
            _ <- get(alert).update(_.caseId, `case`._id).getOrFail("Alert")
            c <-
              caseSrv
                .get(`case`)
                .update(_.description, description)
                .update(_._updatedAt, Some(new Date))
                .update(_._updatedBy, Some(authContext.userId))
                .getOrFail("Case")
            details <- Success(
              Json.obj(
                "customFields" -> get(alert).richCustomFields.toSeq.map(_.toOutput.toJson),
                "description"  -> c.description,
                "tags"         -> (`case`.tags ++ alert.tags).distinct
              )
            )
          } yield details
        }(details => auditSrv.alert.mergeToCase(alert, `case`, details.as[JsObject]))
        .map(_ => integrityCheckActor ! IntegrityCheck.EntityAdded("Alert"))
        .flatMap(_ => caseSrv.getOrFail(`case`._id))

  def importObservables(alert: Alert with Entity, `case`: Case with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    get(alert)
      .observables
      .richObservable
      .toIterator
      .toTry { richObservable =>
        richObservable
          .dataOrAttachment
          .fold(
            data => caseSrv.createObservable(`case`, richObservable.observable, data),
            attachment => caseSrv.createObservable(`case`, richObservable.observable, attachment)
          )
          .recover {
            case _: CreateError => // if case already contains observable, update tags
              richObservable
                .dataOrAttachment
                .fold(
                  data => observableSrv.startTraversal.filterOnData(data),
                  attachment => observableSrv.startTraversal.filterOnAttachmentId(attachment.attachmentId)
                )
                .filterOnData(richObservable.dataType)
                .relatedTo(`case`._id)
                .inOrganisation(organisationSrv.currentId)
                .headOption
                .foreach { observable =>
                  val newTags = (observable.tags ++ richObservable.tags).toSet
                  observableSrv.updateTags(observable, newTags)
                }
          }
      }
      .map(_ => ())

  def importCustomFields(alert: Alert with Entity, `case`: Case with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    get(alert)
      .richCustomFields
      .toIterator
      .toTry { richCustomField =>
        caseSrv
          .setOrCreateCustomField(`case`, richCustomField.customField._id, richCustomField.value, richCustomField.customFieldValue.order)
      }
      .map(_ => ())

  def remove(alert: Alert with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    auditSrv.mergeAudits {
      get(alert).observables.toIterator.foreach(observableSrv.delete(_))
      Success(())
    } { _ =>
      for {
        organisation <- organisationSrv.getOrFail(authContext.organisation)
        _            <- auditSrv.alert.delete(alert, organisation)
      } yield get(alert).remove()
    }
}

object AlertOps {

  implicit class AlertOpsDefs(traversal: Traversal.V[Alert]) {
    def get(idOrSource: EntityIdOrName): Traversal.V[Alert] =
      idOrSource.fold(
        traversal.getByIds(_),
        _.split(';') match {
          case Array(tpe, source, sourceRef) => getBySourceId(tpe, source, sourceRef)
          case _                             => traversal.empty
        }
      )

    def getBySourceId(`type`: String, source: String, sourceRef: String): Traversal.V[Alert] =
      traversal
        .has(_.`type`, `type`)
        .has(_.source, source)
        .has(_.sourceRef, sourceRef)

    def inOrganisation(organisationId: EntityId): Traversal.V[Alert] =
      traversal.has(_.organisationId, organisationId)

    def filterByType(`type`: String): Traversal.V[Alert] = traversal.has(_.`type`, `type`)

    def filterBySource(source: String): Traversal.V[Alert] = traversal.has(_.source, source)

    def organisation: Traversal.V[Organisation] = traversal.out[AlertOrganisation].v[Organisation]

    def tags: Traversal.V[Tag] = traversal.out[AlertTag].v[Tag]

    def `case`: Traversal.V[Case] = traversal.out[AlertCase].v[Case]

    def visible(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Alert] =
      traversal.has(_.organisationId, organisationSrv.currentId(traversal.graph, authContext))

    def can(organisationSrv: OrganisationSrv, permission: Permission)(implicit authContext: AuthContext): Traversal.V[Alert] =
      if (authContext.permissions.contains(permission))
        traversal.visible(organisationSrv)
      else traversal.empty

    def imported: Traversal[Boolean, Boolean, IdentityConverter[Boolean]] =
      traversal.choose(_.nonEmptyId(_.caseId), onTrue = true, onFalse = false)

    def isImported: Boolean =
      traversal.nonEmptyId(_.caseId).exists

    def importDate: Traversal[Date, Date, Converter[Date, Date]] =
      traversal.outE[AlertCase].value(_._createdAt)

    def handlingDuration: Traversal[Long, Long, IdentityConverter[Long]] =
      traversal.coalesceIdent(
        _.filter(_.outE[AlertCase])
          .sack(
            (_: JLong, importDate: JLong) => importDate,
            _.by(_.importDate.graphMap[Long, JLong, Converter[Long, JLong]](_.getTime, Converter.long))
          )
          .sack((_: Long) - (_: JLong), _.by(_._createdAt.graphMap[Long, JLong, Converter[Long, JLong]](_.getTime, Converter.long)))
          .sack[Long],
        _.constant(0L)
      )

    def similarCases(organisationSrv: OrganisationSrv, caseFilter: Option[Traversal.V[Case] => Traversal.V[Case]])(implicit
        authContext: AuthContext
    ): Traversal[(RichCase, SimilarStats), JMap[String, Any], Converter[(RichCase, SimilarStats), JMap[String, Any]]] =
      observables
        .filteredSimilar
        .visible(organisationSrv)
        .merge(caseFilter)((obs, cf) => obs.filter(o => cf(o.`case`)))
        .filter(_.in[ShareObservable])
        .group(_.by(_.`case`))
        .unfold
        .project(
          _.by(
            _.selectKeys
              .project(
                _.by(_.richCaseWithoutPerms)
                  .by((_: Traversal.V[Case]).observables.hasNot(_.ignoreSimilarity, true).groupCount(_.byValue(_.ioc)))
              )
          )
            .by(
              _.selectValues
                .project(
                  _.by(_.unfold.groupCount(_.byValue(_.ioc)))
                    .by(_.unfold.groupCount(_.by(_.typeName)))
                )
            )
        )
        .domainMap {
          case ((richCase, obsStats), (iocStats, observableTypeStats)) =>
            val obsStatsMap     = obsStats.mapValues(_.toInt)
            val similarStatsMap = iocStats.mapValues(_.toInt)
            richCase -> SimilarStats(
              similarStatsMap.values.sum         -> obsStatsMap.values.sum,
              similarStatsMap.getOrElse(true, 0) -> obsStatsMap.getOrElse(true, 0),
              observableTypeStats
            )
        }

    def customFields(idOrName: EntityIdOrName): Traversal.E[AlertCustomField] =
      idOrName
        .fold(
          id => traversal.outE[AlertCustomField].filter(_.inV.getByIds(id)),
          name => traversal.outE[AlertCustomField].filter(_.inV.v[CustomField].has(_.name, name))
        )

    def customFields: Traversal.E[AlertCustomField] = traversal.outE[AlertCustomField]

    def customFieldJsonValue(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName): Traversal.Domain[JsValue] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map(t => CustomFieldType.map(t).getJsonValue(traversal.customFields(customField)))
        .getOrElse(traversal.empty.castDomain)

    def richCustomFields: Traversal[RichCustomField, JMap[String, Any], Converter[RichCustomField, JMap[String, Any]]] =
      traversal
        .outE[AlertCustomField]
        .project(_.by.by(_.inV.v[CustomField]))
        .domainMap {
          case (cfv, cf) => RichCustomField(cf, cfv)
        }

    def customFieldFilter(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName, predicate: P[JsValue]): Traversal.V[Alert] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map {
          case CustomFieldType.boolean =>
            traversal.filter(_.customFields.has(_.booleanValue, predicate.mapValue(_.as[Boolean])).inV.v[CustomField].get(customField))
          case CustomFieldType.date =>
            traversal.filter(_.customFields.has(_.dateValue, predicate.mapValue(_.as[Date])).inV.v[CustomField].get(customField))
          case CustomFieldType.float =>
            traversal.filter(_.customFields.has(_.floatValue, predicate.mapValue(_.as[Double])).inV.v[CustomField].get(customField))
          case CustomFieldType.integer =>
            traversal.filter(_.customFields.has(_.integerValue, predicate.mapValue(_.as[Int])).inV.v[CustomField].get(customField))
          case CustomFieldType.string =>
            traversal.filter(_.customFields.has(_.stringValue, predicate.mapValue(_.as[String])).inV.v[CustomField].get(customField))
        }
        .getOrElse(traversal.empty)

    def hasCustomField(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName): Traversal.V[Alert] = {
      val cfFilter = (t: Traversal.V[CustomField]) => customField.fold(id => t.hasId(id), name => t.has(_.name, name))

      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map {
          case CustomFieldType.boolean => traversal.filter(t => cfFilter(t.outE[AlertCustomField].has(_.booleanValue).inV.v[CustomField]))
          case CustomFieldType.date    => traversal.filter(t => cfFilter(t.outE[AlertCustomField].has(_.dateValue).inV.v[CustomField]))
          case CustomFieldType.float   => traversal.filter(t => cfFilter(t.outE[AlertCustomField].has(_.floatValue).inV.v[CustomField]))
          case CustomFieldType.integer => traversal.filter(t => cfFilter(t.outE[AlertCustomField].has(_.integerValue).inV.v[CustomField]))
          case CustomFieldType.string  => traversal.filter(t => cfFilter(t.outE[AlertCustomField].has(_.stringValue).inV.v[CustomField]))
        }
        .getOrElse(traversal.empty)
    }

    def hasNotCustomField(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName): Traversal.V[Alert] = {
      val cfFilter = (t: Traversal.V[CustomField]) => customField.fold(id => t.hasId(id), name => t.has(_.name, name))

      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map {
          case CustomFieldType.boolean => traversal.filterNot(t => cfFilter(t.outE[AlertCustomField].has(_.booleanValue).inV.v[CustomField]))
          case CustomFieldType.date    => traversal.filterNot(t => cfFilter(t.outE[AlertCustomField].has(_.dateValue).inV.v[CustomField]))
          case CustomFieldType.float   => traversal.filterNot(t => cfFilter(t.outE[AlertCustomField].has(_.floatValue).inV.v[CustomField]))
          case CustomFieldType.integer => traversal.filterNot(t => cfFilter(t.outE[AlertCustomField].has(_.integerValue).inV.v[CustomField]))
          case CustomFieldType.string  => traversal.filterNot(t => cfFilter(t.outE[AlertCustomField].has(_.stringValue).inV.v[CustomField]))
        }
        .getOrElse(traversal.empty)
    }

    def observables: Traversal.V[Observable] = traversal.out[AlertObservable].v[Observable]

    def caseTemplate: Traversal.V[CaseTemplate] = traversal.out[AlertCaseTemplate].v[CaseTemplate]

    def richAlertWithCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Alert] => Traversal[D, G, C]
    ): Traversal[(RichAlert, D), JMap[String, Any], Converter[(RichAlert, D), JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.richCustomFields.fold)
            .by(_.`case`._id.option)
            .by(_.caseTemplate.value(_.name).option)
            .by(entityRenderer)
        )
        .domainMap {
          case (alert, customFields, caseId, caseTemplate, renderedEntity) =>
            val observableCount = traversal
              .graph
              .indexCountQuery(
                s"""v."_label":Observable AND """ +
                  s"v.relatedId:${traversal.graph.escapeQueryParameter(alert._id.value)}"
              )
            RichAlert(
              alert,
              customFields,
              caseId,
              caseTemplate,
              observableCount
            ) -> renderedEntity
        }

    def richAlert: Traversal[RichAlert, JMap[String, Any], Converter[RichAlert, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.richCustomFields.fold)
            .by(_.`case`._id.option)
            .by(_.caseTemplate.value(_.name).option)
            .by(_.outE[AlertObservable].count)
        )
        .domainMap {
          case (alert, customFields, caseId, caseTemplate, observableCount) =>
            RichAlert(
              alert,
              customFields,
              caseId,
              caseTemplate,
              observableCount
            )
        }
  }

  implicit class AlertCustomFieldsOpsDefs(traversal: Traversal.E[AlertCustomField]) extends CustomFieldValueOpsDefs(traversal)
}

class AlertIntegrityCheck @Inject() (val db: Database, val service: AlertSrv, caseSrv: CaseSrv, organisationSrv: OrganisationSrv, tagSrv: TagSrv)
    extends GlobalCheck[Alert]
    with DedupCheck[Alert]
    with IntegrityCheckOps[Alert] {

  override def resolve(entities: Seq[Alert with Entity])(implicit graph: Graph): Try[Unit] = {
    val (imported, notImported) = entities.partition(_.caseId.isDefined)
    val remainingAlerts = if (imported.nonEmpty && notImported.nonEmpty) {
      // Remove all non imported alerts
      service.getByIds(notImported.map(_._id): _*).remove()
      imported
    } else entities
    // Keep the last created alert
    EntitySelector.lastCreatedEntity(remainingAlerts).foreach {
      case (_, tail) => service.getByIds(tail.map(_._id): _*).remove()
    }
    Success(())
  }

  override def globalCheck(traversal: Traversal.V[Alert])(implicit graph: Graph): Map[String, Long] = {
    val caseCheck = singleIdLink[Case]("caseId", caseSrv)(_.outEdge[AlertCase], _.set(EntityId.empty))
    val orgCheck  = singleIdLink[Organisation]("organisationId", organisationSrv)(_.outEdge[AlertOrganisation], _.remove)
    traversal
      .project(
        _.by
          .by(_.`case`._id.fold)
          .by(_.organisation._id.fold)
          .by(_.removeDuplicateOutEdges[AlertCase]())
          .by(_.removeDuplicateOutEdges[AlertOrganisation]())
          .by(_.tags.fold)
      )
      .toIterator
      .map {
        case (alert, caseIds, orgIds, extraCaseEdges, extraOrgEdges, tags) =>
          val caseStats = caseCheck.check(alert, alert.caseId, caseIds)
          val orgStats  = orgCheck.check(alert, alert.organisationId, orgIds)
          val tagStats = {
            val alertTagSet = alert.tags.toSet
            val tagSet      = tags.map(_.toString).toSet
            if (alertTagSet == tagSet) Map.empty[String, Long]
            else {
              implicit val authContext: AuthContext =
                LocalUserSrv.getSystemAuthContext.changeOrganisation(alert.organisationId, Permissions.all)

              val extraTagField = alertTagSet -- tagSet
              val extraTagLink  = tagSet -- alertTagSet
              extraTagField.flatMap(tagSrv.getOrCreate(_).toOption).foreach(service.alertTagSrv.create(AlertTag(), alert, _))
              service.get(alert).update(_.tags, alert.tags ++ extraTagLink).iterate()
              Map(
                "case-tags-extraField" -> extraTagField.size.toLong,
                "case-tags-extraLink"  -> extraTagLink.size.toLong
              )
            }
          }
          caseStats <+> orgStats <+> extraCaseEdges <+> extraOrgEdges <+> tagStats
      }
      .reduceOption(_ <+> _)
      .getOrElse(Map.empty)
  }
}

```

`thehive/app/org/thp/thehive/services/AttachmentSrv.scala`:

```scala
package org.thp.thehive.services

import akka.NotUsed
import akka.stream.scaladsl.{Source, StreamConverters}
import akka.stream.{IOResult, Materializer}
import akka.util.ByteString
import org.thp.scalligraph.NotFoundError
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.FFile
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.services.{StorageSrv, VertexSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.scalligraph.utils.Hasher
import org.thp.thehive.models.Attachment
import org.thp.thehive.services.AttachmentOps._
import play.api.Configuration

import java.io.InputStream
import java.nio.file.Files
import javax.inject.{Inject, Singleton}
import scala.concurrent.Future
import scala.util.Try

@Singleton
class AttachmentSrv @Inject() (configuration: Configuration, storageSrv: StorageSrv)(implicit
    mat: Materializer
) extends VertexSrv[Attachment] {

  val hashers: Hasher = Hasher(configuration.get[Seq[String]]("attachment.hash"): _*)

  def create(file: FFile)(implicit graph: Graph, authContext: AuthContext): Try[Attachment with Entity] = {
    val hs = hashers.fromPath(file.filepath)
    val id = hs.head.toString
    val is = Files.newInputStream(file.filepath)
    try storageSrv
      .saveBinary("attachment", id, is)
      .flatMap(_ => createEntity(Attachment(file.filename, Files.size(file.filepath), file.contentType, hs, id)))
    finally is.close()
  }

  def create(filename: String, contentType: String, data: Array[Byte])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Attachment with Entity] = {
    val hs = hashers.fromBinary(data)
    val id = hs.head.toString
    storageSrv.saveBinary("attachment", id, data).flatMap(_ => createEntity(Attachment(filename, data.length.toLong, contentType, hs, id)))
  }

  def create(filename: String, size: Long, contentType: String, data: Source[ByteString, NotUsed])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Attachment with Entity] = {
    val hs = hashers.fromBinary(data)
    val id = hs.head.toString
    storageSrv.saveBinary("attachment", id, data).flatMap(_ => createEntity(Attachment(filename, size, contentType, hs, id)))
  }

  def duplicate(filename: String, contentType: String, attachmentId: String)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Attachment with Entity] = {
    val (size, hashes) = getByName(attachmentId).headOption match {
      case Some(a) => (a.size, a.hashes)
      case None =>
        val s  = storageSrv.getSize("attachment", attachmentId).getOrElse(throw NotFoundError(s"Attachment $attachmentId not found"))
        val is = storageSrv.loadBinary("attachment", attachmentId)
        val hs =
          try hashers.fromInputStream(is)
          finally is.close()
        (s, hs)
    }
    createEntity(Attachment(filename, size, contentType, hashes, attachmentId))
  }

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[Attachment] =
    startTraversal.getByAttachmentId(name)

  def source(attachment: Attachment with Entity): Source[ByteString, Future[IOResult]] =
    StreamConverters.fromInputStream(() => stream(attachment))

  def stream(attachment: Attachment with Entity): InputStream = storageSrv.loadBinary("attachment", attachment.attachmentId)

  def exists(attachment: Attachment with Entity): Boolean = storageSrv.exists("attachment", attachment.attachmentId)

  override def delete(attachment: Attachment with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val attachments = startTraversal.has(_.attachmentId, attachment.attachmentId).limit(2).getCount
    if (attachments == 1)
      storageSrv.delete("attachment", attachment.attachmentId)

    Try(get(attachment).remove())
  }

}

object AttachmentOps {
  implicit class AttachmentOpsDefs(traversal: Traversal.V[Attachment]) {
    def getByAttachmentId(attachmentId: String): Traversal.V[Attachment] = traversal.has(_.attachmentId, attachmentId)

    def visible: Traversal.V[Attachment] = traversal // TODO

  }
}

```

`thehive/app/org/thp/thehive/services/AuditSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.ActorRef
import com.google.inject.name.Named
import org.apache.tinkerpop.gremlin.process.traversal.Order
import org.apache.tinkerpop.gremlin.structure.Transaction.Status
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.EntityId
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, IdentityConverter, Traversal}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.DashboardOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.notification.AuditNotificationMessage
import play.api.libs.json.{JsObject, JsValue, Json}

import java.util.{Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Success, Try}

case class PendingAudit(audit: Audit, context: Product with Entity, `object`: Option[Product with Entity])

@Singleton
class AuditSrv @Inject() (
    userSrvProvider: Provider[UserSrv],
    @Named("notification-actor") notificationActor: ActorRef,
    eventSrv: EventSrv,
    db: Database
) extends VertexSrv[Audit] { auditSrv =>
  lazy val userSrv: UserSrv                                = userSrvProvider.get
  val auditUserSrv                                         = new EdgeSrv[AuditUser, Audit, User]
  val auditedSrv                                           = new EdgeSrv[Audited, Audit, Product]
  val auditContextSrv                                      = new EdgeSrv[AuditContext, Audit, Product]
  val `case`                                               = new SelfContextObjectAudit[Case]
  val task                                                 = new SelfContextObjectAudit[Task]
  val observable                                           = new SelfContextObjectAudit[Observable]
  val log                                                  = new ObjectAudit[Log, Task]
  val caseTemplate                                         = new SelfContextObjectAudit[CaseTemplate]
  val taskInTemplate                                       = new ObjectAudit[Task, CaseTemplate]
  val alert                                                = new AlertAudit
  val share                                                = new ShareAudit
  val observableInAlert                                    = new ObjectAudit[Observable, Alert]
  val user                                                 = new UserAudit
  val dashboard                                            = new SelfContextObjectAudit[Dashboard]
  val organisation                                         = new SelfContextObjectAudit[Organisation]
  val profile                                              = new SelfContextObjectAudit[Profile]
  val pattern                                              = new SelfContextObjectAudit[Pattern]
  val procedure                                            = new ObjectAudit[Procedure, Case]
  val customField                                          = new SelfContextObjectAudit[CustomField]
  val page                                                 = new SelfContextObjectAudit[Page]
  private val pendingAuditsLock                            = new Object
  private val transactionAuditIdsLock                      = new Object
  private val unauditedTransactionsLock                    = new Object
  private var pendingAudits: Map[Graph, PendingAudit]      = Map.empty
  private var transactionAuditIds: List[(Graph, EntityId)] = Nil
  private var unauditedTransactions: Set[Graph]            = Set.empty

  /**
    * Gets the main action Audits by ids sorted by date
    * @param order the sort
    * @param ids the ids
    * @param graph db
    * @return
    */
  def getMainByIds(order: Order, ids: EntityId*)(implicit graph: Graph): Traversal.V[Audit] =
    getByIds(ids: _*)
      .has(_.mainAction, true)
      .sort(_.by("_createdAt", order))

  def mergeAudits[R](body: => Try[R])(auditCreator: R => Try[Unit])(implicit graph: Graph): Try[R] = {
    unauditedTransactionsLock.synchronized {
      unauditedTransactions = unauditedTransactions + graph
    }
    val result = body
    unauditedTransactionsLock.synchronized {
      unauditedTransactions = unauditedTransactions - graph
    }
    result.flatMap { r =>
      auditCreator(r).map(_ => r)
    }
  }

  def flushPendingAudit()(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    logger.debug("Store last audit")
    pendingAudits.get(graph).fold[Try[Unit]](Success(())) { p =>
      pendingAuditsLock.synchronized {
        pendingAudits = pendingAudits - graph
      }
      createFromPending(p.audit.copy(mainAction = true), p.context, p.`object`).map { _ =>
        val (ids, otherTxIds) = transactionAuditIds.partition(_._1 == graph)
        transactionAuditIdsLock.synchronized {
          transactionAuditIds = otherTxIds
        }
        db.addTransactionListener {
          case Status.COMMIT =>
            logger.debug("Sending audit to stream bus and to notification actor")
            val auditIds = ids.map(_._2)
            eventSrv.publish(StreamTopic.dispatcher)(AuditStreamMessage(auditIds: _*))
            notificationActor ! AuditNotificationMessage(auditIds: _*)
          case _ =>
        }
      }
    }
  }

  private def createFromPending(audit: Audit, context: Product with Entity, `object`: Option[Product with Entity])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] = {
    logger.debug(s"Store audit entity: $audit")
    for {
      user         <- userSrv.current.getOrFail("User")
      createdAudit <- createEntity(audit)
      _            <- auditUserSrv.create(AuditUser(), createdAudit, user)
      _            <- `object`.map(auditedSrv.create(Audited(), createdAudit, _)).flip
      _ = auditContextSrv.create(AuditContext(), createdAudit, context) // this could fail on delete (context doesn't exist)
    } yield transactionAuditIdsLock.synchronized {
      transactionAuditIds = (graph -> createdAudit._id) :: transactionAuditIds
    }
  }

  def create(audit: Audit, context: Product with Entity, `object`: Option[Product with Entity])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] = {
    def setupCallbacks(): Try[Unit] = {
      logger.debug("Setup callbacks for the current transaction")
      db.addTransactionListener {
        case Status.ROLLBACK =>
          pendingAuditsLock.synchronized {
            pendingAudits = pendingAudits - graph
          }
          transactionAuditIdsLock.synchronized {
            transactionAuditIds = transactionAuditIds.filterNot(_._1 == graph)
          }
        case _ =>
      }
      db.addCallback(() => flushPendingAudit())
      Success(())
    }

    if (unauditedTransactions.contains(graph)) {
      logger.debug(s"Audit is disable to the current transaction, $audit ignored.")
      Success(())
    } else {
      logger.debug(s"Hold $audit, store previous audit if any")
      val p = pendingAudits.get(graph)
      pendingAuditsLock.synchronized {
        pendingAudits = pendingAudits + (graph -> PendingAudit(audit, context, `object`))
      }
      p.fold(setupCallbacks())(p => createFromPending(p.audit, p.context, p.`object`))
    }
  }

  def getObject(audit: Audit with Entity)(implicit graph: Graph): Option[Product with Entity] = get(audit).`object`.entity.headOption

  class ObjectAudit[E <: Product, C <: Product] {

    def create(entity: E with Entity, context: C with Entity, details: JsValue)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
      auditSrv.create(Audit(Audit.create, entity, Some(details.toString)), context, Some(entity))

    def update(entity: E with Entity, context: C with Entity, details: JsObject)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
      if (details == JsObject.empty) Success(())
      else auditSrv.create(Audit(Audit.update, entity, Some(details.toString)), context, Some(entity))

    def delete(entity: E with Entity, context: C with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
      auditSrv.create(Audit(Audit.delete, entity, None), context, None)

  }

  class SelfContextObjectAudit[E <: Product] {

    def create(entity: E with Entity, details: JsValue)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
      auditSrv.create(Audit(Audit.create, entity, Some(details.toString)), entity, Some(entity))

    def update(entity: E with Entity, details: JsObject)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
      if (details == JsObject.empty) Success(())
      else auditSrv.create(Audit(Audit.update, entity, Some(details.toString)), entity, Some(entity))

    def delete(entity: E with Entity, context: Product with Entity, details: Option[JsObject] = None)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] =
      auditSrv.create(Audit(Audit.delete, entity, details.map(_.toString())), context, None)

    def merge(entity: E with Entity, details: Option[JsObject] = None)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] =
      auditSrv.create(Audit(Audit.merge, entity, details.map(_.toString())), entity, Some(entity))
  }

  class UserAudit extends SelfContextObjectAudit[User] {

    def changeProfile(user: User with Entity, organisation: Organisation with Entity, profile: Profile)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] =
      auditSrv.create(
        Audit(Audit.update, user, Some(Json.obj("organisation" -> organisation.name, "profile" -> profile.name).toString)),
        organisation,
        Some(user)
      )

    def delete(user: User with Entity, organisation: Organisation with Entity)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] =
      auditSrv.create(
        Audit(Audit.delete, user, Some(Json.obj("organisation" -> organisation.name).toString)),
        organisation,
        None
      )
  }

  class ShareAudit {

    def shareCase(`case`: Case with Entity, organisation: Organisation with Entity, profile: Profile with Entity)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] =
      auditSrv.create(
        Audit(Audit.update, `case`, Some(Json.obj("share" -> Json.obj("organisation" -> organisation.name, "profile" -> profile.name)).toString)),
        `case`,
        Some(`case`)
      )

    def shareTask(task: Task with Entity, `case`: Case with Entity, organisation: Organisation with Entity)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] =
      auditSrv.create(
        Audit(Audit.update, task, Some(Json.obj("share" -> Json.obj("organisation" -> organisation.name)).toString)),
        task,
        Some(`case`)
      )

    def shareObservable(observable: Observable with Entity, `case`: Case with Entity, organisation: Organisation with Entity)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] =
      auditSrv.create(
        Audit(Audit.update, observable, Some(Json.obj("share" -> Json.obj("organisation" -> organisation.name)).toString)),
        observable,
        Some(`case`)
      )

    def unshareCase(`case`: Case with Entity, organisation: Organisation with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
      auditSrv.create(
        Audit(Audit.update, `case`, Some(Json.obj("unshare" -> Json.obj("organisation" -> organisation.name)).toString)),
        `case`,
        Some(`case`)
      )

    def unshareTask(task: Task with Entity, `case`: Case with Entity, organisation: Organisation with Entity)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] =
      auditSrv.create(
        Audit(Audit.update, task, Some(Json.obj("unshare" -> Json.obj("organisation" -> organisation.name)).toString)),
        task,
        Some(`case`)
      )

    def unshareObservable(observable: Observable with Entity, `case`: Case with Entity, organisation: Organisation with Entity)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] =
      auditSrv.create(
        Audit(Audit.update, observable, Some(Json.obj("unshare" -> Json.obj("organisation" -> organisation.name)).toString)),
        observable,
        Some(`case`)
      )
  }

  class AlertAudit extends SelfContextObjectAudit[Alert] {
    def createCase(alert: Alert with Entity, `case`: Case with Entity, details: JsObject)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] = {
      auditSrv.create(Audit(Audit.update, alert, Some(Json.obj("caseId" -> `case`._id).toString)), `case`, Some(`case`))
      val detailsWithAlert = details + ("fromAlert" -> Json.obj(
        "_id"       -> alert._id.toString,
        "type"      -> alert.`type`,
        "source"    -> alert.source,
        "sourceRef" -> alert.sourceRef
      ))
      auditSrv.create(Audit(Audit.create, `case`, Some(detailsWithAlert.toString)), `case`, Some(`case`))
    }

    def mergeToCase(alert: Alert with Entity, `case`: Case with Entity, details: JsObject)(implicit
        graph: Graph,
        authContext: AuthContext
    ): Try[Unit] = {
      auditSrv.create(Audit(Audit.update, alert, Some(Json.obj("caseId" -> `case`._id).toString)), `case`, Some(`case`))
      val detailsWithAlert = details + ("fromAlert" -> Json.obj(
        "_id"       -> alert._id.toString,
        "type"      -> alert.`type`,
        "source"    -> alert.source,
        "sourceRef" -> alert.sourceRef
      ))
      auditSrv.create(Audit(Audit.merge, `case`, Some(detailsWithAlert.toString)), `case`, Some(`case`))
    }
  }
}

object AuditOps {

  implicit class VertexDefs(traversal: Traversal[Vertex, Vertex, IdentityConverter[Vertex]]) {
    def share: Traversal.V[Share] = traversal.coalesceIdent(_.in[ShareObservable], _.in[ShareTask], _.in[ShareCase], _.identity).v[Share]
  }

  implicit class AuditedObjectOpsDefs[A](traversal: Traversal.V[A]) {
    def audits: Traversal.V[Audit]            = traversal.in[Audited].v[Audit]
    def auditsFromContext: Traversal.V[Audit] = traversal.in[AuditContext].v[Audit]
  }

  implicit class AuditOpsDefs(traversal: Traversal.V[Audit]) {
    def auditContextObjectOrganisation: Traversal[
      (Audit with Entity, Option[Map[String, Seq[Any]] with Entity], Option[Map[String, Seq[Any]] with Entity], Seq[Organisation with Entity]),
      JMap[String, Any],
      Converter[
        (Audit with Entity, Option[Map[String, Seq[Any]] with Entity], Option[Map[String, Seq[Any]] with Entity], Seq[Organisation with Entity]),
        JMap[String, Any]
      ]
    ] =
      traversal
        .project(
          _.by
            .by(_.context.entityMap.option)
            .by(_.`object`.entityMap.option)
            .by(_.organisation.dedup.fold)
        )

    def richAudit: Traversal[RichAudit, JMap[String, Any], Converter[RichAudit, JMap[String, Any]]] =
      traversal
        .filter(_.context)
        .project(
          _.by
            .by(_.`case`.entity.fold)
            .by(_.context.entity)
            .by(_.`object`.entity.fold)
        )
        .domainMap {
          case (audit, context, visibilityContext, obj) =>
            val ctx = if (context.isEmpty) visibilityContext else context.head
            RichAudit(audit, ctx, visibilityContext, obj.headOption)
        }

    def richAuditWithCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Audit] => Traversal[D, G, C]
    ): Traversal[(RichAudit, D), JMap[String, Any], Converter[(RichAudit, D), JMap[String, Any]]] =
      traversal
        .filter(_.context)
        .project(
          _.by
            .by(_.`case`.entity.fold)
            .by(_.context.entity.fold)
            .by(_.`object`.entity.fold)
            .by(entityRenderer)
        )
        .domainMap {
          case (audit, context, visibilityContext, obj, renderedObject) =>
            val ctx = if (context.isEmpty) visibilityContext.head else context.head
            RichAudit(audit, ctx, visibilityContext.head, obj.headOption) -> renderedObject
        }

//    def forCase(caseId: String): Traversal.V[Audit] = traversal.filter(_.`case`.hasId(caseId))

    def `case`: Traversal.V[Case] =
      traversal
        .out[AuditContext]
        .share
        .out[ShareCase]
        .v[Case]

    def organisation: Traversal.V[Organisation] =
      traversal
        .out[AuditContext]
        .coalesceIdent[Vertex](
          _.share.in[OrganisationShare],
          _.out[AlertOrganisation],
          _.unsafeHas("_label", "Organisation"),
          _.out[CaseTemplateOrganisation],
          _.in[OrganisationDashboard]
        )
        .v[Organisation]

    def organisationIds: Traversal[EntityId, AnyRef, Converter[EntityId, AnyRef]] =
      traversal
        .out[AuditContext]
        .chooseBranch[String, AnyRef](
          _.on(_.label)
            .option("Case", _.v[Case].value(_.organisationIds).widen[AnyRef])
            .option("Observable", _.v[Observable].value(_.organisationIds).widen[AnyRef])
            .option("Task", _.v[Task].value(_.organisationIds).widen[AnyRef])
            .option("Alert", _.v[Alert].value(_.organisationId).widen[AnyRef])
            .option("Organisation", _.v[Organisation]._id)
            .option("CaseTemplate", _.v[CaseTemplate].organisation._id)
            .option("Dashboard", _.v[Dashboard].organisation._id)
            .option("Share", _.v[Share].organisation._id)
        )
        .domainMap(EntityId.apply)

    def caseId: Traversal[EntityId, AnyRef, Converter[EntityId, AnyRef]] =
      traversal
        .out[AuditContext]
        .chooseBranch[String, AnyRef](
          _.on(_.label)
            .option("Case", _.v[Case]._id)
            .option("Observable", _.v[Observable].value(_.relatedId).widen[AnyRef])
            .option("Task", _.v[Task].value(_.relatedId).widen[AnyRef])
            .option("Share", _.v[Share].`case`._id)
        )
        .domainMap(EntityId.apply)

    def visible(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Audit] =
      traversal.filter(
        _.out[AuditContext].chooseBranch[String, Any](
          _.on(_.label)
            .option("Case", _.v[Case].visible(organisationSrv).widen[Any])
            .option("Observable", _.v[Observable].visible(organisationSrv).widen[Any])
            .option("Task", _.v[Task].visible(organisationSrv).widen[Any])
            .option("Alert", _.v[Alert].visible(organisationSrv).widen[Any])
            .option("Organisation", _.v[Organisation].current.widen[Any])
            .option("CaseTemplate", _.v[CaseTemplate].visible.widen[Any])
            .option("Dashboard", _.v[Dashboard].visible.widen[Any])
            .option("Share", _.v[Share].organisation.current.widen[Any])
        )
      )

    def `object`: Traversal[Vertex, Vertex, IdentityConverter[Vertex]] = traversal.out[Audited]

    def context: Traversal[Vertex, Vertex, IdentityConverter[Vertex]] = traversal.out[AuditContext]
  }

}

```

`thehive/app/org/thp/thehive/services/CaseNumber.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.scaladsl.adapter.ClassicActorSystemOps
import akka.actor.typed.{ActorRefResolver, Behavior, ActorRef => TypedActorRef}
import akka.actor.{ActorSystem, ExtendedActorSystem}
import akka.cluster.typed.{ClusterSingleton, SingletonActor}
import akka.serialization.Serializer
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services.config.ApplicationConfig
import org.thp.scalligraph.services.config.ApplicationConfig.finiteDurationFormat
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.services.CaseOps._

import java.io.NotSerializableException
import java.nio.ByteBuffer
import javax.inject.{Inject, Provider, Singleton}
import scala.concurrent.duration.FiniteDuration

object CaseNumberActor {
  sealed trait Message
  sealed trait Request                                       extends Message
  sealed trait Response                                      extends Message
  case class GetNextNumber(replyTo: TypedActorRef[Response]) extends Request
  case class NextNumber(number: Int)                         extends Response
  case object ReloadFromDatabase                             extends Request

  def behavior(db: Database, appConfig: ApplicationConfig, caseSrvProvider: Provider[CaseSrv]): Behavior[Request] = {
    lazy val caseSrv: CaseSrv = caseSrvProvider.get
    val caseNumberReloadIntervalConfig =
      appConfig.item[FiniteDuration]("caseNumber.reload.interval", "Reload last case number from database interval")
    Behaviors.withTimers { timers =>
      val reloadTimer: () => Unit = () => timers.startSingleTimer(ReloadFromDatabase, caseNumberReloadIntervalConfig.get)
      val getNextNumber: () => Int = () =>
        db.roTransaction { implicit graph =>
          caseSrv.startTraversal.getLast.headOption.fold(0)(_.number) + 1
        }
      caseNumberProvider(getNextNumber, reloadTimer, getNextNumber())
    }
  }

  def caseNumberProvider(getNextNumber: () => Int, reloadTimer: () => Unit, nextNumber: Int): Behavior[Request] =
    Behaviors.receiveMessage {
      case GetNextNumber(replyTo) =>
        replyTo ! NextNumber(nextNumber)
        caseNumberProvider(getNextNumber, reloadTimer, nextNumber + 1)
      case ReloadFromDatabase =>
        reloadTimer()
        caseNumberProvider(getNextNumber, reloadTimer, Math.max(getNextNumber(), nextNumber))
    }
}

@Singleton
class CaseNumberActorProvider @Inject() (system: ActorSystem, db: Database, appConfig: ApplicationConfig, caseSrvProvider: Provider[CaseSrv])
    extends Provider[TypedActorRef[CaseNumberActor.Request]] {
  override lazy val get: TypedActorRef[CaseNumberActor.Request] =
    ClusterSingleton(system.toTyped)
      .init(SingletonActor(CaseNumberActor.behavior(db, appConfig, caseSrvProvider), "CaseNumberLeader"))
}

class CaseNumberSerializer(system: ExtendedActorSystem) extends Serializer {
  import CaseNumberActor._

  private val actorRefResolver = ActorRefResolver(system.toTyped)

  override def identifier: Int = 9739323

  override def toBinary(o: AnyRef): Array[Byte] =
    o match {
      case GetNextNumber(replyTo) => 0.toByte +: actorRefResolver.toSerializationFormat(replyTo).getBytes
      case NextNumber(number)     => ByteBuffer.allocate(5).put(1.toByte).putInt(number).array()
      case ReloadFromDatabase     => Array(2)
      case _                      => throw new NotSerializableException
    }

  override def includeManifest: Boolean = false

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef =
    bytes(0) match {
      case 0 => GetNextNumber(actorRefResolver.resolveActorRef(new String(bytes.tail)))
      case 1 => NextNumber(ByteBuffer.wrap(bytes).getInt(1))
      case 2 => ReloadFromDatabase
      case _ => throw new NotSerializableException
    }
}

```

`thehive/app/org/thp/thehive/services/CaseSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.ActorSystem
import akka.actor.typed.scaladsl.AskPattern._
import akka.actor.typed.scaladsl.adapter.ClassicSchedulerOps
import akka.actor.typed.{ActorRef, Scheduler}
import akka.util.Timeout
import org.apache.tinkerpop.gremlin.process.traversal.{Order, P}
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.controllers.{FFile, FPathElem}
import org.thp.scalligraph.models._
import org.thp.scalligraph.query.PredicateOps.PredicateOpsDefs
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal._
import org.thp.scalligraph.{BadRequestError, EntityId, EntityIdOrName, EntityName, RichOptionTry, RichSeq}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.dto.v1.InputCustomFieldValue
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CustomFieldOps._
import org.thp.thehive.services.DataOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.UserOps._
import play.api.cache.SyncCacheApi
import play.api.libs.json.{JsNull, JsObject, JsValue, Json}

import java.lang.{Long => JLong}
import java.util.{Date, List => JList, Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.concurrent.duration.DurationInt
import scala.concurrent.{Await, ExecutionContextExecutor, Future}
import scala.util.{Failure, Success, Try}

@Singleton
class CaseSrv @Inject() (
    tagSrv: TagSrv,
    customFieldSrv: CustomFieldSrv,
    organisationSrv: OrganisationSrv,
    profileSrv: ProfileSrv,
    shareSrv: ShareSrv,
    taskSrv: TaskSrv,
    auditSrv: AuditSrv,
    resolutionStatusSrv: ResolutionStatusSrv,
    impactStatusSrv: ImpactStatusSrv,
    observableSrv: ObservableSrv,
    attachmentSrv: AttachmentSrv,
    userSrv: UserSrv,
    alertSrvProvider: Provider[AlertSrv],
    integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]],
    caseNumberActor: ActorRef[CaseNumberActor.Request],
    cache: SyncCacheApi,
    system: ActorSystem
) extends VertexSrv[Case] {
  lazy val alertSrv: AlertSrv                                    = alertSrvProvider.get
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  val caseTagSrv              = new EdgeSrv[CaseTag, Case, Tag]
  val caseImpactStatusSrv     = new EdgeSrv[CaseImpactStatus, Case, ImpactStatus]
  val caseResolutionStatusSrv = new EdgeSrv[CaseResolutionStatus, Case, ResolutionStatus]
  val caseUserSrv             = new EdgeSrv[CaseUser, Case, User]
  val caseCustomFieldSrv      = new EdgeSrv[CaseCustomField, Case, CustomField]
  val caseCaseTemplateSrv     = new EdgeSrv[CaseCaseTemplate, Case, CaseTemplate]
  val caseProcedureSrv        = new EdgeSrv[CaseProcedure, Case, Procedure]
  val shareCaseSrv            = new EdgeSrv[ShareCase, Share, Case]
  val mergedFromSrv           = new EdgeSrv[MergedFrom, Case, Case]

  override def createEntity(e: Case)(implicit graph: Graph, authContext: AuthContext): Try[Case with Entity] =
    super.createEntity(e).map { `case` =>
      integrityCheckActor ! IntegrityCheck.EntityAdded("Case")
      `case`
    }

  def create(
      `case`: Case,
      assignee: Option[User with Entity],
      organisation: Organisation with Entity,
      customFields: Seq[InputCustomFieldValue],
      caseTemplate: Option[RichCaseTemplate],
      additionalTasks: Seq[Task]
  )(implicit graph: Graph, authContext: AuthContext): Try[RichCase] = {
    val caseNumber = if (`case`.number == 0) nextCaseNumber else `case`.number
    val tagNames   = (`case`.tags ++ caseTemplate.fold[Seq[String]](Nil)(_.tags)).distinct
    for {
      tags <- tagNames.toTry(tagSrv.getOrCreate)
      createdCase <- createEntity(
        `case`.copy(
          number = caseNumber,
          assignee = assignee.map(_.login),
          organisationIds = Set(organisation._id),
          caseTemplate = caseTemplate.map(_.name),
          impactStatus = None,
          resolutionStatus = None,
          tags = tagNames,
          owningOrganisation = organisationSrv.currentId
        )
      )
      _ <- assignee.map(u => caseUserSrv.create(CaseUser(), createdCase, u)).flip
      _ <- shareSrv.shareCase(owner = true, createdCase, organisation, profileSrv.orgAdmin)
      _ <- caseTemplate.map(ct => caseCaseTemplateSrv.create(CaseCaseTemplate(), createdCase, ct.caseTemplate)).flip
      _ <- caseTemplate.fold(additionalTasks)(_.tasks.map(_.task) ++ additionalTasks).toTry(task => createTask(createdCase, task))
      _ <- tags.toTry(caseTagSrv.create(CaseTag(), createdCase, _))

      caseTemplateCf =
        caseTemplate
          .fold[Seq[RichCustomField]](Seq())(_.customFields)
          .map(cf => InputCustomFieldValue(cf.name, cf.value, cf.order))
      cfs <- cleanCustomFields(caseTemplateCf, customFields).toTry {
        case InputCustomFieldValue(name, value, order) => createCustomField(createdCase, EntityIdOrName(name), value, order)
      }

      richCase = RichCase(createdCase, cfs, authContext.permissions)
      _ <- auditSrv.`case`.create(createdCase, richCase.toJson)
    } yield richCase
  }

  def caseId(idOrName: EntityIdOrName)(implicit graph: Graph): EntityId =
    idOrName.fold(identity, oid => cache.getOrElseUpdate(s"case-$oid")(getByName(oid)._id.getOrFail("Case").get))

  private def cleanCustomFields(caseTemplateCf: Seq[InputCustomFieldValue], caseCf: Seq[InputCustomFieldValue]): Seq[InputCustomFieldValue] = {
    val uniqueFields = caseTemplateCf.filter {
      case InputCustomFieldValue(name, _, _) => !caseCf.exists(_.name == name)
    }
    
    (caseCf.sortBy(_.order) ++ uniqueFields.sortBy(_.order))
      .zipWithIndex
      .map { case (InputCustomFieldValue(name, value, _), i) => InputCustomFieldValue(name, value, Some(i)) }
  }

  def nextCaseNumberAsync: Future[Int] = {
    implicit val timeout: Timeout             = Timeout(1.minute)
    implicit val scheduler: Scheduler         = system.scheduler.toTyped
    implicit val ec: ExecutionContextExecutor = system.dispatcher
    caseNumberActor.ask[CaseNumberActor.Response](replyTo => CaseNumberActor.GetNextNumber(replyTo)).map {
      case CaseNumberActor.NextNumber(caseNumber) => caseNumber
    }
  }

  def nextCaseNumber: Int =
    Await.result(nextCaseNumberAsync, 1.minute)

  override def exists(e: Case)(implicit graph: Graph): Boolean = startTraversal.getByNumber(e.number).exists

  override def update(
      traversal: Traversal.V[Case],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[Case], JsObject)] = {
    val closeCase = PropertyUpdater(FPathElem("closeCase"), "") { (vertex, _, _) =>
      get(vertex)
        .tasks
        .or(_.has(_.status, TaskStatus.Waiting), _.has(_.status, TaskStatus.InProgress))
        .toIterator
        .toTry {
          case task if task.status == TaskStatus.InProgress => taskSrv.updateStatus(task, TaskStatus.Completed)
          case task                                         => taskSrv.updateStatus(task, TaskStatus.Cancel)
        }
        .flatMap { _ =>
          vertex.property("endDate", System.currentTimeMillis())
          Success(Json.obj("endDate" -> System.currentTimeMillis()))
        }
    }

    val isCloseCase = propertyUpdaters.exists(p => p.path.matches(FPathElem("status")) && p.value == CaseStatus.Resolved)

    val newPropertyUpdaters = if (isCloseCase) closeCase +: propertyUpdaters else propertyUpdaters
    auditSrv.mergeAudits(super.update(traversal, newPropertyUpdaters)) {
      case (caseSteps, updatedFields) =>
        caseSteps
          .clone()
          .getOrFail("Case")
          .flatMap(auditSrv.`case`.update(_, updatedFields))
    }
  }

  def updateTags(`case`: Case with Entity, tags: Set[String])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[(Seq[Tag with Entity], Seq[Tag with Entity])] =
    for {
      tagsToAdd <- (tags -- `case`.tags).toTry(tagSrv.getOrCreate)
      tagsToRemove = get(`case`).tags.toSeq.filterNot(t => tags.contains(t.toString))
      _ <- tagsToAdd.toTry(caseTagSrv.create(CaseTag(), `case`, _))
      _ = if (tagsToRemove.nonEmpty) get(`case`).outE[CaseTag].filter(_.otherV.hasId(tagsToRemove.map(_._id): _*)).remove()
      _ <- get(`case`)
        .update(_.tags, tags.toSeq)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("Case")
      _ <- auditSrv.`case`.update(`case`, Json.obj("tags" -> tags))
    } yield (tagsToAdd, tagsToRemove)

  def addTags(`case`: Case with Entity, tags: Set[String])(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    updateTags(`case`, tags ++ `case`.tags).map(_ => ())

  def createTask(`case`: Case with Entity, task: Task)(implicit graph: Graph, authContext: AuthContext): Try[RichTask] =
    for {
      assignee <- task.assignee.map(u => get(`case`).assignableUsers.getByName(u).getOrFail("User")).flip
      task     <- taskSrv.create(task.copy(relatedId = `case`._id, organisationIds = Set(organisationSrv.currentId)), assignee)
      _        <- shareSrv.shareTask(task, `case`, organisationSrv.currentId)
    } yield task

  def createObservable(`case`: Case with Entity, observable: Observable, data: String)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichObservable] =
    for {
      createdObservable <- observableSrv.create(observable.copy(organisationIds = Set(organisationSrv.currentId), relatedId = `case`._id), data)
      _                 <- shareSrv.shareObservable(createdObservable, `case`, organisationSrv.currentId)
    } yield createdObservable

  def createObservable(`case`: Case with Entity, observable: Observable, attachment: Attachment with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichObservable] =
    for {
      createdObservable <- observableSrv.create(observable.copy(organisationIds = Set(organisationSrv.currentId), relatedId = `case`._id), attachment)
      _                 <- shareSrv.shareObservable(createdObservable, `case`, organisationSrv.currentId)
    } yield createdObservable

  def createObservable(`case`: Case with Entity, observable: Observable, file: FFile)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichObservable] =
    attachmentSrv.create(file).flatMap(attachment => createObservable(`case`, observable, attachment))

  override def delete(`case`: Case with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val details = Json.obj("number" -> `case`.number, "title" -> `case`.title)
    organisationSrv.get(authContext.organisation).getOrFail("Organisation").flatMap { organisation =>
      shareSrv
        .get(`case`, authContext.organisation)
        .getOrFail("Share")
        .flatMap {
          case share if share.owner =>
            get(`case`)
              .sideEffect(_.alert.update(_.caseId, EntityId.empty))
              .shares
              .toSeq
              .toTry(s => shareSrv.unshareCase(s._id))
              .map(_ => get(`case`).remove())
          case _ =>
            throw BadRequestError("Your organisation must be owner of the case")
          // shareSrv.unshareCase(share._id)
        }
        .map(_ => auditSrv.`case`.delete(`case`, organisation, Some(details)))
    }
  }

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[Case] =
    Try(startTraversal.getByNumber(name.toInt)).getOrElse(startTraversal.empty)

  def getCustomField(`case`: Case with Entity, customFieldIdOrName: EntityIdOrName)(implicit graph: Graph): Option[RichCustomField] =
    get(`case`).customFields(customFieldIdOrName).richCustomField.headOption

  def updateCustomField(
      `case`: Case with Entity,
      customFieldValues: Seq[(CustomField, Any, Option[Int])]
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val customFieldNames = customFieldValues.map(_._1.name)
    get(`case`)
      .richCustomFields
      .toIterator
      .filterNot(rcf => customFieldNames.contains(rcf.name))
      .foreach(rcf => get(`case`).customFields(EntityName(rcf.name)).remove())
    customFieldValues
      .toTry { case (cf, v, o) => setOrCreateCustomField(`case`, EntityName(cf.name), Some(v), o) }
      .map(_ => ())
  }

  def setOrCreateCustomField(`case`: Case with Entity, customFieldIdOrName: EntityIdOrName, value: Option[Any], order: Option[Int])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] = {
    val cfv = get(`case`).customFields(customFieldIdOrName)
    if (cfv.clone().exists)
      cfv.setValue(value)
    else
      createCustomField(`case`, customFieldIdOrName, value, order).map(_ => ())
  }

  def createCustomField(
      `case`: Case with Entity,
      customFieldIdOrName: EntityIdOrName,
      customFieldValue: Option[Any],
      order: Option[Int]
  )(implicit graph: Graph, authContext: AuthContext): Try[RichCustomField] =
    for {
      cf   <- customFieldSrv.getOrFail(customFieldIdOrName)
      ccf  <- CustomFieldType.map(cf.`type`).setValue(CaseCustomField().order_=(order), customFieldValue)
      ccfe <- caseCustomFieldSrv.create(ccf, `case`, cf)
    } yield RichCustomField(cf, ccfe)

  def deleteCustomField(
      cfIdOrName: EntityIdOrName
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    Try(
      caseCustomFieldSrv
        .get(cfIdOrName)
        .filter(_.outV.v[Case])
        .remove()
    )

  def setImpactStatus(
      `case`: Case with Entity,
      impactStatus: String
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    impactStatusSrv.getOrFail(EntityIdOrName(impactStatus)).flatMap(setImpactStatus(`case`, _))

  def setImpactStatus(
      `case`: Case with Entity,
      impactStatus: ImpactStatus with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(`case`)
      .update(_.impactStatus, Some(impactStatus.value))
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .outE[CaseImpactStatus]
      .remove()
    caseImpactStatusSrv.create(CaseImpactStatus(), `case`, impactStatus)
    auditSrv.`case`.update(`case`, Json.obj("impactStatus" -> impactStatus.value))
  }

  def unsetImpactStatus(`case`: Case with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(`case`)
      .update(_.impactStatus, None)
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .outE[CaseImpactStatus]
      .remove()
    auditSrv.`case`.update(`case`, Json.obj("impactStatus" -> JsNull))
  }

  def setResolutionStatus(
      `case`: Case with Entity,
      resolutionStatus: String
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    resolutionStatusSrv.getOrFail(EntityIdOrName(resolutionStatus)).flatMap(setResolutionStatus(`case`, _))

  def setResolutionStatus(
      `case`: Case with Entity,
      resolutionStatus: ResolutionStatus with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(`case`)
      .update(_.resolutionStatus, Some(resolutionStatus.value))
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .outE[CaseResolutionStatus]
      .remove()
    caseResolutionStatusSrv.create(CaseResolutionStatus(), `case`, resolutionStatus)
    auditSrv.`case`.update(`case`, Json.obj("resolutionStatus" -> resolutionStatus.value))
  }

  def unsetResolutionStatus(`case`: Case with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(`case`)
      .update(_.resolutionStatus, None)
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .outE[CaseResolutionStatus]
      .remove()
    auditSrv.`case`.update(`case`, Json.obj("resolutionStatus" -> JsNull))
  }

  def assign(`case`: Case with Entity, user: User with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(`case`)
      .update(_.assignee, Some(user.login))
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .outE[CaseUser]
      .remove()
    caseUserSrv.create(CaseUser(), `case`, user)
    auditSrv.`case`.update(`case`, Json.obj("owner" -> user.login))
  }

  def unassign(`case`: Case with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(`case`)
      .update(_.assignee, None)
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .outE[CaseUser]
      .remove()
    auditSrv.`case`.update(`case`, Json.obj("owner" -> JsNull))
  }

  def merge(cases: Seq[Case with Entity])(implicit graph: Graph, authContext: AuthContext): Try[RichCase] =
    if (cases.size > 1 && canMerge(cases))
      auditSrv.mergeAudits {
        val mergedCase = Case(
          cases.map(_.title).mkString(" / "),
          cases.map(_.description).mkString("\n\n"),
          cases.map(_.severity).max,
          cases.map(_.startDate).min,
          None,
          cases.exists(_.flag),
          cases.map(_.tlp).max,
          cases.map(_.pap).max,
          CaseStatus.Open,
          cases.map(_.summary).fold(None)((s1, s2) => (s1 ++ s2).reduceOption(_ + "\n\n" + _)),
          cases.flatMap(_.tags).distinct
        )

        val allProfilesOrgas: Seq[(Profile with Entity, Organisation with Entity)] = get(cases.head)
          .shares
          .project(_.by(_.profile).by(_.organisation))
          .toSeq

        for {
          user        <- userSrv.current.getOrFail("User")
          currentOrga <- organisationSrv.current.getOrFail("Organisation")
          richCase    <- create(mergedCase, Some(user), currentOrga, Seq(), None, Seq())
          // Share case with all organisations except the one who created the merged case
          _ <-
            allProfilesOrgas
              .filterNot(_._2._id == currentOrga._id)
              .toTry(profileOrg => shareSrv.shareCase(owner = false, richCase.`case`, profileOrg._2, profileOrg._1))
          _ <- cases.toTry { c =>
            for {

              _ <- shareMergedCaseTasks(allProfilesOrgas.map(_._2), c, richCase.`case`)
              _ <- shareMergedCaseObservables(allProfilesOrgas.map(_._2), c, richCase.`case`)
              _ <-
                get(c)
                  .alert
                  .update(_.caseId, richCase._id)
                  .toSeq
                  .toTry(alertSrv.alertCaseSrv.create(AlertCase(), _, richCase.`case`))
              _ <-
                get(c)
                  .procedure
                  .toSeq
                  .toTry(caseProcedureSrv.create(CaseProcedure(), richCase.`case`, _))
              _ <-
                get(c)
                  .richCustomFields
                  .toSeq
                  .toTry(c => createCustomField(richCase.`case`, EntityIdOrName(c.customField.name), c.value, c.order))
            } yield Success(())
          }
          _ <- cases.toTry(super.delete(_))
        } yield richCase
      }(mergedCase =>
        auditSrv
          .`case`
          .merge(mergedCase.`case`, Some(Json.obj("cases" -> cases.map(c => Json.obj("_id" -> c._id, "number" -> c.number, "title" -> c.title)))))
      )
    else
      Failure(BadRequestError("To be able to merge, cases must have same organisation / profile pair and user must be org-admin"))

  private def canMerge(cases: Seq[Case with Entity])(implicit graph: Graph, authContext: AuthContext): Boolean = {
    val allOrgProfiles = getByIds(cases.map(_._id): _*)
      .flatMap(_.shares.project(_.by(_.profile.value(_.name)).by(_.organisation._id)).fold)
      .toSeq
      .map(_.toSet)
      .distinct

    // All cases must have the same organisation / profile pair &&
    // case organisation must match current organisation and be of org-admin profile
    allOrgProfiles.size == 1 && allOrgProfiles
      .head
      .exists {
        case (profile, orgId) => orgId == organisationSrv.currentId && profile == Profile.orgAdmin.name
      }
  }

  private def shareMergedCaseTasks(orgs: Seq[Organisation with Entity], fromCase: Case with Entity, mergedCase: Case with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    orgs
      .toTry { org =>
        get(fromCase)
          .share(org._id)
          .tasks
          .update(_.relatedId, mergedCase._id)
          .richTask
          .toSeq
          .toTry(shareSrv.shareTask(_, mergedCase, org._id))
      }
      .map(_ => ())

  private def shareMergedCaseObservables(orgs: Seq[Organisation with Entity], fromCase: Case with Entity, mergedCase: Case with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    orgs
      .toTry { org =>
        get(fromCase)
          .share(org._id)
          .observables
          .update(_.relatedId, mergedCase._id)
          .richObservable
          .toSeq
          .toTry(shareSrv.shareObservable(_, mergedCase, org._id))
      }
      .map(_ => ())
}

object CaseOps {

  implicit class CaseOpsDefs(traversal: Traversal.V[Case]) {

    def resolutionStatus: Traversal.V[ResolutionStatus] = traversal.out[CaseResolutionStatus].v[ResolutionStatus]

    def get(idOrName: EntityIdOrName): Traversal.V[Case] =
      idOrName.fold(traversal.getByIds(_), n => getByNumber(n.toInt))

    def getByNumber(caseNumber: Int): Traversal.V[Case] = traversal.has(_.number, caseNumber)

    def visible(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Case] =
      traversal.has(_.organisationIds, organisationSrv.currentId(traversal.graph, authContext))

    def assignee: Traversal.V[User] = traversal.out[CaseUser].v[User]

    def assignedTo(userLogin: String*): Traversal.V[Case] =
      if (userLogin.isEmpty) traversal.empty
      else if (userLogin.size == 1) traversal.has(_.assignee, userLogin.head)
      else traversal.has(_.assignee, P.within(userLogin: _*))

    def caseTemplate: Traversal.V[CaseTemplate] = traversal.out[CaseCaseTemplate].v[CaseTemplate]

    def can(permission: Permission)(implicit authContext: AuthContext): Traversal.V[Case] =
      if (authContext.permissions.contains(permission))
        traversal.filter(_.share.profile.has(_.permissions, permission))
      else
        traversal.empty

    def getLast: Traversal.V[Case] =
      traversal.sort(_.by("number", Order.desc)).limit(1)

    def richCaseWithCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Case] => Traversal[D, G, C]
    )(implicit authContext: AuthContext): Traversal[(RichCase, D), JMap[String, Any], Converter[(RichCase, D), JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.richCustomFields.fold)
            .by(entityRenderer)
            .by(_.userPermissions)
        )
        .domainMap {
          case (caze, customFields, renderedEntity, userPermissions) =>
            RichCase(
              caze,
              customFields,
              userPermissions
            ) -> renderedEntity
        }

    def customFields: Traversal.E[CaseCustomField] = traversal.outE[CaseCustomField]

    def customFields(idOrName: EntityIdOrName): Traversal.E[CaseCustomField] =
      idOrName
        .fold(
          id => customFields.filter(_.inV.getByIds(id)),
          name => customFields.filter(_.inV.v[CustomField].has(_.name, name))
        )

    def customFieldJsonValue(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName): Traversal.Domain[JsValue] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map(t => CustomFieldType.map(t).getJsonValue(traversal.customFields(customField)))
        .getOrElse(traversal.empty.castDomain)

    def richCustomFields: Traversal[RichCustomField, JMap[String, Any], Converter[RichCustomField, JMap[String, Any]]] =
      customFields
        .project(_.by.by(_.inV.v[CustomField]))
        .domainMap {
          case (cfv, cf) => RichCustomField(cf, cfv)
        }

    def customFieldFilter(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName, predicate: P[JsValue]): Traversal.V[Case] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map {
          case CustomFieldType.boolean =>
            traversal.filter(_.customFields.has(_.booleanValue, predicate.mapValue(_.as[Boolean])).inV.v[CustomField].get(customField))
          case CustomFieldType.date =>
            traversal.filter(_.customFields.has(_.dateValue, predicate.mapValue(_.as[Date])).inV.v[CustomField].get(customField))
          case CustomFieldType.float =>
            traversal.filter(_.customFields.has(_.floatValue, predicate.mapValue(_.as[Double])).inV.v[CustomField].get(customField))
          case CustomFieldType.integer =>
            traversal.filter(_.customFields.has(_.integerValue, predicate.mapValue(_.as[Int])).inV.v[CustomField].get(customField))
          case CustomFieldType.string =>
            traversal.filter(_.customFields.has(_.stringValue, predicate.mapValue(_.as[String])).inV.v[CustomField].get(customField))
        }
        .getOrElse(traversal.empty)

    def hasCustomField(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName): Traversal.V[Case] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map {
          case CustomFieldType.boolean => traversal.filter(_.customFields.has(_.booleanValue).inV.v[CustomField].get(customField))
          case CustomFieldType.date    => traversal.filter(_.customFields.has(_.dateValue).inV.v[CustomField].get(customField))
          case CustomFieldType.float   => traversal.filter(_.customFields.has(_.floatValue).inV.v[CustomField].get(customField))
          case CustomFieldType.integer => traversal.filter(_.customFields.has(_.integerValue).inV.v[CustomField].get(customField))
          case CustomFieldType.string  => traversal.filter(_.customFields.has(_.stringValue).inV.v[CustomField].get(customField))
        }
        .getOrElse(traversal.empty)

    def hasNotCustomField(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName): Traversal.V[Case] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map {
          case CustomFieldType.boolean => traversal.filterNot(_.customFields.has(_.booleanValue).inV.v[CustomField].get(customField))
          case CustomFieldType.date    => traversal.filterNot(_.customFields.has(_.dateValue).inV.v[CustomField].get(customField))
          case CustomFieldType.float   => traversal.filterNot(_.customFields.has(_.floatValue).inV.v[CustomField].get(customField))
          case CustomFieldType.integer => traversal.filterNot(_.customFields.has(_.integerValue).inV.v[CustomField].get(customField))
          case CustomFieldType.string  => traversal.filterNot(_.customFields.has(_.stringValue).inV.v[CustomField].get(customField))
        }
        .getOrElse(traversal.empty)

    def share(implicit authContext: AuthContext): Traversal.V[Share] = share(authContext.organisation)

    def share(organisation: EntityIdOrName): Traversal.V[Share] =
      shares.filter(_.organisation.get(organisation)).v[Share]

    def shares: Traversal.V[Share] = traversal.in[ShareCase].v[Share]

    def organisations: Traversal.V[Organisation] = traversal.in[ShareCase].in[OrganisationShare].v[Organisation]

    def organisations(permission: Permission): Traversal.V[Organisation] =
      shares.filter(_.profile.has(_.permissions, permission)).organisation

    def userPermissions(implicit authContext: AuthContext): Traversal[Set[Permission], JList[String], Converter[Set[Permission], JList[String]]] =
      traversal
        .share(authContext.organisation)
        .profile
        .value(_.permissions)
        .fold
        .domainMap(_.toSet & authContext.permissions)

    def origin: Traversal.V[Organisation] = shares.has(_.owner, true).organisation

//    def audits(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Audit] =
//      traversal
//        .unionFlat(_.visible(organisationSrv), _.observables(organisationIdOrName), _.tasks(organisationIdOrName), _.share(organisationIdOrName))
//        .in[AuditContext]
//        .v[Audit]

    def linkedCases(implicit
        authContext: AuthContext
    ): Traversal[(RichCase, Seq[RichObservable]), JMap[String, Any], Converter[(RichCase, Seq[RichObservable]), JMap[String, Any]]] = {
      val originCaseLabel = StepLabel.v[Case]
      val observableLabel = StepLabel.v[Observable] // TODO add similarity on attachment
      traversal
        .as(originCaseLabel)
        .observables
        .hasNot(_.ignoreSimilarity, true)
        .as(observableLabel)
        .data
        .observables
        .hasNot(_.ignoreSimilarity, true)
        .shares
        .filter(_.organisation.current)
        .`case`
        .where(P.neq(originCaseLabel.name))
        .group(_.by, _.by(_.select(observableLabel).richObservable.fold))
        .unfold
        .project(_.by(_.selectKeys.richCase).by(_.selectValues))
    }

    def isShared: Traversal[Boolean, Boolean, Converter.Identity[Boolean]] =
      traversal.choose(_.inE[ShareCase].count.is(P.gt(1)), true, false)

    def richCase(implicit authContext: AuthContext): Traversal[RichCase, JMap[String, Any], Converter[RichCase, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.richCustomFields.fold)
            .by(_.userPermissions)
        )
        .domainMap {
          case (caze, customFields, userPermissions) =>
            RichCase(
              caze,
              customFields,
              userPermissions
            )
        }

    def user: Traversal.V[User] = traversal.out[CaseUser].v[User]

    def richCaseWithoutPerms: Traversal[RichCase, JMap[String, Any], Converter[RichCase, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.richCustomFields.fold)
        )
        .domainMap {
          case (caze, customFields) =>
            RichCase(
              caze,
              customFields,
              Set.empty
            )
        }

    def tags: Traversal.V[Tag] = traversal.out[CaseTag].v[Tag]

    def impactStatus: Traversal.V[ImpactStatus] = traversal.out[CaseImpactStatus].v[ImpactStatus]

    def tasks(implicit authContext: AuthContext): Traversal.V[Task] = tasks(authContext.organisation)

    def tasks(organisationIdOrName: EntityIdOrName): Traversal.V[Task] =
      share(organisationIdOrName).tasks

    def observables(implicit authContext: AuthContext): Traversal.V[Observable] = observables(authContext.organisation)

    def observables(organisationIdOrName: EntityIdOrName): Traversal.V[Observable] =
      share(organisationIdOrName).observables

    def assignableUsers(implicit authContext: AuthContext): Traversal.V[User] =
      organisations(Permissions.manageCase)
        .visible
        .users(Permissions.manageCase)
        .dedup

    def alert: Traversal.V[Alert] = traversal.in[AlertCase].v[Alert]

    def procedure: Traversal.V[Procedure] = traversal.out[CaseProcedure].v[Procedure]

    def isActionRequired(implicit authContext: AuthContext): Traversal[Boolean, Boolean, Converter.Identity[Boolean]] =
      traversal.choose(_.share(authContext).outE[ShareTask].has(_.actionRequired, true), true, false)

    def handlingDuration: Traversal[Long, Long, IdentityConverter[Long]] =
      traversal.coalesceIdent(
        _.has(_.endDate)
          .sack(
            (_: JLong, importDate: JLong) => importDate,
            _.by(_.value(_.endDate).graphMap[Long, JLong, Converter[Long, JLong]](_.getTime, Converter.long))
          )
          .sack((_: Long) - (_: JLong), _.by(_._createdAt.graphMap[Long, JLong, Converter[Long, JLong]](_.getTime, Converter.long)))
          .sack[Long],
        _.constant(0L)
      )
  }
}

class CaseIntegrityCheck @Inject() (
    val db: Database,
    val service: CaseSrv,
    userSrv: UserSrv,
    caseTemplateSrv: CaseTemplateSrv,
    organisationSrv: OrganisationSrv,
    tagSrv: TagSrv
) extends DedupCheck[Case]
    with GlobalCheck[Case]
    with IntegrityCheckOps[Case] {

  override def resolve(entities: Seq[Case with Entity])(implicit graph: Graph): Try[Unit] = {
    EntitySelector
      .firstCreatedEntity(entities)
      .foreach(
        _._2
          .flatMap(service.get(_).setConverter[Vertex, Converter.Identity[Vertex]](Converter.identity).headOption)
          .foreach { vertex =>
            val nextNumber = service.nextCaseNumber
            UMapping.int.setProperty(vertex, "number", nextNumber)
          }
      )
    Success(())
  }

  override def globalCheck(traversal: Traversal.V[Case])(implicit graph: Graph): Map[String, Long] = {
    val assigneeCheck = singleOptionLink[User, String]("assignee", userSrv.getByName(_).head, _.login)(_.outEdge[CaseUser])
    val orgCheck      = multiIdLink[Organisation]("organisationIds", organisationSrv)(_.remove) // FIXME => Seq => Set
    val templateCheck =
      singleOptionLink[CaseTemplate, String]("caseTemplate", caseTemplateSrv.getByName(_).head, _.name)(_.outEdge[CaseCaseTemplate])
    val fixOwningOrg: LinkRemover =
      (caseId, orgId) => service.get(caseId).shares.filter(_.organisation.get(orgId._id)).update(_.owner, false).iterate()
    val owningOrgCheck = singleIdLink[Organisation]("owningOrganisation", organisationSrv)(_ => fixOwningOrg, _.remove)

    traversal
      .project(
        _.by
          .by(_.organisations._id.fold)
          .by(_.assignee.value(_.login).fold)
          .by(_.caseTemplate.value(_.name).fold)
          .by(_.origin._id.fold)
          .by(_.tags.fold)
      )
      .toIterator
      .map {
        case (case0, organisationIds, assignees, caseTemplateNames, owningOrganisationIds, tags) =>
          val assigneeStats  = assigneeCheck.check(case0, case0.assignee, assignees)
          val orgStats       = orgCheck.check(case0, case0.organisationIds, organisationIds)
          val templateStats  = templateCheck.check(case0, case0.caseTemplate, caseTemplateNames)
          val owningOrgStats = owningOrgCheck.check(case0, case0.owningOrganisation, owningOrganisationIds)
          val tagStats = {
            val caseTagSet = case0.tags.toSet
            val tagSet     = tags.map(_.toString).toSet
            if (caseTagSet == tagSet) Map.empty[String, Long]
            else {
              implicit val authContext: AuthContext =
                LocalUserSrv.getSystemAuthContext.changeOrganisation(case0.owningOrganisation, Permissions.all)

              val extraTagField = caseTagSet -- tagSet
              val extraTagLink  = tagSet -- caseTagSet
              extraTagField.flatMap(tagSrv.getOrCreate(_).toOption).foreach(service.caseTagSrv.create(CaseTag(), case0, _))
              service.get(case0).update(_.tags, case0.tags ++ extraTagLink).iterate()
              Map(
                "case-tags-extraField" -> extraTagField.size.toLong,
                "case-tags-extraLink"  -> extraTagLink.size.toLong
              )
            }
          }
          assigneeStats <+> orgStats <+> templateStats <+> owningOrgStats <+> tagStats
      }
      .reduceOption(_ <+> _)
      .getOrElse(Map.empty)
  }
}

```

`thehive/app/org/thp/thehive/services/CaseTemplateSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.apache.tinkerpop.gremlin.process.traversal.P
import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.query.PredicateOps.PredicateOpsDefs
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, StepLabel, Traversal}
import org.thp.scalligraph.{CreateError, EntityIdOrName, EntityName, RichSeq}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.CustomFieldOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.UserOps._
import play.api.libs.json.{JsObject, JsValue, Json}

import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Provider}
import scala.util.{Failure, Success, Try}

class CaseTemplateSrv @Inject() (
    customFieldSrv: CustomFieldSrv,
    organisationSrv: OrganisationSrv,
    tagSrv: TagSrv,
    taskSrv: TaskSrv,
    auditSrv: AuditSrv,
    integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]]
) extends VertexSrv[CaseTemplate] {
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  val caseTemplateTagSrv          = new EdgeSrv[CaseTemplateTag, CaseTemplate, Tag]
  val caseTemplateCustomFieldSrv  = new EdgeSrv[CaseTemplateCustomField, CaseTemplate, CustomField]
  val caseTemplateOrganisationSrv = new EdgeSrv[CaseTemplateOrganisation, CaseTemplate, Organisation]
  val caseTemplateTaskSrv         = new EdgeSrv[CaseTemplateTask, CaseTemplate, Task]

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[CaseTemplate] =
    startTraversal.getByName(name)

  override def createEntity(e: CaseTemplate)(implicit graph: Graph, authContext: AuthContext): Try[CaseTemplate with Entity] = {
    integrityCheckActor ! IntegrityCheck.EntityAdded("CaseTemplate")
    super.createEntity(e)
  }

  def create(
      caseTemplate: CaseTemplate,
      organisation: Organisation with Entity,
      tasks: Seq[Task],
      customFields: Seq[(String, Option[Any])]
  )(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichCaseTemplate] =
    if (organisationSrv.get(organisation).caseTemplates.get(EntityName(caseTemplate.name)).exists)
      Failure(CreateError(s"""The case template "${caseTemplate.name}" already exists"""))
    else
      for {
        createdCaseTemplate <- createEntity(caseTemplate)
        _                   <- caseTemplateOrganisationSrv.create(CaseTemplateOrganisation(), createdCaseTemplate, organisation)
        createdTasks        <- tasks.toTry(createTask(createdCaseTemplate, _))
        _                   <- caseTemplate.tags.toTry(tagSrv.getOrCreate(_).flatMap(t => caseTemplateTagSrv.create(CaseTemplateTag(), createdCaseTemplate, t)))
        cfs <- customFields.zipWithIndex.toTry {
          case ((name, value), order) => createCustomField(createdCaseTemplate, EntityIdOrName(name), value, Some(order + 1))
        }
        richCaseTemplate = RichCaseTemplate(createdCaseTemplate, organisation.name, createdTasks, cfs)
        _ <- auditSrv.caseTemplate.create(createdCaseTemplate, richCaseTemplate.toJson)
      } yield richCaseTemplate

  def createTask(caseTemplate: CaseTemplate with Entity, task: Task)(implicit graph: Graph, authContext: AuthContext): Try[RichTask] =
    for {
      assignee <- task.assignee.map(u => organisationSrv.current.users(Permissions.manageTask).getByName(u).getOrFail("User")).flip
      richTask <- taskSrv.create(task.copy(relatedId = caseTemplate._id, organisationIds = Set(organisationSrv.currentId)), assignee)
      _        <- caseTemplateTaskSrv.create(CaseTemplateTask(), caseTemplate, richTask.task)
      _        <- auditSrv.taskInTemplate.create(richTask.task, caseTemplate, richTask.toJson)
    } yield richTask

  override def update(
      traversal: Traversal.V[CaseTemplate],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[CaseTemplate], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (templateSteps, updatedFields) =>
        templateSteps
          .clone()
          .getOrFail("CaseTemplate")
          .flatMap(auditSrv.caseTemplate.update(_, updatedFields))
    }
  def updateTags(caseTemplate: CaseTemplate with Entity, tags: Set[String])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[(Seq[Tag with Entity], Seq[Tag with Entity])] =
    for {
      tagsToAdd <- (tags -- caseTemplate.tags).toTry(tagSrv.getOrCreate)
      tagsToRemove = get(caseTemplate).tags.toSeq.filterNot(t => tags.contains(t.toString))
      _ <- tagsToAdd.toTry(caseTemplateTagSrv.create(CaseTemplateTag(), caseTemplate, _))
      _ = if (tagsToRemove.nonEmpty) get(caseTemplate).outE[CaseTemplateTag].filter(_.otherV.hasId(tagsToRemove.map(_._id): _*)).remove()
      _ <- get(caseTemplate)
        .update(_.tags, tags.toSeq)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("CaseTemplate")
      _ <- auditSrv.caseTemplate.update(caseTemplate, Json.obj("tags" -> tags))
    } yield (tagsToAdd, tagsToRemove)

  def addTags(caseTemplate: CaseTemplate with Entity, tags: Set[String])(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    updateTags(caseTemplate, tags ++ caseTemplate.tags).map(_ => ())

  def getCustomField(caseTemplate: CaseTemplate with Entity, customFieldIdOrName: EntityIdOrName)(implicit graph: Graph): Option[RichCustomField] =
    get(caseTemplate).customFields(customFieldIdOrName).richCustomField.headOption

  def updateCustomField(
      caseTemplate: CaseTemplate with Entity,
      customFieldValues: Seq[(CustomField, Any, Option[Int])]
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val customFieldNames = customFieldValues.map(_._1.name)
    get(caseTemplate)
      .customFields
      .richCustomField
      .toIterator
      .filterNot(rcf => customFieldNames.contains(rcf.name))
      .foreach(rcf => get(caseTemplate).customFields(EntityName(rcf.name)).remove())
    customFieldValues
      .toTry { case (cf, v, o) => setOrCreateCustomField(caseTemplate, EntityName(cf.name), Some(v), o) }
      .map(_ => ())
  }

  def setOrCreateCustomField(caseTemplate: CaseTemplate with Entity, customFieldIdOrName: EntityIdOrName, value: Option[Any], order: Option[Int])(
      implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] = {
    val cfv = get(caseTemplate).customFields(customFieldIdOrName)
    if (cfv.clone().exists)
      cfv.setValue(value)
    else
      createCustomField(caseTemplate, customFieldIdOrName, value, order).map(_ => ())
  }

  def createCustomField(
      caseTemplate: CaseTemplate with Entity,
      customFieldIdOrName: EntityIdOrName,
      customFieldValue: Option[Any],
      order: Option[Int]
  )(implicit graph: Graph, authContext: AuthContext): Try[RichCustomField] =
    for {
      cf   <- customFieldSrv.getOrFail(customFieldIdOrName)
      ccf  <- CustomFieldType.map(cf.`type`).setValue(CaseTemplateCustomField(order = order), customFieldValue)
      ccfe <- caseTemplateCustomFieldSrv.create(ccf, caseTemplate, cf)
    } yield RichCustomField(cf, ccfe)
}

object CaseTemplateOps {
  implicit class CaseTemplateOpsDefs(traversal: Traversal.V[CaseTemplate]) {

    def get(idOrName: EntityIdOrName): Traversal.V[CaseTemplate] =
      idOrName.fold(traversal.getByIds(_), getByName)

    def getByName(name: String): Traversal.V[CaseTemplate] = traversal.has(_.name, name)

    def visible(implicit authContext: AuthContext): Traversal.V[CaseTemplate] =
      traversal.filter(_.organisation.current)

    def can(permission: Permission)(implicit authContext: AuthContext): Traversal.V[CaseTemplate] =
      if (authContext.permissions.contains(permission))
        traversal.filter(_.organisation.current)
      else
        traversal.empty

    def richCaseTemplate: Traversal[RichCaseTemplate, JMap[String, Any], Converter[RichCaseTemplate, JMap[String, Any]]] = {
      val caseTemplateCustomFieldLabel = StepLabel.e[CaseTemplateCustomField]
      val customFieldLabel             = StepLabel.v[CustomField]
      traversal
        .project(
          _.by
            .by(_.organisation.value(_.name))
            .by(_.tasks.richTaskWithoutActionRequired.fold)
            .by(
              _.outE[CaseTemplateCustomField]
                .as(caseTemplateCustomFieldLabel)
                .inV
                .v[CustomField]
                .as(customFieldLabel)
                .select((caseTemplateCustomFieldLabel, customFieldLabel))
                .fold
            )
        )
        .domainMap {
          case (caseTemplate, organisation, tasks, customFields) =>
            RichCaseTemplate(
              caseTemplate,
              organisation,
              tasks,
              customFields.map(cf => RichCustomField(cf._2, cf._1))
            )
        }
    }

    def organisation: Traversal.V[Organisation] = traversal.out[CaseTemplateOrganisation].v[Organisation]

    def tasks: Traversal.V[Task] = traversal.out[CaseTemplateTask].v[Task]

    def tags: Traversal.V[Tag] = traversal.out[CaseTemplateTag].v[Tag]

    def customFields(idOrName: EntityIdOrName): Traversal.E[CaseTemplateCustomField] =
      idOrName
        .fold(
          id => customFields.filter(_.inV.getByIds(id)),
          name => customFields.filter(_.inV.v[CustomField].has(_.name, name))
        )

    def customFields: Traversal.E[CaseTemplateCustomField] =
      traversal.outE[CaseTemplateCustomField]

    def customFieldJsonValue(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName): Traversal.Domain[JsValue] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map(t => CustomFieldType.map(t).getJsonValue(traversal.customFields(customField)))
        .getOrElse(traversal.empty.castDomain)

    def customFieldFilter(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName, predicate: P[JsValue]): Traversal.V[CaseTemplate] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map {
          case CustomFieldType.boolean =>
            traversal.filter(_.customFields.has(_.booleanValue, predicate.mapValue(_.as[Boolean])).inV.v[CustomField].get(customField))
          case CustomFieldType.date =>
            traversal.filter(_.customFields.has(_.dateValue, predicate.mapValue(_.as[Date])).inV.v[CustomField].get(customField))
          case CustomFieldType.float =>
            traversal.filter(_.customFields.has(_.floatValue, predicate.mapValue(_.as[Double])).inV.v[CustomField].get(customField))
          case CustomFieldType.integer =>
            traversal.filter(_.customFields.has(_.integerValue, predicate.mapValue(_.as[Int])).inV.v[CustomField].get(customField))
          case CustomFieldType.string =>
            traversal.filter(_.customFields.has(_.stringValue, predicate.mapValue(_.as[String])).inV.v[CustomField].get(customField))
        }
        .getOrElse(traversal.empty)

    def hasCustomField(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName): Traversal.V[CaseTemplate] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map {
          case CustomFieldType.boolean => traversal.filter(_.customFields.has(_.booleanValue).inV.v[CustomField].get(customField))
          case CustomFieldType.date    => traversal.filter(_.customFields.has(_.dateValue).inV.v[CustomField].get(customField))
          case CustomFieldType.float   => traversal.filter(_.customFields.has(_.floatValue).inV.v[CustomField].get(customField))
          case CustomFieldType.integer => traversal.filter(_.customFields.has(_.integerValue).inV.v[CustomField].get(customField))
          case CustomFieldType.string  => traversal.filter(_.customFields.has(_.stringValue).inV.v[CustomField].get(customField))
        }
        .getOrElse(traversal.empty)

    def hasNotCustomField(customFieldSrv: CustomFieldSrv, customField: EntityIdOrName): Traversal.V[CaseTemplate] =
      customFieldSrv
        .get(customField)(traversal.graph)
        .value(_.`type`)
        .headOption
        .map {
          case CustomFieldType.boolean => traversal.filterNot(_.customFields.has(_.booleanValue).inV.v[CustomField].get(customField))
          case CustomFieldType.date    => traversal.filterNot(_.customFields.has(_.dateValue).inV.v[CustomField].get(customField))
          case CustomFieldType.float   => traversal.filterNot(_.customFields.has(_.floatValue).inV.v[CustomField].get(customField))
          case CustomFieldType.integer => traversal.filterNot(_.customFields.has(_.integerValue).inV.v[CustomField].get(customField))
          case CustomFieldType.string  => traversal.filterNot(_.customFields.has(_.stringValue).inV.v[CustomField].get(customField))
        }
        .getOrElse(traversal.empty)
  }

  implicit class CaseTemplateCustomFieldsOpsDefs(traversal: Traversal.E[CaseTemplateCustomField]) extends CustomFieldValueOpsDefs(traversal)
}

class CaseTemplateIntegrityCheck @Inject() (
    val db: Database,
    val service: CaseTemplateSrv,
    organisationSrv: OrganisationSrv,
    tagSrv: TagSrv
) extends GlobalCheck[CaseTemplate]
    with DedupCheck[CaseTemplate]
    with IntegrityCheckOps[CaseTemplate] {
  override def findDuplicates(killSwitch: KillSwitch): Seq[Seq[CaseTemplate with Entity]] =
    db.roTransaction { implicit graph =>
      organisationSrv
        .startTraversal
        .flatMap(
          _.in[CaseTemplateOrganisation]
            .v[Organisation]
            .group(_.byValue(_.name), _.by(_._id.fold))
            .unfold
            .selectValues
            .where(_.localCount.is(P.gt(1)))
            .traversal
        )
        .domainMap(ids => service.getByIds(ids: _*).toSeq)
        .toIterator
        .takeWhile(_ => killSwitch.continueProcess)
        .toSeq
    }

  override def resolve(entities: Seq[CaseTemplate with Entity])(implicit graph: Graph): Try[Unit] = {
    entitySelector(entities).foreach {
      case (head, tail) =>
        tail.foreach(copyEdge(_, head, e => e.label() == "CaseCaseTemplate" || e.label() == "AlertCaseTemplate"))
        service.getByIds(tail.map(_._id): _*).remove()
    }
    Success(())
  }

  override def globalCheck(traversal: Traversal.V[CaseTemplate])(implicit graph: Graph): Map[String, Long] =
    traversal
      .project(_.by.by(_.organisation._id.fold).by(_.tags.fold))
      .toIterator
      .map {
        case (caseTemplate, organisationIds, tags) =>
          if (organisationIds.isEmpty) {
            service.get(caseTemplate).remove()
            Map("caseTemplate-orphans" -> 1L)
          } else {
            val orgStats = if (organisationIds.size > 1) {
              service.get(caseTemplate).out[CaseTemplateOrganisation].range(1, Int.MaxValue).remove()
              Map("caseTemplate-organisation-extraLink" -> organisationIds.size.toLong)
            } else Map.empty[String, Long]
            val tagStats = {
              val caseTemplateTagSet = caseTemplate.tags.toSet
              val tagSet             = tags.map(_.toString).toSet
              if (caseTemplateTagSet == tagSet) Map.empty[String, Long]
              else {
                implicit val authContext: AuthContext =
                  LocalUserSrv.getSystemAuthContext.changeOrganisation(organisationIds.head, Permissions.all)

                val extraTagField = caseTemplateTagSet -- tagSet
                val extraTagLink  = tagSet -- caseTemplateTagSet
                extraTagField
                  .flatMap(tagSrv.getOrCreate(_).toOption)
                  .foreach(service.caseTemplateTagSrv.create(CaseTemplateTag(), caseTemplate, _))
                service.get(caseTemplate).update(_.tags, caseTemplate.tags ++ extraTagLink).iterate()
                Map(
                  "caseTemplate-tags-extraField" -> extraTagField.size.toLong,
                  "caseTemplate-tags-extraLink"  -> extraTagLink.size.toLong
                )
              }
            }

            orgStats <+> tagStats
          }
      }
      .reduceOption(_ <+> _)
      .getOrElse(Map.empty)
}

```

`thehive/app/org/thp/thehive/services/ConfigContext.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services.config.ConfigContext
import play.api.libs.json.JsValue

import javax.inject.{Inject, Singleton}
import scala.util.Try

@Singleton
class UserConfigContext @Inject() (db: Database, configSrv: ConfigSrv) extends ConfigContext[AuthContext] {
  override def defaultPath(path: String): String = s"user.defaults.$path"

  override def getValue(context: AuthContext, path: String): Option[JsValue] =
    db.roTransaction { implicit graph =>
      configSrv
        .user
        .getConfigValue(EntityName(context.userId), path)
        .orElse(
          configSrv
            .organisation
            .getConfigValue(context.organisation, s"users.$path")
        )
        .map(_.value)
    }

  override def setValue(context: AuthContext, path: String, value: JsValue): Try[String] =
    db.tryTransaction(graph =>
      configSrv
        .user
        .setConfigValue(EntityName(context.userId), path, value)(graph, context)
        .map(_ => s"user.${context.userId}.$path")
    )
}

@Singleton
class OrganisationConfigContext @Inject() (db: Database, configSrv: ConfigSrv) extends ConfigContext[AuthContext] {
  override def defaultPath(path: String): String = s"organisation.defaults.$path"

  override def getValue(context: AuthContext, path: String): Option[JsValue] =
    db.roTransaction { implicit graph =>
      configSrv
        .organisation
        .getConfigValue(context.organisation, path)
        .orElse(
          configSrv
            .organisation
            .getConfigValue(EntityName("defaults"), path)
        )
        .map(_.value)
    }

  override def setValue(context: AuthContext, path: String, value: JsValue): Try[String] =
    db.tryTransaction(graph =>
      configSrv
        .organisation
        .setConfigValue(context.organisation, path, value)(graph, context)
        .map(_ => s"organisation.${context.organisation}.$path")
    )
}

```

`thehive/app/org/thp/thehive/services/ConfigSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services.{EdgeSrv, VertexSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, StepLabel, Traversal}
import org.thp.scalligraph.{EntityId, EntityIdOrName}
import org.thp.thehive.models._
import org.thp.thehive.services.ConfigOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services.notification.NotificationSrv
import org.thp.thehive.services.notification.triggers.Trigger
import play.api.libs.json.{JsValue, Reads}

import java.util.Date
import javax.inject.{Inject, Singleton}
import scala.util.Try

@Singleton
class ConfigSrv @Inject() (
    organisationSrv: OrganisationSrv,
    userSrv: UserSrv
)(implicit val db: Database)
    extends VertexSrv[Config] {
  val organisationConfigSrv = new EdgeSrv[OrganisationConfig, Organisation, Config]
  val userConfigSrv         = new EdgeSrv[UserConfig, User, Config]

  def triggerMap(notificationSrv: NotificationSrv)(implicit graph: Graph): Map[EntityId, Map[Trigger, (Boolean, Seq[EntityId])]] =
    startTraversal.triggerMap(notificationSrv)

  object organisation {

    def setConfigValue(organisationName: EntityIdOrName, name: String, value: JsValue)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
      getConfigValue(organisationName, name) match {
        case Some(config) =>
          get(config)
            .update(_.value, value)
            .update(_._updatedAt, Some(new Date))
            .update(_._updatedBy, Some(authContext.userId))
            .domainMap(_ => ())
            .getOrFail("Config")
        case None =>
          for {
            createdConfig <- createEntity(Config(name, value))
            organisation  <- organisationSrv.get(organisationName).getOrFail("Organisation")
            _             <- organisationConfigSrv.create(OrganisationConfig(), organisation, createdConfig)
          } yield ()
      }

    def getConfigValue(organisationName: EntityIdOrName, name: String)(implicit graph: Graph): Option[Config with Entity] =
      organisationSrv
        .get(organisationName)
        .config
        .has(_.name, name)
        .headOption
  }

  object user {

    def setConfigValue(userName: EntityIdOrName, name: String, value: JsValue)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
      getConfigValue(userName, name) match {
        case Some(config) =>
          get(config)
            .update(_.value, value)
            .update(_._updatedAt, Some(new Date))
            .update(_._updatedBy, Some(authContext.userId))
            .domainMap(_ => ())
            .getOrFail("Config")
        case None =>
          for {
            createdConfig <- createEntity(Config(name, value))
            user          <- userSrv.get(userName).getOrFail("User")
            _             <- userConfigSrv.create(UserConfig(), user, createdConfig)
          } yield ()
      }

    def getConfigValue(userName: EntityIdOrName, name: String)(implicit graph: Graph): Option[Config with Entity] =
      userSrv
        .get(userName)
        .config
        .has(_.name, name)
        .headOption
  }
}

object ConfigOps {

  implicit class ConfigOpsDefs(traversal: Traversal.V[Config]) {
    def triggerMap(notificationSrv: NotificationSrv): Map[EntityId, Map[Trigger, (Boolean, Seq[EntityId])]] = {

      // Traversal of configuration version of type "notification"
      def notificationRaw: Traversal.V[Config] =
        traversal
          .clone()
          .has(_.name, "notification")

      // Retrieve triggers configured for each organisation
      val organisationTriggers: Iterator[(EntityId, Trigger, Option[EntityId])] = {
        val configLabel         = StepLabel.v[Config]
        val organisationIdLabel = StepLabel[EntityId, AnyRef, Converter[EntityId, AnyRef]]
        for {
          (notifConfig, orgId) <-
            notificationRaw
              .as(configLabel)
              .in[OrganisationConfig]
              ._id
              .as(organisationIdLabel)
              .select((configLabel, organisationIdLabel))
              .toIterator
          //      cfg     <- notificationSrv.getConfig(notifConfig.value[String]("value"))
          //      trigger <- notificationSrv.getTrigger(cfg.triggerConfig).toOption
          trigger <- notificationSrv.getTriggers(notifConfig.value)
        } yield (orgId, trigger, None: Option[EntityId])
      }

      // Retrieve triggers configured for each user
      val userTriggers: Iterator[(EntityId, Trigger, Option[EntityId])] = {
        val configLabel         = StepLabel.v[Config]
        val userLabel           = StepLabel.v[User]
        val organisationIdLabel = StepLabel[EntityId, AnyRef, Converter[EntityId, AnyRef]]
        for {
          (notifConfig, user, orgId) <-
            notificationRaw
              .as(configLabel)
              .in[UserConfig]
              .v[User]
              .as(userLabel)
              .out[UserRole]
              .out[RoleOrganisation]
              ._id
              .as(organisationIdLabel)
              .select((configLabel, userLabel, organisationIdLabel))
              .toIterator
          trigger <- notificationSrv.getTriggers(notifConfig.value)
        } yield (orgId, trigger, Some(user._id))
      }

      (organisationTriggers ++ userTriggers)
        .toSeq
        .groupBy(_._1)
        .mapValues { tuple =>
          tuple
            .groupBy(_._2)
            .mapValues { tuple2 =>
              val inOrg   = tuple2.exists(_._3.isEmpty)
              val userIds = tuple2.flatMap(_._3.toSeq)
              (inOrg, userIds)
            }
        }
    }

    def getValue[A: Reads](name: String): Traversal[JsValue, String, Converter[JsValue, String]] = traversal.has(_.name, name).value(_.value)
  }
}

```

`thehive/app/org/thp/thehive/services/Connector.scala`:

```scala
package org.thp.thehive.services

import org.thp.thehive.models.HealthStatus
import play.api.libs.json.{JsObject, Json}

trait Connector {
  val name: String
  def status: JsObject           = Json.obj("enabled" -> true)
  def health: HealthStatus.Value = HealthStatus.Ok
}

```

`thehive/app/org/thp/thehive/services/CustomFieldSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.apache.tinkerpop.gremlin.structure.Edge
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services.{DedupCheck, VertexSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal._
import org.thp.scalligraph.{CreateError, EntityIdOrName, RichSeq}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.CustomFieldOps._
import play.api.cache.SyncCacheApi
import play.api.libs.json.{JsObject, JsValue}

import java.util.{Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Try}

@Singleton
class CustomFieldSrv @Inject() (
    auditSrv: AuditSrv,
    organisationSrv: OrganisationSrv,
    integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]],
    cacheApi: SyncCacheApi
) extends VertexSrv[CustomField] {
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  override def createEntity(e: CustomField)(implicit graph: Graph, authContext: AuthContext): Try[CustomField with Entity] = {
    integrityCheckActor ! IntegrityCheck.EntityAdded("CustomField")
    cacheApi.remove("describe.v0")
    cacheApi.remove("describe.v1")
    super.createEntity(e)
  }

  def create(e: CustomField)(implicit graph: Graph, authContext: AuthContext): Try[CustomField with Entity] =
    if (startTraversal.getByName(e.name).exists)
      Failure(CreateError(s"CustomField ${e.name} already exists"))
    else
      for {
        created <- createEntity(e)
        _       <- auditSrv.customField.create(created, created.toJson)
      } yield created

  override def exists(e: CustomField)(implicit graph: Graph): Boolean = startTraversal.getByName(e.name).exists

  def delete(c: CustomField with Entity, force: Boolean)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(c).remove() // TODO use force
    cacheApi.remove("describe.v0")
    cacheApi.remove("describe.v1")
    organisationSrv.getOrFail(authContext.organisation).flatMap { organisation =>
      auditSrv.customField.delete(c, organisation)
    }
  }

  def useCount(c: CustomField with Entity)(implicit graph: Graph): Map[String, Long] =
    get(c)
      .in()
      .groupCount(_.byLabel)
      .headOption
      .fold(Map.empty[String, Long])(_.filterNot(_._1 == "Audit"))

  override def update(
      traversal: Traversal.V[CustomField],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[CustomField], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (customFieldSteps, updatedFields) =>
        customFieldSteps
          .clone()
          .getOrFail("CustomFields")
          .flatMap { cf =>
            cacheApi.remove("describe.v0")
            cacheApi.remove("describe.v1")
            auditSrv.customField.update(cf, updatedFields)
          }
    }

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[CustomField] =
    startTraversal.getByName(name)
}

object CustomFieldOps {

  implicit class CustomFieldOpsDefs(traversal: Traversal.V[CustomField]) {
    def get(idOrName: EntityIdOrName): Traversal.V[CustomField] =
      idOrName.fold(traversal.getByIds(_), getByName)

    def getByName(name: String): Traversal.V[CustomField] = traversal.has(_.name, name)
  }

  implicit class CustomFieldValueOpsDefs[C <: CustomFieldValue[_]](traversal: Traversal.E[C]) {

    def setValue(value: Option[Any]): Try[Unit] = {
      val customFieldValueLabel = StepLabel.identity[Edge]
      val typeLabel             = StepLabel[CustomFieldType.Value, String, Converter[CustomFieldType.Value, String]]

      traversal
        .setConverter[Edge, Converter.Identity[Edge]](Converter.identity)
        .as(customFieldValueLabel)
        .inV
        .v[CustomField]
        .value(_.`type`)
        .as(typeLabel)
        .select((customFieldValueLabel, typeLabel))
        .toSeq
        .toTry {
          case (edge, typeName) =>
            val tpe = CustomFieldType.map(typeName)
            tpe.setValue(new CustomFieldValueEdge(edge), value)
        }
        .map(_ => ())
    }

    private def edgeNameType
        : Traversal[(Edge, String, CustomFieldType.Value), JMap[String, Any], Converter[(Edge, String, CustomFieldType.Value), JMap[String, Any]]] = {
      val customFieldValueLabel = StepLabel.identity[Edge]
      val nameLabel             = StepLabel.v[CustomField]
      val typeLabel             = StepLabel.v[CustomField]
      traversal
        .setConverter[Edge, Converter.Identity[Edge]](Converter.identity)
        .as(customFieldValueLabel)
        .inV
        .v[CustomField]
        .as(nameLabel, typeLabel)
        .select(_.apply(customFieldValueLabel)(_.by).apply(nameLabel)(_.byValue(_.name)).apply(typeLabel)(_.byValue(_.`type`)))
    }

    def nameJsonValue: Traversal[(String, JsValue), JMap[String, Any], Converter[(String, JsValue), JMap[String, Any]]] =
      edgeNameType
        .domainMap {
          case (edge, name, tpe) =>
            name -> CustomFieldType.map(tpe).getJsonValue(new CustomFieldValueEdge(edge))
        }

    def nameValue: Traversal[(String, Option[_]), JMap[String, Any], Converter[(String, Option[_]), JMap[String, Any]]] =
      edgeNameType
        .domainMap {
          case (edge, name, tpe) =>
            name -> CustomFieldType.map(tpe).getValue(new CustomFieldValueEdge(edge))
        }

    def selectValue: Traversal[Any, JMap[String, Any], Converter[Any, JMap[String, Any]]] =
      traversal.chooseValue(
        _.on(
          _.inV
            .v[CustomField]
            .value(_.`type`)
        ).option("boolean", _.value(_.booleanValue).widen[Any].setConverter[Any, Converter.Identity[Any]](Converter.identity[Any]))
          .option("date", _.value(_.dateValue).widen[Any].setConverter[Any, Converter.Identity[Any]](Converter.identity[Any]))
          .option("float", _.value(_.floatValue).widen[Any].setConverter[Any, Converter.Identity[Any]](Converter.identity[Any]))
          .option("integer", _.value(_.integerValue).widen[Any].setConverter[Any, Converter.Identity[Any]](Converter.identity[Any]))
          .option("string", _.value(_.stringValue).widen[Any].setConverter[Any, Converter.Identity[Any]](Converter.identity[Any]))
      )

//    def value: Traversal[Any, JMap[String, Any], Converter[Any, JMap[String, Any]]] =
//      edgeNameType
//        .map {
//          case (edge, _, tpe) =>
//            CustomFieldType.map(tpe).getValue(new CustomFieldValueEdge(edge)).getOrElse(JsNull)
//        }

    def richCustomField: Traversal[RichCustomField, JMap[String, Any], Converter[RichCustomField, JMap[String, Any]]] = {
      val customFieldValueLabel = StepLabel.identity[Edge]
      val customFieldLabel      = StepLabel.v[CustomField]
      traversal
        .setConverter[Edge, Converter.Identity[Edge]](Converter.identity)
        .as(customFieldValueLabel)
        .inV
        .v[CustomField]
        .as(customFieldLabel)
        .select((customFieldValueLabel, customFieldLabel))
        .domainMap {
          case (customFieldValue, customField) => RichCustomField(customField, new CustomFieldValueEdge(customFieldValue))
        }
    }

    //  def remove()     = raw.drop().i
  }

}

class CustomFieldIntegrityCheck @Inject() (val db: Database, val service: CustomFieldSrv) extends DedupCheck[CustomField]

```

`thehive/app/org/thp/thehive/services/DashboardSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import play.api.libs.json.{JsObject, Json}

import java.util.{Date, List => JList, Map => JMap}
import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

@Singleton
class DashboardSrv @Inject() (organisationSrv: OrganisationSrv, userSrv: UserSrv, auditSrv: AuditSrv) extends VertexSrv[Dashboard] {
  val organisationDashboardSrv = new EdgeSrv[OrganisationDashboard, Organisation, Dashboard]
  val dashboardUserSrv         = new EdgeSrv[DashboardUser, Dashboard, User]

  def create(dashboard: Dashboard)(implicit graph: Graph, authContext: AuthContext): Try[RichDashboard] =
    for {
      createdDashboard <- createEntity(dashboard)
      user             <- userSrv.current.getOrFail("User")
      _                <- dashboardUserSrv.create(DashboardUser(), createdDashboard, user)
      richDashboard = RichDashboard(createdDashboard, Map.empty, writable = true)
      _ <- auditSrv.dashboard.create(createdDashboard, richDashboard.toJson)
    } yield richDashboard

  override def update(
      traversal: Traversal.V[Dashboard],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[Dashboard], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (dashboardSteps, updatedFields) =>
        dashboardSteps
          .clone()
          .getOrFail("Dashboard")
          .flatMap(auditSrv.dashboard.update(_, updatedFields))
    }

  def share(dashboard: Dashboard with Entity, organisation: EntityIdOrName, writable: Boolean)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    organisationSrv.get(organisation).getOrFail("Organisation").flatMap { org =>
      get(dashboard)
        .inE[OrganisationDashboard]
        .filter(_.outV.v[Organisation].getEntity(org))
        .update(_.writable, writable)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .fold
        .getOrFail("Dashboard")
        .flatMap {
          case d if d.isEmpty =>
            organisationSrv
              .get(organisation)
              .getOrFail("Organisation")
              .flatMap(organisation => organisationDashboardSrv.create(OrganisationDashboard(writable), organisation, dashboard))
          case _ => Success(())
        }
        .flatMap { _ =>
          auditSrv.dashboard.update(dashboard, Json.obj("share" -> Json.obj("organisation" -> org.name, "writable" -> writable)))
        }
    }

  def unshare(dashboard: Dashboard with Entity, organisation: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(dashboard).inE[OrganisationDashboard].filter(_.outV.v[Organisation].get(organisation)).remove()
    Success(()) // TODO add audit
  }

  def remove(dashboard: Dashboard with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    organisationSrv.getOrFail(authContext.organisation).flatMap { organisation =>
      get(dashboard).remove()
      auditSrv.dashboard.delete(dashboard, organisation)
    }
}

object DashboardOps {

  implicit class DashboardOpsDefs(traversal: Traversal.V[Dashboard]) {

    def get(idOrName: EntityIdOrName): Traversal.V[Dashboard] =
      idOrName.fold(traversal.getByIds(_), _ => traversal.empty)

    def visible(implicit authContext: AuthContext): Traversal.V[Dashboard] =
      traversal.filter(_.or(_.user.current, _.organisation.current))

    def organisation: Traversal.V[Organisation] = traversal.in[OrganisationDashboard].v[Organisation]

    def user: Traversal.V[User] = traversal.out[DashboardUser].v[User]

    def canUpdate(implicit authContext: AuthContext): Traversal.V[Dashboard] =
      traversal.filter(
        _.or(_.user.current, _.inE[OrganisationDashboard].has(_.writable, true).outV.v[Organisation].current)
      )

    def organisationShares: Traversal[Seq[(String, Boolean)], JList[JMap[String, Any]], Converter[Seq[(String, Boolean)], JList[JMap[String, Any]]]] =
      traversal
        .inE[OrganisationDashboard]
        .project(
          _.byValue(_.writable)
            .by(_.outV)
        )
        .fold
        .domainMap(_.map { case (writable, orgs) => (orgs.value[String]("name"), writable) })

    def richDashboard(implicit authContext: AuthContext): Traversal[RichDashboard, JMap[String, Any], Converter[RichDashboard, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.organisationShares)
            .by(_.choose(_.canUpdate, true, false))
        )
        .domainMap {
          case (dashboard, organisationShares, writable) => RichDashboard(dashboard, organisationShares.toMap, writable)
        }

  }

}

```

`thehive/app/org/thp/thehive/services/DataSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.apache.tinkerpop.gremlin.process.traversal.P
import org.apache.tinkerpop.gremlin.structure.T
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.thehive.models._
import org.thp.thehive.services.DataOps._

import java.lang.{Long => JLong}
import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Success, Try}

@Singleton
class DataSrv @Inject() (integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]]) extends VertexSrv[Data] {
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  override def createEntity(e: Data)(implicit graph: Graph, authContext: AuthContext): Try[Data with Entity] =
    super.createEntity(e).map { data =>
      integrityCheckActor ! IntegrityCheck.EntityAdded("Data")
      data
    }

  def create(e: Data)(implicit graph: Graph, authContext: AuthContext): Try[Data with Entity] =
    startTraversal
      .getByData(e.data)
      .headOption
      .fold(createEntity(e))(Success(_))

  override def exists(e: Data)(implicit graph: Graph): Boolean = startTraversal.getByData(e.data).exists

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[Data] =
    startTraversal.getByData(name)
}

object DataOps {

  implicit class DataOpsDefs(traversal: Traversal.V[Data]) {
    def observables: Traversal.V[Observable] = traversal.in[ObservableData].v[Observable]

    def notShared(caseId: String): Traversal.V[Data] =
      traversal.filter(
        _.in[ObservableData]
          .in[ShareObservable]
          .out[ShareCase]
          .has(T.id, P.neq(caseId))
          .count
          .is(P.eq(0))
      )

    def getByData(data: String): Traversal.V[Data] = traversal.has(_.data, data)

    def useCount: Traversal[Long, JLong, Converter[Long, JLong]] = traversal.in[ObservableData].count
  }

}

class DataIntegrityCheck @Inject() (val db: Database, val service: DataSrv) extends DedupCheck[Data] with GlobalCheck[Data] {

  override def extraFilter(traversal: Traversal.V[Data]): Traversal.V[Data] = traversal.filterNot(_.inE[ObservableData])
  override def globalCheck(traversal: Traversal.V[Data])(implicit graph: Graph): Map[String, Long] =
    Map("orphan" -> traversal.sideEffect(_.drop()).getCount)
}

```

`thehive/app/org/thp/thehive/services/FlowActor.scala`:

```scala
package org.thp.thehive.services

import akka.actor.{Actor, ActorRef, ActorSystem, PoisonPill, Props}
import akka.cluster.singleton.{ClusterSingletonManager, ClusterSingletonManagerSettings, ClusterSingletonProxy, ClusterSingletonProxySettings}
import com.google.inject.Injector
import org.apache.tinkerpop.gremlin.process.traversal.{Order, P}
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services.EventSrv
import org.thp.scalligraph.services.config.ApplicationConfig.finiteDurationFormat
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.scalligraph.{EntityId, EntityIdOrName}
import org.thp.thehive.GuiceAkkaExtension
import org.thp.thehive.models.{Audit, AuditContext}
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.TaskOps._
import play.api.cache.SyncCacheApi

import java.util.Date
import javax.inject.{Inject, Provider, Singleton}
import scala.concurrent.duration.FiniteDuration

sealed trait FlowMessage
case class FlowId(caseId: Option[EntityIdOrName])(implicit val authContext: AuthContext) extends FlowMessage {
  def organisationId: Option[EntityId] = authContext.organisation.fold(Some(_), _ => None)
}
object FlowId {
  def toString(organisationId: EntityId, caseId: Option[EntityIdOrName]): String =
    s"$organisationId;${caseId.getOrElse("-")}"
}
case class AuditIds(ids: Seq[EntityId]) extends FlowMessage

class FlowActor extends Actor {

  lazy val injector: Injector               = GuiceAkkaExtension(context.system).injector
  lazy val cache: SyncCacheApi              = injector.getInstance(classOf[SyncCacheApi])
  lazy val auditSrv: AuditSrv               = injector.getInstance(classOf[AuditSrv])
  lazy val caseSrv: CaseSrv                 = injector.getInstance(classOf[CaseSrv])
  lazy val observableSrv: ObservableSrv     = injector.getInstance(classOf[ObservableSrv])
  lazy val organisationSrv: OrganisationSrv = injector.getInstance(classOf[OrganisationSrv])
  lazy val taskSrv: TaskSrv                 = injector.getInstance(classOf[TaskSrv])
  lazy val db: Database                     = injector.getInstance(classOf[Database])
  lazy val appConfig: ApplicationConfig     = injector.getInstance(classOf[ApplicationConfig])
  lazy val maxAgeConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("flow.maxAge", "Max age of audit logs shown in initial flow")
  def fromDate: Date = new Date(System.currentTimeMillis() - maxAgeConfig.get.toMillis)

  lazy val eventSrv: EventSrv   = injector.getInstance(classOf[EventSrv])
  override def preStart(): Unit = eventSrv.subscribe(StreamTopic.dispatcher, self)
  override def postStop(): Unit = eventSrv.unsubscribe(StreamTopic.dispatcher, self)

  def flowQuery(
      caseId: Option[EntityIdOrName]
  )(implicit graph: Graph, authContext: AuthContext): Traversal[EntityId, AnyRef, Converter[EntityId, AnyRef]] =
    caseId match {
      case None =>
        auditSrv
          .startTraversal
          .has(_.mainAction, true)
          .has(_._createdAt, P.gt(fromDate))
          .sort(_.by("_createdAt", Order.desc))
          .visible(organisationSrv)
          .limit(10)
          ._id
      case Some(cid) =>
        graph
          .union(
            caseSrv.filterTraversal(_).get(cid).visible(organisationSrv).in[AuditContext],
            observableSrv.filterTraversal(_).visible(organisationSrv).relatedTo(caseSrv.caseId(cid)).in[AuditContext],
            taskSrv.filterTraversal(_).visible(organisationSrv).relatedTo(caseSrv.caseId(cid)).in[AuditContext]
          )
          .v[Audit]
          .has(_.mainAction, true)
          .sort(_.by("_createdAt", Order.desc))
          .limit(10)
          ._id

    }

  override def receive: Receive = {
    case flowId: FlowId =>
      val organisationId = flowId.organisationId.getOrElse {
        db.roTransaction { implicit graph =>
          organisationSrv.currentId(graph, flowId.authContext)
        }
      }
      val auditIds = cache.getOrElseUpdate(FlowId.toString(organisationId, flowId.caseId)) {
        db.roTransaction { implicit graph =>
          flowQuery(flowId.caseId)(graph, flowId.authContext).toSeq
        }
      }
      sender ! AuditIds(auditIds)
    case AuditStreamMessage(ids @ _*) =>
      db.roTransaction { implicit graph =>
        auditSrv
          .getByIds(ids: _*)
          .has(_.mainAction, true)
          .project(
            _.by(_._id)
              .by(_.organisationIds.dedup().fold)
              .by(_.caseId.fold)
          )
          .toIterator
          .foreach {
            case (id, organisations, cases) =>
              organisations.foreach { organisation =>
                val cacheKey = FlowId.toString(organisation, None)
                val ids      = cache.get[Seq[String]](cacheKey).getOrElse(Nil)
                cache.set(cacheKey, (id +: ids).take(10))
                cases.foreach { caseId =>
                  val cacheKey: String = FlowId.toString(organisation, Some(caseId))
                  val ids              = cache.get[Seq[String]](cacheKey).getOrElse(Nil)
                  cache.set(cacheKey, (id +: ids).take(10))
                }
              }
          }
      }
    case _ =>
  }
}

@Singleton
class FlowActorProvider @Inject() (system: ActorSystem) extends Provider[ActorRef] {
  override lazy val get: ActorRef = {
    val singletonManager =
      system.actorOf(
        ClusterSingletonManager.props(
          singletonProps = Props[FlowActor],
          terminationMessage = PoisonPill,
          settings = ClusterSingletonManagerSettings(system)
        ),
        name = "flowSingletonManager"
      )

    system.actorOf(
      ClusterSingletonProxy.props(
        singletonManagerPath = singletonManager.path.toStringWithoutAddress,
        settings = ClusterSingletonProxySettings(system)
      ),
      name = "flowSingletonProxy"
    )
  }
}

```

`thehive/app/org/thp/thehive/services/FlowSerializer.scala`:

```scala
package org.thp.thehive.services

import akka.serialization.Serializer
import org.thp.scalligraph.auth.{AuthContextImpl, Permission}
import org.thp.scalligraph.{EntityId, EntityIdOrName}
import play.api.libs.json._

import java.io.NotSerializableException

class FlowSerializer extends Serializer {
  override def identifier: Int = -1165729876

  override def includeManifest: Boolean = false

  def readFlowId(input: String): FlowId = {
    val json = Json.parse(input)
    FlowId((json \ "caseId").asOpt[String].map(EntityIdOrName.apply))(
      AuthContextImpl(
        (json \ "userId").as[String],
        (json \ "userName").as[String],
        EntityIdOrName((json \ "organisation").as[String]),
        (json \ "requestId").as[String],
        (json \ "permissions").as[Set[String]].map(Permission.apply)
      )
    )
  }
  def writeFlowId(flowId: FlowId): JsObject =
    Json.obj(
      "caseId"       -> flowId.caseId.fold[JsValue](JsNull)(c => JsString(c.toString)),
      "userId"       -> flowId.authContext.userId,
      "userName"     -> flowId.authContext.userName,
      "organisation" -> flowId.authContext.organisation.toString,
      "requestId"    -> flowId.authContext.requestId,
      "permissions"  -> flowId.authContext.permissions
    )

  override def toBinary(o: AnyRef): Array[Byte] =
    o match {
      case f: FlowId     => 0.toByte +: writeFlowId(f).toString().getBytes
      case AuditIds(ids) => 1.toByte +: ids.map(_.value).mkString("|").getBytes
      case _             => throw new NotSerializableException
    }

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef =
    bytes(0) match {
      case 0 => readFlowId(new String(bytes.tail))
      case 1 => AuditIds(new String(bytes.tail).split('|').toSeq.map(EntityId.apply))
      case _ => throw new NotSerializableException
    }
}

```

`thehive/app/org/thp/thehive/services/ImpactStatusSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services.{DedupCheck, EntitySelector, IntegrityCheckOps, VertexSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.scalligraph.{CreateError, EntityIdOrName}
import org.thp.thehive.models.ImpactStatus
import org.thp.thehive.services.ImpactStatusOps._

import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class ImpactStatusSrv @Inject() (integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]]) extends VertexSrv[ImpactStatus] {
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[ImpactStatus] =
    startTraversal.getByName(name)

  override def createEntity(e: ImpactStatus)(implicit graph: Graph, authContext: AuthContext): Try[ImpactStatus with Entity] = {
    integrityCheckActor ! IntegrityCheck.EntityAdded("ImpactStatus")
    super.createEntity(e)
  }

  def create(impactStatus: ImpactStatus)(implicit graph: Graph, authContext: AuthContext): Try[ImpactStatus with Entity] =
    if (exists(impactStatus))
      Failure(CreateError(s"Impact status ${impactStatus.value} already exists"))
    else
      createEntity(impactStatus)

  override def exists(e: ImpactStatus)(implicit graph: Graph): Boolean = startTraversal.getByName(e.value).exists
}

object ImpactStatusOps {
  implicit class ImpactStatusOpsDefs(traversal: Traversal.V[ImpactStatus]) {
    def get(idOrName: EntityIdOrName): Traversal.V[ImpactStatus] =
      idOrName.fold(traversal.getByIds(_), getByName)

    def getByName(name: String): Traversal.V[ImpactStatus] = traversal.has(_.value, name)
  }
}

class ImpactStatusIntegrityCheck @Inject() (val db: Database, val service: ImpactStatusSrv) extends DedupCheck[ImpactStatus]

```

`thehive/app/org/thp/thehive/services/IntegrityCheckActor.scala`:

```scala
package org.thp.thehive.services

import akka.actor.ActorSystem
import akka.actor.typed._
import akka.actor.typed.scaladsl.adapter.ClassicActorSystemOps
import akka.actor.typed.scaladsl.{Behaviors, TimerScheduler}
import akka.cluster.typed.{ClusterSingleton, SingletonActor}
import org.quartz
import org.quartz._
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.services.config.ApplicationConfig.finiteDurationFormat
import org.thp.scalligraph.services.{DedupCheck, GlobalCheck, IntegrityCheck, KillSwitch}
import org.thp.scalligraph.utils.FunctionalCondition.When
import play.api.Logger
import play.api.libs.json._

import javax.inject.{Inject, Provider, Singleton}
import scala.collection.immutable
import scala.concurrent.duration.{DurationDouble, DurationLong, FiniteDuration}
import scala.util.{Success, Try}

case class CheckStats(global: Map[String, Long], last: Map[String, Long], lastDate: Long) {
  def +(stats: Map[String, Long]): CheckStats = {
    val mergedMap = (stats.keySet ++ global.keySet).map(k => k -> (global.getOrElse(k, 0L) + stats.getOrElse(k, 0L))).toMap
    CheckStats(mergedMap + ("iteration" -> (mergedMap.getOrElse("iteration", 0L) + 1)), stats, System.currentTimeMillis())
  }
}
object CheckState {
  val empty: CheckState = {
    val emptyStats = CheckStats(Map.empty, Map.empty, 0L)
    CheckState(
      needCheck = false,
      None,
      dedupRequested = false,
      dedupIsRunning = false,
      emptyStats,
      globalCheckRequested = false,
      globalCheckIsRunning = false,
      emptyStats
    )
  }
}
case class CheckState(
    needCheck: Boolean,
    dedupTimer: Option[AnyRef],
    dedupRequested: Boolean,
    dedupIsRunning: Boolean,
    dedupStats: CheckStats,
    globalCheckRequested: Boolean,
    globalCheckIsRunning: Boolean,
    globalStats: CheckStats
)

case class IntegrityCheckGlobalConfig(
    enabled: Boolean,
    schedule: String,
    maxDuration: FiniteDuration,
    integrityCheckConfig: Map[String, IntegrityCheckConfig]
)
object IntegrityCheckGlobalConfig {
  implicit val format: OFormat[IntegrityCheckGlobalConfig] = Json.format[IntegrityCheckGlobalConfig]
}

sealed trait DedupStrategy
object DedupStrategy {
  final case object AfterAddition                      extends DedupStrategy
  final case object DuringGlobalChecks                 extends DedupStrategy
  final case object AfterAdditionAndDuringGlobalChecks extends DedupStrategy
  final case object Disable                            extends DedupStrategy
  implicit val reads: Reads[DedupStrategy] = Reads.StringReads.flatMap {
    case "AfterAddition"                      => Reads.pure(AfterAddition)
    case "DuringGlobalChecks"                 => Reads.pure(DuringGlobalChecks)
    case "AfterAdditionAndDuringGlobalChecks" => Reads.pure(AfterAdditionAndDuringGlobalChecks)
    case "Disable"                            => Reads.pure(Disable)
    case other                                => Reads.failed(s"Dedup strategy `$other` is not recognised (accepted: AfterAddition, DuringGlobalChecks and Disable)")
  }
  implicit val writes: Writes[DedupStrategy] = Writes[DedupStrategy](s => JsString(s.toString))
}
case class IntegrityCheckConfig(
    enabled: Boolean,
    minTime: Option[FiniteDuration],
    maxTime: Option[FiniteDuration],
    dedupStrategy: DedupStrategy,
    initialDelay: FiniteDuration,
    minInterval: FiniteDuration
)
object IntegrityCheckConfig {
  implicit val format: OFormat[IntegrityCheckConfig] = Json.format[IntegrityCheckConfig]
}

object IntegrityCheck {
  private val logger = Logger(getClass)

  sealed trait Message
  sealed trait Request         extends Message
  sealed trait Response        extends Message
  sealed trait InternalMessage extends Request

  case class EntityAdded(name: String)                                             extends Request
  case class NeedCheck(name: String)                                               extends InternalMessage
  case class CheckRequest(name: String, dedup: Boolean, global: Boolean)           extends Request
  case class GetAllCheckStats(replyTo: ActorRef[AllCheckStats])                    extends Request
  case class AllCheckStats(stats: Map[String, Map[String, Long]])                  extends Response
  case class StartDedup(name: String)                                              extends InternalMessage
  case class FinishDedup(name: String, cancel: Boolean, stats: Map[String, Long])  extends InternalMessage
  case class StartGlobal(name: String)                                             extends InternalMessage
  case class FinishGlobal(name: String, cancel: Boolean, stats: Map[String, Long]) extends InternalMessage
  case object CancelCheck                                                          extends Request

  private val jobKey             = JobKey.jobKey("IntegrityCheck")
  private val triggerKey         = TriggerKey.triggerKey("IntegrityCheck")
  private val checksContextKey   = "IntegrityCheck-checks"
  private val configContextKey   = "IntegrityCheck-config"
  private val actorRefContextKey = "IntegrityCheck-actor"

  def behavior(
      db: Database,
      quartzScheduler: quartz.Scheduler,
      appConfig: ApplicationConfig,
      integrityChecks: Seq[IntegrityCheck]
  ): Behavior[Request] =
    Behaviors.setup[Request] { context =>
      Behaviors.withTimers[Request] { timers =>
        val configItem: ConfigItem[IntegrityCheckGlobalConfig, IntegrityCheckGlobalConfig] = appConfig.validatedItem[IntegrityCheckGlobalConfig](
          "integrityCheck",
          "Integrity check config",
          config =>
            Try {
              CronScheduleBuilder.cronSchedule(config.schedule)
              config
            }
        )

        db.tryTransaction { implicit graph =>
          implicit val authContext: AuthContext = LocalUserSrv.getSystemAuthContext
          integrityChecks.foreach(_.initialCheck())
          Success(())
        }
        setupScheduling(context.self, quartzScheduler, integrityChecks, configItem)
        behavior(context.self, quartzScheduler, configItem, timers, integrityChecks.map(_.name))
      }
    }

  private def behavior(
      self: ActorRef[IntegrityCheck.Request],
      quartzScheduler: quartz.Scheduler,
      configItem: ConfigItem[IntegrityCheckGlobalConfig, IntegrityCheckGlobalConfig],
      timers: TimerScheduler[Request],
      checkNames: Seq[String]
  ): Behavior[Request] = {
    def onMessage(states: Map[String, CheckState]): Behavior[IntegrityCheck.Request] =
      Behaviors
        .receiveMessage[Request] {
          case EntityAdded(name) =>
            logger.debug(s"An entity $name has been created")
            configItem.get.integrityCheckConfig.get(name).foreach {
              case cfg if cfg.dedupStrategy == DedupStrategy.AfterAddition || cfg.dedupStrategy == DedupStrategy.AfterAdditionAndDuringGlobalChecks =>
                timers.startSingleTimer(NeedCheck(name), cfg.initialDelay)
            }
            Behaviors.same

          case NeedCheck(name) =>
            val state   = states.getOrElse(name, CheckState.empty)
            val configs = configItem.get.integrityCheckConfig
            val cfg     = configs.getOrElse(name, configs("default"))
            if (state.dedupTimer.isEmpty) {
              val checkRequest = CheckRequest(name, dedup = true, global = false)
              self ! checkRequest
              val timer = new AnyRef
              timers.startTimerWithFixedDelay(timer, checkRequest, cfg.minInterval)
              onMessage(states + (name -> state.copy(needCheck = true, dedupTimer = Some(timer))))
            } else if (!state.needCheck)
              onMessage(states + (name -> state.copy(needCheck = true)))
            else Behaviors.same[Request]

          case CheckRequest(name, dedup, global) =>
            val state         = states.getOrElse(name, CheckState.empty)
            val dedupRequest  = dedup && !state.dedupRequested
            val globalRequest = global && !state.globalCheckRequested
            if (dedupRequest || globalRequest) {
              val trigger = TriggerBuilder
                .newTrigger()
                .withIdentity(s"$triggerKey-$name${if (dedupRequest) "-dedup" else ""}${if (globalRequest) "-global" else ""}")
                .startNow()
                .forJob(jobKey)
                .usingJobData("name", name)
                .usingJobData("dedup", dedupRequest)
                .usingJobData("global", globalRequest)
                .build()
              val nextRun = quartzScheduler.scheduleJob(trigger)
              logger.info(
                s"Integrity check on $name ${if (dedupRequest) "( dedup" else "("}${if (globalRequest) " global )" else " )"}: job scheduled, it will start at $nextRun"
              )

              onMessage(
                states + (name -> state
                  .copy(dedupRequested = state.dedupRequested || dedupRequest, globalCheckRequested = state.globalCheckRequested || globalRequest))
              )
            } else {
              logger.info(s"Integrity check on $name ignore because a job is already pending")
              onMessage(states)
            }
          case StartDedup(name) =>
            logger.info(s"Start of deduplication of $name")
            val state = states.getOrElse(name, CheckState.empty)
            onMessage(states + (name -> state.copy(needCheck = false, dedupIsRunning = true)))
          case FinishDedup(name, cancel, result) =>
            logger.info(s"End of deduplication of $name${if (cancel) " (cancelled)" else ""}:${result.map(kv => s"\n  ${kv._1}: ${kv._2}").mkString}")
            val state    = states.getOrElse(name, CheckState.empty)
            val newState = state.copy(dedupStats = state.dedupStats + result, dedupIsRunning = false)

            if (state.needCheck) onMessage(states + (name -> newState))
            else {
              state.dedupTimer.foreach(timers.cancel)
              onMessage(states + (name -> newState.copy(dedupTimer = None, dedupRequested = false)))
            }
          case StartGlobal(name) =>
            logger.info(s"Start of global check of $name")
            val state = states.getOrElse(name, CheckState.empty)
            onMessage(states + (name -> state.copy(globalCheckIsRunning = true)))
          case FinishGlobal(name, cancel, result) =>
            logger.info(s"End of global check of $name${if (cancel) " (cancelled)" else ""}:${result.map(kv => s"\n  ${kv._1}: ${kv._2}").mkString}")
            val state    = states.getOrElse(name, CheckState.empty)
            val newState = state.copy(globalStats = state.globalStats + result, globalCheckRequested = false, globalCheckIsRunning = false)
            onMessage(states + (name -> newState))

          case CancelCheck =>
            quartzScheduler.interrupt(jobKey)
            Behaviors.same

          case GetAllCheckStats(replyTo) =>
            val state = states.mapValues { s =>
              Map(
                "needCheck"            -> (if (s.needCheck) 1L else 0L),
                "dedupTimer"           -> s.dedupTimer.fold(0L)(_ => 1L),
                "dedupRequested"       -> (if (s.dedupRequested) 1L else 0L),
                "dedupIsRunning"       -> (if (s.dedupIsRunning) 1L else 0L),
                "globalCheckRequested" -> (if (s.globalCheckRequested) 1L else 0L),
                "globalCheckIsRunning" -> (if (s.globalCheckIsRunning) 1L else 0L)
              ) ++
                s.globalStats.global.map { case (k, v) => s"global.$k" -> v } ++
                s.globalStats.last.map {
                  case (k, v) => s"globalLast.$k" -> v
                } +
                ("globalLastDate" -> s.globalStats.lastDate) ++
                s.dedupStats.global.map { case (k, v) => s"dedup.$k" -> v } ++
                s.dedupStats.last.map {
                  case (k, v) => s"dedupLast.$k" -> v
                } +
                ("dedupLastDate" -> s.dedupStats.lastDate)
            }

            replyTo ! AllCheckStats(state)
            Behaviors.same
        }
        .receiveSignal {
          case (_, PostStop) =>
            quartzScheduler.interrupt(jobKey)
            quartzScheduler.deleteJob(jobKey)
            logger.info("Remove integrity check job")
            Behaviors.same
        }

    onMessage(checkNames.map(_ -> CheckState.empty).toMap)

  }

  private def setupScheduling(
      integrityCheckActorRef: ActorRef[IntegrityCheck.Request],
      quartzScheduler: quartz.Scheduler,
      integrityChecks: Seq[IntegrityCheck],
      configItem: ConfigItem[IntegrityCheckGlobalConfig, IntegrityCheckGlobalConfig]
  ): Unit = {
    logger.debug("Setting up Integrity check actor with its schedule")
    quartzScheduler.addJob(job(), true)
    quartzScheduler.getContext.put(checksContextKey, integrityChecks)
    quartzScheduler.getContext.put(configContextKey, configItem)
    quartzScheduler.getContext.put(actorRefContextKey, integrityCheckActorRef)

    configItem.onUpdate { (_, newConfig) =>
      if (newConfig.enabled) {
        val trigger = jobTrigger(newConfig.schedule, newConfig.maxDuration)
        val nextRun = Option(quartzScheduler.getTrigger(triggerKey)) match {
          case Some(_) => quartzScheduler.rescheduleJob(triggerKey, trigger)
          case None    => quartzScheduler.scheduleJob(trigger)
        }
        logger.info(s"Config updated, will run next integrity checks at $nextRun")
      } else {
        quartzScheduler.unscheduleJob(triggerKey)
        logger.info("Config updated, removing scheduling for integrity check job")
      }
    }

    val initConfig = configItem.get
    if (initConfig.enabled) {
      val trigger = jobTrigger(initConfig.schedule, initConfig.maxDuration)
      val nextRun = quartzScheduler.scheduleJob(trigger)
      logger.info(s"Integrity checks is enabled and will start at $nextRun")
    } else
      logger.info("Integrity checks is disabled")
  }

  private def job() =
    JobBuilder
      .newJob()
      .ofType(classOf[RunJob])
      .withIdentity(jobKey)
      .storeDurably()
      .build()

  private def jobTrigger(cronExpression: String, maxDuration: FiniteDuration) =
    TriggerBuilder
      .newTrigger()
      .withIdentity(triggerKey)
      .usingJobData("maxDuration", java.lang.Long.valueOf(maxDuration.toMillis))
      .withSchedule(CronScheduleBuilder.cronSchedule(cronExpression))
      .forJob(jobKey)
      .build()

  @DisallowConcurrentExecution
  private class RunJob extends Job with InterruptableJob with KillSwitch {
    override def interrupt(): Unit = {
      logger.info("Cancellation of check job has been requested")
      _continueProcess = false
    }
    override def reset(): Unit            = _continueProcess = true
    override def continueProcess: Boolean = _continueProcess
    private var _continueProcess          = true

    def runDedup(
        integrityCheckActor: ActorRef[IntegrityCheck.Request],
        integrityChecks: Seq[IntegrityCheck],
        name: String
    ): Unit = {
      integrityCheckActor ! IntegrityCheck.StartDedup(name)
      val startDate = System.currentTimeMillis()
      val result = integrityChecks
        .collectFirst {
          case dc: DedupCheck[_] if dc.name == name => dc
        }
        .fold(Map("checkNotFound" -> 1L))(_.dedup(killSwitch = this))
      val duration = System.currentTimeMillis() - startDate
      if (continueProcess)
        integrityCheckActor ! FinishDedup(name, cancel = false, result + ("duration" -> duration))
      else {
        reset()
        integrityCheckActor ! FinishDedup(name, cancel = true, result + ("duration" -> duration))
      }
    }

    def runGlobal(
        integrityCheckActor: ActorRef[IntegrityCheck.Request],
        integrityChecks: Seq[IntegrityCheck],
        name: String,
        maxDuration: FiniteDuration
    ): Unit = {
      integrityCheckActor ! IntegrityCheck.StartGlobal(name)
      val result = integrityChecks
        .collectFirst {
          case gc: GlobalCheck[_] if gc.name == name => gc
        }
        .fold(Map("checkNotFound" -> 1L))(_.runGlobalCheck(maxDuration, killSwitch = this))
      if (continueProcess)
        integrityCheckActor ! FinishGlobal(name, cancel = false, result)
      else {
        reset()
        integrityCheckActor ! FinishGlobal(name, cancel = true, result)
      }
    }

    def getConfig(config: IntegrityCheckGlobalConfig, name: String): IntegrityCheckConfig =
      config.integrityCheckConfig.getOrElse(name, config.integrityCheckConfig("default"))

    def runBoth(
        config: IntegrityCheckGlobalConfig,
        integrityCheckActor: ActorRef[IntegrityCheck.Request],
        integrityChecks: Seq[IntegrityCheck],
        name: String,
        maxDuration: FiniteDuration
    ): Unit = {
      val cfg = getConfig(config, name)
      runGlobal(integrityCheckActor, integrityChecks, name, maxDuration.merge(cfg.maxTime)(min).merge(cfg.minTime)(max))
      if (cfg.dedupStrategy == DedupStrategy.DuringGlobalChecks || cfg.dedupStrategy == DedupStrategy.AfterAdditionAndDuringGlobalChecks)
        runDedup(integrityCheckActor, integrityChecks, name)
    }

    def max(a: FiniteDuration, b: FiniteDuration): FiniteDuration = if (a < b) b else a

    def min(a: FiniteDuration, b: FiniteDuration): FiniteDuration = if (a > b) b else a

    override def execute(context: JobExecutionContext): Unit = {
      reset()
      val integrityChecks = context.getScheduler.getContext.get(checksContextKey).asInstanceOf[Seq[IntegrityCheck]]
      val configItem =
        context.getScheduler.getContext.get(configContextKey).asInstanceOf[ConfigItem[IntegrityCheckGlobalConfig, IntegrityCheckGlobalConfig]]
      val integrityCheckActor = context.getScheduler.getContext.get(actorRefContextKey).asInstanceOf[ActorRef[IntegrityCheck.Request]]
      val jobData             = context.getMergedJobDataMap
      val maxDuration         = jobData.get("maxDuration").asInstanceOf[Long]

      if (jobData.containsKey("name")) {
        val name   = jobData.get("name").asInstanceOf[String]
        val dedup  = if (jobData.containsKey("dedup")) jobData.get("dedup").asInstanceOf[Boolean] else true
        val global = if (jobData.containsKey("global")) jobData.get("global").asInstanceOf[Boolean] else true
        if (dedup) runDedup(integrityCheckActor, integrityChecks, name)
        if (global) runGlobal(integrityCheckActor, integrityChecks, name, 24.hours)
      } else {
        val config: IntegrityCheckGlobalConfig = configItem.get
        val enabledChecks                      = integrityChecks.filter(c => getConfig(config, c.name).enabled)
        if (config.enabled && enabledChecks.nonEmpty) {
          val startAt = System.currentTimeMillis()
          val checksWithPerf = enabledChecks.collect {
            case c: GlobalCheck[_] => (c, c.getPerformanceIndicator)
          }
          val avg1 = (maxDuration / enabledChecks.size).millis
          // checks are quick if they have finished the process of all the dataset in one turn
          val (quickChecks, otherChecks) = checksWithPerf.partition(p => p._2.period.isEmpty && p._2.duration.isDefined)
          quickChecks.foreach(c => runBoth(config, integrityCheckActor, enabledChecks, c._1.name, avg1))
          val remainingTime1 = maxDuration - (System.currentTimeMillis - startAt)
          // checks are known if there is performance indicator (period and duration)
          if (otherChecks.nonEmpty) {
            val (knownChecks, unknownChecks) = otherChecks.partition(p => p._2.duration.exists(_ > 0) && p._2.period.exists(_ > 0))
            val avg2                         = remainingTime1 / otherChecks.size
            unknownChecks.foreach(c => runBoth(config, integrityCheckActor, enabledChecks, c._1.name, avg2.millis))
            val remainingTime2 = maxDuration - (System.currentTimeMillis - startAt)
            val sum            = knownChecks.map(c => c._2.duration.get.toDouble / c._2.period.get).sum
            knownChecks.foreach(c =>
              runBoth(config, integrityCheckActor, enabledChecks, c._1.name, (remainingTime2 * sum * c._2.period.get / c._2.duration.get).millis)
            )
          }
        }
      }
    }

  }
}

@Singleton
class IntegrityCheckActorProvider @Inject() (
    db: Database,
    system: ActorSystem,
    quartzScheduler: quartz.Scheduler,
    appConfig: ApplicationConfig,
    integrityChecks: immutable.Set[IntegrityCheck]
) extends Provider[ActorRef[IntegrityCheck.Request]] {
  override lazy val get: ActorRef[IntegrityCheck.Request] =
    ClusterSingleton(system.toTyped)
      .init(SingletonActor(IntegrityCheck.behavior(db, quartzScheduler, appConfig, integrityChecks.toSeq), "IntegrityCheckActor"))
}

```

`thehive/app/org/thp/thehive/services/IntegrityCheckSerializer.scala`:

```scala
package org.thp.thehive.services

import akka.actor.ExtendedActorSystem
import akka.actor.typed.ActorRefResolver
import akka.actor.typed.scaladsl.adapter.ClassicActorSystemOps
import akka.serialization.Serializer
import play.api.libs.json.{Json, OFormat}

import java.io.NotSerializableException

class IntegrityCheckSerializer(system: ExtendedActorSystem) extends Serializer {
  import IntegrityCheck._
  override def identifier: Int = -604584588

  override def includeManifest: Boolean = false
  implicit class RichBoolean(b: Boolean) {
    def toByte: Byte = if (b) 1.toByte else 0.toByte
  }
  implicit class RichByte(b: Byte) {
    def toBoolean: Boolean = if (b == 0) false else true
  }
  implicit val finishDedupFormat: OFormat[FinishDedup]   = Json.format[FinishDedup]
  implicit val finishGlobalFormat: OFormat[FinishGlobal] = Json.format[FinishGlobal]
  private val actorRefResolver                           = ActorRefResolver(system.toTyped)

  override def toBinary(o: AnyRef): Array[Byte] =
    o match {
      case EntityAdded(name)                 => 0.toByte +: name.getBytes
      case NeedCheck(name)                   => 1.toByte +: name.getBytes
      case CheckRequest(name, dedup, global) => Array(2.toByte, dedup.toByte, global.toByte) ++ name.getBytes
      case GetAllCheckStats(replyTo)         => 3.toByte +: actorRefResolver.toSerializationFormat(replyTo).getBytes
      case AllCheckStats(map)                => 4.toByte +: Json.toJson(map).toString.getBytes
      case StartDedup(name: String)          => 5.toByte +: name.getBytes
      case fd: FinishDedup                   => 6.toByte +: Json.toJson(fd).toString.getBytes
      case StartGlobal(name: String)         => 7.toByte +: name.getBytes
      case fg: FinishGlobal                  => 8.toByte +: Json.toJson(fg).toString.getBytes
      case CancelCheck                       => Array(9.toByte)
      case _                                 => throw new NotSerializableException
    }

  override def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef =
    bytes(0) match {
      case 0 => EntityAdded(new String(bytes.tail))
      case 1 => NeedCheck(new String(bytes.tail))
      case 2 => CheckRequest(new String(bytes.drop(3)), bytes(1).toBoolean, bytes(2).toBoolean)
      case 3 => GetAllCheckStats(actorRefResolver.resolveActorRef(new String(bytes.tail)))
      case 4 => AllCheckStats(Json.parse(bytes.tail).as[Map[String, Map[String, Long]]])
      case 5 => StartDedup(new String(bytes.tail))
      case 6 => Json.parse(bytes.tail).as[FinishDedup]
      case 7 => StartGlobal(new String(bytes.tail))
      case 8 => Json.parse(bytes.tail).as[FinishGlobal]
      case 9 => CancelCheck
      case _ => throw new NotSerializableException
    }
}

```

`thehive/app/org/thp/thehive/services/KeyValueSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.services.VertexSrv
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.KeyValue

import javax.inject.{Inject, Singleton}
import scala.util.Try

@Singleton
class KeyValueSrv @Inject() () extends VertexSrv[KeyValue] {
  def create(e: KeyValue)(implicit graph: Graph, authContext: AuthContext): Try[KeyValue with Entity] = createEntity(e)
}

```

`thehive/app/org/thp/thehive/services/LocalKeyAuthSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth._
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{EntityIdOrName, NotFoundError}
import org.thp.thehive.services.UserOps._
import play.api.Configuration
import play.api.mvc.RequestHeader

import java.util.{Base64, Date}
import javax.inject.{Inject, Provider, Singleton}
import scala.concurrent.ExecutionContext
import scala.util.{Failure, Random, Success, Try}

class LocalKeyAuthSrv(
    db: Database,
    userSrv: UserSrv,
    localUserSrv: LocalUserSrv,
    authSrv: AuthSrv,
    requestOrganisation: RequestOrganisation,
    ec: ExecutionContext
) extends KeyAuthSrv(authSrv, requestOrganisation, ec) {

  final protected def generateKey(): String = {
    val bytes = Array.ofDim[Byte](24)
    Random.nextBytes(bytes)
    Base64.getEncoder.encodeToString(bytes)
  }

  override val capabilities: Set[AuthCapability.Value] = Set(AuthCapability.authByKey)

  override def authenticate(key: String, organisation: Option[EntityIdOrName])(implicit request: RequestHeader): Try[AuthContext] =
    db.roTransaction { implicit graph =>
      userSrv
        .startTraversal
        .getByAPIKey(key)
        .getOrFail("User")
        .flatMap(user => localUserSrv.getAuthContext(request, user.login, organisation))
    }

  override def renewKey(username: String)(implicit authContext: AuthContext): Try[String] =
    db.tryTransaction { implicit graph =>
      val newKey = generateKey()
      userSrv
        .get(EntityIdOrName(username))
        .update(_.apikey, Some(newKey))
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .domainMap(_ => newKey)
        .getOrFail("User")
    }

  override def getKey(username: String)(implicit authContext: AuthContext): Try[String] =
    db.roTransaction { implicit graph =>
      userSrv
        .getOrFail(EntityIdOrName(username))
        .flatMap(_.apikey.fold[Try[String]](Failure(NotFoundError(s"User $username hasn't key")))(Success.apply))
    }

  override def removeKey(username: String)(implicit authContext: AuthContext): Try[Unit] =
    db.tryTransaction { implicit graph =>
      userSrv
        .get(EntityIdOrName(username))
        .update(_.apikey, None)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .domainMap(_ => ())
        .getOrFail("User")
    }
}

@Singleton
class LocalKeyAuthProvider @Inject() (
    db: Database,
    userSrv: UserSrv,
    localUserSrv: LocalUserSrv,
    authSrvProvider: Provider[AuthSrv],
    requestOrganisation: RequestOrganisation,
    ec: ExecutionContext
) extends AuthSrvProvider {
  lazy val authSrv: AuthSrv = authSrvProvider.get
  override val name: String = "key"
  override def apply(config: Configuration): Try[AuthSrv] =
    Success(new LocalKeyAuthSrv(db, userSrv, localUserSrv, authSrv, requestOrganisation, ec))
}

```

`thehive/app/org/thp/thehive/services/LocalPasswordAuthSrv.scala`:

```scala
package org.thp.thehive.services

import io.github.nremond.SecureHash
import org.thp.scalligraph.auth.{AuthCapability, AuthContext, AuthSrv, AuthSrvProvider}
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.utils.Hasher
import org.thp.scalligraph.{AuthenticationError, AuthorizationError, EntityIdOrName}
import org.thp.thehive.models.User
import play.api.mvc.RequestHeader
import play.api.{Configuration, Logger}

import java.util.Date
import javax.inject.{Inject, Singleton}
import scala.concurrent.duration.Duration
import scala.util.{Failure, Success, Try}

object LocalPasswordAuthSrv {

  def hashPassword(password: String): String =
    SecureHash.createHash(password)
}

class LocalPasswordAuthSrv(db: Database, userSrv: UserSrv, localUserSrv: LocalUserSrv, maxAttempts: Option[Int], resetAfter: Option[Duration])
    extends AuthSrv {
  val name                                             = "local"
  override val capabilities: Set[AuthCapability.Value] = Set(AuthCapability.changePassword, AuthCapability.setPassword)
  lazy val logger: Logger                              = Logger(getClass)
  import LocalPasswordAuthSrv._

  def isValidPasswordLegacy(hash: String, password: String): Boolean =
    hash.split(",", 2) match {
      case Array(seed, pwd) =>
        val hash = Hasher("SHA-256").fromString(seed + password).head.toString
        logger.trace(s"Legacy password authentication check  ($hash == $pwd)")
        hash == pwd
      case _ =>
        logger.trace("Legacy password authenticate, invalid password format")
        false
    }

  def timeElapsed(user: User with Entity): Boolean =
    user.lastFailed.fold(true)(lf => resetAfter.fold(false)(ra => (System.currentTimeMillis - lf.getTime) > ra.toMillis))

  def lockedUntil(user: User with Entity): Option[Date] =
    if (maxAttemptsReached(user))
      user.lastFailed.map { lf =>
        resetAfter.fold(new Date(Long.MaxValue))(ra => new Date(ra.toMillis + lf.getTime))
      }
    else None

  def maxAttemptsReached(user: User with Entity) =
    (for {
      ma <- maxAttempts
      fa <- user.failedAttempts
    } yield fa >= ma).getOrElse(false)

  def isValidPassword(user: User with Entity, password: String): Boolean =
    if (!maxAttemptsReached(user) || timeElapsed(user)) {
      val isValid = user.password.fold(false)(hash => SecureHash.validatePassword(password, hash) || isValidPasswordLegacy(hash, password))
      if (!isValid)
        db.tryTransaction { implicit graph =>
          userSrv
            .get(user)
            .update(_.failedAttempts, Some(user.failedAttempts.fold(1)(_ + 1)))
            .update(_.lastFailed, Some(new Date))
            .getOrFail("User")
        }
      else if (user.failedAttempts.exists(_ > 0))
        db.tryTransaction { implicit graph =>
          userSrv
            .get(user)
            .update(_.failedAttempts, Some(0))
            .getOrFail("User")
        }
      isValid
    } else {
      logger.warn(
        s"Authentication of ${user.login} is refused because the max attempts is reached (${user.failedAttempts.orNull}/${maxAttempts.orNull})"
      )
      false
    }

  def resetFailedAttempts(user: User with Entity)(implicit graph: Graph): Try[Unit] =
    userSrv.get(user).update(_.failedAttempts, None).update(_.lastFailed, None).getOrFail("User").map(_ => ())

  override def authenticate(username: String, password: String, organisation: Option[EntityIdOrName], code: Option[String])(implicit
      request: RequestHeader
  ): Try[AuthContext] =
    db.roTransaction { implicit graph =>
      userSrv
        .getOrFail(EntityIdOrName(username))
    }.filter(user => isValidPassword(user, password))
      .map(user => localUserSrv.getAuthContext(request, user.login, organisation))
      .getOrElse(Failure(AuthenticationError("Authentication failure")))

  override def changePassword(username: String, oldPassword: String, newPassword: String)(implicit authContext: AuthContext): Try[Unit] =
    db.roTransaction { implicit graph =>
      userSrv
        .getOrFail(EntityIdOrName(username))
    }.filter(user => isValidPassword(user, oldPassword))
      .map(_ => setPassword(username, newPassword))
      .getOrElse(Failure(AuthorizationError("Authentication failure")))

  override def setPassword(username: String, newPassword: String)(implicit authContext: AuthContext): Try[Unit] =
    db.tryTransaction { implicit graph =>
      userSrv
        .get(EntityIdOrName(username))
        .update(_.password, Some(hashPassword(newPassword)))
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("User")
        .map(_ => ())
    }
}

@Singleton
class LocalPasswordAuthProvider @Inject() (db: Database, userSrv: UserSrv, localUserSrv: LocalUserSrv) extends AuthSrvProvider {
  override val name: String = "local"
  override def apply(config: Configuration): Try[AuthSrv] = {
    val maxAttempts = config.getOptional[Int]("maxAttempts")
    val resetAfter  = config.getOptional[Duration]("resetAfter")
    Success(new LocalPasswordAuthSrv(db, userSrv, localUserSrv, maxAttempts, resetAfter))
  }
}

```

`thehive/app/org/thp/thehive/services/LocalUserSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth.{AuthContext, AuthContextImpl, User => ScalligraphUser, UserSrv => ScalligraphUserSrv}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.utils.Instance
import org.thp.scalligraph.{AuthenticationError, CreateError, EntityIdOrName, EntityName, NotFoundError}
import org.thp.thehive.models.{Organisation, Permissions, Profile, User}
import org.thp.thehive.services.UserOps._
import play.api.Configuration
import play.api.libs.json.JsObject
import play.api.mvc.RequestHeader

import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class LocalUserSrv @Inject() (
    db: Database,
    userSrv: UserSrv,
    organisationSrv: OrganisationSrv,
    profileSrv: ProfileSrv,
    configuration: Configuration
) extends ScalligraphUserSrv {

  override def getAuthContext(request: RequestHeader, userId: String, organisationName: Option[EntityIdOrName]): Try[AuthContext] =
    db.roTransaction { implicit graph =>
      val requestId = Instance.getRequestId(request)
      val users     = userSrv.get(EntityIdOrName(userId))

      if (users.clone().exists)
        users
          .clone()
          .getAuthContext(requestId, organisationName)
          .headOption
          .orElse {
            organisationName.flatMap { org =>
              users
                .getAuthContext(requestId, EntityIdOrName(Organisation.administration.name))
                .headOption
                .map(authContext => authContext.changeOrganisation(org, authContext.permissions))
            }
          }
          .fold[Try[AuthContext]](Failure(AuthenticationError("Authentication failure")))(Success.apply)
      else Failure(NotFoundError(s"User $userId not found"))
    }

  override def createUser(userId: String, userInfo: JsObject): Try[ScalligraphUser] = {
    val autocreate = configuration.getOptional[Boolean]("user.autoCreateOnSso").getOrElse(false)
    if (autocreate) {
      val profileFieldName      = configuration.getOptional[String]("user.profileFieldName")
      val organisationFieldName = configuration.getOptional[String]("user.organisationFieldName")
      val defaultProfile        = configuration.getOptional[String]("user.defaults.profile")
      val defaultOrg            = configuration.getOptional[String]("user.defaults.organisation")
      def readData(json: JsObject, field: Option[String], default: Option[String]): Try[String] =
        Try((json \ field.get).as[String])
          .orElse(Try((json \ field.get).as[Seq[String]].head))
          .orElse(Try(default.get))

      db.tryTransaction { implicit graph =>
        implicit val defaultAuthContext: AuthContext = getSystemAuthContext
        for {
          profileStr <- readData(userInfo, profileFieldName, defaultProfile)
          profile    <- profileSrv.getOrFail(EntityName(profileStr))
          orgaStr    <- readData(userInfo, organisationFieldName, defaultOrg)
          if orgaStr != Organisation.administration.name || profile.name == Profile.admin.name
          organisation <- organisationSrv.getOrFail(EntityName(orgaStr))
          richUser <- userSrv.addOrCreateUser(
            User(userId, userId, None, locked = false, None, None, None, None),
            None,
            organisation,
            profile
          )
        } yield richUser.user
      }
    } else Failure(CreateError(s"Autocreate on single sign on is $autocreate"))
  }

  override def getSystemAuthContext: AuthContext = LocalUserSrv.getSystemAuthContext
}

object LocalUserSrv {
  def getSystemAuthContext: AuthContext =
    AuthContextImpl(
      User.system.login,
      User.system.name,
      EntityIdOrName(Organisation.administration.name),
      Instance.getInternalId,
      Permissions.all
    )
}

```

`thehive/app/org/thp/thehive/services/LogSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.controllers.FFile
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.TaskOps._
import play.api.libs.json.JsObject

import java.util
import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

@Singleton
class LogSrv @Inject() (attachmentSrv: AttachmentSrv, auditSrv: AuditSrv, taskSrv: TaskSrv) extends VertexSrv[Log] {
  val taskLogSrv       = new EdgeSrv[TaskLog, Task, Log]
  val logAttachmentSrv = new EdgeSrv[LogAttachment, Log, Attachment]

  def create(log: Log, task: Task with Entity, file: Option[FFile])(implicit graph: Graph, authContext: AuthContext): Try[RichLog] =
    for {
      createdLog <- createEntity(log.copy(taskId = task._id, organisationIds = task.organisationIds))
      _          <- taskLogSrv.create(TaskLog(), task, createdLog)
      _          <- if (task.status == TaskStatus.Waiting) taskSrv.updateStatus(task, TaskStatus.InProgress) else Success(())
      attachment <- file.map(attachmentSrv.create).flip
      _          <- attachment.map(logAttachmentSrv.create(LogAttachment(), createdLog, _)).flip
      richLog = RichLog(createdLog, Nil)
      _ <- auditSrv.log.create(createdLog, task, richLog.toJson)
    } yield richLog

  override def delete(log: Log with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    get(log).attachments.toSeq.toTry(attachmentSrv.delete(_)).map { _ =>
      get(log).task.headOption.foreach(task => auditSrv.log.delete(log, task))
      get(log).remove()
    }

  override def update(
      traversal: Traversal.V[Log],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[Log], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (logSteps, updatedFields) =>
        logSteps.clone().project(_.by.by(_.task)).getOrFail("Log").flatMap {
          case (log, task) => auditSrv.log.update(log, task, updatedFields)
        }
    }
}

object LogOps {

  implicit class LogOpsDefs(traversal: Traversal.V[Log]) {
    def task: Traversal.V[Task] = traversal.in("TaskLog").v[Task]

    def get(idOrName: EntityIdOrName): Traversal.V[Log] =
      idOrName.fold(traversal.getByIds(_), _ => traversal.empty)

    def organisations: Traversal.V[Organisation] =
      task.organisations

    def visible(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Log] =
      traversal.has(_.organisationIds, organisationSrv.currentId(traversal.graph, authContext))

    def attachments: Traversal.V[Attachment] = traversal.out[LogAttachment].v[Attachment]

    def `case`: Traversal.V[Case] = task.`case`

    def can(permission: Permission)(implicit authContext: AuthContext): Traversal.V[Log] =
      if (authContext.permissions.contains(permission))
        traversal.filter(_.task.can(permission))
      else
        traversal.empty

    def richLog: Traversal[RichLog, util.Map[String, Any], Converter[RichLog, util.Map[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.attachments.fold)
        )
        .domainMap {
          case (log, attachments) =>
            RichLog(
              log,
              attachments
            )
        }

    def richLogWithCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Log] => Traversal[D, G, C]
    ): Traversal[(RichLog, D), util.Map[String, Any], Converter[(RichLog, D), util.Map[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.attachments.fold)
            .by(entityRenderer)
        )
        .domainMap {
          case (log, attachments, renderedEntity) =>
            RichLog(
              log,
              attachments
            ) -> renderedEntity
        }
  }
}

class LogIntegrityCheck @Inject() (val db: Database, val service: LogSrv, taskSrv: TaskSrv) extends GlobalCheck[Log] with IntegrityCheckOps[Log] {
  override def globalCheck(traversal: Traversal.V[Log])(implicit graph: Graph): Map[String, Long] = {
    val taskCheck = singleIdLink[Task]("taskId", taskSrv)(_.inEdge[TaskLog], _.remove)
    traversal
      .project(_.by.by(_.task.fold))
      .toIterator
      .map {
        case (log, tasks) =>
          val taskStats = taskCheck.check(log, log.taskId, tasks.map(_._id))
          if (tasks.size == 1 && tasks.head.organisationIds != log.organisationIds) {
            service.get(log).update(_.organisationIds, tasks.head.organisationIds).iterate()
            taskStats + ("Log-invalidOrgs" -> 1L)
          } else taskStats
      }
      .reduceOption(_ <+> _)
      .getOrElse(Map.empty)
  }
}

```

`thehive/app/org/thp/thehive/services/ObservableSrv.scala`:

```scala
package org.thp.thehive.services

import org.apache.tinkerpop.gremlin.process.traversal.P
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.controllers.FFile
import org.thp.scalligraph.models.{Database, Entity, UMapping}
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, StepLabel, Traversal}
import org.thp.scalligraph.utils.Hash
import org.thp.scalligraph.{BadRequestError, CreateError, EntityId, EntityIdOrName, EntityName, RichSeq}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import play.api.libs.json.{JsObject, JsString, Json}

import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.concurrent.ExecutionContext
import scala.util.{Failure, Success, Try}

@Singleton
class ObservableSrv @Inject() (
    dataSrv: DataSrv,
    observableTypeSrv: ObservableTypeSrv,
    attachmentSrv: AttachmentSrv,
    tagSrv: TagSrv,
    auditSrv: AuditSrv,
    shareSrvProvider: Provider[ShareSrv],
    caseSrvProvider: Provider[CaseSrv],
    organisationSrv: OrganisationSrv,
    alertSrvProvider: Provider[AlertSrv]
) extends VertexSrv[Observable] {
  lazy val shareSrv: ShareSrv = shareSrvProvider.get
  lazy val caseSrv: CaseSrv   = caseSrvProvider.get
  lazy val alertSrv: AlertSrv = alertSrvProvider.get
  val observableDataSrv       = new EdgeSrv[ObservableData, Observable, Data]
  val observableAttachmentSrv = new EdgeSrv[ObservableAttachment, Observable, Attachment]
  val observableTagSrv        = new EdgeSrv[ObservableTag, Observable, Tag]

  def create(observable: Observable, file: FFile)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichObservable] =
    attachmentSrv.create(file).flatMap { attachment =>
      create(observable, attachment)
    }

  def create(
      observable: Observable,
      attachment: Attachment with Entity
  )(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichObservable] = {
    val alreadyExists = startTraversal
      .has(_.organisationIds, organisationSrv.currentId)
      .has(_.relatedId, observable.relatedId)
      .has(_.dataType, observable.dataType)
      .filterOnAttachmentId(attachment.attachmentId)
      .exists
    if (alreadyExists) Failure(CreateError("Observable already exists"))
    else
      for {
        observableType <- observableTypeSrv.getOrFail(EntityName(observable.dataType))
        _ <-
          if (!observableType.isAttachment) Failure(BadRequestError("A text observable doesn't accept attachment"))
          else Success(())
        tags              <- observable.tags.toTry(tagSrv.getOrCreate)
        createdObservable <- createEntity(observable.copy(data = None))
        _                 <- observableAttachmentSrv.create(ObservableAttachment(), createdObservable, attachment)
        _                 <- tags.toTry(observableTagSrv.create(ObservableTag(), createdObservable, _))
      } yield RichObservable(createdObservable, None, Some(attachment), None, Nil)
  }

  def create(
      observable: Observable,
      dataValue: String
  )(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichObservable] = {
    val (dataOrHash, fullData) = UseHashToIndex.hashToIndex(dataValue).fold[(String, Option[String])](dataValue -> None)(_ -> Some(dataValue))
    val alreadyExists = startTraversal
      .has(_.organisationIds, organisationSrv.currentId)
      .has(_.relatedId, observable.relatedId)
      .has(_.data, dataOrHash)
      .has(_.dataType, observable.dataType)
      .exists
    if (alreadyExists) Failure(CreateError("Observable already exists"))
    else
      for {
        observableType <- observableTypeSrv.getOrFail(EntityName(observable.dataType))
        _ <-
          if (observableType.isAttachment) Failure(BadRequestError("A attachment observable doesn't accept string value"))
          else Success(())
        tags              <- observable.tags.toTry(tagSrv.getOrCreate)
        data              <- dataSrv.create(Data(dataOrHash, fullData))
        createdObservable <- createEntity(observable.copy(data = Some(dataOrHash)))
        _                 <- observableDataSrv.create(ObservableData(), createdObservable, data)
        _                 <- tags.toTry(observableTagSrv.create(ObservableTag(), createdObservable, _))
      } yield RichObservable(createdObservable, Some(data), None, None, Nil)
  }

  def addTags(observable: Observable with Entity, tags: Set[String])(implicit graph: Graph, authContext: AuthContext): Try[Seq[Tag with Entity]] = {
    val currentTags = get(observable)
      .tags
      .toSeq
      .map(_.toString)
      .toSet
    val newTags = tags -- currentTags
    for {
      createdTags <- newTags.filterNot(_.isEmpty).toTry(tagSrv.getOrCreate)
      _           <- createdTags.toTry(observableTagSrv.create(ObservableTag(), observable, _))
      _ <- get(observable)
        .update(_.tags, (currentTags ++ newTags).toSeq)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("Observable")
//      _           <- auditSrv.observable.update(observable, Json.obj("tags" -> (currentTags ++ tags)))
    } yield createdTags
  }

  def updateTags(observable: Observable with Entity, tags: Set[String])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[(Seq[Tag with Entity], Seq[Tag with Entity])] =
    for {
      tagsToAdd <- (tags -- observable.tags).toTry(tagSrv.getOrCreate)
      tagsToRemove = get(observable).tags.toSeq.filterNot(t => tags.contains(t.toString))
      _ <- tagsToAdd.toTry(observableTagSrv.create(ObservableTag(), observable, _))
      _ = if (tagsToRemove.nonEmpty) get(observable).outE[ObservableTag].filter(_.otherV.hasId(tagsToRemove.map(_._id): _*)).remove()
      _ <- get(observable)
        .update(_.tags, tags.toSeq)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("Observable")
      _ <- auditSrv.observable.update(observable, Json.obj("tags" -> tags))
    } yield (tagsToAdd, tagsToRemove)

  override def delete(observable: Observable with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    def observableDetail(attachment: Option[Attachment with Entity]): JsObject =
      JsObject(
        "dataType" -> JsString(observable.dataType) ::
          attachment.map { a =>
            "attachment" -> Json.obj(
              "name"        -> a.name,
              "id"          -> a.attachmentId,
              "size"        -> a.size,
              "contentType" -> a.contentType,
              "hashes"      -> a.hashes.map(_.toString)
            )
          }.toList ::: observable.data.map(d => "data" -> JsString(d)).toList
      )

    get(observable).alert.headOption match {
      case None =>
        get(observable)
          .project(_.by(_.share).by(_.attachments.option))
          .toIterator
          .toTry {
            case (share, attachment) if share.owner =>
              get(observable)
                .shares
                .toIterator
                .toTry { share =>
                  auditSrv
                    .observable
                    .delete(observable, share, Some(observableDetail(attachment)))
                }
                .map(_ => get(observable).remove())
            case (share, attachment) =>
              for {
                organisation <- organisationSrv.current.getOrFail("Organisation")
                _            <- shareSrv.unshareObservable(observable, organisation)
                _            <- auditSrv.observable.delete(observable, share, Some(observableDetail(attachment)))
              } yield ()
          }
          .map(_ => ())
      case Some(alert) =>
        get(observable).remove()
        auditSrv.observableInAlert.delete(observable, alert)
    }
  }

  override def update(
      traversal: Traversal.V[Observable],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[Observable], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (observableSteps, updatedFields) =>
        observableSteps
          .clone()
          .getOrFail("Observable")
          .flatMap(observable => auditSrv.observable.update(observable, updatedFields))
    }

  def updateType(observable: Observable with Entity, observableType: ObservableType with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    get(observable)
      .update(_.dataType, observableType.name)
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .getOrFail("Observable")
      .flatMap(_ => auditSrv.observable.update(observable, Json.obj("dataType" -> observableType.name)))
}

object ObservableOps {

  implicit class ObservableOpsDefs(traversal: Traversal.V[Observable]) {
    def get(idOrName: EntityIdOrName): Traversal.V[Observable] =
      idOrName.fold(traversal.getByIds(_), _ => traversal.empty)

    def filterOnType(`type`: String): Traversal.V[Observable] =
      traversal.has(_.dataType, `type`)

    def filterOnData(data: String): Traversal.V[Observable] =
      traversal.has(_.data, data)

    def filterOnAttachmentName(name: String): Traversal.V[Observable] =
      traversal.filter(_.attachments.has(_.name, name))

    def filterOnAttachmentSize(size: Long): Traversal.V[Observable] =
      traversal.filter(_.attachments.has(_.size, size))

    def filterOnAttachmentContentType(contentType: String): Traversal.V[Observable] =
      traversal.filter(_.attachments.has(_.contentType, contentType))

    def filterOnAttachmentHash(hash: String): Traversal.V[Observable] =
      traversal.filter(_.attachments.has(_.hashes, Hash(hash)))

    def filterOnAttachmentId(attachmentId: String): Traversal.V[Observable] =
      traversal.filter(_.attachments.has(_.attachmentId, attachmentId))

    def relatedTo(caseId: EntityId): Traversal.V[Observable] =
      traversal.has(_.relatedId, caseId)

    def inOrganisation(organisationId: EntityId): Traversal.V[Observable] =
      traversal.has(_.organisationIds, organisationId)

    def isIoc: Traversal.V[Observable] =
      traversal.has(_.ioc, true)

    def visible(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Observable] =
      traversal.has(_.organisationIds, organisationSrv.currentId(traversal.graph, authContext))

    def can(permission: Permission)(implicit authContext: AuthContext): Traversal.V[Observable] =
      if (authContext.permissions.contains(permission))
        traversal.filter(_.shares.filter(_.filter(_.profile.has(_.permissions, permission))).organisation.current)
      else
        traversal.empty

    def canManage(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Observable] =
      if (authContext.isPermitted(Permissions.manageAlert))
        traversal.filter(_.or(_.alert.visible(organisationSrv), _.can(Permissions.manageObservable)))
      else
        can(Permissions.manageObservable)

    def userPermissions(implicit authContext: AuthContext): Traversal[Set[Permission], Vertex, Converter[Set[Permission], Vertex]] =
      traversal
        .share(authContext.organisation)
        .profile
        .domainMap(profile => profile.permissions & authContext.permissions)

    def organisations: Traversal.V[Organisation] =
      traversal
        .optional(_.in("ReportObservable").in("ObservableJob").v[Observable])
        .unionFlat(_.shares.organisation, _.alert.organisation)
//      traversal.coalesceIdent(_.in[ShareObservable].in[OrganisationShare], _.in[AlertObservable].out[AlertOrganisation]).v[Organisation]

    def origin: Traversal.V[Organisation] = shares.has(_.owner, true).organisation

    def isShared: Traversal[Boolean, Boolean, Converter.Identity[Boolean]] =
      traversal.choose(_.inE[ShareObservable].count.is(P.gt(1)), true, false)

    def richObservable: Traversal[RichObservable, JMap[String, Any], Converter[RichObservable, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.data.option)
            .by(_.attachments.option)
            .by(_.reportTags.fold)
        )
        .domainMap {
          case (observable, data, attachment, reportTags) =>
            RichObservable(
              observable,
              data,
              attachment,
              None,
              reportTags
            )
        }

    def richObservableWithSeen(organisationSrv: OrganisationSrv)(implicit
        authContext: AuthContext
    ): Traversal[RichObservable, JMap[String, Any], Converter[RichObservable, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.data.option)
            .by(_.attachments.option)
            .by(_.filteredSimilar.visible(organisationSrv).limit(1).count)
            .by(_.reportTags.fold)
        )
        .domainMap {
          case (observable, data, attachment, count, reportTags) =>
            RichObservable(
              observable,
              data,
              attachment,
              Some(count != 0),
              reportTags
            )
        }

    def richObservableWithCustomRenderer[D, G, C <: Converter[D, G]](
        organisationSrv: OrganisationSrv,
        entityRenderer: Traversal.V[Observable] => Traversal[D, G, C]
    )(implicit authContext: AuthContext): Traversal[(RichObservable, D), JMap[String, Any], Converter[(RichObservable, D), JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.data.option)
            .by(_.attachments.option)
            .by(_.filteredSimilar.visible(organisationSrv).limit(1).count)
            .by(_.reportTags.fold)
            .by(entityRenderer)
        )
        .domainMap {
          case (observable, data, attachment, count, reportTags, renderedEntity) =>
            RichObservable(
              observable,
              data,
              attachment,
              Some(count != 0),
              reportTags
            ) -> renderedEntity
        }

    def `case`: Traversal.V[Case] = traversal.in[ShareObservable].out[ShareCase].v[Case]

    def alert: Traversal.V[Alert] = traversal.in[AlertObservable].v[Alert]

    def tags: Traversal.V[Tag] = traversal.out[ObservableTag].v[Tag]

    def reportTags: Traversal.V[ReportTag] = traversal.out[ObservableReportTag].v[ReportTag]

    def removeTags(tags: Set[Tag with Entity]): Unit =
      if (tags.nonEmpty)
        traversal.outE[ObservableTag].filter(_.otherV.hasId(tags.map(_._id).toSeq: _*)).remove()

    def filteredSimilar: Traversal.V[Observable] =
      traversal
        .hasNot(_.ignoreSimilarity, true)
        .similar
        .hasNot(_.ignoreSimilarity, true)

    def similar: Traversal.V[Observable] = {
      val originLabel = StepLabel.v[Observable]
      traversal
        .aggregateLocal(originLabel)
        .unionFlat(
          _.out[ObservableData]
            .in[ObservableData],
          _.out[ObservableAttachment]
            .in[ObservableAttachment] // FIXME this doesn't work. Link must be done with attachmentId
        )
        .where(P.without(originLabel.name))
        .dedup
        .v[Observable]
    }

    def data: Traversal.V[Data] = traversal.out[ObservableData].v[Data]

    def attachments: Traversal.V[Attachment] = traversal.out[ObservableAttachment].v[Attachment]

    def keyValues: Traversal.V[KeyValue] = traversal.out[ObservableKeyValue].v[KeyValue]

    def typeName: Traversal[String, String, Converter[String, String]] = traversal.value(_.dataType)

    def shares: Traversal.V[Share] = traversal.in[ShareObservable].v[Share]

    def share(implicit authContext: AuthContext): Traversal.V[Share] = share(authContext.organisation)

    def share(organisationName: EntityIdOrName): Traversal.V[Share] =
      shares.filter(_.byOrganisation(organisationName))
  }
}

class ObservableIntegrityCheck @Inject() (
    val db: Database,
    val service: ObservableSrv,
    organisationSrv: OrganisationSrv,
    dataSrv: DataSrv,
    tagSrv: TagSrv,
    implicit val ec: ExecutionContext
) extends GlobalCheck[Observable]
    with IntegrityCheckOps[Observable] {

  def checkData(observable: Observable with Entity, data: Seq[Data with Entity])(implicit graph: Graph): Map[String, Long] = {
    implicit val authContext: AuthContext = LocalUserSrv.getSystemAuthContext
    data match {
      case Seq(d) if observable.data.contains(d.data) => Map.empty
      case Seq() if observable.data.isEmpty           => Map.empty
      case Seq() =>
        dataSrv
          .create(Data(observable.data.get, None))
          .flatMap(d => service.observableDataSrv.create(ObservableData(), observable, d))
          .fold(e => Map(s"Observable-data-missingLink-failure-$e" -> 1L), _ => Map(s"Observable-data-missingLink" -> 1L))
      case ds if observable.data.nonEmpty =>
        val (relatedData, unrelatedData) = ds.partition(_.data == observable.data.get)
        val extraLinks                   = EntitySelector.firstCreatedEntity(relatedData).fold(Seq.empty[Data with Entity])(_._2) ++ unrelatedData
        service.get(observable).outE[ObservableData].filter(_.hasId(extraLinks.map(_._id): _*)).remove()
        Map("Observable-data-extraLinks" -> extraLinks.size.toLong)
      case ds =>
        EntitySelector.firstCreatedEntity(ds).fold(Map.empty[String, Long]) {
          case (head, tail) =>
            service
              .get(observable)
              .update(_.data, Some(head.data))
              .outE[ObservableData]
              .filter(_.hasId(tail.map(_._id): _*))
              .remove()
            Map("Observable-data-extraLinks" -> tail.size.toLong, "Observable-data-missingField" -> 1L)
        }
    }
  }

  override def globalCheck(traversal: Traversal.V[Observable])(implicit graph: Graph): Map[String, Long] = {
    val orgCheck = multiIdLink[Organisation]("organisationIds", organisationSrv)(_.remove)
    val removeOrphan: OrphanStrategy[Observable, EntityId] = { (_, entity) =>
      service.get(entity).remove()
      Map("Observable-relatedId-removeOrphan" -> 1)
    }
    val relatedCheck = new SingleLinkChecker[Product, EntityId, EntityId](
      orphanStrategy = removeOrphan,
      setField = (entity, link) => UMapping.entityId.setProperty(service.get(entity), "relatedId", link._id).iterate(),
      entitySelector = _ => EntitySelector.firstCreatedEntity,
      removeLink = (_, _) => (),
      getLink = id => graph.VV(id).entity.head,
      optionalField = Some(_)
    )

    traversal
      .project(
        _.by
          .by(_.organisations._id.fold)
          .by(_.unionFlat(_.`case`._id, _.alert._id, _.in("ReportObservable")._id).fold)
          .by(_.data.fold)
          .by(_.tags.fold)
      )
      .toIterator
      .map {
        case (observable, organisationIds, relatedIds, data, tags) =>
          val orgStats            = orgCheck.check(observable, observable.organisationIds, organisationIds)
          val relatedStats        = relatedCheck.check(observable, observable.relatedId, relatedIds)
          val observableDataStats = checkData(observable, data)
          val tagStats = {
            val observableTagSet = observable.tags.toSet
            val tagSet           = tags.map(_.toString).toSet
            if (observableTagSet == tagSet) Map.empty[String, Long]
            else {
              implicit val authContext: AuthContext =
                LocalUserSrv.getSystemAuthContext.changeOrganisation(observable.organisationIds.head, Permissions.all)

              val extraTagField = observableTagSet -- tagSet
              val extraTagLink  = tagSet -- observableTagSet
              extraTagField
                .flatMap(tagSrv.getOrCreate(_).toOption)
                .foreach(service.observableTagSrv.create(ObservableTag(), observable, _))
              service.get(observable).update(_.tags, observable.tags ++ extraTagLink).iterate()
              Map(
                "observable-tags-extraField" -> extraTagField.size.toLong,
                "observable-tags-extraLink"  -> extraTagLink.size.toLong
              )
            }
          }

          orgStats <+> relatedStats <+> observableDataStats <+> tagStats
      }
      .reduceOption(_ <+> _)
      .getOrElse(Map.empty)
  }
}

```

`thehive/app/org/thp/thehive/services/ObservableTypeSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.scalligraph.{BadRequestError, CreateError, EntityIdOrName}
import org.thp.thehive.models._
import org.thp.thehive.services.ObservableTypeOps._

import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class ObservableTypeSrv @Inject() (_observableSrv: Provider[ObservableSrv], integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]])
    extends VertexSrv[ObservableType] {
  lazy val observableSrv: ObservableSrv                          = _observableSrv.get
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[ObservableType] =
    startTraversal.getByName(name)

  override def exists(e: ObservableType)(implicit graph: Graph): Boolean = startTraversal.getByName(e.name).exists

  override def createEntity(e: ObservableType)(implicit graph: Graph, authContext: AuthContext): Try[ObservableType with Entity] = {
    integrityCheckActor ! IntegrityCheck.EntityAdded("ObservableType")
    super.createEntity(e)
  }

  def create(observableType: ObservableType)(implicit graph: Graph, authContext: AuthContext): Try[ObservableType with Entity] =
    if (exists(observableType))
      Failure(CreateError(s"Observable type ${observableType.name} already exists"))
    else
      createEntity(observableType)

  def remove(idOrName: EntityIdOrName)(implicit graph: Graph): Try[Unit] =
    if (!isUsed(idOrName)) Success(get(idOrName).remove())
    else Failure(BadRequestError(s"Observable type $idOrName is used"))

  def isUsed(idOrName: EntityIdOrName)(implicit graph: Graph): Boolean =
    get(idOrName)
      .value(_.name)
      .headOption
      .fold(false)(ot => observableSrv.startTraversal.has(_.dataType, ot).exists)

  def useCount(idOrName: EntityIdOrName)(implicit graph: Graph): Long =
    get(idOrName)
      .value(_.name)
      .headOption
      .fold(0L)(ot => observableSrv.startTraversal.has(_.dataType, ot).getCount)
}

object ObservableTypeOps {

  implicit class ObservableTypeObs(traversal: Traversal.V[ObservableType]) {

    def get(idOrName: EntityIdOrName): Traversal.V[ObservableType] =
      idOrName.fold(traversal.getByIds(_), getByName)

    def getByName(name: String): Traversal.V[ObservableType] = traversal.has(_.name, name)
  }
}

class ObservableTypeIntegrityCheck @Inject() (val db: Database, val service: ObservableTypeSrv) extends DedupCheck[ObservableType]

```

`thehive/app/org/thp/thehive/services/OrganisationSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.models._
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.scalligraph.{BadRequestError, EntityId, EntityIdOrName, RichSeq}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.RoleOps._
import org.thp.thehive.services.UserOps._
import play.api.cache.SyncCacheApi
import play.api.libs.json.JsObject

import java.util.{Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class OrganisationSrv @Inject() (
    taxonomySrvProvider: Provider[TaxonomySrv],
    roleSrv: RoleSrv,
    profileSrv: ProfileSrv,
    auditSrv: AuditSrv,
    userSrv: UserSrv,
    integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]],
    cache: SyncCacheApi
) extends VertexSrv[Organisation] {
  lazy val taxonomySrv: TaxonomySrv                              = taxonomySrvProvider.get
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get
  val organisationOrganisationSrv                                = new EdgeSrv[OrganisationOrganisation, Organisation, Organisation]
  val organisationShareSrv                                       = new EdgeSrv[OrganisationShare, Organisation, Share]
  val organisationTaxonomySrv                                    = new EdgeSrv[OrganisationTaxonomy, Organisation, Taxonomy]

  override def createEntity(e: Organisation)(implicit graph: Graph, authContext: AuthContext): Try[Organisation with Entity] = {
    integrityCheckActor ! IntegrityCheck.EntityAdded("Organisation")
    super.createEntity(e)
  }

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[Organisation] = startTraversal.getByName(name)

  def create(organisation: Organisation, user: User with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Organisation with Entity] =
    for {
      createdOrganisation <- create(organisation)
      _                   <- roleSrv.create(user, createdOrganisation, profileSrv.orgAdmin)
    } yield createdOrganisation

  def create(e: Organisation)(implicit graph: Graph, authContext: AuthContext): Try[Organisation with Entity] = {
    val activeTaxos = getByName("admin").taxonomies.toSeq
    for {
      newOrga <- createEntity(e)
      _       <- taxonomySrv.createFreetagTaxonomy(newOrga)
      _       <- activeTaxos.toTry(t => organisationTaxonomySrv.create(OrganisationTaxonomy(), newOrga, t))
      _       <- auditSrv.organisation.create(newOrga, newOrga.toJson)
    } yield newOrga
  }

  def current(implicit graph: Graph, authContext: AuthContext): Traversal.V[Organisation] = get(authContext.organisation)

  def currentId(implicit graph: Graph, authContext: AuthContext): EntityId =
    getId(authContext.organisation)

  def getId(organisationIdOrName: EntityIdOrName)(implicit graph: Graph): EntityId =
    organisationIdOrName.fold(
      identity,
      name =>
        cache.getOrElseUpdate(s"organisation-id-$name") {
          val oid = getByName(name)._id.getOrFail("Organisation").get
          cache.set(s"organisation-name-$oid", name)
          oid
        }
    )

  def getName(organisationIdOrName: EntityIdOrName)(implicit graph: Graph): String =
    organisationIdOrName.fold(
      oid =>
        cache.getOrElseUpdate(s"organisation-name-$oid") {
          val name = getByIds(oid).value(_.name).getOrFail("Organisation").get
          cache.set(s"organisation-id-$name", oid)
          name
        },
      identity
    )

  def visibleOrganisation(implicit graph: Graph, authContext: AuthContext): Traversal.V[Organisation] =
    userSrv.current.organisations.visibleOrganisationsFrom

  override def exists(e: Organisation)(implicit graph: Graph): Boolean = startTraversal.getByName(e.name).exists

  override def update(
      traversal: Traversal.V[Organisation],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[Organisation], JsObject)] =
    if (traversal.clone().getByName(Organisation.administration.name).exists)
      Failure(BadRequestError("Admin organisation is unmodifiable"))
    else
      auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
        case (orgSteps, updatedFields) =>
          orgSteps
            .clone()
            .getOrFail("Organisation")
            .flatMap(auditSrv.organisation.update(_, updatedFields))
      }

  def linkExists(fromOrg: Organisation with Entity, toOrg: Organisation with Entity)(implicit graph: Graph): Boolean =
    fromOrg._id == toOrg._id || get(fromOrg).links.getEntity(toOrg).exists

  def link(fromOrg: Organisation with Entity, toOrg: Organisation with Entity)(implicit authContext: AuthContext, graph: Graph): Try[Unit] =
    if (linkExists(fromOrg, toOrg)) Success(())
    else organisationOrganisationSrv.create(OrganisationOrganisation(), fromOrg, toOrg).map(_ => ())

  def doubleLink(org1: Organisation with Entity, org2: Organisation with Entity)(implicit authContext: AuthContext, graph: Graph): Try[Unit] =
    if (org1.name == "admin" || org2.name == "admin") Failure(BadRequestError("Admin organisation cannot be link with other organisation"))
    else
      for {
        _ <- link(org1, org2)
        _ <- link(org2, org1)
      } yield ()

  def unlink(fromOrg: Organisation with Entity, toOrg: Organisation with Entity)(implicit graph: Graph): Try[Unit] =
    Success(
      get(fromOrg)
        .outE[OrganisationOrganisation]
        .filter(_.otherV.hasId(toOrg._id))
        .remove()
    )

  def doubleUnlink(org1: Organisation with Entity, org2: Organisation with Entity)(implicit graph: Graph): Try[Unit] = {
    unlink(org1, org2) // can't fail
    unlink(org2, org1)
  }

  def updateLink(fromOrg: Organisation with Entity, toOrganisations: Seq[EntityIdOrName])(implicit
      authContext: AuthContext,
      graph: Graph
  ): Try[Unit] = {
    val toOrgIds = toOrganisations.map(_.fold(identity, getByName(_)._id.getOrFail("Organisation").get)).toSet
    val (orgToAdd, orgToRemove) = get(fromOrg)
      .links
      ._id
      .toIterator
      .foldLeft((toOrgIds, Set.empty[EntityId])) {
        case ((toAdd, toRemove), o) if toAdd.contains(o) => (toAdd - o, toRemove)
        case ((toAdd, toRemove), o)                      => (toAdd, toRemove + o)
      }
    for {
      _ <- orgToAdd.toTry(getOrFail(_).flatMap(doubleLink(fromOrg, _)))
      _ <- orgToRemove.toTry(getOrFail(_).flatMap(doubleUnlink(fromOrg, _)))
    } yield ()
  }
}

object OrganisationOps {

  implicit class OrganisationOpsDefs(traversal: Traversal.V[Organisation]) {

    def get(idOrName: EntityIdOrName): Traversal.V[Organisation] =
      idOrName.fold(traversal.getByIds(_), traversal.getByName(_))

    def current(implicit authContext: AuthContext): Traversal.V[Organisation] = get(authContext.organisation)

    def links: Traversal.V[Organisation] = traversal.out[OrganisationOrganisation].v[Organisation]

    def cases: Traversal.V[Case] = traversal.out[OrganisationShare].out[ShareCase].v[Case]

    def shares: Traversal.V[Share] = traversal.out[OrganisationShare].v[Share]

    def taxonomies: Traversal.V[Taxonomy] = traversal.out[OrganisationTaxonomy].v[Taxonomy]

    def caseTemplates: Traversal.V[CaseTemplate] = traversal.in[CaseTemplateOrganisation].v[CaseTemplate]

    def users(requiredPermission: Permission): Traversal.V[User] =
      traversal.roles.filter(_.profile.has(_.permissions, requiredPermission)).user

    def userPermissions(userId: EntityIdOrName): Traversal[Permission, String, Converter[Permission, String]] =
      traversal
        .roles
        .filter(_.user.get(userId))
        .profile
        .property("permissions", Permission(_: String))

    def roles: Traversal.V[Role] = traversal.in[RoleOrganisation].v[Role]

    def pages: Traversal.V[Page] = traversal.out[OrganisationPage].v[Page]

    def alerts: Traversal.V[Alert] = traversal.in[AlertOrganisation].v[Alert]

    def dashboards: Traversal.V[Dashboard] = traversal.out[OrganisationDashboard].v[Dashboard]

    def visible(implicit authContext: AuthContext): Traversal.V[Organisation] =
      if (authContext.isPermitted(Permissions.manageOrganisation))
        traversal
      else
        traversal.filter(_.visibleOrganisationsTo.current)

    def richOrganisation: Traversal[RichOrganisation, JMap[String, Any], Converter[RichOrganisation, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.out[OrganisationOrganisation].v[Organisation].fold)
        )
        .domainMap {
          case (organisation, linkedOrganisations) =>
            RichOrganisation(organisation, linkedOrganisations)
        }

    def notAdmin: Traversal.V[Organisation] = traversal.hasNot(_.name, Organisation.administration.name)

    def isAdmin: Boolean = traversal.has(_.name, Organisation.administration.name).exists

    def users: Traversal.V[User] = traversal.in[RoleOrganisation].in[UserRole].v[User]

    def userProfile(login: String): Traversal.V[Profile] =
      roles.filter(_.user.has(_.login, login)).profile

    def visibleOrganisationsTo: Traversal.V[Organisation] =
      traversal.unionFlat(identity, _.in[OrganisationOrganisation]).dedup().v[Organisation]

    def visibleOrganisationsFrom: Traversal.V[Organisation] =
      traversal.unionFlat(identity, _.out[OrganisationOrganisation]).dedup().v[Organisation]

    def config: Traversal.V[Config] = traversal.out[OrganisationConfig].v[Config]

    def getByName(name: String): Traversal.V[Organisation] = traversal.has(_.name, name)
  }

}

class OrganisationIntegrityCheck @Inject() (val db: Database, val service: OrganisationSrv) extends DedupCheck[Organisation]

```

`thehive/app/org/thp/thehive/services/PageSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services.{EdgeSrv, VertexSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.thehive.models.{Organisation, OrganisationPage, Page}
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.PageOps._
import play.api.libs.json.Json

import javax.inject.{Inject, Singleton}
import scala.util.Try

@Singleton
class PageSrv @Inject() (organisationSrv: OrganisationSrv, auditSrv: AuditSrv) extends VertexSrv[Page] {

  val organisationPageSrv = new EdgeSrv[OrganisationPage, Organisation, Page]

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[Page] = startTraversal.getBySlug(name)

  def create(page: Page)(implicit authContext: AuthContext, graph: Graph): Try[Page with Entity] =
    for {
      created      <- createEntity(page)
      organisation <- organisationSrv.get(authContext.organisation).getOrFail("Organisation")
      _            <- organisationPageSrv.create(OrganisationPage(), organisation, created)
      _            <- auditSrv.page.create(created, Json.obj("title" -> page.title))
    } yield created

  def update(page: Page with Entity, propertyUpdaters: Seq[PropertyUpdater])(implicit graph: Graph, authContext: AuthContext): Try[Page with Entity] =
    for {
      updated <- update(get(page), propertyUpdaters)
      p       <- updated._1.getOrFail("Page")
      _       <- auditSrv.page.update(p, Json.obj("title" -> p.title))
    } yield p

  override def delete(page: Page with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    organisationSrv.getOrFail(authContext.organisation).flatMap { organisation =>
      get(page).remove()
      auditSrv.page.delete(page, organisation)
    }
}

object PageOps {

  implicit class PageOpsDefs(traversal: Traversal.V[Page]) {

    def getByTitle(title: String): Traversal.V[Page] = traversal.has(_.title, title)

    def getBySlug(slug: String): Traversal.V[Page] = traversal.has(_.slug, slug)

    def organisation: Traversal.V[Organisation] = traversal.in[OrganisationPage].v[Organisation]

    def visible(implicit authContext: AuthContext): Traversal.V[Page] =
      traversal.filter(_.organisation.current)
  }

}

```

`thehive/app/org/thp/thehive/services/PatternSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps.TraversalOpsDefs
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.scalligraph.utils.FunctionalCondition._
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.PatternOps._
import org.thp.thehive.services.ProcedureOps._

import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

@Singleton
class PatternSrv @Inject() (
    auditSrv: AuditSrv,
    caseSrv: CaseSrv,
    organisationSrv: OrganisationSrv
) extends VertexSrv[Pattern] {
  val patternPatternSrv = new EdgeSrv[PatternPattern, Pattern, Pattern]

  def cannotBeParent(child: Pattern with Entity, parent: Pattern with Entity)(implicit graph: Graph): Boolean =
    child._id == parent._id || get(child).parent.getEntity(parent).exists

  def setParent(child: Pattern with Entity, parent: Pattern with Entity)(implicit authContext: AuthContext, graph: Graph): Try[Unit] =
    if (cannotBeParent(child, parent)) Success(())
    else patternPatternSrv.create(PatternPattern(), parent, child).map(_ => ())

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[Pattern] =
    Try(startTraversal.getByPatternId(name)).getOrElse(startTraversal.limit(0))

  def getCasePatterns(caseId: String)(implicit authContext: AuthContext, graph: Graph): Try[Seq[RichPattern]] =
    for {
      caze <- caseSrv.get(EntityIdOrName(caseId)).visible(organisationSrv).getOrFail("Case")
    } yield caseSrv.get(caze).procedure.pattern.richPattern.toSeq

  def update(
      pattern: Pattern with Entity,
      input: Pattern
  )(implicit graph: Graph, authContext: AuthContext): Try[Pattern with Entity] =
    for {
      updatedPattern <- get(pattern)
        .when(pattern.patternId != input.patternId)(_.update(_.patternId, input.patternId))
        .when(pattern.name != input.name)(_.update(_.name, input.name))
        .when(pattern.description != input.description)(_.update(_.description, input.description))
        .when(pattern.tactics != input.tactics)(_.update(_.tactics, input.tactics))
        .when(pattern.url != input.url)(_.update(_.url, input.url))
        .when(pattern.patternType != input.patternType)(_.update(_.patternType, input.patternType))
        .when(pattern.capecId != input.capecId)(_.update(_.capecId, input.capecId))
        .when(pattern.capecUrl != input.capecUrl)(_.update(_.capecUrl, input.capecUrl))
        .when(pattern.revoked != input.revoked)(_.update(_.revoked, input.revoked))
        .when(pattern.dataSources != input.dataSources)(_.update(_.dataSources, input.dataSources))
        .when(pattern.defenseBypassed != input.defenseBypassed)(_.update(_.defenseBypassed, input.defenseBypassed))
        .when(pattern.detection != input.detection)(_.update(_.detection, input.detection))
        .when(pattern.permissionsRequired != input.permissionsRequired)(_.update(_.permissionsRequired, input.permissionsRequired))
        .when(pattern.platforms != input.platforms)(_.update(_.platforms, input.platforms))
        .when(pattern.remoteSupport != input.remoteSupport)(_.update(_.remoteSupport, input.remoteSupport))
        .when(pattern.systemRequirements != input.systemRequirements)(_.update(_.systemRequirements, input.systemRequirements))
        .when(pattern.revision != input.revision)(_.update(_.revision, input.revision))
        .when(input != pattern)(_.update(_._updatedAt, Some(new Date)).update(_._updatedBy, Some(authContext.userId)))
        .getOrFail("Pattern")
    } yield updatedPattern

  def remove(pattern: Pattern with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      organisation <- organisationSrv.getOrFail(authContext.organisation)
      _            <- auditSrv.pattern.delete(pattern, organisation)
    } yield get(pattern).remove()

}

object PatternOps {
  implicit class PatternOpsDefs(traversal: Traversal.V[Pattern]) {

    def getByPatternId(patternId: String): Traversal.V[Pattern] = traversal.has(_.patternId, patternId)

    def parent: Traversal.V[Pattern] =
      traversal.in[PatternPattern].v[Pattern]

    def children: Traversal.V[Pattern] =
      traversal.out[PatternPattern].v[Pattern]

    def procedure: Traversal.V[Procedure] =
      traversal.in[ProcedurePattern].v[Procedure]

    def alreadyImported(patternId: String): Boolean =
      traversal.getByPatternId(patternId).exists

    def richPattern: Traversal[RichPattern, JMap[String, Any], Converter[RichPattern, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.in[PatternPattern].v[Pattern].fold)
        )
        .domainMap {
          case (pattern, parent) =>
            RichPattern(pattern, parent.headOption)
        }

    def richPatternWithCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Pattern] => Traversal[D, G, C]
    ): Traversal[(RichPattern, D), JMap[String, Any], Converter[(RichPattern, D), JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.in[PatternPattern].v[Pattern].fold)
            .by(entityRenderer)
        )
        .domainMap {
          case (pattern, parent, renderedEntity) =>
            RichPattern(pattern, parent.headOption) -> renderedEntity
        }

  }
}

```

`thehive/app/org/thp/thehive/services/ProcedureSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps.TraversalOpsDefs
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.ProcedureOps._
import play.api.libs.json.JsObject

import java.util.{Map => JMap}
import javax.inject.{Inject, Singleton}
import scala.util.Try

@Singleton
class ProcedureSrv @Inject() (
    auditSrv: AuditSrv,
    caseSrv: CaseSrv,
    patternSrv: PatternSrv
) extends VertexSrv[Procedure] {
  val caseProcedureSrv    = new EdgeSrv[CaseProcedure, Case, Procedure]
  val procedurePatternSrv = new EdgeSrv[ProcedurePattern, Procedure, Pattern]

  def create(p: Procedure, caseId: String, patternId: String)(implicit graph: Graph, authContext: AuthContext): Try[RichProcedure] =
    for {
      caze      <- caseSrv.getOrFail(EntityIdOrName(caseId))
      pattern   <- patternSrv.getOrFail(EntityIdOrName(patternId))
      procedure <- createEntity(p)
      _         <- caseProcedureSrv.create(CaseProcedure(), caze, procedure)
      _         <- procedurePatternSrv.create(ProcedurePattern(), procedure, pattern)
      richProcedure = RichProcedure(procedure, pattern)
      _ <- auditSrv.procedure.create(procedure, caze, richProcedure.toJson)
    } yield richProcedure

  override def get(idOrName: EntityIdOrName)(implicit graph: Graph): Traversal.V[Procedure] =
    idOrName.fold(getByIds(_), _ => startTraversal.limit(0))

  override def update(
      traversal: Traversal.V[Procedure],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[Procedure], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (procedureSteps, updatedFields) =>
        procedureSteps.clone().project(_.by.by(_.`case`)).getOrFail("Procedure").flatMap {
          case (procedure, caze) => auditSrv.procedure.update(procedure, caze, updatedFields)
        }
    }

  def remove(procedure: Procedure with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      caze <- get(procedure).`case`.getOrFail("Case")
      _    <- auditSrv.procedure.delete(procedure, caze)
    } yield get(procedure).remove()

}

object ProcedureOps {
  implicit class ProcedureOpsDefs(traversal: Traversal.V[Procedure]) {

    def pattern: Traversal.V[Pattern] =
      traversal.out[ProcedurePattern].v[Pattern]

    def `case`: Traversal.V[Case] =
      traversal.in[CaseProcedure].v[Case]

    def get(idOrName: EntityIdOrName): Traversal.V[Procedure] =
      idOrName.fold(traversal.getByIds(_), _ => traversal.limit(0))

    def richProcedure: Traversal[RichProcedure, JMap[String, Any], Converter[RichProcedure, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.pattern)
        )
        .domainMap { case (procedure, pattern) => RichProcedure(procedure, pattern) }

    def richProcedureWithCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Procedure] => Traversal[D, G, C]
    ): Traversal[(RichProcedure, D), JMap[String, Any], Converter[(RichProcedure, D), JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.pattern)
            .by(entityRenderer)
        )
        .domainMap {
          case (procedure, pattern, renderedEntity) => (RichProcedure(procedure, pattern), renderedEntity)
        }
  }
}

```

`thehive/app/org/thp/thehive/services/ProfileSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.models._
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.scalligraph.{BadRequestError, EntityIdOrName, EntityName}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.ProfileOps._
import play.api.libs.json.JsObject

import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Try}

@Singleton
class ProfileSrv @Inject() (
    auditSrv: AuditSrv,
    organisationSrvProvider: Provider[OrganisationSrv],
    integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]]
)(implicit
    val db: Database
) extends VertexSrv[Profile] {
  lazy val organisationSrv: OrganisationSrv                      = organisationSrvProvider.get
  lazy val orgAdmin: Profile with Entity                         = db.roTransaction(graph => getOrFail(EntityName(Profile.orgAdmin.name))(graph)).get
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  override def createEntity(e: Profile)(implicit graph: Graph, authContext: AuthContext): Try[Profile with Entity] = {
    integrityCheckActor ! IntegrityCheck.EntityAdded("Profile")
    super.createEntity(e)
  }

  def create(profile: Profile)(implicit graph: Graph, authContext: AuthContext): Try[Profile with Entity] =
    for {
      createdProfile <- createEntity(profile)
      _              <- auditSrv.profile.create(createdProfile, createdProfile.toJson)
    } yield createdProfile

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[Profile] =
    startTraversal.getByName(name)

  override def exists(e: Profile)(implicit graph: Graph): Boolean = startTraversal.getByName(e.name).exists

  def remove(profile: Profile with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    if (!profile.isEditable)
      Failure(BadRequestError(s"Profile ${profile.name} cannot be removed"))
    else if (get(profile).filter(_.or(_.roles, _.shares)).exists)
      Failure(BadRequestError(s"Profile ${profile.name} is used"))
    else
      organisationSrv.getOrFail(authContext.organisation).flatMap { organisation =>
        get(profile).remove()
        auditSrv.profile.delete(profile, organisation)
      }

  override def update(
      traversal: Traversal.V[Profile],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[Profile], JsObject)] =
    if (traversal.clone().toIterator.exists(!_.isEditable))
      Failure(BadRequestError(s"Profile is not editable"))
    else super.update(traversal, propertyUpdaters)
}

object ProfileOps {

  implicit class ProfileOpsDefs(traversal: Traversal.V[Profile]) {

    def roles: Traversal.V[Role] = traversal.in[RoleProfile].v[Role]

    def shares: Traversal.V[Share] = traversal.in[ShareProfile].v[Share]

    def get(idOrName: EntityIdOrName): Traversal.V[Profile] =
      idOrName.fold(traversal.getByIds(_), getByName)

    def getByName(name: String): Traversal.V[Profile] = traversal.has(_.name, name)

    def contains(permission: Permission): Traversal.V[Profile] =
      traversal.has(_.permissions, permission)
  }

}

class ProfileIntegrityCheck @Inject() (val db: Database, val service: ProfileSrv) extends DedupCheck[Profile]

```

`thehive/app/org/thp/thehive/services/ReportTagSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.RichSeq
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.services.{EdgeSrv, VertexSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.thehive.models.{Observable, ObservableReportTag, ReportTag}
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.ReportTagOps._

import javax.inject.{Inject, Singleton}
import scala.util.Try

@Singleton
class ReportTagSrv @Inject() (observableSrv: ObservableSrv) extends VertexSrv[ReportTag] {
  val observableReportTagSrv = new EdgeSrv[ObservableReportTag, Observable, ReportTag]

  def updateTags(observable: Observable with Entity, reportTags: Seq[ReportTag])(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] = {
    reportTags.map(_.origin).distinct.foreach { origin =>
      observableSrv.get(observable).reportTags.fromOrigin(origin).remove()
    }
    reportTags
      .toTry { tag =>
        createEntity(tag).flatMap(t => observableReportTagSrv.create(ObservableReportTag(), observable, t))
      }
      .map(_ => ())
  }
}

object ReportTagOps {
  implicit class ReportTagOpsDefs(traversal: Traversal.V[ReportTag]) {
    def observable: Traversal.V[Observable] = traversal.in[ObservableReportTag].v[Observable]

    def fromOrigin(origin: String): Traversal.V[ReportTag] = traversal.has(_.origin, origin)
  }
}

```

`thehive/app/org/thp/thehive/services/ResolutionStatusSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services.{DedupCheck, IntegrityCheckOps, VertexSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.scalligraph.{CreateError, EntityIdOrName}
import org.thp.thehive.models.ResolutionStatus
import org.thp.thehive.services.ResolutionStatusOps._

import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class ResolutionStatusSrv @Inject() (integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]]) extends VertexSrv[ResolutionStatus] {
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[ResolutionStatus] =
    startTraversal.getByName(name)

  override def createEntity(e: ResolutionStatus)(implicit graph: Graph, authContext: AuthContext): Try[ResolutionStatus with Entity] = {
    integrityCheckActor ! IntegrityCheck.EntityAdded("Resolution")
    super.createEntity(e)
  }

  def create(resolutionStatus: ResolutionStatus)(implicit graph: Graph, authContext: AuthContext): Try[ResolutionStatus with Entity] =
    if (exists(resolutionStatus))
      Failure(CreateError(s"Resolution status ${resolutionStatus.value} already exists"))
    else
      createEntity(resolutionStatus)

  override def exists(e: ResolutionStatus)(implicit graph: Graph): Boolean = startTraversal.getByName(e.value).exists
}

object ResolutionStatusOps {
  implicit class ResolutionStatusOpsDefs(traversal: Traversal.V[ResolutionStatus]) {
    def get(idOrName: EntityIdOrName): Traversal.V[ResolutionStatus] =
      idOrName.fold(traversal.getByIds(_), getByName)

    def getByName(name: String): Traversal.V[ResolutionStatus] = traversal.has(_.value, name)
  }
}

class ResolutionStatusIntegrityCheck @Inject() (val db: Database, val service: ResolutionStatusSrv) extends DedupCheck[ResolutionStatus]

```

`thehive/app/org/thp/thehive/services/RoleSrv.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.thehive.models._
import org.thp.thehive.services.RoleOps._

import javax.inject.{Inject, Singleton}
import scala.util.Try

@Singleton
class RoleSrv @Inject() extends VertexSrv[Role] {

  val roleOrganisationSrv = new EdgeSrv[RoleOrganisation, Role, Organisation]
  val userRoleSrv         = new EdgeSrv[UserRole, User, Role]
  val roleProfileSrv      = new EdgeSrv[RoleProfile, Role, Profile]

  def create(user: User with Entity, organisation: Organisation with Entity, profile: Profile with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Role with Entity] =
    for {
      createdRole <- createEntity(Role())
      _           <- roleOrganisationSrv.create(RoleOrganisation(), createdRole, organisation)
      _           <- userRoleSrv.create(UserRole(), user, createdRole)
      _           <- roleProfileSrv.create(RoleProfile(), createdRole, profile)
    } yield createdRole
  // TODO add audit

  def updateProfile(
      role: Role with Entity,
      profile: Profile with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[RoleProfile with Entity] = {
    get(role).removeProfile()
    roleProfileSrv.create(RoleProfile(), role, profile)
  }
}

object RoleOps {
  implicit class RoleOpsDefs(traversal: Traversal.V[Role]) {
    def organisation: Traversal.V[Organisation] = traversal.out[RoleOrganisation].v[Organisation]

    def removeProfile(): Unit = {
      traversal.outE[RoleProfile].remove()
      ()
    }

    def profile: Traversal.V[Profile] = traversal.out[RoleProfile].v[Profile]
    def user: Traversal.V[User]       = traversal.in[UserRole].v[User]

  }
}

@Singleton
class RoleIntegrityCheck @Inject() (
    val db: Database,
    val service: RoleSrv,
    profileSrv: ProfileSrv,
    organisationSrv: OrganisationSrv,
    roleSrv: RoleSrv
) extends GlobalCheck[Role]
    with IntegrityCheckOps[Role] {
  override def globalCheck(traversal: Traversal.V[Role])(implicit graph: Graph): Map[String, Long] = {
    val orgOphanCount      = service.startTraversal.filterNot(_.organisation).sideEffect(_.drop()).getCount
    val userOrphanCount    = service.startTraversal.filterNot(_.user).sideEffect(_.drop()).getCount
    val profileOrphanCount = service.startTraversal.filterNot(_.profile).sideEffect(_.drop()).getCount
    Map("orgOrphan" -> orgOphanCount, "userOrphan" -> userOrphanCount, "profileOrphan" -> profileOrphanCount)
  }
}

```

`thehive/app/org/thp/thehive/services/ShareSrv.scala`:

```scala
package org.thp.thehive.services

import org.apache.tinkerpop.gremlin.process.traversal.P
import org.apache.tinkerpop.gremlin.structure.T
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.scalligraph.{CreateError, EntityId, EntityIdOrName}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._

import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Try}

@Singleton
class ShareSrv @Inject() (implicit
    auditSrv: AuditSrv,
    caseSrvProvider: Provider[CaseSrv],
    taskSrv: TaskSrv,
    observableSrvProvider: Provider[ObservableSrv]
) extends VertexSrv[Share] {
  lazy val caseSrv: CaseSrv             = caseSrvProvider.get
  lazy val observableSrv: ObservableSrv = observableSrvProvider.get

  val organisationShareSrv = new EdgeSrv[OrganisationShare, Organisation, Share]
  val shareProfileSrv      = new EdgeSrv[ShareProfile, Share, Profile]
  val shareCaseSrv         = new EdgeSrv[ShareCase, Share, Case]
  val shareTaskSrv         = new EdgeSrv[ShareTask, Share, Task]
  val shareObservableSrv   = new EdgeSrv[ShareObservable, Share, Observable]

  /**
    * Shares a case (creates a share entity) for a precise organisation
    * according to the given profile.
    *
    * @param owner indicate if the share owns the case
    * @param `case` the case to share
    * @param organisation the organisation to share for
    * @param profile the related share profile
    * @return
    */
  def shareCase(owner: Boolean, `case`: Case with Entity, organisation: Organisation with Entity, profile: Profile with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Share with Entity] =
    get(`case`, organisation._id).headOption match {
      case Some(_) => Failure(CreateError(s"Case #${`case`.number} is already shared with organisation ${organisation.name}"))
      case None =>
        for {
          createdShare <- createEntity(Share(owner))
          _            <- organisationShareSrv.create(OrganisationShare(), organisation, createdShare)
          _            <- shareCaseSrv.create(ShareCase(), createdShare, `case`)
          _            <- shareProfileSrv.create(ShareProfile(), createdShare, profile)
          _            <- caseSrv.get(`case`).addValue(_.organisationIds, organisation._id).getOrFail("Case")
          _            <- auditSrv.share.shareCase(`case`, organisation, profile)
        } yield createdShare
    }

  def get(`case`: Case with Entity, organisationName: EntityIdOrName)(implicit graph: Graph): Traversal.V[Share] =
    caseSrv.get(`case`).share(organisationName)

  def get(observable: Observable with Entity, organisationName: EntityIdOrName)(implicit graph: Graph): Traversal.V[Share] =
    observableSrv.get(observable).share(organisationName)

  def get(task: Task with Entity, organisationName: EntityIdOrName)(implicit graph: Graph): Traversal.V[Share] =
    taskSrv.get(task).share(organisationName)

  def updateProfile(
      share: Share with Entity,
      profile: Profile with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[ShareProfile with Entity] = {
    get(share).outE[ShareProfile].remove()
    for {
      newShareProfile <- shareProfileSrv.create(ShareProfile(), share, profile)
      case0           <- get(share).`case`.getOrFail("Case")
      organisation    <- get(share).organisation.getOrFail("Organisation")
      _               <- auditSrv.share.shareCase(case0, organisation, profile)
    } yield newShareProfile
  }

  def unshareCase(shareId: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      organisation <- get(shareId).organisation.getOrFail("Organisation")
      case0        <- get(shareId).`case`.removeValue(_.organisationIds, organisation._id).getOrFail("Case")
      _ = get(shareId).observables.removeValue(_.organisationIds, organisation._id).barrier().filterNot(_.shares.range(1, 2)).remove()
      _ = get(shareId).tasks.removeValue(_.organisationIds, organisation._id).barrier().filterNot(_.shares.range(1, 2)).remove()
      _ <- auditSrv.share.unshareCase(case0, organisation)
    } yield get(shareId).remove()

  def unshareTask(
      task: Task with Entity,
      organisation: Organisation with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      shareTask <-
        taskSrv
          .get(task)
          .removeValue(_.organisationIds, organisation._id)
          .inE[ShareTask]
          .filter(_.outV.v[Share].byOrganisation(organisation._id))
          .getOrFail("Task")
      case0 <- taskSrv.get(task).`case`.getOrFail("Case")
      _     <- auditSrv.share.unshareTask(task, case0, organisation)
    } yield shareTaskSrv.get(shareTask).remove()

  def unshareObservable(
      observable: Observable with Entity,
      organisation: Organisation with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      shareObservable <-
        observableSrv
          .get(observable)
          .removeValue(_.organisationIds, organisation._id)
          .inE[ShareObservable]
          .filter(_.outV.in[OrganisationShare].hasId(organisation._id))
          .getOrFail("Share")
      case0 <- observableSrv.get(observable).`case`.getOrFail("Case")
      _     <- auditSrv.share.unshareObservable(observable, case0, organisation)
    } yield shareObservableSrv.get(shareObservable).remove()

  /**
    * Shares all the tasks for an already shared case
    * @param share the associated share
    * @return
    */
  def shareCaseTasks(
      share: Share with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[Seq[ShareTask with Entity]] =
    for {
      organisation <- get(share).organisation.getOrFail("Share")
      shareTask <-
        get(share)
          .`case`
          .tasks
          .filter(_.shares.has(T.id, P.neq(share._id)))
          .toIterator
          .toTry { task =>
            taskSrv
              .get(task)
              .addValue(_.organisationIds, organisation._id)
              .getOrFail("Task")
              .flatMap(shareTaskSrv.create(ShareTask(), share, _))
          }
    } yield shareTask

  /**
    * Shares a task for an already shared case
    * @return
    */
  def shareTask(
      richTask: RichTask,
      `case`: Case with Entity,
      organisationId: EntityId
  )(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    for {
      share <- get(`case`, organisationId).getOrFail("Case")
      _     <- shareTaskSrv.create(ShareTask(), share, richTask.task)
      _     <- taskSrv.get(richTask.task).addValue(_.organisationIds, organisationId).getOrFail("Task")
      _     <- auditSrv.task.create(richTask.task, richTask.toJson)
    } yield ()

  /**
    * Shares an observable for an already shared case
    * @return
    */
  def shareObservable(richObservable: RichObservable, `case`: Case with Entity, organisationId: EntityId)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    for {
      share <- get(`case`, organisationId).getOrFail("Case")
      _     <- shareObservableSrv.create(ShareObservable(), share, richObservable.observable)
      _     <- observableSrv.get(richObservable.observable).addValue(_.organisationIds, organisationId).getOrFail("Observable")
      _     <- auditSrv.observable.create(richObservable.observable, richObservable.toJson)
    } yield ()

  /**
    * Shares all the observables for an already shared case
    * @param share the associated share
    * @return
    */
  def shareCaseObservables(
      share: Share with Entity
  )(implicit graph: Graph, authContext: AuthContext): Try[Seq[ShareObservable with Entity]] =
    for {
      organisation <- get(share).organisation.getOrFail("Share")
      shareObservable <-
        get(share)
          .`case`
          .observables // list observables related to authContext
          .filter(_.shares.has(T.id, P.neq(share._id)))
          .toIterator
          .toTry { obs =>
            observableSrv
              .get(obs)
              .addValue(_.organisationIds, organisation._id)
              .getOrFail("Observable")
              .flatMap(_ => shareObservableSrv.create(ShareObservable(), share, obs))

          }
    } yield shareObservable

  /**
    * Does a full rebuild of the share status of a task,
    * i.e. adds what's in the list and removes what's not
    * @param task the task concerned
    * @param organisations the organisations that are going to be able to see the task
    * @return
    */
  def updateTaskShares(
      task: Task with Entity,
      organisations: Set[Organisation with Entity]
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val (orgsToAdd, orgsToRemove) = taskSrv
      .get(task)
      .update(_.organisationIds, organisations.map(_._id))
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .shares
      .organisation
      .toIterator
      .foldLeft((organisations, Set.empty[Organisation with Entity])) {
        case ((toAdd, toRemove), o) if toAdd.contains(o) => (toAdd - o, toRemove)
        case ((toAdd, toRemove), o)                      => (toAdd, toRemove + o)
      }
    orgsToRemove.foreach(o => taskSrv.get(task).share(o._id).remove())
    orgsToAdd
      .toTry { organisation =>
        for {
          case0 <- taskSrv.get(task).`case`.getOrFail("Task")
          share <- caseSrv.get(case0).share(organisation._id).getOrFail("Share")
          _     <- shareTaskSrv.create(ShareTask(), share, task)
          _     <- auditSrv.share.shareTask(task, case0, organisation)
        } yield ()
      }
      .map(_ => ())
  }

  def addTaskShares(
      task: Task with Entity,
      organisations: Seq[Organisation with Entity]
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val existingOrgs = taskSrv
      .get(task)
      .shares
      .organisation
      .toSeq

    organisations
      .filterNot(existingOrgs.contains)
      .toTry { organisation =>
        for {
          case0 <- taskSrv.get(task).addValue(_.organisationIds, organisation._id).`case`.getOrFail("Task")
          share <- caseSrv.get(case0).share(organisation._id).getOrFail("Case")
          _     <- shareTaskSrv.create(ShareTask(), share, task)
          _     <- auditSrv.share.shareTask(task, case0, organisation)
        } yield ()
      }
      .map(_ => ())
  }

  def addObservableShares(
      observable: Observable with Entity,
      organisations: Seq[Organisation with Entity]
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val existingOrgs = observableSrv
      .get(observable)
      .shares
      .organisation
      .toSeq

    organisations
      .filterNot(existingOrgs.contains)
      .toTry { organisation =>
        for {
          case0 <- observableSrv.get(observable).addValue(_.organisationIds, organisation._id).`case`.getOrFail("Observable")
          share <- caseSrv.get(case0).share(organisation._id).getOrFail("Case")
          _     <- shareObservableSrv.create(ShareObservable(), share, observable)
          _     <- auditSrv.share.shareObservable(observable, case0, organisation)
        } yield ()
      }
      .map(_ => ())
  }

  /**
    * Does a full rebuild of the share status of an observable,
    * i.e. adds what's in the list and removes what's not
    * @param observable the observable concerned
    * @param organisations the organisations that are going to be able to see the observable
    * @return
    */
  def updateObservableShares(
      observable: Observable with Entity,
      organisations: Set[Organisation with Entity]
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val (orgsToAdd, orgsToRemove) = observableSrv
      .get(observable)
      .update(_.organisationIds, organisations.map(_._id))
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .shares
      .organisation
      .toIterator
      .foldLeft((organisations, Set.empty[Organisation with Entity])) {
        case ((toAdd, toRemove), o) if toAdd.contains(o) => (toAdd - o, toRemove)
        case ((toAdd, toRemove), o)                      => (toAdd, toRemove + o)
      }
    orgsToRemove.foreach(o => observableSrv.get(observable).removeValue(_.organisationIds, o._id).share(o._id).remove())
    orgsToAdd
      .toTry { organisation =>
        for {
          case0 <- observableSrv.get(observable).addValue(_.organisationIds, organisation._id).`case`.getOrFail("Observable")
          share <- caseSrv.get(case0).share(organisation._id).getOrFail("Case")
          _     <- shareObservableSrv.create(ShareObservable(), share, observable)
          _     <- auditSrv.share.shareObservable(observable, case0, organisation)
        } yield ()
      }
      .map(_ => ())
  }
}

object ShareOps {
  implicit class ShareOpsDefs(traversal: Traversal.V[Share]) {
    def get(idOrName: EntityIdOrName): Traversal.V[Share] =
      idOrName.fold(traversal.getByIds(_), _ => traversal.empty)

    def relatedTo(`case`: Case with Entity): Traversal.V[Share] = traversal.filter(_.`case`.hasId(`case`._id))

    def `case`: Traversal.V[Case] = traversal.out[ShareCase].v[Case]

    def relatedTo(organisation: Organisation with Entity): Traversal.V[Share] = traversal.filter(_.organisation.hasId(organisation._id))

    def organisation: Traversal.V[Organisation] = traversal.in[OrganisationShare].v[Organisation]

    def visible(implicit authContext: AuthContext): Traversal.V[Share] = traversal.filter(_.organisation.visible)

    def tasks: Traversal.V[Task] = traversal.out[ShareTask].v[Task]

    def byTask(taskId: EntityIdOrName): Traversal.V[Share] =
      traversal.filter(_.tasks.get(taskId))

    def byObservable(observableId: EntityIdOrName): Traversal.V[Share] =
      traversal.filter(_.observables.get(observableId))

    def byOrganisation(organisationName: EntityIdOrName): Traversal.V[Share] =
      traversal.filter(_.organisation.get(organisationName))

    def observables: Traversal.V[Observable] = traversal.out[ShareObservable].v[Observable]

    def profile: Traversal.V[Profile] = traversal.out[ShareProfile].v[Profile]

    def richShare: Traversal[RichShare, JMap[String, Any], Converter[RichShare, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.in[OrganisationShare].v[Organisation].value(_.name).fold)
            .by(_.out[ShareCase]._id.fold)
            .by(_.out[ShareProfile].v[Profile].value(_.name).fold)
        )
        .domainMap {
          case (share, organisationName, caseId, profileName) =>
            RichShare(
              share,
              caseId.head,
              organisationName.head,
              profileName.head
            )
        }
  }
}

```

`thehive/app/org/thp/thehive/services/StreamSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.{Actor, ActorIdentity, ActorRef, ActorSystem, Cancellable, Identify, PoisonPill, Props}
import akka.pattern.{ask, AskTimeoutException}
import akka.serialization.Serializer
import akka.util.Timeout
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services.EventSrv
import org.thp.scalligraph.services.config.ApplicationConfig.finiteDurationFormat
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.utils.Retry
import org.thp.scalligraph.{EntityId, NotFoundError}
import org.thp.thehive.services.AuditOps._
import play.api.Logger
import play.api.libs.json.Json

import java.io.NotSerializableException
import javax.inject.{Inject, Singleton}
import scala.collection.immutable
import scala.concurrent.duration.{DurationInt, FiniteDuration}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Random, Try}

sealed trait StreamMessage extends Serializable

object StreamTopic {
  def apply(streamId: String): String = s"stream-$streamId"
  val dispatcher: String              = "stream"
}

case class AuditStreamMessage(id: EntityId*) extends StreamMessage
/* Ask messages, wait if there is no ready messages */
case object GetStreamMessages extends StreamMessage
case object Commit            extends StreamMessage

/**
  * This actor receive message generated locally and when aggregation is finished (http request is over) send the message
  * to global stream actor.
  */
class StreamActor(
    organisationSrv: OrganisationSrv,
    authContext: AuthContext,
    refresh: FiniteDuration,
    maxWait: FiniteDuration,
    graceDuration: FiniteDuration,
    keepAlive: FiniteDuration,
    auditSrv: AuditSrv,
    db: Database
) extends Actor {
  import context.dispatcher

  lazy val logger: Logger = Logger(getClass)

  override def receive: Receive = {
    val keepAliveTimer = context.system.scheduler.scheduleOnce(keepAlive, self, PoisonPill)
    receive(Nil, keepAliveTimer)
  }

  def receive(messages: Seq[EntityId], keepAliveTimer: Cancellable): Receive = {
    case GetStreamMessages =>
      logger.debug(s"[$self] GetStreamMessages")
      // rearm keepalive
      keepAliveTimer.cancel()
      val newKeepAliveTimer = context.system.scheduler.scheduleOnce(keepAlive, self, PoisonPill)
      val commitTimer       = context.system.scheduler.scheduleOnce(refresh, self, Commit)
      val graceTimer =
        if (messages.isEmpty) None
        else Some(context.system.scheduler.scheduleOnce(graceDuration, self, Commit))
      context.become(receive(messages, sender, newKeepAliveTimer, commitTimer, graceTimer))

    case AuditStreamMessage(ids @ _*) =>
      db.roTransaction { implicit graph =>
        val visibleIds = auditSrv
          .getByIds(ids: _*)
          .visible(organisationSrv)(authContext)
          .toSeq
          .map(_._id)
        logger.debug(s"[$self] AuditStreamMessage $ids => $visibleIds")
        if (visibleIds.nonEmpty)
          context.become(receive(messages ++ visibleIds, keepAliveTimer))
      }
  }

  def receive(
      messages: Seq[EntityId],
      requestActor: ActorRef,
      keepAliveTimer: Cancellable,
      commitTimer: Cancellable,
      graceTimer: Option[Cancellable]
  ): Receive = {
    case GetStreamMessages =>
      logger.debug(s"[$self] GetStreamMessages")
      // rearm keepalive
      keepAliveTimer.cancel()
      val newKeepAliveTimer = context.system.scheduler.scheduleOnce(keepAlive, self, PoisonPill)
      commitTimer.cancel()
      val newCommitTimer = context.system.scheduler.scheduleOnce(refresh, self, Commit)
      graceTimer.foreach(_.cancel())
      val newGraceTimer =
        if (messages.isEmpty) None
        else Some(context.system.scheduler.scheduleOnce(graceDuration, self, Commit))
      context.become(receive(messages, sender, newKeepAliveTimer, newCommitTimer, newGraceTimer))

    case Commit =>
      logger.debug(s"[$self] Commit")
      commitTimer.cancel()
      graceTimer.foreach(_.cancel())
      requestActor ! AuditStreamMessage(messages: _*)
      context.become(receive(Nil, keepAliveTimer))

    case AuditStreamMessage(ids @ _*) =>
      db.roTransaction { implicit graph =>
        val visibleIds = auditSrv
          .getByIds(ids: _*)
          .visible(organisationSrv)(authContext)
          .toSeq
          .map(_._id)
        logger.debug(s"[$self] AuditStreamMessage $ids => $visibleIds")
        if (visibleIds.nonEmpty) {

          graceTimer.foreach(_.cancel())
          val newGraceTimer = context.system.scheduler.scheduleOnce(graceDuration, self, Commit)
          if (messages.isEmpty) {
            commitTimer.cancel()
            val newCommitTimer = context.system.scheduler.scheduleOnce(maxWait, self, Commit)
            context.become(receive(messages ++ visibleIds, requestActor, keepAliveTimer, newCommitTimer, Some(newGraceTimer)))
          } else
            context.become(receive(messages ++ visibleIds, requestActor, keepAliveTimer, commitTimer, Some(newGraceTimer)))
        }
      }
  }
}

@Singleton
class StreamSrv @Inject() (
    appConfig: ApplicationConfig,
    eventSrv: EventSrv,
    organisationSrv: OrganisationSrv,
    auditSrv: AuditSrv,
    db: Database,
    system: ActorSystem,
    implicit val ec: ExecutionContext
) {

  lazy val logger: Logger                      = Logger(getClass)
  val streamLength                             = 20
  val alphanumeric: immutable.IndexedSeq[Char] = ('a' to 'z') ++ ('A' to 'Z') ++ ('0' to '9')

  val refreshConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("stream.longPolling.refresh", "Response time when there is no message")
  def refresh: FiniteDuration = refreshConfig.get

  val maxWaitConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("stream.longPolling.maxWait", "Maximum latency when a message is ready to send")
  def maxWait: FiniteDuration = maxWaitConfig.get

  val graceDurationConfig: ConfigItem[FiniteDuration, FiniteDuration] = appConfig
    .item[FiniteDuration]("stream.longPolling.graceDuration", "When a message is ready to send, wait this time to include potential other messages")
  def graceDuration: FiniteDuration = graceDurationConfig.get

  val keepAliveConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("stream.longPolling.keepAlive", "Remove the stream after this time of inactivity")
  val keepAlive: FiniteDuration = keepAliveConfig.get

  val maxAttemptsConfig: ConfigItem[Int, Int] =
    appConfig.item[Int]("stream.get.maxAttempts", "How many attempts to get stream")
  def maxAttempts: Int = maxAttemptsConfig.get

  val minBackoffConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("stream.get.minBackoff", "Minimum backoff for get stream attempts")
  def minBackoff: FiniteDuration = minBackoffConfig.get

  val maxBackoffConfig: ConfigItem[FiniteDuration, FiniteDuration] =
    appConfig.item[FiniteDuration]("stream.get.maxBackoff", "Maximum backoff for get stream attempts")
  def maxBackoff: FiniteDuration = maxBackoffConfig.get

  val randomFactorConfig: ConfigItem[Double, Double] =
    appConfig.item[Double]("stream.get.randomFactor", "Random factor for stream attempts backoff")
  def randomFactor: Double = randomFactorConfig.get

  def generateStreamId(): String = Seq.fill(streamLength)(alphanumeric(Random.nextInt(alphanumeric.size))).mkString

  def isValidStreamId(streamId: String): Boolean = streamId.length == streamLength && streamId.forall(alphanumeric.contains)

  def create(implicit authContext: AuthContext): String = {
    val streamId = generateStreamId()
    val streamActor =
      system.actorOf(
        Props(classOf[StreamActor], organisationSrv, authContext, refresh, maxWait, graceDuration, keepAlive, auditSrv, db),
        s"stream-$streamId"
      )
    logger.debug(s"Register stream actor ${streamActor.path}")
    eventSrv.subscribe(StreamTopic(streamId), streamActor)
    eventSrv.subscribe(StreamTopic.dispatcher, streamActor)
    streamId
  }

  def get(streamId: String): Future[Seq[EntityId]] = {
    implicit val timeout: Timeout = Timeout(refresh + 1.second)
    Retry(maxAttempts).withBackoff(minBackoff, maxBackoff, randomFactor)(system.scheduler, system.dispatcher) {
      // Check if stream actor exists
      eventSrv
        .publishAsk(StreamTopic(streamId))(Identify(1))(Timeout(2.seconds))
        //      .ask(s"/user/stream-$streamId", Identify(1))(Timeout(2.seconds))
        .flatMap {
          case ActorIdentity(1, Some(streamActor)) =>
            logger.debug(s"Stream actor found for stream $streamId")
            (streamActor ? GetStreamMessages)
              .map {
                case AuditStreamMessage(ids @ _*) => ids
                case _                            => Nil
              }
          case other => Future.failed(NotFoundError(s"Stream $streamId doesn't exist: $other"))
        }
        .recoverWith {
          case _: AskTimeoutException => Future.failed(NotFoundError(s"Stream $streamId doesn't exist"))
        }
    }
  }
}

class StreamSerializer extends Serializer {

  def identifier: Int = 226591535
  def includeManifest = false

  /**
    * Serializes the given object into an Array of Byte
    */
  def toBinary(o: AnyRef): Array[Byte] =
    o match {
      case AuditStreamMessage(ids @ _*) => Json.toJson(ids).toString.getBytes
      case GetStreamMessages            => "GetStreamMessages".getBytes
      case Commit                       => "Commit".getBytes
      case _                            => Array.empty[Byte] // Not serializable
    }

  /**
    * Produces an object from an array of bytes, with an optional type-hint;
    * the class should be loaded using ActorSystem.dynamicAccess.
    */
  @throws(classOf[NotSerializableException])
  def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef =
    new String(bytes) match {
      case "GetStreamMessages" => GetStreamMessages
      case "Commit"            => Commit
      case s                   => Try(AuditStreamMessage(Json.parse(s).as[Seq[String]].map(EntityId.read): _*)).getOrElse(throw new NotSerializableException)
    }
}

```

`thehive/app/org/thp/thehive/services/TOTPAuthSrv.scala`:

```scala
package org.thp.thehive.services

import org.apache.commons.codec.binary.Base32
import org.thp.scalligraph.auth._
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AuthenticationError, EntityIdOrName, MultiFactorCodeRequired}
import play.api.Configuration
import play.api.mvc.RequestHeader

import java.net.URI
import java.util.Date
import java.util.concurrent.TimeUnit
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec
import javax.inject.{Inject, Provider, Singleton}
import scala.collection.immutable
import scala.util.{Failure, Random, Success, Try}

class TOTPAuthSrv(
    configuration: Configuration,
    appConfig: ApplicationConfig,
    availableAuthProviders: immutable.Set[AuthSrvProvider],
    userSrv: UserSrv,
    db: Database
) extends MultiAuthSrv(configuration, appConfig, availableAuthProviders) {
  override val name: String = "totp"

  val enabledConfig: ConfigItem[Boolean, Boolean] = appConfig.item[Boolean]("auth.multifactor.enabled", "multifactor activation")
  def enabled: Boolean                            = enabledConfig.get

  val issuerNameConfig: ConfigItem[String, String] = appConfig.item[String]("auth.multifactor.issuer", "name of the multifactor issuer")
  def issuerName: String                           = issuerNameConfig.get

  override def capabilities: Set[AuthCapability.Value] = if (enabled) super.capabilities + AuthCapability.mfa else super.capabilities

  def codeIsValid(secret: String, code: Int): Boolean = {
    val key     = new Base32().decode(secret)
    val signKey = new SecretKeySpec(key, "HmacSHA1")
    val mac     = Mac.getInstance("HmacSHA1")
    mac.init(signKey)
    val timestamp = System.currentTimeMillis() / TimeUnit.SECONDS.toMillis(30)
    (timestamp - 1 to timestamp + 1).exists { ts =>
      val data   = (56 to 0 by -8).map(i => (ts >> i).toByte).toArray
      val hash   = mac.doFinal(data)
      val offset = hash(hash.length - 1) & 0xf
      (BigInt(hash.slice(offset, offset + 4)).toInt & 0x7fffffff) % 1000000 == code
    }
  }

  def checkCode(secret: String, code: Option[String]): Try[Unit] =
    code
      .flatMap(c => Try(c.toInt).toOption)
      .map {
        case intCode if codeIsValid(secret, intCode) => Success(())
        case _                                       => Failure(AuthenticationError("Invalid MFA code"))
      }
      .getOrElse(Failure(MultiFactorCodeRequired("MFA code is required")))

  override def authenticate(username: String, password: String, organisation: Option[EntityIdOrName], code: Option[String])(implicit
      request: RequestHeader
  ): Try[AuthContext] =
    super.authenticate(username, password, organisation, code).flatMap {
      case authContext if !enabled => Success(authContext)
      case authContext =>
        db.roTransaction(implicit graph => getSecret(username)) match {
          case Some(secret) => checkCode(secret, code).map(_ => authContext)
          case None         => Success(authContext)
        }
    }

  def getSecret(username: String)(implicit graph: Graph): Option[String] =
    userSrv.get(EntityIdOrName(username)).headOption.flatMap(_.totpSecret)

  def unsetSecret(username: String)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    userSrv
      .get(EntityIdOrName(username))
      .update(_.totpSecret, None)
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .domainMap(_ => ())
      .getOrFail("User")

  def generateSecret(): String = {
    val key = Array.ofDim[Byte](20)
    Random.nextBytes(key)
    new Base32().encodeToString(key)
  }

  def setSecret(username: String)(implicit graph: Graph, authContext: AuthContext): Try[String] =
    setSecret(username, generateSecret())

  def setSecret(username: String, secret: String)(implicit graph: Graph, authContext: AuthContext): Try[String] =
    userSrv
      .get(EntityIdOrName(username))
      .update(_.totpSecret, Some(secret))
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .domainMap(_ => secret)
      .getOrFail("User")

  def getSecretURI(username: String, secret: String): URI =
    new URI("otpauth", "totp", s"/TheHive:$username", s"secret=$secret&issuer=$issuerName", null)
}

@Singleton
class TOTPAuthSrvProvider @Inject() (
    configuration: Configuration,
    appConfig: ApplicationConfig,
    authProviders: immutable.Set[AuthSrvProvider],
    userSrv: UserSrv,
    db: Database
) extends Provider[AuthSrv] {
  override def get(): AuthSrv = new TOTPAuthSrv(configuration, appConfig, authProviders, userSrv, db)
}

```

`thehive/app/org/thp/thehive/services/TagSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.apache.tinkerpop.gremlin.process.traversal.TextP
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.scalligraph.utils.FunctionalCondition.When
import org.thp.thehive.models._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.TagOps._

import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.util.matching.Regex
import scala.util.{Success, Try}

@Singleton
class TagSrv @Inject() (
    organisationSrv: OrganisationSrv,
    taxonomySrvProvider: Provider[TaxonomySrv],
    appConfig: ApplicationConfig,
    integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]]
) extends VertexSrv[Tag] {
  lazy val taxonomySrv: TaxonomySrv                              = taxonomySrvProvider.get
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  val taxonomyTagSrv = new EdgeSrv[TaxonomyTag, Taxonomy, Tag]
  private val freeTagColourConfig: ConfigItem[String, String] =
    appConfig.item[String]("tags.freeTagColour", "Default colour for free tags")

  def freeTagColour: String = freeTagColourConfig.get

  private def freeTagNamespace(implicit graph: Graph, authContext: AuthContext): String =
    s"_freetags_${organisationSrv.currentId(graph, authContext).value}"

  def fromString(tagName: String): Option[(String, String, Option[String])] = {
    val namespacePredicateValue: Regex = "([^\".:=]+)[.:]([^\".=]+)=\"?([^\"]+)\"?".r
    val namespacePredicate: Regex      = "([^\".:=]+)[.:]([^\".=]+)".r

    tagName match {
      case namespacePredicateValue(namespace, predicate, value) if value.exists(_ != '=') =>
        Some((namespace.trim, predicate.trim, Some(value.trim)))
      case namespacePredicate(namespace, predicate) =>
        Some((namespace.trim, predicate.trim, None))
      case _ => None
    }
  }

  def getTag(tag: Tag)(implicit graph: Graph): Traversal.V[Tag] = startTraversal.getTag(tag)

  def getFreetag(idOrName: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Traversal.V[Tag] =
    startTraversal.getFreetag(organisationSrv, idOrName)

  def getOrCreate(tagName: String)(implicit graph: Graph, authContext: AuthContext): Try[Tag with Entity] =
    fromString(tagName)
      .flatMap {
        case (ns, pred, v) => startTraversal.getByName(ns, pred, v).headOption
      }
      .fold {
        startTraversal
          .getByName(freeTagNamespace, tagName, None)
          .getOrFail("Tag")
          .orElse(createFreeTag(tagName))
      }(Success(_))

  private def createFreeTag(tagName: String)(implicit graph: Graph, authContext: AuthContext): Try[Tag with Entity] =
    for {
      freetagTaxonomy <- taxonomySrv.getFreetagTaxonomy
      tag             <- createEntity(Tag(freeTagNamespace, tagName, None, None, freeTagColour))
      _               <- taxonomyTagSrv.create(TaxonomyTag(), freetagTaxonomy, tag)
    } yield tag

  def create(tag: Tag)(implicit graph: Graph, authContext: AuthContext): Try[Tag with Entity] = {
    integrityCheckActor ! IntegrityCheck.EntityAdded("Tag")
    super.createEntity(tag)
  }

  override def exists(e: Tag)(implicit graph: Graph): Boolean = startTraversal.getByName(e.namespace, e.predicate, e.value).exists

  def update(
      tag: Tag with Entity,
      input: Tag
  )(implicit graph: Graph, authContext: AuthContext): Try[Tag with Entity] =
    for {
      updatedTag <- get(tag)
        .when(tag.description != input.description)(_.update(_.description, input.description))
        .when(tag.colour != input.colour)(_.update(_.colour, input.colour))
        .when(input != tag)(_.update(_._updatedAt, Some(new Date)).update(_._updatedBy, Some(authContext.userId)))
        .getOrFail("Tag")
    } yield updatedTag

  // TODO add audit
  override def delete(tag: Tag with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val tagName = tag.toString
    Try {
      get(tag)
        .sideEffect(
          _.unionFlat(
            _.`case`.removeValue(_.tags, tagName),
            _.alert.removeValue(_.tags, tagName),
            _.observable.removeValue(_.tags, tagName),
            _.caseTemplate.removeValue(_.tags, tagName)
          )
        )
        .remove()
    }
  }
}

object TagOps {

  implicit class TagOpsDefs(traversal: Traversal.V[Tag]) {

    def getTag(tag: Tag): Traversal.V[Tag] = getByName(tag.namespace, tag.predicate, tag.value)

    def getByName(namespace: String, predicate: String, value: Option[String]): Traversal.V[Tag] = {
      val t = traversal
        .has(_.namespace, namespace)
        .has(_.predicate, predicate)
      value.fold(t.hasNot(_.value))(v => t.has(_.value, v))
    }

    def taxonomy: Traversal.V[Taxonomy] = traversal.in[TaxonomyTag].v[Taxonomy]

    def organisation: Traversal.V[Organisation]                           = traversal.in[TaxonomyTag].in[OrganisationTaxonomy].v[Organisation]
    def displayName: Traversal[String, Vertex, Converter[String, Vertex]] = traversal.domainMap(_.toString)

    def fromCase: Traversal.V[Tag] = traversal.filter(_.in[CaseTag])
    def `case`: Traversal.V[Case]  = traversal.in[CaseTag].v[Case]

    def fromObservable: Traversal.V[Tag]    = traversal.filter(_.in[ObservableTag])
    def observable: Traversal.V[Observable] = traversal.in[ObservableTag].v[Observable]

    def fromAlert: Traversal.V[Tag] = traversal.filter(_.in[AlertTag])
    def alert: Traversal.V[Alert]   = traversal.in[AlertTag].v[Alert]

    def fromCaseTemplate: Traversal.V[Tag]      = traversal.filter(_.in[CaseTemplateTag])
    def caseTemplate: Traversal.V[CaseTemplate] = traversal.in[CaseTemplateTag].v[CaseTemplate]

    def freetags(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Tag] = {
      val freeTagNamespace: String = s"_freetags_${organisationSrv.currentId(traversal.graph, authContext).value}"
      traversal
        .has(_.namespace, freeTagNamespace)
    }

    def freetags: Traversal.V[Tag] = traversal.has(_.namespace, TextP.startingWith("_freetag_"))

    def getFreetag(organisationSrv: OrganisationSrv, idOrName: EntityIdOrName)(implicit authContext: AuthContext): Traversal.V[Tag] =
      idOrName.fold(traversal.getByIds(_), traversal.has(_.predicate, _)).freetags(organisationSrv)

    def autoComplete(organisationSrv: OrganisationSrv, freeTag: String)(implicit authContext: AuthContext): Traversal.V[Tag] =
      freetags(organisationSrv)
        .has(_.predicate, TextP.containing(freeTag))

    def autoComplete(namespace: Option[String], predicate: Option[String], value: Option[String])(implicit
        authContext: AuthContext
    ): Traversal.V[Tag] =
      traversal
        .merge(namespace)((t, ns) => t.has(_.namespace, TextP.containing(ns)))
        .merge(predicate)((t, p) => t.has(_.predicate, TextP.containing(p)))
        .merge(value)((t, v) => t.has(_.value, TextP.containing(v)))
        .visible

    def visible(implicit authContext: AuthContext): Traversal.V[Tag] =
      traversal.filter(_.organisation.current)

    def withCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Tag] => Traversal[D, G, C]
    ): Traversal[(Tag with Entity, D), JMap[String, Any], Converter[(Tag with Entity, D), JMap[String, Any]]] =
      traversal.project(_.by.by(entityRenderer))
  }
}

class TagIntegrityCheck @Inject() (val db: Database, val service: TagSrv) extends DedupCheck[Tag] with GlobalCheck[Tag] with IntegrityCheckOps[Tag] {
  override def extraFilter(traversal: Traversal.V[Tag]): Traversal.V[Tag] =
    traversal
      .freetags
      .filterNot(_.or(_.alert, _.observable, _.`case`, _.caseTemplate))

  override def globalCheck(traversal: Traversal.V[Tag])(implicit graph: Graph): Map[String, Long] =
    Map("orphan" -> traversal.sideEffect(_.drop()).getCount)
}

```

`thehive/app/org/thp/thehive/services/TaskSrv.scala`:

```scala
package org.thp.thehive.services

import org.apache.tinkerpop.gremlin.process.traversal.P
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.auth.{AuthContext, Permission}
import org.thp.scalligraph.models.{Database, Entity, Model, UMapping}
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.scalligraph.utils.FunctionalCondition._
import org.thp.scalligraph.{EntityId, EntityIdOrName}
import org.thp.thehive.models._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import play.api.libs.json.{JsNull, JsObject, Json}

import java.lang.{Boolean => JBoolean}
import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Try}

@Singleton
class TaskSrv @Inject() (
    caseSrvProvider: Provider[CaseSrv],
    auditSrv: AuditSrv,
    organisationSrv: OrganisationSrv,
    userSrv: UserSrv,
    shareSrvProvider: Provider[ShareSrv],
    logSrvProvider: Provider[LogSrv]
) extends VertexSrv[Task] {

  lazy val shareSrv: ShareSrv = shareSrvProvider.get
  lazy val caseSrv: CaseSrv   = caseSrvProvider.get
  lazy val logSrv: LogSrv     = logSrvProvider.get
  val caseTemplateTaskSrv     = new EdgeSrv[CaseTemplateTask, CaseTemplate, Task]
  val taskUserSrv             = new EdgeSrv[TaskUser, Task, User]
  val taskLogSrv              = new EdgeSrv[TaskLog, Task, Log]

  def create(task: Task, assignee: Option[User with Entity])(implicit graph: Graph, authContext: AuthContext): Try[RichTask] =
    for {
      createdTask <- createEntity(task.copy(assignee = assignee.map(_.login)))
      _           <- assignee.map(taskUserSrv.create(TaskUser(), createdTask, _)).flip
    } yield RichTask(createdTask)

  def unassign(task: Task with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(task)
      .update(_.assignee, None)
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .outE[TaskUser]
      .remove()
    auditSrv.task.update(task, Json.obj("assignee" -> JsNull))
  }

  def remove(task: Task with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    get(task).caseTemplate.headOption match {
      case None => Try(get(task).remove())
      case Some(caseTemplate) =>
        auditSrv
          .caseTemplate
          .update(caseTemplate, JsObject.empty)
          .map(_ => get(task).remove())
    }

  override def delete(t: Task with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    if (get(t).isShared.head)
      for {
        orga <- organisationSrv.getOrFail(authContext.organisation)
      } yield shareSrv.unshareTask(t, orga)
    else
      for {
        _ <- get(t).logs.toSeq.toTry(logSrv.delete(_))
      } yield remove(t)

  override def update(
      traversal: Traversal.V[Task],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[Task], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (taskSteps, updatedFields) =>
        for {
          t <- taskSteps.clone().getOrFail("Task")
          _ <- auditSrv.task.update(t, updatedFields)
        } yield ()
    }

  /**
    * Tries to update the status of a task with related fields
    * according the status value if empty
    * @param task the task to update
    * @param status the status to set
    * @param graph db
    * @param authContext auth db
    * @return
    */
  def updateStatus(task: Task with Entity, status: TaskStatus.Value)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Task with Entity] = {
    def setStatus(): Traversal.V[Task] =
      get(task)
        .update(_.status, status)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))

    status match {
      case TaskStatus.Cancel | TaskStatus.Waiting => setStatus().getOrFail("Task")
      case TaskStatus.Completed                   => setStatus().when(task.endDate.isEmpty)(_.update(_.endDate, Some(new Date()))).getOrFail("Task")
      case TaskStatus.InProgress =>
        setStatus()
          .when(task.startDate.isEmpty)(_.update(_.startDate, Some(new Date())))
          .getOrFail("Task")
          .when(task.assignee.isEmpty) { updatedTask =>
            for {
              t        <- updatedTask
              assignee <- userSrv.current.getOrFail("User")
              _        <- assign(t, assignee)
            } yield t
          }
      case _ => Failure(new Exception(s"Invalid TaskStatus $status for update"))
    }
  }

  def assign(task: Task with Entity, user: User with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    get(task)
      .update(_.assignee, Some(user.login))
      .update(_._updatedAt, Some(new Date))
      .update(_._updatedBy, Some(authContext.userId))
      .outE[TaskUser]
      .remove()
    for {
      _ <- taskUserSrv.create(TaskUser(), task, user)
      _ <- auditSrv.task.update(task, Json.obj("assignee" -> user.login))
    } yield ()
  }

  def actionRequired(
      task: Task with Entity,
      organisation: Organisation with Entity,
      actionRequired: Boolean
  )(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    val details = Json.obj(s"actionRequired.${organisation.name}" -> actionRequired)
    auditSrv.task.update(task, details).map { _ =>
      organisationSrv
        .get(organisation)
        .out[OrganisationShare]
        .outE[ShareTask]
        .filter(_.inV.v[Task].hasId(task._id))
        .update(_.actionRequired, actionRequired)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .iterate()
    }
  }
}

object TaskOps {
  implicit class TaskOpsDefs(traversal: Traversal.V[Task]) {

    def get(idOrName: EntityIdOrName): Traversal.V[Task] =
      idOrName.fold(traversal.getByIds(_), _ => traversal.empty)

    def visible(organisationSrv: OrganisationSrv)(implicit authContext: AuthContext): Traversal.V[Task] =
      traversal.has(_.organisationIds, organisationSrv.currentId(traversal.graph, authContext))

    def assignTo(login: String): Traversal.V[Task] = traversal.has(_.assignee, login)

    def relatedTo(caseId: EntityId): Traversal.V[Task] =
      traversal.has(_.relatedId, caseId)

    def inOrganisation(organisationId: EntityId): Traversal.V[Task] =
      traversal.has(_.organisationIds, organisationId)

    def active: Traversal.V[Task] = traversal.hasNot(_.status, TaskStatus.Cancel)

    def can(permission: Permission)(implicit authContext: AuthContext): Traversal.V[Task] =
      if (authContext.permissions.contains(permission))
        traversal.filter(_.shares.filter(_.profile.has(_.permissions, permission)).organisation.current)
      else
        traversal.empty

    def inCase: Traversal.V[Task] = traversal.filter(_.inE[ShareTask])

    def `case`: Traversal.V[Case] = traversal.in[ShareTask].out[ShareCase].dedup.v[Case]

    def caseTemplate: Traversal.V[CaseTemplate] = traversal.in[CaseTemplateTask].v[CaseTemplate]

    def logs: Traversal.V[Log] = //traversal.out[TaskLog].v[Log]
      traversal.graph.V()(Model.vertex[Log]).has(_.taskId, P.within(traversal._id.toSeq: _*))

    def assignee: Traversal.V[User] = traversal.out[TaskUser].v[User]

    def unassigned: Traversal.V[Task] = traversal.filterNot(_.outE[TaskUser])

    def organisations: Traversal.V[Organisation] = traversal.in[ShareTask].in[OrganisationShare].v[Organisation]

    def organisations(permission: Permission): Traversal.V[Organisation] =
      shares.filter(_.profile.has(_.permissions, permission)).organisation

    def origin: Traversal.V[Organisation] = shares.has(_.owner, true).organisation

    def assignableUsers(implicit authContext: AuthContext): Traversal.V[User] =
      organisations(Permissions.manageTask)
        .visible
        .users(Permissions.manageTask)
        .dedup

    def isShared: Traversal[Boolean, Boolean, Converter.Identity[Boolean]] =
      traversal.choose(_.inE[ShareTask].count.is(P.gt(1)), true, false)

    def actionRequired(implicit authContext: AuthContext): Traversal[Boolean, JBoolean, Converter[Boolean, JBoolean]] =
      traversal.inE[ShareTask].filter(_.outV.v[Share].organisation.current).value(_.actionRequired)

    def actionRequiredMap(implicit
        authContext: AuthContext
    ): Traversal[(String, Boolean), JMap[String, Any], Converter[(String, Boolean), JMap[String, Any]]] =
      traversal
        .inE[ShareTask]
        .filter(_.outV.v[Share].organisation.visible)
        .project(
          _.by(_.outV.v[Share].organisation.value(_.name))
            .byValue(_.actionRequired)
        )

    def richTask: Traversal[RichTask, Vertex, Converter[RichTask, Vertex]] =
      traversal.identity.domainMap(RichTask) // FIXME add actionRequired ?

    def richTaskWithoutActionRequired: Traversal[RichTask, Vertex, Converter[RichTask, Vertex]] =
      traversal.identity.domainMap(RichTask)

    def richTaskWithCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Task] => Traversal[D, G, C]
    ): Traversal[(RichTask, D), JMap[String, Any], Converter[(RichTask, D), JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(entityRenderer)
        )
        .domainMap {
          case (task, renderedEntity) =>
            RichTask(task) -> renderedEntity
        }

    def shares: Traversal.V[Share] = traversal.in[ShareTask].v[Share]

    def share(implicit authContext: AuthContext): Traversal.V[Share] = share(authContext.organisation)

    def share(organisation: EntityIdOrName): Traversal.V[Share] =
      traversal.in[ShareTask].filter(_.in[OrganisationShare].v[Organisation].get(organisation)).v[Share]
  }
}

class TaskIntegrityCheck @Inject() (val db: Database, val service: TaskSrv, organisationSrv: OrganisationSrv, userSrv: UserSrv)
    extends GlobalCheck[Task]
    with IntegrityCheckOps[Task] {
  override def globalCheck(traversal: Traversal.V[Task])(implicit graph: Graph): Map[String, Long] = {
    val orgCheck = multiIdLink[Organisation]("organisationIds", organisationSrv)(_.remove)
    val removeOrphan: OrphanStrategy[Task, EntityId] = { (_, entity) =>
      service.get(entity).remove()
      Map("Task-relatedId-removeOrphan" -> 1L)
    }
    val relatedCheck = new SingleLinkChecker[Product, EntityId, EntityId](
      orphanStrategy = removeOrphan,
      setField = (entity, link) => UMapping.entityId.setProperty(service.get(entity), "relatedId", link._id).iterate(),
      entitySelector = _ => EntitySelector.firstCreatedEntity,
      removeLink = (_, _) => (),
      getLink = id => graph.VV(id).entity.head,
      Some(_)
    )
    val assigneeCheck = singleOptionLink[User, String]("assignee", userSrv.getByName(_).head, _.login)(_.outEdge[TaskUser])

    traversal
      .project(
        _.by
          .by(_.unionFlat(_.`case`._id, _.caseTemplate._id).fold)
          .by(_.unionFlat(_.organisations._id, _.caseTemplate.organisation._id).fold)
          .by(_.assignee.value(_.login).fold)
      )
      .toIterator
      .map {
        case (task, relatedIds, organisationIds, assignees) =>
          val orgStats      = orgCheck.check(task, task.organisationIds, organisationIds)
          val relatedStats  = relatedCheck.check(task, task.relatedId, relatedIds)
          val assigneeStats = assigneeCheck.check(task, task.assignee, assignees)
          orgStats <+> relatedStats <+> assigneeStats
      }
      .reduceOption(_ <+> _)
      .getOrElse(Map.empty)
  }
}

```

`thehive/app/org/thp/thehive/services/TaxonomySrv.scala`:

```scala
package org.thp.thehive.services

import org.apache.tinkerpop.gremlin.process.traversal.TextP
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.services.{EdgeSrv, VertexSrv}
import org.thp.scalligraph.traversal.TraversalOps.TraversalOpsDefs
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.scalligraph.utils.FunctionalCondition.When
import org.thp.scalligraph.{BadRequestError, EntityId, EntityIdOrName, RichSeq}
import org.thp.thehive.models._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.TagOps._
import org.thp.thehive.services.TaxonomyOps._

import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class TaxonomySrv @Inject() (organisationSrv: OrganisationSrv, tagSrv: TagSrv) extends VertexSrv[Taxonomy] {

  val taxonomyTagSrv          = new EdgeSrv[TaxonomyTag, Taxonomy, Tag]
  val organisationTaxonomySrv = new EdgeSrv[OrganisationTaxonomy, Organisation, Taxonomy]

  def create(taxo: Taxonomy, tags: Seq[Tag with Entity])(implicit graph: Graph, authContext: AuthContext): Try[RichTaxonomy] =
    for {
      taxonomy     <- createEntity(taxo)
      _            <- tags.toTry(t => taxonomyTagSrv.create(TaxonomyTag(), taxonomy, t))
      richTaxonomy <- Try(RichTaxonomy(taxonomy, tags))
    } yield richTaxonomy

  def createFreetagTaxonomy(organisation: Organisation with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Taxonomy with Entity] = {
    val customTaxo = Taxonomy(s"_freetags_${organisation._id.value}", "Custom taxonomy", 1)
    for {
      taxonomy <- createEntity(customTaxo)
      _        <- organisationTaxonomySrv.create(OrganisationTaxonomy(), organisation, taxonomy)
    } yield taxonomy
  }

  def getFreetagTaxonomy(implicit graph: Graph, authContext: AuthContext): Try[Taxonomy with Entity] =
    getByName(s"_freetags_${organisationSrv.currentId.value}")
      .getOrFail("FreetagTaxonomy")
      .orElse {
        organisationSrv.current.notAdmin.getOrFail("Organisation").flatMap(createFreetagTaxonomy)
      }

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[Taxonomy] =
    startTraversal.getByNamespace(name)

  def update(taxonomy: Taxonomy with Entity, input: Taxonomy)(implicit graph: Graph, authContext: AuthContext): Try[RichTaxonomy] =
    for {
      updatedTaxonomy <-
        get(taxonomy)
          .when(taxonomy.namespace != input.namespace)(_.update(_.namespace, input.namespace))
          .when(taxonomy.description != input.description)(_.update(_.description, input.description))
          .when(taxonomy.version != input.version)(_.update(_.version, input.version))
          .when(input != taxonomy)(_.update(_._updatedAt, Some(new Date)).update(_._updatedBy, Some(authContext.userId)))
          .richTaxonomy
          .getOrFail("Taxonomy")
    } yield updatedTaxonomy

  def updateOrCreateTag(namespace: String, t: Tag)(implicit graph: Graph, authContext: AuthContext): Try[Tag with Entity] =
    if (getByName(namespace).doesTagExists(t))
      for {
        tag        <- tagSrv.getTag(t).getOrFail("Tag")
        updatedTag <- tagSrv.update(tag, t)
      } yield updatedTag
    else
      for {
        tag  <- tagSrv.create(t)
        taxo <- getByName(namespace).getOrFail("Taxonomy")
        _    <- taxonomyTagSrv.create(TaxonomyTag(), taxo, tag)
      } yield tag

  def activate(taxonomyId: EntityIdOrName)(implicit graph: Graph, authContext: AuthContext): Try[Unit] =
    for {
      taxo <- get(taxonomyId).getOrFail("Taxonomy")
      _ <-
        if (taxo.namespace.startsWith("_freetags")) Failure(BadRequestError("Cannot activate a freetags taxonomy"))
        else Success(())
      _ <-
        organisationSrv
          .startTraversal
          .filterNot(_.out[OrganisationTaxonomy].v[Taxonomy].has(_.namespace, taxo.namespace))
          .toSeq
          .toTry(o => organisationTaxonomySrv.create(OrganisationTaxonomy(), o, taxo))
    } yield ()

  def deactivate(taxonomyId: EntityIdOrName)(implicit graph: Graph): Try[Unit] =
    for {
      taxo <- getOrFail(taxonomyId)
      _ <-
        if (taxo.namespace.startsWith("_freetags")) Failure(BadRequestError("Cannot deactivate a freetags taxonomy"))
        else Success(())
    } yield get(taxonomyId).inE[OrganisationTaxonomy].remove()

}

object TaxonomyOps {
  implicit class TaxonomyOpsDefs(traversal: Traversal.V[Taxonomy]) {

    def get(idOrName: EntityId): Traversal.V[Taxonomy] =
      idOrName.fold(traversal.getByIds(_), getByNamespace)

    def getByNamespace(namespace: String): Traversal.V[Taxonomy] = traversal.has(_.namespace, namespace)

    def visible(implicit authContext: AuthContext): Traversal.V[Taxonomy] =
      if (authContext.isPermitted(Permissions.manageTaxonomy))
        noFreetags
      else
        noFreetags.filter(_.organisations.get(authContext.organisation))

    def noFreetags: Traversal.V[Taxonomy] =
      traversal.hasNot(_.namespace, TextP.startingWith("_freetags"))

    def freetags: Traversal.V[Taxonomy] =
      traversal.has(_.namespace, TextP.startingWith("_freetags"))

    def alreadyImported(namespace: String): Boolean =
      traversal.getByNamespace(namespace).exists

    def organisations: Traversal.V[Organisation] = traversal.in[OrganisationTaxonomy].v[Organisation]

    def enabled: Traversal[Boolean, Boolean, Converter.Identity[Boolean]] =
      traversal.choose(_.organisations, true, false)

    def tags: Traversal.V[Tag] = traversal.out[TaxonomyTag].v[Tag]

    def doesTagExists(tag: Tag): Boolean = traversal.tags.getTag(tag).exists

    def richTaxonomy: Traversal[RichTaxonomy, JMap[String, Any], Converter[RichTaxonomy, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.tags.fold)
        )
        .domainMap { case (taxonomy, tags) => RichTaxonomy(taxonomy, tags) }

    def richTaxonomyWithCustomRenderer[D, G, C <: Converter[D, G]](
        entityRenderer: Traversal.V[Taxonomy] => Traversal[D, G, C]
    ): Traversal[(RichTaxonomy, D), JMap[String, Any], Converter[(RichTaxonomy, D), JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.tags.fold)
            .by(entityRenderer)
        )
        .domainMap {
          case (taxo, tags, renderedEntity) =>
            RichTaxonomy(
              taxo,
              tags
            ) -> renderedEntity
        }
  }
}

```

`thehive/app/org/thp/thehive/services/UserSrv.scala`:

```scala
package org.thp.thehive.services

import akka.actor.typed.ActorRef
import org.apache.tinkerpop.gremlin.process.traversal.{Order, P}
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.scalligraph.auth.{AuthContext, AuthContextImpl, Permission}
import org.thp.scalligraph.controllers.FFile
import org.thp.scalligraph.models._
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.services._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, Traversal}
import org.thp.scalligraph.{AuthorizationError, BadRequestError, EntityIdOrName, EntityName, RichOptionTry}
import org.thp.thehive.controllers.v1.Conversion._
import org.thp.thehive.models._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.ProfileOps._
import org.thp.thehive.services.RoleOps._
import org.thp.thehive.services.UserOps._
import play.api.Configuration
import play.api.libs.json.{JsObject, Json}

import java.util.regex.Pattern
import java.util.{Date, List => JList, Map => JMap}
import javax.inject.{Inject, Provider, Singleton}
import scala.util.{Failure, Success, Try}

@Singleton
class UserSrv @Inject() (
    configuration: Configuration,
    roleSrv: RoleSrv,
    auditSrv: AuditSrv,
    attachmentSrv: AttachmentSrv,
    integrityCheckActorProvider: Provider[ActorRef[IntegrityCheck.Request]]
) extends VertexSrv[User] {
  lazy val integrityCheckActor: ActorRef[IntegrityCheck.Request] = integrityCheckActorProvider.get

  val defaultUserDomain: Option[String] = configuration.getOptional[String]("auth.defaultUserDomain")
  val fullUserNameRegex: Pattern        = "[\\p{Graph}&&[^@.]](?:[\\p{Graph}&&[^@]]*)*@\\p{Alnum}+[\\p{Alnum}-.]*".r.pattern

  val userAttachmentSrv = new EdgeSrv[UserAttachment, User, Attachment]

  def checkUser(user: User): Try[User] = {
    val login =
      if (!user.login.contains('@') && defaultUserDomain.isDefined) s"${user.login}@${defaultUserDomain.get}".toLowerCase
      else user.login.toLowerCase

    if (fullUserNameRegex.matcher(login).matches() && login != "system@thehive.local") Success(user.copy(login = login))
    else Failure(BadRequestError(s"User login is invalid, it must be an email address (found: ${user.login})"))
  }

  // TODO return Try[Unit]
  def addUserToOrganisation(user: User with Entity, organisation: Organisation with Entity, profile: Profile with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichUser] =
    (if (!get(user).organisations.getByName(organisation.name).exists)
       roleSrv.create(user, organisation, profile)
     else
       Success(())).flatMap { _ =>
      integrityCheckActor ! IntegrityCheck.EntityAdded("User")
      for {
        richUser <- get(user).richUser(authContext, organisation._id).getOrFail("User")
        _        <- auditSrv.user.create(user, richUser.toJson)
      } yield richUser
    }

  def addOrCreateUser(user: User, avatar: Option[FFile], organisation: Organisation with Entity, profile: Profile with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[RichUser] =
    getByName(user.login)
      .getOrFail("User")
      .orElse {
        for {
          validUser   <- checkUser(user)
          createdUser <- createEntity(validUser)
          _           <- avatar.map(setAvatar(createdUser, _)).flip
        } yield createdUser
      }
      .flatMap(addUserToOrganisation(_, organisation, profile))

  def canSetPassword(user: User with Entity)(implicit graph: Graph, authContext: AuthContext): Boolean = {
    val userOrganisations     = get(user).organisations.value(_.name).toSet
    val operatorOrganisations = current.organisations(Permissions.manageUser).value(_.name).toSeq
    operatorOrganisations.contains(Organisation.administration.name) || (userOrganisations -- operatorOrganisations).isEmpty
  }

  def delete(user: User with Entity, organisation: Organisation with Entity)(implicit graph: Graph, authContext: AuthContext): Try[Unit] = {
    if (get(user).organisations.filterNot(_.get(organisation._id)).exists)
      get(user).role.filter(_.organisation.get(organisation._id)).remove()
    else {
      get(user).role.remove()
      get(user).remove()
    }
    auditSrv.user.delete(user, organisation)
  }

  override def exists(e: User)(implicit graph: Graph): Boolean = startTraversal.getByName(e.login).exists

  def lock(user: User with Entity)(implicit graph: Graph, authContext: AuthContext): Try[User with Entity] =
    if (user.login == authContext.userId)
      Failure(AuthorizationError("You cannot lock yourself"))
    else
      for {
        updatedUser <- get(user)
          .update(_.locked, true: Boolean)
          .update(_._updatedAt, Some(new Date))
          .update(_._updatedBy, Some(authContext.userId))
          .getOrFail("User")
        _ <- auditSrv.user.update(updatedUser, Json.obj("locked" -> true))
      } yield updatedUser

  def unlock(user: User with Entity)(implicit graph: Graph, authContext: AuthContext): Try[User with Entity] =
    for {
      updatedUser <- get(user)
        .update(_.locked, false: Boolean)
        .update(_._updatedAt, Some(new Date))
        .update(_._updatedBy, Some(authContext.userId))
        .getOrFail("User")
      _ <- auditSrv.user.update(updatedUser, Json.obj("locked" -> false))
    } yield updatedUser

  def current(implicit graph: Graph, authContext: AuthContext): Traversal.V[User] = get(EntityName(authContext.userId))

  override def getByName(name: String)(implicit graph: Graph): Traversal.V[User] =
    defaultUserDomain.fold(startTraversal.getByName(name)) {
      case d if !name.contains('@') => startTraversal.getByName(s"$name@$d")
      case _                        => startTraversal.getByName(name)
    }

  override def update(
      traversal: Traversal.V[User],
      propertyUpdaters: Seq[PropertyUpdater]
  )(implicit graph: Graph, authContext: AuthContext): Try[(Traversal.V[User], JsObject)] =
    auditSrv.mergeAudits(super.update(traversal, propertyUpdaters)) {
      case (userSteps, updatedFields) =>
        userSteps
          .filterNot(_.systemUser)
          .clone()
          .getOrFail("User")
          .flatMap(auditSrv.user.update(_, updatedFields))
    }

  def setAvatar(user: User with Entity, avatar: FFile)(implicit graph: Graph, authContext: AuthContext): Try[String] =
    attachmentSrv.create(avatar).flatMap(setAvatar(user, _))

  def setAvatar(user: User with Entity, avatar: Attachment with Entity)(implicit graph: Graph, authContext: AuthContext): Try[String] = {
    unsetAvatar(user)
    userAttachmentSrv.create(UserAttachment(), user, avatar).map(_ => avatar.attachmentId)
  }

  def unsetAvatar(user: User with Entity)(implicit graph: Graph): Unit = get(user).avatar.remove()

  def setProfile(user: User with Entity, organisation: Organisation with Entity, profile: Profile with Entity)(implicit
      graph: Graph,
      authContext: AuthContext
  ): Try[Unit] =
    for {
      role <- get(user).role.filter(_.organisation.getEntity(organisation)).getOrFail("User")
      _ = roleSrv.updateProfile(role, profile)
      _ <- auditSrv.user.changeProfile(user, organisation, profile)
    } yield ()
}

object UserOps {

  implicit class UserOpsDefs(traversal: Traversal.V[User]) {
    def get(idOrName: EntityIdOrName): Traversal.V[User] =
      idOrName.fold(traversal.getByIds(_), getByName)

    def current(implicit authContext: AuthContext): Traversal.V[User] = getByName(authContext.userId)

    def getByName(login: String): Traversal.V[User] = traversal.has(_.login, login.toLowerCase)

    def visible(implicit authContext: AuthContext): Traversal.V[User] =
      if (authContext.isPermitted(Permissions.manageOrganisation.permission)) traversal
      else
        traversal.filter(_.or(_.organisations.visibleOrganisationsTo.get(authContext.organisation), _.systemUser))

    def isNotLocked: Traversal.V[User] = traversal.has(_.locked, false)

    def can(requiredPermission: Permission)(implicit authContext: AuthContext): Traversal.V[User] =
      traversal.filter(_.organisations(requiredPermission).get(authContext.organisation))

    def getByAPIKey(key: String): Traversal.V[User] = traversal.has(_.apikey, key).v[User]

    def organisations: Traversal.V[Organisation] = traversal.out[UserRole].out[RoleOrganisation].v[Organisation]

    protected def organisations0(requiredPermission: Permission): Traversal.V[Organisation] =
      role.filter(_.profile.has(_.permissions, requiredPermission)).organisation

    def organisations(requiredPermission: Permission): Traversal.V[Organisation] = {
      val isInAdminOrganisation = traversal.clone().organisations0(requiredPermission).getByName(Organisation.administration.name).exists
      if (isInAdminOrganisation) traversal.graph.V[Organisation]()
      else organisations0(requiredPermission)
    }

    def organisationWithRole: Traversal[Seq[(Organisation with Entity, String)], JList[JMap[String, Any]], Converter.CList[
      (Organisation with Entity, String),
      JMap[String, Any],
      Converter[(Organisation with Entity, String), JMap[String, Any]]
    ]] =
      role
        .project(
          _.by(_.organisation)
            .by(_.profile.value(_.name))
        )
        .fold

    def config: Traversal.V[Config] = traversal.out[UserConfig].v[Config]

    def getAuthContext(
        requestId: String,
        organisation: Option[EntityIdOrName]
    ): Traversal[AuthContext, JMap[String, Any], Converter[AuthContext, JMap[String, Any]]] = {
      val organisationName = organisation
        .orElse(
          traversal
            .clone()
            .role
            .sort(_.by("_createdAt", Order.asc))
            .organisation
            ._id
            .headOption
        )
        .getOrElse(EntityName(Organisation.administration.name))
      getAuthContext(requestId, organisationName)
    }

    def getAuthContext(
        requestId: String,
        organisationName: EntityIdOrName
    ): Traversal[AuthContext, JMap[String, Any], Converter[AuthContext, JMap[String, Any]]] =
      traversal
        .isNotLocked
        .project(
          _.byValue(_.login)
            .byValue(_.name)
            .by(_.profile(organisationName).fold)
            .by(_.organisations.get(organisationName).value(_.name).limit(1).fold)
            .by(_.profile(EntityName(Organisation.administration.name)).fold)
        )
        .domainMap {
          case (userId, userName, profile, org, adminProfile) =>
            val scope =
              if (org.contains(Organisation.administration.name)) "admin"
              else "organisation"
            val permissions =
              Permissions.forScope(scope) & profile.headOption.orElse(adminProfile.headOption).fold(Set.empty[Permission])(_.permissions)
            AuthContextImpl(userId, userName, organisationName, requestId, permissions)
        }

    def profile(organisation: EntityIdOrName): Traversal.V[Profile] =
      role.filter(_.organisation.get(organisation)).profile

    def richUser(implicit authContext: AuthContext): Traversal[RichUser, JMap[String, Any], Converter[RichUser, JMap[String, Any]]] =
      richUser(authContext, authContext.organisation)

    def richUser(
        authContext: AuthContext,
        organisation: EntityIdOrName
    ): Traversal[RichUser, JMap[String, Any], Converter[RichUser, JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.avatar.value(_.attachmentId).option)
            .by(_.role.project(_.by(_.profile).by(_.organisation.visible(authContext).project(_.by(_._id).byValue(_.name)).fold)).fold)
        )
        .domainMap {
          case (user, avatar, profileOrganisations) =>
            organisation
              .fold(id => profileOrganisations.find(_._2.exists(_._1 == id)), name => profileOrganisations.find(_._2.exists(_._2 == name)))
              .orElse(profileOrganisations.headOption)
              .fold(RichUser(user, avatar, Profile.admin.name, Set.empty, "no org")) { // fake user (probably "system")
                case (profile, organisationIdAndName) =>
                  RichUser(user, avatar, profile.name, profile.permissions, organisationIdAndName.headOption.fold("no org")(_._2))
              }
        }

    def richUserWithCustomRenderer[D, G, C <: Converter[D, G]](
        organisation: EntityIdOrName,
        entityRenderer: Traversal.V[User] => Traversal[D, G, C]
    )(implicit authContext: AuthContext): Traversal[(RichUser, D), JMap[String, Any], Converter[(RichUser, D), JMap[String, Any]]] =
      traversal
        .project(
          _.by
            .by(_.avatar.value(_.attachmentId).option)
            .by(_.role.project(_.by(_.profile).by(_.organisation.visible.project(_.by(_._id).byValue(_.name)).fold)).fold)
            .by(entityRenderer)
        )
        .domainMap {
          case (user, avatar, profileOrganisations, renderedEntity) =>
            organisation
              .fold(id => profileOrganisations.find(_._2.exists(_._1 == id)), name => profileOrganisations.find(_._2.exists(_._2 == name)))
              .orElse(profileOrganisations.headOption)
              .fold(RichUser(user, avatar, Profile.admin.name, Set.empty, "no org") -> renderedEntity) { // fake user (probably "system")
                case (profile, organisationIdAndName) =>
                  RichUser(user, avatar, profile.name, profile.permissions, organisationIdAndName.headOption.fold("***")(_._2)) -> renderedEntity
              }
        }

    def config(configName: String): Traversal.V[Config] =
      traversal.out[UserConfig].v[Config].has(_.name, configName)

    def role: Traversal.V[Role] = traversal.out[UserRole].v[Role]

    def avatar: Traversal.V[Attachment] = traversal.out[UserAttachment].v[Attachment]

    def systemUser: Traversal.V[User] = traversal.has(_.login, User.system.login)

    def dashboards: Traversal.V[Dashboard] = traversal.in[DashboardUser].v[Dashboard]

    def tasks: Traversal.V[Task] = traversal.in[TaskUser].v[Task]

    def cases: Traversal.V[Case] = traversal.in[CaseUser].v[Case]
  }
}

@Singleton
class UserIntegrityCheck @Inject() (
    val db: Database,
    val service: UserSrv,
    profileSrv: ProfileSrv,
    organisationSrv: OrganisationSrv,
    roleSrv: RoleSrv
) extends DedupCheck[User]
    with GlobalCheck[User]
    with IntegrityCheckOps[User] {

  override def initialCheck()(implicit graph: Graph, authContext: AuthContext): Unit = {
    super.initialCheck()
    val adminUserIsCreated = service
      .getByName(User.init.login)
      .role
      .filter(_.profile.getByName(Profile.admin.name))
      .organisation
      .getByName(Organisation.administration.name)
      .exists
    if (!adminUserIsCreated)
      for {
        adminUser         <- service.getByName(User.init.login).getOrFail("User")
        adminProfile      <- profileSrv.getByName(Profile.admin.name).getOrFail("Profile")
        adminOrganisation <- organisationSrv.getByName(Organisation.administration.name).getOrFail("Organisation")
        _                 <- roleSrv.create(adminUser, adminOrganisation, adminProfile)
      } yield ()
    ()
  }

  override def globalCheck(traversal: Traversal.V[User])(implicit graph: Graph): Map[String, Long] = {
    val duplicateRoleLinks = duplicateLinks[Vertex, Vertex](
      traversal,
      (_.out("UserRole"), _.in("UserRole")),
      (_.out("RoleOrganisation"), _.in("RoleOrganisation"))
    ).flatMap(ElementSelector.firstCreatedElement(_)).map(e => removeVertices(e._2)).size
    val orphanCount =
      service
        .startTraversal
        .has(_.login, P.without(User.initialValues.map(_.login): _*))
        .filterNot(_.organisations)
        .sideEffect(_.drop())
        .getCount
    Map("duplicateRoleLinks" -> duplicateRoleLinks.toLong, "orphan" -> orphanCount)
  }
}

```

`thehive/app/org/thp/thehive/services/notification/NotificationActor.scala`:

```scala
package org.thp.thehive.services.notification

import akka.actor.{Actor, ActorIdentity, Identify}
import akka.util.Timeout
import org.thp.scalligraph.models.{Database, Entity, Schema}
import org.thp.scalligraph.services.EventSrv
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{BadConfigurationError, EntityId}
import org.thp.thehive.models.{Audit, Organisation, User}
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import org.thp.thehive.services.notification.notifiers.{Notifier, NotifierProvider}
import org.thp.thehive.services.notification.triggers.{Trigger, TriggerProvider}
import play.api.cache.SyncCacheApi
import play.api.libs.json.{Format, JsValue, Json}
import play.api.{Configuration, Logger}

import javax.inject.Inject
import scala.collection.immutable
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.util.{Success, Try}

object NotificationTopic {
  def apply(role: String = ""): String = if (role.isEmpty) "notification" else s"notification-$role"
}

sealed trait NotificationMessage
case class NotificationExecution(userId: Option[EntityId], auditId: EntityId, notificationConfig: NotificationConfig) extends NotificationMessage

object NotificationExecution {
  implicit val format: Format[NotificationExecution] = Json.format[NotificationExecution]
}
case class AuditNotificationMessage(id: EntityId*) extends NotificationMessage

object AuditNotificationMessage {
  implicit val format: Format[AuditNotificationMessage] = Json.format[AuditNotificationMessage]
}

class NotificationSrv @Inject() (
    availableTriggers: immutable.Set[TriggerProvider],
    availableNotifiers: immutable.Set[NotifierProvider]
) {

  val triggers: Map[String, TriggerProvider] = availableTriggers.map(t => t.name -> t).toMap

  def getConfig(config: String): Seq[NotificationConfig] =
    Json
      .parse(config)
      .asOpt[Seq[NotificationConfig]]
      .getOrElse(Nil)

  def getTriggers(config: JsValue): Seq[Trigger] =
    config.asOpt[Seq[NotificationConfig]].getOrElse(Nil).flatMap(c => getTrigger(c.triggerConfig).toOption)

  def getTrigger(config: Configuration): Try[Trigger] =
    for {
      name            <- config.getOptional[String]("name").toRight(BadConfigurationError("name is missing")).toTry
      triggerProvider <- triggers.get(name).toRight(BadConfigurationError(s"unknown trigger $name")).toTry
      trigger         <- triggerProvider(config)
    } yield trigger

  val notifiers: Map[String, NotifierProvider] = availableNotifiers.map(n => n.name -> n).toMap

  def getNotifier(config: Configuration): Try[Notifier] =
    for {
      name             <- config.getOptional[String]("name").toRight(BadConfigurationError("name is missing")).toTry
      notifierProvider <- notifiers.get(name).toRight(BadConfigurationError(s"unknown notifier $name")).toTry
      notifier         <- notifierProvider(config)
    } yield notifier
}

class NotificationActor @Inject() (
    configuration: Configuration,
    eventSrv: EventSrv,
    auditSrv: AuditSrv,
    configSrv: ConfigSrv,
    organisationSrv: OrganisationSrv,
    userSrv: UserSrv,
    notificationSrv: NotificationSrv,
    cache: SyncCacheApi,
    implicit val db: Database,
    implicit val schema: Schema
) extends Actor {
  import context.dispatcher
  lazy val logger: Logger = Logger(getClass)
  val roles: Set[String]  = configuration.get[Seq[String]]("roles").toSet

  // Map of OrganisationId -> Trigger -> (present in org, list of UserId) */
  def triggerMap: Map[EntityId, Map[Trigger, (Boolean, Seq[EntityId])]] =
    cache.getOrElseUpdate("notification-triggers", 5.minutes)(db.roTransaction(graph => configSrv.triggerMap(notificationSrv)(graph)))

  override def preStart(): Unit = {
    roles.foreach(role => eventSrv.subscribe(NotificationTopic(role), self))
    eventSrv.subscribe(NotificationTopic(), self)
    super.preStart()
  }

  /**
    * Execute the notification for that user if the trigger is applicable. If the role restriction configured in the
    * notification configuration, send it to an actor which can execute this notification. The role restriction is
    * related to the host, not to the user. When TheHive is executed in a cluster, a role can be assigned to each host.
    * @param user the targeted user
    * @param notificationConfigs the notification config. Contains the trigger, the role restriction and the notifier
    * @param audit message to be notified
    * @param context context element of the audit
    * @param organisation organisation of the user
    * @param graph the graph
    */
  def executeNotification(
      user: Option[User with Entity],
      notificationConfigs: Seq[NotificationConfig],
      audit: Audit with Entity,
      context: Option[Map[String, Seq[Any]] with Entity],
      `object`: Option[Map[String, Seq[Any]] with Entity],
      organisation: Organisation with Entity
  )(implicit
      graph: Graph
  ): Unit =
    notificationConfigs
      .foreach {
        case notificationConfig if notificationConfig.roleRestriction.isEmpty || (notificationConfig.roleRestriction & roles).nonEmpty =>
          notificationSrv
            .getTrigger(notificationConfig.triggerConfig)
            .flatMap { trigger =>
              logger.debug(s"Checking trigger $trigger against $audit, $context, $organisation, $user")
              if (trigger.filter(audit, context, organisation, user)) notificationSrv.getNotifier(notificationConfig.notifierConfig).map(Some(_))
              else Success(None)
            }
            .map(_.foreach { notififer =>
              logger.info(s"Execution of notifier $notififer for user $user")
              notififer.execute(audit, context, `object`, organisation, user).failed.foreach { error =>
                logger.error(s"Execution of notifier $notififer has failed for user $user", error)
              }
            })
            .failed
            .foreach { error =>
              logger.error(s"Execution of notification $notificationConfig has failed for user $user / ${organisation.name}", error)
            }
        case notificationConfig =>
          logger.debug(s"Notification has role restriction($notificationConfig.roleRestriction) and it is not applicable here ($roles)")
          Future
            .firstCompletedOf(notificationConfig.roleRestriction.map { role =>
              eventSrv.publishAsk(NotificationTopic(role))(Identify(1))(Timeout(2.seconds))
            })
            .map {
              case ActorIdentity(1, Some(notificationActor)) =>
                logger.debug(s"Send notification to $notificationActor")
                notificationActor ! NotificationExecution(user.map(_._id), audit._id, notificationConfig)
            }
      }

  override def receive: Receive = {
    case AuditNotificationMessage(ids @ _*) =>
      logger.debug(s"Receive AuditStreamMessage(${ids.mkString(",")})")
      db.roTransaction { implicit graph =>
        auditSrv
          .getByIds(ids: _*)
          .auditContextObjectOrganisation
          .toIterator
          .foreach {
            case (audit, context, obj, organisations) =>
              logger.debug(s"Notification is related to $audit, $context, ${organisations.map(_.name).mkString(",")}")
              organisations.foreach { organisation =>
                lazy val organisationNotificationConfigs = organisationSrv
                  .get(organisation)
                  .config
                  .has(_.name, "notification")
                  .value(_.value)
                  .headOption
                  .toSeq
                  .flatMap(_.asOpt[Seq[NotificationConfig]].getOrElse(Nil))
                val orgNotifs = triggerMap
                  .getOrElse(organisation._id, Map.empty)
                val mustNotifyOrganisation = orgNotifs
                  .exists {
                    case (trigger, (true, _)) => trigger.preFilter(audit, context, organisation)
                    case _                    => false
                  }
                if (mustNotifyOrganisation)
                  executeNotification(None, organisationNotificationConfigs.filterNot(_.delegate), audit, context, obj, organisation)
                val mustNotifyOrgUsers = orgNotifs.exists {
                  case (trigger, (false, _)) => trigger.preFilter(audit, context, organisation)
                  case _                     => false
                }
                if (mustNotifyOrgUsers) {
                  val userConfig = organisationNotificationConfigs.filter(_.delegate)
                  organisationSrv
                    .get(organisation)
                    .users
                    .filter(_.config.hasNot(_.name, "notification"))
                    .toIterator
                    .foreach { user =>
                      executeNotification(Some(user), userConfig, audit, context, obj, organisation)
                    }
                }
                val usersToNotify = orgNotifs.flatMap {
                  case (trigger, (_, userIds)) if userIds.nonEmpty && trigger.preFilter(audit, context, organisation) => userIds
                  case _                                                                                              => Nil
                }.toSeq
                userSrv
                  .getByIds(usersToNotify: _*)
                  .project(_.by.by(_.config.has(_.name, "notification").value(_.value).option))
                  .foreach {
                    case (user, Some(config)) =>
                      config.asOpt[Seq[NotificationConfig]].foreach { userConfig =>
                        executeNotification(Some(user), userConfig, audit, context, obj, organisation)
                      }
                    case _ =>
                  }
              }
            case _ =>
          }
      }
    case NotificationExecution(userId, auditId, notificationConfig) =>
      db.roTransaction { implicit graph =>
        auditSrv.getByIds(auditId).auditContextObjectOrganisation.getOrFail("Audit").foreach {
          case (audit, context, obj, organisations) =>
            organisations.foreach { organisation =>
              for {
                user    <- userId.map(userSrv.getOrFail).flip
                trigger <- notificationSrv.getTrigger(notificationConfig.triggerConfig)
                if trigger.filter(audit, context, organisation, user)
                notifier <- notificationSrv.getNotifier(notificationConfig.notifierConfig)
                _ = logger.debug(s"Execution of notifier ${notifier.name} for user $user")
              } yield notifier.execute(audit, context, obj, organisation, user)
            }
          case _ => // TODO
        }
      }
  }
}

```

`thehive/app/org/thp/thehive/services/notification/NotificationConfig.scala`:

```scala
package org.thp.thehive.services.notification

import org.thp.scalligraph.services.config.ApplicationConfig.configurationFormat
import play.api.Configuration
import play.api.libs.functional.syntax._
import play.api.libs.json.{JsPath, Json, Reads, Writes}

case class NotificationConfig(delegate: Boolean, triggerConfig: Configuration, notifierConfig: Configuration, roleRestriction: Set[String])

object NotificationConfig {

  implicit val reads: Reads[NotificationConfig] =
    ((JsPath \ "delegate").readWithDefault[Boolean](false) and
      (JsPath \ "trigger").read[Configuration] and
      (JsPath \ "notifier").read[Configuration] and
      (JsPath \ "hostRestriction").readWithDefault[Set[String]](Set.empty))(NotificationConfig.apply _)

  implicit val writes: Writes[NotificationConfig] = Writes[NotificationConfig] { config =>
    Json.obj("triggerConfig" -> config.triggerConfig, "notifierConfig" -> config.notifierConfig, "roleRestriction" -> config.roleRestriction)
  }

}

```

`thehive/app/org/thp/thehive/services/notification/NotificationSerializer.scala`:

```scala
package org.thp.thehive.services.notification

import akka.serialization.Serializer
import play.api.libs.json.Json

import java.io.NotSerializableException

class NotificationSerializer extends Serializer {
  override def identifier: Int = 226591536

  override def includeManifest: Boolean = false

  /**
    * Serializes the given object into an Array of Byte
    */
  def toBinary(o: AnyRef): Array[Byte] =
    o match {
      case m: NotificationExecution    => 0.toByte +: Json.toBytes(Json.toJson(m))
      case m: AuditNotificationMessage => 1.toByte +: Json.toBytes(Json.toJson(m))
      case _                           => throw new NotSerializableException
    }

  /**
    * Produces an object from an array of bytes, with an optional type-hint;
    * the class should be loaded using ActorSystem.dynamicAccess.
    */
  @throws(classOf[NotSerializableException])
  def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef =
    bytes(0) match {
      case 0 => Json.parse(bytes.tail).asOpt[NotificationExecution]
      case 1 => Json.parse(bytes.tail).asOpt[AuditNotificationMessage]
      case _ => throw new NotSerializableException
    }
}

```

`thehive/app/org/thp/thehive/services/notification/notifiers/AppendToFile.scala`:

```scala
package org.thp.thehive.services.notification.notifiers

import org.thp.scalligraph.models.{Entity, Schema}
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.{Audit, Organisation, User}
import play.api.Configuration

import java.nio.charset.Charset
import java.nio.file.{Files, Paths, StandardOpenOption}
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.Try

@Singleton
class AppendToFileProvider @Inject() (appConfig: ApplicationConfig, schema: Schema, ec: ExecutionContext) extends NotifierProvider {
  override val name: String = "AppendToFile"

  val templateConfig: ConfigItem[String, String] =
    appConfig.item[String]("notification.appendToFile.template", "Template text to append")

  val baseUrlConfig: ConfigItem[String, String] =
    appConfig.item[String]("application.baseUrl", "Application base URL")

  override def apply(config: Configuration): Try[Notifier] =
    config.getOrFail[String]("file").map { filename =>
      val template = config.getOptional[String]("message").getOrElse(templateConfig.get)
      val charset  = config.getOptional[String]("charset").fold(Charset.defaultCharset())(Charset.forName)
      new AppendToFile(filename, template, charset, baseUrlConfig.get, schema, ec)
    }
}

class AppendToFile(filename: String, template: String, charset: Charset, baseUrl: String, val schema: Schema, implicit val ec: ExecutionContext)
    extends Notifier
    with Template {
  override val name: String = "AppendToFile"

  override def execute(
      audit: Audit with Entity,
      context: Option[Map[String, Seq[Any]] with Entity],
      `object`: Option[Map[String, Seq[Any]] with Entity],
      organisation: Organisation with Entity,
      user: Option[User with Entity]
  )(implicit
      graph: Graph
  ): Future[Unit] =
    buildMessage(template, audit, context, `object`, user, baseUrl).fold(
      Future.failed[Unit],
      message =>
        Future(Files.write(Paths.get(filename), message.getBytes(charset), StandardOpenOption.APPEND, StandardOpenOption.CREATE)).map(_ => ())
    )
}

```

`thehive/app/org/thp/thehive/services/notification/notifiers/Emailer.scala`:

```scala
package org.thp.thehive.services.notification.notifiers

import org.thp.scalligraph.models.{Entity, Schema}
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.{Audit, Organisation, User}
import play.api.libs.mailer.{Email, MailerClient}
import play.api.{Configuration, Logger}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Success, Try}

@Singleton
class EmailerProvider @Inject() (appConfig: ApplicationConfig, mailerClient: MailerClient, schema: Schema, ec: ExecutionContext)
    extends NotifierProvider {
  override val name: String = "Emailer"

  val subjectConfig: ConfigItem[String, String] =
    appConfig.item[String]("notification.emailer.subject", "Subject of mail")

  val fromConfig: ConfigItem[String, String] =
    appConfig.item[String]("notification.emailer.from", "Mail sender address")

  val templateConfig: ConfigItem[String, String] =
    appConfig.item[String]("notification.emailer.template", "Template message to send")

  val baseUrlConfig: ConfigItem[String, String] =
    appConfig.item[String]("application.baseUrl", "Application base URL")

  override def apply(config: Configuration): Try[Notifier] = {
    val template = config.getOptional[String]("message").getOrElse(templateConfig.get)
    val emailer  = new Emailer(mailerClient, subjectConfig.get, fromConfig.get, template, baseUrlConfig.get, schema, ec)
    Success(emailer)
  }
}

class Emailer(
    mailerClient: MailerClient,
    subject: String,
    from: String,
    template: String,
    baseUrl: String,
    val schema: Schema,
    implicit val ec: ExecutionContext
) extends Notifier
    with Template {
  lazy val logger: Logger   = Logger(getClass)
  override val name: String = "Emailer"

  override def execute(
      audit: Audit with Entity,
      context: Option[Map[String, Seq[Any]] with Entity],
      `object`: Option[Map[String, Seq[Any]] with Entity],
      organisation: Organisation with Entity,
      user: Option[User with Entity]
  )(implicit
      graph: Graph
  ): Future[Unit] =
    user.fold(Future.successful(logger.warn(s"Email can't be sent to an organisation"))) { u =>
      buildMessage(template, audit, context, `object`, user, baseUrl)
        .fold(
          Future.failed[Unit],
          message => Future(mailerClient.send(Email(subject = subject, from = from, to = Seq(u.login), bodyText = Some(message)))).map(_ => ())
        )
    }
}

```

`thehive/app/org/thp/thehive/services/notification/notifiers/Mattermost.scala`:

```scala
package org.thp.thehive.services.notification.notifiers

import akka.stream.Materializer
import org.thp.client.{ProxyWS, ProxyWSConfig}
import org.thp.scalligraph.models.{Entity, Schema}
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.{Audit, Organisation, User}
import play.api.libs.json.{Json, Reads, Writes}
import play.api.libs.ws.WSClient
import play.api.{Configuration, Logger}

import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Success, Try}

case class MattermostNotification(text: String, url: String, channel: Option[String], username: Option[String])

object MattermostNotification {
  implicit val writes: Writes[MattermostNotification] = Json.writes[MattermostNotification]
}

@Singleton
class MattermostProvider @Inject() (appConfig: ApplicationConfig, ec: ExecutionContext, schema: Schema, mat: Materializer) extends NotifierProvider {
  override val name: String                            = "Mattermost"
  implicit val optionStringRead: Reads[Option[String]] = Reads.optionNoError[String]

  val webhookConfig: ConfigItem[String, String] =
    appConfig.item[String]("notification.mattermost.webhook", "Webhook url declared on Mattermost side")

  val usernameConfig: ConfigItem[Option[String], Option[String]] =
    appConfig.item[Option[String]]("notification.mattermost.username", "Username who send Mattermost message")

  val templateConfig: ConfigItem[String, String] =
    appConfig.item[String]("notification.mattermost.template", "Template message to send")

  val baseUrlConfig: ConfigItem[String, String] =
    appConfig.item[String]("application.baseUrl", "Application base URL")

  val wsConfig: ConfigItem[ProxyWSConfig, ProxyWSConfig] =
    appConfig.item[ProxyWSConfig]("notification.mattermost.ws", "HTTP client configuration")

  override def apply(config: Configuration): Try[Notifier] = {
    val template         = config.getOptional[String]("message").getOrElse(templateConfig.get)
    val channel          = config.getOptional[String]("channel")
    val usernameOverride = usernameConfig.get
    val webhook          = webhookConfig.get
    val mattermost =
      new Mattermost(
        new ProxyWS(wsConfig.get, mat),
        MattermostNotification(template, webhook, channel, usernameOverride),
        baseUrlConfig.get,
        schema,
        ec
      )
    Success(mattermost)
  }
}

class Mattermost(ws: WSClient, mattermostNotification: MattermostNotification, baseUrl: String, val schema: Schema, implicit val ec: ExecutionContext)
    extends Notifier
    with Template {
  lazy val logger: Logger   = Logger(getClass)
  override val name: String = "Mattermost"

  def execute(
      audit: Audit with Entity,
      context: Option[Map[String, Seq[Any]] with Entity],
      `object`: Option[Map[String, Seq[Any]] with Entity],
      organisation: Organisation with Entity,
      user: Option[User with Entity]
  )(implicit
      graph: Graph
  ): Future[Unit] =
    for {
      finalMessage <- Future.fromTry(buildMessage(mattermostNotification.text, audit, context, `object`, user, baseUrl))
      _ <-
        ws
          .url(mattermostNotification.url)
          .post(Json.toJson(mattermostNotification.copy(text = finalMessage)))
    } yield ()
}

```

`thehive/app/org/thp/thehive/services/notification/notifiers/Notifier.scala`:

```scala
package org.thp.thehive.services.notification.notifiers

import org.thp.scalligraph.BadConfigurationError
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.{Audit, Organisation, User}
import play.api.{ConfigLoader, Configuration}

import scala.concurrent.Future
import scala.util.{Failure, Success, Try}

trait Notifier {

  val name: String

  def execute(
      audit: Audit with Entity,
      context: Option[Map[String, Seq[Any]] with Entity],
      `object`: Option[Map[String, Seq[Any]] with Entity],
      organisation: Organisation with Entity,
      user: Option[User with Entity]
  )(implicit
      graph: Graph
  ): Future[Unit]

}

trait NotifierProvider extends (Configuration => Try[Notifier]) {
  implicit class RichConfig(configuration: Configuration) {

    def getOrFail[A: ConfigLoader](path: String): Try[A] =
      configuration
        .getOptional[A](path)
        .fold[Try[A]](Failure(BadConfigurationError(s"Configuration $path is missing")))(Success(_))
  }

  val name: String
}

```

`thehive/app/org/thp/thehive/services/notification/notifiers/Template.scala`:

```scala
package org.thp.thehive.services.notification.notifiers

import com.github.jknack.handlebars.Handlebars
import com.github.jknack.handlebars.helper.ConditionalHelpers
import org.thp.scalligraph.models.{Entity, MappingCardinality, Schema}
import org.thp.thehive.models.{Audit, User}

import java.util.{HashMap => JHashMap}
import scala.collection.JavaConverters._
import scala.util.Try

trait Template {
  val handlebars: Handlebars = new Handlebars().registerHelpers(classOf[ConditionalHelpers])
  val schema: Schema

  /**
    * Retrieves the data from an Entity db model (XXX with Entity) as a scala Map
    * @param cc the entity
    * @return
    */
  private def getMap(cc: Map[String, Seq[Any]] with Entity): Map[String, String] =
    schema.getModel(cc._label).fold(cc.mapValues(_.mkString("[", ",", "]"))) { model =>
      cc.map {
        case (k, v) =>
          model.fields.get(k).fold(k -> v.mkString("[", ",", "]")) {
            case mapping if mapping.cardinality == MappingCardinality.list || mapping.cardinality == MappingCardinality.set =>
              k -> v.mkString("[", ",", "]")
            case _ => k -> v.head.toString
          }
      } +
        ("_id"        -> cc._id.toString) +
        ("_type"      -> cc._label) +
        ("_createdAt" -> cc._createdAt.toString) +
        ("_createdBy" -> cc._createdBy) +
        ("_updatedAt" -> cc._updatedAt.fold("never")(_.toString)) +
        ("_updatedBy" -> cc._updatedBy.getOrElse("nobody"))
    }

  private def getMap(cc: Entity): Map[String, String] =
    schema
      .getModel(cc._label)
      .fold(Map.empty[String, String]) {
        _.fields
          .keys
          .filterNot(_ == "password")
          .flatMap { f =>
            cc.getClass.getSuperclass.getDeclaredMethod(f).invoke(cc) match {
              case option: Option[_] => option.map(f -> _.toString)
              case list: Seq[_]      => Some(f -> list.mkString("[", ",", "]"))
              case set: Set[_]       => Some(f -> set.mkString("[", ",", "]"))
              case other             => Some(f -> other.toString)
            }
          }
          .toMap
      } +
      ("_id"        -> cc._id.toString) +
      ("_type"      -> cc._label) +
      ("_createdAt" -> cc._createdAt.toString) +
      ("_createdBy" -> cc._createdBy) +
      ("_updatedAt" -> cc._updatedAt.fold("never")(_.toString)) +
      ("_updatedBy" -> cc._updatedBy.getOrElse("nobody"))

  def buildUrl(baseUrl: String, `object`: Option[Entity], context: Option[Entity]): Option[String] =
    `object`.flatMap { obj =>
      obj._label match {
        case "Case"             => Some(s"$baseUrl/index.html#/case/${obj._id}")
        case "Task"             => context.map(ctx => s"$baseUrl/index.html#/case/${ctx._id}/tasks/${obj._id}")
        case "Log"              => context.map(ctx => s"$baseUrl/index.html#/case/${ctx._id}")
        case "CaseTemplate"     => None
        case "Alert"            => Some(s"$baseUrl/index.html#/alert/list")
        case "Observable"       => context.map(ctx => s"$baseUrl/index.html#/case/${ctx._id}/observables/${obj._id}")
        case "User"             => Some(s"$baseUrl/index.html#/administration/users")
        case "Dashboard"        => Some(s"$baseUrl/index.html#/dashboards/${obj._id}")
        case "Organisation"     => None
        case "Job"              => None
        case "Action"           => buildUrl(baseUrl, context, None)
        case "AnalyzerTemplate" => None
      }
    }

  def buildMessage(
      template: String,
      audit: Audit with Entity,
      context: Option[Map[String, Seq[Any]] with Entity],
      `object`: Option[Map[String, Seq[Any]] with Entity],
      user: Option[User with Entity],
      baseUrl: String
  ): Try[String] = {
    val model = new JHashMap[String, AnyRef]
    model.put("audit", getMap(audit).asJava)
    user.foreach(u => model.put("user", getMap(u).asJava))
    context.foreach(c => model.put("context", getMap(c).asJava))
    `object`.foreach(o => model.put("object", getMap(o).asJava))
    buildUrl(baseUrl, `object`, context).foreach(url => model.put("url", url))
    Try(handlebars.compileInline(template).apply(model))
  }
}

```

`thehive/app/org/thp/thehive/services/notification/notifiers/Webhook.scala`:

```scala
package org.thp.thehive.services.notification.notifiers

import akka.stream.Materializer
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.thp.client.{Authentication, NoAuthentication, ProxyWS, ProxyWSConfig}
import org.thp.scalligraph.models.{Entity, UMapping}
import org.thp.scalligraph.services.config.{ApplicationConfig, ConfigItem}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Converter, Graph, IdentityConverter, Traversal}
import org.thp.scalligraph.{BadConfigurationError, EntityIdOrName}
import org.thp.thehive.controllers.v0.AuditRenderer
import org.thp.thehive.controllers.v0.Conversion.fromObjectType
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.AuditOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.{AuditSrv, _}
import play.api.libs.json.Json.WithDefaultValues
import play.api.libs.json._
import play.api.{Configuration, Logger}

import java.util.{Date, Map => JMap}
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success, Try}

case class WebhookNotification(
    name: String,
    url: String,
    version: Int = 0,
    auth: Authentication = NoAuthentication,
    wsConfig: ProxyWSConfig = ProxyWSConfig(),
    includedTheHiveOrganisations: Seq[String] = Seq("*"),
    excludedTheHiveOrganisations: Seq[String] = Nil
) {
  def organisationAuthorised(organisation: Organisation): Boolean =
    (includedTheHiveOrganisations.contains("*") ||
      includedTheHiveOrganisations.isEmpty ||
      includedTheHiveOrganisations.contains(organisation.name)) &&
      !excludedTheHiveOrganisations.contains(organisation.name)
}

object WebhookNotification {
  implicit val format: Format[WebhookNotification] = Json.using[WithDefaultValues].format[WebhookNotification]
}

@Singleton
class WebhookProvider @Inject() (
    appConfig: ApplicationConfig,
    auditSrv: AuditSrv,
    customFieldSrv: CustomFieldSrv,
    ec: ExecutionContext,
    mat: Materializer
) extends NotifierProvider {
  override val name: String = "webhook"

  val webhookConfigs: ConfigItem[Seq[WebhookNotification], Seq[WebhookNotification]] =
    appConfig.item[Seq[WebhookNotification]]("notification.webhook.endpoints", "webhook configuration list")

  override def apply(config: Configuration): Try[Notifier] =
    for {
      name <- config.getOrFail[String]("endpoint")
      config <-
        webhookConfigs
          .get
          .find(_.name == name)
          .fold[Try[WebhookNotification]](Failure(BadConfigurationError(s"Webhook configuration `$name` not found`")))(Success.apply)

    } yield new Webhook(config, auditSrv, customFieldSrv, mat, ec)
}

class Webhook(
    config: WebhookNotification,
    auditSrv: AuditSrv,
    customFieldSrv: CustomFieldSrv,
    mat: Materializer,
    implicit val ec: ExecutionContext
) extends Notifier {
  override val name: String = "webhook"

  lazy val logger: Logger = Logger(getClass)

  object v0 extends AuditRenderer

  object v1 {
    import org.thp.thehive.controllers.v1.Conversion._

    def caseToJson: Traversal.V[Case] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
      _.richCaseWithoutPerms.domainMap[JsObject](_.toJson.as[JsObject])

    def taskToJson: Traversal.V[Task] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
      _.project(
        _.by(_.richTaskWithoutActionRequired.domainMap(_.toJson))
          .by(t => caseToJson(t.`case`))
      ).domainMap {
        case (task, case0) => task.as[JsObject] + ("case" -> case0)
      }

    def alertToJson: Traversal.V[Alert] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
      _.richAlert.domainMap(_.toJson.as[JsObject])

    def logToJson: Traversal.V[Log] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
      _.project(
        _.by(_.richLog.domainMap(_.toJson))
          .by(l => taskToJson(l.task))
      ).domainMap { case (log, task) => log.as[JsObject] + ("case_task" -> task) }

    def observableToJson: Traversal.V[Observable] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
      _.project(
        _.by(_.richObservable.domainMap(_.toJson))
          .by(_.coalesceMulti(o => caseToJson(o.`case`), o => alertToJson(o.alert)))
      ).domainMap {
        case (obs, caseOrAlert) => obs.as[JsObject] + ((caseOrAlert \ "_type").asOpt[String].getOrElse("<unknown>") -> caseOrAlert)
      }

    case class Job(
        workerId: String,
        workerName: String,
        workerDefinition: String,
        status: String,
        startDate: Date,
        endDate: Date,
        report: Option[JsObject],
        cortexId: String,
        cortexJobId: String
    )
    def jobToJson
        : Traversal[Vertex, Vertex, IdentityConverter[Vertex]] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
      _.project(
        _.by.by
      ).domainMap {
        case (vertex, _) =>
          JsObject(
            UMapping.string.optional.getProperty(vertex, "workerId").map(v => "analyzerId" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "workerName").map(v => "analyzerName" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "workerDefinition").map(v => "analyzerDefinition" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "status").map(v => "status" -> JsString(v)).toList :::
              UMapping.date.optional.getProperty(vertex, "startDate").map(v => "startDate" -> JsNumber(v.getTime)).toList :::
              UMapping.date.optional.getProperty(vertex, "endDate").map(v => "endDate" -> JsNumber(v.getTime)).toList :::
              UMapping.string.optional.getProperty(vertex, "cortexId").map(v => "cortexId" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "cortexJobId").map(v => "cortexJobId" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "_createdBy").map(v => "_createdBy" -> JsString(v)).toList :::
              UMapping.date.optional.getProperty(vertex, "_createdAt").map(v => "_createdAt" -> JsNumber(v.getTime)).toList :::
              UMapping.string.optional.getProperty(vertex, "_updatedBy").map(v => "_updatedBy" -> JsString(v)).toList :::
              UMapping.date.optional.getProperty(vertex, "_updatedAt").map(v => "_updatedAt" -> JsNumber(v.getTime)).toList :::
              UMapping.string.optional.getProperty(vertex, "_type").map(v => "_type" -> JsString(v)).toList :::
              UMapping.string.optional.getProperty(vertex, "_id").map(v => "_id" -> JsString(v)).toList
          )
      }

    def auditRenderer: Traversal.V[Audit] => Traversal[JsObject, JMap[String, Any], Converter[JsObject, JMap[String, Any]]] =
      (_: Traversal.V[Audit])
        .coalesce(
          _.`object` //.out[Audited]
            .chooseValue(
              _.on(_.label)
                .option("Case", t => caseToJson(t.v[Case]))
                .option("Task", t => taskToJson(t.v[Task]))
                .option("Log", t => logToJson(t.v[Log]))
                .option("Observable", t => observableToJson(t.v[Observable]))
                .option("Alert", t => alertToJson(t.v[Alert]))
                .option("Job", jobToJson)
                .none(_.constant2[JsObject, JMap[String, Any]](JsObject.empty))
            ),
          JsObject.empty
        )

  }

  // This method change the format of audit details when it contains custom field.
  // The custom field type is added to match TheHive 3 webhook format.
  def fixCustomFieldDetails(objectType: String, details: String)(implicit graph: Graph): JsValue = {
    val detailsJson = Json.parse(details)
    objectType match {
      case "Case" | "Alert" | "CaseTemplate" =>
        detailsJson.asOpt[JsObject].fold(detailsJson) { o =>
          JsObject(o.fields.map {
            case keyValue @ (key, value) if key.startsWith("customField.") =>
              val fieldName = key.drop(12)
              customFieldSrv
                .getOrFail(EntityIdOrName(fieldName))
                .fold(_ => keyValue, cf => "customFields" -> Json.obj(fieldName -> Json.obj(cf.`type`.toString -> value)))
            case ("customFields", JsArray(cfs)) =>
              "customFields" -> cfs
                .flatMap { cf =>
                  for {
                    name <- (cf \ "name").asOpt[String]
                    tpe  <- (cf \ "type").asOpt[String]
                    value = (cf \ "value").asOpt[JsValue]
                    order = (cf \ "order").asOpt[Int]
                  } yield Json.obj(name -> Json.obj(tpe -> value, "order" -> order))
                }
                .foldLeft(JsObject.empty)(_ ++ _)
            case keyValue => keyValue
          })
        }
      case _ => detailsJson
    }
  }

  def buildMessage(version: Int, audit: Audit with Entity)(implicit graph: Graph): Try[JsObject] =
    version match {
      case 0 =>
        auditSrv.get(audit).richAuditWithCustomRenderer(v0.auditRenderer).getOrFail("Audit").map {
          case (audit, obj) =>
            val objectType = audit.objectType.getOrElse(audit.context._label)
            Json.obj(
              "operation"  -> v0Action(audit.action),
              "details"    -> audit.details.fold[JsValue](JsObject.empty)(fixCustomFieldDetails(objectType, _)),
              "objectType" -> fromObjectType(objectType),
              "objectId"   -> audit.objectId,
              "base"       -> audit.mainAction,
              "startDate"  -> audit._createdAt,
              "rootId"     -> audit.context._id,
              "requestId"  -> audit.requestId,
              "object"     -> obj
            )
        }
      case 1 =>
        auditSrv.get(audit).richAuditWithCustomRenderer(v1.auditRenderer).getOrFail("Audit").map {
          case (audit, obj) =>
            val objectType = audit.objectType.getOrElse(audit.context._label)
            Json.obj(
              "operation"  -> audit.action,
              "details"    -> audit.details.fold[JsValue](JsObject.empty)(fixCustomFieldDetails(objectType, _)),
              "objectType" -> objectType,
              "objectId"   -> audit.objectId,
              "base"       -> audit.mainAction,
              "startDate"  -> audit._createdAt,
              "rootId"     -> audit.context._id,
              "requestId"  -> audit.requestId,
              "object"     -> obj
            )
        }
      case _ => Failure(BadConfigurationError(s"Message version $version in webhook is not supported"))
    }

  def v0Action(action: String): String =
    action match {
      case Audit.merge => Audit.update
      case action      => action
    }

  override def execute(
      audit: Audit with Entity,
      context: Option[Map[String, Seq[Any]] with Entity],
      `object`: Option[Map[String, Seq[Any]] with Entity],
      organisation: Organisation with Entity,
      user: Option[User with Entity]
  )(implicit graph: Graph): Future[Unit] =
    if (!config.organisationAuthorised(organisation))
      Future.failed(BadConfigurationError(s"The organisation ${organisation.name} is not authorised to use the webhook ${config.name}"))
    else if (user.isDefined)
      Future.failed(BadConfigurationError("The notification webhook must not be applied on user"))
    else {
      val ws = new ProxyWS(config.wsConfig, mat)
      val async = for {
        message <- Future.fromTry(
          buildMessage(config.version, audit).map(
            _ + ("organisationId" -> JsString(organisation._id.toString)) + ("organisation" -> JsString(organisation.name))
          )
        )
        _ = logger.debug(s"Request webhook with message $message")
        resp <- config.auth(ws.url(config.url)).post(message)
      } yield if (resp.status >= 400) logger.warn(s"Webhook call on ${config.url} returns ${resp.status} ${resp.statusText}") else ()
      async.andThen { case _ => ws.close() }
    }

}

```

`thehive/app/org/thp/thehive/services/notification/triggers/AlertCreated.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.thehive.models.Audit
import play.api.Configuration

import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

@Singleton
class AlertCreatedProvider @Inject() extends TriggerProvider {
  override val name: String                               = "AlertCreated"
  override def apply(config: Configuration): Try[Trigger] = Success(AlertCreated)
}

object AlertCreated extends GlobalTrigger {
  override val name: String        = "AlertCreated"
  override val auditAction: String = Audit.create
  override val entityName: String  = "Alert"
}

```

`thehive/app/org/thp/thehive/services/notification/triggers/AnyEvent.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.scalligraph.models.Entity
import org.thp.thehive.models.{Audit, Organisation}
import play.api.Configuration

import javax.inject.Singleton
import scala.util.{Success, Try}

@Singleton
class AnyEventProvider extends TriggerProvider {
  override val name: String = "AnyEvent"

  override def apply(config: Configuration): Try[Trigger] = Success(AnyEvent)
}

object AnyEvent extends Trigger {
  override val name: String = "AnyEvent"

  override def preFilter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity): Boolean = true
}

```

`thehive/app/org/thp/thehive/services/notification/triggers/CaseCreated.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.{Audit, Organisation, User}
import play.api.Configuration

import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

@Singleton
class CaseCreatedProvider @Inject() extends TriggerProvider {
  override val name: String                               = "CaseCreated"
  override def apply(config: Configuration): Try[Trigger] = Success(CaseCreated)
}

object CaseCreated extends Trigger {
  override val name: String = "CaseCreated"

  override def preFilter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity): Boolean =
    audit.action == Audit.create && audit.objectType.contains("Case")

  override def filter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity, user: Option[User with Entity])(
      implicit graph: Graph
  ): Boolean =
    super.filter(audit, context, organisation, user) &&
      preFilter(audit, context, organisation) &&
      user.fold(true)(_.login != audit._createdBy)
}

```

`thehive/app/org/thp/thehive/services/notification/triggers/CaseShared.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.scalligraph.models.Entity
import org.thp.thehive.models.{Audit, Organisation}
import play.api.Configuration
import play.api.libs.json.Json

import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

@Singleton
class CaseShareProvider @Inject() extends TriggerProvider {
  override val name: String                               = "CaseShared"
  override def apply(config: Configuration): Try[Trigger] = Success(CaseShared)
}

object CaseShared extends Trigger {
  override val name: String = "CaseShared"

  override def preFilter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity): Boolean =
    audit.action == Audit.update && audit
      .objectType
      .contains("Case") && audit.details.flatMap(d => Try(Json.parse(d)).toOption).exists(d => (d \ "share").isDefined)
}

```

`thehive/app/org/thp/thehive/services/notification/triggers/FilteredEvent.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import com.typesafe.config.ConfigRenderOptions
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.{Audit, Organisation, User}
import play.api.Configuration
import play.api.libs.functional.syntax._
import play.api.libs.json.Reads._
import play.api.libs.json._

import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

object EventFilterOnMissingUser extends Exception

trait EventFilter {
  def getField[T](event: JsValue, name: String)(implicit reads: Reads[T]): Option[T] =
    name.split('.').foldLeft[JsLookupResult](JsDefined(event))(_ \ _).asOpt[T].orElse {
      if (name == "user") throw EventFilterOnMissingUser
      else None
    }
  def apply(event: JsObject): Boolean
}

object AnyEventFilter extends EventFilter {
  override def apply(event: JsObject): Boolean = true
}
case class AndEventFilter(filters: Seq[EventFilter]) extends EventFilter {
  override def apply(event: JsObject): Boolean = filters.forall(_.apply(event))
}
case class OrEventFilter(filters: Seq[EventFilter]) extends EventFilter {
  override def apply(event: JsObject): Boolean = filters.exists(_.apply(event))
}
case class NotEventFilter(filter: EventFilter) extends EventFilter {
  override def apply(event: JsObject): Boolean = !filter.apply(event)
}
case class LtEventFilter(field: String, value: BigDecimal) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[BigDecimal](event, field).fold(false)(_ < value)
}
case class GtEventFilter(field: String, value: BigDecimal) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[BigDecimal](event, field).fold(false)(_ > value)
}
case class LteEventFilter(field: String, value: BigDecimal) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[BigDecimal](event, field).fold(false)(_ <= value)
}
case class GteEventFilter(field: String, value: BigDecimal) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[BigDecimal](event, field).fold(false)(_ >= value)
}
case class IsEventFilter(field: String, value: JsValue) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[JsValue](event, field).fold(false)(_ == value)
}
case class StartsWithEventFilter(field: String, value: String) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[String](event, field).fold(false)(_.startsWith(value))
}
case class EndsWithEventFilter(field: String, value: String) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[String](event, field).fold(false)(_.endsWith(value))
}
case class BetweenEventFilter(field: String, from: BigDecimal, to: BigDecimal) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[BigDecimal](event, field).fold(false)(v => from <= v && v < to)
}
case class InEventFilter(field: String, values: Seq[JsValue]) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[JsValue](event, field).fold(false)(values.contains)
}
case class ContainsEventFilter(field: String, value: String) extends EventFilter {
  override def apply(event: JsObject): Boolean = getField[String](event, field).fold(false)(_.contains(value))
}
case class LikeEventFilter(field: String, value: String) extends EventFilter {
  lazy val s: Boolean = value.headOption.contains('*')
  lazy val e: Boolean = value.lastOption.contains('*')
  override def apply(event: JsObject): Boolean =
    getField[String](event, field).fold(false) {
      case v if s && e => v.contains(value.tail.dropRight(1))
      case v if s      => v.endsWith(value)
      case v if e      => v.startsWith(value)
      case v           => v == value
    }

}

object EventFilter {
  implicit val fieldValueReads: Reads[(String, JsValue)] = Reads[(String, JsValue)] {
    case obj: JsObject if obj.fields.size == 1 => JsSuccess(obj.fields.head)
    case _                                     => JsError("An object with only one field is expected")
  }

  implicit val fieldStringValueReads: Reads[(String, String)] = Reads[(String, String)] {
    case obj: JsObject if obj.fields.size == 1 =>
      obj.fields.head match {
        case (k, JsString(s)) => JsSuccess(k -> s)
        case _                => JsError("An object with only one string field is expected")
      }
    case _ => JsError("An object with only one string field is expected")
  }
  implicit val fieldNumberValueReads: Reads[(String, BigDecimal)] = Reads[(String, BigDecimal)] {
    case obj: JsObject if obj.fields.size == 1 =>
      obj.fields.head match {
        case (k, JsNumber(n)) => JsSuccess(k -> n)
        case _                => JsError("An object with only one number field is expected")
      }
    case _ => JsError("An object with only one number field is expected")
  }

  implicit val fieldValuesReads: Reads[InEventFilter] =
    ((JsPath \ "_field").read[String] and
      (JsPath \ "_values").read[Seq[JsValue]])(InEventFilter.apply _)

  implicit val betweenEventFilterReads: Reads[BetweenEventFilter] =
    ((JsPath \ "_field").read[String] and
      (JsPath \ "_from").read[BigDecimal] and
      (JsPath \ "_to").read[BigDecimal])(BetweenEventFilter.apply _)

  implicit lazy val reads: Reads[EventFilter] =
    (JsPath \ "_any").read[JsValue].map(_ => AnyEventFilter.asInstanceOf[EventFilter]) orElse
      (JsPath \ "_and").lazyRead[Seq[EventFilter]](Reads.seq(reads)).map(AndEventFilter) orElse
      (JsPath \ "_or").lazyRead[Seq[EventFilter]](Reads.seq(reads)).map(OrEventFilter) orElse
      (JsPath \ "_not").lazyRead[EventFilter](reads).map(NotEventFilter) orElse
      (JsPath \ "_lt").read[(String, BigDecimal)].map(fv => LtEventFilter(fv._1, fv._2)) orElse
      (JsPath \ "_gt").read[(String, BigDecimal)].map(fv => GtEventFilter(fv._1, fv._2)) orElse
      (JsPath \ "_lte").read[(String, BigDecimal)].map(fv => LteEventFilter(fv._1, fv._2)) orElse
      (JsPath \ "_gte").read[(String, BigDecimal)].map(fv => GteEventFilter(fv._1, fv._2)) orElse
      (JsPath \ "_is").read[(String, JsValue)].map(fv => IsEventFilter(fv._1, fv._2)) orElse
      (JsPath \ "_startsWith").read[(String, String)].map(fv => StartsWithEventFilter(fv._1, fv._2)) orElse
      (JsPath \ "_endsWith").read[(String, String)].map(fv => EndsWithEventFilter(fv._1, fv._2)) orElse
      (JsPath \ "_between").read[BetweenEventFilter].map(identity) orElse
      (JsPath \ "_in").read[InEventFilter].map(identity) orElse
      (JsPath \ "_contains").read[(String, String)].map(fv => ContainsEventFilter(fv._1, fv._2)) orElse
      (JsPath \ "_like").read[(String, String)].map(fv => LikeEventFilter(fv._1, fv._2))
}

@Singleton
class FilteredEventProvider @Inject() extends TriggerProvider {
  override val name: String = "FilteredEvent"
  override def apply(config: Configuration): Try[Trigger] = {
    val filter = Json.parse(config.underlying.getValue("filter").render(ConfigRenderOptions.concise())).as[EventFilter]
    Success(FilteredEvent(filter))
  }
}

case class FilteredEvent(eventFilter: EventFilter) extends Trigger {
  override val name: String = "FilteredEvent"

  override def preFilter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity): Boolean =
    try eventFilter(
      Json.obj(
        "requestId"  -> audit.requestId,
        "action"     -> audit.action,
        "mainAction" -> audit.mainAction,
        "objectId"   -> audit.objectId,
        "objectType" -> audit.objectType,
        "details"    -> audit.details,
        "_createdBy" -> audit._createdBy,
        "_updatedBy" -> audit._updatedBy,
        "_createdAt" -> audit._createdAt,
        "_updatedAt" -> audit._updatedAt
      )
    )
    catch {
      case EventFilterOnMissingUser => true
    }

  override def filter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity, user: Option[User with Entity])(
      implicit graph: Graph
  ): Boolean =
    try super.filter(audit, context, organisation, user) && eventFilter(
      Json.obj(
        "requestId"  -> audit.requestId,
        "action"     -> audit.action,
        "mainAction" -> audit.mainAction,
        "objectId"   -> audit.objectId,
        "objectType" -> audit.objectType,
        "details"    -> audit.details,
        "_createdBy" -> audit._createdBy,
        "_updatedBy" -> audit._updatedBy,
        "_createdAt" -> audit._createdAt,
        "_updatedAt" -> audit._updatedAt,
        "user"       -> user.map(_.login)
      )
    )
    catch {
      case EventFilterOnMissingUser => false
    }
}

```

`thehive/app/org/thp/thehive/services/notification/triggers/GlobalTrigger.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.{Audit, Organisation, User}

trait GlobalTrigger extends Trigger {
  val entityName: String
  val auditAction: String

  override def preFilter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity): Boolean =
    audit.action == auditAction && audit.objectType.contains(entityName)

  override def filter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity, user: Option[User with Entity])(
      implicit graph: Graph
  ): Boolean =
    preFilter(audit, context, organisation) &&
      super.filter(audit, context, organisation, user) &&
      user.fold(true)(_.login != audit._createdBy)
}

```

`thehive/app/org/thp/thehive/services/notification/triggers/JobFinished.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.thehive.models.Audit
import play.api.Configuration

import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

@Singleton
class JobFinishedProvider @Inject() extends TriggerProvider {
  override val name: String                               = "JobFinished"
  override def apply(config: Configuration): Try[Trigger] = Success(JobFinished)
}

object JobFinished extends GlobalTrigger {
  override val name: String        = "JobFinished"
  override val auditAction: String = Audit.update
  override val entityName: String  = "Job"
}

```

`thehive/app/org/thp/thehive/services/notification/triggers/LogInMyTask.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.scalligraph.EntityId
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.models.{Audit, Organisation, User}
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.LogSrv
import org.thp.thehive.services.TaskOps._
import play.api.Configuration

import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

@Singleton
class LogInMyTaskProvider @Inject() (logSrv: LogSrv) extends TriggerProvider {
  override val name: String                               = "LogInMyTask"
  override def apply(config: Configuration): Try[Trigger] = Success(new LogInMyTask(logSrv))
}

class LogInMyTask(logSrv: LogSrv) extends Trigger {
  override val name: String = "LogInMyTask"

  override def preFilter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity): Boolean =
    audit.action == Audit.create && audit.objectType.contains("Log")

  override def filter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity, user: Option[User with Entity])(
      implicit graph: Graph
  ): Boolean =
    user.fold(false) { u =>
      super.filter(audit, context, organisation, user) &&
      preFilter(audit, context, organisation) &&
      u.login != audit._createdBy &&
      audit.objectEntityId.fold(false)(o => taskAssignee(o).fold(false)(_ == u.login))
    }

  def taskAssignee(logId: EntityId)(implicit graph: Graph): Option[String] =
    logSrv.getByIds(logId).task.assignee.value(_.login).headOption

  override def toString: String = "LogInMyTask"
}

```

`thehive/app/org/thp/thehive/services/notification/triggers/TaskAssigned.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.scalligraph.EntityId
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.models.{Audit, Organisation, User}
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.TaskSrv
import org.thp.thehive.services.UserOps._
import play.api.Configuration

import javax.inject.{Inject, Singleton}
import scala.util.{Success, Try}

@Singleton
class TaskAssignedProvider @Inject() (taskSrv: TaskSrv) extends TriggerProvider {
  override val name: String                               = "TaskAssigned"
  override def apply(config: Configuration): Try[Trigger] = Success(new TaskAssigned(taskSrv))
}

class TaskAssigned(taskSrv: TaskSrv) extends Trigger {
  override val name: String = "TaskAssigned"

  override def preFilter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity): Boolean =
    audit.action == Audit.update && audit.objectType.contains("Task")

  override def filter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity, user: Option[User with Entity])(
      implicit graph: Graph
  ): Boolean =
    user.fold(false) { u =>
      preFilter(audit, context, organisation) &&
      super.filter(audit, context, organisation, user) &&
      u.login != audit._createdBy &&
      audit.objectEntityId.fold(false)(taskAssignee(_, u._id).isDefined)
    }

  def taskAssignee(taskId: EntityId, userId: EntityId)(implicit graph: Graph): Option[User with Entity] =
    taskSrv.getByIds(taskId).assignee.get(userId).headOption

  override def toString: String = "TaskAssigned"
}

```

`thehive/app/org/thp/thehive/services/notification/triggers/Trigger.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.scalligraph.BadConfigurationError
import org.thp.scalligraph.models.Entity
import org.thp.scalligraph.traversal.Graph
import org.thp.thehive.models.{Audit, Organisation, User}
import play.api.{ConfigLoader, Configuration}

import scala.util.{Failure, Success, Try}

trait Trigger {
  val name: String

  def preFilter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity): Boolean

  def filter(audit: Audit with Entity, context: Option[Entity], organisation: Organisation with Entity, user: Option[User with Entity])(implicit
      graph: Graph
  ): Boolean = user.fold(true)(!_.locked)

  override def toString: String = s"Trigger($name)"
}

trait TriggerProvider extends (Configuration => Try[Trigger]) {
  val name: String
  implicit class RichConfig(configuration: Configuration) {

    def getOrFail[A: ConfigLoader](path: String): Try[A] =
      configuration
        .getOptional[A](path)
        .fold[Try[A]](Failure(BadConfigurationError(s"Configuration $path is missing")))(Success(_))
  }
}

```

`thehive/app/org/thp/thehive/services/th3/Aggregation.scala`:

```scala
package org.thp.thehive.services.th3

import org.apache.tinkerpop.gremlin.process.traversal.Order
import org.joda.time.DateTime
import org.scalactic.Accumulation._
import org.scalactic._
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers._
import org.thp.scalligraph.query.{Aggregation, InputQuery, PublicProperties}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal._
import org.thp.scalligraph.{BadRequestError, InvalidFormatAttributeError}
import play.api.Logger
import play.api.libs.json._

import java.lang.{Long => JLong}
import java.time.temporal.ChronoUnit
import java.util.{Calendar, Date, List => JList}
import scala.reflect.runtime.{universe => ru}
import scala.util.Try
import scala.util.matching.Regex

object TH3Aggregation {

  object AggObj {
    def unapply(field: Field): Option[(String, FObject)] =
      field match {
        case f: FObject =>
          f.get("_agg") match {
            case FString(name) => Some(name -> (f - "_agg"))
            case _             => None
          }
        case _ => None
      }
  }

  val intervalParser: FieldsParser[(Long, ChronoUnit)] = FieldsParser[(Long, ChronoUnit)]("interval") {
    case (_, f) =>
      withGood(
        FieldsParser.long.optional.on("_interval")(f),
        FieldsParser[ChronoUnit]("chronoUnit") {
          case (_, f @ FString(value)) =>
            Or.from(
              Try(ChronoUnit.valueOf(value)).toOption,
              One(InvalidFormatAttributeError("_unit", "chronoUnit", ChronoUnit.values.toSet.map((_: ChronoUnit).toString), f))
            )
        }.on("_unit")(f)
      )((i, u) => i.getOrElse(0L) -> u)
  }

  val intervalRegex: Regex = "(\\d+)([smhdwMy])".r

  val mergedIntervalParser: FieldsParser[(Long, ChronoUnit)] = FieldsParser[(Long, ChronoUnit)]("interval") {
    case (_, FString(intervalRegex(interval, unit))) =>
      Good(unit match {
        case "s" => interval.toLong -> ChronoUnit.SECONDS
        case "m" => interval.toLong -> ChronoUnit.MINUTES
        case "h" => interval.toLong -> ChronoUnit.HOURS
        case "d" => interval.toLong -> ChronoUnit.DAYS
        case "w" => interval.toLong -> ChronoUnit.WEEKS
        case "M" => interval.toLong -> ChronoUnit.MONTHS
        case "y" => interval.toLong -> ChronoUnit.YEARS
      })
  }

  def aggregationFieldParser(
      filterParser: FieldsParser[InputQuery[Traversal.Unk, Traversal.Unk]]
  ): PartialFunction[String, FieldsParser[Aggregation]] = {
    case "field" =>
      FieldsParser("FieldAggregation") {
        case (_, field) =>
          withGood(
            FieldsParser.string.optional.on("_name")(field),
            FieldsParser.string.on("_field")(field),
            FieldsParser.string.sequence.on("_order")(field).orElse(FieldsParser.string.on("_order").map("order")(Seq(_))(field)),
            FieldsParser.long.optional.on("_size")(field),
            fieldsParser(filterParser).sequence.on("_select")(field),
            filterParser.optional.on("_query")(field)
          )((aggName, fieldName, order, size, subAgg, filter) => FieldAggregation(aggName, fieldName, order, size, subAgg, filter))
      }
    case "count" =>
      FieldsParser("CountAggregation") {
        case (_, field) =>
          withGood(FieldsParser.string.optional.on("_name")(field), filterParser.optional.on("_query")(field))((aggName, filter) =>
            AggCount(aggName, filter)
          )
      }
    case "time" =>
      FieldsParser("TimeAggregation") {
        case (_, field) =>
          withGood(
            FieldsParser.string.optional.on("_name")(field),
            FieldsParser
              .string
              .sequence
              .on("_fields")(field)
              .orElse(FieldsParser.string.on("_fields")(field).map(Seq(_))), //.map("toSeq")(f => Good(Seq(f)))),
            mergedIntervalParser.on("_interval").orElse(intervalParser)(field),
            fieldsParser(filterParser).sequence.on("_select")(field),
            filterParser.optional.on("_query")(field)
          ) { (aggName, fieldNames, intervalUnit, subAgg, filter) =>
            if (fieldNames.lengthCompare(1) > 0)
              logger.warn(s"Only one field is supported for time aggregation (aggregation $aggName, ${fieldNames.tail.mkString(",")} are ignored)")
            TimeAggregation(aggName, fieldNames.head, intervalUnit._1, intervalUnit._2, subAgg, filter)
          }
      }
    case "avg" =>
      FieldsParser("AvgAggregation") {
        case (_, field) =>
          withGood(
            FieldsParser.string.optional.on("_name")(field),
            FieldsParser.string.on("_field")(field),
            filterParser.optional.on("_query")(field)
          )((aggName, fieldName, filter) => AggAvg(aggName, fieldName, filter))
      }
    case "min" =>
      FieldsParser("MinAggregation") {
        case (_, field) =>
          withGood(
            FieldsParser.string.optional.on("_name")(field),
            FieldsParser.string.on("_field")(field),
            filterParser.optional.on("_query")(field)
          )((aggName, fieldName, filter) => AggMin(aggName, fieldName, filter))
      }
    case "max" =>
      FieldsParser("MaxAggregation") {
        case (_, field) =>
          withGood(
            FieldsParser.string.optional.on("_name")(field),
            FieldsParser.string.on("_field")(field),
            filterParser.optional.on("_query")(field)
          )((aggName, fieldName, filter) => AggMax(aggName, fieldName, filter))
      }
    case "sum" =>
      FieldsParser("SumAggregation") {
        case (_, field) =>
          withGood(
            FieldsParser.string.optional.on("_name")(field),
            FieldsParser.string.on("_field")(field),
            filterParser.optional.on("_query")(field)
          )((aggName, fieldName, filter) => AggSum(aggName, fieldName, filter))
      }
    case other =>
      new FieldsParser[Aggregation](
        "unknownAttribute",
        Set.empty,
        {
          case (path, _) =>
            Bad(One(InvalidFormatAttributeError(path.toString, "string", Set("field", "time", "count", "avg", "min", "max"), FString(other))))
        }
      )
  }

  def fieldsParser(filterParser: FieldsParser[InputQuery[Traversal.Unk, Traversal.Unk]]): FieldsParser[Aggregation] =
    FieldsParser("aggregation") {
      case (_, AggObj(name, field)) => aggregationFieldParser(filterParser)(name)(field)
    }
}

case class AggSum(aggName: Option[String], fieldName: String, filter: Option[InputQuery[Traversal.Unk, Traversal.Unk]])
    extends Aggregation(aggName.getOrElse(s"sum_$fieldName")) {
  override def getTraversal(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Domain[Output[_]] = {
    val fieldPath = FPath(fieldName)
    val property = publicProperties
      .get[Traversal.UnkD, Traversal.UnkDU](fieldPath, traversalType)
      .getOrElse(throw BadRequestError(s"Property $fieldName for type $traversalType not found"))
    filter
      .fold(traversal)(_(publicProperties, traversalType, traversal, authContext))
      .fold
      .coalesce(
        t =>
          property
            .select(fieldPath, t.unfold, authContext)
            .sum
            .domainMap(sum => Output(Json.obj(name -> JsNumber(BigDecimal(sum.toString)))))
            .castDomain[Output[_]],
        Output(Json.obj(name -> JsNull))
      )
  }
}

case class AggAvg(aggName: Option[String], fieldName: String, filter: Option[InputQuery[Traversal.Unk, Traversal.Unk]])
    extends Aggregation(aggName.getOrElse(s"sum_$fieldName")) {
  override def getTraversal(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Domain[Output[_]] = {
    val fieldPath = if (fieldName.startsWith("computed")) FPathElem(fieldName) else FPath(fieldName)
    val property = publicProperties
      .get[Traversal.UnkD, Traversal.UnkDU](fieldPath, traversalType)
      .getOrElse(throw BadRequestError(s"Property $fieldName for type $traversalType not found"))
    filter
      .fold(traversal)(_(publicProperties, traversalType, traversal, authContext))
      .fold
      .coalesce(
        t =>
          property
            .select(fieldPath, t.unfold, authContext)
            .mean
            .domainMap(avg => Output(Json.obj(name -> avg)))
            .asInstanceOf[Traversal.Domain[Output[_]]],
        Output(Json.obj(name -> JsNull))
      )
  }
}

case class AggMin(aggName: Option[String], fieldName: String, filter: Option[InputQuery[Traversal.Unk, Traversal.Unk]])
    extends Aggregation(aggName.getOrElse(s"min_$fieldName")) {
  override def getTraversal(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Domain[Output[_]] = {
    val fieldPath = FPath(fieldName)
    val property = publicProperties
      .get[Traversal.UnkD, Traversal.UnkDU](fieldPath, traversalType)
      .getOrElse(throw BadRequestError(s"Property $fieldName for type $traversalType not found"))
    filter
      .fold(traversal)(_(publicProperties, traversalType, traversal, authContext))
      .fold
      .coalesce(
        t =>
          property
            .select(fieldPath, t.unfold, authContext)
            .min
            .domainMap(min => Output(Json.obj(name -> property.toJson(min)))),
        Output(Json.obj(name -> JsNull))
      )
  }
}

case class AggMax(aggName: Option[String], fieldName: String, filter: Option[InputQuery[Traversal.Unk, Traversal.Unk]])
    extends Aggregation(aggName.getOrElse(s"max_$fieldName")) {
  override def getTraversal(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Domain[Output[_]] = {
    val fieldPath = FPath(fieldName)
    val property = publicProperties
      .get[Traversal.UnkD, Traversal.UnkDU](fieldPath, traversalType)
      .getOrElse(throw BadRequestError(s"Property $fieldName for type $traversalType not found"))
    filter
      .fold(traversal)(_(publicProperties, traversalType, traversal, authContext))
      .fold
      .coalesce(
        t =>
          property
            .select(fieldPath, t.unfold, authContext)
            .max
            .domainMap(max => Output(Json.obj(name -> property.toJson(max)))),
        Output(Json.obj(name -> JsNull))
      )
  }
}

case class AggCount(aggName: Option[String], filter: Option[InputQuery[Traversal.Unk, Traversal.Unk]])
    extends Aggregation(aggName.getOrElse("count")) {
  override def getTraversal(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Domain[Output[_]] =
    filter
      .fold(traversal)(_(publicProperties, traversalType, traversal, authContext))
      .count
      .domainMap(count => Output(Json.obj(name -> count)))
      .castDomain[Output[_]]
}

//case class AggTop[T](fieldName: String) extends AggFunction[T](s"top_$fieldName")

case class FieldAggregation(
    aggName: Option[String],
    fieldName: String,
    orders: Seq[String],
    size: Option[Long],
    subAggs: Seq[Aggregation],
    filter: Option[InputQuery[Traversal.Unk, Traversal.Unk]]
) extends Aggregation(aggName.getOrElse(s"field_$fieldName")) {
  lazy val logger: Logger = Logger(getClass)

  override def getTraversal(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Domain[Output[_]] = {
    val label     = StepLabel[Traversal.UnkD, Traversal.UnkG, Converter[Traversal.UnkD, Traversal.UnkG]]
    val fieldPath = FPath(fieldName)
    val property = publicProperties
      .get[Traversal.UnkD, Traversal.UnkDU](fieldPath, traversalType)
      .getOrElse(throw BadRequestError(s"Property $fieldName for type $traversalType not found"))
    val groupedVertices = property
      .select(
        fieldPath,
        filter
          .fold(traversal)(_(publicProperties, traversalType, traversal, authContext))
          .as(label),
        authContext
      )
      .group(_.by, _.by(_.select(label).fold))
      .unfold
    val sortedAndGroupedVertex = orders
      .map {
        case order if order.headOption.contains('-') => order.tail -> Order.desc
        case order if order.headOption.contains('+') => order.tail -> Order.asc
        case order                                   => order      -> Order.asc
      }
      .foldLeft(groupedVertices) {
        case (acc, (field, order)) if field == fieldName                    => acc.sort(_.by(_.selectKeys, order))
        case (acc, (field, order)) if field == "count" || field == "_count" => acc.sort(_.by(_.selectValues.localCount, order))
        case (acc, (field, _)) =>
          logger.warn(s"In field aggregation you can only sort by the field ($fieldName) or by count, not by $field")
          acc
      }
    val sizedSortedAndGroupedVertex = size.fold(sortedAndGroupedVertex)(sortedAndGroupedVertex.limit)
    val subAggProjection = subAggs.map {
      agg => (s: GenericBySelector[Seq[Traversal.UnkD], JList[Traversal.UnkG], Converter.CList[Traversal.UnkD, Traversal.UnkG, Converter[
        Traversal.UnkD,
        Traversal.UnkG
      ]]]) =>
        s.by(t => agg.getTraversal(publicProperties, traversalType, t.unfold, authContext).castDomain[Output[_]])
    }

    sizedSortedAndGroupedVertex
      .project(
        _.by(_.selectKeys)
          .by(
            _.selectValues
              .flatProject(subAggProjection: _*)
              .domainMap { aggResult =>
                Output(
                  aggResult
                    .asInstanceOf[Seq[Output[JsObject]]]
                    .map(_.toValue)
                    .reduceOption(_ deepMerge _)
                    .getOrElse(JsObject.empty)
                )
              }
          )
      )
      .fold
      .domainMap(kvs =>
        Output(JsObject(kvs.map {
          case (JsString(k), v) => k          -> v.toJson
          case (k, v)           => k.toString -> v.toJson
        }))
      )
      .castDomain[Output[_]]
  }
}

case class TimeAggregation(
    aggName: Option[String],
    fieldName: String,
    interval: Long,
    unit: ChronoUnit,
    subAggs: Seq[Aggregation],
    filter: Option[InputQuery[Traversal.Unk, Traversal.Unk]]
) extends Aggregation(aggName.getOrElse(fieldName)) {

  private val threeDaysInMillis = 259200000L
  private val oneWeekInMillis   = 604800000L
  private def roundToWeek(date: Date, nWeek: Long): Long = {
    val shiftedDate = date.getTime + threeDaysInMillis // Jan 1st is a thursday
    shiftedDate - (shiftedDate % (oneWeekInMillis * nWeek)) - threeDaysInMillis
  }

  private def dateToKey(date: Date): Long =
    unit match {
      case ChronoUnit.WEEKS => roundToWeek(date, interval)
      case ChronoUnit.MONTHS =>
        val d = new DateTime(date)
        new DateTime(d.getYear, d.getMonthOfYear, 1, 0, 0).getMillis
      case ChronoUnit.YEARS =>
        val d = new DateTime(date)
        new DateTime(d.getYear, 1, 1, 0, 0).getMillis
      case other =>
        val duration = other.getDuration.toMillis * interval
        date.getTime - (date.getTime % duration)
    }

  def keyToDate(key: Long): Date = new Date(key)

  override def getTraversal(
      publicProperties: PublicProperties,
      traversalType: ru.Type,
      traversal: Traversal.Unk,
      authContext: AuthContext
  ): Traversal.Domain[Output[_]] = {
    val fieldPath = FPath(fieldName)
    val property = publicProperties
      .get[Traversal.UnkD, Traversal.UnkDU](fieldPath, traversalType)
      .getOrElse(throw BadRequestError(s"Property $fieldName for type $traversalType not found"))
    val label = StepLabel[Traversal.UnkD, Traversal.UnkG, Converter[Traversal.UnkD, Traversal.UnkG]]
    val groupedVertex = property
      .select(
        fieldPath,
        filter
          .fold(traversal)(_(publicProperties, traversalType, traversal, authContext))
          .as(label),
        authContext
      )
      .cast[Date, Date]
      .graphMap[Long, JLong, Converter[Long, JLong]](dateToKey, Converter.long)
      .group(_.by, _.by(_.select(label).fold))
      .unfold
    val subAggProjection = subAggs.map {
      agg => (s: GenericBySelector[
        Seq[Traversal.UnkD],
        JList[Traversal.UnkG],
        Converter.CList[Traversal.UnkD, Traversal.UnkG, Converter[Traversal.UnkD, Traversal.UnkG]]
      ]) =>
        s.by(t => agg.getTraversal(publicProperties, traversalType, t.unfold, authContext).castDomain[Output[_]])
    }

    groupedVertex
      .project(
        _.by(_.selectKeys)
          .by(
            _.selectValues
              .flatProject(subAggProjection: _*)
              .domainMap { aggResult =>
                Output(
                  aggResult
                    .asInstanceOf[Seq[Output[JsObject]]]
                    .map(_.toValue)
                    .reduceOption(_ deepMerge _)
                    .getOrElse(JsObject.empty)
                )
              }
          )
      )
      .fold
      .domainMap(kvs => Output(JsObject(kvs.map(kv => kv._1.toString -> Json.obj(name -> kv._2.toJson)))))
      .castDomain[Output[_]]
  }
}

```

`thehive/conf/play/reference-overrides.conf`:

```conf
# HTTP filters
play.filters {
  # name of cookie in which the CSRF token is transmitted to client
  csrf.cookie.name = THEHIVE-XSRF-TOKEN
  # name of header in which the client should send CSRD token
  csrf.header.name = X-THEHIVE-XSRF-TOKEN

  enabled = [
  ]
}

play.http.parser.maxDiskBuffer = 128MB
play.http.parser.maxMemoryBuffer = 256kB


# Register module for dependency injection
play.modules.enabled += org.thp.thehive.TheHiveModule

play.http.session.cookieName = THEHIVE-SESSION

play.server.provider = org.thp.thehive.CustomAkkaHttpServerProvider

play.server.http.idleTimeout = 10 minutes

akka.actor {
  serializers {
    stream = "org.thp.thehive.services.StreamSerializer"
    notification = "org.thp.thehive.services.notification.NotificationSerializer"
    //thehive-schema-updater = "org.thp.thehive.models.SchemaUpdaterSerializer"
    flow = "org.thp.thehive.services.FlowSerializer"
    integrity = "org.thp.thehive.services.IntegrityCheckSerializer"
    caseNumber = "org.thp.thehive.services.CaseNumberSerializer"
  }

  serialization-bindings {
    "org.thp.thehive.services.StreamMessage" = stream
    "org.thp.thehive.services.notification.NotificationMessage" = notification
    //"org.thp.thehive.models.SchemaUpdaterMessage" = thehive-schema-updater
    "org.thp.thehive.services.FlowMessage" = flow
    "org.thp.thehive.services.IntegrityCheck$Message" = integrity
    "org.thp.thehive.services.CaseNumberActor$Message" = caseNumber
  }
}

```

`thehive/conf/reference.conf`:

```conf
db {
  provider: janusgraph
  janusgraph {
    index.search {
      backend: lucene
      directory: /opt/thp/thehive/index
    }
    storage {
      directory: /opt/thp/thehive/database
    }
  }
  initialisationTimeout: 14 days
}

query.limitedCountThreshold: 1000

storage {
  provider: localfs
  localfs.directory: /opt/thp/thehive/files
}

flow.maxAge: 1 day

auth {
  providers: [
    {name: session}
    {name: basic, realm: thehive}
    {name: local}
    {name: key}
  ]
  defaultUserDomain: "thehive.local"
  organisationCookieName: "X-Organisation"
  multifactor {
    enabled: true
    issuer: TheHive
  }
}

session {
  warning: 5m
  inactivity: 1h
}

attachment.hash: [SHA-256, SHA-1, MD5]
datastore.attachment.password: "malware"

describe.cache.expire: 10 minutes

stream {
  longPolling {
    refresh: 1 minute
    maxWait: 1 second
    graceDuration: 100 milliseconds
    keepAlive: 5 minutes
    pollingDuration: 1 second

  }
  get {
    maxAttempts = 5
    minBackoff = 10 milliseconds
    maxBackoff = 50 milliseconds
    randomFactor = 0.2
  }
}

caseNumber.reload.interval: 10 minutes

tags.freeTagColour: "#000000"

user {
  defaults {
    notification: []
    organisation: "admin"
    profile: "admin"
  }
  autoCreateOnSso: false
  profileFieldName: "profile"
  organisationFieldName: "organisation"
}

organisation {
  defaults {
    notification: []
  }
}

roles: [default]

play.mailer {
  host: "localhost"
}

application.baseUrl: "http://localhost"

monitor.disk: []

notification {
  webhook {
    endpoints: []
  }
  mattermost {
    webhook: "http://localhost:8065/hooks/xxxyoursecretkeyxxx"
    username: "thehive"
    ws: {}
    template: """
Audit ({{audit.requestId}}):
{{audit.action}} {{audit.objectType}} {{audit.objectId}}
  by {{audit._createdBy}} at {audit._createdAt}}
Context {{context._type}} {{context._id}} ({{user.organisation}})
For user {{user.login}}
----------------"""
  }
  emailer {
    subject: "Notification from TheHive"
    from: "notification@thehive.local"
    template: """
Audit ({{audit.requestId}}):
{{audit.action}} {{audit.objectType}} {{audit.objectId}}
  by {{audit._createdBy}} at {audit._createdAt}}
Context {{context._type}} {{context._id}} ({{user.organisation}})
For user {{user.login}}
----------------"""
  }
  appendToFile {
    template: """
Audit ({{audit.requestId}}):
{{audit.action}} {{audit.objectType}} {{audit.objectId}}
  by {{audit._createdBy}} at {audit._createdAt}}
Context {{context._type}} {{context._id}} ({{user.organisation}})
For user {{user.login}}
----------------"""
  }

}

integrityCheck {
  enabled: true
  schedule: "0 30 2 ? * SUN"
  maxDuration: 4 hours
  integrityCheckConfig: {
    default {
      enabled: true
      //    minTime: 1 minute
      //    maxTime: 1 hour
      initialDelay: 1 minute
      minInterval: 10 minutes
      dedupStrategy: AfterAddition
    }
    Profile {
      enabled: true
      initialDelay: 10 seconds
      minInterval: 1 minutes
      dedupStrategy: AfterAddition
    }
    Organisation {
      enabled: true
      initialDelay: 30 seconds
      minInterval: 1 minutes
      dedupStrategy: AfterAddition
    }
    Tag {
      enabled: true
      initialDelay: 5 minute
      minInterval: 6 hours
      dedupStrategy: AfterAddition
    }
    User {
      enabled: true
      initialDelay: 30 seconds
      minInterval: 1 minutes
      dedupStrategy: AfterAddition
    }
    ImpactStatus {
      enabled: true
      initialDelay: 30 seconds
      minInterval: 1 minutes
      dedupStrategy: AfterAddition
    }
    ResolutionStatus {
      enabled: true
      initialDelay: 30 seconds
      minInterval: 1 minutes
      dedupStrategy: AfterAddition
    }
    ObservableType {
      enabled: true
      initialDelay: 30 seconds
      minInterval: 1 minutes
      dedupStrategy: AfterAddition
    }
    CustomField {
      enabled: true
      initialDelay: 1 minute
      minInterval: 10 minutes
      dedupStrategy: AfterAddition
    }
    CaseTemplate {
      enabled: true
      initialDelay: 1 minute
      minInterval: 10 minutes
      dedupStrategy: AfterAddition
    }
    Data {
      enabled: true
      initialDelay: 5 minute
      minInterval: 30 minutes
      dedupStrategy: AfterAddition
    }
    Case {
      enabled: true
      initialDelay: 1 minute
      minInterval: 10 minutes
      dedupStrategy: AfterAddition
    }
    Alert {
      enabled: true
      initialDelay: 5 minute
      minInterval: 30 minutes
      dedupStrategy: AfterAddition
    }
    Task {
      enabled: true
      initialDelay: 5 minute
      minInterval: 30 minutes
      dedupStrategy: AfterAddition
    }
    Log {
      enabled: true
      initialDelay: 5 minute
      minInterval: 30 minutes
      dedupStrategy: AfterAddition
    }
    Observable {
      enabled: true
      initialDelay: 5 minute
      minInterval: 30 minutes
      dedupStrategy: AfterAddition
    }
    Role {
      enabled: true
      initialDelay: 30 seconds
      minInterval: 1 minute
      dedupStrategy: AfterAddition
    }
  }
}


organisation.defaults {
  ui.hideEmptyCaseButton: false
  ui.disallowMergeAlertInResolvedSimilarCases: false
  ui.defaultAlertSimilarCaseFilter: "open-cases",
  ui.defaultDateFormat: "MM/DD/YY HH:mm"
}

```

`thehive/test/org/thp/thehive/DatabaseBuilder.scala`:

```scala
package org.thp.thehive

import org.scalactic.Or
import org.thp.scalligraph.auth.{AuthContext, AuthContextImpl}
import org.thp.scalligraph.controllers._
import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.services.{EdgeSrv, IntegrityCheck, VertexSrv}
import org.thp.scalligraph.traversal.Graph
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{EntityId, EntityName, RichOption}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.TaxonomyOps._
import org.thp.thehive.services._
import play.api.Logger
import play.api.libs.json.{JsArray, JsObject, JsValue, Json}

import java.io.File
import javax.inject.{Inject, Singleton}
import scala.io.Source
import scala.reflect.runtime.{universe => ru}
import scala.util.{Failure, Success, Try}

@Singleton
class DatabaseBuilder @Inject() (
    alertSrv: AlertSrv,
    attachmentSrv: AttachmentSrv,
    caseSrv: CaseSrv,
    caseTemplateSrv: CaseTemplateSrv,
    customFieldSrv: CustomFieldSrv,
    dashboardSrv: DashboardSrv,
    dataSrv: DataSrv,
    impactStatusSrv: ImpactStatusSrv,
    logSrv: LogSrv,
    observableSrv: ObservableSrv,
    observableTypeSrv: ObservableTypeSrv,
    organisationSrv: OrganisationSrv,
    pageSrv: PageSrv,
    patternSrv: PatternSrv,
    procedureSrv: ProcedureSrv,
    profileSrv: ProfileSrv,
    resolutionStatusSrv: ResolutionStatusSrv,
    roleSrv: RoleSrv,
    shareSrv: ShareSrv,
    tagSrv: TagSrv,
    taskSrv: TaskSrv,
    taxonomySrv: TaxonomySrv,
    userSrv: UserSrv,
    integrityChecks: Set[IntegrityCheck]
) {

  lazy val logger: Logger = Logger(getClass)

  def build()(implicit db: Database): Try[Unit] = {

    lazy val logger: Logger = Logger(getClass)
    logger.info("Initialize database schema")
    integrityChecks.foreach { check =>
      db.tryTransaction { implicit graph =>
        Success(check.initialCheck()(graph, LocalUserSrv.getSystemAuthContext))
      }
      ()
    }
    db.tryTransaction { implicit graph =>
      implicit val authContext: AuthContext = LocalUserSrv.getSystemAuthContext
      val idMap =
        createVertex(caseSrv, FieldsParser[Case]) ++
          createVertex(alertSrv, FieldsParser[Alert]) ++
          createVertex(attachmentSrv, FieldsParser[Attachment]) ++
          createVertex(caseTemplateSrv, FieldsParser[CaseTemplate]) ++
          createVertex(customFieldSrv, FieldsParser[CustomField]) ++
          createVertex(dashboardSrv, FieldsParser[Dashboard]) ++
          //              createVertex(dataSrv, FieldsParser[Data]) ++
          //              createVertex(impactStatusSrv, FieldsParser[ImpactStatus]) ++
          //              createVertex(keyValueSrv, FieldsParser[KeyValue]) ++
          createVertex(logSrv, FieldsParser[Log]) ++
          createVertex(observableSrv, FieldsParser[Observable]) ++
          createVertex(observableTypeSrv, FieldsParser[ObservableType]) ++
          createVertex(organisationSrv, FieldsParser[Organisation]) ++
          createVertex(pageSrv, FieldsParser[Page]) ++
          createVertex(patternSrv, FieldsParser[Pattern]) ++
          createVertex(procedureSrv, FieldsParser[Procedure]) ++
          createVertex(profileSrv, FieldsParser[Profile]) ++
          //              createVertex(resolutionStatusSrv, FieldsParser[ResolutionStatus]) ++
          createVertex(roleSrv, FieldsParser[Role]) ++
          createVertex(shareSrv, FieldsParser[Share]) ++
          createVertex(tagSrv, FieldsParser[Tag]) ++
          createVertex(taskSrv, FieldsParser[Task]) ++
          createVertex(taxonomySrv, FieldsParser[Taxonomy]) ++
          createVertex(userSrv, FieldsParser[User])

      createEdge(organisationSrv.organisationOrganisationSrv, organisationSrv, organisationSrv, FieldsParser[OrganisationOrganisation], idMap)
      createEdge(organisationSrv.organisationShareSrv, organisationSrv, shareSrv, FieldsParser[OrganisationShare], idMap)
      createEdge(organisationSrv.organisationTaxonomySrv, organisationSrv, taxonomySrv, FieldsParser[OrganisationTaxonomy], idMap)

      createEdge(taxonomySrv.taxonomyTagSrv, taxonomySrv, tagSrv, FieldsParser[TaxonomyTag], idMap)

      createEdge(roleSrv.userRoleSrv, userSrv, roleSrv, FieldsParser[UserRole], idMap)

      createEdge(shareSrv.shareProfileSrv, shareSrv, profileSrv, FieldsParser[ShareProfile], idMap)
      createEdge(shareSrv.shareObservableSrv, shareSrv, observableSrv, FieldsParser[ShareObservable], idMap)
      createEdge(shareSrv.shareTaskSrv, shareSrv, taskSrv, FieldsParser[ShareTask], idMap)
      createEdge(shareSrv.shareCaseSrv, shareSrv, caseSrv, FieldsParser[ShareCase], idMap)

      createEdge(roleSrv.roleOrganisationSrv, roleSrv, organisationSrv, FieldsParser[RoleOrganisation], idMap)
      createEdge(roleSrv.roleProfileSrv, roleSrv, profileSrv, FieldsParser[RoleProfile], idMap)

      //          createEdge(observableSrv.observableKeyValueSrv, observableSrv, keyValueSrv, FieldsParser[ObservableKeyValue], idMap)
      //          createEdge(observableSrv.observableObservableType, observableSrv, observableTypeSrv, FieldsParser[ObservableObservableType], idMap)
      //          createEdge(observableSrv.observableDataSrv, observableSrv, dataSrv, FieldsParser[ObservableData], idMap)
      createEdge(observableSrv.observableAttachmentSrv, observableSrv, attachmentSrv, FieldsParser[ObservableAttachment], idMap)
      //          createEdge(observableSrv.observableTagSrv, observableSrv, tagSrv, FieldsParser[ObservableTag], idMap)

      //          createEdge(taskSrv.taskUserSrv, taskSrv, userSrv, FieldsParser[TaskUser], idMap)
      createEdge(taskSrv.taskLogSrv, taskSrv, logSrv, FieldsParser[TaskLog], idMap)

      createEdge(logSrv.logAttachmentSrv, logSrv, attachmentSrv, FieldsParser[LogAttachment], idMap)
      //          createEdge(caseSrv.caseUserSrv, caseSrv, userSrv, FieldsParser[CaseUser], idMap)
      //          createEdge(caseSrv.mergedFromSrv, caseSrv, caseSrv, FieldsParser[MergedFrom], idMap)
      //          createEdge(caseSrv.caseCaseTemplateSrv, caseSrv, caseTemplateSrv, FieldsParser[CaseCaseTemplate], idMap)
      //          createEdge(caseSrv.caseResolutionStatusSrv, caseSrv, resolutionStatusSrv, FieldsParser[CaseResolutionStatus], idMap)
      //          createEdge(caseSrv.caseImpactStatusSrv, caseSrv, impactStatusSrv, FieldsParser[CaseImpactStatus], idMap)
      createEdge(caseSrv.caseCustomFieldSrv, caseSrv, customFieldSrv, FieldsParser[CaseCustomField], idMap)
      //          createEdge(caseSrv.caseTagSrv, caseSrv, tagSrv, FieldsParser[CaseTag], idMap)

      createEdge(caseTemplateSrv.caseTemplateOrganisationSrv, caseTemplateSrv, organisationSrv, FieldsParser[CaseTemplateOrganisation], idMap)
      //          createEdge(caseTemplateSrv.caseTemplateTaskSrv, caseTemplateSrv, taskSrv, FieldsParser[CaseTemplateTask], idMap)
      createEdge(caseTemplateSrv.caseTemplateCustomFieldSrv, caseTemplateSrv, customFieldSrv, FieldsParser[CaseTemplateCustomField], idMap)
      //          createEdge(caseTemplateSrv.caseTemplateTagSrv, caseTemplateSrv, tagSrv, FieldsParser[CaseTemplateTag], idMap)

      createEdge(alertSrv.alertOrganisationSrv, alertSrv, organisationSrv, FieldsParser[AlertOrganisation], idMap)
      createEdge(alertSrv.alertObservableSrv, alertSrv, observableSrv, FieldsParser[AlertObservable], idMap)
      createEdge(alertSrv.alertCaseSrv, alertSrv, caseSrv, FieldsParser[AlertCase], idMap)
      createEdge(alertSrv.alertCaseTemplateSrv, alertSrv, caseTemplateSrv, FieldsParser[AlertCaseTemplate], idMap)
      createEdge(alertSrv.alertCustomFieldSrv, alertSrv, customFieldSrv, FieldsParser[AlertCustomField], idMap)
      //          createEdge(alertSrv.alertTagSrv, alertSrv, tagSrv, FieldsParser[AlertTag], idMap)

      createEdge(pageSrv.organisationPageSrv, organisationSrv, pageSrv, FieldsParser[OrganisationPage], idMap)

      createEdge(dashboardSrv.dashboardUserSrv, dashboardSrv, userSrv, FieldsParser[DashboardUser], idMap)
      createEdge(dashboardSrv.organisationDashboardSrv, organisationSrv, dashboardSrv, FieldsParser[OrganisationDashboard], idMap)

      //          createEdge(patternSrv.patternPatternSrv, patternSrv, patternSrv, FieldsParser[PatternPattern], idMap)

      createEdge(procedureSrv.caseProcedureSrv, caseSrv, procedureSrv, FieldsParser[CaseProcedure], idMap)
      createEdge(procedureSrv.procedurePatternSrv, procedureSrv, patternSrv, FieldsParser[ProcedurePattern], idMap)
      Success(())
    }

    db.tryTransaction { implicit graph =>
      val (defaultOrganisation, defaultUser) = organisationSrv.startTraversal.notAdmin.project(_.by.by(_.users)).head
      implicit val authContext: AuthContext =
        AuthContextImpl(defaultUser.login, defaultUser.name, defaultOrganisation._id, "init", Permissions.all)
      // For each organisation, if there is no custom taxonomy, create it
      organisationSrv
        .startTraversal
        .hasNot(_.name, "admin")
        .filterNot(_.taxonomies.freetags)
        .foreach(o => taxonomySrv.createFreetagTaxonomy(o).get)

      caseSrv
        .startTraversal
        .project(
          _.by
            .by(_.organisations._id.fold)
        )
        .foreach {
          case (case0, organisationIds) =>
            case0.tags.foreach(tag => tagSrv.getOrCreate(tag).flatMap(caseSrv.caseTagSrv.create(CaseTag(), case0, _)).get)
            case0.assignee.foreach(userSrv.getByName(_).getOrFail("User").flatMap(caseSrv.caseUserSrv.create(CaseUser(), case0, _)).get)
            case0
              .resolutionStatus
              .foreach(
                resolutionStatusSrv
                  .getByName(_)
                  .getOrFail("ResolutionStatus")
                  .flatMap(caseSrv.caseResolutionStatusSrv.create(CaseResolutionStatus(), case0, _))
                  .get
              )
            case0
              .impactStatus
              .foreach(
                impactStatusSrv
                  .getByName(_)
                  .getOrFail("ImpectStatus")
                  .flatMap(caseSrv.caseImpactStatusSrv.create(CaseImpactStatus(), case0, _))
                  .get
              )
            case0
              .caseTemplate
              .foreach(
                caseTemplateSrv
                  .getByName(_)
                  .getOrFail("CaseTemplate")
                  .flatMap(caseSrv.caseCaseTemplateSrv.create(CaseCaseTemplate(), case0, _))
                  .get
              )
            caseSrv.get(case0).update(_.organisationIds, organisationIds.toSet).iterate()
        }

      alertSrv
        .startTraversal
        .project(_.by.by(_.organisation._id).by(_.`case`._id.option))
        .foreach {
          case (alert, organisationId, caseId) =>
            alert.tags.foreach(tag => tagSrv.getOrCreate(tag).flatMap(alertSrv.alertTagSrv.create(AlertTag(), alert, _)).get)
            alertSrv.get(alert).update(_.organisationId, organisationId).update(_.caseId, caseId.getOrElse(EntityId.empty)).iterate()
        }

      observableSrv
        .startTraversal
        .project(_.by.by(_.coalesceIdent(_.`case`, _.alert)._id).by(_.organisations._id.fold))
        .foreach {
          case (observable, relatedId, organisationIds) =>
            observable
              .tags
              .foreach(tag => tagSrv.getOrCreate(tag).flatMap(observableSrv.observableTagSrv.create(ObservableTag(), observable, _)).get)
            observable
              .data
              .foreach(data =>
                dataSrv
                  .getByName(data)
                  .getOrFail("data")
                  .orElse(dataSrv.create(Data(data, None)))
                  .flatMap(observableSrv.observableDataSrv.create(ObservableData(), observable, _))
                  .get
              )
            observableSrv.get(observable).update(_.relatedId, relatedId).update(_.organisationIds, organisationIds.toSet).iterate()
        }

      caseTemplateSrv
        .startTraversal
        .foreach { caseTemplate =>
          caseTemplate
            .tags
            .foreach(tag => tagSrv.getOrCreate(tag).flatMap(caseTemplateSrv.caseTemplateTagSrv.create(CaseTemplateTag(), caseTemplate, _)).get)
        }

      logSrv
        .startTraversal
        .project(_.by.by(_.task._id).by(_.organisations._id.fold))
        .foreach {
          case (log, taskId, organisationIds) =>
            logSrv.get(log).update(_.taskId, taskId).update(_.organisationIds, organisationIds.toSet).iterate()
        }

      taskSrv
        .startTraversal
        .project(
          _.by
            .by(_.coalesceIdent(_.`case`, _.caseTemplate)._id)
            .by(_.coalesceIdent(_.organisations, _.caseTemplate.organisation)._id.fold)
        )
        .foreach {
          case (task, relatedId, organisationIds) =>
            task.assignee.foreach(userSrv.getByName(_).getOrFail("User").flatMap(taskSrv.taskUserSrv.create(TaskUser(), task, _)).get)
            taskSrv.get(task).update(_.relatedId, relatedId).update(_.organisationIds, organisationIds.toSet).iterate()
        }
      Success(())
    }
  }

  def warn(message: String, error: Throwable = null): Option[Nothing] = {
    logger.warn(message, error)
    None
  }

  def readFile(name: String): String = {
    val source = Source.fromResource(name)
    try source.mkString
    catch {
      case _: NullPointerException => sys.error(s"resources/$name : file or directory unreadable")
    } finally source.close()
  }

  def readFile(file: File): String = {
    val source = Source.fromFile(file)
    try source.mkString
    finally source.close()
  }

  //  def readDirectory(name: String): Seq[File] = {
  //    val loader = Thread.currentThread.getContextClassLoader
  //    val url    = Option(loader.getResource(name)).getOrElse(sys.error(s"Directory $name not found"))
  //    val path   = url.getPath
  //    new File(path).listFiles.toSeq
  //  }

  def readJsonFile(path: String): Seq[FObject] =
    try {
      val data = readFile(path)
      for {
        json <-
          Json
            .parse(data)
            .asOpt[JsValue]
            .orElse(warn(s"File $data has invalid format"))
            .flatMap {
              case arr: JsArray => arr.asOpt[Seq[JsObject]].orElse(warn("Array must contain only object"))
              case o: JsObject  => Some(Seq(o))
              case _            => warn(s"File $data contains data that is not an object nor an array")
            }
            .getOrElse(Nil)
      } yield FObject(json)
    } catch {
      case error: Throwable =>
        logger.warn(s"$path error: ${error.getMessage}")
        Nil
    }

  implicit class RichField(field: Field) {

    def getString(path: String): Option[String] =
      field.get(path) match {
        case FString(value) => Some(value)
        case _              => None
      }
  }

  def createVertex[V <: Product](
      srv: VertexSrv[V],
      parser: FieldsParser[V]
  )(implicit graph: Graph, authContext: AuthContext): Map[String, EntityId] =
    readJsonFile(s"data/${srv.model.label}.json").flatMap { fields =>
      parser(fields - "id")
        .flatMap(e => Or.from(srv.createEntity(e)))
        .map(v => fields.getString("id").map(_ -> v._id))
        .recover(e => warn(s"creation of ${srv.model.label} with $fields fails: $e"))
        .get
    }.toMap

  def createEdge[E <: Product, FROM <: Product: ru.TypeTag, TO <: Product: ru.TypeTag](
      srv: EdgeSrv[E, FROM, TO],
      fromSrv: VertexSrv[FROM],
      toSrv: VertexSrv[TO],
      parser: FieldsParser[E],
      idMap: Map[String, EntityId]
  )(implicit graph: Graph, authContext: AuthContext): Seq[E with Entity] =
    readJsonFile(s"data/${srv.model.label}.json")
      .flatMap { fields =>
        (for {
          fromExtId <- fields.getString("from").toTry(Failure(new Exception("Edge has no from vertex")))
          fromId = idMap.getOrElse(fromExtId, EntityName(fromExtId))
          from    <- fromSrv.getOrFail(fromId)
          toExtId <- fields.getString("to").toTry(Failure(new Exception("Edge has no to vertex")))
          toId = idMap.getOrElse(toExtId, EntityName(toExtId))
          to <- toSrv.getOrFail(toId)
          e  <- parser(fields - "from" - "to").fold(e => srv.create(e, from, to), _ => Failure(new Exception("XX")))
        } yield e)
          .fold(t => warn(s"Edge ${srv.model.label} creation fails with: $fields", t), Some(_))
      }
}

```

`thehive/test/org/thp/thehive/DevStart.scala`:

```scala
package org.thp.thehive

import play.api._
import play.core.server.{RealServerProcess, ServerConfig, ServerProcess, ServerProvider}

import java.io.File

object DevStart extends App {
  val process = new RealServerProcess(args)
  val config  = readConfig(process)

  val application: Application = {
    val environment = Environment(config.rootDir, process.classLoader, Mode.Dev)
    val context     = ApplicationLoader.Context.create(environment)
    val loader      = ApplicationLoader(context)
    loader.load(context)
  }
  Play.start(application)

  // Start the server
  val serverProvider = ServerProvider.fromConfiguration(process.classLoader, config.configuration)
  val server         = serverProvider.createServer(config, application)

  process.addShutdownHook {
    if (application.coordinatedShutdown.shutdownReason().isEmpty)
      server.stop()
  }

  def readConfig(process: ServerProcess) = {
    val configuration: Configuration = {
      val rootDirArg    = process.args.headOption.map(new File(_))
      val rootDirConfig = rootDirArg.fold(Map.empty[String, String])(ServerConfig.rootDirConfig)
      Configuration.load(process.classLoader, process.properties, rootDirConfig, allowMissingApplicationConf = true)
    }
    val rootDir: File = {
      val path = configuration
        .getOptional[String]("play.server.dir")
        .getOrElse(sys.error("No root server path supplied"))
      val file = new File(path)
      if (!file.isDirectory)
        sys.error(s"Bad root server path: $path")
      file
    }

    def parsePort(portType: String): Option[Int] =
      configuration.getOptional[String](s"play.server.$portType.port").filter(_ != "disabled").map { str =>
        try Integer.parseInt(str)
        catch {
          case _: NumberFormatException =>
            sys.error(s"Invalid ${portType.toUpperCase} port: $str")
        }
      }

    val httpPort  = parsePort("http")
    val httpsPort = parsePort("https")
    val address   = configuration.getOptional[String]("play.server.http.address").getOrElse("0.0.0.0")

    if (httpPort.orElse(httpsPort).isEmpty)
      sys.error("Must provide either an HTTP or HTTPS port")

    ServerConfig(rootDir, httpPort, httpsPort, address, Mode.Dev, process.properties, configuration)
  }
}

```

`thehive/test/org/thp/thehive/DummyActor.scala`:

```scala
package org.thp.thehive

import akka.actor.Actor

class DummyActor extends Actor {
  override def receive: Receive = PartialFunction.empty
}

```

`thehive/test/org/thp/thehive/FunctionalTest.scala`:

```scala
//package org.thp.thehive
//
//import java.util.Date
//
//import scala.concurrent.{ExecutionContext, Promise}
//import play.api.cache.caffeine.CaffeineCacheModule
//import play.api.i18n.{I18nModule => PlayI18nModule}
//import play.api.inject.guice.GuiceApplicationBuilder
//import play.api.inject.{SimpleModule, bind, BuiltinModule => PlayBuiltinModule}
//import play.api.libs.json._
//import play.api.libs.ws.WSClient
//import play.api.libs.ws.ahc.{AhcWSModule => PlayAhcWSModule}
//import play.api.mvc.{CookiesModule => PlayCookiesModule}
//import play.api.test.{Helpers, PlaySpecification, TestServer}
//import play.api.{Configuration, Environment}
//import _root_.controllers.{AssetsConfiguration, AssetsConfigurationProvider, AssetsMetadata, AssetsMetadataProvider}
//import com.typesafe.config.ConfigFactory
//import org.specs2.specification.core.Fragments
//import org.thp.client.{ApplicationError, Authentication, PasswordAuthentication}
//import org.thp.scalligraph.services.{LocalFileSystemStorageSrv, StorageSrv}
//import org.thp.scalligraph.{ScalligraphApplicationLoader, ScalligraphModule}
//import org.thp.thehive.client.TheHiveClient
//import org.thp.thehive.controllers.v1.{TestCase, TestUser}
//import org.thp.thehive.dto.v1._
//import org.thp.thehive.models.Permissions
//import org.thp.thehive.services.UserSrv
//import play.api.libs.mailer.{MailerClient, MockMailer}
//
//case class TestTask(
//    title: String,
//    description: Option[String],
//    status: String,
//    flag: Boolean,
//    startDate: Option[Date],
//    endDate: Option[Date],
//    order: Int,
//    dueDate: Option[Date]
//)
//
//object TestTask {
//
//  def apply(task: OutputTask): TestTask =
//    TestTask(task.title, task.description, task.status, task.flag, task.startDate, task.endDate, task.order, task.dueDate)
//}
//
//class FunctionalTest extends PlaySpecification {
//
//  sequential
//
////  case class StableAudit(
////      _createdBy: String,
////      _updatedBy: Option[String] = None,
////      operation: String,
////      attributeName: Option[String] = None,
////      oldValue: Option[String] = None,
////      newValue: Option[String] = None,
////      objType: String,
////      summary: Map[String, Map[String, Int]])
////  object StableAudit {
////    def apply(audit: OutputAudit): StableAudit =
////      StableAudit(
////        audit._createdBy,
////        audit._updatedBy,
////        audit.operation,
////        audit.attributeName,
////        audit.oldValue,
////        audit.newValue,
////        audit.obj._type,
////        audit.summary)
////  }
//
//  val janusGraphConfig =
//    Configuration(ConfigFactory.parseString("""
//                                              |db {
//                                              |  provider: janusgraph
//                                              |  storage.backend: inmemory
//                                              |}
//                                              |storage {
//                                              |  provider: localfs
//                                              |  localfs.location: /tmp
//                                              |}
//                                              |auth.providers: [
//                                              |  {name: basic},
//                                              |  {name: local}
//                                              |]
//    """.stripMargin))
////  Configuration(ConfigFactory.parseString("""
////      |db {
////      |  provider: janusgraph
////      |  storage.backend: berkeleyje
////      |  storage.directory: /tmp/thehive-test.db
////      |}
////      |storage {
////      |  provider: localfs
////      |  localfs.location: /tmp
////      |}
////      |auth.provider: [local]
////    """.stripMargin))
//
//  val orientdbConfig = Configuration(ConfigFactory.parseString("""
//                                                                 |db.provider: orientdb
//                                                                 |storage {
//                                                                 |  provider: localfs
//                                                                 |  localfs.location: /tmp
//                                                                 |}
//                                                                 |
//                                                                 |auth.providers: [
//                                                                 |  {name: basic},
//                                                                 |  {name: local}
//                                                                 |]
//   """.stripMargin))
//
//  val neo4jConfig = Configuration(ConfigFactory.parseString("""
//                                                              |db.provider: neo4j
//                                                              |storage {
//                                                              |  provider: localfs
//                                                              |  localfs.location: /tmp
//                                                              |}
//                                                              |auth.providers: [
//                                                              |  {name: basic},
//                                                              |  {name: local}
//                                                              |]
//    """.stripMargin))
//  Fragments.foreach(Seq(janusGraphConfig /*, orientdbConfig , neo4jConfig*/ )) { dbConfig =>
//    val serverPromise: Promise[TestServer] = Promise[TestServer]
//    lazy val server: TestServer            = serverPromise.future.value.get.get
//
//    s"[${dbConfig.get[String]("db.provider")}] TheHive" should {
//      lazy val app = server.application
//
//      implicit lazy val ec: ExecutionContext = app.injector.instanceOf[ExecutionContext]
//      implicit lazy val ws: WSClient         = app.injector.instanceOf[WSClient]
//      lazy val client                        = new TheHiveClient(s"http://127.0.0.1:${server.runningHttpPort.get}")
//
//      "start the application" in {
//        val applicationBuilder = GuiceApplicationBuilder()
//          .configure(dbConfig)
//          .load(
//            new PlayBuiltinModule,
//            new PlayI18nModule,
//            new PlayCookiesModule,
//            new PlayAhcWSModule,
//            new CaffeineCacheModule,
//            new ScalligraphModule,
//            new TheHiveModule(Environment.simple(), dbConfig),
//            new SimpleModule(
//              bind[AssetsMetadata].toProvider[AssetsMetadataProvider],
//              bind[AssetsConfiguration].toProvider[AssetsConfigurationProvider],
//              bind[StorageSrv].to[LocalFileSystemStorageSrv],
//              bind[MailerClient].to[MockMailer]
//
//              //              bind[Database].to[AuditedDatabase]
//            )
//          )
//        val application = applicationBuilder
//          .load(ScalligraphApplicationLoader.loadModules(applicationBuilder.loadModules))
//          .build()
//
//        serverPromise.success(TestServer(port = Helpers.testServerPort, application = application))
//        server.start()
//        1 must_=== 1
//      }
//
//      var adminUser: TestUser = null
//      var user2: TestUser     = null
//      var user3: TestUser     = null
//      var case1: TestCase     = null
//      var case2: TestCase     = null
//      var case2Id: String     = null
//      var case3: TestCase     = null
//      var task1: TestTask     = null
//
//      {
//        implicit val auth: Authentication = PasswordAuthentication(UserSrv.initUser.login, UserSrv.initUserPassword)
//
//        "get admin user" in {
//          val asyncResp = client.user.get("admin@thehive.local")
//          adminUser = TestUser(await(asyncResp))
//          adminUser.login must_=== "admin@thehive.local"
//        }
//
//        "create new user" in {
//          val asyncResp = client.user.create(InputUser("toom@thehive.local", "Thomas", Some("secret"), "analyst"))
//          user2 = TestUser(await(asyncResp))
//          val expected = TestUser("toom@thehive.local", "Thomas", "analyst", Set("manageAlert", "manageCase", "manageTask"), "admin")
//          user2 must_=== expected
//        }
//
//        "list users" in {
//          val resonse = await(client.query(Json.obj("_name" -> "listUser"), Json.obj("_name" -> "toList")))
//          val users   = (resonse \ "result").asOpt[Seq[OutputUser]]
//          users must beSome.updateMessage(s => s"$s\n$resonse")
//          users.get.map(TestUser.apply) must contain(exactly(adminUser, user2))
//        }
//
//        "return an authentication error if password is wrong" in {
//          val wrongAuth = PasswordAuthentication("admin@thehive.local", "nopassword")
//          val asyncResp = client.query(Json.obj("_name" -> "listUser"), Json.obj("_name" -> "toList"))(ec, wrongAuth)
//          val expected  = ApplicationError(401, Json.obj("type" -> "AuthenticationError", "message" -> "Authentication failure"))
//          await(asyncResp) must throwA(expected)
//        }
//
//        "create a custom field" in {
//          val asyncResp =
//            client.customFields.create(InputCustomField("businessUnit", "Business unit impacted by the incident", "string", Some(false)))
//          val expected = OutputCustomField("businessUnit", "Business unit impacted by the incident", "string", mandatory = false)
//          await(asyncResp) must_=== expected
//        }
//
//        "create a simple case" in {
//          val asyncResp = client.`case`.create(InputCase("First case", "This case is the first case of functional tests"))
//          case1 = TestCase(await(asyncResp))
//          val expected = TestCase(
//            title = "First case",
//            description = "This case is the first case of functional tests",
//            severity = 2,
//            startDate = case1.startDate,
//            flag = false,
//            tlp = 2,
//            pap = 2,
//            status = "Open",
//            user = Some(UserSrv.initUser.login)
//          )
//
//          case1 must_=== expected
//        }
//
//        "create a case with custom fields" in {
//          val asyncResp = client
//            .`case`
//            .create(
//              InputCase(
//                title = "Second case",
//                description = "This case contains status, summary and custom fields",
//                status = Some("resolved"),
//                summary = Some("no comment"),
//                customFieldValue = Seq(InputCustomFieldValue("businessUnit", Some("HR")))
//              )
//            )
//          val outputCase = await(asyncResp)
//          case2Id = outputCase._id
//          case2 = TestCase(outputCase)
//          val expected = TestCase(
//            title = "Second case",
//            description = "This case contains status, summary and custom fields",
//            severity = 2,
//            startDate = case2.startDate,
//            flag = false,
//            tlp = 2,
//            pap = 2,
//            status = "Open",
//            user = Some(UserSrv.initUser.login),
//            summary = Some("no comment"),
//            customFields = Set(OutputCustomFieldValue("businessUnit", "Business unit impacted by the incident", "string", Some("HR")))
//          )
//          case2 must_=== expected
//        }
//
//        "list audit" in {
////          val asyncResp = client.audit.list
////          await(asyncResp).map(StableAudit.apply) must contain(
////            exactly(
//////              StableAudit(_createdBy="system", operation="Creation", objType="ImpactStatus",     summary=Map("ImpactStatus"     → Map("Creation" → 1))),
//////              StableAudit(_createdBy="system", operation="Creation", objType="ImpactStatus",     summary=Map("ImpactStatus"     → Map("Creation" → 1))),
//////              StableAudit(_createdBy="system", operation="Creation", objType="ImpactStatus",     summary=Map("ImpactStatus"     → Map("Creation" → 1))),
//////              StableAudit(_createdBy="system", operation="Creation", objType="ResolutionStatus", summary=Map("ResolutionStatus" → Map("Creation" → 1))),
//////              StableAudit(_createdBy="system", operation="Creation", objType="ResolutionStatus", summary=Map("ResolutionStatus" → Map("Creation" → 1))),
//////              StableAudit(_createdBy="system", operation="Creation", objType="ResolutionStatus", summary=Map("ResolutionStatus" → Map("Creation" → 1))),
//////              StableAudit(_createdBy="system", operation="Creation", objType="ResolutionStatus", summary=Map("ResolutionStatus" → Map("Creation" → 1))),
//////              StableAudit(_createdBy="system", operation="Creation", objType="ResolutionStatus", summary=Map("ResolutionStatus" → Map("Creation" → 1))),
//////              StableAudit(_createdBy="system", operation="Creation", objType="Organisation",     summary=Map("Organisation"     → Map("Creation" → 1))),
////              StableAudit(_createdBy="system", operation="Creation", objType="User",             summary=Map("User"             → Map("Update"   → 1, "Creation" → 1))),
////              StableAudit(_createdBy="admin",  operation="Creation", objType="User",             summary=Map("User"             → Map("Update"   → 1, "Creation" → 1))),
////              StableAudit(_createdBy="admin",  operation="Creation", objType="Case",             summary=Map("Case"             → Map("Creation" → 1))),
////              StableAudit(_createdBy="admin",  operation="Creation", objType="CustomField",      summary=Map("CustomField"      → Map("Creation" → 1))),
////              StableAudit(_createdBy="admin",  operation="Creation", objType="Case",             summary=Map("Case"             → Map("Creation" → 1)))
////            ))
//          pending
//        }
//
//        "list cases with custom fields" in {
//          val asyncResp = client.query(
//            Json.obj("_name" -> "listCase"),
//            Json.obj(
//              "_name" -> "filter",
//              "_and" -> Json
//                .arr(Json.obj("_is" -> Json.obj("customFieldName" -> "businessUnit")), Json.obj("_is" -> Json.obj("customFieldValue" -> "HR")))
//            ),
//            Json.obj("_name" -> "toList")
//          )
//          val cases = (await(asyncResp) \ "result").as[Seq[OutputCase]].map(TestCase.apply)
//          cases must contain(exactly(case2))
//        }
//
//        "add a task to case 2" in {
//          val asyncResp = client.task.create(InputTask(case2Id, "identification"))
//          task1 = TestTask(await(asyncResp))
//          val expected = TestTask(
//            title = "identification",
//            description = None,
//            status = "Waiting",
//            flag = false,
//            startDate = None,
//            endDate = None,
//            order = 0,
//            dueDate = None
//          )
//          task1 must_=== expected
//        }
//
//        "list task for case 2" in {
//          val asyncResp =
//            client.query(Json.obj("_name" -> "getCase", "idOrName" -> case2Id), Json.obj("_name" -> "tasks"), Json.obj("_name" -> "toList"))
//          val tasks = (await(asyncResp) \ "result").as[Seq[OutputTask]].map(TestTask.apply)
//          tasks must contain(exactly(task1))
//        }
//
//        "list cases" in {
//          val asyncResp = client.query(Json.obj("_name" -> "listCase"), Json.obj("_name" -> "toList"))
//          val cases     = (await(asyncResp) \ "result").as[Seq[OutputCase]].map(TestCase.apply)
//          cases must contain(exactly(case1, case2))
//        }
//
//        "create a new organisation" in {
//          val asyncResp = client.organisation.create(InputOrganisation("test", "no description"))
//          await(asyncResp) must_=== OutputOrganisation("test", "no description")
//        }
//
//        "list organisations" in {
//          val asyncResp     = client.query(Json.obj("_name" -> "listOrganisation"), Json.obj("_name" -> "toList"))
//          val organisations = (await(asyncResp) \ "result").as[Seq[OutputOrganisation]]
//          organisations must contain(exactly(OutputOrganisation("test", "no description"), OutputOrganisation("admin", "initial organisation")))
//        }
//
//        "create a new user in the test organisation" in {
//          val asyncResp =
//            client.user.create(InputUser("testAdmin@thehive.local", "Admin user in test organisation", Some("secret"), "admin", Some("test")))
//          user3 = TestUser(await(asyncResp))
//          val expected = TestUser("testAdmin@thehive.local", "Admin user in test organisation", "admin", Permissions.all.map(_.toString), "test")
//          user3 must_== expected
//        }
//      }
//
//      {
//        implicit val auth: Authentication = PasswordAuthentication("testAdmin@thehive.local", "secret")
//
//        "list cases in test organisation" in {
//          val asyncResp = client.query(Json.obj("_name" -> "listCase"), Json.obj("_name" -> "toList"))
//          val cases     = (await(asyncResp) \ "result").as[Seq[OutputCase]]
//          cases must beEmpty
//        }
//
//        "create a case in test organisation" in {
//          val asyncResp =
//            client
//              .`case`
//              .create(InputCase("test case", "Case in test organisation", severity = Some(1), pap = Some(1), user = Some("testAdmin@thehive.local")))
//          case3 = TestCase(await(asyncResp))
//          val expected = TestCase(
//            title = "test case",
//            description = "Case in test organisation",
//            severity = 1,
//            startDate = case3.startDate,
//            flag = false,
//            tlp = 2,
//            pap = 1,
//            status = "Open",
//            user = Some("testAdmin@thehive.local")
//          )
//
//          case3 must_=== expected
//        }
//
//        "list cases in test organisation" in {
//          val asyncResp = client.query(Json.obj("_name" -> "listCase"), Json.obj("_name" -> "toList"))
//          val cases     = (await(asyncResp) \ "result").as[Seq[OutputCase]].map(TestCase.apply)
//          cases must contain(exactly(case3))
//        }
//      }
//
//      {
////        implicit val auth: Authentication = Authentication(UserSrv.initUser, UserSrv.initUserPassword)
//
//        "share a case from admin organisation to test organisation" in {
////          val asyncResp = client.share.create(InputShare(case2._id, "test"))
////          await(asyncResp) must_=== OutputShare(case2._id, "test")
//          pending
//        }
//      }
//
//      {
//        implicit val auth: Authentication = PasswordAuthentication("testAdmin@thehive.local", "secret")
//
//        "list cases in test organisation (should contain shared case)" in {
////          val asyncResp = client.query(Json.obj("_name" -> "listCase"), Json.obj("_name" -> "toList"))
////          val cases = (await(asyncResp) \ "result").as[Seq[OutputCase]].map(TestCase.apply)
////          cases must contain(exactly(case2, case3))
//          pending
//        }
//
//        "create an alert" in {
//          val asyncResp = client.alert.create(InputAlert("test", "source1", "sourceRef1", None, "new alert", "test alert"))
//          val alert     = await(asyncResp)
//          alert must_== OutputAlert(
//            _id = alert._id,
//            _createdBy = "testAdmin@thehive.local",
//            _createdAt = alert._createdAt,
//            `type` = "test",
//            source = "source1",
//            sourceRef = "sourceRef1",
//            externalLink = None,
//            title = "new alert",
//            description = "test alert",
//            severity = 2,
//            date = alert.date,
//            tags = Set.empty,
//            flag = false,
//            tlp = 2,
//            pap = 2,
//            read = false,
//            follow = true,
//            customFields = Set.empty
//          )
//        }
//      }
//
//      "stop the application and drop database" in {
//        server.stop()
//        //app.injector.instanceOf[Database].drop()
//        1 must_=== 1
//      }
//    }
//  }
//}

```

`thehive/test/org/thp/thehive/QueryTest.scala`:

```scala
package org.thp.thehive

class QueryTest {}

```

`thehive/test/org/thp/thehive/TestAppBuilder.scala`:

```scala
package org.thp.thehive

import akka.actor.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ActorRef => TypedActorRef}
import akka.actor.typed.scaladsl.adapter.ClassicActorSystemOps
import org.apache.commons.io.FileUtils
import org.thp.scalligraph.auth._
import org.thp.scalligraph.janus.JanusDatabaseProvider
import org.thp.scalligraph.models.{Database, Schema, UpdatableSchema}
import org.thp.scalligraph.query.QueryExecutor
import org.thp.scalligraph.services.{IntegrityCheck, LocalFileSystemStorageSrv, StorageSrv}
import org.thp.scalligraph.{AppBuilder, SingleInstance}
import org.thp.thehive.controllers.v0.TheHiveQueryExecutor
import org.thp.thehive.models.TheHiveSchemaDefinition
import org.thp.thehive.services.notification.notifiers.{AppendToFileProvider, EmailerProvider, NotifierProvider}
import org.thp.thehive.services.notification.triggers._
import org.thp.thehive.services.{UserSrv => _, _}

import java.io.File
import java.nio.file.{Files, Paths}
import java.util.UUID
import javax.inject.{Inject, Provider, Singleton}
import scala.util.Try

object TestAppBuilderLock

trait TestAppBuilder {

  val databaseName: String = "default"

  def appConfigure: AppBuilder =
    (new AppBuilder)
      .bind[UserSrv, LocalUserSrv]
      .bind[StorageSrv, LocalFileSystemStorageSrv]
      .bind[Schema, TheHiveSchemaDefinition]
      .bindToProvider[TypedActorRef[CaseNumberActor.Request], TestNumberActorProvider]
      .multiBind[UpdatableSchema](classOf[TheHiveSchemaDefinition])
      .bindNamed[QueryExecutor, TheHiveQueryExecutor]("v0")
      .multiBind[AuthSrvProvider](classOf[LocalPasswordAuthProvider], classOf[LocalKeyAuthProvider], classOf[HeaderAuthProvider])
      .multiBind[NotifierProvider](classOf[AppendToFileProvider])
      .multiBind[NotifierProvider](classOf[EmailerProvider])
      .multiBind[TriggerProvider](classOf[LogInMyTaskProvider])
      .multiBind[TriggerProvider](classOf[CaseCreatedProvider])
      .multiBind[TriggerProvider](classOf[TaskAssignedProvider])
      .multiBind[TriggerProvider](classOf[AlertCreatedProvider])
      .bindToProvider[AuthSrv, MultiAuthSrvProvider]
      .bindInstance[SingleInstance](new SingleInstance(true))
      .multiBind[IntegrityCheck](
        classOf[ProfileIntegrityCheck],
        classOf[OrganisationIntegrityCheck],
        classOf[TagIntegrityCheck],
        classOf[UserIntegrityCheck],
        classOf[ImpactStatusIntegrityCheck],
        classOf[ResolutionStatusIntegrityCheck],
        classOf[ObservableTypeIntegrityCheck],
        classOf[CustomFieldIntegrityCheck],
        classOf[CaseTemplateIntegrityCheck],
        classOf[DataIntegrityCheck],
        classOf[CaseIntegrityCheck],
        classOf[AlertIntegrityCheck],
        classOf[RoleIntegrityCheck]
      )
      .bindActor[DummyActor]("config-actor")
      .bindActor[DummyActor]("notification-actor")
      .bindToProvider[TypedActorRef[IntegrityCheck.Request], DummyTypedActorProvider[IntegrityCheck.Request]]
      .bindActor[DummyActor]("integrity-check-actor")
      .bindActor[DummyActor]("flow-actor")
      .addConfiguration("auth.providers = [{name:local},{name:key},{name:header, userHeader:user}]")
      .addConfiguration("play.modules.disabled = [org.thp.scalligraph.ScalligraphModule, org.thp.thehive.TheHiveModule]")
      .addConfiguration("play.mailer.mock = yes")
      .addConfiguration("play.mailer.debug = yes")
      .addConfiguration(s"storage.localfs.location = ${System.getProperty("user.dir")}/target/storage")
      .bindEagerly[ClusterSetup]

  def testApp[A](body: AppBuilder => A): A = {
    val storageDirectory = Files.createTempDirectory(Paths.get("target"), "janusgraph-test-database").toFile
    val indexDirectory   = Files.createTempDirectory(Paths.get("target"), storageDirectory.getName).toFile
    TestAppBuilderLock.synchronized {
      if (!Files.exists(Paths.get(s"target/janusgraph-test-database-$databaseName"))) {
        val app = appConfigure
          .addConfiguration(s"""
                               |db {
                               |  provider: janusgraph
                               |  janusgraph {
                               |    storage.backend: berkeleyje
                               |    storage.directory: "target/janusgraph-test-database-$databaseName"
                               |    berkeleyje.freeDisk: 2
                               |    index.search {
                               |      backend : lucene
                               |      directory: target/janusgraph-test-database-$databaseName-idx
                               |    }
                               |  }
                               |}
                               |akka.cluster.jmx.multi-mbeans-in-same-jvm: on
                               |""".stripMargin)
          .bindToProvider[Database, JanusDatabaseProvider]

        app[DatabaseBuilder].build()(app[Database])
        app[Database].close()
      }
      FileUtils.copyDirectory(new File(s"target/janusgraph-test-database-$databaseName"), storageDirectory)
      FileUtils.copyDirectory(new File(s"target/janusgraph-test-database-$databaseName-idx"), indexDirectory)
    }
    val app = appConfigure
      .bindToProvider[Database, JanusDatabaseProvider]
      .addConfiguration(s"""
                           |db {
                           |  provider: janusgraph
                           |  janusgraph {
                           |    storage.backend: berkeleyje
                           |    storage.directory: $storageDirectory
                           |    berkeleyje.freeDisk: 2
                           |    index.search {
                           |      backend : lucene
                           |      directory: $indexDirectory
                           |    }
                           |  }
                           |}
                           |""".stripMargin)

    try body(app)
    finally {
      Try(app[Database].close())
      FileUtils.deleteDirectory(storageDirectory)
      FileUtils.deleteDirectory(indexDirectory)
    }
  }
}

@Singleton
class BasicDatabaseProvider @Inject() (database: Database) extends Provider[Database] {
  override def get(): Database = database
}

class TestNumberActorProvider @Inject() (actorSystem: ActorSystem) extends Provider[TypedActorRef[CaseNumberActor.Request]] {
  override def get: TypedActorRef[CaseNumberActor.Request] =
    actorSystem
      .toTyped
      .systemActorOf(CaseNumberActor.caseNumberProvider(getNextNumber = () => 36, reloadTimer = () => (), nextNumber = 36), "case-number")
}

class DummyTypedActorProvider[T] @Inject() (actorSystem: ActorSystem) extends Provider[TypedActorRef[T]] {
  override def get(): TypedActorRef[T] =
    actorSystem
      .toTyped
      .systemActorOf(Behaviors.empty, UUID.randomUUID().toString)
}

```

`thehive/test/org/thp/thehive/controllers/v0/AlertCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import io.scalaland.chimney.dsl._
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0._
import org.thp.thehive.models.RichObservable
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseSrv
import org.thp.thehive.services.ObservableOps._
import play.api.libs.json.{JsNull, JsObject, JsString, Json}
import play.api.test.{FakeRequest, PlaySpecification}

import java.util.Date

case class TestAlert(
    `type`: String,
    source: String,
    sourceRef: String,
    title: String,
    description: String,
    severity: Int,
    date: Date,
    tags: Set[String] = Set.empty,
    tlp: Int,
    pap: Int,
    status: String,
    follow: Boolean,
    customFields: JsObject = JsObject.empty,
    caseTemplate: Option[String] = None
)

object TestAlert {

  def apply(outputAlert: OutputAlert): TestAlert =
    outputAlert.into[TestAlert].transform
}

class AlertCtrlTest extends PlaySpecification with TestAppBuilder {
  "create an alert" in testApp { app =>
    val now                = new Date()
    val outputCustomFields = Json.obj("string1" -> Json.obj("string" -> "string custom field"), "float1" -> Json.obj("float" -> 42.0))
    val inputCustomFields = Seq(
      InputCustomFieldValue("float1", Some(42), None),
      InputCustomFieldValue("string1", Some("string custom field"), None)
    )
    val inputObservables =
      Seq(
        InputObservable(dataType = "ip", data = Seq("127.0.0.1"), message = Some("localhost"), tlp = Some(1), tags = Set("here")),
        InputObservable(
          dataType = "file",
          data = Seq("hello.txt;text/plain;aGVsbG8gd29ybGQgIQ=="),
          message = Some("coucou"),
          tlp = Some(1),
          tags = Set("welcome", "message")
        )
      )
    val outputObservables = Seq(
      TestObservable(dataType = "ip", data = Some("127.0.0.1"), message = Some("localhost"), tlp = 1, tags = Set("here")),
      TestObservable(
        dataType = "file",
        attachment = Some(
          OutputAttachment(
            "hello.txt",
            Seq(
              "a4bf1f6be616bf6a0de2ff6264de43a64bb768d38c783ec2bc74b5d4dcf5f889",
              "b1fda0e52e8099d2aeb80f57bb91548cace3093f",
              "905138a85e85e74344e90d25dba7299e"
            ),
            13,
            "text/plain",
            "a4bf1f6be616bf6a0de2ff6264de43a64bb768d38c783ec2bc74b5d4dcf5f889"
          )
        ),
        message = Some("coucou"),
        tlp = 1,
        tags = Set("welcome", "message")
      )
    )
    val request = FakeRequest("POST", "/api/v0/alert")
      .withJsonBody(
        Json
          .toJson(
            InputAlert(
              `type` = "test",
              source = "alert_creation_test",
              sourceRef = "#1",
              externalLink = None,
              title = "alert title (create alert test)",
              description = "alert description (create alert test)",
              severity = Some(2),
              date = Some(now),
              tags = Set("tag1", "tag2"),
              flag = Some(false),
              tlp = Some(1),
              pap = Some(3),
              customFields = inputCustomFields
            )
          )
          .as[JsObject] +
          ("caseTemplate" -> JsString("spam")) +
          ("artifacts"    -> Json.toJson(inputObservables))
      )
      .withHeaders("user" -> "certuser@thehive.local")

    val result = app[AlertCtrl].create(request)
    status(result) should equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
    val resultAlert       = contentAsJson(result)
    val resultAlertOutput = resultAlert.as[OutputAlert]
    val expected = TestAlert(
      `type` = "test",
      source = "alert_creation_test",
      sourceRef = "#1",
      title = "alert title (create alert test)",
      description = "alert description (create alert test)",
      severity = 2,
      date = now,
      tags = Set("tag1", "tag2"),
      tlp = 1,
      pap = 3,
      status = "New",
      follow = true,
      customFields = outputCustomFields,
      caseTemplate = Some("spam")
    )

    TestAlert(resultAlertOutput) shouldEqual expected
    resultAlertOutput.artifacts.map(TestObservable.apply) should containTheSameElementsAs(outputObservables)
  }

  "get an alert" in testApp { app =>
    val request = FakeRequest("GET", "/api/v0/alert/testType;testSource;ref1")
      .withHeaders("user" -> "socuser@thehive.local")
    val result = app[AlertCtrl].get("testType;testSource;ref1")(request)
    status(result) should equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
    val resultAlert       = contentAsJson(result)
    val resultAlertOutput = resultAlert.as[OutputAlert]
    val expected = TestAlert(
      `type` = "testType",
      source = "testSource",
      sourceRef = "ref1",
      title = "alert#1",
      description = "description of alert #1",
      severity = 2,
      date = new Date(1555359572000L),
      tags = Set("alert", "test"),
      tlp = 2,
      pap = 2,
      status = "New",
      follow = true,
      customFields = Json.obj("integer1" -> Json.obj("integer" -> 42)),
      caseTemplate = Some("spam")
    )

    TestAlert(resultAlertOutput) shouldEqual expected
    resultAlertOutput
      .artifacts
      .map(o => TestObservable(o)) must contain(
      TestObservable(
        "domain",
        Some("h.fr"),
        None,
        1,
        Set("hello"),
        ioc = true,
        sighted = true,
        Some("observable from alert")
      )
    )
  }

  "update an alert" in testApp { app =>
    val request = FakeRequest("PATCH", "/api/v0/alert/testType;testSource;ref2")
      .withJsonBody(
        Json.obj(
          "tlp" -> 3
        )
      )
      .withHeaders("user" -> "certuser@thehive.local")
    val result = app[AlertCtrl].update("testType;testSource;ref2")(request)
    status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
    val resultAlert       = contentAsJson(result)
    val resultAlertOutput = resultAlert.as[OutputAlert]
    resultAlertOutput.tlp must beEqualTo(3)
  }

  "mark an alert as read/unread" in testApp { app =>
    val request1 = FakeRequest("GET", "/api/v0/alert/testType;testSource;ref3")
      .withHeaders("user" -> "certuser@thehive.local")
    val result1 = app[AlertCtrl].get("testType;testSource;ref3")(request1)
    status(result1) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result1)}")
    contentAsJson(result1).as[OutputAlert].status must beEqualTo("New")

    val request2 = FakeRequest("POST", "/api/v0/alert/testType;testSource;ref3/markAsRead")
      .withHeaders("user" -> "certuser@thehive.local")
    val result2 = app[AlertCtrl].markAsRead("testType;testSource;ref3")(request2)
    status(result2) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result2)}")

    val request3 = FakeRequest("GET", "/api/v0/alert/testType;testSource;ref3")
      .withHeaders("user" -> "certuser@thehive.local")
    val result3 = app[AlertCtrl].get("testType;testSource;ref3")(request3)
    status(result3) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result3)}")
    contentAsJson(result3).as[OutputAlert].status must beEqualTo("Ignored")

    val request4 = FakeRequest("POST", "/api/v0/alert/testType;testSource;ref3/markAsUnread")
      .withHeaders("user" -> "certuser@thehive.local")
    val result4 = app[AlertCtrl].markAsUnread("testType;testSource;ref3")(request4)
    status(result4) should equalTo(200).updateMessage(s => s"$s\n${contentAsString(result4)}")

    val request5 = FakeRequest("GET", "/api/v0/alert/testType;testSource;ref3")
      .withHeaders("user" -> "certuser@thehive.local")
    val result5 = app[AlertCtrl].get("testType;testSource;ref3")(request5)
    status(result5) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result5)}")
    contentAsJson(result5).as[OutputAlert].status must beEqualTo("New")
  }

  "follow/unfollow an alert" in testApp { app =>
    val request1 = FakeRequest("GET", "/api/v0/alert/testType;testSource;ref3")
      .withHeaders("user" -> "certuser@thehive.local")
    val result1 = app[AlertCtrl].get("testType;testSource;ref3")(request1)
    status(result1) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result1)}")
    contentAsJson(result1).as[OutputAlert].follow must beTrue

    val request2 = FakeRequest("POST", "/api/v0/alert/testType;testSource;ref3/unfollow")
      .withHeaders("user" -> "certuser@thehive.local")
    val result2 = app[AlertCtrl].unfollowAlert("testType;testSource;ref3")(request2)
    status(result2) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result2)}")

    val request3 = FakeRequest("GET", "/api/v0/alert/testType;testSource;ref3")
      .withHeaders("user" -> "certuser@thehive.local")
    val result3 = app[AlertCtrl].get("testType;testSource;ref3")(request3)
    status(result3) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result3)}")
    contentAsJson(result3).as[OutputAlert].follow must beFalse

    val request4 = FakeRequest("POST", "/api/v0/alert/testType;testSource;ref3/follow")
      .withHeaders("user" -> "certuser@thehive.local")
    val result4 = app[AlertCtrl].followAlert("testType;testSource;ref3")(request4)
    status(result4) should equalTo(200).updateMessage(s => s"$s\n${contentAsString(result4)}")

    val request5 = FakeRequest("GET", "/api/v0/alert/testType;testSource;ref3")
      .withHeaders("user" -> "certuser@thehive.local")
    val result5 = app[AlertCtrl].get("testType;testSource;ref3")(request5)
    status(result5) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result5)}")
    contentAsJson(result5).as[OutputAlert].follow must beTrue
  }

  "create a case from an alert" in testApp { app =>
    val request1 = FakeRequest("POST", "/api/v0/alert/testType;testSource;ref5/createCase")
      .withHeaders("user" -> "certuser@thehive.local")
    val result1 = app[AlertCtrl].createCase("testType;testSource;ref5")(request1)
    status(result1) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result1)}")

    val resultCase       = contentAsJson(result1)
    val resultCaseOutput = resultCase.as[OutputCase]

    val expected = TestCase(
      caseId = resultCaseOutput.caseId,
      title = "[SPAM] alert#5",
      description = "description of alert #5",
      severity = 2,
      startDate = resultCaseOutput.startDate,
      endDate = None,
      flag = false,
      tlp = 2,
      pap = 2,
      status = "Open",
      tags = Set(
        "alert",
        "test",
        "spam",
        "src:mail"
      ),
      summary = None,
      owner = Some("certuser@thehive.local"),
      customFields = Json.obj(
        "boolean1" -> Json.obj("boolean" -> JsNull, "order" -> 1),
        "string1"  -> Json.obj("string" -> "string1 custom field", "order" -> 0)
      ),
      stats = Json.obj()
    )

    TestCase(resultCaseOutput) must_=== expected
    val observables = app[Database].roTransaction { implicit graph =>
      val authContext = DummyUserSrv(organisation = "cert").authContext
      app[CaseSrv].get(EntityIdOrName(resultCaseOutput._id)).observables(authContext).richObservable.toList
    }
    observables must contain(
      exactly(
        beLike[RichObservable] {
          case obs if obs.dataType == "domain" && obs.data.contains("c.fr") => ok
        }
      )
    )
  }

  "merge an alert with a case" in testApp { app =>
    val request1 = FakeRequest("POST", "/api/v0/alert/testType;testSource;ref5/merge/#1")
      .withHeaders("user" -> "certuser@thehive.local")
    val result1 = app[AlertCtrl].mergeWithCase("testType;testSource;ref5", "1")(request1)
    status(result1) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result1)}")

    val resultCase       = contentAsJson(result1)
    val resultCaseOutput = resultCase.as[OutputCase]

    resultCaseOutput.description.contains("Merged with alert #ref5") must beTrue

    app[Database].roTransaction { implicit graph =>
      val observables = app
        .apply[CaseSrv]
        .get(EntityIdOrName("1"))
        .observables(DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").getSystemAuthContext)
        .toList

      observables.flatMap(_.message) must contain("This domain")
    }
  }

  "delete an alert" in testApp { app =>
//    app[Database].roTransaction { implicit graph =>
//      app[ObservableSrv]
//        .initSteps
//        .has("message", "if you are lost")
//        .alert
//        .getOrFail() must beSuccessfulTry
//
//      val request1 = FakeRequest("DELETE", "/api/v0/alert/testType;testSource;ref4")
//        .withHeaders("user" -> "certuser@thehive.local")
//      val result1 = app[AlertCtrl].delete("testType;testSource;ref4")(request1)
//
//      status(result1) must equalTo(204).updateMessage(s => s"$s\n${contentAsString(result1)}")
//      app[Database].roTransaction(graph =>
//        app[ObservableSrv]
//          .initSteps(graph)
//          .has("message", "if you are lost")
//          .alert
//          .getOrFail() must beFailedTry
//      )
//    }
    pending
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/AttachmentCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import akka.stream.scaladsl.Source
import akka.util.ByteString
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.services.AttachmentSrv
import play.api.test.{FakeRequest, PlaySpecification}

class AttachmentCtrlTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "admin@thehive.local").authContext
  val data: String                      = "DataFromAttachmentCtrlTest"
  "download a simple attachment from his id" in testApp { app =>
    app[Database].tryTransaction { implicit graph =>
      app[AttachmentSrv].create("test.txt", data.length.toLong, "text/plain", Source.single(ByteString(data)))
    }
    val request = FakeRequest("GET", "/api/v0/datastore/810384dd79918958607f6a6e4c90f738c278c847b408864ea7ce84ee1970bcdf")
      .withHeaders("user" -> "certuser@thehive.local")
    val result = app[AttachmentCtrl].download("810384dd79918958607f6a6e4c90f738c278c847b408864ea7ce84ee1970bcdf", None)(request)

    status(result)                        must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
    header("Content-Disposition", result) must beSome("attachment; filename=\"810384dd79918958607f6a6e4c90f738c278c847b408864ea7ce84ee1970bcdf\"")
  }

  "download a zipped attachment from his hash" in testApp { app =>
    app[Database].tryTransaction { implicit graph =>
      app[AttachmentSrv].create("test.txt", data.length.toLong, "text/plain", Source.single(ByteString(data)))
    }
    val request = FakeRequest("GET", "/api/v0/datastorezip/810384dd79918958607f6a6e4c90f738c278c847b408864ea7ce84ee1970bcdf")
      .withHeaders("user" -> "certuser@thehive.local")
    val result = app[AttachmentCtrl].downloadZip("810384dd79918958607f6a6e4c90f738c278c847b408864ea7ce84ee1970bcdf", Some("lol"))(request)

    status(result)                        must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
    header("Content-Disposition", result) must beSome("attachment; filename=\"lol.zip\"")
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/AuditCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.scalligraph.{AppBuilder, EntityIdOrName}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models.{Case, CaseStatus, Permissions}
import org.thp.thehive.services.{CaseSrv, FlowActor, OrganisationSrv}
import play.api.libs.json.JsObject
import play.api.test.{FakeRequest, PlaySpecification}

import java.util.Date

class AuditCtrlTest extends PlaySpecification with TestAppBuilder {
  override def appConfigure: AppBuilder =
    super
      .appConfigure
      .`override`(_.bindActor[FlowActor]("flow-actor"))

  val authContext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert", permissions = Permissions.all).authContext

  "return a list of audits including the last created one" in testApp { app =>
    def getFlow(caseId: String) = {
      val request = FakeRequest("GET", "/api/v0/flow")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[AuditCtrl].flow(Some(caseId))(request)
      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      contentAsJson(result).as[List[JsObject]]
    }

    // Check for no parasite audit
    getFlow("1") must beEmpty

    // Create an event first
    val `case` = app[Database].tryTransaction { implicit graph =>
      val organisation = app[OrganisationSrv].getOrFail(EntityIdOrName("admin")).get
      app[CaseSrv].create(
        `case` = Case(
          title = "case audit",
          description = "desc audit",
          severity = 1,
          startDate = new Date,
          endDate = None,
          flag = false,
          tlp = 1,
          pap = 1,
          status = CaseStatus.Open,
          summary = None,
          tags = Nil
        ),
        assignee = None,
        organisation = organisation,
        customFields = Nil,
        caseTemplate = None,
        additionalTasks = Nil
      )(graph, authContext)
    }.get

    // Get the actual data
    val l = getFlow(`case`._id.toString)

//    l must not(beEmpty)
    pending
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/AuthenticationCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.OutputUser
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class AuthenticationCtrlTest extends PlaySpecification with TestAppBuilder {
  "login and logout users" in testApp { app =>
    val request = FakeRequest("POST", "/api/v0/login")
      .withJsonBody(Json.parse("""{"user": "certuser@thehive.local", "password": "my-secret-password"}"""))
    val result = app[AuthenticationCtrl].login(request)

    status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
    contentAsJson(result).as[OutputUser].name shouldEqual "certuser"

    val requestOut = FakeRequest("GET", "/api/v0/logout")
    val resultOut  = app[AuthenticationCtrl].logout()(requestOut)

    status(resultOut) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/CaseCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import akka.stream.Materializer
import io.scalaland.chimney.dsl._
import org.thp.scalligraph.EntityIdOrName
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.CaseSrv
import play.api.libs.json._
import play.api.test.{FakeRequest, PlaySpecification}

import java.util.Date

case class TestCase(
    caseId: Int,
    title: String,
    description: String,
    severity: Int,
    startDate: Date,
    endDate: Option[Date] = None,
    tags: Set[String] = Set.empty,
    flag: Boolean,
    tlp: Int,
    pap: Int,
    status: String,
    summary: Option[String] = None,
    owner: Option[String],
    customFields: JsObject = JsObject.empty,
    stats: JsValue
)

object TestCase {
  def apply(outputCase: OutputCase): TestCase =
    outputCase.into[TestCase].transform
}

class CaseCtrlTest extends PlaySpecification with TestAppBuilder {

  "case controller" should {

    "create a new case from spam template" in testApp { app =>
      val now = new Date()

      val inputCustomFields = Seq(
        InputCustomFieldValue("date1", Some(now.getTime), None),
        InputCustomFieldValue("boolean1", Some(true), None)
//          InputCustomFieldValue("string1", Some("string custom field"))
      )

      val request = FakeRequest("POST", "/api/v0/case")
        .withJsonBody(
          Json
            .toJson(
              InputCase(
                title = "case title (create case test)",
                description = "case description (create case test)",
                severity = Some(1),
                startDate = Some(now),
                tags = Set("tag1", "tag2"),
                flag = Some(false),
                tlp = Some(1),
                pap = Some(3),
                customFields = inputCustomFields
              )
            )
            .as[JsObject] + ("template" -> JsString("spam"))
        )
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[CaseCtrl].create(request)
      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
      val resultCase       = contentAsJson(result)
      val resultCaseOutput = resultCase.as[OutputCase]
      val expected = TestCase(
        caseId = resultCaseOutput.caseId,
        title = "[SPAM] case title (create case test)",
        description = "case description (create case test)",
        severity = 1,
        startDate = now,
        endDate = None,
        flag = false,
        tlp = 1,
        pap = 3,
        status = "Open",
        tags = Set("spam", "src:mail", "tag1", "tag2"),
        summary = None,
        owner = Some("certuser@thehive.local"),
        customFields = Json.obj(
          "boolean1" -> Json.obj("boolean" -> true, "order" -> 1),
          "string1"  -> Json.obj("string" -> "string1 custom field", "order" -> 2),
          "date1"    -> Json.obj("date" -> now.getTime, "order" -> 0)
        ),
        stats = Json.obj()
      )

      TestCase(resultCaseOutput) shouldEqual expected
    }

    "create a new case from scratch" in testApp { app =>
      val request = FakeRequest("POST", "/api/v0/case")
        .withJsonBody(
          Json
            .parse(
              """{
                     "status":"Open",
                     "severity":1,
                     "tlp":2,
                     "pap":2,
                     "title":"test 6",
                     "description":"desc ok",
                     "tags":[],
                     "tasks":[
                        {
                           "title":"task x",
                           "flag":false,
                           "status":"Waiting"
                        }
                     ],
                     "user":"certro@thehive.local"
                  }"""
            )
            .as[JsObject]
        )
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[CaseCtrl].create(request)
      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
      val outputCase = contentAsJson(result).as[OutputCase]
      TestCase(outputCase) must equalTo(
        TestCase(
          caseId = outputCase.caseId,
          title = "test 6",
          description = "desc ok",
          severity = 1,
          startDate = outputCase.startDate,
          flag = false,
          tlp = 2,
          pap = 2,
          status = "Open",
          tags = Set.empty,
          owner = Some("certro@thehive.local"),
          stats = JsObject.empty
        )
      )

      val requestList = FakeRequest("GET", "/api/case/task").withHeaders("user" -> "certuser@thehive.local")
      val resultList  = app[TaskCtrl].search(requestList)

      status(resultList) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(resultList)}")
      val tasksList = contentAsJson(resultList)(defaultAwaitTimeout, app[Materializer]).as[Seq[OutputTask]]
      tasksList.find(_.title == "task x") must beSome

      val assignee = app[Database].roTransaction(implicit graph => app[CaseSrv].get(EntityIdOrName(outputCase._id)).assignee.getOrFail("Case"))

      assignee must beSuccessfulTry
      assignee.get.login shouldEqual "certro@thehive.local"
    }

    "try to get a case" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v0/case/#2")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[CaseCtrl].get("145")(request)

      status(result) shouldEqual 404

      val result2 = app[CaseCtrl].get("2")(request)
      status(result2) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result2)}")
      val resultCase       = contentAsJson(result2)
      val resultCaseOutput = resultCase.as[OutputCase]

      val expected = TestCase(
        caseId = 2,
        title = "case#2",
        description = "description of case #2",
        severity = 2,
        startDate = new Date(1531667370000L),
        endDate = None,
        flag = false,
        tlp = 2,
        pap = 2,
        status = "Open",
        tags = Set("t2", "t1"),
        summary = None,
        owner = Some("certuser@thehive.local"),
        customFields = JsObject.empty,
        stats = Json.obj()
      )

      TestCase(resultCaseOutput) must_=== expected
    }

    "update a case properly" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/v0/case/1")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(
          Json.obj(
            "title" -> "new title",
            "flag"  -> true
          )
        )
      val result = app[CaseCtrl].update("1")(request)
      status(result) must_=== 200
      val resultCase = contentAsJson(result).as[OutputCase]

      resultCase.title must equalTo("new title")
      resultCase.flag  must equalTo(true)
    }

    "update a bulk of cases properly" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/v0/case/_bulk")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(
          Json.obj(
            "ids"         -> List("1", "2"),
            "description" -> "new description",
            "tlp"         -> 1,
            "pap"         -> 1
          )
        )
      val result = app[CaseCtrl].bulkUpdate(request)
      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      val resultCases = contentAsJson(result).as[List[OutputCase]]
      resultCases must have size 2

      resultCases.map(_.description) must contain(be_==("new description")).forall
      resultCases.map(_.tlp)         must contain(be_==(1)).forall
      resultCases.map(_.pap)         must contain(be_==(1)).forall

      val requestGet1 = FakeRequest("GET", s"/api/v0/case/1")
        .withHeaders("user" -> "certuser@thehive.local")
      val resultGet1 = app[CaseCtrl].get("1")(requestGet1)
      status(resultGet1) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(resultGet1)}")
      val case1 = contentAsJson(resultGet1).as[OutputCase]

      val requestGet2 = FakeRequest("GET", s"/api/v0/case/2")
        .withHeaders("user" -> "certuser@thehive.local")
      val resultGet2 = app[CaseCtrl].get("2")(requestGet2)
      status(resultGet2) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(resultGet2)}")
      val case3 = contentAsJson(resultGet2).as[OutputCase]

      resultCases.map(TestCase.apply) must contain(exactly(TestCase(case1), TestCase(case3)))
    }

    "search cases" in testApp { app =>
      val request = FakeRequest("POST", s"/api/v0/case/_search?range=0-15&sort=-flag&sort=-startDate&nstats=true")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(
          Json.parse("""{"query":{"severity":2}}""")
        )
      val result = app[CaseCtrl].search()(request)
      status(result)            must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      header("X-Total", result) must beSome("2")
      val resultCases = contentAsJson(result)(defaultAwaitTimeout, app[Materializer]).as[Seq[OutputCase]]

      resultCases.map(_.caseId) must contain(exactly(1, 2))
    }

    "search a case by custom field" in testApp { app =>
//      // Create a case with custom fields
//      val now = new Date()
//      val inputCustomFields = Seq(
//        InputCustomFieldValue("date1", Some(now.getTime), None),
//        InputCustomFieldValue("boolean1", Some(true), None)
//      )
//
//      val request = FakeRequest("POST", "/api/v0/case")
//        .withJsonBody(
//          Json
//            .toJson(
//              InputCase(
//                title = "cf case",
//                description = "cf case description",
//                severity = Some(2),
//                startDate = Some(now),
//                tags = Set("tag1cf", "tag2cf"),
//                flag = Some(false),
//                tlp = Some(2),
//                pap = Some(2),
//                customFields = inputCustomFields
//              )
//            )
//            .as[JsObject] + ("template" -> JsString("spam"))
//        )
//        .withHeaders("user" -> "certuser@thehive.local")
//
//      val result = app[CaseCtrl].create(request)
//      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      // Search it by cf value
      val requestSearch = FakeRequest("POST", s"/api/v0/case/_search?range=0-15&sort=-flag&sort=-startDate&nstats=true")
        .withHeaders("user" -> "socuser@thehive.local")
        .withJsonBody(
          Json.parse("""{"query":{"_and":[{"_field":"customFields.boolean1","_value":true}]}}""")
        )
      val resultSearch = app[CaseCtrl].search()(requestSearch)
      status(resultSearch)                                                                     must equalTo(200).updateMessage(s => s"$s\n${contentAsString(resultSearch)}")
      contentAsJson(resultSearch)(defaultAwaitTimeout, app[Materializer]).as[List[OutputCase]] must not(beEmpty)
    }

    "get and aggregate properly case stats" in testApp { app =>
      val request = FakeRequest("POST", s"/api/v0/case/_stats")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(
          Json.parse("""{
                            "query": {},
                            "stats":[
                               {
                                  "_agg":"field",
                                  "_field":"tags",
                                  "_select":[
                                     {
                                        "_agg":"count"
                                     }
                                  ],
                                  "_size":1000
                               },
                               {
                                  "_agg":"count"
                               }
                            ]
                         }""")
        )
      val result = app[CaseCtrl].stats()(request)
      status(result) must_=== 200
      val resultCase = contentAsJson(result)

      (resultCase \ "count").asOpt[Int]        must beSome(10)
      (resultCase \ "t1" \ "count").asOpt[Int] must beSome(2)
      (resultCase \ "t2" \ "count").asOpt[Int] must beSome(1)
      (resultCase \ "t3" \ "count").asOpt[Int] must beSome(1)
    }

    "assign a case to an user" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/v0/case/4")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.obj("owner" -> "certro@thehive.local"))
      val result = app[CaseCtrl].update("1")(request)
      status(result) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      val resultCase       = contentAsJson(result)
      val resultCaseOutput = resultCase.as[OutputCase]

      resultCaseOutput.owner should beSome("certro@thehive.local")
    }

    "force delete a case" in testApp { app =>
      val tasks = app[Database].roTransaction { implicit graph =>
        val authContext = DummyUserSrv(organisation = "cert").authContext
        app[CaseSrv].get(EntityIdOrName("1")).tasks(authContext).toSeq
      }
      tasks must have size 2

      val requestDel = FakeRequest("DELETE", s"/api/v0/case/#1/force")
        .withHeaders("user" -> "certuser@thehive.local")
      val resultDel = app[CaseCtrl].delete("1")(requestDel)
      status(resultDel) must equalTo(204).updateMessage(s => s"$s\n${contentAsString(resultDel)}")

      app[Database].roTransaction { implicit graph =>
        app[CaseSrv].get(EntityIdOrName("1")).headOption must beNone
//        tasks.flatMap(task => app[TaskSrv].get(task).headOption) must beEmpty
      }
    }

    "merge two cases correctly" in testApp { app =>
      val request21 = FakeRequest("GET", s"/api/v0/case/#21")
        .withHeaders("user" -> "certuser@thehive.local")
      val case21 = app[CaseCtrl].get("21")(request21)
      status(case21) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(case21)}")
      val output21 = contentAsJson(case21).as[OutputCase]

      val request = FakeRequest("POST", "/api/v0/case/21/_merge/22")
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[CaseCtrl].merge("21", "22")(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val outputCase = contentAsJson(result).as[OutputCase]

      // Merge result
      TestCase(outputCase) must equalTo(
        TestCase(
          caseId = 36,
          title = "case#21 / case#22",
          description = "description of case #21\n\ndescription of case #22",
          severity = 3,
          startDate = output21.startDate,
          flag = true,
          tlp = 4,
          pap = 3,
          status = "Open",
          tags = Set("toMerge:pred1=\"value1\"", "toMerge:pred2=\"value2\""),
          owner = Some("certuser@thehive.local"),
          stats = JsObject.empty
        )
      )

      // Merged cases should be deleted
      val deleted21 = app[CaseCtrl].get("21")(request)
      status(deleted21) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(deleted21)}")
      val deleted22 = app[CaseCtrl].get("22")(request)
      status(deleted22) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(deleted22)}")
    }

    "merge two cases error, not same organisation" in testApp { app =>
      val request = FakeRequest("POST", "/api/v0/case/21/_merge/24")
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[CaseCtrl].merge("21", "24")(request)
      // User shouldn't be able to see others cases, resulting in 404
      status(result) must beEqualTo(400).updateMessage(s => s"$s\n${contentAsString(result)}")
    }

    "merge two cases error, not same profile" in testApp { app =>
      val request = FakeRequest("POST", "/api/v0/case/21/_merge/25")
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[CaseCtrl].merge("21", "25")(request)
      status(result)                              must beEqualTo(400).updateMessage(s => s"$s\n${contentAsString(result)}")
      (contentAsJson(result) \ "type").as[String] must beEqualTo("BadRequest")
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/CaseTemplateCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.OutputCaseTemplate
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.CaseTemplateSrv
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class CaseTemplateCtrlTest extends PlaySpecification with TestAppBuilder {
// TODO what to do with unused test ?

//  val dummyUserSrv = DummyUserSrv(userId = "admin@thehive.local", permissions = Permissions.all)

//    def getAndTestCaseTemplate(name: String, description: String)(body: OutputCaseTemplate => MatchResult[Any]) = {
//      val json = s"""{
//            "name":"$name",
//            "titlePrefix":"test",
//            "severity":1,
//            "tlp":2,
//            "pap":2,
//            "tags":[
//               "tg${Random.nextInt}",
//               "tg${Random.nextInt}"
//            ],
//            "tasks":[
//               {
//                  "order":0,
//                  "title":"task template ${Random.nextInt}",
//                  "group":"default",
//                  "description":"Alios autem dicere aiunt multo etiam inhumanius (quem locum breviter paulo ante perstrinxi) praesidii adiumentique causa, non benevolentiae neque caritatis..."
//                }
//            ],
//            "customFields":{},
//            "description":"$description"
//          }""".stripMargin
//      val request = FakeRequest("POST", "/api/case/template")
//        .withHeaders("user" -> "certadmin@thehive.local")
//        .withJsonBody(
//          Json.parse(json)
//        )
//      val result = caseTemplateCtrl.create(request)
//
//      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
//
//      body(contentAsJson(result).as[OutputCaseTemplate])
//    }

  s"case template controller" should {
    "create a template" in testApp { app =>
      val json = Json.parse(
        """{
                    "name":"test case template",
                    "titlePrefix":"test",
                    "severity":1,
                    "tlp":2,
                    "pap":2,
                    "tags":[
                       "tg1",
                       "tg2"
                    ],
                    "tasks":[
                       {
                          "order":0,
                          "title":"task template 1",
                          "group":"default",
                          "description":"Alios autem dicere aiunt multo etiam inhumanius (quem locum breviter paulo ante perstrinxi) praesidii adiumentique causa, non benevolentiae neque caritatis..."
                        }
                    ],
                    "customFields":{},
                    "description":"test case template"
                  }"""
      )
      val request = FakeRequest("POST", "/api/case/template")
        .withHeaders("user" -> "certadmin@thehive.local")
        .withJsonBody(json)
      val result = app[CaseTemplateCtrl].create(request)

      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val output = contentAsJson(result).as[OutputCaseTemplate]
      output.tags.size shouldEqual 2
      output.name shouldEqual "test case template"
      output.tlp must beSome(2)
      output.pap must beSome(2)
      output.severity must beSome(1)
      output.tasks must not(beEmpty)
      output.tasks.head.title must beEqualTo("task template 1")
    }

    "get a template" in testApp { app =>
      val request = FakeRequest("GET", "/api/case/template/spam")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[CaseTemplateCtrl].get("spam")(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
    }

    "delete a template" in testApp { app =>
      val request = FakeRequest("DELETE", "/api/case/template/spam")
        .withHeaders("user" -> "certadmin@thehive.local")
      val result = app[CaseTemplateCtrl].delete("spam")(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")

      app[Database].roTransaction { implicit graph =>
        app[CaseTemplateSrv].get(EntityName("spam")).headOption must beNone
      }
    }

    "update a template" in testApp { app =>
      val request = FakeRequest("PATCH", "/api/case/template/spam")
        .withHeaders("user" -> "certadmin@thehive.local")
        .withJsonBody(
          Json.parse(s"""{
            "displayName": "patched",
            "titlePrefix":"test patched",
            "severity":2,
            "tlp":3,
            "pap":3,
            "tags":[
               "tg1",
               "spam",
               "src:mail"
            ],
            "customFields":{},
            "tasks": [{"title": "analysis"}],
            "description":"patched"
          }""")
        )
      val result = app[CaseTemplateCtrl].update("spam")(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      contentAsJson(result).as[OutputCaseTemplate].displayName must beEqualTo("patched")

      val updatedOutput = app[Database].roTransaction { implicit graph =>
        app[CaseTemplateSrv].get(EntityName("spam")).richCaseTemplate.head
      }

      updatedOutput.displayName shouldEqual "patched"
      updatedOutput.tags.size shouldEqual 3
      updatedOutput.name shouldEqual "spam"
      updatedOutput.tlp must beSome(3)
      updatedOutput.pap must beSome(3)
      updatedOutput.severity must beSome(2)
      updatedOutput.tasks must not(beEmpty)
      updatedOutput.tasks.head.title must beEqualTo("analysis")
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/ConfigCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.thehive.TestAppBuilder
import org.thp.thehive.services.TagSrv
import play.api.libs.json.{JsObject, Json}
import play.api.test.{FakeRequest, PlaySpecification}

class ConfigCtrlTest extends PlaySpecification with TestAppBuilder {

// TODO leave unused code ?
//
//    def getList = {
//      val request = FakeRequest("GET", "/api/config")
//        .withHeaders("user" -> "admin@thehive.local")
//      val result = configCtrl.list(request)
//
//      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
//
//      contentAsJson(result).as[List[JsObject]]
//    }

  s"config controller" should {
    "list configuration items" in testApp { app =>
      val request = FakeRequest("GET", "/api/config")
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[ConfigCtrl].list(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")

      contentAsJson(result).as[List[JsObject]] must not(beEmpty)
    }

    "set configuration item" in testApp { app =>
      app[TagSrv]
      val request = FakeRequest("PUT", "/api/config/tags.freeTagColour")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""{"value": "#00FF00"}"""))
      val result = app[ConfigCtrl].set("tags.freeTagColour")(request)

      status(result) must equalTo(204).updateMessage(s => s"$s\n${contentAsString(result)}")

      app[TagSrv].freeTagColour must beEqualTo("#00FF00")
    }
// TODO leave unused tests ?
//
//      "get user specific configuration" in testApp { app =>
//        val request = FakeRequest("GET", "/api/config/user/organisation")
//          .withHeaders("user" -> "admin@thehive.local")
//        val result = app[ConfigCtrl].userGet("organisation")(request)
//
//        status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
//        (contentAsJson(result).as[JsObject] \ "value").as[String] shouldEqual "admin"
//      }
//
//      "set user specific configuration" in {
//        val request = FakeRequest("PUT", "/api/config/user/organisation")
//          .withHeaders("user" -> "admin@thehive.local")
//          .withJsonBody(Json.parse("""{"value": "default"}"""))
//        val result = app[ConfigCtrl].userSet("organisation")(request)
//
//        status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
//        (contentAsJson(result).as[JsObject] \ "value").as[String] shouldEqual "default"
//      }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/CustomFieldCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.OutputCustomField
import org.thp.thehive.models._
import org.thp.thehive.services.CustomFieldSrv
import play.api.libs.json.{JsNumber, JsString, Json}
import play.api.test.{FakeRequest, PlaySpecification}

class CustomFieldCtrlTest extends PlaySpecification with TestAppBuilder {
  "custom field controller" should {
    "create a string custom field with options" in testApp { app =>
      val request = FakeRequest("POST", s"/api/customField")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""
              {

                      "name": "test",
                      "reference": "test",
                      "description": "test cf",
                      "type": "string",
                      "options": ["h", "m", "l"]

              }
            """.stripMargin))
      val result = app[CustomFieldCtrl].create(request)

      status(result) shouldEqual 201

      val outputCustomField: OutputCustomField = contentAsJson(result).as[OutputCustomField]

      outputCustomField.reference shouldEqual "test"
      outputCustomField.name shouldEqual "test"
      outputCustomField.description shouldEqual "test cf"
      outputCustomField.`type` shouldEqual "string"
      outputCustomField.options must containAllOf(Seq(JsString("h"), JsString("m"), JsString("l")))
      outputCustomField.mandatory shouldEqual false
    }

    "create a boolean custom field" in testApp { app =>
      val request = FakeRequest("POST", s"/api/customField")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""
              {

                      "name": "test bool",
                      "reference": "test-bool",
                      "description": "test cf bool",
                      "type": "boolean",
                      "mandatory": true

              }
            """.stripMargin))
      val result = app[CustomFieldCtrl].create(request)

      status(result) shouldEqual 201

      val outputCustomField: OutputCustomField = contentAsJson(result).as[OutputCustomField]

      outputCustomField.reference shouldEqual "test-bool"
      outputCustomField.name shouldEqual "test bool"
      outputCustomField.description shouldEqual "test cf bool"
      outputCustomField.`type` shouldEqual "boolean"
      outputCustomField.mandatory must beTrue
    }

    "create an integer custom field with options" in testApp { app =>
      val request = FakeRequest("POST", s"/api/customField")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""
              {

                      "name": "test int",
                      "reference": "test int",
                      "description": "test cf int",
                      "type": "integer",
                      "options": [1, 2, 3]

              }
            """.stripMargin))
      val result = app[CustomFieldCtrl].create(request)

      status(result) shouldEqual 201

      val outputCustomField: OutputCustomField = contentAsJson(result).as[OutputCustomField]

      outputCustomField.reference shouldEqual "test int"
      outputCustomField.name shouldEqual "test int"
      outputCustomField.description shouldEqual "test cf int"
      outputCustomField.`type` shouldEqual "integer"
      outputCustomField.options must containAllOf(Seq(JsNumber(1), JsNumber(2), JsNumber(3)))
      outputCustomField.mandatory must beFalse
    }

    "create a float custom field" in testApp { app =>
      val request = FakeRequest("POST", s"/api/customField")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""
              {

                      "name": "test float",
                      "reference": "test float",
                      "description": "test cf float",
                      "type": "float"

              }
            """.stripMargin))
      val result = app[CustomFieldCtrl].create(request)

      status(result) shouldEqual 201

      val outputCustomField: OutputCustomField = contentAsJson(result).as[OutputCustomField]

      outputCustomField.reference shouldEqual "test float"
      outputCustomField.name shouldEqual "test float"
      outputCustomField.description shouldEqual "test cf float"
      outputCustomField.`type` shouldEqual "float"
    }

    "create a date custom field with options and list all available" in testApp { app =>
      val request = FakeRequest("POST", s"/api/customField")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""
              {

                      "name": "test date",
                      "reference": "test date",
                      "description": "test cf date",
                      "type": "date",
                      "mandatory": false
              }
            """.stripMargin))
      val result = app[CustomFieldCtrl].create(request)

      status(result) shouldEqual 201

      val outputCustomField: OutputCustomField = contentAsJson(result).as[OutputCustomField]

      outputCustomField.reference shouldEqual "test date"
      outputCustomField.name shouldEqual "test date"
      outputCustomField.description shouldEqual "test cf date"
      outputCustomField.`type` shouldEqual "date"
      outputCustomField.mandatory must beFalse

      val requestList = FakeRequest("GET", s"/api/customField")
        .withHeaders("user" -> "admin@thehive.local")
      val res = app[CustomFieldCtrl].list(requestList)

      status(res) shouldEqual 200

      contentAsJson(res).as[List[OutputCustomField]] must not(beEmpty)
    }

    "remove a custom field" in testApp { app =>
      val l = app[Database].roTransaction(graph => app[CustomFieldSrv].startTraversal(graph).toSeq)

      l must not(beEmpty)

      val cf = l.head

      val request = FakeRequest("DELETE", s"/api/customField/${cf._id}")
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[CustomFieldCtrl].delete(cf._id.toString)(request)

      status(result) shouldEqual 204

      val newList = app[Database].roTransaction(graph => app[CustomFieldSrv].startTraversal(graph).toSeq)

      newList.find(_._id == cf._id) must beNone
    }

    "update a string custom field" in testApp { app =>
      val l = app[Database].roTransaction(graph => app[CustomFieldSrv].startTraversal(graph).toSeq)

      l must not(beEmpty)

      val cf = l.find(_.`type` == CustomFieldType.string)

      cf must beSome

      val request = FakeRequest("PATCH", s"/api/customField")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""
              {

                      "options": ["fear", "laughing"],
                      "description": "test cf updated",
                      "mandatory": true,
                      "reference": "las vegas"

              }
            """.stripMargin))
      val result = app[CustomFieldCtrl].update(cf.get._id.toString)(request)

      status(result) shouldEqual 200

      val outputCustomField: OutputCustomField = contentAsJson(result).as[OutputCustomField]

      outputCustomField.reference shouldEqual cf.get.name
      outputCustomField.name shouldEqual cf.get.name
      outputCustomField.description shouldEqual "test cf updated"
      outputCustomField.`type` shouldEqual "string"
      outputCustomField.mandatory must beTrue
      outputCustomField.options must containAllOf(Seq(JsString("fear"), JsString("laughing")))
    }

    "update a date custom field" in testApp { app =>
      val l = app[Database].roTransaction(graph => app[CustomFieldSrv].startTraversal(graph).toSeq)

      l must not(beEmpty)

      val cf = l.find(_.`type` == CustomFieldType.date)

      cf must beSome

      val request = FakeRequest("PATCH", s"/api/customField")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""
              {

                      "description": "test date cf updated"

              }
            """.stripMargin))
      val result = app[CustomFieldCtrl].update(cf.get._id.toString)(request)

      status(result) shouldEqual 200

      val outputCustomField: OutputCustomField = contentAsJson(result).as[OutputCustomField]

      outputCustomField.description shouldEqual "test date cf updated"
      outputCustomField.`type` shouldEqual "date"
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/DashboardCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.OutputDashboard
import org.thp.thehive.services.DashboardSrv
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class DashboardCtrlTest extends PlaySpecification with TestAppBuilder {
  "dashboard controller" should {

    "create a dashboard" in testApp { app =>
      val request = FakeRequest("POST", "/api/dashboard")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse("""{"title": "title test 1", "description": "desc test 1", "status": "Private", "definition": "{\"items\":[]}"}"""))
      val result = app[DashboardCtrl].create(request)

      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val dashboard = contentAsJson(result).as[OutputDashboard]

      dashboard.title shouldEqual "title test 1"
      dashboard.description shouldEqual "desc test 1"
      dashboard.status shouldEqual "Private" pendingUntilFixed "Dashboards rights management ongoing"
      dashboard.definition shouldEqual "{\"items\":[]}"
    }

    "get a dashboard if visible" in testApp { app =>
      val dashboard = app[Database].roTransaction { implicit graph =>
        app[DashboardSrv].startTraversal.has(_.title, "dashboard cert").getOrFail("Dashboard").get
      }

      val request = FakeRequest("GET", s"/api/dashboard/${dashboard._id}")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[DashboardCtrl].get(dashboard._id.toString)(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")

      val requestFailed = FakeRequest("GET", s"/api/dashboard/${dashboard._id}")
        .withHeaders("user" -> "socuser@thehive.local")
      val resultFailed = app[DashboardCtrl].get(dashboard._id.toString)(requestFailed)

      status(resultFailed) must equalTo(404).updateMessage(s => s"$s\n${contentAsString(resultFailed)}")
    }

    "update a dashboard" in testApp { app =>
      val dashboard = app[Database].roTransaction { implicit graph =>
        app[DashboardSrv].startTraversal.has(_.title, "dashboard cert").getOrFail("Dashboard").get
      }

      val request = FakeRequest("PATCH", s"/api/dashboard/${dashboard._id}")
        .withHeaders("user" -> "certadmin@thehive.local")
        .withJsonBody(Json.parse("""{"title": "updated", "description": "updated", "status": "Private", "definition": "{}"}"""))
      val result = app[DashboardCtrl].update(dashboard._id.toString)(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")

      val updatedDashboard = contentAsJson(result).as[OutputDashboard]

      updatedDashboard.title shouldEqual "updated"
      updatedDashboard.description shouldEqual "updated"
      updatedDashboard.status shouldEqual "Private"
      updatedDashboard.definition shouldEqual "{}"
    }

    "delete a dashboard" in testApp { app =>
      val dashboard = app[Database].roTransaction { implicit graph =>
        app[DashboardSrv].startTraversal.has(_.title, "dashboard cert").getOrFail("Dashboard").get
      }

      val request = FakeRequest("DELETE", s"/api/dashboard/${dashboard._id}")
        .withHeaders("user" -> "certadmin@thehive.local")
      val result = app[DashboardCtrl].delete(dashboard._id.toString)(request)

      status(result) must equalTo(204).updateMessage(s => s"$s\n${contentAsString(result)}")

      app[Database].roTransaction { implicit graph =>
        app[DashboardSrv].startTraversal.has(_.title, "dashboard cert").exists must beFalse
      }
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/DescribeCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.specs2.matcher.MatchResult
import org.thp.thehive.TestAppBuilder
import play.api.libs.json.{JsObject, Reads}
import play.api.test.{FakeRequest, PlaySpecification}

class DescribeCtrlTest extends PlaySpecification with TestAppBuilder {

  def checkValues[T](l: List[JsObject], attribute: String, values: List[T])(implicit r: Reads[List[T]]): MatchResult[Option[JsObject]] =
    l.find(o => (o \ "name").as[String] == attribute) must beSome.which(
      is => (is \ "values").as[List[T]] must containAllOf(values)
    )

  "describe controller" should {

    "describe a model by its name if existing" in testApp { app =>
      val request = FakeRequest("GET", s"/api/dashboard/case")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[DescribeCtrl].describe("case")(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")

      val jsonResult = contentAsJson(result).as[JsObject]
      val attributes = (jsonResult \ "attributes").as[List[JsObject]]

      attributes must not(beEmpty)
      (jsonResult \ "label").as[String] shouldEqual "case"
      (jsonResult \ "path").as[String] shouldEqual "/case"
      (jsonResult \ "attributes" \\ "name").map(_.as[String]).toList must contain("customFields.string1")
      checkValues[String](attributes, "impactStatus", List("NoImpact", "WithImpact", "NotApplicable"))
      checkValues[String](attributes, "status", List("Open", "Resolved", "Deleted", "Duplicated"))
      checkValues[String](attributes, "resolutionStatus", List("FalsePositive", "Duplicated", "Indeterminate", "TruePositive", "Other"))
      checkValues[Int](attributes, "pap", List(0, 1, 2, 3))
      checkValues[Int](attributes, "tlp", List(0, 1, 2, 3))

      val requestGet = FakeRequest("GET", s"/api/describe/yolo")
        .withHeaders("user" -> "certuser@thehive.local")
      val resultGet = app[DescribeCtrl].describe("yolo")(requestGet)

      status(resultGet) must equalTo(404).updateMessage(s => s"$s\n${contentAsString(resultGet)}")
    }

    "describe all available models" in testApp { app =>
      val request = FakeRequest("GET", s"/api/describe/_all")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[DescribeCtrl].describeAll(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      contentAsJson(result).as[JsObject].keys must not(beEmpty)
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/LogCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.{LogSrv, TaskSrv}
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class LogCtrlTest extends PlaySpecification with TestAppBuilder {

  "log controller" should {

    "be able to create a log" in testApp { app =>
      val task = app[Database].roTransaction { implicit graph =>
        app[TaskSrv].startTraversal.has(_.title, "case 1 task 1").getOrFail("Task").get
      }

      val request = FakeRequest("POST", s"/api/case/task/${task._id}/log")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse("""
              {"message":"log 1\n\n### yeahyeahyeahs", "deleted":false}
            """.stripMargin))
      val result = app[LogCtrl].create(task._id.toString)(request)

      status(result) shouldEqual 201

      app[Database].roTransaction { implicit graph =>
        app[TaskSrv].get(task).logs.has(_.message, "log 1\n\n### yeahyeahyeahs").exists
      } must beTrue
    }

    "be able to create and remove a log" in testApp { app =>
      val log = app[Database].roTransaction { implicit graph =>
        app[LogSrv].startTraversal.has(_.message, "log for action test").getOrFail("Log").get
      }

      val requestDelete = FakeRequest("DELETE", s"/api/case/task/log/${log._id}").withHeaders("user" -> "certuser@thehive.local")
      val resultDelete  = app[LogCtrl].delete(log._id.toString)(requestDelete)

      status(resultDelete) shouldEqual 204

      val deletedLog = app[Database].roTransaction { implicit graph =>
        app[LogSrv].startTraversal.has(_.message, "log for action test").headOption
      }
      deletedLog should beNone
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/ObservableCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import akka.stream.Materializer
import io.scalaland.chimney.dsl._
import org.thp.scalligraph.AppBuilder
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.utils.Hasher
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.{OutputAttachment, OutputCase, OutputObservable}
import org.thp.thehive.models._
import org.thp.thehive.services.DataOps._
import org.thp.thehive.services.DataSrv
import play.api.Configuration
import play.api.libs.Files
import play.api.libs.Files.TemporaryFileCreator
import play.api.libs.json.Json
import play.api.mvc.MultipartFormData.FilePart
import play.api.mvc.{AnyContentAsMultipartFormData, Headers, MultipartFormData}
import play.api.test.{FakeRequest, NoTemporaryFileCreator, PlaySpecification}

import java.io.File
import java.nio.file.{Path, Files => JFiles}
import java.util.UUID

case class TestObservable(
    dataType: String,
    data: Option[String] = None,
    attachment: Option[OutputAttachment] = None,
    tlp: Int = 2,
    tags: Set[String] = Set.empty,
    ioc: Boolean = false,
    sighted: Boolean = false,
    message: Option[String] = None
)

object TestObservable {

  def apply(outputObservable: OutputObservable): TestObservable =
    outputObservable.into[TestObservable].transform
}

class ObservableCtrlTest extends PlaySpecification with TestAppBuilder {
  "observable controller" should {

    "be able to create an observable with string data" in testApp { app =>
      val request = FakeRequest("POST", s"/api/case/1/artifact")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse("""
              {
                "dataType":"autonomous-system",
                "ioc":false,
                "sighted":false,
                "tlp":2,
                "message":"love exciting and new",
                "tags":["tagfile"],
                "data":["multi","line","test"]
              }
            """.stripMargin))
      val result = app[ObservableCtrl].createInCase("1")(request)

      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
      val createdObservables = contentAsJson(result).as[Seq[OutputObservable]]

      createdObservables must have size 3
      createdObservables.map(_.dataType) must contain(be_==("autonomous-system")).forall
      createdObservables.flatMap(_.data) must contain(exactly("multi", "line", "test"))
      createdObservables.map(_.sighted) must contain(beFalse).forall
      createdObservables.map(_.message) must contain(beSome("love exciting and new")).forall
      createdObservables.map(_.tags) must contain(be_==(Set("tagfile"))).forall
    }

    "be able to create and search 2 observables with data array" in testApp { app =>
      val request = FakeRequest("POST", s"/api/case/1/artifact")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse("""
              {
                "dataType":"autonomous-system",
                "ioc":false,
                "sighted":false,
                "tlp":2,
                "message":"love exciting and new",
                "tags":["tagfile", "lol"],
                "data":["observable", "in", "array"]
              }
            """.stripMargin))
      val result = app[ObservableCtrl].createInCase("1")(request)

      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val createdObservables = contentAsJson(result).as[Seq[OutputObservable]]

      createdObservables must have size 3
      createdObservables.map(_.dataType) must contain(be_==("autonomous-system")).forall
      createdObservables.flatMap(_.data) must contain(exactly("observable", "in", "array"))
      createdObservables.map(_.sighted) must contain(beFalse).forall
      createdObservables.map(_.message) must contain(beSome("love exciting and new")).forall
      createdObservables.map(_.tags) must contain(be_==(Set("lol", "tagfile"))).forall

      val requestCase =
        FakeRequest("GET", s"/api/v0/case/1").withHeaders("user" -> "certuser@thehive.local")
      val resultCaseGet = app[CaseCtrl].get("1")(requestCase)

      status(resultCaseGet) shouldEqual 200

      val resultCase = contentAsJson(resultCaseGet).as[OutputCase]
      val requestSearch = FakeRequest("POST", s"/api/case/artifact/_search?range=all&sort=-startDate&nstats=true")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse(s"""
              {
                "query":{
                   "_and":[
                      {
                         "_and":[
                            {
                               "_parent":{
                                  "_type":"case",
                                  "_query":{
                                     "_id":"${resultCase._id}"
                                  }
                               }
                            },
                            {
                               "status":"Ok"
                            }
                         ]
                      }
                   ]
                }
             }
            """.stripMargin))
      val resultSearch = app[ObservableCtrl].search(requestSearch)

      status(resultSearch) should equalTo(200).updateMessage(s => s"$s\n${contentAsString(resultSearch)}")

      val resSearchObservables = contentAsJson(resultSearch)(defaultAwaitTimeout, app[Materializer]).as[Seq[OutputObservable]]

      resSearchObservables must have size 4
      resSearchObservables.flatMap(_.data) must contain(exactly("observable", "in", "array", "h.fr"))
    }

    "be able to create and get 2 observables with string data" in testApp { app =>
      WithFakeTemporaryFile { tempFile =>
        val files     = Seq(FilePart("attachment", "myfile.txt", Some("text/plain"), tempFile))
        val dataParts = Map("_json" -> Seq("""
              {
                "dataType":"ip",
                "ioc":false,
                "sighted":false,
                "tlp":2,
                "message":"localhost",
                "tags":["local", "host"],
                "data":["127.0.0.1","127.0.0.2"]
              }
            """))
        val request = FakeRequest(
          "POST",
          s"/api/case/#1/artifact",
          Headers("user" -> "certuser@thehive.local"),
          body = AnyContentAsMultipartFormData(MultipartFormData(dataParts, files, Nil))
        )
        val result = app[ObservableCtrl].createInCase("1")(request)
        status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
        val createdObservables = contentAsJson(result).as[Seq[OutputObservable]]

        createdObservables must have size 2
        createdObservables.map(_.dataType) must contain(be_==("ip")).forall
        createdObservables.flatMap(_.data) must contain(exactly("127.0.0.1", "127.0.0.2"))
        createdObservables.map(_.sighted) must contain(beFalse).forall
        createdObservables.map(_.message) must contain(beSome("localhost")).forall
        createdObservables.map(_.tags) must contain(be_==(Set("local", "host"))).forall
        val attachmentOption = createdObservables.flatMap(_.attachment).headOption
        attachmentOption must beNone
      }
    }

    "be able to create and get 2 observables with string data and attachment" in testApp { app =>
      WithFakeTemporaryFile { tempFile =>
        val hasher      = Hasher(app.apply[Configuration].get[Seq[String]]("attachment.hash"): _*)
        val hashes      = hasher.fromPath(tempFile.path).map(_.toString)
        val helloHashes = hasher.fromString("Hello world").map(_.toString)
        val files       = Seq(FilePart("attachment", "myfile.txt", Some("text/plain"), tempFile))
        val dataParts   = Map("_json" -> Seq("""
              {
                "dataType":"file",
                "ioc":false,
                "sighted":false,
                "tlp":2,
                "message":"localhost",
                "tags":["local", "host"],
                "data":["hello.txt;text/plain;SGVsbG8gd29ybGQ="]
              }
            """))
        val request = FakeRequest(
          "POST",
          s"/api/alert/testType;testSource;ref2/artifact",
          Headers("user" -> "certuser@thehive.local"),
          body = AnyContentAsMultipartFormData(MultipartFormData(dataParts, files, Nil))
        )
        val result = app[ObservableCtrl].createInAlert("testType;testSource;ref2")(request)
        status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
        val createdObservables = contentAsJson(result).as[Seq[OutputObservable]]

        createdObservables must have size 2
        createdObservables.map(_.dataType) must contain(be_==("file")).forall
        createdObservables.flatMap(_.data) must beEmpty
        createdObservables.map(_.sighted) must contain(beFalse).forall
        createdObservables.map(_.message) must contain(beSome("localhost")).forall
        createdObservables.map(_.tags) must contain(be_==(Set("local", "host"))).forall
        val attachments = createdObservables.flatMap(_.attachment)
        attachments must have size 2
        attachments must contain(beLike[OutputAttachment] {
          case attachment =>
            attachment.name must beEqualTo("myfile.txt")
            attachment.hashes must containTheSameElementsAs(hashes)
            attachment.size must beEqualTo(tempFile.length())
            attachment.contentType must beEqualTo("text/plain")
        })
        attachments must contain(beLike[OutputAttachment] {
          case attachment =>
            attachment.name must beEqualTo("hello.txt")
            attachment.hashes must containTheSameElementsAs(helloHashes)
            attachment.size must beEqualTo(11)
            attachment.contentType must beEqualTo("text/plain")
        })
        createdObservables.foreach(obs => obs must equalTo(getObservable(obs._id, app[ObservableCtrl])))
        ok
      }
    }

    "be able to update and bulk update observables" in testApp { app =>
      val resObservable = createDummyObservable(app[ObservableCtrl])
      val requestUp = FakeRequest("PATCH", s"/api/case/artifact/_bulk")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse(s"""
              {
                "ids":${Json.toJson(resObservable.map(_._id))},
                "ioc":true,
                "sighted":true,
                "tlp":1,
                "message":"love exciting and new edited",
                "tags":["tagfileUp"]
              }
            """))
      val resultUp = app[ObservableCtrl].bulkUpdate(requestUp)

      status(resultUp) must equalTo(204).updateMessage(s => s"$s\n${contentAsString(resultUp)}")

      val resObsUpdated = resObservable.map(obs => getObservable(obs._id, app[ObservableCtrl]))

      resObsUpdated.map(_.tags) must contain(be_==(Set("tagfileUp"))).forall
      resObsUpdated.map(_.message) must contain(beSome("love exciting and new edited")).forall
      resObsUpdated.map(_.ioc) must contain(beTrue).forall
      resObsUpdated.map(_.sighted) must contain(beTrue).forall
    }

    "create 2 observables with the same data" in testApp { app =>
      val request1 = FakeRequest("POST", s"/api/case/1/artifact")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse("""
              {
                "dataType":"hostname",
                "message":"here",
                "data":"localhost"
              }
            """))
      val result1 = app[ObservableCtrl].createInCase("1")(request1)
      status(result1) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result1)}")

      getData("localhost", app) must have size 1

      val request2 = FakeRequest("POST", s"/api/case/2/artifact")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse("""
              {
                "dataType":"domain",
                "message":"good place",
                "data":"localhost"
              }
            """))
      val result2 = app[ObservableCtrl].createInCase("2")(request2)
      status(result2) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result2)}")

      getData("localhost", app) must have size 1
    }

    "delete an observable" in testApp { app =>
      val resObservable = createDummyObservable(app[ObservableCtrl])
      val observableId  = resObservable.head._id
      val requestDelete = FakeRequest("DELETE", s"/api/case/artifact/$observableId")
        .withHeaders("user" -> "certuser@thehive.local")
      val resultDelete = app[ObservableCtrl].delete(observableId)(requestDelete)

      status(resultDelete) shouldEqual 204
    }
  }

  def getObservable(id: String, observableCtrl: ObservableCtrl): OutputObservable = {
    val requestGet = FakeRequest("GET", s"/api/case/artifact/$id")
      .withHeaders("user" -> "certuser@thehive.local")
    val resultGet = observableCtrl.get(id)(requestGet)

    status(resultGet) shouldEqual 200
    contentAsJson(resultGet).as[OutputObservable]
  }

  def createDummyObservable(observableCtrl: ObservableCtrl): Seq[OutputObservable] = {
    val request = FakeRequest("POST", s"/api/case/1/artifact")
      .withHeaders("user" -> "certuser@thehive.local")
      .withJsonBody(Json.parse(s"""
              {
                "dataType":"autonomous-system",
                "ioc":false,
                "sighted":false,
                "tlp":2,
                "message":"love exciting and new",
                "tags":["tagfile"],
                "data":"${UUID.randomUUID()}\\n${UUID.randomUUID()}"
              }
            """))
    val result = observableCtrl.createInCase("1")(request)

    status(result) shouldEqual 201
    contentAsJson(result).as[Seq[OutputObservable]]
  }

  def getData(data: String, app: AppBuilder): List[Data with Entity] = {
    val dataSrv: DataSrv = app.apply[DataSrv]
    val db: Database     = app.apply[Database]
    db.roTransaction { implicit graph =>
      dataSrv.startTraversal.getByData(data).toList
    }
  }
}

object WithFakeTemporaryFile {

  def apply[A](body: Files.TemporaryFile => A): A = {
    val tempFile = JFiles.createTempFile("thehive-", "-test")
    JFiles.write(tempFile, s"hello ${UUID.randomUUID()}".getBytes)
    val fakeTempFile = new Files.TemporaryFile {
      override def path: Path                                 = tempFile
      override def file: File                                 = tempFile.toFile
      override def temporaryFileCreator: TemporaryFileCreator = NoTemporaryFileCreator
    }
    try body(fakeTempFile)
    finally {
      JFiles.deleteIfExists(tempFile)
      ()
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/OrganisationCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.{InputOrganisation, OutputOrganisation}
import org.thp.thehive.services.OrganisationSrv
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class OrganisationCtrlTest extends PlaySpecification with TestAppBuilder {
  "organisation controller" should {
    "create a new organisation and bulk link several" in testApp { app =>
      val request = FakeRequest("POST", "/api/v0/organisation")
        .withJsonBody(Json.toJson(InputOrganisation("orga1", "no description")))
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[OrganisationCtrl].create(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
      contentAsJson(result).as[OutputOrganisation].name must_=== "orga1"

      val requestBulkLink = FakeRequest("PUT", s"/api/organisation/cert/links")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""{"organisations":["orga1"]}"""))
      val resultBulkLink = app[OrganisationCtrl].bulkLink("cert")(requestBulkLink)
      status(resultBulkLink) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(resultBulkLink)}")

      val requestLinks = FakeRequest("GET", s"/api/organisation/cert/links")
        .withHeaders("user" -> "admin@thehive.local")
      val resultLinks = app[OrganisationCtrl].listLinks("cert")(requestLinks)
      status(resultLinks) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(resultLinks)}")
      contentAsJson(resultLinks).as[List[OutputOrganisation]].map(_.name) must contain("orga1")
    }

    "refuse to create an organisation if the permission doesn't contain ManageOrganisation right" in testApp { app =>
      val request = FakeRequest("POST", "/api/v0/organisation")
        .withJsonBody(Json.toJson(InputOrganisation(name = "orga2", "no description")))
        .withHeaders("user" -> "certadmin@thehive.local")
      val result = app[OrganisationCtrl].create(request)
      status(result) must_=== 403
    }

    "get an organisation" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v0/organisation/cert").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[OrganisationCtrl].get("cert")(request)
      status(result) must_=== 200
      val resultOrganisation = contentAsJson(result).as[OutputOrganisation]
      resultOrganisation.name must_=== "cert"
    }

    "get a visible organisation" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v0/organisation/cert").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[OrganisationCtrl].get("cert")(request)
      status(result) must_=== 200
      val resultOrganisation = contentAsJson(result).as[OutputOrganisation]
      resultOrganisation.name must_=== "cert"
    }

    "refuse to get a invisible organisation" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v0/organisation/FIXME").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[OrganisationCtrl].get("FIXME")(request)
      status(result) must_=== 404
    }

    "update an organisation" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/organisation/admin")
        .withJsonBody(Json.parse(s"""
              {
                 "organisation":{
                    "name":"defaultUpdate"
                 }
              }
            """.stripMargin))
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[OrganisationCtrl].update("cert")(request)

      status(result) must_=== 204
    }

    "link organisations to soc organisation" in testApp { app =>
      val request = FakeRequest("PUT", s"/api/organisation/soc/link/cert")
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[OrganisationCtrl].link("soc", "cert")(request)
      status(result) shouldEqual 201

      val requestLinks = FakeRequest("GET", s"/api/organisation/soc/links")
        .withHeaders("user" -> "admin@thehive.local")
      val resultLinks = app[OrganisationCtrl].listLinks("soc")(requestLinks)
      status(resultLinks) shouldEqual 200
      contentAsJson(resultLinks).as[List[OutputOrganisation]] must not(beEmpty)
    }

    "link and unlink organisations" in testApp { app =>
      val request = FakeRequest("PUT", s"/api/organisation/cert/link/admin")
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[OrganisationCtrl].link("soc", "cert")(request)
      status(result) shouldEqual 201

      val requestLinks = FakeRequest("GET", s"/api/organisation/soc/links")
        .withHeaders("user" -> "socuser@thehive.local")
      val resultLinks = app[OrganisationCtrl].listLinks("soc")(requestLinks)
      status(resultLinks) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(resultLinks)}")
      contentAsJson(resultLinks).as[List[OutputOrganisation]].length must beEqualTo(1)

      val requestUnlink = FakeRequest("DELETE", s"/api/organisation/soc/link/cert")
        .withHeaders("user" -> "admin@thehive.local")
      val resultUnlink = app[OrganisationCtrl].unlink("soc", "cert")(requestUnlink)

      status(resultUnlink) shouldEqual 204

      val requestLinks2 = FakeRequest("GET", s"/api/organisation/soc/links")
        .withHeaders("user" -> "socuser@thehive.local")
      val resultLinks2 = app[OrganisationCtrl].listLinks("soc")(requestLinks2)
      status(resultLinks2) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(resultLinks2)}")
      contentAsJson(resultLinks2).as[List[OutputOrganisation]] must beEmpty
    }

    "update organisation name" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/v0/organisation/cert")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.obj("name" -> "cert2"))
      val result = app[OrganisationCtrl].update("cert")(request)
      status(result) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(result)}")
      app[Database].roTransaction { implicit graph =>
        app[OrganisationSrv].get(EntityName("cert2")).exists must beTrue
      }
    }

    "fail to update admin organisation" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/v0/organisation/admin")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.obj("description" -> "new description"))
      val result = app[OrganisationCtrl].update("admin")(request)
      status(result) must_=== 400
    }

  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/PageCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.OutputPage
import org.thp.thehive.services.PageSrv
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class PageCtrlTest extends PlaySpecification with TestAppBuilder {
//  val dummyUserSrv               = DummyUserSrv(userId = "admin@thehive.local", permissions = Permissions.all)
//    def createPage(title: String, content: String, order: Int, slug: String, cat: String) = {
//      val request = FakeRequest("POST", "/api/page")
//        .withHeaders("user" -> "certuser@thehive.local")
//        .withJsonBody(Json.parse(s"""{"title": "$title", "content": "$content", "slug": "$slug", "category": "$cat", "order": $order}"""))
//      val result = app[PageCtrl].create(request)
//
//      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
//
//      contentAsJson(result).as[OutputPage]
//    }

  s"page controller" should {
    "create a simple page if allowed" in testApp { app =>
      val request = FakeRequest("POST", "/api/page")
        .withHeaders("user" -> "certadmin@thehive.local")
        .withJsonBody(Json.parse(s"""{"title": "test title", "content": "test content", "category": "test cat", "order": 0}"""))
      val result = app[PageCtrl].create(request)

      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val page = contentAsJson(result).as[OutputPage]

      page.title shouldEqual "test title"
      page.content shouldEqual "test content"
      page.slug shouldEqual "test_title"
      page.category shouldEqual "test cat"
      page.order shouldEqual 0
    }

    "get a page by id or title" in testApp { app =>
      val request = FakeRequest("GET", s"/api/page/how_to_create_a_case")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[PageCtrl].get("how_to_create_a_case")(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      val resultPage = contentAsJson(result).as[OutputPage]
      resultPage.title shouldEqual "how to create a case"
      resultPage.content shouldEqual "this page explain how to create a case"
    }

    "update a page if allowed" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/page/how_to_create_a_case")
        .withHeaders("user" -> "certadmin@thehive.local")
        .withJsonBody(Json.parse("""{"title": "lol"}"""))
      val result = app[PageCtrl].update("how_to_create_a_case")(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      val r = contentAsJson(result).as[OutputPage]
      r.title shouldEqual "lol"
      r.content shouldEqual "this page explain how to create a case"
    }

    "remove a page" in testApp { app =>
      val request = FakeRequest("DELETE", s"/api/page/how_to_create_a_case")
        .withHeaders("user" -> "certadmin@thehive.local")
      val result = app[PageCtrl].delete("how_to_create_a_case")(request)
      status(result) must equalTo(204).updateMessage(s => s"$s\n${contentAsString(result)}")

      app[Database].roTransaction { implicit graph =>
        app[PageSrv].get(EntityName("how_to_create_a_case")).exists
      } must beFalse
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/ProfileCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.OutputProfile
import org.thp.thehive.models.Profile
import org.thp.thehive.services.ProfileSrv
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class ProfileCtrlTest extends PlaySpecification with TestAppBuilder {
  "profile controller" should {
    "create a profile if allowed" in testApp { app =>
      val request = FakeRequest("POST", "/api/profile")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse(s"""{"name": "name test 1", "permissions": ["manageCase"]}"""))
      val result = app[ProfileCtrl].create(request)

      status(result) must equalTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
      val profile = contentAsJson(result).as[OutputProfile]
      profile.name shouldEqual "name test 1"
      profile.permissions shouldEqual List("manageCase")
    }

    "get a profile" in testApp { app =>
      val request = FakeRequest("GET", s"/api/profile/read-only")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[ProfileCtrl].get("read-only")(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      contentAsJson(result).as[OutputProfile].name shouldEqual "read-only"
    }

    "update a profile" in testApp { app =>
      val request = FakeRequest("PATCH", "/api/profile/testProfile")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""{"permissions": ["manageTask"]}"""))
      val result = app[ProfileCtrl].update("testProfile")(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      val updatedProfile = contentAsJson(result).as[OutputProfile]
      updatedProfile.permissions shouldEqual List("manageTask")
    }

    "fail to update non editable profile" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/profile/${Profile.orgAdmin.name}")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.parse("""{"permissions": ["manageTask"]}"""))
      val result = app[ProfileCtrl].update(Profile.orgAdmin.name)(request)

      status(result) must equalTo(400).updateMessage(s => s"$s\n${contentAsString(result)}")
    }

    "delete a profile if allowed" in testApp { app =>
      val request = FakeRequest("DELETE", "/api/profile/testProfile")
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[ProfileCtrl].delete("testProfile")(request)
      status(result) must equalTo(204).updateMessage(s => s"$s\n${contentAsString(result)}")
      app[Database].roTransaction { implicit graph =>
        app[ProfileSrv].get(EntityName("testProfile")).exists must beFalse
      }
    }

    "refuse to delete protected profile" in testApp { app =>
      val requestFailed = FakeRequest("DELETE", s"/api/profile/${Profile.orgAdmin.name}")
        .withHeaders("user" -> "admin@thehive.local")
      val resultFailed = app[ProfileCtrl].delete(Profile.orgAdmin.name)(requestFailed)

      status(resultFailed) must equalTo(400).updateMessage(s => s"$s\n${contentAsString(resultFailed)}")
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/QueryTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.specs2.mock.Mockito
import org.thp.scalligraph.controllers.{Entrypoint, Field}
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.query.{ParamQuery, PublicProperties, QueryExecutor}
import org.thp.thehive.services._
import play.api.libs.json.Json
import play.api.test.PlaySpecification

class QueryTest extends PlaySpecification with Mockito {

  val publicTask = new PublicTask(mock[TaskSrv], mock[OrganisationSrv], mock[UserSrv])

  val queryExecutor: QueryExecutor = new QueryExecutor {
    override val limitedCountThreshold: Long = 1000
    override val db: Database                = mock[Database]
    override val version: (Int, Int)         = 0 -> 0
    override lazy val queries: Seq[ParamQuery[_]] =
      publicTask.initialQuery +: publicTask.getQuery +: publicTask.outputQuery +: publicTask.outputQuery +: publicTask.extraQueries
    override lazy val publicProperties: PublicProperties = publicTask.publicProperties
  }

  val taskCtrl = new TaskCtrl(
    mock[Entrypoint],
    mock[Database],
    mock[TaskSrv],
    mock[CaseSrv],
    mock[OrganisationSrv],
    queryExecutor,
    publicTask
  )

  "Controller" should {
    "parse stats query" in {
      val input = Json.parse("""
                               | {
                               |   "query": {
                               |     "_and": [{
                               |       "_in": {
                               |         "_field": "status",
                               |         "_values": ["Waiting", "InProgress"]
                               |       }
                               |     }, {
                               |       "owner": "admin@thehive.local"
                               |     }]
                               |   },
                               |   "stats": [{
                               |     "_agg": "field",
                               |     "_field": "status",
                               |     "_select": [{ "_agg": "count"}]
                               |   }, {
                               |     "_agg": "count"
                               |   }]
                               | }
        """.stripMargin)

      val queryOrError = taskCtrl.statsParser(Field(input))
      queryOrError.isGood must beTrue.updateMessage(s => s"$s\n$queryOrError")
      queryOrError.get    must not be empty
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/ShareCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0._
import org.thp.thehive.models.Profile
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.{CaseSrv, OrganisationSrv}
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class ShareCtrlTest extends PlaySpecification with TestAppBuilder {
  "share a case" in testApp { app =>
    val request = FakeRequest("POST", "/api/case/1/shares")
      .withJsonBody(Json.obj("shares" -> List(Json.toJson(InputShare("soc", Profile.orgAdmin.name, TasksFilter.all, ObservablesFilter.all)))))
      .withHeaders("user" -> "certuser@thehive.local")
    val result = app[ShareCtrl].shareCase("1")(request)

    status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")

    app[Database].roTransaction { implicit graph =>
      app[CaseSrv].get(EntityName("1")).visible(app[OrganisationSrv])(DummyUserSrv(organisation = "soc").authContext).exists
    } must beTrue
  }

  "fail to share a already share case" in testApp { app =>
    val request = FakeRequest("POST", "/api/case/2/shares")
      .withJsonBody(Json.obj("shares" -> Seq(Json.toJson(InputShare("soc", Profile.orgAdmin.name, TasksFilter.all, ObservablesFilter.all)))))
      .withHeaders("user" -> "certuser@thehive.local")
    val result = app[ShareCtrl].shareCase("2")(request)

    status(result) must equalTo(400).updateMessage(s => s"$s\n${contentAsString(result)}")
  }

  "remove a share" in testApp { app =>
    val request = FakeRequest("DELETE", s"/api/case/2")
      .withJsonBody(Json.obj("organisations" -> Seq("soc")))
      .withHeaders("user" -> "certuser@thehive.local")
    val result = app[ShareCtrl].removeShares("2")(request)

    status(result) must equalTo(204).updateMessage(s => s"$s\n${contentAsString(result)}")

    app[Database].roTransaction { implicit graph =>
      app[CaseSrv].get(EntityName("2")).visible(app[OrganisationSrv])(DummyUserSrv(organisation = "soc").authContext).exists
    } must beFalse
  }

  "refuse to remove owner share" in testApp { app =>
    val request = FakeRequest("DELETE", s"/api/case/2")
      .withJsonBody(Json.obj("organisations" -> Seq("cert")))
      .withHeaders("user" -> "certuser@thehive.local")
    val result = app[ShareCtrl].removeShares("2")(request)

    status(result) must equalTo(400).updateMessage(s => s"$s\n${contentAsString(result)}")
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/StatusCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.{AppBuilder, ScalligraphApplicationLoader}
import org.thp.thehive.models.HealthStatus
import org.thp.thehive.services.Connector
import org.thp.thehive.{TestAppBuilder, TheHiveModule}
import play.api.libs.json.{JsNull, JsObject, Json}
import play.api.mvc.AbstractController
import play.api.test.{FakeRequest, PlaySpecification}
import play.api.{Configuration, Environment}

class StatusCtrlTest extends PlaySpecification with TestAppBuilder {
  val config: Configuration = Configuration.load(Environment.simple())

  val fakeCortexConnector: Connector = new Connector {
    override val name: String = "cortex"
    override def status: JsObject =
      Json.obj(
        "enabled" -> true,
        "status"  -> "OK",
        "servers" -> Json.arr(
          Json.obj(
            "name"    -> "interne",
            "version" -> "2.x.x",
            "status"  -> "OK"
          )
        )
      )

    override def health: HealthStatus.Value = HealthStatus.Warning
  }

  override def appConfigure: AppBuilder = super.appConfigure.multiBindInstance[Connector](fakeCortexConnector)

  "status controller" should {

    "return proper status" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v0/status")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[StatusCtrl].get()(request)

      status(result) shouldEqual 200

      val resultJson = contentAsJson(result)
      val expectedJson = Json.obj(
        "versions" -> Json.obj(
          "Scalligraph" -> getVersion(classOf[ScalligraphApplicationLoader]),
          "TheHive"     -> getVersion(classOf[TheHiveModule]),
          "Play"        -> getVersion(classOf[AbstractController])
        ),
        "connectors" -> Json.obj(
          "cortex" -> Json.obj(
            "enabled" -> true,
            "status"  -> "Ok",
            "servers" -> Json.arr(
              Json.obj(
                "name"    -> "interne",
                "version" -> "2.x.x",
                "status"  -> "OK"
              )
            ),
            "status" -> "OK"
          )
        ),
        "config" -> Json.obj(
          "protectDownloadsWith" -> config.get[String]("datastore.attachment.password"),
          "authType"             -> Seq("local", "key", "header"),
          "capabilities"         -> Seq("changePassword", "setPassword", "authByKey"),
          "ssoAutoLogin"         -> config.get[Boolean]("user.autoCreateOnSso"),
          "pollingDuration"      -> 1000,
          "freeTagDefaultColour" -> "#000000"
        ),
        "schemaStatus" -> Json.arr(
          Json.obj("name" -> "thehive", "currentVersion" -> 99, "expectedVersion" -> 99, "error" -> JsNull)
        )
      )

      resultJson shouldEqual expectedJson
    }

    "be healthy" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v0/health")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[StatusCtrl].health(request)

      status(result) shouldEqual 200
      contentAsString(result) shouldEqual "Warning"
    }
  }

  private def getVersion(c: Class[_]) = Option(c.getPackage.getImplementationVersion).getOrElse("SNAPSHOT")
}

```

`thehive/test/org/thp/thehive/controllers/v0/StreamCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import org.thp.thehive.services.{CaseSrv, OrganisationSrv}
import play.api.test.{FakeRequest, PlaySpecification}

import java.util.Date

class StreamCtrlTest extends PlaySpecification with TestAppBuilder {
  "stream controller" should {
    "create a stream" in testApp { app =>
      val request = FakeRequest("POST", "/api/stream")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[StreamCtrl].create(request)

      status(result)          must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      contentAsString(result) must not(beEmpty)
    }

    "get a case related stream" in testApp { app =>
      implicit val authContext: AuthContext = DummyUserSrv(permissions = Permissions.all).authContext

      val createStreamRequest = FakeRequest("POST", "/api/stream")
        .withHeaders("user" -> "certuser@thehive.local")
      val createStreamResult = app[StreamCtrl].create(createStreamRequest)

      status(createStreamResult) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(createStreamResult)}")
      val streamId = contentAsString(createStreamResult)

      // Add an event
      app[Database].tryTransaction { implicit graph =>
        val organisation = app[OrganisationSrv].getOrFail(EntityName("cert")).get
        app[CaseSrv].create(
          Case(
            title = "case audit",
            description = "desc audit",
            severity = 1,
            startDate = new Date,
            endDate = None,
            flag = false,
            tlp = 1,
            pap = 1,
            status = CaseStatus.Open,
            summary = None,
            tags = Nil
          ),
          assignee = None,
          organisation = organisation,
          customFields = Nil,
          caseTemplate = None,
          additionalTasks = Nil
        )
      } must beASuccessfulTry

      val getStreamRequest = FakeRequest("GET", s"/api/stream/$streamId")
        .withHeaders("user" -> "certuser@thehive.local")
      val getStreamResult = app[StreamCtrl].get(streamId)(getStreamRequest)

      status(getStreamResult) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(getStreamResult)}")
      val stream = contentAsJson(getStreamResult)
      (stream \ 0 \ "summary" \ "case" \ "Creation").asOpt[Int] must beSome(1)
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/TagCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import akka.stream.Materializer
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.OutputTag
import org.thp.thehive.services.TagSrv
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class TagCtrlTest extends PlaySpecification with TestAppBuilder {
  "tag controller" should {
    "get a tag" in testApp { app =>
      // Get a tag id first
      val tags = app[Database].roTransaction(implicit graph => app[TagSrv].startTraversal.toSeq)
      val tag  = tags.head

      val request = FakeRequest("GET", s"/api/tag/${tag._id}")
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[TagCtrl].get(tag._id.toString)(request)

      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
    }

    "search a tag" in testApp { app =>
//      val json = Json.parse("""{
//         "range":"all",
//         "sort":[
//            "-updatedAt",
//            "-createdAt"
//         ],
//         "query":{
//            "_and":[
//               {
//                  "_or":[
//                     {
//                        "predicate":"testDomain"
//                     },
//                     {
//                        "predicate":"t2"
//                     }
//                  ]
//               }
//            ]
//         }
//          }""".stripMargin)
//
//      val request = FakeRequest("POST", s"/api/tag/_search")
//        .withHeaders("user" -> "certuser@thehive.local")
//        .withJsonBody(json)
//      val result = app[TagCtrl].search(request)
//
//      status(result) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
//
//      val l = contentAsJson(result)(defaultAwaitTimeout, app[Materializer]).as[List[OutputTag]]
//
//      l.length shouldEqual 2
//      l.find(_.predicate == "testDomain") must beSome
      pending("freetags created in test database are owned by organisation admin")
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/TaskCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import akka.stream.Materializer
import io.scalaland.chimney.dsl._
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.controllers.v0.Conversion._
import org.thp.thehive.dto.v0.OutputTask
import org.thp.thehive.models._
import org.thp.thehive.services.TaskOps._
import org.thp.thehive.services.{CaseSrv, TaskSrv}
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

import java.util.Date

case class TestTask(
    title: String,
    group: Option[String] = None,
    description: Option[String] = None,
    owner: Option[String] = None,
    status: String,
    flag: Boolean = false,
    startDate: Option[Date] = None,
    endDate: Option[Date] = None,
    order: Int = 0,
    dueDate: Option[Date] = None
)

object TestTask {
  def apply(richTask: RichTask): TestTask = apply(richTask.toValue)

  def apply(outputTask: OutputTask): TestTask =
    outputTask.into[TestTask].transform
}

class TaskCtrlTest extends PlaySpecification with TestAppBuilder {
  "task controller" should {
    "list available tasks and get one task" in testApp { app =>
      val taskId = app[Database].roTransaction { implicit graph =>
        app[TaskSrv].startTraversal.has(_.title, "case 1 task 1")._id.getOrFail("Task").get
      }
      val request    = FakeRequest("GET", s"/api/case/task/$taskId").withHeaders("user" -> "certuser@thehive.local")
      val result     = app[TaskCtrl].get(taskId.toString)(request)
      val resultTask = contentAsJson(result)

      status(result) shouldEqual 200

      val expected = TestTask(
        title = "case 1 task 1",
        description = Some("description task 1"),
        owner = Some("certuser@thehive.local"),
        startDate = None,
        status = "Waiting",
        group = Some("group1"),
        endDate = None,
        dueDate = None
      )

      TestTask(resultTask.as[OutputTask]) must_=== expected
    }

    "patch a task" in testApp { app =>
      val taskId = app[Database].roTransaction { implicit graph =>
        app[TaskSrv].startTraversal.has(_.title, "case 1 task 1")._id.getOrFail("Task").get
      }
      val request = FakeRequest("PATCH", s"/api/case/task/$taskId")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse("""{"title": "new title task 1", "owner": "certuser@thehive.local", "status": "InProgress"}"""))
      val result = app[TaskCtrl].update(taskId.toString)(request)

      status(result) shouldEqual 200

      val expected = TestTask(
        title = "new title task 1",
        description = Some("description task 1"),
        owner = Some("certuser@thehive.local"),
        startDate = None,
        status = "InProgress",
        group = Some("group1"),
        endDate = None,
        dueDate = None
      )

      val newTask = app[Database]
        .roTransaction { implicit graph =>
          app[TaskSrv].startTraversal.has(_.title, "new title task 1").richTask.getOrFail("Task")
        }
        .map(TestTask.apply)
        .map(_.copy(startDate = None))
      newTask must beASuccessfulTry(expected)
    }

    "create a new task for an existing case" in testApp { app =>
      val request = FakeRequest("POST", "/api/case/1/task?flag=true")
        .withJsonBody(
          Json
            .parse(
              """{
                    "title": "case 1 task",
                    "group": "group1",
                    "description": "description task 1",
                    "status": "Waiting"
                }"""
            )
        )
        .withHeaders("user" -> "certuser@thehive.local")

      val result     = app[TaskCtrl].create("1")(request)
      val resultTask = contentAsJson(result)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val resultTaskOutput = resultTask.as[OutputTask]
      val expected = TestTask(
        title = "case 1 task",
        description = Some("description task 1"),
        owner = None,
        startDate = None,
        flag = true,
        status = "Waiting",
        group = Some("group1"),
        endDate = None,
        dueDate = None
      )

      TestTask(resultTaskOutput) must_=== expected

      val requestGet = FakeRequest("GET", s"/api/case/task/${resultTaskOutput.id}").withHeaders("user" -> "certuser@thehive.local")
      val resultGet  = app[TaskCtrl].get(resultTaskOutput.id)(requestGet)

      status(resultGet) shouldEqual 200
    }

    "unset task owner" in testApp { app =>
      val taskId = app[Database].roTransaction { implicit graph =>
        app[TaskSrv].startTraversal.has(_.title, "case 1 task 1")._id.getOrFail("Task").get
      }
      val request = FakeRequest("PATCH", s"/api/case/task/$taskId")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse("""{"owner": null}"""))
      val result = app[TaskCtrl].update(taskId.toString)(request)

      status(result) shouldEqual 200

      val newTask = app[Database]
        .roTransaction { implicit graph =>
          app[TaskSrv].startTraversal.has(_.title, "case 1 task 1").richTask.getOrFail("Task")
        }
        .map(TestTask.apply)

      val expected = TestTask(
        title = "case 1 task 1",
        description = Some("description task 1"),
        owner = None,
        startDate = None,
        status = "Waiting",
        group = Some("group1"),
        endDate = None,
        dueDate = None
      )

      newTask must beSuccessfulTry(expected)

    }

    "search tasks in case" in testApp { app =>
      val request = FakeRequest("POST", "/api/case/task/_stats")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(Json.parse(s"""{
               "query":{
                 "order": 1
               }
             }"""))
      val result = app[TaskCtrl].search(request)
      val t = TestTask(
        title = "case 1 task 2",
        group = Some("group1"),
        description = Some("description task 2"),
        status = "Waiting",
        flag = true,
        order = 1
      )
      val tasks = contentAsJson(result)(defaultAwaitTimeout, app[Materializer]).as[Seq[OutputTask]]
      tasks.map(TestTask.apply) should contain(t)
    }

    "get tasks stats" in testApp { app =>
      val case1 = app[Database].roTransaction(graph => app[CaseSrv].startTraversal(graph).has(_.title, "case#1").getOrFail("Case"))

      case1 must beSuccessfulTry

      val c = case1.get

      val request = FakeRequest("POST", "/api/case/task/_stats")
        .withHeaders("user" -> "certuser@thehive.local")
        .withJsonBody(
          Json.parse(
            s"""{
                         "query":{
                            "_and":[
                               {
                                  "_parent":{
                                     "_type":"case",
                                     "_query":{
                                        "_id":"${c._id}"
                                     }
                                  }
                               },
                               {
                                  "_not":{
                                     "status":"Cancel"
                                  }
                               }
                            ]
                         },
                         "stats":[
                            {
                               "_agg":"field",
                               "_field":"status",
                               "_select":[
                                  {
                                     "_agg":"count"
                                  }
                               ]
                            },
                            {
                               "_agg":"count"
                            }
                         ]
                      }""".stripMargin
          )
        )
      val result = app[TaskCtrl].stats(request)

      status(result) must equalTo(200)

      contentAsJson(result) shouldEqual Json.parse("""{"count":2,"Waiting":{"count":2}}""")
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v0/UserCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v0

import akka.stream.Materializer
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{AuthenticationError, EntityName}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v0.OutputUser
import org.thp.thehive.services.UserSrv
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

case class TestUser(login: String, name: String, roles: Set[String], organisation: String, hasKey: Boolean, status: String)

object TestUser {

  def apply(user: OutputUser): TestUser =
    TestUser(user.login, user.name, user.roles, user.organisation, user.hasKey, user.status)
}

class UserCtrlTest extends PlaySpecification with TestAppBuilder {
  "user controller" should {
    "search users" in testApp { app =>
      val request = FakeRequest("POST", "/api/v0/user/_search?range=all&sort=%2Bname")
        .withJsonBody(
          Json.parse(
            """{"query": {"_and": [{"status": "Ok"}, {"_not": {"_is": {"login": "socadmin@thehive.local"}}}, {"_not": {"_is": {"login": "socuser@thehive.local"}}}]}}"""
          )
        )
        .withHeaders("user" -> "socadmin@thehive.local")

      val result = app[UserCtrl].search(request)
      status(result) must_=== 200

      val resultUsers = contentAsJson(result)(defaultAwaitTimeout, app[Materializer])
      val expected =
        Seq(
          TestUser(
            login = "socro@thehive.local",
            name = "socro",
            roles = Set("read"),
            organisation = "soc",
            hasKey = false,
            status = "Ok"
          )
        )

      resultUsers.as[Seq[OutputUser]].map(TestUser.apply) shouldEqual expected
    }

    "create a new user" in testApp { app =>
      val request = FakeRequest("POST", "/api/v0/user")
        .withJsonBody(Json.parse("""{"login": "certXX@thehive.local", "name": "new user", "roles": ["read", "write", "alert"]}"""))
        .withHeaders("user" -> "certadmin@thehive.local")

      val result = app[UserCtrl].create(request)
      status(result) must_=== 201

      val resultUser = contentAsJson(result).as[OutputUser]
      val expected = TestUser(
        login = "certxx@thehive.local",
        name = "new user",
        roles = Set("read", "write", "alert"),
        organisation = "cert",
        hasKey = false,
        status = "Ok"
      )

      TestUser(resultUser) must_=== expected
    }

    "update a user" in testApp { app =>
      val request = FakeRequest("POST", "/api/v0/user/certuser@thehive.local")
        .withJsonBody(Json.parse("""{"name": "new name"}"""))
        .withHeaders("user" -> "certadmin@thehive.local")

      val result = app[UserCtrl].update("certuser@thehive.local")(request)
      status(result) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")

      val resultUser = contentAsJson(result).as[OutputUser]
      resultUser.name must_=== "new name"
    }

    "lock an user" in testApp { app =>
      val authRequest1 = FakeRequest("POST", "/api/v0/login")
        .withJsonBody(Json.parse("""{"user": "certuser@thehive.local", "password": "my-secret-password"}"""))
      val authResult1 = app[AuthenticationCtrl].login(authRequest1)
      status(authResult1) must_=== 200

      val request = FakeRequest("POST", "/api/v0/user/certuser@thehive.local")
        .withJsonBody(Json.parse("""{"status": "Locked"}"""))
        .withHeaders("user" -> "certadmin@thehive.local")

      val result = app[UserCtrl].update("certuser@thehive.local")(request)
      status(result) must_=== 200
      val resultUser = contentAsJson(result).as[OutputUser]
      resultUser.status must_=== "Locked"

      // then authentication must fail
      val authRequest2 = FakeRequest("POST", "/api/v0/login")
        .withJsonBody(Json.parse("""{"user": "certuser@thehive.local", "password": "my-secret-password"}"""))
      val authResult2 = app[AuthenticationCtrl].login(authRequest2)
      status(authResult2) must_=== 401
    }

    "unlock an user" in testApp { app =>
      val keyAuthRequest = FakeRequest("GET", "/api/v0/user/current")
        .withHeaders("Authorization" -> "Bearer azertyazerty")

      status(app[UserCtrl].current(keyAuthRequest)) must throwA[AuthenticationError]

      val request = FakeRequest("POST", "/api/v0/user/certro@thehive.local")
        .withJsonBody(Json.parse("""{"status": "Ok"}"""))
        .withHeaders("user" -> "certadmin@thehive.local")

      val result = app[UserCtrl].update("certro@thehive.local")(request)
      status(result) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      val resultUser = contentAsJson(result).as[OutputUser]
      resultUser.status must_=== "Ok"

      status(app[UserCtrl].current(keyAuthRequest)) must_=== 200
    }

    "remove a user (lock)" in testApp { app =>
      val request = FakeRequest("DELETE", "/api/v0/user/certro@thehive.local")
        .withHeaders("user" -> "certadmin@thehive.local")
      val result = app[UserCtrl].lock("certro@thehive.local")(request)

      status(result) must beEqualTo(204)

      val requestGet = FakeRequest("POST", "/api/v0/user/certro@thehive.local")
        .withHeaders("user" -> "certadmin@thehive.local")
      val resultGet = app[UserCtrl].get("certro@thehive.local")(requestGet)

      status(resultGet) must_=== 200
      contentAsJson(resultGet).as[OutputUser].status must beEqualTo("Locked")
    }

    "remove a user (force)" in testApp { app =>
      val request = FakeRequest("DELETE", "/api/v0/user/certro@thehive.local/force")
        .withHeaders("user" -> "certadmin@thehive.local")
      val result = app[UserCtrl].delete("certro@thehive.local")(request)

      status(result) must beEqualTo(204)

      app[Database].roTransaction { implicit graph =>
        app[UserSrv].get(EntityName("certro@thehive.local")).exists
      } must beFalse
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v1/AlertCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.models.{Database, Entity}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v1.{InputAlert, OutputAlert}
import org.thp.thehive.models._
import org.thp.thehive.services.AlertSrv
import play.api.libs.json.{JsObject, JsString, Json}
import play.api.test.{FakeRequest, PlaySpecification}

import java.util.Date

case class TestAlert(
    `type`: String,
    source: String,
    sourceRef: String,
    title: String,
    description: String,
    severity: Int,
    date: Date,
    tags: Set[String],
    tlp: Int,
    pap: Int,
    read: Boolean,
    follow: Boolean
)

object TestAlert {

  def apply(alert: OutputAlert): TestAlert =
    TestAlert(
      alert.`type`,
      alert.source,
      alert.sourceRef,
      alert.title,
      alert.description,
      alert.severity,
      alert.date,
      alert.tags,
      alert.tlp,
      alert.pap,
      alert.read,
      alert.follow
    )
}

class AlertCtrlTest extends PlaySpecification with TestAppBuilder {
  "alert controller" should {

    "create a new alert" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/alert")
        .withJsonBody(Json.toJson(InputAlert("test", "source1", "sourceRef1", None, "new alert", "test alert")))
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[AlertCtrl].create(request)
      status(result) must_=== 201
      val createdAlert = contentAsJson(result).as[OutputAlert]
      val expected = OutputAlert(
        _id = createdAlert._id,
        _type = "Alert",
        _createdBy = createdAlert._createdBy,
        _updatedBy = None,
        _createdAt = createdAlert._createdAt,
        _updatedAt = None,
        `type` = "test",
        source = "source1",
        sourceRef = "sourceRef1",
        externalLink = None,
        title = "new alert",
        description = "test alert",
        severity = 2,
        date = createdAlert.date,
        tags = Set.empty,
        tlp = 2,
        pap = 2,
        read = false,
        follow = true,
        customFields = Seq.empty,
        caseTemplate = None,
        observableCount = 0L,
        caseId = None,
        extraData = JsObject.empty
      )

      createdAlert must_=== expected
    }

    "fail to create a duplicated alert" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/alert")
        .withJsonBody(Json.toJson(InputAlert("testType", "testSource", "ref2", None, "new alert", "test alert")))
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[AlertCtrl].create(request)
      status(result) must_=== 400
    }

    "create an alert with a case template" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/alert")
        .withJsonBody(
          Json.toJsObject(InputAlert("test", "source1", "sourceRef1Template", None, "new alert", "test alert"))
            + ("caseTemplate" -> JsString("spam"))
        )
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[AlertCtrl].create(request)
      status(result) must_=== 201
      val createdAlert = contentAsJson(result).as[OutputAlert]
      val expected = OutputAlert(
        _id = createdAlert._id,
        _type = "Alert",
        _createdBy = createdAlert._createdBy,
        _updatedBy = None,
        _createdAt = createdAlert._createdAt,
        _updatedAt = None,
        `type` = "test",
        source = "source1",
        sourceRef = "sourceRef1Template",
        externalLink = None,
        title = "new alert",
        description = "test alert",
        severity = 2,
        date = createdAlert.date,
        tags = Set.empty,
        tlp = 2,
        pap = 2,
        read = false,
        follow = true,
        customFields = Seq.empty,
        caseTemplate = Some("spam"),
        observableCount = 0L,
        caseId = None,
        extraData = JsObject.empty
      )

      createdAlert must_=== expected
    }

    "get an alert" in testApp { app =>
      val alertSrv = app.apply[AlertSrv]
      app.apply[Database].roTransaction { implicit graph =>
        alertSrv.startTraversal.has(_.sourceRef, "ref1").getOrFail("Alert")
      } must beSuccessfulTry.which { alert: Alert with Entity =>
        val request = FakeRequest("GET", s"/api/v1/alert/${alert._id}").withHeaders("user" -> "socuser@thehive.local")
        val result  = app[AlertCtrl].get(alert._id.toString)(request)
        status(result) must_=== 200
        val resultAlert = contentAsJson(result).as[OutputAlert]
        val expected = TestAlert(
          `type` = "testType",
          source = "testSource",
          sourceRef = "ref1",
          title = "alert#1",
          description = "description of alert #1",
          severity = 2,
          date = new Date(1555359572000L),
          tags = Set("alert", "test"),
          tlp = 2,
          pap = 2,
          read = false,
          follow = true
        )
        TestAlert(resultAlert) must_=== expected
      }
    }

    "update an alert" in testApp { app =>
      pending
    }

    "mark an alert as read" in testApp { app =>
      pending
    }

    "unfollow an alert" in testApp { app =>
      pending
    }

    "create a case from an alert" in testApp { app =>
      pending
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v1/CaseCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v1

import io.scalaland.chimney.dsl.TransformerOps
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v1.{InputCase, OutputCase, OutputCustomFieldValue}
import play.api.libs.json.{JsNull, JsString, JsValue, Json}
import play.api.test.{FakeRequest, PlaySpecification}

import java.util.Date

case class TestCustomFieldValue(name: String, description: String, `type`: String, value: JsValue, order: Int)

object TestCustomFieldValue {
  def apply(outputCustomFieldValue: OutputCustomFieldValue): TestCustomFieldValue =
    outputCustomFieldValue.into[TestCustomFieldValue].transform
}

case class TestCase(
    title: String,
    description: String,
    severity: Int,
    startDate: Date,
    endDate: Option[Date] = None,
    tags: Set[String] = Set.empty,
    flag: Boolean,
    tlp: Int,
    pap: Int,
    status: String,
    summary: Option[String] = None,
    impactStatus: Option[String] = None,
    resolutionStatus: Option[String] = None,
    user: Option[String],
    customFields: Seq[TestCustomFieldValue] = Seq.empty
)

object TestCase {
  def apply(outputCase: OutputCase): TestCase =
    outputCase
      .into[TestCase]
      .withFieldRenamed(_.assignee, _.user)
      .withFieldComputed(_.customFields, _.customFields.map(TestCustomFieldValue.apply).sortBy(_.order))
      .transform
}

class CaseCtrlTest extends PlaySpecification with TestAppBuilder {
  "case controller" should {
    "create a new case" in testApp { app =>
      val now = new Date()
      val request = FakeRequest("POST", "/api/v1/case")
        .withJsonBody(
          Json.toJson(
            InputCase(
              title = "case title (create case test)",
              description = "case description (create case test)",
              severity = Some(2),
              startDate = Some(now),
              tags = Set("tag1", "tag2"),
              flag = Some(false),
              tlp = Some(1),
              pap = Some(3),
              user = Some("certro@thehive.local")
            )
          )
        )
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[CaseCtrl].create(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")
      val resultCase = contentAsJson(result).as[OutputCase]
      val expected = TestCase(
        title = "case title (create case test)",
        description = "case description (create case test)",
        severity = 2,
        startDate = now,
        endDate = None,
        tags = Set("tag1", "tag2"),
        flag = false,
        tlp = 1,
        pap = 3,
        status = "Open",
        summary = None,
        user = Some("certro@thehive.local"),
        customFields = Seq.empty
      )

      TestCase(resultCase) must_=== expected
    }

    "create a new case using a template" in testApp { app =>
      val now = new Date()
      val request = FakeRequest("POST", "/api/v1/case")
        .withJsonBody(
          Json.toJsObject(
            InputCase(
              title = "case title (create case test with template)",
              description = "case description (create case test with template)",
              severity = None,
              startDate = Some(now),
              tags = Set("tag1", "tag2"),
              flag = Some(false),
              tlp = Some(1),
              pap = Some(3)
            )
          ) + ("caseTemplate" -> JsString("spam"))
        )
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[CaseCtrl].create(request)
      status(result) must_=== 201
      val resultCase = contentAsJson(result).as[OutputCase]
      val expected = TestCase(
        title = "[SPAM] case title (create case test with template)",
        description = "case description (create case test with template)",
        severity = 1,
        startDate = now,
        endDate = None,
        tags = Set("tag1", "tag2", "spam", "src:mail"),
        flag = false,
        tlp = 1,
        pap = 3,
        status = "Open",
        summary = None,
        user = Some("certuser@thehive.local"),
        customFields = Seq(
          TestCustomFieldValue("string1", "string custom field", "string", JsString("string1 custom field"), 0),
          TestCustomFieldValue("boolean1", "boolean custom field", "boolean", JsNull, 1)
        )
      )

      TestCase(resultCase) must_=== expected
    }

    "get a case" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v1/case/1")
        .withHeaders("user" -> "certuser@thehive.local")
      val result     = app[CaseCtrl].get("1")(request)
      val resultCase = contentAsJson(result).as[OutputCase]
      val expected = TestCase(
        title = "case#1",
        description = "description of case #1",
        severity = 2,
        startDate = new Date(1531667370000L),
        endDate = None,
        tags = Set("t1", "t3"),
        flag = false,
        tlp = 2,
        pap = 2,
        status = "Open",
        user = Some("certuser@thehive.local")
      )

      TestCase(resultCase) must_=== expected
    }

    "update a case" in testApp { app =>
//        val updateRequest = FakeRequest("PATCH", s"/api/v1/case/#2")
//          .withJsonBody(
//            Json.obj(
//              "title"  → "new title",
//              "flag"   → false,
//              "tlp"    → 2,
//              "pap"    → 1,
//              "status" → "resolved"
//            ))
//          .withHeaders("user" → "certuser@thehive.local")
//        val updateResult = app[CaseCtrl].update("#2")(updateRequest)
//        status(updateResult) must_=== 204
//
//        val getRequest = FakeRequest("GET", s"/api/v1/case/#2")
//        val getResult  = app[CaseCtrl].get("#2")(getRequest)
//        val resultCase = contentAsJson(getResult).as[OutputCase]
//        val expected = TestCase(
//          title = "new title",
//          description = "case description (update case test)",
//          severity = 2,
//          startDate = new Date(),
//          endDate = None,
//          tags = Set("tag1", "tag2"),
//          flag = false,
//          tlp = 2,
//          pap = 1,
//          status = "resolved",
//          user = Some(dummyUserSrv.authContext.userId)
//        )

//        TestCase(resultCase) must_=== expected
      pending
    }

    "merge 3 cases correctly" in testApp { app =>
      val request21 = FakeRequest("GET", s"/api/v1/case/#21")
        .withHeaders("user" -> "certuser@thehive.local")
      val case21 = app[CaseCtrl].get("21")(request21)
      status(case21) must equalTo(200).updateMessage(s => s"$s\n${contentAsString(case21)}")
      val output21 = contentAsJson(case21).as[OutputCase]

      val request = FakeRequest("GET", "/api/v1/case/_merge/21,22,23")
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[CaseCtrl].merge("21,22,23")(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val outputCase = contentAsJson(result).as[OutputCase]

      // Merge result
      TestCase(outputCase) must equalTo(
        TestCase(
          title = "case#21 / case#22 / case#23",
          description = "description of case #21\n\ndescription of case #22\n\ndescription of case #23",
          severity = 3,
          startDate = output21.startDate,
          endDate = output21.endDate,
          Set("toMerge:pred1=\"value1\"", "toMerge:pred2=\"value2\""),
          flag = true,
          tlp = 4,
          pap = 3,
          status = "Open",
          None,
          None,
          None,
          Some("certuser@thehive.local"),
          Seq()
        )
      )

      // Merged cases should be deleted
      val deleted21 = app[CaseCtrl].get("21")(request)
      status(deleted21) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(deleted21)}")
      val deleted22 = app[CaseCtrl].get("22")(request)
      status(deleted22) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(deleted22)}")
      val deleted23 = app[CaseCtrl].get("23")(request)
      status(deleted23) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(deleted23)}")
    }

    "merge two cases error, not same organisation" in testApp { app =>
      val request = FakeRequest("GET", "/api/v1/case/_merge/21,24")
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[CaseCtrl].merge("21,24")(request)
      // User shouldn't be able to see others cases, resulting in 404
      status(result) must beEqualTo(400).updateMessage(s => s"$s\n${contentAsString(result)}")
    }

    "merge two cases error, not same profile" in testApp { app =>
      val request = FakeRequest("GET", "/api/v1/case/_merge/21,25")
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[CaseCtrl].merge("21,25")(request)
      status(result)                              must beEqualTo(400).updateMessage(s => s"$s\n${contentAsString(result)}")
      (contentAsJson(result) \ "type").as[String] must beEqualTo("BadRequest")
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v1/GraphqlTest.scala`:

```scala
//package org.thp.thehive.controllers.v1
//
//import scala.util.Success
//import play.api.mvc.RequestHeader
//import play.api.test.PlaySpecification
//import org.specs2.mock.Mockito
//import org.specs2.specification.core.{Fragment, Fragments}
//import org.thp.scalligraph.auth.AuthSrv
//import org.thp.scalligraph.controllers.AuthenticateSrv
//import org.thp.scalligraph.models.{Database, DatabaseProviders, DummyUserSrv, Schema}
//import org.thp.scalligraph.services.{LocalFileSystemStorageSrv, StorageSrv}
//import org.thp.scalligraph.{graphql, AppBuilder}
//import org.thp.thehive.models._
//import sangria.renderer.SchemaRenderer
//
//class GraphqlTest extends PlaySpecification  {
//  val dummyUserSrv                 = DummyUserSrv()
//  val authenticated: AuthenticateSrv = mock[AuthenticateSrv]
//  authenticated.getContext(any[RequestHeader]) returns Success(dummyUserSrv.authContext)
//
//  Fragments.foreach(new DatabaseProviders().list) { dbProvider =>
//    val app: AppBuilder = AppBuilder()
//      .bindInstance[org.thp.scalligraph.auth.UserSrv](dummyUserSrv)
//      .bindInstance[InitialAuthContext](InitialAuthContext(dummyUserSrv.getSystemAuthContext))
//      .bindToProvider(dbProvider)
//      .bindInstance[AuthSrv](mock[AuthSrv])
//      .bindInstance[AuthenticateSrv](authenticated)
//      .bind[StorageSrv, LocalFileSystemStorageSrv]
//      .bind[Schema, TheHiveSchema]
//      .addConfiguration("play.modules.disabled = [org.thp.scalligraph.ScalligraphModule, org.thp.thehive.TheHiveModule]")
//    step(setupDatabase(app)) ^ specs(dbProvider.name, app) ^ step(teardownDatabase(app))
//  }
//
//  def setupDatabase(app: AppBuilder): Try[Unit] =
//    app.instanceOf[DatabaseBuilder].build()(app.instanceOf[Database], dummyUserSrv.getSystemAuthContext)
//
//  def teardownDatabase(app: AppBuilder): Unit = app.instanceOf[Database].drop()
//
//  def specs(name: String, app: AppBuilder): Fragment = {
//    val queryExecutor: TheHiveQueryExecutor = app.instanceOf[TheHiveQueryExecutor]
//
//    s"[$name] TheHive" should {
//      "have graphql schema" in {
//
//        val schema    = graphql.SchemaGenerator(queryExecutor)
//        val schemaStr = SchemaRenderer.renderSchema(schema)
//        //println(s"new modern graphql schema is:\n$schemaStr")
//
//        schemaStr must_!== ""
//      }
//    }
//  }
//}

```

`thehive/test/org/thp/thehive/controllers/v1/OrganisationCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v1.{InputOrganisation, OutputOrganisation}
import org.thp.thehive.models.Organisation
import org.thp.thehive.services.OrganisationSrv
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class OrganisationCtrlTest extends PlaySpecification with TestAppBuilder {
  "organisation controller" should {
    "create a new organisation" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/organisation")
        .withJsonBody(Json.toJson(InputOrganisation(name = "orga1", "no description")))
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[OrganisationCtrl].create(request)
      status(result) must_=== 201
      val resultOrganisation = contentAsJson(result).as[OutputOrganisation]
      resultOrganisation.name must_=== "orga1"
    }

    "refuse to create an user if the permission doesn't contain ManageOrganisation right" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/organisation")
        .withJsonBody(Json.toJson(InputOrganisation(name = "orga2", "no description")))
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[OrganisationCtrl].create(request)
      status(result) must_=== 403
    }

    "get an organisation" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v1/organisation/cert").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[OrganisationCtrl].get("cert")(request)
      status(result) must_=== 200
      val resultOrganisation = contentAsJson(result).as[OutputOrganisation]
      resultOrganisation.name must_=== "cert"
    }

    "get a visible organisation" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v1/organisation/soc").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[OrganisationCtrl].get("soc")(request)
      status(result) must_=== 200
      val resultOrganisation = contentAsJson(result).as[OutputOrganisation]
      resultOrganisation.name must_=== "soc"
    }

    "refuse to get a invisible organisation" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v1/organisation/${Organisation.administration.name}").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[OrganisationCtrl].get(Organisation.administration.name)(request)
      status(result) must_=== 404
    }

    "update organisation name" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/v1/organisation/cert")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.obj("name" -> "cert2"))
      val result = app[OrganisationCtrl].update("cert")(request)
      status(result) must_=== 204
      app[Database].roTransaction { implicit graph =>
        app[OrganisationSrv].get(EntityName("cert2")).exists must beTrue
      }
    }

    "fail to update admin organisation" in testApp { app =>
      val request = FakeRequest("PATCH", s"/api/v1/organisation/admin")
        .withHeaders("user" -> "admin@thehive.local")
        .withJsonBody(Json.obj("description" -> "new description"))
      val result = app[OrganisationCtrl].update("admin")(request)
      status(result) must_=== 400
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v1/PatternCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v1

import io.scalaland.chimney.dsl._
import org.thp.scalligraph.controllers.FakeTemporaryFile
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v1.OutputPattern
import play.api.libs.json.{JsArray, JsString}
import play.api.mvc.MultipartFormData.FilePart
import play.api.mvc.{AnyContentAsMultipartFormData, MultipartFormData}
import play.api.test.{FakeRequest, PlaySpecification}

case class TestPattern(
    patternId: String,
    name: String,
    description: Option[String],
    tactics: Set[String],
    url: String,
    patternType: String,
    capecId: Option[String],
    capecUrl: Option[String],
    revoked: Boolean,
    dataSources: Seq[String],
    defenseBypassed: Seq[String],
    detection: Option[String],
    permissionsRequired: Seq[String],
    platforms: Seq[String],
    remoteSupport: Boolean,
    systemRequirements: Seq[String],
    version: Option[String]
)

object TestPattern {
  def apply(outputPattern: OutputPattern): TestPattern =
    outputPattern.into[TestPattern].transform
}

class PatternCtrlTest extends PlaySpecification with TestAppBuilder {
  "pattern controller" should {
    "import json patterns" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/pattern/import/attack")
        .withHeaders("user" -> "admin@thehive.local")
        .withBody(
          AnyContentAsMultipartFormData(
            MultipartFormData(
              dataParts = Map.empty,
              files = Seq(FilePart("file", "patterns.json", Option("application/json"), FakeTemporaryFile.fromResource("/patterns.json"))),
              badParts = Seq()
            )
          )
        )

      val result = app[PatternCtrl].importMitre(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      contentAsJson(result)
        .as[JsArray]
        .value
        .count(jsValue => (jsValue \ "status").get == JsString("Success")) must beEqualTo(8)
    }

    "get a existing pattern" in testApp { app =>
      val request = FakeRequest("GET", "/api/v1/pattern/T123")
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[PatternCtrl].get("T123")(request)
      status(result) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      val resultPattern = contentAsJson(result).as[OutputPattern]

      TestPattern(resultPattern) must_=== TestPattern(
        "T123",
        "testPattern1",
        Some("The testPattern 1"),
        Set("testTactic1", "testTactic2"),
        "http://test.pattern.url",
        "unit-test",
        None,
        None,
        revoked = false,
        Seq(),
        Seq(),
        None,
        Seq(),
        Seq(),
        remoteSupport = true,
        Seq(),
        Some("1.0")
      )
    }

    "get patterns linked to case" in testApp { app =>
      val request = FakeRequest("GET", "/api/v1/pattern/case/1")
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[PatternCtrl].getCasePatterns("1")(request)
      status(result) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")

      contentAsJson(result).as[Seq[OutputPattern]].size must beEqualTo(2)
    }

    "import & update a pattern" in testApp { app =>
      // Get a pattern
      val request1 = FakeRequest("GET", "/api/v1/pattern/T123")
        .withHeaders("user" -> "certuser@thehive.local")

      val result1 = app[PatternCtrl].get("T123")(request1)
      status(result1) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result1)}")
      val result1Pattern = contentAsJson(result1).as[OutputPattern]

      TestPattern(result1Pattern) must_=== TestPattern(
        "T123",
        "testPattern1",
        Some("The testPattern 1"),
        Set("testTactic1", "testTactic2"),
        "http://test.pattern.url",
        "unit-test",
        None,
        None,
        revoked = false,
        Seq(),
        Seq(),
        None,
        Seq(),
        Seq(),
        remoteSupport = true,
        Seq(),
        Some("1.0")
      )

      // Update a pattern
      val request2 = FakeRequest("POST", "/api/v1/pattern/import/attack")
        .withHeaders("user" -> "admin@thehive.local")
        .withBody(
          AnyContentAsMultipartFormData(
            MultipartFormData(
              dataParts = Map.empty,
              files =
                Seq(FilePart("file", "patternsUpdate.json", Option("application/json"), FakeTemporaryFile.fromResource("/patternsUpdate.json"))),
              badParts = Seq()
            )
          )
        )

      val result2 = app[PatternCtrl].importMitre(request2)
      status(result2) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result2)}")

      // Check for updates
      val request3 = FakeRequest("GET", "/api/v1/pattern/T123")
        .withHeaders("user" -> "certuser@thehive.local")

      val result3 = app[PatternCtrl].get("T123")(request3)
      status(result3) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result3)}")
      val result3Pattern = contentAsJson(result3).as[OutputPattern]

      TestPattern(result3Pattern) must_=== TestPattern(
        "T123",
        "Updated testPattern1",
        None,
        Set(),
        "https://attack.mitre.org/techniques/T123",
        "attack-pattern",
        None,
        None,
        revoked = true,
        Seq(),
        Seq(),
        None,
        Seq(),
        Seq(),
        remoteSupport = false,
        Seq(),
        None
      )
    }

    "delete a pattern" in testApp { app =>
      val request1 = FakeRequest("GET", "/api/v1/pattern/testPattern1")
        .withHeaders("user" -> "certuser@thehive.local")
      val result1 = app[PatternCtrl].get("T123")(request1)
      status(result1) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result1)}")

      val request2 = FakeRequest("DELETE", "/api/v1/pattern/testPattern1")
        .withHeaders("user" -> "admin@thehive.local")
      val result2 = app[PatternCtrl].delete("T123")(request2)
      status(result2) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(result2)}")

      val request3 = FakeRequest("GET", "/api/v1/pattern/testPattern1")
        .withHeaders("user" -> "certuser@thehive.local")
      val result3 = app[PatternCtrl].get("T123")(request3)
      status(result3) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(result3)}")
    }

  }
}

```

`thehive/test/org/thp/thehive/controllers/v1/ProcedureCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v1

import io.scalaland.chimney.dsl.TransformerOps
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v1.{InputProcedure, OutputProcedure}
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

import java.util.Date

case class TestProcedure(
    description: Option[String],
    occurDate: Date,
    tactic: String,
    patternId: String
)

object TestProcedure {
  def apply(outputProcedure: OutputProcedure): TestProcedure =
    outputProcedure.into[TestProcedure].transform
}

class ProcedureCtrlTest extends PlaySpecification with TestAppBuilder {
  "procedure controller" should {
    "create a valid procedure" in testApp { app =>
      val procedureDate = new Date()
      val inputProcedure = InputProcedure(
        Some("testProcedure3"),
        procedureDate,
        "tactic1",
        "1",
        "T123"
      )

      val request = FakeRequest("POST", "/api/v1/procedure")
        .withJsonBody(Json.toJson(inputProcedure))
        .withHeaders("user" -> "certadmin@thehive.local")

      val result = app[ProcedureCtrl].create(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val resultProcedure = contentAsJson(result).as[OutputProcedure]

      TestProcedure(resultProcedure) must_=== TestProcedure(
        Some("testProcedure3"),
        procedureDate,
        "tactic1",
        "T123"
      )
    }

    "update a procedure" in testApp { app =>
      val request1 = FakeRequest("POST", "/api/v1/procedure/testProcedure3")
        .withJsonBody(
          Json.toJson(
            InputProcedure(
              Some("an old description"),
              new Date(),
              "tactic1",
              "1",
              "T123"
            )
          )
        )
        .withHeaders("user" -> "certadmin@thehive.local")
      val result1     = app[ProcedureCtrl].create(request1)
      val procedureId = contentAsJson(result1).as[OutputProcedure]._id
      status(result1) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result1)}")

      val updatedDate = new Date()
      val request2 = FakeRequest("PATCH", "/api/v1/procedure/testProcedure3")
        .withHeaders("user" -> "certadmin@thehive.local")
        .withJsonBody(Json.obj("description" -> "a new description", "occurDate" -> updatedDate, "tactic" -> "tactic2"))
      val result2 = app[ProcedureCtrl].update(procedureId)(request2)
      status(result2) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(result2)}")

      val request3 = FakeRequest("GET", "/api/v1/procedure/testProcedure3")
        .withHeaders("user" -> "certadmin@thehive.local")
      val result3 = app[ProcedureCtrl].get(procedureId)(request3)
      status(result3) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result3)}")

      val resultProcedure = contentAsJson(result3).as[OutputProcedure]
      TestProcedure(resultProcedure) must_=== TestProcedure(
        Some("a new description"),
        updatedDate,
        "tactic2",
        "T123"
      )
    }

    "delete a procedure" in testApp { app =>
      val request1 = FakeRequest("POST", "/api/v1/procedure/testProcedure3")
        .withJsonBody(
          Json.toJson(
            InputProcedure(
              Some("testProcedure3"),
              new Date(),
              "tactic1",
              "1",
              "T123"
            )
          )
        )
        .withHeaders("user" -> "certadmin@thehive.local")
      val result1     = app[ProcedureCtrl].create(request1)
      val procedureId = contentAsJson(result1).as[OutputProcedure]._id
      status(result1) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result1)}")

      val request2 = FakeRequest("DELETE", "/api/v1/procedure/testProcedure3")
        .withHeaders("user" -> "certadmin@thehive.local")
      val result2 = app[ProcedureCtrl].delete(procedureId)(request2)
      status(result2) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(result2)}")

      val request3 = FakeRequest("GET", "/api/v1/procedure/testProcedure3")
        .withHeaders("user" -> "certuser@thehive.local")
      val result3 = app[ProcedureCtrl].get(procedureId)(request3)
      status(result3) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(result3)}")
    }
  }
}

```

`thehive/test/org/thp/thehive/controllers/v1/TaxonomyCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v1

import io.scalaland.chimney.dsl.TransformerOps
import org.thp.scalligraph.controllers.FakeTemporaryFile
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v1._
import play.api.libs.Files
import play.api.libs.json.{JsArray, Json}
import play.api.mvc.MultipartFormData.FilePart
import play.api.mvc.{AnyContentAsMultipartFormData, MultipartFormData}
import play.api.test.{FakeRequest, PlaySpecification}

case class TestTaxonomy(
    namespace: String,
    description: String,
    version: Int,
    tags: Set[TestTag]
)

object TestTaxonomy {
  def apply(outputTaxonomy: OutputTaxonomy): TestTaxonomy =
    outputTaxonomy
      .into[TestTaxonomy]
      .withFieldComputed(_.tags, _.tags.toSet.map(TestTag.apply))
      .transform
}

case class TestTag(namespace: String, predicate: String, value: Option[String], description: Option[String], colour: String)

object TestTag {
  def apply(outputTag: OutputTag): TestTag =
    TestTag(outputTag.namespace, outputTag.predicate, outputTag.value, outputTag.description, outputTag.colour)
}
class TaxonomyCtrlTest extends PlaySpecification with TestAppBuilder {
  "taxonomy controller" should {

    val inputTaxo = InputTaxonomy(
      "test-taxo",
      "A test taxonomy",
      1,
      None,
      List(
        InputPredicate("pred1", None, None, None, None),
        InputPredicate("pred2", None, None, None, None)
      ),
      List(
        InputValue("pred1", List(InputEntry("entry1", None, Some("#ffa800"), None, None))),
        InputValue(
          "pred2",
          List(
            InputEntry("entry2", None, Some("#00ad1c"), None, None),
            InputEntry("entry21", None, Some("#00ad1c"), None, None)
          )
        )
      )
    )

    val updateTaxo = InputTaxonomy(
      "taxonomy1",
      "Updated The taxonomy 1",
      2,
      None,
      List(InputPredicate("pred1", None, None, None, None)),
      List(InputValue("pred1", List(InputEntry("value2", None, Some("#fba800"), None, None))))
    )

    "create a valid taxonomy" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/taxonomy")
        .withJsonBody(Json.toJson(inputTaxo))
        .withHeaders("user" -> "admin@thehive.local")

      val result = app[TaxonomyCtrl].create(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val resultTaxo = contentAsJson(result).as[OutputTaxonomy]

      TestTaxonomy(resultTaxo) must_=== TestTaxonomy(
        "test-taxo",
        "A test taxonomy",
        1,
        Set(
          TestTag("test-taxo", "pred1", Some("entry1"), None, "#ffa800"),
          TestTag("test-taxo", "pred2", Some("entry2"), None, "#00ad1c"),
          TestTag("test-taxo", "pred2", Some("entry21"), None, "#00ad1c")
        )
      )
    }

    "return error if not admin" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/taxonomy")
        .withJsonBody(Json.toJson(inputTaxo))
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[TaxonomyCtrl].create(request)
      status(result) must beEqualTo(403).updateMessage(s => s"$s\n${contentAsString(result)}")
      (contentAsJson(result) \ "type").as[String] must beEqualTo("AuthorizationError")
    }

    "return error if namespace is empty" in testApp { app =>
      val emptyNamespace = inputTaxo.copy(namespace = "")

      val request = FakeRequest("POST", "/api/v1/taxonomy")
        .withJsonBody(Json.toJson(emptyNamespace))
        .withHeaders("user" -> "admin@thehive.local")

      val result = app[TaxonomyCtrl].create(request)
      status(result) must beEqualTo(400).updateMessage(s => s"$s\n${contentAsString(result)}")
      (contentAsJson(result) \ "type").as[String] must beEqualTo("BadRequest")

    }

    "get a taxonomy present" in testApp { app =>
      val request = FakeRequest("GET", "/api/v1/taxonomy/taxonomy1")
        .withHeaders("user" -> "certuser@thehive.local")

      val result = app[TaxonomyCtrl].get("taxonomy1")(request)
      status(result) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result)}")
      val resultCase = contentAsJson(result).as[OutputTaxonomy]

      TestTaxonomy(resultCase) must_=== TestTaxonomy(
        "taxonomy1",
        "The taxonomy 1",
        1,
        Set(TestTag("taxonomy1", "pred1", Some("value1"), None, "#00f300"))
      )
    }

    "return error if taxonomy is not present in database" in testApp { app =>
      val request = FakeRequest("GET", "/api/v1/taxonomy/taxonomy404")
        .withHeaders("user" -> "admin@thehive.local")

      val result = app[TaxonomyCtrl].get("taxonomy404")(request)
      status(result) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(result)}")
      (contentAsJson(result) \ "type").as[String] must beEqualTo("NotFoundError")
    }

    "import zip file correctly" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/taxonomy/import-zip")
        .withHeaders("user" -> "admin@thehive.local")
        .withBody(AnyContentAsMultipartFormData(multipartZipFile("machinetag.zip")))

      val result = app[TaxonomyCtrl].importZip(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      contentAsString(result) must not contain "Failure"
      contentAsJson(result).as[JsArray].value.size must beEqualTo(2)
    }

    "import zip file with folders correctly" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/taxonomy/import-zip")
        .withHeaders("user" -> "admin@thehive.local")
        .withBody(AnyContentAsMultipartFormData(multipartZipFile("machinetag-folders.zip")))

      val result = app[TaxonomyCtrl].importZip(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      contentAsString(result) must not contain "Failure"
      contentAsJson(result).as[JsArray].value.size must beEqualTo(2)
    }

    "return no error if zip file contains other files than taxonomies" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/taxonomy/import-zip")
        .withHeaders("user" -> "admin@thehive.local")
        .withBody(AnyContentAsMultipartFormData(multipartZipFile("machinetag-otherfiles.zip")))

      val result = app[TaxonomyCtrl].importZip(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      contentAsString(result) must not contain "Failure"
      contentAsJson(result).as[JsArray].value.size must beEqualTo(1)
    }

    "return error if zip file contains a bad formatted taxonomy" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/taxonomy/import-zip")
        .withHeaders("user" -> "admin@thehive.local")
        .withBody(AnyContentAsMultipartFormData(multipartZipFile("machinetag-badformat.zip")))

      val result = app[TaxonomyCtrl].importZip(request)
      status(result) must beEqualTo(400).updateMessage(s => s"$s\n${contentAsString(result)}")
      (contentAsJson(result) \ "type").as[String] must beEqualTo("BadRequest")
      (contentAsJson(result) \ "message").as[String] must contain("formatting")
    }

    "update a taxonomies and their tags" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/taxonomy")
        .withJsonBody(Json.toJson(updateTaxo))
        .withHeaders("user" -> "admin@thehive.local")

      val result = app[TaxonomyCtrl].create(request)
      status(result) must beEqualTo(201).updateMessage(s => s"$s\n${contentAsString(result)}")

      val resultTaxo = contentAsJson(result).as[OutputTaxonomy]

      TestTaxonomy(resultTaxo) must_=== TestTaxonomy(
        "taxonomy1",
        "Updated The taxonomy 1",
        2,
        Set(
          TestTag("taxonomy1", "pred1", Some("value2"), None, "#fba800"),
          TestTag("taxonomy1", "pred1", Some("value1"), None, "#00f300")
        )
      )
    }

    "activate a taxonomy" in testApp { app =>
      val request1 = FakeRequest("GET", "/api/v1/taxonomy/taxonomy2")
        .withHeaders("user" -> "certuser@thehive.local")
      val result1 = app[TaxonomyCtrl].get("taxonomy2")(request1)
      status(result1) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(result1)}")

      val request2 = FakeRequest("PUT", "/api/v1/taxonomy/taxonomy2")
        .withHeaders("user" -> "admin@thehive.local")
      val result2 = app[TaxonomyCtrl].toggleActivation("taxonomy2", isActive = true)(request2)
      status(result2) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(result2)}")

      val request3 = FakeRequest("GET", "/api/v1/taxonomy/taxonomy2")
        .withHeaders("user" -> "certuser@thehive.local")
      val result3 = app[TaxonomyCtrl].get("taxonomy2")(request3)
      status(result3) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result3)}")
    }

    "deactivate a taxonomy" in testApp { app =>
      val request1 = FakeRequest("GET", "/api/v1/taxonomy/taxonomy1")
        .withHeaders("user" -> "certuser@thehive.local")
      val result1 = app[TaxonomyCtrl].get("taxonomy1")(request1)
      status(result1) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result1)}")

      val request2 = FakeRequest("PUT", "/api/v1/taxonomy/taxonomy1/deactivate")
        .withHeaders("user" -> "admin@thehive.local")
      val result2 = app[TaxonomyCtrl].toggleActivation("taxonomy1", isActive = false)(request2)
      status(result2) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(result2)}")

      val request3 = FakeRequest("GET", "/api/v1/taxonomy/taxonomy1")
        .withHeaders("user" -> "certuser@thehive.local")
      val result3 = app[TaxonomyCtrl].get("taxonomy1")(request3)
      status(result3) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(result3)}")
    }

    "delete a taxonomy" in testApp { app =>
      val request1 = FakeRequest("GET", "/api/v1/taxonomy/taxonomy1")
        .withHeaders("user" -> "certuser@thehive.local")
      val result1 = app[TaxonomyCtrl].get("taxonomy1")(request1)
      status(result1) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(result1)}")

      val request2 = FakeRequest("DELETE", "/api/v1/taxonomy/taxonomy1")
        .withHeaders("user" -> "admin@thehive.local")
      val result2 = app[TaxonomyCtrl].delete("taxonomy1")(request2)
      status(result2) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(result2)}")

      val request3 = FakeRequest("GET", "/api/v1/taxonomy/taxonomy1")
        .withHeaders("user" -> "certuser@thehive.local")
      val result3 = app[TaxonomyCtrl].get("taxonomy1")(request3)
      status(result3) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(result3)}")
    }

  }

  def multipartZipFile(name: String): MultipartFormData[Files.TemporaryFile] =
    // file must be place in test/resources/
    MultipartFormData(
      dataParts = Map.empty,
      files = Seq(FilePart("file", name, Option("application/zip"), FakeTemporaryFile.fromResource(s"/$name"))),
      badParts = Seq()
    )

}

```

`thehive/test/org/thp/thehive/controllers/v1/UserCtrlTest.scala`:

```scala
package org.thp.thehive.controllers.v1

import org.thp.scalligraph.auth._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v1.{InputUser, OutputUser}
import org.thp.thehive.models._
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

import scala.util.{Success, Try}

case class TestUser(login: String, name: String, profile: String, permissions: Set[String], organisation: String)

object TestUser {

  def apply(user: OutputUser): TestUser =
    TestUser(user.login, user.name, user.profile, user.permissions, user.organisation)
}

class DummyAuthSrv extends AuthSrv {
  val name: String                                                                                              = "dummy"
  override def setPassword(username: String, newPassword: String)(implicit authContext: AuthContext): Try[Unit] = Success(())
}

class UserCtrlTest extends PlaySpecification with TestAppBuilder {
  "user controller" should {

    "return current user information" in testApp { app =>
      val request = FakeRequest("GET", "/api/v1/user/current")
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[UserCtrl].current(request)
      status(result) must_=== 200
      val resultCase = contentAsJson(result).as[OutputUser]
      val expected = TestUser(
        login = "admin@thehive.local",
        name = "Default admin user",
        profile = "admin",
        permissions = Permissions.adminPermissions.asInstanceOf[Set[String]],
        organisation = Organisation.administration.name
      )

      TestUser(resultCase) must_=== expected
    }

    "create a new user" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/user")
        .withJsonBody(
          Json.toJson(
            InputUser(
              login = "test_user_1@thehive.local",
              name = "create user test",
              password = Some("azerty"),
              profile = "read-only",
              organisation = Some(Organisation.administration.name),
              avatar = None
            )
          )
        )
        .withHeaders("user" -> "admin@thehive.local")
      val result = app[UserCtrl].create(request)
      status(result) must_=== 201
      val resultCase = contentAsJson(result).as[OutputUser]
      val expected = TestUser(
        login = "test_user_1@thehive.local",
        name = "create user test",
        profile = "read-only",
        permissions = Set.empty,
        organisation = Organisation.administration.name
      )

      TestUser(resultCase) must_=== expected
    }

    "refuse to create an user if the permission doesn't contain ManageUser right" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/user")
        .withJsonBody(
          Json.toJson(
            InputUser(
              login = "test_user_3@thehive.local",
              name = "create user test",
              password = Some("azerty"),
              profile = "analyst",
              organisation = Some("cert"),
              avatar = None
            )
          )
        )
        .withHeaders("user" -> "certuser@thehive.local")
      val result = app[UserCtrl].create(request)
      status(result) must beEqualTo(403).updateMessage(s => s"$s\n${contentAsString(result)}")
    }

    "get a user in the same organisation" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v1/user/certadmin@thehive.local").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[UserCtrl].get("certadmin@thehive.local")(request)
      status(result) must_=== 200
      val resultCase = contentAsJson(result).as[OutputUser]
      val expected = TestUser(
        login = "certadmin@thehive.local",
        name = "certadmin",
        profile = Profile.orgAdmin.name,
        permissions = Set(
          Permissions.manageShare,
          Permissions.manageAnalyse,
          Permissions.manageTask,
          Permissions.manageCaseTemplate,
          Permissions.manageCase,
          Permissions.manageUser,
          Permissions.managePage,
          Permissions.manageProcedure,
          Permissions.manageObservable,
          Permissions.manageAlert,
          Permissions.manageAction,
          Permissions.manageConfig,
          Permissions.accessTheHiveFS,
          Permissions.manageTag
        ),
        organisation = "cert"
      )

      TestUser(resultCase) must_=== expected
    }

    "get a user of a visible organisation" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v1/user/socuser@thehive.local").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[UserCtrl].get("socuser@thehive.local")(request)
      status(result) must_=== 200
      val resultCase = contentAsJson(result).as[OutputUser]
      val expected = TestUser(
        login = "socuser@thehive.local",
        name = "socuser",
        profile = "analyst",
        permissions = Profile.analyst.permissions.asInstanceOf[Set[String]],
        organisation = "soc"
      )

      TestUser(resultCase) must_=== expected
    } //.pendingUntilFixed("Organisation visibility needs to be fixed")

    "refuse to get a user of an invisible organisation" in testApp { app =>
      val request = FakeRequest("GET", s"/api/v1/user/admin@thehive.local").withHeaders("user" -> "certuser@thehive.local")
      val result  = app[UserCtrl].get("admin@thehive.local")(request)
      status(result) must_=== 404
    }

    "update an user" in testApp { app =>
      val request = FakeRequest("POST", "/api/v1/user/certuser@thehive.local")
        .withJsonBody(Json.parse("""{"name": "new name", "roles": ["read"]}"""))
        .withHeaders("user" -> "certadmin@thehive.local")

      val result = app[UserCtrl].update("certuser@thehive.local")(request)
      status(result) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(result)}")
    }

    "set password" in testApp { app =>
      val requestSetPassword = FakeRequest("POST", s"/user/certuser@thehive.local/password/set")
        .withJsonBody(Json.obj("password" -> "mySecretPassword"))
        .withHeaders("user" -> "user2@thehive.local")
      val resultSetPassword = app[UserCtrl].setPassword("certuser@thehive.local")(requestSetPassword)
      status(resultSetPassword) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(resultSetPassword)}")

      val request = FakeRequest("GET", "/api/v1/login")
        .withJsonBody(Json.obj("user" -> "certuser@thehive.local", "password" -> "mySecretPassword"))
      val resultAuth = app[AuthenticationCtrl].login()(request)
      status(resultAuth) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(resultAuth)}")
    }.pendingUntilFixed("need an admin user in cert organisation")

    "change password" in pending
    "get key" in testApp { app =>
      val requestRenew = FakeRequest("POST", s"/user/user2@thehive.local/key/renew").withHeaders("user" -> "user2@thehive.local")
      val resultRenew  = app[UserCtrl].renewKey("user2@thehive.local")(requestRenew)
      status(resultRenew) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(resultRenew)}")
      val key = contentAsString(resultRenew)
      key.length must beEqualTo(32)

      val requestGet = FakeRequest("GET", s"/user/user2@thehive.local/key").withHeaders("user" -> "user2@thehive.local")
      val resultGet  = app[UserCtrl].getKey("user2@thehive.local")(requestGet)
      status(resultGet) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(resultGet)}")
      val newKey = contentAsString(resultGet)
      newKey must beEqualTo(key)
    }.pendingUntilFixed("need an admin user in cert organisation")

    "remove key" in testApp { app =>
      val requestRenew = FakeRequest("POST", s"/user/certuser@thehive.local/key/renew").withHeaders("user" -> "user2@thehive.local")
      val resultRenew  = app[UserCtrl].renewKey("certuser@thehive.local")(requestRenew)
      status(resultRenew) must beEqualTo(200).updateMessage(s => s"$s\n${contentAsString(resultRenew)}")
      val key = contentAsString(resultRenew)
      key.length must beEqualTo(32)

      val requestRemove = FakeRequest("DELETE", s"/user/certuser@thehive.local/key").withHeaders("user" -> "user2@thehive.local")
      val resultRemove  = app[UserCtrl].removeKey("certuser@thehive.local")(requestRemove)
      status(resultRemove) must beEqualTo(204).updateMessage(s => s"$s\n${contentAsString(resultRemove)}")

      val requestGet = FakeRequest("GET", s"/user/certuser@thehive.local/key").withHeaders("user" -> "user2@thehive.local")
      val resultGet  = app[UserCtrl].getKey("certuser@thehive.local")(requestGet)
      status(resultGet) must beEqualTo(404).updateMessage(s => s"$s\n${contentAsString(resultGet)}")
    }.pendingUntilFixed("need an admin user in cert organisation")

    "renew key" in pending
  }
}

```

`thehive/test/org/thp/thehive/services/AlertSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{EntityId, EntityIdOrName, EntityName}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.dto.v1.InputCustomFieldValue
import org.thp.thehive.models._
import org.thp.thehive.services.AlertOps._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.OrganisationOps._
import play.api.libs.json.JsString
import play.api.test.PlaySpecification

import java.util.Date

class AlertSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").authContext

  "alert service" should {
    "create an alert" in testApp { app =>
      val a = app[Database].tryTransaction { implicit graph =>
        val organisation = app[OrganisationSrv].getOrFail(EntityName("cert")).get
        app[AlertSrv].create(
          Alert(
            `type` = "test",
            source = "#1",
            sourceRef = "alert_creation_test",
            externalLink = Some("test.com"),
            title = "test",
            description = "test desc",
            severity = 0,
            date = new Date(),
            lastSyncDate = new Date(),
            tlp = 1,
            pap = 2,
            read = false,
            follow = false,
            organisationId = organisation._id,
            tags = Seq("tag1", "tag2"),
            caseId = EntityId.empty
          ),
          organisation,
          Set("tag1", "tag2"),
          Seq(InputCustomFieldValue("string1", Some("lol"), None)),
          Some(app[CaseTemplateSrv].getOrFail(EntityName("spam")).get)
        )
      }
      a must beSuccessfulTry.which { a =>
        a.title shouldEqual "test"
        a.source shouldEqual "#1"
        a.sourceRef shouldEqual "alert_creation_test"
        a.externalLink shouldEqual Some("test.com")
        a.description shouldEqual "test desc"
        a.severity shouldEqual 0
        a.tlp shouldEqual 1
        a.pap shouldEqual 2
      }

      app[Database].roTransaction { implicit graph =>
        app[OrganisationSrv].get(EntityName("cert")).alerts.toList must contain(a.get.alert)

        val tags = app[TagSrv].startTraversal.toSeq.filter(t => t.predicate == "tag1" || t.predicate == "tag2")

        app[AlertSrv].get(a.get.alert).tags.toSeq must containTheSameElementsAs(tags)
      }
    }

    "update tags" in testApp { app =>
      val newTags = app[Database].tryTransaction { implicit graph =>
        for {
          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref1"))
          _     <- app[AlertSrv].updateTags(alert, Set("tag3", "tag5"))
        } yield app[AlertSrv].get(EntityName("testType;testSource;ref1")).tags.toSeq
      }
      newTags must beSuccessfulTry.which(t => t.map(_.toString) must contain(exactly("tag3", "tag5")))
    }

    "update tag names" in testApp { app =>
      val tags = app[Database].tryTransaction { implicit graph =>
        for {
          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref1"))
          _     <- app[AlertSrv].updateTags(alert, Set("tag3", "tag5"))
        } yield app[AlertSrv].get(EntityName("testType;testSource;ref1")).tags.toSeq
      }
      tags must beSuccessfulTry.which(t => t.map(_.toString) must contain(exactly("tag3", "tag5")))
    }

    "add tags" in testApp { app =>
      val tags = app[Database].tryTransaction { implicit graph =>
        for {
          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref1"))
          _     <- app[AlertSrv].addTags(alert, Set("tag7"))
        } yield app[AlertSrv].get(EntityName("testType;testSource;ref1")).tags.toSeq
      }

      tags must beSuccessfulTry.which(t => t.map(_.toString) must contain(exactly("alert", "test", "tag7")))
    }

//    "add an observable if not existing" in testApp { app => // TODO clarify the expectation
//      val anObservable = Observable(
//        message = Some("if you are lost"),
//        tlp = 1,
//        ioc = false,
//        sighted = true,
//        ignoreSimilarity = None,
//        dataType = "domain",
//        tags = Seq("tag10")
//      )
//      app[Database].tryTransaction { implicit graph =>
//        for {
//          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref4"))
//          _     <- app[AlertSrv].createObservable(alert, anObservable, "perdu.com")
//        } yield ()
//      } must beASuccessfulTry
//
//      app[Database].tryTransaction { implicit graph =>
//        for {
//          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref1"))
//          _     <- app[AlertSrv].createObservable(alert, anObservable, "perdu.com")
//        } yield ()
//      } must beASuccessfulTry
//
//      app[Database].roTransaction { implicit graph =>
//        app[AlertSrv]
//          .get(EntityName("testType;testSource;ref1"))
//          .observables
//          .filterOnData("perdu.com")
//          .filterOnType("domain")
//          .tags
//          .toSeq
//          .map(_.toString)
//      } must contain("tag10")
//    }

    "update custom fields" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref1"))
          cfv   <- app[CustomFieldSrv].getOrFail(EntityName("string1"))
          _     <- app[AlertSrv].updateCustomField(alert, Seq((cfv, JsString("sad"))))
        } yield ()
      } must beSuccessfulTry

      app[Database].roTransaction { implicit graph =>
        app[AlertSrv].get(EntityName("testType;testSource;ref1")).customFields(EntityIdOrName("string1")).nameJsonValue.headOption
      } must beSome("string1" -> JsString("sad"))
    }

    "mark as read an alert" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          _     <- app[AlertSrv].markAsRead(EntityName("testType;testSource;ref1"))
          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref1"))
        } yield alert.read
      } must beASuccessfulTry(true)
    }

    "mark as unread an alert" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          _     <- app[AlertSrv].markAsUnread(EntityName("testType;testSource;ref1"))
          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref1"))
        } yield alert.read
      } must beASuccessfulTry(false)
    }

    "mark as follow an alert" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          _     <- app[AlertSrv].followAlert(EntityName("testType;testSource;ref1"))
          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref1"))
        } yield alert.follow
      } must beASuccessfulTry(true)
    }

    "mark as unfollow an alert" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          _     <- app[AlertSrv].unfollowAlert(EntityName("testType;testSource;ref1"))
          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref1"))
        } yield alert.follow
      } must beASuccessfulTry(false)
    }

    "create a case" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          alert        <- app[AlertSrv].get(EntityName("testType;testSource;ref1")).richAlert.getOrFail("Alert")
          organisation <- app[OrganisationSrv].getOrFail(EntityName("cert"))
          c            <- app[AlertSrv].createCase(alert, None, organisation)
          _ = c.title must beEqualTo("[SPAM] alert#1")
          _ <- app[CaseSrv].startTraversal.has(_.title, "[SPAM] alert#1").getOrFail("Alert")
        } yield ()
      } must beASuccessfulTry(())
    }

    "merge into an existing case" in testApp { app =>
      app[Database]
        .tryTransaction { implicit graph =>
          app[AlertSrv].mergeInCase(EntityName("testType;testSource;ref1"), EntityName("1"))
        } must beASuccessfulTry

      app[Database].roTransaction { implicit graph =>
        val observables = app[CaseSrv].get(EntityName("1")).observables.richObservable.toList
        observables must have size 1
        observables must contain { (o: RichObservable) =>
          o.data must beSome("h.fr")
          o.tags must contain("testDomain")
        }
      }
    }

    "remove totally an alert" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          alert <- app[AlertSrv].getOrFail(EntityName("testType;testSource;ref4"))
          _     <- app[AlertSrv].remove(alert)
        } yield ()
      } must beSuccessfulTry
      app[Database].roTransaction { implicit graph =>
//        app[ObservableSrv].initSteps.filterOnType("domain").filterOnData("perdu.com").exists must beFalse
        app[AlertSrv].startTraversal.get(EntityName("testType;testSource;ref4")).exists must beFalse
      }
    }
  }
}

```

`thehive/test/org/thp/thehive/services/AttachmentSrvTest.scala`:

```scala
package org.thp.thehive.services

import java.io.{File, InputStream}
import java.nio.file.{Path, Files => JFiles}
import java.util.UUID

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.FFile
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import play.api.libs.Files
import play.api.libs.Files.TemporaryFileCreator
import play.api.test.{NoTemporaryFileCreator, PlaySpecification}

import scala.annotation.tailrec

class AttachmentSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").getSystemAuthContext

  @tailrec
  private def streamCompare(is1: InputStream, is2: InputStream): Boolean = {
    val n1 = is1.read()
    val n2 = is2.read()
    if (n1 == -1 || n2 == -1) n1 == n2
    else (n1 == n2) && streamCompare(is1, is2)
  }

  "attachment service" should {
    "create an attachment from a file" in testApp { app =>
      WithFakeScalligraphFile { tempFile =>
        val r =
          app[Database].tryTransaction(implicit graph => app[AttachmentSrv].create(FFile("test.txt", tempFile.path, "text/plain")))

        r must beSuccessfulTry.which { a =>
          a.name shouldEqual "test.txt"
          a.contentType shouldEqual "text/plain"
          a.size shouldEqual JFiles.size(tempFile.path)
          a.hashes must containAllOf(app[AttachmentSrv].hashers.fromPath(tempFile.path))
        }
      }
    }

    "create an attachment from file data" in testApp { app =>
      WithFakeScalligraphFile { tempFile =>
        val r = app[Database].tryTransaction(implicit graph => app[AttachmentSrv].create("test2.txt", "text/plain", JFiles.readAllBytes(tempFile)))

        r must beSuccessfulTry.which { a =>
          a.name shouldEqual "test2.txt"
          a.contentType shouldEqual "text/plain"
          a.size shouldEqual JFiles.size(tempFile.path)
          a.hashes must containAllOf(app[AttachmentSrv].hashers.fromPath(tempFile.path))
        }
      }
    }

    "get an attachment" in testApp { app =>
      val allAttachments = app[Database].roTransaction(implicit graph => app[AttachmentSrv].startTraversal.toSeq)
      allAttachments must not(beEmpty)

      app[Database].roTransaction { implicit graph =>
        app[AttachmentSrv].get(EntityName(allAttachments.head.attachmentId)).exists must beTrue
      }
    }
  }
}

object WithFakeScalligraphFile {

  def apply[A](body: Files.TemporaryFile => A): A = {
    val tempFile = File.createTempFile("thehive-", "-test")
    JFiles.write(tempFile.toPath, s"hello ${UUID.randomUUID()}".getBytes)
    val fakeTempFile = new Files.TemporaryFile {
      override def path: Path                                 = tempFile.toPath
      override def file: File                                 = tempFile
      override def temporaryFileCreator: TemporaryFileCreator = NoTemporaryFileCreator
    }
    try body(fakeTempFile)
    finally {
      JFiles.deleteIfExists(tempFile.toPath)
      ()
    }
  }
}

```

`thehive/test/org/thp/thehive/services/AuditSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.apache.tinkerpop.gremlin.process.traversal.Order
import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import play.api.test.PlaySpecification

import java.util.Date
import scala.util.Success

class AuditSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").getSystemAuthContext

  "audit service" should {
    "get main audits by ids and sorted" in testApp { app =>
      val org = app[Database].roTransaction { implicit graph =>
        app[OrganisationSrv].getOrFail(EntityName("cert")).get
      }
      // Create 3 case events first
      val c1 = app[Database].tryTransaction { implicit graph =>
        val c = app[CaseSrv]
          .create(
            Case(
              title = "case audit",
              description = "desc audit",
              severity = 1,
              startDate = new Date(),
              endDate = None,
              flag = false,
              tlp = 1,
              pap = 1,
              status = CaseStatus.Open,
              summary = None,
              tags = Nil
            ),
            assignee = None,
            org,
            Seq.empty,
            None,
            Nil
          )
          .get
        app[CaseSrv].updateTags(c.`case`, Set("lol")).get
        Success(c)
      }.get

      app[Database].tryTransaction { implicit graph =>
        app[CaseSrv].createTask(
          c1.`case`,
          Task(
            title = "test audit",
            group = "",
            description = None,
            status = TaskStatus.Waiting,
            flag = false,
            startDate = None,
            endDate = None,
            order = 0,
            dueDate = None,
            assignee = None
          )
        )
      }
      app[Database].roTransaction { implicit graph =>
        val audits = app[AuditSrv].startTraversal.toSeq

        val r = app[AuditSrv].getMainByIds(Order.asc, audits.map(_._id): _*).toSeq

        // Only the main ones
        r.head shouldEqual audits.filter(_.mainAction).minBy(_._createdAt)
      }
    }

    "merge audits" in testApp { app =>
      val auditedTask = app[Database]
        .tryTransaction(implicit graph =>
          app[TaskSrv].create(
            Task(
              title = "test audit 1",
              group = "",
              description = None,
              status = TaskStatus.Waiting,
              flag = false,
              startDate = None,
              endDate = None,
              order = 0,
              dueDate = None,
              assignee = None
            ),
            None
          )
        )
        .get
      app[Database].tryTransaction { implicit graph =>
        app[AuditSrv].mergeAudits(app[TaskSrv].update(app[TaskSrv].get(auditedTask._id), Nil)) {
          case (taskSteps, updatedFields) =>
            taskSteps
              .clone()
              .getOrFail("Task")
              .flatMap(app[AuditSrv].task.update(_, updatedFields))
        }
      } must beSuccessfulTry
    }
  }
}

```

`thehive/test/org/thp/thehive/services/CaseNumberTest.scala`:

```scala
package org.thp.thehive.services

import akka.actor.ExtendedActorSystem
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import org.thp.thehive.TestAppBuilder
import play.api.test.PlaySpecification

class CaseNumberTest extends PlaySpecification with TestAppBuilder {

  "case number actor" should {
    "serialize and deserialize messages" in withActorSystem { system =>
      val ref = system.deadLetters[CaseNumberActor.Response]
      val sut = new CaseNumberSerializer(system.classicSystem.asInstanceOf[ExtendedActorSystem])

      val messages = Seq(
        CaseNumberActor.GetNextNumber(ref),
        CaseNumberActor.NextNumber(42),
        CaseNumberActor.NextNumber(Int.MaxValue)
      )
      val out = messages.map(message => sut.toBinary(message))

      val result = out.map(bin => sut.fromBinary(bin))

      result must beEqualTo(messages)
    }
  }

  private def withActorSystem[T](body: ActorSystem[Nothing] => T) = {
    val system = ActorSystem(Behaviors.empty, "test")
    try body(system)
    finally system.terminate()
  }
}

```

`thehive/test/org/thp/thehive/services/CaseSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.specs2.matcher.Matcher
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.controllers.FPathElem
import org.thp.scalligraph.models._
import org.thp.scalligraph.query.PropertyUpdater
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.traversal.{Graph, Traversal}
import org.thp.scalligraph.{BadRequestError, EntityName}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import org.thp.thehive.services.CaseOps._
import org.thp.thehive.services.LogOps._
import org.thp.thehive.services.ObservableOps._
import org.thp.thehive.services.ShareOps._
import org.thp.thehive.services.TaskOps._
import play.api.libs.json.Json
import play.api.test.PlaySpecification

import java.util.Date
import scala.util.Success

class CaseSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext =
    DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert", permissions = Profile.analyst.permissions).authContext

  "case service" should {

    "list all cases" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        app[CaseSrv].startTraversal.toSeq.map(_.number) must contain(allOf(1, 2, 3))
      }
    }

    "get a case without impact status" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        val richCase = app[CaseSrv].get(EntityName("1")).richCase.head
        val expected = RichCase(
          richCase._id,
          authContext.userId,
          richCase._updatedBy,
          richCase._createdAt,
          richCase._updatedAt,
          number = 1,
          title = "case#1",
          description = "description of case #1",
          severity = 2,
          startDate = new Date(1531667370000L),
          endDate = None,
          tags = richCase.tags,
          flag = false,
          tlp = 2,
          pap = 2,
          status = CaseStatus.Open,
          summary = None,
          impactStatus = None,
          resolutionStatus = None,
          assignee = Some("certuser@thehive.local"),
          Nil,
          Set(
            Permissions.manageTask,
            Permissions.manageCase,
            Permissions.manageObservable,
            Permissions.manageAlert,
            Permissions.manageAction,
            Permissions.manageAnalyse,
            Permissions.manageShare,
            Permissions.managePage,
            Permissions.manageProcedure,
            Permissions.accessTheHiveFS
          ),
          richCase.`case`.organisationIds,
          None,
          richCase.`case`.owningOrganisation
        )
        richCase must_== expected
        richCase.tags must contain(exactly("t1", "t3"))
      }
    }

    "get a case with impact status" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        val richCase = app[CaseSrv].get(EntityName("2")).richCase.head
        richCase must_== RichCase(
          richCase._id,
          authContext.userId,
          richCase._updatedBy,
          richCase._createdAt,
          richCase._updatedAt,
          number = 2,
          title = "case#2",
          description = "description of case #2",
          severity = 2,
          startDate = new Date(1531667370000L),
          endDate = None,
          tags = richCase.tags,
          flag = false,
          tlp = 2,
          pap = 2,
          status = CaseStatus.Open,
          summary = None,
          impactStatus = Some("NoImpact"),
          resolutionStatus = None,
          assignee = Some("certuser@thehive.local"),
          Nil,
          Set(
            Permissions.manageTask,
            Permissions.manageCase,
            Permissions.manageObservable,
            Permissions.manageAlert,
            Permissions.manageAction,
            Permissions.manageAnalyse,
            Permissions.manageShare,
            Permissions.managePage,
            Permissions.manageProcedure,
            Permissions.accessTheHiveFS
          ),
          richCase.`case`.organisationIds,
          None,
          richCase.`case`.owningOrganisation
        )
        richCase.tags must contain(exactly("t2", "t1"))
        richCase._createdBy must_=== "system@thehive.local"
      }
    }

    "get a case with custom fields" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        val richCase =
          app[CaseSrv].get(EntityName("3")).richCase(DummyUserSrv(userId = "socuser@thehive.local", organisation = "soc").authContext).head
        richCase.number must_=== 3
        richCase.title must_=== "case#3"
        richCase.description must_=== "description of case #3"
        richCase.severity must_=== 2
        richCase.startDate must_=== new Date(1531667370000L)
        richCase.endDate must beNone
        richCase.tags    must contain(exactly("t1", "t2"))
        richCase.flag must_=== false
        richCase.tlp must_=== 2
        richCase.pap must_=== 2
        richCase.status must_=== CaseStatus.Open
        richCase.summary      must beNone
        richCase.impactStatus must beNone
        richCase.assignee     must beSome("socuser@thehive.local")
        CustomField("boolean1", "boolean1", "boolean custom field", CustomFieldType.boolean, mandatory = false, options = Nil)
        richCase.customFields.map(f => (f.name, f.typeName, f.value)) must contain(
          allOf[(String, String, Option[Any])](
            ("boolean1", "boolean", Some(true)),
            ("string1", "string", Some("string1 custom field"))
          )
        )
      }
    }

    "add custom field with wrong type" in testApp { app =>
      app[Database].transaction { implicit graph =>
        app[CaseSrv].getOrFail(EntityName("3")) must beSuccessfulTry.which { `case`: Case with Entity =>
          app[CaseSrv].setOrCreateCustomField(`case`, EntityName("boolean1"), Some("plop"), None) must beFailedTry
        }
      }
    }

    "add custom field" in testApp { app =>
      app[Database].transaction { implicit graph =>
        app[CaseSrv].getOrFail(EntityName("3")) must beSuccessfulTry.which { `case`: Case with Entity =>
          app[CaseSrv].setOrCreateCustomField(`case`, EntityName("boolean1"), Some(true), None) must beSuccessfulTry
          app[CaseSrv].getCustomField(`case`, EntityName("boolean1")).flatMap(_.value)          must beSome.which(_ == true)
        }
      }
    }

    "update custom field" in testApp { app =>
      app[Database].transaction { implicit graph =>
        app[CaseSrv].getOrFail(EntityName("3")) must beSuccessfulTry.which { `case`: Case with Entity =>
          app[CaseSrv].setOrCreateCustomField(`case`, EntityName("boolean1"), Some(false), None) must beSuccessfulTry
          app[CaseSrv].getCustomField(`case`, EntityName("boolean1")).flatMap(_.value)           must beSome.which(_ == false)
        }
      }
    }

    "update case title" in testApp { app =>
      app[Database].transaction { implicit graph =>
        app[CaseSrv].get(EntityName("3")).update(_.title, "new title").getOrFail("Case")
        app[CaseSrv].getOrFail(EntityName("3")) must beSuccessfulTry.which { `case`: Case with Entity =>
          `case`.title must_=== "new title"
        }
      }
    }

    "get correct next case number" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        app[CaseSrv].nextCaseNumber shouldEqual 36
      }
    }

    "close a case properly" in testApp { app =>
      val updates = Seq(PropertyUpdater(FPathElem("status"), CaseStatus.Resolved) { (vertex, _, _) =>
        vertex.property("status", CaseStatus.Resolved)
        Success(Json.obj("status" -> CaseStatus.Resolved))
      })

      val r = app[Database].tryTransaction(implicit graph => app[CaseSrv].update(app[CaseSrv].get(EntityName("1")), updates))

      r must beSuccessfulTry

      val updatedCase = app[Database].roTransaction(implicit graph => app[CaseSrv].get(EntityName("1")).getOrFail("Case").get)
      updatedCase.status shouldEqual CaseStatus.Resolved
      updatedCase.endDate must beSome
    }

    "upsert case tags" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          c3 <- app[CaseSrv].get(EntityName("3")).getOrFail("Case")
          _  <- app[CaseSrv].updateTags(c3, Set("t2", "yolo"))
        } yield app[CaseSrv].get(c3).tags.toList.map(_.toString)
      } must beASuccessfulTry.which { tags =>
        tags must contain(exactly("t2", "yolo"))
      }
    }

    "add new tags and not previous ones" in testApp { app =>
      // Create a case with tags first
      val c = app[Database].tryTransaction { implicit graph =>
        val organisation = app[OrganisationSrv].getOrFail(EntityName("cert")).get
        app[CaseSrv].create(
          Case(
            title = "case 5",
            description = "desc 5",
            severity = 1,
            startDate = new Date(),
            endDate = None,
            flag = false,
            tlp = 2,
            pap = 3,
            status = CaseStatus.Open,
            summary = None,
            tags = Seq("tag1", "tag2")
          ),
          assignee = None,
          organisation,
          Seq.empty,
          None,
          Nil
        )
      }.get

      c.tags must not(beEmpty)

      val currentLen = c.tags.length

      app[Database].tryTransaction(implicit graph => app[CaseSrv].addTags(c.`case`, Set("tag1", "tag3"))) must beSuccessfulTry

      app[Database].roTransaction { implicit graph =>
        app[CaseSrv].startTraversal.has(_.title, "case 5").tags.toList.length shouldEqual currentLen + 1
      }
    }

    "add an observable if not existing" in testApp { app =>
      //      app[Database].roTransaction { implicit graph =>
      //        val c1          = app[CaseSrv].get(EntityName("1")).getOrFail("Case").get
      //        val observables = app[ObservableSrv].startTraversal.richObservable.toList
      //
      //        observables must not(beEmpty)
      //
      //        val hfr = observables.find(_.message.contains("Some weird domain")).get
      //
      //        app[Database].tryTransaction { implicit graph =>
      ////          app[CaseSrv].addObservable(c1, hfr)
      //          app[CaseSrv].createObservable(c1, hfr, hfr.data.get)
      //        }.get must throwA[CreateError]
      //
      //        val newObs = app[Database].tryTransaction { implicit graph =>
      //          val organisation = app[OrganisationSrv].current.getOrFail("Organisation").get
      //          app[ObservableSrv].create(
      //            Observable(
      //              message = Some("if you feel lost"),
      //              tlp = 1,
      //              ioc = false,
      //              sighted = true,
      //              ignoreSimilarity = None,
      //              dataType = "domain",
      //              tags = Nil,
      //              organisationIds = Seq(organisation._id),
      //              relatedId = c1._id
      //            ),
      //            "lost.com"
      //          )
      //        }.get
      //
      //        app[Database].tryTransaction { implicit graph =>
      //          app[CaseSrv].addObservable(c1, newObs)
      //        } must beSuccessfulTry
      //      }
      pending
    }

    "remove a case and its dependencies" in testApp { app =>
      val c1 = app[Database].tryTransaction { implicit graph =>
        val organisation = app[OrganisationSrv].getOrFail(EntityName("cert")).get
        app[CaseSrv].create(
          Case(
            title = "case 9",
            description = "desc 9",
            severity = 1,
            startDate = new Date(),
            endDate = None,
            flag = false,
            tlp = 2,
            pap = 3,
            status = CaseStatus.Open,
            summary = None,
            tags = Nil
          ),
          assignee = None,
          organisation,
          Seq.empty,
          None,
          Nil
        )
      }.get

      app[Database].tryTransaction(implicit graph => app[CaseSrv].delete(c1.`case`)) must beSuccessfulTry
      app[Database].roTransaction { implicit graph =>
        app[CaseSrv].get(c1._id).exists must beFalse
      }
    }

    "set or unset case impact status" in testApp { app =>
      app[Database]
        .tryTransaction { implicit graph =>
          for {
            organisation <- app[OrganisationSrv].getOrFail(EntityName("cert"))
            case0 <- app[CaseSrv].create(
              Case(
                title = "case 6",
                description = "desc 6",
                severity = 1,
                startDate = new Date(),
                endDate = None,
                flag = false,
                tlp = 2,
                pap = 3,
                status = CaseStatus.Open,
                summary = None,
                tags = Seq("tag1", "tag2")
              ),
              assignee = None,
              organisation,
              Seq.empty,
              None,
              Nil
            )

            _ = app[CaseSrv].get(case0._id).impactStatus.exists must beFalse
            _ <- app[CaseSrv].setImpactStatus(case0.`case`, "WithImpact")
            _ <- app[CaseSrv].get(case0._id).impactStatus.getOrFail("Case")
            _ <- app[CaseSrv].unsetImpactStatus(case0.`case`)
            _ = app[CaseSrv].get(case0._id).impactStatus.exists must beFalse
          } yield ()
        } must beASuccessfulTry
    }

    "set or unset case resolution status" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        val c7 = app[Database].tryTransaction { implicit graph =>
          val organisation = app[OrganisationSrv].getOrFail(EntityName("cert")).get
          app[CaseSrv].create(
            Case(
              title = "case 7",
              description = "desc 7",
              severity = 1,
              startDate = new Date(),
              endDate = None,
              flag = false,
              tlp = 2,
              pap = 3,
              status = CaseStatus.Open,
              summary = None,
              tags = Seq("tag1", "tag2")
            ),
            assignee = None,
            organisation,
            Seq.empty,
            None,
            Nil
          )
        }.get

        app[CaseSrv].get(c7._id).resolutionStatus.exists                                                          must beFalse
        app[Database].tryTransaction(implicit graph => app[CaseSrv].setResolutionStatus(c7.`case`, "Duplicated")) must beSuccessfulTry
        app[Database].roTransaction(implicit graph => app[CaseSrv].get(c7._id).resolutionStatus.exists must beTrue)
        app[Database].tryTransaction(implicit graph => app[CaseSrv].unsetResolutionStatus(c7.`case`)) must beSuccessfulTry
        app[Database].roTransaction(implicit graph => app[CaseSrv].get(c7._id).resolutionStatus.exists must beFalse)
      }
    }

    "assign/unassign a case" in testApp { app =>
      val c8 = app[Database]
        .tryTransaction { implicit graph =>
          val organisation = app[OrganisationSrv].getOrFail(EntityName("cert")).get
          val certuser     = app[UserSrv].getOrFail(EntityName("certuser@thehive.local")).get
          app[CaseSrv].create(
            Case(
              title = "case 8",
              description = "desc 8",
              severity = 2,
              startDate = new Date(),
              endDate = None,
              flag = false,
              tlp = 2,
              pap = 3,
              status = CaseStatus.Open,
              summary = None,
              tags = Seq("tag1", "tag2"),
              assignee = Some("certuser@thehive.local")
            ),
            assignee = Some(certuser),
            organisation,
            Seq.empty,
            None,
            Nil
          )
        }
        .get
        .`case`

      def checkAssignee(status: Matcher[Boolean]) =
        app[Database].roTransaction(implicit graph => app[CaseSrv].get(c8).assignee.exists must status)

      checkAssignee(beTrue)
      app[Database].tryTransaction(implicit graph => app[CaseSrv].unassign(c8)) must beSuccessfulTry
      checkAssignee(beFalse)
      app[Database].tryTransaction(implicit graph =>
        app[CaseSrv].assign(c8, app[UserSrv].get(EntityName("certuser@thehive.local")).getOrFail("Case").get)
      ) must beSuccessfulTry
      checkAssignee(beTrue)
    }

    "show only visible cases" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        app[CaseSrv].get(EntityName("3")).visible(app[OrganisationSrv]).getOrFail("Case") must beFailedTry
      }
    }

    "forbid correctly case access" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        app[CaseSrv]
          .get(EntityName("1"))
          .can(Permissions.manageCase)(DummyUserSrv(userId = "certro@thehive.local", organisation = "cert").authContext)
          .exists must beFalse
      }
    }

    "show linked cases" in testApp { app =>
      //      app[Database].roTransaction { implicit graph =>
      //        app[CaseSrv].get(EntityName("1")).linkedCases must beEmpty
      //        val observables = app[ObservableSrv].startTraversal.richObservable.toList
      //        val hfr         = observables.find(_.message.contains("Some weird domain")).get
      //
      //        app[Database].tryTransaction { implicit graph =>
      //          app[CaseSrv].addObservable(app[CaseSrv].get(EntityName("2")).getOrFail("Case").get, hfr)
      //        }
      //
      //        app[Database].roTransaction(implicit graph => app[CaseSrv].get(EntityName("1")).linkedCases must not(beEmpty))
      //      }
      pending
    }

    "merge cases, happy path with one organisation" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        def case21 = app[CaseSrv].get(EntityName("21")).clone()

        def case22 = app[CaseSrv].get(EntityName("22")).clone()

        def case23 = app[CaseSrv].get(EntityName("23")).clone()
        // Procedures
        case21.procedure.getCount must beEqualTo(1).updateMessage(s => s"$s: invalid number of procedure in case 21")
        case22.procedure.getCount must beEqualTo(2).updateMessage(s => s"$s: invalid number of procedure in case 22")
        case23.procedure.getCount must beEqualTo(0).updateMessage(s => s"$s: invalid number of procedure in case 23")
        // CustomFields
        case21.customFields.getCount must beEqualTo(0).updateMessage(s => s"$s: invalid number of custom fields in case 21")
        case22.customFields.getCount must beEqualTo(1).updateMessage(s => s"$s: invalid number of custom fields in case 22")
        case23.customFields.getCount must beEqualTo(1).updateMessage(s => s"$s: invalid number of custom fields in case 23")
        // Tasks
        case21.tasks.getCount must beEqualTo(2).updateMessage(s => s"$s: invalid number of tasks in case 21")
        case22.tasks.getCount must beEqualTo(0).updateMessage(s => s"$s: invalid number of tasks in case 22")
        case23.tasks.getCount must beEqualTo(1).updateMessage(s => s"$s: invalid number of tasks in case 23")
        // Observables
        case21.observables.getCount must beEqualTo(1).updateMessage(s => s"$s: invalid number of observables in case 21")
        case22.observables.getCount must beEqualTo(0).updateMessage(s => s"$s: invalid number of observables in case 22")
        case23.observables.getCount must beEqualTo(2).updateMessage(s => s"$s: invalid number of observables in case 23")
        // Alerts
        case21.alert.getCount must beEqualTo(1).updateMessage(s => s"$s: invalid number of alert in case 21")
        case22.alert.getCount must beEqualTo(0).updateMessage(s => s"$s: invalid number of alert in case 22")
        case23.alert.getCount must beEqualTo(0).updateMessage(s => s"$s: invalid number of alert in case 23")

        for {
          c21     <- case21.getOrFail("Case")
          c22     <- case22.getOrFail("Case")
          c23     <- case23.getOrFail("Case")
          newCase <- app[CaseSrv].merge(Seq(c21, c22, c23))
        } yield newCase
      } must beASuccessfulTry.which { richCase =>
        app[Database].roTransaction { implicit graph =>
          def mergedCase = app[CaseSrv].get(EntityName(richCase.number.toString)).clone()

          mergedCase.procedure.getCount    must beEqualTo(3).updateMessage(s => s"$s: invalid number of procedure in merged case")
          mergedCase.customFields.getCount must beEqualTo(2).updateMessage(s => s"$s: invalid number of customFields in merged case")
          mergedCase.tasks.getCount        must beEqualTo(3).updateMessage(s => s"$s: invalid number of tasks in merged case")
          mergedCase.observables.getCount  must beEqualTo(3).updateMessage(s => s"$s: invalid number of observables in merged case")
          mergedCase.alert.getCount        must beEqualTo(1).updateMessage(s => s"$s: invalid number of alert in merged case")

          app[CaseSrv].get(EntityName("21")).getOrFail("Case") must beAFailedTry.updateMessage(s => s"$s: case 21 is not removed")
          app[CaseSrv].get(EntityName("22")).getOrFail("Case") must beAFailedTry.updateMessage(s => s"$s: case 22 is not removed")
          app[CaseSrv].get(EntityName("23")).getOrFail("Case") must beAFailedTry.updateMessage(s => s"$s: case 23 is not removed")
        }
      }
    }

    "refuse to merge cases with different shares" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        val case21 = app[CaseSrv].getOrFail(EntityName("21")).get
        val case24 = app[CaseSrv].getOrFail(EntityName("24")).get
        val case26 = app[CaseSrv].getOrFail(EntityName("26")).get
        app[CaseSrv].merge(Seq(case21, case24, case26))
      } must beFailedTry.withThrowable[BadRequestError]
    }

    "merge cases, happy path with three organisations" in testApp { app =>
      implicit val authContext: AuthContext =
        DummyUserSrv(organisation = "soc", permissions = Profile.analyst.permissions).authContext

      def getCase(number: Int)(implicit graph: Graph): Traversal.V[Case] = app[CaseSrv].getByName(number.toString)

      app[Database].tryTransaction { implicit graph =>
        // Tasks
        getCase(24).share(EntityName("cert")).tasks.getCount mustEqual 1
        getCase(24).share(EntityName("soc")).tasks.getCount mustEqual 2
        getCase(25).share(EntityName("cert")).tasks.getCount mustEqual 0
        getCase(25).share(EntityName("soc")).tasks.getCount mustEqual 0

        // Observables
        getCase(24).share(EntityName("cert")).observables.getCount mustEqual 0
        getCase(24).share(EntityName("soc")).observables.getCount mustEqual 0
        getCase(25).share(EntityName("cert")).observables.getCount mustEqual 2
        getCase(25).share(EntityName("soc")).observables.getCount mustEqual 1

        for {
          c24     <- getCase(24).getOrFail("Case")
          c25     <- getCase(25).getOrFail("Case")
          newCase <- app[CaseSrv].merge(Seq(c24, c25))
        } yield newCase
      } must beASuccessfulTry.which { richCase =>
        app[Database].roTransaction { implicit graph =>
          getCase(richCase.number).share(EntityName("cert")).tasks.getCount mustEqual 1
          getCase(richCase.number).share(EntityName("soc")).tasks.getCount mustEqual 2
          getCase(richCase.number).share(EntityName("cert")).observables.getCount mustEqual 2
          getCase(richCase.number).share(EntityName("soc")).observables.getCount mustEqual 1

          getCase(24).getOrFail("Case") must beAFailedTry
          getCase(25).getOrFail("Case") must beAFailedTry
        }
      }
    }

    "cascade remove, case not shared" in testApp { app =>
      app[Database].transaction { implicit graph =>
        implicit val authContext: AuthContext = DummyUserSrv(organisation = "cert", permissions = Set(Permissions.manageCase)).authContext

        def caze = app[CaseSrv].startTraversal.has(_.number, 35).getOrFail("Case")
        caze must beSuccessfulTry

        def taskTraversal = app[TaskSrv].startTraversal.has(_.title, "task-cascade-remove-simple")
        def taskDelete    = taskTraversal.getOrFail("Task")
        def logs          = taskTraversal.logs.toSeq.size
        def logsAttach    = taskTraversal.logs.attachments.toSeq.size
        taskDelete must beSuccessfulTry
        logs       must beEqualTo(1)
        logsAttach must beEqualTo(1)

        def obsTraversal = app[ObservableSrv].startTraversal.has(_.message, "obs-cascade-remove-simple")
        def obsDelete    = obsTraversal.getOrFail("Observable")
        def obsAttach    = obsTraversal.attachments.toSeq.size
        obsDelete must beSuccessfulTry
        obsAttach must beEqualTo(1)

        app[CaseSrv].delete(caze.get) must beASuccessfulTry

        taskDelete must beAFailedTry
        logs       must beEqualTo(0)
        logsAttach must beEqualTo(0)
        obsDelete  must beAFailedTry
        obsAttach  must beEqualTo(0)
        caze       must beAFailedTry
      }
    }

    "cascade remove, shared" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        // Check users of soc have access to case 4
        implicit val authContext: AuthContext = DummyUserSrv(organisation = "soc", permissions = Set(Permissions.manageCase)).authContext

        app[CaseSrv]
          .startTraversal
          .has(_.number, 34)
          .getOrFail("Case") must beSuccessfulTry

        app[TaskSrv]
          .startTraversal
          .has(_.title, "task-cascade-remove-unshare")
          .getOrFail("Task") must beSuccessfulTry

        app[ObservableSrv]
          .startTraversal
          .has(_.message, "obs-cascade-remove-unshare")
          .getOrFail("Observable") must beSuccessfulTry
      }

      app[Database].transaction { implicit graph =>
        // Check entities & cascade remove the case
        implicit val authContext: AuthContext = DummyUserSrv(organisation = "cert", permissions = Set(Permissions.manageCase)).authContext

        def caze = app[CaseSrv].startTraversal.has(_.number, 34).getOrFail("Case")
        caze must beSuccessfulTry

        def taskTraversal  = app[TaskSrv].startTraversal.has(_.title, "task-cascade-remove-delete")
        def taskTraversal2 = app[TaskSrv].startTraversal.has(_.title, "task-cascade-remove-unshare")
        def taskDelete     = taskTraversal.getOrFail("Task")
        def taskUnshare    = taskTraversal2.getOrFail("Task")
        def logs           = taskTraversal.logs.toSeq.size
        def logs2          = taskTraversal2.logs.toSeq.size
        def taskAttach     = taskTraversal.logs.attachments.toSeq.size
        def taskAttach2    = taskTraversal2.logs.attachments.toSeq.size
        taskDelete  must beSuccessfulTry
        logs        must beEqualTo(1)
        taskAttach  must beEqualTo(1)
        taskUnshare must beSuccessfulTry
        logs2       must beEqualTo(0)
        taskAttach2 must beEqualTo(0)

        def obsTraversal  = app[ObservableSrv].startTraversal.has(_.message, "obs-cascade-remove-delete")
        def obsTraversal2 = app[ObservableSrv].startTraversal.has(_.message, "obs-cascade-remove-unshare")
        def obsDelete     = obsTraversal.getOrFail("Observable")
        def obsUnshare    = obsTraversal2.getOrFail("Observable")
        def obsAttach     = obsTraversal.attachments.toSeq.size
        def obsAttach2    = obsTraversal2.attachments.toSeq.size
        obsDelete  must beSuccessfulTry
        obsAttach  must beEqualTo(1)
        obsUnshare must beSuccessfulTry
        obsAttach2 must beEqualTo(0)

        app[CaseSrv].delete(caze.get) must beASuccessfulTry

        caze        must beASuccessfulTry
        taskDelete  must beAFailedTry
        taskUnshare must beASuccessfulTry
        logs        must beEqualTo(0)
        taskAttach  must beEqualTo(0)
        logs2       must beEqualTo(0)
        taskAttach2 must beEqualTo(0)
        obsDelete   must beAFailedTry
        obsUnshare  must beASuccessfulTry
        obsAttach   must beEqualTo(0)
        obsAttach2  must beEqualTo(0)
      }

      app[Database].roTransaction { implicit graph =>
        // Users of soc should still have access to case
        implicit val authContext: AuthContext = DummyUserSrv(organisation = "soc", permissions = Set(Permissions.manageCase)).authContext

        app[CaseSrv]
          .startTraversal
          .has(_.number, 4)
          .getOrFail("Case") must beSuccessfulTry

        app[TaskSrv]
          .startTraversal
          .has(_.title, "task-cascade-remove-unshare")
          .getOrFail("Task") must beSuccessfulTry

        app[ObservableSrv]
          .startTraversal
          .has(_.message, "obs-cascade-remove-unshare")
          .getOrFail("Observable") must beSuccessfulTry
      }
    }.pendingUntilFixed

  }
}

```

`thehive/test/org/thp/thehive/services/CaseTemplateSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import org.thp.thehive.services.CaseTemplateOps._
import org.thp.thehive.services.TagOps._
import play.api.libs.json.{JsNumber, JsString, JsTrue, JsValue}
import play.api.test.PlaySpecification

class CaseTemplateSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authcontext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").authContext

  "case template service" should {
    "create a case template" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        app[CaseTemplateSrv].create(
          caseTemplate = CaseTemplate(
            name = "case template test 1",
            displayName = "case template test 1",
            titlePrefix = Some("[CTT]"),
            description = Some("description ctt1"),
            severity = Some(2),
            tags = Seq("""t2""", """newOne"""),
            flag = false,
            tlp = Some(1),
            pap = Some(3),
            summary = Some("summary case template test 1")
          ),
          organisation = app[OrganisationSrv].getOrFail(EntityName("cert")).get,
          tasks = Seq(
            Task(
              title = "task case template case template test 1",
              group = "group1",
              description = None,
              status = TaskStatus.Waiting,
              flag = false,
              startDate = None,
              endDate = None,
              order = 0,
              dueDate = None,
              assignee = None
            )
          ),
          customFields = Seq(("string1", Some("love")), ("boolean1", Some(false)))
        )
      } must beASuccessfulTry

      app[Database].roTransaction { implicit graph =>
        val orgId = app[OrganisationSrv].currentId.value
        app[TagSrv].startTraversal.getByName(s"_freetags_$orgId", "newOne", None).exists           must beTrue
        app[TaskSrv].startTraversal.has(_.title, "task case template case template test 1").exists must beTrue
        val richCT = app[CaseTemplateSrv].startTraversal.getByName("case template test 1").richCaseTemplate.getOrFail("CaseTemplate").get
        richCT.customFields.length shouldEqual 2
      }
    }

    "add a task to a template" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          caseTemplate <- app[CaseTemplateSrv].getOrFail(EntityName("spam"))
          _ <- app[CaseTemplateSrv].createTask(
            caseTemplate,
            Task(
              title = "t1",
              group = "default",
              description = None,
              status = TaskStatus.Waiting,
              flag = false,
              startDate = None,
              endDate = None,
              order = 1,
              dueDate = None,
              assignee = None
            )
          )
        } yield ()
      } must beSuccessfulTry

      app[Database].roTransaction { implicit graph =>
        app[CaseTemplateSrv].get(EntityName("spam")).tasks.has(_.title, "t1").exists
      } must beTrue
    }

    "update case template tags" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          caseTemplate <- app[CaseTemplateSrv].getOrFail(EntityName("spam"))
          _ <- app[CaseTemplateSrv].updateTags(
            caseTemplate,
            Set("""t2""", """newOne2""", """newNspc:newPred="newOne3"""")
          )
        } yield ()
      } must beSuccessfulTry
      app[Database].roTransaction { implicit graph =>
        app[CaseTemplateSrv].get(EntityName("spam")).tags.toList.map(_.toString)
      } must containTheSameElementsAs(
        Seq("t2", "newOne2", "newNspc:newPred=\"newOne3\"")
      )
    }

    "add tags to a case template" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          caseTemplate <- app[CaseTemplateSrv].getOrFail(EntityName("spam"))
          _            <- app[CaseTemplateSrv].addTags(caseTemplate, Set("""t2""", """newOne2"""))
        } yield ()
      } must beSuccessfulTry
      app[Database].roTransaction { implicit graph =>
        app[CaseTemplateSrv].get(EntityName("spam")).tags.toList.map(_.toString)
      } must containTheSameElementsAs(
        Seq(
          "t2",
          "newOne2",
          "spam",
          "src:mail"
        )
      )
    }

    "update/create case template custom fields" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          string1      <- app[CustomFieldSrv].getOrFail(EntityName("string1"))
          bool1        <- app[CustomFieldSrv].getOrFail(EntityName("boolean1"))
          integer1     <- app[CustomFieldSrv].getOrFail(EntityName("integer1"))
          caseTemplate <- app[CaseTemplateSrv].getOrFail(EntityName("spam"))
          _ <- app[CaseTemplateSrv].updateCustomField(
            caseTemplate,
            Seq((string1, JsString("hate"), None), (bool1, JsTrue, None), (integer1, JsNumber(1), None))
          )
        } yield ()
      } must beSuccessfulTry

      val expected: Seq[(String, JsValue)] = Seq("string1" -> JsString("hate"), "boolean1" -> JsTrue, "integer1" -> JsNumber(1))
      app[Database].roTransaction { implicit graph =>
        app[CaseTemplateSrv].get(EntityName("spam")).customFields.nameJsonValue.toSeq
      } must contain(exactly(expected: _*))
    }
  }
}

```

`thehive/test/org/thp/thehive/services/ConfigSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.thehive.TestAppBuilder
import play.api.libs.json.{JsBoolean, JsString}
import play.api.test.PlaySpecification

class ConfigSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").authContext

  "config service" should {
    "set/get values" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        app[ConfigSrv].organisation.setConfigValue(EntityName("cert"), "test", JsBoolean(true))
        app[ConfigSrv].user.setConfigValue(EntityName("certuser@thehive.local"), "test2", JsString("lol"))
      }

      app[Database].roTransaction { implicit graph =>
        app[ConfigSrv].organisation.getConfigValue(EntityName("cert"), "test") must beSome.which(c => c.value.as[Boolean] must beTrue)
        app[ConfigSrv].user.getConfigValue(EntityName("certuser@thehive.local"), "test2") must beSome.which(c => c.value.as[String] shouldEqual "lol")
      }
    }
  }
}

```

`thehive/test/org/thp/thehive/services/CustomFieldSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import play.api.libs.json._
import play.api.test.PlaySpecification

class CustomFieldSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").authContext

  "custom field service" should {
    "create a custom field" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        app[CustomFieldSrv].create(
          CustomField(
            "cf 1",
            "displayed cf 1",
            "desc cf 1",
            CustomFieldType.boolean,
            mandatory = false,
            Seq(JsBoolean(true))
          )
        )
      } must beSuccessfulTry.which { cf =>
        cf.name shouldEqual "cf 1"
        cf.displayName shouldEqual "displayed cf 1"
        cf.description shouldEqual "desc cf 1"
        cf.options shouldEqual Seq(JsBoolean(true))
      }

      "delete custom fields" in testApp { app =>
        app[Database].tryTransaction { implicit graph =>
          for {
            cf <- app[CustomFieldSrv].getOrFail(EntityName("boolean1"))
            _  <- app[CustomFieldSrv].delete(cf, force = true)
          } yield ()
        } must beSuccessfulTry
      }

      "count use of custom fields" in testApp { app =>
        app[Database].roTransaction { implicit graph =>
          app[CustomFieldSrv].useCount(app[CustomFieldSrv].getOrFail(EntityName("boolean1")).get)
        } shouldEqual Map("Case" -> 1, "CaseTemplate" -> 1)
      }
    }
  }
}

```

`thehive/test/org/thp/thehive/services/DashboardSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import org.thp.thehive.services.DashboardOps._
import play.api.libs.json.{JsObject, Json}
import play.api.test.PlaySpecification

class DashboardSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").authContext

  s" dashboard service" should {
    "create dashboards" in testApp { app =>
      val definition =
        Json
          .parse("""{
             "period":"custom",
             "items":[
                {
                   "type":"container",
                   "items":[
                      {
                         "type":"line",
                         "options":{
                            "title":"cases",
                            "entity":"case",
                            "field":"createdAt",
                            "interval":"1d",
                            "query":{

                            },
                            "series":[
                               {
                                  "agg":"count",
                                  "field":null,
                                  "type":"line",
                                  "label":"cases"
                               }
                            ]
                         },
                         "id":"37741393-eecc-16c9-f5b8-f0e668b403eb"
                      }
                   ]
                }
             ],
             "customPeriod":{
                "fromDate":"2019-07-08T22:00:00.000Z",
                "toDate":"2019-11-27T23:00:00.000Z"
             }
          }""")
          .as[JsObject]
      app[Database].tryTransaction { implicit graph =>
        app[DashboardSrv].create(Dashboard("dashboard test 1", "desc dashboard test 1", definition))
      } must beASuccessfulTry.which { d =>
        d.title shouldEqual "dashboard test 1"
        d.organisationShares must beEmpty
        d.definition shouldEqual definition
      }
    }

    "share a dashboard" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          dashboard <- app[DashboardSrv].startTraversal.has(_.title, "dashboard soc").getOrFail("Dashboard")
          _ = app[DashboardSrv].get(dashboard).visible.headOption must beNone
          _ <- app[DashboardSrv].share(dashboard, EntityName("cert"), writable = false)
          _ = app[DashboardSrv].get(dashboard).visible.headOption must beSome
        } yield ()
      } must beASuccessfulTry
    }
//    "update dashboard share status" in testApp { app =>
//      app[Database].tryTransaction { implicit graph =>
//        for {
//          dashboard <- app[DashboardSrv].initSteps.has("title", "dashboard-cert").getOrFail()
//          _         <- app[DashboardSrv].shareUpdate(dashboard, status = true)
//        } yield ()
//      } must beSuccessfulTry
//    }

    "remove a dashboard" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          dashboard <- app[DashboardSrv].startTraversal.has(_.title, "dashboard soc").getOrFail("Dashboard")
          _         <- app[DashboardSrv].remove(dashboard)
        } yield app[DashboardSrv].startTraversal.has(_.title, "dashboard soc").exists
      } must beASuccessfulTry(false)
    }
  }
}

```

`thehive/test/org/thp/thehive/services/DataSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import org.thp.thehive.services.DataOps._
import play.api.test.PlaySpecification

class DataSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").authContext

  "data service" should {
    "create not existing data" in testApp { app =>
      val existingData = app[Database].roTransaction(implicit graph => app[DataSrv].startTraversal.getByData("h.fr").getOrFail("Data")).get
      val newData      = app[Database].tryTransaction(implicit graph => app[DataSrv].create(existingData))
      newData must beSuccessfulTry.which(data => data._id shouldEqual existingData._id)
    }

    "get related observables" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        app[ObservableSrv].create(
          Observable(
            message = Some("love"),
            tlp = 1,
            ioc = false,
            sighted = true,
            ignoreSimilarity = None,
            dataType = "domain",
            tags = Seq("tagX")
          ),
          "love.com"
        )
      }

      app[Database].roTransaction(implicit graph => app[DataSrv].startTraversal.getByData("love.com").observables.exists must beTrue)
    }
  }
}

```

`thehive/test/org/thp/thehive/services/ImpactStatusSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.models._
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import org.thp.thehive.services.ImpactStatusOps._
import play.api.test.PlaySpecification

class ImpactStatusSrvTest extends PlaySpecification with TestAppBuilder {
  "impact status service" should {
    "get values" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        app[ImpactStatusSrv].startTraversal.toSeq must containTheSameElementsAs(
          Seq(
            ImpactStatus("NoImpact"),
            ImpactStatus("WithImpact"),
            ImpactStatus("NotApplicable")
          )
        )

        app[ImpactStatusSrv].startTraversal.getByName("NoImpact").exists must beTrue
      }
    }
  }
}

```

`thehive/test/org/thp/thehive/services/LocalPasswordAuthSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.models.Database
import org.thp.thehive.TestAppBuilder
import play.api.Configuration
import play.api.libs.json.Json
import play.api.test.{FakeRequest, PlaySpecification}

class LocalPasswordAuthSrvTest extends PlaySpecification with TestAppBuilder {
  "localPasswordAuth service" should {
    "be able to verify passwords" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        val certuser             = app[UserSrv].getOrFail(EntityName("certuser@thehive.local")).get
        val localPasswordAuthSrv = app[LocalPasswordAuthProvider].apply(app[Configuration]).get.asInstanceOf[LocalPasswordAuthSrv]
        val request = FakeRequest("POST", "/api/v0/login")
          .withJsonBody(
            Json.parse("""{"user": "certuser@thehive.local", "password": "my-secret-password"}""")
          )

        localPasswordAuthSrv.authenticate(certuser.login, "my-secret-password", None, None)(request) must beSuccessfulTry
      }
    }
  }
}

```

`thehive/test/org/thp/thehive/services/ObservableSrvTest.scala`:

```scala
//package org.thp.thehive.services
//
//import org.thp.scalligraph.RichSeq
//import org.thp.scalligraph.auth.AuthContext
//import org.thp.scalligraph.models.{Database, DummyUserSrv}
//import org.thp.thehive.TestAppBuilder
//import org.thp.thehive.models._
//import play.api.test.PlaySpecification
//
//class ObservableSrvTest extends PlaySpecification with TestAppBuilder {
//  implicit val authContext: AuthContext = DummyUserSrv(userId = "admin@thehive.local").authContext
//
//  def printTiming[A](message: String)(body: => A): A = {
//    val start = System.currentTimeMillis()
//    val ret   = body
//    val time  = System.currentTimeMillis() - start
//    println(s"$message: $time ms")
//    ret
//  }
//
//  "observable service" should {
//    "create observable" in testApp { app =>
//      val observable        = Observable(Some("test observable message"), 2, ioc = false, sighted = false)
//      val observableSrv     = app[ObservableSrv]
//      val observableTypeSrv = app[ObservableTypeSrv]
//      val dataSrv           = app[DataSrv]
//      val tagNames          = Set("t1", "t2", "t3")
//
//      (1 to 100).map(i => s"data$i").toTry { dataValue =>
//        println("====================================")
//        printTiming("transaction") {
//          app[Database].tryTransaction { implicit graph =>
//            printTiming("createObservable") {
//              for {
//                createdObservable <- printTiming("createEntity")(observableSrv.createEntity(observable))
//                tpe               <- printTiming("getType")(observableTypeSrv.getOrFail("domain"))
//                _                 <- printTiming("linkType")(observableSrv.observableObservableType.create(ObservableObservableType(), createdObservable, tpe))
//                data              <- printTiming("createData")(dataSrv.create(Data(dataValue)))
//                _                 <- printTiming("linkData")(observableSrv.observableDataSrv.create(ObservableData(), createdObservable, data))
//                tags              <- printTiming("createTags")(observableSrv.addTags(createdObservable, tagNames))
//                //          ext               <- observableSrv.addExtensions(createdObservable, extensions)
//              } yield RichObservable(createdObservable, tpe, Some(data), None, tags, None, Nil, Nil)
//            }
//          }
//        }
//      } must beSuccessfulTry
//    }
//  }
//}
///*
//observableType <- observableTypeSrv.getOrFail(inputObservable.`type`)
//case Left(data) => observableSrv.create(inputObservable.observable, observableType, data, inputObservable.tags, Nil)
//        }
//        case0 <- caseSrv.getOrFail(caseId)
//        orgs  <- inputObservable.organisations.toTry(organisationSrv.getOrFail)
//        _     <- orgs.toTry(o => shareSrv.shareObservable(richObservable, case0, o))
// */

```

`thehive/test/org/thp/thehive/services/OrganisationSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import play.api.test.PlaySpecification

class OrganisationSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "admin@thehive.local").authContext

  "organisation service" should {
    "create an organisation" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        app[OrganisationSrv].create(Organisation(name = "orga1", "no description"))
      } must beSuccessfulTry
    }

    "get an organisation by its name" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        app[OrganisationSrv].getOrFail(EntityName("cert"))
      } must beSuccessfulTry
    }
  }
}

```

`thehive/test/org/thp/thehive/services/TagSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models.Profile
import play.api.test.PlaySpecification

import scala.util.Success

class TagSrvTest extends PlaySpecification with TestAppBuilder {

  implicit val authContext: AuthContext =
    DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert", permissions = Profile.analyst.permissions).authContext

  "tag service" should {
    "fromString" should {
      "be parsed from namespace:predicate" in testApp { app =>
        app[TagSrv].fromString("namespace:predicate") must beEqualTo(Some(("namespace", "predicate", None)))
      }

      "be parsed from namespace:predicate=" in testApp { app =>
        app[TagSrv].fromString("namespace:predicate=") must beEqualTo(None)
      }

      "be parsed from namespace: predicate" in testApp { app =>
        app[TagSrv].fromString("namespace: predicate") must beEqualTo(Some(("namespace", "predicate", None)))
      }

      "be parsed from namespace:predicate=value" in testApp { app =>
        app[TagSrv].fromString("namespace:predicate=value") must beEqualTo(Some(("namespace", "predicate", Some("value"))))
      }
    }

    "getOrCreate" should {
      "get a tag from a taxonomy" in testApp { app =>
        // TODO add tags property in Taxonomy.json to test get
        app[Database].transaction { implicit graph =>
          val tag = app[TagSrv].getOrCreate("taxonomy1:pred1=value1")
          tag.map(_.toString) must beEqualTo(Success("taxonomy1:pred1=\"value1\""))
        }
      }

      "get a _freetag tag" in testApp { app =>
        app[Database].transaction { implicit graph =>
          val orgId = app[OrganisationSrv].currentId.value
          val tag   = app[TagSrv].getOrCreate("afreetag")
          tag.map(_.namespace) must beEqualTo(Success(s"_freetags_$orgId"))
          tag.map(_.predicate) must beEqualTo(Success("afreetag"))
          tag.map(_.predicate) must beEqualTo(Success("afreetag"))
          tag.map(_.colour)    must beEqualTo(Success(app[TagSrv].freeTagColour))
        }
      }
    }

  }
}

```

`thehive/test/org/thp/thehive/services/TaskSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.scalligraph.traversal.TraversalOps.TraversalOpsDefs
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.services.TaskOps._
import play.api.test.PlaySpecification

class TaskSrvTest extends PlaySpecification with TestAppBuilder {
  "task service" should {

    "set actionRequired for an organisation" in testApp { app =>
      app[Database].transaction { implicit graph =>
        implicit val authContext: AuthContext = DummyUserSrv(organisation = "cert").authContext

        val task = app[TaskSrv].startTraversal.has(_.title, "taskActionRequired1").getOrFail("Task").get
        val cert = app[OrganisationSrv].startTraversal.has(_.name, "cert").getOrFail("Organisation").get
        def getActionRequired = app[TaskSrv].get(task).actionRequired.toSeq.head
        def getActionRequiredMap = app[TaskSrv].get(task).actionRequiredMap.toSeq.toMap

        getActionRequired must beEqualTo(false)
        getActionRequiredMap must beEqualTo(Map("soc" -> false, "cert" -> false))

        app[TaskSrv].actionRequired(task, cert, actionRequired = true)

        getActionRequired must beEqualTo(true)
        getActionRequiredMap must beEqualTo(Map("soc" -> false, "cert" -> true))
      }
    }

    "unset actionRequired for an organisation" in testApp { app =>
      app[Database].transaction { implicit graph =>
        implicit val authContext: AuthContext = DummyUserSrv(organisation = "cert").authContext

        val task = app[TaskSrv].startTraversal.has(_.title, "taskActionRequired2").getOrFail("Task").get
        val cert = app[OrganisationSrv].startTraversal.has(_.name, "cert").getOrFail("Organisation").get
        def getActionRequired = app[TaskSrv].get(task).actionRequired.toSeq.head
        def getActionRequiredMap = app[TaskSrv].get(task).actionRequiredMap.toSeq.toMap

        getActionRequired must beEqualTo(true)
        getActionRequiredMap must beEqualTo(Map("soc" -> false, "cert" -> true))

        app[TaskSrv].actionRequired(task, cert, actionRequired = false)

        getActionRequired must beEqualTo(false)
        getActionRequiredMap must beEqualTo(Map("soc" -> false, "cert" -> false))
      }
    }

  }

}

```

`thehive/test/org/thp/thehive/services/UserSrvTest.scala`:

```scala
package org.thp.thehive.services

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.scalligraph.services.KillSwitch
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.models._
import org.thp.thehive.services.OrganisationOps._
import org.thp.thehive.services.UserOps._
import play.api.test.PlaySpecification

import scala.concurrent.duration.DurationInt
import scala.util.{Failure, Success}

class UserSrvTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "admin@thehive.local").getSystemAuthContext

  "user service" should {

    "create and get an user by his id" in testApp { app =>
      app[Database].transaction { implicit graph =>
        app[UserSrv].createEntity(
          User(
            login = "getByIdTest",
            name = "test user (getById)",
            apikey = None,
            locked = false,
            password = None,
            totpSecret = None,
            failedAttempts = None,
            lastFailed = None
          )
        ) must beSuccessfulTry
          .which { user =>
            app[UserSrv].getOrFail(user._id) must beSuccessfulTry(user)
          }
      }
    }

    "create and get an user by his login" in testApp { app =>
      app[Database].transaction { implicit graph =>
        app[UserSrv].createEntity(
          User(
            login = "getbylogintest@thehive.local",
            name = "test user (getByLogin)",
            apikey = None,
            locked = false,
            password = None,
            totpSecret = None,
            failedAttempts = None,
            lastFailed = None
          )
        ) must beSuccessfulTry
          .which { user =>
            app[UserSrv].getOrFail(user._id) must beSuccessfulTry(user)
          }
      }
    }

    "deduplicate users in an organisation" in testApp { app =>
      implicit val db: Database = app[Database]
      val userSrv               = app[UserSrv]
      val organisationSrv       = app[OrganisationSrv]
      val profileSrv            = app[ProfileSrv]
      val roleSrv               = app[RoleSrv]
      db.tryTransaction { implicit graph =>
        val certadmin = userSrv.get(EntityName("certadmin@thehive.local")).head
        val cert      = organisationSrv.get(EntityName("cert")).head
        val analyst   = profileSrv.get(EntityName("analyst")).head
        roleSrv.create(certadmin, cert, analyst).get
        val userCount = userSrv.get(EntityName("certadmin@thehive.local")).organisations.get(EntityName("cert")).getCount
        if (userCount == 2) Success(())
        else Failure(new Exception(s"User certadmin is not in cert organisation twice ($userCount)"))
      }
      new UserIntegrityCheck(db, userSrv, profileSrv, organisationSrv, roleSrv).runGlobalCheck(5.minutes, KillSwitch.alwaysOn)
      db.roTransaction { implicit graph =>
        val userCount = userSrv.get(EntityName("certadmin@thehive.local")).organisations.get(EntityName("cert")).getCount
        userCount must beEqualTo(1)
      }
    }
  }
}

```

`thehive/test/org/thp/thehive/services/notification/notifiers/NotificationTemplateTest.scala`:

```scala
package org.thp.thehive.services.notification.notifiers

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv, Schema}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.services.{AuditSrv, CaseSrv, UserSrv}
import play.api.test.PlaySpecification

import java.util.{HashMap => JHashMap}
import scala.collection.JavaConverters._

class NotificationTemplateTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "certuser@thehive.local", organisation = "cert").authContext
  def templateEngine(testSchema: Schema): Template =
    new Object with Template {
      override val schema: Schema = testSchema
    }

  "template engine" should {
    "format message" in testApp { app =>
      val template =
        """Dear {{user.name}},
          |you have a new notification:
          |
          |The {{audit.objectType}} {{audit.objectId}} has been {{audit.action}}d by {{audit._createdBy}}
          |
          |{{#with object~}}
          |{{#if (eq _type "Case")}}
          |{{~title}}
          |{{else}}
          |{{~_type}} is not a case
          |{{/if}}
          |{{~/with}}
          |
          |Audit ({{audit.requestId}}): {{audit.action}} {{audit.objectType}} {{audit.objectId}} by {{audit._createdBy}}
          |Context {{context._id}}""".stripMargin

      val model = new JHashMap[String, AnyRef]
      model.put(
        "audit",
        Map(
          "objectType" -> "Case",
          "objectId"   -> "2231",
          "action"     -> "create",
          "_createdBy" -> "admin@thehive.local",
          "requestId"  -> "testRequest"
        ).asJava
      )
      model.put("object", Map("_type" -> "Case", "title" -> "case title").asJava)
      model.put("user", Map("name" -> "Thomas").asJava)
      model.put("context", Map("_id" -> "2231").asJava)
      val message = templateEngine(app[Schema]).handlebars.compileInline(template).apply(model)
      message must beEqualTo("""Dear Thomas,
                               |you have a new notification:
                               |
                               |The Case 2231 has been created by admin@thehive.local
                               |
                               |case title
                               |
                               |
                               |Audit (testRequest): create Case 2231 by admin@thehive.local
                               |Context 2231""".stripMargin)
    }

    "build properly message" in testApp { app =>
      val template =
        """Dear {{user.name}},
          |you have a new notification:
          |
          |The {{audit.objectType}} {{audit.objectId}} has been {{audit.action}}d by {{audit._createdBy}}
          |
          |{{#with object~}}
          |{{#if (eq _type "Case")}}
          |{{~title}}
          |{{else}}
          |{{~_type}} is not a case
          |{{/if}}
          |{{~/with}}
          |
          |Audit ({{audit.requestId}}): {{audit.action}} {{audit.objectType}} {{audit.objectId}} by {{audit._createdBy}}
          |Context {{context._id}}""".stripMargin

      val message = app[Database].tryTransaction { implicit graph =>
        for {
          case4       <- app[CaseSrv].get(EntityName("1")).getOrFail("Case")
          case4Entity <- app[CaseSrv].get(EntityName("1")).entityMap.getOrFail("Case")
          _           <- app[CaseSrv].addTags(case4, Set("emailer test"))
          _           <- app[CaseSrv].addTags(case4, Set("emailer test")) // this is needed to make AuditSrv write Audit in DB
          audit       <- app[AuditSrv].startTraversal.has(_.objectId, case4._id.toString).getOrFail("Audit")
          user        <- app[UserSrv].get(EntityName("certuser@thehive.local")).getOrFail("User")
          msg         <- templateEngine(app[Schema]).buildMessage(template, audit, Some(case4Entity), Some(case4Entity), Some(user), "http://localhost/")
        } yield msg
      }
      message must beSuccessfulTry.which { m =>
        m must beMatching("""Dear certuser,
                            |you have a new notification:
                            |
                            |The Case ~\d+ has been updated by certuser@thehive.local
                            |
                            |case#1
                            |
                            |
                            |Audit \(testRequest\): update Case ~\d+ by certuser@thehive.local
                            |Context ~\d+""".stripMargin)
      }
    }
  }
}

```

`thehive/test/org/thp/thehive/services/notification/triggers/AlertCreatedTest.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import java.util.Date

import org.thp.scalligraph.models.Database
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.scalligraph.{EntityIdOrName, EntityName}
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.controllers.v0.AlertCtrl
import org.thp.thehive.dto.v0.{InputAlert, OutputAlert}
import org.thp.thehive.services.{AlertSrv, AuditSrv, OrganisationSrv, UserSrv}
import play.api.libs.json.{JsObject, Json}
import play.api.test.{FakeRequest, PlaySpecification}

class AlertCreatedTest extends PlaySpecification with TestAppBuilder {

  "alert created trigger" should {
    "be properly triggered on alert creation" in testApp { app =>
      app[Database].roTransaction { implicit graph =>
        val request = FakeRequest("POST", "/api/v0/alert")
          .withJsonBody(
            Json
              .toJson(
                InputAlert(
                  `type` = "test",
                  source = "alert_creation_test",
                  sourceRef = "#1",
                  externalLink = None,
                  title = "alert title (create alert test)",
                  description = "alert description (create alert test)",
                  severity = Some(2),
                  date = Some(new Date()),
                  tags = Set("tag1", "tag2"),
                  flag = Some(false),
                  tlp = Some(1),
                  pap = Some(3)
                )
              )
              .as[JsObject]
          )
          .withHeaders("user" -> "certuser@thehive.local")

        val result = app[AlertCtrl].create(request)

        status(result) should equalTo(201)

        val alertOutput = contentAsJson(result).as[OutputAlert]
        val alert       = app[AlertSrv].get(EntityIdOrName(alertOutput.id)).getOrFail("Alert")

        alert must beSuccessfulTry

        val audit = app[AuditSrv].startTraversal.has(_.objectId, alert.get._id.toString).getOrFail("Audit")

        audit must beSuccessfulTry

        val organisation = app[OrganisationSrv].get(EntityName("cert")).getOrFail("Organisation")

        organisation must beSuccessfulTry

        val user2 = app[UserSrv].getOrFail(EntityName("certadmin@thehive.local"))
        val user1 = app[UserSrv].getOrFail(EntityName("certuser@thehive.local"))

        user2 must beSuccessfulTry
        user1 must beSuccessfulTry

        val alertCreated = AlertCreated

        alertCreated.filter(audit.get, Some(alert.get), organisation.get, user1.toOption) must beFalse
        alertCreated.filter(audit.get, Some(alert.get), organisation.get, user2.toOption) must beTrue
      }
    }
  }
}

```

`thehive/test/org/thp/thehive/services/notification/triggers/TaskAssignedTest.scala`:

```scala
package org.thp.thehive.services.notification.triggers

import org.thp.scalligraph.EntityName
import org.thp.scalligraph.auth.AuthContext
import org.thp.scalligraph.models.{Database, DummyUserSrv}
import org.thp.scalligraph.traversal.TraversalOps._
import org.thp.thehive.TestAppBuilder
import org.thp.thehive.services.UserOps._
import org.thp.thehive.services._
import play.api.test.PlaySpecification

class TaskAssignedTest extends PlaySpecification with TestAppBuilder {
  implicit val authContext: AuthContext = DummyUserSrv(userId = "certadmin@thehive.local").authContext

  "task assigned trigger" should {
    "be properly triggered on task assignment" in testApp { app =>
      app[Database].tryTransaction { implicit graph =>
        for {
          task1 <- app[TaskSrv].startTraversal.has(_.title, "case 1 task 1").getOrFail("Task")
          user1 <- app[UserSrv].startTraversal.getByName("certuser@thehive.local").getOrFail("User")
          user2 <- app[UserSrv].startTraversal.getByName("certadmin@thehive.local").getOrFail("User")
          _     <- app[TaskSrv].assign(task1, user1)
          _     <- app[AuditSrv].flushPendingAudit()
          audit <- app[AuditSrv].startTraversal.has(_.objectId, task1._id.toString).getOrFail("Audit")
          orga  <- app[OrganisationSrv].get(EntityName("cert")).getOrFail("Organisation")
          taskAssignedTrigger = new TaskAssigned(app[TaskSrv])
          _                   = taskAssignedTrigger.filter(audit, Some(task1), orga, Some(user1)) must beTrue
          _                   = taskAssignedTrigger.filter(audit, Some(task1), orga, Some(user2)) must beFalse
        } yield ()
      } must beASuccessfulTry
    }
  }
}

```

`thehive/test/resources/data/Alert.json`:

```json
[
  {
    "id": "alert1",
    "type": "testType",
    "source": "testSource",
    "sourceRef": "ref1",
    "title": "alert#1",
    "description": "description of alert #1",
    "severity": 2,
    "date": 1555359572000,
    "lastSyncDate": 1555359600000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "read": false,
    "follow": true,
    "organisationId": "",
    "tags": ["test", "alert"],
    "caseId": ""
  },
  {
    "id": "alert2",
    "type": "testType",
    "source": "testSource",
    "sourceRef": "ref2",
    "title": "alert#2",
    "description": "description of alert #2",
    "severity": 2,
    "date": 1555359572000,
    "lastSyncDate": 1555359600000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "read": false,
    "follow": true,
    "organisationId": "",
    "tags": ["test", "alert"],
    "caseId": ""
  },
  {
    "id": "alert3",
    "type": "testType",
    "source": "testSource",
    "sourceRef": "ref3",
    "title": "alert#3",
    "description": "description of alert #3",
    "severity": 2,
    "date": 1555359572000,
    "lastSyncDate": 1555359600000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "read": false,
    "follow": true,
    "organisationId": "",
    "tags": ["test", "alert"],
    "caseId": ""
  },
  {
    "id": "alert4",
    "type": "testType",
    "source": "testSource",
    "sourceRef": "ref4",
    "title": "alert#4",
    "description": "description of alert #4",
    "severity": 2,
    "date": 1555359572000,
    "lastSyncDate": 1555359600000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "read": false,
    "follow": true,
    "organisationId": "",
    "tags": ["test", "alert"],
    "caseId": ""
  },
  {
    "id": "alert5",
    "type": "testType",
    "source": "testSource",
    "sourceRef": "ref5",
    "title": "alert#5",
    "description": "description of alert #5",
    "severity": 2,
    "date": 1555359572000,
    "lastSyncDate": 1555359600000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "read": false,
    "follow": true,
    "organisationId": "",
    "tags": ["test", "alert"],
    "caseId": ""
  },
  {
    "id": "alertMerge1",
    "type": "testType",
    "source": "testSource",
    "sourceRef": "ref6",
    "title": "alert#6",
    "description": "description of alert #6",
    "severity": 2,
    "date": 1555359572000,
    "lastSyncDate": 1555359600000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "read": false,
    "follow": true,
    "organisationId": "",
    "caseId": ""
  }
]

```

`thehive/test/resources/data/AlertCase.json`:

```json
[
  {"from": "alertMerge1", "to": "caseMerge21"}
]
```

`thehive/test/resources/data/AlertCaseTemplate.json`:

```json
[
  {"from": "alert1", "to": "spam"},
  {"from": "alert5", "to": "spam"}
]
```

`thehive/test/resources/data/AlertCustomField.json`:

```json
[
  {"from": "alert4", "to": "integer1"},
  {"from": "alert1", "to": "integer1", "integerValue": 42}
]
```

`thehive/test/resources/data/AlertObservable.json`:

```json
[
  {"from": "alert1", "to": "alert-h.fr"},
  {"from": "alert4", "to": "perdu.com"},
  {"from": "alert5", "to": "c.fr"}
]

```

`thehive/test/resources/data/AlertOrganisation.json`:

```json
[
  {"from": "alert1", "to": "soc"},
  {"from": "alert2", "to": "cert"},
  {"from": "alert3", "to": "cert"},
  {"from": "alert4", "to": "cert"},
  {"from": "alert5", "to": "cert"},
  {"from": "alertMerge1", "to": "cert"}
]

```

`thehive/test/resources/data/Attachment.json`:

```json
[
  {
    "id": "attachment-hello",
    "name": "hello.txt",
    "size": 13,
    "contentType": "text/plain",
    "hashes": [
      "a4bf1f6be616bf6a0de2ff6264de43a64bb768d38c783ec2bc74b5d4dcf5f889",
      "b1fda0e52e8099d2aeb80f57bb91548cace3093f",
      "905138a85e85e74344e90d25dba7299e"
    ],
    "attachmentId": "a4bf1f6be616bf6a0de2ff6264de43a64bb768d38c783ec2bc74b5d4dcf5f889"
  },
  {
    "id": "cascade-remove-attachment1",
    "name": "cascade1.txt",
    "size": 13,
    "contentType": "text/plain",
    "hashes": [
      "905138a85e85e74344e90d25dba7299e"
    ],
    "attachmentId": "b4bf1f6be616bf6a0de2ff6264de43a64bb768d38c783ec2bc74b5d4dcf5f889"
  },
  {
    "id": "cascade-remove-attachment2",
    "name": "cascade2.txt",
    "size": 13,
    "contentType": "text/plain",
    "hashes": [
      "a4bf1f6be616bf6a0de2ff6264de43a64bb768d38c783ec2bc74b5d4dcf5f889"
    ],
    "attachmentId": "c4bf1f6be616bf6a0de2ff6264de43a64bb768d38c783ec2bc74b5d4dcf5f889"
  }
]
```

`thehive/test/resources/data/Case.json`:

```json
[
  {
    "id": "case1",
    "number": 1,
    "title": "case#1",
    "description": "description of case #1",
    "severity": 2,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "tags": ["t1", "t3"],
    "assignee": "certuser@thehive.local",
    "owningOrganisation": ""
  },
  {
    "id": "case2",
    "number": 2,
    "title": "case#2",
    "description": "description of case #2",
    "severity": 2,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "tags": ["t1","t2"],
    "impactStatus": "NoImpact",
    "assignee": "certuser@thehive.local",
    "owningOrganisation": ""
  },
  {
    "id": "case3",
    "number": 3,
    "title": "case#3",
    "description": "description of case #3",
    "severity": 2,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "caseTemplate": "spam",
    "tags": ["t1","t2"],
    "assignee": "socuser@thehive.local",
    "owningOrganisation": ""
  },
  {
    "id": "caseActionRequired1",
    "number": 4,
    "title": "case#10",
    "description": "description of case #10",
    "severity": 3,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "owningOrganisation": ""
  },
  {
    "id": "caseActionRequired2",
    "number": 5,
    "title": "case#11",
    "description": "description of case #11",
    "severity": 3,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "owningOrganisation": ""
  },
  {
    "id": "caseMerge21",
    "number": 21,
    "title": "case#21",
    "description": "description of case #21",
    "severity": 1,
    "startDate": 1531664370000,
    "flag": false,
    "tlp": 4,
    "pap": 3,
    "status": "Open",
    "tags": ["toMerge:pred1=\"value1\""],
    "assignee": "certuser@thehive.local",
    "owningOrganisation": ""
  },
  {
    "id": "caseMerge22",
    "number": 22,
    "title": "case#22",
    "description": "description of case #22",
    "severity": 3,
    "startDate": 1531667370000,
    "flag": true,
    "tlp": 1,
    "pap": 2,
    "status": "Open",
    "tags": ["toMerge:pred2=\"value2\""],
    "assignee": "certuser@thehive.local",
    "owningOrganisation": ""
  },
  {
    "id": "caseMerge23",
    "number": 23,
    "title": "case#23",
    "description": "description of case #23",
    "severity": 3,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "assignee": "certuser@thehive.local",
    "owningOrganisation": ""
  },
  {
    "id": "caseMerge24",
    "number": 24,
    "title": "case#24",
    "description": "description of case #24",
    "severity": 3,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "assignee": "socuser@thehive.local",
    "owningOrganisation": ""
  },
  {
    "id": "caseMerge25",
    "number": 25,
    "title": "case#25",
    "description": "description of case #25",
    "severity": 3,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "assignee": "certuser@thehive.local",
    "owningOrganisation": ""
  },
  {
    "id": "caseMerge26",
    "number": 26,
    "title": "case#26",
    "description": "description of case #26",
    "severity": 2,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 1,
    "pap": 2,
    "status": "Open",
    "assignee": "puguser@thehive.local",
    "owningOrganisation": ""
  },
  {
    "id": "case4",
    "number": 34,
    "title": "case#4",
    "description": "description of case cascade remove",
    "severity": 3,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "owningOrganisation": ""
  },
  {
    "id": "case5",
    "number": 35,
    "title": "case#5",
    "description": "description of case cascade remove",
    "severity": 3,
    "startDate": 1531667370000,
    "flag": false,
    "tlp": 2,
    "pap": 2,
    "status": "Open",
    "owningOrganisation": ""
  }
]

```

`thehive/test/resources/data/CaseCustomField.json`:

```json
[
  {"from": "case3", "to": "string1", "stringValue": "string1 custom field"},
  {"from": "case3", "to": "boolean1", "booleanValue": true},
  {"from": "caseMerge22", "to": "string1", "stringValue": "merge string1"},
  {"from": "caseMerge23", "to": "integer1", "integerValue": 3}
]
```

`thehive/test/resources/data/CaseProcedure.json`:

```json
[
  {"from": "case1", "to": "testProcedure1"},
  {"from": "case1", "to": "testProcedure2"},
  {"from": "caseMerge21", "to": "mergeProcedure211"},
  {"from": "caseMerge22", "to": "mergeProcedure221"},
  {"from": "caseMerge22", "to": "mergeProcedure222"}
]
```

`thehive/test/resources/data/CaseTemplate.json`:

```json
[
  {
    "name": "spam",
    "displayName": "Spam case template",
    "titlePrefix": "[SPAM] ",
    "description": "description of SPAM case",
    "severity": 1,
    "flag": false,
    "tlp": 1,
    "pap": 1,
    "tags": [
      "spam",
      "src:mail"
    ]
  }
]
```

`thehive/test/resources/data/CaseTemplateCustomField.json`:

```json
[
  {"from": "spam", "to": "string1", "stringValue": "string1 custom field", "order":  1},
  {"from": "spam", "to": "boolean1", "order":  2}
]

```

`thehive/test/resources/data/CaseTemplateOrganisation.json`:

```json
[
  {"from": "spam", "to": "cert"}
]
```

`thehive/test/resources/data/CustomField.json`:

```json
[
  {
    "name": "string1",
    "displayName": "string1",
    "description": "string custom field",
    "type": "string",
    "mandatory": false,
    "options": []
  },
  {
    "name": "boolean1",
    "displayName": "boolean1",
    "description": "boolean custom field",
    "type": "boolean",
    "mandatory": false,
    "options": []
  },
  {
    "name": "integer1",
    "displayName": "integer1",
    "description": "integer custom field",
    "type": "integer",
    "mandatory": false,
    "options": []
  },
  {
    "name": "float1",
    "displayName": "float1",
    "description": "float custom field",
    "type": "float",
    "mandatory": false,
    "options": []
  },
  {
    "name": "date1",
    "displayName": "date1",
    "description": "date custom field",
    "type": "date",
    "mandatory": false,
    "options": []
  }
]
```

`thehive/test/resources/data/Dashboard.json`:

```json
[
  {
    "id": "dashboard-cert",
    "title": "dashboard cert",
    "description": "dashboard for cert organisation",
    "definition": {
      "period": "custom",
      "items": [
        {
          "type": "container",
          "items": [
            {
              "type": "line",
              "options": {
                "title": "cases",
                "entity": "case",
                "field": "createdAt",
                "interval": "1d",
                "query": {
                },
                "series": [
                  {
                    "agg": "count",
                    "field": null,
                    "type": "line",
                    "label": "cases"
                  }
                ]
              },
              "id": "37741393-eecc-16c9-f5b8-f0e668b403eb"
            }
          ]
        }
      ],
      "customPeriod": {
        "fromDate": "2019-07-08T22:00:00.000Z",
        "toDate": "2019-11-27T23:00:00.000Z"
      }
    }
  },
  {
    "id": "dashboard-soc",
    "title": "dashboard soc",
    "description": "dashboard for soc organisation",
    "definition": {
      "period": "custom",
      "items": [
        {
          "type": "container",
          "items": [
            {
              "type": "line",
              "options": {
                "title": "cases",
                "entity": "case",
                "field": "createdAt",
                "interval": "1d",
                "query": {
                },
                "series": [
                  {
                    "agg": "count",
                    "field": null,
                    "type": "line",
                    "label": "cases"
                  }
                ]
              },
              "id": "37741393-eecc-16c9-f5b8-f0e668b403eb"
            }
          ]
        }
      ],
      "customPeriod": {
        "fromDate": "2019-07-08T22:00:00.000Z",
        "toDate": "2019-11-27T23:00:00.000Z"
      }
    }
  }
]
```

`thehive/test/resources/data/DashboardUser.json`:

```json
[
  {"from": "dashboard-cert", "to": "certadmin"},
  {"from": "dashboard-soc", "to": "socadmin"}
]
```

`thehive/test/resources/data/Job.json`:

```json
[
  {
    "id": "jobTest1",
    "cortexId": "test",
    "startDate": 1561625908856,
    "endDate": 1561625908856,
    "cortexJobId": "AWuYKFatq3Rtqym9DFmL",
    "workerId": "anaTest1",
    "workerDefinition": "test",
    "workerName": "anaTest1",
    "status": "Waiting"
  },
  {
    "id": "jobTest2",
    "cortexId": "test",
    "startDate": 1561625908856,
    "endDate": 1561625908856,
    "cortexJobId": "LVyYKFstq3Rtrdc9DFmL",
    "workerId": "anaTest2",
    "workerDefinition": "test2",
    "workerName": "anaTest2",
    "status": "Waiting"
  }
]
```

`thehive/test/resources/data/Log.json`:

```json
[
  {
    "id": "log1",
    "message": "log for action test",
    "date": 1566303875000,
    "taskId": ""
  },
  {
    "id": "log-cascade-remove-simple",
    "message": "log cascade remove simple",
    "date": 1566303875000,
    "taskId": ""
  },
  {
    "id": "log-cascade-remove-delete",
    "message": "log cascade remove delete",
    "date": 1566303875000,
    "taskId": ""
  }
]

```

`thehive/test/resources/data/LogAttachment.json`:

```json
[
  {"from": "log-cascade-remove-simple", "to": "cascade-remove-attachment2"},
  {"from": "log-cascade-remove-delete", "to": "cascade-remove-attachment2"}
]

```

`thehive/test/resources/data/Observable.json`:

```json
[
  {
    "id": "h.fr",
    "message": "Some weird domain",
    "tlp": 3,
    "ioc": true,
    "sighted": false,
    "dataType": "domain",
    "data": "h.fr",
    "tags": ["testDomain"],
    "relatedId": ""
  },
  {
    "id": "c.fr",
    "message": "This domain",
    "tlp": 2,
    "ioc": false,
    "sighted": false,
    "dataType": "domain",
    "data": "c.fr",
    "tags": ["testDomain"],
    "relatedId": ""
  },
  {
    "id": "helloworld",
    "message": "hello world",
    "tlp": 1,
    "ioc": false,
    "sighted": false,
    "dataType": "file",
    "tags": ["hello", "world"],
    "relatedId": ""
  },
  {
    "id": "perdu.com",
    "message": "if you are lost",
    "tlp": 1,
    "ioc": false,
    "sighted": true,
    "dataType": "domain",
    "data": "perdu.com",
    "relatedId": ""
  },
  {
    "id": "alert-h.fr",
    "message": "observable from alert",
    "tlp": 1,
    "ioc": true,
    "sighted": true,
    "dataType": "domain",
    "data": "h.fr",
    "tags": ["hello"],
    "relatedId": ""
  },
  {
    "id": "mergeObs211",
    "message": "merge Obs 211",
    "tlp": 1,
    "ioc": true,
    "dataType": "ip",
    "data": "127.0.0.1",
    "sighted": false,
    "relatedId": ""
  },
  {
    "id": "mergeObs231",
    "message": "merge Obs 231",
    "tlp": 2,
    "ioc": false,
    "dataType": "ip",
    "data": "127.0.0.1",
    "sighted": true,
    "relatedId": ""
  },
  {
    "id": "mergeObs232",
    "message": "merge Obs 232",
    "tlp": 4,
    "ioc": true,
    "dataType": "ip",
    "data": "127.0.0.1",
    "sighted": true,
    "relatedId": ""
  },
  {
    "id": "mergeObs251",
    "message": "merge Obs 251",
    "tlp": 4,
    "ioc": true,
    "dataType": "ip",
    "data": "127.0.0.1",
    "sighted": true,
    "relatedId": ""
  },
  {
    "id": "mergeObs252",
    "message": "merge Obs 252",
    "tlp": 4,
    "ioc": true,
    "dataType": "ip",
    "data": "127.0.0.1",
    "sighted": true,
    "relatedId": ""
  },
  {
    "id": "obs-cascade-remove-simple",
    "message": "obs-cascade-remove-simple",
    "tlp": 1,
    "ioc": true,
    "dataType": "ip",
    "data": "127.0.0.2",
    "sighted": true,
    "relatedId": ""
  },
  {
    "id": "obs-cascade-remove-unshare",
    "message": "obs-cascade-remove-unshare",
    "tlp": 1,
    "ioc": true,
    "dataType": "ip",
    "data": "127.0.0.3",
    "sighted": true,
    "relatedId": ""
  },
  {
    "id": "obs-cascade-remove-delete",
    "message": "obs-cascade-remove-delete",
    "tlp": 1,
    "ioc": true,
    "dataType": "ip",
    "data": "127.0.0.4",
    "sighted": true,
    "relatedId": ""
  }
]

```

`thehive/test/resources/data/ObservableAttachment.json`:

```json
[
  {"from": "helloworld", "to": "attachment-hello"},
  {"from": "obs-cascade-remove-simple", "to": "cascade-remove-attachment1"},
  {"from": "obs-cascade-remove-delete", "to": "cascade-remove-attachment1"}
]
```

`thehive/test/resources/data/ObservableJob.json`:

```json
[
  {
    "from": "h.fr",
    "to": "jobTest1"
  },
  {
    "from": "helloworld",
    "to": "jobTest2"
  }
]
```

`thehive/test/resources/data/Organisation.json`:

```json
[
  {
    "id": "cert",
    "name": "cert",
    "description": "cert"
  },
  {
    "id": "soc",
    "name": "soc",
    "description": "soc"
  },
  {
    "id": "pug",
    "name": "pug",
    "description": "pug"
  }
]
```

`thehive/test/resources/data/OrganisationDashboard.json`:

```json
[
  {"from": "cert", "to": "dashboard-cert", "writable": true},
  {"from": "soc", "to": "dashboard-soc", "writable": false}
]
```

`thehive/test/resources/data/OrganisationOrganisation.json`:

```json
[
  {
    "from": "cert",
    "to": "soc"
  }
]
```

`thehive/test/resources/data/OrganisationPage.json`:

```json
[
  {"from": "cert", "to": "how_to_create_a_case"}
]
```

`thehive/test/resources/data/OrganisationShare.json`:

```json
[
  {"from": "cert", "to": "case1-cert"},
  {"from": "cert", "to": "case2-cert"},
  {"from": "cert", "to": "cascade-remove-simple"},
  {"from": "cert", "to": "share-cascade-remove"},
  {"from": "soc", "to": "share-cascade-remove2"},
  {"from": "soc", "to": "case2-soc"},
  {"from": "soc", "to": "case3-soc"},
  {"from": "soc", "to": "case-actionRequired-soc"},
  {"from": "cert", "to": "case-actionRequired-cert"},
  {"from": "cert", "to": "case21-merge-cert"},
  {"from": "cert", "to": "case22-merge-cert"},
  {"from": "cert", "to": "case23-merge-cert"},
  {"from": "cert", "to": "case24-merge-cert"},
  {"from": "soc", "to": "case24-merge-soc"},
  {"from": "cert", "to": "case25-merge-cert"},
  {"from": "soc", "to": "case25-merge-soc"},
  {"from": "pug", "to": "case26-merge-pug"}
]

```

`thehive/test/resources/data/OrganisationTaxonomy.json`:

```json
[
  {"from": "admin", "to": "taxonomy1"},
  {"from": "cert", "to": "taxonomy1"},
  {"from": "soc", "to": "taxonomy1"}
]
```

`thehive/test/resources/data/Page.json`:

```json
[{
  "title": "how to create a case",
  "content": "this page explain how to create a case",
  "slug": "how_to_create_a_case",
  "order": 0,
  "category": "basics"
}]
```

`thehive/test/resources/data/Pattern.json`:

```json
[
  {
    "id": "testPattern1",
    "patternId": "T123",
    "name": "testPattern1",
    "description": "The testPattern 1",
    "tactics": [
      "testTactic1",
      "testTactic2"
    ],
    "url": "http://test.pattern.url",
    "patternType": "unit-test",
    "revoked": false,
    "dataSources": [],
    "defenseBypassed": [],
    "platforms": [],
    "remoteSupport": true,
    "revision": "1.0"
  },
  {
    "id": "testPattern2",
    "patternId": "T234",
    "name": "testPattern2",
    "description": "The testPattern 2",
    "tactics": [
      "testTactic2",
      "testTactic3"
    ],
    "url": "http://test.pattern2.url",
    "patternType": "unit-test",
    "revoked": false,
    "dataSources": [],
    "defenseBypassed": [],
    "platforms": [],
    "remoteSupport": false,
    "revision": "1.1"
  }
]

```

`thehive/test/resources/data/Procedure.json`:

```json
[
  {
    "id": "testProcedure1",
    "description": "The testProcedure 1",
    "occurDate": 1531667370000,
    "tactic": "tactic1"
  },
  {
    "id": "testProcedure2",
    "description": "The testProcedure 2",
    "occurDate": 1531667370000,
    "tactic": "tactic2"
  },
  {
    "id": "mergeProcedure211",
    "description": "merge Procedure 211",
    "occurDate": 1531667370000,
    "tactic": "tactic 21"
  },
  {
    "id": "mergeProcedure221",
    "description": "merge Procedure 221",
    "occurDate": 1531667370000,
    "tactic": "tactic 22"
  },
  {
    "id": "mergeProcedure222",
    "description": "merge Procedure 222",
    "occurDate": 1531667370000,
    "tactic": "tactic 22"
  }
]
```

`thehive/test/resources/data/ProcedurePattern.json`:

```json
[
  {"from": "testProcedure1", "to": "testPattern1"},
  {"from": "testProcedure2", "to": "testPattern2"}
]
```

`thehive/test/resources/data/Profile.json`:

```json
[
  {"name": "testProfile", "permissions": ["manageObservable"]}
]
```

`thehive/test/resources/data/Role.json`:

```json
[
  {"id": "ro-cert"},
  {"id": "user-cert"},
  {"id": "admin-cert"},
  {"id": "ro-soc"},
  {"id": "user-soc"},
  {"id": "admin-soc"},
  {"id": "ro-pug"},
  {"id": "user-pug"},
  {"id": "admin-pug"}
]
```

`thehive/test/resources/data/RoleOrganisation.json`:

```json
[
  {"from": "ro-cert", "to":  "cert"},
  {"from": "user-cert", "to":  "cert"},
  {"from": "admin-cert", "to":  "cert"},
  {"from": "ro-soc", "to":  "soc"},
  {"from": "user-soc", "to":  "soc"},
  {"from": "admin-soc", "to":  "soc"},
  {"from": "ro-pug", "to":  "pug"},
  {"from": "user-pug", "to":  "pug"},
  {"from": "admin-pug", "to":  "pug"}
]
```

`thehive/test/resources/data/RoleProfile.json`:

```json
[
  {"from": "ro-cert", "to":  "read-only"},
  {"from": "user-cert", "to":  "analyst"},
  {"from": "admin-cert", "to":  "org-admin"},
  {"from": "ro-soc", "to":  "read-only"},
  {"from": "user-soc", "to":  "analyst"},
  {"from": "admin-soc", "to":  "org-admin"},
  {"from": "ro-pug", "to":  "read-only"},
  {"from": "user-pug", "to":  "analyst"},
  {"from": "admin-pug", "to":  "org-admin"}
]

```

`thehive/test/resources/data/Share.json`:

```json
[
  {"id": "case1-cert", "owner":  true},
  {"id": "case2-cert", "owner":  true},
  {"id": "case2-soc", "owner":  false},
  {"id": "case3-soc", "owner":  true},
  {"id": "case-actionRequired-soc", "owner":  true},
  {"id": "case-actionRequired-cert", "owner":  true},
  {"id": "case21-merge-cert", "owner":  true},
  {"id": "case22-merge-cert", "owner":  true},
  {"id": "case23-merge-cert", "owner":  true},
  {"id": "case24-merge-soc", "owner":  true},
  {"id": "case24-merge-cert", "owner":  false},
  {"id": "case25-merge-cert", "owner":  true},
  {"id": "case25-merge-soc", "owner":  false},
  {"id": "case26-merge-pug", "owner":  true},
  {"id": "cascade-remove-simple", "owner":  true},
  {"id": "share-cascade-remove", "owner":  false},
  {"id": "share-cascade-remove2", "owner":  true}
]

```

`thehive/test/resources/data/ShareCase.json`:

```json
[
  {"from": "case1-cert", "to": "case1"},
  {"from": "case2-cert", "to": "case2"},
  {"from": "case2-soc", "to": "case2"},
  {"from": "case3-soc", "to": "case3"},
  {"from": "case-actionRequired-soc", "to": "caseActionRequired1"},
  {"from": "case-actionRequired-cert", "to": "caseActionRequired2"},
  {"from": "case21-merge-cert", "to": "caseMerge21"},
  {"from": "case22-merge-cert", "to": "caseMerge22"},
  {"from": "case23-merge-cert", "to": "caseMerge23"},
  {"from": "case24-merge-soc", "to": "caseMerge24"},
  {"from": "case24-merge-cert", "to": "caseMerge24"},
  {"from": "case25-merge-cert", "to": "caseMerge25"},
  {"from": "case25-merge-soc", "to": "caseMerge25"},
  {"from": "case26-merge-pug", "to": "caseMerge26"},
  {"from": "cascade-remove-simple", "to": "case5"},
  {"from": "share-cascade-remove", "to": "case4"},
  {"from": "share-cascade-remove2", "to": "case4"}
]

```

`thehive/test/resources/data/ShareObservable.json`:

```json
[
  {"from": "case1-cert", "to": "h.fr"},
  {"from": "case2-cert", "to": "helloworld"},
  {"from": "case2-soc", "to": "helloworld"},
  {"from": "case21-merge-cert", "to": "mergeObs211"},
  {"from": "case23-merge-cert", "to": "mergeObs231"},
  {"from": "case23-merge-cert", "to": "mergeObs232"},
  {"from": "case25-merge-soc", "to": "mergeObs251"},
  {"from": "case25-merge-cert", "to": "mergeObs251"},
  {"from": "case25-merge-cert", "to": "mergeObs252"},
  {"from": "cascade-remove-simple", "to": "obs-cascade-remove-simple"},
  {"from": "share-cascade-remove", "to": "obs-cascade-remove-delete"},
  {"from": "share-cascade-remove", "to": "obs-cascade-remove-unshare"},
  {"from": "share-cascade-remove2", "to": "obs-cascade-remove-unshare"}
]

```

`thehive/test/resources/data/ShareProfile.json`:

```json
[
  {"from": "case1-cert", "to": "org-admin"},
  {"from": "case2-cert", "to": "org-admin"},
  {"from": "case2-soc", "to": "read-only"},
  {"from": "case3-soc", "to": "org-admin"},
  {"from": "case21-merge-cert", "to": "org-admin"},
  {"from": "case22-merge-cert", "to": "org-admin"},
  {"from": "case23-merge-cert", "to": "org-admin"},
  {"from": "case24-merge-soc", "to": "org-admin"},
  {"from": "case24-merge-cert", "to": "read-only"},
  {"from": "case25-merge-cert", "to": "read-only"},
  {"from": "case25-merge-soc", "to": "org-admin"},
  {"from": "case26-merge-pug", "to": "read-only"}
]

```

`thehive/test/resources/data/ShareTask.json`:

```json
[
  {"from": "case1-cert", "to": "task1", "actionRequired":  false},
  {"from": "case1-cert", "to": "task2", "actionRequired":  false},
  {"from": "case2-soc", "to": "task3", "actionRequired":  false},
  {"from": "case2-cert", "to": "task4", "actionRequired":  false},
  {"from": "case3-soc", "to": "task5", "actionRequired":  false},
  {"from": "case-actionRequired-soc", "to": "taskActionRequired1", "actionRequired":  false},
  {"from": "case-actionRequired-cert", "to": "taskActionRequired1", "actionRequired":  false},
  {"from": "case-actionRequired-soc", "to": "taskActionRequired2", "actionRequired":  false},
  {"from": "case-actionRequired-cert", "to": "taskActionRequired2", "actionRequired":  true},
  {"from": "case21-merge-cert", "to": "taskMerge211", "actionRequired":  false},
  {"from": "case21-merge-cert", "to": "taskMerge212", "actionRequired":  false},
  {"from": "case23-merge-cert", "to": "taskMerge231", "actionRequired":  false},
  {"from": "case24-merge-soc", "to": "taskMerge241", "actionRequired":  false},
  {"from": "case24-merge-soc", "to": "taskMerge242", "actionRequired":  false},
  {"from": "case24-merge-cert", "to": "taskMerge242", "actionRequired":  false},
  {"from": "cascade-remove-simple", "to": "task-cascade-remove-simple", "actionRequired":  false},
  {"from": "share-cascade-remove", "to": "task-cascade-remove-delete", "actionRequired":  false},
  {"from": "share-cascade-remove", "to": "task-cascade-remove-unshare", "actionRequired":  false},
  {"from": "share-cascade-remove2", "to": "task-cascade-remove-unshare", "actionRequired":  false}

]

```

`thehive/test/resources/data/Tag.json`:

```json
[
  {
    "id": "taxonomy-tag1",
    "namespace": "taxonomy1",
    "predicate": "pred1",
    "value": "value1",
    "colour": "#00f300"
  }
]
```

`thehive/test/resources/data/Task.json`:

```json
[
  {
    "id": "task1",
    "title": "case 1 task 1",
    "group": "group1",
    "description": "description task 1",
    "status": "Waiting",
    "flag": false,
    "order": 0,
    "assignee": "certuser@thehive.local",
    "relatedId": ""
  },
  {
    "id": "task2",
    "title": "case 1 task 2",
    "group": "group1",
    "description": "description task 2",
    "status": "Waiting",
    "flag": true,
    "order": 1,
    "relatedId": ""
  },
  {
    "id": "task3",
    "title": "case 2 task 1",
    "group": "group1",
    "description": "description task 3",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "assignee": "certuser@thehive.local",
    "relatedId": ""
  },
  {
    "id": "task4",
    "title": "case 2 task 2",
    "group": "group1",
    "description": "description task 4",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "task5",
    "title": "case 3 task 1",
    "group": "group1",
    "description": "description task 5",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "taskActionRequired1",
    "title": "taskActionRequired1",
    "group": "groupActionRequired",
    "description": "description task Required",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "taskActionRequired2",
    "title": "taskActionRequired2",
    "group": "groupActionRequired",
    "description": "description task Required",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "taskMerge211",
    "title": "taskMerge211",
    "group": "task merge",
    "description": "description task merge 21 1",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "taskMerge212",
    "title": "taskMerge212",
    "group": "task merge",
    "description": "description task merge 21 2",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "taskMerge231",
    "title": "taskMerge231",
    "group": "task merge",
    "description": "description task merge 23 1",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "taskMerge241",
    "title": "taskMerge241",
    "group": "task merge",
    "description": "description task merge 24 1",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "taskMerge242",
    "title": "taskMerge242",
    "group": "task merge",
    "description": "description task merge 24 2",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "task-cascade-remove-simple",
    "title": "task-cascade-remove-simple",
    "group": "group1",
    "description": "description task simple",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "task-cascade-remove-unshare",
    "title": "task-cascade-remove-unshare",
    "group": "group1",
    "description": "description task unshare",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  },
  {
    "id": "task-cascade-remove-delete",
    "title": "task-cascade-remove-delete",
    "group": "group1",
    "description": "description task delete",
    "status": "Waiting",
    "flag": true,
    "order": 0,
    "relatedId": ""
  }
]

```

`thehive/test/resources/data/TaskLog.json`:

```json
[
  {"from": "task4", "to": "log1"},
  {"from": "task-cascade-remove-simple", "to": "log-cascade-remove-simple"},
  {"from": "task-cascade-remove-delete", "to": "log-cascade-remove-delete"}
]

```

`thehive/test/resources/data/Taxonomy.json`:

```json
[
  {
    "id": "taxonomy1",
    "namespace": "taxonomy1",
    "description": "The taxonomy 1",
    "version": 1
  },
  {
    "id": "taxonomy2",
    "namespace": "taxonomy2",
    "description": "The taxonomy 2",
    "version": 1
  }
]
```

`thehive/test/resources/data/TaxonomyTag.json`:

```json
[
  {"from": "taxonomy1", "to": "taxonomy-tag1"}
]
```

`thehive/test/resources/data/User.json`:

```json
[
  {
    "id": "certuser",
    "login": "certuser@thehive.local",
    "name": "certuser",
    "locked": false,
    "password": "*random*seed*,d57cb64654764ab43edfc76a0a84e4e2fda867e761ab5a82859b00ad8412b2a1"
  },
  {
    "id": "socuser",
    "login": "socuser@thehive.local",
    "name": "socuser",
    "locked": false
  },
  {
    "id": "puguser",
    "login": "puguser@thehive.local",
    "name": "puguser",
    "locked": false
  },
  {
    "id": "certadmin",
    "login": "certadmin@thehive.local",
    "name": "certadmin",
    "locked": false
  },
  {
    "id": "socadmin",
    "login": "socadmin@thehive.local",
    "name": "socadmin",
    "locked": false
  },
  {
    "id": "pugadmin",
    "login": "pugadmin@thehive.local",
    "name": "pugadmin",
    "locked": false
  },
  {
    "id": "certro",
    "login": "certro@thehive.local",
    "name": "certro",
    "locked": true,
    "apikey": "azertyazerty"
  },
  {
    "id": "socro",
    "login": "socro@thehive.local",
    "name": "socro",
    "locked": false,
    "password": "*random*seed*,d57cb64654764ab43edfc76a0a84e4e2fda867e761ab5a82859b00ad8412b2a1"
  },
  {
    "id": "pugro",
    "login": "pugro@thehive.local",
    "name": "pugro",
    "locked": false,
    "password": "*random*seed*,d57cb64654764ab43edfc76a0a84e4e2fda867e761ab5a82859b00ad8412b2a1"
  }
]
```

`thehive/test/resources/data/UserRole.json`:

```json
[
  {"from": "certro@thehive.local","to": "ro-cert"},
  {"from": "certuser@thehive.local","to": "user-cert"},
  {"from": "certadmin@thehive.local","to": "admin-cert"},
  {"from": "socro@thehive.local","to": "ro-soc"},
  {"from": "socuser@thehive.local","to": "user-soc"},
  {"from": "socadmin@thehive.local","to": "admin-soc"},
  {"from": "pugro@thehive.local","to": "ro-pug"},
  {"from": "puguser@thehive.local","to": "user-pug"},
  {"from": "pugadmin@thehive.local","to": "admin-pug"}
]

```

`thehive/test/resources/init_orgs.sh`:

```sh
#!/usr/bin/env bash

declare -A PROFILES
PROFILES[admin]="org-admin"
PROFILES[user]="analyst"
PROFILES[ro]="read-only"

for ORG in cert csirt soc
do
  echo -n "Create organisation $ORG ... "
  curl -s -w '%{http_code}\n' -o /dev/null -uadmin:secret http://127.0.0.1:9000/api/organisation -H 'Content-type: application/json' -d '{"name": "'$ORG'", "description": "'$ORG'"}'
  for USER in admin user ro
  do
    echo -n "Create user $ORG$USER in $ORG ... "
    curl -s -w '%{http_code}\n' -o /dev/null -uadmin:secret http://127.0.0.1:9000/api/v1/user -H 'Content-type: application/json' -d '{"login":"'$ORG$USER'@thehive.local","name":"'$ORG$USER'","profile":"'${PROFILES[$USER]}'","organisation":"'$ORG'"}'
    echo -n "Set password $ORG$USER to user $ORG$USER ... "
    curl -s -w '%{http_code}\n' -o /dev/null -uadmin:secret http://127.0.0.1:9000/api/v1/user/$ORG${USER}@thehive.local/password/set -H 'Content-type: application/json' -H "X-Organisation: $ORG" -d '{"password": "'$ORG$USER'"}'
  done
  for I in $(seq 1 10)
  do
    echo -n "Create case $I in $ORG ... "
    curl -s -w '%{http_code}\n' -o /dev/null -u${ORG}user:${ORG}user http://127.0.0.1:9000/api/case -H 'Content-type: application/json' -H "X-Organisation: $ORG" -d '{"title": "case #'$I' ('$ORG')", "description": "created automatically"}'
  done
  for I in $(seq 1 10)
  do
    echo -n "Create alert $I in $ORG ... "
    curl -s -w '%{http_code}\n' -o /dev/null -u${ORG}user:${ORG}user http://127.0.0.1:9000/api/alert -H 'Content-type: application/json' -H "X-Organisation: $ORG" -d '{"type": "init", "source": "init_script", "sourceRef": "alert_'$ORG'_'$I'", "title": "alert #'$I' ('$ORG')", "description": "An alert", "date": '$(date +%s)000'}'
  done
done
echo -n "Link cert to csirt and soc ... "
curl -s -w '%{http_code}\n' -o /dev/null -uadmin:secret -XPUT http://127.0.0.1:9000/api/organisation/cert/links -H 'Content-type: application/json' -d '{"organisations":["csirt","soc"]}'
echo -n "Link csirt to soc ... "
curl -s -w '%{http_code}\n' -o /dev/null -uadmin:secret -XPUT http://127.0.0.1:9000/api/organisation/csirt/links -H 'Content-type: application/json' -d '{"organisations":["soc"]}'


```

`thehive/test/resources/patterns.json`:

```json
{
  "type": "bundle",
  "id": "bundle--ad5f3bce-004b-417e-899d-392f8591ab55",
  "spec_version": "2.0",
  "objects": [
  {
    "id": "attack-pattern--01df3350-ce05-4bdf-bdf8-0a919a66d4a8",
    "name": ".bash_profile and .bashrc",
    "external_references": [
      {
        "source_name": "mitre-attack",
        "external_id": "T1156",
        "url": "https://attack.mitre.org/techniques/T1156"
      },
      {
        "url": "https://researchcenter.paloaltonetworks.com/2017/04/unit42-new-iotlinux-malware-targets-dvrs-forms-botnet/",
        "description": "Claud Xiao, Cong Zheng, Yanhui Jia. (2017, April 6). New IoT/Linux Malware Targets DVRs, Forms Botnet. Retrieved February 19, 2018.",
        "source_name": "amnesia malware"
      }
    ],
    "revoked": true,
    "type": "attack-pattern",
    "modified": "2020-01-24T14:14:05.452Z",
    "created": "2017-12-14T16:46:06.044Z"
  },
  {
    "external_references": [
      {
        "source_name": "mitre-attack",
        "external_id": "T1546.004",
        "url": "https://attack.mitre.org/techniques/T1546/004"
      },
      {
        "url": "https://researchcenter.paloaltonetworks.com/2017/04/unit42-new-iotlinux-malware-targets-dvrs-forms-botnet/",
        "description": "Claud Xiao, Cong Zheng, Yanhui Jia. (2017, April 6). New IoT/Linux Malware Targets DVRs, Forms Botnet. Retrieved February 19, 2018.",
        "source_name": "amnesia malware"
      }
    ],
    "object_marking_refs": [
      "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168"
    ],
    "created_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
    "name": ".bash_profile and .bashrc",
    "description": "Adversaries may establish persistence by executing malicious content triggered by a user’s shell. <code>~/.bash_profile</code> and <code>~/.bashrc</code> are shell scripts that contain shell commands. These files are executed in a user's context when a new shell opens or when a user logs in so that their environment is set correctly.\n\n<code>~/.bash_profile</code> is executed for login shells and <code>~/.bashrc</code> is executed for interactive non-login shells. This means that when a user logs in (via username and password) to the console (either locally or remotely via something like SSH), the <code>~/.bash_profile</code> script is executed before the initial command prompt is returned to the user. After that, every time a new shell is opened, the <code>~/.bashrc</code> script is executed. This allows users more fine-grained control over when they want certain commands executed. These shell scripts are meant to be written to by the local user to configure their own environment.\n\nThe macOS Terminal.app is a little different in that it runs a login shell by default each time a new terminal window is opened, thus calling <code>~/.bash_profile</code> each time instead of <code>~/.bashrc</code>.\n\nAdversaries may abuse these shell scripts by inserting arbitrary shell commands that may be used to execute other binaries to gain persistence. Every time the user logs in or opens a new shell, the modified ~/.bash_profile and/or ~/.bashrc scripts will be executed.(Citation: amnesia malware)",
    "id": "attack-pattern--b63a34e8-0a61-4c97-a23b-bf8a2ed812e2",
    "type": "attack-pattern",
    "kill_chain_phases": [
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "privilege-escalation"
      },
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "persistence"
      }
    ],
    "modified": "2020-03-24T16:28:04.990Z",
    "created": "2020-01-24T14:13:45.936Z",
    "x_mitre_version": "1.0",
    "x_mitre_is_subtechnique": true,
    "x_mitre_permissions_required": [
      "User",
      "Administrator"
    ],
    "x_mitre_detection": "While users may customize their <code>~/.bashrc</code> and <code>~/.bash_profile</code> files , there are only certain types of commands that typically appear in these files. Monitor for abnormal commands such as execution of unknown programs, opening network sockets, or reaching out across the network when user profiles are loaded during the login process.",
    "x_mitre_data_sources": [
      "Process use of network",
      "Process command-line parameters",
      "Process monitoring",
      "File monitoring"
    ],
    "x_mitre_platforms": [
      "Linux",
      "macOS"
    ]
  },
  {
    "external_references": [
      {
        "url": "https://attack.mitre.org/techniques/T1003/008",
        "external_id": "T1003.008",
        "source_name": "mitre-attack"
      },
      {
        "description": "The Linux Documentation Project. (n.d.). Linux Password and Shadow File Formats. Retrieved February 19, 2020.",
        "url": "https://www.tldp.org/LDP/lame/LAME/linux-admin-made-easy/shadow-file-formats.html",
        "source_name": "Linux Password and Shadow File Formats"
      },
      {
        "description": "Vivek Gite. (2014, September 17). Linux Password Cracking: Explain unshadow and john Commands (John the Ripper Tool). Retrieved February 19, 2020.",
        "url": "https://www.cyberciti.biz/faq/unix-linux-password-cracking-john-the-ripper/",
        "source_name": "nixCraft - John the Ripper"
      }
    ],
    "object_marking_refs": [
      "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168"
    ],
    "created_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
    "name": "/etc/passwd and /etc/shadow",
    "description": "Adversaries may attempt to dump the contents of <code>/etc/passwd</code> and <code>/etc/shadow</code> to enable offline password cracking. Most modern Linux operating systems use a combination of <code>/etc/passwd</code> and <code>/etc/shadow</code> to store user account information including password hashes in <code>/etc/shadow</code>. By default, <code>/etc/shadow</code> is only readable by the root user.(Citation: Linux Password and Shadow File Formats)\n\nThe Linux utility, unshadow, can be used to combine the two files in a format suited for password cracking utilities such as John the Ripper:(Citation: nixCraft - John the Ripper) <code># /usr/bin/unshadow /etc/passwd /etc/shadow > /tmp/crack.password.db</code>\n",
    "id": "attack-pattern--d0b4fcdb-d67d-4ed2-99ce-788b12f8c0f4",
    "type": "attack-pattern",
    "kill_chain_phases": [
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "credential-access"
      }
    ],
    "modified": "2020-03-20T15:56:55.022Z",
    "created": "2020-02-11T18:46:56.263Z",
    "x_mitre_detection": "The AuditD monitoring tool, which ships stock in many Linux distributions, can be used to watch for hostile processes attempting to access <code>/etc/passwd</code> and <code>/etc/shadow</code>, alerting on the pid, process name, and arguments of such programs.",
    "x_mitre_permissions_required": [
      "root"
    ],
    "x_mitre_version": "1.0",
    "x_mitre_is_subtechnique": true,
    "x_mitre_platforms": [
      "Linux"
    ]
  },
  {
    "external_references": [
      {
        "source_name": "mitre-attack",
        "external_id": "T1557.002",
        "url": "https://attack.mitre.org/techniques/T1557/002"
      },
      {
        "source_name": "RFC826 ARP",
        "url": "https://tools.ietf.org/html/rfc826",
        "description": "Plummer, D. (1982, November). An Ethernet Address Resolution Protocol. Retrieved October 15, 2020."
      },
      {
        "source_name": "Sans ARP Spoofing Aug 2003",
        "url": "https://pen-testing.sans.org/resources/papers/gcih/real-world-arp-spoofing-105411",
        "description": "Siles, R. (2003, August). Real World ARP Spoofing. Retrieved October 15, 2020."
      },
      {
        "source_name": "Cylance Cleaver",
        "description": "Cylance. (2014, December). Operation Cleaver. Retrieved September 14, 2017.",
        "url": "https://www.cylance.com/content/dam/cylance/pages/operation-cleaver/Cylance_Operation_Cleaver_Report.pdf"
      }
    ],
    "object_marking_refs": [
      "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168"
    ],
    "created_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
    "name": "ARP Cache Poisoning",
    "description": "Adversaries may poison Address Resolution Protocol (ARP) caches to position themselves between the communication of two or more networked devices. This activity may be used to enable follow-on behaviors such as [Network Sniffing](https://attack.mitre.org/techniques/T1040) or [Transmitted Data Manipulation](https://attack.mitre.org/techniques/T1565/002).\n\nThe ARP protocol is used to resolve IPv4 addresses to link layer addresses, such as a media access control (MAC) address.(Citation: RFC826 ARP) Devices in a local network segment communicate with each other by using link layer addresses. If a networked device does not have the link layer address of a particular networked device, it may send out a broadcast ARP request to the local network to translate the IP address to a MAC address. The device with the associated IP address directly replies with its MAC address. The networked device that made the ARP request will then use as well as store that information in its ARP cache.\n\nAn adversary may passively wait for an ARP request to poison the ARP cache of the requesting device. The adversary may reply with their MAC address, thus deceiving the victim by making them believe that they are communicating with the intended networked device. For the adversary to poison the ARP cache, their reply must be faster than the one made by the legitimate IP address owner. Adversaries may also send a gratuitous ARP reply that maliciously announces the ownership of a particular IP address to all the devices in the local network segment.\n\nThe ARP protocol is stateless and does not require authentication. Therefore, devices may wrongly add or update the MAC address of the IP address in their ARP cache.(Citation: Sans ARP Spoofing Aug 2003)(Citation: Cylance Cleaver)\n\nAdversaries may use ARP cache poisoning as a means to man-in-the-middle (MiTM) network traffic. This activity may be used to collect and/or relay data such as credentials, especially those sent over an insecure, unencrypted protocol.(Citation: Sans ARP Spoofing Aug 2003)\n",
    "id": "attack-pattern--cabe189c-a0e3-4965-a473-dcff00f17213",
    "type": "attack-pattern",
    "kill_chain_phases": [
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "credential-access"
      },
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "collection"
      }
    ],
    "modified": "2020-10-16T15:22:11.604Z",
    "created": "2020-10-15T12:05:58.755Z",
    "x_mitre_version": "1.0",
    "x_mitre_is_subtechnique": true,
    "x_mitre_permissions_required": [
      "User"
    ],
    "x_mitre_detection": "Monitor network traffic for unusual ARP traffic, gratuitous ARP replies may be suspicious. \n\nConsider collecting changes to ARP caches across endpoints for signs of ARP poisoning. For example, if multiple IP addresses map to a single MAC address, this could be an indicator that the ARP cache has been poisoned.",
    "x_mitre_data_sources": [
      "Packet capture",
      "Netflow/Enclave netflow"
    ],
    "x_mitre_contributors": [
      "Jon Sternstein, Stern Security"
    ],
    "x_mitre_platforms": [
      "Linux",
      "Windows",
      "macOS"
    ]
  },
  {
    "external_references": [
      {
        "source_name": "mitre-attack",
        "external_id": "T1558.004",
        "url": "https://attack.mitre.org/techniques/T1558/004"
      },
      {
        "source_name": "Harmj0y Roasting AS-REPs Jan 2017",
        "url": "http://www.harmj0y.net/blog/activedirectory/roasting-as-reps/",
        "description": "HarmJ0y. (2017, January 17). Roasting AS-REPs. Retrieved August 24, 2020."
      },
      {
        "source_name": "Microsoft Kerberos Preauth 2014",
        "url": "https://social.technet.microsoft.com/wiki/contents/articles/23559.kerberos-pre-authentication-why-it-should-not-be-disabled.aspx",
        "description": "Sanyal, M.. (2014, March 18). Kerberos Pre-Authentication: Why It Should Not Be Disabled. Retrieved August 25, 2020."
      },
      {
        "source_name": "Stealthbits Cracking AS-REP Roasting Jun 2019",
        "url": "https://blog.stealthbits.com/cracking-active-directory-passwords-with-as-rep-roasting/",
        "description": "Jeff Warren. (2019, June 27). Cracking Active Directory Passwords with AS-REP Roasting. Retrieved August 24, 2020."
      },
      {
        "description": "Medin, T. (2014, November). Attacking Kerberos - Kicking the Guard Dog of Hades. Retrieved March 22, 2018.",
        "source_name": "SANS Attacking Kerberos Nov 2014",
        "url": "https://redsiege.com/kerberoast-slides"
      },
      {
        "url": "https://adsecurity.org/?p=2293",
        "description": "Metcalf, S. (2015, December 31). Cracking Kerberos TGS Tickets Using Kerberoast – Exploiting Kerberos to Compromise the Active Directory Domain. Retrieved March 22, 2018.",
        "source_name": "AdSecurity Cracking Kerberos Dec 2015"
      },
      {
        "url": "https://blogs.technet.microsoft.com/motiba/2018/02/23/detecting-kerberoasting-activity-using-azure-security-center/",
        "description": "Bani, M. (2018, February 23). Detecting Kerberoasting activity using Azure Security Center. Retrieved March 23, 2018.",
        "source_name": "Microsoft Detecting Kerberoasting Feb 2018"
      },
      {
        "source_name": "Microsoft 4768 TGT 2017",
        "url": "https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-4768",
        "description": "Microsoft. (2017, April 19). 4768(S, F): A Kerberos authentication ticket (TGT) was requested. Retrieved August 24, 2020."
      }
    ],
    "object_marking_refs": [
      "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168"
    ],
    "created_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
    "name": "AS-REP Roasting",
    "description": "Adversaries may reveal credentials of accounts that have disabled Kerberos preauthentication by [Password Cracking](https://attack.mitre.org/techniques/T1110/002) Kerberos messages.(Citation: Harmj0y Roasting AS-REPs Jan 2017) \n\nPreauthentication offers protection against offline [Password Cracking](https://attack.mitre.org/techniques/T1110/002). When enabled, a user requesting access to a resource initiates communication with the Domain Controller (DC) by sending an Authentication Server Request (AS-REQ) message with a timestamp that is encrypted with the hash of their password. If and only if the DC is able to successfully decrypt the timestamp with the hash of the user’s password, it will then send an Authentication Server Response (AS-REP) message that contains the Ticket Granting Ticket (TGT) to the user. Part of the AS-REP message is signed with the user’s password.(Citation: Microsoft Kerberos Preauth 2014)\n\nFor each account found without preauthentication, an adversary may send an AS-REQ message without the encrypted timestamp and receive an AS-REP message with TGT data which may be encrypted with an insecure algorithm such as RC4. The recovered encrypted data may be vulnerable to offline [Password Cracking](https://attack.mitre.org/techniques/T1110/002) attacks similarly to [Kerberoasting](https://attack.mitre.org/techniques/T1558/003) and expose plaintext credentials. (Citation: Harmj0y Roasting AS-REPs Jan 2017)(Citation: Stealthbits Cracking AS-REP Roasting Jun 2019) \n\nAn account registered to a domain, with or without special privileges, can be abused to list all domain accounts that have preauthentication disabled by utilizing Windows tools like [PowerShell](https://attack.mitre.org/techniques/T1059/001) with an LDAP filter. Alternatively, the adversary may send an AS-REQ message for each user. If the DC responds without errors, the account does not require preauthentication and the AS-REP message will already contain the encrypted data. (Citation: Harmj0y Roasting AS-REPs Jan 2017)(Citation: Stealthbits Cracking AS-REP Roasting Jun 2019)\n\nCracked hashes may enable [Persistence](https://attack.mitre.org/tactics/TA0003), [Privilege Escalation](https://attack.mitre.org/tactics/TA0004), and [Lateral Movement](https://attack.mitre.org/tactics/TA0008) via access to [Valid Accounts](https://attack.mitre.org/techniques/T1078).(Citation: SANS Attacking Kerberos Nov 2014)",
    "id": "attack-pattern--3986e7fd-a8e9-4ecb-bfc6-55920855912b",
    "type": "attack-pattern",
    "kill_chain_phases": [
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "credential-access"
      }
    ],
    "modified": "2020-10-20T19:30:11.783Z",
    "created": "2020-08-24T13:43:00.028Z",
    "x_mitre_version": "1.0",
    "x_mitre_is_subtechnique": true,
    "x_mitre_system_requirements": [
      "Valid domain account"
    ],
    "x_mitre_permissions_required": [
      "User"
    ],
    "x_mitre_detection": "Enable Audit Kerberos Service Ticket Operations to log Kerberos TGS service ticket requests. Particularly investigate irregular patterns of activity (ex: accounts making numerous requests, Event ID 4768 and 4769, within a small time frame, especially if they also request RC4 encryption [Type 0x17], pre-authentication not required [Type: 0x0]).(Citation: AdSecurity Cracking Kerberos Dec 2015)(Citation: Microsoft Detecting Kerberoasting Feb 2018)(Citation: Microsoft 4768 TGT 2017)",
    "x_mitre_data_sources": [
      "Windows event logs",
      "Authentication logs"
    ],
    "x_mitre_contributors": [
      "James Dunn, @jamdunnDFW, EY",
      "Swapnil Kumbhar",
      "Jacques Pluviose, @Jacqueswildy_IT",
      "Dan Nutting, @KerberToast"
    ],
    "x_mitre_platforms": [
      "Windows"
    ]
  },
  {
    "external_references": [
      {
        "source_name": "mitre-attack",
        "external_id": "T1548",
        "url": "https://attack.mitre.org/techniques/T1548"
      }
    ],
    "object_marking_refs": [
      "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168"
    ],
    "created_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
    "name": "Abuse Elevation Control Mechanism",
    "description": "Adversaries may circumvent mechanisms designed to control elevate privileges to gain higher-level permissions. Most modern systems contain native elevation control mechanisms that are intended to limit privileges that a user can perform on a machine. Authorization has to be granted to specific users in order to perform tasks that can be considered of higher risk. An adversary can perform several methods to take advantage of built-in control mechanisms in order to escalate privileges on a system.",
    "id": "attack-pattern--67720091-eee3-4d2d-ae16-8264567f6f5b",
    "type": "attack-pattern",
    "kill_chain_phases": [
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "privilege-escalation"
      },
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "defense-evasion"
      }
    ],
    "modified": "2020-07-22T21:36:52.825Z",
    "created": "2020-01-30T13:58:14.373Z",
    "x_mitre_data_sources": [
      "Windows Registry",
      "File monitoring",
      "Process command-line parameters",
      "API monitoring",
      "Process monitoring"
    ],
    "x_mitre_permissions_required": [
      "Administrator",
      "User"
    ],
    "x_mitre_detection": "Monitor the file system for files that have the setuid or setgid bits set. Also look for any process API calls for behavior that may be indicative of [Process Injection](https://attack.mitre.org/techniques/T1055) and unusual loaded DLLs through [DLL Search Order Hijacking](https://attack.mitre.org/techniques/T1574/001), which indicate attempts to gain access to higher privileged processes. On Linux, auditd can alert every time a user's actual ID and effective ID are different (this is what happens when you sudo).\n\nConsider monitoring for <code>/usr/libexec/security_authtrampoline</code> executions which may indicate that AuthorizationExecuteWithPrivileges is being executed. MacOS system logs may also indicate when AuthorizationExecuteWithPrivileges is being called. Monitoring OS API callbacks for the execution can also be a way to detect this behavior but requires specialized security tooling.\n\nOn Linux, auditd can alert every time a user's actual ID and effective ID are different (this is what happens when you sudo). This technique is abusing normal functionality in macOS and Linux systems, but sudo has the ability to log all input and output based on the <code>LOG_INPUT</code> and <code>LOG_OUTPUT</code> directives in the <code>/etc/sudoers</code> file.\n\nThere are many ways to perform UAC bypasses when a user is in the local administrator group on a system, so it may be difficult to target detection on all variations. Efforts should likely be placed on mitigation and collecting enough information on process launches and actions that could be performed before and after a UAC bypass is performed. Some UAC bypass methods rely on modifying specific, user-accessible Registry settings. Analysts should monitor Registry settings for unauthorized changes.",
    "x_mitre_version": "1.0",
    "x_mitre_is_subtechnique": false,
    "x_mitre_platforms": [
      "Linux",
      "macOS",
      "Windows"
    ]
  },
  {
    "object_marking_refs": [
      "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168"
    ],
    "external_references": [
      {
        "source_name": "mitre-attack",
        "external_id": "T1134",
        "url": "https://attack.mitre.org/techniques/T1134"
      },
      {
        "external_id": "CAPEC-633",
        "source_name": "capec",
        "url": "https://capec.mitre.org/data/definitions/633.html"
      },
      {
        "url": "https://pentestlab.blog/2017/04/03/token-manipulation/",
        "description": "netbiosX. (2017, April 3). Token Manipulation. Retrieved April 21, 2017.",
        "source_name": "Pentestlab Token Manipulation"
      },
      {
        "url": "https://technet.microsoft.com/en-us/windows-server-docs/identity/ad-ds/manage/component-updates/command-line-process-auditing",
        "description": "Mathers, B. (2017, March 7). Command line process auditing. Retrieved April 21, 2017.",
        "source_name": "Microsoft Command-line Logging"
      },
      {
        "url": "https://msdn.microsoft.com/en-us/library/windows/desktop/aa378184(v=vs.85).aspx",
        "description": "Microsoft TechNet. (n.d.). Retrieved April 25, 2017.",
        "source_name": "Microsoft LogonUser"
      },
      {
        "url": "https://msdn.microsoft.com/en-us/library/windows/desktop/aa446617(v=vs.85).aspx",
        "description": "Microsoft TechNet. (n.d.). Retrieved April 25, 2017.",
        "source_name": "Microsoft DuplicateTokenEx"
      },
      {
        "url": "https://msdn.microsoft.com/en-us/library/windows/desktop/aa378612(v=vs.85).aspx",
        "description": "Microsoft TechNet. (n.d.). Retrieved April 25, 2017.",
        "source_name": "Microsoft ImpersonateLoggedOnUser"
      },
      {
        "url": "https://www.blackhat.com/docs/eu-17/materials/eu-17-Atkinson-A-Process-Is-No-One-Hunting-For-Token-Manipulation.pdf",
        "description": "Atkinson, J., Winchester, R. (2017, December 7). A Process is No One: Hunting for Token Manipulation. Retrieved December 21, 2017.",
        "source_name": "BlackHat Atkinson Winchester Token Manipulation"
      }
    ],
    "description": "Adversaries may modify access tokens to operate under a different user or system security context to perform actions and bypass access controls. Windows uses access tokens to determine the ownership of a running process. A user can manipulate access tokens to make a running process appear as though it is the child of a different process or belongs to someone other than the user that started the process. When this occurs, the process also takes on the security context associated with the new token.\n\nAn adversary can use built-in Windows API functions to copy access tokens from existing processes; this is known as token stealing. These token can then be applied to an existing process (i.e. [Token Impersonation/Theft](https://attack.mitre.org/techniques/T1134/001)) or used to spawn a new process (i.e. [Create Process with Token](https://attack.mitre.org/techniques/T1134/002)). An adversary must already be in a privileged user context (i.e. administrator) to steal a token. However, adversaries commonly use token stealing to elevate their security context from the administrator level to the SYSTEM level. An adversary can then use a token to authenticate to a remote system as the account for that token if the account has appropriate permissions on the remote system.(Citation: Pentestlab Token Manipulation)\n\nAny standard user can use the <code>runas</code> command, and the Windows API functions, to create impersonation tokens; it does not require access to an administrator account. There are also other mechanisms, such as Active Directory fields, that can be used to modify access tokens.",
    "name": "Access Token Manipulation",
    "created_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
    "id": "attack-pattern--dcaa092b-7de9-4a21-977f-7fcb77e89c48",
    "type": "attack-pattern",
    "kill_chain_phases": [
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "defense-evasion"
      },
      {
        "kill_chain_name": "mitre-attack",
        "phase_name": "privilege-escalation"
      }
    ],
    "modified": "2020-04-16T19:37:02.355Z",
    "created": "2017-12-14T16:46:06.044Z",
    "x_mitre_defense_bypassed": [
      "Windows User Account Control",
      "System access controls",
      "File system access controls",
      "Heuristic Detection",
      "Host forensic analysis"
    ],
    "x_mitre_is_subtechnique": false,
    "x_mitre_version": "2.0",
    "x_mitre_contributors": [
      "Tom Ueltschi @c_APT_ure",
      "Travis Smith, Tripwire",
      "Robby Winchester, @robwinchester3",
      "Jared Atkinson, @jaredcatkinson"
    ],
    "x_mitre_data_sources": [
      "Authentication logs",
      "Windows event logs",
      "API monitoring",
      "Access tokens",
      "Process monitoring",
      "Process command-line parameters"
    ],
    "x_mitre_detection": "If an adversary is using a standard command-line shell, analysts can detect token manipulation by auditing command-line activity. Specifically, analysts should look for use of the <code>runas</code> command. Detailed command-line logging is not enabled by default in Windows.(Citation: Microsoft Command-line Logging)\n\nIf an adversary is using a payload that calls the Windows token APIs directly, analysts can detect token manipulation only through careful analysis of user network activity, examination of running processes, and correlation with other endpoint and network behavior. \n\nThere are many Windows API calls a payload can take advantage of to manipulate access tokens (e.g., <code>LogonUser</code> (Citation: Microsoft LogonUser), <code>DuplicateTokenEx</code>(Citation: Microsoft DuplicateTokenEx), and <code>ImpersonateLoggedOnUser</code>(Citation: Microsoft ImpersonateLoggedOnUser)). Please see the referenced Windows API pages for more information.\n\nQuery systems for process and thread token information and look for inconsistencies such as user owns processes impersonating the local SYSTEM account.(Citation: BlackHat Atkinson Winchester Token Manipulation)\n\nLook for inconsistencies between the various fields that store PPID information, such as the EventHeader ProcessId from data collected via Event Tracing for Windows (ETW), Creator Process ID/Name from Windows event logs, and the ProcessID and ParentProcessID (which are also produced from ETW and other utilities such as Task Manager and Process Explorer). The ETW provided EventHeader ProcessId identifies the actual parent process.",
    "x_mitre_permissions_required": [
      "User",
      "Administrator"
    ],
    "x_mitre_effective_permissions": [
      "SYSTEM"
    ],
    "x_mitre_platforms": [
      "Windows"
    ]
  },
  {
    "external_references": [
      {
        "source_name": "mitre-attack",
        "external_id": "T1015",
        "url": "https://attack.mitre.org/techniques/T1015"
      },
      {
        "external_id": "CAPEC-558",
        "source_name": "capec",
        "url": "https://capec.mitre.org/data/definitions/558.html"
      },
      {
        "url": "https://www.fireeye.com/blog/threat-research/2012/08/hikit-rootkit-advanced-persistent-attack-techniques-part-1.html",
        "description": "Glyer, C., Kazanciyan, R. (2012, August 20). The “Hikit” Rootkit: Advanced and Persistent Attack Techniques (Part 1). Retrieved June 6, 2016.",
        "source_name": "FireEye Hikit Rootkit"
      },
      {
        "url": "https://www.slideshare.net/DennisMaldonado5/sticky-keys-to-the-kingdom",
        "description": "Maldonado, D., McGuffin, T. (2016, August 6). Sticky Keys to the Kingdom. Retrieved July 5, 2017.",
        "source_name": "DEFCON2016 Sticky Keys"
      },
      {
        "url": "http://blog.crowdstrike.com/registry-analysis-with-crowdresponse/",
        "description": "Tilbury, C. (2014, August 28). Registry Analysis with CrowdResponse. Retrieved November 12, 2014.",
        "source_name": "Tilbury 2014"
      }
    ],
    "name": "Accessibility Features",
    "id": "attack-pattern--9b99b83a-1aac-4e29-b975-b374950551a3",
    "revoked": true,
    "type": "attack-pattern",
    "modified": "2020-05-13T20:37:30.008Z",
    "created": "2017-05-31T21:30:26.946Z"
  },
    {
      "object_marking_refs": [
        "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168"
      ],
      "external_references": [
        {
          "source_name": "mitre-attack",
          "url": "https://attack.mitre.org/software/S0066",
          "external_id": "S0066"
        },
        {
          "source_name": "CrowdStrike Putter Panda",
          "description": "Crowdstrike Global Intelligence Team. (2014, June 9). CrowdStrike Intelligence Report: Putter Panda. Retrieved January 22, 2016.",
          "url": "http://cdn0.vox-cdn.com/assets/4589853/crowdstrike-intelligence-report-putter-panda.original.pdf"
        }
      ],
      "description": "[3PARA RAT](https://attack.mitre.org/software/S0066) is a remote access tool (RAT) programmed in C++ that has been used by [Putter Panda](https://attack.mitre.org/groups/G0024). (Citation: CrowdStrike Putter Panda)",
      "name": "3PARA RAT",
      "created_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
      "id": "malware--7bec698a-7e20-4fd3-bb6a-12787770fb1a",
      "type": "malware",
      "labels": [
        "malware"
      ],
      "modified": "2020-03-30T18:34:04.031Z",
      "created": "2017-05-31T21:32:44.131Z",
      "x_mitre_version": "1.1",
      "x_mitre_aliases": [
        "3PARA RAT"
      ],
      "x_mitre_platforms": [
        "Windows"
      ]
    }
]
}
```

`thehive/test/resources/patternsUpdate.json`:

```json
{
  "type": "bundle",
  "id": "bundle--ad5f3bce-004b-417e-899d-392f8591ab55",
  "spec_version": "2.0",
  "objects": [
    {
      "id": "testPattern1",
      "name": "Updated testPattern1",
      "external_references": [
        {
          "source_name": "mitre-attack",
          "external_id": "T123",
          "url": "https://attack.mitre.org/techniques/T123"
        }
      ],
      "revoked": true,
      "type": "attack-pattern",
      "modified": "2020-01-24T14:14:05.452Z",
      "created": "2017-12-14T16:46:06.044Z"
    }
  ]
}
```