Project Path: arc_gmh5225_execution-trace-viewer_wi__qtww

Source Tree:

```txt
arc_gmh5225_execution-trace-viewer_wi__qtww
├── LICENSE.txt
├── README.md
├── core
│   ├── __init__.py
│   ├── api.py
│   ├── bookmark.py
│   ├── filter_and_find.py
│   ├── prefs.py
│   ├── trace_data.py
│   └── trace_files.py
├── docs
│   └── img
│       └── etv.png
├── gui
│   ├── __init__.py
│   ├── input_dialog.py
│   ├── mainwindow.py
│   ├── mainwindow.ui
│   ├── syntax_hl
│   │   ├── rules
│   │   │   ├── syntax_x86_dark.txt
│   │   │   ├── syntax_x86_light.txt
│   │   │   ├── value_dark.txt
│   │   │   └── value_light.txt
│   │   ├── syntax_hl_delegate.py
│   │   └── syntax_hl_log.py
│   └── widgets
│       ├── __init__.py
│       ├── filter_widget.py
│       ├── find_widget.py
│       ├── mem_table_widget.py
│       ├── pagination_widget.py
│       ├── reg_table_widget.py
│       └── trace_table_widget.py
├── plugins
│   ├── comment_mem_access.py
│   ├── comment_mem_access.yapsy-plugin
│   ├── exec_counts.py
│   ├── exec_counts.yapsy-plugin
│   ├── filter_by_mem_addr.py
│   ├── filter_by_mem_addr.yapsy-plugin
│   ├── list_bookmarks.py
│   ├── list_bookmarks.yapsy-plugin
│   ├── print_rows.py
│   ├── print_rows.yapsy-plugin
│   ├── print_selected_bookmarks.py
│   └── print_selected_bookmarks.yapsy-plugin
├── requirements.txt
├── traces
│   └── vmp3_32b_11k.tvt
└── tv.py

```

`LICENSE.txt`:

```txt
The MIT License

Copyright (c) 2019 Teemu Laurila

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
# Execution Trace Viewer

Execution Trace Viewer is an application for viewing, editing and analyzing execution traces. It was originally made for reverse engineering obfuscated code, but it can be used to analyze any kind of execution trace.

![Execution Trace Viewer](docs/img/etv.png "Execution Trace Viewer")

## Features

- open, edit and save execution traces
- search & filter trace by disasm, reg values, memory address/value, etc
- add comments and bookmarks
- write python plugins
- supports x64dbg traces

## Dependencies

- [Python 3.6](https://python.org/download)
- [PyQt5](https://www.riverbankcomputing.com/software/pyqt/intro)
- [Yapsy](https://github.com/tibonihoo/yapsy/)
- [QDarkStylesheet](https://github.com/ColinDuquesnoy/QDarkStyleSheet)
- [Capstone](https://github.com/aquynh/capstone)

## Install & run

```shell
git clone https://github.com/teemu-l/execution-trace-viewer

pip install pyqt5 yapsy qdarkstyle capstone
python tv.py
```

## Trace file formats

Following file formats are supported:

- .tvt - Default file format. Developed from x64dbg trace format. 3 differences with x64dbg format: comments, disasm and bookmarks added.

- .trace32 / .trace64 - x64dbg file format. Only reading supported. Loading x64dbg traces is slow because the code needs to be disassembled.

- json - Traces can be saved and loaded from json text files.

Traces folder contains one sample trace. It is ~11k lines of obfuscated code (by VMProtect3). All the handlers are disassembled and added to bookmarks table.

## Plugins

Execution Trace Viewer can be extended by Python3 plugins. Plugins are launched from plugins menu or from right-click menu on trace table. Check the example plugins and core/api.py for more info.

More plugins:

- [Memory trace graph](https://github.com/teemu-l/mem-trace-plugin)
- [Data visualizer](https://github.com/teemu-l/dataviz-plugin)
- your link here?

## Filters

Example filters:

| Filter                   | Description                                                   |
| ------------------------ | ------------------------------------------------------------- |
| disasm=push&#x7c;pop     | disasm contains word push or pop (push, pushfd, pop, etc)     |
| reg_eax=0x1337           | show rows where eax is 0x1337                                 |
| reg_any=0x1337           | any reg value is 0x1337                                       |
| mem_value=0x1337         | read or write value 0x1337 to memory                          |
| mem_read_value=0x1337    | read value 0x1337 from memory                                 |
| mem_addr=0x4f20          | read from or write to memory address 0x4f20                   |
| mem_read_addr=0x40400    | read from memory address 0x40400                              |
| mem_write_addr=0x40400   | write to memory address 0x40400                               |
| opcodes=c704             | filter by opcodes                                             |
| rows=20-50               | show only rows 20-50                                          |
| regex=0x40?00            | case-sensitive regex search for whole row (including comment) |
| regex=READ               | show insctructions which read memory                          |
| iregex=junk&#x7c;decrypt | inverse regex, rows with 'junk' or 'decrypt' are filtered out |
| comment=decrypt          | filter by comment                                             |

It's possible to join multiple filters together:

```
disasm=xor/reg_any=0x1337 ; show all xor instructions where atleast one register value is 0x1337
```

For more complex filtering you can create a filter plugin and save the result list using api.set_filtered_trace(). Then show the trace by calling api.show_filtered_trace().

## Find

Finds next or previous row that contains specified keyword/value in trace.

### Using Find in plugin

Find previous memory write:

```python
from core.filter_and_find import TraceField
current_row = 500
next_row = find(
    trace=trace_data.trace,
    field=TraceField.MEM,
    keyword='WRITE',
    start_row=current_row,
    direction=-1
)
```

Trace fields: DISASM, REGS, MEM, MEM_ADDR, MEM_VALUE, COMMENT, ANY

DISASM field supports multiple keywords: "xor/shl/shr". MEM field checks all three fields in mem access (access, addr and value). Integers must be given in hexadecimal.

## Themes

Dark theme can be disabled by editing prefs.py:

```python
USE_DARK_THEME = False
```

## To-Do

- add support for more trace formats & architectures
- fix x64dbg trace problem: if memory content doesn't change on write operation, the access is shown as 'READ' (bad design of the file format?)
- documentation

## License

MIT

## Author

Developed by Teemu Laurila.

Contact:

```python
print(''.join(map(chr,[k^86 for k in [34,51,51,59,35,58,55,22,38,36,57,34,57,56,59,55,63,58,120,53,57,59]])))
```

```

`core/api.py`:

```py
class Api:
    """Api class for plugins

    Attributes:
        main_window (MainWindow): MainWindow object
    """

    def __init__(self, main_window):
        """Inits Api."""
        self.main_window = main_window

    def add_bookmark(self, bookmark, replace=False):
        """Adds a new bookmark to bookmark table

        Args:
            new_bookmark (Bookmark): A new bookmark
            replace (bool): Replace an existing bookmark if found on same row?
                Defaults to False.
        """
        self.main_window.trace_data.add_bookmark(bookmark, replace)

    def ask_user(self, title: str, question: str):
        """Shows a messagebox with yes/no question

        Args:
            title (str): MessageBox title
            question (str): MessageBox question label
        Returns:
            bool: True if user clicked yes, False otherwise
        """
        return self.main_window.ask_user(title, question)

    def get_bookmarks(self):
        """Returns all bookmarks

        Returns:
            list: List of Bookmark objects
        """
        return self.main_window.trace_data.get_bookmarks()

    def get_filtered_trace(self):
        """Returns filtered_trace"""
        return self.main_window.filtered_trace

    def get_full_trace(self):
        """Returns full trace from TraceData object"""
        return self.main_window.trace_data.trace

    def get_main_window(self):
        """Returns main_window object"""
        return self.main_window

    def get_string_from_user(self, title: str, label: str):
        """Get string from user.

        Args:
            title (str): Input dialog title
            label (str): Input dialog label
        Returns:
            string: String given by user
        """
        return self.main_window.get_string_from_user(title, label)

    def get_values_from_user(self, title: str, data: list, on_ok_clicked=None):
        """Get input from user. Data types: str, int, list, bool.

        Args:
            title (str): Input dialog title
            data (list): List of dicts describing labels and data
            on_ok_clicked (method): Callback function to e.g. check the input
        Returns:
            list: List of values, empty list if canceled
        """
        return self.main_window.get_values_from_user(title, data, on_ok_clicked)

    def get_selected_bookmarks(self):
        """Returns list of selected bookmarks"""
        return self.main_window.get_selected_bookmarks()

    def get_selected_trace(self):
        """Returns list of selected trace"""
        row_ids = self.get_selected_trace_row_ids()
        trace_data = self.get_trace_data()
        trace = trace_data.get_trace_rows(row_ids)
        return trace

    def get_selected_trace_row_ids(self):
        """Returns list of ids of selected rows"""
        return self.main_window.get_selected_row_ids(self.main_window.trace_table)

    def get_trace_data(self):
        """Returns TraceData object"""
        return self.main_window.trace_data

    def get_visible_trace(self):
        """Returns visible trace, either full or filtered trace"""
        return self.main_window.get_visible_trace()

    def get_regs(self):
        """Returns dictionary of registers and their indexes"""
        return self.main_window.trace_data.get_regs()

    def go_to_row_in_full_trace(self, row_id: int):
        """Goes to given row in full trace

        Args:
            row_id (int): Row id
        """
        self.main_window.go_to_row_in_full_trace(row_id)

    def go_to_row_in_current_trace(self, row_index: int):
        """Goes to given row index in currently visible trace (full or filtered)

        Args:
            row_index (int): Row index in trace
        """
        self.main_window.go_to_row_in_visible_trace(row_index)

    def print(self, text: str):
        """Prints text to log

        Args:
            text (str): Text to print in log
        """
        self.main_window.print(str(text))

    def set_comment(self, row: int, comment: str):
        """Sets a comment to trace

        Args:
            row (int): A row index in full trace
            comment (str): A comment text
        """
        try:
            self.main_window.trace_data.trace[row]["comment"] = str(comment)
        except IndexError:
            print(f"Error. Could not set comment to row {row}")

    def set_filtered_trace(self, trace):
        """Sets filtered_trace

        Args:
            trace (list): List of trace rows
        """
        self.main_window.filtered_trace = trace

    def show_filtered_trace(self):
        """Shows filtered trace on trace_table"""
        self.main_window.show_filtered_trace()

    def show_messagebox(self, title: str, msg: str):
        """Shows a messagebox

        Args:
            title (str): Title of messagebox
            msg (str): Message to show
        """
        self.main_window.show_messagebox(title, msg)

    def update_trace_table(self):
        """Updates trace_table"""
        self.main_window.trace_table.populate()

    def update_bookmark_table(self):
        """Updates bookmark_table"""
        self.main_window.update_bookmark_table()

```

`core/bookmark.py`:

```py
class Bookmark:
    """Bookmark class for TraceData

    Attributes:
        addr (str): Address of startrow
        disasm (str): Disassembly of bookmark's startrow
        startrow (int): First row of bookmark (index in trace list)
        endrow (int): Last row of bookmark
        comment (str): Comment
    """
    def __init__(self, addr="", disasm="", startrow=0, endrow=0, comment=""):
        self.addr = addr
        self.disasm = disasm
        self.startrow = startrow
        self.endrow = endrow
        self.comment = comment

```

`core/filter_and_find.py`:

```py
import re
from enum import Enum, auto


class TraceField(Enum):
    """Enum for trace fields.
    DISASM, REGS, MEM, MEM_ADDR, MEM_VALUE, COMMENT or ANY
    """

    DISASM = auto()
    REGS = auto()
    MEM = auto()
    MEM_ADDR = auto()
    MEM_VALUE = auto()
    COMMENT = auto()
    ANY = auto()


def find(
    trace: list, field: TraceField, keyword: str, start_row: int = 0, direction: int = 1
):
    """Finds next/previous trace row with keyword

    Args:
        trace (list): Traced instructions, registers and memory (TraceData.trace)
        field (TraceField): Which field(s) to search
        keyword (str): Keyword to search for
        start_row (int): Trace row number to start search
        direction (int, optional): Search direction, 1 for forward, -1 for backward
            Defaults to 1.
    Returns:
        Trace row number, None if nothing found
    """
    if not keyword or not trace or start_row > len(trace):
        return None

    last_row = len(trace)

    if direction < 0:
        last_row = -1

    if field == TraceField.DISASM:
        keywords = keyword.split("/")
        for row in range(start_row, last_row, direction):
            disasm = trace[row]["disasm"]
            for key in keywords:
                if key in disasm:
                    return row

    elif field == TraceField.REGS:
        value = int(keyword, 16)
        for row in range(start_row, last_row, direction):
            if value in trace[row]["regs"]:
                return row

    elif field == TraceField.MEM:
        keyword = keyword.strip()
        if "0x" in keyword:
            keyword = int(keyword, 16)
        for row in range(start_row, last_row, direction):
            for mem in trace[row]["mem"]:
                if keyword in mem.values():
                    return row

    elif field == TraceField.MEM_ADDR:
        keyword = keyword.strip()
        addr = int(keyword, 16)
        for row in range(start_row, last_row, direction):
            for mem in trace[row]["mem"]:
                if addr == mem["addr"]:
                    return row

    elif field == TraceField.MEM_VALUE:
        keyword = keyword.strip()
        value = int(keyword, 16)
        for row in range(start_row, last_row, direction):
            for mem in trace[row]["mem"]:
                if value == mem["value"]:
                    return row

    elif field == TraceField.COMMENT:
        for row in range(start_row, last_row, direction):
            if keyword in trace[row].get("comment", ""):
                return row

    elif field == TraceField.ANY:
        keyword_int = None
        if keyword.startswith("0x"):
            keyword_int = int(keyword, 16)

        for row in range(start_row, last_row, direction):
            if keyword in trace[row].get("comment", ""):
                return row
            for mem in trace[row]["mem"]:
                mem_values = mem.values()
                if keyword in mem_values:
                    return row
                if keyword_int and keyword_int in mem_values:
                    return row
            if keyword in trace[row]["disasm"]:
                return row
            if keyword_int and keyword_int in trace[row]["regs"]:
                return row

    else:
        raise ValueError("Unknown field")

    return None


def filter_trace(trace: list, regs: dict, filter_text: str):
    """Filters trace

    Args:
        trace (list): Traced instructions, registers and memory (TraceData.trace)
        filter_text (str): Filter text
        regs (dict): Register names and indexes (TraceData.regs)
    Raises:
      ValueError: If unknown keywords or wrong filter format
    Returns:
        List of filtered trace records
    """
    data = trace
    if len(filter_text) == 0:
        return data
    filters = filter_text.split("/")
    if not filters or not data:
        raise ValueError("Empty trace or filter")
    value = ""

    for f in filters:
        f_parts = f.split("=")
        if len(f_parts) != 2 or not f_parts[1]:
            raise ValueError("Wrong filter format")
        value = f_parts[1]
        if f_parts[0] == "rows":
            rows = value.split("-")
            start = int(rows[0])
            end = int(rows[1])
            data = data[start : end + 1]
        elif f_parts[0] == "disasm":
            disasm_list = f_parts[1].split("|")
            data = list(
                filter(lambda x: any(k for k in disasm_list if k in x["disasm"]), data)
            )
        elif f_parts[0] == "opcodes":
            data = list(filter(lambda x: value in x["opcodes"], data))
        elif f_parts[0] == "comment":
            data = list(filter(lambda x: value in x.get("comment", ""), data))
        elif "reg_" in f_parts[0]:
            reg = f_parts[0].split("_")[1]
            value = int(value, 16)
            if reg == "any":
                data = list(filter(lambda x: value in x["regs"], data))
            elif data and reg in regs:
                reg_index = regs[reg]
                data = list(filter(lambda x: x["regs"][reg_index] == value, data))
            else:
                raise ValueError(f"Unknown register: {reg}")
        elif f_parts[0] == "regex":
            data = list(filter(lambda x: re.search(value, str(x)) is not None, data))
        elif f_parts[0] == "iregex":
            data = list(filter(lambda x: re.search(value, str(x)) is None, data))
        elif f_parts[0] == "mem_value":
            value = int(value, 16)
            data = list(
                filter(lambda x: any(k for k in x["mem"] if k["value"] == value), data)
            )
        elif f_parts[0] == "mem_read_value":
            value = int(value, 16)
            data = list(
                filter(
                    lambda x: any(
                        k
                        for k in x["mem"]
                        if k["value"] == value and k["access"] == "READ"
                    ),
                    data,
                )
            )
        elif f_parts[0] == "mem_write_value":
            value = int(value, 16)
            data = list(
                filter(
                    lambda x: any(
                        k
                        for k in x["mem"]
                        if k["value"] == value and k["access"] == "WRITE"
                    ),
                    data,
                )
            )
        elif f_parts[0] == "mem_addr":
            value = int(value, 16)
            data = list(
                filter(lambda x: any(k for k in x["mem"] if k["addr"] == value), data)
            )
        elif f_parts[0] == "mem_read_addr":
            value = int(value, 16)
            data = list(
                filter(
                    lambda x: any(
                        k
                        for k in x["mem"]
                        if k["addr"] == value and k["access"] == "READ"
                    ),
                    data,
                )
            )
        elif f_parts[0] == "mem_write_addr":
            value = int(value, 16)
            data = list(
                filter(
                    lambda x: any(
                        k
                        for k in x["mem"]
                        if k["addr"] == value and k["access"] == "WRITE"
                    ),
                    data,
                )
            )
        else:
            raise ValueError(f"Unknown word: {f_parts[0]}")
    return data

```

`core/prefs.py`:

```py
PACKAGE_NAME = "Execution Trace Viewer"
PACKAGE_AUTHOR = "Teemu Laurila"
PACKAGE_URL = "https://github.com/teemu-l/execution-trace-viewer"
PACKAGE_VERSION = "1.0.0"
PACKAGE_COPYRIGHTS = "(C) 2019 Teemu Laurila"

DEBUG = True

WINDOW_WIDTH = 1300
WINDOW_HEIGHT = 800

LIGHT_THEME = "Fusion"
USE_DARK_THEME = False

TRACE_FONT = "Courier"
TRACE_FONT_SIZE = 8
TRACE_SHOW_OLD_REG_VALUE = False
TRACE_SHOW_GRID = True

HIGHLIGHT_MODIFIED_REGS = True

TRACE_HL_DISASM_COLUMNS = [3]
TRACE_HL_VALUE_COLUMNS = [4, 5]
BOOKMARK_HL_DISASM_COLUMNS = [3]
BOOKMARK_HL_VALUE_COLUMNS = [2, 4]

USE_SYNTAX_HIGHLIGHT_IN_TRACE = True
USE_SYNTAX_HIGHLIGHT_IN_LOG = True

REG_HL_COLOR = "white"
REG_HL_BG_COLORS = [
    "blue",
    "red",
    "green",
    "magenta",
    "#a328e0",
    "#cc0a4a",
    "#cc7800",
    "#d68711",
]
DISASM_RULES_FILE = "gui/syntax_hl/rules/syntax_x86_light.txt"
VALUE_RULES_FILE = "gui/syntax_hl/rules/value_light.txt"
if USE_DARK_THEME:
    REG_HL_COLOR = "black"
    REG_HL_BG_COLORS = ["magenta", "green", "pink", "lightgreen", "#7bbef2", "#f96459"]
    DISASM_RULES_FILE = "gui/syntax_hl/rules/syntax_x86_dark.txt"
    VALUE_RULES_FILE = "gui/syntax_hl/rules/value_dark.txt"

HL_REGS_X86 = {
    "r8": ["r8", "r8d", "r8w", "r8b"],
    "r9": ["r9", "r9d", "r9w", "r9b"],
    "r10": ["r10", "r10d", "r10w", "r10b"],
    "r11": ["r11", "r11d", "r11w", "r11b"],
    "r12": ["r12", "r12d", "r12w", "r12b"],
    "r13": ["r13", "r13d", "r13w", "r13b"],
    "r14": ["r14", "r14d", "r14w", "r14b"],
    "r15": ["r15", "r15d", "r15w", "r15b"],
}
HL_REGS_X86.update(dict.fromkeys(["rax", "eax"], ["rax", "eax", "ax", "ah", "al"]))
HL_REGS_X86.update(dict.fromkeys(["rbx", "ebx"], ["rbx", "ebx", "bx", "bh", "bl"]))
HL_REGS_X86.update(dict.fromkeys(["rcx", "ecx"], ["rcx", "ecx", "cx", "ch", "cl"]))
HL_REGS_X86.update(dict.fromkeys(["rdx", "edx"], ["rdx", "edx", "dx", "dh", "dl"]))
HL_REGS_X86.update(dict.fromkeys(["rbp", "ebp"], ["rbp", "ebp", "bp", "bpl"]))
HL_REGS_X86.update(dict.fromkeys(["rsi", "esi"], ["rsi", "esi", "si", "sil"]))
HL_REGS_X86.update(dict.fromkeys(["rdi", "edi"], ["rdi", "edi", "di", "dil"]))
HL_REGS_X86.update(dict.fromkeys(["rip", "eip"], ["rip", "eip", "ip"]))
HL_REGS_X86.update(dict.fromkeys(["rsp", "esp"], ["rsp", "esp", "sp", "spl"]))


SHOW_SAMPLE_FILTERS = True
SAMPLE_FILTERS = [
    "",
    "disasm=push|pop",
    "reg_eax=0x1",
    "reg_any=0x1",
    "rows=0-200",
    "regex=0x40?00",
    "iregex=junk|decrypt",
    "mem_value=0x1",
    "mem_read_value=0x1",
    "mem_write_value=0x1",
    "mem_addr=0x4f20",
    "mem_read_addr=0x4f20",
    "mem_write_addr=0x4f20",
    "opcodes=c704",
    "comment=decrypt",
]

FIND_FIELDS = [
    "Disasm",
    "Registers",
    "Mem (any field)",
    "Mem address",
    "Mem value",
    "Comment",
    "Any",
]

# columns for tables
TRACE_LABELS = ["#", "address", "opcodes", "disasm", "registers", "comment"]
BOOKMARK_LABELS = ["start row", "end row", "addr", "disasm", "comment"]
REG_LABELS = ["reg", "hex", "dec"]
MEM_LABELS = ["access", "address", "value"]

TRACE_ROW_HEIGHT = 20

PAGINATION_ENABLED = True
PAGINATION_ROWS_PER_PAGE = 10000

# ask for comment when creating a bookmark?
ASK_FOR_BOOKMARK_COMMENT = True

# registers for x64dbg traces
# if you want to see more regs, add them here (in correct order)
# check the order of regs from REGISTERCONTEXT:
# https://github.com/x64dbg/x64dbg/blob/development/src/bridge/bridgemain.h#L723
X32_REGS = [
    "eax",
    "ecx",
    "edx",
    "ebx",
    "esp",
    "ebp",
    "esi",
    "edi",
    "eip",
    "eflags",
    "gs",
    "fs",
    "es",
    "ds",
    "cs",
    "ss",
    "dr0",
    "dr1",
    "dr2",
    "dr3",
    "dr6",
    "dr7",
]
X64_REGS = [
    "rax",
    "rcx",
    "rdx",
    "rbx",
    "rsp",
    "rbp",
    "rsi",
    "rdi",
    "r8",
    "r9",
    "r10",
    "r11",
    "r12",
    "r13",
    "r14",
    "r15",
    "rip",
    "eflags",
    "gs",
    "fs",
    "es",
    "ds",
    "cs",
    "ss",
    "dr0",
    "dr1",
    "dr2",
    "dr3",
    "dr6",
    "dr7",
]

# disable this to show all registers
REG_FILTER_ENABLED = True

# regs not on this list are filtered out of reglist
REG_FILTER = [
    "eax",
    "ecx",
    "edx",
    "ebx",
    "esp",
    "ebp",
    "esi",
    "edi",
    "eip",
    "rax",
    "rcx",
    "rdx",
    "rbx",
    "rsp",
    "rbp",
    "rsi",
    "rdi",
    "r8",
    "r9",
    "r10",
    "r11",
    "r12",
    "r13",
    "r14",
    "r15",
    "rip",
    "eflags",
    # "gs","fs","es","ds","cs","ss",
    "dr0",
    "dr1",
    "dr2",
    "dr3",
    "dr6",
    "dr7",
]

```

`core/trace_data.py`:

```py
from operator import attrgetter


class TraceData:
    """TraceData class.

    Class for storing execution trace and bookmarks.

    Attributes:
        filename (str): A trace file name.
        arch (str): CPU architecture.
        ip_reg (str): Name of instruction pointer register
        pointer_size (int): Pointer size (4 in x86, 8 in x64)
        regs (dict): Register names and indexes
        trace (list): A list of traced instructions, registers and memory accesses.
        bookmarks (list): A list of bookmarks.
    """

    def __init__(self):
        """Inits TraceData."""
        self.filename = ""
        self.arch = ""
        self.ip_reg = ""
        self.pointer_size = 0
        self.regs = {}
        self.trace = []
        self.bookmarks = []

    def clear(self):
        """Clears trace and all data"""
        self.trace = []
        self.bookmarks = []

    def get_trace(self):
        """Returns a full trace

        Returns:
            list: Trace
        """
        return self.trace

    def get_regs(self):
        """Returns dict of registers and their indexes

        Returns:
            dict: Regs
        """
        return self.regs

    def get_regs_and_values(self, row):
        """Returns dict of registers and their values

        Returns:
            dict: Register names and values
        """
        registers = {}
        try:
            reg_values = self.trace[row]["regs"]
            for reg_name, reg_index in self.regs.items():
                reg_value = reg_values[reg_index]
                registers[reg_name] = reg_value
        except IndexError:
            print(f"Error. Could not get regs from row {row}.")
            return {}
        return registers

    def get_reg_index(self, reg_name):
        """Returns a register index

        Args:
            reg_name (str): Register name
        Returns:
            int: Register index
        """
        try:
            index = self.regs[reg_name]
        except KeyError:
            print("Unknown register")
        return index

    def get_modified_regs(self, row):
        """Returns modfied regs

        Args:
            row (int): Trace row index
        Returns:
            list: List of register names
        """
        modified_regs = []
        reg_values = self.trace[row]["regs"]
        next_row = row + 1
        if next_row < len(self.trace):
            next_row_data = self.trace[next_row]
            for reg_name, reg_index in self.regs.items():
                reg_value = reg_values[reg_index]
                next_reg_value = next_row_data["regs"][reg_index]
                if next_reg_value != reg_value:
                    modified_regs.append(reg_name)
        return modified_regs

    def get_trace_rows(self, rows):
        """Returns a trace of given rows

        Args:
            rows (list): List of trace indexes
        Returns:
            list: Trace
        """
        trace = []
        try:
            trace = [self.trace[int(i)] for i in rows]
        except IndexError:
            print("Error. Could not get trace rows.")
        return trace

    def get_instruction_pointer_name(self):
        """Returns an instruction pointer name

        Returns:
            str: Instruction pointer name
        """
        if self.ip_reg:
            return self.ip_reg
        elif "eip" in self.regs:
            return "eip"
        elif "rip" in self.regs:
            return "rip"
        elif "ip" in self.regs:
            return "ip"
        elif "pc" in self.regs:
            return "pc"
        return ""

    def get_instruction_pointer(self, row):
        """Returns a value of instruction pointer of given row

        Args:
            row: A row index in trace
        Returns:
            int: Address of instruction
        """
        ip = 0
        ip_reg = self.get_instruction_pointer_name()
        try:
            reg_index = self.regs[ip_reg]
            ip = self.trace[row]["regs"][reg_index]
        except IndexError:
            print(f"Error. Could not get IP from row {row}")
        return ip

    def set_comment(self, row, comment):
        """Adds a comment to trace

        Args:
            row (int): Row index in trace
            comment (str): Comment text
        """
        try:
            self.trace[row]["comment"] = str(comment)
        except IndexError:
            print(f"Error. Could not set comment to row {row}")

    def add_bookmark(self, new_bookmark, replace=False):
        """Adds a new bookmark

        Args:
            new_bookmark (Bookmark): A new bookmark
            replace (bool): Replace an existing bookmark if found on same row?
                Defaults to False.
        """
        for i, bookmark in enumerate(self.bookmarks):
            if bookmark.startrow == new_bookmark.startrow:
                if replace:
                    self.bookmarks[i] = new_bookmark
                    print(f"Bookmark at {bookmark.startrow} replaced.")
                else:
                    print(f"Error: bookmark at {bookmark.startrow} already exists.")
                return
        self.bookmarks.append(new_bookmark)
        self.sort_bookmarks()

    def delete_bookmark(self, index):
        """Deletes a bookmark

        Args:
            index (int): Index on bookmark list
        Returns:
            bool: True if bookmark deleted, False otherwise
        """
        try:
            del self.bookmarks[index]
        except IndexError:
            print(f"Error. Could not delete a bookmark {index}")
            return False
        return True

    def sort_bookmarks(self):
        """Sorts bookmarks by startrow"""
        self.bookmarks.sort(key=attrgetter("startrow"))

    def get_bookmark_from_row(self, row):
        """Returns a bookmark for a given trace row.

        Args:
            row (int): Trace row index
        Returns:
            Bookmark: Returns A Bookmark if found, None otherwise.
        """
        for bookmark in self.bookmarks:
            if bookmark.startrow <= row <= bookmark.endrow:
                return bookmark
        return None

    def get_bookmarks(self):
        """Returns all bookmarks

        Returns:
            list: List of bookmarks
        """
        return self.bookmarks

    def set_bookmarks(self, bookmarks):
        """Sets bookmarks

        Args:
            bookmarks (list): Bookmarks
        """
        self.bookmarks = bookmarks

    def clear_bookmarks(self):
        """Clears bookmarks"""
        self.bookmarks = []

```

`core/trace_files.py`:

```py
import json
import traceback
from capstone import Cs, CS_ARCH_X86, CS_MODE_32, CS_MODE_64

from core.trace_data import TraceData
from core.bookmark import Bookmark
from core import prefs


def open_trace(filename):
    """Opens trace file and reads trace data and bookmarks

    Args:
        filename: name of trace file
    """
    try:
        with open(filename, "rb") as f:
            magic = f.read(4)
    except IOError:
        print("Error, could not open file.")
    else:
        if magic == b"TRAC":
            return open_x64dbg_trace(filename)
        elif magic == b"TVTR":
            return open_tv_trace(filename)
        return open_json_trace(filename)
    return None


def open_tv_trace(filename):
    """Opens tvt trace file and reads trace data and bookmarks

    Args:
        filename: name of trace file
    """
    with open(filename, "rb") as f:
        trace_data = TraceData()
        trace_data.filename = filename

        # check first 4 bytes
        magic = f.read(4)
        if magic != b"TVTR":
            raise ValueError("Error, wrong file format.")

        json_length_bytes = f.read(4)
        json_length = int.from_bytes(json_length_bytes, "little")

        # read JSON blob
        json_blob = f.read(json_length)
        json_str = str(json_blob, "utf-8")
        file_info = json.loads(json_str)

        arch = file_info.get("arch", "")

        reg_indexes = {}
        if arch == "x64":
            regs = prefs.X64_REGS
            for i, reg in enumerate(regs):
                reg_indexes[reg] = i
            pointer_size = 8  # qword
            ip_reg = "rip"
        elif arch == "x86":
            regs = prefs.X32_REGS
            for i, reg in enumerate(regs):
                reg_indexes[reg] = i
            pointer_size = 4  # dword
            ip_reg = "eip"
        else:
            print(f"Unknown CPU arch: {arch} Let's try to load it anyway.")
            ip_reg = file_info.get("ip_reg", "")
            pointer_size = file_info.get("pointer_size", 4)

        if "regs" in file_info:
            reg_indexes = {}
            for i, reg in enumerate(file_info["regs"]):
                reg_indexes[reg] = i

        trace_data.arch = arch
        trace_data.ip_reg = ip_reg
        trace_data.regs = reg_indexes
        trace_data.pointer_size = pointer_size

        reg_values = [None] * len(reg_indexes)
        trace = []
        row_id = 0
        while f.peek(1)[:1] == b"\x00":
            f.read(1)
            disasm = ""
            disasm_length = int.from_bytes(f.read(1), "little")
            if disasm_length > 0:
                disasm = f.read(disasm_length).decode()

            comment = ""
            comment_length = int.from_bytes(f.read(1), "little")
            if comment_length > 0:
                comment = f.read(comment_length).decode()

            register_changes = int.from_bytes(f.read(1), "little")
            memory_accesses = int.from_bytes(f.read(1), "little")
            flags_and_opcode_size = int.from_bytes(f.read(1), "little")  # Bitfield
            thread_id_bit = (flags_and_opcode_size >> 7) & 1  # msb
            opcode_size = flags_and_opcode_size & 15  # 4 lsb

            if thread_id_bit > 0:
                thread_id = int.from_bytes(f.read(4), "little")

            opcodes = f.read(opcode_size)

            register_change_position = []
            for _ in range(register_changes):
                register_change_position.append(int.from_bytes(f.read(1), "little"))

            register_change_new_data = []
            for _ in range(register_changes):
                register_change_new_data.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_flags = []
            for _ in range(memory_accesses):
                memory_access_flags.append(int.from_bytes(f.read(1), "little"))

            memory_access_addresses = []
            for _ in range(memory_accesses):
                memory_access_addresses.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_data = []
            for i in range(memory_accesses):
                memory_access_data.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            reg_id = 0
            regchanges = ""
            for i, change in enumerate(register_change_position):
                reg_id += change
                if reg_id + i < len(reg_indexes):
                    reg_values[reg_id + i] = register_change_new_data[i]
                if reg_id + i < len(reg_indexes) and row_id > 0:
                    reg_name = regs[reg_id + i]
                    if reg_name is not ip_reg:
                        old_value = trace[-1]["regs"][reg_id + i]
                        new_value = register_change_new_data[i]
                        if old_value != new_value:
                            if prefs.TRACE_SHOW_OLD_REG_VALUE:
                                regchanges += (
                                    f"{reg_name}: {hex(old_value)} -> {hex(new_value)} "
                                )
                            else:
                                regchanges += f"{reg_name}: {hex(new_value)} "
                            if 0x7F > new_value > 0x1F:
                                regchanges += f"'{chr(new_value)}' "

            mems = []
            mem = {}
            for i in range(memory_accesses):
                flag = memory_access_flags[i]
                value = memory_access_data[i]
                mem["access"] = "READ"
                if flag & 1 == 1:
                    mem["access"] = "WRITE"

                mem["addr"] = memory_access_addresses[i]
                mem["value"] = value
                mems.append(mem.copy())

            if regchanges:
                trace[-1]["regchanges"] = regchanges

            trace_row = {}
            trace_row["id"] = row_id
            if ip_reg:
                trace_row["ip"] = reg_values[reg_indexes[ip_reg]]
            trace_row["disasm"] = disasm
            trace_row["comment"] = comment
            trace_row["regs"] = reg_values.copy()
            trace_row["opcodes"] = opcodes.hex()
            trace_row["mem"] = mems.copy()
            trace.append(trace_row)
            row_id += 1

        trace_data.trace = trace

        while f.peek(1)[:1] == b"\x01":
            f.read(1)
            bookmark = Bookmark()
            bookmark.startrow = int.from_bytes(f.read(4), "little")
            bookmark.endrow = int.from_bytes(f.read(4), "little")
            disasm_length = int.from_bytes(f.read(1), "little")
            bookmark.disasm = f.read(disasm_length).decode()
            comment_length = int.from_bytes(f.read(1), "little")
            bookmark.comment = f.read(comment_length).decode()
            addr_length = int.from_bytes(f.read(1), "little")
            bookmark.addr = f.read(addr_length).decode()
            trace_data.add_bookmark(bookmark)

        return trace_data


def open_json_trace(filename):
    """Opens JSON trace file and reads trace data and bookmarks

    Args:
        filename: name of trace file
    """
    try:
        f = open(filename)
    except IOError:
        print("Error, could not open file.")
    else:
        with f:
            try:
                trace_data = TraceData()
                data = json.load(f)
                trace_data.bookmarks = []
                trace_data.filename = filename
                trace_data.trace = data["trace"]
                trace_data.arch = data.get("arch", "")
                trace_data.ip_reg = data.get("ip_reg", "")
                trace_data.pointer_size = data.get("pointer_size", 4)
                trace_data.regs = data.get("regs", {})
                if "bookmarks" in data:
                    for bookmark in data["bookmarks"]:
                        trace_data.add_bookmark(Bookmark(**bookmark))
                return trace_data
            except KeyError:
                print("Error while reading trace file.")
            except Exception as exc:
                print("Error while reading trace file: " + str(exc))
                print(traceback.format_exc())
    return None


def save_as_json(trace_data, filename):
    """Saves trace data to file in JSON format

    Args:
        trace_data: TraceData object
        filename: name of trace file
    """
    data = {
        "arch": trace_data.arch,
        "regs": trace_data.regs,
        "ip_reg": trace_data.ip_reg,
        "pointer_size": trace_data.pointer_size,
        "trace": trace_data.trace,
        "bookmarks": [vars(h) for h in trace_data.bookmarks],
    }
    with open(filename, "w") as f:
        json.dump(data, f)


def save_as_tv_trace(trace_data, filename):
    """Saves trace data in a default Trace Viewer format

    Args:
        trace_data: TraceData object
        filename: name of trace file
    """
    try:
        f = open(filename, "wb")
    except IOError:
        print("Error, could not write to file.")
    else:
        with f:
            trace = trace_data.trace
            f.write(b"TVTR")
            file_info = {"arch": trace_data.arch, "version": "1.0"}
            if trace_data.pointer_size:
                pointer_size = trace_data.pointer_size
            elif trace_data.arch == "x64":
                pointer_size = 8
            else:
                pointer_size = 4

            file_info["pointer_size"] = pointer_size
            file_info["regs"] = list(trace_data.regs.keys())
            file_info["ip_reg"] = trace_data.ip_reg

            json_blob = json.dumps(file_info)
            json_blob_length = len(json_blob)
            f.write((json_blob_length).to_bytes(4, byteorder="little"))
            f.write(json_blob.encode())

            for i, t in enumerate(trace):
                f.write(b"\x00")

                disasm = t["disasm"][:255]  # limit length to 0xff
                f.write((len(disasm)).to_bytes(1, byteorder="little"))
                f.write(disasm.encode())

                comment = t["comment"][:255]
                f.write((len(comment)).to_bytes(1, byteorder="little"))
                f.write(comment.encode())

                reg_change_newdata = []
                reg_change_positions = []
                pos = 0
                for reg_index, reg_value in enumerate(t["regs"]):
                    if i == 0 or reg_value != trace[i - 1]["regs"][reg_index]:
                        reg_change_newdata.append(reg_value)  # value changed
                        reg_change_positions.append(pos)
                        pos = -1
                    pos += 1

                reg_changes = len(reg_change_positions) & 0xFF
                f.write((reg_changes).to_bytes(1, byteorder="little"))

                memory_accesses = len(t["mem"]) & 0xFF
                f.write((memory_accesses).to_bytes(1, byteorder="little"))

                flag = 0
                opcodes = bytes.fromhex(t["opcodes"])
                opcode_size = len(opcodes)
                if "thread" in t:
                    flag = flag | (1 << 7)
                flags_and_opcode_size = flag | opcode_size

                f.write((flags_and_opcode_size).to_bytes(1, byteorder="little"))
                if "thread" in t:
                    f.write((t["thread"]).to_bytes(4, byteorder="little"))
                f.write(opcodes)

                for pos in reg_change_positions:
                    f.write((pos).to_bytes(1, byteorder="little"))

                for newdata in reg_change_newdata:
                    f.write((newdata).to_bytes(pointer_size, byteorder="little"))

                mem_access_flags = []
                mem_access_addresses = []
                mem_access_data = []
                for mem_access in t["mem"]:
                    flag = 0
                    if mem_access["access"].lower() == "write":
                        flag = 1
                    mem_access_flags.append(flag)
                    mem_access_data.append(mem_access["value"])
                    mem_access_addresses.append(mem_access["addr"])

                for flag in mem_access_flags:
                    f.write((flag).to_bytes(1, byteorder="little"))
                for addr in mem_access_addresses:
                    f.write((addr).to_bytes(pointer_size, byteorder="little"))
                for data in mem_access_data:
                    f.write((data).to_bytes(pointer_size, byteorder="little"))

            for bookmark in trace_data.bookmarks:
                f.write(b"\x01")
                f.write((bookmark.startrow).to_bytes(4, byteorder="little"))
                f.write((bookmark.endrow).to_bytes(4, byteorder="little"))
                disasm = bookmark.disasm[:255]
                disasm_length = len(disasm)
                f.write((disasm_length).to_bytes(1, byteorder="little"))
                f.write(disasm.encode())
                comment = bookmark.comment[:255]
                comment_length = len(comment)
                f.write((comment_length).to_bytes(1, byteorder="little"))
                f.write(comment.encode())
                addr = bookmark.addr[:255]
                addr_length = len(addr)
                f.write((addr_length).to_bytes(1, byteorder="little"))
                f.write(addr.encode())


def open_x64dbg_trace(filename):
    """Opens x64dbg trace file

    Args:
        filename: name of trace file
    Returns:
        TraceData object
    """
    with open(filename, "rb") as f:
        trace_data = TraceData()
        trace_data.filename = filename

        # check first 4 bytes
        magic = f.read(4)
        if magic != b"TRAC":
            raise ValueError("Error, wrong file format.")

        json_length_bytes = f.read(4)
        json_length = int.from_bytes(json_length_bytes, "little")

        # read JSON blob
        json_blob = f.read(json_length)
        json_str = str(json_blob, "utf-8")
        arch = json.loads(json_str)["arch"]

        reg_indexes = {}
        if arch == "x64":
            regs = prefs.X64_REGS
            ip_reg = "rip"
            capstone_mode = CS_MODE_64
            pointer_size = 8  # qword
        else:
            regs = prefs.X32_REGS
            ip_reg = "eip"
            capstone_mode = CS_MODE_32
            pointer_size = 4  # dword

        for i, reg in enumerate(regs):
            reg_indexes[reg] = i

        trace_data.arch = arch
        trace_data.ip_reg = ip_reg
        trace_data.regs = reg_indexes
        trace_data.pointer_size = pointer_size

        md = Cs(CS_ARCH_X86, capstone_mode)
        reg_values = [None] * len(reg_indexes)
        trace = []
        row_id = 0
        while f.read(1) == b"\x00":
            register_changes = int.from_bytes(f.read(1), "little")
            memory_accesses = int.from_bytes(f.read(1), "little")
            flags_and_opcode_size = int.from_bytes(f.read(1), "little")  # Bitfield
            thread_id_bit = (flags_and_opcode_size >> 7) & 1  # msb
            opcode_size = flags_and_opcode_size & 15  # 4 lsbs

            if thread_id_bit > 0:
                thread_id = int.from_bytes(f.read(4), "little")

            opcodes = f.read(opcode_size)

            register_change_position = []
            for _ in range(register_changes):
                register_change_position.append(int.from_bytes(f.read(1), "little"))

            register_change_new_data = []
            for _ in range(register_changes):
                register_change_new_data.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_flags = []
            for _ in range(memory_accesses):
                memory_access_flags.append(int.from_bytes(f.read(1), "little"))

            memory_access_addresses = []
            for _ in range(memory_accesses):
                memory_access_addresses.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_old_data = []
            for _ in range(memory_accesses):
                memory_access_old_data.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_new_data = []
            for i in range(memory_accesses):
                if memory_access_flags[i] & 1 == 0:
                    memory_access_new_data.append(
                        int.from_bytes(f.read(pointer_size), "little")
                    )

            reg_id = 0
            regchanges = ""
            for i, change in enumerate(register_change_position):
                reg_id += change
                if reg_id + i < len(reg_indexes):
                    reg_values[reg_id + i] = register_change_new_data[i]
                if reg_id + i < len(reg_indexes) and row_id > 0:
                    reg_name = regs[reg_id + i]
                    if reg_name is not ip_reg:
                        old_value = trace[-1]["regs"][reg_id + i]
                        new_value = register_change_new_data[i]
                        if old_value != new_value:
                            if prefs.TRACE_SHOW_OLD_REG_VALUE:
                                regchanges += (
                                    f"{reg_name}: {hex(old_value)} -> {hex(new_value)} "
                                )
                            else:
                                regchanges += f"{reg_name}: {hex(new_value)} "
                            if 0x7F > new_value > 0x1F:
                                regchanges += f"'{chr(new_value)}' "

            # disassemble
            ip = reg_values[reg_indexes[ip_reg]]
            for _address, _size, mnemonic, op_str in md.disasm_lite(opcodes, ip):
                disasm = mnemonic
                if op_str:
                    disasm += " " + op_str

            mems = []
            mem = {}
            new_data_counter = 0
            for i in range(memory_accesses):
                flag = memory_access_flags[i]
                value = memory_access_old_data[i]
                mem["access"] = "READ"
                if flag & 1 == 0:
                    value = memory_access_new_data[new_data_counter]
                    mem["access"] = "WRITE"
                    new_data_counter += 1
                else:
                    pass
                    # memory value didn't change
                    # (it is read or overwritten with identical value)
                    # this has to be fixed somehow in x64dbg

                mem["addr"] = memory_access_addresses[i]

                # fix value (x64dbg saves all values as qwords)
                if "qword" in disasm:
                    pass
                elif "dword" in disasm:
                    value &= 0xFFFFFFFF
                elif "word" in disasm:
                    value &= 0xFFFF
                elif "byte" in disasm:
                    value &= 0xFF
                mem["value"] = value
                mems.append(mem.copy())

            if regchanges:
                trace[-1]["regchanges"] = regchanges

            trace_row = {}
            trace_row["id"] = row_id
            trace_row["ip"] = ip
            trace_row["disasm"] = disasm
            trace_row["regs"] = reg_values.copy()
            trace_row["opcodes"] = opcodes.hex()
            trace_row["mem"] = mems.copy()
            # trace_row["comment"] = ""
            trace.append(trace_row)
            row_id += 1

        trace_data.trace = trace
        return trace_data

```

`gui/input_dialog.py`:

```py
"""Dialog to get values from user"""
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QDialog,
    QWidget,
    QGridLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QComboBox,
    QCheckBox,
)


class InputDialog(QDialog):
    def __init__(self, parent=None, title="Title", data=[], on_ok_clicked=None):
        QWidget.__init__(self, parent)

        self.setWindowFlags(
            Qt.Dialog
            | Qt.WindowTitleHint
            | Qt.CustomizeWindowHint
            | Qt.WindowCloseButtonHint
        )
        self.data = data
        self.output_data = []
        self.on_ok_clicked = on_ok_clicked

        mainLayout = QGridLayout()

        # create labels and input widgets
        for i, item in enumerate(self.data):

            label_widget = QLabel(item["label"] + ":")

            if isinstance(item["data"], bool):
                input_widget = QCheckBox()
                input_widget.setChecked(item["data"])
            elif isinstance(item["data"], (int, str)):
                default = str(item.get("data", ""))
                input_widget = QLineEdit(default)
            elif isinstance(item["data"], list):
                input_widget = QComboBox()
                input_widget.addItems(item["data"])
            else:
                print(f"Error. Unknown data type: {type(item['data'])}")
                return

            if "tooltip" in item:
                input_widget.setToolTip(str(item["tooltip"]))
                label_widget.setToolTip(str(item["tooltip"]))

            item["widget"] = input_widget

            mainLayout.addWidget(label_widget, i, 0)
            mainLayout.addWidget(input_widget, i, 1)

        ok_btn = QPushButton("Ok")
        ok_btn.clicked.connect(self.on_ok_btn_clicked)
        mainLayout.addWidget(ok_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.on_cancel_btn_clicked)
        mainLayout.addWidget(cancel_btn)

        self.setLayout(mainLayout)
        self.setWindowTitle(title)

    def on_ok_btn_clicked(self):
        data = []
        for item in self.data:
            if isinstance(item["data"], bool):
                data.append(item["widget"].isChecked())
            elif isinstance(item["data"], str):
                data.append(item["widget"].text())
            elif isinstance(item["data"], int):
                text = item["widget"].text()
                text = text.strip()  # remove whitespaces
                try:
                    if "0x" in text:
                        data.append(int(text, 16))
                    else:
                        data.append(int(text))
                except ValueError:
                    print(f"Error, could not convert {text} to integer.")
                    return
            elif isinstance(item["data"], list):
                data.append(int(item["widget"].currentIndex()))

        # call callback function to check the data
        if self.on_ok_clicked and not self.on_ok_clicked(data):
            return

        self.output_data = data
        self.close()

    def on_cancel_btn_clicked(self):
        self.output_data = []
        self.close()

    def get_data(self):
        return self.output_data

```

`gui/mainwindow.py`:

```py
import sys
import os
import functools
import traceback

from PyQt5 import uic
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QCursor, QFont
from PyQt5.QtWidgets import (
    QMainWindow,
    QAction,
    QMenu,
    QFileDialog,
    QAbstractItemView,
    QMessageBox,
    QInputDialog,
    QLineEdit,
    QTableWidgetItem,
    QApplication,
)
from yapsy.PluginManager import PluginManager

from core.trace_data import TraceData
from core import trace_files
from core.filter_and_find import find
from core.filter_and_find import filter_trace
from core.filter_and_find import TraceField
from core.api import Api
from core import prefs
from gui.syntax_hl.syntax_hl_log import AsmHighlighter
from gui.syntax_hl.syntax_hl_delegate import SyntaxHighlightDelegate
from gui.widgets.pagination_widget import PaginationWidget
from gui.widgets.find_widget import FindWidget
from gui.widgets.filter_widget import FilterWidget
from gui.input_dialog import InputDialog


class MainWindow(QMainWindow):
    """MainWindow class

    Attributes:
        trace_data (TraceData): TraceData object
        filtered_trace (list): Filtered trace
    """

    def __init__(self, parent=None):
        """Inits MainWindow, UI and plugins"""
        super(MainWindow, self).__init__(parent)
        self.api = Api(self)
        self.trace_data = TraceData()
        self.filtered_trace = []
        self.filter_text = ""
        self.init_plugins()
        self.init_ui()
        if len(sys.argv) > 1:
            self.open_trace(sys.argv[1])

    def dragEnterEvent(self, event):
        """QMainWindow method reimplementation for file drag."""
        event.setDropAction(Qt.MoveAction)
        super().dragEnterEvent(event)
        event.accept()

    def dropEvent(self, event):
        """QMainWindow method reimplementation for file drop."""
        super().dropEvent(event)
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                local_file = url.toLocalFile()
                if os.path.isfile(local_file):
                    self.open_trace(local_file)

    def init_ui(self):
        """Inits UI"""
        uic.loadUi("gui/mainwindow.ui", self)

        self.setWindowTitle(prefs.PACKAGE_NAME)

        # accept file drops
        self.setAcceptDrops(True)

        self.resize(prefs.WINDOW_WIDTH, prefs.WINDOW_HEIGHT)

        # make trace table wider than regs&mem
        self.splitter1.setSizes([1000, 100])
        self.splitter2.setSizes([600, 100])

        # Init trace table
        self.trace_table.itemSelectionChanged.connect(self.on_trace_table_row_changed)
        self.trace_table.setColumnCount(len(prefs.TRACE_LABELS))
        self.trace_table.setHorizontalHeaderLabels(prefs.TRACE_LABELS)
        self.trace_table.horizontalHeader().setStretchLastSection(True)
        self.trace_table.bookmarkCreated.connect(self.add_bookmark)
        self.trace_table.commentEdited.connect(self.set_comment)
        self.trace_table.printer = self.print
        self.trace_table.set_row_height(prefs.TRACE_ROW_HEIGHT)

        trace_font = QFont(prefs.TRACE_FONT)
        trace_font.setPointSize(prefs.TRACE_FONT_SIZE)
        self.trace_table.setFont(trace_font)
        self.bookmark_table.setFont(trace_font)
        self.trace_table.setShowGrid(prefs.TRACE_SHOW_GRID)

        if prefs.USE_SYNTAX_HIGHLIGHT_IN_TRACE:
            self.trace_table.init_syntax_highlight()

        # trace pagination
        if prefs.PAGINATION_ENABLED:
            self.trace_pagination = PaginationWidget()
            self.trace_pagination.pageChanged.connect(self.trace_table.populate)
            self.horizontalLayout.addWidget(self.trace_pagination)
            self.trace_pagination.set_enabled(True)
            self.trace_pagination.rows_per_page = prefs.PAGINATION_ROWS_PER_PAGE

            self.trace_table.pagination = self.trace_pagination
            self.horizontalLayout.setAlignment(self.trace_pagination, Qt.AlignLeft)

        # these are used to remember current pages & scroll values for both traces
        self.trace_current_pages = [1, 1]
        self.trace_scroll_values = [0, 0]

        self.reg_table.create_context_menu()
        self.reg_table.setColumnCount(len(prefs.REG_LABELS))
        self.reg_table.setHorizontalHeaderLabels(prefs.REG_LABELS)
        self.reg_table.horizontalHeader().setStretchLastSection(True)
        self.reg_table.regCheckBoxChanged.connect(self.on_reg_checkbox_change)
        self.reg_table.printer = self.print

        if prefs.REG_FILTER_ENABLED:
            self.reg_table.filtered_regs = prefs.REG_FILTER

        if not prefs.USE_DARK_THEME:
            trace_style = (
                "QTableView { selection-background-color: #dddddd; selection-"
                "color: #000000; border: 0px;} QTableWidget::item { padding: 0px; border: 0px}"
            )
            reg_style = (
                "QTableView { selection-background-color: #eee864; selection"
                "-color: #000000;}"
            )
            self.trace_table.setStyleSheet(trace_style)
            self.bookmark_table.setStyleSheet(trace_style)
            self.reg_table.setStyleSheet(reg_style)

        # Init memory table
        self.mem_table.setColumnCount(len(prefs.MEM_LABELS))
        self.mem_table.setHorizontalHeaderLabels(prefs.MEM_LABELS)
        self.mem_table.horizontalHeader().setStretchLastSection(True)

        # Init bookmark table
        self.bookmark_table.setColumnCount(len(prefs.BOOKMARK_LABELS))
        self.bookmark_table.setHorizontalHeaderLabels(prefs.BOOKMARK_LABELS)
        self.bookmark_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.bookmark_table.customContextMenuRequested.connect(
            self.bookmark_table_context_menu_event
        )

        self.bookmark_table.delegate = SyntaxHighlightDelegate(self)
        self.bookmark_table.delegate.disasm_columns = prefs.BOOKMARK_HL_DISASM_COLUMNS
        self.bookmark_table.delegate.value_columns = prefs.BOOKMARK_HL_VALUE_COLUMNS
        self.bookmark_table.setItemDelegate(self.bookmark_table.delegate)

        self.bookmark_menu = QMenu(self)

        go_action = QAction("Go to bookmark", self)
        go_action.triggered.connect(self.go_to_bookmark_in_trace)
        self.bookmark_menu.addAction(go_action)

        delete_bookmarks_action = QAction("Delete bookmark(s)", self)
        delete_bookmarks_action.triggered.connect(self.delete_bookmarks)
        self.bookmark_menu.addAction(delete_bookmarks_action)

        # Menu
        exit_action = QAction("&Exit", self)
        exit_action.setShortcut("Ctrl+Q")
        exit_action.setStatusTip("Exit application")
        exit_action.triggered.connect(self.close)

        open_trace_action = QAction("&Open trace..", self)
        open_trace_action.setStatusTip("Open trace")
        open_trace_action.triggered.connect(self.dialog_open_trace)

        self.save_trace_action = QAction("&Save trace", self)
        self.save_trace_action.setStatusTip("Save trace")
        self.save_trace_action.triggered.connect(self.save_trace)
        self.save_trace_action.setEnabled(False)

        save_trace_as_action = QAction("&Save trace as..", self)
        save_trace_as_action.setStatusTip("Save trace as..")
        save_trace_as_action.triggered.connect(self.dialog_save_trace_as)

        save_trace_as_json_action = QAction("&Save trace as JSON..", self)
        save_trace_as_json_action.setStatusTip("Save trace as JSON..")
        save_trace_as_json_action.triggered.connect(self.dialog_save_trace_as_json)

        file_menu = self.menu_bar.addMenu("&File")
        file_menu.addAction(open_trace_action)
        file_menu.addAction(self.save_trace_action)
        file_menu.addAction(save_trace_as_action)
        file_menu.addAction(save_trace_as_json_action)
        file_menu.addAction(exit_action)

        self.plugins_topmenu = self.menu_bar.addMenu("&Plugins")

        clear_bookmarks_action = QAction("&Clear bookmarks", self)
        clear_bookmarks_action.setStatusTip("Clear bookmarks")
        clear_bookmarks_action.triggered.connect(self.clear_bookmarks)

        bookmarks_menu = self.menu_bar.addMenu("&Bookmarks")
        bookmarks_menu.addAction(clear_bookmarks_action)

        # Create right click menu for trace table
        self.create_trace_table_menu()
        # Create plugins menu on menu bar
        self.create_plugins_menu()

        about_action = QAction("&About", self)
        about_action.triggered.connect(self.show_about_dialog)

        about_menu = self.menu_bar.addMenu("&About")
        about_menu.addAction(about_action)

        if prefs.USE_SYNTAX_HIGHLIGHT_IN_LOG:
            self.highlight = AsmHighlighter(self.log_text_edit.document())

        # trace select
        self.select_trace_combo_box.addItem("Full trace")
        self.select_trace_combo_box.addItem("Filtered trace")
        self.select_trace_combo_box.currentIndexChanged.connect(
            self.on_trace_combo_box_index_changed
        )

        self.filter_widget = FilterWidget()
        self.filter_widget.filterBtnClicked.connect(self.on_filter_btn_clicked)
        self.horizontalLayout.addWidget(self.filter_widget)
        if prefs.SHOW_SAMPLE_FILTERS:
            self.filter_widget.set_sample_filters(prefs.SAMPLE_FILTERS)

        self.find_widget = FindWidget()
        self.find_widget.findBtnClicked.connect(self.on_find_btn_clicked)
        self.find_widget.set_fields(prefs.FIND_FIELDS)
        self.horizontalLayout.addWidget(self.find_widget)

        self.show()

    def init_plugins(self):
        """Inits plugins"""
        self.manager = PluginManager()
        self.manager.setPluginPlaces(["plugins"])
        self.manager.collectPlugins()
        for plugin in self.manager.getAllPlugins():
            print_debug(f"Plugin found: {plugin.name}")

    def create_plugins_menu(self):
        """Creates plugins menu"""
        self.plugins_topmenu.clear()

        reload_action = QAction("Reload plugins", self)
        reload_action.setShortcut("Ctrl+R")
        func = functools.partial(self.reload_plugins)
        reload_action.triggered.connect(func)
        self.plugins_topmenu.addAction(reload_action)
        self.plugins_topmenu.addSeparator()

        plugins_menu = QMenu("Run plugin", self)

        for plugin in self.manager.getAllPlugins():
            action = QAction(plugin.name, self)
            func = functools.partial(self.execute_plugin, plugin)
            action.triggered.connect(func)
            plugins_menu.addAction(action)
        self.plugins_topmenu.addMenu(plugins_menu)

    def create_trace_table_menu(self):
        """Creates right click menu for trace table"""
        self.trace_table_menu = QMenu(self)

        print_action = QAction("Print selected cells", self)
        print_action.triggered.connect(self.trace_table.print_selected_cells)
        self.trace_table_menu.addAction(print_action)

        add_bookmark_action = QAction("Add Bookmark", self)
        add_bookmark_action.triggered.connect(self.trace_table.create_bookmark)
        self.trace_table_menu.addAction(add_bookmark_action)

        plugins_menu = QMenu("Plugins", self)

        for plugin in self.manager.getAllPlugins():
            action = QAction(plugin.name, self)
            func = functools.partial(self.execute_plugin, plugin)
            action.triggered.connect(func)
            plugins_menu.addAction(action)
        self.trace_table_menu.addMenu(plugins_menu)
        self.trace_table.menu = self.trace_table_menu

    def reload_plugins(self):
        """Reloads plugins"""
        self.init_plugins()
        self.create_trace_table_menu()
        self.create_plugins_menu()

    def on_trace_table_row_changed(self):
        """Called when selected row changes"""
        selected_row_ids = self.get_selected_row_ids(self.trace_table)
        if not selected_row_ids:
            return
        row_id = selected_row_ids[0]
        regs = self.trace_data.get_regs_and_values(row_id)
        modified_regs = []
        if prefs.HIGHLIGHT_MODIFIED_REGS:
            modified_regs = self.trace_data.get_modified_regs(row_id)
        self.reg_table.set_data(regs, modified_regs)
        mem = []
        if "mem" in self.trace_data.trace[row_id]:
            mem = self.trace_data.trace[row_id]["mem"]
        self.mem_table.set_data(mem)
        self.update_status_bar()

    def on_filter_btn_clicked(self, filter_text: str):
        self.filter_text = filter_text
        if self.trace_data is None:
            return
        try:
            filtered_trace = filter_trace(
                self.trace_data.trace, self.trace_data.get_regs(), filter_text,
            )
        except Exception as exc:
            self.show_messagebox("Filter error", f"{exc}")
            # print(traceback.format_exc())
        else:
            self.filtered_trace = filtered_trace
            self.show_filtered_trace()
            self.update_status_bar()

    def on_find_btn_clicked(self, keyword: str, field_index: int, direction: int):
        """Find next or prev button clicked"""
        current_row = self.trace_table.currentRow()
        if current_row < 0:
            current_row = 0

        if self.trace_table.pagination is not None:
            pagination = self.trace_table.pagination
            page = pagination.current_page
            rows_per_page = pagination.rows_per_page
            current_row += (page - 1) * rows_per_page

        if field_index == 0:
            field = TraceField.DISASM
        elif field_index == 1:
            field = TraceField.REGS
        elif field_index == 2:
            field = TraceField.MEM
        elif field_index == 3:
            field = TraceField.MEM_ADDR
        elif field_index == 4:
            field = TraceField.MEM_VALUE
        elif field_index == 5:
            field = TraceField.COMMENT
        elif field_index == 6:
            field = TraceField.ANY

        try:
            row_number = find(
                trace=self.get_visible_trace(),
                field=field,
                keyword=keyword,
                start_row=current_row + direction,
                direction=direction,
            )
        except Exception as exc:
            self.show_messagebox("Find error", f"{exc}")
            print(traceback.format_exc())
            self.print(traceback.format_exc())
            return

        if row_number is not None:
            self.trace_table.go_to_row(row_number)
        else:
            print_debug(
                f"{keyword} not found (row: {current_row}, direction: {direction})"
            )

    def get_visible_trace(self):
        """Returns the trace that is currently shown on trace table"""
        index = self.select_trace_combo_box.currentIndex()
        if self.trace_data is not None:
            if index == 0:
                return self.trace_data.trace
            else:
                return self.filtered_trace
        return None

    def bookmark_table_context_menu_event(self):
        """Context menu for bookmark table right click"""
        self.bookmark_menu.popup(QCursor.pos())

    def dialog_open_trace(self):
        """Shows dialog to open trace file"""
        all_traces = "All traces (*.tvt *.trace32 *.trace64)"
        all_files = "All files (*.*)"
        filename = QFileDialog.getOpenFileName(
            self, "Open trace", "", all_traces + ";; " + all_files
        )[0]
        if filename:
            self.open_trace(filename)
            if self.trace_data:
                self.save_trace_action.setEnabled(True)

    def dialog_save_trace_as(self):
        """Shows a dialog to select a save file"""
        filename = QFileDialog.getSaveFileName(
            self, "Save trace as", "", "Trace Viewer traces (*.tvt);; All files (*.*)"
        )[0]
        print_debug("Save trace as: " + filename)
        if filename and trace_files.save_as_tv_trace(self.trace_data, filename):
            self.trace_data.filename = filename
            self.save_trace_action.setEnabled(True)

    def dialog_save_trace_as_json(self):
        """Shows a dialog to save trace to JSON file"""
        filename = QFileDialog.getSaveFileName(
            self, "Save as JSON", "", "JSON files (*.txt);; All files (*.*)"
        )[0]
        print_debug("Save trace as: " + filename)
        if filename:
            trace_files.save_as_json(self.trace_data, filename)

    def execute_plugin(self, plugin):
        """Executes a plugin and updates tables"""
        print_debug(f"Executing a plugin: {plugin.name}")
        try:
            plugin.plugin_object.execute(self.api)
        except Exception:
            print("Error in plugin:")
            print(traceback.format_exc())
            self.print("Error in plugin:")
            self.print(traceback.format_exc())
        finally:
            if prefs.USE_SYNTAX_HIGHLIGHT_IN_LOG:
                self.highlight.rehighlight()

    def show_filtered_trace(self):
        """Shows filtered_trace on trace_table"""
        if self.select_trace_combo_box.currentIndex() == 0:
            self.select_trace_combo_box.setCurrentIndex(1)
        else:
            self.trace_table.set_data(self.filtered_trace)
            self.trace_table.populate()

    def set_comment(self, row_id, comment):
        """Sets comment to row on full trace"""
        self.trace_data.set_comment(row_id, comment)

    def on_bookmark_table_cell_edited(self, item):
        """Called when any cell is edited on bookmark table"""
        cell_type = item.whatsThis()
        bookmarks = self.trace_data.get_bookmarks()
        row = self.bookmark_table.currentRow()
        if row < 0:
            print_debug("Error, could not edit bookmark.")
            return
        if cell_type == "startrow":
            bookmarks[row].startrow = int(item.text())
        elif cell_type == "endrow":
            bookmarks[row].endrow = int(item.text())
        elif cell_type == "address":
            bookmarks[row].addr = item.text()
        elif cell_type == "disasm":
            bookmarks[row].disasm = item.text()
        elif cell_type == "comment":
            bookmarks[row].comment = item.text()
        else:
            print_debug("Unknown field edited on bookmark table...")

    def open_trace(self, filename):
        """Opens and reads a trace file"""
        print_debug(f"Opening trace file: {filename}")
        self.close_trace()
        self.trace_data = trace_files.open_trace(filename)
        if self.trace_data is None:
            print_debug(f"Error, couldn't open trace file: {filename}")
        else:
            if prefs.PAGINATION_ENABLED:
                self.trace_pagination.set_current_page(1, True)
            self.trace_table.get_syntax_highlighter().reset()
            self.trace_table.set_data(self.trace_data.trace)
            self.trace_table.populate()
            self.trace_table.selectRow(0)
            self.setWindowTitle(f"{filename.split('/')[-1]} - {prefs.PACKAGE_NAME}")

        self.update_bookmark_table()
        self.trace_table.update_column_widths()

    def close_trace(self):
        """Clears trace and updates UI"""
        self.trace_data = None
        self.filtered_trace = []
        self.trace_table.set_data([])
        self.update_ui()

    def update_ui(self):
        """Updates tables and status bar"""
        self.trace_table.populate()
        self.update_bookmark_table()
        self.update_status_bar()

    def save_trace(self):
        """Saves a trace file"""
        filename = self.trace_data.filename
        print_debug("Save trace: " + filename)
        if filename:
            trace_files.save_as_tv_trace(self.trace_data, filename)

    def show_about_dialog(self):
        """Shows an about dialog"""
        title = "About"
        name = prefs.PACKAGE_NAME
        version = prefs.PACKAGE_VERSION
        copyrights = prefs.PACKAGE_COPYRIGHTS
        url = prefs.PACKAGE_URL
        text = f"{name} {version} \n {copyrights} \n {url}"
        QMessageBox().about(self, title, text)

    def update_column_widths(self, table):
        """Updates column widths of a TableWidget to match the content"""
        table.setVisible(False)  # fix ui glitch with column widths
        table.resizeColumnsToContents()
        table.horizontalHeader().setStretchLastSection(True)
        table.setVisible(True)

    def update_status_bar(self):
        """Updates status bar"""
        if self.trace_data is None:
            return
        table = self.trace_table
        row = table.currentRow()

        row_count = table.rowCount()
        row_info = f"{row}/{row_count - 1}"
        msg = f"Row: {row_info} "

        selected_row_id = 0
        row_ids = self.trace_table.get_selected_row_ids()
        if row_ids:
            selected_row_id = row_ids[0]

        msg += f" | {len(self.trace_data.trace)} rows in full trace."
        if len(self.filter_text) > 0:
            msg += f" | {len(self.filtered_trace)} rows in filtered trace."

        bookmark = self.trace_data.get_bookmark_from_row(selected_row_id)
        if bookmark:
            msg += f" | Bookmark: {bookmark.disasm}   ; {bookmark.comment}"

        self.status_bar.showMessage(msg)

    def on_reg_checkbox_change(self, reg: str, is_checked: bool):
        """Callback for register checkbox change"""

        highlighter = self.trace_table.get_syntax_highlighter()
        if highlighter:
            highlighter.set_reg_highlight(reg, is_checked)
            # force repaint, update() didn't work
            self.trace_table.setVisible(False)
            self.trace_table.setVisible(True)
        else:
            print_debug("Error, highlighter not found!")

    def get_selected_row_ids(self, table):
        """Returns IDs of all selected rows of TableWidget.

        Args:
            table: PyQt TableWidget
        returns:
            list: Ordered list of row ids
        """
        # use a set so we don't get duplicate ids
        row_ids_set = set(
            table.item(index.row(), 0).text() for index in table.selectedIndexes()
        )
        try:
            row_ids_list = [int(i) for i in row_ids_set]
        except ValueError:
            print_debug("Error. Values in the first column must be integers.")
            return []
        return sorted(row_ids_list)

    def on_trace_combo_box_index_changed(self, index):
        """Trace selection combo box index changed"""
        self.trace_table.set_data(self.get_visible_trace())

        other_index = index ^ 1
        if prefs.PAGINATION_ENABLED:
            # save current page
            self.trace_current_pages[other_index] = self.trace_pagination.current_page
            self.trace_pagination.set_current_page(
                self.trace_current_pages[index], True
            )

        # save scrollbar value
        current_scroll = self.trace_table.verticalScrollBar().value()
        self.trace_scroll_values[other_index] = current_scroll
        next_value = self.trace_scroll_values[index]

        self.trace_table.populate()
        QApplication.processEvents()  # this is needed to update the scrollbar
        self.trace_table.verticalScrollBar().setValue(next_value)

    def go_to_row_in_visible_trace(self, row):
        """Goes to given row in currently visible trace"""
        self.trace_table.go_to_row(row)
        self.tab_widget.setCurrentIndex(0)

    def go_to_row_in_full_trace(self, row_id):
        """Switches to full trace and goes to given row"""
        # make sure we are shown full trace, not filtered
        if self.select_trace_combo_box.currentIndex() == 1:
            self.select_trace_combo_box.setCurrentIndex(0)
        self.go_to_row_in_visible_trace(row_id)

    def go_to_bookmark_in_trace(self):
        """Goes to trace row of selected bookmark"""
        selected_row_ids = self.get_selected_row_ids(self.bookmark_table)
        if not selected_row_ids:
            print_debug("Error. No bookmark selected.")
            return
        self.go_to_row_in_full_trace(selected_row_ids[0])

    def clear_bookmarks(self):
        """Clears all bookmarks"""
        self.trace_data.clear_bookmarks()
        self.update_bookmark_table()

    def delete_bookmarks(self):
        """Deletes selected bookmarks"""
        selected = self.bookmark_table.selectedItems()
        if not selected:
            print_debug("Could not delete a bookmark. Nothing selected.")
            return
        selected_rows = sorted(set({sel.row() for sel in selected}))
        for row in reversed(selected_rows):
            self.trace_data.delete_bookmark(row)
            self.bookmark_table.removeRow(row)

    def get_selected_bookmarks(self):
        """Returns selected bookmarks"""
        selected = self.bookmark_table.selectedItems()
        if not selected:
            print_debug("No bookmarks selected.")
            return []
        selected_rows = sorted(set({sel.row() for sel in selected}))
        all_bookmarks = self.trace_data.get_bookmarks()
        return [all_bookmarks[i] for i in selected_rows]

    def add_bookmark(self, bookmark):
        if prefs.ASK_FOR_BOOKMARK_COMMENT:
            comment = self.get_string_from_user(
                "Bookmark comment", "Give a comment for bookmark:"
            )
            if comment:
                bookmark.comment = comment
        self.trace_data.add_bookmark(bookmark)
        self.update_bookmark_table()

    def update_bookmark_table(self):
        """Updates bookmarks table from trace_data"""
        if self.trace_data is None:
            return
        table = self.bookmark_table
        try:
            table.itemChanged.disconnect()
        except Exception:
            pass
        bookmarks = self.trace_data.get_bookmarks()
        table.setRowCount(len(bookmarks))

        for i, bookmark in enumerate(bookmarks):
            startrow = QTableWidgetItem(bookmark.startrow)
            startrow.setData(Qt.DisplayRole, int(bookmark.startrow))
            startrow.setWhatsThis("startrow")
            table.setItem(i, 0, startrow)

            endrow = QTableWidgetItem(bookmark.endrow)
            endrow.setData(Qt.DisplayRole, int(bookmark.endrow))
            endrow.setWhatsThis("endrow")
            table.setItem(i, 1, endrow)

            address = QTableWidgetItem(bookmark.addr)
            address.setWhatsThis("address")
            table.setItem(i, 2, address)

            disasm = QTableWidgetItem(bookmark.disasm)
            disasm.setWhatsThis("disasm")
            table.setItem(i, 3, disasm)

            comment = QTableWidgetItem(bookmark.comment)
            comment.setWhatsThis("comment")
            table.setItem(i, 4, comment)

            table.setRowHeight(i, 14)

        table.itemChanged.connect(self.on_bookmark_table_cell_edited)
        self.update_column_widths(table)

    def print(self, text):
        """Prints text to TextEdit on log tab"""
        self.log_text_edit.appendPlainText(str(text))

    def go_to_row(self, table, row):
        """Scrolls a table to the specified row"""
        table.scrollToItem(table.item(row, 3), QAbstractItemView.PositionAtCenter)

    def ask_user(self, title, question):
        """Shows a messagebox with yes/no question

        Args:
            title (str): MessageBox title
            question (str): MessageBox qustion label
        Returns:
            bool: True if user clicked yes, False otherwise
        """
        answer = QMessageBox.question(
            self,
            title,
            question,
            QMessageBox.StandardButtons(QMessageBox.Yes | QMessageBox.No),
        )
        return bool(answer == QMessageBox.Yes)

    def get_string_from_user(self, title, label):
        """Gets a string from user

        Args:
            title (str): Input dialog title
            label (str): Input dialog label
        Returns:
            string: String given by user, empty string if user clicked cancel
        """
        answer, ok_clicked = QInputDialog.getText(
            self, title, label, QLineEdit.Normal, ""
        )
        if ok_clicked:
            return answer
        return ""

    def get_values_from_user(self, title, data, on_ok_clicked=None):
        """Gets values from user

        Args:
            title (str): Input dialog title
            data (list): List of dicts
            on_ok_clicked (method): Callback function to e.g. check the input
        Returns:
            list: List of values given by user, empty list if user canceled
        """
        input_dlg = InputDialog(self, title, data, on_ok_clicked)
        input_dlg.exec_()
        return input_dlg.get_data()

    def show_messagebox(self, title, msg):
        """Shows a messagebox"""
        alert = QMessageBox()
        alert.setWindowTitle(title)
        alert.setText(msg)
        alert.exec_()


def print_debug(msg):
    """Prints a debug message"""
    if prefs.DEBUG:
        print(msg)

```

`gui/mainwindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1114</width>
    <height>742</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralWidget">
   <property name="enabled">
    <bool>true</bool>
   </property>
   <property name="sizePolicy">
    <sizepolicy hsizetype="Maximum" vsizetype="Preferred">
     <horstretch>0</horstretch>
     <verstretch>0</verstretch>
    </sizepolicy>
   </property>
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <widget class="QTabWidget" name="tab_widget">
      <property name="sizePolicy">
       <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
        <horstretch>0</horstretch>
        <verstretch>0</verstretch>
       </sizepolicy>
      </property>
      <property name="acceptDrops">
       <bool>true</bool>
      </property>
      <property name="currentIndex">
       <number>0</number>
      </property>
      <widget class="QWidget" name="tab">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>1048</width>
         <height>594</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>16777215</height>
        </size>
       </property>
       <attribute name="title">
        <string>Trace</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout" stretch="0">
        <property name="sizeConstraint">
         <enum>QLayout::SetNoConstraint</enum>
        </property>
        <item>
         <layout class="QVBoxLayout" name="verticalLayout_3">
          <property name="sizeConstraint">
           <enum>QLayout::SetMaximumSize</enum>
          </property>
          <item>
           <layout class="QHBoxLayout" name="horizontalLayout" stretch="0">
            <property name="spacing">
             <number>6</number>
            </property>
            <property name="sizeConstraint">
             <enum>QLayout::SetDefaultConstraint</enum>
            </property>
            <property name="topMargin">
             <number>0</number>
            </property>
            <property name="rightMargin">
             <number>0</number>
            </property>
            <item>
             <widget class="QComboBox" name="select_trace_combo_box">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="maximumSize">
               <size>
                <width>100</width>
                <height>24</height>
               </size>
              </property>
             </widget>
            </item>
           </layout>
          </item>
          <item>
           <widget class="QSplitter" name="splitter1">
            <property name="sizePolicy">
             <sizepolicy hsizetype="Minimum" vsizetype="MinimumExpanding">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
            <property name="minimumSize">
             <size>
              <width>0</width>
              <height>500</height>
             </size>
            </property>
            <property name="orientation">
             <enum>Qt::Horizontal</enum>
            </property>
            <widget class="TraceTableWidget" name="trace_table">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Maximum" vsizetype="Expanding">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
             <property name="minimumSize">
              <size>
               <width>0</width>
               <height>0</height>
              </size>
             </property>
             <property name="font">
              <font>
               <family>Courier New</family>
               <pointsize>8</pointsize>
              </font>
             </property>
             <property name="acceptDrops">
              <bool>true</bool>
             </property>
             <property name="dragEnabled">
              <bool>false</bool>
             </property>
             <property name="dragDropMode">
              <enum>QAbstractItemView::NoDragDrop</enum>
             </property>
             <property name="alternatingRowColors">
              <bool>false</bool>
             </property>
             <property name="verticalScrollMode">
              <enum>QAbstractItemView::ScrollPerPixel</enum>
             </property>
             <property name="horizontalScrollMode">
              <enum>QAbstractItemView::ScrollPerPixel</enum>
             </property>
             <property name="showGrid">
              <bool>true</bool>
             </property>
             <property name="gridStyle">
              <enum>Qt::DotLine</enum>
             </property>
             <property name="rowCount">
              <number>0</number>
             </property>
             <property name="columnCount">
              <number>5</number>
             </property>
             <attribute name="horizontalHeaderStretchLastSection">
              <bool>true</bool>
             </attribute>
             <attribute name="verticalHeaderVisible">
              <bool>false</bool>
             </attribute>
             <column/>
             <column/>
             <column/>
             <column/>
             <column/>
            </widget>
            <widget class="QSplitter" name="splitter2">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Minimum" vsizetype="Expanding">
               <horstretch>0</horstretch>
               <verstretch>0</verstretch>
              </sizepolicy>
             </property>
             <property name="orientation">
              <enum>Qt::Vertical</enum>
             </property>
             <widget class="RegTableWidget" name="reg_table">
              <property name="minimumSize">
               <size>
                <width>240</width>
                <height>420</height>
               </size>
              </property>
              <property name="font">
               <font>
                <family>Courier</family>
                <pointsize>8</pointsize>
               </font>
              </property>
              <property name="alternatingRowColors">
               <bool>true</bool>
              </property>
              <property name="horizontalScrollMode">
               <enum>QAbstractItemView::ScrollPerPixel</enum>
              </property>
              <property name="showGrid">
               <bool>true</bool>
              </property>
              <property name="gridStyle">
               <enum>Qt::DotLine</enum>
              </property>
              <attribute name="horizontalHeaderVisible">
               <bool>true</bool>
              </attribute>
              <attribute name="verticalHeaderVisible">
               <bool>false</bool>
              </attribute>
              <attribute name="verticalHeaderDefaultSectionSize">
               <number>24</number>
              </attribute>
              <attribute name="verticalHeaderMinimumSectionSize">
               <number>22</number>
              </attribute>
             </widget>
             <widget class="MemTableWidget" name="mem_table">
              <property name="minimumSize">
               <size>
                <width>240</width>
                <height>0</height>
               </size>
              </property>
              <property name="font">
               <font>
                <family>Courier</family>
                <pointsize>8</pointsize>
               </font>
              </property>
              <property name="gridStyle">
               <enum>Qt::DashLine</enum>
              </property>
              <attribute name="horizontalHeaderVisible">
               <bool>true</bool>
              </attribute>
              <attribute name="verticalHeaderVisible">
               <bool>false</bool>
              </attribute>
              <attribute name="verticalHeaderDefaultSectionSize">
               <number>24</number>
              </attribute>
              <attribute name="verticalHeaderMinimumSectionSize">
               <number>22</number>
              </attribute>
             </widget>
            </widget>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tab_2">
       <attribute name="title">
        <string>Log</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_5">
        <item>
         <widget class="QPlainTextEdit" name="log_text_edit">
          <property name="font">
           <font>
            <family>Courier</family>
            <pointsize>10</pointsize>
            <weight>50</weight>
            <bold>false</bold>
            <underline>false</underline>
            <strikeout>false</strikeout>
           </font>
          </property>
          <property name="plainText">
           <string/>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tab_3">
       <attribute name="title">
        <string>Bookmarks</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_4">
        <item>
         <widget class="QTableWidget" name="bookmark_table">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="minimumSize">
           <size>
            <width>0</width>
            <height>0</height>
           </size>
          </property>
          <property name="maximumSize">
           <size>
            <width>16777215</width>
            <height>16777215</height>
           </size>
          </property>
          <property name="font">
           <font>
            <family>Courier</family>
            <pointsize>8</pointsize>
           </font>
          </property>
          <property name="verticalScrollMode">
           <enum>QAbstractItemView::ScrollPerPixel</enum>
          </property>
          <property name="horizontalScrollMode">
           <enum>QAbstractItemView::ScrollPerPixel</enum>
          </property>
          <property name="gridStyle">
           <enum>Qt::DashLine</enum>
          </property>
          <attribute name="horizontalHeaderStretchLastSection">
           <bool>true</bool>
          </attribute>
          <attribute name="verticalHeaderVisible">
           <bool>false</bool>
          </attribute>
         </widget>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menu_bar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>1114</width>
     <height>21</height>
    </rect>
   </property>
  </widget>
  <widget class="QStatusBar" name="status_bar"/>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <customwidgets>
  <customwidget>
   <class>TraceTableWidget</class>
   <extends>QTableWidget</extends>
   <header>gui/widgets/trace_table_widget.h</header>
  </customwidget>
  <customwidget>
   <class>RegTableWidget</class>
   <extends>QTableWidget</extends>
   <header>gui/widgets/reg_table_widget.h</header>
  </customwidget>
  <customwidget>
   <class>MemTableWidget</class>
   <extends>QTableWidget</extends>
   <header>gui/widgets/mem_table_widget.h</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`gui/syntax_hl/rules/syntax_x86_dark.txt`:

```txt
[
    {
        "startswith": [
            "0x", "-0x"
        ],
        "color": "#f16a4e"
    },
    {
        "words": [
            "byte", "word", "dword", "qword", "ptr"
        ],
        "color": "#a25500"
    },
    {
        "startswith": [
            "pop", "push"
        ],
        "color": "#ff40ff"
    },
    {
        "startswith": ["cmp"],
        "words": [
            "test", "bt"
        ],
        "color": "#32c435"
    },
    {
        "startswith": [
            "mov", "stos"
        ],
        "words": [
            "lea", "xchg"
        ],
        "color": "#c4536a"
    },
    {
        "startswith": ["jmp"],
        "color": "black",
        "bgcolor": "yellow"
    },
    {
        "startswith": ["j"],
        "color": "darkRed",
        "bgcolor": "yellow"
    },
    {
        "words": [
            "call", "ret"
        ],
        "color": "#000000",
        "bgcolor": "#00ccff"
    },
    {
        "words": [
            "adc", "dec", "inc", "sub", "sbb"
        ],
        "has": [
            "add", "div", "mul"
        ],
        "color": "cyan"
    },
    {
        "has": ["xor"],
        "words": [
            "and",
            "or",
            "shl",
            "shld",
            "shr",
            "shrd",
            "sal",
            "sar",
            "rol",
            "ror",
            "rcl",
            "rcr",
            "bswap",
            "neg",
            "not",
            "btc",
            "bts"
        ],
        "color": "#ff2424"
    }
]

```

`gui/syntax_hl/rules/syntax_x86_light.txt`:

```txt
[
    {
        "startswith": [
            "0x", "-0x"
        ],
        "color": "#f16a4e"
    },
    {
        "words": [
            "byte", "word", "dword", "qword", "ptr"
        ],
        "color": "#a25500"
    },
    {
        "startswith": [
            "pop", "push"
        ],
        "color": "#ff3fa8"
    },
    {
        "startswith": [
            "mov", "stos"
        ],
        "words": [
            "lea", "xchg"
        ],
        "color": "#8e3ca5"
    },
    {
        "startswith": ["cmp"],
        "words": [
            "test", "bt"
        ],
        "color": "darkGreen"
    },
    {
        "words": ["jmp"],
        "color": "#000000",
        "bgcolor": "yellow"
    },
    {
        "startswith": ["j"],
        "color": "red",
        "bgcolor": "yellow"
    },
    {
        "words": [
            "call", "ret"
        ],
        "color": "#000000",
        "bgcolor": "#00ffff"
    },
    {
        "words": [
            "adc", "dec", "inc", "sub", "sbb"
        ],
        "has": [
            "add", "div", "mul"
        ],
        "color": "darkCyan"
    },
    {
        "has": ["xor"],
        "words": [
            "and",
            "or",
            "shl",
            "shld",
            "shr",
            "shrd",
            "sal",
            "sar",
            "rol",
            "ror",
            "rcl",
            "rcr",
            "bswap",
            "neg",
            "not",
            "btc",
            "bts"
        ],
        "color": "darkRed"
    },
    {
        "startswith": [
            "1", "2", "3", "4", "5", "6", "7", "8", "9"
        ],
        "color": "#f16a4e"
    }
]

```

`gui/syntax_hl/rules/value_dark.txt`:

```txt
[
    {"startswith": ["0x", "-0x"], "color": "#ff6a4e"}
]
```

`gui/syntax_hl/rules/value_light.txt`:

```txt
[
    {"startswith": ["0x", "-0x"], "color": "#ff6a4e"}
]
```

`gui/syntax_hl/syntax_hl_delegate.py`:

```py
import json

from PyQt5.QtWidgets import (
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QApplication,
    QStyle,
)
from PyQt5.QtGui import (
    QColor,
    QTextDocument,
    QTextCursor,
    QTextCharFormat,
    QPalette,
    QAbstractTextDocumentLayout,
    QFont,
)

from core import prefs


class SyntaxHighlightDelegate(QStyledItemDelegate):
    def __init__(self, parent=None):
        super(SyntaxHighlightDelegate, self).__init__(parent)

        self.doc = QTextDocument(self)

        self.disasm_columns = []
        self.value_columns = []

        self.highlighted_regs = {}
        self.reg_hl_color = prefs.REG_HL_COLOR
        self.reg_hl_bg_colors = prefs.REG_HL_BG_COLORS

        self.ignored_chars = (" ", ",", "+", "[", "]")

        self.disasm_rules = self.load_rules_file(prefs.DISASM_RULES_FILE)
        self.value_rules = self.load_rules_file(prefs.VALUE_RULES_FILE)

    def load_rules_file(self, filename: str) -> list:
        """Loads syntax highlighting rules from json file"""
        with open(filename) as f:
            return json.load(f)

    def reset(self):
        """Resets highlighter"""
        self.highlighted_regs = {}

    def paint(self, painter, option, index):
        painter.save()

        options = QStyleOptionViewItem(option)
        self.initStyleOption(options, index)

        self.doc.setPlainText(options.text)

        column = index.column()
        if column in self.disasm_columns:
            options.font.setWeight(QFont.Bold)
            self.highlight(self.doc, self.disasm_rules)
        elif column in self.value_columns:
            options.font.setWeight(QFont.Bold)
            self.highlight(self.doc, self.value_rules)

        self.doc.setDefaultFont(options.font)

        options.text = ""

        style = (
            QApplication.style() if options.widget is None else options.widget.style()
        )
        style.drawControl(QStyle.CE_ItemViewItem, options, painter)

        ctx = QAbstractTextDocumentLayout.PaintContext()
        if option.state & QStyle.State_Selected:
            ctx.palette.setColor(
                QPalette.Text,
                option.palette.color(QPalette.Active, QPalette.HighlightedText),
            )
        else:
            ctx.palette.setColor(
                QPalette.Text, option.palette.color(QPalette.Active, QPalette.Text),
            )

        textRect = style.subElementRect(QStyle.SE_ItemViewItemText, options)

        if index.column() != 0:
            textRect.adjust(5, 0, 0, 0)

        the_constant = 4
        margin = (option.rect.height() - options.fontMetrics.height()) // 2
        margin = margin - the_constant
        textRect.setTop(textRect.top() + margin)

        painter.translate(textRect.topLeft())
        painter.setClipRect(textRect.translated(-textRect.topLeft()))
        self.doc.documentLayout().draw(painter, ctx)

        painter.restore()

    def set_reg_highlight(self, reg: str, enabled: bool):
        """Enables or disables register highlight"""
        regs_hl = prefs.HL_REGS_X86
        words = regs_hl.get(reg, [reg])

        if enabled:
            self.highlighted_regs[reg] = words
        elif reg in self.highlighted_regs:
            del self.highlighted_regs[reg]

    def highlight(self, document: QTextDocument, rules: list):
        """Highlights document"""
        char_format = QTextCharFormat()
        cursor = QTextCursor(document)

        while not cursor.isNull() and not cursor.atEnd():
            cursor.movePosition(QTextCursor.EndOfWord, QTextCursor.KeepAnchor)

            text = cursor.selectedText()
            color, bgcolor = self.get_register_hl_color(text, self.highlighted_regs)

            if not color:
                color, bgcolor = self.get_color(text, rules)

            if color:
                char_format.setForeground(QColor(color))

            if bgcolor:
                char_format.setBackground(QColor(bgcolor))

            if color or bgcolor:
                cursor.mergeCharFormat(char_format)
                char_format.clearBackground()

            self.move_to_next_word(document, cursor)

    def move_to_next_word(self, doc: QTextDocument, cursor: QTextCursor):
        """Moves cursor to next word"""
        while not cursor.isNull() and not cursor.atEnd():
            if doc.characterAt(cursor.position()) not in self.ignored_chars:
                return
            cursor.movePosition(QTextCursor.NextCharacter)

    def get_register_hl_color(self, word_to_check: str, regs_hl: dict) -> tuple:
        """Gets color and bgcolor if given word is found in regs_hl"""
        color_index = 0

        for words in regs_hl.values():
            if word_to_check in words:
                if color_index < len(self.reg_hl_bg_colors):
                    bg_color = self.reg_hl_bg_colors[color_index]
                else:
                    bg_color = self.reg_hl_bg_colors[-1]
                return (self.reg_hl_color, bg_color)
            color_index += 1

        return ("", "")

    def get_color(self, word_to_check: str, rules: dict) -> tuple:
        """Gets color and bgcolor if given word is found in rules"""
        for rule in rules:
            if "words" in rule:
                for word in rule["words"]:
                    if word == word_to_check:
                        return (rule["color"], rule.get("bgcolor", ""))
            if "startswith" in rule:
                for sw in rule["startswith"]:
                    if word_to_check.startswith(sw):
                        return (rule["color"], rule.get("bgcolor", ""))
            if "has" in rule:
                for has in rule["has"]:
                    if has in word_to_check:
                        return (rule["color"], rule.get("bgcolor", ""))

        return ("", "")

```

`gui/syntax_hl/syntax_hl_log.py`:

```py
"""
This syntax highlighter is modified from the following code:
    https://wiki.python.org/moin/PyQt/Python%20syntax%20highlighting

License: https://directory.fsf.org/wiki/License:BSD-3-Clause
"""

from PyQt5.QtCore import QRegExp
from PyQt5.QtGui import QColor, QTextCharFormat, QFont, QSyntaxHighlighter


def format(color, bgcolor="", style=""):
    """Return a QTextCharFormat with the given attributes."""
    _color = QColor()
    _color.setNamedColor(color)
    _format = QTextCharFormat()
    _format.setForeground(_color)

    if bgcolor:
        _format.setBackground(QColor(bgcolor))

    if "bold" in style:
        _format.setFontWeight(QFont.Bold)
    if "italic" in style:
        _format.setFontItalic(True)
    return _format


# Syntax styles
STYLES = {
    "instr_general": format("#8e3ca5"),
    "instr_cmp": format("green"),
    "instr_call": format("#000000", bgcolor="#00ffff"),
    "instr_branch": format("black", bgcolor="yellow"),
    "instr_cond_branch": format("red", bgcolor="yellow", style="italic"),
    "instr_arith": format("darkCyan"),
    "instr_vm": format("red", style="bold"),
    "keywords_vm": format("darkMagenta"),
    "instr_stack": format("#ff3fa8"),
    "instr_bitwise": format("red"),
    "operator": format("red"),
    "brace": format("darkMagenta"),
    "comment": format("darkGreen", style="italic"),
    "numbers": format("brown"),
}


class AsmHighlighter(QSyntaxHighlighter):
    """Syntax highlighter for the x86 ASM language."""

    instr_general = ["mov", "movzx", "movsx", "movsx", "lea"]
    instr_cmp = ["cmp", "test"]
    instr_call = ["call", "ret"]
    instr_branch = ["jmp"]
    instr_cond_branch = [
        "jne",
        "jnz",
        "je",
        "jz",
        "jg",
        "jnle",
        "jle",
        "jng",
        "jge",
        "jnl",
        "jl",
        "jnge",
        "ja",
        "jnbe",
        "jbe",
        "jna",
        "jnb",
        "jae",
        "jnc",
        "jb",
        "jnae",
        "jc",
        "jns",
        "js",
    ]
    instr_arith = ["add", "sub", "dec", "inc", "mul"]
    instr_vm = ["nor", "load", "exit", "enter", "init"]
    instr_stack = ["push", "pushad", "pushfd", "pushal", "pop", "popfd"]
    instr_bitwise = [
        "xor",
        "and",
        "or",
        "shl",
        "shr",
        "bswap",
        "rol",
        "ror",
        "neg",
        "not",
        "btc",
        "bts",
    ]

    # Operators
    operators = [
        "=",
        # Comparison
        "==",
        "!=",
        "<",
        "<=",
        ">",
        ">=",
        # Arithmetic
        "\+",
        "-",
        "\*",
        "/",
        "//",
        "\%",
        "\*\*",
        # In-place
        "\+=",
        "-=",
        "\*=",
        "/=",
        "\%=",
        # Bitwise
        "\^",
        "\|",
        "\&",
        "\~",
        ">>",
        "<<",
    ]

    # Braces
    braces = ["\[", "\]"]

    def __init__(self, document):
        QSyntaxHighlighter.__init__(self, document)

        rules = []

        # Keyword, operator, and brace rules
        rules += [
            (r"\b%s\b" % w, 0, STYLES["instr_general"])
            for w in AsmHighlighter.instr_general
        ]

        rules += [
            (r"\b%s\b" % w, 0, STYLES["instr_cmp"]) for w in AsmHighlighter.instr_cmp
        ]

        rules += [
            (r"\b%s\b" % w, 0, STYLES["instr_call"]) for w in AsmHighlighter.instr_call
        ]

        rules += [
            (r"\b%s\b" % w, 0, STYLES["instr_branch"])
            for w in AsmHighlighter.instr_branch
        ]
        rules += [
            (r"\b%s\b" % w, 0, STYLES["instr_cond_branch"])
            for w in AsmHighlighter.instr_cond_branch
        ]

        rules += [
            (r"\b%s\b" % w, 0, STYLES["instr_arith"])
            for w in AsmHighlighter.instr_arith
        ]

        rules += [
            (r"\b%s\b" % w, 0, STYLES["instr_vm"]) for w in AsmHighlighter.instr_vm
        ]

        rules += [
            (r"\b%s\b" % w, 0, STYLES["instr_stack"])
            for w in AsmHighlighter.instr_stack
        ]

        rules += [
            (r"\b%s\b" % w, 0, STYLES["instr_bitwise"])
            for w in AsmHighlighter.instr_bitwise
        ]

        rules += [(r"%s" % o, 0, STYLES["operator"]) for o in AsmHighlighter.operators]

        rules += [(r"%s" % b, 0, STYLES["brace"]) for b in AsmHighlighter.braces]

        # All other rules
        rules += [
            # Numeric literals
            (r"\b[+-]?[0-9]+[lL]?\b", 0, STYLES["numbers"]),
            (r"\b[+-]?0[xX][0-9A-Fa-f]+[lL]?\b", 0, STYLES["numbers"]),
            (r"\b[+-]?[0-9]+(?:\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\b", 0, STYLES["numbers"]),
            # From 'vm_' until a space or a comma
            (r"vm_[^ ,]*", 0, STYLES["keywords_vm"]),
            # From 'j' until a space or a comma
            # (r"j[^ ,]*", 0, STYLES["instr_cond_branch"]),
            # From '#' until a newline
            (r"#[^\n]*", 0, STYLES["comment"]),
            # From ';' until a newline
            (r";[^\n]*", 0, STYLES["comment"]),
        ]

        # Build a QRegExp for each pattern
        self.rules = [(QRegExp(pat), index, fmt) for (pat, index, fmt) in rules]

    def highlightBlock(self, text):
        """Apply syntax highlighting to the given block of text."""
        # Do other syntax formatting
        for expression, nth, format in self.rules:
            index = expression.indexIn(text, 0)

            while index >= 0:
                # We actually want the index of the nth match
                index = expression.pos(nth)
                length = len(expression.cap(nth))
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

```

`gui/widgets/filter_widget.py`:

```py
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtWidgets import (
    QWidget, QHBoxLayout, QPushButton, QComboBox, QSizePolicy
)


class FilterWidget(QWidget):

    filterBtnClicked = pyqtSignal(str)

    def __init__(self, parent=None):
        super(FilterWidget, self).__init__(parent)
        self.init_ui()

    def init_ui(self):

        layout = QHBoxLayout(self)

        self.filter_combo_box = QComboBox()
        self.filter_combo_box.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)
        self.filter_combo_box.setEditable(True)
        self.filter_combo_box.setMaxVisibleItems(25)
        self.filter_combo_box.setMaximumSize(440, 24)
        self.filter_combo_box.setMinimumSize(220, 24)
        self.filter_combo_box.keyPressEvent = self.on_filter_combo_box_key_pressed
        layout.addWidget(self.filter_combo_box)

        self.filter_btn = QPushButton("Filter", self)
        self.filter_btn.clicked.connect(self.on_filter_btn_clicked)
        self.filter_btn.setMinimumSize(40, 24)
        self.filter_btn.setMaximumSize(40, 24)
        layout.addWidget(self.filter_btn)

        self.setMaximumSize(500, 40)

    def set_sample_filters(self, filters):
        for f in filters:
            self.filter_combo_box.addItem(f)

    def add_sample_filter(self, sample_filter):
        self.filter_combo_box.addItem(sample_filter)

    def on_filter_btn_clicked(self):
        self.filterBtnClicked.emit(self.filter_combo_box.currentText())

    def on_filter_combo_box_key_pressed(self, event):
        """Checks if enter is pressed on filterEdit"""
        key = event.key()
        if key in (Qt.Key_Return, Qt.Key_Enter):
            self.on_filter_btn_clicked()
        QComboBox.keyPressEvent(self.filter_combo_box, event)

```

`gui/widgets/find_widget.py`:

```py
from PyQt5.QtWidgets import (
    QWidget,
    QHBoxLayout,
    QLabel,
    QToolButton,
    QLineEdit,
    QComboBox,
)
from PyQt5.QtCore import Qt, pyqtSignal


class FindWidget(QWidget):

    findBtnClicked = pyqtSignal(str, int, int)

    def __init__(self, parent=None):
        super(FindWidget, self).__init__(parent)
        self.last_direction = 1
        self.init_ui()

    def init_ui(self):

        layout = QHBoxLayout(self)

        self.find_label = QLabel("Find:")
        self.find_label.setMaximumSize(35, 24)
        layout.addWidget(self.find_label)

        self.find_combo_box = QComboBox()
        self.find_combo_box.setMaximumSize(105, 24)
        layout.addWidget(self.find_combo_box)

        self.find_edit = QLineEdit()
        self.find_edit.setMaximumSize(140, 24)
        self.find_edit.returnPressed.connect(
            lambda: self.on_find_btn_clicked(self.last_direction)
        )
        layout.addWidget(self.find_edit)

        self.prev_btn = QToolButton(self)
        self.prev_btn.clicked.connect(lambda: self.on_find_btn_clicked(-1))
        self.prev_btn.setArrowType(Qt.UpArrow)
        self.prev_btn.setToolTip("Find previous")
        layout.addWidget(self.prev_btn)

        self.next_btn = QToolButton(self)
        self.next_btn.clicked.connect(lambda: self.on_find_btn_clicked(1))
        self.next_btn.setArrowType(Qt.DownArrow)
        self.next_btn.setToolTip("Find next")
        layout.addWidget(self.next_btn)

        layout.setAlignment(Qt.AlignLeft)

    def set_fields(self, fields):
        for field in fields:
            self.find_combo_box.addItem(field)

    def add_field(self, field):
        self.find_combo_box.addItem(field)

    def on_find_btn_clicked(self, direction):
        """Find next or prev button clicked"""
        self.last_direction = direction
        field_index = self.find_combo_box.currentIndex()
        keyword = self.find_edit.text()
        self.findBtnClicked.emit(keyword, field_index, direction)

```

`gui/widgets/mem_table_widget.py`:

```py
from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem


class MemTableWidget(QTableWidget):
    def __init__(self, parent=None):
        super(MemTableWidget, self).__init__(parent)
        self.mem_data = []

    def set_data(self, data):
        """Sets table data and updates it"""
        self.mem_data = data
        self.populate()

    def populate(self):
        """Fills table with data"""
        if self.mem_data is None or not self.mem_data:
            self.setRowCount(0)
        else:
            self.setRowCount(len(self.mem_data))
            for i, mem in enumerate(self.mem_data):
                self.setItem(i, 0, QTableWidgetItem(mem["access"]))
                self.setItem(i, 1, QTableWidgetItem(hex(mem["addr"])))
                self.setItem(i, 2, QTableWidgetItem(hex(mem["value"])))
            self.update_column_widths()

    def update_column_widths(self):
        """Updates column widths of a TableWidget to match the content"""
        self.setVisible(False)  # fix ui glitch with column widths
        self.resizeColumnsToContents()
        self.horizontalHeader().setStretchLastSection(True)
        self.setVisible(True)

```

`gui/widgets/pagination_widget.py`:

```py
from PyQt5.QtCore import pyqtSignal, QSize, Qt
from PyQt5.QtWidgets import QWidget, QHBoxLayout, QToolButton, QLineEdit, QLabel


class PaginationWidget(QWidget):

    pageChanged = pyqtSignal(int)

    def __init__(self, parent=None):
        QWidget.__init__(self, parent=parent)
        self.rows_per_page = 1000
        self.page_count = 1
        self.current_page = 1
        self.init_ui()

    def init_ui(self):
        layout = QHBoxLayout(self)

        self.first_page_btn = QToolButton(self)
        self.first_page_btn.clicked.connect(self._on_first_page_btn_clicked)
        self.first_page_btn.setArrowType(Qt.LeftArrow)
        self.first_page_btn.setToolTip("First page")
        layout.addWidget(self.first_page_btn)

        self.prev_page_btn = QToolButton(self)
        self.prev_page_btn.clicked.connect(self._on_prev_page_btn_clicked)
        self.prev_page_btn.setArrowType(Qt.LeftArrow)
        self.prev_page_btn.setToolTip("Previous page")
        layout.addWidget(self.prev_page_btn)

        self.page_edit = QLineEdit("1")
        self.page_edit.setMaximumSize(45, 24)
        self.page_edit.returnPressed.connect(
            lambda: self.set_current_page(self.page_edit.text())
        )
        layout.addWidget(self.page_edit)

        self.next_page_btn = QToolButton(self)
        self.next_page_btn.clicked.connect(self._on_next_page_btn_clicked)
        self.next_page_btn.setArrowType(Qt.RightArrow)
        self.next_page_btn.setToolTip("Next page")
        layout.addWidget(self.next_page_btn)

        self.last_page_btn = QToolButton(self)
        self.last_page_btn.clicked.connect(self._on_last_page_btn_clicked)
        self.last_page_btn.setArrowType(Qt.RightArrow)
        self.last_page_btn.setToolTip("Last page")
        layout.addWidget(self.last_page_btn)

        self.status_label = QLabel("")
        layout.addWidget(self.status_label)

    def set_enabled(self, enabled):
        self.prev_page_btn.setEnabled(enabled)
        self.next_page_btn.setEnabled(enabled)
        self.last_page_btn.setEnabled(enabled)
        self.first_page_btn.setEnabled(enabled)
        self.status_label.setEnabled(enabled)
        self.page_edit.setEnabled(enabled)

    def update_status_text(self):
        status = f"Page: {self.current_page} / {self.page_count}"
        self.status_label.setText(status)

    def set_status_text(self, text):
        self.status_label.setText(text)

    def set_page_count(self, page_count):
        # if self.current_page > page_count:
        #     self.set_current_page(page_count)
        self.page_count = page_count
        self.update_status_text()

    def set_current_page(self, page, block_signals=False):
        try:
            if not isinstance(page, int):
                page = int(page)
        except ValueError:
            print(f"Exception on set_current_page: page must be integer.")
            return

        if page < 1:
            page = 1
        if page > self.page_count:
            page = self.page_count

        self.current_page = page
        self.page_edit.setText(str(page))
        self.update_status_text()
        if not block_signals:
            self.pageChanged.emit(page)

    def _on_prev_page_btn_clicked(self):
        self.set_current_page(self.current_page - 1)

    def _on_next_page_btn_clicked(self):
        self.set_current_page(self.current_page + 1)

    def _on_first_page_btn_clicked(self):
        self.set_current_page(1)

    def _on_last_page_btn_clicked(self):
        self.set_current_page(self.page_count)

```

`gui/widgets/reg_table_widget.py`:

```py
import string

from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem, QMenu, QAction
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QColor, QCursor

from core import prefs


class RegTableWidget(QTableWidget):

    regCheckBoxChanged = pyqtSignal(str, int)

    def __init__(self, parent=None):
        super(RegTableWidget, self).__init__(parent)
        self.printer = print
        self.regs = {}
        self.modified_regs = []
        self.modified_regs_ignore = ["eip", "rip"]
        self.filtered_regs = []
        self.checked_regs = {}
        self.menu = None
        if prefs.USE_DARK_THEME:
            self.hl_color = QColor("darkRed")
        else:
            self.hl_color = QColor("#fcabab")

    def create_context_menu(self):
        """Initializes context menu for mouse right click"""
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.on_custom_context_menu_requested)

        self.menu = QMenu(self)
        print_action = QAction("Print selected cells", self)
        print_action.triggered.connect(self.print_selected_cells)
        self.menu.addAction(print_action)

    def onCellChanged(self, row, col):
        if col > 0:
            return
        item = self.item(row, 0)
        state = item.checkState()
        state_bool = state == Qt.Checked
        reg_name = item.text()

        self.checked_regs[reg_name] = state
        self.regCheckBoxChanged.emit(reg_name, state_bool)

    def on_custom_context_menu_requested(self):
        """Context menu callback for mouse right click"""
        if self.menu is not None:
            self.menu.popup(QCursor.pos())

    def set_data(self, regs, modified_regs):
        """Sets table data and populates the table"""
        if self.filtered_regs:
            temp_regs = {}
            for reg, value in regs.items():
                if reg in self.filtered_regs:
                    temp_regs[reg] = value
                regs = temp_regs
        self.regs = regs
        self.modified_regs = modified_regs
        self.populate()

    def populate(self):
        """Populates the register table"""
        try:
            self.cellChanged.disconnect()
        except Exception:
            pass

        if self.rowCount() != len(self.regs):
            self.setRowCount(len(self.regs))
        if not self.regs:
            return

        i = 0
        for reg, value in self.regs.items():
            if self.filtered_regs and reg not in self.filtered_regs:
                continue
            regname_item = QTableWidgetItem(reg)
            regname_item.setFlags(
                Qt.ItemIsUserCheckable | Qt.ItemIsEnabled | Qt.ItemIsSelectable
            )
            check_state = self.checked_regs.get(reg, Qt.Unchecked)
            regname_item.setCheckState(check_state)
            self.setItem(i, 0, regname_item)

            if isinstance(value, int):
                hex_str = hex(value)
                if 0 < value < 255 and chr(value) in string.printable:
                    hex_str += f"  '{chr(value)}'"

                hex_item = QTableWidgetItem(hex_str)

                hex_item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)
                dec_item = QTableWidgetItem(str(value))
                dec_item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)
                self.setItem(i, 1, hex_item)
                self.setItem(i, 2, dec_item)
            else:
                self.setItem(i, 1, QTableWidgetItem(value))

            if reg in self.modified_regs and reg not in self.modified_regs_ignore:
                self.item(i, 0).setBackground(self.hl_color)
                self.item(i, 1).setBackground(self.hl_color)
                self.item(i, 2).setBackground(self.hl_color)
            i += 1

        if "eflags" in self.regs:
            eflags = self.regs["eflags"]
            flags = {
                "c": eflags & 1,  # carry
                "p": (eflags >> 2) & 1,  # parity
                # "a": (eflags >> 4) & 1,  # aux_carry
                "z": (eflags >> 6) & 1,  # zero
                "s": (eflags >> 7) & 1,  # sign
                # "d": (eflags >> 10) & 1, # direction
                # "o":  (eflags >> 11) & 1 # overflow
            }
            flags_text = f"C:{flags['c']} P:{flags['p']} Z:{flags['z']} S:{flags['s']}"
            self.setRowCount(i + 1)
            self.setItem(i, 0, QTableWidgetItem("flags"))
            self.setItem(i, 1, QTableWidgetItem(flags_text))

        self.cellChanged.connect(self.onCellChanged)

    def print(self, msg: str):
        if self.printer:
            self.printer(msg)
        else:
            print(msg)

    def print_selected_cells(self):
        """Prints selected cells"""
        items = self.selectedItems()

        if len(items) < 1:
            return

        rows = {}
        for item in items:
            row = item.row()
            if row not in rows:
                rows[row] = [item.text()]
            else:
                rows[row].append(item.text())

        for row in rows.values():
            self.print(" ".join(row))

```

`gui/widgets/trace_table_widget.py`:

```py
from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem, QAbstractItemView
from PyQt5.QtCore import pyqtSignal, Qt, QItemSelectionModel
from PyQt5.QtGui import QCursor

from core import prefs
from core.bookmark import Bookmark
from gui.syntax_hl.syntax_hl_delegate import SyntaxHighlightDelegate


class TraceTableWidget(QTableWidget):

    bookmarkCreated = pyqtSignal(Bookmark)
    commentEdited = pyqtSignal(int, str)

    def __init__(self, parent=None):
        super(TraceTableWidget, self).__init__(parent)
        self.printer = self.print_debug
        self.trace = []
        self.pagination = None
        self.menu = None
        self.row_height = 20
        self.delegate = None
        self.init_ui()

    def init_ui(self):
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.custom_context_menu_requested)
        self.itemChanged.connect(self.item_changed)

    def init_syntax_highlight(self):
        """Inits syntax higlighter delegate"""
        self.delegate = SyntaxHighlightDelegate(self)
        self.delegate.disasm_columns = prefs.TRACE_HL_DISASM_COLUMNS
        self.delegate.value_columns = prefs.TRACE_HL_VALUE_COLUMNS
        self.setItemDelegate(self.delegate)

    def get_syntax_highlighter(self):
        """Returns syntax higlighter delegate"""
        return self.delegate

    def create_bookmark(self):
        """Create a bookmark from selected rows"""
        selected_rows = self.selectedItems()
        if not selected_rows:
            self.print_debug("Could not create a bookmark. Nothing selected.")
            return

        addr = self.item(selected_rows[0].row(), 1).text()
        disasm = self.item(selected_rows[0].row(), 3).text()
        comment = self.item(selected_rows[0].row(), 5).text()

        selected_row_ids = self.get_selected_row_ids()
        first_row_id = selected_row_ids[0]
        last_row_id = selected_row_ids[-1]
        bookmark = Bookmark(
            startrow=first_row_id,
            endrow=last_row_id,
            addr=addr,
            disasm=disasm,
            comment=comment,
        )
        self.bookmarkCreated.emit(bookmark)

    def custom_context_menu_requested(self):
        """Context menu for mouse right click"""
        if self.menu is not None:
            self.menu.popup(QCursor.pos())

    def get_selected_row_ids(self):
        """Returns IDs of all selected rows.

        returns:
            list: Sorted list of row ids
        """
        # use a set so we don't get duplicate ids
        row_ids_set = set(
            self.item(index.row(), 0).text() for index in self.selectedIndexes()
        )
        try:
            row_ids_list = [int(i) for i in row_ids_set]
        except ValueError:
            self.print_debug("Error. Values in the first column must be integers.")
            return None
        return sorted(row_ids_list)

    def go_to_row(self, row: int):
        if self.pagination is not None:
            page = int(row / self.pagination.rows_per_page) + 1
            row = row % self.pagination.rows_per_page
            if page != self.pagination.current_page:
                self.pagination.set_current_page(page)
        self.scrollToItem(self.item(row, 3), QAbstractItemView.PositionAtCenter)
        self.select_row(row)

    def item_changed(self, item: QTableWidgetItem):
        """Called when user edits a cell"""
        cell_type = item.whatsThis()
        if cell_type == "comment":
            row = self.currentRow()
            if row < 0:
                self.print_debug("Error, could not edit trace.")
                return
            row_id = int(self.item(row, 0).text())
            self.commentEdited.emit(row_id, item.text())
        else:
            self.print_debug("Only comment editing allowed for now...")

    def print(self, msg: str):
        if self.printer:
            self.printer(msg)
        else:
            print(msg)

    def print_debug(self, msg: str):
        print(msg)

    def print_selected_cells(self):
        """Prints selected cells"""
        items = self.selectedItems()

        if len(items) < 1:
            return

        paddings = [6, 12, 16, 40, 40, 0]
        rows = {}
        for item in items:
            row = item.row()
            item_text = item.text().ljust(paddings[item.column()], " ")

            if item.whatsThis() == "comment" and item.text():
                item_text = f"; {item_text}"

            if row not in rows:
                rows[row] = [item_text]
            else:
                rows[row].append(item_text)

        for row in rows.values():
            self.print(" ".join(row).strip())

    def select_row(self, row: int):
        """Selects a row in a table"""
        self.clearSelection()
        item = self.item(row, 0)
        self.setCurrentItem(
            item,
            QItemSelectionModel.Select
            | QItemSelectionModel.Rows
            | QItemSelectionModel.Current,
        )

    def set_data(self, data: list):
        """Sets table data"""
        self.trace = data
        if self.pagination is not None:
            self.update_pagination()

    def set_row_height(self, height: int):
        """Sets table row height"""
        self.row_height = height

    def populate(self):
        """Populates the table with trace data"""
        try:
            self.itemChanged.disconnect()
        except Exception:
            pass

        trace = self.trace
        if trace is None or not trace:
            self.setRowCount(0)
            return

        if self.pagination is not None:
            self.update_pagination()
            page = self.pagination.current_page
            per_page = self.pagination.rows_per_page
            trace = trace[(page - 1) * per_page : page * per_page]

        row_count = len(trace)
        self.setRowCount(row_count)
        if row_count == 0:
            return

        for i in range(0, row_count):
            row_id_item = QTableWidgetItem(str(trace[i]["id"]))
            row_id_item.setFlags(row_id_item.flags() & ~Qt.ItemIsEditable)

            address_item = QTableWidgetItem(hex(trace[i].get("ip")))
            address_item.setFlags(address_item.flags() & ~Qt.ItemIsEditable)

            opcodes_item = QTableWidgetItem(trace[i]["opcodes"])
            opcodes_item.setFlags(opcodes_item.flags() & ~Qt.ItemIsEditable)

            disasm_item = QTableWidgetItem(trace[i]["disasm"])
            disasm_item.setFlags(disasm_item.flags() & ~Qt.ItemIsEditable)

            regchanges_item = QTableWidgetItem(trace[i].get("regchanges", ""))
            regchanges_item.setFlags(regchanges_item.flags() & ~Qt.ItemIsEditable)
            regchanges_item.setWhatsThis("regchanges")

            comment_item = QTableWidgetItem(trace[i].get("comment", ""))
            comment_item.setWhatsThis("comment")

            self.setItem(i, 0, row_id_item)
            self.setItem(i, 1, address_item)
            self.setItem(i, 2, opcodes_item)
            self.setItem(i, 3, disasm_item)
            self.setItem(i, 4, regchanges_item)
            self.setItem(i, 5, comment_item)

            self.setRowHeight(i, self.row_height)

        self.itemChanged.connect(self.item_changed)

    def update_column_widths(self):
        """Updates column widths of a TableWidget to match the content"""
        self.setVisible(False)  # fix ui glitch with column widths
        self.resizeColumnToContents(3)
        self.setColumnWidth(0, 60)  # make id column wider
        self.setColumnWidth(4, 230)  # make reg column wider
        self.horizontalHeader().setStretchLastSection(True)
        self.setVisible(True)

    def update_pagination(self):
        """Update pagination widget"""
        if self.pagination is not None:
            trace_length = len(self.trace)
            page_count = int(trace_length / self.pagination.rows_per_page) + 1
            self.pagination.set_page_count(page_count)

```

`plugins/comment_mem_access.py`:

```py
"""This plugin finds every memory access and comments the row with address and value"""

from yapsy.IPlugin import IPlugin
from core.api import Api

class PluginCommentMemAccesses(IPlugin):

    def execute(self, api: Api):

        want_to_continue = api.ask_user(
            "Warning", "This plugin may replace some of your comments, continue?"
        )
        if not want_to_continue:
            return

        trace_data = api.get_trace_data()
        trace = api.get_visible_trace()

        for i, t in enumerate(trace):
            if 'mem' in t and t['mem']:
                comment = ""
                for mem in t['mem']:
                    addr = hex(mem['addr'])
                    value = mem['value']
                    if mem['access'] == "READ":
                        comment += f"[{ addr }] -> { hex(value) } "
                    elif mem['access'] == "WRITE":
                        comment += f"[{ addr }] <- { hex(value) } "
                    if 0x20 <= value <= 0x7e:
                        comment += f"'{ chr(value) }' "

                # Add comment to full trace
                row = t["id"]
                trace_data.trace[row]['comment'] = comment

                # Add comment to visible trace too because it could be filtered_trace
                trace[i]['comment'] = comment

        api.update_trace_table()

```

`plugins/comment_mem_access.yapsy-plugin`:

```yapsy-plugin
[Core]
Name = Comment mem accesses
Module = comment_mem_access

[Documentation]
Author = Teemu
Version = 0.1
Website = https://github.com/teemu-l/execution-trace-viewer
Description = Comments all memory reads and writes ([addr] -> data)
```

`plugins/exec_counts.py`:

```py
"""This plugin prints top 30 most executed addresses"""
from yapsy.IPlugin import IPlugin
from operator import itemgetter
from core.api import Api

class PluginPrintExecCounts(IPlugin):

    def execute(self, api: Api):

        trace = api.get_visible_trace()
        if not trace:
            return

        api.print('')

        trace_data = api.get_trace_data()
        ip_name = trace_data.get_instruction_pointer_name()
        if ip_name not in trace_data.regs:
            api.print('Error. Unknown instruction pointer name.')
            return
        ip_index = trace_data.regs[ip_name]
        counts = {}
        for t in trace:
            addr = t['regs'][ip_index]
            if addr in counts:
                counts[addr] += 1
            else:
                counts[addr] = 1

        api.print('%d unique addresses executed.' % len(counts))
        api.print('Top 30 executed addresses:')

        counts = sorted(counts.items(), key=itemgetter(1), reverse=True)
        for address, count in counts[:30]:
            api.print('%s  %d ' % (hex(address), count))

```

`plugins/exec_counts.yapsy-plugin`:

```yapsy-plugin
[Core]
Name = Print execution counts
Module = exec_counts

[Documentation]
Author = Teemu
Version = 0.1
Website = https://github.com/teemu-l/execution-trace-viewer
Description = Print execution counts for top 30 most executed addresses
```

`plugins/filter_by_mem_addr.py`:

```py
"""This plugin filters a trace by addresses in memory accesses.
Every row which accesses memory in given range is added to filtered_trace.
"""

from yapsy.IPlugin import IPlugin
from core.api import Api


class PluginFilterByMemAddress(IPlugin):
    def execute(self, api: Api):

        input_dlg_data = [
            {"label": "Memory address", "data": "0x0"},
            {"label": "Size", "data": 2000},
            {"label": "Access types", "data": ["Reads and writes", "Reads", "Writes"]},
            {"label": "Source trace", "data": ["Full trace", "Filtered trace"]},
        ]
        options = api.get_values_from_user("Filter by memory address", input_dlg_data)

        if not options:
            return

        addr, size, access_types, trace_id = options
        addr = self.str_to_int(addr)

        print(f"Filtering by mem address: from {hex(addr)} to {hex(addr+size)}")

        if trace_id == 0:
            trace = api.get_full_trace()
        else:
            trace = api.get_filtered_trace()

        result_trace = []

        for t in trace:
            for mem in t["mem"]:
                if mem["access"].upper() == "READ" and access_types == 2:
                    continue
                elif mem["access"].upper() == "WRITE" and access_types == 1:
                    continue
                if addr <= mem["addr"] <= (addr + size):
                    result_trace.append(t.copy())
                    break  # avoid adding the same row more than once

        if len(result_trace) > 0:
            print(f"Length of filtered trace: {len(result_trace)}")
            api.set_filtered_trace(result_trace)
            api.show_filtered_trace()
        else:
            api.show_messagebox(
                "Error", "Could not find any rows accessing given memory area"
            )

    def str_to_int(self, s: str):
        result = 0
        if s:
            s = s.strip()
            if "0x" in s:
                result = int(s, 16)
            else:
                result = int(s)
        return result

```

`plugins/filter_by_mem_addr.yapsy-plugin`:

```yapsy-plugin
[Core]
Name = Filter by mem access address
Module = filter_by_mem_addr

[Documentation]
Author = Teemu
Version = 0.1
Website = https://github.com/teemu-l/execution-trace-viewer
Description = Filter trace by memory access address
```

`plugins/list_bookmarks.py`:

```py
from yapsy.IPlugin import IPlugin
from operator import itemgetter
from core.api import Api

class PluginListBookmarks(IPlugin):

    def execute(self, api: Api):

        api.print('----------------------------------')

        bookmarks = api.get_bookmarks()
        if not bookmarks:
            api.print('No bookmarks found.')
            return

        for b in bookmarks:
            row = '{:<8}'.format(b.startrow)
            api.print(row + '{:<20}'.format(b.disasm) + '; %s' % b.comment)

        api.print('')

        addresses = {}
        for b in bookmarks:
            if b.addr in addresses:
                addresses[b.addr] += 1
            else:
                addresses[b.addr] = 1
        addresses = sorted(addresses.items(), key=itemgetter(1), reverse=True)

        api.print('Duplicate bookmarks:')
        api.print('Address  | count |  start row')
        for address, count in addresses:  # [:15]
            b_rows = []
            for b in bookmarks:
                if address == b.addr:
                    b_rows.append(b.startrow)
            b_rows_str = ' '.join(map(str, b_rows))
            api.print('%s |  %d    | %s' % (address, count, b_rows_str))

        api.print('')

        api.print('%d bookmarks total.' % len(bookmarks))
        api.print('%d unique bookmarks.' % len(addresses))

        lengths = []
        for b in bookmarks:
            lengths.append(b.endrow - b.startrow + 1)
        avg_len = sum(lengths) / len(bookmarks)
        shortest = min(lengths)
        longtest = max(lengths)
        api.print('Average length of bookmark: %d' % avg_len)
        api.print('Longest: %d  Shortest: %d' % (longtest, shortest))

```

`plugins/list_bookmarks.yapsy-plugin`:

```yapsy-plugin
[Core]
Name = List bookmarks
Module = list_bookmarks

[Documentation]
Author = Teemu
Version = 0.1
Website = https://github.com/teemu-l/execution-trace-viewer
Description = Lists all bookmarks
```

`plugins/print_rows.py`:

```py
from yapsy.IPlugin import IPlugin
from core.api import Api


class PluginPrintRows(IPlugin):
    def execute(self, api: Api):

        trace_data = api.get_trace_data()
        trace = api.get_selected_trace()

        if not trace:
            print("PluginPrintRows error: Nothing selected.")
            return

        api.print("")

        row_id_digits = len(str(trace[-1]["id"]))
        for t in trace:
            ip = hex(trace_data.get_instruction_pointer(t["id"]))
            api.print(
                "{:<{}} ".format(t["id"], row_id_digits)
                + " %s " % ip
                + " {:<42}".format(t["disasm"])
                + "; %s" % t.get("comment", "")
            )

```

`plugins/print_rows.yapsy-plugin`:

```yapsy-plugin
[Core]
Name = Print selected rows
Module = print_rows

[Documentation]
Author = Teemu
Version = 0.1
Website = https://github.com/teemu-l/execution-trace-viewer
Description = Prints selected rows
```

`plugins/print_selected_bookmarks.py`:

```py
"""This plugin prints all selected bookmarks from bookmarks table"""
from yapsy.IPlugin import IPlugin
from core.api import Api


class PluginPrintSelectedBookmarks(IPlugin):
    def execute(self, api: Api):

        api.print("")

        bookmarks = api.get_selected_bookmarks()

        for b in bookmarks:
            if b.startrow is not b.endrow:
                rows = "{:<13}".format(f"{b.startrow} - {b.endrow}")
            else:
                rows = "{:<13}".format(f"{b.startrow}")
            addr = "{:<16}".format(b.addr)
            disasm = "{:<33}".format(b.disasm)
            api.print(f"{rows}  {addr} {disasm} ; {b.comment}")

```

`plugins/print_selected_bookmarks.yapsy-plugin`:

```yapsy-plugin
[Core]
Name = Print selected bookmarks
Module = print_selected_bookmarks

[Documentation]
Author = Teemu
Version = 0.1
Website = https://github.com/teemu-l/execution-trace-viewer
Description = Prints all selected bookmarks to log
```

`requirements.txt`:

```txt
capstone>=3.0.5.post1
PyQt5>=5.11.3
QDarkStyle>=2.6.8
Yapsy==1.12.0

```

`tv.py`:

```py
import sys
from PyQt5 import QtWidgets
import qdarkstyle

from core import prefs
from gui.mainwindow import MainWindow

if __name__ == "__main__":
    APP = QtWidgets.QApplication(sys.argv)
    if prefs.USE_DARK_THEME:
        APP.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())
    else:
        APP.setStyle(prefs.LIGHT_THEME)
    WINDOW = MainWindow()
    WINDOW.show()
    sys.exit(APP.exec_())

```