Project Path: arc_gmh5225_CreateProcessAsPPL_hj85ewst

Source Tree:

```txt
arc_gmh5225_CreateProcessAsPPL_hj85ewst
├── CreateProcessAsPPL.cpp
├── CreateProcessAsPPL.sln
├── CreateProcessAsPPL.vcxproj
├── CreateProcessAsPPL.vcxproj.filters
└── README.md

```

`CreateProcessAsPPL.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <string>
#include <vector>
#include <cstdlib>

#pragma comment(lib, "advapi32.lib")

class PPLProcessCreator
{
private:
    HANDLE m_hProcess;
    HANDLE m_hThread;

public:
    PPLProcessCreator() : m_hProcess(nullptr), m_hThread(nullptr) {}
    ~PPLProcessCreator()
    {
        if (m_hProcess) CloseHandle(m_hProcess);
        if (m_hThread) CloseHandle(m_hThread);
    }

    DWORD GetPPLProtectionLevel(DWORD processId)
    {
        DWORD protectionLevel = 0;
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, processId);

        if (hProcess)
        {
            PROCESS_PROTECTION_LEVEL_INFORMATION protectionInfo;
            DWORD returnLength = 0;

            if (GetProcessInformation(hProcess, ProcessProtectionLevelInfo,
                &protectionInfo, sizeof(protectionInfo)))
            {
                protectionLevel = protectionInfo.ProtectionLevel;
            }

            CloseHandle(hProcess);
        }

        return protectionLevel;
    }
    std::wstring GetPPLProtectionLevelName(DWORD protectionLevel)
    {
        switch (protectionLevel)
        {
        case PROTECTION_LEVEL_WINTCB_LIGHT:
            return L"PROTECTION_LEVEL_WINTCB_LIGHT";
        case PROTECTION_LEVEL_WINDOWS:
            return L"PROTECTION_LEVEL_WINDOWS";
        case PROTECTION_LEVEL_WINDOWS_LIGHT:
            return L"PROTECTION_LEVEL_WINDOWS_LIGHT";
        case PROTECTION_LEVEL_ANTIMALWARE_LIGHT:
            return L"PROTECTION_LEVEL_ANTIMALWARE_LIGHT";
        case PROTECTION_LEVEL_LSA_LIGHT:
            return L"PROTECTION_LEVEL_LSA_LIGHT";
        default:
            return L"Unknown protection level";
        }
    }
    bool CreatePPLProcess(DWORD protectionLevel, const std::wstring& executablePath, const std::wstring& commandLine = L"")
    {
        SIZE_T size = 0;
        STARTUPINFOEXW siex = { 0 };
        siex.StartupInfo.cb = sizeof(siex);
        PROCESS_INFORMATION pi = { 0 };
        LPPROC_THREAD_ATTRIBUTE_LIST ptal = nullptr;

        // Initialize attribute list size
        if (!InitializeProcThreadAttributeList(nullptr, 1, 0, &size) && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            std::wcerr << L"InitializeProcThreadAttributeList failed: " << GetLastError() << std::endl;
            return false;
        }

        // Allocate attribute list
        ptal = reinterpret_cast<LPPROC_THREAD_ATTRIBUTE_LIST>(HeapAlloc(GetProcessHeap(), 0, size));
        if (!ptal)
        {
            std::wcerr << L"HeapAlloc failed: " << GetLastError() << std::endl;
            return false;
        }

        // Initialize attribute list
        if (!InitializeProcThreadAttributeList(ptal, 1, 0, &size))
        {
            std::wcerr << L"InitializeProcThreadAttributeList failed: " << GetLastError() << std::endl;
            HeapFree(GetProcessHeap(), 0, ptal);
            return false;
        }

        // Set protection level
        //DWORD protectionLevel = PROTECTION_LEVEL_ANTIMALWARE_LIGHT;
        if (!UpdateProcThreadAttribute(ptal, 0, PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL, &protectionLevel, sizeof(protectionLevel), nullptr, nullptr))
        {
            std::wcerr << L"UpdateProcThreadAttribute failed: " << GetLastError() << std::endl;
            DeleteProcThreadAttributeList(ptal);
            HeapFree(GetProcessHeap(), 0, ptal);
            return false;
        }

        siex.lpAttributeList = ptal;

        // Prepare command line (CreateProcessW requires modifiable string)
        std::wstring fullCommandLine = L"\"" + executablePath + L"\"";
        if (!commandLine.empty()) {
            fullCommandLine += L" " + commandLine;
        }

        std::vector<wchar_t> cmdLineBuffer(fullCommandLine.begin(), fullCommandLine.end());
        cmdLineBuffer.push_back(L'\0');

        // Create process with PPL protection
        if (!CreateProcessW(
            executablePath.c_str(),    // Application name
            cmdLineBuffer.data(),      // Command line
            nullptr,                   // Process security attributes
            nullptr,                   // Thread security attributes
            FALSE,                     // Inherit handles
            EXTENDED_STARTUPINFO_PRESENT | CREATE_PROTECTED_PROCESS,
            nullptr,                   // Environment
            nullptr,                   // Current directory
            &siex.StartupInfo,         // Startup info
            &pi))                       // Process information
        {
            std::wcerr << L"CreateProcessW failed: " << GetLastError() << std::endl;
            DeleteProcThreadAttributeList(ptal);
            HeapFree(GetProcessHeap(), 0, ptal);
            return false;
        }

        // Clean up attribute list
        DeleteProcThreadAttributeList(ptal);
        HeapFree(GetProcessHeap(), 0, ptal);

        m_hProcess = pi.hProcess;
        m_hThread = pi.hThread;

        std::wcout << L"Successfully created PPL process with PID: " << pi.dwProcessId << std::endl;
        std::wcerr << L"Protection level: " << GetPPLProtectionLevelName(GetPPLProtectionLevel(pi.dwProcessId)) << std::endl;
        return true;
    }

    bool WaitForProcess(DWORD timeout = INFINITE)
    {
        if (!m_hProcess) return false;

        DWORD result = WaitForSingleObject(m_hProcess, timeout);
        if (result == WAIT_OBJECT_0) {
            DWORD exitCode;
            if (GetExitCodeProcess(m_hProcess, &exitCode)) {
                std::wcout << L"Process exited with code: " << exitCode << std::endl;
            }
            return true;
        }

        return false;
    }

    HANDLE GetProcessHandle() const { return m_hProcess; }
    HANDLE GetThreadHandle() const { return m_hThread; }
};

// Function to check if we have sufficient privileges
bool CheckPrivileges()
{
    HANDLE hToken;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        return false;
    }

    TOKEN_ELEVATION elevation;
    DWORD dwSize;
    bool isElevated = false;

    if (GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize))
    {
        isElevated = elevation.TokenIsElevated;
    }

    CloseHandle(hToken);
    return isElevated;
}

int wmain(int argc, wchar_t* argv[])
{
    std::wcout << L"\nPPL Process Creator" << std::endl;
    std::wcout << L"Two Seven One Three: x.com/TwoSevenOneT" << std::endl;
    std::wcout << L"==================================================" << std::endl << std::endl;
    //

    // Check if running with sufficient privileges
    if (!CheckPrivileges())
    {
        std::wcerr << L"Error: This program requires elevated privileges (Run as Administrator)" << std::endl;
        return 1;
    }

    if (argc < 3)
    {
        std::wcout << L"Usage: " << argv[0] << L"[mode:0-4] <executable_path> [command_line_args]" << std::endl << std::endl;
        std::wcout << L"Example: " << argv[0] << L" 1 \"C:\\Windows\\System32\\PPL.exe\"" << std::endl << std::endl;
        std::wcout << L"MODE: " << std::endl;
        std::wcout << L"PROTECTION_LEVEL_WINTCB_LIGHT       00000000" << std::endl;
        std::wcout << L"PROTECTION_LEVEL_WINDOWS            00000001" << std::endl;
        std::wcout << L"PROTECTION_LEVEL_WINDOWS_LIGHT      00000002" << std::endl;
        std::wcout << L"PROTECTION_LEVEL_ANTIMALWARE_LIGHT  00000003" << std::endl;
        std::wcout << L"PROTECTION_LEVEL_LSA_LIGHT          00000004" << std::endl;
        return 1;
    }
    //#define PROTECTION_LEVEL_WINTCB_LIGHT       0x00000000
    //#define PROTECTION_LEVEL_WINDOWS            0x00000001
    //#define PROTECTION_LEVEL_WINDOWS_LIGHT      0x00000002
    //#define PROTECTION_LEVEL_ANTIMALWARE_LIGHT  0x00000003
    //#define PROTECTION_LEVEL_LSA_LIGHT          0x00000004
    wchar_t* end;
    long value = wcstol(argv[1], &end, 10);
    DWORD protectionLevel = PROTECTION_LEVEL_ANTIMALWARE_LIGHT;
    switch (value)
    {
    case 0:
    {
        protectionLevel = PROTECTION_LEVEL_WINTCB_LIGHT;
        break;
    }
    case 1:
    {
        protectionLevel = PROTECTION_LEVEL_WINDOWS;
        break;
    }
    case 2:
    {
        protectionLevel = PROTECTION_LEVEL_WINDOWS_LIGHT;
        break;
    }
    case 4:
    {
        protectionLevel = PROTECTION_LEVEL_LSA_LIGHT;
        break;
    }
    default:
        break;
    }

    PPLProcessCreator creator;
    std::wstring executablePath = argv[2];
    std::wstring commandLine;

    // Build command line from remaining arguments
    for (int i = 3; i < argc; ++i)
    {
        if (!commandLine.empty())
        {
            commandLine += L" ";
        }
        commandLine += argv[i];
    }

    // Create the PPL process
    if (creator.CreatePPLProcess(protectionLevel, executablePath, commandLine))
    {
        std::wcout << L"Process created successfully. Waiting for completion..." << std::endl;
        creator.WaitForProcess();
        return 0;
    }
    else
    {
        std::wcerr << L"Failed to create PPL process." << std::endl;
        return 1;
    }
}

```

`CreateProcessAsPPL.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35825.156 d17.13
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CreateProcessAsPPL", "CreateProcessAsPPL.vcxproj", "{4E850EA4-209F-44A7-9104-E4A34A00CB83}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PPLSupportCheck", "..\PPLSupportCheck\PPLSupportCheck.vcxproj", "{62DB1282-7224-41F9-A328-5F52241D8E0D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4E850EA4-209F-44A7-9104-E4A34A00CB83}.Debug|x64.ActiveCfg = Debug|x64
		{4E850EA4-209F-44A7-9104-E4A34A00CB83}.Debug|x64.Build.0 = Debug|x64
		{4E850EA4-209F-44A7-9104-E4A34A00CB83}.Debug|x86.ActiveCfg = Debug|Win32
		{4E850EA4-209F-44A7-9104-E4A34A00CB83}.Debug|x86.Build.0 = Debug|Win32
		{4E850EA4-209F-44A7-9104-E4A34A00CB83}.Release|x64.ActiveCfg = Release|x64
		{4E850EA4-209F-44A7-9104-E4A34A00CB83}.Release|x64.Build.0 = Release|x64
		{4E850EA4-209F-44A7-9104-E4A34A00CB83}.Release|x86.ActiveCfg = Release|Win32
		{4E850EA4-209F-44A7-9104-E4A34A00CB83}.Release|x86.Build.0 = Release|Win32
		{62DB1282-7224-41F9-A328-5F52241D8E0D}.Debug|x64.ActiveCfg = Debug|x64
		{62DB1282-7224-41F9-A328-5F52241D8E0D}.Debug|x64.Build.0 = Debug|x64
		{62DB1282-7224-41F9-A328-5F52241D8E0D}.Debug|x86.ActiveCfg = Debug|Win32
		{62DB1282-7224-41F9-A328-5F52241D8E0D}.Debug|x86.Build.0 = Debug|Win32
		{62DB1282-7224-41F9-A328-5F52241D8E0D}.Release|x64.ActiveCfg = Release|x64
		{62DB1282-7224-41F9-A328-5F52241D8E0D}.Release|x64.Build.0 = Release|x64
		{62DB1282-7224-41F9-A328-5F52241D8E0D}.Release|x86.ActiveCfg = Release|Win32
		{62DB1282-7224-41F9-A328-5F52241D8E0D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DA304F95-660D-4540-A20E-2244CD10F7F0}
	EndGlobalSection
EndGlobal

```

`CreateProcessAsPPL.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4e850ea4-209f-44a7-9104-e4a34a00cb83}</ProjectGuid>
    <RootNamespace>CreateProcessAsPPL</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CreateProcessAsPPL.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CreateProcessAsPPL.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CreateProcessAsPPL.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`README.md`:

```md
### CreateProcessAsPPL

If you want to run a program with PPL protection enabled, then this tool will help you do that.

### Command Line Syntax

**CreateProcessAsPPL.exe Mode:0-4 path_to_exe arg0 arg1 ...**

**Mode:**

* PROTECTION_LEVEL_WINTCB_LIGHT       0
* PROTECTION_LEVEL_WINDOWS            1
* PROTECTION_LEVEL_WINDOWS_LIGHT      2
* PROTECTION_LEVEL_ANTIMALWARE_LIGHT  3
* PROTECTION_LEVEL_LSA_LIGHT          4

## Author:

[Two Seven One Three](https://x.com/TwoSevenOneT)

```