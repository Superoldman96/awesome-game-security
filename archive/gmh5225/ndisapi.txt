Project Path: arc_gmh5225_ndisapi_edh302ff

Source Tree:

```txt
arc_gmh5225_ndisapi_edh302ff
├── Cargo.toml
├── LICENSE
├── README.md
├── examples
│   ├── filter.rs
│   ├── listadapters.rs
│   ├── packthru.rs
│   └── passthru.rs
└── src
    ├── driver
    │   ├── base.rs
    │   ├── constants.rs
    │   ├── fastio.rs
    │   ├── filters.rs
    │   └── ioctl.rs
    ├── driver.rs
    ├── lib.rs
    ├── ndisapi
    │   ├── base_api.rs
    │   ├── defs.rs
    │   ├── fastio_api.rs
    │   ├── filters_api.rs
    │   ├── io_api.rs
    │   └── static_api.rs
    ├── ndisapi.rs
    └── net.rs

```

`Cargo.toml`:

```toml
[package]
name = "ndisapi"
version = "0.2.0"
edition = "2021"
authors = ["Vadim Smirnov <vadim@ntkernel.com>"]
description = "Windows Packet Filter API for Rust"
license = "Apache-2.0"
documentation = "https://docs.rs/ndisapi"
repository = "https://github.com/firezone/ndisapi"
readme = "README.md"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
bitflags = "2.1.0"

[dependencies.windows]
version = "0.48.0"
features = [
    "Win32_Foundation",
    "Win32_Security",
    "Win32_System_Registry",
    "Win32_System_Threading",
    "Win32_System_IO",
    "Win32_Storage_FileSystem",
    "Win32_Networking_WinSock",
    "Win32_System_SystemInformation",
    ]

[dev-dependencies]
etherparse = "0.13"
clap = {version = "4.0.32", features = ["derive"]}
ctrlc = "3.2.4"

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2023 Firezone, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# NDISAPI

[![Crates.io](https://img.shields.io/crates/v/ndisapi.svg)](https://crates.io/crates/ndisapi)
[![Documentation](https://docs.rs/ndisapi/badge.svg)](https://docs.rs/ndisapi)
[![License](https://img.shields.io/crates/l/ndisapi)](https://github.com/firezone/ndisapi/blob/main/LICENSE)

NDISAPI is a Rust crate for interacting with the [Windows Packet Filter](https://www.ntkernel.com/windows-packet-filter/) driver. It provides an easy-to-use, safe, and efficient interface to efficiently filter (inspect and modify) raw network packets at the NDIS level of the network stack with minimal impact on network activity.

Windows Packet Filter (WinpkFilter) is a high-performance, lightweight packet filtering framework for Windows, enabling developers to efficiently inspect, modify, and control raw network packets at the NDIS level. With user-friendly APIs and support for various Windows versions, WinpkFilter simplifies network packet manipulation without requiring kernel-mode programming expertise.

## Features

- Enumerate network adapters
- Query and set network adapter properties
- Capture and analyze packets
- Filter and modify packets
- Send raw packets

## Dependencies

- Rust 1.58.0 or later
- Windows 7, 8, 10, or 11
- [Windows Packet Filter](https://github.com/wiresock/ndisapi/releases) driver installed

## Installation

Add the following to your `Cargo.toml` file:

```toml
[dependencies]
ndisapi = "0.2.0"
```

## Usage

Here's an example of how to enumerate network adapters and print their information:

```rust
use ndisapi::{MacAddress, Ndisapi};

fn main() {
    let ndis = Ndisapi::new("NDISRD").expect("Failed to create NdisApi instance");

    let adapters = ndis
        .get_tcpip_bound_adapters_info()
        .expect("Failed to enumerate adapters");

    for adapter in adapters {
        println!("Adapter: {:?}", adapter.get_name());
        println!(
            "Description: {:?}",
            Ndisapi::get_friendly_adapter_name(adapter.get_name()).unwrap_or("Unknown".to_string())
        );
        println!(
            "MAC Address: {:?}",
            MacAddress::from_slice(adapter.get_hw_address()).unwrap_or_default()
        );
        println!("-------------------------------");
    }
}
```

For more examples and in-depth usage, check out the [documentation](https://docs.rs/ndisapi).

## License

This project is licensed under the Apache License 2.0. See [LICENSE](https://github.com/firezone/ndisapi/blob/main/LICENSE) for details.


```

`examples/filter.rs`:

```rs
/// This example demonstrates the basic usage of the `set_packet_filter_table` API, showcasing different filter scenarios:
///
/// 1. Redirect only DNS packets for user mode processing.
/// 2. Redirect only HTTP (TCP port 80) packets for user mode processing.
/// 3. Drop all ICMP packets and redirect all other packets to user mode (default behavior).
/// 4. Block access to http://www.ntkernel.com, while allowing all other packets to pass without user mode processing.
/// 5. Redirect only ARP/RARP packets to user mode, and pass all other packets without processing.
/// 6. Redirect only outgoing ICMP ping request packets to user mode. Pass all others.
use clap::Parser;
use etherparse::{InternetSlice::*, LinkSlice::*, TransportSlice::*, *};
use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};
use windows::{
    core::Result,
    Win32::Foundation::HANDLE,
    Win32::Networking::WinSock::{IN_ADDR, IN_ADDR_0, IN_ADDR_0_0},
    Win32::System::Threading::{CreateEventW, SetEvent, WaitForSingleObject},
};

#[derive(Parser)]
struct Cli {
    /// Network interface index (please use listadapters example to determine the right one)
    #[clap(short, long)]
    interface_index: usize,
    /// Filter set to apply the selected network interface. The following sets are supported:
    /// 1 - Redirect only IPv4 DNS packets for processing in user mode.
    /// 2 - Redirect only HTTP(TCP port 80) packets for processing in user mode. Both IPv4 and IPv6 protocols.
    /// 3 - Drop all IPv4 ICMP packets. Redirect all other packets to user mode (default behaviour).
    /// 4 - Block IPv4 access to https://www.ntkernel.com. Pass all other packets without processing in user mode.
    /// 5 - Redirect only ARP/RARP packets to user mode. Pass all others.
    /// 6 - Redirect only outgoing ICMP ping request packets to user mode. Pass all others.
    #[clap(short, long, verbatim_doc_comment)]
    filter: usize,
}

// Reverse Addr Res packet
const ETH_P_RARP: u16 = 0x8035;
// Address Resolution packet
const ETH_P_ARP: u16 = 0x0806;

const IPPROTO_ICMP: u8 = 1;
const IPPROTO_TCP: u8 = 6;
const IPPROTO_UDP: u8 = 17;

const DNS_PORT: u16 = 53;
const HTTP_PORT: u16 = 80;

fn load_ipv4_dns_filters(ndisapi: &ndisapi::Ndisapi) -> Result<()> {
    let mut filter_table = ndisapi::StaticFilterTable::<3>::default();
    //**************************************************************************************
    // 1. Outgoing DNS requests filter: REDIRECT OUT UDP packets with destination PORT 53
    // Common values
    filter_table.static_filters[0].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[0].valid_fields = ndisapi::FilterLayerFlags::NETWORK_LAYER_VALID
        | ndisapi::FilterLayerFlags::TRANSPORT_LAYER_VALID;
    filter_table.static_filters[0].filter_action = ndisapi::FILTER_PACKET_REDIRECT;
    filter_table.static_filters[0].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    // Network layer filter
    filter_table.static_filters[0].network_filter.union_selector = ndisapi::IPV4;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .valid_fields = ndisapi::IpV4FilterFlags::IP_V4_FILTER_PROTOCOL;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .protocol = IPPROTO_UDP;

    // Transport layer filter
    filter_table.static_filters[0]
        .transport_filter
        .union_selector = ndisapi::TCPUDP;
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .tcp_udp
        .valid_fields = ndisapi::TcpUdpFilterFlags::TCPUDP_DEST_PORT;
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .tcp_udp
        .dest_port
        .start_range = DNS_PORT; // DNS
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .tcp_udp
        .dest_port
        .end_range = DNS_PORT;

    //****************************************************************************************
    // 2. Incoming DNS responses filter: REDIRECT IN UDP packets with source PORT 53
    // Common values
    filter_table.static_filters[1].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[1].valid_fields = ndisapi::FilterLayerFlags::NETWORK_LAYER_VALID
        | ndisapi::FilterLayerFlags::TRANSPORT_LAYER_VALID;
    filter_table.static_filters[1].filter_action = ndisapi::FILTER_PACKET_REDIRECT;
    filter_table.static_filters[1].direction_flags =
        ndisapi::DirectionFlags::PACKET_FLAG_ON_RECEIVE;

    // Network layer filter
    filter_table.static_filters[1].network_filter.union_selector = ndisapi::IPV4;
    filter_table.static_filters[1]
        .network_filter
        .network_layer
        .ipv4
        .valid_fields = ndisapi::IpV4FilterFlags::IP_V4_FILTER_PROTOCOL;
    filter_table.static_filters[1]
        .network_filter
        .network_layer
        .ipv4
        .protocol = IPPROTO_UDP;

    // Transport layer filter
    filter_table.static_filters[1]
        .transport_filter
        .union_selector = ndisapi::TCPUDP;
    filter_table.static_filters[1]
        .transport_filter
        .transport_layer
        .tcp_udp
        .valid_fields = ndisapi::TcpUdpFilterFlags::TCPUDP_SRC_PORT;
    filter_table.static_filters[1]
        .transport_filter
        .transport_layer
        .tcp_udp
        .source_port
        .start_range = DNS_PORT;
    filter_table.static_filters[1]
        .transport_filter
        .transport_layer
        .tcp_udp
        .source_port
        .end_range = DNS_PORT;

    //***************************************************************************************
    // 3. Pass all packets (skipped by previous filters) without processing in user mode
    // Common values
    filter_table.static_filters[2].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[2].valid_fields = ndisapi::FilterLayerFlags::empty();
    filter_table.static_filters[2].filter_action = ndisapi::FILTER_PACKET_PASS;
    filter_table.static_filters[2].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_RECEIVE
        | ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    ndisapi.set_packet_filter_table(&filter_table)
}

fn load_http_ipv4v6_filters(ndisapi: &ndisapi::Ndisapi) -> Result<()> {
    let mut filter_table = ndisapi::StaticFilterTable::<5>::default();
    //**************************************************************************************
    // 1. Outgoing HTTP requests filter: REDIRECT OUT TCP packets with destination PORT 80 IPv4
    // Common values
    filter_table.static_filters[0].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[0].valid_fields = ndisapi::FilterLayerFlags::NETWORK_LAYER_VALID
        | ndisapi::FilterLayerFlags::TRANSPORT_LAYER_VALID;
    filter_table.static_filters[0].filter_action = ndisapi::FILTER_PACKET_REDIRECT;
    filter_table.static_filters[0].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    // Network layer filter
    filter_table.static_filters[0].network_filter.union_selector = ndisapi::IPV4;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .valid_fields = ndisapi::IpV4FilterFlags::IP_V4_FILTER_PROTOCOL;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .protocol = IPPROTO_TCP;

    // Transport layer filter
    filter_table.static_filters[0]
        .transport_filter
        .union_selector = ndisapi::TCPUDP;
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .tcp_udp
        .valid_fields = ndisapi::TcpUdpFilterFlags::TCPUDP_DEST_PORT;
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .tcp_udp
        .dest_port
        .start_range = HTTP_PORT; // HTTP
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .tcp_udp
        .dest_port
        .end_range = HTTP_PORT;

    //****************************************************************************************
    // 2. Incoming HTTP responses filter: REDIRECT IN TCP packets with source PORT 80 IPv4
    // Common values
    filter_table.static_filters[1].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[1].valid_fields = ndisapi::FilterLayerFlags::NETWORK_LAYER_VALID
        | ndisapi::FilterLayerFlags::TRANSPORT_LAYER_VALID;
    filter_table.static_filters[1].filter_action = ndisapi::FILTER_PACKET_REDIRECT;
    filter_table.static_filters[1].direction_flags =
        ndisapi::DirectionFlags::PACKET_FLAG_ON_RECEIVE;

    // Network layer filter
    filter_table.static_filters[1].network_filter.union_selector = ndisapi::IPV4;
    filter_table.static_filters[1]
        .network_filter
        .network_layer
        .ipv4
        .valid_fields = ndisapi::IpV4FilterFlags::IP_V4_FILTER_PROTOCOL;
    filter_table.static_filters[1]
        .network_filter
        .network_layer
        .ipv4
        .protocol = IPPROTO_TCP;

    // Transport layer filter
    filter_table.static_filters[1]
        .transport_filter
        .union_selector = ndisapi::TCPUDP;
    filter_table.static_filters[1]
        .transport_filter
        .transport_layer
        .tcp_udp
        .valid_fields = ndisapi::TcpUdpFilterFlags::TCPUDP_SRC_PORT;
    filter_table.static_filters[1]
        .transport_filter
        .transport_layer
        .tcp_udp
        .source_port
        .start_range = HTTP_PORT; // HTTP
    filter_table.static_filters[1]
        .transport_filter
        .transport_layer
        .tcp_udp
        .source_port
        .end_range = HTTP_PORT;

    //****************************************************************************************
    // 3. Outgoing HTTP requests filter: REDIRECT OUT TCP packets with destination PORT 80 IPv6
    // Common values
    filter_table.static_filters[2].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[2].valid_fields = ndisapi::FilterLayerFlags::NETWORK_LAYER_VALID
        | ndisapi::FilterLayerFlags::TRANSPORT_LAYER_VALID;
    filter_table.static_filters[2].filter_action = ndisapi::FILTER_PACKET_REDIRECT;
    filter_table.static_filters[2].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    // Network layer filter
    filter_table.static_filters[2].network_filter.union_selector = ndisapi::IPV6;
    filter_table.static_filters[2]
        .network_filter
        .network_layer
        .ipv6
        .valid_fields = ndisapi::IpV6FilterFlags::IP_V6_FILTER_PROTOCOL;
    filter_table.static_filters[2]
        .network_filter
        .network_layer
        .ipv6
        .protocol = IPPROTO_TCP;

    // Transport layer filter
    filter_table.static_filters[2]
        .transport_filter
        .union_selector = ndisapi::TCPUDP;
    filter_table.static_filters[2]
        .transport_filter
        .transport_layer
        .tcp_udp
        .valid_fields = ndisapi::TcpUdpFilterFlags::TCPUDP_DEST_PORT;
    filter_table.static_filters[2]
        .transport_filter
        .transport_layer
        .tcp_udp
        .dest_port
        .start_range = HTTP_PORT; // HTTP
    filter_table.static_filters[2]
        .transport_filter
        .transport_layer
        .tcp_udp
        .dest_port
        .end_range = HTTP_PORT;

    //****************************************************************************************
    // 4. Incoming HTTP responses filter: REDIRECT IN TCP packets with source PORT 80 IPv6
    // Common values
    filter_table.static_filters[3].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[3].valid_fields = ndisapi::FilterLayerFlags::NETWORK_LAYER_VALID
        | ndisapi::FilterLayerFlags::TRANSPORT_LAYER_VALID;
    filter_table.static_filters[3].filter_action = ndisapi::FILTER_PACKET_REDIRECT;
    filter_table.static_filters[3].direction_flags =
        ndisapi::DirectionFlags::PACKET_FLAG_ON_RECEIVE;

    // Network layer filter
    filter_table.static_filters[3].network_filter.union_selector = ndisapi::IPV6;
    filter_table.static_filters[3]
        .network_filter
        .network_layer
        .ipv6
        .valid_fields = ndisapi::IpV6FilterFlags::IP_V6_FILTER_PROTOCOL;
    filter_table.static_filters[3]
        .network_filter
        .network_layer
        .ipv6
        .protocol = IPPROTO_TCP;

    // Transport layer filter
    filter_table.static_filters[3]
        .transport_filter
        .union_selector = ndisapi::TCPUDP;
    filter_table.static_filters[3]
        .transport_filter
        .transport_layer
        .tcp_udp
        .valid_fields = ndisapi::TcpUdpFilterFlags::TCPUDP_SRC_PORT;
    filter_table.static_filters[3]
        .transport_filter
        .transport_layer
        .tcp_udp
        .source_port
        .end_range = HTTP_PORT; // HTTP
    filter_table.static_filters[3]
        .transport_filter
        .transport_layer
        .tcp_udp
        .source_port
        .end_range = HTTP_PORT;

    //***************************************************************************************
    // 5. Pass all packets (skipped by previous filters) without processing in user mode
    // Common values
    filter_table.static_filters[4].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[4].valid_fields = ndisapi::FilterLayerFlags::empty();
    filter_table.static_filters[4].filter_action = ndisapi::FILTER_PACKET_PASS;
    filter_table.static_filters[4].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_RECEIVE
        | ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    ndisapi.set_packet_filter_table(&filter_table)
}

fn load_icmpv4_drop_filters(ndisapi: &ndisapi::Ndisapi) -> Result<()> {
    let mut filter_table = ndisapi::StaticFilterTable::<1>::default();
    //**************************************************************************************
    // 1. Block all ICMP packets
    // Common values
    filter_table.static_filters[0].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[0].valid_fields = ndisapi::FilterLayerFlags::NETWORK_LAYER_VALID;
    filter_table.static_filters[0].filter_action = ndisapi::FILTER_PACKET_DROP;
    filter_table.static_filters[0].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND
        | ndisapi::DirectionFlags::PACKET_FLAG_ON_RECEIVE;

    // Network layer filter
    filter_table.static_filters[0].network_filter.union_selector = ndisapi::IPV4;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .valid_fields = ndisapi::IpV4FilterFlags::IP_V4_FILTER_PROTOCOL;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .protocol = IPPROTO_ICMP;

    ndisapi.set_packet_filter_table(&filter_table)
}

fn load_block_ntkernel_https_filters(ndisapi: &ndisapi::Ndisapi) -> Result<()> {
    let mut filter_table = ndisapi::StaticFilterTable::<2>::default();

    //**************************************************************************************
    // 1. Outgoing HTTP requests filter: DROP OUT TCP packets with destination IP 95.179.146.125 PORT 443 (https://www.ntkernel.com)
    // Common values
    filter_table.static_filters[0].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[0].valid_fields = ndisapi::FilterLayerFlags::NETWORK_LAYER_VALID
        | ndisapi::FilterLayerFlags::TRANSPORT_LAYER_VALID;
    filter_table.static_filters[0].filter_action = ndisapi::FILTER_PACKET_DROP;
    filter_table.static_filters[0].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    // Network layer filter
    let address = IN_ADDR {
        S_un: IN_ADDR_0 {
            S_un_b: IN_ADDR_0_0 {
                s_b1: 95,
                s_b2: 179,
                s_b3: 146,
                s_b4: 125,
            },
        },
    };

    let mask = IN_ADDR {
        S_un: IN_ADDR_0 {
            S_un_b: IN_ADDR_0_0 {
                s_b1: 255,
                s_b2: 255,
                s_b3: 255,
                s_b4: 255,
            },
        },
    };

    filter_table.static_filters[0].network_filter.union_selector = ndisapi::IPV4;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .valid_fields = ndisapi::IpV4FilterFlags::IP_V4_FILTER_PROTOCOL
        | ndisapi::IpV4FilterFlags::IP_V4_FILTER_DEST_ADDRESS;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .dest_address
        .address_type = ndisapi::IP_SUBNET_V4_TYPE;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .dest_address
        .address
        .ip_subnet
        .ip = address; // IP address
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .dest_address
        .address
        .ip_subnet
        .ip_mask = mask; // network mask
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .protocol = IPPROTO_TCP;

    // Transport layer filter
    filter_table.static_filters[0]
        .transport_filter
        .union_selector = ndisapi::TCPUDP;
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .tcp_udp
        .valid_fields = ndisapi::TcpUdpFilterFlags::TCPUDP_DEST_PORT;
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .tcp_udp
        .dest_port
        .start_range = 443; // HTTPS
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .tcp_udp
        .dest_port
        .end_range = 443;

    //***************************************************************************************
    // 2. Pass all packets (skipped by previous filters) without processing in user mode
    // Common values
    filter_table.static_filters[1].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[1].valid_fields = ndisapi::FilterLayerFlags::empty();
    filter_table.static_filters[1].filter_action = ndisapi::FILTER_PACKET_PASS;
    filter_table.static_filters[1].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_RECEIVE
        | ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    ndisapi.set_packet_filter_table(&filter_table)
}

fn load_redirect_arp_filters(ndisapi: &ndisapi::Ndisapi) -> Result<()> {
    let mut filter_table = ndisapi::StaticFilterTable::<3>::default();

    //**************************************************************************************
    // 1. Redirects all ARP packets to be processes by user mode application
    // Common values
    filter_table.static_filters[0].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[0].valid_fields = ndisapi::FilterLayerFlags::DATA_LINK_LAYER_VALID;
    filter_table.static_filters[0].filter_action = ndisapi::FILTER_PACKET_REDIRECT;
    filter_table.static_filters[0].direction_flags =
        ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND_RECEIVE;
    filter_table.static_filters[0]
        .data_link_filter
        .union_selector = ndisapi::ETH_802_3;
    filter_table.static_filters[0]
        .data_link_filter
        .data_link_layer
        .eth_8023_filter
        .valid_fields = ndisapi::Eth802_3FilterFlags::ETH_802_3_PROTOCOL;
    filter_table.static_filters[0]
        .data_link_filter
        .data_link_layer
        .eth_8023_filter
        .protocol = ETH_P_ARP;

    //**************************************************************************************
    // 2. Redirects all RARP packets to be processes by user mode application
    // Common values
    filter_table.static_filters[1].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[1].valid_fields = ndisapi::FilterLayerFlags::DATA_LINK_LAYER_VALID;
    filter_table.static_filters[1].filter_action = ndisapi::FILTER_PACKET_REDIRECT;
    filter_table.static_filters[1].direction_flags =
        ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND_RECEIVE;
    filter_table.static_filters[1]
        .data_link_filter
        .union_selector = ndisapi::ETH_802_3;
    filter_table.static_filters[1]
        .data_link_filter
        .data_link_layer
        .eth_8023_filter
        .valid_fields = ndisapi::Eth802_3FilterFlags::ETH_802_3_PROTOCOL;
    filter_table.static_filters[1]
        .data_link_filter
        .data_link_layer
        .eth_8023_filter
        .protocol = ETH_P_RARP;

    //***************************************************************************************
    // 3. Pass all packets (skipped by previous filters) without processing in user mode
    // Common values
    filter_table.static_filters[2].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[2].valid_fields = ndisapi::FilterLayerFlags::empty();
    filter_table.static_filters[2].filter_action = ndisapi::FILTER_PACKET_PASS;
    filter_table.static_filters[2].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_RECEIVE
        | ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    ndisapi.set_packet_filter_table(&filter_table)
}

fn load_redirect_icmp_req_filters(ndisapi: &ndisapi::Ndisapi) -> Result<()> {
    let mut filter_table = ndisapi::StaticFilterTable::<2>::default();

    //**************************************************************************************
    // 1. Redirects all ARP packets to be processes by user mode application
    // Common values
    filter_table.static_filters[0].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[0].valid_fields = ndisapi::FilterLayerFlags::NETWORK_LAYER_VALID
        | ndisapi::FilterLayerFlags::TRANSPORT_LAYER_VALID;
    filter_table.static_filters[0].filter_action = ndisapi::FILTER_PACKET_REDIRECT;
    filter_table.static_filters[0].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    filter_table.static_filters[0].network_filter.union_selector = ndisapi::IPV4;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .valid_fields = ndisapi::IpV4FilterFlags::IP_V4_FILTER_PROTOCOL;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .dest_address
        .address_type = ndisapi::IP_SUBNET_V4_TYPE;
    filter_table.static_filters[0]
        .network_filter
        .network_layer
        .ipv4
        .protocol = IPPROTO_ICMP;

    // Transport layer filter
    filter_table.static_filters[0]
        .transport_filter
        .union_selector = ndisapi::ICMP;
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .icmp
        .valid_fields = ndisapi::IcmpFilterFlags::ICMP_TYPE;
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .icmp
        .type_range
        .start_range = 8; // ICMP PING REQUEST
    filter_table.static_filters[0]
        .transport_filter
        .transport_layer
        .icmp
        .type_range
        .end_range = 8;

    //***************************************************************************************
    // 2. Pass all packets (skipped by previous filters) without processing in user mode
    // Common values
    filter_table.static_filters[1].adapter_handle = 0; // applied to all adapters
    filter_table.static_filters[1].valid_fields = ndisapi::FilterLayerFlags::empty();
    filter_table.static_filters[1].filter_action = ndisapi::FILTER_PACKET_PASS;
    filter_table.static_filters[1].direction_flags = ndisapi::DirectionFlags::PACKET_FLAG_ON_RECEIVE
        | ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND;

    ndisapi.set_packet_filter_table(&filter_table)
}

fn main() -> Result<()> {
    let Cli {
        mut interface_index,
        filter,
    } = Cli::parse();

    interface_index -= 1;

    let driver = ndisapi::Ndisapi::new("NDISRD")
        .expect("WinpkFilter driver is not installed or failed to load!");

    println!(
        "Detected Windows Packet Filter version {}",
        driver.get_version()?
    );

    let adapters = driver.get_tcpip_bound_adapters_info()?;

    if interface_index + 1 > adapters.len() {
        panic!("Interface index is beoynd the number of available interfaces");
    }

    println!("Using interface {}s", adapters[interface_index].get_name());

    let filter_set_result = match filter {
        1 => load_ipv4_dns_filters(&driver),
        2 => load_http_ipv4v6_filters(&driver),
        3 => load_icmpv4_drop_filters(&driver),
        4 => load_block_ntkernel_https_filters(&driver),
        5 => load_redirect_arp_filters(&driver),
        6 => load_redirect_icmp_req_filters(&driver),
        _ => panic!("Filter set is not availbale"),
    };

    match filter_set_result {
        Ok(_) => println!("Succesfully loaded static filters into the driver."),
        Err(err) => panic!("Failed to load static filter into the driver. Error code: {err}"),
    }

    // Create Win32 event
    let event: HANDLE;
    unsafe {
        event = CreateEventW(None, true, false, None)?;
    }

    let terminate: Arc<AtomicBool> = Arc::new(AtomicBool::new(false));
    let ctrlc_pressed = terminate.clone();
    ctrlc::set_handler(move || {
        println!("Ctrl-C was pressed. Terminating...");
        // set atomic flag to exit the loop
        ctrlc_pressed.store(true, Ordering::SeqCst);
        // signal an event to release the loop if there are no packets in the queue
        unsafe {
            SetEvent(event);
        }
    })
    .expect("Error setting Ctrl-C handler");

    // Set the event within the driver
    driver.set_packet_event(adapters[interface_index].get_handle(), event)?;

    // Put network interface into the tunnel mode
    driver.set_adapter_mode(
        adapters[interface_index].get_handle(),
        ndisapi::FilterFlags::MSTCP_FLAG_SENT_RECEIVE_TUNNEL,
    )?;

    // Allocate single IntermediateBuffer on the stack
    let mut ib = ndisapi::IntermediateBuffer::default();

    // Initialize EthPacket to pass to driver API
    let mut packet = ndisapi::EthRequest {
        adapter_handle: adapters[interface_index].get_handle(),
        packet: ndisapi::EthPacket {
            buffer: &mut ib as *mut ndisapi::IntermediateBuffer,
        },
    };

    while !terminate.load(Ordering::SeqCst) {
        unsafe {
            WaitForSingleObject(event, u32::MAX);
        }
        while unsafe { driver.read_packet(&mut packet) }.ok().is_some() {
            // Print packet information
            if ib.get_device_flags() == ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND {
                println!("\nMSTCP --> Interface ({} bytes)\n", ib.get_length());
            } else {
                println!("\nInterface --> MSTCP ({} bytes)\n", ib.get_length());
            }

            // Print some informations about the sliced packet
            print_packet_info(&mut ib);

            // Re-inject the packet back into the network stack
            if ib.get_device_flags() == ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND {
                match unsafe { driver.send_packet_to_adapter(&packet) } {
                    Ok(_) => {}
                    Err(err) => println!("Error sending packet to adapter. Error code = {err}"),
                };
            } else {
                match unsafe { driver.send_packet_to_mstcp(&packet) } {
                    Ok(_) => {}
                    Err(err) => println!("Error sending packet to mstcp. Error code = {err}"),
                }
            }
        }
    }

    Ok(())
}

/// Print detailed information about a network packet.
///
/// This function takes an `IntermediateBuffer` containing a network packet and prints various
/// details about the packet, such as Ethernet, IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP information.
///
/// # Arguments
///
/// * `packet` - A mutable reference to an `ndisapi::IntermediateBuffer` containing the network packet.
///
/// # Examples
///
/// ```no_run
/// let mut packet: ndisapi::IntermediateBuffer = ...;
/// print_packet_info(&mut packet);
/// ```
fn print_packet_info(packet: &mut ndisapi::IntermediateBuffer) {
    // Attempt to create a SlicedPacket from the Ethernet frame.
    match SlicedPacket::from_ethernet(&packet.buffer.0) {
        // If there's an error, print it.
        Err(value) => println!("Err {value:?}"),

        // If successful, proceed with printing packet information.
        Ok(value) => {
            // Print Ethernet information if available.
            if let Some(Ethernet2(value)) = value.link {
                println!(
                    " Ethernet {} => {}",
                    ndisapi::MacAddress::from_slice(&value.source()[..]).unwrap(),
                    ndisapi::MacAddress::from_slice(&value.destination()[..]).unwrap(),
                );
            }

            // Print IP information if available.
            match value.ip {
                Some(Ipv4(value, extensions)) => {
                    println!(
                        "  Ipv4 {:?} => {:?}",
                        value.source_addr(),
                        value.destination_addr()
                    );
                    if !extensions.is_empty() {
                        println!("    {extensions:?}");
                    }
                }
                Some(Ipv6(value, extensions)) => {
                    println!(
                        "  Ipv6 {:?} => {:?}",
                        value.source_addr(),
                        value.destination_addr()
                    );
                    if !extensions.is_empty() {
                        println!("    {extensions:?}");
                    }
                }
                None => {}
            }

            // Print transport layer information if available.
            match value.transport {
                Some(Icmpv4(value)) => println!(" Icmpv4 {value:?}"),
                Some(Icmpv6(value)) => println!(" Icmpv6 {value:?}"),
                Some(Udp(value)) => println!(
                    "   UDP {:?} -> {:?}",
                    value.source_port(),
                    value.destination_port()
                ),
                Some(Tcp(value)) => {
                    println!(
                        "   TCP {:?} -> {:?}",
                        value.source_port(),
                        value.destination_port()
                    );
                }
                Some(Unknown(ip_protocol)) => {
                    println!("  Unknown Protocol (ip protocol number {ip_protocol:?})")
                }
                None => {}
            }
        }
    }
}

```

`examples/listadapters.rs`:

```rs
/// This example demonstrates the basic usage of the `Ndisapi` object, `Ndisapi::get_tcpip_bound_adapters_info`,
/// adapter name conversion functions, and `Ndisapi::get_mtu_decrement` and etc.. It retrieves information about the
/// network interfaces, including their indexes, which can be passed to the `packthru` and `passthru`
/// examples. The collected information is dumped to the console screen.
use std::{
    mem::{self, size_of},
    ptr::write_bytes,
};

use ndisapi::{MacAddress, Ndisapi};
use windows::core::Result;

const OID_802_3_CURRENT_ADDRESS: u32 = 0x01010102;

fn main() -> Result<()> {
    let driver = ndisapi::Ndisapi::new("NDISRD")
        .expect("WinpkFilter driver is not installed or failed to load!");

    println!(
        "Detected Windows Packet Filter version {}",
        driver.get_version()?
    );

    let adapters = driver.get_tcpip_bound_adapters_info()?;

    for (index, adapter) in adapters.iter().enumerate() {
        // Display the information about each network interface provided by the get_tcpip_bound_adapters_info
        let network_interface_name = Ndisapi::get_friendly_adapter_name(adapter.get_name())
            .expect("Unkown network interface");
        println!(
            "{}. {}\n\t{}",
            index + 1,
            network_interface_name,
            adapter.get_name(),
        );
        println!("\t Medium: {}", adapter.get_medium());
        println!(
            "\t MAC: {}",
            MacAddress::from_slice(adapter.get_hw_address()).unwrap_or_default()
        );
        println!("\t MTU: {}", adapter.get_mtu());
        println!(
            "\t FilterFlags: {:?}",
            driver.get_adapter_mode(adapter.get_handle()).unwrap()
        );

        // Query hardware packet filter for the adapter using built wrapper for ndis_get_request
        match driver.get_hw_packet_filter(adapter.get_handle()) {
            Err(err) => println!(
                "Getting OID_GEN_CURRENT_PACKET_FILTER Error: {}",
                err.message().to_string_lossy()
            ),
            Ok(current_packet_filter) => {
                println!("\t OID_GEN_CURRENT_PACKET_FILTER: 0x{current_packet_filter:08X}")
            }
        }

        // Query MAC address of the network adapter using ndis_get_request directly
        let mut current_address_request = ndisapi::PacketOidData::new(
            adapter.get_handle(),
            OID_802_3_CURRENT_ADDRESS,
            ndisapi::MacAddress::default(),
        );
        if let Err(err) = driver.ndis_get_request::<_>(&mut current_address_request) {
            println!(
                "Getting OID_802_3_CURRENT_ADDRESS Error: {}",
                err.message().to_string_lossy()
            )
        } else {
            println!(
                "\t OID_802_3_CURRENT_ADDRESS: {}",
                current_address_request.data
            )
        }

        if Ndisapi::is_ndiswan_ip(adapter.get_name())
            || Ndisapi::is_ndiswan_ipv6(adapter.get_name())
        {
            let mut ras_links_vec: Vec<ndisapi::RasLinks> = Vec::with_capacity(1);
            // SAFETY: ndisapi::RasLinks is too large to allocate memory on the stack and results in a stackoverflow error
            // Here is the workaround get a raw pointer to the vector with capacity to hold one ndisapi::RasLinks structure,
            // zero initialize the vector allocated memory and then set a vector length to one
            unsafe {
                write_bytes::<u8>(
                    mem::transmute(ras_links_vec.as_mut_ptr()),
                    0,
                    size_of::<ndisapi::RasLinks>(),
                );
                ras_links_vec.set_len(1)
            };
            let ras_links = &mut ras_links_vec[0];

            if let Ok(()) = driver.get_ras_links(adapter.get_handle(), ras_links) {
                println!(
                    "Number of active WAN links: {}",
                    ras_links.get_number_of_links()
                );

                for k in 0..ras_links.get_number_of_links() {
                    println!(
                        "\t{}) LinkSpeed = {} MTU = {}",
                        k,
                        ras_links.ras_links[k].get_link_speed(),
                        ras_links.ras_links[k].get_maximum_total_size()
                    );

                    let local_mac_address =
                        MacAddress::from_slice(ras_links.ras_links[k].get_local_address()).unwrap();
                    let remote_mac_address =
                        MacAddress::from_slice(ras_links.ras_links[k].get_remote_address())
                            .unwrap();

                    println!("\t\tLocal MAC:\t {local_mac_address}");

                    println!("\t\tRemote MAC:\t {remote_mac_address}");

                    if Ndisapi::is_ndiswan_ip(adapter.get_name()) {
                        // Windows Vista and later offsets are used
                        println!(
                            "\t\tIP address:\t {}.{}.{}.{} mask {}.{}.{}.{}",
                            ras_links.ras_links[k].get_protocol_buffer()[584],
                            ras_links.ras_links[k].get_protocol_buffer()[585],
                            ras_links.ras_links[k].get_protocol_buffer()[586],
                            ras_links.ras_links[k].get_protocol_buffer()[587],
                            ras_links.ras_links[k].get_protocol_buffer()[588],
                            ras_links.ras_links[k].get_protocol_buffer()[589],
                            ras_links.ras_links[k].get_protocol_buffer()[590],
                            ras_links.ras_links[k].get_protocol_buffer()[591],
                        );
                    } else {
                        // IP v.6
                        println!(
                            "\t\tIPv6 address (without prefix):\t {:02X}{:02X}:{:02X}{:02X}:{:02X}{:02X}:{:02X}{:02X}",
                            ras_links.ras_links[k].get_protocol_buffer()[588],
                            ras_links.ras_links[k].get_protocol_buffer()[589],
                            ras_links.ras_links[k].get_protocol_buffer()[590],
                            ras_links.ras_links[k].get_protocol_buffer()[591],
                            ras_links.ras_links[k].get_protocol_buffer()[592],
                            ras_links.ras_links[k].get_protocol_buffer()[593],
                            ras_links.ras_links[k].get_protocol_buffer()[594],
                            ras_links.ras_links[k].get_protocol_buffer()[595],
                        );
                    }
                }
            } else {
                println!("Failed to query active WAN links information.");
            }
        }
    }

    let mtu_decrement = driver.get_mtu_decrement().unwrap_or(0);

    println!("\nSystem wide MTU decrement: {mtu_decrement}");

    let startup_mode = driver.get_adapters_startup_mode().unwrap_or(0);

    println!("\nSystem wide network adapter startup filter mode: {startup_mode}");

    let pool_size = driver.get_pool_size().unwrap_or(0);

    println!("\nDriver intermediate buffer pool size multiplier: {pool_size}");

    let effective_pool_size = driver.get_intermediate_buffer_pool_size().unwrap_or(0);

    println!("\nEffective intermediate buffer pool size: {effective_pool_size}");

    Ok(())
}

```

`examples/packthru.rs`:

```rs
/// This example demonstrates the fundamental usage of active filtering modes in packet processing. By selecting a
/// network interface and configuring it to operate in a filtering mode, both sent and received packets are queued.
/// The example registers a Win32 event through the `Ndisapi::set_packet_event` function and enters a waiting state
/// for incoming packets. As packets are received, their content is decoded and printed on the console screen, offering
/// a real-time visualization of network traffic. This example resembles the `passthru` utility but employs bulk
/// packet sending and receiving to optimize performance.
use clap::Parser;
use etherparse::{InternetSlice::*, LinkSlice::*, TransportSlice::*, *};
use windows::{
    core::Result,
    Win32::Foundation::HANDLE,
    Win32::System::Threading::{CreateEventW, WaitForSingleObject},
};

#[derive(Parser)]
struct Cli {
    /// Network interface index (please use listadapters example to determine the right one)
    #[clap(short, long)]
    interface_index: usize,
    /// Number of packets to read from the specified network interface
    #[clap(short, long)]
    packets_number: usize,
}

const PACKET_NUMBER: usize = 256;

fn main() -> Result<()> {
    // Parse command line arguments.
    let Cli {
        mut interface_index,
        mut packets_number,
    } = Cli::parse();

    // Decrement the interface index since it's zero-based.
    interface_index -= 1;

    // Initialize the NDISAPI driver.
    let driver = ndisapi::Ndisapi::new("NDISRD")
        .expect("WinpkFilter driver is not installed or failed to load!");

    // Print the detected Windows Packet Filter version.
    println!(
        "Detected Windows Packet Filter version {}",
        driver.get_version()?
    );

    // Get a list of TCP/IP bound adapters.
    let adapters = driver.get_tcpip_bound_adapters_info()?;

    // Validate the user-specified interface index.
    if interface_index + 1 > adapters.len() {
        panic!("Interface index is beyond the number of available interfaces");
    }

    // Print the selected interface and number of packets to process.
    println!(
        "Using interface {} with {} packets",
        adapters[interface_index].get_name(),
        packets_number
    );

    // Create a Win32 event.
    let event: HANDLE = unsafe { CreateEventW(None, true, false, None)? };

    // Set the event within the driver.
    driver.set_packet_event(adapters[interface_index].get_handle(), event)?;

    // Put the network interface into tunnel mode.
    driver.set_adapter_mode(
        adapters[interface_index].get_handle(),
        ndisapi::FilterFlags::MSTCP_FLAG_SENT_RECEIVE_TUNNEL,
    )?;

    // Initialize a container to store IntermediateBuffers allocated on the heap.
    let mut ibs: Vec<ndisapi::IntermediateBuffer> = vec![Default::default(); PACKET_NUMBER];

    // Initialize containers to read/write IntermediateBuffers from/to the driver.
    let mut to_read = ndisapi::EthMRequest::new(adapters[interface_index].get_handle());
    let mut to_mstcp: ndisapi::EthMRequest<PACKET_NUMBER> =
        ndisapi::EthMRequest::new(adapters[interface_index].get_handle());
    let mut to_adapter: ndisapi::EthMRequest<PACKET_NUMBER> =
        ndisapi::EthMRequest::new(adapters[interface_index].get_handle());

    // Initialize the read EthMRequest object.
    for ib in &mut ibs {
        to_read.push(ndisapi::EthPacket {
            buffer: ib as *mut _,
        })?;
    }

    // Main loop: Process packets until the specified number of packets is reached.
    while packets_number > 0 {
        // Wait for the event to be signaled.
        unsafe {
            WaitForSingleObject(event, u32::MAX);
        }

        // Read packets from the driver.
        let mut packets_read: usize;
        while {
            packets_read =
                unsafe { driver.read_packets::<PACKET_NUMBER>(&mut to_read) }.unwrap_or(0usize);
            packets_read > 0
        } {
            // Decrement the packets counter.
            packets_number = packets_number.saturating_sub(packets_read);

            // Process each packet.
            for i in 0..packets_read {
                let mut eth = to_read.at(i).unwrap();
                let packet = unsafe { eth.get_buffer_mut() };

                // Print packet direction and remaining packets.
                if packet.get_device_flags() == ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND {
                    println!(
                        "\nMSTCP --> Interface ({} bytes) remaining packets {}\n",
                        packet.get_length(),
                        packets_number + (packets_read - i)
                    );
                } else {
                    println!(
                        "\nInterface --> MSTCP ({} bytes) remaining packets {}\n",
                        packet.get_length(),
                        packets_number + (packets_read - i)
                    );
                }

                // Print packet information
                print_packet_info(packet);

                if packet.get_device_flags() == ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND {
                    to_adapter.push(eth)?;
                } else {
                    to_mstcp.push(eth)?;
                }
            }

            // Re-inject packets back into the network stack
            if to_adapter.get_packet_number() > 0 {
                match unsafe { driver.send_packets_to_adapter::<PACKET_NUMBER>(&to_adapter) } {
                    Ok(_) => {}
                    Err(err) => println!("Error sending packet to adapter. Error code = {err}"),
                }
                to_adapter.reset();
            }

            if !to_mstcp.get_packet_number() > 0 {
                match unsafe { driver.send_packets_to_mstcp::<PACKET_NUMBER>(&to_mstcp) } {
                    Ok(_) => {}
                    Err(err) => println!("Error sending packet to mstcp. Error code = {err}"),
                };
                to_mstcp.reset();
            }

            if packets_number == 0 {
                println!("Filtering complete\n");
                break;
            }
        }
    }

    Ok(())
}

/// Print detailed information about a network packet.
///
/// This function takes an `IntermediateBuffer` containing a network packet and prints various
/// details about the packet, such as Ethernet, IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP information.
///
/// # Arguments
///
/// * `packet` - A mutable reference to an `ndisapi::IntermediateBuffer` containing the network packet.
///
/// # Examples
///
/// ```no_run
/// let mut packet: ndisapi::IntermediateBuffer = ...;
/// print_packet_info(&mut packet);
/// ```
fn print_packet_info(packet: &mut ndisapi::IntermediateBuffer) {
    // Attempt to create a SlicedPacket from the Ethernet frame.
    match SlicedPacket::from_ethernet(&packet.buffer.0) {
        // If there's an error, print it.
        Err(value) => println!("Err {value:?}"),

        // If successful, proceed with printing packet information.
        Ok(value) => {
            // Print Ethernet information if available.
            if let Some(Ethernet2(value)) = value.link {
                println!(
                    " Ethernet {} => {}",
                    ndisapi::MacAddress::from_slice(&value.source()[..]).unwrap(),
                    ndisapi::MacAddress::from_slice(&value.destination()[..]).unwrap(),
                );
            }

            // Print IP information if available.
            match value.ip {
                Some(Ipv4(value, extensions)) => {
                    println!(
                        "  Ipv4 {:?} => {:?}",
                        value.source_addr(),
                        value.destination_addr()
                    );
                    if !extensions.is_empty() {
                        println!("    {extensions:?}");
                    }
                }
                Some(Ipv6(value, extensions)) => {
                    println!(
                        "  Ipv6 {:?} => {:?}",
                        value.source_addr(),
                        value.destination_addr()
                    );
                    if !extensions.is_empty() {
                        println!("    {extensions:?}");
                    }
                }
                None => {}
            }

            // Print transport layer information if available.
            match value.transport {
                Some(Icmpv4(value)) => println!(" Icmpv4 {value:?}"),
                Some(Icmpv6(value)) => println!(" Icmpv6 {value:?}"),
                Some(Udp(value)) => println!(
                    "   UDP {:?} -> {:?}",
                    value.source_port(),
                    value.destination_port()
                ),
                Some(Tcp(value)) => {
                    println!(
                        "   TCP {:?} -> {:?}",
                        value.source_port(),
                        value.destination_port()
                    );
                }
                Some(Unknown(ip_protocol)) => {
                    println!("  Unknown Protocol (ip protocol number {ip_protocol:?})")
                }
                None => {}
            }
        }
    }
}

```

`examples/passthru.rs`:

```rs
/// This example demonstrates the essential usage of active filtering modes for packet processing. It selects a
/// network interface and sets it into a filtering mode, where both sent and received packets are queued. The example
/// registers a Win32 event using the `Ndisapi::set_packet_event` function, and enters a waiting state for incoming packets.
/// Upon receiving a packet, its content is decoded and displayed on the console screen, providing a real-time view of
/// the network traffic.
use clap::Parser;
use etherparse::{InternetSlice::*, LinkSlice::*, TransportSlice::*, *};
use windows::{
    core::Result,
    Win32::Foundation::HANDLE,
    Win32::System::Threading::{CreateEventW, WaitForSingleObject},
};

#[derive(Parser)]
struct Cli {
    /// Network interface index (please use listadapters example to determine the right one)
    #[clap(short, long)]
    interface_index: usize,
    /// Number of packets to read from the specified network interface
    #[clap(short, long)]
    packets_number: usize,
}

fn main() -> Result<()> {
    let Cli {
        mut interface_index,
        mut packets_number,
    } = Cli::parse();

    interface_index -= 1;

    let driver = ndisapi::Ndisapi::new("NDISRD")
        .expect("WinpkFilter driver is not installed or failed to load!");

    println!(
        "Detected Windows Packet Filter version {}",
        driver.get_version()?
    );

    let adapters = driver.get_tcpip_bound_adapters_info()?;

    if interface_index + 1 > adapters.len() {
        panic!("Interface index is beoynd the number of available interfaces");
    }

    println!(
        "Using interface {} with {} packets",
        adapters[interface_index].get_name(),
        packets_number
    );

    // Create Win32 event
    let event: HANDLE;
    unsafe {
        event = CreateEventW(None, true, false, None)?;
    }

    // Set the event within the driver
    driver.set_packet_event(adapters[interface_index].get_handle(), event)?;

    // Put network interface into the tunnel mode
    driver.set_adapter_mode(
        adapters[interface_index].get_handle(),
        ndisapi::FilterFlags::MSTCP_FLAG_SENT_RECEIVE_TUNNEL,
    )?;

    // Allocate single IntermediateBuffer on the stack
    let mut ib = ndisapi::IntermediateBuffer::default();

    // Initialize EthPacket to pass to driver API
    let mut packet = ndisapi::EthRequest {
        adapter_handle: adapters[interface_index].get_handle(),
        packet: ndisapi::EthPacket {
            buffer: &mut ib as *mut ndisapi::IntermediateBuffer,
        },
    };

    while packets_number > 0 {
        unsafe {
            WaitForSingleObject(event, u32::MAX);
        }
        while unsafe { driver.read_packet(&mut packet) }.ok().is_some() {
            // Print packet information
            if ib.get_device_flags() == ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND {
                println!(
                    "\nMSTCP --> Interface ({} bytes) remaining packets {}\n",
                    ib.get_length(),
                    packets_number
                );
            } else {
                println!(
                    "\nInterface --> MSTCP ({} bytes) remaining packets {}\n",
                    ib.get_length(),
                    packets_number
                );
            }

            // Decrement packets counter
            packets_number -= 1;

            // Print some informations about the sliced packet
            print_packet_info(&mut ib);

            // Re-inject the packet back into the network stack
            if ib.get_device_flags() == ndisapi::DirectionFlags::PACKET_FLAG_ON_SEND {
                match unsafe { driver.send_packet_to_adapter(&packet) } {
                    Ok(_) => {}
                    Err(err) => println!("Error sending packet to adapter. Error code = {err}"),
                };
            } else {
                match unsafe { driver.send_packet_to_mstcp(&packet) } {
                    Ok(_) => {}
                    Err(err) => println!("Error sending packet to mstcp. Error code = {err}"),
                }
            }

            if packets_number == 0 {
                println!("Filtering complete\n");
                break;
            }
        }
    }

    Ok(())
}

/// Print detailed information about a network packet.
///
/// This function takes an `IntermediateBuffer` containing a network packet and prints various
/// details about the packet, such as Ethernet, IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP information.
///
/// # Arguments
///
/// * `packet` - A mutable reference to an `ndisapi::IntermediateBuffer` containing the network packet.
///
/// # Examples
///
/// ```no_run
/// let mut packet: ndisapi::IntermediateBuffer = ...;
/// print_packet_info(&mut packet);
/// ```
fn print_packet_info(packet: &mut ndisapi::IntermediateBuffer) {
    // Attempt to create a SlicedPacket from the Ethernet frame.
    match SlicedPacket::from_ethernet(&packet.buffer.0) {
        // If there's an error, print it.
        Err(value) => println!("Err {value:?}"),

        // If successful, proceed with printing packet information.
        Ok(value) => {
            // Print Ethernet information if available.
            if let Some(Ethernet2(value)) = value.link {
                println!(
                    " Ethernet {} => {}",
                    ndisapi::MacAddress::from_slice(&value.source()[..]).unwrap(),
                    ndisapi::MacAddress::from_slice(&value.destination()[..]).unwrap(),
                );
            }

            // Print IP information if available.
            match value.ip {
                Some(Ipv4(value, extensions)) => {
                    println!(
                        "  Ipv4 {:?} => {:?}",
                        value.source_addr(),
                        value.destination_addr()
                    );
                    if !extensions.is_empty() {
                        println!("    {extensions:?}");
                    }
                }
                Some(Ipv6(value, extensions)) => {
                    println!(
                        "  Ipv6 {:?} => {:?}",
                        value.source_addr(),
                        value.destination_addr()
                    );
                    if !extensions.is_empty() {
                        println!("    {extensions:?}");
                    }
                }
                None => {}
            }

            // Print transport layer information if available.
            match value.transport {
                Some(Icmpv4(value)) => println!(" Icmpv4 {value:?}"),
                Some(Icmpv6(value)) => println!(" Icmpv6 {value:?}"),
                Some(Udp(value)) => println!(
                    "   UDP {:?} -> {:?}",
                    value.source_port(),
                    value.destination_port()
                ),
                Some(Tcp(value)) => {
                    println!(
                        "   TCP {:?} -> {:?}",
                        value.source_port(),
                        value.destination_port()
                    );
                }
                Some(Unknown(ip_protocol)) => {
                    println!("  Unknown Protocol (ip protocol number {ip_protocol:?})")
                }
                None => {}
            }
        }
    }
}

```

`src/driver.rs`:

```rs
//! # Module: DRIVER
//!
//! This module provides a low-level interface used by NDISAPI module for communicating
//! with the Windows Packet Filter driver.
//!
//! The submodules in this module contain various structures, functions, and constants
//! required to communicate with the driver and perform operations such as setting packet filters,
//! reading packets, and sending packets to the adapter or MSTCP stack.
//!
//! # Submodules
//!
//! * [`constants`] - Provides various constants and bitflag structures used to configure the
//! packet filtering mechanism, specify filtering options for different protocols, and define
//! the conditions for filtering at specific layers.
//!
//! * [`base`] - Provides Rust equivalents of several structures used in the NDISAPI Rust library
//! for communicating with the Windows Packet Filter driver. he structures in this submodule are related
//! to network adapters, Ethernet packets, adapter events, and Remote Access Service (RAS) links.
//!
//! * [`ioctl`] - Provides a collection of constants for IOCTL (Input/Output Control) codes and
//! the `ctl_code` function used to generate these codes. IOCTL codes are used to communicate
//! with the Windows Packet Filter driver to perform various operations.
//!
//! * [`filters`] - Provides structures for specifying filter conditions and actions for various protocols,
//! including Ethernet 802.3, IPv4, IPv6, TCP, UDP, and ICMP. These structures allow users to define complex
//! filtering rules based on multiple packet fields and layers.
//!
//! * [`fastio`] - Provides Rust equivalents of several structures related to Fast I/O operations
//! for the NDISAPI Rust library used in communicating with the Windows Packet Filter driver.
//! The structures in this submodule are related to Fast I/O sections, which include headers and packet data,
//! and are involved in read and write operations.
//!

// Submodules
pub mod base;
pub mod constants;
pub mod fastio;
pub mod filters;
pub mod ioctl;

pub use self::base::*;
pub use self::constants::*;
pub use self::fastio::*;
pub use self::filters::*;
pub use self::ioctl::*;

```

`src/driver/base.rs`:

```rs
//! # Submodule: Basic NDISAPI Structures
//!
//! This submodule provides Rust equivalents of several structures used in the NDISAPI Rust library
//! for communicating with the Windows Packet Filter driver.
//!
//! The structures in this submodule are related to network adapters, Ethernet packets, adapter events,
//! and Remote Access Service (RAS) links.
//!
//! For a detailed description of each structure, refer to their respective documentation within the
//! submodule.

// Import required external crates and types
use std::mem::size_of;
use windows::{
    core::Result,
    Win32::Foundation::{ERROR_INVALID_PARAMETER, HANDLE},
};

use super::constants::*;

/// The `TcpAdapterList` structure is the Rust equivalent of the
/// [_TCP_AdapterList](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_tcp_adapterlist/)
/// structure in the Windows Packet Filter documentation. It represents a list of network adapters,
/// along with their properties, such as adapter names, handles, medium types, current addresses, and MTUs.
///
/// # Fields
///
/// * `adapter_count`: A 32-bit unsigned integer representing the total number of adapters in the list.
/// * `adapter_name_list`: An array of arrays, with each inner array containing `ADAPTER_NAME_SIZE` bytes,
///   representing the adapter names in the list.
/// * `adapter_handle`: An array of `HANDLE` values, representing the handles of the adapters in the list.
/// * `adapter_medium_list`: An array of 32-bit unsigned integers, representing the medium types of the
///   adapters in the list.
/// * `current_address`: An array of arrays, with each inner array containing `ETHER_ADDR_LENGTH` bytes,
///   representing the current addresses of the adapters in the list.
/// * `mtu`: An array of 16-bit unsigned integers, representing the Maximum Transmission Units (MTUs) of the
///   adapters in the list.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TcpAdapterList {
    pub adapter_count: u32,
    pub adapter_name_list: [[u8; ADAPTER_NAME_SIZE]; ADAPTER_LIST_SIZE],
    pub adapter_handle: [HANDLE; ADAPTER_LIST_SIZE],
    pub adapter_medium_list: [u32; ADAPTER_LIST_SIZE],
    pub current_address: [[u8; ETHER_ADDR_LENGTH]; ADAPTER_LIST_SIZE],
    pub mtu: [u16; ADAPTER_LIST_SIZE],
}

/// The `ListEntry` structure is the Rust equivalent of the
/// [_LIST_ENTRY](https://learn.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-list_entry)
/// structure in the Windows API. It represents a doubly-linked list entry, containing forward and backward
/// pointers to adjacent list entries.
///
/// # Fields
///
/// * `flink`: A mutable raw pointer to the next `ListEntry` in the list (forward link).
/// * `blink`: A mutable raw pointer to the previous `ListEntry` in the list (backward link).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ListEntry {
    pub flink: *mut ListEntry,
    pub blink: *mut ListEntry,
}

/// The `IntermediateBufferHeaderUnion` structure is the Rust equivalent of the union
/// used for `INTERMEDIATE_BUFFER` in the driver API. It represents a union between a
/// `HANDLE` and a `ListEntry`, providing a way to access either of them based on the context.
///
/// # Fields
///
/// * `adapter_handle`: A `HANDLE` representing the adapter handle.
/// * `list_entry`: A `ListEntry` structure representing a doubly-linked list entry.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union IntermediateBufferHeaderUnion {
    pub adapter_handle: HANDLE,
    pub list_entry: ListEntry,
}

/// Provides a default implementation for the `IntermediateBufferHeaderUnion` structure.
///
/// # Safety
///
/// This implementation is safe because the union contains either a `HANDLE` or a `ListEntry`.
/// The `ListEntry` is a union of raw pointers, which can be safely zeroed as long as they are not dereferenced.
/// The `HANDLE` is a wrapper around an `isize`, which can also be safely zeroed.
impl Default for IntermediateBufferHeaderUnion {
    fn default() -> Self {
        // SAFETY: This union contains either a `HANDLE` or a `ListEntry`
        // ListEntry: is an union of raw pointers which can be safely zeroed(as long as you not dereference it)
        // HANDLE: is just an `isize` wrapper which can also be zeroed
        unsafe { core::mem::zeroed() }
    }
}

/// The `IntermediateBuffer` structure represents an intermediate buffer that stores packet data along with some
/// additional information. This structure is used internally by the packet filter driver.
///
/// Rust equivalent for [_INTERMEDIATE_BUFFER](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_intermediate_buffer/).
///
/// # Fields
/// * `header`: An `IntermediateBufferHeaderUnion` which is a union of `HANDLE` and `ListEntry`.
/// * `device_flags`: A `DirectionFlags` value that indicates the direction of the packet (send or receive).
/// * `length`: A `u32` representing the length of the packet data.
/// * `flags`: A `u32` value containing various flags related to the packet.
/// * `vlan_8021q`: A `u32` value representing the VLAN tag (802.1Q) associated with the packet.
/// * `filter_id`: A `u32` value identifying the filter that processed the packet.
/// * `reserved`: A reserved `[u32; 4usize]` array for future use.
/// * `buffer`: A `Buffer` structure containing the actual packet data.
#[repr(C, packed)]
#[derive(Copy, Clone, Default)]
pub struct IntermediateBuffer {
    pub header: IntermediateBufferHeaderUnion,
    pub device_flags: DirectionFlags,
    pub length: u32,
    pub flags: u32,
    pub vlan_8021q: u32,
    pub filter_id: u32,
    pub reserved: [u32; 4usize],
    pub buffer: Buffer,
}

/// This structure represents the buffer used for storing the actual packet data.
///
/// A wrapper around an array of bytes with a size of `MAX_ETHER_FRAME`.
#[repr(transparent)]
#[derive(Copy, Clone)]
pub struct Buffer(pub [u8; MAX_ETHER_FRAME]);

impl Default for Buffer {
    fn default() -> Self {
        Self([0; MAX_ETHER_FRAME])
    }
}

/// IntermediateBuffer implementation
impl IntermediateBuffer {
    /// Creates a new `IntermediateBuffer` with default values.
    ///
    /// # Returns
    /// A new `IntermediateBuffer` instance.
    pub fn new() -> Self {
        Self::default()
    }

    /// Gets the `DirectionFlags` value associated with the `IntermediateBuffer`.
    ///
    /// # Returns
    /// The `DirectionFlags` value indicating the direction of the packet (send or receive).
    pub fn get_device_flags(&self) -> DirectionFlags {
        self.device_flags
    }

    /// Gets the length of the packet data stored in the `IntermediateBuffer`.
    ///
    /// # Returns
    /// A `u32` value representing the length of the packet data.
    pub fn get_length(&self) -> u32 {
        self.length
    }

    /// Sets the length of the packet data stored in the `IntermediateBuffer`.
    ///
    /// # Arguments
    /// * `length`: A `u32` value representing the new length of the packet data.
    pub fn set_length(&mut self, length: u32) {
        self.length = length
    }
}

/// This structure is used to define the mode of an adapter with a specified handle and filter flags.
///
/// A Rust equivalent for the [_ADAPTER_MODE](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/adapter_mode/) structure.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Default)]
pub struct AdapterMode {
    /// A `HANDLE` representing the adapter handle.
    pub adapter_handle: HANDLE,
    /// `FilterFlags` representing the filter flags associated with the adapter mode.
    pub flags: FilterFlags,
}

/// This structure represents an Ethernet packet with a pointer to an `IntermediateBuffer`.
///
/// A Rust equivalent for the [_NDISRD_ETH_Packet](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ndisrd_eth_packet/) structure.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EthPacket {
    /// A raw pointer to an `IntermediateBuffer` representing the buffer for this Ethernet packet.
    pub buffer: *mut IntermediateBuffer,
}

impl EthPacket {
    /// Returns a mutable reference to the `IntermediateBuffer` pointed to by the `EthPacket`.
    ///
    /// # Safety
    ///
    /// This function is unsafe because `EthPacket.buffer` may not be initialized or may point to
    /// invalid memory.
    pub unsafe fn get_buffer_mut(&mut self) -> &mut IntermediateBuffer {
        &mut *self.buffer
    }

    /// Returns a reference to the `IntermediateBuffer` pointed to by the `EthPacket`.
    ///
    /// # Safety
    ///
    /// This function is unsafe because `EthPacket.buffer` may not be initialized or may point to
    /// invalid memory.
    pub unsafe fn get_buffer(&self) -> &IntermediateBuffer {
        &*self.buffer
    }
}

/// This structure represents a request for an Ethernet packet, containing an adapter handle and an `EthPacket`.
///
/// A Rust equivalent for the [_ETH_REQUEST](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_eth_request/) structure.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EthRequest {
    /// A handle to the network adapter associated with this request.
    pub adapter_handle: HANDLE,
    /// An `EthPacket` representing the Ethernet packet for this request.
    pub packet: EthPacket,
}

/// This structure represents a multiple Ethernet packets request, containing an adapter handle, packet number, packet success, and an array of `EthPacket`.
///
/// A Rust equivalent for the [_ETH_M_REQUEST](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_eth_m_request/) structure.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EthMRequest<const N: usize> {
    /// A handle to the network adapter associated with this request.
    adapter_handle: HANDLE,
    /// The number of packets in the `packets` array.
    packet_number: u32,
    /// The number of successfully processed packets.
    packet_success: u32,
    /// An array of `EthPacket` representing the Ethernet packets for this request.
    packets: [EthPacket; N],
}

impl<const N: usize> EthMRequest<N> {
    /// Creates a new `EthMRequest` with the specified adapter handle.
    pub fn new(adapter_handle: HANDLE) -> Self {
        Self {
            adapter_handle,
            packet_number: 0,
            packet_success: 0,
            packets: [EthPacket {
                buffer: core::ptr::null_mut(),
            }; N],
        }
    }

    /// Returns an `EthPacket` at the specified index if the index is within the valid range.
    pub fn at(&self, index: usize) -> Option<EthPacket> {
        if index < self.packet_number as usize {
            Some(self.packets[index])
        } else {
            None
        }
    }

    /// Returns the number of packets in the `packets` array.
    pub fn get_packet_number(&self) -> u32 {
        self.packet_number
    }

    /// Sets the number of packets in the `packets` array.
    pub fn set_packet_number(&mut self, number: u32) {
        self.packet_number = number;
    }

    /// Resets the packet number to 0.
    pub fn reset(&mut self) {
        self.set_packet_number(0);
    }

    /// Returns the number of successfully processed packets.
    pub fn get_packet_success(&self) -> u32 {
        self.packet_success
    }

    /// Pushes an `EthPacket` to the `packets` array if there's available space, returning an error if the array is full.
    pub fn push(&mut self, packet: EthPacket) -> Result<()> {
        if (self.packet_number as usize) < N {
            self.packets[self.packet_number as usize] = packet;
            self.packet_number += 1;
            Ok(())
        } else {
            Err(ERROR_INVALID_PARAMETER.into())
        }
    }
}

/// This structure represents an adapter event, containing an adapter handle and an event handle.
///
/// A Rust equivalent for the [_ADAPTER_EVENT](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/adapter_event/) structure.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AdapterEvent {
    /// A handle to the network adapter associated with this event.
    pub adapter_handle: HANDLE,
    /// A handle to the event associated with this adapter.
    pub event_handle: HANDLE,
}

/// This structure is used to make queries or set parameters on a network adapter.
///
/// A Rust equivalent for the [_PACKET_OID_DATA](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_packet_oid_data/) structure.
#[repr(C, packed)]
pub struct PacketOidData<T> {
    /// A handle to the network adapter associated with this query or parameter setting.
    pub adapter_handle: HANDLE,
    /// The OID (Object Identifier) that represents the query or parameter to be set.
    pub oid: u32,
    /// The length of the data in bytes.
    pub length: u32,
    /// The data associated with the query or parameter.
    pub data: T,
}

impl<T> PacketOidData<T> {
    /// Creates a new PacketOidData instance.
    ///
    /// # Arguments
    ///
    /// * `adapter_handle` - A handle to the network adapter associated with this query or parameter setting.
    /// * `oid` - The OID (Object Identifier) that represents the query or parameter to be set.
    /// * `data` - The data associated with the query or parameter.
    pub fn new(adapter_handle: HANDLE, oid: u32, data: T) -> Self {
        Self {
            adapter_handle,
            oid,
            length: size_of::<T>() as u32,
            data,
        }
    }
}

/// This structure contains information about a RAS (Remote Access Service) link.
///
/// A Rust equivalent for the [_RAS_LINK_INFO](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ras_link_info/) structure.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RasLinkInformation {
    /// The link speed in bits per second.
    link_speed: u32,
    /// The maximum total size, in bytes.
    maximum_total_size: u32,
    /// The remote MAC address.
    remote_address: [u8; ETHER_ADDR_LENGTH],
    /// The local MAC address.
    local_address: [u8; ETHER_ADDR_LENGTH],
    /// The length of the protocol buffer, in bytes.
    protocol_buffer_length: u32,
    /// The buffer containing information about the RAS-managed protocols.
    protocol_buffer: [u8; RAS_LINK_BUFFER_LENGTH],
}

impl RasLinkInformation {
    /// Returns the link speed in bits per second.
    pub fn get_link_speed(&self) -> u32 {
        self.link_speed
    }

    /// Returns the maximum total size.
    pub fn get_maximum_total_size(&self) -> u32 {
        self.maximum_total_size
    }

    /// Returns the remote MAC address.
    pub fn get_remote_address(&self) -> &[u8; ETHER_ADDR_LENGTH] {
        &self.remote_address
    }

    /// Returns the local MAC address.
    pub fn get_local_address(&self) -> &[u8; ETHER_ADDR_LENGTH] {
        &self.local_address
    }

    /// Returns the length of the protocol buffer, in bytes.
    pub fn get_protocol_buffer_length(&self) -> usize {
        self.protocol_buffer_length as usize
    }

    /// Returns the buffer containing information about the RAS-managed protocols.
    pub fn get_protocol_buffer(&self) -> &[u8; RAS_LINK_BUFFER_LENGTH] {
        &self.protocol_buffer
    }
}

/// This structure is a container for RAS (Remote Access Service) link information structures.
///
/// A Rust equivalent for the [_RAS_LINKS](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ras_links/) structure.
/// Note that this struct may be too large to be allocated on the stack in Rust and may result in a stack overflow.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RasLinks {
    /// The number of RAS links in the array.
    number_of_links: u32,
    /// The array of RAS link information structures.
    pub ras_links: [RasLinkInformation; RAS_LINKS_MAX],
}

impl Default for RasLinks {
    /// Returns a zero-initialized instance of `RasLinks`.
    ///
    /// # Safety
    ///
    /// This structure is filled by the information by NDIS filter driver when passed as a memory buffer
    /// along with IOCTL_NDISRD_GET_RAS_LINKS. It is safe to be zeroed because contains only values and arrays that
    /// can be default initialized with zeroes.
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

impl RasLinks {
    /// Returns the number of RAS links in the array.
    pub fn get_number_of_links(&self) -> usize {
        self.number_of_links as usize
    }
}

```

`src/driver/constants.rs`:

```rs
//! # Submodule: Basic NDISAPI Constants and flags
//!
//! This submodule contains various constants and bitflag structures for the NDISAPI Rust library.
//!
//! The NDISAPI library provides a Rust interface for interacting with the Windows Packet Filter
//! driver. This module contains various constants and bitflag structures used to configure the
//! packet filtering mechanism, specify filtering options for different protocols, and define
//! the conditions for filtering at specific layers.

// Import required external crates and types
use bitflags::bitflags;

/// ADAPTER_NAME_SIZE is the maximum length for the adapter name.
pub const ADAPTER_NAME_SIZE: usize = 256;

/// ADAPTER_LIST_SIZE is the maximum number of adapters in the adapter list.
pub const ADAPTER_LIST_SIZE: usize = 32;

/// ETHER_ADDR_LENGTH is the length of an Ethernet address in bytes.
pub const ETHER_ADDR_LENGTH: usize = 6;

/// MAX_ETHER_FRAME is the maximum size of an Ethernet frame in bytes. If the driver was built with
/// the JUMBO_FRAME_SUPPORTED option, this value would be 9014 bytes instead.
pub const MAX_ETHER_FRAME: usize = 1514;

/// RAS_LINK_BUFFER_LENGTH is the length of the RAS link buffer in bytes.
pub const RAS_LINK_BUFFER_LENGTH: usize = 2048;

/// RAS_LINKS_MAX is the maximum number of RAS links.
pub const RAS_LINKS_MAX: usize = 256;

/// Constant representing the IPv4 subnet type.
pub const IP_SUBNET_V4_TYPE: u32 = 1;
/// Constant representing the IPv4 address range type.
pub const IP_RANGE_V4_TYPE: u32 = 2;

/// Constant representing the IPv6 subnet type.
pub const IP_SUBNET_V6_TYPE: u32 = 1;
/// Constant representing the IPv6 address range type.
pub const IP_RANGE_V6_TYPE: u32 = 2;

/// ETH_802_3 is a constant representing the 802.3 Ethernet standard.
pub const ETH_802_3: u32 = 1;

/// Constant representing the IPv4 network protocols.
pub const IPV4: u32 = 1;
/// Constant representing the IPv6 network protocols.
pub const IPV6: u32 = 2;

/// Constant representing the TCP or UDP protocols.
pub const TCPUDP: u32 = 1;
/// Constant representing the ICMP protocol.
pub const ICMP: u32 = 2;

/// Allows a packet to pass through the filter without any modification.
pub const FILTER_PACKET_PASS: u32 = 1;
/// Drops the packet and prevents it from reaching the destination.
pub const FILTER_PACKET_DROP: u32 = 2;
/// Redirects the packet for processing in user-mode.
pub const FILTER_PACKET_REDIRECT: u32 = 3;
/// Allows the packet to pass through the filter and redirects a copy of it for processing by user-mode application.
pub const FILTER_PACKET_PASS_RDR: u32 = 4;
/// Drops the packet and and redirects a copy of it for processing by user-mode application.
pub const FILTER_PACKET_DROP_RDR: u32 = 5;

// Define bitflag structures for filter flags, direction flags, and various protocol-specific filter flags
bitflags! {
    /// FilterFlags represent various flags used for packet filtering.
    ///
    /// These flags are used to configure the behavior of the packet filtering mechanism in different scenarios.
    #[derive(Default, Clone, Copy, Debug, PartialEq)]
    pub struct FilterFlags: u32 {
        /// MSTCP_FLAG_SENT_TUNNEL: Queue all packets sent from TCP/IP to network interface. Original packet is dropped.
        const MSTCP_FLAG_SENT_TUNNEL = 1;

        /// MSTCP_FLAG_RECV_TUNNEL: Queue all packets indicated by network interface to TCP/IP. Original packet is dropped.
        const MSTCP_FLAG_RECV_TUNNEL = 2;

        /// MSTCP_FLAG_SENT_LISTEN: Queue all packets sent from TCP/IP to network interface. Original packet goes ahead.
        const MSTCP_FLAG_SENT_LISTEN = 4;

        /// MSTCP_FLAG_RECV_LISTEN: Queue all packets indicated by network interface to TCP/IP. Original packet goes ahead.
        const MSTCP_FLAG_RECV_LISTEN = 8;

        /// MSTCP_FLAG_FILTER_DIRECT: In promiscuous mode, the TCP/IP stack receives all packets in the Ethernet segment
        /// and replies with various ICMP packets. To prevent this, set this flag. All packets with destination MAC different
        /// from FF-FF-FF-FF-FF-FF and network interface current MAC will never reach TCP/IP.
        const MSTCP_FLAG_FILTER_DIRECT = 16;

        /// MSTCP_FLAG_LOOPBACK_FILTER: If not set, loopback packets are silently passed over. Otherwise, these packets are
        /// passed for further processing (queued for redirecting to the application if not dropped by the MSTCP_FLAG_LOOPBACK_BLOCK below).
        const MSTCP_FLAG_LOOPBACK_FILTER = 32;

        /// MSTCP_FLAG_LOOPBACK_BLOCK: If set, loopback packets (with exception to broadcast/multicast) are silently dropped.
        const MSTCP_FLAG_LOOPBACK_BLOCK = 64;

        /// MSTCP_FLAG_SENT_RECEIVE_TUNNEL: Combination of MSTCP_FLAG_SENT_TUNNEL and MSTCP_FLAG_RECV_TUNNEL.
        const MSTCP_FLAG_SENT_RECEIVE_TUNNEL = Self::MSTCP_FLAG_SENT_TUNNEL.bits() | Self::MSTCP_FLAG_RECV_TUNNEL.bits();

        /// MSTCP_FLAG_SENT_RECEIVE_LISTEN: Combination of MSTCP_FLAG_SENT_LISTEN and MSTCP_FLAG_RECV_LISTEN.
        const MSTCP_FLAG_SENT_RECEIVE_LISTEN = Self::MSTCP_FLAG_SENT_LISTEN.bits() | Self::MSTCP_FLAG_RECV_LISTEN.bits();
    }
}

bitflags! {
    /// DirectionFlags represent various direction flags for packet processing.
    ///
    /// These flags are used to specify the direction of packets that the filter should act upon and
    /// to specify the packet direction in IntermediateBuffer.
    #[derive(Default, Clone, Copy, Debug, PartialEq)]
    pub struct DirectionFlags: u32 {
        /// PACKET_FLAG_ON_SEND: Indicates an outgoing packet. In the context of filters, the filter should act on packets being sent from the system.
        const PACKET_FLAG_ON_SEND = 1;

        /// PACKET_FLAG_ON_RECEIVE: Indicates an incoming packet. In the context of filters, the filter should act on packets being received by the system.
        const PACKET_FLAG_ON_RECEIVE = 2;

        /// PACKET_FLAG_ON_SEND_RECEIVE: Filter should act on both sent and received packets.
        const PACKET_FLAG_ON_SEND_RECEIVE = Self::PACKET_FLAG_ON_SEND.bits() | Self::PACKET_FLAG_ON_RECEIVE.bits();
    }
}

bitflags! {
    /// Eth802_3FilterFlags represent various filtering options for Ethernet 802.3 frames.
    ///
    /// These flags are used to specify which fields of an Ethernet 802.3 frame the filter should
    /// consider when determining whether to process the packet.
    #[derive(Default, Clone, Copy, Debug, PartialEq)]
    pub struct Eth802_3FilterFlags: u32 {
        /// ETH_802_3_SRC_ADDRESS: Filter based on the source MAC address of the Ethernet 802.3 frame.
        const ETH_802_3_SRC_ADDRESS = 1;

        /// ETH_802_3_DEST_ADDRESS: Filter based on the destination MAC address of the Ethernet 802.3 frame.
        const ETH_802_3_DEST_ADDRESS = 2;

        /// ETH_802_3_PROTOCOL: Filter based on the protocol field (EtherType) of the Ethernet 802.3 frame.
        const ETH_802_3_PROTOCOL = 4;
    }
}

bitflags! {
    /// IpV4FilterFlags represent various filtering options for IPv4 packets.
    ///
    /// These flags are used to specify which fields of an IPv4 packet the filter should
    /// consider when determining whether to process the packet.
    #[derive(Default, Clone, Copy, Debug, PartialEq)]
    pub struct IpV4FilterFlags: u32 {
        /// IP_V4_FILTER_SRC_ADDRESS: Filter based on the source IP address of the IPv4 packet.
        const IP_V4_FILTER_SRC_ADDRESS = 1;

        /// IP_V4_FILTER_DEST_ADDRESS: Filter based on the destination IP address of the IPv4 packet.
        const IP_V4_FILTER_DEST_ADDRESS = 2;

        /// IP_V4_FILTER_PROTOCOL: Filter based on the protocol field of the IPv4 packet (e.g., TCP, UDP, ICMP).
        const IP_V4_FILTER_PROTOCOL = 4;
    }
}

bitflags! {
    /// IpV6FilterFlags represent various filtering options for IPv6 packets.
    ///
    /// These flags are used to specify which fields of an IPv6 packet the filter should
    /// consider when determining whether to process the packet.
    #[derive(Default, Clone, Copy, Debug, PartialEq)]
    pub struct IpV6FilterFlags: u32 {
        /// IP_V6_FILTER_SRC_ADDRESS: Filter based on the source IP address of the IPv6 packet.
        const IP_V6_FILTER_SRC_ADDRESS = 1;

        /// IP_V6_FILTER_DEST_ADDRESS: Filter based on the destination IP address of the IPv6 packet.
        const IP_V6_FILTER_DEST_ADDRESS = 2;

        /// IP_V6_FILTER_PROTOCOL: Filter based on the protocol field of the IPv6 packet (e.g., TCP, UDP, ICMPv6).
        const IP_V6_FILTER_PROTOCOL = 4;
    }
}

bitflags! {
    /// TcpUdpFilterFlags represent various filtering options for TCP and UDP packets.
    ///
    /// These flags are used to specify which fields of a TCP or UDP packet the filter should
    /// consider when determining whether to process the packet.
    #[derive(Default, Clone, Copy, Debug, PartialEq)]
    pub struct TcpUdpFilterFlags: u32 {
        /// TCPUDP_SRC_PORT: Filter based on the source port of the TCP or UDP packet.
        const TCPUDP_SRC_PORT = 1;

        /// TCPUDP_DEST_PORT: Filter based on the destination port of the TCP or UDP packet.
        const TCPUDP_DEST_PORT = 2;

        /// TCPUDP_TCP_FLAGS: Filter based on the TCP flags of a TCP packet. This flag is ignored for UDP packets.
        const TCPUDP_TCP_FLAGS = 4;
    }
}

bitflags! {
    /// IcmpFilterFlags represent various filtering options for ICMP packets.
    ///
    /// These flags are used to specify which fields of an ICMP packet the filter should
    /// consider when determining whether to process the packet.
    #[derive(Default, Clone, Copy, Debug, PartialEq)]
    pub struct IcmpFilterFlags: u32 {
        /// ICMP_TYPE: Filter based on the ICMP type of the ICMP packet.
        const ICMP_TYPE = 1;

        /// ICMP_CODE: Filter based on the ICMP code of the ICMP packet.
        const ICMP_CODE = 2;
    }
}

bitflags! {
    /// FilterLayerFlags represent the validation flags for various filter layers.
    ///
    /// These flags are used to specify which layers of a packet the filter should consider
    /// when determining whether to process the packet. They are typically used in conjunction
    /// with other filter flags to define the conditions for filtering at specific layers.
    #[derive(Default, Clone, Copy, Debug, PartialEq)]
    pub struct FilterLayerFlags: u32 {
        /// DATA_LINK_LAYER_VALID: Indicates that the Data Link Layer filter fields are valid and should be considered in the filtering process.
        const DATA_LINK_LAYER_VALID = 1;

        /// NETWORK_LAYER_VALID: Indicates that the Network Layer filter fields are valid and should be considered in the filtering process.
        const NETWORK_LAYER_VALID = 2;

        /// TRANSPORT_LAYER_VALID: Indicates that the Transport Layer filter fields are valid and should be considered in the filtering process.
        const TRANSPORT_LAYER_VALID = 4;
    }
}

```

`src/driver/fastio.rs`:

```rs
//! # Submodule: Fast I/O Structures
//!
//! This submodule provides Rust equivalents of several structures related to Fast I/O operations
//! for the NDISAPI Rust library used in communicating with the Windows Packet Filter driver.
//!
//! The structures in this submodule are related to Fast I/O sections, which include headers and packet data,
//! and are involved in read and write operations.
//!
//! For a detailed description of each structure, refer to their respective documentation within the
//! submodule.

use super::base::*;

/// This structure contains the fields that make up the FastIoWriteUnion when accessed separately.
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct FastIoWriteUnionStruct {
    /// The number of packets
    pub number_of_packets: u16,
    /// Flag indicating whether a write operation is in progress
    pub write_in_progress_flag: u16,
}

/// This union represents a combined 32-bit field containing both the number of packets and a flag
/// indicating whether a write operation is in progress. It provides the option to access the fields individually
/// through the `split` field or the combined 32-bit value through the `join` field.
///
/// Rust equivalent for _FAST_IO_WRITE_UNION
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FastIoWriteUnion {
    /// Separate access to the number of packets and write in progress flag
    pub split: FastIoWriteUnionStruct,
    /// Combined 32-bit representation of the number of packets and write in progress flag
    pub join: u32,
}

impl Default for FastIoWriteUnion {
    /// Initializes a new `FastIoWriteUnion` with default values for both the `join` field and the fields in the `split` structure.
    fn default() -> Self {
        FastIoWriteUnion { join: 0 }
    }
}

/// This structure is used as the header for the FastIoSection structure, containing the FastIoWriteUnion
/// and a flag indicating whether a read operation is in progress.
///
/// Rust equivalent for _FAST_IO_SECTION_HEADER
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct FastIoSectionHeader {
    /// Union containing the number of packets and write in progress flag
    pub fast_io_write_union: FastIoWriteUnion,
    /// Flag indicating whether a read operation is in progress
    pub read_in_progress_flag: u32,
}

/// This structure represents a Fast I/O section, which includes a FastIoSectionHeader and an array of IntermediateBuffer
/// structures. It is used to store information about packet data and the state of read and write operations.
///
/// Rust equivalent for _FAST_IO_SECTION
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FastIoSection<const N: usize> {
    /// Header containing the FastIoWriteUnion and read in progress flag
    pub fast_io_header: FastIoSectionHeader,
    /// Array of IntermediateBuffer structures for packet data
    pub fast_io_packets: [IntermediateBuffer; N],
}

impl<const N: usize> Default for FastIoSection<N> {
    // Initializes a new `FastIoSection<N>` with default values for its fields.
    // SAFETY: This structure is filled by information by NDIS filter driver.
    // Zero-initialized FastIoSection<N> is completely valid and ignored by the code.
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// A Rust struct that represents the parameters for fast I/O initialization.
///
/// Rust equivalent for _INITIALIZE_FAST_IO_PARAMS.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct InitializeFastIoParams<const N: usize> {
    /// header_ptr: A mutable pointer to a FastIoSection of size N.
    pub header_ptr: *mut FastIoSection<N>,
    /// data_size: A u32 representing the data size of the Fast I/O section.
    pub data_size: u32,
}

/// A Rust struct that represents an unsorted read/send request.
///
/// Rust equivalent for _UNSORTED_READ_SEND_REQUEST.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UnsortedReadSendRequest<const N: usize> {
    /// packets: A mutable pointer to an array of IntermediateBuffer of size N.
    pub packets: *mut [IntermediateBuffer; N],
    /// packets_num: A u32 representing the number of packets in the request.
    pub packets_num: u32,
}

```

`src/driver/filters.rs`:

```rs
//! # Submodule: Basic NDISAPI static filter definitions
//!
//! This submodule contains various structures used for static filters in the NDISAPI Rust library.
//!
//! The `filters` submodule provides a Rust interface for configuring static filters for the Windows Packet
//! Filter driver. It contains structures for specifying filter conditions and actions for various protocols,
//! including Ethernet 802.3, IPv4, IPv6, TCP, UDP, and ICMP. These structures allow users to define complex
//! filtering rules based on multiple packet fields and layers.
//!
//! # Structures
//!
//! * [`Eth8023Filter`] - Represents a static filter for Ethernet 802.3 frames.
//! * [`IpV4Filter`] - Represents a static filter for IPv4 packets.
//! * [`IpV6Filter`] - Represents a static filter for IPv6 packets.
//! * [`TcpUdpFilter`] - Represents a static filter for TCP and UDP packets.
//! * [`IcmpFilter`] - Represents a static filter for ICMP packets.
//! * [`StaticFilter`] - Represents a single static filter entry that combines filter conditions for various
//! layers and the filter action to be taken.
//! * [`StaticFilterTable`] - Represents a table of static filters, used for managing multiple static filter entries.

// Import required external crates and types
use windows::{Win32::Networking::WinSock::IN6_ADDR, Win32::Networking::WinSock::IN_ADDR};

use super::constants::*;

/// This structure is used to define an Ethernet 802.3 filter based on various fields like source and destination addresses, and protocol.
///
/// A Rust equivalent for the [_ETH_802_3_FILTER](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_eth_802_3_filter/) structure.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct Eth8023Filter {
    /// A bitmask indicating which fields in the filter are valid.
    pub valid_fields: Eth802_3FilterFlags,
    /// The source address to filter on.
    pub src_address: [u8; ETHER_ADDR_LENGTH],
    /// The destination address to filter on.
    pub dest_address: [u8; ETHER_ADDR_LENGTH],
    /// The protocol (Ethertype) to filter on.
    pub protocol: u16,
    /// Padding to align the structure.
    pub padding: u16,
}

impl Default for Eth8023Filter {
    /// Returns a zero-initialized instance of `Eth8023Filter`.
    ///
    /// # Safety
    ///
    /// It is safe to zero-initialize this structure because it contains only values and arrays that
    /// can be default initialized with zeroes.
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// This structure is used to represent an IPv4 subnet based on an IP address and a subnet mask.
///
/// A Rust equivalent for the [_IP_SUBNET_V4](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ip_subnet_v4/) structure.
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct IpSubnetV4 {
    /// The IPv4 address.
    pub ip: IN_ADDR,
    /// The subnet mask.
    pub ip_mask: IN_ADDR,
}

/// This structure is used to represent an IPv4 address range based on a start and end IP address.
///
/// A Rust equivalent for the [_IP_RANGE_V4](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ip_range_v4/) structure.
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct IpRangeV4 {
    /// The start of the IPv4 address range.
    pub start_ip: IN_ADDR,
    /// The end of the IPv4 address range.
    pub end_ip: IN_ADDR,
}

/// A Rust union representing either an IPv4 subnet (IpSubnetV4) or an IPv4 address range (IpRangeV4).
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union IpAddressV4Union {
    /// The IPv4 subnet representation.
    pub ip_subnet: IpSubnetV4,
    /// The IPv4 address range representation.
    pub ip_range: IpRangeV4,
}

impl Default for IpAddressV4Union {
    fn default() -> Self {
        // SAFETY: This union contains either a `IpSubnetV4` or a `IpRangeV4`
        // IpSubnetV4: when zeroed is equivalent to 0.0.0.0/0
        // IpRangeV4: when zeroed is equivalent to 0.0.0.0 - 0.0.0.0
        unsafe { std::mem::zeroed() }
    }
}

/// Represents an IPv4 address in a format used by the packet filtering mechanism.
///
/// A Rust equivalent for [_IP_ADDRESS_V4](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ip_address_v4/).
///
/// The `address_type` field indicates whether the address is a subnet or a range.
/// The `address` field contains the actual IPv4 address information in a union format.
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct IpAddressV4 {
    pub address_type: u32, // IP_SUBNET_V4_TYPE or IP_RANGE_V4_TYPE
    pub address: IpAddressV4Union,
}

/// Represents an IPv4 filter used by the packet filtering mechanism.
///
/// A Rust equivalent for [_IP_V4_FILTER](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ip_v4_filter/).
///
/// The `valid_fields` field specifies which fields in the filter structure are used for filtering.
/// The `src_address` field contains the source IPv4 address information.
/// The `dest_address` field contains the destination IPv4 address information.
/// The `protocol` field represents the IP protocol number.
/// The `padding` field is used for alignment purposes.
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct IpV4Filter {
    pub valid_fields: IpV4FilterFlags,
    pub src_address: IpAddressV4,
    pub dest_address: IpAddressV4,
    pub protocol: u8,
    pub padding: [u8; 3usize],
}

/// Represents an IPv6 subnet used by the packet filtering mechanism.
///
/// A Rust equivalent for [_IP_SUBNET_V6](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ip_subnet_v6/).
///
/// The `ip` field contains the IPv6 address.
/// The `ip_mask` field contains the subnet mask.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct IpSubnetV6 {
    pub ip: IN6_ADDR,
    pub ip_mask: IN6_ADDR,
}

/// Represents an IPv6 address range used by the packet filtering mechanism.
///
/// A Rust equivalent for [_IP_RANGE_V6](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ip_range_v6/).
///
/// The `start_ip` field contains the starting IPv6 address of the range.
/// The `end_ip` field contains the ending IPv6 address of the range.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct IpRangeV6 {
    pub start_ip: IN6_ADDR,
    pub end_ip: IN6_ADDR,
}

/// This structure is used to store information about a particular address space
/// for packet filtering purposes.
///
/// A Rust union that represents either an IPv6 subnet or an IPv6 address range.
///
/// The `ip_subnet` field contains the IPv6 subnet if the address space is a subnet.
/// The `ip_range` field contains the IPv6 address range if the address space is a range.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union IpAddressV6Union {
    pub ip_subnet: IpSubnetV6,
    pub ip_range: IpRangeV6,
}

impl Default for IpAddressV6Union {
    fn default() -> Self {
        // SAFETY: This union contains either a `IpSubnetV6` or a `IpRangeV6`
        // IpSubnetV6: when zeroed is equivalent to ::/0
        // IpRangeV6: when zeroed is equivalent to :: - ::
        unsafe { std::mem::zeroed() }
    }
}

/// This structure is used to store information about an IPv6 address for packet filtering purposes.
///
/// Rust equivalent for [_IP_ADDRESS_V6](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ip_address_v6/).
///
/// The `address_type` field indicates whether the address is a subnet (IP_SUBNET_V6_TYPE) or a range (IP_RANGE_V6_TYPE).
/// The `address` field contains the specific IPv6 address data, either a subnet or an address range, depending on the `address_type`.
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct IpAddressV6 {
    pub address_type: u32, // IP_SUBNET_V6_TYPE or IP_RANGE_V6_TYPE
    pub address: IpAddressV6Union,
}

/// This structure is used to define packet filtering rules for IPv6 packets.
///
/// Rust equivalent for [_IP_V6_FILTER](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_ip_v6_filter/).
///
/// The `valid_fields` field contains flags that specify which fields of the filter are active.
/// The `src_address` and `dest_address` fields store information about the source and destination IPv6 addresses respectively.
/// The `protocol` field represents the protocol used in the packet (e.g., TCP, UDP).
/// The `padding` field is reserved for padding to ensure the correct alignment of the structure.
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct IpV6Filter {
    pub valid_fields: IpV6FilterFlags,
    pub src_address: IpAddressV6,
    pub dest_address: IpAddressV6,
    pub protocol: u8,
    pub padding: [u8; 3usize],
}

/// This structure is used to define a range of port numbers for packet filtering rules.
///
/// Rust equivalent for [_PORT_RANGE](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_port_range/).
///
/// The `start_range` field represents the starting port number in the range.
/// The `end_range` field represents the ending port number in the range.
#[repr(C, packed)]
#[derive(Default, Debug, Copy, Clone)]
pub struct PortRange {
    pub start_range: u16,
    pub end_range: u16,
}

/// This structure is used to define filtering rules for TCP and UDP packets.
///
/// Rust equivalent for [_TCPUDP_FILTER](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_tcpudp_filter/).
///
/// The `valid_fields` field specifies which fields in the structure are valid for filtering.
/// The `source_port` field represents the range of source port numbers to filter.
/// The `dest_port` field represents the range of destination port numbers to filter.
/// The `tcp_flags` field is used to filter TCP packets based on their flags.
/// The `padding` field ensures proper alignment of the structure.
#[repr(C, packed)]
#[derive(Default, Debug, Copy, Clone)]
pub struct TcpUdpFilter {
    pub valid_fields: TcpUdpFilterFlags,
    pub source_port: PortRange,
    pub dest_port: PortRange,
    pub tcp_flags: u8,
    pub padding: [u8; 3usize],
}

/// A Rust struct that represents a range of byte values.
///
/// Rust equivalent for _BYTE_RANGE. This structure can be used to define
/// filtering rules based on byte ranges, such as ICMP type or code ranges.
///
/// The `start_range` field represents the start of the byte range.
/// The `end_range` field represents the end of the byte range.
#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct ByteRange {
    pub start_range: u8,
    pub end_range: u8,
}

/// A Rust struct that represents an ICMP filter.
///
/// Rust equivalent for _ICMP_FILTER. This structure can be used to define
/// filtering rules for ICMP packets based on ICMP type and code ranges.
///
/// The `valid_fields` field specifies which fields in the filter are valid for filtering.
/// The `type_range` field represents a range of ICMP types for filtering.
/// The `code_range` field represents a range of ICMP codes for filtering.
#[repr(C, packed)]
#[derive(Default, Debug, Copy, Clone)]
pub struct IcmpFilter {
    pub valid_fields: IcmpFilterFlags,
    pub type_range: ByteRange,
    pub code_range: ByteRange,
}

/// A Rust union that holds an `Eth8023Filter`.
///
/// This union can be extended to include other data link layer filters if needed.
/// Currently, it only contains an `Eth8023Filter` for filtering Ethernet/802.3 packets.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union DataLinkLayerFilterUnion {
    pub eth_8023_filter: Eth8023Filter,
}

impl Default for DataLinkLayerFilterUnion {
    fn default() -> Self {
        // SAFETY: This union contains an `Eth8023Filter`
        // Eth8023Filter: when zeroed is meaningless and ignored by code
        unsafe { std::mem::zeroed() }
    }
}

/// A Rust struct that represents a data link layer filter.
///
/// Rust equivalent for [_DATA_LINK_LAYER_FILTER](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/data_link_layer_filter/)
/// This struct can be used to filter packets at the data link layer (e.g., Ethernet/802.3) by specifying the filter type in `union_selector`.
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct DataLinkLayerFilter {
    pub union_selector: u32, // ETH_802_3 for Eth8023Filter
    pub data_link_layer: DataLinkLayerFilterUnion,
}

/// A Rust union that holds either an `IpV4Filter` or an `IpV6Filter`.
///
/// This union can be used to filter packets at the network layer by specifying the appropriate filter type (IPv4 or IPv6).
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union NetworkLayerFilterUnion {
    pub ipv4: IpV4Filter,
    pub ipv6: IpV6Filter,
}

impl Default for NetworkLayerFilterUnion {
    fn default() -> Self {
        // SAFETY: This union contains either a `IpV4Filter` or `IpV6Filter'
        // IpV4Filter: when zeroed is meaningless and ignored by code
        // IpV6Filter: when zeroed is meaningless and ignored by code
        unsafe { std::mem::zeroed() }
    }
}

/// A Rust struct that represents a network layer filter.
///
/// Rust equivalent for [_NETWORK_LAYER_FILTER](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_network_layer_filter/).
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct NetworkLayerFilter {
    /// union_selector: A field that determines the type of the network layer filter.
    /// Set to IPV4 for IpV4Filter, and IPV6 for IpV6Filter.
    pub union_selector: u32,
    /// network_layer: A union that holds either an IpV4Filter or an IpV6Filter,
    /// depending on the value of the union_selector field.
    pub network_layer: NetworkLayerFilterUnion,
}

/// A Rust union that represents a transport layer filter.
///
/// Holds either a `TcpUdpFilter` or an `IcmpFilter`.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union TransportLayerFilterUnion {
    /// tcp_udp: A TcpUdpFilter struct that represents a TCP/UDP filter.
    pub tcp_udp: TcpUdpFilter,
    /// icmp: An IcmpFilter struct that represents an ICMP filter.
    pub icmp: IcmpFilter,
}

impl Default for TransportLayerFilterUnion {
    fn default() -> Self {
        // SAFETY: This union contains either a `TcpUdpFilter` or an `IcmpFilter`
        // TcpUdpFilter: when zeroed is meaningless and ignored by code
        // IcmpFilter: when zeroed is meaningless and ignored by code
        unsafe { std::mem::zeroed() }
    }
}

/// A Rust struct that represents a transport layer filter.
///
/// Rust equivalent for [_TRANSPORT_LAYER_FILTER](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_transport_layer_filter/)
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct TransportLayerFilter {
    /// union_selector: A u32 flag that selects the appropriate filter.
    /// Use TCPUDP for TcpUdpFilter and ICMP for IcmpFilter.
    pub union_selector: u32,
    /// transport_layer: A TransportLayerFilterUnion that holds either a `TcpUdpFilter` or an `IcmpFilter`.
    pub transport_layer: TransportLayerFilterUnion,
}

/// This structure is used to define a single static filter rule for packet filtering. Each rule can specify filtering criteria at
/// the data link, network, and transport layers. The structure also includes counters for incoming and outgoing packets and bytes
/// that match the filter rule.
///
/// * Rust equivalent for [_STATIC_FILTER](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_static_filter/)
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct StaticFilter {
    /// Adapter handle extended to 64 bit size for structure compatibility across x64 and x86 architectures
    pub adapter_handle: u64,
    /// PACKET_FLAG_ON_SEND or/and PACKET_FLAG_ON_RECEIVE to specify the direction of packets to match
    pub direction_flags: DirectionFlags,
    /// FILTER_PACKET_XXX to define the action to take when a packet matches the filter
    pub filter_action: u32,
    /// Specifies which of the fields below contain valid values and should be matched against the packet
    pub valid_fields: FilterLayerFlags,
    /// Time of the last counters reset (in seconds passed since 1 Jan 1980)
    pub last_reset: u32,
    /// Incoming packets passed through this filter
    pub packets_in: u64,
    /// Incoming bytes passed through this filter
    pub bytes_in: u64,
    /// Outgoing packets passed through this filter
    pub packets_out: u64,
    /// Outgoing bytes passed through this filter
    pub bytes_out: u64,
    /// Filter criteria for the data link layer (e.g., Ethernet)
    pub data_link_filter: DataLinkLayerFilter,
    /// Filter criteria for the network layer (e.g., IPv4, IPv6)
    pub network_filter: NetworkLayerFilter,
    /// Filter criteria for the transport layer (e.g., TCP, UDP, ICMP)
    pub transport_filter: TransportLayerFilter,
}

/// This structure represents an array of static filter rules, each of which is defined by a `StaticFilter` structure.
/// It is used to manage multiple filter rules for packet filtering in a table format.
///
/// * Rust equivalent to the [_STATIC_FILTER_TABLE](https://www.ntkernel.com/docs/windows-packet-filter-documentation/structures/_static_filter_table/)
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct StaticFilterTable<const N: usize> {
    /// The number of elements in the static_filters array
    pub table_size: u32,
    /// Padding to ensure correct memory alignment
    pub padding: u32,
    /// Array of static filter rules
    pub static_filters: [StaticFilter; N],
}

impl<const N: usize> StaticFilterTable<N> {
    /// Creates a new `StaticFilterTable` with the specified number of elements.
    pub fn new() -> Self {
        Self {
            table_size: N as u32,
            padding: 0u32,
            static_filters: [StaticFilter::default(); N],
        }
    }
}

impl<const N: usize> Default for StaticFilterTable<N> {
    /// Initializes a new `StaticFilterTable` with the specified number of elements and default values for each element.
    fn default() -> Self {
        Self::new()
    }
}

```

`src/driver/ioctl.rs`:

```rs
//! # Submodule: Basic NDISAPI driver I/O control codes
//!
//! This submodule provides a collection of constants for IOCTL (Input/Output Control) codes
//! and the `ctl_code` function used to generate these codes.
//!
//! IOCTL codes are used by the Windows Packet Filter driver to communicate with the driver
//! and perform various operations such as setting packet filters, reading packets, and sending
//! packets to the adapter or MSTCP stack.
//!
//! The `ctl_code` function is used to create the IOCTL codes by taking the device type, function,
//! method, and access as input parameters.

// Device and ioctl codes
/// FILE_DEVICE_NDISRD: A constant u32 value representing the NDISRD device type.
const FILE_DEVICE_NDISRD: u32 = 0x00008300;

/// NDISRD_IOCTL_INDEX: A constant u32 value representing the NDISRD IOCTL index.
const NDISRD_IOCTL_INDEX: u32 = 0x830;

/// METHOD_BUFFERED: A constant u32 value representing the buffered method.
const METHOD_BUFFERED: u32 = 0;

/// FILE_ANY_ACCESS: A constant u32 value representing any file access.
const FILE_ANY_ACCESS: u32 = 0;

/// ctl_code function creates an IOCTL control code from the specified device type, function, method, and access values.
///
/// # Arguments
/// * `device_type`: A u32 representing the device type.
/// * `function`: A u32 representing the function.
/// * `method`: A u32 representing the method.
/// * `access`: A u32 representing the access type.
///
/// # Returns
/// * A u32 value representing the resulting IOCTL control code.
const fn ctl_code(device_type: u32, function: u32, method: u32, access: u32) -> u32 {
    (device_type << 16) | (access << 14) | (function << 2) | method
}

/// IOCTL_NDISRD_GET_VERSION: A constant u32 value representing the IOCTL code to get the NDISRD version.
pub const IOCTL_NDISRD_GET_VERSION: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_GET_TCPIP_INTERFACES: A constant u32 value representing the IOCTL code to get the TCPIP interfaces.
pub const IOCTL_NDISRD_GET_TCPIP_INTERFACES: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 1,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SEND_PACKET_TO_ADAPTER: A constant u32 value representing the IOCTL code to send a packet to the adapter.
pub const IOCTL_NDISRD_SEND_PACKET_TO_ADAPTER: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 2,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SEND_PACKET_TO_MSTCP: A constant u32 value representing the IOCTL code to send a packet to MSTCP.
pub const IOCTL_NDISRD_SEND_PACKET_TO_MSTCP: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 3,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_READ_PACKET: A constant u32 value representing the IOCTL code to read a packet.
pub const IOCTL_NDISRD_READ_PACKET: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 4,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SET_ADAPTER_MODE: A constant u32 value representing the IOCTL code to set the adapter mode.
pub const IOCTL_NDISRD_SET_ADAPTER_MODE: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 5,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_FLUSH_ADAPTER_QUEUE: A constant u32 value representing the IOCTL code to flush the adapter queue.
pub const IOCTL_NDISRD_FLUSH_ADAPTER_QUEUE: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 6,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SET_EVENT: A constant u32 value representing the IOCTL code to set a queued packet event.
pub const IOCTL_NDISRD_SET_EVENT: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 7,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_NDIS_SET_REQUEST: A constant u32 value representing the IOCTL code for an NDIS set request.
pub const IOCTL_NDISRD_NDIS_SET_REQUEST: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 8,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_NDIS_GET_REQUEST: A constant u32 value representing the IOCTL code for an NDIS get request.
pub const IOCTL_NDISRD_NDIS_GET_REQUEST: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 9,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SET_WAN_EVENT: A constant u32 value representing the IOCTL code to set a WAN event.
pub const IOCTL_NDISRD_SET_WAN_EVENT: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 10,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SET_ADAPTER_EVENT: A constant u32 value representing the IOCTL code to set an adapters list change event.
pub const IOCTL_NDISRD_SET_ADAPTER_EVENT: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 11,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_ADAPTER_QUEUE_SIZE: A constant u32 value representing the IOCTL code to get the adapter queue size.
pub const IOCTL_NDISRD_ADAPTER_QUEUE_SIZE: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 12,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_GET_ADAPTER_MODE: A constant u32 value representing the IOCTL code to get the adapter mode.
pub const IOCTL_NDISRD_GET_ADAPTER_MODE: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 13,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SET_PACKET_FILTERS: A constant u32 value representing the IOCTL code to set packet filters.
pub const IOCTL_NDISRD_SET_PACKET_FILTERS: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 14,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_RESET_PACKET_FILTERS: A constant u32 value representing the IOCTL code to reset packet filters.
pub const IOCTL_NDISRD_RESET_PACKET_FILTERS: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 15,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_GET_PACKET_FILTERS_TABLESIZE: A constant u32 value representing the IOCTL code to get the packet filters table size.
pub const IOCTL_NDISRD_GET_PACKET_FILTERS_TABLESIZE: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 16,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_GET_PACKET_FILTERS: A constant u32 value representing the IOCTL code to get packet filters.
pub const IOCTL_NDISRD_GET_PACKET_FILTERS: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 17,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_GET_PACKET_FILTERS_RESET_STATS: A constant u32 value representing the IOCTL code to get packet filters and reset their statistics.
pub const IOCTL_NDISRD_GET_PACKET_FILTERS_RESET_STATS: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 18,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_GET_RAS_LINKS: A constant u32 value representing the IOCTL code to get active RAS links.
pub const IOCTL_NDISRD_GET_RAS_LINKS: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 19,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SEND_PACKETS_TO_ADAPTER: A constant u32 value representing the IOCTL code to send packets to the adapter.
pub const IOCTL_NDISRD_SEND_PACKETS_TO_ADAPTER: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 20,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SEND_PACKETS_TO_MSTCP: A constant u32 value representing the IOCTL code to send packets to the MSTCP.
pub const IOCTL_NDISRD_SEND_PACKETS_TO_MSTCP: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 21,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_READ_PACKETS: A constant u32 value representing the IOCTL code to read packets.
pub const IOCTL_NDISRD_READ_PACKETS: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 22,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SET_ADAPTER_HWFILTER_EVENT: A constant u32 value representing the IOCTL code to set the adapter hardware filter change event.
pub const IOCTL_NDISRD_SET_ADAPTER_HWFILTER_EVENT: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 23,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_INITIALIZE_FAST_IO: A constant u32 value representing the IOCTL code to initialize fast I/O.
pub const IOCTL_NDISRD_INITIALIZE_FAST_IO: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 24,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_READ_PACKETS_UNSORTED: A constant u32 value representing the IOCTL code to read packets unsorted.
pub const IOCTL_NDISRD_READ_PACKETS_UNSORTED: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 25,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SEND_PACKET_TO_ADAPTER_UNSORTED: A constant u32 value representing the IOCTL code to send packets to the adapter unsorted.
pub const IOCTL_NDISRD_SEND_PACKET_TO_ADAPTER_UNSORTED: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 26,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_SEND_PACKET_TO_MSTCP_UNSORTED: A constant u32 value representing the IOCTL code to send packets to the MSTCP unsorted.
pub const IOCTL_NDISRD_SEND_PACKET_TO_MSTCP_UNSORTED: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 27,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_ADD_SECOND_FAST_IO_SECTION: A constant u32 value representing the IOCTL code to add a second fast I/O section.
pub const IOCTL_NDISRD_ADD_SECOND_FAST_IO_SECTION: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 28,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

/// IOCTL_NDISRD_QUERY_IB_POOL_SIZE: A constant u32 value representing the IOCTL code to query the effective size of the Windows Packet Filter internal intermediate buffer pool.
pub const IOCTL_NDISRD_QUERY_IB_POOL_SIZE: u32 = ctl_code(
    FILE_DEVICE_NDISRD,
    NDISRD_IOCTL_INDEX + 29,
    METHOD_BUFFERED,
    FILE_ANY_ACCESS,
);

```

`src/lib.rs`:

```rs
//! The NDISAPI crate is a Rust library that provides functionality for capturing and filtering network packets
//! on Windows operating systems. The crate contains three main modules: driver, ndisapi, and net.
//!
//! The driver module provides low-level functionality for interacting with Windows device drivers, and is used
//! by the ndisapi module to capture and filter network packets.
//!
//! The ndisapi module contains the main functionality for capturing and filtering network packets.
//! This includes various structs and enums for representing packet data and filter settings, as well as a Ndisapi
//! struct for interacting with the driver and performing packet capture and filtering operations.
//!
//! The net module contains a MacAddress struct for representing and manipulating MAC addresses.

mod driver;
mod ndisapi;
mod net;

pub use crate::ndisapi::{
    DirectionFlags, Eth802_3FilterFlags, EthMRequest, EthPacket, EthRequest, FastIoSection,
    FastIoSectionHeader, FilterFlags, FilterLayerFlags, IcmpFilterFlags, IntermediateBuffer,
    IpV4FilterFlags, IpV6FilterFlags, Ndisapi, PacketOidData, RasLinks, StaticFilterTable,
    TcpUdpFilterFlags, UnsortedReadSendRequest, ETHER_ADDR_LENGTH, ETH_802_3, FILTER_PACKET_DROP,
    FILTER_PACKET_DROP_RDR, FILTER_PACKET_PASS, FILTER_PACKET_PASS_RDR, FILTER_PACKET_REDIRECT,
    ICMP, IPV4, IPV6, IP_RANGE_V4_TYPE, IP_RANGE_V6_TYPE, IP_SUBNET_V4_TYPE, IP_SUBNET_V6_TYPE,
    TCPUDP,
};

pub use net::MacAddress;

```

`src/ndisapi.rs`:

```rs
//! # Module: NDISAPI
//!
//! This module provides a high-level interface to the NDISAPI Rust library for communicating with the Windows Packet Filter driver.
//! It includes the definition and implementation of the `Ndisapi` struct, which represents the main entry point to interact with the driver.
//!
//! The NDISAPI module also contains submodules for various aspects of the NDISAPI functionality, such as:
//! - base_api: Basic API operations
//! - defs: Definitions of constants, structures, and enumerations
//! - fastio_api: Fast I/O operations
//! - filters_api: Filter management and manipulation
//! - io_api: Basic I/O operations
//! - static_api: Static and Registry related methods for the NDISAPI
//!
//! For a detailed description of each submodule and the `Ndisapi` struct, refer to their respective documentation within the module.

// Imports required dependencies
use windows::{
    core::{Result, PCWSTR},
    Win32::Foundation::CloseHandle,
    Win32::Foundation::{GetLastError, HANDLE},
    Win32::Storage::FileSystem::{
        CreateFileW, FILE_FLAG_OVERLAPPED, FILE_SHARE_READ, FILE_SHARE_WRITE,
        OPEN_EXISTING,
    },
};

// Submodules
mod base_api;
mod defs;
mod fastio_api;
mod filters_api;
mod io_api;
mod static_api;

// Re-exports the `driver` submodule
pub use crate::driver::*;

/// The `Ndisapi` struct represents an instance of the NDIS filter driver that provides access to network adapters and packets.
///
/// This struct is used to communicate with the NDIS filter driver and access its functionalities. It contains a single field, `driver_handle`,
/// which represents a handle to the driver. This handle is used to perform operations such as reading and writing packets, setting filters, and
/// getting information about network adapters.
///
/// To use `Ndisapi`, you should first create an instance of the struct by calling the `Ndisapi::new()` function. This will return a `Result`
/// that contains an instance of `Ndisapi` if the operation was successful, or an error if it failed. Once you have an instance of `Ndisapi`,
/// you can call its methods to perform various network-related operations.
///
/// For example, you can use the `Ndisapi::read_packets()` method to read packets from the network adapter, or the `Ndisapi::send_packets_to_adapter()`
/// method to write packets to the network adapter. You can also use the `Ndisapi::set_packet_filter_table()` method to set a filter that specifies which
/// packets should be captured or dropped.
pub struct Ndisapi {
    // Represents a handle to the NDIS filter driver.
    driver_handle: HANDLE,
    // Stores the driver registry key for parameters
    registry_key: Vec<u16>,
}

// Implements the Drop trait for the `Ndisapi` struct
impl Drop for Ndisapi {
    // Provides a custom implementation for the `drop` method
    fn drop(&mut self) {
        // Closes the driver_handle when the `Ndisapi` instance goes out of scope
        unsafe {
            CloseHandle(self.driver_handle);
        }
    }
}

// Implements additional methods for the `Ndisapi` struct
impl Ndisapi {
    /// Initializes new Ndisapi instance opening the NDIS filter driver
    ///
    /// # Arguments
    ///
    /// * `driver_name` - The name of the file representing the NDIS filter driver.
    ///
    /// # Returns
    ///
    /// * `Result<Self>` - A Result containing the Ndisapi instance if successful, or an error if not.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use ndisapi::Ndisapi;
    /// let ndisapi = Ndisapi::new("NDISRD").unwrap();
    /// ```
    pub fn new(driver_name: &str) -> Result<Self> {
        // Create the filename and driver parameters registry path
        let filename = format!(r"\\.\{driver_name}");
        let registry_key = format!(r"SYSTEM\CurrentControlSet\Services\{driver_name}\Parameters");
        let mut filename: Vec<u16> = filename.encode_utf16().collect();
        let mut registry_key: Vec<u16> = registry_key.encode_utf16().collect();
        filename.push(0);
        registry_key.push(0);

        // Attempts to create a file handle for the NDIS filter driver
        if let Ok(driver_handle) = unsafe {
            CreateFileW(
                PCWSTR::from_raw(filename.as_ptr()),
                0u32,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                None,
                OPEN_EXISTING,
                FILE_FLAG_OVERLAPPED,
                None,
            )
        } {
            // Returns a new Ndisapi instance with the created handle if successful
            Ok(Self {
                driver_handle,
                registry_key,
            })
        } else {
            // Returns an error if the file handle creation fails
            Err(unsafe { GetLastError() }.into())
        }
    }

    pub fn get_driver_registry_key(&self) -> PCWSTR {
        PCWSTR::from_raw(self.registry_key.as_ptr())
    }
}

```

`src/ndisapi/base_api.rs`:

```rs
//! # Submodule: Basic NDISAPI functions
//!
//! This submodule provides a comprehensive set of functionalities for interacting with the Windows Packet Filter Kit,
//! allowing users to perform various actions on network adapters within Windows operating systems.
//! It includes methods for setting various adapter parameters, configuring packet filter modes,
//! handling hardware packet filters, and managing events related to adapter list changes
//! and WAN connections.

use std::mem::{size_of, MaybeUninit};

use windows::{
    core::Result,
    Win32::Foundation::{GetLastError, HANDLE},
    Win32::System::IO::DeviceIoControl,
};

use super::Ndisapi;
use crate::driver::*;
use crate::ndisapi::defs::*;

pub const OID_GEN_CURRENT_PACKET_FILTER: u32 = 0x0001010E;

impl Ndisapi {
    /// This method takes an adapter handle as an argument and returns a Result containing
    /// the FilterFlags enum for the selected network interface. If an error occurs, the
    /// GetLastError function is called to retrieve the error and is then converted into
    /// a Result::Err variant.
    ///
    /// # Arguments
    ///
    /// * `adapter_handle` - A HANDLE representing the network interface for which the
    ///   packet filter mode should be queried.
    ///
    /// # Returns
    ///
    /// * `Result<FilterFlags>` - A Result containing the FilterFlags enum for the selected
    ///   network interface if the query was successful, or an error if it failed.
    pub fn get_adapter_mode(&self, adapter_handle: HANDLE) -> Result<FilterFlags> {
        let mut adapter_mode = AdapterMode {
            adapter_handle,
            ..Default::default()
        };

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_GET_ADAPTER_MODE,
                Some(&adapter_mode as *const AdapterMode as *const std::ffi::c_void),
                size_of::<AdapterMode>() as u32,
                Some(&mut adapter_mode as *mut AdapterMode as *mut std::ffi::c_void),
                size_of::<AdapterMode>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(adapter_mode.flags)
        }
    }

    /// This method takes an adapter handle as an argument and returns a Result containing
    /// a u32 value representing the hardware packet filter for the specified network interface.
    /// If an error occurs, it will be propagated as a Result::Err variant.
    ///
    /// # Arguments
    ///
    /// * `adapter_handle` - A HANDLE representing the network interface for which the
    ///   hardware packet filter should be queried.
    ///
    /// # Returns
    ///
    /// * `Result<u32>` - A Result containing a u32 value representing the hardware packet
    ///   filter for the specified network interface if the query was successful, or an error
    ///   if it failed.
    pub fn get_hw_packet_filter(&self, adapter_handle: HANDLE) -> Result<u32> {
        let mut oid = PacketOidData::new(adapter_handle, OID_GEN_CURRENT_PACKET_FILTER, 0u32);

        self.ndis_get_request::<_>(&mut oid)?;

        Ok(oid.data)
    }

    /// This method takes an adapter handle and a mutable reference to a RasLinks struct
    /// as arguments. It queries the active WAN connections from the NDIS filter driver
    /// and updates the `ras_links` argument with the received information. If an error
    /// occurs, it will be propagated as a Result::Err variant.
    ///
    /// # Arguments
    ///
    /// * `adapter_handle` - A HANDLE representing the network interface for which the
    ///   active WAN connections should be queried.
    /// * `ras_links` - A mutable reference to a RasLinks struct that will be updated
    ///   with the information about active WAN connections.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result containing an empty tuple if the query was successful,
    ///   or an error if it failed.
    pub fn get_ras_links(&self, adapter_handle: HANDLE, ras_links: &mut RasLinks) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_GET_RAS_LINKS,
                Some(&adapter_handle as *const HANDLE as *const std::ffi::c_void),
                size_of::<HANDLE>() as u32,
                Some(ras_links as *const RasLinks as *mut std::ffi::c_void),
                size_of::<RasLinks>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This method retrieves information about network interfaces that available to NDIS filter driver.
    /// It returns a Result containing a vector of NetworkAdapterInfo
    /// structs, which contain detailed information about each network interface.
    ///
    /// # Returns
    ///
    /// * `Result<Vec<NetworkAdapterInfo>>` - A Result containing a vector of NetworkAdapterInfo
    /// structs representing the available network interfaces if the query was successful,
    /// or an error if it failed.
    pub fn get_tcpip_bound_adapters_info(&self) -> Result<Vec<NetworkAdapterInfo>> {
        let mut adapters: MaybeUninit<TcpAdapterList> = ::std::mem::MaybeUninit::uninit();

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_GET_TCPIP_INTERFACES,
                None,
                0,
                Some(adapters.as_mut_ptr() as _),
                size_of::<TcpAdapterList>() as u32,
                None,
                None,
            )
        };

        if result.as_bool() {
            let mut result = Vec::new();
            let adapters = unsafe { adapters.assume_init() };

            for i in 0..adapters.adapter_count as usize {
                let adapter_name =
                    String::from_utf8(adapters.adapter_name_list[i].to_vec()).unwrap();
                let adapter_name = adapter_name.trim_end_matches(char::from(0)).to_owned();
                let next = NetworkAdapterInfo::new(
                    adapter_name,
                    adapters.adapter_handle[i],
                    adapters.adapter_medium_list[i],
                    adapters.current_address[i],
                    adapters.mtu[i],
                );
                result.push(next);
            }
            Ok(result)
        } else {
            Err(unsafe { GetLastError() }.into())
        }
    }

    /// This method retrieves the version of the NDIS filter driver currently running on the
    /// system. It returns a Result containing a Version struct with the major, minor, and
    /// revision numbers of the driver version.
    ///
    /// # Returns
    ///
    /// * `Result<Version>` - A Result containing a Version struct representing the NDIS
    ///   filter driver version if the query was successful, or an error if it failed.
    pub fn get_version(&self) -> Result<Version> {
        let mut version = u32::MAX;

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_GET_VERSION,
                Some(&mut version as *mut u32 as _),
                size_of::<u32>() as u32,
                Some(&mut version as *mut u32 as _),
                size_of::<u32>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(Version {
                major: (version & (0xF000)) >> 12,
                minor: (version & (0xFF000000)) >> 24,
                revision: (version & (0xFF0000)) >> 16,
            })
        }
    }

    /// This function is used to obtain various parameters of the network adapter, such as the
    /// dimension of the internal buffers, the link speed, or the counter of corrupted packets.
    /// The constants that define the operations are declared in the file `ntddndis.h`.
    ///
    /// # Type Parameters
    ///
    /// * `T`: The type of data to be queried from the network adapter.
    ///
    /// # Arguments
    ///
    /// * `oid_request`: A mutable reference to a `PacketOidData<T>` struct that specifies
    ///   the adapter handle and the operation to perform.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result indicating whether the query operation was successful or not.
    ///   On success, returns `Ok(())`. On failure, returns an error.
    pub fn ndis_get_request<T>(&self, oid_request: &mut PacketOidData<T>) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_NDIS_GET_REQUEST,
                Some(oid_request as *const PacketOidData<T> as *const std::ffi::c_void),
                size_of::<PacketOidData<T>>() as u32,
                Some(oid_request as *const PacketOidData<T> as *mut std::ffi::c_void),
                size_of::<PacketOidData<T>>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function is used to set various parameters of the network adapter, such as the
    /// dimension of the internal buffers, the link speed, or the counter of corrupted packets.
    /// The constants that define the operations are declared in the file `ntddndis.h`.
    ///
    /// # Type Parameters
    ///
    /// * `T`: The type of data to be set for the network adapter.
    ///
    /// # Arguments
    ///
    /// * `oid_request`: A reference to a `PacketOidData<T>` struct that specifies
    ///   the adapter handle and the operation to perform.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result indicating whether the set operation was successful or not.
    ///   On success, returns `Ok(())`. On failure, returns an error.
    pub fn ndis_set_request<T>(&self, oid_request: &PacketOidData<T>) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_NDIS_SET_REQUEST,
                Some(oid_request as *const PacketOidData<T> as *const std::ffi::c_void),
                size_of::<PacketOidData<T>>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// The user application should create a Win32 event (with the `CreateEvent` API call) and pass
    /// the event handle to this function. The helper driver will signal this event when the
    /// NDIS filter adapter's list changes, for example, when a network card is plugged/unplugged,
    /// a network connection is disabled/enabled, or other similar events.
    ///
    /// # Arguments
    ///
    /// * `event_handle`: A `HANDLE` to a Win32 event created by the user application.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result indicating whether setting the event was successful or not.
    ///   On success, returns `Ok(())`. On failure, returns an error.
    pub fn set_adapter_list_change_event(&self, event_handle: HANDLE) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SET_ADAPTER_EVENT,
                Some(&event_handle as *const HANDLE as *const std::ffi::c_void),
                size_of::<HANDLE>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// Sets the packet filter mode for the selected network interface.
    ///
    /// # Arguments
    ///
    /// * `adapter_handle`: A `HANDLE` to the network interface (obtained via call to `get_tcpip_bound_adapters_info`).
    /// * `flags`: A `FilterFlags` value representing the combination of packet filter mode flags.
    /// * `MSTCP_FLAG_SENT_TUNNEL` – Queue all packets sent from MSTCP to the network interface. Original packet dropped.
    /// * `MSTCP_FLAG_RECV_TUNNEL` – Queue all packets indicated by the network interface to MSTCP. Original packet dropped.
    /// * `MSTCP_FLAG_SENT_LISTEN` – Queue all packets sent from MSTCP to the network interface. Original packet goes ahead.
    /// * `MSTCP_FLAG_RECV_LISTEN` – Queue all packets indicated by the network interface to MSTCP. Original packet goes ahead.
    /// * `MSTCP_FLAG_FILTER_DIRECT` – In promiscuous mode, the TCP/IP stack receives all packets in the Ethernet segment and replies
    ///   with various ICMP packets. To prevent this, set this flag. All packets with destination MAC different from
    ///   FF-FF-FF-FF-FF-FF and the network interface's current MAC will never reach MSTCP.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result indicating whether setting the adapter mode was successful or not.
    ///   On success, returns `Ok(())`. On failure, returns an error.
    pub fn set_adapter_mode(&self, adapter_handle: HANDLE, flags: FilterFlags) -> Result<()> {
        let adapter_mode = AdapterMode {
            adapter_handle,
            flags,
        };

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SET_ADAPTER_MODE,
                Some(&adapter_mode as *const AdapterMode as *const std::ffi::c_void),
                size_of::<AdapterMode>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This method allows setting the hardware packet filter mode for the specified network interface by calling
    /// the `ndis_set_request` function.
    ///
    /// # Arguments
    ///
    /// * `adapter_handle`: A `HANDLE` to the network interface.
    /// * `filter`: A `u32` value representing the packet filter mode.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result indicating whether setting the hardware packet filter was successful or not.
    ///   On success, returns `Ok(())`. On failure, returns an error.
    pub fn set_hw_packet_filter(&self, adapter_handle: HANDLE, filter: u32) -> Result<()> {
        let oid = PacketOidData::new(adapter_handle, OID_GEN_CURRENT_PACKET_FILTER, filter);

        self.ndis_set_request::<_>(&oid)?;

        Ok(())
    }

    /// This method allows setting a Win32 event that will be signaled by the filter driver when the hardware packet
    /// filter for the network interface changes.
    ///
    /// # Arguments
    ///
    /// * `event_handle`: A `HANDLE` to the Win32 event created by the user application.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result indicating whether setting the hardware packet filter event was successful or not.
    ///   On success, returns `Ok(())`. On failure, returns an error.
    pub fn set_hw_packet_filter_event(&self, event_handle: HANDLE) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SET_ADAPTER_HWFILTER_EVENT,
                Some(&event_handle as *const HANDLE as *const std::ffi::c_void),
                size_of::<HANDLE>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This method allows setting a Win32 event that will be signaled by the filter driver when a WAN connection
    /// (such as dial-up, DSL, ADSL, etc.) is established or terminated.
    ///
    /// # Arguments
    ///
    /// * `event_handle`: A `HANDLE` to the Win32 event created by the user application.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - A Result indicating whether setting the WAN event was successful or not. On success,
    ///   returns `Ok(())`. On failure, returns an error.
    pub fn set_wan_event(&self, event_handle: HANDLE) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SET_WAN_EVENT,
                Some(&event_handle as *const HANDLE as *const std::ffi::c_void),
                size_of::<HANDLE>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// Retrieves the effective size of the Windows Packet Filter internal intermediate buffer pool.
    ///
    /// # Returns
    ///
    /// * `Result<u32>` - If the operation is successful, returns `Ok(pool_size)` where `pool_size`
    ///   is the size of the intermediate buffer pool. Otherwise, returns an `Err` with the error code.
    ///
    /// This function retrieves the size of the intermediate buffer pool used by the driver.
    /// It uses `DeviceIoControl` with the `IOCTL_NDISRD_QUERY_IB_POOL_SIZE` code to perform the operation.
    pub fn get_intermediate_buffer_pool_size(&self) -> Result<u32> {
        let mut pool_size: u32 = 0;

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_QUERY_IB_POOL_SIZE,
                None,
                0,
                Some(&mut pool_size as *mut u32 as _),
                size_of::<u32>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(pool_size)
        }
    }
}

```

`src/ndisapi/defs.rs`:

```rs
//! # Submodule: High-level NDISAPI Types
//!
//! This submodule provides high-level NDISAPI definitions of constants, structures, and enumerations
//!

// Required imports for the submodule
use std::fmt::{Display, Formatter, Result};
use windows::Win32::Foundation::HANDLE;

/// Represents the version information for the NDIS filter driver.
#[derive(PartialEq, Eq, PartialOrd, Ord)]
pub struct Version {
    pub major: u32,
    pub minor: u32,
    pub revision: u32,
}

impl Display for Version {
    /// Formats the version information for display purposes.
    ///
    /// # Arguments
    ///
    /// * `f`: A mutable reference to a `Formatter` object.
    ///
    /// # Returns
    ///
    /// * `Result` - A formatting Result.
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        write!(f, "{}.{}.{}", self.major, self.minor, self.revision)
    }
}

/// Represents information about a network adapter.
pub struct NetworkAdapterInfo {
    name: String,
    handle: HANDLE,
    medium: u32,
    hw_address: [u8; 6],
    mtu: u16,
}

impl NetworkAdapterInfo {
    /// Creates a new `NetworkAdapterInfo` object with the specified properties.
    ///
    /// # Arguments
    ///
    /// * `name`: A `String` representing the name of the network adapter.
    /// * `handle`: A `HANDLE` to the network adapter.
    /// * `medium`: A `u32` value representing the network adapter medium.
    /// * `hw_address`: A `[u8; 6]` array representing the hardware address of the network adapter.
    /// * `mtu`: A `u16` value representing the maximum transmission unit (MTU) of the network adapter.
    ///
    /// # Returns
    ///
    /// * `NetworkAdapterInfo` - A new instance of `NetworkAdapterInfo`.
    pub fn new(name: String, handle: HANDLE, medium: u32, hw_address: [u8; 6], mtu: u16) -> Self {
        Self {
            name,
            handle,
            medium,
            hw_address,
            mtu,
        }
    }

    /// Returns the name of the network adapter.
    ///
    /// # Returns
    ///
    /// * `&str` - A reference to the name of the network adapter.
    pub fn get_name(&self) -> &str {
        &self.name
    }

    /// Returns the handle of the network adapter.
    ///
    /// # Returns
    ///
    /// * `HANDLE` - The handle of the network adapter.
    pub fn get_handle(&self) -> HANDLE {
        self.handle
    }

    /// Returns the medium of the network adapter.
    ///
    /// # Returns
    ///
    /// * `u32` - The medium of the network adapter.
    pub fn get_medium(&self) -> u32 {
        self.medium
    }

    /// Returns the hardware address of the network adapter.
    ///
    /// # Returns
    ///
    /// * `&[u8; 6]` - A reference to the hardware address of the network adapter.
    pub fn get_hw_address(&self) -> &[u8; 6] {
        &self.hw_address
    }

    /// Returns the maximum transmission unit (MTU) of the network adapter.
    ///
    /// # Returns
    ///
    /// * `u16` - The MTU of the network adapter.
    pub fn get_mtu(&self) -> u16 {
        self.mtu
    }
}

```

`src/ndisapi/fastio_api.rs`:

```rs
//! # Submodule: Fast I/O operations
//!
//! This submodule  offers methods to interact with the NDIS filter driver, allowing users to
//! initialize the fast I/O mechanism, add a secondary fast I/O shared memory sections, and forward
//! packets to the driver or to the target network interface or protocol layer. The methods in this
//! submodule are designed to be highly flexible, allowing for parameterization by the size of the shared
//! memory section or the number of packets to send. This submodule is part of the larger NDISAPI module,
//! which provides a high-level API for the Windows Packet Filter on Windows.
//!

use std::mem::size_of;

use windows::{core::Result, Win32::Foundation::GetLastError, Win32::System::IO::DeviceIoControl};

use super::Ndisapi;
use crate::driver::*;

impl Ndisapi {
    /// This function adds a secondary Fast I/O shared memory section to the NDIS filter driver,
    /// allowing faster communication between user-mode applications and the driver.
    ///
    /// # Type Parameters
    ///
    /// * `N`: The size of the Fast I/O shared memory section.
    ///
    /// # Arguments
    ///
    /// * `fast_io_section`: A mutable reference to a `FastIoSection<N>` object representing
    ///   the shared memory section to be added.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub fn add_secondary_fast_io<const N: usize>(
        &self,
        fast_io_section: &mut FastIoSection<N>,
    ) -> Result<()> {
        let params = InitializeFastIoParams::<N> {
            header_ptr: fast_io_section as *mut FastIoSection<N>,
            data_size: N as u32,
        };

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_ADD_SECOND_FAST_IO_SECTION,
                Some(&params as *const InitializeFastIoParams<N> as *const std::ffi::c_void),
                size_of::<InitializeFastIoParams<N>>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function initializes the fast I/O mechanism for the NDIS filter driver and
    /// submits the initial shared memory section for faster communication between
    /// user-mode applications and the driver.
    ///
    /// # Type Parameters
    ///
    /// * `N`: The size of the Fast I/O shared memory section.
    ///
    /// # Arguments
    ///
    /// * `fast_io_section`: A mutable reference to a `FastIoSection<N>` object representing
    ///   the shared memory section to be submitted.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub fn initialize_fast_io<const N: usize>(
        &self,
        fast_io_section: &mut FastIoSection<N>,
    ) -> Result<()> {
        let params = InitializeFastIoParams::<N> {
            header_ptr: fast_io_section as *mut FastIoSection<N>,
            data_size: N as u32,
        };

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_INITIALIZE_FAST_IO,
                Some(&params as *const InitializeFastIoParams<N> as *const std::ffi::c_void),
                size_of::<InitializeFastIoParams<N>>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function retrieves queued packets from the NDIS filter driver without considering
    /// the network interface. It reads packets in an unsorted manner and stores them in the
    /// provided buffer.
    ///
    /// # Type Parameters
    ///
    /// * `N`: The number of packets to read.
    ///
    /// # Arguments
    ///
    /// * `packets`: A mutable reference to an array of `IntermediateBuffer` objects, where the
    ///   read packets will be stored.
    ///
    /// # Returns
    ///
    /// * `Result<usize>`: If successful, returns `Ok(usize)` with the number of packets read.
    ///   Otherwise, returns an error.
    pub fn read_packets_unsorted<const N: usize>(
        &self,
        packets: &mut [IntermediateBuffer; N],
    ) -> Result<usize> {
        let mut request = UnsortedReadSendRequest::<N> {
            packets: packets as *mut [IntermediateBuffer; N],
            packets_num: N as u32,
        };

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_READ_PACKETS_UNSORTED,
                Some(&request as *const UnsortedReadSendRequest<N> as *const std::ffi::c_void),
                size_of::<UnsortedReadSendRequest<N>>() as u32,
                Some(&mut request as *mut UnsortedReadSendRequest<N> as *mut std::ffi::c_void),
                size_of::<UnsortedReadSendRequest<N>>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(request.packets_num as usize)
        }
    }

    /// This function forwards packets to the NDIS filter driver in an unsorted manner, which then
    /// sends them to the target network interface. The target adapter handle should be set in the
    /// `IntermediateBuffer.header.adapter_handle` field.
    ///
    /// # Type Parameters
    ///
    /// * `N`: The number of packets to send.
    ///
    /// # Arguments
    ///
    /// * `packets`: A mutable reference to an array of `IntermediateBuffer` objects, which contain
    ///   the packets to be sent.
    /// * `packets_num`: The number of packets to send from the array.
    ///
    /// # Returns
    ///
    /// * `Result<usize>`: If successful, returns `Ok(usize)` with the number of packets sent.
    ///   Otherwise, returns an error.
    pub fn send_packets_to_adapters_unsorted<const N: usize>(
        &self,
        packets: &mut [IntermediateBuffer; N],
        packets_num: usize,
    ) -> Result<usize> {
        let mut request = UnsortedReadSendRequest::<N> {
            packets: packets as *mut [IntermediateBuffer; N],
            packets_num: packets_num as u32,
        };

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SEND_PACKET_TO_ADAPTER_UNSORTED,
                Some(&request as *const UnsortedReadSendRequest<N> as *const std::ffi::c_void),
                size_of::<UnsortedReadSendRequest<N>>() as u32,
                Some(&mut request as *mut UnsortedReadSendRequest<N> as *mut std::ffi::c_void),
                size_of::<UnsortedReadSendRequest<N>>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(request.packets_num as usize)
        }
    }

    /// This function forwards packets to the NDIS filter driver in an unsorted manner, which then
    /// sends them to the target protocols layer (MSTCP). The target adapter handle (to be indicated
    /// from) should be set in the `IntermediateBuffer.header.adapter_handle` field.
    ///
    /// # Type Parameters
    ///
    /// * `N`: The number of packets to send.
    ///
    /// # Arguments
    ///
    /// * `packets`: A mutable reference to an array of `IntermediateBuffer` objects, which contain
    ///   the packets to be sent.
    /// * `packets_num`: The number of packets to send from the array.
    ///
    /// # Returns
    ///
    /// * `Result<usize>`: If successful, returns `Ok(usize)` with the number of packets sent.
    ///   Otherwise, returns an error.
    pub fn send_packets_to_mstcp_unsorted<const N: usize>(
        &self,
        packets: &mut [IntermediateBuffer; N],
        packets_num: usize,
    ) -> Result<usize> {
        let mut request = UnsortedReadSendRequest::<N> {
            packets: packets as *mut [IntermediateBuffer; N],
            packets_num: packets_num as u32,
        };

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SEND_PACKET_TO_MSTCP_UNSORTED,
                Some(&request as *const UnsortedReadSendRequest<N> as *const std::ffi::c_void),
                size_of::<UnsortedReadSendRequest<N>>() as u32,
                Some(&mut request as *mut UnsortedReadSendRequest<N> as *mut std::ffi::c_void),
                size_of::<UnsortedReadSendRequest<N>>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(request.packets_num as usize)
        }
    }
}

```

`src/ndisapi/filters_api.rs`:

```rs
//! # Submodule: Static filter functions
//!
//! This submodule provides methods for controlling the NDIS filter driver, including retrieving and setting
//! the static filter table, resetting the filter statistics, and resetting the static filter table. These
//! methods are parameterized by the size of the static filter table. The submodule is part of a larger module
//! (NDISAPI) that provides high-level API for the Windows packet Filter on Windows.
//!

use std::mem::size_of;

use windows::{core::Result, Win32::Foundation::GetLastError, Win32::System::IO::DeviceIoControl};

use super::Ndisapi;
use crate::driver::*;

impl Ndisapi {
    /// This function retrieves the static filter table from the NDIS filter driver and stores it in
    /// the provided `filter_table` argument.
    ///
    /// # Type Parameters
    ///
    /// * `N`: The size of the static filter table.
    ///
    /// # Arguments
    ///
    /// * `filter_table`: A mutable reference to a `StaticFilterTable<N>` object, which will store the
    ///   queried static filter table.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub fn get_packet_filter_table<const N: usize>(
        &self,
        filter_table: &mut StaticFilterTable<N>,
    ) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_GET_PACKET_FILTERS,
                None,
                0,
                Some(filter_table as *mut StaticFilterTable<N> as *mut std::ffi::c_void),
                size_of::<StaticFilterTable<N>>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function retrieves the static filter table from the NDIS filter driver, stores it in
    /// the provided `filter_table` argument, and resets the filter statistics.
    ///
    /// # Type Parameters
    ///
    /// * `N`: The size of the static filter table.
    ///
    /// # Arguments
    ///
    /// * `filter_table`: A mutable reference to a `StaticFilterTable<N>` object, which will store the
    ///   queried static filter table.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub fn get_packet_filter_table_reset_stats<const N: usize>(
        &self,
        filter_table: &mut StaticFilterTable<N>,
    ) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_GET_PACKET_FILTERS_RESET_STATS,
                None,
                0,
                Some(filter_table as *mut StaticFilterTable<N> as *mut std::ffi::c_void),
                size_of::<StaticFilterTable<N>>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function retrieves the size of the static filter table from the NDIS filter driver.
    ///
    /// # Returns
    ///
    /// * `Result<usize>`: If successful, returns the size of the static filter table as `Ok(usize)`.
    ///   Otherwise, returns an error.
    pub fn get_packet_filter_table_size(&self) -> Result<usize> {
        let mut size = 0u32;

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_GET_PACKET_FILTERS_TABLESIZE,
                None,
                0,
                Some(&mut size as *mut u32 as *mut std::ffi::c_void),
                size_of::<u32>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(size as usize)
        }
    }

    /// This function resets the static filter table in the NDIS filter driver, effectively
    /// removing all filters from the table.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub fn reset_packet_filter_table(&self) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_RESET_PACKET_FILTERS,
                None,
                0,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function takes a static filter table and sets it as the current filter table
    /// in the NDIS filter driver.
    ///
    /// # Type Parameters
    ///
    /// * `N`: The number of filters in the static filter table.
    ///
    /// # Arguments
    ///
    /// * `filter_table: &StaticFilterTable<N>`: A reference to the static filter table to be loaded.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub fn set_packet_filter_table<const N: usize>(
        &self,
        filter_table: &StaticFilterTable<N>,
    ) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SET_PACKET_FILTERS,
                Some(filter_table as *const StaticFilterTable<N> as *const std::ffi::c_void),
                size_of::<StaticFilterTable<N>>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }
}

```

`src/ndisapi/io_api.rs`:

```rs
//! # Submodule: I/O functions
//!
//! This submodule defines a set of functions that interact with the NDIS filter driver.
//! These functions include clearing the packet queue associated with a network adapter,
//! retrieving the number of packets currently queued in the packet queue, reading single
//! or multiple network packets from the NDIS filter driver, and sending single or multiple
//! network packets to the NDIS filter driver to be passed down or up the network stack.
//! This submodule also provides a function to set a Win32 event to be signaled by the
//! NDIS filter when packets are available for read on a network adapter.
//!

use std::mem::size_of;

use windows::{
    core::Result,
    Win32::Foundation::{GetLastError, HANDLE},
    Win32::System::IO::DeviceIoControl,
};

use super::Ndisapi;
use crate::driver::*;

impl Ndisapi {
    /// This function clears the packet queue associated with the specified network adapter
    /// handle in the NDIS filter driver.
    ///
    /// # Arguments
    ///
    /// * `adapter_handle: HANDLE`: The handle of the network adapter whose packet queue
    ///   should be flushed.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub fn flush_adapter_packet_queue(&self, adapter_handle: HANDLE) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_FLUSH_ADAPTER_QUEUE,
                Some(&adapter_handle as *const HANDLE as *const std::ffi::c_void),
                size_of::<HANDLE>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function retrieves the number of packets currently queued in the packet queue associated with the
    /// specified network adapter handle in the NDIS filter driver.
    ///
    /// # Arguments
    ///
    /// * `adapter_handle: HANDLE`: The handle of the network adapter whose packet queue size should be queried.
    ///
    /// # Returns
    ///
    /// * `Result<u32>`: If successful, returns `Ok(queue_size)` where `queue_size` is the number of packets in the
    ///   adapter's packet queue. Otherwise, returns an error.
    pub fn get_adapter_packet_queue_size(&self, adapter_handle: HANDLE) -> Result<u32> {
        let mut queue_size = 0u32;

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_ADAPTER_QUEUE_SIZE,
                Some(&adapter_handle as *const HANDLE as *const std::ffi::c_void),
                size_of::<HANDLE>() as u32,
                Some(&mut queue_size as *mut u32 as *mut std::ffi::c_void),
                size_of::<u32>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(queue_size)
        }
    }

    /// This function retrieves a single network packet from the NDIS filter driver associated with
    /// the specified `EthRequest`.
    ///
    /// # Safety
    ///
    /// This function is unsafe because `EthRequest.packet` may not be initialized or might point to
    /// invalid memory.
    ///
    /// # Arguments
    ///
    /// * `packet: &mut EthRequest`: A mutable reference to the `EthRequest` structure that will be filled with
    ///   the retrieved packet data.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub unsafe fn read_packet(&self, packet: &mut EthRequest) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_READ_PACKET,
                Some(packet as *const EthRequest as *const std::ffi::c_void),
                size_of::<EthRequest>() as u32,
                Some(packet as *mut EthRequest as *mut std::ffi::c_void),
                size_of::<EthRequest>() as u32,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function retrieves a block of network packets from the NDIS filter driver associated with
    /// the specified `EthMRequest<N>`.
    ///
    /// # Safety
    ///
    /// This function is unsafe because `EthMRequest<N>.packets` may not be initialized or might point to
    /// invalid memory.
    ///
    /// # Arguments
    ///
    /// * `packets: &mut EthMRequest<N>`: A mutable reference to the `EthMRequest<N>` structure that will be filled with
    ///   the retrieved packet data.
    ///
    /// # Returns
    ///
    /// * `Result<usize>`: If successful, returns `Ok(packet_count)` where `packet_count` is the number of packets read
    ///   into `EthMRequest<N>`. Otherwise, returns an error.
    pub unsafe fn read_packets<const N: usize>(
        &self,
        packets: &mut EthMRequest<N>,
    ) -> Result<usize> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_READ_PACKETS,
                Some(packets as *const EthMRequest<N> as *const std::ffi::c_void),
                size_of::<EthMRequest<N>>() as u32,
                Some(packets as *mut EthMRequest<N> as *mut std::ffi::c_void),
                size_of::<EthMRequest<N>>() as u32,
                None,
                None,
            )
        };

        if result.as_bool() {
            Ok(packets.get_packet_success() as usize)
        } else {
            Err(unsafe { GetLastError() }.into())
        }
    }

    /// This function sends a single network packet to the NDIS filter driver associated with
    /// the specified `EthRequest`, which will then be passed down the network stack.
    ///
    /// # Safety
    ///
    /// This function is unsafe because `EthRequest.packet` may not be initialized or might point to
    /// invalid memory.
    ///
    /// # Arguments
    ///
    /// * `packet: &EthRequest`: A reference to the `EthRequest` structure containing the packet data to be sent.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub unsafe fn send_packet_to_adapter(&self, packet: &EthRequest) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SEND_PACKET_TO_ADAPTER,
                Some(packet as *const EthRequest as *const std::ffi::c_void),
                size_of::<EthRequest>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function sends a single network packet to the NDIS filter driver associated with
    /// the specified `EthRequest`, which will then be passed down the network stack to the Microsoft TCP/IP stack.
    ///
    /// # Safety
    ///
    /// This function is unsafe because `EthRequest.packet` may not be initialized or might point to
    /// invalid memory.
    ///
    /// # Arguments
    ///
    /// * `packet: &EthRequest`: A reference to the `EthRequest` structure containing the packet data to be sent.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub unsafe fn send_packet_to_mstcp(&self, packet: &EthRequest) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SEND_PACKET_TO_MSTCP,
                Some(packet as *const EthRequest as *const std::ffi::c_void),
                size_of::<EthRequest>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function sends a block of network packets to the NDIS filter driver associated with
    /// the specified `EthMRequest<N>`, which will then be passed down the network stack.
    ///
    /// # Safety
    ///
    /// This function is unsafe because `EthMRequest<N>.packets` may not be initialized or might point to
    /// invalid memory.
    ///
    /// # Arguments
    ///
    /// * `packets: &EthMRequest<N>`: A reference to the `EthMRequest<N>` structure containing the packet data to be sent.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub unsafe fn send_packets_to_adapter<const N: usize>(
        &self,
        packets: &EthMRequest<N>,
    ) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SEND_PACKETS_TO_ADAPTER,
                Some(packets as *const EthMRequest<N> as *const std::ffi::c_void),
                size_of::<EthMRequest<N>>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function sends a block of network packets to the NDIS filter driver associated with
    /// the specified `EthMRequest<N>`, which will then be passed up the network stack to the Microsoft TCP/IP stack.
    ///
    /// # Safety
    ///
    /// This function is unsafe because `EthMRequest<N>.packets` may not be initialized or might point to
    /// invalid memory.
    ///
    /// # Arguments
    ///
    /// * `packets: &EthMRequest<N>`: A reference to the `EthMRequest<N>` structure containing the packet data to be sent.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub unsafe fn send_packets_to_mstcp<const N: usize>(
        &self,
        packets: &EthMRequest<N>,
    ) -> Result<()> {
        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SEND_PACKETS_TO_MSTCP,
                Some(packets as *const EthMRequest<N> as *const std::ffi::c_void),
                size_of::<EthMRequest<N>>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }

    /// This function sets a Win32 event to be signaled by the NDIS filter when it has queued packets available for read
    /// on the specified network adapter.
    ///
    /// # Arguments
    ///
    /// * `adapter_handle: HANDLE`: The handle of the network adapter to associate the event with.
    /// * `event_handle: HANDLE`: The handle of the Win32 event to be signaled when queued packets are available.
    ///
    /// # Returns
    ///
    /// * `Result<()>`: If successful, returns `Ok(())`. Otherwise, returns an error.
    pub fn set_packet_event(&self, adapter_handle: HANDLE, event_handle: HANDLE) -> Result<()> {
        let adapter_event = AdapterEvent {
            adapter_handle,
            event_handle,
        };

        let result = unsafe {
            DeviceIoControl(
                self.driver_handle,
                IOCTL_NDISRD_SET_EVENT,
                Some(&adapter_event as *const AdapterEvent as *const std::ffi::c_void),
                size_of::<AdapterEvent>() as u32,
                None,
                0,
                None,
                None,
            )
        };

        if !result.as_bool() {
            Err(unsafe { GetLastError() }.into())
        } else {
            Ok(())
        }
    }
}

```

`src/ndisapi/static_api.rs`:

```rs
//! # Submodule: Static NDISAPI functions
//!
//! This module provides utility functions for interacting with the Windows Registry related
//! to NDIS Filter driver and network interfaces. It defines constants for various Registry keys,
//! values, and data types that are used to access and modify settings related to network interfaces.
//! It also contains an //! implementation of Ndisapi that includes functions for setting and retrieving
//! Registry values related to NDIS filter driver and network interfaces.
//!

use windows::{
    core::{Result, PCWSTR, PWSTR},
    s, w,
    Win32::System::Registry::{
        RegCloseKey, RegEnumKeyExW, RegOpenKeyExW, RegQueryValueExA, RegQueryValueExW,
        RegSetValueExW, HKEY, HKEY_LOCAL_MACHINE, KEY_READ, KEY_WRITE, REG_DWORD, REG_VALUE_TYPE,
    },
};

use super::Ndisapi;
use std::str;

/// The registry key path for the network control class.
const REGSTR_NETWORK_CONTROL_CLASS: ::windows::core::PCWSTR =
    w!(r"SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318}");

/// The name of the registry value.
const REGSTR_VAL_NAME: ::windows::core::PCWSTR = w!("Name");

/// The name of the registry value containing the component ID.
const REGSTR_COMPONENTID: ::windows::core::PCSTR = s!("ComponentId");

/// The name of the registry value containing the linkage information.
const REGSTR_LINKAGE: ::windows::core::PCWSTR = w!("Linkage");

/// The name of the registry value containing the export information.
const REGSTR_EXPORT: ::windows::core::PCSTR = s!("Export");

/// The name of the registry value containing the MTU decrement value.
const REGSTR_MTU_DECREMENT: ::windows::core::PCWSTR = w!("MTUDecrement");

/// The name of the registry value containing the network adapter startup filter mode value.
const REGSTR_STARTUP_MODE: ::windows::core::PCWSTR = w!("StartupMode");

/// The name of the registry value containing theintermediate buffer pool size multiplier.
const REGSTR_POOL_SIZE: ::windows::core::PCWSTR = w!("PoolSize");

/// The component ID for the NDIS WAN IP driver.
const REGSTR_COMPONENTID_NDISWANIP: &str = "ms_ndiswanip";

/// The component ID for the NDIS WAN IPv6 driver.
const REGSTR_COMPONENTID_NDISWANIPV6: &str = "ms_ndiswanipv6";

/// The component ID for the NDIS WAN BH driver.
const REGSTR_COMPONENTID_NDISWANBH: &str = "ms_ndiswanbh";

/// The user-friendly name for the NDIS WAN IP interface.
const USER_NDISWANIP: &str = "WAN Network Interface (IP)";

/// The user-friendly name for the NDIS WAN BH interface.
const USER_NDISWANBH: &str = "WAN Network Interface (BH)";

/// The user-friendly name for the NDIS WAN IPv6 interface.
const USER_NDISWANIPV6: &str = "WAN Network Interface (IPv6)";

impl Ndisapi {
    /// Determines if a given network interface is an NDISWAN interface.
    ///
    /// This function enumerates all subkeys of the registry key `HKLM\SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318}`,
    /// and looks for the specified `component_id` (e.g., "ms_ndiswanip", "ms_ndiswanipv6", "ms_ndiswanbh").
    /// If a match is found, it checks the linkage subkey and export string to determine if the interface is an NDISWAN interface.
    ///
    /// # Arguments
    ///
    /// * `adapter_name: impl Into<String>`: The name of the network adapter to check.
    /// * `component_id: &str`: The component ID to look for in the registry (e.g., "ms_ndiswanip", "ms_ndiswanipv6", "ms_ndiswanbh").
    ///
    /// # Returns
    ///
    /// * `Result<bool>`: If successful, returns `Ok(true)` if the interface is an NDISWAN interface, `Ok(false)` otherwise.
    ///   If an error occurs, returns an error.
    fn is_ndiswan_interface(adapter_name: impl Into<String>, component_id: &str) -> Result<bool> {
        let adapter_name = adapter_name.into();
        // Handles to registry keys
        let mut target_key = HKEY::default();
        let mut connection_key = HKEY::default();
        let mut linkage_key = HKEY::default();

        let result = unsafe {
            RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                REGSTR_NETWORK_CONTROL_CLASS,
                0,
                KEY_READ,
                &mut target_key,
            )
        };

        if result.is_err() {
            return Err(result.into());
        }

        // Counter for enumerating registry keys
        let mut index = 0u32;

        // Buffers for storing registry values
        let mut buffer = vec![0u16; 256];
        let mut buffer_size = buffer.len() as u32;
        let mut temp_buffer = vec![0u8; 256];
        let mut temp_buffer_size = temp_buffer.len() as u32;

        // Set to true if found
        let mut found = false;

        while !found {
            let result = unsafe {
                RegEnumKeyExW(
                    target_key,
                    index,
                    PWSTR::from_raw(buffer.as_mut_ptr()),
                    &mut buffer_size as *mut u32,
                    None,
                    PWSTR::null(),
                    None,
                    None,
                )
            };

            if !result.is_ok() {
                break;
            } else {
                let result = unsafe {
                    RegOpenKeyExW(
                        target_key,
                        PCWSTR::from_raw(buffer.as_ptr()),
                        0,
                        KEY_READ,
                        &mut connection_key,
                    )
                };

                if result.is_ok() {
                    let mut value_type = REG_VALUE_TYPE::default();
                    let result = unsafe {
                        RegQueryValueExA(
                            connection_key,
                            REGSTR_COMPONENTID,
                            None,
                            Some(&mut value_type),
                            Some(temp_buffer.as_mut_ptr()),
                            Some(&mut temp_buffer_size),
                        )
                    };

                    if result.is_ok() {
                        let comp_id = if let Ok(id) =
                            str::from_utf8(&temp_buffer[..temp_buffer_size as usize])
                        {
                            id.trim_end_matches(char::from(0)).to_string()
                        } else {
                            String::default()
                        };

                        if comp_id.as_str() == component_id {
                            temp_buffer_size = temp_buffer.len() as u32;
                            let result = unsafe {
                                RegOpenKeyExW(
                                    connection_key,
                                    REGSTR_LINKAGE,
                                    0,
                                    KEY_READ,
                                    &mut linkage_key,
                                )
                            };

                            if result.is_ok() {
                                let result = unsafe {
                                    RegQueryValueExA(
                                        linkage_key,
                                        REGSTR_EXPORT,
                                        None,
                                        Some(&mut value_type),
                                        Some(temp_buffer.as_mut_ptr()),
                                        Some(&mut temp_buffer_size),
                                    )
                                };

                                if result.is_ok() {
                                    let export = if let Ok(id) =
                                        str::from_utf8(&temp_buffer[..temp_buffer_size as usize])
                                    {
                                        id.trim_end_matches(char::from(0)).to_string()
                                    } else {
                                        String::default()
                                    };

                                    if export.as_str().eq_ignore_ascii_case(adapter_name.as_str()) {
                                        found = true;
                                    }
                                }
                                unsafe {
                                    RegCloseKey(linkage_key);
                                }
                            }
                        }
                        unsafe {
                            RegCloseKey(connection_key);
                        }
                    }
                    temp_buffer_size = temp_buffer.len() as u32;
                }

                index += 1;
                buffer_size = buffer.len() as u32;
            }
        }

        unsafe {
            RegCloseKey(target_key);
        }

        Ok(found)
    }

    /// Determines if a given network interface is an NDISWANIP interface.
    ///
    /// This function checks if the specified network adapter is an NDISWANIP interface by calling `is_ndiswan_interface`
    /// with the component ID "ms_ndiswanip".
    ///
    /// # Arguments
    ///
    /// * `adapter_name: impl Into<String>`: The name of the network adapter to check.
    ///
    /// # Returns
    ///
    /// * `bool`: Returns `true` if the interface is an NDISWANIP interface, `false` otherwise.
    pub fn is_ndiswan_ip(adapter_name: impl Into<String>) -> bool {
        Self::is_ndiswan_interface(adapter_name.into(), REGSTR_COMPONENTID_NDISWANIP)
            .unwrap_or(false)
    }

    /// Determines if a given network interface is an NDISWANIPV6 interface.
    ///
    /// This function checks if the specified network adapter is an NDISWANIPV6 interface by calling `is_ndiswan_interface`
    /// with the component ID "ms_ndiswanipv6".
    ///
    /// # Arguments
    ///
    /// * `adapter_name: impl Into<String>`: The name of the network adapter to check.
    ///
    /// # Returns
    ///
    /// * `bool`: Returns `true` if the interface is an NDISWANIPV6 interface, `false` otherwise.
    pub fn is_ndiswan_ipv6(adapter_name: impl Into<String>) -> bool {
        Self::is_ndiswan_interface(adapter_name.into(), REGSTR_COMPONENTID_NDISWANIPV6)
            .unwrap_or(false)
    }

    /// Determines if a given network interface is an NDISWANBH interface.
    ///
    /// This function checks if the specified network adapter is an NDISWANBH interface by calling `is_ndiswan_interface`
    /// with the component ID "ms_ndiswanbh".
    ///
    /// # Arguments
    ///
    /// * `adapter_name: impl Into<String>`: The name of the network adapter to check.
    ///
    /// # Returns
    ///
    /// * `bool`: Returns `true` if the interface is an NDISWANBH interface, `false` otherwise.
    pub fn is_ndiswan_bh(adapter_name: impl Into<String>) -> bool {
        Self::is_ndiswan_interface(adapter_name.into(), REGSTR_COMPONENTID_NDISWANBH)
            .unwrap_or(false)
    }

    /// This function checks if the specified network adapter is an NDISWAN IP, IPv6, or BH interface, and if not,
    /// attempts to find the friendly name from the registry.
    ///
    /// # Arguments
    ///
    /// * `adapter_name: impl Into<String>`: The system-level name of the network adapter to obtain the user-friendly name for.
    ///
    /// # Returns
    ///
    /// * `Result<String>`: Returns a `Result` containing the user-friendly name of the network adapter if found, or an error otherwise.

    pub fn get_friendly_adapter_name(adapter_name: impl Into<String>) -> Result<String> {
        let mut adapter_name = adapter_name.into();

        if Self::is_ndiswan_ip(adapter_name.as_str()) {
            return Ok(USER_NDISWANIP.into());
        }

        if Self::is_ndiswan_ipv6(adapter_name.as_str()) {
            return Ok(USER_NDISWANIPV6.into());
        }

        if Self::is_ndiswan_bh(adapter_name.as_str()) {
            return Ok(USER_NDISWANBH.into());
        }

        // Trim the '\DEVICE\' prefix from the adapter system name
        adapter_name = adapter_name.replace("\\DEVICE\\", "");

        let friendly_name_key = format!(
            "SYSTEM\\CurrentControlSet\\Control\\Network\\{{4D36E972-E325-11CE-BFC1-08002BE10318}}\\{}\\Connection",
            &adapter_name
        );

        // Convert the string to UTF16 array and get a pointer to it as PCWSTR
        let mut friendly_name_key = friendly_name_key.encode_utf16().collect::<Vec<u16>>();
        friendly_name_key.push(0);

        let mut hkey = HKEY::default();

        let mut result = unsafe {
            RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                PCWSTR::from_raw(friendly_name_key.as_ptr()),
                0,
                KEY_READ,
                &mut hkey,
            )
        };

        let mut value_type = REG_VALUE_TYPE::default();
        let mut data = vec![0u16; 256];
        let mut data_size = data.len() as u32;
        let mut friendly_name = String::default();

        if result.is_ok() {
            result = unsafe {
                RegQueryValueExW(
                    hkey,
                    REGSTR_VAL_NAME,
                    None,
                    Some(&mut value_type),
                    Some(data.as_mut_ptr() as *const u8 as *mut u8),
                    Some(&mut data_size),
                )
            };

            if result.is_ok() {
                friendly_name = if let Ok(name) = String::from_utf16(&data[..data_size as usize]) {
                    name.trim_end_matches(char::from(0)).to_string()
                } else {
                    String::default()
                }
            }

            unsafe {
                RegCloseKey(hkey);
            }
        }

        if !result.is_ok() {
            Err(result.into())
        } else {
            Ok(friendly_name)
        }
    }

    /// This function sets a parameter in the registry key that the filter driver reads during its initialization.
    /// The value set in the registry is subtracted from the actual MTU (Maximum Transmission Unit) when it is requested
    /// by the MSTCP (Microsoft TCP/IP) from the network. Because this parameter is read during the initialization of the
    /// filter driver, a system reboot is required for the changes to take effect. Requires Administrator permissions.
    ///
    /// # Arguments
    ///
    /// * `mtu_decrement: u32` - The value to subtract from the actual MTU.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - Returns a `Result` that is `Ok(())` if the MTU decrement value is set successfully in the registry, or an error otherwise.
    pub fn set_mtu_decrement(&self, mtu_decrement: u32) -> Result<()> {
        let mut hkey = HKEY::default();

        let mut result = unsafe {
            RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                self.get_driver_registry_key(),
                0,
                KEY_WRITE,
                &mut hkey,
            )
        };

        if result.is_ok() {
            result = unsafe {
                RegSetValueExW(
                    hkey,
                    REGSTR_MTU_DECREMENT,
                    0,
                    REG_DWORD,
                    Some(mtu_decrement.to_ne_bytes().as_ref()),
                )
            };
        }

        if result.is_ok() {
            Ok(())
        } else {
            Err(result.into())
        }
    }

    /// This function retrieves the value set by `set_mtu_decrement` from the registry. Note that if you have not
    /// rebooted after calling `set_mtu_decrement`, the return value is meaningless. If `MTUDecrement` value is not
    /// present in the registry or an error occurred, then `None` is returned.
    ///
    /// # Returns
    ///
    /// * `Option<u32>` - Returns an `Option` containing the MTU decrement value if it is present in the registry and there are no errors, or `None` otherwise.
    pub fn get_mtu_decrement(&self) -> Option<u32> {
        let mut hkey = HKEY::default();

        let mut result = unsafe {
            RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                self.get_driver_registry_key(),
                0,
                KEY_READ,
                &mut hkey,
            )
        };

        let mut value_type = REG_VALUE_TYPE::default();
        let mtu_decrement = 0u32;
        let mut data_size = std::mem::size_of::<u32>() as u32;

        if result.is_ok() {
            result = unsafe {
                RegQueryValueExW(
                    hkey,
                    REGSTR_MTU_DECREMENT,
                    None,
                    Some(&mut value_type),
                    Some(&mtu_decrement as *const u32 as *mut u8),
                    Some(&mut data_size),
                )
            };
        }

        if result.is_ok() {
            Some(mtu_decrement)
        } else {
            None
        }
    }

    /// This routine sets the default mode to be applied to each adapter as soon as it appears in the system.
    /// It can be helpful in scenarios where you need to delay a network interface from operating until your
    /// application has started. However, it's essential to note that this API call requires a system reboot to take effect.
    /// Requires Administrator permissions to succeed.
    ///
    /// # Arguments
    ///
    /// * `startup_mode: u32` - The default startup mode to be applied to each adapter.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - Returns a `Result` indicating whether the operation succeeded or an error occurred.
    pub fn set_adapters_startup_mode(&self, startup_mode: u32) -> Result<()> {
        let mut hkey = HKEY::default();

        let mut result = unsafe {
            RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                self.get_driver_registry_key(),
                0,
                KEY_WRITE,
                &mut hkey,
            )
        };

        if result.is_ok() {
            result = unsafe {
                RegSetValueExW(
                    hkey,
                    REGSTR_STARTUP_MODE,
                    0,
                    REG_DWORD,
                    Some(startup_mode.to_ne_bytes().as_ref()),
                )
            };
        }

        if result.is_ok() {
            Ok(())
        } else {
            Err(result.into())
        }
    }

    /// Returns the current default filter mode value applied to each adapter when it appears in the system.
    /// Note that if you have not rebooted after calling SetAdaptersStartupMode, the return value is meaningless.
    ///
    /// # Returns
    ///
    /// * `Option<u32>` - Returns the current default startup mode as `Some(u32)` if the value is present in the registry,
    ///   or `None` if the value is not present or an error occurred.
    pub fn get_adapters_startup_mode(&self) -> Option<u32> {
        let mut hkey = HKEY::default();

        let mut result = unsafe {
            RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                self.get_driver_registry_key(),
                0,
                KEY_READ,
                &mut hkey,
            )
        };

        let mut value_type = REG_VALUE_TYPE::default();
        let startup_mode = 0u32;
        let mut data_size = std::mem::size_of::<u32>() as u32;

        if result.is_ok() {
            result = unsafe {
                RegQueryValueExW(
                    hkey,
                    REGSTR_STARTUP_MODE,
                    None,
                    Some(&mut value_type),
                    Some(&startup_mode as *const u32 as *mut u8),
                    Some(&mut data_size),
                )
            };
        }

        if result.is_ok() {
            Some(startup_mode)
        } else {
            None
        }
    }

    /// Sets the pool size multiplier for Windows Packet Filter driver in the Windows registry.
    ///
    /// This function creates or modifies the PoolSize value in the registry based on the
    /// given value. The appropriate registry key is selected depending on the
    /// Windows platform (NT/2000/XP or 9x/ME). The resulting internal packet pool size
    /// will be equal to 2048 (512 for Windows version before Vista) * PoolSize packets. The maximum
    /// effective PoolSize is 10.
    ///
    /// # Arguments
    ///
    /// * `pool_size: u32` - The desired pool size multiplier to be set in the registry.
    ///
    /// # Returns
    ///
    /// * `Result<()>` - If the pool size multiplier is successfully set, returns `Ok(())`.
    ///   Otherwise, returns an `Err` with the error code.
    pub fn set_pool_size(&self, pool_size: u32) -> Result<()> {
        let mut hkey = HKEY::default();

        let mut result = unsafe {
            RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                self.get_driver_registry_key(),
                0,
                KEY_WRITE,
                &mut hkey,
            )
        };

        if result.is_ok() {
            result = unsafe {
                RegSetValueExW(
                    hkey,
                    REGSTR_POOL_SIZE,
                    0,
                    REG_DWORD,
                    Some(pool_size.to_ne_bytes().as_ref()),
                )
            };
        }

        if result.is_ok() {
            Ok(())
        } else {
            Err(result.into())
        }
    }

    /// Retrieves the pool size multiplier for the Windows Packet Filter driver from the Windows registry.
    ///
    /// This function queries the registry for the PoolSize value and returns it.
    /// The appropriate registry key is used depending on the Windows platform
    /// (NT/2000/XP or 9x/ME). The internal packet pool size is determined by
    /// 2048 * PoolSize packets. The maximum effective PoolSize is 10.
    ///
    /// # Returns
    ///
    /// * `Option<u32>` - The pool size multiplier retrieved from the registry.
    ///   If the value is not found or an error occurs, returns `None`.
    pub fn get_pool_size(&self) -> Option<u32> {
        let mut hkey = HKEY::default();

        let mut result = unsafe {
            RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                self.get_driver_registry_key(),
                0,
                KEY_READ,
                &mut hkey,
            )
        };

        let mut value_type = REG_VALUE_TYPE::default();
        let pool_size = 0u32;
        let mut data_size = std::mem::size_of::<u32>() as u32;

        if result.is_ok() {
            result = unsafe {
                RegQueryValueExW(
                    hkey,
                    REGSTR_POOL_SIZE,
                    None,
                    Some(&mut value_type),
                    Some(&pool_size as *const u32 as *mut u8),
                    Some(&mut data_size),
                )
            };
        }

        if result.is_ok() {
            Some(pool_size)
        } else {
            None
        }
    }
}

```

`src/net.rs`:

```rs
/// This module provides a type for a MAC address, represented as a 6-byte array of unsigned
/// integers. It implements `Display` and `Debug` traits for displaying a MAC address in the
/// standard colon-separated format.
///
/// # Example
///
/// ```
/// use ndisapi::MacAddress;
///
/// let mac = MacAddress::from_slice(&[0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC]).unwrap();
/// assert_eq!(format!("{}", mac), "12:34:56:78:9A:BC");
/// assert_eq!(format!("{:?}", mac), "12:34:56:78:9A:BC");
/// ```
use crate::driver::ETHER_ADDR_LENGTH;
use std::fmt::{Debug, Display, Formatter, Result};

/// A MAC address represented as a 6-byte array of unsigned integers.
#[derive(Default)]
pub struct MacAddress([u8; ETHER_ADDR_LENGTH]);

impl Display for MacAddress {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        write!(
            f,
            "{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
            self.0[0], self.0[1], self.0[2], self.0[3], self.0[4], self.0[5]
        )
    }
}

impl Debug for MacAddress {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        write!(
            f,
            "{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
            self.0[0], self.0[1], self.0[2], self.0[3], self.0[4], self.0[5]
        )
    }
}

impl MacAddress {
    /// Creates a new `MacAddress` instance from a slice of bytes.
    ///
    /// # Arguments
    ///
    /// * `slice` - A slice of bytes representing a MAC address.
    ///
    /// # Returns
    ///
    /// An `Option` containing a `MacAddress` instance if the slice has a length of `ETHER_ADDR_LENGTH`
    /// bytes, `None` otherwise.
    pub fn from_slice(slice: &[u8]) -> Option<MacAddress> {
        let mut mac_address = MacAddress::default();
        if slice.len() < ETHER_ADDR_LENGTH {
            None
        } else {
            mac_address.0.copy_from_slice(slice);
            Some(mac_address)
        }
    }

    /// Returns a reference to the internal byte array of the `MacAddress` instance.
    pub fn get(&self) -> &[u8; 6] {
        &self.0
    }

    /// Returns a mutable reference to the internal byte array of the `MacAddress` instance.
    pub fn get_mut(&mut self) -> &mut [u8; 6] {
        &mut self.0
    }
}

```