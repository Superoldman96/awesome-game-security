Project Path: arc_gmh5225_Venom_lhf51ztq

Source Tree:

```txt
arc_gmh5225_Venom_lhf51ztq
├── CHANGELOG.md
├── CONTRIBUTING.md
├── Docs.md
├── LICENSE
├── README.md
├── SECURITY.md
├── Update.md
├── docs
│   └── getting-started
│       ├── basic-functions.md
│       ├── creating-client.md
│       └── installation.md
├── examples
│   └── screenshot
│       ├── README.md
│       ├── index.js
│       └── package.json
├── package.json
├── src
│   ├── api
│   │   ├── helpers
│   │   │   ├── base64-mimetype.ts
│   │   │   ├── callback-wile.ts
│   │   │   ├── check-token-file.ts
│   │   │   ├── closes-browser.ts
│   │   │   ├── decrypt.ts
│   │   │   ├── delete-file.ts
│   │   │   ├── dowload-meta.ts
│   │   │   ├── download-file.ts
│   │   │   ├── exposed.enum.ts
│   │   │   ├── file-to-base64.ts
│   │   │   ├── filename-from-mimetype.ts
│   │   │   ├── force-connect.ts
│   │   │   ├── index.ts
│   │   │   ├── layers-interface.ts
│   │   │   ├── scrape-deletetoken.ts
│   │   │   ├── scrape-desconnect.ts
│   │   │   ├── scrape-img-qr.ts
│   │   │   ├── scrape-login.ts
│   │   │   ├── select-sticker.ts
│   │   │   └── sleep.ts
│   │   ├── inject
│   │   │   └── webpack.ts
│   │   ├── layers
│   │   │   ├── README.md
│   │   │   ├── business.layer.ts
│   │   │   ├── callback-on.layes.ts
│   │   │   ├── controls.layer.ts
│   │   │   ├── group.layer.ts
│   │   │   ├── host.layer.ts
│   │   │   ├── index.ts
│   │   │   ├── listener.layer.ts
│   │   │   ├── profile.layer.ts
│   │   │   ├── retriever.layer.ts
│   │   │   ├── sender.layer.ts
│   │   │   └── ui.layer.ts
│   │   ├── model
│   │   │   ├── Interface-mode.ts
│   │   │   ├── ack.ts
│   │   │   ├── chat-status.ts
│   │   │   ├── chat.ts
│   │   │   ├── contact-status.ts
│   │   │   ├── contact.ts
│   │   │   ├── enum
│   │   │   │   ├── ack-type.ts
│   │   │   │   ├── chat-state.ts
│   │   │   │   ├── definitions.ts
│   │   │   │   ├── group-change-event.ts
│   │   │   │   ├── group-notification-type.ts
│   │   │   │   ├── group-settings.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── interface-mode.ts
│   │   │   │   ├── interface-state.ts
│   │   │   │   ├── message-type.ts
│   │   │   │   ├── mode.enum.ts
│   │   │   │   └── socket-state.ts
│   │   │   ├── group-creation.ts
│   │   │   ├── group-metadata.ts
│   │   │   ├── host-device.ts
│   │   │   ├── id.ts
│   │   │   ├── index.ts
│   │   │   ├── live-location.ts
│   │   │   ├── message.ts
│   │   │   ├── partial-message.ts
│   │   │   ├── participant-event.ts
│   │   │   ├── pic-thumb.ts
│   │   │   ├── qrcode.ts
│   │   │   ├── result.ts
│   │   │   └── whatsapp-profile.ts
│   │   └── whatsapp.ts
│   ├── config
│   │   ├── WAuserAgente.ts
│   │   ├── create-config.ts
│   │   ├── index.ts
│   │   ├── options.ts
│   │   └── puppeteer.config.ts
│   ├── controllers
│   │   ├── auth.ts
│   │   ├── browser.ts
│   │   ├── check-up-to-date.ts
│   │   ├── init.ts
│   │   ├── initializer.ts
│   │   └── welcome.ts
│   ├── index.ts
│   ├── lib
│   │   ├── README.md
│   │   ├── counter
│   │   │   ├── Counter.js
│   │   │   └── gulpfile.js
│   │   ├── middleware
│   │   │   ├── middleware.ts
│   │   │   ├── tsconfig.json
│   │   │   └── webpack.config.js
│   │   ├── middleware.js
│   │   └── wapi
│   │       ├── api.js
│   │       ├── business
│   │       │   ├── get-business-profiles-products.js
│   │       │   ├── send-message-with-buttons.js
│   │       │   └── send-payment-request.js
│   │       ├── functions
│   │       │   ├── add-chat-wapi.js
│   │       │   ├── add-participant.js
│   │       │   ├── archive-chat.js
│   │       │   ├── are-all-messages-loaded.js
│   │       │   ├── block-contact.js
│   │       │   ├── block-list.js
│   │       │   ├── check-beta.js
│   │       │   ├── check-chat.js
│   │       │   ├── check-id-messagem.js
│   │       │   ├── check-number-status.js
│   │       │   ├── check-send-exist.js
│   │       │   ├── clear-chat.js
│   │       │   ├── create-community.js
│   │       │   ├── create-group.js
│   │       │   ├── delete-all-message.js
│   │       │   ├── delete-conversation.js
│   │       │   ├── delete-messages-all.js
│   │       │   ├── delete-messages-me.js
│   │       │   ├── delete-messages.js
│   │       │   ├── demote-participant.js
│   │       │   ├── download-file-with-credentials.js
│   │       │   ├── download-media.js
│   │       │   ├── encrypt-and-upload-file.js
│   │       │   ├── fix-chat.js
│   │       │   ├── forward-messages.js
│   │       │   ├── get-all-chats-ids.js
│   │       │   ├── get-all-chats-with-messages.js
│   │       │   ├── get-all-chats.js
│   │       │   ├── get-all-contacts.js
│   │       │   ├── get-all-group-metadata.js
│   │       │   ├── get-all-groups.js
│   │       │   ├── get-all-messages-in-chat.js
│   │       │   ├── get-all-new-messages.js
│   │       │   ├── get-battery-level.js
│   │       │   ├── get-chat-by-id.js
│   │       │   ├── get-chat-by-name.js
│   │       │   ├── get-chat.js
│   │       │   ├── get-common-groups.js
│   │       │   ├── get-contact.js
│   │       │   ├── get-data-messages.js
│   │       │   ├── get-group-admins.js
│   │       │   ├── get-group-info-from-invite-link.js
│   │       │   ├── get-group-invite-link.js
│   │       │   ├── get-group-metadata.js
│   │       │   ├── get-group-participant-ids.js
│   │       │   ├── get-group-participant.js
│   │       │   ├── get-group-participants.js
│   │       │   ├── get-host.js
│   │       │   ├── get-list-mute.js
│   │       │   ├── get-me.js
│   │       │   ├── get-message-by-id.js
│   │       │   ├── get-my-contacts.js
│   │       │   ├── get-new-id.js
│   │       │   ├── get-new-message-id.js
│   │       │   ├── get-number-profile.js
│   │       │   ├── get-profile-pic-from-server.js
│   │       │   ├── get-session-token.js
│   │       │   ├── get-state-connection.js
│   │       │   ├── get-status.js
│   │       │   ├── get-unread-messages-in-chat.js
│   │       │   ├── get-unread-messages.js
│   │       │   ├── help
│   │       │   │   ├── add-chat-wapi.js
│   │       │   │   ├── check-number-status.js
│   │       │   │   ├── filter-object.js
│   │       │   │   ├── get-chat.js
│   │       │   │   ├── get-mew-id.js
│   │       │   │   ├── get-new-message.js
│   │       │   │   ├── index.js
│   │       │   │   ├── is-md.js
│   │       │   │   ├── scope.js
│   │       │   │   ├── send-check-type.js
│   │       │   │   └── send-exist.js
│   │       │   ├── index.js
│   │       │   ├── is-connected.js
│   │       │   ├── is-logged-in.js
│   │       │   ├── join-group.js
│   │       │   ├── kill-service-worker.js
│   │       │   ├── leave-group.js
│   │       │   ├── load-all-earlier-chat-messages.js
│   │       │   ├── load-and-get-all-messages-in-chat.js
│   │       │   ├── load-earlier-chat-messages.js
│   │       │   ├── load-earlier-messages-til-date.js
│   │       │   ├── logout.js
│   │       │   ├── mark-markSeen-message.js
│   │       │   ├── mark-unseen-message.js
│   │       │   ├── only-send-admin.js
│   │       │   ├── only-send-data-admin.js
│   │       │   ├── open-chat.js
│   │       │   ├── pin.chat.js
│   │       │   ├── poll-creation.js
│   │       │   ├── process-files.js
│   │       │   ├── process-message-object.js
│   │       │   ├── promote-participant.js
│   │       │   ├── remove-participant.js
│   │       │   ├── reply.js
│   │       │   ├── restart-service.js
│   │       │   ├── return-reply.js
│   │       │   ├── revoke-invite-link.js
│   │       │   ├── send-buttons.js
│   │       │   ├── send-chat-state.js
│   │       │   ├── send-contact-vcard-list.js
│   │       │   ├── send-contact-vcard.js
│   │       │   ├── send-file.js
│   │       │   ├── send-image-as-stricker.js
│   │       │   ├── send-image-with-product.js
│   │       │   ├── send-image.js
│   │       │   ├── send-link-preview.js
│   │       │   ├── send-list-menu.js
│   │       │   ├── send-location.js
│   │       │   ├── send-message-scope.js
│   │       │   ├── send-message-with-tags.js
│   │       │   ├── send-message-with-thumb.js
│   │       │   ├── send-message.js
│   │       │   ├── send-message2.js
│   │       │   ├── send-mute.js
│   │       │   ├── send-ptt.js
│   │       │   ├── send-query-message-info.js
│   │       │   ├── send-reactions.js
│   │       │   ├── send-seen.js
│   │       │   ├── send-sticker.js
│   │       │   ├── send-type-buttons.js
│   │       │   ├── send-video-as-gif.js
│   │       │   ├── sendMessageOptions.js
│   │       │   ├── set-group-description.js
│   │       │   ├── set-group-image.js
│   │       │   ├── set-group-settings.js
│   │       │   ├── set-group-title.js
│   │       │   ├── set-my-name.js
│   │       │   ├── set-my-status.js
│   │       │   ├── set-new-message.js
│   │       │   ├── set-presence-offline.js
│   │       │   ├── set-presence-online.js
│   │       │   ├── set-profile-pic.js
│   │       │   ├── simulate-status-chat.js
│   │       │   ├── simulate-typing.js
│   │       │   ├── test.js
│   │       │   ├── theme.js
│   │       │   └── unblock-contact.js
│   │       ├── globals.d.ts
│   │       ├── help
│   │       │   ├── array-buffer-to-base64.js
│   │       │   ├── base64ToFile.js
│   │       │   ├── encrypt-and-upload-file.js
│   │       │   ├── filter-module.js
│   │       │   ├── filter-object.js
│   │       │   ├── generate-media-key.js
│   │       │   ├── get-file-hash.js
│   │       │   ├── index.js
│   │       │   ├── inject-config.js
│   │       │   ├── inject-paresite.js
│   │       │   ├── process-files.js
│   │       │   └── sleep.js
│   │       ├── helper
│   │       │   ├── array-buffer-to-base64.js
│   │       │   ├── base64-to-file.js
│   │       │   ├── filter-module.js
│   │       │   ├── filter-object.js
│   │       │   ├── generate-media-key.js
│   │       │   ├── get-file-hash.js
│   │       │   ├── index.js
│   │       │   ├── inject-config.js
│   │       │   ├── is-chat-message.js
│   │       │   └── sleep.js
│   │       ├── jsconfig.json
│   │       ├── jssha
│   │       │   └── index.js
│   │       ├── listeners
│   │       │   ├── add-all-new-messages.js
│   │       │   ├── add-new-messages.js
│   │       │   ├── add-on-added-to-group.js
│   │       │   ├── add-on-chatstate-change.js
│   │       │   ├── add-on-live-location.js
│   │       │   ├── add-on-new-ack.js
│   │       │   ├── add-on-participants-change.js
│   │       │   ├── add-on-pictumb-change.js
│   │       │   ├── add-on-poll.js
│   │       │   ├── add-on-state-change.js
│   │       │   ├── add-on-stream.js
│   │       │   ├── add-unread-message.js
│   │       │   ├── index.js
│   │       │   ├── init-common-listener.js
│   │       │   └── init-listeners.js
│   │       ├── serialize
│   │       │   ├── index.js
│   │       │   ├── serialize-chat.js
│   │       │   ├── serialize-contact.js
│   │       │   ├── serialize-message.js
│   │       │   ├── serialize-profile-pic-thumb.js
│   │       │   ├── serialize-raw.js
│   │       │   └── serielize-me.js
│   │       ├── serializers
│   │       │   ├── index.js
│   │       │   ├── serialize-chat.js
│   │       │   ├── serialize-contact.js
│   │       │   ├── serialize-forcing.js
│   │       │   ├── serialize-message.js
│   │       │   ├── serialize-profile-pic-thumb.js
│   │       │   ├── serialize-raw.js
│   │       │   ├── serializeNumberStatusObj.js
│   │       │   └── serielize-me.js
│   │       ├── store
│   │       │   ├── get-store.js
│   │       │   └── store-objects.js
│   │       ├── wapi.js
│   │       ├── webpack.config.cjs
│   │       └── webpack.config.js
│   ├── types
│   │   ├── WAPI.d.ts
│   │   └── spinnies.d.ts
│   └── utils
│       ├── semver.ts
│       ├── sleep.ts
│       └── spinnies.ts
├── test
│   └── index.js
├── tsconfig.json
└── typedoc.json

```

`CHANGELOG.md`:

```md
## [5.0.17](https://github.com/orkestral/venom/compare/v5.0.16...v5.0.17) (2023-08-11)


### Bug Fixes

* chromium version ([e692b48](https://github.com/orkestral/venom/commit/e692b4804e53604bdf33d8e2a86efc378c66f36d))
* error r.findImpl is not function ([9c7d5f3](https://github.com/orkestral/venom/commit/9c7d5f35f15849c11a5c732b678f238e4b801fee))
* QRCode Scan terminal ([33d8d50](https://github.com/orkestral/venom/commit/33d8d50e2366e17e64347f472c995d99a5bb0909))


### Features

* remove npm publish ([ce117a7](https://github.com/orkestral/venom/commit/ce117a7104a71b5dd2c63e1169bf7ce43677a8b5))
* set timeout page ([817945f](https://github.com/orkestral/venom/commit/817945f256effca3cf831a75f757aa2865f307e5))



## [5.0.16](https://github.com/orkestral/venom/compare/v5.0.15...v5.0.16) (2023-08-03)


### Bug Fixes

* npm install ([e6eccd6](https://github.com/orkestral/venom/commit/e6eccd6817fc9c3b7a8fffeacc33e7d3918d4656))
* tsconfig.json ([1a98b89](https://github.com/orkestral/venom/commit/1a98b89e8b336f103c5dbd4fb27113ce72f2ff5b))



## [5.0.15](https://github.com/orkestral/venom/compare/v5.0.14...v5.0.15) (2023-08-03)


### Bug Fixes

* is-admin ([3d47967](https://github.com/orkestral/venom/commit/3d479674a0bb0301f4d3673ce1a0a98cda57e6a9))



## [5.0.14](https://github.com/orkestral/venom/compare/v5.0.13...v5.0.14) (2023-08-01)


### Bug Fixes

* add `npm-check-updates` as dependencies ([3ba733f](https://github.com/orkestral/venom/commit/3ba733f9da96c6a1ed6600a3fa2d3c20d018e37c))
* add argsRoot ([089db66](https://github.com/orkestral/venom/commit/089db66d4f9a4d8638dc071571d4c451aa2b8c72))
* remove npm ci ([8db4b93](https://github.com/orkestral/venom/commit/8db4b934ed83b1c9602e7915e7e2af035f32db0c))



## [5.0.13](https://github.com/orkestral/venom/compare/v5.0.12...v5.0.13) (2023-07-23)


### Bug Fixes

* Error removing SingletonLock ([fd6b316](https://github.com/orkestral/venom/commit/fd6b316e1e1dd7462cbbba9eb4080875d6613759))
* in NPM ([dc52d4a](https://github.com/orkestral/venom/commit/dc52d4a28cbd74d312cd43aa0d96bba8d9038c81))
* npm check updates ([68aa57c](https://github.com/orkestral/venom/commit/68aa57c85aad56773e9ff2769e8362241a58ee9a))



## [5.0.12](https://github.com/orkestral/venom/compare/v5.0.11...v5.0.12) (2023-07-21)


### Bug Fixes

* browser does not open when there are token files ([77909a5](https://github.com/orkestral/venom/commit/77909a54ca5d07a8e9b5d19ed416d8dd493d85ed))
* Check if version exists ([8348640](https://github.com/orkestral/venom/commit/8348640973417df3056755c5ec8821f30f288fcc))
* Chrome path darwin ([2b434c2](https://github.com/orkestral/venom/commit/2b434c24227dc95a54521d585e20849c92a35c0a))
* sendLinkPreview interim ([d66b4f8](https://github.com/orkestral/venom/commit/d66b4f80cc374da7316200830a7e91478b3d5f45))


### Features

* add errors and promise to SingletonLock ([25b3fa8](https://github.com/orkestral/venom/commit/25b3fa8e6b40e7841e8381f2ec65f4aaa45a7688))
* Apply Bug Fixes and Features ([32a36a5](https://github.com/orkestral/venom/commit/32a36a540caab689ed3304c278c08d58aedf486d))
* browser executable path ([451dbfa](https://github.com/orkestral/venom/commit/451dbfab5f3bc74a8ce4393cbf4349b20ea56713))
* chrome Version bash ([bb76bb2](https://github.com/orkestral/venom/commit/bb76bb22892844d5091f8827f7d5d5fde458681d))
* downloadBash linux and darwin ([d4914b4](https://github.com/orkestral/venom/commit/d4914b4c8387ba400c6e649aa6aaf59ebcf8ea74))
* get version: headless ([e04f2d4](https://github.com/orkestral/venom/commit/e04f2d4b492c42f59abf0024040a3946e2c5ffce))
* release headless: true ([dc90954](https://github.com/orkestral/venom/commit/dc90954773a3b248d2e4064feffe8d6c3a53cef7))



## [5.0.11](https://github.com/orkestral/venom/compare/v5.0.7...v5.0.11) (2023-07-03)


### Bug Fixes

* getAllContacts ([4f98590](https://github.com/orkestral/venom/commit/4f9859066add6dbd5ebc9ba39fcde0da2f078225))
* Group Link ([98ade84](https://github.com/orkestral/venom/commit/98ade8416b326b467ff50c3ee5f874ac03d0fab6))
* Query Group Store ([5a44a29](https://github.com/orkestral/venom/commit/5a44a29bedf2ce97d23e642ae1e4a533891c231b))
* remove createWid ([5e8da45](https://github.com/orkestral/venom/commit/5e8da457315497b258c3cccc38560e8105b1c3ac))


### Features

* dowload ([e1ef845](https://github.com/orkestral/venom/commit/e1ef8456d56fa7372f524ba4f35d9c28450f11e4))
* download Chrome ([777cd44](https://github.com/orkestral/venom/commit/777cd4459c7f861955873a3727b9e2e8a1a06d42))
* getChrome ([8b98eba](https://github.com/orkestral/venom/commit/8b98eba3e4018297cb2d50ff574580cba7ff8c9f))
* refactoring chrome download ([4623eed](https://github.com/orkestral/venom/commit/4623eedbdb39a9e30aeb75324d3eae245b8111a8))



## [5.0.7](https://github.com/orkestral/venom/compare/v5.0.6...v5.0.7) (2023-06-19)


### Bug Fixes

* session name ([5db179c](https://github.com/orkestral/venom/commit/5db179c2ef601f440e6519c99d1d619d5638ab2c))


### Features

* Create Release versions ([bf14b48](https://github.com/orkestral/venom/commit/bf14b481e2f9b2f69703773c2f6b845123087551))
* headless =  "new" |  false https://developer.chrome.com/articles/new-headless/ ([b2d0610](https://github.com/orkestral/venom/commit/b2d0610762ce4f4373ca7ae64a034e1f31064805))



## [5.0.6](https://github.com/orkestral/venom/compare/v5.0.5...v5.0.6) (2023-06-19)


### Bug Fixes

* Environment Files ([08f9812](https://github.com/orkestral/venom/commit/08f98127c04a243e6e1d241bef9b19392af1f2b9))
* latest-version ([e77e790](https://github.com/orkestral/venom/commit/e77e7900aed827f9342ed19ebd80dd7f1089636e))
* required Node Version ([4751ac4](https://github.com/orkestral/venom/commit/4751ac4c56357bf4a6c67bb68f4e1c731317fa14))



## [5.0.5](https://github.com/orkestral/venom/compare/v5.0.4...v5.0.5) (2023-06-16)


### Bug Fixes

* main and types ([ded9fd6](https://github.com/orkestral/venom/commit/ded9fd69c3c8918946819488fa70d10af84ce6da))


### Features

* add routine Update Package Version ([f3160b1](https://github.com/orkestral/venom/commit/f3160b1914c98663c998d3407068454691ab71f3))



## [5.0.4](https://github.com/orkestral/venom/compare/v5.0.3...v5.0.4) (2023-06-16)


### Bug Fixes

* ci dependencies ([6902d7d](https://github.com/orkestral/venom/commit/6902d7d6691927176e3cab0c4ff812d5e2750a58))
* wait For Objects webpack ([6c22540](https://github.com/orkestral/venom/commit/6c225408ceb43beef43bfa4cae64754edf5bad68))



## [5.0.1](https://github.com/orkestral/venom/compare/v5.0.0...v5.0.1) (2023-05-05)


### Bug Fixes

* eslintrc.cjs ([59ee984](https://github.com/orkestral/venom/commit/59ee98427c99cab569c394b1475f274e753955d0))
* sendListMenu for Bussines contacts ([262eaaa](https://github.com/orkestral/venom/commit/262eaaa6ba5f50e8e335a1a0af1f50d2dd703c5b))
* temporary sendLinkPreview ([059df92](https://github.com/orkestral/venom/commit/059df928b9013ae0d7c56bff56f0da673c6a9d42))


### Features

* remove useChrome ([a1850b4](https://github.com/orkestral/venom/commit/a1850b4a9dc4c1a22e593af47986eac916f7cc9f))
* removing multi device option ([4564c24](https://github.com/orkestral/venom/commit/4564c246347074bd1f625b2f6bede62d7ac89d19))
* update puppeteer ([459a2ea](https://github.com/orkestral/venom/commit/459a2eaa5746133d06314d3c67b1245b05d963f7))



# [5.0.0](https://github.com/orkestral/venom/compare/v4.3.7...v5.0.0) (2023-04-12)


### Bug Fixes

* all functions ([dbbee0e](https://github.com/orkestral/venom/commit/dbbee0ebc7f89eece8ed2953768e2ec4b6bd0e28))
* lint! ([f25bc41](https://github.com/orkestral/venom/commit/f25bc41994f72e933bd72dfc588bd972f91f1542))
* lint? ([46c6cae](https://github.com/orkestral/venom/commit/46c6cae046d503bf52dcc95f69c5a850a738c665))
* yml ([c167d83](https://github.com/orkestral/venom/commit/c167d832232e1412cc0a4f12bf8efa1b4e214545))


### Features

* checkUpdates ([c90a155](https://github.com/orkestral/venom/commit/c90a1557370121fbd8ae68cc09799ef3d13d7309))
* ECMAScript ([05b1854](https://github.com/orkestral/venom/commit/05b1854fd66d428d329cc79892887443a3bda588))
* workflows ([4ac92fd](https://github.com/orkestral/venom/commit/4ac92fdd0896764137bc8936444c194fe5c92484))



## [4.3.7](https://github.com/orkestral/venom/compare/v4.3.6...v4.3.7) (2022-12-01)



## [4.3.6](https://github.com/orkestral/venom/compare/v4.3.4...v4.3.6) (2022-11-24)



## [4.3.4](https://github.com/orkestral/venom/compare/v4.3.3...v4.3.4) (2022-11-18)



## [4.3.3](https://github.com/orkestral/venom/compare/v4.3.2...v4.3.3) (2022-11-08)



## [4.3.2](https://github.com/orkestral/venom/compare/v4.3.1...v4.3.2) (2022-11-08)



## [4.3.1](https://github.com/orkestral/venom/compare/v4.3.0...v4.3.1) (2022-11-07)


### Bug Fixes

* alterado ordem de inicialização ([f782610](https://github.com/orkestral/venom/commit/f7826106b05b361123fe6c8f724408dab68d22df))
* getAllUnreadMessages ack incorreto ([c39c3a0](https://github.com/orkestral/venom/commit/c39c3a09d8e41413512ea35f6f958b80e9cd4d30))
* loadAllEarlierMessages e retorno da loadAndGetAllMessagesInChat ([4e2a198](https://github.com/orkestral/venom/commit/4e2a198109677df4be10a82ed99cfca8d4230f10))



# [4.3.0](https://github.com/orkestral/venom/compare/v4.2.3...v4.3.0) (2022-08-15)



## [4.2.3](https://github.com/orkestral/venom/compare/v4.2.2...v4.2.3) (2022-08-08)



## [4.2.2](https://github.com/orkestral/venom/compare/v4.2.1...v4.2.2) (2022-08-08)



## [4.2.1](https://github.com/orkestral/venom/compare/v4.2.0...v4.2.1) (2022-08-08)


### Bug Fixes

* e.isLid is not a function ([88209cf](https://github.com/orkestral/venom/commit/88209cf86d706935bb5f59884097959bd32385e0))
* queryExists ([267372a](https://github.com/orkestral/venom/commit/267372a7fa6183298965644983c3978521bb0fb9))



# [4.2.0](https://github.com/orkestral/venom/compare/v4.1.0...v4.2.0) (2022-06-09)


### Bug Fixes

* **wapi:** fix sendFile function issue [#1718](https://github.com/orkestral/venom/issues/1718) ([ed89eb7](https://github.com/orkestral/venom/commit/ed89eb797b78c884898a49d23d33691ee3cb6eb2))
* Bug Fix send message with media


# [4.1.0](https://github.com/orkestral/venom/compare/v4.0.11...v4.1.0) (2022-06-02)

### Features

* Bug Fix e.isUser
* Change target TS

## [4.0.11](https://github.com/orkestral/venom/compare/v4.0.10...v4.0.11) (2022-04-27)


### Features

* addBrowserArgs ([6541669](https://github.com/orkestral/venom/commit/654166943f8d256a07fc1163c49681c16a783a65))
* statusFind ([7ee608d](https://github.com/orkestral/venom/commit/7ee608d20595146e4287635f3844db403a08b17f))



## [4.0.10](https://github.com/orkestral/venom/compare/v4.0.9...v4.0.10) (2022-04-18)


### Bug Fixes

* lint ([890d7b3](https://github.com/orkestral/venom/commit/890d7b37a8a571794d46c0c7b1a857ca48f045c0))
* module Cmd is now a class, no longer exported in the `default` key ([b21b11f](https://github.com/orkestral/venom/commit/b21b11f53261d50735782d3d73cea1d639dfaedd))
* sendLinkPreview ([d00634a](https://github.com/orkestral/venom/commit/d00634a5b44adc47517708bc22c220576b269ec8))
* sendLocation ([921e2f0](https://github.com/orkestral/venom/commit/921e2f016f55522ba49e51563a21f09dfa13ec52))
* type definition and code expect a promise from isBeta ([b7b9ccb](https://github.com/orkestral/venom/commit/b7b9ccb5156a83027ab028a71e4f0a81996d8ec3))
* **wapi:** sendMessage function throw exception on invalid object ([4332fce](https://github.com/orkestral/venom/commit/4332fce89820a287921708e361990caf4ea903fb))


### Features

* device ([21d4173](https://github.com/orkestral/venom/commit/21d4173e785cb2228dbd40854561485491926819))
* remove mandatory descrition sendList ([0098594](https://github.com/orkestral/venom/commit/0098594df2695596cd2ec30c5cf8611b848129ab))



## [4.0.9](https://github.com/orkestral/venom/compare/v4.0.8...v4.0.9) (2022-03-10)


### Bug Fixes

* add queryExists ([bdea56c](https://github.com/orkestral/venom/commit/bdea56c2b2cb7e246e2a8614eaad3fd260868bad))
* lint ([9bfbead](https://github.com/orkestral/venom/commit/9bfbead2009d617600261f804f0939bb8d7dd921))



## [4.0.8](https://github.com/orkestral/venom/compare/v4.0.7...v4.0.8) (2022-03-10)


### Bug Fixes

* checkNumber ([d0515e7](https://github.com/orkestral/venom/commit/d0515e79db9da39f881c6fc7ef8561187524cd9d))



## [4.0.7](https://github.com/orkestral/venom/compare/v4.0.6...v4.0.7) (2022-03-01)


### Bug Fixes

* Socket ([bca8283](https://github.com/orkestral/venom/commit/bca8283323fdd92274637a92ddb8c94748e21c69))
* Stream and State ([b71e032](https://github.com/orkestral/venom/commit/b71e032610d0e2935d1b5f8d0a926538b3c97ab6))


### Features

* forcing injectApi ([f5404ba](https://github.com/orkestral/venom/commit/f5404ba93ab258664b88ca46dc3702bd9e32fef6))
* typedoc ([9ca17ec](https://github.com/orkestral/venom/commit/9ca17ec34780ed1811217f1ffde70f4d2a3c2889))
* webpack sleep ([ec89f4e](https://github.com/orkestral/venom/commit/ec89f4e9114aff587153f5e170cecc5bb801e267))



## [4.0.6](https://github.com/orkestral/venom/compare/v4.0.5...v4.0.6) (2022-02-23)


### Bug Fixes

* checkNumber ([0a20479](https://github.com/orkestral/venom/commit/0a204796998d547da7a3395dcf1985a05edf0935))
* Product ([d17d3a3](https://github.com/orkestral/venom/commit/d17d3a3ee1597c44749e0cb3173f7f977302782f))
* sendSticker ([557d1ae](https://github.com/orkestral/venom/commit/557d1ae8b07597d16a77a1a3c27de24240c85685))


### Features

* typedoc ([977eb8d](https://github.com/orkestral/venom/commit/977eb8d954956b46c43149de7c6ce1ee4ab16d0b))



## [4.0.5](https://github.com/orkestral/venom/compare/v4.0.4...v4.0.5) (2022-01-15)


### Bug Fixes

* logout ([ee6b6c3](https://github.com/orkestral/venom/commit/ee6b6c33ed2a1bccda588af5f08b156139c9dd41))
* MessageObj ([deae0e9](https://github.com/orkestral/venom/commit/deae0e9b15b5385572ec32c56d5252f54f3b5ad8))


### Features

* addProxy ([22f9f01](https://github.com/orkestral/venom/commit/22f9f01866dc90d0d682500f97116e4e148efe5f))
* readme ([ab0ff66](https://github.com/orkestral/venom/commit/ab0ff6667b7c127a2e39246c822e65c006118235))



## [4.0.4](https://github.com/orkestral/venom/compare/v4.0.3...v4.0.4) (2021-12-19)


### Bug Fixes

* changed _quotedMsgObj to quotedMsg ([288b65a](https://github.com/orkestral/venom/commit/288b65a6064ef4d0f047004b7fe89e7348244213))
* logout ([8f08abb](https://github.com/orkestral/venom/commit/8f08abbc2ed9414c9c7d71862d0bc0666eab52eb))
* sendContactVcard ([d4a4700](https://github.com/orkestral/venom/commit/d4a4700557f1bbf632ba5f70a86477f146462fc6))
* sendLinkPreview ([de3b0a7](https://github.com/orkestral/venom/commit/de3b0a71fc2a0ac0786c935c7599b8881a993430))
* setProfilePic ([ddc8184](https://github.com/orkestral/venom/commit/ddc81844c5fb76be3ece25d715bd032ed07fa36e))
* sticker ([6506d40](https://github.com/orkestral/venom/commit/6506d408863f740afc03e5325fb79345c7803960))
* Store.State ([54dcd8e](https://github.com/orkestral/venom/commit/54dcd8e14c1895d7a45f8fd257118ddce03eccc1))


### Features

* checkNumber ([a2708e5](https://github.com/orkestral/venom/commit/a2708e5c559366a9395bff7b7ce76d9d3f0fc850))
* checkNumberStatus ([15e8224](https://github.com/orkestral/venom/commit/15e822496b96f12187446db615ed9502b0b2bbaf))
* multidevice and chromiumVersion ([4f8fe94](https://github.com/orkestral/venom/commit/4f8fe94b9ade9e6e291c5864ddbb97a9347a2531))
* SerializeMeObj ([5d72a61](https://github.com/orkestral/venom/commit/5d72a61c4782009f19dd841ac5191a0e3a001721))
* test typedoc ([5e4007f](https://github.com/orkestral/venom/commit/5e4007fd338c306d51d07e5b7c9028ef5610ff1c))
* typedoc ([bb58502](https://github.com/orkestral/venom/commit/bb58502f747a023eb884fabdf3c1a6a54c0484e9))
* update puppeteer ([b8ca6b6](https://github.com/orkestral/venom/commit/b8ca6b633a77c4e14535083586a46a58bfa6d777))



## [4.0.3](https://github.com/orkestral/venom/compare/v4.0.2...v4.0.3) (2021-11-24)


### Bug Fixes

* get host ([0e055ae](https://github.com/orkestral/venom/commit/0e055aeda0c55279ca9278a8b618be44b672282a))
* get me and State ([c1fac1b](https://github.com/orkestral/venom/commit/c1fac1b000f7277a680bcebfc04aed457e718305))
* getNumberProfile ([cd62707](https://github.com/orkestral/venom/commit/cd62707d2bfe55c45e164fba1e1852198f2b7200))


### Features

* readme ([6d48b4e](https://github.com/orkestral/venom/commit/6d48b4e8f522acf4ce22682d7db15b61fc6059e2))



## [4.0.2](https://github.com/orkestral/venom/compare/v4.0.1...v4.0.2) (2021-11-17)


### Bug Fixes

* checkNumber ([42e631e](https://github.com/orkestral/venom/commit/42e631ebcbcd5baccedec31f37512773c77b186e))
* eslint ([7a91719](https://github.com/orkestral/venom/commit/7a91719ec6b0a414c33cc176063778fe0597bab8))
* eslint ([5779d62](https://github.com/orkestral/venom/commit/5779d62a44fe90be72417a3037e14a7d24ac242a))
* send ([f1a6289](https://github.com/orkestral/venom/commit/f1a6289af68449ea2d0fca476dab8c2cb12057b0))
* Send with more digits ([14e2fea](https://github.com/orkestral/venom/commit/14e2fea6fe6b066ce6a793b7894c1d8955b15792))
* webpack ([dc6e5db](https://github.com/orkestral/venom/commit/dc6e5db8380a0bd0b2f56d4f1e4a9c88d6f7ab66))



## [4.0.1](https://github.com/orkestral/venom/compare/v4.0.0...v4.0.1) (2021-11-08)


### Bug Fixes

* corretion for not multidevice version ([782fea4](https://github.com/orkestral/venom/commit/782fea4b1c664e4d96c664545eba2cdfe700c9c1))
* corretion for version not multidevice ([e4d9c37](https://github.com/orkestral/venom/commit/e4d9c37cc5ee4b42db575a9145180f4134c49245))
* eslint ([77a670b](https://github.com/orkestral/venom/commit/77a670b123fad100644705394c34750530a3d192))
* readme param MD ([96c3163](https://github.com/orkestral/venom/commit/96c31630485c789a59d3d5e93314280b8f77ebcc))



# [4.0.0](https://github.com/orkestral/venom/compare/v3.1.12...v4.0.0) (2021-11-08)



## [3.1.12](https://github.com/orkestral/venom/compare/v3.1.11...v3.1.12) (2021-10-28)


### Bug Fixes

* Error connect ([e15a018](https://github.com/orkestral/venom/commit/e15a018486a36edc510b57ca5206f38c639bf053))



## [3.1.11](https://github.com/orkestral/venom/compare/v3.1.10...v3.1.11) (2021-10-24)



## [3.1.10](https://github.com/orkestral/venom/compare/v3.1.9...v3.1.10) (2021-10-24)


### Bug Fixes

* body ([242df0b](https://github.com/orkestral/venom/commit/242df0be835708c772758fe8edae28cd74ee04e9))


### Features

* Add text option to the message with thumb method ([edddc3c](https://github.com/orkestral/venom/commit/edddc3cd85995c9c8ad734e3b0be2a422eb1ae17))



## [3.1.9](https://github.com/orkestral/venom/compare/v3.1.8...v3.1.9) (2021-10-23)


### Bug Fixes

* deleteMessage ([1ae12b1](https://github.com/orkestral/venom/commit/1ae12b134aec9620c83859db94389c778a6886d3))
* get profile ([642aedc](https://github.com/orkestral/venom/commit/642aedcf3ccc0517df1e12d0f27cbe8eb1a09121))
* onAnyMessage ([ba96f80](https://github.com/orkestral/venom/commit/ba96f80790c3eb23d115ed3277f0bf1bcdcd3d4a))
* send group ([58b46d6](https://github.com/orkestral/venom/commit/58b46d60aa8f058cdee4484e5e1a7a030bce464f))



## [3.1.8](https://github.com/orkestral/venom/compare/v3.1.7...v3.1.8) (2021-10-06)


### Bug Fixes

* lint ([7a0f465](https://github.com/orkestral/venom/commit/7a0f465094b037e530b4628b01657d45bb90bdbf))
* lint ([83a8df9](https://github.com/orkestral/venom/commit/83a8df985fa79c03b9cc6bc9ff6c5586cd53ec58))
* lint -  fix-reply ([423c844](https://github.com/orkestral/venom/commit/423c84440dea92f631ec3079dd21a8970773a3b4))


### Features

*  checkNumber - state ([d617640](https://github.com/orkestral/venom/commit/d6176405aead74a2d734f0a7f7a21d17e49bb7a5))
* get profile connection ([b57455e](https://github.com/orkestral/venom/commit/b57455e2b80882f4735571d5ff69a89c80fac8b3))
* getHostDevice ([b342e23](https://github.com/orkestral/venom/commit/b342e2384f67aa0266a97ab137967efa11de582c))
* sendCheckType ([dd10fea](https://github.com/orkestral/venom/commit/dd10feab37247b351ce5fcf6ee14335eceb9df97))



## [3.1.7](https://github.com/orkestral/venom/compare/v3.1.6...v3.1.7) (2021-09-24)


### Bug Fixes

* Chat find ([00918f0](https://github.com/orkestral/venom/commit/00918f0c89e0226555df4eeefb9e16f1b36b3f70))
* lint ([35a1c4a](https://github.com/orkestral/venom/commit/35a1c4ad38b1326cd1951689d4a22d530017ce0a))
* statusFind ([80b5a77](https://github.com/orkestral/venom/commit/80b5a774d9f77002b405555071d162076af91849))


### Features

* checkChat ([ca4c1ba](https://github.com/orkestral/venom/commit/ca4c1bab17f15eeb33bca22f84867607352ff03c))
* checkNumberStatus - Promise ([457eccb](https://github.com/orkestral/venom/commit/457eccb352f55044140ceba812af4938ce8d653a))
* lint check-send-exist ([0390f9a](https://github.com/orkestral/venom/commit/0390f9a13e5105dc610207ec7c0d14dbaedcc01a))
* select chat group ([170ab45](https://github.com/orkestral/venom/commit/170ab454c2f4bda1c7b99bc7c5b117ce4ca44281))



## [3.1.6](https://github.com/orkestral/venom/compare/v3.1.4...v3.1.6) (2021-09-16)


### Bug Fixes

* chat not exist ([18281d3](https://github.com/orkestral/venom/commit/18281d37bd26197b0df7621cad0512fc845fc3a4))
* check lint ([6f24f22](https://github.com/orkestral/venom/commit/6f24f226ef997ca2c0222a7155b66296e34eeb1f))
* check lint - Process completed ([535cd99](https://github.com/orkestral/venom/commit/535cd997ae364d0af1660c7344f4fb43849c0cc5))
* close browser ([c791d43](https://github.com/orkestral/venom/commit/c791d4348bae5d383888b93ce2a6dcc57e1e8a12))
* codeql ([1ab1b55](https://github.com/orkestral/venom/commit/1ab1b55d149344bd252457171aa06a98ef7eadf6))
* codeql ([fe7400d](https://github.com/orkestral/venom/commit/fe7400d8dc036c01edb296ca2206582ee321764c))
* getGroupInviteLink ([bfbbde1](https://github.com/orkestral/venom/commit/bfbbde152e3ed3cdeb03d9366ce65044f929bfb4))
* lint ([81bdabb](https://github.com/orkestral/venom/commit/81bdabb942bc1d83eadcc80d8f8e43e424cc9a67))
* lint code concert ([a340eaa](https://github.com/orkestral/venom/commit/a340eaa69efa6f458cd0cc841b3759c526efac9d))
* lint code concert ([ab1e82d](https://github.com/orkestral/venom/commit/ab1e82d2c3ff91c07faf373a13e90b521ebb78fd))
* lint code concert ([9876b1b](https://github.com/orkestral/venom/commit/9876b1b0bf33a342491416d2a9475bbff28076ed))
* new version ([daeb1cc](https://github.com/orkestral/venom/commit/daeb1cc0fce81bfe0d592c48b11d5333be56d266))
* not  Organizations ([4aeef14](https://github.com/orkestral/venom/commit/4aeef1437d667ae5ebea5eaf0003d6ee48e87e42))
* queryGroupInviteInfo ([ba55f4a](https://github.com/orkestral/venom/commit/ba55f4a3a86e7b24169b788e3c0b29954a29ddc1))
* remove HEAD^2 ([e3d318e](https://github.com/orkestral/venom/commit/e3d318e4be64db80df21bde6e3b1b6d557d3fa35))
* send-loacation ([261920b](https://github.com/orkestral/venom/commit/261920ba41b495c424efb180253c7f4098cbe581))
* sendButtons - (reformulated) ([28d7898](https://github.com/orkestral/venom/commit/28d7898ff5330b0b59cb4f393c19abf848fcc848))
* sendContactVcard ([e9ecd0c](https://github.com/orkestral/venom/commit/e9ecd0c1c6fad27783d8658c402dfe0e5c377266))
* sendContactVcardList ([fb0417f](https://github.com/orkestral/venom/commit/fb0417f8c7076ae3680e01fe47e440b1fa6fac41))
* sendExist and checkNumberStatus ([8f3c954](https://github.com/orkestral/venom/commit/8f3c954a944b22371d0e29537b135874d6783347))
* typedoc-default-themes ([9d75b0e](https://github.com/orkestral/venom/commit/9d75b0e739a48dc76ed922bf63eaa5c0aa84b6e8))
* webpack config ([da8c190](https://github.com/orkestral/venom/commit/da8c190df83ae0dce2c3d2f70c5796afb3ebbd60))


### Features

* Change group description ([3278bff](https://github.com/orkestral/venom/commit/3278bff7f394c5c2b47a26c20688878192f34a48))
* lint fix - package ([226b490](https://github.com/orkestral/venom/commit/226b4902b13d1783ac56c6446b6b2d81265a3895))
* mew ([06915eb](https://github.com/orkestral/venom/commit/06915eba4b8ba85c2d5d28c24be77c4d7c4ba6c5))
* new functions ([6721144](https://github.com/orkestral/venom/commit/6721144b770f55a3195326c7f301e56cb062ac3b))
* project ([8fc9aaa](https://github.com/orkestral/venom/commit/8fc9aaa96611ded0cbc927392c83d17828298d77))
* sendListMenu ([fd8792d](https://github.com/orkestral/venom/commit/fd8792dcc2f82cf981f151a1ffb2592c94e1af47))
* typescript formatter ([6e79c52](https://github.com/orkestral/venom/commit/6e79c5290faf166ec149983db7a3fe7d9cf8aa00))



## [3.1.5](https://github.com/orkestral/venom/compare/v3.1.4...v3.1.5) (2021-09-16)


### Bug Fixes

* chat not exist ([18281d3](https://github.com/orkestral/venom/commit/18281d37bd26197b0df7621cad0512fc845fc3a4))
* check lint ([6f24f22](https://github.com/orkestral/venom/commit/6f24f226ef997ca2c0222a7155b66296e34eeb1f))
* check lint - Process completed ([535cd99](https://github.com/orkestral/venom/commit/535cd997ae364d0af1660c7344f4fb43849c0cc5))
* close browser ([c791d43](https://github.com/orkestral/venom/commit/c791d4348bae5d383888b93ce2a6dcc57e1e8a12))
* codeql ([1ab1b55](https://github.com/orkestral/venom/commit/1ab1b55d149344bd252457171aa06a98ef7eadf6))
* codeql ([fe7400d](https://github.com/orkestral/venom/commit/fe7400d8dc036c01edb296ca2206582ee321764c))
* getGroupInviteLink ([bfbbde1](https://github.com/orkestral/venom/commit/bfbbde152e3ed3cdeb03d9366ce65044f929bfb4))
* lint ([81bdabb](https://github.com/orkestral/venom/commit/81bdabb942bc1d83eadcc80d8f8e43e424cc9a67))
* lint code concert ([a340eaa](https://github.com/orkestral/venom/commit/a340eaa69efa6f458cd0cc841b3759c526efac9d))
* lint code concert ([ab1e82d](https://github.com/orkestral/venom/commit/ab1e82d2c3ff91c07faf373a13e90b521ebb78fd))
* lint code concert ([9876b1b](https://github.com/orkestral/venom/commit/9876b1b0bf33a342491416d2a9475bbff28076ed))
* new version ([daeb1cc](https://github.com/orkestral/venom/commit/daeb1cc0fce81bfe0d592c48b11d5333be56d266))
* not  Organizations ([4aeef14](https://github.com/orkestral/venom/commit/4aeef1437d667ae5ebea5eaf0003d6ee48e87e42))
* queryGroupInviteInfo ([ba55f4a](https://github.com/orkestral/venom/commit/ba55f4a3a86e7b24169b788e3c0b29954a29ddc1))
* remove HEAD^2 ([e3d318e](https://github.com/orkestral/venom/commit/e3d318e4be64db80df21bde6e3b1b6d557d3fa35))
* send-loacation ([261920b](https://github.com/orkestral/venom/commit/261920ba41b495c424efb180253c7f4098cbe581))
* sendButtons - (reformulated) ([28d7898](https://github.com/orkestral/venom/commit/28d7898ff5330b0b59cb4f393c19abf848fcc848))
* sendContactVcard ([e9ecd0c](https://github.com/orkestral/venom/commit/e9ecd0c1c6fad27783d8658c402dfe0e5c377266))
* sendContactVcardList ([fb0417f](https://github.com/orkestral/venom/commit/fb0417f8c7076ae3680e01fe47e440b1fa6fac41))
* sendExist and checkNumberStatus ([8f3c954](https://github.com/orkestral/venom/commit/8f3c954a944b22371d0e29537b135874d6783347))
* typedoc-default-themes ([9d75b0e](https://github.com/orkestral/venom/commit/9d75b0e739a48dc76ed922bf63eaa5c0aa84b6e8))
* webpack config ([da8c190](https://github.com/orkestral/venom/commit/da8c190df83ae0dce2c3d2f70c5796afb3ebbd60))


### Features

* Change group description ([3278bff](https://github.com/orkestral/venom/commit/3278bff7f394c5c2b47a26c20688878192f34a48))
* lint fix - package ([226b490](https://github.com/orkestral/venom/commit/226b4902b13d1783ac56c6446b6b2d81265a3895))
* mew ([06915eb](https://github.com/orkestral/venom/commit/06915eba4b8ba85c2d5d28c24be77c4d7c4ba6c5))
* new functions ([6721144](https://github.com/orkestral/venom/commit/6721144b770f55a3195326c7f301e56cb062ac3b))
* project ([8fc9aaa](https://github.com/orkestral/venom/commit/8fc9aaa96611ded0cbc927392c83d17828298d77))
* sendListMenu ([fd8792d](https://github.com/orkestral/venom/commit/fd8792dcc2f82cf981f151a1ffb2592c94e1af47))
* typescript formatter ([6e79c52](https://github.com/orkestral/venom/commit/6e79c5290faf166ec149983db7a3fe7d9cf8aa00))



## [3.1.4](https://github.com/orkestral/venom/compare/v3.1.3...v3.1.4) (2021-09-02)

## [3.1.3](https://github.com/orkestral/venom/compare/v3.1.2...v3.1.3) (2021-09-02)

### Features

- api ([72b9648](https://github.com/orkestral/venom/commit/72b9648ef7638c3f769b0210f76828f1612d3387))

## [3.1.2](https://github.com/orkestral/venom/compare/v3.1.1...v3.1.2) (2021-08-18)

## [3.1.1](https://github.com/orkestral/venom/compare/v3.1.0...v3.1.1) (2021-08-17)

# [3.1.0](https://github.com/orkestral/venom/compare/v3.0.21...v3.1.0) (2021-08-17)

### Bug Fixes

- lint ([81568ed](https://github.com/orkestral/venom/commit/81568ed57ea2b35cd28ae9de2225a51b245a6ca1))
- lint dependencies ([e86e6b2](https://github.com/orkestral/venom/commit/e86e6b275f38cd27af1b2194ddeb42b9fb0054a4))

## [3.0.21](https://github.com/orkestral/venom/compare/v3.0.20...v3.0.21) (2021-07-09)

### Bug Fixes

- chat not exist ([082a80a](https://github.com/orkestral/venom/commit/082a80aecb493972b198186fa802c328573a6932))
- Parcial fix webpack ([4dce474](https://github.com/orkestral/venom/commit/4dce4748308c7f5a0b4d2dfed88ddf856382f082))

## [3.0.20](https://github.com/orkestral/venom/compare/v3.0.19...v3.0.20) (2021-06-24)

### Bug Fixes

- send-loacation ([92446ea](https://github.com/orkestral/venom/commit/92446ea447deafe88b363f5e6294b9ee95274512))
- sendContactVcardList ([e6518cc](https://github.com/orkestral/venom/commit/e6518cc7e98031a8a62fe0606b08b8a26245dd70))

## [3.0.19](https://github.com/orkestral/venom/compare/v3.0.18...v3.0.19) (2021-06-22)

### Bug Fixes

- getGroupInviteLink (await) ([7040168](https://github.com/orkestral/venom/commit/70401688b0104af74610ac5f40d5ef123a5888b1))
- queryGroupInviteInfo ([48e1086](https://github.com/orkestral/venom/commit/48e10863eb2fecf4b405ade38c4bb1a00e2bb3ed))
- revokeGroupInviteLink (export) ([07947c3](https://github.com/orkestral/venom/commit/07947c326fc42c457b21cdbd74cab8f76726bc1b))
- sendContactVcard ([e47ff16](https://github.com/orkestral/venom/commit/e47ff16c44e0b0025a653b347df667d8bcabca82))
- typescript ([5e345a9](https://github.com/orkestral/venom/commit/5e345a941ece883d9875578035da5aabd9faadee))

### Features

- Change group description ([c635644](https://github.com/orkestral/venom/commit/c6356445b12eeae77306efc000202f6f353e0839))
- Support ([190be33](https://github.com/orkestral/venom/commit/190be33cecca2b7a528c991bd879c5b6269b7faf))

## [3.0.18](https://github.com/orkestral/venom/compare/v3.0.17...v3.0.18) (2021-06-04)

### Bug Fixes

- Button Reload ([ae20c9f](https://github.com/orkestral/venom/commit/ae20c9f5b13a113e56e3201b9e830bd7775a1c20))
- deleteMessages ([da56acb](https://github.com/orkestral/venom/commit/da56acb08e3b966176059418a8eeb24034997a26))
- queryExist ([1e5e2a6](https://github.com/orkestral/venom/commit/1e5e2a67f5f4b92537946da2aeb58f208dce59f6))
- RevokeGroup and getGroupInviteLink ([55e1310](https://github.com/orkestral/venom/commit/55e1310ab1cc3b202b0b30222c27d925bdae1913))
- statusFind ([ef9dc78](https://github.com/orkestral/venom/commit/ef9dc78af8592ac75089ad43d0098020218990af))
- WidFactory ([c2a51e7](https://github.com/orkestral/venom/commit/c2a51e7aa0c00dc499bb5aeeba318d0c70e73232))

## [3.0.16](https://github.com/orkestral/venom/compare/v3.0.15...v3.0.16) (2021-05-04)

### Bug Fixes

- browserInstance callback ([8132418](https://github.com/orkestral/venom/commit/8132418c208e7efd2006cd76be9028e8a2031aaa))
- Close error multi sessions ([68505e0](https://github.com/orkestral/venom/commit/68505e0af2c152531ebb8989129564359e360ae9))
- delete file ([dca4152](https://github.com/orkestral/venom/commit/dca415282fac3a8fa35bff067d45e2c2a8b1c921))
- directory permissions ([08724ea](https://github.com/orkestral/venom/commit/08724ea49228a3ad37ee4742afa988a0bc2924d1))
- lint ([f922428](https://github.com/orkestral/venom/commit/f922428ebc58432c71ec8fb7800fe7c69ceca309))
- lint ([d89aa5a](https://github.com/orkestral/venom/commit/d89aa5a0c29e0cfd9d5c2e9585b205f860453d7f))

### Features

- add args defaultOptions ([cc75244](https://github.com/orkestral/venom/commit/cc752442d03afd67cee02b7d50c6796081e98df9))

## [3.0.15](https://github.com/orkestral/venom/compare/v3.0.14...v3.0.15) (2021-04-25)

### Bug Fixes

- id double ([bf5181f](https://github.com/orkestral/venom/commit/bf5181f611701465022449c735ec2c092e07f2c5))

### Features

- files ([de02822](https://github.com/orkestral/venom/commit/de02822582716c0a7438e8a267abe3110e66864c))

## [3.0.14](https://github.com/orkestral/venom/compare/v3.0.13...v3.0.14) (2021-04-11)

### Bug Fixes

- close and inject ([20e2f74](https://github.com/orkestral/venom/commit/20e2f74f5438e9305a27420dbd56ad16fbdda953))
- error checkIdMessag not function ([31c3041](https://github.com/orkestral/venom/commit/31c304104fe1707b2dfbae72827690a40b7a5a70))
- lint ([e39d709](https://github.com/orkestral/venom/commit/e39d7098a888ee8ccfe076eb50a789cf0da4e719))
- object returns correct deleteMessages ([e99edfd](https://github.com/orkestral/venom/commit/e99edfda9083e21e1c77f7bf12aa985054c90f56))
- remove delay checkIdMessage ([e63ca37](https://github.com/orkestral/venom/commit/e63ca37f6e08e7b6cf2fbe99c6e14a1ff6f08acf))
- statusFind deviceNotConnected ([46d39f4](https://github.com/orkestral/venom/commit/46d39f4c0d3395503f102cbd9992b6ae17def396))
- update Agent ([60458e5](https://github.com/orkestral/venom/commit/60458e559d999eebe4ab4794d91fbaf9e3f01c06))

### Features

- add Args ([01f4a53](https://github.com/orkestral/venom/commit/01f4a53223ec51ab1b473540566211f0d6c0aaa2))
- Check npmjs page ([2591f52](https://github.com/orkestral/venom/commit/2591f52c47821a2747f77035c69707e80e7f0557))
- check site access ([b822fce](https://github.com/orkestral/venom/commit/b822fce7f7150786376e2b64af20df51408b625c))

## [3.0.13](https://github.com/orkestral/venom/compare/v3.0.12...v3.0.13) (2021-04-04)

### Features

- addOnStreamChange ([7ab8d10](https://github.com/orkestral/venom/commit/7ab8d1067b058889c3d38a4fa1b58fe2d6409efb))
- checkFileJson ([9602b78](https://github.com/orkestral/venom/commit/9602b7881bbe3f268659787829307412be504307))
- injectParasite intro ([9f7fe6e](https://github.com/orkestral/venom/commit/9f7fe6e81597bf5102a241de052b1da5e00fc320))
- listener onStreamChange ([5a5a819](https://github.com/orkestral/venom/commit/5a5a8192e57e7b81aadd87cb808d6af01f759525))
- new return statusFind ([d8b6cee](https://github.com/orkestral/venom/commit/d8b6ceea1817c1c16127300123a3b8c59e86bc2b))
- SocketStream ([0683a20](https://github.com/orkestral/venom/commit/0683a20c2661d95b03bbf791733dbcd2447873f5))
- WAPI logout ([b309586](https://github.com/orkestral/venom/commit/b30958609520bd049558a2dc62c7e0107c35217f))

## [3.0.12](https://github.com/orkestral/venom/compare/v3.0.11...v3.0.12) (2021-03-31)

### Bug Fixes

- error undefined ([eb2b9af](https://github.com/orkestral/venom/commit/eb2b9afa0a867a48dda30caae8120b52dbe194fb))
- token ([b75c51a](https://github.com/orkestral/venom/commit/b75c51ad6f8d0f40a2cb31e11b45bfab308bb7c9))

### Features

- add BrowserInstance callback on create function ([fe96807](https://github.com/orkestral/venom/commit/fe96807b2d69e25032839f05a2814fd892338c0f))
- check deleteMessage ([c525c71](https://github.com/orkestral/venom/commit/c525c71de5cacff1bcf4974c4243a1b1e86d4713))
- checkIdMessage and returnReply function ([e3a307d](https://github.com/orkestral/venom/commit/e3a307d451a62719aa20dd139761b97f0374b71f))
- ERROR 429 ([074dc28](https://github.com/orkestral/venom/commit/074dc281838a5ddb41d84740a7b8fae52bd93370))
- refactored the reply function ([d74f96b](https://github.com/orkestral/venom/commit/d74f96b4b0654d29503d6edaa6bca507db50ebf0))
- retrunReply ([6ae385e](https://github.com/orkestral/venom/commit/6ae385e63d44d82f63ca512937d212d42cf399ac))

## [3.0.11](https://github.com/orkestral/venom/compare/v3.0.10...v3.0.11) (2021-03-17)

### Bug Fixes

- lint ([39a1b61](https://github.com/orkestral/venom/commit/39a1b611d6604511c8d4703c1e05672d8bceff0c))
- Return the correct number! ([7ecc5b0](https://github.com/orkestral/venom/commit/7ecc5b0d307edb3107a3bc1b129dd3b152a4d909))
- send group and transmission ([80c4cd2](https://github.com/orkestral/venom/commit/80c4cd2abb555130dc7aec6e848ca03181486af6))

### Features

- check values sendImageFromBase64 - ts ([f44dc08](https://github.com/orkestral/venom/commit/f44dc083bdf6cdc11f45430ed4e0463b98841a01))

## [3.0.10](https://github.com/orkestral/venom/compare/v3.0.9...v3.0.10) (2021-03-15)

### Bug Fixes

- Error when checking number! ([39d0f17](https://github.com/orkestral/venom/commit/39d0f1711a98b949ef70a79d8c682a0d2c81f39a))

### Features

- check values sendLinkPreview - ts ([55e7ac6](https://github.com/orkestral/venom/commit/55e7ac699be51271cb3c61197032d37a6e6bab47))
- check values sendText - ts ([dd3eb0c](https://github.com/orkestral/venom/commit/dd3eb0c40071100871345f7b325e0e021d8c5521))
- Create checkValues ([319230f](https://github.com/orkestral/venom/commit/319230fd248ebbc957a0309eed1649c577366065))

## [3.0.9](https://github.com/orkestral/venom/compare/v3.0.8...v3.0.9) (2021-03-10)

### Bug Fixes

- Cannot read property '\_\_x_id' of undefined ([bc83c78](https://github.com/orkestral/venom/commit/bc83c78e9b5401c1e5eebbc6749ef78960e5c493))
- forwardMessages ([0c0e14d](https://github.com/orkestral/venom/commit/0c0e14d8f3d329b0ee4a600041f9b07dd5cfbfe3))
- return parameters sendVoice ([a7b6813](https://github.com/orkestral/venom/commit/a7b681311e7fe52df69e650c285c1e0c53873116))
- sendLinkPreview ([d5d1145](https://github.com/orkestral/venom/commit/d5d11458bda0256f9d090d7acc012c381a90a368))

### Features

- sendVoiceBase64 ([677c36e](https://github.com/orkestral/venom/commit/677c36e3d74e7ba80ad392c71c9d29246e4f9324))

## [3.0.8](https://github.com/orkestral/venom/compare/v3.0.7...v3.0.8) (2021-03-02)

### Bug Fixes

- qrcode ([691c3af](https://github.com/orkestral/venom/commit/691c3af5def47cbd0dc9cc3ff3f504c38fe6f789))
- sendContactVcard ([448b686](https://github.com/orkestral/venom/commit/448b686384cc212a0d153165be31156de11ae568))

### Features

- return sendLinkPreview ([11f3c34](https://github.com/orkestral/venom/commit/11f3c34205dcdf8a4267d0e963d651a9f8170913))

## [3.0.7](https://github.com/orkestral/venom/compare/v3.0.6...v3.0.7) (2021-03-01)

### Bug Fixes

- spinnies ([e10be38](https://github.com/orkestral/venom/commit/e10be389b3f1b578446f0d07d2ee050a721f4600))
- Undefined or null to object sendMessage ([1b34977](https://github.com/orkestral/venom/commit/1b3497789c3853c2254a85ce2f1c4c483e2ba54c))
- wapi ([003a5b2](https://github.com/orkestral/venom/commit/003a5b2a85064b000081a0ac8f2e9534933de476))

### Features

- Error results sendExist () ([488a5e1](https://github.com/orkestral/venom/commit/488a5e193b4069a47e1658e071163415f03c3924))

## [3.0.6](https://github.com/orkestral/venom/compare/v3.0.5...v3.0.6) (2021-02-28)

### Bug Fixes

- clearChatMessages ([4c10248](https://github.com/orkestral/venom/commit/4c102488fdd9a3e85ca93ef7f9b04baeaaa973ab))
- forwardMessages ([3570b9e](https://github.com/orkestral/venom/commit/3570b9ebf0edd8ed404fb96ac74c7ae65d2a8b08))
- forwardMessages return ([4b3511b](https://github.com/orkestral/venom/commit/4b3511bf4dfba7b15d38424cbc6de58307662259))
- getAllChatsGroups ([06e641c](https://github.com/orkestral/venom/commit/06e641ca37160f6d2c1a7816af38caa27f5b7394))
- getAllContacts ([9cd653e](https://github.com/orkestral/venom/commit/9cd653e01db2fad54201c0f1c611749d23286b99))
- lint ([29aa079](https://github.com/orkestral/venom/commit/29aa07959ad32402366f97e4867532d057304f3c))
- sendText ([dbea75d](https://github.com/orkestral/venom/commit/dbea75de8a9a7c1f4baadc12bf8caa57e05ae48c))

### Features

- getAllChatsNewMsg ([b703462](https://github.com/orkestral/venom/commit/b703462225e680707d1a976c80c250af33510b04))
- getAllChatsTransmission ([6461f1f](https://github.com/orkestral/venom/commit/6461f1fff18b765a53f36e4d6e16c57c886974ce))
- getChatGroupNewMsg ([04f2200](https://github.com/orkestral/venom/commit/04f2200af27fb1f0fab4487b6b017c6937b9bc3d))
- return object forwardMessages and sendText ([ee40497](https://github.com/orkestral/venom/commit/ee404970ecad12f704e1b21363c87f84292b69b8))

## [3.0.5](https://github.com/orkestral/venom/compare/3.0.4...3.0.5) (2021-02-27)

### Bug Fixes

- getAllGroups return ([7673f1e](https://github.com/orkestral/venom/commit/7673f1e7ed4c11e6622fd53c2bbce7bf55c08d7c))

## [3.0.1](https://github.com/orkestral/venom/compare/v2.2.6...v3.0.1) (2021-02-26)

### Bug Fixes

- sendText, onMessage, onck ([e04586f](https://github.com/orkestral/venom/commit/e04586f7f43d5d3dd5426709a1469eb2c41398a4))

# [3.0.0](https://github.com/orkestral/venom/compare/v2.2.6...v3.0.0) (2021-02-25)

### Bug Fixes

### Fix Whatsapp update

### New Initializer

### Add SendVoice

### Speed Improvements

### Memory loss improvements

### Resource Balancing

## [2.2.6](https://github.com/orkestral/venom/compare/v2.2.5...v2.2.6) (2021-02-21)

### Bug Fixes

- lint ([538306f](https://github.com/orkestral/venom/commit/538306fd9565c90fe2670a087cf92fa3f72c76ec))

## [2.2.5](https://github.com/orkestral/venom/compare/v2.2.4...v2.2.5) (2021-02-21)

### Bug Fixes

- file upload functions ([e9cee11](https://github.com/orkestral/venom/commit/e9cee118fac64f25d133e3f62ca0e9ee2451c1b7))
- function sticker ([c1e40b2](https://github.com/orkestral/venom/commit/c1e40b225f40d22302551d7f673f3818c687ad85))
- getchats ([c4fade7](https://github.com/orkestral/venom/commit/c4fade7a8b95537a1921c091475465cef4ba519e))
- incorrect class object -onAck ([1c18017](https://github.com/orkestral/venom/commit/1c18017c9b72e88b3e509b1fec5814929bee58fa))
- Logged out correctly - logout() ([64daabc](https://github.com/orkestral/venom/commit/64daabc560c7e9d6254936ec023a0130a3bea221))
- Multiple equal returns in the onack function ([3628734](https://github.com/orkestral/venom/commit/36287341dae4c43468063e19e9bd8c3800852d4f))
- onMessage return sender and contact ([8902a53](https://github.com/orkestral/venom/commit/8902a53f7357661eec3ba4e0ce4caf43af53a6f4))
- onStreamChange ([44eab67](https://github.com/orkestral/venom/commit/44eab67d22ee988bb589be2984a2a951a3caa280))

## [2.2.4](https://github.com/orkestral/venom/compare/v2.2.3...v2.2.4) (2021-02-13)

### Bug Fixes

- client url undefined ([6d1818c](https://github.com/orkestral/venom/commit/6d1818c26b65d9a322372ecc28f9c67d056f2bd6))
- client url undefined ([cc288b9](https://github.com/orkestral/venom/commit/cc288b942430a876ffa889c523feeecaeeea6c57))
- Fixed contact thumbmail (close [#523](https://github.com/orkestral/venom/issues/523)) ([2e6e54f](https://github.com/orkestral/venom/commit/2e6e54f759790dc8ea24e5a4ff23d7f1fd9bde03))
- Fixed sendLocation error: 'includes' of undefined ([cce314a](https://github.com/orkestral/venom/commit/cce314ab87f8c42e9fc8154f9bedce0f100012ae))
- issues [#585](https://github.com/orkestral/venom/issues/585) ([1794097](https://github.com/orkestral/venom/commit/1794097ac40e8d56f2ee5271eaad4083272b5ada))

### Features

- Added onStreamChange method ([1236dbb](https://github.com/orkestral/venom/commit/1236dbb61395b404229d64915aa8edfb3330f177))
- callback decryptFile interface ([8e6c0db](https://github.com/orkestral/venom/commit/8e6c0db86d5f8030d5d62920e8e868164ca33748))
- Get list chats ([acf172d](https://github.com/orkestral/venom/commit/acf172ddc749ca6529f8cb32de29bb4594d802e0))
- Get new messages chat ([674b1c8](https://github.com/orkestral/venom/commit/674b1c83cd798c0e7c4c2cc9795f478573ae173b))
- Picthumb ([3d1a42b](https://github.com/orkestral/venom/commit/3d1a42bc7811b04285b4fc1e4bb4ebd3026c68d3))
- Send Status ([66af91d](https://github.com/orkestral/venom/commit/66af91db3452b93580336d8117bcd30a839bdb81))
- Send Status: Text, Video, img ([f310e77](https://github.com/orkestral/venom/commit/f310e77f16ebd65a4fd739f2c91c2425df673586))

## [2.2.3](https://github.com/orkestral/venom/compare/v2.2.2...v2.2.3) (2020-12-30)

### Bug Fixes

- Fixed downloadMedia for videos on Chromium (close [#456](https://github.com/orkestral/venom/issues/456)) ([8834957](https://github.com/orkestral/venom/commit/8834957b7629976a81a7782f6a0575545ece7c52))

### Features

- append optional 'stale' property to ContactStatus (close [#461](https://github.com/orkestral/venom/issues/461)) ([56cbb68](https://github.com/orkestral/venom/commit/56cbb685b15d0f4d731cd7d4d40faa070585f0fa))

## [2.2.2](https://github.com/orkestral/venom/compare/v2.2.1...v2.2.2) (2020-12-17)

### Bug Fixes

- Fixed browser error output ([b7da3a5](https://github.com/orkestral/venom/commit/b7da3a5ecaf9ea62870f3c6eb18711c359308f06))
- Fixed set profile picture (fix [#359](https://github.com/orkestral/venom/issues/359), close [#426](https://github.com/orkestral/venom/issues/426)) ([034c603](https://github.com/orkestral/venom/commit/034c603a76d5fb0c16f47fa075dca28ef16a37cb))
- Reset autoclose interval after QRCode read ([fb9d5bd](https://github.com/orkestral/venom/commit/fb9d5bdcd57f22acbb2e17b29f4656033bb2b2ce))

## [2.2.1](https://github.com/orkestral/venom/compare/v2.2.0...v2.2.1) (2020-12-15)

### Bug Fixes

- Fixed sendSeen call ([e2c0026](https://github.com/orkestral/venom/commit/e2c0026763f6255c903095c02c484d763b8de65d))

# [2.2.0](https://github.com/orkestral/venom/compare/v2.1.2...v2.2.0) (2020-12-15)

### Bug Fixes

- Fixed getMessageById from non loaded chat ([600ace1](https://github.com/orkestral/venom/commit/600ace18eb87807d07f813e06e6758dba2f79ad1))
- Fixed group functions (close [#416](https://github.com/orkestral/venom/issues/416)) ([e595f94](https://github.com/orkestral/venom/commit/e595f94a0768af41e2a89e6fbabe058deb2af637))
- Fixed undefined from sendLocation and sendContactVcard (close [#410](https://github.com/orkestral/venom/issues/410)) ([b46fc39](https://github.com/orkestral/venom/commit/b46fc39133f44e60b5833211b2eb700e6662a5e1))
- Improved script injection ([ba3b109](https://github.com/orkestral/venom/commit/ba3b109820c4dce62d02568b88b6174c5f9ea3b3))

### Features

- Added onInterfaceChange listener ([61e5fdf](https://github.com/orkestral/venom/commit/61e5fdfa43256b1eb4b91a1928fdf3ed6dfbf544))
- Added option to create from object ([6e9d557](https://github.com/orkestral/venom/commit/6e9d55757a76e969399e27f4a1798192e8663397))
- Improved logger using winston package ([dffb38c](https://github.com/orkestral/venom/commit/dffb38cc8330cec53aa70f66cff1b105e9c027d1))

## [2.1.2](https://github.com/orkestral/venom/compare/v2.1.1...v2.1.2) (2020-12-04)

### Bug Fixes

- Added error throw for sendSticker ([cdd43ef](https://github.com/orkestral/venom/commit/cdd43ef6b3a031a3820b92aba79f5f6da5c94d5c))

### Features

- Added downloadMedia method (close [#383](https://github.com/orkestral/venom/issues/383), close [#378](https://github.com/orkestral/venom/issues/378)) ([f3e3906](https://github.com/orkestral/venom/commit/f3e3906836c0b9458a8244995c7c32292eacb065))

## [2.1.1](https://github.com/orkestral/venom/compare/v2.1.0...v2.1.1) (2020-12-02)

### Bug Fixes

- Fixed ninth digit problem (close [#370](https://github.com/orkestral/venom/issues/370)) ([ee970dd](https://github.com/orkestral/venom/commit/ee970ddb38ed0a5c048cff093dc337f109de34fb))
- Fixed ninth digit problem for groups (close [#372](https://github.com/orkestral/venom/issues/372)) ([7017dea](https://github.com/orkestral/venom/commit/7017dea8ab66298a267e7cdcf9aa810b82d7313a))
- Fixed ninth digit problem group operation (close [#374](https://github.com/orkestral/venom/issues/374)) ([df477e7](https://github.com/orkestral/venom/commit/df477e7973b620c1f80850d95842ae09936985bc))

# [2.1.0](https://github.com/orkestral/venom/compare/v2.0.27...v2.1.0) (2020-12-01)

### Bug Fixes

- Fixed CPU and memory usage ([b439abf](https://github.com/orkestral/venom/commit/b439abf53372fbe935bbedba8e6967cd78194693))

### Features

- Added logout method ([6950e40](https://github.com/orkestral/venom/commit/6950e4053ab80976064ee353f011cb5eb5be8426))
- Improved client, allow page refresh, better event listener ([fec67ca](https://github.com/orkestral/venom/commit/fec67caada07443a26c6b9bf66a976a16285df48))
- Improved the quality of wapi.js ([5ea77e3](https://github.com/orkestral/venom/commit/5ea77e3d269edc959d7730c7fa59b60b7d68a486))
- new example ([ea45fa5](https://github.com/orkestral/venom/commit/ea45fa50b720e96a4f7389b093ca0013e816dc7e))

## [2.0.27](https://github.com/orkestral/venom/compare/v2.0.26...v2.0.27) (2020-11-28)

### Bug Fixes

- Fixed error log for send files from local ([e4a6f06](https://github.com/orkestral/venom/commit/e4a6f069d3a8c1d8f1d3478fb3cd43b3c50a0aa7))

## [2.0.26](https://github.com/orkestral/venom/compare/v2.0.25...v2.0.26) (2020-11-25)

### Features

- Improved QRCode reader and added url code in callback ([0bdcc05](https://github.com/orkestral/venom/commit/0bdcc056508396ebefd7c6b91a44258602f00250))

## [2.0.25](https://github.com/orkestral/venom/compare/v2.0.24...v2.0.25) (2020-11-23)

### Bug Fixes

- Fixed download GIF image format ([78def2e](https://github.com/orkestral/venom/commit/78def2e1e55de40f63c7b2374f4285676d10424f))

## [2.0.24](https://github.com/orkestral/venom/compare/v2.0.23...v2.0.24) (2020-11-23)

### Bug Fixes

- Fixed download JPEG image format ([c88590f](https://github.com/orkestral/venom/commit/c88590f16c1976a60372a3af8dd1d4868a9ef1a8))

## [2.0.23](https://github.com/orkestral/venom/compare/v2.0.22...v2.0.23) (2020-11-21)

### Bug Fixes

- Added timeout for browserWS connection ([3b31c1f](https://github.com/orkestral/venom/commit/3b31c1f2412559d87ee4097d7ab4cd027445b5e6))
- Added timeout for browserWS connection ([1b28832](https://github.com/orkestral/venom/commit/1b288322d5e4a4ef7d52402be28d638aaf478d6a))
- Fixed autoclose is holding promise ([35a5898](https://github.com/orkestral/venom/commit/35a58989d6314a82dfc3a0c4f8bb81c58b98808a))
- Fixed return of sendText for new non contact ([4147e75](https://github.com/orkestral/venom/commit/4147e75b53ca22fecd855356dbaaf80dd3710f94))
- Fixed send content from URL ([325538b](https://github.com/orkestral/venom/commit/325538b80f45a2792ff1119841bf03849723a416))
- Fixed sendImageAsStickerGif for big images (close [#251](https://github.com/orkestral/venom/issues/251)) ([48b1268](https://github.com/orkestral/venom/commit/48b12683bf8b249bf1088d2a8dd8071140109014))

## [2.0.22](https://github.com/orkestral/venom/compare/v2.0.21...v2.0.22) (2020-11-19)

### Bug Fixes

- Fixed QRCode reader ([247fe17](https://github.com/orkestral/venom/commit/247fe178aec25c504afd6142464ea7420a489a7c))

## [2.0.21](https://github.com/orkestral/venom/compare/v2.0.20...v2.0.21) (2020-11-17)

### Bug Fixes

- Added lint and fixed javascript issues (close [#326](https://github.com/orkestral/venom/issues/326)) ([#328](https://github.com/orkestral/venom/issues/328)) ([31509d6](https://github.com/orkestral/venom/commit/31509d64de7ce228653f8b521986c4c29ff1ac80))

### Features

- Added method getLastSeen (close [#303](https://github.com/orkestral/venom/issues/303)) ([#330](https://github.com/orkestral/venom/issues/330)) ([430e2c3](https://github.com/orkestral/venom/commit/430e2c32d398240991b50c8984a508dc0a2952a9))

## [2.0.20](https://github.com/orkestral/venom/compare/v2.0.19...v2.0.20) (2020-11-16)

### Bug Fixes

- Fixed error on replying a invalid message (close [#320](https://github.com/orkestral/venom/issues/320)) ([917db7a](https://github.com/orkestral/venom/commit/917db7a8db960d914d207a967bdd3603dbf040e0))

### Features

- Send image from base64 ([#319](https://github.com/orkestral/venom/issues/319)) ([9085132](https://github.com/orkestral/venom/commit/90851322e9cedddb16299dbc93c675af084033c0))

## [2.0.19](https://github.com/orkestral/venom/compare/v2.0.18...v2.0.19) (2020-11-14)

### Bug Fixes

- Add StickerGif compatibility with Webp format ([#278](https://github.com/orkestral/venom/issues/278)) ([9104a9b](https://github.com/orkestral/venom/commit/9104a9b4713b1c5a194a8f9f955240318a5d4b2d)), closes [/github.com/orkestral/venom/issues/277#issuecomment-719068476](https://github.com//github.com/orkestral/venom/issues/277/issues/issuecomment-719068476)
- git ignore ([2c1fc1d](https://github.com/orkestral/venom/commit/2c1fc1d108bb907f83fe6ab1d00439c0ad6ce0ae))
- remove package-lock.json ([2c2e134](https://github.com/orkestral/venom/commit/2c2e134f40d97b6583797aa0c6f20b728e87b713))
- sendSticker 'modelClass' of undefined ([9166c68](https://github.com/orkestral/venom/commit/9166c6821e1c91c446478e4584c9ef0304f081f1))
- **293:** group property 'find' of undefined ([a661e1c](https://github.com/orkestral/venom/commit/a661e1c0d3505469af1ce8f2af198ad016b7ba85))

### Features

- fix some things and create space for examples ([ed964d8](https://github.com/orkestral/venom/commit/ed964d8829d26ae2740442c27bf7ab333d28b8ac))
- **conteex:** fix sticker ([f8feaae](https://github.com/orkestral/venom/commit/f8feaae74b71328ac0ab541cdea15c939a4308a2))
- **context:** file dist.zip ([3134cdf](https://github.com/orkestral/venom/commit/3134cdfeb24422874b1a996b176183c93b4d4cba))
- **context:** readme whatsapp ([6682e01](https://github.com/orkestral/venom/commit/6682e01779f13f967fc16544763fb02f88c4ba57))
- dist teste ([68d63de](https://github.com/orkestral/venom/commit/68d63ded50b98e7968dff32320c8c1f999229ef1))
- new function and fixed some things ([#295](https://github.com/orkestral/venom/issues/295)) ([f1cea5d](https://github.com/orkestral/venom/commit/f1cea5d5ec1e3610087363c5d4df7545033f60d9))
- new function and some corrections ([a4be96f](https://github.com/orkestral/venom/commit/a4be96fd589ca40a0d8c85720bda36515caea59c))
- new function to change group permission ([9f4eeef](https://github.com/orkestral/venom/commit/9f4eeef3bfd8fffe61897d0c9051e1aa4bbe8241))

## [2.0.18](https://github.com/orkestral/venom/compare/v2.0.17...v2.0.18) (2020-10-22)

### Bug Fixes

- change deprecated function puppeteer ([eff5660](https://github.com/orkestral/venom/commit/eff5660edd031f46b6d4f6fdc68314586ec017ff))

## [2.0.17](https://github.com/orkestral/venom/compare/v2.0.16...v2.0.17) (2020-10-22)

### Bug Fixes

- remove function stream and fix userAgente ([7fe0701](https://github.com/orkestral/venom/commit/7fe0701f71da1d3e4b8b85152120bf547b691fbc))

## [2.0.16](https://github.com/orkestral/venom/compare/v2.0.15...v2.0.16) (2020-10-20)

### Bug Fixes

- **#222:** add option to inject options into puppeteer ([bbd907c](https://github.com/orkestral/venom/commit/bbd907c808a1990786ad7d48033bcad35ee48a84)), closes [#222](https://github.com/orkestral/venom/issues/222)

### Features

- **context:** delete token after disconnecting by phone and others ([e88fbd0](https://github.com/orkestral/venom/commit/e88fbd07b1cbd2d4f800366cd1a075db45771028))
- **context:** list mute chats and add mute chat ([0d37634](https://github.com/orkestral/venom/commit/0d3763498543f876e7c42661933e31a822d1e048))
- add new function to detect incoming call ([e6e2b7c](https://github.com/orkestral/venom/commit/e6e2b7c573383338954233757b3bd00c4aabc9a5))

## [2.0.15](https://github.com/orkestral/venom/compare/v2.0.14...v2.0.15) (2020-10-16)

### Bug Fixes

- fix function useHere() ([dd0564e](https://github.com/orkestral/venom/commit/dd0564e9fe975a3f61a9779053f3b81ab5b771a5))
- Update dependabot.yml ([472b407](https://github.com/orkestral/venom/commit/472b4070cfcdbe1f169aa18533d389d6e3346cd0))
- Update dependabot.yml ([a63d969](https://github.com/orkestral/venom/commit/a63d969e6d41cc79eb85b16c28abd89b3c22842c))
- Update dependabot.yml ([b41867f](https://github.com/orkestral/venom/commit/b41867f9ded889d74a91b208a355f10778b5538c))
- Update dependabot.yml ([c3f996f](https://github.com/orkestral/venom/commit/c3f996f6b8e99c3cd9b5558cca9a5dc05c005977))

### Features

- Create codeql-analysis workflow ([f35d3c1](https://github.com/orkestral/venom/commit/f35d3c151e2e85004ae1188ca8cdc803e2c52d69))
- Create dependabot ([2b59f52](https://github.com/orkestral/venom/commit/2b59f527a21efda62b1bfa7163828ff80f6a9ba4))
- create new function to detect disconnect ([1d70c9c](https://github.com/orkestral/venom/commit/1d70c9cc9a069a2b079e0ed40ee0488f84e3f27b))

## [2.0.14](https://github.com/orkestral/venom/compare/v2.0.11...v2.0.14) (2020-10-14)

### Bug Fixes

- change package ([9770cb6](https://github.com/orkestral/venom/commit/9770cb6d178877661531fe42e44070c51d64353c))

### Features

- **context:** client desconnected mobile ([0fafa3c](https://github.com/orkestral/venom/commit/0fafa3c3dbb71e2e7008eab1c69712b292d9f103))
- **context:** fix and add functions ([9222837](https://github.com/orkestral/venom/commit/9222837b7b8f5b328783b7077e7756155fbbdf01))
- **context:** return browserClose after logging in ([fed693c](https://github.com/orkestral/venom/commit/fed693c0229c7fe293ec45c13a82078ea3386f78))
- **context:** Treatment of the puppeteer.connect() function ([0dbebee](https://github.com/orkestral/venom/commit/0dbebeefeaaeeeb0e6327a876af18fd9691f9525))

## [2.0.12]

- fix is onAck
- fix create more than one function: onMessage, onAnyMessage, onStateChange and onAck
- new option createPathFileToken
- new option in create browserSessionToken
- new option catchQR: attempt
- new function getSessionTokenBrowser

## [2.0.11](https://github.com/orkestral/venom/compare/v2.0.10...v2.0.11) (2020-10-07)

## [2.0.10](https://github.com/orkestral/venom/compare/v2.0.9...v2.0.10) (2020-10-06)

## [2.0.9](https://github.com/orkestral/venom/compare/v2.0.8...v2.0.9) (2020-10-06)

### Bug Fixes

- change chromium args ([1a18c5d](https://github.com/orkestral/venom/commit/1a18c5dbfaefe25de543db6ee179ffd8a02f20ad))
- change user agent ([baf9598](https://github.com/orkestral/venom/commit/baf9598e876245c8f51f8d3791727af61eab3979))
- correct link update ([599c562](https://github.com/orkestral/venom/commit/599c5625be97b07f5857683dea3cbc77f5ea35cc))
- name chromium ([25c1a3d](https://github.com/orkestral/venom/commit/25c1a3d1aef646ae4a93026e7880274c6b56988e))

### Features

- new option to connect browserWSEndpoint ([2343e1a](https://github.com/orkestral/venom/commit/2343e1a39059dced4a13dc6b41fc4055ac55ddcc))
- new option to connect with external browser ([2a62bb9](https://github.com/orkestral/venom/commit/2a62bb9d254d6651e5040d84128043d696d6694d))

## [2.0.7 | 2.0.8](https://github.com/orkestral/venom/compare/v2.0.6...v2.0.8) (2020-09-29)

- Updating packages
- Improved message download
- Message error when try descrypt

## [2.0.6](https://github.com/orkestral/venom/compare/v2.0.4...v2.0.6) (2020-09-28)

- Fixed return type of create function
- Fix initialization with autoclose

## [2.0.4 | 2.0.5](https://github.com/orkestral/venom/compare/v2.0.3...v2.0.4) (2020-09-22)

- Change ascii welcome venom
- Update user agent
- Fix is connected

## [2.0.2 | 2.0.3](https://github.com/orkestral/venom/compare/a6ac61cd31c759dc75b1bfac3c6ecee645f54ee5...v2.0.3) (2020-09-21)

- add crete config folderNameToken, mkdirFolderToken
- fix package.json rxjs
- add option to disable message terminal Welcome Venom
- fix function to send by group id
- fix bug sendImageAsStickerGif, sendImageAsSticker
- return to chatid to object route treatment

## 2.0.1 (2020-09-14)

- fix bug initialization
- add checkNumberStatus, sendContactVcardList
- correction qrcode in terminal, sendContactVcard, setProfilePic, sendLocation
- add parameter in Callback Status Session: browserClose || qrReadSuccess \* || qrReadFail
- remove refreshQR and sendMessageToId

## 1.1.4 (2020-07-26)

- fix bug

## 1.1.2 (2020-07-24)

- fix bug autoclose

## 1.1.1 (2020-07-24)

- New functions

## 1.0.9 (2020-06-30)

- remove fix file mime type discovery

## 1.0.8 (2020-06-29)

- fix reply (with mention)
- add function autoClose
- add function joingroup
- add function getgroupinfofrominvitelink
- fix file mime type discovery

## 1.0.7 (2020-06-20)

- add setProfilePic
- Fix bug getAllNewMessages

## 1.0.6 (2020-06-19)

- Fix bug not exist folder dist

## 1.0.5 (2020-06-19)

- Fix bug useHere

## 1.0.4 (2020-06-15)

- Fix bug performace

## 1.0.3 (2020-06-14)

- Fix bug performace

## 1.0.2 (2020-06-13)

\*Fix bug disabled spinners

## 1.0.1 (2020-06-13)

- Session for Token - for [HelioSilva](https://github.com/orkestral/venom/commits?author=HelioSilva)
- Spinners disabled options - for [CosmicSnow](https://github.com/orkestral/venom/commits?author=CosmicSnow)

## 1.0.0 (2020-06-06)

- First version
- Init readme
- Do not force rxjs
- Initial commit
- Fix CatchQR erro
- QR catching
- Add Status of Session

```

`CONTRIBUTING.md`:

```md
# Contributing

PRs are welcome. Just please mantain the code as clean as possible and use common JS conventions

```

`Docs.md`:

```md
## Installation

```bash
> npm i --save venom-bot
```

or for [Nightly releases](https://github.com/orkestral/venom/releases/tag/nightly):

```bash
> npm i --save https://github.com/orkestral/venom/releases/download/nightly/venom-bot-nightly.tgz
```

Installing the current repository "you can download the beta version from the current repository!"

```bash
> npm i github:orkestral/venom
```

## Getting started Multidevice and Normal

```javascript
// Supports ES6
// import { create, Whatsapp } from 'venom-bot';
const venom = require('venom-bot');

venom
  .create({
    session: 'session-name', //name of session
    multidevice: false // for version not multidevice use false.(default: true)
  })
  .then((client) => start(client))
  .catch((erro) => {
    console.log(erro);
  });

function start(client) {
  client.onMessage((message) => {
    if (message.body === 'Hi' && message.isGroupMsg === false) {
      client
        .sendText(message.from, 'Welcome Venom 🕷')
        .then((result) => {
          console.log('Result: ', result); //return object success
        })
        .catch((erro) => {
          console.error('Error when sending: ', erro); //return object error
        });
    }
  });
}
```

##### After executing `create()` function, **venom** will create an instance of whatsapp web. If you are not logged in, it will print a QR code in the terminal. Scan it with your phone and you are ready to go!

##### Venom will remember the session so there is no need to authenticate everytime.

##### Multiples sessions can be created at the same time by pasing a session name to `create()` function:

```javascript
// Init sales whatsapp bot
venom.create('sales').then((salesClient) => {...});

// Init support whatsapp bot
venom.create('support').then((supportClient) => {...});
```

<br>

## Optional create parameters

Venom `create()` method third parameter can have the following optional parameters:

If you are using the `Linux` server do not forget to pass the args `--user-agent`
[Original parameters in browserArgs](https://github.com/orkestral/venom/blob/master/src/config/puppeteer.config.ts)

```javascript
const venom = require('venom-bot');

venom
  .create(
    //session
    'sessionName', //Pass the name of the client you want to start the bot
    //catchQR
    (base64Qrimg, asciiQR, attempts, urlCode) => {
      console.log('Number of attempts to read the qrcode: ', attempts);
      console.log('Terminal qrcode: ', asciiQR);
      console.log('base64 image string qrcode: ', base64Qrimg);
      console.log('urlCode (data-ref): ', urlCode);
    },
    // statusFind
    (statusSession, session) => {
      console.log('Status Session: ', statusSession); //return isLogged || notLogged || browserClose || qrReadSuccess || qrReadFail || autocloseCalled || desconnectedMobile || deleteToken || chatsAvailable || deviceNotConnected || serverWssNotConnected || noOpenBrowser || initBrowser || openBrowser || connectBrowserWs || initWhatsapp || erroPageWhatsapp || successPageWhatsapp || waitForLogin || waitChat || successChat
      //Create session wss return "serverClose" case server for close
      console.log('Session name: ', session);
    },
    // options
    {
      multidevice: false, // for version not multidevice use false.(default: true)
      folderNameToken: 'tokens', //folder name when saving tokens
      mkdirFolderToken: '', //folder directory tokens, just inside the venom folder, example:  { mkdirFolderToken: '/node_modules', } //will save the tokens folder in the node_modules directory
      headless: true, // Headless chrome
      devtools: false, // Open devtools by default
      debug: false, // Opens a debug session
      logQR: true, // Logs QR automatically in terminal
      browserWS: '', // If u want to use browserWSEndpoint
      browserArgs: [''], // Original parameters  ---Parameters to be added into the chrome browser instance
      addBrowserArgs: [''], // Add broserArgs without overwriting the project's original
      puppeteerOptions: {}, // Will be passed to puppeteer.launch
      disableSpins: true, // Will disable Spinnies animation, useful for containers (docker) for a better log
      disableWelcome: true, // Will disable the welcoming message which appears in the beginning
      updatesLog: true, // Logs info updates automatically in terminal
      autoClose: 60000, // Automatically closes the venom-bot only when scanning the QR code (default 60 seconds, if you want to turn it off, assign 0 or false)
      createPathFileToken: false, // creates a folder when inserting an object in the client's browser, to work it is necessary to pass the parameters in the function create browserSessionToken
      addProxy: [''], // Add proxy server exemple : [e1.p.webshare.io:01, e1.p.webshare.io:01]
      userProxy: '', // Proxy login username
      userPass: '' // Proxy password
    },
    // BrowserSessionToken
    // To receive the client's token use the function await clinet.getSessionTokenBrowser()
    {
      WABrowserId: '"UnXjH....."',
      WASecretBundle:
        '{"key":"+i/nRgWJ....","encKey":"kGdMR5t....","macKey":"+i/nRgW...."}',
      WAToken1: '"0i8...."',
      WAToken2: '"1@lPpzwC...."'
    },
    // BrowserInstance
    (browser, waPage) => {
      console.log('Browser PID:', browser.process().pid);
      waPage.screenshot({ path: 'screenshot.png' });
    }
  )
  .then((client) => {
    start(client);
  })
  .catch((erro) => {
    console.log(erro);
  });
```

## Callback Status Session

Gets the return if the session is `isLogged` or `notLogged` or `browserClose` or `qrReadSuccess` or `qrReadFail` or `autocloseCalled` or `desconnectedMobile` or `deleteToken` or `chatsAvailable` or `deviceNotConnected` or `serverWssNotConnected` or `noOpenBrowser` or `initBrowser` or `openBrowser` or `connectBrowserWs` or `initWhatsapp` or `erroPageWhatsapp` or `successPageWhatsapp` or `waitForLogin` or `waitChat` or `successChat` or `Create session wss return "serverClose" case server for close`

| Status                  | Condition                                                                                                                                                      |
|-------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `isLogged`              | When the user is already logged in to the browser                                                                                                              |
| `notLogged`             | When the user is not connected to the browser, it is necessary to scan the QR code through the cell phone in the option WhatsApp Web                           |
| `browserClose`          | If the browser is closed this parameter is returned                                                                                                            |
| `qrReadSuccess`         | If the user is not logged in, the QR code is passed on the terminal a callback is returned. After the correct reading by cell phone this parameter is returned |
| `qrReadFail`            | If the browser stops when the QR code scan is in progress, this parameter is returned                                                                          |
| `autocloseCalled`       | The browser was closed using the autoClose command                                                                                                             |
| `desconnectedMobile`    | Client has desconnected in to mobile                                                                                                                           |
| `serverClose`           | Client has desconnected in to wss                                                                                                                              |
| `deleteToken`           | If you pass true within the function `client.getSessionTokenBrowser(true)`                                                                                     |
| `chatsAvailable`        | When Venom is connected to the chat list                                                                                                                       |
| `deviceNotConnected`    | Chat not available because the phone is disconnected `(Trying to connect to the phone)`                                                                        |
| `serverWssNotConnected` | The address wss was not found!                                                                                                                                 |
| `noOpenBrowser`         | It was not found in the browser, or some command is missing in args                                                                                            |
| `initBrowser`           | Starting the browser                                                                                                                                           |
| `openBrowser`           | The browser has been successfully opened!                                                                                                                      |
| `connectBrowserWs`      | Connection with BrowserWs successfully done!                                                                                                                   |
| `initWhatsapp`          | Starting whatsapp!                                                                                                                                             |
| `erroPageWhatsapp`      | Error accessing whatsapp page                                                                                                                                  |
| `successPageWhatsapp`   | Page Whatsapp successfully accessed                                                                                                                            |
| `waitForLogin`          | Waiting for login verification!                                                                                                                                |
| `waitChat`              | Waiting for the chat to load                                                                                                                                   |
| `successChat`           | Chat successfully loaded!                                                                                                                                      | 
```javascript
const venom = require('venom-bot');
venom
  .create(
    'sessionName',
    undefined,
    (statusSession, session) => {
      console.log('Status Session: ', statusSession);
      //return isLogged || notLogged || browserClose || qrReadSuccess || qrReadFail || autocloseCalled || desconnectedMobile || deleteToken || chatsAvailable || deviceNotConnected || serverWssNotConnected || noOpenBrowser || initBrowser || openBrowser || connectBrowserWs || initWhatsapp || erroPageWhatsapp || successPageWhatsapp || waitForLogin || waitChat || successChat
      //Create session wss return "serverClose" case server for close
      console.log('Session name: ', session);
    },
    {
      multidevice: false // for version not multidevice use false.(default: true)
    }
  )
  .then((client) => {
    start(client);
  })
  .catch((erro) => {
    console.log(erro);
  });
```

## Exporting QR Code

By default QR code will appear on the terminal. If you need to pass the QR
somewhere else heres how:

```javascript
const fs = require('fs');
const venom = require('venom-bot');

venom
  .create(
    'sessionName',
    (base64Qr, asciiQR, attempts, urlCode) => {
      console.log(asciiQR); // Optional to log the QR in the terminal
      var matches = base64Qr.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/),
        response = {};

      if (matches.length !== 3) {
        return new Error('Invalid input string');
      }
      response.type = matches[1];
      response.data = new Buffer.from(matches[2], 'base64');

      var imageBuffer = response;
      require('fs').writeFile(
        'out.png',
        imageBuffer['data'],
        'binary',
        function (err) {
          if (err != null) {
            console.log(err);
          }
        }
      );
    },
    undefined,
    { logQR: false }
  )
  .then((client) => {
    start(client);
  })
  .catch((erro) => {
    console.log(erro);
  });
```

## Downloading Files

Puppeteer takes care of the file downloading. The decryption is being done as
fast as possible (outruns native methods). Supports big files!

```javascript
import fs = require('fs');
import mime = require('mime-types');

client.onMessage( async (message) => {
  if (message.isMedia === true || message.isMMS === true) {
    const buffer = await client.decryptFile(message);
    // At this point you can do whatever you want with the buffer
    // Most likely you want to write it into a file
    const fileName = `some-file-name.${mime.extension(message.mimetype)}`;
    await fs.writeFile(fileName, buffer, (err) => {
      ...
    });
  }
});
```

## Basic Functions (usage)

Not every available function is listed, for further look, every function
available can be found in [here](/src/api/layers) and
[here](/src/lib/wapi/functions)

### Chatting

##### Here, `chatId` could be `<phoneNumber>@c.us` or `<phoneNumber>-<groupId>@g.us`

```javascript

// Send List menu
//This function does not work for Bussines contacts
const list = [
    {
      title: "Pasta",
      rows: [
        {
          title: "Ravioli Lasagna",
          description: "Made with layers of frozen cheese",
        }
      ]
    },
    {
      title: "Dessert",
      rows: [
        {
          title: "Baked Ricotta Cake",
          description: "Sweets pecan baklava rolls",
        },
        {
          title: "Lemon Meringue Pie",
          description: "Pastry filled with lemonand meringue.",
        }
      ]
    }
  ];

await client.sendListMenu('000000000000@c.us', 'Title', 'subTitle', 'Description', 'menu', list)
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send Messages with Buttons Reply
const buttons = [
  {
    "buttonText": {
      "displayText": "Text of Button 1"
      }
    },
  {
    "buttonText": {
      "displayText": "Text of Button 2"
      }
    }
  ]
await client.sendButtons('000000000000@c.us', 'Title', buttons, 'Description')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
// Send audio file MP3
await client.sendVoice('000000000000@c.us', './audio.mp3').then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send audio file base64
await client.sendVoiceBase64('000000000000@c.us', base64MP3)
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send contact
await client
  .sendContactVcard('000000000000@c.us', '111111111111@c.us', 'Name of contact')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send a list of contact cards
await client
  .sendContactVcardList('000000000000@c.us', [
    '111111111111@c.us',
    '222222222222@c.us',
  ])
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send basic text
await client
  .sendText('000000000000@c.us', '👋 Hello from venom!')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send location
await client
  .sendLocation('000000000000@c.us', '-13.6561589', '-69.7309264', 'Brasil')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Automatically sends a link with the auto generated link preview. You can also add a custom message to be added.
await client
  .sendLinkPreview(
    '000000000000@c.us',
    'https://www.youtube.com/watch?v=V1bFr2SWP1I',
    'Kamakawiwo ole'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send image (you can also upload an image using a valid HTTP protocol)
await client
  .sendImage(
    '000000000000@c.us',
    'path/to/img.jpg',
    'image-name',
    'Caption text'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });


// Send image file base64
await client.sendImageFromBase64('000000000000@c.us', base64Image, "name file")
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send file (venom will take care of mime types, just need the path)
// you can also upload an image using a valid HTTP protocol
await client
  .sendFile(
    '000000000000@c.us',
    'path/to/file.pdf',
    'file_name',
    'See my file in pdf'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Sends file
// base64 parameter should have mime type already defined
await client
  .sendFileFromBase64(
    '000000000000@c.us',
    base64PDF,
    'file_name.pdf',
    'See my file in pdf'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Generates sticker from the provided animated gif image and sends it (Send image as animated sticker)
// image path imageBase64 A valid gif and webp image is required. You can also send via http/https (http://www.website.com/img.gif)
await client
  .sendImageAsStickerGif('000000000000@c.us', './image.gif')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Generates sticker from given image and sends it (Send Image As Sticker)
// image path imageBase64 A valid png, jpg and webp image is required. You can also send via http/https (http://www.website.com/img.jpg)
await client
  .sendImageAsSticker('000000000000@c.us', './image.jpg')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Forwards messages
await client.forwardMessages(
  '000000000000@c.us',
  ['false_000000000000@c.us_B70847EE89E22D20FB86ECA0C1B11609','false_000000000000@c.us_B70847EE89E22D20FB86ECA0C1B11777']
).then((result) => {
    console.log('Result: ', result); //return object success
})
.catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
});

// Send @tagged message
await client.sendMentioned(
  '000000000000@c.us',
  'Hello @5218113130740 and @5218243160777!',
  ['5218113130740', '5218243160777']
);

// Reply to a message
await client.reply(
  '000000000000@c.us',
  'This is a reply!',
  'true_551937311025@c.us_7C22WHCB6DKYHJKQIEN9'
).then((result) => {
    console.log('Result: ', result); //return object success
}).catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
});

// Send message with options
await client.
        .sendMessageOptions(
          '000000000000@c.us',
          'This is a reply!',
           {
              quotedMessageId: reply,
            }
        )
        .then((retorno) => {
          resp = retorno;
        })
        .catch((e) => {
          console.log(e);
        });

// Send gif
await client.sendVideoAsGif(
  '000000000000@c.us',
  'path/to/video.mp4',
  'video.gif',
  'Gif image file'
);

//checks and returns whether a message and a reply
// exemple:
// await client.onMessage(async (message) => {
//     console.log(await client.returnReply(message)); // replicated message
//     console.log(message.body ); //customer message
//   })
checkReply = await client.returnReply(messagem);

// Send seen ✔️✔️
await client.sendSeen('000000000000@c.us');

// Start typing...
await client.startTyping('000000000000@c.us');

// Stop typing
await client.stopTyping('000000000000@c.us');

// Set chat state (0: Typing, 1: Recording, 2: Paused)
await client.setChatState('000000000000@c.us', 0 | 1 | 2);
```

## Retrieving Data

```javascript
// Retrieve all chats
const chats = await client.getAllChats();

//Retrieves all chats new messages
const chatsAllNew = getAllChatsNewMsg();

//Retrieves all chats Contacts
const contacts = await client.getAllChatsContacts();

//Retrieve all contacts new messages
const contactNewMsg = await client.getChatContactNewMsg();

// Retrieve all groups
// you can pass the group id optional use, exemple: client.getAllChatsGroups('00000000-000000@g.us')
const chats = await client.getAllChatsGroups();

//Retrieve all groups new messages
const groupNewMsg = await client.getChatGroupNewMsg();

//Retrieves all chats Transmission list
const transmission = await client.getAllChatsTransmission();

// Retrieve contacts
const contacts = await client.getAllContacts();

// Returns a list of mute and non-mute users
// "all" List all mutes
// "toMute" List all silent chats
// "noMute" List all chats without silence
const listMute = await client.getListMute('all');

// Retrieve the browser session token
// if you want to delete the token file -> const browserSessionToken = await client.getSessionTokenBrowser(true);
const browserSessionToken = await client.getSessionTokenBrowser();

// Calls your list of blocked contacts (returns an array)
const getBlockList = await client.getBlockList();

// Retrieve messages in chat
//chatID chat id
//includeMe will be by default true, if you do not want to pass false
//includeNotifications will be by default true, if you do not want to pass false
//const Messages = await client.getAllMessagesInChat(chatID, includeMe, includeNotifications)
const Messages = await client.getAllMessagesInChat('000000000000@c.us');

// Retrieve more chat message
const moreMessages = await client.loadEarlierMessages('000000000000@c.us');

// Retrieve all messages in chat
const allMessages = await client.loadAndGetAllMessagesInChat(
  '000000000000@c.us'
);

// Retrieve contact status
const status = await client.getStatus('000000000000@c.us');

// Retrieve user profile
const user = await client.getNumberProfile('000000000000@c.us');

// Retrieve all unread message
const messages = await client.getAllUnreadMessages();

// Retrieve profile fic (as url)
const url = await client.getProfilePicFromServer('000000000000@c.us');

// Retrieve chat/conversation
const chat = await client.getChat('000000000000@c.us');

// Check if the number exists
const chat = await client.checkNumberStatus('000000000000@c.us')
.then((result) => {
    console.log('Result: ', result); //return object success
}).catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
});
```

## Group Functions

```javascript
// groupId or chatId: leaveGroup 52123123-323235@g.us

//change group description
await client
  .setGroupDescription('00000000-000000@g.us', 'group description')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Leave group
await client.leaveGroup('00000000-000000@g.us');

// Get group members
await client.getGroupMembers('00000000-000000@g.us');

// Get group members ids
await client.getGroupMembersIds('00000000-000000@g.us');

// Generate group invite url link
await client.getGroupInviteLink('00000000-000000@g.us');

// Create group (title, participants to add)
await client.createGroup('Group name', [
  '111111111111@c.us',
  '222222222222@c.us'
]);

// Remove participant
await client.removeParticipant('00000000-000000@g.us', '111111111111@c.us');

// Add participant
await client.addParticipant('00000000-000000@g.us', '111111111111@c.us');

// Promote participant (Give admin privileges)
await client.promoteParticipant('00000000-000000@g.us', '111111111111@c.us');

// Demote particiapnt (Revoke admin privileges)
await client.demoteParticipant('00000000-000000@g.us', '111111111111@c.us');

// Get group admins
await client.getGroupAdmins('00000000-000000@g.us');

// Return the group status, jid, description from it's invite link
await client.getGroupInfoFromInviteLink(InviteCode);

// Join a group using the group invite code
await client.joinGroup(InviteCode);
```

## Profile Functions

```javascript
// Set client status
await client.setProfileStatus('On vacations! ✈️');

// Set client profile name
await client.setProfileName('Venom bot');

// Set client profile photo
await client.setProfilePic('path/to/image.jpg');

// Get device info
await client.getHostDevice();

```

## Device Functions

```javascript

// Disconnect from service
await client.logout();

// Delete the Service Worker
await client.killServiceWorker();

// Load the service again
await client.restartService();

// Get connection state
await client.getConnectionState();

// Get battery level
await client.getBatteryLevel();

// Is connected
await client.isConnected();

// Get whatsapp web version
await client.getWAVersion();
```

## Events

```javascript

//Listens to all new messages
//To receiver or recipient
client.onAnyMessage(message => {
  ...
};

// Listen to messages
client.onMessage(message => {
  ...
})

// Listen to state changes
client.onStateChange(state => {
  ...
});

// Listen to ack's
// See the status of the message when sent.
// When receiving the confirmation object, "ack" may return a number, look {@link AckType} for details:
// -7 = MD_DOWNGRADE,
// -6 = INACTIVE,
// -5 = CONTENT_UNUPLOADABLE,
// -4 = CONTENT_TOO_BIG,
// -3 = CONTENT_GONE,
// -2 = EXPIRED,
// -1 = FAILED,
//  0 = CLOCK,
//  1 = SENT,
//  2 = RECEIVED,
//  3 = READ,
//  4 = PLAYED =

client.onAck(ack => {
  ...
});

// Listen to live location
// chatId: 'phone@c.us'
client.onLiveLocation("000000000000@c.us", (liveLocation) => {
  ...
});

// chatId looks like this: '5518156745634-1516512045@g.us'
// Event interface is in here: https://github.com/s2click/venom/blob/master/src/api/model/participant-event.ts
client.onParticipantsChanged("000000000000@c.us", (event) => {
  ...
});

// Listen when client has been added to a group
client.onAddedToGroup(chatEvent => {
  ...
});
```

## Other

```javascript
//Check if there is chat
await client
  .checkChat(chatId)
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Pin chat and Unpin chat messages with true or false
// Pin chat, non-existent (optional)
await client
  .pinChat(chatId, true, false)
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

///mute a contact
await client
  .sendMute(
    '000000000000@c.us', //contact mute
    30, //duration of silence, example: 30 minutes
    'minutes' ///kind of silence "hours" "minutes" "year"
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

///unmute contact
await client
  .sendMute(
    '000000000000@c.us' //contact unmute
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Change the theme
// string types "dark" or "light"
await client.setTheme('dark');

// Receive the current theme
// returns string light or dark
await client.getTheme();

// Delete chat
await client.deleteChat('000000000000@c.us');

// Clear chat messages
await client.clearChatMessages('000000000000@c.us');

// Archive and unarchive chat messages with true or false
await client.archiveChat(chatId, true);

// Delete message (last parameter: delete only locally)
await client
  .deleteMessage('000000000000@c.us', [
    'false_000000000000@c.us_B70847EE89E22D20FB86ECA0C1B11609',
    'false_000000000000@c.us_B70847EE89E22D20FB86ECA0C1B11777'
  ])
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Mark chat as not seen (returns true if it works)
await client.markUnseenMessage('000000000000@c.us');

// Blocks a user (returns true if it works)
await client.blockContact('000000000000@c.us');

// Unlocks contacts (returns true if it works)
await client.unblockContact('000000000000@c.us');

```

## Misc

There are some tricks for a better usage of venom.

#### Keep session alive:

```javascript
// function to detect conflits and change status
// Force it to keep the current session
// Possible state values:
// CONFLICT
// CONNECTED
// DEPRECATED_VERSION
// OPENING
// PAIRING
// PROXYBLOCK
// SMB_TOS_BLOCK
// TIMEOUT
// TOS_BLOCK
// UNLAUNCHED
// UNPAIRED
// UNPAIRED_IDLE
client.onStateChange((state) => {
  console.log('State changed: ', state);
  // force whatsapp take over
  if ('CONFLICT'.includes(state)) client.useHere();
  // detect disconnect on whatsapp
  if ('UNPAIRED'.includes(state)) console.log('logout');
});

// DISCONNECTED
// SYNCING
// RESUMING
// CONNECTED
let time = 0;
client.onStreamChange((state) => {
  console.log('State Connection Stream: ' + state);
  clearTimeout(time);
  if (state === 'DISCONNECTED' || state === 'SYNCING') {
    time = setTimeout(() => {
      client.close();
    }, 80000);
  }
});

// function to detect incoming call
client.onIncomingCall(async (call) => {
  console.log(call);
  client.sendText(call.peerJid, "Sorry, I still can't answer calls");
});
```

#### Closing (saving) sessions

Close the session properly to ensure the session is saved for the next time you
log in (So it won't ask for QR scan again). So instead of CTRL+C,

```javascript
// Catch ctrl+C
process.on('SIGINT', function() {
  client.close();
});

// Try-catch close
try {
   ...
} catch (error) {
   client.close();
}
```

### Auto closing unsynced sessions

The auto close is enabled by default and the timeout is set to 60 sec.
Receives the time in milliseconds to countdown until paired.

Use "autoClose: 0 | false" to disable auto closing.


## Development

Building venom is really simple altough it contains 3 main projects inside

1. Wapi project

```bash
> npm run build:wapi
```

2. Middleware

```bash
> npm run build:middleware
> npm run build:jsQR
```

3. Venom

```bash
> npm run build:venom
```

To build the entire project just run

```bash
> npm run build
```

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# 🕷Venom Bot🕸

[![npm version](https://img.shields.io/npm/v/venom-bot.svg?color=green)](https://www.npmjs.com/package/venom-bot)
![node](https://img.shields.io/node/v/venom-bot)
[![Downloads](https://img.shields.io/npm/dm/venom-bot.svg)](https://www.npmjs.com/package/venom-bot)
[![Average time to resolve an issue](http://isitmaintained.com/badge/resolution/orkestral/venom.svg)](http://isitmaintained.com/project/orkestral/venom 'Average time to resolve an issue')
[![Percentage of issues still open](http://isitmaintained.com/badge/open/orkestral/venom.svg)](http://isitmaintained.com/project/orkestral/venom 'Percentage of issues still open')
<a href="https://discord.gg/qCJ95FVbzR"><img src="https://img.shields.io/discord/772885202351292426?color=blueviolet&label=discord&style=flat" /></a>

[![Build Status](https://img.shields.io/github/actions/workflow/status/orkestral/venom/build.yml?branch=master)](https://github.com/orkestral/venom/actions)
[![Lint Status](https://img.shields.io/github/actions/workflow/status/orkestral/venom/lint.yml?branch=master&label=lint)](https://github.com/orkestral/venom/actions)
[![release-it](https://img.shields.io/badge/%F0%9F%93%A6%F0%9F%9A%80-release--it-e10079.svg)](https://github.com/release-it/release-it)

> Venom is a high-performance system developed with JavaScript to create a bot for WhatsApp, support for creating any interaction, such as customer service, media sending, sentence recognition based on artificial intelligence and all types of design architecture for WhatsApp.

## Get started fast and easy! Official API!

<p align="center">
  <a href="https://docs.orkestral.io/venom">Full Documentation</a>
</p>

<p>
It's a high-performance alternative API to whatzapp, you can send, text messages, files, images, videos and more.
</p>
<p>
Remember, the API was developed on a platform called RESTful Web services, providing interoperability between computer systems on the Internet.
</p>
<p>
It uses a set of well-defined operations that apply to all information resources: HTTP itself defines a small set of operations, the most important being POST, GET, PUT and DELETE.
</p>
<p>
Use it in your favorite language like PHP, Python, C# and others. as long as your language is supported with the HTTP protocol, you will save time and money. you don't need to know how Venom works, we have the complete API documentation, in a professional way!
</p>

## Get our official API Venom ! Contact us!

<a target="_blank" href="https://web.whatsapp.com/send?phone=5561985290357&text=I%20want%20access%20to%20API%20Venom" target="_blank"><img title="whatzapp" height="100" width="375" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/WhatsApp_logo.svg/2000px-WhatsApp_logo.svg.png"></a>

## Venom group support on Telegram

<a target="_blank" href="https://t.me/joinchat/G8wxNXidWBo1ZDYx" target="_blank"><img title="Telegram" height="100" width="375" src="https://user-images.githubusercontent.com/66584466/117182238-7d1d8980-adac-11eb-9a70-e32f90c3d4e5.png"></a>

## Venom group support on Discord

<a target="_blank" href="https://discord.gg/uBRjk6vecs" target="_blank"><img title="Discord" height="110" width="375" src="https://s2.glbimg.com/GUbCgnBxJERAmuaYcrjBzTXD5ws=/0x0:800x272/984x0/smart/filters:strip_icc()/i.s3.glbimg.com/v1/AUTH_63b422c2caee4269b8b34177e8876b93/internal_photos/bs/2021/d/N/zJs579QOGxKVRxfPILCA/discord-app.png"></a>

## Meet the Superchats

<br>
<a href='https://github.com/orkestral/superchats'><img src='https://github.com/orkestral/superchats/raw/main/img/superchats.png' height='60' alt='SuperChats' aria-label='https://github.com/orkestral/superchats' /></a>
<br>
<br>

**SuperChats** is a premium library with unique features that control Whatsapp functions with socket.
With Superchats you can build service bots, multiservice chats or any system that uses Whatsapp

**Superchats** is a premium version of **Venom**, with exclusive features and support for companies and developers worldwide
<br>
<a href='https://github.com/orkestral/superchats'>https://github.com/orkestral/superchats</a>

## Buy a license Superchats

The value of the license is $50 monthly dollars, to acquire contact in whatsapp by clicking on the image below !!

<a target="_blank" href="https://web.whatsapp.com/send?phone=5561985290357&text=I%20want%20to%20buy%201%20license" target="_blank"><img title="whatzapp" height="100" width="375" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/WhatsApp_logo.svg/2000px-WhatsApp_logo.svg.png"></a>

## 🕷🕷 Functions Venom🕷🕷

|                                                               |     |
| ------------------------------------------------------------- | --- |
| 🚻 Automatic QR Refresh                                       | ✔   |
| 📁 Send **text, image, video, audio and docs**                | ✔   |
| 👥 Get **contacts, chats, groups, group members, Block List** | ✔   |
| 📞 Send contacts                                              | ✔   |
| Send Buttons                                                  | ✔   |
| Send stickers                                                 | ✔   |
| Send stickers GIF                                             | ✔   |
| Multiple Sessions                                             | ✔   |
| ⏩ Forward Messages                                           | ✔   |
| 📥 Receive message                                            | ✔   |
| 👤 insert user section                                        | ✔   |
| 📍 Send location!!                                            | ✔   |
| 🕸🕸 **and much more**                                          | ✔   |

Documentation at https://orkestral.github.io/venom/index.html

## Installation

```bash
> npm i --save venom-bot
```

or for [Nightly releases](https://github.com/orkestral/venom/releases/tag/nightly):

```bash
> npm i --save https://github.com/orkestral/venom/releases/download/nightly/venom-bot-nightly.tgz
```

Installing the current repository "you can download the beta version from the current repository!"

```bash
> npm i github:orkestral/venom
```

## Getting started

```javascript
// Supports ES6
// import { create, Whatsapp } from 'venom-bot';
const venom = require('venom-bot');

venom
  .create({
    session: 'session-name' //name of session
  })
  .then((client) => start(client))
  .catch((erro) => {
    console.log(erro);
  });

function start(client) {
  client.onMessage((message) => {
    if (message.body === 'Hi' && message.isGroupMsg === false) {
      client
        .sendText(message.from, 'Welcome Venom 🕷')
        .then((result) => {
          console.log('Result: ', result); //return object success
        })
        .catch((erro) => {
          console.error('Error when sending: ', erro); //return object error
        });
    }
  });
}
```

##### After executing `create()` function, **venom** will create an instance of whatsapp web. If you are not logged in, it will print a QR code in the terminal. Scan it with your phone and you are ready to go!

##### Venom will remember the session so there is no need to authenticate everytime.

##### Multiples sessions can be created at the same time by pasing a session name to `create()` function:

```javascript
// Init sales whatsapp bot
venom.create('sales').then((salesClient) => {...});

// Init support whatsapp bot
venom.create('support').then((supportClient) => {...});
```

<br>

## Optional create parameters

Venom `create()` method third parameter can have the following optional parameters:

If you are using the `Linux` server do not forget to pass the args `--user-agent`
[Original parameters in browserArgs](https://github.com/orkestral/venom/blob/master/src/config/puppeteer.config.ts)

```javascript
const venom = require('venom-bot');

venom
  .create(
    //session
    'sessionName', //Pass the name of the client you want to start the bot
    //catchQR
    (base64Qrimg, asciiQR, attempts, urlCode) => {
      console.log('Number of attempts to read the qrcode: ', attempts);
      console.log('Terminal qrcode: ', asciiQR);
      console.log('base64 image string qrcode: ', base64Qrimg);
      console.log('urlCode (data-ref): ', urlCode);
    },
    // statusFind
    (statusSession, session) => {
      console.log('Status Session: ', statusSession); //return isLogged || notLogged || browserClose || qrReadSuccess || qrReadFail || autocloseCalled || desconnectedMobile || deleteToken || chatsAvailable || deviceNotConnected || serverWssNotConnected || noOpenBrowser || initBrowser || openBrowser || connectBrowserWs || initWhatsapp || erroPageWhatsapp || successPageWhatsapp || waitForLogin || waitChat || successChat
      //Create session wss return "serverClose" case server for close
      console.log('Session name: ', session);
    },
    // options
    {
      browserPathExecutable: '', // browser executable path
      folderNameToken: 'tokens', //folder name when saving tokens
      mkdirFolderToken: '', //folder directory tokens, just inside the venom folder, example:  { mkdirFolderToken: '/node_modules', } //will save the tokens folder in the node_modules directory
      headless: 'new', // you should no longer use boolean false or true, now use false, true or 'new' learn more https://developer.chrome.com/articles/new-headless/
      devtools: false, // Open devtools by default
      debug: false, // Opens a debug session
      logQR: true, // Logs QR automatically in terminal
      browserWS: '', // If u want to use browserWSEndpoint
      browserArgs: [''], // Original parameters  ---Parameters to be added into the chrome browser instance
      addBrowserArgs: [''], // Add broserArgs without overwriting the project's original
      puppeteerOptions: {}, // Will be passed to puppeteer.launch
      disableSpins: true, // Will disable Spinnies animation, useful for containers (docker) for a better log
      disableWelcome: true, // Will disable the welcoming message which appears in the beginning
      updatesLog: true, // Logs info updates automatically in terminal
      autoClose: 60000, // Automatically closes the venom-bot only when scanning the QR code (default 60 seconds, if you want to turn it off, assign 0 or false)
      createPathFileToken: false, // creates a folder when inserting an object in the client's browser, to work it is necessary to pass the parameters in the function create browserSessionToken
      addProxy: [''], // Add proxy server exemple : [e1.p.webshare.io:01, e1.p.webshare.io:01]
      userProxy: '', // Proxy login username
      userPass: '' // Proxy password
    },

    // BrowserInstance
    (browser, waPage) => {
      console.log('Browser PID:', browser.process().pid);
      waPage.screenshot({ path: 'screenshot.png' });
    }
  )
  .then((client) => {
    start(client);
  })
  .catch((erro) => {
    console.log(erro);
  });
```

## Callback Status Session

Gets the return if the session is `isLogged` or `notLogged` or `browserClose` or `qrReadSuccess` or `qrReadFail` or `autocloseCalled` or `desconnectedMobile` or `deleteToken` or `chatsAvailable` or `deviceNotConnected` or `serverWssNotConnected` or `noOpenBrowser` or `initBrowser` or `openBrowser` or `connectBrowserWs` or `initWhatsapp` or `erroPageWhatsapp` or `successPageWhatsapp` or `waitForLogin` or `waitChat` or `successChat` or `Create session wss return "serverClose" case server for close`

| Status                  | Condition                                                                                                                                                      |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `isLogged`              | When the user is already logged in to the browser                                                                                                              |
| `notLogged`             | When the user is not connected to the browser, it is necessary to scan the QR code through the cell phone in the option WhatsApp Web                           |
| `browserClose`          | If the browser is closed this parameter is returned                                                                                                            |
| `qrReadSuccess`         | If the user is not logged in, the QR code is passed on the terminal a callback is returned. After the correct reading by cell phone this parameter is returned |
| `qrReadFail`            | If the browser stops when the QR code scan is in progress, this parameter is returned                                                                          |
| `autocloseCalled`       | The browser was closed using the autoClose command                                                                                                             |
| `desconnectedMobile`    | Client has desconnected in to mobile                                                                                                                           |
| `serverClose`           | Client has desconnected in to wss                                                                                                                              |
| `deleteToken`           | If you pass true within the function                                                                                                                           |
| `chatsAvailable`        | When Venom is connected to the chat list                                                                                                                       |
| `deviceNotConnected`    | Chat not available because the phone is disconnected `(Trying to connect to the phone)`                                                                        |
| `serverWssNotConnected` | The address wss was not found!                                                                                                                                 |
| `noOpenBrowser`         | It was not found in the browser, or some command is missing in args                                                                                            |
| `initBrowser`           | Starting the browser                                                                                                                                           |
| `openBrowser`           | The browser has been successfully opened!                                                                                                                      |
| `connectBrowserWs`      | Connection with BrowserWs successfully done!                                                                                                                   |
| `initWhatsapp`          | Starting whatsapp!                                                                                                                                             |
| `erroPageWhatsapp`      | Error accessing whatsapp page                                                                                                                                  |
| `successPageWhatsapp`   | Page Whatsapp successfully accessed                                                                                                                            |
| `waitForLogin`          | Waiting for login verification!                                                                                                                                |
| `waitChat`              | Waiting for the chat to load                                                                                                                                   |
| `successChat`           | Chat successfully loaded!                                                                                                                                      |

```javascript
const venom = require('venom-bot');
venom
  .create('sessionName', undefined, (statusSession, session) => {
    console.log('Status Session: ', statusSession);
    //return isLogged || notLogged || browserClose || qrReadSuccess || qrReadFail || autocloseCalled || desconnectedMobile || deleteToken || chatsAvailable || deviceNotConnected || serverWssNotConnected || noOpenBrowser || initBrowser || openBrowser || connectBrowserWs || initWhatsapp || erroPageWhatsapp || successPageWhatsapp || waitForLogin || waitChat || successChat
    //Create session wss return "serverClose" case server for close
    console.log('Session name: ', session);
  })
  .then((client) => {
    start(client);
  })
  .catch((erro) => {
    console.log(erro);
  });
```

## Exporting QR Code

By default QR code will appear on the terminal. If you need to pass the QR
somewhere else heres how:

```javascript
const fs = require('fs');
const venom = require('venom-bot');

venom
  .create(
    'sessionName',
    (base64Qr, asciiQR, attempts, urlCode) => {
      console.log(asciiQR); // Optional to log the QR in the terminal
      var matches = base64Qr.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/),
        response = {};

      if (matches.length !== 3) {
        return new Error('Invalid input string');
      }
      response.type = matches[1];
      response.data = new Buffer.from(matches[2], 'base64');

      var imageBuffer = response;
      require('fs').writeFile(
        'out.png',
        imageBuffer['data'],
        'binary',
        function (err) {
          if (err != null) {
            console.log(err);
          }
        }
      );
    },
    undefined,
    { logQR: false }
  )
  .then((client) => {
    start(client);
  })
  .catch((erro) => {
    console.log(erro);
  });
```

## Downloading Files

Puppeteer takes care of the file downloading. The decryption is being done as
fast as possible (outruns native methods). Supports big files!

```javascript
import fs = require('fs');
import mime = require('mime-types');

client.onMessage( async (message) => {
  if (message.isMedia === true || message.isMMS === true) {
    const buffer = await client.decryptFile(message);
    // At this point you can do whatever you want with the buffer
    // Most likely you want to write it into a file
    const fileName = `some-file-name.${mime.extension(message.mimetype)}`;
    await fs.writeFile(fileName, buffer, (err) => {
      ...
    });
  }
});
```

## Basic Functions (usage)

Not every available function is listed, for further look, every function
available can be found in [here](/src/api/layers) and
[here](/src/lib/wapi/functions)

### Chatting

##### Here, `chatId` could be `<phoneNumber>@c.us` or `<phoneNumber>-<groupId>@g.us`

```javascript

// Send Poll
const poll = {
  name: 'new poll',
  options: [
    {
      name: 'option 1'
    },
    {
      name: 'option 2'
    }
  ],
  selectableOptionsCount: 1
};
await client.sendPollCreation('000000000000@c.us', poll)
.then((result) => {
    console.log('Result: ', result); //return object success
})
.catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
});

// Send List menu
const list = [
    {
      title: "Pasta",
      rows: [
        {
          title: "Ravioli Lasagna",
          description: "Made with layers of frozen cheese",
        }
      ]
    },
    {
      title: "Dessert",
      rows: [
        {
          title: "Baked Ricotta Cake",
          description: "Sweets pecan baklava rolls",
        },
        {
          title: "Lemon Meringue Pie",
          description: "Pastry filled with lemonand meringue.",
        }
      ]
    }
  ];

await client.sendListMenu('000000000000@c.us', 'Title', 'subTitle', 'Description', 'menu', list)
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send Messages with Buttons Reply
const buttons = [
  {
    "buttonText": {
      "displayText": "Text of Button 1"
      }
    },
  {
    "buttonText": {
      "displayText": "Text of Button 2"
      }
    }
  ]
await client.sendButtons('000000000000@c.us', 'Title', buttons, 'Description')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
// Send audio file MP3
await client.sendVoice('000000000000@c.us', './audio.mp3').then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send audio file base64
await client.sendVoiceBase64('000000000000@c.us', base64MP3)
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send contact
await client
  .sendContactVcard('000000000000@c.us', '111111111111@c.us', 'Name of contact')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send a list of contact cards
await client
  .sendContactVcardList('000000000000@c.us', [
    '111111111111@c.us',
    '222222222222@c.us',
  ])
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send basic text
await client
  .sendText('000000000000@c.us', '👋 Hello from venom!')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send location
await client
  .sendLocation('000000000000@c.us', '-13.6561589', '-69.7309264', 'Brasil')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Automatically sends a link with the auto generated link preview. You can also add a custom message to be added.
await client
  .sendLinkPreview(
    '000000000000@c.us',
    'https://www.youtube.com/watch?v=V1bFr2SWP1I',
    'Kamakawiwo ole'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send image (you can also upload an image using a valid HTTP protocol)
await client
  .sendImage(
    '000000000000@c.us',
    'path/to/img.jpg',
    'image-name',
    'Caption text'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });


// Send image file base64
await client.sendImageFromBase64('000000000000@c.us', base64Image, "name file")
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Send file (venom will take care of mime types, just need the path)
// you can also upload an image using a valid HTTP protocol
await client
  .sendFile(
    '000000000000@c.us',
    'path/to/file.pdf',
    'file_name',
    'See my file in pdf'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Sends file
// base64 parameter should have mime type already defined
await client
  .sendFileFromBase64(
    '000000000000@c.us',
    base64PDF,
    'file_name.pdf',
    'See my file in pdf'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Generates sticker from the provided animated gif image and sends it (Send image as animated sticker)
// image path imageBase64 A valid gif and webp image is required. You can also send via http/https (http://www.website.com/img.gif)
await client
  .sendImageAsStickerGif('000000000000@c.us', './image.gif')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Generates sticker from given image and sends it (Send Image As Sticker)
// image path imageBase64 A valid png, jpg and webp image is required. You can also send via http/https (http://www.website.com/img.jpg)
await client
  .sendImageAsSticker('000000000000@c.us', './image.jpg')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Forwards messages
await client.forwardMessages(
  '000000000000@c.us',
  ['false_000000000000@c.us_B70847EE89E22D20FB86ECA0C1B11609','false_000000000000@c.us_B70847EE89E22D20FB86ECA0C1B11777']
).then((result) => {
    console.log('Result: ', result); //return object success
})
.catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
});

// Send @tagged message
await client.sendMentioned(
  '000000000000@c.us',
  'Hello @5218113130740 and @5218243160777!',
  ['5218113130740', '5218243160777']
);

// Reply to a message
await client.reply(
  '000000000000@c.us',
  'This is a reply!',
  'true_551937311025@c.us_7C22WHCB6DKYHJKQIEN9'
).then((result) => {
    console.log('Result: ', result); //return object success
}).catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
});

// Send message with options
await client.
        .sendMessageOptions(
          '000000000000@c.us',
          'This is a reply!',
           {
              quotedMessageId: reply,
            }
        )
        .then((retorno) => {
          resp = retorno;
        })
        .catch((e) => {
          console.log(e);
        });

// Send gif
await client.sendVideoAsGif(
  '000000000000@c.us',
  'path/to/video.mp4',
  'video.gif',
  'Gif image file'
);

//checks and returns whether a message and a reply
// exemple:
// await client.onMessage(async (message) => {
//     console.log(await client.returnReply(message)); // replicated message
//     console.log(message.body ); //customer message
//   })
checkReply = await client.returnReply(messagem);

// Send seen ✔️✔️
await client.sendSeen('000000000000@c.us');

// Start typing...
await client.startTyping('000000000000@c.us');

// Stop typing
await client.stopTyping('000000000000@c.us');

// Set chat state (0: Typing, 1: Recording, 2: Paused)
await client.setChatState('000000000000@c.us', 0 | 1 | 2);
```

## Retrieving Data

```javascript
// Retrieve all chats
const chats = await client.getAllChats();

//Retrieves all chats new messages
const chatsAllNew = getAllChatsNewMsg();

//Retrieves all chats Contacts
const contacts = await client.getAllChatsContacts();

//Retrieve all contacts new messages
const contactNewMsg = await client.getChatContactNewMsg();

// Retrieve all groups
// you can pass the group id optional use, exemple: client.getAllChatsGroups('00000000-000000@g.us')
const chats = await client.getAllChatsGroups();

//Retrieve all groups new messages
const groupNewMsg = await client.getChatGroupNewMsg();

//Retrieves all chats Transmission list
const transmission = await client.getAllChatsTransmission();

// Retrieve contacts
const contacts = await client.getAllContacts();

// Returns a list of mute and non-mute users
// "all" List all mutes
// "toMute" List all silent chats
// "noMute" List all chats without silence
const listMute = await client.getListMute('all');

// Calls your list of blocked contacts (returns an array)
const getBlockList = await client.getBlockList();

// Retrieve messages in chat
//chatID chat id
//includeMe will be by default true, if you do not want to pass false
//includeNotifications will be by default true, if you do not want to pass false
//const Messages = await client.getAllMessagesInChat(chatID, includeMe, includeNotifications)
const Messages = await client.getAllMessagesInChat('000000000000@c.us');

// Retrieve more chat message
const moreMessages = await client.loadEarlierMessages('000000000000@c.us');

// Retrieve all messages in chat
const allMessages = await client.loadAndGetAllMessagesInChat(
  '000000000000@c.us'
);

// Retrieve contact status
const status = await client.getStatus('000000000000@c.us');

// Retrieve user profile
const user = await client.getNumberProfile('000000000000@c.us');

// Retrieve all unread message
const messages = await client.getUnreadMessages();

// Retrieve profile fic (as url)
const url = await client.getProfilePicFromServer('000000000000@c.us');

// Retrieve chat/conversation
const chat = await client.getChat('000000000000@c.us');

// Check if the number exists
const chat = await client
  .checkNumberStatus('000000000000@c.us')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

## Group Functions

```javascript
// groupId or chatId: leaveGroup 52123123-323235@g.us

//change group description
await client
  .setGroupDescription('00000000-000000@g.us', 'group description')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Leave group
await client.leaveGroup('00000000-000000@g.us');

// Get group members
await client.getGroupMembers('00000000-000000@g.us');

// Get group members ids
await client.getGroupMembersIds('00000000-000000@g.us');

// Generate group invite url link
await client.getGroupInviteLink('00000000-000000@g.us');

// Create group (title, participants to add)
await client.createGroup('Group name', [
  '111111111111@c.us',
  '222222222222@c.us'
]);

// Remove participant
await client.removeParticipant('00000000-000000@g.us', '111111111111@c.us');

// Add participant
await client.addParticipant('00000000-000000@g.us', '111111111111@c.us');

// Promote participant (Give admin privileges)
await client.promoteParticipant('00000000-000000@g.us', '111111111111@c.us');

// Demote particiapnt (Revoke admin privileges)
await client.demoteParticipant('00000000-000000@g.us', '111111111111@c.us');

// Get group admins
await client.getGroupAdmins('00000000-000000@g.us');

// Return the group status, jid, description from it's invite link
await client.getGroupInfoFromInviteLink(InviteCode);

// Join a group using the group invite code
await client.joinGroup(InviteCode);
```

## Profile Functions

```javascript
// Set client status
await client.setProfileStatus('On vacations! ✈️');

// Set client profile name
await client.setProfileName('Venom bot');

// Set client profile photo
await client.setProfilePic('path/to/image.jpg');

// Get device info
await client.getHostDevice();
```

## Device Functions

```javascript
// Disconnect from service
await client.logout();

// Delete the Service Worker
await client.killServiceWorker();

// Load the service again
await client.restartService();

// Get connection state
await client.getConnectionState();

// Get battery level
await client.getBatteryLevel();

// Is connected
await client.isConnected();

// Get whatsapp web version
await client.getWAVersion();
```

## Events

```javascript

//Listens to all new messages
//To receiver or recipient
client.onAnyMessage(message => {
  ...
};

// Listen to messages
client.onMessage(message => {
  ...
})

// Listen to state changes
client.onStateChange(state => {
  ...
});

// Listen to ack's
// See the status of the message when sent.
// When receiving the confirmation object, "ack" may return a number, look {@link AckType} for details:
// -7 = MD_DOWNGRADE,
// -6 = INACTIVE,
// -5 = CONTENT_UNUPLOADABLE,
// -4 = CONTENT_TOO_BIG,
// -3 = CONTENT_GONE,
// -2 = EXPIRED,
// -1 = FAILED,
//  0 = CLOCK,
//  1 = SENT,
//  2 = RECEIVED,
//  3 = READ,
//  4 = PLAYED =

client.onAck(ack => {
  ...
});

// Listen to live location
// chatId: 'phone@c.us'
client.onLiveLocation("000000000000@c.us", (liveLocation) => {
  ...
});

// chatId looks like this: '5518156745634-1516512045@g.us'
// Event interface is in here: https://github.com/s2click/venom/blob/master/src/api/model/participant-event.ts
client.onParticipantsChanged("000000000000@c.us", (event) => {
  ...
});

// Listen when client has been added to a group
client.onAddedToGroup(chatEvent => {
  ...
});
```

## Other

```javascript
//Check if there is chat
await client
  .checkChat(chatId)
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Pin chat and Unpin chat messages with true or false
// Pin chat, non-existent (optional)
await client
  .pinChat(chatId, true, false)
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

///mute a contact
await client
  .sendMute(
    '000000000000@c.us', //contact mute
    30, //duration of silence, example: 30 minutes
    'minutes' ///kind of silence "hours" "minutes" "year"
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

///unmute contact
await client
  .sendMute(
    '000000000000@c.us' //contact unmute
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Change the theme
// string types "dark" or "light"
await client.setTheme('dark');

// Receive the current theme
// returns string light or dark
await client.getTheme();

// Delete chat
await client.deleteChat('000000000000@c.us');

// Clear chat messages
await client.clearChatMessages('000000000000@c.us');

// Archive and unarchive chat messages with true or false
await client.archiveChat(chatId, true);

// Delete message (last parameter: delete only locally)
await client
  .deleteMessage('000000000000@c.us', [
    'false_000000000000@c.us_B70847EE89E22D20FB86ECA0C1B11609',
    'false_000000000000@c.us_B70847EE89E22D20FB86ECA0C1B11777'
  ])
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });

// Mark chat as not seen (returns true if it works)
await client.markUnseenMessage('000000000000@c.us');

// Blocks a user (returns true if it works)
await client.blockContact('000000000000@c.us');

// Unlocks contacts (returns true if it works)
await client.unblockContact('000000000000@c.us');
```

## Misc

There are some tricks for a better usage of venom.

#### Keep session alive:

```javascript
// function to detect conflits and change status
// Force it to keep the current session
// Possible state values:
// CONFLICT
// CONNECTED
// DEPRECATED_VERSION
// OPENING
// PAIRING
// PROXYBLOCK
// SMB_TOS_BLOCK
// TIMEOUT
// TOS_BLOCK
// UNLAUNCHED
// UNPAIRED
// UNPAIRED_IDLE
client.onStateChange((state) => {
  console.log('State changed: ', state);
  // force whatsapp take over
  if ('CONFLICT'.includes(state)) client.useHere();
  // detect disconnect on whatsapp
  if ('UNPAIRED'.includes(state)) console.log('logout');
});

// DISCONNECTED
// SYNCING
// RESUMING
// CONNECTED
let time = 0;
client.onStreamChange((state) => {
  console.log('State Connection Stream: ' + state);
  clearTimeout(time);
  if (state === 'DISCONNECTED' || state === 'SYNCING') {
    time = setTimeout(() => {
      client.close();
    }, 80000);
  }
});

// function to detect incoming call
client.onIncomingCall(async (call) => {
  console.log(call);
  client.sendText(call.peerJid, "Sorry, I still can't answer calls");
});
```

#### Closing (saving) sessions

Close the session properly to ensure the session is saved for the next time you
log in (So it won't ask for QR scan again). So instead of CTRL+C,

```javascript
// Catch ctrl+C
process.on('SIGINT', function() {
  client.close();
});

// Try-catch close
try {
   ...
} catch (error) {
   client.close();
}
```

### Auto closing unsynced sessions

The auto close is enabled by default and the timeout is set to 60 sec.
Receives the time in milliseconds to countdown until paired.

Use "autoClose: 0 | false" to disable auto closing.

### Debugging

## Development

Building venom is really simple altough it contains 3 main projects inside

1. Wapi project

```bash
> npm run build:wapi
```

2. Middleware

```bash
> npm run build:middleware
> npm run build:jsQR
```

3. Venom

```bash
> npm run build:venom
```

To build the entire project just run

```bash
> npm run build
```

## Maintainers

Maintainers are needed, I cannot keep with all the updates by myself. If you are
interested please open a Pull Request.

## Contributing

Pull requests are welcome. For major changes, please open an issue first to
discuss what you would like to change.

```

`SECURITY.md`:

```md
# Security Policy

## Supported Versions

Use this section to tell people about which versions of your project are
currently being supported with security updates.

| Version | Supported          |
| ------- | ------------------ |
| 5.1.x   | :white_check_mark: |
| 5.0.x   | :x:                |
| 4.0.x   | :white_check_mark: |
| < 4.0   | :x:                |

## Reporting a Vulnerability

Use this section to tell people how to report a vulnerability.

Tell them where to go, how often they can expect to get an update on a
reported vulnerability, what to expect if the vulnerability is accepted or
declined, etc.

```

`Update.md`:

```md
# Update checking

Whatsapp is in constant change, in order to tackle this issue I suggest keeping your Venom package always up-to-date.

The method/function names won't change, only their core algorithm. This way you won't have to makes changes in your code at every update. They will remain the same forever.

```

`docs/getting-started/basic-functions.md`:

```md
# Basic Functions (usage)

Not every available function will be listed, for further look, every function
available can be found in {@link Whatsapp}

## Summary

- [Chatting](#chatting)
  - [sendContactVcard](#sendcontactvcard)
  - [sendContactVcardList](#sendcontactvcardlist)
  - [sendText](#sendtext)
  - [sendLocation](#sendlocation)
  - [sendLinkPreview](#sendlinkpreview)
  - [sendImage](#sendimage)
  - [sendFile](#sendfile)
  - [sendFileFromBase64](#sendfilefrombase64)
  - [sendImageAsStickerGif](#sendimageasstickergif)
  - [sendImageAsSticker](#sendimageassticker)
  - [sendMentioned](#sendmentioned)
  - [reply](#reply)
  - [reply with mention](#reply-with-mention)
  - [sendMessageOptions](#sendmessageoptions)
  - [sendVideoAsGif](#sendvideoasgif)
  - [forwardMessages](#forwardmessages)
  - [sendSeen](#sendseen)
  - [startTyping](#starttyping)
  - [stopTyping](#stoptyping)
  - [setChatState](#setchatstate)

## Chatting

> Here, `chatId` could be `<phoneNumber>@c.us` or `<phoneNumber>-<groupId>@g.us`

### sendContactVcard

Send contact

```javascript
await client
  .sendContactVcard('000000000000@c.us', '111111111111@c.us', 'Name of contact')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendContactVcardList

Send a list of contact cards

```javascript
await client
  .sendContactVcardList('000000000000@c.us', [
    '111111111111@c.us',
    '222222222222@c.us',
  ])
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendText

Send basic text

```javascript
await client
  .sendText('000000000000@c.us', '👋 Hello from venom!')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendLocation

Send location

```javascript
await client
  .sendLocation('000000000000@c.us', '-13.6561589', '-69.7309264', 'Brasil')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendLinkPreview

Automatically sends a link with the auto generated link preview. You can also add a custom message to be added.

```javascript
await client
  .sendLinkPreview(
    '000000000000@c.us',
    'https://www.youtube.com/watch?v=V1bFr2SWP1I',
    'Kamakawiwo ole'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendImage

Send an image (you can also upload an image using a valid HTTP protocol)

```javascript
await client
  .sendImage(
    '000000000000@c.us',
    'path/to/img.jpg',
    'image-name',
    'Caption text'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendFile

Send a file (venom will take care of mime types, just need the path).\
You can also upload an image using a valid HTTP protocol

```javascript
await client
  .sendFile(
    '000000000000@c.us',
    'path/to/file.pdf',
    'file_name',
    'See my file in pdf'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendFileFromBase64

Sends a file.

> base64 parameter should have mime type already defined

```javascript
await client
  .sendFileFromBase64(
    '000000000000@c.us',
    base64PDF,
    'file_name.pdf',
    'See my file in pdf'
  )
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendImageAsStickerGif

Generates a sticker from the provided animated gif image and sends it (Send an image as animated sticker)\
Image path imageBase64 A valid gif and webp image will be required. You can also send via http/https (<http://www.website.com/img.gif>)

```javascript
await client
  .sendImageAsStickerGif('000000000000@c.us', './image.gif')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendImageAsSticker

Generates a sticker from given image and sends it (Send Image As Sticker)\
image path imageBase64 A valid png, jpg and webp image will be required. You can also send via http/https (<http://www.website.com/img.jpg>)

```javascript
await client
  .sendImageAsSticker('000000000000@c.us', './image.jpg')
  .then((result) => {
    console.log('Result: ', result); //return object success
  })
  .catch((erro) => {
    console.error('Error when sending: ', erro); //return object error
  });
```

### sendMentioned

Send `@tagged` message

```javascript
await client.sendMentioned(
  '000000000000@c.us',
  'Hello @5218113130740 and @5218243160777!',
  ['5218113130740', '5218243160777']
);
```

### reply

Reply to a message

```javascript
await client.reply(
  '000000000000@c.us',
  'This is a reply!',
  message.id.toString()
);
```

### reply with mention

Reply to a message with mention

```javascript
await client.reply(
  '000000000000@c.us',
  'Hello @5218113130740 and @5218243160777! This is a reply with mention!',
  message.id.toString(),
  ['5218113130740', '5218243160777']
);
```

### sendMessageOptions

Send a message with options

```javascript
await client
    .sendMessageOptions(
      '000000000000@c.us',
      'This is a reply!',
       {
          quotedMessageId: reply,
        }
    )
    .then((result) => {
        console.log(result);
    })
    .catch((e) => {
      console.log(e);
    });

```

### sendVideoAsGif

Send a gif

```javascript
await client.sendVideoAsGif(
  '000000000000@c.us',
  'path/to/video.mp4',
  'video.gif',
  'Gif image file'
);
```

### forwardMessages

Forwards messages

```javascript
await client.forwardMessages(
  '000000000000@c.us',
  [message.id.toString()],
  true
);
```

### sendSeen

Send seen ✔️✔️

```javascript
await client.sendSeen('000000000000@c.us');
```

### startTyping

Start typing...

```javascript
await client.startTyping('000000000000@c.us');
```

### stopTyping

Stop typing

```javascript
await client.stopTyping('000000000000@c.us');
```

### setChatState

Set chat state (0: Typing, 1: Recording, 2: Paused)

```javascript
await client.setChatState('000000000000@c.us', 0 | 1 | 2);
```

```

`docs/getting-started/creating-client.md`:

```md
# Creating a Client

To start using `Venom Bot`, you need to create a file and call the {@link create} method.\
That method returns an `Promise` of {@link Whatsapp}.

```javascript
// Supports ES6
// import { create, Whatsapp } from 'venom-bot';
const venom = require('venom-bot');

venom
  .create()
  .then((client) => start(client))
  .catch((error) => console.log(error));
```

## Multi sessions

If you want to start more than one session, for example,
in case you have different departments in your project,
then you had to specify it in your code like in that example:

```javascript
// Init sales whatsapp bot
venom.create('sales').then((client) => startClient(client));

// Init support whatsapp bot
venom.create('support').then((client) => startSupport(client));
```

## Passing options on create

The `create` method third parameter can have the following optional parameters:

```javascript
venom.create(
    //session
    'sessionName', //Pass the name of the client you want to start the bot
    //catchQR
    (base64Qrimg, asciiQR, attempts, urlCode) => {
      console.log('Number of attempts to read the qrcode: ', attempts);
      console.log('Terminal qrcode: ', asciiQR);
      console.log('base64 image string qrcode: ', base64Qrimg);
      console.log('urlCode (data-ref): ', urlCode);
    },
    // statusFind
    (statusSession, session) => {
      console.log('Status Session: ', statusSession); //return isLogged || notLogged || browserClose || qrReadSuccess || qrReadFail || autocloseCalled || desconnectedMobile || deleteToken
      //Create session wss return "serverClose" case server for close
      console.log('Session name: ', session);
    },
    // options
    {
      folderNameToken: 'tokens', //folder name when saving tokens
      mkdirFolderToken: '', //folder directory tokens, just inside the venom folder, example:  { mkdirFolderToken: '/node_modules', } //will save the tokens folder in the node_modules directory
      headless: true, // Headless chrome
      devtools: false, // Open devtools by default
      useChrome: true, // If false will use Chromium instance
      debug: false, // Opens a debug session
      logQR: true, // Logs QR automatically in terminal
      browserWS: '', // If u want to use browserWSEndpoint
      browserArgs: [''], // Parameters to be added into the chrome browser instance
      puppeteerOptions: {}, // Will be passed to puppeteer.launch
      disableSpins: true, // Will disable Spinnies animation, useful for containers (docker) for a better log
      disableWelcome: true, // Will disable the welcoming message which appears in the beginning
      updatesLog: true, // Logs info updates automatically in terminal
      autoClose: 60000, // Automatically closes the venom-bot only when scanning the QR code (default 60 seconds, if you want to turn it off, assign 0 or false)
      createPathFileToken: false, //creates a folder when inserting an object in the client's browser, to work it is necessary to pass the parameters in the function create browserSessionToken
    },
    // BrowserSessionToken
    // To receive the client's token use the function await clinet.getSessionTokenBrowser()
    {
      WABrowserId: '"UnXjH....."',
      WASecretBundle:
        '{"key":"+i/nRgWJ....","encKey":"kGdMR5t....","macKey":"+i/nRgW...."}',
      WAToken1: '"0i8...."',
      WAToken2: '"1@lPpzwC...."',
    }
  )
  .then((client) => start(client))
  .catch((error) => console.log(error));
```

### Callback Status Session

Gets the return if the session is `isLogged` or `notLogged` or `browserClose`
or `qrReadSuccess` or `qrReadFail` or `autocloseCalled` or `desconnectedMobile`
or `deleteToken` or `Create session wss return "serverClose" case server for close`

| Status               | Condition                                                                                                                                                      |
|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `isLogged`           | When the user is already logged in to the browser                                                                                                              |
| `notLogged`          | When the user is not connected to the browser, it is necessary to scan the QR code through the cell phone in the option WhatsApp Web                           |
| `browserClose`       | If the browser is closed this parameter is returned                                                                                                            |
| `qrReadSuccess`      | If the user is not logged in, the QR code is passed on the terminal a callback is returned. After the correct reading by cell phone this parameter is returned |
| `qrReadFail`         | If the browser stops when the QR code scan is in progress, this parameter is returned                                                                          |
| `autocloseCalled`    | The browser was closed using the autoClose command                                                                                                             |
| `desconnectedMobile` | Client has disconnected in to mobile                                                                                                                           |
| `serverClose`        | Client has disconnected in to wss                                                                                                                              |
| `deleteToken`        | If you pass true within the function `client.getSessionTokenBrowser(true)`                                                                                     |

```javascript
const venom = require('venom-bot');
venom
  .create(
    'sessionName',
    undefined,
    (statusSession, session) => {
      // return: isLogged || notLogged || browserClose || qrReadSuccess || qrReadFail || autocloseCalled || desconnectedMobile || deleteToken
      console.log('Status Session: ', statusSession);
      // create session wss return "serverClose" case server for close
      console.log('Session name: ', session);
    },
    undefined
  )
  .then((client) => start(client))
  .catch((error) => console.log(error));
```

### Exporting QR Code

By default, QR code will appear on the terminal. If you need to pass the QR
somewhere else heres how:

```javascript
const fs = require('fs');
const venom = require('venom-bot');

venom
  .create(
    'sessionName',
    (base64Qr, asciiQR) => {
      console.log(asciiQR); // Optional to log the QR in the terminal
      var matches = base64Qr.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/),
        response = {};

      if (matches.length !== 3) {
        return new Error('Invalid input string');
      }
      response.type = matches[1];
      response.data = new Buffer.from(matches[2], 'base64');

      var imageBuffer = response;
      require('fs').writeFile(
        'out.png',
        imageBuffer['data'],
        'binary',
        function (err) {
          if (err != null) {
            console.log(err);
          }
        }
      );
    },
    undefined,
    { logQR: false }
  )
  .then((client) => start(client))
  .catch((error) => console.log(error));
```

```

`docs/getting-started/installation.md`:

```md
# Installation

The first thing that you had to do is install the `npm package`:

```bash
npm i --save venom-bot
```

or for [Nightly releases](https://github.com/orkestral/venom/releases/tag/nightly):

```bash
> npm i --save https://github.com/orkestral/venom/releases/download/nightly/venom-bot-nightly.tgz
```

```

`examples/screenshot/README.md`:

```md
# Screenshot

Get screenshot to see what happen behind the hood.

```

`examples/screenshot/index.js`:

```js
const venom = require('../../dist');

venom
  .create(
    'sessionName', //session
    null, //catchQR
    null, //statusFind
    null, //options
    null, //BrowserSessionToken
    (browser, waPage) => {
      // Show broser process ID
      console.log('Browser PID:', browser.process().pid);
      // Take screenshot before logged-in
      waPage.screenshot({ path: 'before-screenshot.png' });
    }
  )
  .then((client) => start(client))
  .catch((erro) => {
    console.log(erro);
  });

function start(client) {
  // Taks screenshot after logged-in
  client.waPage.screenshot({ path: 'after-screenshot.png' });
}

```

`examples/screenshot/package.json`:

```json
{
  "name": "venom-bot-functions",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "license": "ISC"
}

```

`package.json`:

```json
{
  "name": "venom-bot",
  "version": "5.0.17",
  "description": "Venom is a high-performance system developed with JavaScript to create a bot for WhatsApp, support for creating any interaction, such as customer service, media sending, sentence recognition based on artificial intelligence and all types of design architecture for WhatsApp. ",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build:counter": "cd src/lib/counter/ && gulp",
    "build:docs": "typedoc && git add docs/*",
    "build:jsQR": "cd src/lib/jsQR/ && gulp",
    "build:middleware": "cd src/lib/middleware/ && webpack",
    "build:venom": "tsc",
    "build:wapi": "cd src/lib/wapi/ && webpack",
    "build": "npm run fix:imports && npm run build:wapi && npm run build:middleware && npm run build:counter && npm run build:venom",
    "build:test": "npm run fix:imports && npm run build:wapi && npm run build:middleware && npm run build:counter && npm run build:venom && npm test",
    "changelog:last": "conventional-changelog -p angular -r 2",
    "changelog:preview": "conventional-changelog -p angular -u",
    "changelog:update": "conventional-changelog -p angular -i CHANGELOG.md -s",
    "clean": "shx rm -rf session dist",
    "commit": "cz",
    "fix:doc-theme": "shx cp ./node_modules/typedoc-default-themes/bin/default/partials/type.hbs ./node_modules/typedoc-plugin-pages/dist/theme/v2/partials/type.hbs",
    "fix:imports": "eslint --fix \"src/**/*.{js,jsx,ts,tsx}\" && npm run lint:fix",
    "generate-api-docs": "npm run fix:doc-theme && typedoc",
    "lint:js": "npx eslint -c .eslintrc.cjs --ext .js src",
    "lint:ts": "npx eslint -c .eslintrc.cjs --ext .ts src",
    "lint": "npm run lint:ts && npm run lint:js",
    "lint:fix": "npx eslint src --fix",
    "prepare": "npm run clean && npm run build",
    "release": "release-it",
    "start": "npm run build:venom & tsc app.ts && node app.js",
    "test": "node ./test/index.js",
    "watch": "concurrently \"tsc -w\" \"nodemon dist/index.js\""
  },
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS",
      "pre-commit": "pretty-quick --staged"
    }
  },
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/orkestral/venom.git"
  },
  "keywords": [
    "whatsapp",
    "javascript",
    "bot",
    "chat bot",
    "bot",
    "typescript",
    "automation",
    "puppeteer"
  ],
  "author": "Orkestral",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/orkestral/venom/issues"
  },
  "publishConfig": {
    "access": "public"
  },
  "files": [
    ".env",
    "dist/*",
    "dist",
    "package.json",
    "CHANGELOG.md",
    "LICENSE",
    "README.md",
    "SECURITY.md"
  ],
  "homepage": "https://github.com/orkestral/venom#readme",
  "devDependencies": {
    "@commitlint/cli": "^17.3.0",
    "@commitlint/config-angular": "^17.0.3",
    "@types/atob": "^2.1.2",
    "@types/is-root": "^2.1.2",
    "@types/mime-types": "^2.1.0",
    "@types/node": "^18.11.10",
    "@types/puppeteer": "^5.4.6",
    "@types/qrcode": "^1.5.1",
    "@types/qrcode-terminal": "^0.12.0",
    "@types/sharp": "^0.30.5",
    "@types/unzipper": "^0.10.6",
    "@types/ws": "^8.5.3",
    "@typescript-eslint/eslint-plugin": "^5.59.11",
    "@typescript-eslint/parser": "^5.59.11",
    "concurrently": "^7.6.0",
    "conventional-changelog-cli": "^2.2.2",
    "copy-webpack-plugin": "^10.2.4",
    "eslint": "^8.39.0",
    "eslint-config-eslint": "^7.0.0",
    "eslint-config-prettier": "^6.14.0",
    "eslint-import-resolver-typescript": "^3.5.5",
    "eslint-plugin-import": "^2.27.5",
    "eslint-plugin-jsdoc": "^46.4.4",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^4.2.1",
    "gulp": "^4.0.2",
    "husky": "^8.0.1",
    "nodemon": "^3.0.1",
    "prettier": "^2.7.1",
    "pretty-quick": "^3.1.3",
    "release-it": "^16.1.0",
    "shx": "^0.3.4",
    "ts-loader": "^9.4.2",
    "typedoc": "^0.23.28",
    "typedoc-default-themes": "^0.12.10",
    "typedoc-plugin-pages": "^1.1.0",
    "typescript": "^4.9.5",
    "webpack": "^5.74.0",
    "webpack-cli": "^5.0.1"
  },
  "dependencies": {
    "atob": "^2.1.2",
    "axios": "^1.4.0",
    "boxen": "^5.1.1",
    "chalk": "^4.0.0",
    "cheerio": "^1.0.0-rc.12",
    "chrome-launcher": "^0.15.1",
    "chrome-version": "^1.0.1",
    "dotenv": "^16.0.1",
    "esm": "^3.2.25",
    "futoin-hkdf": "^1.5.1",
    "i": "^0.3.7",
    "is-root": "^2.0.0",
    "latest-lib": "^0.2.1",
    "mime-types": "^2.1.35",
    "npm-check-updates": "^16.10.17",
    "ora": "^6.1.2",
    "os": "^0.1.2",
    "puppeteer": "^20.8.1",
    "puppeteer-core": "^20.7.3",
    "puppeteer-extra": "^3.3.6",
    "puppeteer-extra-plugin-stealth": "^2.11.2",
    "qrcode": "^1.5.1",
    "qrcode-terminal": "^0.12.0",
    "sanitize-filename": "^1.6.3",
    "sharp": "^0.30.7",
    "spinnies": "^0.5.1",
    "unzipper": "^0.10.14",
    "ws": "^8.8.0",
    "yoo-hoo": "^1.2.0"
  }
}

```

`src/api/helpers/base64-mimetype.ts`:

```ts
export function base64MimeType(encoded: string) {
  let result = null;
  if (typeof encoded !== 'string') {
    return result;
  }

  const mime = encoded.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
  if (mime && mime.length) {
    result = mime[1];
  }

  return result;
}

```

`src/api/helpers/callback-wile.ts`:

```ts
import { AckType } from '../../api/model/enum/ack-type';
export class callbackWile {
  obj: Object;
  constructor() {
    this.obj = [];
  }
  addObjects(ids: AckType | String, serializeds: string) {
    let checkFilter = this.obj['filter'](
      (order: any) => order.serialized === serializeds
    );
    let add = null;
    if (!checkFilter.length) {
      add = {
        id: ids,
        serialized: serializeds
      };
      this.obj['push'](add);
      return true;
    }
    return false;
  }

  getObjKey(serialized: string) {
    for (let i in this.obj) {
      if (this.obj[i].serialized === serialized) {
        return i;
      }
    }
    return false;
  }

  checkObj(id: AckType | String, serialized: string) {
    let checkFilter = this.obj['filter'](
      (order: any) => order.id === id && order.serialized === serialized
    );
    if (checkFilter.length) {
      return true;
    }
    return false;
  }

  get module() {
    return this.obj;
  }
}

```

`src/api/helpers/check-token-file.ts`:

```ts
const path = require('path');
import { existsSync } from 'fs';

export function checkFileJson(mergedOptions: any, Session: String) {
  const pathTokens: string = path.join(
    path.resolve(
      process.cwd() + mergedOptions.mkdirFolderToken,
      mergedOptions.folderNameToken
    ),
    `${Session}.data.json`
  );
  if (existsSync(pathTokens)) {
    return true;
  } else {
    return false;
  }
}

```

`src/api/helpers/closes-browser.ts`:

```ts
import { Browser } from 'puppeteer';
import { CreateConfig } from '../../config/create-config';

export async function checkingCloses(
  browser: Browser | string,
  mergedOptions: CreateConfig,
  callStatus: (e: string) => void
) {
  new Promise(async (resolve, reject) => {
    if (typeof browser !== 'string') {
      let err: boolean;
      do {
        try {
          await new Promise((r) => setTimeout(r, 2000));
          if (
            browser['isClose'] ||
            (mergedOptions.browserWS && !browser.isConnected())
          ) {
            if (mergedOptions.browserWS) {
              browser.disconnect();
              callStatus && callStatus('serverClose');
            }
            if (browser['isClose']) {
              browser.close().catch((e) => reject(e));
              callStatus && callStatus('browserClose');
            }
            err = false;
          } else {
            throw 1;
          }
        } catch (e) {
          err = true;
        }
      } while (err);
    }
  });
}

```

`src/api/helpers/decrypt.ts`:

```ts
import * as crypto from 'crypto';
import hkdf from 'futoin-hkdf';
const atob = require('atob');
import { ResponseType } from 'axios';

export const makeOptions = (useragentOverride: string) => ({
  responseType: 'arraybuffer' as ResponseType,
  headers: {
    'User-Agent': processUA(useragentOverride),
    DNT: 1,
    'Upgrade-Insecure-Requests': 1,
    origin: 'https://web.whatsapp.com/',
    referer: 'https://web.whatsapp.com/'
  }
});

export const timeout = (ms: number) =>
  new Promise((res) => setTimeout(res, ms));
export const mediaTypes = {
  IMAGE: 'Image',
  VIDEO: 'Video',
  AUDIO: 'Audio',
  PTT: 'Audio',
  DOCUMENT: 'Document',
  STICKER: 'Image'
};

const processUA = (userAgent: string) => {
  let ua =
    userAgent ||
    'WhatsApp/2.2108.8 Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36';
  if (!ua.includes('WhatsApp')) ua = 'WhatsApp/2.2108.8 ' + ua;
  return ua;
};

export const magix = (
  fileData: any,
  mediaKeyBase64: any,
  mediaType: any,
  expectedSize?: number
) => {
  const encodedHex = fileData.toString('hex');
  const encodedBytes = hexToBytes(encodedHex);
  const mediaKeyBytes: any = base64ToBytes(mediaKeyBase64);
  const info = `WhatsApp ${mediaTypes[mediaType.toUpperCase()]} Keys`;
  const hash: string = 'sha256';
  const salt: any = new Uint8Array(32);
  const expandedSize = 112;
  const mediaKeyExpanded = hkdf(mediaKeyBytes, expandedSize, {
    salt,
    info,
    hash
  });
  const iv = mediaKeyExpanded.slice(0, 16);
  const cipherKey = mediaKeyExpanded.slice(16, 48);
  const decipher = crypto.createDecipheriv('aes-256-cbc', cipherKey, iv);
  const decoded: Buffer = decipher.update(encodedBytes);
  const mediaDataBuffer = expectedSize
    ? fixPadding(decoded, expectedSize)
    : decoded;
  return mediaDataBuffer;
};

const fixPadding = (data: Buffer, expectedSize: number) => {
  let padding = (16 - (expectedSize % 16)) & 0xf;
  if (padding > 0) {
    if (expectedSize + padding == data.length) {
      //  console.log(`trimmed: ${padding} bytes`);
      data = data.slice(0, data.length - padding);
    } else if (data.length + padding == expectedSize) {
      // console.log(`adding: ${padding} bytes`);
      let arr = new Uint16Array(padding).map((b) => padding);
      data = Buffer.concat([data, Buffer.from(arr)]);
    }
  }
  //@ts-ignore
  return Buffer.from(data, 'utf-8');
};

const hexToBytes = (hexStr: any) => {
  const intArray = [];
  for (let i = 0; i < hexStr.length; i += 2) {
    intArray.push(parseInt(hexStr.substr(i, 2), 16));
  }
  return new Uint8Array(intArray);
};

const base64ToBytes = (base64Str: any) => {
  const binaryStr = atob(base64Str);
  const byteArray = new Uint8Array(binaryStr.length);
  for (let i = 0; i < binaryStr.length; i++) {
    byteArray[i] = binaryStr.charCodeAt(i);
  }
  return byteArray;
};

```

`src/api/helpers/delete-file.ts`:

```ts
import path from 'path';
import { existsSync, unlink } from 'fs';
import * as Spinnies from 'spinnies';
export async function deleteFiles(
  mergedOptions: any,
  Session: String,
  spinnies: Spinnies
) {
  try {
    spinnies.add(`removeFile`, { text: '....' });
    const pathTokens: string = path.join(
      path.resolve(
        process.cwd() + mergedOptions.mkdirFolderToken,
        mergedOptions.folderNameToken
      ),
      `${Session}.data.json`
    );
    if (existsSync(pathTokens)) {
      unlink(pathTokens, (err) => {
        if (err) {
          spinnies.fail(`removeFile`, {
            text: `Not removed file: ${pathTokens}`
          });
        }
        spinnies.succeed(`removeFile`, {
          text: `Removed file: ${pathTokens}`
        });
      });
    } else {
      spinnies.fail(`removeFile`, { text: `Not Files: ${pathTokens}` });
    }
  } catch (e) {}
}

```

`src/api/helpers/dowload-meta.ts`:

```ts
import { load } from 'cheerio';
import axios, { AxiosResponse } from 'axios';
import { Buffer } from 'buffer';

export async function dowloadMetaFileBase64(url: string): Promise<string> {
  const backImage =
    'iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAIAAAAAWSnCAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAA0SURBVHhe7cExAQAAAMKg9U9tCj8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADipAXM+AAFcstx4AAAAAElFTkSuQmCC';
  try {
    const response: AxiosResponse<string> = await axios(url);
    const htmlContent: string = response.data;
    const $ = load(htmlContent);
    let thumbnail = '';

    $('link[type="image/png"]').each((index, element) => {
      const imgURL = $(element).attr('href');
      if (imgURL) {
        if (!imgURL.includes('http')) {
          thumbnail = url + imgURL;
        } else {
          thumbnail = imgURL;
        }
        return false;
      }
    });

    $('meta[property="og:image"]').each((index, element) => {
      const imgURL = $(element).attr('content');
      if (imgURL) {
        if (!imgURL.includes('http')) {
          thumbnail = url + imgURL;
        } else {
          thumbnail = imgURL;
        }
        return false;
      }
    });

    $('meta[itemprop="image"]').each((index, element) => {
      const imgURL = $(element).attr('content');
      if (imgURL) {
        if (!imgURL.includes('http')) {
          thumbnail = url + imgURL;
        } else {
          thumbnail = imgURL;
        }
        return false;
      }
    });

    if (!thumbnail) {
      $('meta[name="twitter:image"]').each((index, element) => {
        const imgURL = $(element).attr('content');
        if (imgURL) {
          if (!imgURL.includes('http')) {
            thumbnail = url + imgURL;
          } else {
            thumbnail = imgURL;
          }
          return false;
        }
      });
    }

    if (thumbnail) {
      const imageResponse: AxiosResponse<ArrayBuffer> = await axios(thumbnail, {
        responseType: 'arraybuffer'
      });
      const base64Thumbnail = Buffer.from(imageResponse.data).toString(
        'base64'
      );

      return base64Thumbnail;
    }
    return backImage;
  } catch (e) {
    console.log('Erro meta thumbnail', e);
    return backImage;
  }
}

```

`src/api/helpers/download-file.ts`:

```ts
import axios from 'axios';

export async function downloadFileToBase64(
  _path: string,
  _mines: (string | RegExp)[] = []
): Promise<string | false> {
  if (!Array.isArray(_mines)) {
    console.error(`set mines string array, not "${typeof _mines}" `);
    return false;
  }

  const reHttp = /^https?:/;

  if (!reHttp.test(_path)) {
    return false;
  }

  try {
    const response = await axios.get(_path, {
      responseType: 'arraybuffer'
    });

    const mimeType = response.headers['content-type'];
    if (_mines.length) {
      const isValidMime = _mines.some((m) => {
        if (typeof m === 'string') {
          return m === mimeType;
        }
        return m.exec(mimeType);
      });
      if (!isValidMime) {
        console.error(`Content-Type "${mimeType}" of ${_path} is not allowed`);
        return false;
      }
    }

    const content = Buffer.from(response.data, 'binary').toString('base64');

    return `data:${mimeType};base64,${content}`;
  } catch (error) {}

  return false;
}

```

`src/api/helpers/exposed.enum.ts`:

```ts
export enum ExposedFn {
  OnMessage = 'onMessage',
  OnAnyMessage = 'onAnyMessage',
  onAck = 'onAck',
  onParticipantsChanged = 'onParticipantsChanged',
  onStateChange = 'onStateChange',
  onIncomingCall = 'onIncomingCall',
  onInterfaceChange = 'onInterfaceChange',
  onStreamChange = 'onStreamChange',
  onFilePicThumb = 'onFilePicThumb',
  onChatState = 'onChatState',
  onUnreadMessage = 'onUnreadMessage',
  onPoll = 'onPoll'
}

```

`src/api/helpers/file-to-base64.ts`:

```ts
const mimeTypes = require('mime-types');
import * as fs from 'fs';

/**
 * Converts given file into base64 string
 * @param path file path
 * @param mime Optional, will retrieve file mime automatically if not defined (Example: 'image/png')
 */
export async function fileToBase64(path: string, mime?: string) {
  if (fs.existsSync(path)) {
    const base64 = fs.readFileSync(path, { encoding: 'base64' });
    if (mime === undefined) {
      mime = await mimeTypes.lookup(path);
    }
    const data = `data:${mime};base64,${base64}`;
    return data;
  } else {
    return false;
  }
}

export async function Mine(path: string) {
  if (fs.existsSync(path)) {
    const mime = await mimeTypes.lookup(path);
    return mime;
  } else {
    return false;
  }
}

```

`src/api/helpers/filename-from-mimetype.ts`:

```ts
import * as path from 'path';
import * as mime from 'mime-types';

export function filenameFromMimeType(
  filename: string,
  mimeType: string
): string {
  const filenameExtension = path.extname(filename);
  const mimeExtension = mime.extension(mimeType);

  if (!mimeExtension || filenameExtension === mimeExtension) {
    return filename;
  }

  return path.basename(filename, filenameExtension) + '.' + mimeExtension;
}

```

`src/api/helpers/force-connect.ts`:

```ts
import { Page } from 'puppeteer';
import { sleep } from '../../utils/sleep';
export async function loadForceConnect(
  page: Page,
  callback: (infoLog: string | true) => void,
  attempts: number,
  sleeps: number
) {
  try {
    page.on('load', async () => {
      await page
        .evaluate(() => {
          window['connectionAttempts'] = 0;
        })
        .catch(() => undefined);
    });

    while (true) {
      if (page.isClosed()) break;

      if (attempts <= 0) {
        attempts = 1;
      }
      if (sleeps === 0) {
        sleeps = 5000;
      }

      const checkStatus: string | true = (await page
        .evaluate((attempts) => {
          if (
            window.Store &&
            window.Store.State &&
            window.Store.State.Socket &&
            window.Store.State.Socket.state
          ) {
            const status = window.Store.State.Socket.state;
            if (status !== 'CONNECTED') {
              if (window['connectionAttempts'] >= attempts) {
                window.location.reload();
                window['connectionAttempts'] = 0;
                return true;
              }
              window['connectionAttempts']++;
              return `Number of attempts ${window['connectionAttempts']} of ${attempts}, status connection: ${status}`;
            } else {
              window['connectionAttempts'] = 0;
            }
          } else {
            const att = document.querySelectorAll('._2Nr6U');
            if (att.length) {
              if (window['connectionAttempts'] >= attempts) {
                window.location.reload();
                window['connectionAttempts'] = 0;
                return true;
              }
              window['connectionAttempts']++;
              return `Number of attempts ${window['connectionAttempts']} of ${attempts}, status connection: Not Defined`;
            }
          }
        }, attempts)
        .catch(() => undefined)) as string | true;

      if (checkStatus) {
        callback(checkStatus);
      }

      await sleep(sleeps);
    }
  } catch (e) {}
}

```

`src/api/helpers/index.ts`:

```ts
export { fileToBase64 } from './file-to-base64';
export { base64MimeType } from './base64-mimetype';
export { downloadFileToBase64 } from './download-file';
export { stickerSelect, resizeImg } from './select-sticker';
export { scrapeImg } from './scrape-img-qr';
export { scrapeLogin } from './scrape-login';
export { scrapeDesconnected } from './scrape-desconnect';
export { scrapeDeleteToken } from './scrape-deletetoken';
export { deleteFiles } from './delete-file';
export { callbackWile } from './callback-wile';
export { checkingCloses } from './closes-browser';
export { loadForceConnect } from './force-connect';
export { sleep } from './sleep';
export { dowloadMetaFileBase64 } from './dowload-meta';

```

`src/api/helpers/layers-interface.ts`:

```ts
export interface Scope {
  erro: boolean;
  to: string;
  text: string;
}

function infoType(data: string, type: string) {
  return typeof data === type ? true : false;
}
export function checkValuesSender(data: any) {
  if (Array.isArray(data)) {
    for (let i in data) {
      if (typeof i == 'number') {
        let result =
          data[i].type && data[i].value && infoType(data[i].value, data[i].type)
            ? true
            : !data[i].value && data[i].isUser === false
            ? true
            : false;
        if (!result) {
          return {
            erro: true,
            param: data[i].param,
            function: data[i].function,
            text: `Invalid parameter in ${data[i].param}! Pass a variable of type ${data[i].type}!`
          };
        }
      }
    }
    return true;
  } else {
    console.error('Error: checkValuesSender is not array');
  }
}

```

`src/api/helpers/scrape-deletetoken.ts`:

```ts
import { Page } from 'puppeteer';
declare global {
  interface Window {
    pathSession: any;
  }
}
export async function scrapeDeleteToken(page: Page): Promise<boolean> {
  const result = await page
    .evaluate(() => {
      const scrape = window.pathSession;
      if (scrape === true) {
        return true;
      } else {
        return false;
      }
    })
    .catch(() => undefined);
  return result;
}

```

`src/api/helpers/scrape-desconnect.ts`:

```ts
import { Page } from 'puppeteer';
declare global {
  interface Window {
    Store: any;
    Stream: any;
  }
}
export async function scrapeDesconnected(page: Page): Promise<boolean> {
  const result = await page
    .evaluate(() => {
      const scrape = window.Store.State.Socket.on('change:state');
      if (
        scrape.__x_stream === 'DISCONNECTED' &&
        scrape.__x_state === 'CONNECTED'
      ) {
        return true;
      } else {
        return false;
      }
    })
    .catch(() => undefined);
  return result;
}

```

`src/api/helpers/scrape-img-qr.ts`:

```ts
import { Page } from 'puppeteer';
import { ScrapQrcode } from '../model/qrcode';

export async function scrapeImg(page: Page): Promise<ScrapQrcode | undefined> {
  let click = await page.evaluate(async () => {
    const buttonReload = document.querySelector('button.Jht5u');
    if (buttonReload != null) {
      return true;
    }
    return false;
  });

  if (click) {
    const buttonReloadElementHandle = await page.$('button.Jht5u');
    if (buttonReloadElementHandle) {
      await buttonReloadElementHandle.click();
    }
  }

  const result = await page
    .evaluate(() => {
      const selectorImg = document.querySelector('canvas');
      const selectorUrl = selectorImg.closest('[data-ref]');
      const buttonReload = document.querySelector('button.Jht5u');

      if (buttonReload === null && selectorImg != null && selectorUrl != null) {
        let data = {
          base64Image: selectorImg.toDataURL(),
          urlCode: selectorUrl.getAttribute('data-ref')
        };
        return data;
      } else {
        return undefined;
      }
    })
    .catch(() => undefined);

  return result;
}

```

`src/api/helpers/scrape-login.ts`:

```ts
import { Page } from 'puppeteer';
export async function scrapeLogin(page: Page): Promise<boolean> {
  const result = await page
    .evaluate(() => {
      const count = document.querySelector('._9a59P');
      let data: boolean;
      data = false;
      if (count != null) {
        const text = count.textContent,
          timeNumber = text.match('Invalid');
        if (timeNumber) {
          data = true;
        }
        return data;
      }
    })
    .catch(() => undefined);
  return result;
}

```

`src/api/helpers/select-sticker.ts`:

```ts
import sharp from 'sharp';

interface selectOutput {
  webpBase64: string;
  metadata: {
    width?: number;
    height?: number;
  };
}

export async function stickerSelect(_B: Buffer, _t: number) {
  let _w: sharp.Sharp, _ins: Buffer;
  switch (_t) {
    case 0:
      _ins = await sharp(_B, { failOnError: false })
        .resize({ width: 512, height: 512 })
        .toBuffer();
      _w = sharp(_ins, { failOnError: false }).webp();
      break;
    case 1:
      _w = sharp(_B, { animated: true }).webp();
      break;
    default:
      console.error('Enter a valid number 0 or 1');
      return false;
  }

  const metadata = await _w.metadata();

  if (metadata.width > 512 || metadata.pageHeight > 512) {
    console.error(
      `Invalid image size (max 512x512):${metadata.width}x${metadata.pageHeight}`
    );
    return false;
  }

  const obj: selectOutput = {
    webpBase64: (await _w.toBuffer()).toString('base64'),
    metadata: {
      width: metadata.width,
      height: metadata.pageHeight
    }
  };

  return obj;
}

interface CreateSize {
  width?: number;
  height?: number;
}
export async function resizeImg(buff: Buffer, size: CreateSize) {
  const _ins = await sharp(buff, { failOnError: false })
      .resize({ width: size.width, height: size.height })
      .toBuffer(),
    _w = sharp(_ins, { failOnError: false }).jpeg(),
    _webb64 = (await _w.toBuffer()).toString('base64');

  return _webb64;
}

```

`src/api/helpers/sleep.ts`:

```ts
/**
 * Pauses the execution for a specified amount of time.
 * @param time The duration to sleep in milliseconds.
 */
export function sleep(time: number) {
  try {
    // Create a promise that resolves after the specified time
    return new Promise((resolve) => setTimeout(resolve, time));
  } catch {}
}

```

`src/api/inject/webpack.ts`:

```ts
//import { Page, Browser } from 'puppeteer';
//import * as path from 'path';
//import { SenderLayer } from '../api/layes/sender.layes';
//import { CreateOptions, defaultConfig } from '../model/interface';

// export class webPack extends SenderLayer {
//   constructor(
//     public page: Page,
//     public browser: Browser,
//     public options: CreateOptions,
//     public ev: any
//   ) {
//     super(page, browser, options, ev);
//     this.initService();

//     this.page.on('load', async () => {
//       await this.initService();
//     });
//   }

//   async initService() {
//     try {
//       await this.page
//         .waitForFunction('webpackChunkwhatsapp_web_client.length')
//         .catch();
//       await this.page
//         .addScriptTag({
//           path: require.resolve(path.join(__dirname, '../assets/', 'api.js'))
//         })
//         .catch();
//       this.initLitener();
//     } catch {}
//   }
// }

```

`src/api/layers/README.md`:

```md
# Layers

## Each layer should extends the previous one in the next order

1. Host layer
2. Profile layer
3. Listener layer
4. Sender layer
5. Retriever layer
6. Group layer
7. Controls layer
8. Business layer (Optional)

**Controls layer** should be enough

```

`src/api/layers/business.layer.ts`:

```ts
import { Browser, Page } from 'puppeteer';
import { ControlsLayer } from './controls.layer';

export class BusinessLayer extends ControlsLayer {
  constructor(public page: Page, public browser: Browser) {
    super(browser, page);
  }

  /**
   * Querys product catalog
   * @param id Buisness profile id ('00000@c.us')
   */
  public async getBusinessProfilesProducts(id: string) {
    return this.page.evaluate(
      ({ id }) => {
        WAPI.getBusinessProfilesProducts(id);
      },
      { id }
    );
  }

  /**
   * Sends product with product image to given chat id
   * @param to Chat id
   * @param base64 Base64 image data
   * @param caption Message body
   * @param businessId Business id number that owns the product ('0000@c.us')
   * @param productId Product id, see method getBusinessProfilesProducts for more info
   */
  public async sendImageWithProduct(
    to: string,
    base64: string,
    caption: string,
    businessId: string,
    productId: string
  ) {
    return this.page.evaluate(
      ({ to, base64, businessId, caption, productId }) => {
        WAPI.sendImageWithProduct(base64, to, caption, businessId, productId);
      },
      { to, base64, businessId, caption, productId }
    );
  }
}

```

`src/api/layers/callback-on.layes.ts`:

```ts
import { onMode } from '../model/enum';
import { sleep } from '../helpers';

/**
 * attribution and behavior change of a given event
 */
export class CallbackOnStatus {
  public statusFind: any;
  constructor() {
    this.statusFind = '';
  }

  /**
   * waiting for event change
   * @param event returns event status
   */
  async onChange(event: (status: any) => void) {
    let change = null;
    while (true) {
      if (this.statusFind !== change) {
        change = this.statusFind;
        event && event(change);
      }
      await sleep(50);
    }
  }

  /**
   * here you can monitor user events
   * @param type types of monitoring
   * @param callback returns of monitoring
   */
  public async on(type: onMode, callback: (state: any) => void) {
    switch (type) {
      case onMode.interfaceChange:
        this.onChange((event) => {
          if (event.onType === onMode.interfaceChange) {
            callback(event);
          }
        });
        break;
      case onMode.newOnAck:
        this.onChange((event) => {
          if (event.onType === onMode.newOnAck) {
            callback(event);
          }
        });
        break;
      case onMode.newMessage:
        this.onChange((event) => {
          if (event.onType === onMode.newMessage) {
            callback(event);
          }
        });
        break;
      case onMode.qrcode:
        this.onChange((event) => {
          if (event.onType === onMode.qrcode) {
            callback(event);
          }
        });
        break;
      case onMode.connection:
        this.onChange((event) => {
          if (event.onType === onMode.connection) {
            callback(event);
          }
        });
        break;
    }
  }
}

```

`src/api/layers/controls.layer.ts`:

```ts
import { Page, Browser } from 'puppeteer';
import { CreateConfig } from '../../config/create-config';
import { UILayer } from './ui.layer';
import { checkValuesSender } from '../helpers/layers-interface';

export class ControlsLayer extends UILayer {
  constructor(
    public browser: Browser,
    public page: Page,
    session?: string,
    options?: CreateConfig
  ) {
    super(browser, page, session, options);
  }

  /**
   * Unblock contact
   * @param contactId {string} id '000000000000@c.us'
   * @returns boolean
   */
  public async unblockContact(contactId: string) {
    return this.page.evaluate(
      (contactId: string) => WAPI.unblockContact(contactId),
      contactId
    );
  }

  /**
   * Block contact
   * @param contactId {string} id '000000000000@c.us'
   * @returns boolean
   */
  public async blockContact(contactId: string) {
    return this.page.evaluate(
      (contactId: string) => WAPI.blockContact(contactId),
      contactId
    );
  }

  /**
   * Mark unread chat
   * @param contactId {string} id '000000000000@c.us'
   * @returns bollean
   */
  public async markUnseenMessage(contactId: string) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'markUnseenMessage';
      const type = 'string';
      const check = [
        {
          param: 'contactId',
          type: type,
          value: contactId,
          function: typeFunction,
          isUser: true
        }
      ];

      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = await this.page.evaluate(
        (contactId: string) => WAPI.markUnseenMessage(contactId),
        contactId
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Mark chat as read ✔️✔️
   * @param contactId {string} id '000000000000@c.us'
   * @returns boolean
   */
  public async markMarkSeenMessage(contactId: string) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'markMarkSeenMessage';
      const type = 'string';
      const check = [
        {
          param: 'contactId',
          type: type,
          value: contactId,
          function: typeFunction,
          isUser: true
        }
      ];

      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = await this.page.evaluate(
        (contactId: string) => WAPI.markMarkSeenMessage(contactId),
        contactId
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Deletes the given chat
   * @param chatId {string} id '000000000000@c.us'
   * @returns boolean
   */
  public async deleteChat(chatId: string) {
    return await this.page.evaluate(
      (chatId) => WAPI.deleteConversation(chatId),
      chatId
    );
  }

  /**
   * Archive and unarchive chat messages with true or false
   * @param chatId {string} id '000000000000@c.us'
   * @param option {boolean} true or false
   * @returns boolean
   */
  public async archiveChat(chatId: string, option: boolean) {
    return this.page.evaluate(
      ({ chatId, option }) => WAPI.archiveChat(chatId, option),
      { chatId, option }
    );
  }

  /**
   * Pin and Unpin chat messages with true or false
   * @param chatId {string} id '000000000000@c.us'
   * @param option {boolean} true or false
   * @param nonExistent {boolean} Pin chat, non-existent (optional)
   * @returns object
   */
  public async pinChat(chatId: string, option: boolean, nonExistent?: boolean) {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ chatId, option, nonExistent }) => {
          return WAPI.pinChat(chatId, option, nonExistent);
        },
        { chatId, option, nonExistent }
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Deletes all messages of given chat
   * @param chatId
   * @returns boolean
   */
  public async clearChatMessages(chatId: string) {
    return this.page.evaluate(
      (chatId) => WAPI.clearChatMessages(chatId),
      chatId
    );
  }

  /**
   * Deletes message of given message id
   * @param chatId The chat id from which to delete the message.
   * @param messageId The specific message id of the message to be deleted
   * @param onlyLocal If it should only delete locally (message remains on the other recipienct's phone). Defaults to false.
   */
  public async deleteMessage(
    chatId: string,
    messageId: string[]
  ): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'deleteMessage';
      const type = 'string';
      const check = [
        {
          param: 'chatId',
          type: type,
          value: chatId,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'messageId',
          type: 'object',
          value: messageId,
          function: typeFunction,
          isUser: true
        }
      ];

      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = await this.page.evaluate(
        ({ chatId, messageId }) => WAPI.deleteMessages(chatId, messageId),
        { chatId, messageId }
      );

      if (result['erro'] === true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Archive and unarchive chat messages with true or false
   * @param chatId {string} id '000000000000@c.us'
   * @param option {boolean} true or false
   * @returns boolean
   */
  public async setMessagesAdminsOnly(chatId: string, option: boolean) {
    return this.page.evaluate(
      ({ chatId, option }) => WAPI.setMessagesAdminsOnly(chatId, option),
      { chatId, option }
    );
  }

  public async reload() {
    await this.page.evaluate(() => {
      window.location.reload();
    });
  }
}

```

`src/api/layers/group.layer.ts`:

```ts
import { Page, Browser } from 'puppeteer';
import { CreateConfig } from '../../config/create-config';
import { RetrieverLayer } from './retriever.layer';
import { checkValuesSender } from '../helpers/layers-interface';
import {
  base64MimeType,
  fileToBase64,
  downloadFileToBase64,
  resizeImg
} from '../helpers';
import { GroupSettings } from '../model/enum';

export class GroupLayer extends RetrieverLayer {
  constructor(
    public browser: Browser,
    public page: Page,
    session?: string,
    options?: CreateConfig
  ) {
    super(browser, page, session, options);
  }

  /**
   * Parameters to change group settings, see {@link GroupSettings for details}
   * @param {string} groupId group number
   * @param {GroupSettings} settings
   * @param {boolean} value
   */
  public async setGroupSettings(
    groupId: string,
    settings: GroupSettings,
    value: boolean
  ): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'setGroupSettings';
      const type = 'string';
      const check = [
        {
          param: 'groupId',
          type: type,
          value: groupId,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'settings',
          type: type,
          value: settings,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'value',
          type: type,
          value: value,
          function: typeFunction,
          isUser: true
        }
      ];

      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }

      const result = await this.page.evaluate(
        ({ groupId, settings, value }) => {
          return WAPI.setGroupSettings(groupId, settings, value);
        },
        { groupId, settings, value }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Parameters to change group image
   * @param {string} groupId group number
   * @param {string} path of image
   */
  public async setGroupImage(groupId: string, path: string) {
    let b64 = await downloadFileToBase64(path, [
      'image/gif',
      'image/png',
      'image/jpg',
      'image/jpeg',
      'image/webp'
    ]);
    if (!b64) {
      b64 = await fileToBase64(path);
    }
    if (b64) {
      const buff = Buffer.from(
        b64.replace(/^data:image\/(png|jpe?g|webp);base64,/, ''),
        'base64'
      );
      const mimeInfo = base64MimeType(b64);

      if (!mimeInfo || mimeInfo.includes('image')) {
        let _webb64_96 = await resizeImg(buff, { width: 96, height: 96 }),
          _webb64_640 = await resizeImg(buff, { width: 640, height: 640 });
        let obj = { a: _webb64_640, b: _webb64_96 };

        return await this.page.evaluate(
          ({ obj, groupId }) => WAPI.setProfilePic(obj, groupId),
          {
            obj,
            groupId
          }
        );
      } else {
        console.log('Not an image, allowed formats png, jpeg and webp');
        return false;
      }
    }
  }

  /**
   * Parameters to change group title
   * @param {string} groupId group number
   * @param {string} title group title
   */
  public async setGroupTitle(groupId: string, title: string): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'setGroupTitle';
      const type = 'string';
      const check = [
        {
          param: 'groupId',
          type: type,
          value: groupId,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'title',
          type: type,
          value: title,
          function: typeFunction,
          isUser: true
        }
      ];

      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }

      const result = await this.page.evaluate(
        ({ groupId, title }) => {
          return WAPI.setGroupTitle(groupId, title);
        },
        { groupId, title }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Parameters to change group description
   * @param {string} groupId group number
   * @param {string} description group description
   */
  public async setGroupDescription(
    groupId: string,
    description: string
  ): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'setGroupDescription';
      const type = 'string';
      const check = [
        {
          param: 'groupId',
          type: type,
          value: groupId,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'description',
          type: type,
          value: description,
          function: typeFunction,
          isUser: true
        }
      ];

      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }

      const result = await this.page.evaluate(
        ({ groupId, description }) => {
          return WAPI.setGroupDescription(groupId, description);
        },
        { groupId, description }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Retrieve all groups
   * @returns array of groups
   */
  public async getAllChatsGroups() {
    return await this.page.evaluate(async () => {
      let chats = WAPI.getAllChats();
      return (await chats).filter((chat) => chat.kind === 'group');
    });
  }

  /**
   * Retrieve all groups new messages
   * @returns array of groups
   */
  public async getChatGroupNewMsg() {
    return await this.page.evaluate(() => {
      let chats = WAPI.getAllChatsWithNewMsg();
      return chats.filter((chat) => chat.kind === 'group');
    });
  }

  /**
   * Removes the host device from the group
   * @param groupId group id
   */
  public async leaveGroup(groupId: string) {
    return this.page.evaluate((groupId) => WAPI.leaveGroup(groupId), groupId);
  }

  /**
   * Retrieves group members as [Id] objects
   * @param groupId group id
   */
  public async getGroupMembers(groupId: string, time: string): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'getGroupMembers';
      const type = 'string';
      const check = [
        {
          param: 'groupId',
          type: type,
          value: groupId,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = this.page.evaluate(
        (groupId: string, time: string) =>
          WAPI.getGroupParticipant(groupId, time),
        groupId,
        time
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  // /**
  //  * Returns group members [Contact] objects
  //  * @param groupId
  //  */
  // public async getGroupMembers(groupId: string) {
  //   const membersIds = await this.getGroupMembersIds(groupId);
  //   const actions = membersIds.map((memberId) => {
  //     return this.getContact(memberId._serialized);
  //   });
  //   return Promise.all(actions);
  // }

  /**
   * Reset group invitation link
   * @param chatId
   * @returns boolean
   */
  public async revokeGroupInviteLink(chatId: string) {
    return await this.page.evaluate(
      (chatId) => WAPI.revokeGroupInviteLink(chatId),
      chatId
    );
  }

  /**
   * Generates group-invite link
   * @param chatId
   * @returns Invitation link
   */
  public async getGroupInviteLink(chatId: string) {
    return await this.page.evaluate(
      (chatId) => WAPI.getGroupInviteLink(chatId),
      chatId
    );
  }
  /**
   * Generates group-invite link
   * @param inviteCode
   * @returns Invite code from group link. Example: CMJYfPFqRyE2GxrnkldYED
   */
  public async getGroupInfoFromInviteLink(inviteCode: string) {
    inviteCode = inviteCode.replace('chat.whatsapp.com/', '');
    inviteCode = inviteCode.replace('invite/', '');
    inviteCode = inviteCode.replace('https://', '');
    inviteCode = inviteCode.replace('http://', '');
    return await this.page.evaluate(
      (inviteCode) => WAPI.getGroupInfoFromInviteLink(inviteCode),
      inviteCode
    );
  }

  /**
   * Creates a new chat group
   * @param groupName Group name
   * @param contacts Contacts that should be added.
   */
  public async createGroup(groupName: string, contacts: string | string[]) {
    return await this.page.evaluate(
      ({ groupName, contacts }) => WAPI.createGroup(groupName, contacts),
      { groupName, contacts }
    );
  }

  /**
   * Removes participant from group
   * @param groupId Chat id ('0000000000-00000000@g.us')
   * @param participantId Participant id'000000000000@c.us'
   */
  public async removeParticipant(
    groupId: string,
    participantId: string | string[]
  ) {
    return await this.page.evaluate(
      ({ groupId, participantId }) =>
        WAPI.removeParticipant(groupId, participantId),
      { groupId, participantId }
    );
  }

  /**
   * Adds participant to Group
   * @param groupId Chat id ('0000000000-00000000@g.us')
   * @param participantId Participant id'000000000000@c.us'
   */
  public async addParticipant(
    groupId: string,
    participantId: string | string[]
  ) {
    return await this.page.evaluate(
      ({ groupId, participantId }) =>
        WAPI.addParticipant(groupId, participantId),
      { groupId, participantId }
    );
  }

  /**
   * Promotes participant as Admin in given group
   * @param groupId Chat id ('0000000000-00000000@g.us')
   * @param participantId Participant id'000000000000@c.us'
   */
  public async promoteParticipant(
    groupId: string,
    participantId: string | string[]
  ) {
    return await this.page.evaluate(
      ({ groupId, participantId }) =>
        WAPI.promoteParticipant(groupId, participantId),
      { groupId, participantId }
    );
  }

  /**
   * Demotes admin privileges of participant
   * @param groupId Chat id ('0000000000-00000000@g.us')
   * @param participantId Participant id'000000000000@c.us'
   */
  public async demoteParticipant(
    groupId: string,
    participantId: string | string[]
  ) {
    return await this.page.evaluate(
      ({ groupId, participantId }) =>
        WAPI.demoteParticipant(groupId, participantId),
      { groupId, participantId }
    );
  }

  /**
   * Retrieves group admins
   * @param groupId Group/Chat id ('0000000000-00000000@g.us')
   */
  public async getGroupAdmins(groupId: string): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'getGroupAdmins';
      const type = 'string';
      const check = [
        {
          param: 'groupId',
          type: type,
          value: groupId,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = this.page.evaluate(
        (groupId: string) => WAPI.getGroupAdmins(groupId),
        groupId
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }
  /**
   * Join a group with invite code
   * @param inviteCode
   */
  public async joinGroup(inviteCode: string) {
    inviteCode = inviteCode.replace('chat.whatsapp.com/', '');
    inviteCode = inviteCode.replace('invite/', '');
    inviteCode = inviteCode.replace('https://', '');
    inviteCode = inviteCode.replace('http://', '');
    return await this.page.evaluate(
      (inviteCode) => WAPI.joinGroup(inviteCode),
      inviteCode
    );
  }
}

```

`src/api/layers/host.layer.ts`:

```ts
import { Page, Browser } from 'puppeteer';
import { CreateConfig, defaultOptions } from '../../config/create-config';
import { SocketState } from '../model/enum';
//import { injectApi } from '../../controllers/browser';
import { ScrapQrcode } from '../model/qrcode';
import { scrapeImg } from '../helpers';
import {
  asciiQr,
  isAuthenticated,
  isInsideChats,
  needsToScan,
  retrieveQR
} from '../../controllers/auth';
import { sleep } from '../../utils/sleep';
import { getSpinnies } from '../../utils/spinnies';
import * as Spinnies from 'spinnies';

export class HostLayer {
  readonly session: string;
  readonly options: CreateConfig;

  protected spinnies: Spinnies = getSpinnies();
  protected spinStatus = {
    apiInject: '',
    autoCloseRemain: 0,
    previousText: '',
    previousStatus: null,
    state: ''
  };

  protected autoCloseInterval = null;
  protected statusFind?: (statusGet: string, session: string) => void = null;

  constructor(
    public browser: Browser,
    public page: Page,
    session?: string,
    options?: CreateConfig
  ) {
    this.session = session;
    this.options = { ...defaultOptions, ...options };

    // this.spin('Initializing...', 'spinning');
    //this._initialize(this.page);
  }

  protected spin(text?: string, status?: Spinnies.SpinnerStatus) {
    const name = `session-${this.session}`;

    text = text || this.spinStatus.previousText;
    this.spinStatus.previousText = text;

    status =
      status || (this.spinStatus.previousStatus as Spinnies.SpinnerStatus);
    this.spinStatus.previousStatus = status;

    let fullText = `[instance: ${this.session}`;
    // if (this.spinStatus.state) {
    //   fullText += `, ${this.spinStatus.state}`;
    // }
    fullText += `]: ${text}`;

    let prevText = '';

    try {
      prevText = this.spinnies.pick(name).text;
    } catch (error) {
      this.spinnies.add(name, { text: fullText, status });
      prevText = fullText;
    }
    if (prevText !== fullText) {
      this.spinnies.update(name, {
        text: fullText,
        status
      });
    }
  }

  // public async _initialize(page: Page) {
  //   this.spinStatus.apiInject = 'injecting';
  //   await injectApi(page)
  //     .then(() => {
  //       this.spinStatus.apiInject = 'injected';
  //     })
  //     .catch(() => {
  //       this.spinStatus.apiInject = 'failed';
  //     });
  // }

  protected tryAutoClose() {
    if (
      this.options.autoClose > 0 &&
      !this.autoCloseInterval &&
      !this.page.isClosed()
    ) {
      this.statusFind && this.statusFind('autocloseCalled', this.session);
      this.page.close().catch(() => {});
      this.browser.close().catch(() => {});
    }
  }

  protected startAutoClose() {
    if (this.options.autoClose > 0 && !this.autoCloseInterval) {
      let remain = this.options.autoClose;
      try {
        this.autoCloseInterval = setInterval(() => {
          if (this.page.isClosed()) {
            this.cancelAutoClose();
            return;
          }
          remain -= 1000;
          this.spinStatus.autoCloseRemain = Math.round(remain / 1000);
          if (remain <= 0) {
            this.cancelAutoClose();
            this.tryAutoClose();
          }
        }, 1000);
      } catch (e) {}
    }
  }

  public cancelAutoClose() {
    clearInterval(this.autoCloseInterval);
    this.autoCloseInterval = null;
  }

  public async getQrCode() {
    let qrResult: ScrapQrcode | undefined | any;

    qrResult = await scrapeImg(this.page).catch((e) => console.log(e));
    if (!qrResult || !qrResult.urlCode) {
      qrResult = await retrieveQR(this.page).catch((e) => console.log(e));
    }
    return qrResult;
  }

  public async waitForQrCodeScan(
    catchQR?: (
      qrCode: string,
      asciiQR: string,
      attempt: number,
      urlCode?: string
    ) => void
  ) {
    let urlCode = null;
    let attempt = 0;

    while (true) {
      let needsScan = await needsToScan(this.page).catch(() => null);
      if (!needsScan) {
        break;
      }
      const result = await this.getQrCode().catch(() => null);

      if (!result.urlCode) {
        break;
      }

      if (urlCode !== result.urlCode) {
        urlCode = result.urlCode;
        attempt++;

        let qr = '';

        if (this.options.logQR || catchQR) {
          qr = await asciiQr(urlCode).catch(() => undefined);
        }

        if (this.options.logQR) {
          console.log(qr);
        } else {
          this.spin(`Waiting for QRCode Scan: Attempt ${attempt}`);
        }

        if (catchQR) {
          catchQR(result.base64Image, qr, attempt, result.urlCode);
        }
      }
      await sleep(200).catch(() => undefined);
    }
  }

  public async waitForInChat() {
    let inChat = await isInsideChats(this.page);

    while (inChat === false) {
      await sleep(200);
      inChat = await isInsideChats(this.page);
    }
    return inChat;
  }

  public async waitForLogin(
    catchQR?: (
      qrCode: string,
      asciiQR: string,
      attempt: number,
      urlCode?: string
    ) => void,
    statusFind?: (statusGet: string, session?: string) => void
  ) {
    this.statusFind = statusFind;

    this.spin('Waiting page load', 'spinning');

    this.spin('Checking is logged...');
    let authenticated = await isAuthenticated(this.page).catch(() => null);

    if (typeof authenticated === 'object' && authenticated.type) {
      this.spin(`Error http: ${authenticated.type}`, 'fail');
      this.page.close().catch(() => {});
      this.browser.close().catch(() => {});
      throw `Error http: ${authenticated.type}`;
    }

    this.startAutoClose();

    if (authenticated === false) {
      this.spin('Waiting for QRCode Scan...');
      statusFind && statusFind('notLogged', this.session);

      await this.waitForQrCodeScan(catchQR).catch(() => undefined);

      this.spin('Checking QRCode status...');

      // Wait for interface update
      await sleep(200);
      authenticated = await isAuthenticated(this.page).catch(() => null);

      if (authenticated === null || JSON.stringify(authenticated) === '{}') {
        this.spin('Failed to authenticate');
        statusFind && statusFind('qrReadFail', this.session);
      } else if (authenticated) {
        this.spin('QRCode Success');
        statusFind && statusFind('qrReadSuccess', this.session);
      } else {
        this.spin('QRCode Fail', 'fail');
        statusFind && statusFind('qrReadFail', this.session);
        this.cancelAutoClose();
        this.tryAutoClose();
        throw 'Failed to read the QRCode';
      }
    } else if (authenticated === true) {
      this.spin('Authenticated');
      statusFind && statusFind('isLogged', this.session);
    }

    if (authenticated === true) {
      // Reinicia o contador do autoclose
      this.cancelAutoClose();
      this.startAutoClose();
      // Wait for interface update
      await sleep(200);
      this.spin('Checking phone is connected...');
      const inChat = await this.waitForInChat();

      if (!inChat) {
        this.spin('Phone not connected', 'fail');
        statusFind && statusFind('phoneNotConnected', this.session);
        this.cancelAutoClose();
        this.tryAutoClose();
        throw new Error('Phone not connected');
      }
      this.cancelAutoClose();
      this.spin('Connected', 'succeed');
      //   statusFind && statusFind('inChat', this.session);
      return true;
    }

    if (authenticated === false) {
      this.cancelAutoClose();
      this.tryAutoClose();
      this.spin('Not logged', 'fail');
      throw new Error('Not logged');
    }

    this.cancelAutoClose();
    this.tryAutoClose();
    this.spin('Unknow error', 'fail');
  }

  //Pro
  /**
   * Set offline
   */
  public async setPresenceOffline() {
    return await this.page.evaluate(() => WAPI.setPresenceOffline());
  }

  //Pro
  /**
   * Set online
   */
  public async setPresenceOnline() {
    return await this.page.evaluate(() => WAPI.setPresenceOnline());
  }

  /**
   * Delete the Service Workers
   */
  public async killServiceWorker() {
    return await this.page.evaluate(() => WAPI.killServiceWorker());
  }

  /**
   * Load the service again
   */
  public async restartService() {
    return await this.page.evaluate(() => WAPI.restartService());
  }

  /**
   * @returns Current host device details
   */
  public async getHostDevice(): Promise<Object> {
    return await this.page.evaluate(() => WAPI.getHost());
  }

  /**
   * Retrieves WA version
   */
  public async getWAVersion() {
    return await this.page.evaluate(() => WAPI.getWAVersion());
  }

  /**
   * Retrieves the connecction state
   */
  public async getConnectionState(): Promise<SocketState> {
    return await this.page.evaluate(() => {
      //@ts-ignore
      return Store.State.Socket.state;
    });
  }

  /**
   * Retrieves if the phone is online. Please note that this may not be real time.
   */
  public async isConnected() {
    return await this.page.evaluate(() => WAPI.isConnected());
  }

  /**
   * Retrieves if the phone is online. Please note that this may not be real time.
   */
  public async isLoggedIn() {
    return await this.page.evaluate(() => WAPI.isLoggedIn());
  }

  /**
   * Retrieves Battery Level
   */
  public async getBatteryLevel() {
    return await this.page.evaluate(() => WAPI.getBatteryLevel());
  }
}

```

`src/api/layers/index.ts`:

```ts
export { CallbackOnStatus } from './callback-on.layes';

```

`src/api/layers/listener.layer.ts`:

```ts
import { EventEmitter } from 'events';
import { Page, Browser } from 'puppeteer';
import { CreateConfig } from '../../config/create-config';
import { ExposedFn } from '../helpers/exposed.enum';
import {
  Ack,
  Chat,
  LiveLocation,
  Message,
  ParticipantEvent,
  PicTumb,
  ChatStatus
} from '../model';
import { SocketState, SocketStream } from '../model/enum';
import { InterfaceChangeMode } from '../model';
import { InterfaceMode } from '../model/enum/interface-mode';
import { InterfaceState } from '../model/enum/interface-state';
import { ProfileLayer } from './profile.layer';
import { callbackWile } from '../helpers';

declare global {
  interface Window {
    onMessage: any;
    onAnyMessage: any;
    onStateChange: any;
    onIncomingCall: any;
    onAck: any;
    onStreamChange: any;
    onFilePicThumb: any;
    onChatState: any;
    onUnreadMessage: any;
    onInterfaceChange: any;
    onAddedToGroup: any;
    func: any;
    onLiveLocation: any;
    waitNewMessages: any;
    onPoll: any;
  }
}

const callonMessage = new callbackWile();
const callOnack = new callbackWile();

export class ListenerLayer extends ProfileLayer {
  private listenerEmitter = new EventEmitter();

  constructor(
    public browser: Browser,
    public page: Page,
    session?: string,
    options?: CreateConfig
  ) {
    super(browser, page, session, options);

    this.page.on('close', () => {
      this.cancelAutoClose();
      this.spin('Page Closed', 'fail');
    });
  }

  public async initialize() {
    const functions = [...Object.values(ExposedFn)];

    for (const func of functions) {
      const has = await this.page
        .evaluate((func) => typeof window[func] === 'function', func)
        .catch(() => false);

      if (!has) {
        await this.page
          .exposeFunction(func, (...args: any) =>
            this.listenerEmitter.emit(func, ...args)
          )
          .catch(() => {});
      }
    }

    this.addMsg();
    await this.page
      .evaluate(() => {
        window.WAPI.onInterfaceChange((e: any) => {
          window.onInterfaceChange(e);
        });
        window.WAPI.onStreamChange((e: any) => {
          window.onStreamChange(e);
        });
        window.WAPI.onChatState((e: any) => {
          window.onChatState(e);
        });
        window.WAPI.onStateChange((e: any) => {
          window.onStateChange(e);
        });
        window.WAPI.onUnreadMessage((e: any) => {
          window.onUnreadMessage(e);
        });
        window.WAPI.waitNewMessages(false, (data: any) => {
          data.forEach((message: any) => {
            window.onMessage(message);
          });
        });
        window.WAPI.onAddedToGroup((e: any) => {
          window.onAddedToGroup(e);
        });
        window.WAPI.onAck((e: any) => {
          window.onAck(e);
        });
        window.WAPI.onPoll((e: any) => {
          window.onPoll(e);
        });
      })
      .catch(() => {});
  }

  public async addMsg() {
    this.page
      .evaluate(() => {
        let isHeroEqual = {};
        // try {
        window.Store.Msg.on('add', async (newMessage) => {
          if (!Object.is(isHeroEqual, newMessage)) {
            isHeroEqual = newMessage;
            if (newMessage && newMessage.isNewMsg) {
              const processMessageObj = await window.WAPI.processMessageObj(
                newMessage,
                true,
                false
              );
              window.onAnyMessage(processMessageObj);
            }
          }
        });
        // } catch { }
      })
      .catch(() => {});
  }

  public async onPoll(fn: (ack: any) => void) {
    this.listenerEmitter.on(ExposedFn.onPoll, (e) => {
      fn(e);
    });

    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.onPoll, (e) => {
          fn(e);
        });
      }
    };
  }

  /**
   * @event Listens to all new messages
   * @param to callback
   * @fires Message
   */
  public async onAnyMessage(fn: (message: Message) => void) {
    this.listenerEmitter.on(ExposedFn.OnAnyMessage, (msg) => {
      fn(msg);
    });

    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.OnAnyMessage, (msg) => {
          fn(msg);
        });
      }
    };
  }

  /**
   * @event Listens to messages received
   * @returns Observable stream of messages
   */
  public async onStateChange(fn: (state: SocketState) => void) {
    this.listenerEmitter.on(ExposedFn.onStateChange, fn);

    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.onStateChange, fn);
      }
    };
  }

  /**
   * @returns Returns chat state
   */
  public async onChatState(fn: (state: ChatStatus) => void) {
    this.listenerEmitter.on(ExposedFn.onChatState, (state: ChatStatus) => {
      fn(state);
    });
    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.onChatState, fn);
      }
    };
  }

  ////////////////////////////////////////////////////
  /**
   * @returns Returns the current state of the connection
   */
  public async onStreamChange(fn: (state: SocketStream) => void) {
    this.listenerEmitter.on(ExposedFn.onStreamChange, (state: SocketStream) => {
      fn(state);
    });
    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.onStreamChange, fn);
      }
    };
  }

  /**
   * @event Listens to interface mode change See {@link InterfaceState} and {@link InterfaceMode} for details
   * @returns A disposable object to cancel the event
   */
  public async onInterfaceChange(
    fn: (state: {
      displayInfo: InterfaceState;
      mode: InterfaceMode;
      info: InterfaceState;
    }) => void | InterfaceChangeMode | Promise<any>
  ) {
    this.listenerEmitter.on(ExposedFn.onInterfaceChange, fn);

    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.onInterfaceChange, fn);
      }
    };
  }

  //////////////////////////////////////PRO
  /**
   * @returns Returns new UnreadMessage
   */
  public async onUnreadMessage(fn: (unread: Message) => void) {
    this.listenerEmitter.on(ExposedFn.onUnreadMessage, fn);
    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.onUnreadMessage, fn);
      }
    };
  }

  /**
   * @returns Returns new PicThumb
   */
  public async onFilePicThumb(fn: (pic: PicTumb) => void) {
    this.listenerEmitter.on(ExposedFn.onFilePicThumb, fn);
    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.onFilePicThumb, fn);
      }
    };
  }

  /**
   * @event Listens to messages received
   * @returns Observable stream of messages
   */
  public async onMessage(fn: (message: Message) => void) {
    this.listenerEmitter.on(ExposedFn.OnMessage, (state: Message) => {
      if (!callonMessage.checkObj(state.from, state.id)) {
        callonMessage.addObjects(state.from, state.id);
        fn(state);
      }
    });
    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.OnMessage, (state: Message) => {
          if (!callonMessage.checkObj(state.from, state.id)) {
            callonMessage.addObjects(state.from, state.id);
            fn(state);
          }
        });
      }
    };
  }

  /**
   * @event Listens to messages acknowledgement Changes
   * @returns Observable stream of messages
   */
  public async onAck(fn: (ack: Ack) => void) {
    this.listenerEmitter.on(ExposedFn.onAck, (e: Ack) => {
      if (!callOnack.checkObj(e.ack, e.id._serialized)) {
        let key = callOnack.getObjKey(e.id._serialized);
        if (key) {
          callOnack.module[key].id = e.ack;
          fn(e);
        } else {
          callOnack.addObjects(e.ack, e.id._serialized);
          fn(e);
        }
      }
    });

    return {
      dispose: () => {
        this.listenerEmitter.off(ExposedFn.onAck, (e: Ack) => {
          if (!callOnack.checkObj(e.ack, e.id._serialized)) {
            let key = callOnack.getObjKey(e.id._serialized);
            if (key) {
              callOnack.module[key].id = e.ack;
              fn(e);
            } else {
              callOnack.addObjects(e.ack, e.id._serialized);
              fn(e);
            }
          }
        });
      }
    };
  }

  /**
   * @event Listens to live locations from a chat that already has valid live locations
   * @param chatId the chat from which you want to subscribes to live location updates
   * @param fn callback that takes in a LiveLocation
   * @returns boolean, if returns false then there were no valid live locations in the chat of chatId
   * @emits <LiveLocation> LiveLocation
   */
  public async onLiveLocation(
    chatId: string,
    fn: (liveLocationChangedEvent: LiveLocation) => void
  ) {
    const method = 'onLiveLocation_' + chatId.replace('_', '').replace('_', '');
    return this.page
      .exposeFunction(method, (liveLocationChangedEvent: LiveLocation) =>
        fn(liveLocationChangedEvent)
      )
      .then((_) =>
        this.page.evaluate(
          ({ chatId, method }) => {
            //@ts-ignore
            return WAPI.onLiveLocation(chatId, window[method]);
          },
          { chatId, method }
        )
      );
  }

  /**
   * @event Listens to participants changed
   * @param to group id: xxxxx-yyyy@us.c
   * @param to callback
   * @returns Stream of ParticipantEvent
   */
  public async onParticipantsChanged(
    groupId: string,
    fn: (participantChangedEvent: ParticipantEvent) => void
  ) {
    const method =
      'onParticipantsChanged_' + groupId.replace('_', '').replace('_', '');
    return this.page
      .exposeFunction(method, (participantChangedEvent: ParticipantEvent) =>
        fn(participantChangedEvent)
      )
      .then((_) =>
        this.page.evaluate(
          ({ groupId, method }) => {
            //@ts-ignore
            WAPI.onParticipantsChanged(groupId, window[method]);
          },
          { groupId, method }
        )
      );
  }

  /**
   * @event Fires callback with Chat object every time the host phone is added to a group.
   * @param to callback
   * @returns Observable stream of Chats
   */
  public async onAddedToGroup(fn: (chat: Chat) => any) {
    this.listenerEmitter.on('onAddedToGroup', fn);

    return {
      dispose: () => {
        this.listenerEmitter.off('onAddedToGroup', fn);
      }
    };
  }

  /**
   * @event Listens to messages received
   * @returns Observable stream of messages
   */
  public async onIncomingCall(fn: (call: any) => any) {
    this.listenerEmitter.on('onIncomingCall', fn);

    return {
      dispose: () => {
        this.listenerEmitter.off('onIncomingCall', fn);
      }
    };
  }
}

```

`src/api/layers/profile.layer.ts`:

```ts
import { Page, Browser } from 'puppeteer';
import { HostLayer } from './host.layer';
import * as path from 'path';
const { exec } = require('child_process');

const fs = require('fs');
import {
  base64MimeType,
  fileToBase64,
  downloadFileToBase64,
  resizeImg
} from '../helpers';
import { CreateConfig } from '../../config/create-config';

export class ProfileLayer extends HostLayer {
  constructor(
    public browser: Browser,
    public page: Page,
    session?: string,
    options?: CreateConfig
  ) {
    super(browser, page, session, options);
  }

  public async clearToken() {
    await this.page.evaluate(() => {
      localStorage.clear();
      window.location.reload();
    });
  }

  /**
   * @param contactsId Example: 0000@c.us | [000@c.us, 1111@c.us]
   * @param time duration of silence
   * @param type kind of silence "hours" "minutes" "year"
   * To remove the silence, just enter the contact parameter
   */
  public sendMute(id: string, time: number, type: string): Promise<object> {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        (id, time, type) => WAPI.sendMute(id, time, type),
        id,
        time,
        type
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Change the theme
   * @param string types "dark" or "light"
   */
  public setTheme(type: string) {
    return this.page.evaluate((type) => WAPI.setTheme(type), type);
  }

  /**
   * Sets current user profile status
   * @param status
   */
  public async setProfileStatus(status: string) {
    return await this.page.evaluate(
      ({ status }) => {
        WAPI.setMyStatus(status);
      },
      { status }
    );
  }

  /**
   * Sets the user's current profile photo
   * @param name
   */
  public async setProfilePic(path: string, to?: string) {
    let b64 = await downloadFileToBase64(path, [
      'image/gif',
      'image/png',
      'image/jpg',
      'image/jpeg',
      'image/webp'
    ]);
    if (!b64) {
      b64 = await fileToBase64(path);
    }
    if (b64) {
      const buff = Buffer.from(
        b64.replace(/^data:image\/(png|jpe?g|webp);base64,/, ''),
        'base64'
      );
      const mimeInfo = base64MimeType(b64);

      if (!mimeInfo || mimeInfo.includes('image')) {
        let _webb64_96 = await resizeImg(buff, { width: 96, height: 96 }),
          _webb64_640 = await resizeImg(buff, { width: 640, height: 640 });
        let obj = { a: _webb64_640, b: _webb64_96 };

        return await this.page.evaluate(
          ({ obj, to }) => WAPI.setProfilePic(obj, to),
          {
            obj,
            to
          }
        );
      } else {
        console.log('Not an image, allowed formats png, jpeg and webp');
        return false;
      }
    }
  }

  /**
   * Sets current user profile name
   * @param name
   */
  public async setProfileName(name: string) {
    return this.page.evaluate(
      ({ name }) => {
        WAPI.setMyName(name);
      },
      { name }
    );
  }

  public async delProfile() {
    if (!this.page.isClosed()) {
      await this.page.evaluate(() => WAPI.logout()).catch(() => {});
      await this.page.close().catch(() => {});
      await this.browser.close().catch(() => {});
      const folderSession = path.join(
        path.resolve(
          process.cwd(),
          this.options.mkdirFolderToken,
          this.options.folderNameToken,
          this.session
        )
      );
      if (fs.existsSync(folderSession)) {
        try {
          fs.rmSync(folderSession, {
            recursive: true,
            force: true
          });
        } catch {
          exec(`rm -Rf ${folderSession}`).catch(() => {});
        }
      }
    }
  }
}

```

`src/api/layers/retriever.layer.ts`:

```ts
import { Page, Browser } from 'puppeteer';
import { CreateConfig } from '../../config/create-config';
import { WhatsappProfile } from '../model';
import { SenderLayer } from './sender.layer';
import { checkValuesSender } from '../helpers/layers-interface';

export class RetrieverLayer extends SenderLayer {
  constructor(
    public browser: Browser,
    public page: Page,
    session?: string,
    options?: CreateConfig
  ) {
    super(browser, page, session, options);
  }

  /**
 * Return messages by dates!
 * @param {string} id contact number id
 * @param {string} type 
  types:
  lowerThan: Return all messages after the date informed;
  higherThan: Return all messages before the date informed;
  equal: Return all messages from the informed date;
  full: Return all messages, with two new stringdate parameters, dateNumeric;
 * @param {string} date Pass the example date 00/00/0000 or 00-00-0000
 * @param {string} date Pass the example time 00:00 24 hours
 */
  public async getAllMessagesDate(
    chatId: string,
    type: string,
    idateStart: string,
    time: string,
    limit: number
  ) {
    return await this.page.evaluate(
      ({ chatId, type, idateStart, time, limit }) =>
        WAPI.getAllMessagesDate(chatId, type, idateStart, time, limit),
      { chatId, type, idateStart, time, limit }
    );
  }

  public async getNewMessageId(chatId: string) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'getNewMessageId';
      const type = 'string';
      const check = [
        {
          param: 'text',
          type: type,
          value: chatId,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }

      const result = await this.page.evaluate(
        (chatId: string) => WAPI.getNewMessageId(chatId),
        chatId
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }
  /**
   * Returns a list of mute and non-mute users
   * @param type return type: all, toMute and noMute.
   * @returns obj
   */
  public async getListMutes(type?: string) {
    return await this.page.evaluate(
      (type: string) => WAPI.getListMute(type),
      type
    );
  }

  /**
   * Returns state connection
   * @returns obj
   */
  public async getStateConnection() {
    return await this.page.evaluate(() => WAPI.getStateConnection());
  }

  /**
   * Receive the current theme
   * @returns string light or dark
   */
  public async getTheme() {
    return await this.page.evaluate(() => WAPI.getTheme());
  }

  /**
   * Receive all blocked contacts
   * @returns array of [0,1,2,3....]
   */
  public async getBlockList() {
    return await this.page.evaluate(() => WAPI.getBlockList());
  }

  /**
   * Retrieves all chats
   * @returns array of [Chat]
   */
  public async getAllChats() {
    return await this.page.evaluate(() => {
      let chats = WAPI.getAllChats();
      return chats;
    });
  }

  /**
   * Retrieves all chats new messages
   * @returns array of [Chat]
   */
  public async getAllChatsNewMsg() {
    return await this.page.evaluate(() => {
      let chats = WAPI.getAllChatsWithNewMsg();
      return chats;
    });
  }

  /**
   * Retrieves all chats Contacts
   * @returns array of [Chat]
   */
  public async getAllChatsContacts() {
    return await this.page.evaluate(async () => {
      let chats = WAPI.getAllChats(),
        filter = (await chats).filter((chat) => chat.kind === 'chat');
      return filter;
    });
  }

  /**
   * Checks if a number is a valid WA number
   * @param contactId, you need to include the @c.us at the end.
   * @returns contact detial as promise
   */
  public async checkNumberStatus(contactId: string): Promise<WhatsappProfile> {
    return new Promise(async (resolve, reject) => {
      const result: WhatsappProfile = await this.page.evaluate(
        (contactId) => WAPI.checkNumberStatus(contactId),
        contactId
      );
      if (result['status'] !== 200) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Retrieves all chats with messages
   * @returns array of [Chat]
   */
  public async getAllChatsWithMessages(withNewMessageOnly = false) {
    return this.page.evaluate(
      (withNewMessageOnly: boolean) =>
        WAPI.getAllChatsWithMessages(withNewMessageOnly),
      withNewMessageOnly
    );
  }

  /**
   * Retrieve all contact new messages
   * @returns array of groups
   */
  public async getChatContactNewMsg() {
    // prettier-ignore
    const chats = await this.page.evaluate(() => WAPI.getAllChatsWithNewMsg());
    return chats.filter((chat) => chat.kind === 'chat');
  }

  /**
   * Retrieves contact detail object of given contact id
   * @param contactId
   * @returns contact detial as promise
   */
  public async getContact(contactId: string) {
    return this.page.evaluate(
      (contactId) => WAPI.getContact(contactId),
      contactId
    );
  }

  /**
   * Retrieves all contacts
   * @returns array of [Contact]
   */
  public async getAllContacts() {
    return await this.page.evaluate(() => WAPI.getAllContacts());
  }

  /**
   * Retrieves all chats Transmission list
   * @returns array of [Chat]
   */
  public async getAllChatsTransmission() {
    return await this.page.evaluate(async () => {
      let chats = WAPI.getAllChats();
      return (await chats).filter((chat) => chat.kind === 'broadcast');
    });
  }

  /**
   * Retrieves chat object of given contact id
   * @param contactId
   * @returns contact detial as promise
   */
  public async getChatById(contactId: string) {
    return await this.page.evaluate(
      (contactId) => WAPI.getChatById(contactId),
      contactId
    );
  }

  /**
   * Retrieves chat object of given contact id
   * @param contactId
   * @returns contact detial as promise
   * @deprecated
   */
  public async getChat(contactId: string) {
    return await this.getChatById(contactId);
  }

  /**
   * Retrieves chat picture
   * @param chatId Chat id
   * @returns url of the chat picture or undefined if there is no picture for the chat.
   */
  public async getProfilePicFromServer(chatId: string) {
    return this.page.evaluate(
      (chatId) => WAPI.getProfilePicFromServer(chatId),
      chatId
    );
  }

  /**
   * Load more messages in chat object from server. Use this in a while loop
   * @param contactId
   * @returns contact detial as promise
   * @deprecated
   */
  public async loadEarlierMessages(contactId: string) {
    return this.page.evaluate(
      (contactId: string) => WAPI.loadEarlierMessages(contactId),
      contactId
    );
  }

  /**
   * Retrieves status of given contact
   * @param contactId
   */
  public async getStatus(contactId: string) {
    return this.page.evaluate(
      (contactId: string) => WAPI.getStatus(contactId),
      contactId
    );
  }

  /**
   * Checks if a number is a valid whatsapp number
   * @param contactId, you need to include the @c.us at the end.
   * @returns contact detial as promise
   */
  public async getNumberProfile(contactId: string) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'getNumberProfile';
      const type = 'string';
      const check = [
        {
          param: 'contactId',
          type: type,
          value: contactId,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = this.page.evaluate(
        (contactId: string) => WAPI.getNumberProfile(contactId),
        contactId
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * check if it's beta
   * @returns boolean
   */
  public async isBeta() {
    return await this.page.evaluate(() => WAPI.isBeta());
  }

  /**
   * Retrieves all undread Messages
   */
  public async getUnreadMessages(unread?: boolean) {
    return await this.page.evaluate(
      (unread) => WAPI.getUnreadMessages(unread),
      unread
    );
  }

  /**
   * Retrieves all messages already loaded in a chat
   * For loading every message use loadAndGetAllMessagesInChat
   * @param chatId, the chat to get the messages from
   * @param includeMe, include my own messages? boolean
   * @param includeNotifications
   * @returns any
   */
  public async getAllMessagesInChat(
    chatId: string,
    includeMe: boolean,
    includeNotifications: boolean
  ) {
    return await this.page.evaluate(
      ({ chatId, includeMe, includeNotifications }) =>
        WAPI.getAllMessagesInChat(chatId, includeMe, includeNotifications),
      { chatId, includeMe, includeNotifications }
    );
  }

  /**
   * Loads and Retrieves all Messages in a chat
   * @param chatId, the chat to get the messages from
   * @param includeMe, include my own messages? boolean
   * @param includeNotifications
   * @returns any
   */
  public async loadAndGetAllMessagesInChat(
    chatId: string,
    includeMe = false,
    includeNotifications = false
  ) {
    return await this.page.evaluate(
      ({ chatId, includeMe, includeNotifications }) =>
        WAPI.loadAndGetAllMessagesInChat(
          chatId,
          includeMe,
          includeNotifications
        ),
      { chatId, includeMe, includeNotifications }
    );
  }

  /**
   * Checks if a CHAT contact is online.
   * @param chatId chat id: xxxxx@c.us
   */
  public async getChatIsOnline(chatId: string): Promise<boolean> {
    return await this.page.evaluate(
      (chatId: string) => WAPI.getChatIsOnline(chatId),
      chatId
    );
  }

  /**
   * Retrieves the last seen of a CHAT.
   * @param chatId chat id: xxxxx@c.us
   */
  public async getLastSeen(chatId: string): Promise<number | boolean> {
    return await this.page.evaluate(
      (chatId: string) => WAPI.getLastSeen(chatId),
      chatId
    );
  }
}

```

`src/api/layers/sender.layer.ts`:

```ts
import * as path from 'path';
import { Page, Browser } from 'puppeteer';
import { CreateConfig } from '../../config/create-config';
import {
  base64MimeType,
  downloadFileToBase64,
  fileToBase64,
  stickerSelect,
  dowloadMetaFileBase64
} from '../helpers';
import { filenameFromMimeType } from '../helpers/filename-from-mimetype';
import { Message, SendFileResult, SendStickerResult } from '../model';
import { ChatState } from '../model/enum';
import { ListenerLayer } from './listener.layer';
import { Scope, checkValuesSender } from '../helpers/layers-interface';

let obj: Scope;

export class SenderLayer extends ListenerLayer {
  constructor(
    public browser: Browser,
    public page: Page,
    session?: string,
    options?: CreateConfig
  ) {
    super(browser, page, session, options);
  }

  public async createCommunity(name: string, description: string) {
    return await this.page.evaluate(
      ({ name, description }) => {
        return WAPI.createCommunity(name, description);
      },
      { name, description }
    );
  }

  /**
   * Send List menu
   * @param to the numberid xxx@c.us
   * @param title the titulo
   * @param subtitle the subtitle
   * @param description the description
   * @param buttonText the name button
   * @param menu List menu
   */
  public async sendListMenu(
    to: string,
    title: string,
    subTitle: string,
    description: string,
    buttonText: string,
    menu: Array<any>
  ): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ to, title, subTitle, description, buttonText, menu }) => {
          return WAPI.sendListMenu(
            to,
            title,
            subTitle,
            description,
            buttonText,
            menu
          );
        },
        { to, title, subTitle, description, buttonText, menu }
      );
      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  //*PRO_
  /**
   * Send status text
   * @param text The text for the status
   */
  public async sendStatusText(text: string) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'sendText';
      const type = 'string';
      const check = [
        {
          param: 'text',
          type: type,
          value: text,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const to = 'status@broadcast';
      const result = await this.page.evaluate(
        ({ to, text }) => {
          return WAPI.sendMessage(to, text, true);
        },
        { to, text }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Create poll
   * @param idUser chat id: xxxxx@us.c
   */
  public async sendPollCreation(idUser: string, poll: any) {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ idUser, poll }) => {
          return WAPI.sendPollCreation(idUser, poll);
        },
        { idUser, poll }
      );
      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  //*PRO_
  /**
   * @param filePath path, http link or base64Encoded
   * @param filename
   */
  public async sendImageStatus(
    filePath: string,
    description?: string
  ): Promise<SendFileResult> {
    return new Promise(async (resolve, reject) => {
      let base64 = await downloadFileToBase64(filePath, [
        'image/gif',
        'image/png',
        'image/jpg',
        'image/jpeg',
        'image/webp'
      ]);

      if (!base64) {
        base64 = await fileToBase64(filePath);
      }

      if (!base64) {
        const obj = {
          erro: true,
          to: 'status',
          text: 'No such file or directory, open "' + filePath + '"'
        };
        return reject(obj);
      }

      let filename = path.basename(filePath);
      let mimeType = base64MimeType(base64);

      if (!mimeType) {
        obj = {
          erro: true,
          to: 'status',
          text: 'Invalid base64!'
        };
        return reject(obj);
      }

      if (!mimeType.includes('image')) {
        const obj = {
          erro: true,
          to: 'status',
          text: 'Not an image, allowed formats gif, png, jpg, jpeg and webp'
        };
        return reject(obj);
      }
      const to = 'status@broadcast';
      filename = filenameFromMimeType(filename, mimeType);

      const result = await this.page.evaluate(
        ({ to, base64, filename, description }) => {
          return WAPI.sendImage(
            base64,
            to,
            filename,
            description,
            'sendImageStatus'
          );
        },
        { to, base64, filename, description }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Sends file from path
   * @param filePath File path
   * @param caption
   */
  public async sendVideoStatus(filePath: string, description?: string) {
    return new Promise(async (resolve, reject) => {
      let base64 = await downloadFileToBase64(filePath, ['video/mp4']),
        obj: { erro: boolean; to: string; text: string };

      if (!base64) {
        base64 = await fileToBase64(filePath);
      }

      if (!base64) {
        obj = {
          erro: true,
          to: 'status',
          text: 'No such file or directory, open "' + filePath + '"'
        };
        return reject(obj);
      }

      let filename = path.basename(filePath);

      let mimeType = base64MimeType(base64);

      if (!mimeType) {
        obj = {
          erro: true,
          to: 'status',
          text: 'Invalid base64!'
        };
        return reject(obj);
      }

      if (!mimeType.includes('video')) {
        const obj = {
          erro: true,
          to: 'status',
          text: 'Not an video, allowed format mp4'
        };
        return reject(obj);
      }

      filename = filenameFromMimeType(filename, mimeType);
      const to = 'status@broadcast';
      const result = await this.page.evaluate(
        ({ to, base64, filename, description }) => {
          return WAPI.sendFile(
            base64,
            to,
            filename,
            description,
            'sendVideoStatus',
            true
          );
        },
        { to, base64, filename, description }
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Sends a text message to given chat
   * @param to chat id: xxxxx@us.c
   * @param content text message
   * @param idMessage add id message
   * @param passId new id
   */
  public async sendButtons(
    to: string,
    title: string,
    subtitle: string,
    buttons: any
  ): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'sendButtons';
      const type = 'string';
      const obj = 'object';
      const check = [
        {
          param: 'to',
          type: type,
          value: to,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'title',
          type: type,
          value: title,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'subtitle',
          type: type,
          value: subtitle,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'buttons',
          type: obj,
          value: buttons,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }

      const result = await this.page.evaluate(
        ({ to, title, subtitle, buttons }) => {
          return WAPI.sendButtons(to, title, subtitle, buttons);
        },
        { to, title, subtitle, buttons }
      );
      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  public async sendTypeButtons(
    to: string,
    title: string,
    subtitle: string,
    footer: string,
    buttons: any
  ): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ to, title, subtitle, footer, buttons }) => {
          return WAPI.sendTypeButtons(to, title, subtitle, footer, buttons);
        },
        { to, title, subtitle, footer, buttons }
      );
      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }
  /**
   * Sends a text message to given chat
   * @param to chat id: xxxxx@us.c
   * @param content text message
   * @param passId new id
   * @param checkNumber the number when submitting!
   * @param forcingReturn return without sending the message to the server!
   */
  public async sendText(
    to: string,
    content: string,
    passId?: any,
    checkNumber?: boolean,
    forcingReturn?: boolean,
    delSend?: boolean
  ): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'sendText';
      const type = 'string';
      const check = [
        {
          param: 'to',
          type: type,
          value: to,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'content',
          type: type,
          value: content,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = await this.page.evaluate(
        ({ to, content, passId, checkNumber, forcingReturn, delSend }) => {
          return WAPI.sendMessage(
            to,
            content,
            undefined,
            passId,
            checkNumber,
            forcingReturn,
            delSend
          );
        },
        { to, content, passId, checkNumber, forcingReturn, delSend }
      );
      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Automatically sends a link with the auto generated link preview. You can also add a custom message to be added.
   * @param chatId chat id: xxxxx@us.c
   * @param url string A link, for example for youtube. e.g https://www.youtube.com/watch?v=Zi_XLOBDo_Y&list=RDEMe12_MlgO8mGFdeeftZ2nOQ&start_radio=1
   * @param title custom text as the message body, this includes the link or will be attached after the link
   */
  public async sendLinkPreview(
    chatId: string,
    url: string,
    title: string
  ): Promise<object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'sendLinkPreview';
      const type = 'string';
      const check = [
        {
          param: 'chatId',
          type: type,
          value: chatId,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'url',
          type: type,
          value: url,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'title',
          type: type,
          value: title,
          function: typeFunction,
          isUser: false
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const thumbnail = await dowloadMetaFileBase64(url);
      const result = await this.page.evaluate(
        ({ chatId, url, title, thumbnail }) => {
          return WAPI.sendLinkPreview(chatId, url, title, thumbnail);
        },
        { chatId, url, title, thumbnail }
      );
      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Sends image message base64
   * @param to Chat id
   * @param base64 File path, http link or base64Encoded
   * @param filename
   * @param caption
   */
  public async sendImageFromBase64(
    to: string,
    base64: string,
    filename?: string,
    caption?: string,
    status?: boolean
  ): Promise<SendFileResult> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'sendImageFromBase64';
      const type = 'string';
      const check = [
        {
          param: 'to',
          type: type,
          value: to,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'base64',
          type: type,
          value: base64,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'filename',
          type: type,
          value: filename,
          function: typeFunction,
          isUser: false
        }
      ];

      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }

      let mimeType = base64MimeType(base64);

      if (!mimeType) {
        obj = {
          erro: true,
          to: to,
          text: 'Invalid base64!'
        };
        return reject(obj);
      }

      if (!mimeType.includes('image')) {
        const obj = {
          erro: true,
          to: to,
          text: 'Not an image, allowed formats gif, png, jpg, jpeg and webp'
        };
        return reject(obj);
      }

      filename = filenameFromMimeType(filename, mimeType);

      const result = await this.page.evaluate(
        ({ to, base64, filename, caption, status }) => {
          return WAPI.sendImage(base64, to, filename, caption, status);
        },
        { to, base64, filename, caption, status }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * only admin send messages
   * @param chatId Group
   * @param {boolean} type 'true' only admin can send messages or 'false' everyone can send
   */
  public async onlySendAdmin(chatId: string, type: boolean) {
    return new Promise(async (resolve, reject) => {
      const result: any = await this.page
        .evaluate(
          ({ chatId, type }) => {
            return WAPI.onlySendAdmin(chatId, type);
          },
          { chatId, type }
        )
        .catch(() => {});
      if (result?.erro == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  public async sendMessageOptions(
    chat: any,
    content: any,
    options?: any
  ): Promise<Message> {
    return new Promise(async (resolve, reject) => {
      try {
        const messageId = await this.page.evaluate(
          ({ chat, content, options }) => {
            return WAPI.sendMessageOptions(chat, content, options);
          },
          { chat, content, options }
        );
        const result = (await this.page.evaluate(
          (messageId: any) => WAPI.getMessageById(messageId),
          messageId
        )) as Message;
        resolve(result);
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Sends image message
   * @param to Chat id
   * @param filePath File path or http link
   * @param filename
   * @param caption
   */
  public async sendImage(
    to: string,
    filePath: string,
    filename?: string,
    caption?: string,
    passId?: any
  ): Promise<SendFileResult> {
    return new Promise(async (resolve, reject) => {
      let base64 = await downloadFileToBase64(filePath, [
        'image/gif',
        'image/png',
        'image/jpg',
        'image/jpeg',
        'image/webp'
      ]);

      if (!base64) {
        base64 = await fileToBase64(filePath);
      }

      if (!base64) {
        const obj = {
          erro: true,
          to: to,
          text: 'No such file or directory, open "' + filePath + '"'
        };
        return reject(obj);
      }

      if (!filename) {
        filename = path.basename(filePath);
      }

      let mimeType = base64MimeType(base64);

      if (!mimeType) {
        obj = {
          erro: true,
          to: to,
          text: 'Invalid base64!'
        };
        return reject(obj);
      }

      if (!mimeType.includes('image')) {
        const obj = {
          erro: true,
          to: to,
          text: 'Not an image, allowed formats gif, png, jpg, jpeg and webp'
        };
        return reject(obj);
      }

      filename = filenameFromMimeType(filename, mimeType);

      const result = await this.page.evaluate(
        ({ to, base64, filename, caption, passId }) => {
          return WAPI.sendImage(
            base64,
            to,
            filename,
            caption,
            'sendImage',
            false,
            passId
          );
        },
        { to, base64, filename, caption, passId }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Sends message with thumbnail
   * @param thumb
   * @param url
   * @param title
   * @param description
   * @param chatId
   */
  public async sendMessageWithThumb(
    thumb: string,
    url: string,
    title: string,
    description: string,
    chatId: string
  ) {
    return await this.page.evaluate(
      ({ thumb, url, title, description, chatId }) => {
        WAPI.sendMessageWithThumb(thumb, url, title, description, chatId);
      },
      {
        thumb,
        url,
        title,
        description,
        chatId
      }
    );
  }

  /**
   * Replies to given mesage id of given chat id
   * @param to Chat id
   * @param content Message body
   * @param quotedMsg Message id to reply to.
   */
  public async reply(
    to: string,
    content: string,
    quotedMsg: string
  ): Promise<Message | object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'reply';
      const type = 'string';
      const check = [
        {
          param: 'to',
          type: type,
          value: to,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'content',
          type: type,
          value: content,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'quotedMsg',
          type: type,
          value: quotedMsg,
          function: typeFunction,
          isUser: false
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result: object = await this.page.evaluate(
        ({ to, content, quotedMsg }) => {
          return WAPI.reply(to, content, quotedMsg);
        },
        { to, content, quotedMsg }
      );

      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Send audio base64
   * @param to Chat id
   * @param base64 base64 data
   * @param passId new id
   */
  public async sendVoiceBase64(to: string, base64: string, passId?: any) {
    return new Promise(async (resolve, reject) => {
      const mimeType: any = base64MimeType(base64);

      if (!mimeType) {
        obj = {
          erro: true,
          to: to,
          text: 'Invalid base64!'
        };
        return reject(obj);
      }

      if (
        !mimeType ||
        mimeType.includes('audio/mpeg') ||
        mimeType.includes('audio/mp3')
      ) {
        const result = await this.page.evaluate(
          ({ to, base64, passId }) => {
            return WAPI.sendPtt(base64, to, passId);
          },
          { to, base64, passId }
        );
        if (result['erro'] == true) {
          reject(result);
        } else {
          resolve(result);
        }
      } else {
        obj = {
          erro: true,
          to: to,
          text: 'Use the MP3 format to be able to send an audio!'
        };
        return reject(obj);
      }
    });
  }

  /**
   * Send audio file
   * @param to Chat id
   * @param filePath Path file
   * @param passId new id
   * @param checkNumber the number when submitting!
   * @param forcingReturn return without sending the message to the server!
   */
  public async sendVoice(
    to: string,
    filePath: string,
    passId?: any,
    checkNumber?: boolean,
    forcingReturn?: boolean,
    delSend?: boolean
  ) {
    return new Promise(async (resolve, reject) => {
      try {
        let base64: string | false = await downloadFileToBase64(filePath, [
          'audio/mpeg',
          'audio/mp3'
        ]);

        if (!base64) {
          base64 = await fileToBase64(filePath);
        }

        if (!base64) {
          obj = {
            erro: true,
            to: to,
            text: 'No such file or directory, open "' + filePath + '"'
          };
          return reject(obj);
        }

        const mimeInfo = base64MimeType(base64);

        if (
          !mimeInfo ||
          mimeInfo.includes('audio/mpeg') ||
          mimeInfo.includes('audio/mp3')
        ) {
          const result: any = await this.page.evaluate(
            ({ to, base64, passId, checkNumber, forcingReturn, delSend }) => {
              return WAPI.sendPtt(
                base64,
                to,
                passId,
                checkNumber,
                forcingReturn,
                delSend
              );
            },
            { to, base64, passId, checkNumber, forcingReturn, delSend }
          );
          if (result['erro'] == true) {
            reject(result);
          } else {
            resolve(result);
          }
        } else {
          obj = {
            erro: true,
            to: to,
            text: 'Use the MP3 format to be able to send an audio!'
          };
          return reject(obj);
        }
      } catch (error) {
        console.log(error);
        return reject(error);
      }
    });
  }

  /**
   * Sends file
   * base64 parameter should have mime type already defined
   * @param to Chat id
   * @param base64 base64 data
   * @param filename
   * @param caption
   */
  public async sendFileFromBase64(
    to: string,
    base64: string,
    filename: string,
    caption?: string,
    passId?: any
  ): Promise<SendFileResult> {
    return new Promise(async (resolve, reject) => {
      let mimeType = base64MimeType(base64);

      if (!mimeType) {
        obj = {
          erro: true,
          to: to,
          text: 'Invalid base64!'
        };
        return reject(obj);
      }

      filename = filenameFromMimeType(filename, mimeType);

      const type = 'FileFromBase64';
      const result = await this.page.evaluate(
        ({ to, base64, filename, caption, type, passId }) => {
          return WAPI.sendFile(
            base64,
            to,
            filename,
            caption,
            type,
            undefined,
            passId
          );
        },
        { to, base64, filename, caption, type, passId }
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Sends file from path
   * @param to Chat id
   * @param filePath File path
   * @param filename
   * @param caption
   */
  public async sendFile(
    to: string,
    filePath: string,
    filename?: string,
    caption?: string,
    passId?: any,
    checkNumber?: boolean,
    forcingReturn?: boolean,
    delSend?: boolean
  ) {
    return new Promise(async (resolve, reject) => {
      let base64 = await downloadFileToBase64(filePath),
        obj: { erro: boolean; to: string; text: string };

      if (!base64) {
        base64 = await fileToBase64(filePath);
      }

      if (!base64) {
        obj = {
          erro: true,
          to: to,
          text: 'No such file or directory, open "' + filePath + '"'
        };
        return reject(obj);
      }

      if (!filename && typeof filename !== 'string') {
        filename = path.basename(filePath);
      }

      let mimeType = base64MimeType(base64);

      if (!mimeType) {
        obj = {
          erro: true,
          to: to,
          text: 'Invalid base64!'
        };
        return reject(obj);
      }

      filename = filenameFromMimeType(filename, mimeType);

      const result = await this.page.evaluate(
        ({
          to,
          base64,
          filename,
          caption,
          passId,
          checkNumber,
          forcingReturn,
          delSend
        }) => {
          return WAPI.sendFile(
            base64,
            to,
            filename,
            caption,
            'sendFile',
            undefined,
            passId,
            checkNumber,
            forcingReturn,
            delSend
          );
        },
        {
          to,
          base64,
          filename,
          caption,
          passId,
          checkNumber,
          forcingReturn,
          delSend
        }
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Sends a video to given chat as a gif, with caption or not, using base64
   * @param to chat id xxxxx@us.c
   * @param base64 base64 data:video/xxx;base64,xxx
   * @param filename string xxxxx
   * @param caption string xxxxx
   */
  public async sendVideoAsGif(
    to: string,
    path: string,
    filename: string,
    caption: string
  ) {
    const base64 = await fileToBase64(path);
    if (base64) {
      return this.sendVideoAsGifFromBase64(to, base64, filename, caption);
    }
  }

  /**
   * Sends a video to given chat as a gif, with caption or not, using base64
   * @param to chat id xxxxx@us.c
   * @param base64 base64 data:video/xxx;base64,xxx
   * @param filename string xxxxx
   * @param caption string xxxxx
   */
  public async sendVideoAsGifFromBase64(
    to: string,
    base64: string,
    filename: string,
    caption: string
  ) {
    return await this.page.evaluate(
      ({ to, base64, filename, caption }) => {
        WAPI.sendVideoAsGif(base64, to, filename, caption);
      },
      { to, base64, filename, caption }
    );
  }

  /**
   * Sends contact card to iven chat id
   * @param to Chat id
   * @param contactsId Example: 0000@c.us | [000@c.us, 1111@c.us]
   */
  public async sendContactVcard(
    to: string,
    contactsId: string | string[],
    name?: string
  ) {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ to, contactsId, name }) => {
          return WAPI.sendContactVcard(to, contactsId, name);
        },
        { to, contactsId, name }
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Send a list of contact cards
   * @param to Chat id
   * @param contacts Example: | [000@c.us, 1111@c.us]
   */
  public async sendContactVcardList(to: string, contacts: string[]) {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ to, contacts }) => {
          return WAPI.sendContactVcardList(to, contacts);
        },
        { to, contacts }
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Forwards array of messages (could be ids or message objects)
   * @param to Chat id
   * @param messages Array of messages ids to be forwarded
   * @param skipMyMessages
   */
  public async forwardMessages(
    to: string,
    messages: string | string[],
    skipMyMessages: boolean
  ) {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ to, messages, skipMyMessages }) => {
          return WAPI.forwardMessages(to, messages, skipMyMessages).catch(
            (e) => e
          );
        },
        { to, messages, skipMyMessages }
      );
      if (typeof result['erro'] !== 'undefined' && result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Generates sticker from the provided animated gif image and sends it (Send image as animated sticker)
   *  @param path image path imageBase64 A valid gif image is required. You can also send via http/https (http://www.website.com/img.gif)
   *  @param to chatId '000000000000@c.us'
   */
  public async sendImageAsStickerGif(
    to: string,
    path: string
  ): Promise<SendStickerResult | false> {
    let b64 = await downloadFileToBase64(path, ['image/gif', 'image/webp']);
    if (!b64) {
      b64 = await fileToBase64(path);
    }
    if (b64) {
      const buff = Buffer.from(
        b64.replace(/^data:image\/(gif|webp);base64,/, ''),
        'base64'
      );
      const mimeInfo = base64MimeType(b64);
      if (!mimeInfo || mimeInfo.includes('image')) {
        let obj = await stickerSelect(buff, 1);
        if (typeof obj == 'object') {
          let _webb64 = obj['webpBase64'];
          let _met = obj['metadata'];

          return new Promise(async (resolve, reject) => {
            const result = await this.page.evaluate(
              ({ _webb64, to, _met }) => {
                return WAPI.sendImageAsSticker(_webb64, to, _met, 'StickerGif');
              },
              { _webb64, to, _met }
            );
            if (result['erro'] == true) {
              reject(result);
            } else {
              resolve(result);
            }
          });
        } else {
          throw {
            error: true,
            message: 'Error with sharp library, check the console log'
          };
        }
      } else {
        console.log('Not an image, allowed format gif');
        return false;
      }
    }
  }

  /**
   * Generates sticker from given image and sends it (Send Image As Sticker)
   * @param path image path imageBase64 A valid png, jpg and webp image is required. You can also send via http/https (http://www.website.com/img.gif)
   * @param to chatId '000000000000@c.us'
   */
  public async sendImageAsSticker(
    to: string,
    path: string
  ): Promise<SendStickerResult | false> {
    let b64 = await downloadFileToBase64(path, [
      'image/gif',
      'image/png',
      'image/jpg',
      'image/jpeg',
      'image/webp'
    ]);

    if (!b64) {
      b64 = await fileToBase64(path);
    }

    if (b64) {
      const buff = Buffer.from(
        b64.replace(/^data:image\/(png|jpe?g|webp|gif);base64,/, ''),
        'base64'
      );

      const mimeInfo = base64MimeType(b64);

      if (!mimeInfo || mimeInfo.includes('image')) {
        let obj = await stickerSelect(buff, 0);
        if (typeof obj == 'object') {
          let _webb64 = obj['webpBase64'];
          let _met = obj['metadata'];
          return new Promise(async (resolve, reject) => {
            const result = await this.page.evaluate(
              ({ _webb64, to, _met }) => {
                return WAPI.sendImageAsSticker(_webb64, to, _met, 'Sticker');
              },
              { _webb64, to, _met }
            );
            if (result['erro'] == true) {
              reject(result);
            } else {
              resolve(result);
            }
          });
        } else {
          throw {
            error: true,
            message: 'Error with sharp library, check the console log'
          };
        }
      } else {
        console.log('Not an image, allowed formats png, jpeg and webp');
        return false;
      }
    }
  }

  /**
   * TODO: Fix message not being delivered
   * Sends location to given chat id
   * @param to Chat id
   * @param latitude Latitude
   * @param longitude Longitude
   * @param title Text caption
   */
  public async sendLocation(
    to: string,
    latitude: string,
    longitude: string,
    title: string
  ) {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ to, latitude, longitude, title }) => {
          return WAPI.sendLocation(to, latitude, longitude, title);
        },
        { to, latitude, longitude, title }
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Starts typing ('Typing...' state)
   * @param chatId chat id: xxxxx@us.c
   * @param checkNumber the number when submitting!
   */
  public async startTyping(chatId: string, checkNumber: boolean) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'startTyping';
      const type = 'string';
      const check = [
        {
          param: 'chatId',
          type: type,
          value: chatId,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = await this.page.evaluate(
        ({ chatId, checkNumber }) => WAPI.startTyping(chatId, checkNumber),
        { chatId, checkNumber }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Start Recording
   * @param chatId Chat id
   * @param checkNumber the number when submitting!
   */
  public async startRecording(chatId: string, checkNumber: boolean) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'startRecording';
      const type = 'string';
      const check = [
        {
          param: 'chatId',
          type: type,
          value: chatId,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = await this.page.evaluate(
        ({ chatId, checkNumber }) => WAPI.startRecording(chatId, checkNumber),
        { chatId, checkNumber }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Mark Paused
   * @param chatId Chat id
   * @param checkNumber the number when submitting!
   */
  public async markPaused(chatId: string, checkNumber: boolean) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'startRecording';
      const type = 'string';
      const check = [
        {
          param: 'chatId',
          type: type,
          value: chatId,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = await this.page.evaluate(
        ({ chatId, checkNumber }) => WAPI.markPaused(chatId, checkNumber),
        { chatId, checkNumber }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Clear Presence
   * @param chatId Chat id
   */
  public async clearPresence(chatId: string) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'clearPresence';
      const type = 'string';
      const check = [
        {
          param: 'chatId',
          type: type,
          value: chatId,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }

      const result = await this.page.evaluate(
        ({ chatId }) => WAPI.clearPresence(chatId),
        { chatId }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Presence Available
   */
  public async presenceAvailable() {
    return this.page.evaluate(() => WAPI.presenceAvailable());
  }

  /**
   * Presence Available
   */
  public async presenceUnavailable() {
    return this.page.evaluate(() => WAPI.presenceUnavailable());
  }

  /**
   * Sends text with tags
   *
   */
  public async sendMentioned(to: string, message: string, mentioned: string[]) {
    return await this.page.evaluate(
      ({ to, message, mentioned }) => {
        WAPI.sendMessageMentioned(to, message, mentioned);
      },
      { to, message, mentioned }
    );
  }

  /**
   * Sets the chat state
   * @param chatState
   * @param chatId
   */
  public async setChatState(chatId: string, chatState: ChatState) {
    return await this.page.evaluate(
      ({ chatState, chatId }) => {
        return WAPI.sendChatstate(chatState, chatId);
      },
      { chatState, chatId }
    );
  }

  public async sendReactions(IdMessage: string, emoji: string) {
    return await this.page.evaluate(
      ({ IdMessage, emoji }) => {
        WAPI.sendReactions(IdMessage, emoji);
      },
      { IdMessage, emoji }
    );
  }
}

```

`src/api/layers/ui.layer.ts`:

```ts
import { Page, Browser } from 'puppeteer';
import { CreateConfig } from '../../config/create-config';
import { GroupLayer } from './group.layer';
import { checkValuesSender } from '../helpers/layers-interface';

export class UILayer extends GroupLayer {
  constructor(
    public browser: Browser,
    public page: Page,
    session?: string,
    options?: CreateConfig
  ) {
    super(browser, page, session, options);
  }

  /**
   * MouveMouse
   */
  public async mouseMove(x: number, y: number) {
    await this.page.mouse.move(0, 0);
    await this.page.mouse.down();
    await this.page.mouse.move(0, 100);
    await this.page.mouse.up();
  }

  /**
   * checks and returns whether a message and a reply
   * @param messages
   */
  public async returnReply(messages: any) {
    return await this.page.evaluate(
      ({ messages }) => WAPI.returnReply(messages),
      {
        messages
      }
    );
  }

  /**
   * Opens given chat at last message (bottom)
   * Will fire natural workflow events of whatsapp web
   * @param chatId
   */
  public async openChat(chatId: string, force?: boolean) {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'openChat';
      const type = 'string';
      const check = [
        {
          param: 'text',
          type: type,
          value: chatId,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = await this.page.evaluate(
        ({ chatId, force }) => WAPI.openChat(chatId, force),
        { chatId, force }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Opens chat at given message position
   * @param chatId Chat id
   * @param messageId Message id (For example: '06D3AB3D0EEB9D077A3F9A3EFF4DD030')
   */
  public async openChatAt(chatId: string, messageId: string) {
    return this.page.evaluate(
      (chatId: string) => WAPI.openChatAt(chatId, messageId),
      chatId
    );
  }
}

```

`src/api/model/Interface-mode.ts`:

```ts
import { InterfaceState, InterfaceMode } from '../model/enum';
export interface InterfaceChangeMode {
  displayInfo: InterfaceState;
  mode: InterfaceMode;
  info: InterfaceState;
}

```

`src/api/model/ack.ts`:

```ts
import { Id } from './id';
import { AckType } from './enum';

export interface Ack {
  id: Id;
  body: string;
  type: string;
  t: number;
  subtype: any;
  notifyName: string;
  from: string;
  to: string;
  self: string;
  ack: AckType;
  invis: boolean;
  isNewMsg: boolean;
  star: boolean;
  loc: string;
  lat: number;
  lng: number;
  mentionedJidList: any[];
  isForwarded: boolean;
  labels: any[];
  ephemeralStartTimestamp: number;
}

```

`src/api/model/chat-status.ts`:

```ts
export interface ChatStatus {
  id: ID;
  isGroup: string;
  isUser: string;
  type: string;
}

interface ID {
  server: string;
  user: string;
  _serialized: string;
}

```

`src/api/model/chat.ts`:

```ts
import { Contact } from './contact';
import { GroupMetadata } from './group-metadata';
import { Id } from './id';

export interface Chat {
  archive: boolean;
  changeNumberNewJid: Id;
  changeNumberOldJid: Id;
  contact: Contact;
  ephemeralDuration: number;
  ephemeralSettingTimestamp: number;
  groupMetadata: GroupMetadata;
  id: Id;
  isAnnounceGrpRestrict: boolean;
  isGroup: boolean;
  isOnline: null | boolean;
  isReadOnly: boolean;
  kind: string;
  lastReceivedKey: LastReceivedKey;
  lastSeen: null | number | boolean;
  modifyTag: number;
  msgs: null;
  muteExpiration: number;
  name: string;
  notSpam: boolean;
  pendingMsgs: boolean;
  pin: number;
  presence: Presence;
  t: number;
  unreadCount: number;
}

export interface ProfilePicThumbObj {
  eurl: string;
  id: Id;
  img: string;
  imgFull: string;
  raw: null;
  tag: string;
}

export interface LastReceivedKey {
  fromMe: boolean;
  remote: Id;
  id: string;
  _serialized: string;
}

export interface Presence {
  id: Id;
  chatstates: any[];
}

```

`src/api/model/contact-status.ts`:

```ts
export interface ContactStatus {
  id: string;
  status: string;
  stale?: boolean;
}

```

`src/api/model/contact.ts`:

```ts
import { Id } from './id';

export interface Contact {
  formattedName: string;
  id: Id;
  isBusiness: boolean;
  isEnterprise: boolean;
  isHighLevelVerified: any;
  isMe: boolean;
  isMyContact: boolean;
  isPSA: boolean;
  isUser: boolean;
  isVerified: any;
  isWAContact: boolean;
  labels: any[];
  msgs: any;
  name: string;
  plaintextDisabled: boolean;
  profilePicThumbObj: {
    eurl: string;
    id: Id;
    img: string;
    imgFull: string;
    raw: any;
    tag: string;
  };
  pushname: string;
  sectionHeader: any;
  shortName: string;
  statusMute: boolean;
  type: string;
  verifiedLevel: any;
  verifiedName: any;
  /**
   * @deprecated This is unreliable. Use the method {@link Whatsapp.getChatIsOnline} instead.
   */
  isOnline: null | boolean;
  /**
   * @deprecated This is unreliable. Use the method {@link Whatsapp.getLastSeen} instead.
   */
  lastSeen: null | number | boolean;
}

```

`src/api/model/enum/ack-type.ts`:

```ts
export enum AckType {
  MD_DOWNGRADE = -7,
  INACTIVE = -6,
  CONTENT_UNUPLOADABLE = -5,
  CONTENT_TOO_BIG = -4,
  CONTENT_GONE = -3,
  EXPIRED = -2,
  FAILED = -1,
  CLOCK = 0,
  SENT = 1,
  RECEIVED = 2,
  READ = 3,
  PLAYED = 4
}

```

`src/api/model/enum/chat-state.ts`:

```ts
export enum ChatState {
  Typing = 0,
  Recording = 1,
  Paused = 2
}

```

`src/api/model/enum/definitions.ts`:

```ts
const defs = {
  MAX_GROUP_SIZE: 101,
  MAX_SUBJECT_LENGTH: 25,
  IMG_MAX_EDGE: 1600,
  IMG_MAX_BYTES: 1048576,
  IMG_THUMB_MAX_EDGE: 100,
  DOC_THUMB_MAX_EDGE: 480,
  MAX_MEDIA_UPLOAD_SIZE: 16777216,
  MAX_FILE_SIZE: 104857600,
  MAX_FILES: 30,
  SHOW_GIF_SEARCH: !1,
  USE_NOTIFICATION_QUERY: !1,
  FWD_UI_START_TS: 0,
  GOOGLE_MAPS_DO_NOT_AUTH: !0,
  GOOGLE_MAPS_KEYLESS: !1,
  SUSPICIOUS_LINKS: !1,
  FINAL_LIVE_LOCATION: !1,
  STATUS_RANKING: !1,
  FREQUENTLY_FORWARDED_MESSAGES: !1,
  FREQUENTLY_FORWARDED_THRESHOLD: 5,
  FREQUENTLY_FORWARDED_MAX: 1,
  FREQUENTLY_FORWARDED_GROUP_SETTING: !1,
  QUICK_MESSAGE_SEARCH: !1,
  EPHEMERAL_MESSAGES: !1,
  PRELOAD_STICKERS: !1,
  PRODUCT_CATALOG_DEEPLINK: !1,
  PRODUCT_CATALOG_OPEN_DEEPLINK: !1,
  PRODUCT_MEDIA_ATTACHMENTS: !1,
  WEB_CLEAN_INCOMING_FILENAME: !1,
  WEB_VOIP_INTERNAL_TESTER: !1,
  WEB_ENABLE_MODEL_STORAGE: !1,
  WS_CAN_CACHE_REQUESTS: !1,
  MAX_FORWARD_COUNT_GLOBAL: 5,
  FREQUENTLY_FORWARDED_SENTINEL: 127,
  MAX_SMB_LABEL_COUNT: 20,
  DEFAULT_SMB__NEW_LABEL_COLOR: '#d6d7d7',
  FB_CLB_TOKEN: '1063127757113399|745146ffa34413f9dbb5469f5370b7af',
  FB_CLB_CHECK_URL: 'https://crashlogs.whatsapp.net/wa_fls_upload_check',
  FB_CLB_URL: 'https://crashlogs.whatsapp.net/wa_clb_data',
  G_MAPS_DIR_URL: 'https://maps.google.com/maps/dir',
  G_MAPS_IMG_URL: 'https://maps.googleapis.com/maps/api/staticmap',
  G_MAPS_SEARCH_URL: 'https://maps.google.com/maps/search',
  G_MAPS_URL: 'https://maps.google.com/maps',
  NOTIFICATION_PROMPT_DELAY: 1e4,
  PTT_PLAYBACK_DELAY: 400,
  NOTIFICATION_TIMEOUT: 5e3,
  CALL_NOTIFICATION_TIMEOUT: 45e3,
  IDLE_TIMEOUT: 6e4,
  IDLE_TIMEOUT_WAIT: 78e4,
  SEARCH_ZOOM: 17,
  SEND_UNAVAILABLE_WAIT: 15e3,
  SEND_PAUSED_WAIT: 2500,
  CLEAR_CHAT_DIRTY_WAIT: 2500,
  LOG_UPLOAD_INTERVAL: 36e5,
  REVOKE_WINDOW: 4096,
  WAM_ROTATE_INTERVAL: 300,
  ALBUM_DIFF_INTERVAL: 600,
  MAX_TXT_MSG_SIZE: 65536,
  INITIAL_PAGE_SIZE: 768,
  FREQUENTLY_FORWARDED_INITIAL_PAGE_SIZE: 308,
  SUBSEQUENT_PAGE_SIZE: 3072,
  OVERFLOWING_PAGE_THRESHOLD: 0.1,
  GROUP_DESCRIPTION_INFO_PANEL_TRUNC_LENGTH: 100,
  GROUP_DESCRIPTION_LENGTH: 0,
  GROUPS_V3_RESTRICT_GROUPS: !1,
  GROUPS_V3_ANNOUNCE_GROUPS: !1,
  GROUPS_V3: !1,
  INFO_DRAWER_MAX_ROWS: 10,
  NUM_COLORS: 20,
  FTS_MIN_CHARS: 2,
  FTS_TTL: 6e4,
  FTS_TYPING_DELAY: 300,
  FTS_NUM_RESULTS: 30,
  STICKERS: !1,
  HSM_ASPECT_RATIO: 1.91,
  TEMPLATE_DOC_MIME_TYPES: 1,
  TEMPLATE_URL_START: 64,
  TEMPLATE_URL_END: 32,
  MMS_MEDIA_KEY_TTL: 1 / 0,
  KEY_STORAGE_TEST: 'storage_test',
  KEY_CLIENT_TOKEN: 'WAToken1',
  KEY_SERVER_TOKEN: 'WAToken2',
  KEY_SECRET: 'WASecretKey',
  KEY_SECRET_BUNDLE: 'WASecretBundle',
  KEY_SECURITY_NOTIFICATIONS: 'WASecurityNotifications',
  KEY_BROWSER_ID: 'WABrowserId',
  KEY_GEOCODER_LOCATION: 'WAGeocoderLocation',
  KEY_GROUP_ASSIGNED_COLOR: 'WAGroupAssignedColor',
  KEY_GMAPS_OVER_LIMIT: 'WAGmapsOverLimit',
  KEY_GLOBAL_MUTE_SOUNDS: 'WAGlobalSounds',
  KEY_GLOBAL_MUTE_NOTIFICATIONS: 'WAGlobalNotifications',
  KEY_GLOBAL_MUTE_IN_APP_NOTIFICATIONS: 'WAGlobalInAppNotifications',
  KEY_GLOBAL_MUTE_PREVIEWS: 'WAGlobalPreviews',
  KEY_GLOBAL_COLLAPSE_MUTED: 'WAGlobalCollapseMuted',
  KEY_NOTIFICATION_SOUND: 'WANotificationSound',
  KEY_LANG: 'WALangPref',
  KEY_LAST_ACTIVE_EMOJI_TAB: 'WALastActiveEmojiTab',
  KEY_LAST_SELECTED_COMPOSE_BOX_PANEL: 'WALastActiveComposeBoxPanel',
  KEY_LAST_CHAT_MUTE_DURATION: 'WALastChatMuteDuration',
  KEY_UNKNOWN_ID: 'WAUnknownID',
  KEY_VERSION: 'WAVersion',
  KEY_LOAD_RETRY_GENERATION: 'WALoadRetryGeneration',
  KEY_WHATSAPP_MUTEX: 'whatsapp-mutex',
  KEY_LAST_WID: 'last-wid',
  KEY_LAST_WID_MD: 'last-wid-md',
  KEY_SAVE_TO_CAMERA_ROLL: 'save_to_camera_roll',
  KEY_SMB_LABEL_COLOR_PALETTE: 'smb_label_color_palette',
  KEY_LAST_PUSHNAME: 'last-pushname',
  KEY_PROTO_VERSION: 'WAProtoVersion',
  KEY_MOBILE_PLATFORM: 'mobile-platform',
  KEY_REMEMBER_ME: 'remember-me',
  KEY_LOGOUT_TOKEN: 'logout-token',
  KEY_OLD_LOGOUT_CREDS: 'old-logout-cred',
  KEY_NO_TAKEOVER: 'no-takeover',
  KEY_WHATSAPP_LS_VERSION: 'ver',
  KEY_WAM_BUFFER: 'wam-buffer',
  KEY_WAM_INFO: 'wam-info',
  KEY_TIME_SPENT_EVENT: 'WaTimeSpentEvent',
  KEY_VIDEO_VOLUME: 'video-volume',
  KEY_VIDEO_MUTE: 'video-mute',
  KEY_CONTACT_CHECKSUM: 'contact-checksum',
  KEY_COMPOSE_CONTENTS_PREFIX: 'compose-contents_',
  COOKIE_REF: 'ref',
  COOKIE_TOK: 'tok',
  PAGE_SIZE: 50,
  MSG_PRELOAD_THRESHOLD: 20,
  MEDIA_QUERY_LIMIT: 50,
  MIN_PIC_SIDE: 192,
  MAX_PIC_SIDE: 640,
  PROF_PIC_THUMB_SIDE: 96,
  MAX_CAPTION_LENGTH: 1024,
  MAX_PRODUCT_SUBTITLE_LENGTH: 70,
  MAX_REPLY_PRODUCT_TITLE_LENGTH: 40,
  MAX_REPLY_PRODUCT_DESC_LENGTH: 95,
  ALBUM_MIN_SIZE: 4,
  ALBUM_MAX_SIZE: 102,
  ALBUM_MAX_HEIGHT: 168,
  ALBUM_PADDING: 3,
  PRESENCE_COMPOSING_TIMEOUT: 25e3,
  PRESENCE_RESEND_WAIT: 1e4,
  MIMETYPE_OGG: 'audio/ogg',
  IMAGE_MIMES: 'image/*',
  WEBP_MIMES: 'image/webp',
  VIDEO_MIMES: 'video/mp4,video/3gpp,video/quicktime',
  KEY_LOG_CURSOR: 'debugCursor',
  MAX_STATUS_LENGTH: 139,
  MAX_PUSHNAME_LENGTH: 25,
  DISP_TYPE: {
    CONVERSATION: 'CONVERSATION',
    MSG_INFO: 'MSG_INFO',
    STARRED_MSGS: 'STARRED_MSGS',
    GALLERY: 'GALLERY',
    REPLY_STAGE: 'REPLY_STAGE',
    QUOTED_MSG: 'QUOTED_MSG',
    CONTACT_CARD: 'CONTACT_CARD'
  },
  SEND_LOGS_MAX_EMAIL_LENGTH: 320,
  SEND_LOGS_MAX_SUBJECT_LENGTH: 50,
  SEND_LOGS_MIN_DESC_LENGTH: 10,
  SEND_LOGS_MAX_DESC_LENGTH: 500,
  SEND_LOGS_MAX_SCREENSHOTS: 3,
  SEND_LOGS_MAX_SCREENSHOT_SIZE: 10485760,
  ACK: {
    MD_DOWNGRADE: -7,
    INACTIVE: -6,
    CONTENT_UNUPLOADABLE: -5,
    CONTENT_TOO_BIG: -4,
    CONTENT_GONE: -3,
    EXPIRED: -2,
    FAILED: -1,
    CLOCK: 0,
    SENT: 1,
    RECEIVED: 2,
    READ: 3,
    PLAYED: 4
  },
  ACK_STRING: {
    SENDER: 'sender',
    DELIVERY: 'delivery',
    READ: 'read',
    PLAYED: 'played',
    INACTIVE: 'inactive'
  },
  RETRY: {
    VALIDATE_OLD_SESSION: 2,
    MAX_RETRY: 5
  },
  KEY_BUNDLE_TYPE: '',
  EDIT_ATTR: {
    REVOKE: 7
  },
  DEVICE: {
    PRIMARY_DEVICE: 0,
    PRIMARY_VERSION: -1
  },
  BATTERY_LOW_THRESHOLD_1: 15,
  BATTERY_LOW_THRESHOLD_2: 5,
  BATTERY_DELAY: 1e4,
  WAM_MAX_BUFFER_SIZE: 5e4,
  SOCKET_STATE: {
    OPENING: 'OPENING',
    PAIRING: 'PAIRING',
    UNPAIRED: 'UNPAIRED',
    UNPAIRED_IDLE: 'UNPAIRED_IDLE',
    CONNECTED: 'CONNECTED',
    WITHOUT_INTERNET: 'WITHOUT INTERNET',
    CONFLICT: 'CONFLICT',
    UNLAUNCHED: 'UNLAUNCHED',
    PROXYBLOCK: 'PROXYBLOCK',
    TOS_BLOCK: 'TOS_BLOCK',
    SMB_TOS_BLOCK: 'SMB_TOS_BLOCK',
    DEPRECATED_VERSION: 'DEPRECATED_VERSION'
  },
  SOCKET_STREAM: {
    DISCONNECTED: 'DISCONNECTED',
    SYNCING: 'SYNCING',
    RESUMING: 'RESUMING',
    CONNECTED: 'CONNECTED'
  },
  COLLECTION_HAS_SYNCED: 'collection_has_synced',
  NEW_MSG_SENT: 'new_msg_sent',
  DIAGNOSTIC_DELAY: 18e3,
  ONE_BY_ONE_TRANS_GIF:
    'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
  WALLPAPER_COLOR: [
    '#ede9e4',
    '#ccebdc',
    '#aed8c7',
    '#7acba5',
    '#c7e9eb',
    '#a9dbd8',
    '#68d5d9',
    '#6ec3d4',
    '#f2dad5',
    '#f2d5e1',
    '#fbcad2',
    '#ffa7a8',
    '#cbdaec',
    '#d7d3eb',
    '#e5c0eb',
    '#d0deb1',
    '#dee0b4',
    '#e6dfa8',
    '#f7e9a8',
    '#ffd1a4',
    '#ff8a8c',
    '#ff5978',
    '#f56056',
    '#dc6e4f',
    '#e6e365',
    '#73c780',
    '#2293a4',
    '#219ed9',
    '#2b5aa6',
    '#74676a',
    '#48324d',
    '#dee3e9',
    '#d9dade',
    '#c0c1c4',
    '#7e90a3',
    '#55626f',
    '#243640',
    '#162127'
  ],
  DEFAULT_CHAT_WALLPAPER: 'default_chat_wallpaper',
  INVERT_TRANSPARENT: {
    '#ede9e4': !1,
    '#ccebdc': !1,
    '#aed8c7': !1,
    '#7acba5': !1,
    '#c7e9eb': !1,
    '#a9dbd8': !1,
    '#68d5d9': !1,
    '#6ec3d4': !1,
    '#f2dad5': !1,
    '#f2d5e1': !1,
    '#fbcad2': !1,
    '#ffa7a8': !1,
    '#cbdaec': !1,
    '#d7d3eb': !1,
    '#e5c0eb': !1,
    '#d0deb1': !1,
    '#dee0b4': !1,
    '#e6dfa8': !1,
    '#f7e9a8': !1,
    '#ffd1a4': !1,
    '#ff8a8c': !0,
    '#ff5978': !0,
    '#f56056': !0,
    '#dc6e4f': !0,
    '#e6e365': !1,
    '#73c780': !0,
    '#2293a4': !0,
    '#219ed9': !0,
    '#2b5aa6': !0,
    '#74676a': !0,
    '#48324d': !0,
    '#dee3e9': !1,
    '#d9dade': !1,
    '#c0c1c4': !1,
    '#7e90a3': !0,
    '#55626f': !0,
    '#243640': !0,
    '#162127': !0
  },
  L10N_PRIORITY: {
    SAVED: 6,
    PHONE: 5,
    PREVIOUS: 4,
    URL: 3,
    BROWSER: 2,
    DEFAULT: 1
  },
  RENDER_CURSOR: {
    RECENT_AT_TOP: 'recent_at_top',
    RECENT_AT_BOTTOM: 'recent_at_bottom',
    CONVERSATION: 'conversation',
    GROUP_CONVERSATION: 'group_conversation',
    STARRED_DRAWER: 'starred_drawer'
  },
  SECURITY_LINK: 'https://www.whatsapp.com/security/',
  SMB_TOS_LEARN_MORE_LINK:
    'https://www.whatsapp.com/legal/small-business-terms/',
  SERVER_WID: 'server@c.us',
  PSA_WID: '0@c.us',
  STATUS_WID: 'status@broadcast',
  OFFICIAL_BIZ_WID: '16505361212@c.us',
  VISIBILITY: {
    ABOVE: 'above',
    VISIBLE: 'visible',
    BELOW: 'below'
  },
  VIDEO_STREAM_URL: '/stream/video',
  SPELL_CHECK_SKIP_WORDS: {
    en_us: new Set([
      'ain',
      'couldn',
      'didn',
      'doesn',
      'hadn',
      'hasn',
      'mightn',
      'mustn',
      'needn',
      'oughtn',
      'shan',
      'shouldn',
      'wasn',
      'weren',
      'wouldn',
      'Ain',
      'Couldn',
      'Didn',
      'Doesn',
      'Hadn',
      'Hasn',
      'Mightn',
      'Mustn',
      'Needn',
      'Oughtn',
      'Shan',
      'Shouldn',
      'Wasn',
      'Weren',
      'Wouldn'
    ]),
    en_gb: new Set([
      'ain',
      'couldn',
      'didn',
      'doesn',
      'hadn',
      'hasn',
      'mightn',
      'mustn',
      'needn',
      'oughtn',
      'shan',
      'shouldn',
      'wasn',
      'weren',
      'wouldn',
      'Ain',
      'Couldn',
      'Didn',
      'Doesn',
      'Hadn',
      'Hasn',
      'Mightn',
      'Mustn',
      'Needn',
      'Oughtn',
      'Shan',
      'Shouldn',
      'Wasn',
      'Weren',
      'Wouldn'
    ]),
    en: new Set([
      'ain',
      'couldn',
      'didn',
      'doesn',
      'hadn',
      'hasn',
      'mightn',
      'mustn',
      'needn',
      'oughtn',
      'shan',
      'shouldn',
      'wasn',
      'weren',
      'wouldn',
      'Ain',
      'Couldn',
      'Didn',
      'Doesn',
      'Hadn',
      'Hasn',
      'Mightn',
      'Mustn',
      'Needn',
      'Oughtn',
      'Shan',
      'Shouldn',
      'Wasn',
      'Weren',
      'Wouldn'
    ])
  },
  GROUP_INVITE_LINK_URL: 'https://chat.whatsapp.com/',
  GROUP_SETTING_TYPE: {
    ANNOUNCEMENT: 'announcement',
    RESTRICT: 'restrict',
    NO_FREQUENTLY_FORWARDED: 'no_frequently_forwarded',
    EPHEMERAL: 'ephemeral'
  },
  GROUP_SETTING_TO_METADATA: {
    announcement: 'announce',
    restrict: 'restrict',
    no_frequently_forwarded: 'noFrequentlyForwarded',
    ephemeral: 'ephemeralDuration'
  },
  L10N: {
    DEFAULT: 'en'
  },
  EMOJI: {
    BUCKET_SIZE: 25,
    CATEGORIES: {
      SMILEYS_PEOPLE: 'SMILEYS_PEOPLE',
      ANIMALS_NATURE: 'ANIMALS_NATURE',
      FOOD_DRINK: 'FOOD_DRINK',
      ACTIVITY: 'ACTIVITY',
      TRAVEL_PLACES: 'TRAVEL_PLACES',
      OBJECTS: 'OBJECTS',
      SYMBOLS: 'SYMBOLS',
      FLAGS: 'FLAGS'
    },
    CATEGORY_MAPPING: {
      'Smileys & People': 'SMILEYS_PEOPLE',
      'Animals & Nature': 'ANIMALS_NATURE',
      'Food & Drink': 'FOOD_DRINK',
      Activity: 'ACTIVITY',
      'Travel & Places': 'TRAVEL_PLACES',
      Objects: 'OBJECTS',
      Symbols: 'SYMBOLS',
      Flags: 'FLAGS'
    },
    ORDERED_CATEGORY_IDS: [
      'SMILEYS_PEOPLE',
      'ANIMALS_NATURE',
      'FOOD_DRINK',
      'ACTIVITY',
      'TRAVEL_PLACES',
      'OBJECTS',
      'SYMBOLS',
      'FLAGS'
    ],
    EMOJI_TYPE: {
      APPLE: 'APPLE',
      WHATSAPP: 'WHATSAPP'
    },
    LARGE_EMOJI_BASE_PATH: '/img',
    LARGE_EMOJI_ELECTRON_BASE_PATH: 'img',
    EMOJI_SPRITES_BASE_PATH: '/img',
    EMOJI_SPRITES_ELECTRON_BASE_PATH: 'img'
  },
  MSG_TYPE: {
    NOTIFICATION: 'notification',
    NOTIFICATION_TEMPLATE: 'notification_template',
    GROUP_NOTIFICATION: 'group_notification',
    GP2: 'gp2',
    BROADCAST_NOTIFICATION: 'broadcast_notification',
    E2E_NOTIFICATION: 'e2e_notification',
    CALL_LOG: 'call_log',
    PROTOCOL: 'protocol',
    CHAT: 'chat',
    LOCATION: 'location',
    PAYMENT: 'payment',
    VCARD: 'vcard',
    CIPHERTEXT: 'ciphertext',
    MULTI_VCARD: 'multi_vcard',
    REVOKED: 'revoked',
    OVERSIZED: 'oversized',
    GROUPS_V4_INVITE: 'groups_v4_invite',
    TEMPLATE: 'template',
    HSM: 'hsm',
    TEMPLATE_BUTTON_REPLY: 'template_button_reply',
    IMAGE: 'image',
    VIDEO: 'video',
    AUDIO: 'audio',
    PTT: 'ptt',
    STICKER: 'sticker',
    DOCUMENT: 'document',
    PRODUCT: 'product',
    UNKNOWN: 'unknown'
  },
  TEMPLATE_SUBTYPE: {
    IMAGE: 'image',
    VIDEO: 'video',
    LOCATION: 'location',
    DOCUMENT: 'document',
    TEXT: 'text'
  },
  TEMPLATE_BUTTON_SUBTYPE: {
    QUICK_REPLY: 'quick_reply',
    CALL: 'call',
    URL: 'url'
  },
  NATIVE_PREF: {
    LAST_SAVED_LOCATION: 'lastSavedLocation',
    CONTENT_SETTINGS: 'contentSettings'
  },
  TOUCHBAR_MAX_EMOJIS: 8,
  VERIFIED_LEVEL: {
    UNKNOWN: 0,
    LOW: 1,
    HIGH: 2
  },
  HOSTNAME: {
    YOUTUBE: 'www.youtube.com',
    YOUTUBE_SHORTENED: 'youtu.be',
    INSTAGRAM: 'www.instagram.com',
    STREAMABLE: 'streamable.com',
    FACEBOOK: 'www.facebook.com',
    FBWATCH: 'fbwat.ch',
    LASSOVIDEOS: 'lassovideos.com'
  },
  WHATSAPP_ORIGIN: 'https://whatsapp.com',
  SMB_SEARCH_FILTERS: {
    UNREAD: 'unread',
    GROUP: 'group',
    BROADCAST: 'broadcast'
  },
  SMB_LABELS: {
    MAX_LABEL_LENGTH: 100
  },
  PRODUCT_INQUIRY_TYPE: 'product_inquiry',
  PRODUCT_LIST_ITEM_HEIGHT: 96,
  LOADABLE_DELAY: 200,
  MAX_EPHEMERAL_DURATION: 31536e3,
  EPHEMERAL_SETTINGS: {
    OFF: 0,
    ONE_HOUR: 3600,
    ONE_DAY: 86400,
    ONE_WEEK: 604800,
    ONE_MONTH: 2592e3,
    ONE_YEAR: 31536e3
  },
  TAB_ORDERS: {
    COMPOSE_BOX_INPUT: 1,
    MESSAGE_LIST: 2,
    CHAT_STARRED_DRAWER: 3,
    CHAT_LIST_SEARCH: 3,
    CHAT_LIST: 4,
    CHAT_CONTACT_LIST: 4,
    CHAT_IMAGE_GALLERY: 4,
    CHAT_SEARCH_MSG_LIST: 4,
    PANEL_SEARCH_INPUT: 5,
    COMPOSE_BOX_MENU_BUTTON: 5
  },
  SPEEDY_RESUME_MAX_CHATS: 5e3,
  MEDIA_VIEWER: {
    ANIMATION_DURATION: 500,
    CLOSE_ANIMATION_DURATION: 200,
    ZOOM_IN_FACTOR: 2
  }
};

```

`src/api/model/enum/group-change-event.ts`:

```ts
export enum GroupChangeEvent {
  Remove = 'remove',
  Add = 'add'
}

```

`src/api/model/enum/group-notification-type.ts`:

```ts
export enum GroupNotificationType {
  Add = 'add',
  Inivite = 'invite',
  Remove = 'remove',
  Leave = 'leave',
  Subject = 'subject',
  Description = 'description',
  Picture = 'picture',
  Announce = 'announce',
  Restrict = 'restrict'
}

```

`src/api/model/enum/group-settings.ts`:

```ts
/**
 * Group properties
 */
export enum GroupSettings {
  /**
   * Define how can send message in the group
   * `true` only admins
   * `false` everyone
   */
  ANNOUNCEMENT = 'announcement',

  /**
   * Define how can edit the group data
   * `true` only admins
   * `false` everyone
   */
  RESTRICT = 'restrict',

  /**
   * Non-Documented
   */
  NO_FREQUENTLY_FORWARDED = 'no_frequently_forwarded',

  /**
   * Enable or disable temporary messages
   * `true` to enable
   * `false` to disable
   */
  EPHEMERAL = 'ephemeral'
}

```

`src/api/model/enum/index.ts`:

```ts
export { AckType } from './ack-type';
export { ChatState } from './chat-state';
export { GroupChangeEvent } from './group-change-event';
export { GroupNotificationType } from './group-notification-type';
export { SocketState, SocketStream } from './socket-state';
export { MessageType, MediaType } from './message-type';
export { GroupSettings } from './group-settings';
export { onMode } from './mode.enum';
export * from './interface-mode';
export * from './interface-state';

```

`src/api/model/enum/interface-mode.ts`:

```ts
export enum InterfaceMode {
  /**
   * QR code page.
   */
  QR = 'QR',
  /**
   * Chat page.
   */
  MAIN = 'MAIN',
  /**
   * Connection.
   */
  CONNECTION = 'CONNECTION',
  /**
   * Loading page, waiting data from smartphone.
   */
  SYNCING = 'SYNCING',
  /**
   * Offline page, when there are no internet.
   */
  OFFLINE = 'OFFLINE',
  /**
   * Conflic page, when there are another whatsapp web openned.
   */
  CONFLICT = 'CONFLICT',
  /**
   * Blocked page, by proxy.
   */
  PROXYBLOCK = 'PROXYBLOCK',
  /**
   * Blocked page.
   */
  TOS_BLOCK = 'TOS_BLOCK',
  /**
   * Blocked page.
   */
  SMB_TOS_BLOCK = 'SMB_TOS_BLOCK',
  /**
   * Deprecated page.
   */
  DEPRECATED_VERSION = 'DEPRECATED_VERSION'
}

```

`src/api/model/enum/interface-state.ts`:

```ts
export enum InterfaceState {
  /**
   * When there are no internet.
   */
  OFFLINE = 'OFFLINE',
  /**
   * When the whatsapp web page is loading.
   */
  OPENING = 'OPENING',
  /**
   * When the whatsapp web is connecting to smartphone after QR code scan.
   */
  PAIRING = 'PAIRING',
  /**
   * When the whatsapp web is syncing messages with smartphone.
   */
  SYNCING = 'SYNCING',
  /**
   * When the whatsapp web is syncing messages with smartphone after a disconnection.
   */
  RESUMING = 'RESUMING',
  /**
   * When the whatsapp web is connecting to whatsapp server.
   */
  CONNECTING = 'CONNECTING',
  /**
   * When the whatsapp web is ready.
   */
  NORMAL = 'NORMAL',
  /**
   * When the whatsapp web couldn't connect to smartphone.
   */
  WITHOUT_INTERNET = 'WITHOUT INTERNET'
}

```

`src/api/model/enum/message-type.ts`:

```ts
export enum MessageType {
  TEXT = 'chat',
  AUDIO = 'audio',
  VOICE = 'ptt',
  IMAGE = 'image',
  VIDEO = 'video',
  DOCUMENT = 'document',
  STICKER = 'sticker',
  LOCATION = 'location',
  CONTACT_CARD = 'vcard',
  CONTACT_CARD_MULTI = 'multi_vcard',
  REVOKED = 'revoked',
  UNKNOWN = 'unknown'
}

export enum MediaType {
  IMAGE = 'Image',
  VIDEO = 'Video',
  AUDIO = 'Audio',
  PTT = 'Audio',
  DOCUMENT = 'Document',
  STICKER = 'Image'
}

```

`src/api/model/enum/mode.enum.ts`:

```ts
export enum onMode {
  /**
   * Indicates a change in the user interface.
   * @description Used to receive information about the current interface the user is on.
   */
  interfaceChange = 'interfaceChange',

  /**
   * Monitors new messages.
   * @description Used to receive notifications when a new message is received.
   */
  newMessage = 'newMessage',

  /**
   * Receives QR code updates.
   * @description Used to receive updated information about the QR code.
   */
  qrcode = 'qrcode',

  /**
   * User connection information.
   * @description Used to obtain information about the user's connection.
   */
  connection = 'connection',

  /**
   * Monitors the status of a message.
   * @description Used to receive notifications about the delivery status of a message.
   */
  newOnAck = 'newOnAck'
}

```

`src/api/model/enum/socket-state.ts`:

```ts
export enum SocketState {
  // for state
  CONFLICT = 'CONFLICT',
  CONNECTED = 'CONNECTED',
  DEPRECATED_VERSION = 'DEPRECATED_VERSION',
  OPENING = 'OPENING',
  PAIRING = 'PAIRING',
  PROXYBLOCK = 'PROXYBLOCK',
  SMB_TOS_BLOCK = 'SMB_TOS_BLOCK',
  TIMEOUT = 'TIMEOUT',
  TOS_BLOCK = 'TOS_BLOCK',
  UNLAUNCHED = 'UNLAUNCHED',
  UNPAIRED = 'UNPAIRED',
  UNPAIRED_IDLE = 'UNPAIRED_IDLE',
  // for stream
  DISCONNECTED = 'DISCONNECTED',
  SYNCING = 'SYNCING',
  RESUMING = 'RESUMING',
  WITHOUT_INTERNET = 'WITHOUT INTERNET'
}
export enum SocketStream {
  CONNECTED = 'CONNECTED',
  DISCONNECTED = 'DISCONNECTED',
  RESUMING = 'RESUMING',
  SYNCING = 'SYNCING'
}

```

`src/api/model/group-creation.ts`:

```ts
export interface GroupCreation {
  status: number;
  gid: {
    server: string;
    user: string;
    _serialized: string;
  };
  participants: { [key: string]: any[] }[];
}

```

`src/api/model/group-metadata.ts`:

```ts
import { Id } from '.';

export interface GroupMetadata {
  id: Id;
  creation: number;
  owner: {
    server: string;
    user: string;
    _serialized: string;
  };
  participants: any[];
  pendingParticipants: any[];
}

```

`src/api/model/host-device.ts`:

```ts
export interface HostDevice {
  id: string;
  ref: string;
  refTTL: number;
  wid: Me;
  connected: boolean;
  me: Me;
  protoVersion: number[];
  clientToken: string;
  serverToken: string;
  isResponse: string;
  battery: number;
  plugged: boolean;
  lc: string;
  lg: string;
  locales: string;
  is24h: boolean;
  platform: string;
  phone: Phone;
  tos: number;
  smbTos: number;
  pushname: string;
  blockStoreAdds: boolean;
}

export interface Me {
  server: string;
  user: string;
  _serialized: string;
}

export interface Phone {
  wa_version: string;
  mcc: string;
  mnc: string;
  os_version: string;
  device_manufacturer: string;
  device_model: string;
  os_build_number: string;
}

```

`src/api/model/id.ts`:

```ts
export interface Id {
  server: string;
  user: string;
  _serialized: string;
  fromMe: boolean;
  remote: string;
  id: string;
}

```

`src/api/model/index.ts`:

```ts
export { Chat, LastReceivedKey } from './chat';
export { Contact } from './contact';
export { GroupMetadata } from './group-metadata';
export { Id } from './id';
export { Message } from './message';
export { ParticipantEvent } from './participant-event';
export { PartialMessage } from './partial-message';
export { Ack } from './ack';
export { HostDevice } from './host-device';
export { LiveLocation } from './live-location';
export { ContactStatus } from './contact-status';
export { GroupCreation } from './group-creation';
export { WhatsappProfile } from './whatsapp-profile';
export { PicTumb } from './pic-thumb';
export { ChatStatus } from './chat-status';
export { InterfaceChangeMode } from './Interface-mode';
export * from './result';

```

`src/api/model/live-location.ts`:

```ts
export interface LiveLocation {
  id: string;
  lat: number;
  lng: number;
  speed: number;
  lastUpdated: number;
  accuracy: number;
  degrees: any;
}

```

`src/api/model/message.ts`:

```ts
export interface Message {
  id: string;
  body: string;
  type: string;
  t: number;
  notifyName: string;
  from: string;
  to: string;
  fromMe: boolean;
  author: string;
  self: string;
  ack: number;
  invis: boolean;
  isNewMsg: boolean;
  star: boolean;
  recvFresh: boolean;
  interactiveAnnotations: any[];
  caption: string;
  filename: string;
  clientUrl: string;
  deprecatedMms3Url: string;
  mimetype: string;
  directPath: string;
  filehash: string;
  uploadhash: string;
  size: number;
  mediaKey: string;
  mediaKeyTimestamp: number;
  width: number;
  height: number;
  broadcast: boolean;
  mentionedJidList: any[];
  isForwarded: boolean;
  labels: any[];
  sender: Sender;
  timestamp: number;
  content: string;
  isGroupMsg: boolean;
  isMMS: boolean;
  isMedia: boolean;
  isNotification: boolean;
  isPSA: boolean;
  chat: {
    id: string;
    pendingMsgs: boolean;
    lastReceivedKey: LastReceivedKey;
    t: number;
    unreadCount: number;
    archive: boolean;
    isReadOnly: boolean;
    muteExpiration: number;
    name: string;
    notSpam: boolean;
    pin: number;
    msgs: null;
    kind: string;
    isGroup: boolean;
    contact: Sender;
    groupMetadata: null;
    presence: Presence;
    /**
     * @deprecated This is unreliable. Use the method {@link Whatsapp.getChatIsOnline} instead.
     */
    isOnline: null | boolean;
    /**
     * @deprecated This is unreliable. Use the method {@link Whatsapp.getLastSeen} instead.
     */
    lastSeen: null | number | boolean;
  };
  /**
   * @deprecated This is unreliable. Use the method {@link Whatsapp.getChatIsOnline} instead.
   */
  isOnline: null | boolean;
  /**
   * @deprecated This is unreliable. Use the method {@link Whatsapp.getLastSeen} instead.
   */
  lastSeen: null | number | boolean;
  chatId: string;
  quotedMsgObj: null;
  mediaData: MediaData;
}

export interface Sender {
  id: string;
  name: string;
  shortName: string;
  pushname: string;
  type: string;
  isBusiness: boolean;
  isEnterprise: boolean;
  statusMute: boolean;
  labels: any[];
  formattedName: string;
  isMe: boolean;
  isMyContact: boolean;
  isPSA: boolean;
  isUser: boolean;
  isWAContact: boolean;
  profilePicThumbObj: ProfilePicThumbObj;
  msgs: null;
}

export interface ProfilePicThumbObj {
  eurl: string;
  id: string;
  img: string;
  imgFull: string;
  raw: null;
  tag: string;
}

export interface LastReceivedKey {
  fromMe: boolean;
  remote: string;
  id: string;
  _serialized: string;
}

export interface Presence {
  id: string;
  chatstates: any[];
}

export interface MediaData {
  type: string;
  mediaStage: string;
  animationDuration: number;
  animatedAsNewMsg: boolean;
  _swStreamingSupported: boolean;
  _listeningToSwSupport: boolean;
}

```

`src/api/model/partial-message.ts`:

```ts
export interface PartialMessage {
  id: ID;
  body: string;
  type: string;
  t: number;
  notifyName: string;
  from: string;
  to: string;
  self: string;
  ack: number;
  invis: boolean;
  star: boolean;
  broadcast: boolean;
  mentionedJidList: any[];
  isForwarded: boolean;
  labels: any[];
}

interface ID {
  fromMe: boolean;
  remote: string;
  id: string;
  _serialized: string;
}

```

`src/api/model/participant-event.ts`:

```ts
import { Id } from './id';
import { GroupChangeEvent } from './enum';

export interface ParticipantEvent {
  by: Id;
  action: GroupChangeEvent;
  who: [Id];
}

```

`src/api/model/pic-thumb.ts`:

```ts
export interface PicTumb {
  attributes: Attributes;
  eurl: string;
  eurlStale: boolean;
  fallbackType: string;
  id: ID;
  img: string;
  imgFull: string;
  isState: boolean;
  pendingPic: any;
  raw: any;
  stale: boolean;
  tag: string;
  token: string;
}

interface Attributes {
  eurl: string;
  eurlStale: boolean;
  id: ID;
  pendingPic: any;
  raw: any;
  stale: boolean;
  tag: string;
  token: string;
}

interface ID {
  server: string;
  user: string;
  _serialized: string;
}

```

`src/api/model/qrcode.ts`:

```ts
export interface ScrapQrcode {
  base64Image: string;
  urlCode: string;
}

```

`src/api/model/result.ts`:

```ts
import { LastReceivedKey } from './chat';
import { HostDevice } from './host-device';

export interface ScopeResult {
  me: HostDevice;
  to: LastReceivedKey & {
    formattedName: string;
    isBusiness: boolean;
    isMyContact: boolean;
    verifiedName: string;
    pushname?: string;
    isOnline?: boolean;
  };
  erro?: boolean;
  text?: string | null;
  status?: number | string;
}

export interface SendFileResult extends ScopeResult {
  type: string;
  filename: string;
  text?: string;
  mimeType?: string;
}

export interface SendStickerResult extends ScopeResult {
  type: string;
}

export interface SendLinkResult extends ScopeResult {
  type: string;
  url: string;
  text: string;
}

```

`src/api/model/whatsapp-profile.ts`:

```ts
import { Id } from './id';

export interface WhatsappProfile {
  id: Id;
  status: number;
  isBusiness: boolean;
  canReceiveMessage: boolean;
  numberExists: boolean;
  profilePic: string;
}

```

`src/api/whatsapp.ts`:

```ts
import { Page, Browser } from 'puppeteer';
import { ControlsLayer } from './layers/controls.layer';
import { Message } from './model';
import { magix, timeout, makeOptions } from './helpers/decrypt';
import { useragentOverride } from '../config/WAuserAgente';
import { CreateConfig } from '../config/create-config';
import axios from 'axios';
import * as path from 'path';

export class Whatsapp extends ControlsLayer {
  constructor(
    public browser: Browser,
    public page: Page,
    session?: string,
    options?: CreateConfig
  ) {
    super(browser, page, session, options);
    this.initService();
    this.page.on('load', async () => {
      this.initialize();
      await page
        .waitForSelector('#app .two', { visible: true })
        .catch(() => {});
      await this.initService();
      await this.addChatWapi();
    });
  }

  async initService() {
    try {
      await this.page
        .waitForFunction('webpackChunkwhatsapp_web_client.length')
        .catch();

      await this.page
        .addScriptTag({
          path: require.resolve(path.join(__dirname, '../lib/wapi/', 'wapi.js'))
        })
        .catch();

      await this.page
        .addScriptTag({
          path: require.resolve(
            path.join(__dirname, '../lib/middleware', 'middleware.js')
          )
        })
        .catch();
      this.initialize();
    } catch {}
  }

  async addChatWapi() {
    await this.page.evaluate(() => WAPI.addChatWapi());
  }

  /**
   * Decrypts message file
   * @param data Message object
   * @returns Decrypted file buffer (null otherwise)
   */
  public async downloadFile(data: string) {
    return await this.page.evaluate((data) => WAPI.downloadFile(data), data);
  }

  /**
   * Download and returns the media content in base64 format
   * @param messageId Message ou id
   * @returns Base64 of media
   */
  public async downloadMedia(messageId: string | Message): Promise<string> {
    if (typeof messageId !== 'string') {
      messageId = messageId.id;
    }

    const result = await this.page
      .evaluate(
        (messageId) =>
          WAPI.downloadMedia(messageId).catch((e) => ({
            __error: e
          })),
        messageId
      )
      .catch(() => undefined);

    if (typeof result === 'object' && result.__error) {
      throw result.__error;
    }
    return result as string;
  }

  /**
   * Get the puppeteer page instance
   * @returns The Whatsapp page
   */
  get waPage(): Page {
    return this.page;
  }

  /**
   * Clicks on 'use here' button (When it get unlaunched)
   * This method tracks the class of the button
   * Whatsapp web might change this class name over the time
   * Dont rely on this method
   */
  public async useHere() {
    return await this.page.evaluate(() => WAPI.takeOver());
  }

  /**
   * Logout whastapp
   * @returns boolean
   */
  public async logout() {
    return await this.page.evaluate(() => WAPI.logout());
  }

  /**
   * Closes page and browser
   * @internal
   */
  public async close() {
    try {
      if (!this.page.isClosed()) {
        await this.page.close();
        await this.browser.close();
        return true;
      }
    } catch (e) {
      return false;
    }
  }

  /**
   * Get message by id
   * @param messageId string
   * @returns Message object
   */
  public async getMessageById(messageId: string) {
    return (await this.page.evaluate(
      (messageId: any) => WAPI.getMessageById(messageId),
      messageId
    )) as Message;
  }

  /**
   * Decrypts message file
   * @param message Message object
   * @returns Decrypted file buffer (null otherwise)
   */
  public async decryptFile(message: Message) {
    const options = makeOptions(useragentOverride);
    message.clientUrl =
      message.clientUrl !== undefined
        ? message.clientUrl
        : message.deprecatedMms3Url;

    if (!message.clientUrl) {
      throw new Error(
        'message is missing critical data needed to download the file.'
      );
    }

    let haventGottenImageYet: boolean = true,
      res: any;
    try {
      while (haventGottenImageYet) {
        res = await axios.get(message.clientUrl.trim(), options);
        if (res.status == 200) {
          haventGottenImageYet = false;
        } else {
          await timeout(2000);
        }
      }
    } catch (error) {
      console.error(error);
      throw 'Error trying to download the file.';
    }
    const buff = Buffer.from(res.data, 'binary');
    return magix(buff, message.mediaKey, message.type, message.size);
  }
}

```

`src/config/WAuserAgente.ts`:

```ts
const useragentOverride =
  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36';
export { useragentOverride };

```

`src/config/create-config.ts`:

```ts
import { Browser, BrowserContext, LaunchOptions, Page } from 'puppeteer';
import { puppeteerConfig } from './puppeteer.config';

// Server config
export interface CreateConfig {
  session?: string;
  /** folder name when saving tokens
   * @default 'tokens'
   */
  folderNameToken?: string;
  /**
   * folder directory tokens, just inside the venom folder, example:  { mkdirFolderToken: '/node_modules', } //will save the tokens folder in the node_modules directory
   * @default 'null'
   */
  mkdirFolderToken?: string;
  /**
   * Headless chrome
   * @default true
   */
  headless?: false | 'new';
  /**
   * Open devtools by default
   * @default false
   */
  devtools?: boolean;
  /**
   * Opens a debug session
   * @default false
   */
  debug?: boolean;
  /**
   * If you want to use browserWSEndpoint
   */
  browserWS?: string;
  /**
   * Parameters to be added into the chrome browser instance
   */
  browserArgs?: string[];
  /**
   * Add broserArgs without overwriting the project's original
   */
  addBrowserArgs?: string[];
  /**
   * Will be passed to puppeteer.launch
   */
  puppeteerOptions?: LaunchOptions;
  /**
   * Pass a external browser instance, can be used with electron
   */
  browser?: Browser | BrowserContext;
  /**
   * Pass a external page instance, can be used with electron
   */
  page?: Page;
  /**
   * Logs QR automatically in terminal
   * @default true
   */
  logQR?: boolean;
  /**
   * Will disable Spinnies animation, useful for containers (docker) for a better log
   * @default false
   */
  disableSpins?: boolean;
  /**
   * Will disable the welcoming message which appears in the beginning
   * @default false
   */
  disableWelcome?: boolean;
  /**
   * Logs info updates automatically in terminal
   * @default true
   */
  updatesLog?: boolean;
  /**
   * Automatically closes the venom-bot only when scanning the QR code (default 60000 miliseconds, if you want to turn it off, assign 0 or false)
   * @default 60000
   */
  autoClose?: number;
  /**
   * Creates a folder when inserting an object in the client's browser, to work it is necessary to pass the parameters in the function create browserSessionToken
   * @default true
   */
  createPathFileToken?: boolean;
  /**
   * Wait for in chat to return a instance of {@link Whatsapp}
   * @default false
   */
  waitForLogin?: boolean;
  /**
   * automatically download Chromium browser
   * @default true
   */
  BrowserFetcher?: boolean;
  /**
   * Forcing connection with whatsapp
   * @default true
   */
  forceConnect?: boolean;
  /**
   * Wait attempts, to force connection
   * @default 5
   */
  attemptsForceConnectLoad?: number;
  /**
   * force connect time stamp
   * @default 5000
   */
  forceConnectTime?: number;
  /**
   * Add proxy server
   * @default null
   */
  addProxy?: string[];
  /**
   * Proxy username
   * @default null
   */
  userProxy?: string;
  /**
   * Proxy password
   * @default null
   */
  userPass?: string;
  /**
   * Browser executable path
   * @default null
   */
  browserPathExecutable?: string;
}

export const defaultOptions: CreateConfig = {
  folderNameToken: 'tokens',
  mkdirFolderToken: '',
  headless: 'new',
  devtools: false,
  debug: false,
  logQR: true,
  browserWS: '',
  browserArgs: puppeteerConfig.chromiumArgs,
  addBrowserArgs: [],
  puppeteerOptions: {},
  disableSpins: false,
  disableWelcome: true,
  updatesLog: true,
  autoClose: 120000,
  createPathFileToken: true,
  waitForLogin: true,
  BrowserFetcher: true,
  forceConnect: false,
  attemptsForceConnectLoad: 5,
  forceConnectTime: 5000,
  addProxy: [],
  browserPathExecutable: null
};

```

`src/config/index.ts`:

```ts
export { options, defaultOptions } from './options';

```

`src/config/options.ts`:

```ts
import { LaunchOptions } from 'puppeteer';
import { puppeteerConfig } from './puppeteer.config';

// Server config
export interface options {
  /**
   * logs info updates automatically in terminal
   * @default true
   */
  updatesLog?: boolean;
  /**
   * name of the token to be generated, a folder with all customer information will be created
   * @default 'session'
   */
  session?: string;
  /** folder name when saving tokens
   * @default 'tokens'
   */
  folderNameToken?: string;
  /**
   * folder directory tokens, just inside the venom folder, example:  { mkdirFolderToken: '/node_modules', } //will save the tokens folder in the node_modules directory
   * @default 'null'
   */
  mkdirFolderToken?: string;
  /**
   * Headless chrome
   * @default true
   */
  headless?: boolean | 'new';
  /**
   * If you want to use browserWSEndpoint
   */
  browserWS?: string;
  /**
   * Parameters to be added into the chrome browser instance
   */
  browserArgs?: string[];
  /**
   * Add broserArgs without overwriting the project's original
   */
  addBrowserArgs?: string[];
  /**
   * Will be passed to puppeteer.launch
   */
  puppeteerOptions?: LaunchOptions;
  /**
   * Logs QR automatically in terminal
   * @default true
   */
  logQR?: boolean;
  /**
   * Will disable the welcoming message which appears in the beginning
   * @default false
   */
  disableWelcome?: boolean;
  /**
   * Automatically closes the venom-bot only when scanning the QR code (default 60000 miliseconds, if you want to turn it off, assign 0 or false)
   * @default 60000
   */
  autoClose?: number;
  /**
   * Creates a folder when inserting an object in the client's browser, to work it is necessary to pass the parameters in the function create browserSessionToken
   * @default true
   */
  createPathFileToken?: boolean;
  /**
   * automatically download Chromium browser
   * @default true
   */
  BrowserFetcher?: boolean;
  /**
   * Add proxy server
   * @default null
   */
  addProxy?: string[];
  /**
   * Proxy username
   * @default null
   */
  userProxy?: string;
  /**
   * Proxy password
   * @default null
   */
  userPass?: string;
  /**
   * Open devtools by default
   * @default false
   */
  devtools?: boolean;
  /**
   * Browser executable path
   * @default null
   */
  browserPathExecutable?: string;
}

export const defaultOptions: options = {
  session: 'name-session',
  folderNameToken: 'tokens',
  disableWelcome: false,
  BrowserFetcher: true,
  updatesLog: true,
  headless: true,
  logQR: true,
  devtools: false,
  mkdirFolderToken: '',
  browserWS: '',
  browserArgs: puppeteerConfig.chromiumArgs,
  addBrowserArgs: [],
  autoClose: 120000,
  addProxy: [],
  browserPathExecutable: ''
};

```

`src/config/puppeteer.config.ts`:

```ts
const puppeteerConfig = {
  whatsappUrl: 'https://web.whatsapp.com',
  argsRoot: ['--no-sandbox', '--disable-setuid-sandbox'],
  chromiumArgs: [
    '--no-zygote',
    '--log-level=3',
    '--disable-site-isolation-trials',
    '--no-experiments',
    '--ignore-gpu-blacklist',
    '--ignore-certificate-errors',
    '--ignore-certificate-errors-spki-list',
    '--disable-gpu',
    '--disable-extensions',
    '--disable-default-apps',
    '--enable-features=NetworkService',
    '--disable-setuid-sandbox',
    '--no-sandbox',
    '--disable-webgl',
    '--disable-infobars',
    '--window-position=0,0',
    '--ignore-certifcate-errors',
    '--ignore-certifcate-errors-spki-list',
    '--disable-threaded-animation',
    '--disable-threaded-scrolling',
    '--disable-in-process-stack-traces',
    '--disable-histogram-customizer',
    '--disable-gl-extensions',
    '--disable-composited-antialiasing',
    '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36',
    '--disable-background-networking',
    '--enable-features=NetworkService,NetworkServiceInProcess',
    '--disable-background-timer-throttling',
    '--disable-backgrounding-occluded-windows',
    '--disable-breakpad',
    '--disable-client-side-phishing-detection',
    '--disable-component-extensions-with-background-pages',
    '--disable-dev-shm-usage',
    '--disable-features=Translate',
    '--disable-hang-monitor',
    '--disable-ipc-flooding-protection',
    '--disable-popup-blocking',
    '--disable-prompt-on-repost',
    '--disable-renderer-backgrounding',
    '--disable-sync',
    '--force-color-profile=srgb',
    '--metrics-recording-only',
    '--no-first-run',
    '--enable-automation',
    '--password-store=basic',
    '--use-mock-keychain',
    '--enable-blink-features=IdleDetection',
    '--export-tagged-pdf',
    'about:blank'
  ]
};

export { puppeteerConfig };

```

`src/controllers/auth.ts`:

```ts
import * as path from 'path';
import * as puppeteer from 'puppeteer';
import * as qrcode from 'qrcode-terminal';
import { ScrapQrcode } from '../api/model/qrcode';
import { sleep } from '../utils/sleep';
import { Whatsapp } from '../api/whatsapp';

export const getInterfaceStatus = async (waPage: puppeteer.Page) => {
  return await waPage
    .waitForFunction(
      () => {
        const erroHTTP = document.querySelector('.error-code');
        if (erroHTTP && erroHTTP[0].innerText.includes('HTTP ERROR 429')) {
          return { type: erroHTTP[0].innerText };
        }
        const elLoginWrapper = document.querySelector(
          'body > div > div > .landing-wrapper'
        );
        const elQRCodeCanvas = document.querySelector('canvas');
        if (elLoginWrapper && elQRCodeCanvas) {
          return 'UNPAIRED';
        }

        const streamStatus = window?.Store?.Stream?.displayInfo;

        if (['PAIRING', 'RESUMING', 'SYNCING'].includes(streamStatus)) {
          return 'PAIRING';
        }

        const chat = document.querySelector('.app, .two') as HTMLDivElement;
        if (chat && chat.attributes && chat.tabIndex) {
          return 'CONNECTED';
        }
        return false;
      },
      {
        timeout: 0,
        polling: 100
      }
    )
    .then(async (element: any) => {
      return await element
        .evaluate((a: any) => {
          return a;
        })
        .catch(() => undefined);
    })
    .catch(() => undefined);
};

// };

/**
 * Validates if client is authenticated
 * @returns true if is authenticated, false otherwise
 * @param waPage
 */
export const isAuthenticated = async (waPage: puppeteer.Page) => {
  const status = await getInterfaceStatus(waPage);

  if (typeof status === 'object') {
    return status;
  }

  if (typeof status !== 'string') {
    return null;
  }
  return ['CONNECTED', 'PAIRING'].includes(status);
};

export const needsToScan = async (waPage: puppeteer.Page) => {
  const status = await getInterfaceStatus(waPage);
  if (typeof status !== 'string') {
    return null;
  }
  return status === 'UNPAIRED';
};

export const isInsideChats = async (waPage: puppeteer.Page) => {
  const status = await getInterfaceStatus(waPage);
  if (typeof status !== 'string') {
    return null;
  }

  return status === 'CONNECTED';
};

export const isConnectingToPhone = async (waPage: puppeteer.Page) => {
  const status = await getInterfaceStatus(waPage);
  if (typeof status !== 'string') {
    return null;
  }

  return status === 'PAIRING';
};

export async function asciiQr(code: string): Promise<string> {
  return new Promise((resolve) => {
    try {
      qrcode.generate(code, { small: true }, (qrcode) => {
        resolve(qrcode);
      });
    } catch (e) {}
  });
}

export async function retrieveQR(
  page: puppeteer.Page
): Promise<ScrapQrcode | undefined> {
  const hasCanvas = await page
    .evaluate(() => {
      const buttonReload = document.querySelector('button.Jht5u');
      const canvas = document.querySelector('canvas');
      if (canvas !== null && buttonReload === null) {
        return true;
      } else {
        return false;
      }
    })
    .catch(() => undefined);

  if (hasCanvas === false) {
    return undefined;
  }

  await page
    .addScriptTag({
      path: require.resolve(path.join(__dirname, '../lib/jsQR', 'jsQR.js'))
    })
    .catch(() => undefined);

  return await page
    .evaluate(() => {
      const buttonReload = document.querySelector('button.Jht5u');
      const canvas = document.querySelector('canvas') || null;
      if (canvas !== null && buttonReload === null) {
        const context = canvas.getContext('2d') || null;
        if (context !== null && buttonReload === null) {
          // @ts-ignore
          const code = jsQR(
            context.getImageData(0, 0, canvas.width, canvas.height).data,
            canvas.width,
            canvas.height
          );

          return {
            urlCode: code.data ? code.data : '',
            base64Image: canvas.toDataURL()
          };
        }
      }
      return undefined;
    })
    .catch(() => undefined);
}

export async function checkDisconnect(page: puppeteer.Page, wpp: Whatsapp) {
  while (true) {
    const erroBrowser = await page
      .evaluate(() => {
        const WebEncKeySalt = localStorage.getItem('WebEncKeySalt');
        const WANoiseInfo = localStorage.getItem('WANoiseInfo');
        if (WebEncKeySalt === null && WANoiseInfo === null) {
          return true;
        }
        return false;
      })
      .catch(() => {});

    if (erroBrowser) {
      await wpp.delProfile();
    }
    await sleep(100);
  }
}

export async function checkStore(page: puppeteer.Page, client: Whatsapp) {
  while (true) {
    const result = await page
      .evaluate(() => {
        const checkStore =
          typeof window.Store !== 'undefined'
            ? Object.keys(window.Store).length
            : undefined;
        if (!checkStore || !window.WAPI) {
          if (
            window['webpackChunkwhatsapp_web_client'] &&
            Array.isArray(window['webpackChunkwhatsapp_web_client'])
          ) {
            let last = window['webpackChunkwhatsapp_web_client'].length - 1;
            let check =
              window['webpackChunkwhatsapp_web_client'] &&
              window['webpackChunkwhatsapp_web_client'][last] &&
              window['webpackChunkwhatsapp_web_client'][last][0]
                ? []
                : undefined;
            if (check !== undefined) {
              window.Store = undefined;
              window.WAPI = undefined;
              return false;
            }
          }
        }
        return true;
      })
      .catch(() => {});

    if (result === false) {
      await client.initService();
      // await injectApi(page).catch(() => {});
    }
    await sleep(100);
  }
}

```

`src/controllers/browser.ts`:

```ts
import * as ChromeLauncher from 'chrome-launcher';
import chromeVersion from 'chrome-version';
import * as fs from 'fs';
import * as path from 'path';
import {
  Browser,
  BrowserContext,
  Page,
  LaunchOptions,
  PuppeteerLaunchOptions
} from 'puppeteer';
import puppeteer from 'puppeteer-extra';
import { options } from '../config';
import { CreateConfig } from '../config/create-config';
import { puppeteerConfig } from '../config/puppeteer.config';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';
import { useragentOverride } from '../config/WAuserAgente';
import { sleep } from '../utils/sleep';
import * as Spinnies from 'spinnies';
import * as os from 'os';
import axios from 'axios';
import { defaultOptions } from '../config/create-config';
import * as unzipper from 'unzipper';
import { exec } from 'child_process';
import isRoot from 'is-root';

export async function initWhatsapp(
  options: options | CreateConfig,
  browser: Browser
): Promise<Page | false> {
  const waPage = await getWhatsappPage(browser);
  if (!waPage) {
    return false;
  }
  try {
    await waPage.setUserAgent(useragentOverride);
    waPage.setDefaultTimeout(60000);

    const { userPass, userProxy, addProxy } = options;

    if (
      typeof userPass === 'string' &&
      userPass.length &&
      typeof userProxy === 'string' &&
      userProxy.length &&
      Array.isArray(addProxy) &&
      addProxy.length
    ) {
      await waPage.authenticate({
        username: userProxy,
        password: userPass
      });
    }

    await waPage.goto(puppeteerConfig.whatsappUrl, {
      waitUntil: 'domcontentloaded'
    });

    waPage.on('pageerror', ({ message }) => {
      const erroLogType1 = message.includes('RegisterEffect is not a function');
      const erroLogType2 = message.includes('[Report Only]');
      if (erroLogType1 || erroLogType2) {
        waPage.evaluate(() => {
          localStorage.clear();
          window.location.reload();
        });
      }
    });

    await browser.userAgent();
    return waPage;
  } catch (error) {
    console.error(error);
    await waPage.close();
    return false;
  }
}

export async function getWhatsappPage(
  browser: Browser | BrowserContext
): Promise<Page | false> {
  try {
    const pages: Page[] = await browser.pages();
    return pages.length !== 0 ? pages[0] : await browser.newPage();
  } catch {
    return false;
  }
}

export function folderSession(options: options | CreateConfig) {
  try {
    if (!options) {
      throw new Error(`Missing required options`);
    }
    if (!options.folderNameToken) {
      options.folderNameToken = defaultOptions.folderNameToken;
    }

    if (!options.session) {
      options.session = defaultOptions.session;
    }

    const folderSession = options.mkdirFolderToken
      ? path.join(
          path.resolve(
            process.cwd(),
            options.mkdirFolderToken,
            options.folderNameToken,
            options.session
          )
        )
      : path.join(
          path.resolve(process.cwd(), options.folderNameToken, options.session)
        );

    if (!fs.existsSync(folderSession)) {
      fs.mkdirSync(folderSession, { recursive: true });
    }

    const folderMulidevice = options.mkdirFolderToken
      ? path.join(
          path.resolve(
            process.cwd(),
            options.mkdirFolderToken,
            options.folderNameToken
          )
        )
      : path.join(path.resolve(process.cwd(), options.folderNameToken));

    if (!fs.existsSync(folderMulidevice)) {
      fs.mkdirSync(folderMulidevice, { recursive: true });
    }

    fs.chmodSync(folderMulidevice, '777');
    fs.chmodSync(folderSession, '777');

    options.puppeteerOptions = {
      userDataDir: folderSession,
      ignoreHTTPSErrors: true
    } as LaunchOptions;

    puppeteerConfig.chromiumArgs.push(`--user-data-dir=${folderSession}`);
    return true;
  } catch (error) {
    console.error(error);
    return false;
  }
}

async function getGlobalChromeVersion(): Promise<string | null> {
  try {
    const chromePath = ChromeLauncher.Launcher.getInstallations().pop();
    if (chromePath) {
      const version = await chromeVersion(chromePath);
      return version;
    }
  } catch (e) {
    console.error('Error retrieving Chrome version:', e);
  }
  return null;
}

async function checkPathDowload(extractPath: string) {
  try {
    const pathChrome = path.join(extractPath, 'chrome-win', 'chrome.exe');
    if (!fs.existsSync(pathChrome)) {
      return false;
    }
    return pathChrome;
  } catch {
    return false;
  }
}

async function getChromeVersionBash(executablePath: string): Promise<string> {
  const notCheckText = 'Not check version';

  try {
    const platform = os.platform();
    let command = '';

    if (platform === 'linux') {
      if (executablePath.includes('chromium')) {
        command = 'chromium-browser --version';
      } else if (executablePath.includes('chrome')) {
        command = 'google-chrome --version';
      }
    } else if (platform === 'darwin' && executablePath.includes('Chrome')) {
      command =
        '/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --version';
    }

    if (!command) {
      return notCheckText;
    }

    const { stdout, stderr } = await execAsync(command);
    if (stderr) {
      return notCheckText;
    }

    const version = stdout.trim().split(' ')[2];
    return version;
  } catch (error) {
    return notCheckText;
  }
}

function execAsync(
  command: string
): Promise<{ stdout: string; stderr: string }> {
  return new Promise((resolve) => {
    exec(command, (error, stdout, stderr) => {
      resolve({ stdout, stderr });
    });
  });
}

function downloadBash(): Promise<string | false> {
  return new Promise((resolve, reject) => {
    try {
      const platform = os.platform();
      if (platform === 'linux') {
        exec(
          'curl -O https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb',
          (error, stdout, stderr) => {
            if (error) {
              throw new Error(
                `Error downloading Google Chrome: ${error.message}`
              );
            }
            exec(
              'sudo dpkg -i google-chrome-stable_current_amd64.deb',
              (error, stdout, stderr) => {
                if (error) {
                  throw new Error(
                    `Error installing Google Chrome: ${error.message}`
                  );
                }
                exec('sudo apt-get update', (error, stdout, stderr) => {
                  if (error) {
                    throw new Error(
                      `Error update dependencies: ${error.message}`
                    );
                  }

                  exec('sudo apt-get install -f', (error, stdout, stderr) => {
                    if (error) {
                      throw new Error(
                        `Error fixing dependencies: ${error.message}`
                      );
                    }

                    exec('which google-chrome', (error, stdout, stderr) => {
                      if (error) {
                        throw new Error(
                          `Error getting Google Chrome path: ${error.message}`
                        );
                      }
                      const path = stdout.trim();
                      console.log(
                        `Google Chrome installed successfully at: ${path}`
                      );
                      return resolve(path);
                    });
                  });
                });
              }
            );
          }
        );
      } else if (platform === 'darwin') {
        exec(
          'curl -O https://dl.google.com/chrome/mac/stable/GGRO/googlechrome.dmg',
          (error, stdout, stderr) => {
            if (error) {
              throw new Error(
                `Error downloading Google Chrome: ${error.message}`
              );
            }

            exec('hdiutil attach googlechrome.dmg', (error, stdout, stderr) => {
              if (error) {
                throw new Error(`Error mounting DMG file: ${error.message}`);
              }

              exec(
                'rsync -a "/Volumes/Google Chrome/Google Chrome.app" "/Applications/"',
                (error, stdout, stderr) => {
                  if (error) {
                    throw new Error(
                      `Error installing Google Chrome: ${error.message}`
                    );
                  }

                  exec(
                    'hdiutil detach "/Volumes/Google Chrome"',
                    (error, stdout, stderr) => {
                      if (error) {
                        throw new Error(
                          `Error unmounting DMG file: ${error.message}`
                        );
                      }

                      exec(
                        'ls -d "/Applications/Google Chrome.app"',
                        (error, stdout, stderr) => {
                          if (error) {
                            console.error(
                              `Error getting Google Chrome path: ${error.message}`
                            );
                            return;
                          }

                          const path = stdout.trim();
                          console.log(
                            `Google Chrome installed successfully at: ${path}`
                          );
                          return resolve(path);
                        }
                      );
                    }
                  );
                }
              );
            });
          }
        );
      }
      resolve(false);
    } catch (error) {
      console.error(error);
      return reject(false);
    }
  });
}

export async function initBrowser(
  options: options | CreateConfig,
  spinnies: any
): Promise<Browser | false> {
  try {
    // Use stealth plugin to avoid being detected as a bot
    puppeteer.use(StealthPlugin());

    const checkFolder = folderSession(options);
    if (!checkFolder) {
      throw new Error(`Error executing client session info`);
    }

    // Check for deprecated headless option
    if (options.headless === true) {
      console.warn(
        'Warning: The usage of "headless: true" is deprecated. Please use "headless: \'new\'" or "headless: false" instead. https://developer.chrome.com/articles/new-headless/'
      );
    }

    if (
      options.headless !== 'new' &&
      options.headless !== false &&
      options.headless !== true
    ) {
      throw new Error('Now use only headless: "new", "true" or false');
    }

    const chromePath = getChromeExecutablePath();
    // Set the executable path to the path of the Chrome binary or the executable path provided
    let executablePath =
      options.browserPathExecutable ??
      getChrome() ??
      puppeteer.executablePath() ??
      chromePath;

    console.log('Executable Path: ', executablePath);

    const extractPath = path.join(process.cwd(), 'chrome');
    const checkPath = await checkPathDowload(extractPath);
    const platform = os.platform();

    if (!executablePath || !isChromeInstalled(executablePath)) {
      spinnies.add(`browser-info-${options.session}`, {
        text: `...`
      });
      spinnies.fail(`browser-info-${options.session}`, {
        text: `Could not find the google-chrome browser on the machine!`
      });
      const resultBash = await downloadBash();
      if (resultBash) {
        executablePath = resultBash;
      } else if (!checkPath) {
        spinnies.add(`browser-status-${options.session}`, {
          text: `Downloading browser...`
        });

        // Download the latest version of Chrome
        const downloadUrl = `https://www.googleapis.com/download/storage/v1/b/chromium-browser-snapshots/o/Win_x64%2F1000027%2Fchrome-win.zip?generation=1651780728332948&alt=media`;
        const zipFilePath = path.join(
          process.cwd(),
          'chrome',
          'chrome-win.zip'
        );

        if (!fs.existsSync(extractPath)) {
          fs.mkdirSync(extractPath, { recursive: true });
        }

        fs.chmodSync(extractPath, '777');

        spinnies.add(`browser-path-${options.session}`, {
          text: `...`
        });
        spinnies.succeed(`browser-path-${options.session}`, {
          text: `Path download Chrome: ${zipFilePath}`
        });

        const response = await axios.get(downloadUrl, {
          responseType: 'arraybuffer'
        });

        // Verifica se o status da resposta é 200 (OK)
        if (response.status === 200) {
          await fs.promises.writeFile(zipFilePath, response.data);
          spinnies.succeed(`browser-status-${options.session}`, {
            text: `Download completed.`
          });

          spinnies.add(`browser-status-${options.session}`, {
            text: `Extracting Chrome: ${extractPath}`
          });

          const zip = await unzipper.Open.file(zipFilePath);
          await zip.extract({ path: extractPath });
          spinnies.succeed(`browser-status-${options.session}`, {
            text: `Chrome extracted successfully.`
          });
          const pathChrome = path.join(extractPath, 'chrome-win', 'chrome.exe');
          if (!fs.existsSync(pathChrome)) {
            throw new Error(`Error no Path download Chrome`);
          }
          const checkDowl = await checkPathDowload(extractPath);
          if (!checkDowl) {
            throw new Error(`Error no Path download Chrome`);
          }

          const folderChrom = path.join(extractPath, 'chrome-win');
          fs.chmodSync(folderChrom, '777');

          executablePath = pathChrome;
          spinnies.add(`browser-path-${options.session}`, {
            text: `...`
          });
          spinnies.succeed(`browser-path-${options.session}`, {
            text: `Execute Path Chrome: ${executablePath}`
          });
        } else {
          throw new Error('Error download file Chrome.');
        }
      } else {
        executablePath = checkPath;
      }
    }

    let chromeVersion = '';
    let versionTimeout: string | number | NodeJS.Timeout;

    spinnies.add(`browser-Platform-${options.session}`, {
      text: `...`
    });

    spinnies.succeed(`browser-Platform-${options.session}`, {
      text: `Platform: ${platform}`
    });

    if (platform === 'darwin' || platform === 'linux') {
      chromeVersion = await getChromeVersionBash(executablePath);
    } else {
      if (executablePath.includes('google-chrome')) {
        chromeVersion = await getGlobalChromeVersion();
      } else {
        const browser = await puppeteer.launch({
          executablePath,
          headless: options.headless === true ? options.headless : 'new',
          args: ['--no-sandbox', '--disable-setuid-sandbox']
        });

        versionTimeout = setTimeout(() => {
          browser.close();
          throw new Error('This browser version has problems');
        }, 10000);
        chromeVersion = await browser.version();
        clearTimeout(versionTimeout);
        await browser.close();
      }
    }

    if (chromeVersion) {
      spinnies.add(`browser-Version-${options.session}`, {
        text: `...`
      });

      spinnies.succeed(`browser-Version-${options.session}`, {
        text: `Browser Version: ${chromeVersion}`
      });
    }

    const extras = { executablePath };

    if (Array.isArray(options.addProxy) && options.addProxy.length) {
      const proxy =
        options.addProxy[Math.floor(Math.random() * options.addProxy.length)];
      const args = options.browserArgs ?? puppeteerConfig.chromiumArgs;
      args.push(`--proxy-server=${proxy}`);
    }

    if (
      Array.isArray(options.addBrowserArgs) &&
      options.addBrowserArgs.length
    ) {
      options.addBrowserArgs.forEach((arg) => {
        if (!puppeteerConfig.chromiumArgs.includes(arg)) {
          puppeteerConfig.chromiumArgs.push(arg);
        }
      });
    }

    const launchOptions = {
      headless: options.headless,
      devtools: options.devtools,
      args: options.browserArgs ?? puppeteerConfig.chromiumArgs,
      ...options.puppeteerOptions,
      ...extras
    };

    const isRunningAsRoot = isRoot();
    if (isRunningAsRoot && options.browserArgs && options.browserArgs.length) {
      addArgsRoot(options.browserArgs);
    }

    if (options.browserWS && options.browserWS !== '') {
      return await puppeteer.connect({ browserWSEndpoint: options.browserWS });
    } else {
      await removeStoredSingletonLock(options.puppeteerOptions);
      return await puppeteer.launch(launchOptions);
    }
  } catch (e) {
    console.error(e);
    return false;
  }
}

function addArgsRoot(args: string[]) {
  if (Array.isArray(args)) {
    args.forEach((option) => {
      if (!puppeteerConfig.argsRoot.includes(option)) {
        puppeteerConfig.argsRoot.push(option);
      }
    });
  }
}

function getChromeExecutablePath() {
  const platform = os.platform();
  switch (platform) {
    case 'win32':
      return getWindowsChromeExecutablePath();
    case 'darwin':
      return '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome';
    case 'linux':
      return '/usr/bin/google-chrome';
    default:
      console.error('Could not find browser.');
      return null;
  }
}

function getWindowsChromeExecutablePath() {
  const programFilesPath = process.env.ProgramFiles || '';
  const programFilesx86Path = process.env['ProgramFiles(x86)'] || '';

  if (programFilesx86Path) {
    return path.join(
      programFilesx86Path,
      'Google',
      'Chrome',
      'Application',
      'chrome.exe'
    );
  } else if (programFilesPath) {
    return path.join(
      programFilesPath,
      'Google',
      'Chrome',
      'Application',
      'chrome.exe'
    );
  } else {
    return null;
  }
}

export async function statusLog(
  page: Page,
  spinnies: Spinnies,
  session: string,
  callback: (infoLog: string) => void
) {
  while (true) {
    if (page.isClosed()) {
      try {
        spinnies.fail(`whatzapp-intro-${session}`, {
          text: 'Erro intro'
        });
      } catch {}
      break;
    }

    const infoLog: string = await page
      .evaluate(() => {
        const target = document.getElementsByClassName('_2dfCc');
        if (target && target.length) {
          if (
            target[0]['innerText'] !== 'WhatsApp' &&
            target[0]['innerText'] !== window['statusInicial']
          ) {
            window['statusInicial'] = target[0]['innerText'];
            return window['statusInicial'];
          }
        }
      })
      .catch(() => {});
    if (infoLog) {
      callback(infoLog);
    }
    await sleep(200);
  }
}

/**
 * Retrieves chrome instance path
 */
function getChrome() {
  try {
    const chromeInstalations = ChromeLauncher.Launcher.getInstallations();
    return chromeInstalations[0];
  } catch (error) {
    return undefined;
  }
}

function isChromeInstalled(executablePath: string): boolean {
  try {
    fs.accessSync(executablePath);
    return true;
  } catch {
    return false;
  }
}

function removeStoredSingletonLock(
  puppeteerOptions: PuppeteerLaunchOptions
): Promise<boolean> {
  return new Promise((resolve, reject) => {
    try {
      const platform = os.platform();
      const { userDataDir } = puppeteerOptions;
      const singletonLockPath = path.join(userDataDir, 'SingletonLock');

      if (platform === 'win32') {
        // No need to remove the lock on Windows, so resolve with true directly.
        resolve(true);
      } else {
        if (fs.existsSync(singletonLockPath)) {
          fs.unlink(singletonLockPath, (error) => {
            if (error) {
              console.error('Error removing SingletonLock:', error);
              reject(false);
            } else {
              console.error('Removing SingletonLock:');
              resolve(true);
            }
          });
        } else {
          resolve(true);
        }
      }
    } catch {
      resolve(true);
    }
  });
}

```

`src/controllers/check-up-to-date.ts`:

```ts
import { upToDate } from '../utils/semver';
import boxen from 'boxen';
import chalk from 'chalk';
const { version } = require('../../package.json');
import npmCheckUpdates from 'npm-check-updates';

let updatesChecked = false;

export async function checkUpdates() {
  if (!updatesChecked) {
    updatesChecked = true;
    return await checkVenomVersion();
  }
}

async function checkVenomVersion() {
  try {
    const latest = await getLatestVersion('venom-bot');
    if (upToDate(version, latest)) {
      console.log(chalk.red("You're up to date 🎉🎉🎉"));
    } else {
      console.log('There is a new version available');
      logUpdateAvailable(version, latest);
    }
  } catch (e) {
    console.log(e);
    console.log(
      'Unable to access: "https://www.npmjs.com", check your internet'
    );
    return false;
  }
}

async function getLatestVersion(packageName: string) {
  const upgraded = await npmCheckUpdates({
    packageData: JSON.stringify({
      dependencies: { 'venom-bot': '1.0.0' }
    }),
    silent: true,
    jsonUpgraded: true
  });
  return upgraded[packageName];
}

function logUpdateAvailable(current: string, latest: string) {
  // prettier-ignore
  const newVersionLog =
      `There is a new version of ${chalk.bold(`venom`)} ${chalk.gray(current)} ➜  ${chalk.bold.green(latest)}\n` +
      `Update your package by running:\n\n` +
      `${chalk.bold('\>')} ${chalk.blueBright('npm update venom-bot')}`;
  console.log(boxen(newVersionLog, { padding: 1 }));
  console.log(
    `For more info visit: ${chalk.underline(
      'https://github.com/orkestral/venom/blob/master/Update.md'
    )}\n`
  );
}

```

`src/controllers/init.ts`:

```ts
//import { Browser, Page } from 'puppeteer';
import { checkUpdates } from './check-up-to-date';
import { options, defaultOptions } from '../config';
//import { initWhatsapp, initBrowser } from './browser';
//import { CallbackOnStatus } from '../api/layers';

export async function connect(options?: options);

export async function connect(options?: options) {
  //const event = new CallbackOnStatus();
  const mergeOptionsDefault = { ...defaultOptions, ...options };

  if (!!mergeOptionsDefault.session && mergeOptionsDefault.session.length) {
    const sessionName = mergeOptionsDefault.session;
    const replaceSession = sessionName.replace(/[^0-9a-zA-Zs]/g, '');
    if (replaceSession.length) {
      mergeOptionsDefault.session = replaceSession;
    } else {
      mergeOptionsDefault.session = defaultOptions.session;
    }
  }

  if (mergeOptionsDefault.updatesLog) {
    await checkUpdates();
  }

  // const wpage: Browser | boolean = await initBrowser(mergeOptionsDefault);
  // if (typeof wpage !== 'boolean') {
  //   const page: boolean | Page = await initWhatsapp(mergeOptionsDefault, wpage);
  //   if (typeof page !== 'boolean') {
  //     console.log('New option');
  //   }
  // }
}

```

`src/controllers/initializer.ts`:

```ts
import { Whatsapp } from '../api/whatsapp';
import { CreateConfig, defaultOptions } from '../config/create-config';
import { initWhatsapp, initBrowser, statusLog } from './browser';
import { welcomeScreen } from './welcome';
import { getSpinnies } from '../utils/spinnies';
import {
  SocketState,
  SocketStream,
  InterfaceMode,
  InterfaceState
} from '../api/model/enum';
import { InterfaceChangeMode } from '../api/model';
import { checkingCloses } from '../api/helpers';
import { Browser, Page } from 'puppeteer';
import { checkUpdates } from './check-up-to-date';

declare global {
  interface Window {
    updater;
  }
}
/**
 * A callback will be received, informing the status of the qrcode
 */
export type CatchQR = (
  qrCode: string,
  asciiQR: string,
  attempt?: number,
  urlCode?: string
) => void;

/**
 * A callback will be received, informing the customer's status
 */
export type StatusFind = (
  statusGet: string,
  session: string,
  info?: string
) => void;

/**
 * A callback will be received, informing user about browser and page instance
 */
export type BrowserInstance = (
  browser: string | Browser,
  waPage: false | Page,
  client: Whatsapp
) => void;

export type interfaceChange = (
  statusGet: InterfaceStateChange | string,
  session: string
) => void;

export enum InterfaceStateChange {
  /**
   * Client interface is loading page from qrcode
   */
  qrcodeOpening = 'qrcodeOpening',
  /**
   * Client interface is loading qrcode
   */
  qrcodeLoading = 'qrcodeLoading',
  /**
   * QR code ready to be read!
   */
  qrcodeNormal = 'qrcodeNormal',
  /**
   * Client interface is loading page from syncing
   */
  syncingOpening = 'syncingOpening',
  /**
   * Client interface is loading syncing
   */
  syncingLoading = 'syncingLoading',
  /**
   * Syncing ready to be read!
   */
  syncingNormal = 'syncingNormal',
  /**
   * The customer is in the chat
   */
  chatsAvailable = 'chatsAvailable'
}

export type ReconnectQrcode = (client: Whatsapp) => void;

export interface CreateOptions extends CreateConfig {
  /**
   * You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
   */
  session: string;
  /**
   * A callback will be received, informing the status of the qrcode
   */
  catchQR?: CatchQR;
  /**
   * A callback will be received, informing the customer's status
   */
  statusFind?: StatusFind;
  /**
   * A callback will be received, informing user about browser and page instance
   */
  browserInstance?: BrowserInstance;
  /**
   * A callback will be received, customer interface information
   */
  interfaceChange?: interfaceChange;
}

/**
 * Start the bot
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */
export async function create(createOption: CreateOptions): Promise<Whatsapp>;
/**
 * Start the bot
 * You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */

export async function create(
  sessionName: string,
  catchQR?: CatchQR,
  statusFind?: StatusFind,
  options?: CreateConfig,
  browserInstance?: BrowserInstance,
  reconnectQrcode?: ReconnectQrcode,
  interfaceChange?: interfaceChange
): Promise<Whatsapp>;

export async function create(
  sessionOrOption: string | CreateOptions,
  catchQR?: CatchQR,
  statusFind?: StatusFind,
  options?: CreateConfig,
  browserInstance?: BrowserInstance,
  reconnectQrcode?: ReconnectQrcode,
  interfaceChange?: interfaceChange
): Promise<any> {
  let session = 'session';
  return new Promise(async (resolve, reject) => {
    if (
      typeof sessionOrOption === 'string' &&
      sessionOrOption.replace(/\s/g, '').length
    ) {
      session = sessionOrOption.replace(/\s/g, '');
      options = { session };
    } else if (typeof sessionOrOption === 'object') {
      session = sessionOrOption.session || session;
      catchQR = sessionOrOption.catchQR || catchQR;
      statusFind = sessionOrOption.statusFind || statusFind;
      browserInstance = sessionOrOption.browserInstance || browserInstance;
      options = sessionOrOption;
    }

    const requiredNodeVersion = 16;
    const currentNodeVersion = Number(process.versions.node.split('.')[0]);
    if (currentNodeVersion < requiredNodeVersion) {
      return reject(
        `Outdated Node.js version. Node.js ${requiredNodeVersion} or higher is required. Please update Node.js.`
      );
    }

    await checkUpdates();

    const spinnies = getSpinnies({
      disableSpins: options ? options.disableSpins : false
    });

    const mergedOptions = { ...defaultOptions, ...options };

    if (!mergedOptions.disableWelcome) {
      welcomeScreen();
    }

    statusFind && statusFind('initBrowser', session);

    // Initialize whatsapp
    if (mergedOptions.browserWS) {
      spinnies.add(`browser-${session}`, {
        text: `Waiting... checking the wss server...`
      });
    } else {
      spinnies.add(`browser-${session}`, {
        text: 'Waiting... checking the browser...'
      });
    }

    const browser: Browser | boolean = await initBrowser(
      mergedOptions,
      spinnies
    );

    if (typeof browser === 'boolean') {
      spinnies.fail(`browser-${session}`, {
        text: `Error no open browser....`
      });
      statusFind && statusFind('noOpenBrowser', session);
      return reject(`Error no open browser....`);
    }

    if (mergedOptions.browserWS) {
      statusFind && statusFind('connectBrowserWs', session);
      spinnies.succeed(`browser-${session}`, {
        text: `Has been properly connected to the wss server`
      });
    } else {
      statusFind && statusFind('openBrowser', session);
      spinnies.succeed(`browser-${session}`, {
        text: `Browser successfully opened`
      });
    }

    if (!mergedOptions.browserWS) {
      spinnies.add(`browser-${session}`, {
        text: 'checking headless...'
      });

      if (mergedOptions.headless) {
        spinnies.succeed(`browser-${session}`, {
          text: 'headless option is active, browser hidden'
        });
      } else {
        spinnies.succeed(`browser-${session}`, {
          text: 'headless option is disabled, browser visible'
        });
      }
    }

    if (typeof browser === 'object') {
      if (!mergedOptions.browserWS && browser['_process']) {
        browser['_process'].once('close', () => {
          browser['isClose'] = true;
        });
      }

      checkingCloses(browser, mergedOptions, (result) => {
        statusFind && statusFind(result, session);
      }).catch(() => {
        spinnies.fail(`whatzapp-${session}-close`, {
          text: 'Closed Browser'
        });
        return reject('The client has been closed');
      });

      spinnies.add(`whatzapp-${session}`, {
        text: 'Checking page to whatzapp...'
      });

      statusFind && statusFind('initWhatsapp', session);
      // Initialize whatsapp
      const page: false | Page = await initWhatsapp(mergedOptions, browser);

      if (page === false) {
        spinnies.fail(`whatzapp-${session}`, {
          text: 'Error accessing the page: "https://web.whatsapp.com"'
        });
        statusFind && statusFind('erroPageWhatsapp', session);
        return reject(
          'Error when trying to access the page: "https://web.whatsapp.com"'
        );
      }

      statusFind && statusFind('successPageWhatsapp', session);

      spinnies.succeed(`whatzapp-${session}`, {
        text: 'Page successfully accessed'
      });

      try {
        spinnies.add(`whatzapp-intro-${session}`, {
          text: 'waiting for introduction'
        });
      } catch {}

      statusLog(page, spinnies, session, (event) => {
        try {
          spinnies.add(`whatzapp-intro-${session}`, {
            text: event
          });
        } catch {}
        statusFind && statusFind('introductionHistory', session, event);
      });

      const client = new Whatsapp(browser, page, session, mergedOptions);

      if (browserInstance) {
        browserInstance(browser, page, client);
      }

      client.onInterfaceChange(async (interFace: InterfaceChangeMode) => {
        try {
          if (interFace.mode === InterfaceMode.MAIN) {
            interfaceChange && interfaceChange('chatsAvailable', session);
            spinnies.add(`whatzapp-mode-main-${session}`, {
              text: 'opening main page...'
            });

            spinnies.succeed(`whatzapp-mode-main-${session}`, {
              text: 'Successfully main page!'
            });

            spinnies.succeed(`whatzapp-mode-syncing-${session}`, {
              text: 'Successfully sync!'
            });

            await client.initService();
            await client.addChatWapi();
          }

          if (interFace.mode === InterfaceMode.SYNCING) {
            if (interFace.info === InterfaceState.OPENING) {
              interfaceChange && interfaceChange('syncingOpening', session);
              spinnies.add(`whatzapp-mode-syncing-${session}`, {
                text: 'opening sync page...'
              });
            }

            if (interFace.info === InterfaceState.PAIRING) {
              interfaceChange && interfaceChange('syncingLoading', session);
              spinnies.add(`whatzapp-mode-syncing-${session}`, {
                text: 'Loading sync...'
              });
            }

            if (interFace.info === InterfaceState.NORMAL) {
              interfaceChange && interfaceChange('syncingNormal', session);
              spinnies.succeed(`whatzapp-mode-syncing-${session}`, {
                text: 'Successfully sync!'
              });
            }
          }

          if (interFace.mode === InterfaceMode.QR) {
            const status = await page.evaluate(
              () => window?.Store?.State?.Socket?.stream
            );
            if (status === SocketStream.DISCONNECTED) {
              spinnies.add(`whatzapp-disconnected-${session}`, {
                text: 'checking...'
              });

              spinnies.fail(`whatzapp-disconnected-${session}`, {
                text: 'Was disconnected!'
              });
              document.querySelectorAll('.MLTJU p')[0].textContent;
              statusFind && statusFind('desconnected', session);
            }

            if (interFace.info === InterfaceState.OPENING) {
              interfaceChange && interfaceChange('qrcodeOpening', session);
              spinnies.add(`whatzapp-mode-qr-${session}`, {
                text: 'Opening QR Code page...'
              });
            }

            if (interFace.info === InterfaceState.PAIRING) {
              interfaceChange && interfaceChange('qrcodeLoading', session);
              spinnies.add(`whatzapp-mode-qr-${session}`, {
                text: 'Loading QR Code...'
              });
            }

            if (interFace.info === InterfaceState.NORMAL) {
              interfaceChange && interfaceChange('qrcodeNormal', session);
              spinnies.succeed(`whatzapp-mode-qr-${session}`, {
                text: 'Successfully loaded QR Code!'
              });
            }
          }
        } catch {}
      });

      client
        .onStreamChange(async (stateStream: SocketStream) => {
          if (stateStream === SocketStream.CONNECTED) {
            try {
              spinnies.succeed(`whatzapp-intro-${session}`, {
                text: 'Successfully connected!'
              });
            } catch {}
          }

          if (stateStream === SocketStream.DISCONNECTED) {
            const mode = await page
              .evaluate(() => window?.Store?.Stream?.mode)
              .catch(() => {});
            if (
              mode === InterfaceMode.QR
              // && checkFileJson(mergedOptions, session)
            ) {
              if (statusFind) {
                spinnies.add(`whatzapp-qr-${session}`, {
                  text: 'check....'
                });
                statusFind('desconnectedMobile', session);
                spinnies.fail(`whatzapp-qr-${session}`, {
                  text: 'Disconnected by cell phone!'
                });
              }
            }
          }
        })
        .catch();

      client
        .onStateChange(async (state) => {
          if (state === SocketState.PAIRING) {
            const device: Boolean = await page
              .evaluate(() => {
                if (
                  document.querySelector('[tabindex="-1"]') &&
                  window?.Store?.Stream?.mode === InterfaceMode.SYNCING &&
                  window?.Store?.Stream?.obscurity === 'SHOW'
                ) {
                  return true;
                }
                return false;
              })
              .catch(() => undefined);
            if (device === true) {
              if (statusFind) {
                statusFind('deviceNotConnected', session);
              }
            }
          }
        })
        .catch();

      page.on('dialog', async (dialog) => {
        await dialog.accept();
      });

      if (mergedOptions.waitForLogin) {
        const isLogged = await client
          .waitForLogin(catchQR, statusFind)
          .catch(() => undefined);

        statusFind && statusFind('waitForLogin', session);

        if (!isLogged) {
          return reject('Not Logged');
        }

        let waitLoginPromise = null;
        client
          .onStateChange(async (state) => {
            if (
              state === SocketState.UNPAIRED ||
              state === SocketState.UNPAIRED_IDLE
            ) {
              if (!waitLoginPromise) {
                waitLoginPromise = client
                  .waitForLogin(catchQR, statusFind)
                  .then(() => {
                    if (reconnectQrcode) {
                      reconnectQrcode(client);
                    }
                  })
                  .catch(() => {})
                  .finally(() => {
                    waitLoginPromise = null;
                  });
              }
              await waitLoginPromise;
            }
          })
          .catch();
      }

      statusFind && statusFind('waitChat', session);

      await page
        .waitForSelector('#app .two', { visible: true })
        .catch(() => {});

      try {
        spinnies.succeed(`whatzapp-intro-${session}`, {
          text: 'Successfully connected!'
        });
      } catch {}

      await client.initService();
      await client.addChatWapi();

      statusFind && statusFind('successChat', session);

      return resolve(client);
    }
  });
}

```

`src/controllers/welcome.ts`:

```ts
import { yo } from 'yoo-hoo';
let welcomeShown = false;
export function welcomeScreen() {
  if (welcomeShown) {
    return;
  }
  welcomeShown = true;
  yo('VENOM-BOT', { color: 'cyan' });
  console.log('\n\n');
}

```

`src/index.ts`:

```ts
export * from './api/model';
export {
  AckType,
  ChatState,
  GroupChangeEvent,
  GroupNotificationType,
  MessageType,
  SocketState,
  InterfaceMode,
  InterfaceState
} from './api/model/enum';
export { Whatsapp } from './api/whatsapp';
export { CreateConfig } from './config/create-config';
export { connect } from './controllers/init';
export {
  create,
  CatchQR,
  CreateOptions,
  StatusFind
} from './controllers/initializer';

```

`src/lib/README.md`:

```md
# Files here should not be touched

> Files inside this directory are automatically generated and copied into dist bundle with the build scripts

```

`src/lib/counter/Counter.js`:

```js
class Counter {
  constructor(msTime) {
    this.isFirstCall = true;
    this.startTime = '';
  }

  counterInit() {
    if (this.isFirstCall) {
      console.log(`Starting count down for close`);
      this.isFirstCall = false;
      this.startTime = new Date();
    } else return false;
  }

  getElapsedTime() {
    //console.log('Elapsed Time ' + this.calculateTime())
    return this.calculateTime();
  }

  calculateTime() {
    let currentTime = new Date();
    return Math.round(currentTime.getTime() - this.startTime.getTime());
  }
}
module.exports = Counter;

```

`src/lib/counter/gulpfile.js`:

```js
const { src, dest } = require('gulp');
const path = require('path');

function copy() {
  return src('./Counter.js').pipe(
    dest(path.resolve(__dirname, '../../../dist/lib/counter'))
  );
}

exports.default = copy;

```

`src/lib/middleware.js`:

```js
var ExposedFn;
(function (ExposedFn) {
  ExposedFn['OnMessage'] = 'onMessage';
})(ExposedFn || (ExposedFn = {}));
/**
 * Exposes [OnMessage] function
 */
WAPI.waitNewMessages(false, function (data) {
  data.forEach(function (message) {
    window[ExposedFn.OnMessage](message);
  });
});

```

`src/lib/middleware/middleware.ts`:

```ts
enum ExposedFn {
  OnMessage = 'onMessage',
  OnAck = 'onAck',
  OnParticipantsChanged = 'onParticipantsChanged'
}

/**
 * Exposes [OnMessage] function
 */
(window as any).WAPI.waitNewMessages(false, (data: any[]) => {
  data.forEach((message: any) => {
    window[ExposedFn.OnMessage](message);
  });
});

(window as any).WAPI.waitNewAcknowledgements(function (data: any) {
  if (window[ExposedFn.OnAck]) {
    window[ExposedFn.OnAck](data);
  }
});

```

`src/lib/middleware/tsconfig.json`:

```json
{
  "compilerOptions": {
    "noImplicitAny": false,
    "module": "es6",
    "target": "es6"
  }
}

```

`src/lib/middleware/webpack.config.js`:

```js
const path = require('path');

module.exports = {
  entry: './middleware.ts',
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/
      }
    ]
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js']
  },
  output: {
    filename: 'middleware.js',
    path: path.resolve(__dirname, '../../../dist/lib/middleware')
  }
};

```

`src/lib/wapi/api.js`:

```js
import {
  sleep,
  injectConfig,
  injectParasiteSnake,
  processFiles,
  base64ToFile,
  generateMediaKey,
  arrayBufferToBase64,
  encryptAndUploadFile,
  getFileHash
} from './help';

import {
  getChat,
  scope,
  getNewId,
  getNewMessageId,
  sendExist,
  checkNumberStatus,
  isMD,
  sendCheckType,
  addChatWapi
} from './functions/help';

import {
  sendMessage,
  baseSendMessage,
  getAllContacts,
  createGroup,
  addParticipant,
  setGroupDescription,
  getHost,
  setGroupImage
} from './functions';

import {
  serializeMessageObj,
  serializeChatObj,
  serializeContactObj,
  serializeProfilePicThumb,
  serializeRawObj,
  serializeMeObj
} from './serialize';

//initialized scrap webpack
(async () => {
  window[injectConfig.webpack] = window[injectConfig.webpack] || [];
  window.Store = {};
  while (true) {
    try {
      const webPackLast = window[injectConfig.webpack].length - 1;
      if (
        !window[injectConfig.webpack][webPackLast][0].includes(
          injectConfig.parasite
        )
      ) {
        await injectParasiteSnake();
        return;
      }
    } catch {
      await sleep(1000);
    }
  }
})();

if (typeof window.WAPI === 'undefined') {
  window.WAPI = {};

  // Helps
  window.WAPI.getChat = getChat;
  window.WAPI.scope = scope;
  window.WAPI.getNewId = getNewId;
  window.WAPI.getNewMessageId = getNewMessageId;
  window.WAPI.sendExist = sendExist;
  window.WAPI.checkNumberStatus = checkNumberStatus;
  window.WAPI.isMD = isMD;
  window.WAPI.baseSendMessage = baseSendMessage;
  window.WAPI.processFiles = processFiles;
  window.WAPI.base64ToFile = base64ToFile;
  window.WAPI.generateMediaKey = generateMediaKey;
  window.WAPI.arrayBufferToBase64 = arrayBufferToBase64;
  window.WAPI.encryptAndUploadFile = encryptAndUploadFile;
  window.WAPI.getFileHash = getFileHash;
  window.WAPI.sendCheckType = sendCheckType;
  window.WAPI.addChatWapi = addChatWapi;

  // Functions

  // Send
  window.WAPI.sendMessage = sendMessage;

  // Host
  window.WAPI.getAllContacts = getAllContacts;
  window.WAPI.getHost = getHost;

  // Group
  window.WAPI.createGroup = createGroup;
  window.WAPI.addParticipant = addParticipant;
  window.WAPI.setGroupDescription = setGroupDescription;
  window.WAPI.setGroupImage = setGroupImage;

  // Serialize
  window.WAPI.serializeMessageObj = serializeMessageObj;
  window.WAPI.serializeChatObj = serializeChatObj;
  window.WAPI.serializeContactObj = serializeContactObj;
  window.WAPI.serializeProfilePicThumb = serializeProfilePicThumb;
  window.WAPI.serializeRawObj = serializeRawObj;
  window.WAPI.serializeMeObj = serializeMeObj;
}

```

`src/lib/wapi/business/get-business-profiles-products.js`:

```js
window.WAPI.getBusinessProfilesProducts = function (id, done) {
  return Store.Catalog.find(id)
    .then((resp) => {
      if (resp.msgProductCollection && resp.msgProductCollection._models.length)
        done();
      return resp.productCollection._models;
    })
    .catch((error) => {
      done();
      return error.model._products;
    });
};

```

`src/lib/wapi/business/send-message-with-buttons.js`:

```js
window.WAPI.sendButtons = async function (chatId) {
  var chat = Store.Chat.get(chatId);
  var tempMsg = Object.create(chat.msgs.filter((msg) => msg.__x_isSentByMe)[0]);
  // var tempMsg = Object.create(Store.Msg.models.filter(msg => msg.to._serialized===chatId&&msg.__x_isSentByMe&& msg.type=='chat' && !msg.quotedStanzaID)[0])
  var t2 = Object.create(
    Store.Msg.filter((x) => (x.type == 'template') & !x.id.fromMe)[0]
  );
  var newId = window.WAPI.getNewMessageId(chat.id._serialized);
  delete tempMsg.hasTemplateButtons;
  var extend = {
    ack: 0,
    id: newId,
    local: !0,
    self: 'out',
    t: parseInt(new Date().getTime() / 1000),
    to: chat.id,
    isNewMsg: false,
    // isNewMsg: !0,
    type: 'template',
    subtype: 'text',
    body: 'body text',
    isForwarded: false,
    broadcast: false,
    isQuotedMsgAvailable: false,
    shouldEnableHsm: true,
    __x_hasTemplateButtons: true,
    invis: true
  };

  Object.assign(tempMsg, extend);

  var btns = new Store.Builders.HydratedFourRowTemplate({
    hydratedButtons: [
      new Store.Builders.HydratedTemplateButton({
        quickReplyButton: new Store.Builders.HydratedQuickReplyButton({
          displayText: 'test',
          id: '{"eventName":"inform"}',
          quickReplyButton: true,
          subtype: 'quick_reply'
        }),
        index: 0
      }),
      new Store.Builders.HydratedTemplateButton({
        callButton: new Store.Builders.HydratedCallButton({
          displayText: 'test call',
          phoneNumber: '4477777777777'
        }),
        index: 1
      }),
      new Store.Builders.HydratedTemplateButton({
        urlButton: new Store.Builders.HydratedURLButton({
          displayText: 'test url',
          url: 'https://google.com'
        }),
        index: 2
      })
    ],
    hydratedContentText: 'hellllloooowww',
    hydratedFooterText: 'asdasd',
    hydratedTitleText: 'asdasd232'
  });

  Store.Parser.parseTemplateMessage(t2, btns);
  tempMsg.buttons = t2.buttons;
  console.log('t2', t2.body);
  tempMsg.mediaData = undefined;
  tempMsg.mediaObject = undefined;
  tempMsg._minEphemeralExpirationTimestamp();
  tempMsg.senderObj.isBusiness = true;
  tempMsg.senderObj.isEnterprise = true;
  tempMsg.senderObj = {
    ...tempMsg.senderObj,
    isBusiness: true,
    isEnterprise: true,
    notifyName: 'button test',
    mentionName: 'Button Test',
    displayName: 'Button Test',
    searchName: 'button test',
    header: 'b',
    formattedShortNameWithNonBreakingSpaces: 'Button test',
    formattedShortName: 'Button test',
    formattedName: 'Button test',
    formattedUser: 'Button test'
  };
  tempMsg.body = t2.body;
  tempMsg.to = tempMsg.from;
  tempMsg.caption = tempMsg.body;
  console.log('tempMsg', tempMsg);
  return chat.sendQueue
    .enqueue(
      chat.addQueue
        .enqueue(
          Store.MessageUtils.appendMessage(chat, tempMsg).then(() => {
            var e = Store.Msg.add(tempMsg)[0];
            console.log('e ', e);
            if (e) {
              return e.waitForPrep().then(() => {
                return e;
              });
            }
          })
        )
        .then((t) => chat.msgs.add(t))
        .catch((e) => console.log(e))
    )
    .then((t) => {
      var e = t[0];
      const s = Store.Base2;
      if (!s.BinaryProtocol)
        window.Store.Base2.BinaryProtocol = new window.Store.bp(11);
      var idUser = new Store.WidFactory.createWid(chatId);
      var k = Store.createMessageKey({
        ...e,
        to: idUser,
        id: e.__x_id
      });
      console.log('key', k);
      var wm = new Store.WebMessageInfo({
        message: new Store.Builders.Message({
          // conversation:'okhellowhi',
          templateMessage: new Store.Builders.TemplateMessage({
            hydratedFourRowTemplate: btns,
            hydratedTemplate: btns
          })
        }),
        key: k,
        messageTimestamp: e.t,
        multicast: undefined,
        url: undefined,
        urlNumber: undefined,
        clearMedia: undefined,
        ephemeralDuration: undefined
      });
      console.log('wm', wm);
      var action = s.actionNode('relay', [
        ['message', null, Store.WebMessageInfo.encode(wm).readBuffer()]
      ]);
      console.log('action', action);
      var a = e.id.id;
      return new Promise(function (resolve, reject) {
        console.log('yo');
        return s.binSend(
          'send',
          action,
          reject,
          {
            tag: a,
            onSend: s.wrap((_) => {
              console.log('onsend', _);
              resolve(_);
            }),
            onDrop: s.wrap((_) => {
              console.log('ondrop', _);
              reject(_);
            }),
            retryOn5xx: !0,
            resendGuard: function (_) {
              var t = Store.Msg.get(e.id);
              console.log('in resend', _);
              return 'protocol' === e.type || (t && t.id.equals(e.id));
            }
          },
          {
            debugString: ['action', 'message', e.type, e.subtype, a].join(),
            debugObj: {
              xml: action,
              pb: wm
            },
            metricName: 'MESSAGE',
            ackRequest: !1
          }
        );
      });
    });
};

window.WAPI.sendButtons2 = async function (chatId) {
  var chat = Store.Chat.get(chatId);
  var tempMsg = Object.create(
    Store.Msg.models.filter(
      (msg) =>
        msg.to._serialized === chatId &&
        msg.__x_isSentByMe &&
        msg.type == 'chat' &&
        !msg.quotedStanzaID
    )[0]
  );
  var t2 = Object.create(
    Store.Msg.models.filter(
      (msg) =>
        msg.to._serialized === chatId &&
        msg.__x_isSentByMe &&
        msg.type == 'chat' &&
        !msg.quotedStanzaID
    )[0]
  );
  var newId = window.WAPI.getNewMessageId(chatId);
  delete tempMsg.hasTemplateButtons;
  var extend = {
    ack: 0,
    id: newId,
    local: !0,
    self: 'out',
    t: parseInt(new Date().getTime() / 1000),
    to: Store.WidFactory.createWid(chatId),
    isNewMsg: !0,
    type: 'template',
    subtype: 'text',
    broadcast: false,
    isQuotedMsgAvailable: false,
    shouldEnableHsm: true,
    __x_hasTemplateButtons: true,
    invis: false
  };

  Object.assign(tempMsg, extend);

  var btns = new Store.Builders.HydratedFourRowTemplate({
    hydratedButtons: [
      new Store.Builders.HydratedTemplateButton({
        quickReplyButton: new Store.Builders.HydratedQuickReplyButton({
          displayText: 'test',
          id: '{"eventName":"inform"}',
          quickReplyButton: true
        }),
        index: 0
      }),
      new Store.Builders.HydratedTemplateButton({
        callButton: new Store.Builders.HydratedCallButton({
          displayText: 'test call',
          phoneNumber: '4477777777777'
        }),
        index: 1
      }),
      new Store.Builders.HydratedTemplateButton({
        callButton: new Store.Builders.HydratedCallButton({
          displayText: 'test call',
          phoneNumber: '4477777777777'
        }),
        index: 2
      }),
      new Store.Builders.HydratedTemplateButton({
        urlButton: new Store.Builders.HydratedURLButton({
          displayText: 'test url',
          url: 'https://google.com'
        }),
        index: 3
      })
    ],
    hydratedContentText: 'hellllloooowww',
    hydratedFooterText: 'asdasd',
    hydratedTitleText: 'asdasd232'
  });

  Store.Parser.parseTemplateMessage(t2, btns);
  tempMsg.buttons = t2.buttons;
  console.log('t2', t2.body);
  console.log('tempMsg', tempMsg);

  return chat.sendQueue
    .enqueue(
      chat.addQueue
        .enqueue(
          Store.MessageUtils.appendMessage(chat, tempMsg).then(() => {
            var e = Store.Msg.add(tempMsg)[0];
            console.log('e ', e);
            if (e) {
              return e.waitForPrep().then(() => {
                return e;
              });
            }
          })
        )
        .then((t) => chat.msgs.add(t))
        .catch((e) => console.log(e))
    )
    .then((t) => {
      var e = t[0];
      console.log('e', e);
      const s = Store.Base2;
      if (!s.BinaryProtocol)
        window.Store.Base2.BinaryProtocol = new window.Store.bp(11);
      var idUser = new Store.WidFactory.createWid(chatId);
      var k = Store.createMessageKey({
        ...e,
        to: idUser,
        id: e.__x_id
      });
      console.log('key', k);
      var wm = new Store.WebMessageInfo({
        message: new Store.Builders.Message({
          //if you uncomment the next line then the message gets sent properly as a text
          // conversation:'okhellowhi',
          templateMessage: new Store.Builders.TemplateMessage({
            hydratedFourRowTemplate: btns,
            hydratedTemplate: btns
          })
        }),
        key: k,
        messageTimestamp: e.t
      });
      console.log('wm', wm);
      var action = s.actionNode('relay', [
        ['message', null, Store.WebMessageInfo.encode(wm).readBuffer()]
      ]);
      console.log('action', action);
      var a = e.id.id;
      console.log('a', a);
      return new Promise(function (resolve, reject) {
        console.log('yo');
        return s.binSend(
          'send',
          action,
          reject,
          {
            tag: a,
            onSend: s.wrap(resolve),
            onDrop: s.wrap(reject),
            retryOn5xx: !0,
            resendGuard: function (_) {
              var t = Store.Msg.get(e.id);
              return 'protocol' === e.type || (t && t.id.equals(e.id));
            }
          },
          {
            debugString: ['action', 'message', 'chat', 'null', a].join(),
            debugObj: {
              xml: action,
              pb: wm
            },
            metricName: 'MESSAGE',
            ackRequest: !1
          }
        );
      });
    });
};

```

`src/lib/wapi/business/send-payment-request.js`:

```js
window.WAPI.sendPaymentRequest = async function (
  chatId,
  amount1000,
  currency,
  noteMessage
) {
  var chat = Store.Chat.get(chatId);
  var tempMsg = Object.create(chat.msgs.filter((msg) => msg.__x_isSentByMe)[0]);
  var newId = window.WAPI.getNewMessageId(chat.id._serialized);
  var extend = {
    ack: 0,
    id: newId,
    local: !0,
    self: 'out',
    t: parseInt(new Date().getTime() / 1000),
    to: chatId,
    isNewMsg: !0,
    type: 'payment',
    subtype: 'request',
    amount1000,
    requestFrom: chatId,
    currency,
    noteMessage,
    expiryTimestamp: parseInt(
      new Date(new Date().setDate(new Date().getDate() + 1)).getTime() / 1000
    )
  };
  Object.assign(tempMsg, extend);
  await Store.addAndSendMsgToChat(chat, tempMsg);
};

```

`src/lib/wapi/functions/add-chat-wapi.js`:

```js
import { injectConfig, filterModule, filterObjects } from '../helper';

export async function addChatWapi() {
  window[injectConfig.webpack].push([
    [injectConfig.parasite],
    {},
    async function (o) {
      let modules = [];
      for (let idx in o.m) {
        modules.push(o(idx));
      }

      const filterMod = await filterModule(filterObjects, modules);

      filterMod.forEach((needObj) => {
        if (needObj.yesModule) {
          if (!window.Store[needObj.type]) {
            window.Store[needObj.type] = needObj.yesModule;
          }
        }
      });

      if (Store && Store.BusinessProfile) {
        Store.Chat._findAndParse = Store.BusinessProfile._findAndParse;
        Store.Chat._find = Store.BusinessProfile._find;
      }
    }
  ]);
}

```

`src/lib/wapi/functions/add-participant.js`:

```js
export async function addParticipant(groupId, contactsId) {
  const chat = Store.Chat.get(groupId);

  if (!Array.isArray(contactsId)) {
    contactsId = [contactsId];
  }

  contactsId = await Promise.all(contactsId.map((c) => WAPI.sendExist(c)));
  if (!contactsId.length) {
    return false;
  }

  try {
    await Store.Participants.addParticipants(chat, contactsId);
    return true;
  } catch {
    return false;
  }
}

```

`src/lib/wapi/functions/archive-chat.js`:

```js
export async function archiveChat(idUser, type) {
  const chat = await WAPI.sendExist(idUser);
  if (typeof type !== 'boolean') {
    return WAPI.scope(
      undefined,
      true,
      null,
      'Use true to archive or false to unarchive'
    );
  }
  if (chat && chat.status != 404) {
    const archive = await window.chatOptions.archiveChat(chat, type);
    return WAPI.scope(undefined, false, archive, undefined);
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/are-all-messages-loaded.js`:

```js
export async function areAllMessagesLoaded(id, done) {
  const found = await WAPI.getChat(id);
  if (!found.msgs.msgLoadState.noEarlierMsgs) {
    if (done) done(false);
    return false;
  }
  if (done) done(true);
  return true;
}

```

`src/lib/wapi/functions/block-contact.js`:

```js
export async function blockContact(_id) {
  if (!_id) {
    return false;
  }
  const __contact = window.Store.Contact.get(_id);
  if (__contact !== undefined) {
    await Store.Block.blockContact(__contact);
    return true;
  } else {
    return false;
  }
}

```

`src/lib/wapi/functions/block-list.js`:

```js
export async function getBlockList() {
  let _l = await Store.Blocklist,
    __numbers = [];
  if (_l !== undefined && _l._index !== undefined) {
    for (let _n in _l._index) {
      __numbers.push(_n);
    }
    return __numbers;
  }
  return false;
}

```

`src/lib/wapi/functions/check-beta.js`:

```js
export async function isBeta() {
  if (
    !window.localStorage.getItem('WASecretBundle') &&
    !window.localStorage.getItem('WAToken1') &&
    !window.localStorage.getItem('WAToken2')
  ) {
    return true;
  }
  return false;
}

```

`src/lib/wapi/functions/check-chat.js`:

```js
export async function checkChat(id) {
  try {
    if (
      typeof id === 'string' &&
      (id.includes('@g.us') ||
        id.includes('@c.us') ||
        id.includes('@broadcast'))
    ) {
      const chat = await Store.Chat.get(id);
      if (!!chat && chat.t) {
        return WAPI.scope(
          undefined,
          false,
          200,
          null,
          WAPI._serializeChatObj(chat)
        );
      } else {
        throw 404;
      }
    } else {
      throw 400;
    }
  } catch (e) {
    return WAPI.scope(undefined, true, e, 'Was not found');
  }
}

```

`src/lib/wapi/functions/check-id-messagem.js`:

```js
export async function checkIdMessage(chatId, idMesagem) {
  if (typeof chatId != 'string') {
    return WAPI.scope(
      null,
      true,
      404,
      'enter the chatId variable as an string'
    );
  }
  const chat = await WAPI.sendExist(chatId);
  if (chat && chat.status != 404) {
    const getIdMessage = await window.Store.Msg.get(idMesagem);
    if (!getIdMessage) {
      return WAPI.scope(chat, true, 404, `The id ${idMesagem} does not exist!`);
    }
    const To = chat.id;
    const m = { type: 'checkIdMessage' };
    let obj = WAPI.scope(To, false, 'OK', '');
    Object.assign(obj, m);
    return obj;
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/check-number-status.js`:

```js
export async function checkNumberStatus(id, conn = false) {
  try {
    const err = { error: 404 };
    const connection =
      window.Store &&
      window.Store.State &&
      window.Store.State.Socket &&
      window.Store.State.Socket.state
        ? window.Store.State.Socket.state
        : '';
    const checkType = WAPI.sendCheckType(id);
    if (!!checkType && checkType.status === 404) {
      Object.assign(err, {
        text: checkType.text,
        numberExists: null
      });
      throw err;
    }

    if (conn === true) {
      if (connection !== 'CONNECTED') {
        Object.assign(err, {
          text: 'No connection with WhatsApp',
          connection: connection,
          numberExists: null
        });
        throw err;
      }
    }

    const lid = await WAPI.getChat(id);
    if (lid) {
      return await Store.checkNumber
        .queryWidExists(lid.id)
        .then((result) => {
          if (!!result && typeof result === 'object') {
            const data = {
              status: 200,
              numberExists: true,
              id: result.wid
            };
            return data;
          }
          throw Object.assign(err, {
            connection: connection,
            numberExists: false,
            text: `The number does not exist`
          });
        })
        .catch((err) => {
          if (err.text) {
            throw err;
          }
          throw Object.assign(err, {
            connection: connection,
            numberExists: false,
            text: err
          });
        });
    } else {
      throw Object.assign(err, {
        connection: connection,
        numberExists: false
      });
    }
  } catch (e) {
    return {
      status: e.error,
      text: e.text,
      numberExists: e.numberExists,
      connection: e.connection
    };
  }
}

```

`src/lib/wapi/functions/check-send-exist.js`:

```js
export async function scope(id, erro, status, text = null) {
  const me = await WAPI.getHost();
  let e = {
    me: me,
    to: id,
    erro: erro,
    text: text,
    status: status
  };
  return e;
}

export async function getchatId(chatId) {
  if (chatId) {
    let to = await WAPI.getChatById(chatId);
    if (to && typeof to === 'object') {
      let objTo = to.lastReceivedKey;
      if (objTo && typeof objTo === 'object') {
        let extend = {
          formattedName: to.contact.formattedName,
          isBusiness: to.contact.isBusiness,
          isMyContact: to.contact.isMyContact,
          verifiedName: to.contact.verifiedName,
          pushname: to.contact.pushname,
          isOnline: to.isOnline
        };
        Object.assign(objTo, extend);
        return objTo;
      }
    }
  }
  return undefined;
}

export function sendCheckType(chatId = undefined) {
  if (!chatId) {
    return WAPI.scope(chatId, true, 404, 'It is necessary to pass a number!');
  }
  if (typeof chatId === 'string') {
    const contact = '@c.us';
    const broadcast = '@broadcast';
    const grup = '@g.us';
    if (
      contact !== chatId.substr(-contact.length, contact.length) &&
      broadcast !== chatId.substr(-broadcast.length, broadcast.length) &&
      grup !== chatId.substr(-grup.length, grup.length)
    ) {
      return WAPI.scope(
        chatId,
        true,
        404,
        'The chat number must contain the parameters @c.us, @broadcast or @g.us. At the end of the number!'
      );
    }
    if (
      contact === chatId.substr(-contact.length, contact.length) &&
      ((chatId.match(/(@c.us)/g) && chatId.match(/(@c.us)/g).length > 1) ||
        !chatId.match(/^(\d+(\d)*@c.us)$/g))
    ) {
      return WAPI.scope(
        chatId,
        true,
        404,
        'incorrect parameters! Use as an example: 000000000000@c.us'
      );
    }

    if (
      broadcast === chatId.substr(-broadcast.length, broadcast.length) &&
      (chatId.match(/(@broadcast)/g).length > 1 ||
        (!chatId.match(/^(\d+(\d)*@broadcast)$/g) &&
          !chatId.match(/^(status@broadcast)$/g)))
    ) {
      return WAPI.scope(
        chatId,
        true,
        404,
        'incorrect parameters! Use as an example: 0000000000@broadcast'
      );
    }

    if (
      grup === chatId.substr(-grup.length, grup.length) &&
      ((chatId.match(/(@g.us)/g) && chatId.match(/(@g.us)/g).length > 1) ||
        !chatId.match(/^(\d+(-)+(\d)|\d+(\d))*@g.us$/g))
    ) {
      return WAPI.scope(
        chatId,
        true,
        404,
        'incorrect parameters! Use as an example: 00000000-000000@g.us or 00000000000000@g.us'
      );
    }
  }
}

export async function returnChat(chatId, returnChat = true, Send = true) {
  const checkType = WAPI.sendCheckType(chatId);
  if (!!checkType && checkType.status === 404) {
    return checkType;
  }

  let chat = await WAPI.getChat(chatId);
  if (!chat) {
    var idUser = new Store.UserConstructor(chatId, {
      intentionallyUsePrivateConstructor: true
    });
    const chatWid = new Store.WidFactory.createWid(chatId);
    await Store.Chat.add(
      {
        createdLocally: true,
        id: chatWid
      },
      {
        merge: true
      }
    );
    chat = await Store.Chat.find(idUser);
  }

  if (chat === undefined) {
    const chatWid = new Store.WidFactory.createWid(chatId);
    await Store.Chat.add(
      {
        createdLocally: true,
        id: chatWid
      },
      {
        merge: true
      }
    );
    const storeChat = await Store.Chat.find(chatId);
    if (storeChat) {
      chat =
        storeChat && storeChat.id && storeChat.id._serialized
          ? await WAPI.getChat(storeChat.id._serialized)
          : undefined;
    }
  }

  if (!chat) {
    return WAPI.scope(chatId, true, 404);
  }

  if (Send) {
    await window.Store.ReadSeen.sendSeen(chat, false);
  }

  if (returnChat) {
    return chat;
  }

  return WAPI.scope(chatId, false, 200);
}

export async function sendExist(chatId, returnChat = true, Send = true) {
  const checkType = await WAPI.sendCheckType(chatId);
  if (!!checkType && checkType.status === 404) {
    return checkType;
  }

  let ck = await window.WAPI.checkNumberStatus(chatId, false);

  if (
    (ck.status === 404 &&
      !chatId.includes('@g.us') &&
      !chatId.includes('@broadcast')) ||
    (ck &&
      ck.text &&
      typeof ck.text.includes === 'function' &&
      ck.text.includes('XmppParsingFailure'))
  ) {
    return WAPI.scope(chatId, true, ck.status, 'The number does not exist');
  }

  const chatWid = new Store.WidFactory.createWid(chatId);

  let chat =
    ck && ck.id && ck.id._serialized
      ? await WAPI.getChat(ck.id._serialized)
      : undefined;

  if (ck.numberExists && chat === undefined) {
    var idUser = new Store.UserConstructor(chatId, {
      intentionallyUsePrivateConstructor: true
    });
    const chatWid = new Store.WidFactory.createWid(chatId);
    await Store.Chat.add(
      {
        createdLocally: true,
        id: chatWid
      },
      {
        merge: true
      }
    );
    chat = await Store.Chat.find(idUser);
  }

  if (!chat) {
    const storeChat = await Store.Chat.find(chatWid);
    if (storeChat) {
      chat =
        storeChat && storeChat.id && storeChat.id._serialized
          ? await WAPI.getChat(storeChat.id._serialized)
          : undefined;
    }
  }

  if (!ck.numberExists && !chat.t && chat.isUser) {
    return WAPI.scope(chatId, true, ck.status, 'The number does not exist');
  }

  if (!ck.numberExists && !chat.t && chat.isGroup) {
    return WAPI.scope(
      chatId,
      true,
      ck.status,
      'The group number does not exist on your chat list, or it does not exist at all!'
    );
  }

  if (
    !ck.numberExists &&
    !chat.t &&
    chat.id &&
    chat.id.user != 'status' &&
    chat.isBroadcast
  ) {
    return WAPI.scope(
      chatId,
      true,
      ck.status,
      'The transmission list number does not exist on your chat list, or it does not exist at all!'
    );
  }

  if (!chat) {
    return WAPI.scope(chatId, true, 404);
  }

  if (Send) {
    await window.Store.ReadSeen.sendSeen(chat, false);
  }

  if (returnChat) {
    return chat;
  }

  return WAPI.scope(chatId, false, 200);
}

```

`src/lib/wapi/functions/clear-chat.js`:

```js
export async function clearChatMessages(chatId) {
  const chat = await Store.Chat.get(chatId);
  if (chat) {
    return await Store.ChatUtil.sendClear(chat, chat.lastReceivedKey, true);
  } else {
    return false;
  }
}

```

`src/lib/wapi/functions/create-community.js`:

```js
export async function createCommunity(name, desc) {
  try {
    const options = {
      name: name,
      desc: desc,
      closed: true
    };
    await window.Store.SendCommunity.sendCreateCommunity(options);
    return true;
  } catch {
    return false;
  }
}

```

`src/lib/wapi/functions/create-group.js`:

```js
export async function createGroup(name, contactsId) {
  if (!Array.isArray(contactsId)) {
    contactsId = [contactsId];
  }

  contactsId = await Promise.all(contactsId.map((c) => WAPI.sendExist(c)));
  contactsId = contactsId.filter((c) => !c.erro && c.isUser);

  if (!contactsId.length) {
    return false;
  }
  return await window.Store.createGroup(name, undefined, undefined, contactsId);
}

```

`src/lib/wapi/functions/delete-all-message.js`:

```js
export async function deleteMessages(chatId, messageArray) {
  if (typeof chatId != 'string') {
    return WAPI.scope(
      null,
      true,
      404,
      'enter the chatid variable as an string'
    );
  }
  const chat = await WAPI.sendExist(chatId);
  if (chat && chat.status != 404) {
    if (!Array.isArray(messageArray)) {
      return WAPI.scope(
        chat,
        true,
        404,
        'enter the message identification variable as an array'
      );
    }

    for (let i in messageArray) {
      if (typeof messageArray[i] === 'string') {
        let checkID = await WAPI.checkIdMessage(chatId, messageArray[i]);
        if (checkID.erro == true) {
          return checkID;
        }
      }
    }

    let messagesToDelete = (
      await Promise.all(
        messageArray.map(
          async (msgId) => await WAPI.getMessageById(msgId, null, false)
        )
      )
    ).filter((x) => x);

    const To = chat.id;
    const m = { type: 'deleteMessages' };

    let jobs = [
      chat.sendRevokeMsgs(messagesToDelete, chat),
      chat.sendDeleteMsgs(messagesToDelete, chat)
    ];

    const result = (await Promise.all(jobs))[1];

    if (result >= 0) {
      let obj = WAPI.scope(To, false, result, '');
      Object.assign(obj, m);
      return obj;
    } else {
      let obj = WAPI.scope(To, true, result, '');
      Object.assign(obj, m);
      return obj;
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/delete-conversation.js`:

```js
export async function deleteConversation(chatId, done) {
  let userId = new Store.UserConstructor(chatId, {
    intentionallyUsePrivateConstructor: true
  });
  let conversation = await WAPI.getChat(userId);

  if (!conversation) {
    if (done !== undefined) {
      done(false);
    }
    return false;
  }

  window.Store.sendDelete(conversation, false)
    .then(() => {
      if (done !== undefined) {
        done(true);
      }
    })
    .catch(() => {
      if (done !== undefined) {
        done(false);
      }
    });

  return true;
}

```

`src/lib/wapi/functions/delete-messages-all.js`:

```js
export async function deleteMessagesAll(chatId, messageArray, onlyLocal) {
  //return WAPI.chat.deleteMessage(chatId, messageArray, true, onlyLocal);
}

```

`src/lib/wapi/functions/delete-messages-me.js`:

```js
export async function deleteMessagesMe(chatId, messageArray, revoke) {
  //return WAPI.chat.deleteMessage(chatId, messageArray, true, revoke);
}

```

`src/lib/wapi/functions/delete-messages.js`:

```js
export async function deleteMessages(chatId, messageArray) {
  if (typeof chatId != 'string') {
    return WAPI.scope(
      null,
      true,
      404,
      'enter the chatid variable as an string'
    );
  }
  const chat = await WAPI.sendExist(chatId);
  if (chat && chat.status != 404) {
    if (!Array.isArray(messageArray)) {
      return WAPI.scope(
        chat,
        true,
        404,
        'enter the message identification variable as an array'
      );
    }

    for (let i in messageArray) {
      if (typeof messageArray[i] === 'string') {
        let checkID = await WAPI.checkIdMessage(chatId, messageArray[i]);
        if (checkID.erro == true) {
          return checkID;
        }
      }
    }

    let messagesToDelete = (
      await Promise.all(
        messageArray.map(
          async (msgId) => await WAPI.getMessageById(msgId, null, false)
        )
      )
    ).filter((x) => x);

    const To = chat.id;
    const m = { type: 'deleteMessages' };

    let jobs = [
      chat.sendRevokeMsgs(
        messagesToDelete.filter((msg) => !msg.isSentByMe),
        chat
      ),
      chat.sendDeleteMsgs(
        messagesToDelete.filter((msg) => msg.isSentByMe),
        chat
      )
    ];
    try {
      var result = (await Promise.all(jobs))[1];

      if (result >= 0) {
        let obj = WAPI.scope(To, false, result, '');
        Object.assign(obj, m);
        return obj;
      }
    } catch (e) {
      let obj = WAPI.scope(
        null,
        true,
        result,
        'The message has not been deleted'
      );
      Object.assign(obj, m);
      return obj;
    }
    let obj = WAPI.scope(To, true, result, '');
    Object.assign(obj, m);
    return obj;
  } else {
    if (!chat.erro) {
      chat.erro = true;
    }
    return chat;
  }
}

```

`src/lib/wapi/functions/demote-participant.js`:

```js
export async function demoteParticipant(groupId, contactsId, done) {
  const chat = Store.Chat.get(groupId);

  if (!Array.isArray(contactsId)) {
    contactsId = [contactsId];
  }

  contactsId = await Promise.all(contactsId.map((c) => WAPI.sendExist(c)));
  contactsId = contactsId
    .filter((c) => !c.erro && c.isUser)
    .map((c) => chat.groupMetadata.participants.get(c.id))
    .filter((c) => typeof c !== 'undefined')
    .map((c) => c.id);

  if (!contactsId.length) {
    typeof done === 'function' && done(false);
    return false;
  }

  await window.Store.WapQuery.demoteParticipants(chat.id, contactsId);

  const participants = contactsId.map((c) =>
    chat.groupMetadata.participants.get(c)
  );

  await window.Store.Participants.demoteParticipants(chat, participants);

  typeof done === 'function' && done(true);
  return true;
}

```

`src/lib/wapi/functions/download-file-with-credentials.js`:

```js
export async function downloadFile(url) {
  return await new Promise((resolve, reject) => {
    let xhr = new XMLHttpRequest();
    xhr.onload = function () {
      if (xhr.readyState == 4) {
        if (xhr.status == 200) {
          let reader = new FileReader();
          reader.readAsDataURL(xhr.response);
          reader.onload = function (e) {
            resolve(reader.result.substr(reader.result.indexOf(',') + 1));
          };
        } else {
          console.error(xhr.statusText);
        }
      } else {
        // console.log(err);
        resolve(false);
      }
    };
    xhr.open('GET', url, true);
    xhr.responseType = 'blob';
    xhr.send(null);
  });
}

```

`src/lib/wapi/functions/download-media.js`:

```js
export async function downloadMedia(messageId) {
  const msg = await WAPI.getMessageById(messageId, null, false);

  if (!msg) {
    throw {
      error: true,
      code: 'message_not_found',
      message: 'Message not found'
    };
  }
  if (!msg.mediaData) {
    throw {
      error: true,
      code: 'message_not_contains_media',
      message: 'Message not contains media'
    };
  }

  await msg.downloadMedia(true, 1);

  let blob = null;

  if (msg.mediaData.mediaBlob) {
    blob = msg.mediaData.mediaBlob.forceToBlob();
  } else if (msg.mediaData.filehash) {
    blob = Store.BlobCache.get(msg.mediaData.filehash);
  }

  // Transform a VIDEO message to a DOCUMENT message
  if (!blob && msg.mediaObject.type && msg.mediaObject.type === 'VIDEO') {
    delete msg.mediaObject.type;
    msg.type = 'document';
    return downloadMedia(messageId);
  }

  if (!blob) {
    throw {
      error: true,
      code: 'media_not_found',
      message: 'Media not found'
    };
  }

  return await new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onloadend = function (e) {
      resolve(reader.result);
    };
    reader.onabort = reject;
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

```

`src/lib/wapi/functions/encrypt-and-upload-file.js`:

```js
import { generateMediaKey, getFileHash } from '../helper';

export async function encryptAndUploadFile(type, blob) {
  try {
    const filehash = await getFileHash(blob);
    const mediaKey = generateMediaKey(32);
    const controller = new AbortController();
    const signal = controller.signal;
    const encrypted = await window.Store.UploadUtils.encryptAndUpload({
      blob,
      type,
      signal,
      mediaKey
    });
    return {
      ...encrypted,
      clientUrl: encrypted.url,
      filehash,
      id: filehash,
      uploadhash: encrypted.encFilehash,
      mediaBlob: blob
    };
  } catch {
    return false;
  }
}

```

`src/lib/wapi/functions/fix-chat.js`:

```js
export async function pinChat(chatId, type = true, notExist = false) {
  if (typeof type != 'boolean' || typeof notExist != 'boolean') {
    var text = 'incorrect parameter, insert a boolean true or false';
    return WAPI.scope(chatId, true, null, text);
  }
  let typeFix = type ? 'pin' : 'unpin',
    retult = void 0;
  var chat = await WAPI.sendExist(chatId, true, notExist);
  if (!chat.erro) {
    var m = {
        type: 'pinChat',
        typefix: typeFix
      },
      To = await WAPI.getchatId(chat.id);
    await Store.pinChat
      .setPin(chat, type)
      .then((_) => {
        var obj = WAPI.scope(To, false, 'OK', null);
        Object.assign(obj, m);
        retult = obj;
      })
      .catch((error) => {
        var obj = WAPI.scope(To, true, error, 'Pin Chat first');
        Object.assign(obj, m);
        retult = obj;
      });
    return retult;
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/forward-messages.js`:

```js
export async function forwardMessages(chatId, messages, skipMyMessages) {
  var chat = await WAPI.sendExist(chatId);

  if (!Array.isArray(messages)) {
    messages = [messages];
  }

  var toForward = (
    await Promise.all(
      messages.map(async (msg) => {
        return await WAPI.getMessageById(msg, null, false);
      })
    )
  ).filter((msg) => (skipMyMessages ? !msg.__x_isSentByMe : true));

  var m = { type: 'forwardMessages' };

  return new Promise(async (resolve, reject) => {
    let newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    let inChat = await WAPI.getchatId(chat.id).catch(() => {});
    if (inChat) {
      chat.lastReceivedKey._serialized = inChat._serialized;
      chat.lastReceivedKey.id = inChat.id;
    }
    if (chat.id) {
      await Promise.each(toForward, async (e) => {
        if (typeof e.erro !== 'undefined' && e.erro === true) {
          var obj = WAPI.scope(chatId, true, null, 'message not found');
          Object.assign(obj, m);
          reject(obj);
          return;
        }

        let tempMsg = await Object.create(
          chat.msgs.filter((msg) => msg.__x_isSentByMe)
        )[0];
        const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
        let toFor = await Object.assign(e);
        let extend = {
          id: newMsgId,
          ack: 0,
          from: fromwWid,
          to: chat.id,
          local: !0,
          self: 'out',
          t: parseInt(new Date().getTime() / 1000),
          isNewMsg: !0,
          isForwarded: true,
          forwardingScore: 1,
          multicast: true,
          __x_isSentByMe: true
        };

        Object.assign(tempMsg, toFor);
        Object.assign(tempMsg, extend);

        return await Store.addAndSendMsgToChat(chat, tempMsg);
      })
        .then(async () => {
          var obj = WAPI.scope(newMsgId, false, 200, null);
          Object.assign(obj, m);
          resolve(obj);
        })
        .catch(() => {
          var obj = WAPI.scope(newMsgId, true, 404, null);
          Object.assign(obj, m);
          reject(obj);
        });
    } else {
      reject(chat);
    }
  });
}

```

`src/lib/wapi/functions/get-all-chats-ids.js`:

```js
export const getAllChatIds = function (done) {
  const chatIds = window.Store.Chat.map(
    (chat) => chat.id._serialized || chat.id
  );

  if (done !== undefined) done(chatIds);
  return chatIds;
};

```

`src/lib/wapi/functions/get-all-chats-with-messages.js`:

```js
export async function getAllChatsWithMessages(newOnly) {
  const x = [];
  if (newOnly) {
    x.push(
      WAPI.getAllChatsWithNewMsg().map(
        async (c) => await WAPI.getChat(c.id._serialized)
      )
    );
  } else {
    x.push(WAPI.getAllChatIds().map(async (c) => await WAPI.getChat(c)));
  }
  const _result = (await Promise.all(x)).flatMap((x) => x);
  const result = JSON.stringify(_result);
  return JSON.parse(result);
}

```

`src/lib/wapi/functions/get-all-chats.js`:

```js
export const getAllChats = async function (done) {
  const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
  if (fromwWid) {
    const idUser = await WAPI.sendExist(fromwWid._serialized);
    if (idUser && idUser.status !== 404) {
      const chats = window.Store.Chat.map((chat) =>
        WAPI._serializeChatObj(chat)
      );

      if (done !== undefined) done(chats);
      return chats;
    }
  }
};

```

`src/lib/wapi/functions/get-all-contacts.js`:

```js
export const getAllContacts = function () {
  const allContacts = Store.Contact.map((contact) =>
    WAPI._serializeContactObj(contact)
  );

  return allContacts.filter((result) => {
    return result.isUser === true;
  });
};

```

`src/lib/wapi/functions/get-all-group-metadata.js`:

```js
export function getAllGroupMetadata(done) {
  const groupData = window.Store.GroupMetadata.map(
    (groupData) => groupData.attributes
  );

  if (done !== undefined) done(groupData);
  return groupData;
}

```

`src/lib/wapi/functions/get-all-groups.js`:

```js
export function getAllGroups(done) {
  const groups = window.Store.Chat.filter((chat) => chat.isGroup);

  if (done !== undefined) done(groups);
  return groups;
}

```

`src/lib/wapi/functions/get-all-messages-in-chat.js`:

```js
export async function getAllMessagesInChat(
  id,
  includeMe = true,
  includeNotifications = true,
  done
) {
  const chat = typeof id === 'string' ? await WAPI.getChat(id) : false;
  if (
    chat &&
    typeof includeMe === 'boolean' &&
    typeof includeNotifications === 'boolean'
  ) {
    let output = [];
    const messages = chat.msgs._models;

    for (const i in messages) {
      if (i === 'remove') {
        continue;
      }
      const messageObj = messages[i];

      let message = await WAPI.processMessageObj(
        messageObj,
        includeMe,
        includeNotifications
      );
      if (message) output.push(message);
    }
    if (done !== undefined) done(output);
    return output;
  } else {
    return await WAPI.sendExist(id);
  }
}

```

`src/lib/wapi/functions/get-all-new-messages.js`:

```js
import { getAllChatsWithNewMessages } from './get-chats-with-new-messages';

export const getAllNewMessages = async function () {
  const serializeMessageObj = await WAPI._serializeMessageObj;
  const _newMessages =
    getAllChatsWithNewMessages()
      .map(async (c) => await WAPI.getChat(c.id))
      .flatMap((c) => c.msgs._models.filter((x) => x.isNewMsg))
      .map(serializeMessageObj) || [];

  return _newMessages;
};

```

`src/lib/wapi/functions/get-battery-level.js`:

```js
export function getBatteryLevel() {
  return Store.Me && Store.Me.battery ? Store.Me.battery : undefined;
}

```

`src/lib/wapi/functions/get-chat-by-id.js`:

```js
export async function getChatById(id) {
  try {
    if (id) {
      let found = await WAPI.getChat(id);
      if (found) {
        return WAPI._serializeChatObj(found);
      }
    }
    throw false;
  } catch {
    return false;
  }
}

```

`src/lib/wapi/functions/get-chat-by-name.js`:

```js
export function getChatByName(name, done) {
  const found = Store.Chat.find((chat) => chat.name === name);
  if (done !== undefined) done(found);
  return found;
}

```

`src/lib/wapi/functions/get-chat.js`:

```js
export async function getChat(id) {
  if (!id) {
    return false;
  }
  id = typeof id == 'string' ? id : id._serialized;
  let found = Store.Chat.get(id);
  if (!found) {
    if (Store.CheckWid.validateWid(id)) {
      const ConstructChat = new window.Store.UserConstructor(id, {
        intentionallyUsePrivateConstructor: !0
      });
      const chatWid = new Store.WidFactory.createWid(id);
      await Store.Chat.add(
        {
          createdLocally: true,
          id: chatWid
        },
        {
          merge: true
        }
      );
      found = Store.Chat.find(ConstructChat) || false;
    }
  }
  if (found) {
    found.sendMessage = found.sendMessage
      ? found.sendMessage
      : function () {
          return window.Store.sendMessage.apply(this, arguments);
        };
  }
  return found;
}

```

`src/lib/wapi/functions/get-common-groups.js`:

```js
export async function getCommonGroups(participantId, done) {
  let output = [];
  let groups = window.WAPI.getAllGroups();
  for (let idx in groups) {
    try {
      let participants = await window.WAPI.getGroupParticipant(groups[idx].id);
      if (
        participants.filter((participant) => participant == participantId)
          .length
      ) {
        output.push(groups[idx]);
      }
    } catch (err) {
      console.log('Error in group:');
      console.log(groups[idx]);
      console.log(err);
    }
  }

  if (done !== undefined) {
    done(output);
  }
  return output;
}

```

`src/lib/wapi/functions/get-contact.js`:

```js
export const getContact = function (id, done) {
  const found = window.Store.Contact.get(id);

  if (done !== undefined) done(window.WAPI._serializeContactObj(found));
  return window.WAPI._serializeContactObj(found);
};

```

`src/lib/wapi/functions/get-data-messages.js`:

```js
/**
 * Return messages by dates!
 * @param {string} id contact number id
 * @param {string} type 
  types:
  lowerThan: Return all messages before the date informed; 
  higherThan: Return all messages after the date informed;
  equal: Return all messages from the informed date;
  full: Return all messages, with two new stringdate parameters, dateNumeric;
 * @param {string} dateStart Pass the example date 00/00/0000 or 00-00-0000
 * @param {string} time Pass the example time 00:00 24 hours
 */
export async function getAllMessagesDate(
  id,
  type = 'full',
  dateStart = undefined,
  time = undefined,
  limit = 10,
  output = [],
  idCheck = [],
  stop = true
) {
  const types = ['higherThan', 'equal', 'lowerThan', 'full'];
  if (!types.includes(type)) {
    return WAPI.scope(
      undefined,
      true,
      null,
      `wrong type! use the types: ${types.join()}`
    );
  }

  if (!!time && dateStart === undefined) {
    return WAPI.scope(
      undefined,
      true,
      null,
      `it is necessary to inform the date field`
    );
  }

  const chat = await WAPI.sendExist(id);
  if (chat && chat.status != 404) {
    const statusMsg = chat.msgs.msgLoadState.noEarlierMsgs;
    if (statusMsg === false) {
      await chat.onEmptyMRM();
    }

    let messages = chat.msgs._models;
    let dateStartTimeStamp, msg;

    if (time !== undefined && dateStart !== undefined) {
      const splitTimeStart =
        typeof time === 'string' ? time.split(/[:]/) : undefined;
      const splitDateStart =
        typeof dateStart === 'string' ? dateStart.split(/[-,/]/) : undefined;
      dateStartTimeStamp = timeStampConvert(splitDateStart, splitTimeStart)
        ? timeStampConvert(splitDateStart, splitTimeStart)
        : false;
      if (dateStartTimeStamp === false || isNaN(dateStartTimeStamp)) {
        const date = new Date();
        const year = date.toLocaleString('en-US', { year: 'numeric' });
        return WAPI.scope(
          undefined,
          true,
          null,
          `Date and time with invalid format! use as an example: data: 01/01/${year} or 01-01-${year} Tima 01:01`
        );
      }
    } else {
      if (dateStart !== undefined) {
        const splitDateStart =
          typeof dateStart === 'string' ? dateStart.split(/[-,/]/) : undefined;
        dateStartTimeStamp = timeStampConvert(splitDateStart)
          ? timeStampConvert(splitDateStart)
          : false;
        if (dateStartTimeStamp === false || isNaN(dateStartTimeStamp)) {
          const date = new Date();
          const year = date.toLocaleString('en-US', { year: 'numeric' });
          return WAPI.scope(
            undefined,
            true,
            null,
            `Date with invalid format! use as an example: 01/01/${year} or 01-01-${year}`
          );
        }
      }
    }
    messages = messages.reverse();
    for (const i in messages) {
      if (i === 'remove') {
        continue;
      }
      if (output.length < limit || limit === 0) {
        const messageObj = messages[i];
        const message = await WAPI._serializeMessageObj(messageObj);
        if (message.id && idCheck.includes(message.id) === true) {
          continue;
        }

        if (type === 'higherThan') {
          if (
            parseInt(dateStartTimeStamp.getTime() / 1000) <= message.timestamp
          ) {
            msg = getMenssage(message);
          }
        }

        if (type === 'equal') {
          if (
            parseInt(dateStartTimeStamp.getTime() / 1000) === message.timestamp
          ) {
            msg = getMenssage(message);
          }
        }

        if (type === 'lowerThan') {
          if (
            parseInt(dateStartTimeStamp.getTime() / 1000) >= message.timestamp
          ) {
            msg = getMenssage(message);
          }
        }

        if (type === 'full') {
          msg = getMenssage(message);
        }

        if (msg && idCheck.includes(msg.id) === false) {
          stop = false;
          idCheck.push(msg.id);
          output.push(msg);
        }
      }
    }

    if (statusMsg === false && stop === false && output.length < limit) {
      return await getAllMessagesDate(
        id,
        type,
        dateStart,
        time,
        limit,
        output,
        idCheck,
        true
      );
    } else {
      return output;
    }
  } else {
    return chat;
  }
}

function timeStampConvert(date, time) {
  var newdate = undefined;
  if (date !== undefined) {
    if (time !== undefined) {
      newdate = new Date(date[2], date[1] - 1, date[0], time[0], time[1]);
    } else {
      newdate = new Date(date[2], date[1] - 1, date[0]);
    }
    return newdate;
  } else {
    return false;
  }
}

function getMenssage(message) {
  const date = new Date(message.timestamp * 1000);
  const stringdate = date.toLocaleString();

  const day = '0' + date.toLocaleString('en-US', { day: 'numeric' });
  const month = '0' + date.toLocaleString('en-US', { month: 'numeric' });
  const minutes = '0' + date.getUTCMinutes();
  const seconds = '0' + date.getSeconds();
  const hours = '0' + date.getHours();

  const _d = {
    id: message.id,
    timestamp: date.getTime(),
    stringdate,
    dateNumeric: {
      day: day.substr(-2),
      month: month.substr(-2),
      year: date.toLocaleString('en-US', { year: 'numeric' }),
      hours: hours.substr(-2),
      minutes: minutes.substr(-2),
      seconds: seconds.substr(-2)
    },
    type: message.type,
    fromMe: message.fromMe
  };
  return Object.assign(message, _d);
}

```

`src/lib/wapi/functions/get-group-admins.js`:

```js
export async function getGroupAdmins(groupId) {
  if (typeof groupId !== 'string') {
    return WAPI.scope(undefined, true, null, 'Use to groupId string');
  }
  const chat = await WAPI.sendExist(groupId);

  if (chat && chat.status != 404 && chat.id) {
    const moduleGroup = await window.Store.GroupMetadata.default.models.filter(
      (e) => e.id._serialized === groupId
    );

    const participants =
      moduleGroup.length && moduleGroup[0].participants
        ? moduleGroup[0].participants
        : undefined;

    if (participants) {
      const output = participants
        .filter((participant) => participant.isAdmin)
        .map((participant) => {
          return {
            id: participant.id ? participant.id : null,
            displayName:
              participant.contact && participant.contact.displayName
                ? participant.contact.displayName
                : null,
            mentionName:
              participant.contact && participant.contact.mentionName
                ? participant.contact.mentionName
                : null,
            notifyName:
              participant.contact && participant.contact.notifyName
                ? participant.contact.notifyName
                : null,
            isBusiness:
              participant.contact && participant.contact.isBusiness
                ? participant.contact.isBusiness
                : null,
            pushname:
              participant.contact && participant.contact.pushname
                ? participant.contact.pushname
                : null,
            isUser:
              participant.contact && participant.contact.isUser
                ? participant.contact.isUser
                : null,
            isMyContact:
              participant.contact && participant.contact.isMyContact
                ? participant.contact.isMyContact
                : null,
            isMe:
              participant.contact && participant.contact.isMe
                ? participant.contact.isMe
                : null
          };
        });
      return output;
    }
    return WAPI.scope(undefined, true, null, 'Error find Group');
  }
  return WAPI.scope(undefined, true, null, 'Group not found');
}

```

`src/lib/wapi/functions/get-group-info-from-invite-link.js`:

```js
export async function getGroupInfoFromInviteLink(link) {
  if (typeof link === 'string' && !link) {
    return null;
  }
  const regex = /https:\/\/chat\.whatsapp\.com\/([A-Za-z0-9]+)/;
  const match = link.match(regex);
  const input = match ? match[1] : link;
  const data = await Store.infoGroup.queryGroupInviteInfo(input);
  return {
    inGroup: data?.inGroup,
    membershipApprovalRequest: data?.membershipApprovalRequest,
    parentGroupSubject: data?.parentGroupSubject,
    status: data?.status,
    subject: data?.subject,
    id: data?.groupMetadata?.id
  };
}

```

`src/lib/wapi/functions/get-group-invite-link.js`:

```js
export async function getGroupInviteLink(chatId) {
  var chat = Store.Chat.get(chatId);
  if (!chat.isGroup) return '';
  await Store.GroupInvite.queryGroupInviteCode(chat.groupMetadata);
  return {
    groupInviteLink: chat?.groupMetadata?.groupInviteLink,
    inviteCode: chat?.groupMetadata?.inviteCode,
    incognito: chat?.groupMetadata?.incognito,
    id: chat?.groupMetadata?.id
  };
}

```

`src/lib/wapi/functions/get-group-metadata.js`:

```js
export async function getGroupMetadata(id, done) {
  let groupWid = await window.Store.WidFactory.createWid(id);
  let output = await window.Store.GroupMetadata.default.find(groupWid);
  if (done !== undefined) done(output);
  return output;
}

```

`src/lib/wapi/functions/get-group-participant-ids.js`:

```js
export async function getGroupParticipantIDs(groupId, done) {
  // const output = Promise.resolve(WAPI.group.getParticipants(groupId)).then(
  //   (participants) => participants.map((p) => p.toJSON())
  // );
  // if (done !== undefined) done(output);
  // return output;
}

```

`src/lib/wapi/functions/get-group-participant.js`:

```js
import { sleep } from '../helper';

export async function getGroupParticipant(groupId, time = 1000) {
  if (typeof groupId !== 'string') {
    return WAPI.scope(undefined, true, null, 'Use to groupId string');
  }

  const chat = await WAPI.sendExist(groupId);

  if (chat && chat.status != 404 && chat.id) {
    await window.Store.Cmd.openChatBottom(chat);
    await sleep(time);
    const moduleGroup = await window.Store.GroupMetadata._models.filter(
      (e) => e.id._serialized === groupId
    );

    const participants =
      moduleGroup.length && moduleGroup[0].participants
        ? moduleGroup[0].participants
        : undefined;

    if (participants) {
      const output = participants.map((participant) => {
        return {
          id: participant.id,
          displayName:
            participant.contact && participant.contact.displayName
              ? participant.contact.displayName
              : null,
          mentionName:
            participant.contact && participant.contact.mentionName
              ? participant.contact.mentionName
              : null,
          notifyName:
            participant.contact && participant.contact.notifyName
              ? participant.contact.notifyName
              : null,
          isBusiness:
            participant.contact && participant.contact.isBusiness
              ? participant.contact.isBusiness
              : null,
          pushname:
            participant.contact && participant.contact.pushname
              ? participant.contact.pushname
              : null,
          isUser:
            participant.contact && participant.contact.isUser
              ? participant.contact.isUser
              : null,
          isMyContact:
            participant.contact && participant.contact.isMyContact
              ? participant.contact.isMyContact
              : null,
          isMe:
            participant.contact && participant.contact.isMe
              ? participant.contact.isMe
              : null
        };
      });

      return output;
    }
    return WAPI.scope(undefined, true, null, 'Error find Group');
  }
  return WAPI.scope(undefined, true, null, 'Group not found');
}

```

`src/lib/wapi/functions/get-group-participants.js`:

```js
export async function _getGroupParticipants(id, done) {
  // const output = Promise.resolve(WAPI.group.getParticipants(id)).then(
  //   (participants) => participants.map((p) => p.toJSON())
  // );
  // if (done !== undefined) done(output);
  // return output;
}

```

`src/lib/wapi/functions/get-host.js`:

```js
export async function getHost() {
  const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
  if (fromwWid) {
    const idUser = await WAPI.sendExist(fromwWid._serialized);
    if (idUser && idUser.status !== 404) {
      //const infoUser = new Store.ProfileBusiness.BusinessProfile(idUser);
      const infoUser = await Store.Contacts.ContactCollection.get(
        fromwWid._serialized
      );
      //  const infoUser = await Store.MyStatus.getStatus(idUser.id);
      if (infoUser) {
        return await WAPI._serializeMeObj(infoUser);
      }
    }
  }
}

```

`src/lib/wapi/functions/get-list-mute.js`:

```js
export async function getListMute(type = 'all') {
  var muteList = (await window.Store.Mute)._models,
    noMute = new Array(),
    toMute = new Array();
  for (var i in muteList)
    muteList[i].__x_isMuted
      ? toMute.push(WAPI.interfaceMute(muteList[i]))
      : noMute.push(WAPI.interfaceMute(muteList[i]));
  var r = null;
  console.log(0, type);
  switch (type) {
    case 'all':
      r = [
        {
          total: toMute.length + noMute.length,
          amountToMute: toMute.length,
          amountnoMute: noMute.length
        },
        toMute,
        noMute
      ];
      break;
    case 'toMute':
      r = [{ total: toMute.length }, toMute];
      break;
    case 'noMute':
      r = [{ total: noMute.length }, noMute];
      break;
  }
  return r;
}
export function interfaceMute(arr) {
  let { attributes, expiration, id, isMuted, isState, promises, stale } = arr;
  return { attributes, expiration, id, isMuted, isState, promises, stale };
}

```

`src/lib/wapi/functions/get-me.js`:

```js
export function getMe(done) {
  const rawMe = window.Store.Contact.get(window.Store.Conn.me);

  if (done !== undefined) done(rawMe.all);
  return rawMe.all;
}

```

`src/lib/wapi/functions/get-message-by-id.js`:

```js
export async function getMessageById(key, done, serialize = true) {
  // Check message is loaded in store
  let msg = window.Store.Msg.get(key);
  let erro = { erro: true };

  if (!msg) {
    // Get chat of message
    const chat = window.Store.Chat.get(key.remote);
    if (!chat) {
      return erro;
    }

    //If not message not found, load latest messages of chat
    await chat.onEmptyMRM();
    await WAPI.sleep(100);
    msg = window.Store.Msg.get(key);

    if (!msg) {
      // If not found, load messages around the message ID
      const context = chat.getSearchContext(key);
      if (
        context &&
        context.collection &&
        context.collection.loadAroundPromise
      ) {
        await context.collection.loadAroundPromise;
      }
      msg = window.Store.Msg.get(key);
    }
  }

  if (!msg) {
    return erro;
  }

  let result = erro;

  if (serialize) {
    try {
      result = await WAPI.processMessageObj(msg, true, true);
    } catch (err) {}
  } else {
    result = msg;
  }

  if (typeof done === 'function') {
    done(result);
  } else {
    return result;
  }
}

```

`src/lib/wapi/functions/get-my-contacts.js`:

```js
export const getMyContacts = function (done) {
  const contacts = window.Store.Contact.filter(
    (contact) => contact.isMyContact === true
  ).map((contact) => WAPI._serializeContactObj(contact));
  if (done !== undefined) done(contacts);
  return contacts;
};

```

`src/lib/wapi/functions/get-new-id.js`:

```js
export function getNewId() {
  var text = '';
  var possible =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (var i = 0; i < 16; i++)
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  return text;
}

```

`src/lib/wapi/functions/get-new-message-id.js`:

```js
export async function getNewMessageId(chatId, checkNumber = true) {
  const chat = checkNumber
    ? await WAPI.sendExist(chatId)
    : await WAPI.returnChat(chatId);
  if (chat.id) {
    const newMsgId = new Object();
    newMsgId.fromMe = true;
    newMsgId.id = await WAPI.getNewId().toUpperCase();
    newMsgId.remote = new Store.WidFactory.createWid(chat.id._serialized);
    newMsgId._serialized = `${newMsgId.fromMe}_${newMsgId.remote}_${newMsgId.id}`;
    const Msgkey = new Store.MsgKey(newMsgId);
    return Msgkey;
  } else {
    return false;
  }
}

```

`src/lib/wapi/functions/get-number-profile.js`:

```js
export async function getNumberProfile(id) {
  if (typeof id != 'string' || id.length === 0) {
    return WAPI.scope(id, true, 404, 'It is necessary to number');
  }
  const chat = await WAPI.sendExist(id);
  if (chat && chat.status != 404 && chat.id) {
    const infoUser = await Store.MyStatus.getStatus(chat);
    return await WAPI._serializeMeObj(infoUser);
  }
  if (!chat.erro) {
    chat.erro = true;
  }
  return chat;
}

```

`src/lib/wapi/functions/get-profile-pic-from-server.js`:

```js
export async function getProfilePicFromServer(id) {
  const pinc = await Store.WapQuery.profilePicFind(id).then((x) => x.eurl);
  return pinc;
}

```

`src/lib/wapi/functions/get-session-token.js`:

```js
export async function getSessionTokenBrowser() {
  if (window.localStorage) {
    var localStorages = await JSON.parse(JSON.stringify(window.localStorage));
    let { WABrowserId, WASecretBundle, WAToken1, WAToken2 } = localStorages;
    return {
      WABrowserId,
      WASecretBundle,
      WAToken1,
      WAToken2
    };
  }
}

```

`src/lib/wapi/functions/get-state-connection.js`:

```js
/**
 * Returns state connection
 * @returns obj
 */
export function getStateConnection() {
  return window.Store.State.Socket.state;
}

```

`src/lib/wapi/functions/get-status.js`:

```js
export async function getStatus(id) {
  return await Store.MyStatus.getStatus(id);
}

```

`src/lib/wapi/functions/get-unread-messages-in-chat.js`:

```js
export async function getUnreadMessagesInChat(
  id,
  includeMe,
  includeNotifications,
  done
) {
  // get chat and its messages
  let chat = await WAPI.getChat(id);
  let messages = chat.msgs._models;

  // initialize result list
  let output = [];

  // look for unread messages, newest is at the end of array
  for (let i = messages.length - 1; i >= 0; i--) {
    // system message: skip it
    if (i === 'remove') {
      continue;
    }

    // get message
    let messageObj = messages[i];

    // found a read message: stop looking for others
    if (
      typeof messageObj.isNewMsg !== 'boolean' ||
      messageObj.isNewMsg === false
    ) {
      continue;
    } else {
      messageObj.isNewMsg = false;
      // process it
      let message = await WAPI.processMessageObj(
        messageObj,
        includeMe,
        includeNotifications
      );

      // save processed message on result list
      if (message) output.push(message);
    }
  }
  // callback was passed: run it
  if (done !== undefined) done(output);
  // return result list
  return output;
}

```

`src/lib/wapi/functions/get-unread-messages.js`:

```js
export async function getUnreadMessages(undread = true) {
  const arr = [];
  let chats;

  if (undread) {
    chats = await Store.Chat.filter((e) => e.unreadCount > 0);
  } else {
    chats = await Store.Chat.filter((e) => e.unreadCount <= 0);
  }

  for (const chat of chats) {
    const t = chat.msgs._models.slice(-chat.unreadCount);
    for (const messageObj of t) {
      const message = await WAPI.processMessageObj(messageObj, true, true);
      if (message) {
        arr.push(message);
      }
    }
  }

  return arr;
}

```

`src/lib/wapi/functions/help/add-chat-wapi.js`:

```js
import { filterObjects } from './filter-object';
import { injectConfig, filterModule } from '../../help';

export async function addChatWapi() {
  window[injectConfig.webpack].push([
    [injectConfig.parasite],
    {},
    async function (o) {
      let modules = [];
      for (let idx in o.m) {
        modules.push(o(idx));
      }

      const filterMod = await filterModule(filterObjects, modules);

      filterMod.forEach((needObj) => {
        if (needObj.yesModule) {
          if (!Store[needObj.type]) {
            Store[needObj.type] = needObj.yesModule;
          }
        }
      });

      if (Store && Store.BusinessProfile) {
        Store.Chat._findAndParse = Store.BusinessProfile._findAndParse;
        Store.Chat._find = Store.BusinessProfile._find;
      }
    }
  ]);
}

```

`src/lib/wapi/functions/help/check-number-status.js`:

```js
export async function checkNumberStatus(id, conn = false) {
  try {
    const err = {
      error: 404
    };

    const connection =
      Store && Store.State && Store.State.Socket && Store.State.Socket.state
        ? Store.State.Socket.state
        : '';

    if (conn === true) {
      if (connection !== 'CONNECTED') {
        Object.assign(err, {
          text: 'No connection with WhatsApp',
          connection: connection,
          numberExists: null
        });
        throw err;
      }
    }

    const lid = await WAPI.getChat(id);
    if (lid) {
      return await Store.checkNumberMD
        .queryExists(lid.id)
        .then((result) => {
          if (!!result && typeof result === 'object') {
            const data = {
              status: 200,
              numberExists: true,
              id: result.wid
            };
            return data;
          }
          throw Object.assign(err, {
            connection: connection,
            numberExists: false,
            text: `The number does not exist`
          });
        })
        .catch((err) => {
          if (err.text) {
            throw err;
          }
          throw Object.assign(err, {
            connection: connection,
            numberExists: false,
            text: err
          });
        });
    } else {
      throw Object.assign(err, {
        connection: connection,
        numberExists: false
      });
    }
  } catch (e) {
    return {
      status: e.error,
      text: e.text,
      numberExists: e.numberExists,
      connection: e.connection
    };
  }
}

```

`src/lib/wapi/functions/help/filter-object.js`:

```js
export const filterObjects = [
  {
    type: 'Chat',
    when: (module) =>
      module.default && module.default.Chat && module.default.Msg
        ? module.default.Chat
        : null
  },
  {
    type: 'MaybeMeUser',
    when: (module) => (module.getMaybeMeUser ? module : null)
  }
];

```

`src/lib/wapi/functions/help/get-chat.js`:

```js
/**
 * building a chat number
 * @param {string} chatId Contact number
 * @returns {(Object|undefined)}
 */
export async function getChat(chatId) {
  if (!chatId) return false;

  chatId = typeof chatId == 'string' ? chatId : chatId._serialized;
  let found = Store.Chat.get(chatId);

  if (!found) {
    if (Store.CheckWid.validateWid(chatId)) {
      const ConstructChat = new Store.UserConstructor(chatId, {
        intentionallyUsePrivateConstructor: !0
      });
      const chatWid = new Store.WidFactory.createWid(chatId);
      await Store.Chat.add(
        {
          createdLocally: true,
          id: chatWid
        },
        {
          merge: true
        }
      );

      found = Store.Chat.find(ConstructChat) || false;
    }
  }

  return found;
}

```

`src/lib/wapi/functions/help/get-mew-id.js`:

```js
/**
 * create a random id with 16 characters
 * @returns {string} returns a new id of a new message
 */
export function getNewId() {
  let text = '';
  const possible =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (var i = 0; i < 16; i++)
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  return text;
}

```

`src/lib/wapi/functions/help/get-new-message.js`:

```js
export async function getNewMessageId(chatId) {
  const chat = await WAPI.sendExist(chatId);
  if (chat.id) {
    const newMsgId = new Object();
    newMsgId.fromMe = true;
    newMsgId.id = await WAPI.getNewId().toUpperCase();
    newMsgId.remote = new Store.WidFactory.createWid(chat.id._serialized);
    newMsgId._serialized = `${newMsgId.fromMe}_${newMsgId.remote}_${newMsgId.id}`;
    const Msgkey = new Store.MsgKey(newMsgId);
    return Msgkey;
  } else {
    return false;
  }
}

```

`src/lib/wapi/functions/help/index.js`:

```js
export { getChat } from './get-chat';
export { scope } from './scope';
export { getNewId } from './get-mew-id';
export { getNewMessageId } from './get-new-message';
export { sendExist } from './send-exist';
export { checkNumberStatus } from './check-number-status';
export { sendCheckType } from './send-check-type';
export { isMD } from './is-md';
export { addChatWapi } from './add-chat-wapi';

```

`src/lib/wapi/functions/help/is-md.js`:

```js
export async function isMD() {
  if (
    !window.localStorage.getItem('WASecretBundle') &&
    !window.localStorage.getItem('WAToken1') &&
    !window.localStorage.getItem('WAToken2')
  ) {
    return true;
  }
  return false;
}

```

`src/lib/wapi/functions/help/scope.js`:

```js
export async function scope(
  id,
  erro,
  status,
  text = null,
  type = null,
  body = null
) {
  let e = {
    to: id,
    erro: erro,
    text: text,
    status: status,
    type: type,
    body: body
  };
  return e;
}

```

`src/lib/wapi/functions/help/send-check-type.js`:

```js
export function sendCheckType(chatId = undefined) {
  if (!chatId) {
    return WAPI.scope(chatId, true, 404, 'It is necessary to pass a number!');
  }
  if (typeof chatId === 'string') {
    const contact = '@c.us';
    const broadcast = '@broadcast';
    const grup = '@g.us';
    if (
      contact !== chatId.substr(-contact.length, contact.length) &&
      broadcast !== chatId.substr(-broadcast.length, broadcast.length) &&
      grup !== chatId.substr(-grup.length, grup.length)
    ) {
      return WAPI.scope(
        chatId,
        true,
        404,
        'The chat number must contain the parameters @c.us, @broadcast or @g.us. At the end of the number!'
      );
    }
    if (
      contact === chatId.substr(-contact.length, contact.length) &&
      ((chatId.match(/(@c.us)/g) && chatId.match(/(@c.us)/g).length > 1) ||
        !chatId.match(/^(\d+(\d)*@c.us)$/g))
    ) {
      return WAPI.scope(
        chatId,
        true,
        404,
        'incorrect parameters! Use as an example: 000000000000@c.us'
      );
    }

    if (
      broadcast === chatId.substr(-broadcast.length, broadcast.length) &&
      (chatId.match(/(@broadcast)/g).length > 1 ||
        (!chatId.match(/^(\d+(\d)*@broadcast)$/g) &&
          !chatId.match(/^(status@broadcast)$/g)))
    ) {
      return WAPI.scope(
        chatId,
        true,
        404,
        'incorrect parameters! Use as an example: 0000000000@broadcast'
      );
    }

    if (
      grup === chatId.substr(-grup.length, grup.length) &&
      ((chatId.match(/(@g.us)/g) && chatId.match(/(@g.us)/g).length > 1) ||
        !chatId.match(/^(\d+(-)+(\d)|\d+(\d))*@g.us$/g))
    ) {
      return WAPI.scope(
        chatId,
        true,
        404,
        'incorrect parameters! Use as an example: 00000000-000000@g.us or 00000000000000@g.us'
      );
    }
  }
}

```

`src/lib/wapi/functions/help/send-exist.js`:

```js
/**
 * Sends an existence check for a given chat ID and returns the result.
 * @param chatId The ID of the chat to check.
 * @param returnChat Whether to return the chat object if it exists.
 * @param Send Whether to send a "seen" confirmation to the chat.
 * @returns The result of the existence check or the chat object if returnChat is true.
 */
export async function sendExist(chatId, returnChat = true, Send = true) {
  const checkType = await WAPI.sendCheckType(chatId);

  // Check if chatId does not exist
  if (!!checkType && checkType.status === 404) {
    return checkType;
  }

  let ck = await WAPI.checkNumberStatus(chatId, false);

  // Check if chatId does not exist and it's not a group or broadcast
  if (
    (ck.status === 404 &&
      !chatId.includes('@g.us') &&
      !chatId.includes('@broadcast')) ||
    (ck &&
      ck.text &&
      typeof ck.text.includes === 'function' &&
      ck.text.includes('XmppParsingFailure'))
  ) {
    return WAPI.scope(chatId, true, ck.status, 'The number does not exist');
  }

  const chatWid = new Store.WidFactory.createWid(chatId);

  let chat =
    ck && ck.id && ck.id._serialized
      ? await WAPI.getChat(ck.id._serialized)
      : undefined;

  // Check if chat exists using the serialized ID
  if (ck.numberExists && chat === undefined) {
    var idUser = new Store.UserConstructor(chatId, {
      intentionallyUsePrivateConstructor: true
    });
    await Store.Chat.add(
      {
        createdLocally: true,
        id: chatWid
      },
      {
        merge: true
      }
    );
    chat = await Store.Chat.find(idUser);
  }

  if (!chat) {
    await Store.Chat.add(
      {
        createdLocally: true,
        id: chatWid
      },
      {
        merge: true
      }
    );
    const storeChat = await Store.Chat.find(chatWid);

    // Retrieve chat using the storeChat object
    if (storeChat) {
      chat =
        storeChat && storeChat.id && storeChat.id._serialized
          ? await WAPI.getChat(storeChat.id._serialized)
          : undefined;
    }
  }

  // Check if the number does not exist and it's a user chat
  if (!ck.numberExists && !chat.t && chat.isUser) {
    return WAPI.scope(chatId, true, ck.status, 'The number does not exist');
  }

  // Check if the number does not exist and it's a group chat
  if (!ck.numberExists && !chat.t && chat.isGroup) {
    return WAPI.scope(
      chatId,
      true,
      ck.status,
      'The group number does not exist on your chat list, or it does not exist at all!'
    );
  }

  if (!chat) {
    return WAPI.scope(chatId, true, 404);
  }

  // Send a "seen" confirmation to the chat if Send is true
  if (Send) {
    await Store.ReadSeen.sendSeen(chat, false);
  }

  // Return the chat object if returnChat is true
  if (returnChat) {
    return chat;
  }

  return WAPI.scope(chatId, false, 200);
}

```

`src/lib/wapi/functions/index.js`:

```js
export { areAllMessagesLoaded } from './are-all-messages-loaded';
export { clearChatMessages } from './clear-chat';
export { createGroup } from './create-group';
export { deleteConversation } from './delete-conversation';
export { deleteMessages } from './delete-messages';
export { downloadFile } from './download-file-with-credentials';
export { encryptAndUploadFile } from './encrypt-and-upload-file';
export { getAllChats } from './get-all-chats';
export { getAllChatIds } from './get-all-chats-ids';
export { getAllChatsWithMessages } from './get-all-chats-with-messages';
export { getAllContacts } from './get-all-contacts';
export { getAllGroupMetadata } from './get-all-group-metadata';
export { getAllGroups } from './get-all-groups';
export { getAllMessagesInChat } from './get-all-messages-in-chat';
export { getBatteryLevel } from './get-battery-level';
export { getChat } from './get-chat';
export { getChatById } from './get-chat-by-id';
export { getChatByName } from './get-chat-by-name';
export { getCommonGroups } from './get-common-groups';
export { getContact } from './get-contact';
export { getGroupAdmins } from './get-group-admins';
export { getGroupInviteLink } from './get-group-invite-link';
export { getGroupInfoFromInviteLink } from './get-group-info-from-invite-link';
export { getGroupParticipant } from './get-group-participant';
export { getHost } from './get-host';
export { getMe } from './get-me';
export { getMyContacts } from './get-my-contacts';
export { getNewId } from './get-new-id';
export { getNumberProfile } from './get-number-profile';
export { getProfilePicFromServer } from './get-profile-pic-from-server';
export { getStatus } from './get-status';
export { getUnreadMessages } from './get-unread-messages';
export { isConnected } from './is-connected';
export { isLoggedIn } from './is-logged-in';
export { leaveGroup } from './leave-group';
export {
  asyncLoadAllEarlierMessages,
  loadAllEarlierMessages
} from './load-all-earlier-chat-messages';
export { loadAndGetAllMessagesInChat } from './load-and-get-all-messages-in-chat';
export { loadChatEarlierMessages } from './load-earlier-chat-messages';
export { loadEarlierMessagesTillDate } from './load-earlier-messages-til-date';
export { processFiles } from './process-files';
export { processMessageObj } from './process-message-object';
export { revokeGroupInviteLink } from './revoke-invite-link';
export { sendChatstate } from './send-chat-state';
export { sendFile } from './send-file';
export { sendImage } from './send-image';
export { sendPtt } from './send-ptt';
export { sendImageAsSticker } from './send-image-as-stricker';
export { sendImageWithProduct } from './send-image-with-product';
export { sendLocation } from './send-location';
export { sendMessage } from './send-message';
export { sendMessageOptions } from './sendMessageOptions';
export { sendMessageWithTags } from './send-message-with-tags';
export { sendMessageWithThumb } from './send-message-with-thumb';
export { sendMessage2 } from './send-message2';
export { sendSticker } from './send-sticker';
export { sendVideoAsGif } from './send-video-as-gif';
export { setMyName } from './set-my-name';
export { setMyStatus } from './set-my-status';
export { forwardMessages } from './forward-messages';
export { sendContactVcard } from './send-contact-vcard';
export { getNewMessageId } from './get-new-message-id';
export { reply } from './reply';
export {
  startTyping,
  startRecording,
  markPaused,
  clearPresence,
  presenceAvailable,
  presenceUnavailable
} from './simulate-status-chat';
export { getMessageById } from './get-message-by-id';
export { blockContact } from './block-contact';
export { unblockContact } from './unblock-contact';
export { removeParticipant } from './remove-participant';
export { addParticipant } from './add-participant';
export { promoteParticipant } from './promote-participant';
export { demoteParticipant } from './demote-participant';
export { openChat, openChatAt } from './open-chat';
export { joinGroup } from './join-group';
export { markUnseenMessage } from './mark-unseen-message';
export { markMarkSeenMessage } from './mark-markSeen-message';
export { getBlockList } from './block-list';
export { setTheme, getTheme } from './theme';
export { restartService } from './restart-service';
export { killServiceWorker } from './kill-service-worker';
export { sendLinkPreview } from './send-link-preview';
export {
  sendExist,
  scope,
  getchatId,
  sendCheckType,
  returnChat
} from './check-send-exist';
export { sendContactVcardList } from './send-contact-vcard-list';
export { setProfilePic } from './set-profile-pic';
export { pinChat } from './fix-chat';
export { getSessionTokenBrowser } from './get-session-token';
export { sendMute } from './send-mute';
export { getListMute, interfaceMute } from './get-list-mute';
export { downloadMedia } from './download-media';
export { checkIdMessage } from './check-id-messagem';
export { returnReply } from './return-reply';
export { logout } from './logout';
export { setPresenceOnline } from './set-presence-online';
export { setPresenceOffline } from './set-presence-offline';
export { archiveChat } from './archive-chat';
export { setNewMessageId } from './set-new-message';
export { setGroupDescription } from './set-group-description';
export { sendButtons } from './send-buttons';
export { setGroupTitle } from './set-group-title';
export { setGroupSettings } from './set-group-settings';
export { getAllMessagesDate } from './get-data-messages';
export { checkNumberStatus } from './check-number-status';
export { sendListMenu } from './send-list-menu';
export { getStateConnection } from './get-state-connection';
export { isBeta } from './check-beta';
export { sendReactions } from './send-reactions';
export { addChatWapi } from './add-chat-wapi';
export { sendTypeButtons } from './send-type-buttons';
export { onlySendAdmin } from './only-send-admin';
export { createCommunity } from './create-community';
export { pollCreation } from './poll-creation';

/////
export { baseSendMessage } from './send-message-scope';
export { setGroupImage } from './set-group-image';

```

`src/lib/wapi/functions/is-connected.js`:

```js
export function isConnected(done) {
  // Phone Disconnected icon appears when phone
  const isConnected =
    document.querySelector('[data-testid="alert-phone"]') == null &&
    document.querySelector('[data-testid="alert-computer"]') == null
      ? true
      : false;
  if (done !== undefined) done(isConnected);
  return isConnected;
}

```

`src/lib/wapi/functions/is-logged-in.js`:

```js
export function isLoggedIn(done) {
  // Contact always exists when logged in
  const isLogged =
    window.Store.Contact && window.Store.Contact.checksum !== undefined;

  if (done !== undefined) done(isLogged);
  return isLogged;
}

```

`src/lib/wapi/functions/join-group.js`:

```js
export async function joinGroup(inviteCode) {
  var result = await Store.WapQuery.acceptGroupInvite(inviteCode);
  return result;
}

```

`src/lib/wapi/functions/kill-service-worker.js`:

```js
export async function killServiceWorker() {
  await Store.ServiceWorker.default.killServiceWorker();
  return true;
}

```

`src/lib/wapi/functions/leave-group.js`:

```js
export async function leaveGroup(groupId) {
  groupId = typeof groupId == 'string' ? groupId : groupId._serialized;
  var group = await WAPI.getChat(groupId);
  return Store.GroupActions.sendExitGroup(group);
}

```

`src/lib/wapi/functions/load-all-earlier-chat-messages.js`:

```js
export async function loadAllEarlierMessages(id, chat) {
  const found = await WAPI.getChat(id);
  while (!found.msgs.msgLoadState.noEarlierMsgs) {
    await found.onEmptyMRM();
    await WAPI.sleep(100);
  }
  chat(found);
  return true;
}

/**
 * SYNC version
 * Loads all earlier messages of given chat id
 * @param {string} id Chat id
 * @param {Funciton} done Optional callback
 */
export function asyncLoadAllEarlierMessages(id, done) {
  loadAllEarlierMessages(id);
  done();
}

```

`src/lib/wapi/functions/load-and-get-all-messages-in-chat.js`:

```js
export async function loadAndGetAllMessagesInChat(
  id,
  includeMe,
  includeNotifications
) {
  return new Promise((resolve) => {
    WAPI.loadAllEarlierMessages(id, async (chat) => {
      let output = [];
      const messages = chat.msgs._models;

      for (const i in messages) {
        if (i === 'remove') {
          continue;
        }
        const messageObj = messages[i];
        let message = await WAPI.processMessageObj(
          messageObj,
          includeMe,
          includeNotifications
        );

        if (message) {
          output.push(message);
        }
      }
      resolve(output);
    });
  });
}

```

`src/lib/wapi/functions/load-earlier-chat-messages.js`:

```js
export async function loadChatEarlierMessages(id) {
  const chat = await WAPI.getChat(id);
  if (chat) {
    const someEarlierMessages = await chat.onEmptyMRM();
    if (someEarlierMessages) {
      const serializeMessageObj = await WAPI._serializeMessageObj;
      return someEarlierMessages.map(serializeMessageObj);
    }
  }
  return false;
}

```

`src/lib/wapi/functions/load-earlier-messages-til-date.js`:

```js
export async function loadEarlierMessagesTillDate(id, lastMessage, done) {
  const found = await WAPI.getChat(id);
  const x = function () {
    if (
      found.msgs.models[0].t > lastMessage &&
      !found.msgs.msgLoadState.noEarlierMsgs
    ) {
      found.onEmptyMRM().then(x);
    } else {
      done();
    }
  };
  x();
}

```

`src/lib/wapi/functions/logout.js`:

```js
export async function logout() {
  if (window.Store.Login) {
    await window.Store.Login.startLogout();
    return true;
  } else {
    return false;
  }
}

```

`src/lib/wapi/functions/mark-markSeen-message.js`:

```js
/**
 * Mark chat as read ✔️✔️
 * @param {*} id idchat
 * @returns bollean
 */
export async function markMarkSeenMessage(id) {
  const chat = await WAPI.sendExist(id);
  if (!chat.erro) {
    //await Store.ReadSeen.markUnread(chat);
    await Store.ReadSeen.sendSeen(chat, false);
    return WAPI.scope(undefined, false, 'OK', null);
  } else {
    return WAPI.scope(undefined, true, 'Error', null);
  }
}

```

`src/lib/wapi/functions/mark-unseen-message.js`:

```js
/**
 * Mark unread chat
 * @param {*} id idchat
 * @returns bollean
 */
export async function markUnseenMessage(id) {
  const chat = await WAPI.sendExist(id);
  if (!chat.erro) {
    await Store.ReadSeen.markUnread(chat, true);
    return WAPI.scope(undefined, false, 'OK', null);
  } else {
    return WAPI.scope(undefined, true, 'Error', null);
  }
}

```

`src/lib/wapi/functions/only-send-admin.js`:

```js
export async function onlySendAdmin(chatId, type) {
  if (!chatId.includes('@g.us')) {
    return window.WAPI.scope(chatId, true, 404, 'The number is not a group');
  }

  if (typeof type !== 'boolean') {
    return window.WAPI.scope(chatId, true, 404, 'the type must be boolean');
  }
  const chat = await WAPI.sendExist(chatId);
  if (chat && chat.status != 404 && chat.id) {
    try {
      const onlyAdmin = await Store.onlySendAdmin.setGroupProperty(
        chat.id,
        `announcement`,
        type
      );
      return WAPI.scope(chatId, false, 200, 'successfully changed');
    } catch (e) {
      return WAPI.scope(chatId, true, 404, 'not changed');
    }
  } else {
    if (!chat.erro) {
      chat.erro = true;
    }
    return chat;
  }
}

```

`src/lib/wapi/functions/only-send-data-admin.js`:

```js
export async function onlySendDataAdmin(chat, type) {
  if (!chat.includes('@g.us')) {
    return WAPI.scope(chat, true, 404, 'The number is not a group');
  }

  if (typeof type !== 'boolean') {
    return WAPI.scope(chat, true, 404, 'the type must be boolean');
  }

  if (chat && chat.status != 404 && chat.id) {
    const chat = await WAPI.sendExist(chat);
    try {
      await Store.onlySendAdmin.sendSetGroupProperty(chat.id, `restrict`, type);
      return WAPI.scope(chat, false, 200, 'successfully changed');
    } catch {
      console.log('ddd');
    }
  } else {
    if (!chat.erro) {
      chat.erro = true;
    }
    return chat;
  }
}

```

`src/lib/wapi/functions/open-chat.js`:

```js
/**
 * open chat!
 * @param {string} chatId Chat id
 */
export async function openChat(chatId, force = false) {
  if (force) {
    const chat = await WAPI.getChat(chatId);
    const result = await Store.Cmd.openChatBottom(chat);
    return WAPI.scope(undefined, false, result);
  }

  if (typeof chatId != 'string' || chatId.length === 0) {
    return WAPI.scope(chatId, true, 404, 'It is necessary to number');
  }

  const chat = await WAPI.sendExist(chatId);
  if (chat && chat.status != 404 && chat.id) {
    const chat = Store.Chat.get(chatId);
    const result = Store.Cmd.default.openChatBottom(chat);
    return WAPI.scope(undefined, false, result);
  }
  if (!chat.erro) {
    chat.erro = true;
  }
  return chat;
}

/**
 * Opens chat at given message position
 * This is a UI proccess, use this in a queue
 * @param {string} chatId Chat id
 * @param {string} messageId Message id: (For example: '06D3AB3D0EEB9D077A3F9A3EFF4DD030')
 * @returns {{wasVisible: boolean, alignAt: string}}: {wasVisible: false, alignAt: "center"}
 */
export async function openChatAt(chatId, messageId) {
  const chat = Store.Chat.get(chatId);
  const atMessage = chat.msgs.models.find((model) => model.id.id === messageId);
  const args = {
    collection: chat.msgs,
    msg: atMessage,
    isUnreadDivider: false
  };
  const result = await Store.Cmd.default._openChat(chat, args);
  return result;
}

```

`src/lib/wapi/functions/pin.chat.js`:

```js
export async function pinChat(idUser, type) {
  const chat = await WAPI.sendExist(idUser);
  if (typeof type !== 'boolean') {
    return WAPI.scope(
      undefined,
      true,
      null,
      'Use true to pin or false to unpin'
    );
  }
  if (chat && chat.status != 404) {
    const pin = await window.chatOptions.pinChat(chat, type);
    return WAPI.scope(undefined, false, pin, undefined);
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/poll-creation.js`:

```js
export async function pollCreation(idUser, poll) {
  if (typeof poll !== 'object') {
    return WAPI.scope(idUser, true, 404, 'poll must be an object');
  }
  if (!poll?.name) {
    return WAPI.scope(idUser, true, 404, 'Missing object name');
  }
  if (!poll?.options) {
    return WAPI.scope(idUser, true, 404, 'Missing object options');
  }
  if (
    typeof poll.selectableOptionsCount !== 'number' ||
    (poll.selectableOptionsCount !== 1 && poll.selectableOptionsCount !== 0)
  ) {
    return WAPI.scope(
      idUser,
      true,
      404,
      'Error checking selectableOptionsCount!'
    );
  }

  const options = poll.options;
  if (Array.isArray(options) && options.length > 0) {
    for (let index in options) {
      if (typeof options[index] !== 'function') {
        if (!options[index].name) {
          return WAPI.scope(idUser, true, 404, 'Missing object name');
        }
        if (typeof options[index].name !== 'string') {
          return WAPI.scope(idUser, true, 404, 'Passed string value in name');
        }
      }
    }
  }

  const chat = await WAPI.sendExist(idUser);
  if (chat && chat.status !== 404 && chat.id) {
    await Store.Survey.sendPollCreation({
      chat: chat,
      poll: poll,
      quotedMsg: null
    });
    return { error: false, lastReceivedKey: chat.lastReceivedKey };
  } else {
    if (!chat.error) {
      chat.error = true;
    }
    return chat;
  }
}

```

`src/lib/wapi/functions/process-files.js`:

```js
export async function processFiles(chat, blobs) {
  if (!Array.isArray(blobs)) {
    blobs = [blobs];
  }
  const mediaCollection = new Store.MediaCollection({
    chatParticipantCount: chat.getParticipantCount()
  });

  await mediaCollection.processAttachments(
    Debug.VERSION === '0.4.613'
      ? blobs
      : blobs.map((blob) => {
          return {
            file: blob
          };
        }),
    chat,
    1
  );
  return mediaCollection;
}

```

`src/lib/wapi/functions/process-message-object.js`:

```js
export async function processMessageObj(
  messageObj,
  includeMe,
  includeNotifications
) {
  if (messageObj.isNotification) {
    if (includeNotifications) {
      return await WAPI._serializeMessageObj(messageObj);
    } else {
      return;
    }
  } else if (messageObj.id.fromMe === false || includeMe) {
    return await WAPI._serializeMessageObj(messageObj);
  }
  return;
}

```

`src/lib/wapi/functions/promote-participant.js`:

```js
export async function promoteParticipant(groupId, contactsId, done) {
  const chat = Store.Chat.get(groupId);

  if (!Array.isArray(contactsId)) {
    contactsId = [contactsId];
  }

  contactsId = await Promise.all(contactsId.map((c) => WAPI.sendExist(c)));
  contactsId = contactsId
    .filter((c) => !c.erro && c.isUser)
    .map((c) => chat.groupMetadata.participants.get(c.id))
    .filter((c) => typeof c !== 'undefined')
    .map((c) => c.id);

  if (!contactsId.length) {
    typeof done === 'function' && done(false);
    return false;
  }

  await window.Store.WapQuery.promoteParticipants(chat.id, contactsId);

  const participants = contactsId.map((c) =>
    chat.groupMetadata.participants.get(c)
  );

  await window.Store.Participants.promoteParticipants(chat, participants);

  typeof done === 'function' && done(true);
  return true;
}

```

`src/lib/wapi/functions/remove-participant.js`:

```js
export async function removeParticipant(groupId, contactsId, done) {
  const chat = Store.Chat.get(groupId);

  if (!Array.isArray(contactsId)) {
    contactsId = [contactsId];
  }

  contactsId = await Promise.all(contactsId.map((c) => WAPI.sendExist(c)));
  contactsId = contactsId
    .filter((c) => !c.erro && c.isUser)
    .map((c) => chat.groupMetadata.participants.get(c.id))
    .filter((c) => typeof c !== 'undefined')
    .map((c) => c.id);

  if (!contactsId.length) {
    typeof done === 'function' && done(false);
    return false;
  }

  await window.Store.WapQuery.removeParticipants(chat.id, contactsId);

  const participants = contactsId.map((c) =>
    chat.groupMetadata.participants.get(c)
  );

  await window.Store.Participants.removeParticipants(chat, participants);

  typeof done === 'function' && done(true);
  return true;
}

```

`src/lib/wapi/functions/reply.js`:

```js
export async function reply(chatId, content, quotedMessageId) {
  if (typeof chatId != 'string') {
    return WAPI.scope(
      null,
      true,
      404,
      'enter the chatid variable as an string'
    );
  }
  if (typeof content != 'string') {
    return WAPI.scope(
      null,
      true,
      404,
      'enter the content variable as an string'
    );
  }
  if (typeof quotedMessageId != 'string') {
    return WAPI.scope(
      null,
      true,
      404,
      'enter the content variable as an string'
    );
  }
  const chat = await WAPI.sendExist(chatId);
  if (chat && chat.status != 404) {
    let To = chat.id;
    const m = { type: 'deleteMessages' };
    let quotedMsgOptions = {};

    let quotedMessage = await WAPI.getMessageById(quotedMessageId, null, false);
    if (quotedMessage.erro == undefined) {
      let checkID = await WAPI.checkIdMessage(
        quotedMessage.to._serialized,
        quotedMessageId
      );
      if (checkID.erro == true) {
        return checkID;
      }
    } else {
      let obj = WAPI.scope(
        To,
        true,
        404,
        `The id ${quotedMessageId} does not exist!`
      );
      Object.assign(obj, m);
      return obj;
    }

    quotedMsgOptions = quotedMessage.msgContextInfo(chat);

    let checkID = await WAPI.checkIdMessage(chatId, quotedMessageId);
    if (checkID.erro == true) {
      return checkID;
    }

    const newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
    let inChat = await WAPI.getchatId(chat.id).catch(() => {});
    if (inChat) {
      chat.lastReceivedKey._serialized = inChat._serialized;
      chat.lastReceivedKey.id = inChat.id;
    }
    const message = {
      id: newMsgId,
      ack: 0,
      body: content,
      from: fromwWid,
      to: chat.id,
      local: !0,
      self: 'out',
      t: parseInt(new Date().getTime() / 1000),
      isNewMsg: !0,
      type: 'chat',
      ...quotedMsgOptions
    };

    const result = (
      await Promise.all(window.Store.addAndSendMsgToChat(chat, message))
    )[1];

    if (result === 'success' || result === 'OK') {
      let obj = WAPI.scope(newMsgId, false, result, '');
      Object.assign(obj, m);
      return obj;
    } else {
      let obj = WAPI.scope(newMsgId, true, result, '');
      Object.assign(obj, m);
      return obj;
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/restart-service.js`:

```js
export async function restartService() {
  await Store.ServiceWorker.default.restart();
  return true;
}

```

`src/lib/wapi/functions/return-reply.js`:

```js
export async function returnReply(message) {
  if (typeof message != 'object') {
    return WAPI.scope(
      null,
      true,
      404,
      'enter the message variable as an object'
    );
  }
  if (
    message &&
    message.quotedMsg &&
    message.quotedMsg.type &&
    message.quotedMsgObj
  ) {
    return message.quotedMsgObj;
  } else {
    return false;
  }
}

```

`src/lib/wapi/functions/revoke-invite-link.js`:

```js
export async function revokeGroupInviteLink(chatId) {
  var chat = Store.Chat.get(chatId);
  if (!chat.isGroup) return false;
  await Store.GroupInvite.sendRevokeGroupInviteCode(chat.id);
  return true;
}

```

`src/lib/wapi/functions/send-buttons.js`:

```js
export async function sendButtons(to, title, buttons, subtitle) {
  if (typeof title != 'string' || title.length === 0) {
    return WAPI.scope(to, true, 404, 'It is necessary to write a title!');
  }

  if (typeof subtitle != 'string' || subtitle.length === 0) {
    return WAPI.scope(to, true, 404, 'It is necessary to write a subtitle!');
  }

  if (Array.isArray(buttons) && buttons.length > 0) {
    for (let index in buttons) {
      if (typeof buttons[index] !== 'function') {
        if (!buttons[index].buttonText) {
          return WAPI.scope(to, true, 404, 'passed object buttonText');
        }
        if (typeof buttons[index].buttonText !== 'object') {
          return WAPI.scope(to, true, 404, 'passed object value in buttonText');
        }
        if (!buttons[index].buttonText.displayText) {
          return WAPI.scope(to, true, 404, 'passed object displayText');
        }
        if (typeof buttons[index].buttonText.displayText !== 'string') {
          return WAPI.scope(
            to,
            true,
            404,
            'passed string value in displayText'
          );
        }
        if (!buttons[index].buttonId) {
          buttons[index].buttonId = `id${index}`;
        }
        if (!buttons[index].type) {
          buttons[index].type = 1;
        }
      }
    }
  }

  const chat = await WAPI.sendExist(to);

  if (chat && chat.status != 404 && chat.id) {
    const newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();

    const message = {
      id: newMsgId,
      ack: 0,
      from: fromwWid,
      to: chat.id,
      local: !0,
      self: 'out',
      t: parseInt(new Date().getTime() / 1000),
      isNewMsg: !0,
      type: 'chat',
      body: title,
      caption: title,
      content: title,
      footer: subtitle,
      isDynamicReplyButtonsMsg: true,
      isForwarded: false,
      isFromTemplate: true,
      invis: true,
      fromMe: false
    };
    var obj = {
      dynamicReplyButtons: buttons
    };
    Object.assign(message, obj);
    var result = (
      await Promise.all(window.Store.addAndSendMsgToChat(chat, message))
    )[1];
    if (result === 'success' || result === 'OK') {
      return WAPI.scope(newMsgId, false, result, null);
    } else {
      return WAPI.scope(newMsgId, true, result, null);
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/send-chat-state.js`:

```js
export async function sendChatstate(state, chatId) {
  switch (state) {
    case '0':
      await window.Store.ChatStates.sendChatStateComposing(chatId);
      break;
    case '1':
      await window.Store.ChatStates.sendChatStateRecording(chatId);
      break;
    case '2':
      await window.Store.ChatStates.sendChatStatePaused(chatId);
      break;
    default:
      return false;
  }
  return true;
}

```

`src/lib/wapi/functions/send-contact-vcard-list.js`:

```js
export async function sendContactVcardList(chatId, contacts) {
  if (typeof chatId != 'string') {
    return WAPI.scope(
      chatId,
      true,
      null,
      "incorrect parameter, insert an string. Example: '222222222222@c.us'"
    );
  }

  if (!Array.isArray(contacts)) {
    return WAPI.scope(
      chatId,
      true,
      null,
      "incorrect parameter, insert an array. Example: ['222222222222@c.us', '333333333333@c.us, ... ]"
    );
  }

  if (contacts.length === 1) {
    return WAPI.scope(
      chatId,
      true,
      null,
      "Enter more than one number to send. Example: ['222222222222@c.us', '333333333333@c.us, ... ]"
    );
  }

  const chat = await WAPI.sendExist(chatId);

  if (!chat.erro) {
    var conta = contacts.map(async (e) => {
      return await WAPI.sendExist(e);
    });

    var ar = await Promise.all(conta);
    var cont = new Array();

    for (var key in ar) {
      if (typeof ar[key] === 'object') {
        cont.push(ar[key].__x_contact);
      }
    }

    var vcard = cont.map(async (e) => {
      if (typeof e === 'object') {
        return await window.Store.Vcard.vcardFromContactModel(e);
      }
    });

    var newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
    let inChat = await WAPI.getchatId(chat.id).catch(() => {});

    if (inChat) {
      chat.lastReceivedKey._serialized = inChat._serialized;
      chat.lastReceivedKey.id = inChat.id;
    }

    var Vcards = await Promise.all(vcard);

    const message = {
      id: newMsgId,
      ack: 0,
      from: fromwWid,
      local: !0,
      self: 'in',
      t: parseInt(new Date().getTime() / 1000),
      to: chat.id,
      type: 'multi_vcard',
      vcardList: Vcards,
      isNewMsg: !0
    };

    var result =
      (await Promise.all(Store.addAndSendMsgToChat(chat, message)))[1] || '';

    var m = { from: contacts, type: 'multi_vcard' };

    if (result === 'success' || result === 'OK') {
      var obj = WAPI.scope(newMsgId, false, result, null);
      Object.assign(obj, m);
      return obj;
    } else {
      var obj = WAPI.scope(newMsgId, true, result, null);
      Object.assign(obj, m);
      return obj;
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/send-contact-vcard.js`:

```js
export async function sendContactVcard(chatId, contact, name) {
  if (typeof chatId != 'string' || chatId.length === 0) {
    return WAPI.scope(chatId, true, 404, 'It is necessary to pass the number!');
  }

  if (typeof contact != 'string' || contact.length === 0) {
    return WAPI.scope(
      contact,
      true,
      404,
      'It is necessary to pass the number!'
    );
  }

  const chat = await WAPI.sendExist(chatId);
  const cont = await WAPI.sendExist(contact);
  if (
    chat &&
    chat.status != 404 &&
    chat.id &&
    cont &&
    cont.status != 404 &&
    cont.id
  ) {
    const newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    let inChat = await WAPI.getchatId(chat.id).catch(() => {
      return WAPI.scope(chat.id, true, 404, 'Error to number ' + chatId);
    });

    if (inChat) {
      chat.lastReceivedKey && chat.lastReceivedKey._serialized
        ? (chat.lastReceivedKey._serialized = inChat._serialized)
        : '';
      chat.lastReceivedKey && chat.lastReceivedKey.id
        ? (chat.lastReceivedKey.id = inChat.id)
        : '';
    }

    if (!newMsgId) {
      return WAPI.scope(chatId, true, 404, 'Error to newId');
    }

    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
    const body = await window.Store.Vcard.vcardFromContactModel(
      cont.__x_contact
    );

    name = !name ? cont.__x_formattedTitle : name;

    const message = {
      id: newMsgId,
      ack: 0,
      body: body.vcard,
      from: fromwWid,
      to: chat.id,
      local: !0,
      self: 'out',
      t: parseInt(new Date().getTime() / 1000),
      isNewMsg: !0,
      type: 'vcard'
    };

    const result = (
      await Promise.all(window.Store.addAndSendMsgToChat(chat, message))
    )[1];

    var m = { from: contact, type: 'vcard' };
    if (result === 'success' || result === 'OK') {
      var obj = WAPI.scope(newMsgId, false, result, null);
      Object.assign(obj, m);
      return obj;
    } else {
      var obj = WAPI.scope(newMsgId, true, result, null);
      Object.assign(obj, m);
      return obj;
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/send-file.js`:

```js
import { processFiles } from './process-files';
import { base64ToFile } from '../helper';

export async function sendFile(
  file,
  chatid,
  filename,
  caption,
  type,
  status,
  passId,
  checkNumber = true,
  forcingReturn = false,
  delSend = true
) {
  type = type ? type : 'sendFile';

  if (typeof chatid != 'string' || chatid.length === 0) {
    return WAPI.scope(
      chatid,
      true,
      null,
      'incorrect parameter chatid, insert an string.'
    );
  }

  if (typeof filename !== 'string' || chatid.length === 0) {
    return WAPI.scope(
      chatid,
      true,
      null,
      'incorrect parameter filename, insert an string'
    );
  }

  if (typeof caption !== 'string' || chatid.length === 0) {
    return WAPI.scope(
      chatid,
      true,
      null,
      'incorrect parameter caption, insert an string'
    );
  }

  if (typeof file !== 'string' || chatid.length === 0) {
    return WAPI.scope(
      chatid,
      true,
      null,
      'incorrect parameter file, insert an string'
    );
  }

  var mime = file.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
  if (mime && mime.length) {
    mime = mime[1];
  }

  const chat = checkNumber
    ? await WAPI.sendExist(chatid)
    : await WAPI.returnChat(chatid);

  if (chat && chat.status != 404 && chat.id) {
    let inChat = await WAPI.getchatId(chat.id).catch(() => {
      return WAPI.scope(chat.id, true, 404, 'Error to number ' + chatid);
    });

    if (inChat) {
      chat.lastReceivedKey && chat.lastReceivedKey._serialized
        ? (chat.lastReceivedKey._serialized = inChat._serialized)
        : '';
      chat.lastReceivedKey && chat.lastReceivedKey.id
        ? (chat.lastReceivedKey.id = inChat.id)
        : '';
    }

    const m = { type: type, filename: filename, text: caption, mimeType: mime };
    const newMsgId = !passId
      ? await window.WAPI.getNewMessageId(chat.id._serialized, checkNumber)
      : await window.WAPI.setNewMessageId(passId, checkNumber);

    if (!newMsgId) {
      return WAPI.scope(chat.id, true, 404, 'Error to newId');
    }
    const chatWid = new Store.WidFactory.createWid(chatid);
    await Store.Chat.add(
      {
        createdLocally: true,
        id: chatWid
      },
      {
        merge: true
      }
    );
    const result = await Store.Chat.find(chat.id)
      .then(async (_chat) => {
        const mediaBlob = base64ToFile(file);
        return await processFiles(_chat, mediaBlob)
          .then(async (mc) => {
            if (typeof mc === 'object' && mc._models && mc._models[0]) {
              const media = mc._models[0];
              const enc = await WAPI.encryptAndUploadFile(
                media.type,
                mediaBlob
              );

              if (enc === false) {
                return WAPI.scope(
                  chat.id,
                  true,
                  404,
                  'Error to encryptAndUploadFile'
                );
              }

              const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
              const message = {
                id: newMsgId,
                ack: 0,
                from: fromwWid,
                to: chat.id,
                local: !0,
                self: 'out',
                t: parseInt(new Date().getTime() / 1000),
                isNewMsg: !0,
                invis: true,
                type: media.type,
                deprecatedMms3Url: enc.url,
                directPath: enc.directPath,
                encFilehash: enc.encFilehash,
                filehash: enc.filehash,
                mediaKeyTimestamp: enc.mediaKeyTimestamp,
                mimetype: media.mimetype,
                ephemeralStartTimestamp: enc.mediaKeyTimestamp,
                mediaKey: enc.mediaKey,
                size: media.filesize,
                caption: caption,
                filename: filename
              };
              if (forcingReturn) {
                if (delSend) {
                  while (true) {
                    const connection = window.Store.State.Socket.state;
                    if (connection === 'CONNECTED') {
                      const result = await window.Store.addAndSendMsgToChat(
                        chat,
                        message
                      );
                      await WAPI.sleep(5000);
                      const statusMsg = chat.msgs._models.filter(
                        (e) => e.id === newMsgId._serialized && e.ack > 0
                      );
                      if (statusMsg.length === 0) {
                        await WAPI.deleteMessages(chatid, [
                          newMsgId._serialized
                        ]);
                      } else {
                        let obj = WAPI.scope(
                          newMsgId,
                          false,
                          WAPI._serializeForcing(result),
                          null
                        );
                        Object.assign(obj, m);
                        return obj;
                      }
                    }
                  }
                } else {
                  const result = await window.Store.addAndSendMsgToChat(
                    chat,
                    message
                  );
                  let obj = WAPI.scope(
                    newMsgId,
                    false,
                    WAPI._serializeForcing(result),
                    null
                  );
                  Object.assign(obj, m);
                  return obj;
                }
              }
              try {
                return (
                  await Promise.all(
                    window.Store.addAndSendMsgToChat(chat, message)
                  )
                )[1];
              } catch (e) {
                return WAPI.scope(
                  chat.id,
                  true,
                  404,
                  'The message was not sent'
                );
              }
            } else {
              return WAPI.scope(chat.id, true, 404, 'Error to models');
            }
          })
          .catch(() => {
            return WAPI.scope(chat.id, true, 404, 'Error to processFiles');
          });
      })
      .catch(() => {
        return WAPI.scope(chat.id, true, 404, 'Error to chat not find');
      });

    if (result.erro === false) {
      return result;
    }

    if (result === 'success' || result === 'OK') {
      var obj = WAPI.scope(newMsgId, false, result, null);
      Object.assign(obj, m);
      return obj;
    }

    if (result.erro === true) {
      return result;
    }

    var obj = WAPI.scope(newMsgId, true, result, null);
    Object.assign(obj, m);
    return obj;
  } else {
    if (!chat.erro) {
      chat.erro = true;
    }
    return chat;
  }
}

```

`src/lib/wapi/functions/send-image-as-stricker.js`:

```js
import { base64ToFile } from '../helper/base64-to-file';
import { sendSticker } from './send-sticker';

/**
 * Sends image as sticker to given chat id
 * @param {string} imageBase64 Image as base64 A valid webp image is required.
 * @param {string} chatId chat id '000000000000@c.us'
 * @param {*} metadata about the image. Based on [sharp metadata](https://sharp.pixelplumbing.com/api-input#metadata)
 */
export async function sendImageAsSticker(imageBase64, chatId, metadata, type) {
  const mediaBlob = base64ToFile(
    'data:image/webp;base64,' + imageBase64,
    'file.webp'
  );
  let encrypted = await window.WAPI.encryptAndUploadFile('sticker', mediaBlob);

  return await sendSticker(encrypted, chatId, metadata, type);
}

```

`src/lib/wapi/functions/send-image-with-product.js`:

```js
import { processFiles } from './process-files';
import { base64ToFile } from '../helper';

/**
 * Sends product with product image to given chat id
 * @param {string} imgBase64 Base64 image data
 * @param {string} chatid Chat id
 * @param {string} caption Caption
 * @param {string} bizNumber string the @c.us number of the business account from which you want to grab the product
 * @param {string} productId string the id of the product within the main catalog of the aforementioned business
 * @param {Function} done Optional callback
 */
export function sendImageWithProduct(
  imgBase64,
  chatid,
  caption,
  bizNumber,
  productId,
  done
) {
  Store.Catalog.findCarouselCatalog(bizNumber).then(async (cat) => {
    if (cat && cat[0]) {
      const product = cat[0].productCollection.get(productId);
      const temp = {
        productMsgOptions: {
          businessOwnerJid: product.catalogWid.toString({
            legacy: !0
          }),
          productId: product.id.toString(),
          url: product.url,
          productImageCount: product.productImageCollection.length,
          title: product.name,
          description: product.description,
          currencyCode: product.currency,
          priceAmount1000: product.priceAmount1000,
          type: 'product'
        },
        caption
      };

      const idUser = new Store.WidFactory.createWid(chatid);
      await Store.Chat.add(
        {
          createdLocally: true,
          id: idUser
        },
        {
          merge: true
        }
      );
      return Store.Chat.find(idUser).then((chat) => {
        var mediaBlob = base64ToFile(imgBase64, product.name);
        // var mc = new Store.MediaCollection(chat);
        // mc.processFiles([mediaBlob], chat, 1)
        processFiles(chat, mediaBlob).then((mc) => {
          var media = mc.models[0];
          Object.entries(temp.productMsgOptions).map(
            ([k, v]) => (media.mediaPrep._mediaData[k] = v)
          );
          media.mediaPrep.sendToChat(chat, temp);
          if (done !== undefined) done(true);
        });
      });
    }
  });
}

```

`src/lib/wapi/functions/send-image.js`:

```js
import { sendFile } from './send-file';

/**
 * Sends image to given chat if
 * @param {string} imgBase64 base64 encoded file
 * @param {string} chatid Chat id
 * @param {string} filename
 * @param {string} caption
 * @param {Function} done Optional callback
 */
export function sendImage(
  imgBase64,
  chatid,
  filename,
  caption,
  type,
  status = false,
  passId
) {
  return sendFile(imgBase64, chatid, filename, caption, type, status, passId);
}

```

`src/lib/wapi/functions/send-link-preview.js`:

```js
export async function sendLinkPreview(chatId, url, text, thumbnail) {
  text = text || '';
  const _Path = {
    Protocol: '^(https?:\\/\\/)?',
    Domain: '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|',
    IP: '((\\d{1,3}\\.){3}\\d{1,3}))',
    Port: '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*',
    Query: '(\\?[;&a-z\\d%_.~+=-]*)?',
    End: '(\\#[-a-z\\d_]*)?$',
    Reg: () => {
      return new RegExp(
        _Path.Protocol +
          _Path.Domain +
          _Path.IP +
          _Path.Port +
          _Path.Query +
          _Path.End,
        'i'
      );
    }
  };
  if (!_Path.Reg().test(url)) {
    var text =
      'Use a valid HTTP protocol. Example: https://www.youtube.com/watch?v=V1bFr2SWP1';
    return WAPI.scope(chatId, true, null, text);
  }

  var chat = await WAPI.sendExist(chatId);
  if (!chat.erro) {
    const newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
    let inChat = await WAPI.getchatId(chat.id).catch(() => {});
    if (inChat) {
      chat.lastReceivedKey._serialized = inChat._serialized;
      chat.lastReceivedKey.id = inChat.id;
    }
    const link = await window.Store.Validators.findLink(url);
    const message = {
      id: newMsgId,
      links: link,
      ack: 0,
      body: url,
      from: fromwWid,
      to: chat.id,
      local: !0,
      self: 'out',
      t: parseInt(new Date().getTime() / 1000),
      isNewMsg: !0,
      type: 'chat',
      subtype: 'url',
      preview: true,
      disappearingModeInitiator: 'chat',
      thumbnail: thumbnail,
      content: url,
      canonicalUrl: url,
      description: url,
      matchedText: url,
      title: text
    };
    const result = (
      await Promise.all(window.Store.addAndSendMsgToChat(chat, message))
    )[1];
    let m = { type: 'LinkPreview', url: url, text: text };
    if (result === 'success' || result === 'OK') {
      let obj = WAPI.scope(newMsgId, false, result, null);
      Object.assign(obj, m);
      return obj;
    } else {
      let obj = WAPI.scope(newMsgId, true, result, null);
      Object.assign(obj, m);
      return obj;
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/send-list-menu.js`:

```js
/**
 * Send List menu
 * @param {string} to the numberid xxx@c.us
 * @param {string} title the titulo
 * @param {string} subtitle the subtitle
 * @param {string} description the description
 * @param {string} buttonText the name button
 * @param {array} menu List menu
 */
export async function sendListMenu(
  to,
  title,
  subTitle,
  description,
  buttonText,
  menu
) {
  if (!title && typeof title != 'string') {
    return WAPI.scope(null, true, 404, 'Enter the title variable as an string');
  }

  if (!subTitle && typeof subTitle != 'string') {
    return WAPI.scope(
      null,
      true,
      404,
      'Enter the SubTitle variable as an string'
    );
  }

  if (!description && typeof description != 'string') {
    return WAPI.scope(
      null,
      true,
      404,
      'Enter the description variable as an string'
    );
  }

  if (!buttonText && typeof buttonText != 'string') {
    return WAPI.scope(
      null,
      true,
      404,
      'Enter the buttonText variable as an string'
    );
  }

  if (!menu && Array.isArray(menu) === false) {
    return WAPI.scope(null, true, 404, 'Enter the menu variable as an array');
  }

  for (let index in menu) {
    if (index !== 'remove') {
      if (
        !!menu[index].title &&
        typeof menu[index].title === 'string' &&
        menu[index].title.length
      ) {
        if (
          !!menu[index].rows &&
          Array.isArray(menu[index].rows) &&
          menu[index].rows.length
        ) {
          for (let i in menu[index].rows) {
            if (i !== 'remove') {
              if (
                !!menu[index].rows[i].title &&
                menu[index].rows[i].title.length
              ) {
                if (
                  !!menu[index].rows[i].description &&
                  menu[index].rows[i].description.length
                ) {
                  if (!menu[index].rows[i].rowId) {
                    menu[index].rows[i].rowId = `dessert_${i}`;
                  }
                }
              } else {
                return WAPI.scope(
                  null,
                  true,
                  404,
                  'Enter the Title variable as an string'
                );
              }
            }
          }
        } else {
          return WAPI.scope(null, true, 404, 'Rows must be an object array');
        }
      } else {
        return WAPI.scope(null, true, 404, 'Incorrect Title passed in menu');
      }
    }
  }

  const chat = await WAPI.sendExist(to);

  if (chat && chat.status != 404 && chat.id) {
    const newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
    const inChat = await WAPI.getchatId(chat.id).catch(() => {});

    if (inChat) {
      chat.lastReceivedKey._serialized = inChat._serialized;
      chat.lastReceivedKey.id = inChat.id;
    }

    const message = {
      id: newMsgId,
      ack: 0,
      from: fromwWid,
      to: chat.id,
      local: !0,
      self: 'out',
      t: parseInt(new Date().getTime() / 1000),
      isNewMsg: !0,
      invis: true,
      footer: subTitle,
      notifyName: '',
      type: 'list',
      interactiveAnnotations: true,
      interactiveMessage: true,
      star: false,
      broadcast: false,
      fromMe: false,
      list: {
        title: title,
        description: description,
        buttonText: buttonText,
        listType: 1,
        sections: menu
      }
    };

    var result = (
      await Promise.all(window.Store.addAndSendMsgToChat(chat, message))
    )[1];
    if (result === 'success' || result === 'OK') {
      return WAPI.scope(newMsgId, false, result, null);
    } else {
      return WAPI.scope(newMsgId, true, result, null);
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/send-location.js`:

```js
export async function sendLocation(
  chatId,
  latitude,
  longitude,
  location = null
) {
  const chat = await WAPI.sendExist(chatId);
  if (isNaN(Number(latitude)) || isNaN(Number(longitude))) {
    return WAPI.scope(
      chatId,
      true,
      null,
      'latitude and longitude must be numbers'
    );
  }
  if (!chat.erro) {
    const newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    const inChat = await WAPI.getchatId(chat.id).catch(() => {});
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();

    if (inChat) {
      chat.lastReceivedKey._serialized = inChat._serialized;
      chat.lastReceivedKey.id = inChat.id;
    }
    const newid = await window.WAPI.getNewMessageId(
      chat.id._serialized,
      chatId
    );
    const message = {
      type: 'location',
      ack: 0,
      from: fromwWid,
      id: newid,
      local: !0,
      isNewMsg: !0,
      self: 'out',
      t: parseInt(new Date().getTime() / 1000),
      to: chat.id,
      lat: Number(latitude),
      lng: Number(longitude),
      loc: location
    };

    const result =
      (await Promise.all(Store.addAndSendMsgToChat(chat, message)))[1] || '';

    let m = {
        latitude: latitude,
        longitude: longitude,
        title: location,
        type: 'location'
      },
      obj;
    if (result == 'success' || result == 'OK') {
      obj = WAPI.scope(newMsgId, false, result, null);
      Object.assign(obj, m);
      return obj;
    } else {
      obj = WAPI.scope(newMsgId, true, result, null);
      Object.assign(obj, m);
      return obj;
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/send-message-scope.js`:

```js
/**
 * send message in options mode
 * @param {string} to contact number
 * @param {string} body message body
 * @param {object} options shipping options
 */
export async function sendMessage(to, body, options = {}) {
  const types = [
    'sendText',
    'sendAudioBase64',
    'sendImageFromBase64',
    'sendAudio',
    'sendFile',
    'sendImage'
  ];
  let typesObj;
  types.reduce(
    (a, v) =>
      (typesObj = {
        ...a,
        [v]: v
      }),
    {}
  );

  if (!body) {
    return WAPI.scope(undefined, true, null, `parameters are missing`);
  }

  if (!options.type || (options.type && !types.includes(options.type))) {
    return WAPI.scope(
      undefined,
      true,
      null,
      `pass the message type, examples: ${types.join(', ')}`
    );
  }

  const chat = await WAPI.sendExist(to);
  const merge = {};

  if (chat && chat.status != 404 && chat.id) {
    const newMsgId = await WAPI.getNewMessageId(chat.id._serialized);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();

    if (options.type === typesObj.sendText) {
      merge.type = 'chat';
    }

    if (
      options.type === typesObj.sendAudioBase64 ||
      options.type === typesObj.sendAudio ||
      options.type === typesObj.sendFile ||
      options.type === typesObj.sendImage ||
      options.type === typesObj.sendImageFromBase64
    ) {
      const chatWid = new Store.WidFactory.createWid(to);
      await Store.Chat.add(
        {
          createdLocally: true,
          id: chatWid
        },
        {
          merge: true
        }
      );
      let result = await Store.Chat.find(chat.id);
      const mediaBlob = WAPI.base64ToFile(body);
      const mc = await WAPI.processFiles(result, mediaBlob);
      if (typeof mc === 'object' && mc._models && mc._models[0]) {
        const media = mc._models[0];
        let enc, type;

        if (
          options.type === typesObj.sendFile ||
          options.type === typesObj.sendImage ||
          options.type === typesObj.sendImageFromBase64
        ) {
          type = media.type;
          merge.caption = options?.caption;
          merge.filename = options?.filename;
          enc = await WAPI.encryptAndUploadFile(type, mediaBlob);
        } else {
          type = 'ptt';
          enc = await WAPI.encryptAndUploadFile(type, mediaBlob);
        }

        if (enc === false) {
          return WAPI.scope(
            chat.id,
            true,
            404,
            'Error to encryptAndUploadFile'
          );
        }

        merge.type = type;
        merge.duration = media?.__x_mediaPrep?._mediaData?.duration;
        merge.mimetype = media.mimetype;
        merge.size = media.filesize;
        merge.deprecatedMms3Url = enc.url;
        merge.directPath = enc.directPath;
        merge.encFilehash = enc.encFilehash;
        merge.filehash = enc.filehash;
        merge.mediaKeyTimestamp = enc.mediaKeyTimestamp;
        merge.ephemeralStartTimestamp = enc.mediaKeyTimestamp;
        merge.mediaKey = enc.mediaKey;
        body = undefined;
      }
    }

    if (!Object.keys(merge).length) {
      return WAPI.scope(undefined, true, null, 'Error sending message');
    }

    const message = WAPI.baseSendMessage(
      {
        to,
        body,
        newMsgId,
        fromwWid,
        chat
      },
      merge
    );

    try {
      const result = (
        await Promise.all(Store.addAndSendMsgToChat(chat, message))
      )[1];
      if (result === 'OK') {
        return WAPI.scope(newMsgId, false, result, null, options.type, body);
      }
      throw result;
    } catch (result) {
      return WAPI.scope(newMsgId, true, result, null, options.type, body);
    }
  } else {
    if (!chat.erro) {
      chat.erro = true;
    }

    return chat;
  }
}

export function baseSendMessage(param, merge) {
  const message = {
    id: param.newMsgId,
    ack: 0,
    body: param?.body,
    from: param.fromwWid,
    to: param.chat.id,
    local: !0,
    self: 'out',
    t: parseInt(new Date().getTime() / 1000),
    isNewMsg: !0,
    ...merge
  };
  return message;
}

```

`src/lib/wapi/functions/send-message-with-tags.js`:

```js
export async function sendMessageWithTags(to, body) {
  var chat = to.id ? to : Store.Chat.get(to);
  var chatId = chat.id._serialized;
  var msgIveSent = chat.msgs.filter((msg) => msg.__x_isSentByMe)[0];
  if (!msgIveSent) {
    return chat.sendMessage(body);
  }

  var tempMsg = Object.create(msgIveSent);
  var newId = await window.WAPI.getNewMessageId(chat.id._serialized);
  var mentionedJidList =
    body
      .match(/@(\d*)/g)
      .map((x) => new Store.WidFactory.createUserWid(x.replace('@', ''))) ||
    undefined;

  var extend = {
    ack: 0,
    id: newId,
    local: !0,
    self: 'out',
    t: parseInt(new Date().getTime() / 1000),
    to: new Store.WidFactory.createWid(chatId),
    isNewMsg: !0,
    type: 'chat',
    body,
    quotedMsg: null,
    mentionedJidList
  };

  Object.assign(tempMsg, extend);
  await Store.addAndSendMsgToChat(chat, tempMsg);
  return newId._serialized;
}

```

`src/lib/wapi/functions/send-message-with-thumb.js`:

```js
export async function sendMessageWithThumb(
  thumb,
  url,
  title,
  description,
  chatId,
  done
) {
  var chatSend = await WAPI.getChat(chatId);
  if (chatSend === undefined) {
    if (done !== undefined) done(false);
    return false;
  }
  var linkPreview = {
    canonicalUrl: url,
    description: description,
    matchedText: url,
    title: title,
    thumbnail: thumb
  };
  chatSend.sendMessage(url, {
    linkPreview: linkPreview,
    mentionedJidList: [],
    quotedMsg: null,
    quotedMsgAdminGroupJid: null
  });
  if (done !== undefined) done(true);
  return true;
}

```

`src/lib/wapi/functions/send-message.js`:

```js
export async function sendMessage(
  to,
  content,
  status = false,
  passId,
  checkNumber = true,
  forcingReturn = false,
  delSend = true
) {
  if (status && content.length > 700) {
    return WAPI.scope(undefined, true, null, 'Use a maximum of 700 characters');
  }

  if (
    status === false &&
    (typeof content != 'string' || content.length === 0)
  ) {
    return WAPI.scope(
      undefined,
      true,
      null,
      'It is necessary to write a text!'
    );
  }

  if (status == false && (typeof to != 'string' || to.length === 0)) {
    return WAPI.scope(to, true, 404, 'It is necessary to number');
  }

  const chat = checkNumber
    ? await WAPI.sendExist(to)
    : await WAPI.returnChat(to);

  if (chat && chat.status != 404 && chat.id) {
    const t = status != false ? 'sendStatusText' : 'sendText';
    const m = { type: t, text: content };
    const newMsgId = !passId
      ? await window.WAPI.getNewMessageId(chat.id._serialized, checkNumber)
      : await window.WAPI.setNewMessageId(passId, checkNumber);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();

    let inChat = await WAPI.getchatId(chat.id).catch(() => {
      return WAPI.scope(chat.id, true, 404, 'Error to number ' + to);
    });

    if (inChat) {
      chat.lastReceivedKey && chat.lastReceivedKey._serialized
        ? (chat.lastReceivedKey._serialized = inChat._serialized)
        : '';
      chat.lastReceivedKey && chat.lastReceivedKey.id
        ? (chat.lastReceivedKey.id = inChat.id)
        : '';
    }

    if (!newMsgId) {
      return WAPI.scope(to, true, 404, 'Error to gerate newId');
    }

    const message = {
      id: newMsgId,
      ack: 0,
      body: content,
      from: fromwWid,
      to: chat.id,
      local: !0,
      self: 'out',
      t: parseInt(new Date().getTime() / 1000),
      isNewMsg: !0,
      type: 'chat'
    };

    if (forcingReturn) {
      if (delSend) {
        while (true) {
          const connection = window.Store.State.Socket.state;
          if (connection === 'CONNECTED') {
            const result = await window.Store.addAndSendMsgToChat(
              chat,
              message
            );
            await WAPI.sleep(5000);
            const statusMsg = chat.msgs._models.filter(
              (e) => e.id === newMsgId._serialized && e.ack > 0
            );
            if (statusMsg.length === 0) {
              await WAPI.deleteMessages(to, [newMsgId._serialized]);
            } else {
              let obj = WAPI.scope(
                newMsgId,
                false,
                WAPI._serializeForcing(result),
                content
              );
              Object.assign(obj, m);
              return obj;
            }
          }
        }
      } else {
        const result = await window.Store.addAndSendMsgToChat(chat, message);
        let obj = WAPI.scope(
          newMsgId,
          false,
          WAPI._serializeForcing(result),
          content
        );
        Object.assign(obj, m);
        return obj;
      }
    }

    try {
      const result = (
        await Promise.all(window.Store.addAndSendMsgToChat(chat, message))
      )[1];

      if (result === 'success' || result === 'OK') {
        const obj = WAPI.scope(newMsgId, false, result, content);
        Object.assign(obj, m);
        return obj;
      }
      if (result === 'ERROR_UNKNOWN' && to.includes('@g.us')) {
        const obj = WAPI.scope(
          newMsgId,
          true,
          result,
          'Could not send message to this group, possibly you have been removed'
        );
        Object.assign(obj, m);
        return obj;
      }
    } catch (result) {
      let res = result;
      if (result?.contact?.id) {
        res = result.contact.id;
      }
      if (result?.message) {
        res.message = result.message;
      }
      const obj = WAPI.scope(newMsgId, true, res, 'The message was not sent');
      Object.assign(obj, m);
      return obj;
    }
  } else {
    if (!chat.erro) {
      chat.erro = true;
    }
    return chat;
  }
}

```

`src/lib/wapi/functions/send-message2.js`:

```js
export async function sendMessage2(id, message, done) {
  var chat = await WAPI.getChat(id);
  if (chat !== undefined) {
    try {
      if (done !== undefined) {
        chat.sendMessage(message).then(function () {
          done(true);
        });
      } else {
        chat.sendMessage(message);
      }
      return true;
    } catch (error) {
      if (done !== undefined) done(false);
      return false;
    }
  }
  if (done !== undefined) done(false);
  return false;
}

```

`src/lib/wapi/functions/send-mute.js`:

```js
export async function sendMute(chatId, time, type) {
  var chat = await WAPI.sendExist(chatId);
  if (!chat.erro) {
    let TimeInt = null;
    var result = null,
      remove = null,
      texto = null;
    var To = await WAPI.getchatId(chat.id),
      isMute = await window.Store.Mute.get(chat.id),
      m = { type: 'sendMute', time: time, timeType: type };
    if (typeof time === 'number' && typeof type === 'string') {
      switch (type) {
        case 'hours':
          TimeInt = parseInt(
            new Date(
              new Date().setHours(new Date().getHours() + time)
            ).getTime() / 1000
          );
          break;
        case 'minutes':
          TimeInt = parseInt(
            new Date(
              new Date().setMinutes(new Date().getMinutes() + time)
            ).getTime() / 1000
          );
          break;
        case 'year':
          TimeInt = parseInt(
            new Date(
              new Date().setDate(new Date().getDate() + time)
            ).getTime() / 1000
          );
          break;
      }
      await window.Store.SendMute.sendConversationMute(chat.id, TimeInt, 0)
        .then((e) => {
          result = e;
        })
        .catch((e) => {
          result = e;
        });
    } else {
      remove = true;
      await window.Store.SendMute.sendConversationMute(
        chat.id,
        0,
        isMute.__x_expiration
      )
        .then((e) => {
          result = e;
        })
        .catch((e) => {
          result = e;
        });
    }
    if (result.status === 200) {
      if (remove) {
        isMute.__x_expiration = 0;
        isMute.__x_isMuted = false;
      } else {
        isMute.__x_expiration = TimeInt;
        isMute.__x_isMuted = true;
      }
      var obj = WAPI.scope(To, false, result.status, null);
      Object.assign(obj, m);
      return obj;
    } else {
      if (remove) {
        texto = 'is not mute to remove';
      } else {
        texto = 'This chat is already mute';
      }
      var obj = WAPI.scope(To, true, result['status'], texto);
      Object.assign(obj, m);
      return obj;
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/send-ptt.js`:

```js
import { processFiles } from './process-files';
import { base64ToFile } from '../helper';
import C from '../jssha';
/**
 * Sends files
 * @param {string} Base64 base64 encoded file
 * @param {string} chatid Chat id
 */
export async function sendPtt(
  Base64,
  chatid,
  passId,
  checkNumber = true,
  forcingReturn = false,
  delSend = true
) {
  if (typeof Base64 === 'string' && !Base64.length) {
    return WAPI.scope(chatid, true, 404, 'Audio not foud');
  }
  const chat = checkNumber
    ? await WAPI.sendExist(chatid)
    : await WAPI.returnChat(chatid);

  if (chat && chat.status != 404 && chat.id) {
    const m = { type: 'sendPtt' };

    let inChat = await WAPI.getchatId(chat.id).catch(() => {
      return WAPI.scope(chat.id, true, 404, 'Error to number ' + chatid);
    });

    if (inChat) {
      chat.lastReceivedKey && chat.lastReceivedKey._serialized
        ? (chat.lastReceivedKey._serialized = inChat._serialized)
        : '';
      chat.lastReceivedKey && chat.lastReceivedKey.id
        ? (chat.lastReceivedKey.id = inChat.id)
        : '';
    }

    const newMsgId = !passId
      ? await window.WAPI.getNewMessageId(chat.id._serialized, checkNumber)
      : await window.WAPI.setNewMessageId(passId, checkNumber);

    if (!newMsgId) {
      return WAPI.scope(chat.id, true, 404, 'Error to newId');
    }
    const chatWid = new Store.WidFactory.createWid(chatid);
    await Store.Chat.add(
      {
        createdLocally: true,
        id: chatWid
      },
      {
        merge: true
      }
    );
    let result = await Store.Chat.find(chat.id)
      .then(async (chat) => {
        const mediaBlob = base64ToFile(Base64);
        return await processFiles(chat, mediaBlob).then(async (mc) => {
          if (typeof mc === 'object' && mc._models && mc._models[0]) {
            const media = mc._models[0];
            const enc = await WAPI.encryptAndUploadFile('ptt', mediaBlob);

            if (enc === false) {
              return WAPI.scope(
                chat.id,
                true,
                404,
                'Error to encryptAndUploadFile'
              );
            }

            const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();

            const message = {
              id: newMsgId,
              ack: 0,
              from: fromwWid,
              to: chat.id,
              local: !0,
              self: 'out',
              t: parseInt(new Date().getTime() / 1000),
              isNewMsg: !0,
              invis: true,
              type: 'ptt', //media.type,
              duration: media?.__x_mediaPrep?._mediaData?.duration,
              deprecatedMms3Url: enc.url,
              directPath: enc.directPath,
              encFilehash: enc.encFilehash,
              filehash: enc.filehash,
              mediaKeyTimestamp: enc.mediaKeyTimestamp,
              mimetype: media.mimetype,
              ephemeralStartTimestamp: enc.mediaKeyTimestamp,
              mediaKey: enc.mediaKey,
              size: media.filesize
            };

            if (forcingReturn) {
              if (delSend) {
                while (true) {
                  const connection = window.Store.State.Socket.state;
                  if (connection === 'CONNECTED') {
                    const result = await window.Store.addAndSendMsgToChat(
                      chat,
                      message
                    );
                    await WAPI.sleep(5000);
                    const statusMsg = chat.msgs._models.filter(
                      (e) => e.id === newMsgId._serialized && e.ack > 0
                    );
                    if (statusMsg.length === 0) {
                      await WAPI.deleteMessages(chatid, [newMsgId._serialized]);
                    } else {
                      let obj = WAPI.scope(
                        newMsgId,
                        false,
                        WAPI._serializeForcing(result),
                        null
                      );
                      Object.assign(obj, m);
                      return obj;
                    }
                  }
                }
              } else {
                const result = await window.Store.addAndSendMsgToChat(
                  chat,
                  message
                );
                let obj = WAPI.scope(
                  newMsgId,
                  false,
                  WAPI._serializeForcing(result),
                  null
                );
                Object.assign(obj, m);
                return obj;
              }
            }

            try {
              return (
                await Promise.all(
                  window.Store.addAndSendMsgToChat(chat, message)
                )
              )[1];
            } catch (e) {
              return WAPI.scope(chat.id, true, 404, 'The message was not sent');
            }
          } else {
            return WAPI.scope(chat.id, true, 404, 'Error to models');
          }
        });
      })
      .catch((e) => {
        return WAPI.scope(chat.id, true, 404, 'Error to chat not find');
      });

    if (result.erro === false) {
      return result;
    }

    if (result === 'success' || result === 'OK') {
      let obj = WAPI.scope(newMsgId, false, result, null);
      Object.assign(obj, m);
      return obj;
    }

    if (result.erro === true) {
      return result;
    }

    let obj = WAPI.scope(newMsgId, true, result, null);
    Object.assign(obj, m);
    return obj;
  } else {
    if (!chat.erro) {
      chat.erro = true;
    }
    return chat;
  }
}

```

`src/lib/wapi/functions/send-query-message-info.js`:

```js
export async function sendQueryMsgInfo(msgId) {
  var result = await window.Store.sendQueryMsgInfo(msgId);
  return result;
}

```

`src/lib/wapi/functions/send-reactions.js`:

```js
export async function sendReactions(IdMessage, emoji = '🐙') {
  if (!IdMessage && IdMessage.length && typeof IdMessage === 'string') {
    return WAPI.scope(
      undefined,
      true,
      null,
      'necessary to pass the id of the message!'
    );
  }
  const checkMsg = await Store.Msg.find(IdMessage);
  if (typeof checkMsg === 'object') {
    return Store.Reactions.sendReactionToMsg(checkMsg, emoji);
  }
  return WAPI.scope(undefined, true, null, 'Message id not found!');
}

```

`src/lib/wapi/functions/send-seen.js`:

```js
export async function sendSeen(id, done) {
  const chat = await WAPI.sendExist(id);
  if (!chat.erro) {
    await Store.ReadSeen.markUnread(chat, false)
      .then(() => {
        return WAPI.scope(undefined, false, 'OK', null);
      })
      .catch(() => {
        return WAPI.scope(undefined, true, 'Error', null);
      });
    return true;
  } else {
    return false;
  }
}

```

`src/lib/wapi/functions/send-sticker.js`:

```js
export async function sendSticker(sticker, chatId, metadata, type) {
  const chat = await WAPI.sendExist(chatId);

  if (!chat.erro) {
    const newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
    const inChat = await WAPI.getchatId(chat.id).catch(() => {
      return WAPI.scope(chat.id, true, 404, 'Error to number ' + chatId);
    });
    if (inChat) {
      chat.lastReceivedKey && chat.lastReceivedKey._serialized
        ? (chat.lastReceivedKey._serialized = inChat._serialized)
        : '';
      chat.lastReceivedKey && chat.lastReceivedKey.id
        ? (chat.lastReceivedKey.id = inChat.id)
        : '';
    }
    const message = {
      id: newMsgId,
      ack: 0,
      encFilehash: sticker.uploadhash,
      from: fromwWid,
      to: chat.id,
      local: !0,
      self: 'out',
      t: parseInt(new Date().getTime() / 1000),
      isNewMsg: !0,
      type: 'sticker',
      deprecatedMms3Url: sticker.clientUrl,
      filehash: sticker.filehash,
      mediaKey: sticker.mediaKey,
      mimetype: 'image/webp',
      height: metadata && metadata.height ? metadata.height : 512,
      width: metadata && metadata.width ? metadata.width : 512
    };

    const result = (
      await Promise.all(window.Store.addAndSendMsgToChat(chat, message))
    )[1];

    const m = { type: type };
    if (result === 'success' || result === 'OK') {
      const obj = WAPI.scope(newMsgId, false, result, null);
      Object.assign(obj, m);
      return obj;
    }
    const obj = WAPI.scope(newMsgId, true, result, null);
    Object.assign(obj, m);
    return obj;
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/send-type-buttons.js`:

```js
export async function sendTypeButtons(to, text, title, footer, hButtons) {
  const chat = await WAPI.sendExist(to);

  if (typeof text != 'string' || text.length === 0) {
    return WAPI.scope(to, true, 404, 'It is necessary to write a text!');
  }

  let b = 0;

  if (Array.isArray(hButtons) && hButtons.length > 0) {
    for (let index in hButtons) {
      if (typeof hButtons[index] !== 'function') {
        if (hButtons[index].urlButton) {
          b++;
          if (!hButtons[index].urlButton) {
            return WAPI.scope(to, true, 404, 'passed object urlButton');
          }
          if (typeof hButtons[index].urlButton !== 'object') {
            return WAPI.scope(
              to,
              true,
              404,
              'passed object value in urlButton'
            );
          }
          if (!hButtons[index].urlButton.displayText) {
            return WAPI.scope(to, true, 404, 'passed object displayText');
          }

          if (typeof hButtons[index].urlButton.displayText !== 'string') {
            return WAPI.scope(
              to,
              true,
              404,
              'passed string value in displayText'
            );
          }
          if (!hButtons[index].urlButton.url) {
            return WAPI.scope(to, true, 404, 'passed object url');
          }
          if (typeof hButtons[index].urlButton.url !== 'string') {
            return WAPI.scope(to, true, 404, 'passed string value in url');
          }
        }

        if (hButtons[index].callButton) {
          b++;
          if (!hButtons[index].callButton) {
            return WAPI.scope(to, true, 404, 'passed object callButton');
          }
          if (typeof hButtons[index].callButton !== 'object') {
            return WAPI.scope(
              to,
              true,
              404,
              'passed object value in callButton'
            );
          }
          if (!hButtons[index].callButton.displayText) {
            return WAPI.scope(to, true, 404, 'passed object displayText');
          }
          if (typeof hButtons[index].callButton.displayText !== 'string') {
            return WAPI.scope(
              to,
              true,
              404,
              'passed string value in displayText'
            );
          }
          if (!hButtons[index].callButton.phoneNumber) {
            return WAPI.scope(to, true, 404, 'passed object phoneNumber');
          }
          if (typeof hButtons[index].callButton.phoneNumber !== 'string') {
            return WAPI.scope(
              to,
              true,
              404,
              'passed string value in phoneNumber'
            );
          }
        }

        if (hButtons[index].quickReplyButton) {
          b++;
          if (!hButtons[index].quickReplyButton) {
            return WAPI.scope(to, true, 404, 'passed object quickReplyButton');
          }
          if (typeof hButtons[index].quickReplyButton !== 'object') {
            return WAPI.scope(
              to,
              true,
              404,
              'passed object value in quickReplyButton'
            );
          }
          if (!hButtons[index].quickReplyButton.displayText) {
            return WAPI.scope(to, true, 404, 'passed object displayText');
          }
          if (
            typeof hButtons[index].quickReplyButton.displayText !== 'string'
          ) {
            return WAPI.scope(
              to,
              true,
              404,
              'passed string value in displayText'
            );
          }
          if (!hButtons[index].quickReplyButton.id) {
            hButtons[index].quickReplyButton.id = `id${index}`;
          }
        }
      }
    }
  }

  if (b === 0) {
    return WAPI.scope(to, true, 404, 'button type not specified!');
  }
  if (chat && chat.status != 404 && chat.id) {
    const newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
    const buttons = new Store.TemplateButtonCollection();
    const message = {
      from: fromwWid,
      id: newMsgId,
      ack: 0,
      to: chat.id,
      local: !0,
      self: 'out',
      isNewMsg: !0,
      t: parseInt(new Date().getTime() / 1000),
      type: 'chat',
      isQuotedMsgAvailable: true,
      isFromTemplate: true,
      footer: footer,
      body: text,
      buttons,
      __x_title: title,
      hydratedButtons: hButtons
    };

    message.buttons.add(
      message.hydratedButtons.map((e, t) => {
        const r = `${null != e.index ? e.index : t}`;
        if (e.quickReplyButton) {
          return new Store.templateButton({
            id: r,
            displayText: e.quickReplyButton.displayText,
            selectionId: e.quickReplyButton.id,
            subtype: 'quick_reply'
          });
        }
        if (e.urlButton) {
          return new Store.templateButton({
            id: r,
            displayText: e.urlButton.displayText,
            url: e.urlButton?.url,
            subtype: 'url'
          });
        }
        if (e.callButton) {
          return new Store.templateButton({
            id: r,
            displayText: e.callButton.displayText,
            phoneNumber: e.callButton.phoneNumber,
            subtype: 'call'
          });
        }
      })
    );

    var result = (
      await Promise.all(window.Store.addAndSendMsgToChat(chat, message))
    )[1];
    if (result === 'success' || result === 'OK') {
      return WAPI.scope(newMsgId, false, result, null);
    } else {
      return WAPI.scope(newMsgId, true, result, null);
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/send-video-as-gif.js`:

```js
import { processFiles } from './process-files';
import { base64ToFile } from '../helper';

/**
 * Sends video as a gif to given chat id
 * @param {string} dataBase64
 * @param {string} chatid
 * @param {string} filename
 * @param {string} caption
 * @param {Function} done Optional callback
 */
export async function sendVideoAsGif(
  dataBase64,
  chatid,
  filename,
  caption,
  done
) {
  // const idUser = new window.Store.UserConstructor(chatid);
  const idUser = new Store.WidFactory.createWid(chatid);
  await Store.Chat.add(
    {
      createdLocally: true,
      id: idUser
    },
    {
      merge: true
    }
  );
  return Store.Chat.find(idUser).then((chat) => {
    var mediaBlob = base64ToFile(dataBase64, filename);
    processFiles(chat, mediaBlob).then((mc) => {
      var media = mc.models[0];
      media.mediaPrep._mediaData.isGif = true;
      media.mediaPrep._mediaData.gifAttribution = 1;
      media.mediaPrep.sendToChat(chat, { caption: caption });
      if (done !== undefined) done(true);
    });
  });
}

```

`src/lib/wapi/functions/sendMessageOptions.js`:

```js
/**
 * Send message with options
 * @param {string} chatid the numberid xxx@c.us
 * @param {string} content the message
 * @param {string} options object aditionais
 */
export async function sendMessageOptions(chatId, content, options = {}) {
  const chat = Store.Chat.get(chatId);
  let attOptions = {};
  if (options.attachment) {
    attOptions = await WWebJS.processMediaData(
      options.attachment,
      options.sendAudioAsVoice
    );
    content = attOptions.preview;
    delete options.attachment;
  }

  let quotedMsgOptions = {};
  if (options.quotedMessageId) {
    let quotedMessage = await WAPI.getMessageById(
      options.quotedMessageId,
      null,
      false
    );
    if (quotedMessage && quotedMessage.canReply()) {
      quotedMsgOptions = quotedMessage.msgContextInfo(chat);
    }
    delete options.quotedMessageId;
  }

  if (options.mentionedJidList) {
    options.mentionedJidList = options.mentionedJidList.map(
      (cId) => window.Store.Contact.get(cId).id
    );
  }

  let locationOptions = {};
  if (options.location) {
    locationOptions = {
      type: 'location',
      loc: options.location.description,
      lat: options.location.latitude,
      lng: options.location.longitude
    };
    delete options.location;
  }

  let vcardOptions = {};
  if (options.contactCard) {
    let contact = window.Store.Contact.get(options.contactCard);
    vcardOptions = {
      body: window.Store.VCard.vcardFromContactModel(contact).vcard,
      type: 'vcard',
      vcardFormattedName: contact.formattedName
    };
    delete options.contactCard;
  } else if (options.contactCardList) {
    let contacts = options.contactCardList.map((c) =>
      window.Store.Contact.get(c)
    );
    let vcards = contacts.map((c) =>
      window.Store.VCard.vcardFromContactModel(c)
    );
    vcardOptions = {
      type: 'multi_vcard',
      vcardList: vcards,
      body: undefined
    };
    delete options.contactCardList;
  } else if (
    options.parseVCards &&
    typeof content === 'string' &&
    content.startsWith('BEGIN:VCARD')
  ) {
    delete options.parseVCards;
    try {
      const parsed = await window.Store.VCard.parseVcard(content);
      if (parsed) {
        vcardOptions = {
          type: 'vcard',
          vcardFormattedName: await window.Store.VCard.vcardGetNameFromParsed(
            parsed
          )
        };
      }
    } catch (_) {
      // not a vcard
    }
  }

  if (options.linkPreview) {
    delete options.linkPreview;
    const link = await window.Store.Validators.findLink(content);
    if (link) {
      const preview = await window.Store.Wap2.default.queryLinkPreview(
        link.url
      );
      preview.preview = true;
      preview.subtype = 'url';
      options = { ...options, ...preview };
    }
  }
  const newMsgId = await window.WAPI.getNewMessageId(chat.id);
  const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();
  const message = {
    ...options,
    id: newMsgId,
    ack: 0,
    body: content,
    from: fromwWid,
    to: chat.id,
    local: !0,
    self: 'out',
    t: parseInt(new Date().getTime() / 1000),
    isNewMsg: !0,
    type: 'chat',
    ...locationOptions,
    ...attOptions,
    ...quotedMsgOptions,
    ...vcardOptions
  };

  await window.Store.addAndSendMsgToChat(chat, message);

  return newMsgId._serialized;
}

```

`src/lib/wapi/functions/set-group-description.js`:

```js
/**
 * Parameters to change group description
 * @param {string} groupId group number
 * @param {string} description group description
 */
export async function setGroupDescription(groupId, description) {
  if (typeof description != 'string' || description.length === 0) {
    return WAPI.scope(
      undefined,
      true,
      null,
      'It is necessary to write a text!'
    );
  }
  const chat = await WAPI.sendExist(groupId);
  if (chat && chat.status != 404) {
    const m = { type: 'setGroupDescription', description };
    const To = await WAPI.getchatId(chat.id);
    return Store.GroupDesc.setGroupDesc(chat, description)
      .then(() => {
        const obj = WAPI.scope(To, false, 'OK', description);
        Object.assign(obj, m);
        return obj;
      })
      .catch(() => {
        const obj = WAPI.scope(To, true, 'error', description);
        Object.assign(obj, m);
        return obj;
      });
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/set-group-image.js`:

```js
/**
 * Parameters to change group image
 * @param {object} path of image
 * @param {string} groupId group number
 */
export async function setGroupImage(obj, groupId) {
  const nameFunc = new Error().stack
    .match(/at (.*?) /)[1]
    .replace('Object.', '');
  if (typeof groupId !== 'string' || groupId.length === 0) {
    return WAPI.scope(groupId, true, 400, 'You must pass the group groupId!');
  }
  const chat = await WAPI.sendExist(groupId);
  if (chat && chat.status != 404) {
    groupId = new Store.WidFactory.createWid(groupId);
    let base64 = 'data:image/jpeg;base64,';
    try {
      const sendPinture = await Store.Profile.sendSetPicture(
        groupId,
        base64 + obj.b,
        base64 + obj.a
      );
      return WAPI.scope(
        groupId,
        false,
        200,
        `Image changed successfully`,
        nameFunc,
        sendPinture
      );
    } catch {
      return WAPI.scope(
        groupId,
        true,
        400,
        `Unable to change image`,
        nameFunc,
        null
      );
    }
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/set-group-settings.js`:

```js
/**
 * Parameters to change group title
 * @param {string} groupId group number
 * @param {GroupSettings} settings
 * @param {boolean} value
 */
export async function setGroupSettings(groupId, settings, value) {
  if (typeof settings != 'string' || settings.length === 0) {
    return WAPI.scope(
      undefined,
      true,
      null,
      'It is necessary to write a settings!'
    );
  }
  const chat = await WAPI.sendExist(groupId);
  if (chat && chat.status != 404) {
    const m = { type: 'setGroupSettings', settings };
    const To = await WAPI.getchatId(chat.id);
    const Value = { type: 'setGroupSettings', value };
    return window.Store.GroupSettings.sendSetGroupProperty(
      chat.id,
      settings,
      value
    )
      .then(() => {
        const obj = WAPI.scope(To, false, 'OK', m, Value);
        Object.assign(obj, m);
        return obj;
      })
      .catch(() => {
        const obj = WAPI.scope(To, true, 'error', m, Value);
        Object.assign(obj, m);
        return obj;
      });
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/set-group-title.js`:

```js
/**
 * Parameters to change group title
 * @param {string} groupId group number
 * @param {string} title group name
 */
export async function setGroupTitle(groupId, title) {
  if (typeof title != 'string' || title.length === 0) {
    return WAPI.scope(
      undefined,
      true,
      null,
      'It is necessary to write a text!'
    );
  }
  const chat = await WAPI.sendExist(groupId);
  if (chat && chat.status != 404) {
    const m = { type: 'setGroupTitle', title };
    const To = await WAPI.getchatId(chat.id);
    return window.Store.GroupTitle.sendSetGroupSubject(chat.id, title)
      .then(() => {
        const obj = WAPI.scope(To, false, 'OK', title);
        Object.assign(obj, m);
        return obj;
      })
      .catch(() => {
        const obj = WAPI.scope(To, true, 'error', title);
        Object.assign(obj, m);
        return obj;
      });
  } else {
    return chat;
  }
}

```

`src/lib/wapi/functions/set-my-name.js`:

```js
export async function setMyName(name) {
  await window.Store.Perfil.setPushname(name);
}

```

`src/lib/wapi/functions/set-my-status.js`:

```js
export function setMyStatus(status) {
  return Store.MyStatus.setMyStatus(status);
}

```

`src/lib/wapi/functions/set-new-message.js`:

```js
export async function setNewMessageId(info, checkNumber = true) {
  if (
    info &&
    typeof info === 'object' &&
    info.number &&
    info._serialized &&
    info.id
  ) {
    const chat = checkNumber
      ? await WAPI.sendExist(info.number)
      : await WAPI.returnChat(info.number);
    delete info.number;
    if (chat.id) {
      const newMsgId = new Object();
      newMsgId.fromMe = true;
      newMsgId.id = info.id;
      newMsgId.remote = await new Store.WidFactory.createWid(
        chat.id._serialized
      );
      newMsgId._serialized = `${newMsgId.fromMe}_${newMsgId.remote}_${newMsgId.id}`;
      const Msgkey = await new Store.MsgKey(newMsgId);
      return Msgkey;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

```

`src/lib/wapi/functions/set-presence-offline.js`:

```js
export async function setPresenceOffline() {
  await Store.Presence.setPresenceUnavailable();
  return true;
}

```

`src/lib/wapi/functions/set-presence-online.js`:

```js
export async function setPresenceOnline() {
  await Store.Presence.setPresenceAvailable();
  return true;
}

```

`src/lib/wapi/functions/set-profile-pic.js`:

```js
export async function setProfilePic(obj, id) {
  if (!id) {
    id = await Store.MaybeMeUser.getMaybeMeUser();
  } else {
    id = new Store.WidFactory.createWid(id);
  }
  let base64 = 'data:image/jpeg;base64,';
  return await Store.Profile.sendSetPicture(id, base64 + obj.b, base64 + obj.a);
}

```

`src/lib/wapi/functions/simulate-status-chat.js`:

```js
/**
 * Start Typing
 * @param chatId
 * @param checkNumber the number when submitting!
 */
export async function startTyping(chatId, checkNumber = true) {
  const chat = checkNumber
    ? await WAPI.sendExist(chatId)
    : await WAPI.returnChat(chatId);
  if (chat && chat.status != 404 && chat.id) {
    await WAPI.presenceAvailable();
    const result = await Store.SetStatusChat.markComposing(chat);
    return WAPI.scope(undefined, false, result);
  }
  if (!chat.erro) {
    chat.erro = true;
  }
  return chat;
}

/**
 * Start Recording audio
 * @param chatId
 * @param checkNumber the number when submitting!
 */
export async function startRecording(chatId, checkNumber = true) {
  const chat = checkNumber
    ? await WAPI.sendExist(chatId)
    : await WAPI.returnChat(chatId);
  if (chat && chat.status != 404 && chat.id) {
    await WAPI.presenceAvailable();
    const result = await Store.SetStatusChat.markRecording(chat);
    return WAPI.scope(undefined, false, result);
  }
  if (!chat.erro) {
    chat.erro = true;
  }
  return chat;
}

/**
 * Stop Recording audio
 * @param chatId
 * @param checkNumber the number when submitting!
 */
export async function markPaused(chatId, checkNumber = true) {
  const chat = checkNumber
    ? await WAPI.sendExist(chatId)
    : await WAPI.returnChat(chatId);
  if (chat && chat.status != 404 && chat.id) {
    await WAPI.presenceAvailable();
    const result = await Store.SetStatusChat.markPaused(chat);
    return WAPI.scope(undefined, false, result);
  }
  if (!chat.erro) {
    chat.erro = true;
  }
  return chat;
}

/**
 * @param chatId
 * @param checkNumber the number when submitting!
 */
export async function clearPresence(chatId, checkNumber = true) {
  const chat = checkNumber
    ? await WAPI.sendExist(chatId)
    : await WAPI.returnChat(chatId);
  if (chat && chat.status != 404 && chat.id) {
    const result = await Store.SetStatusChat.clearPresence(chat);
    return WAPI.scope(undefined, false, result);
  }
  if (!chat.erro) {
    chat.erro = true;
  }
  return chat;
}

export async function presenceAvailable() {
  return await Store.SetStatusChat.sendPresenceAvailable();
}

export async function presenceUnavailable() {
  return await Store.SetStatusChat.sendPresenceUnavailable();
}

```

`src/lib/wapi/functions/simulate-typing.js`:

```js
export async function startTyping(chatId) {
  const chat = window.Store.WidFactory.createWid(chatId);
  if (!chat) {
    throw {
      error: true,
      code: 'chat_not_found',
      message: 'Chat not found',
      chatId: chatId
    };
  }
  await Store.ChatState.sendChatStateComposing(chat);
  return { status: 200 };
}

/**
 * Stops typing
 * @param {string} chatId
 */
export async function stopTyping(chatId) {
  const chat = window.Store.WidFactory.createWid(chatId);
  if (!chat) {
    throw {
      error: true,
      code: 'chat_not_found',
      message: 'Chat not found',
      chatId: chatId
    };
  }
  await Store.ChatState.sendChatStatePaused(chat);
  return { status: 200 };
}

```

`src/lib/wapi/functions/test.js`:

```js
async function test() {
  const chat = await WAPI.sendExist('556999626866@c.us');

  if (chat && chat.status != 404 && chat.id) {
    const newMsgId = await window.WAPI.getNewMessageId(chat.id._serialized);
    const fromwWid = await Store.MaybeMeUser.getMaybeMeUser();

    let inChat = await WAPI.getchatId(chat.id).catch(() => {
      return WAPI.scope(chat.id, true, 404, 'Error to number ' + chat);
    });

    if (inChat) {
      chat.lastReceivedKey && chat.lastReceivedKey._serialized
        ? (chat.lastReceivedKey._serialized = inChat._serialized)
        : '';
      chat.lastReceivedKey && chat.lastReceivedKey.id
        ? (chat.lastReceivedKey.id = inChat.id)
        : '';
    }

    const message = {
      id: newMsgId,
      ack: 0,
      from: fromwWid,
      to: chat.id,
      local: !0,
      self: 'out',
      t: parseInt(new Date().getTime() / 1000),
      footer: 'test?',
      caption: 'test?',
      body: 'test?',
      text: 'test?',
      type: 'chat',
      isNewMsg: !0,

      isFromTemplate: true,
      isMdHistoryMsg: true,
      hydratedButtons: [
        {
          index: 1,
          quickReplyButton: {
            displayText: 'Sim',
            id: 'ID1'
          }
        }
      ]
    };

    return await window.Store.addAndSendMsgToChat(chat, message);
  }
}

```

`src/lib/wapi/functions/theme.js`:

```js
export async function setTheme(type) {
  if (type == 'dark' || type == 'light') {
    await Store.Theme.setTheme(type);
    return true;
  } else {
    return console.error('Use type dark or light');
  }
}

export async function getTheme() {
  return await Store.Theme.getTheme();
}

```

`src/lib/wapi/functions/unblock-contact.js`:

```js
export async function unblockContact(_id) {
  if (!_id) {
    return false;
  }
  const __contact = window.Store.Contact.get(_id);
  if (__contact !== undefined) {
    await Store.Block.unblockContact(__contact);
    return true;
  } else {
    return false;
  }
}

```

`src/lib/wapi/globals.d.ts`:

```ts
declare module global {
  interface Window {
    Store: any;
  }
}

```

`src/lib/wapi/help/array-buffer-to-base64.js`:

```js
export function arrayBufferToBase64(arrayBuffer) {
  var base64 = '';
  var encodings =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  var bytes = new Uint8Array(arrayBuffer);
  var byteLength = bytes.byteLength;
  var byteRemainder = byteLength % 3;
  var mainLength = byteLength - byteRemainder;

  var a, b, c, d;
  var chunk;

  // Main loop deals with bytes in chunks of 3
  for (var i = 0; i < mainLength; i = i + 3) {
    // Combine the three bytes into a single integer
    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

    // Use bitmasks to extract 6-bit segments from the triplet
    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
    d = chunk & 63; // 63       = 2^6 - 1

    // Convert the raw binary segments to the appropriate ASCII encoding
    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
  }

  // Deal with the remaining bytes and padding
  if (byteRemainder == 1) {
    chunk = bytes[mainLength];

    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

    // Set the 4 least significant bits to zero
    b = (chunk & 3) << 4; // 3   = 2^2 - 1

    base64 += encodings[a] + encodings[b] + '==';
  } else if (byteRemainder == 2) {
    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4

    // Set the 2 least significant bits to zero
    c = (chunk & 15) << 2; // 15    = 2^4 - 1

    base64 += encodings[a] + encodings[b] + encodings[c] + '=';
  }
  return base64;
}

```

`src/lib/wapi/help/base64ToFile.js`:

```js
export function base64ToFile(base64, filename) {
  try {
    const arr = base64.split(',');
    let mime = arr[0].match(/(?:data:)?(.*?)(?:;base64)?$/i)[1];
    mime = mime.split(/\s+;\s+/).join('; '); // Fix spaces, like "audio/ogg; codecs=opus"

    const bstr = window.Base64 ? window.Base64.atob(arr[1]) : atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);

    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }

    return new File([u8arr], filename, {
      type: mime
    });
  } catch {
    return false;
  }
}

```

`src/lib/wapi/help/encrypt-and-upload-file.js`:

```js
export async function encryptAndUploadFile(type, blob) {
  try {
    const filehash = await WAPI.getFileHash(blob);
    const mediaKey = WAPI.generateMediaKey(32);
    const controller = new AbortController();
    const signal = controller.signal;
    const encrypted = await Store.UploadUtils.encryptAndUpload({
      blob,
      type,
      signal,
      mediaKey
    });
    return {
      ...encrypted,
      clientUrl: encrypted.url,
      filehash,
      id: filehash,
      uploadhash: encrypted.encFilehash,
      mediaBlob: blob
    };
  } catch {
    return false;
  }
}

```

`src/lib/wapi/help/filter-module.js`:

```js
export async function filterModule(filterObjects, modules) {
  let found = 0;
  for (let i in modules) {
    if (typeof modules[i] === 'object' && modules[i] !== null) {
      filterObjects.forEach((needObj) => {
        if (!needObj.when | needObj.yesModule) return;

        const checkObj = needObj.when(modules[i]);
        if (checkObj !== null) {
          found++;
          needObj.yesModule = checkObj;
        }
      });
      if (found == filterObjects.length) {
        break;
      }
    }
  }
  return filterObjects;
}

```

`src/lib/wapi/help/filter-object.js`:

```js
export const filterObjects = [
  {
    type: 'Module',
    when: (module) =>
      module.default && module.default.Chat && module.default.Msg
        ? module.default
        : null
  },
  {
    type: 'addAndSendMsgToChat',
    when: (module) =>
      module.addAndSendMsgToChat ? module.addAndSendMsgToChat : null
  },
  {
    type: 'WidFactory',
    when: (module) =>
      module.isWidlike && module.createWid && module.createWidFromWidLike
        ? module
        : null
  },
  {
    type: 'UserConstructor',
    when: (module) =>
      module.default &&
      module.default.prototype &&
      module.default.prototype.isServer &&
      module.default.prototype.isUser
        ? module.default
        : null
  },
  {
    type: 'WidFactory',
    when: (module) =>
      module.isWidlike && module.createWid && module.createWidFromWidLike
        ? module
        : null
  },
  {
    type: 'MsgKey',
    when: (module) =>
      module.default &&
      module.default.toString &&
      typeof module.default.toString === 'function' &&
      module.default.toString().includes('MsgKey error: obj is null/undefined')
        ? module.default
        : null
  },
  {
    type: 'State',
    when: (module) => (module.Socket ? module : null)
  },
  {
    type: 'addAndSendMsgToChat',
    when: (module) =>
      module.addAndSendMsgToChat ? module.addAndSendMsgToChat : null
  },
  {
    type: 'checkNumber',
    when: (module) =>
      module.default && module.default.queryExist ? module.default : null
  },
  {
    type: 'checkNumberMD',
    when: (module) =>
      module.queryExists && module.queryPhoneExists ? module : null
  },
  {
    type: 'ReadSeen',
    when: (module) => (module.sendSeen ? module : null)
  },
  {
    type: 'Stream',
    when: (module) =>
      module.Stream && module.StreamInfo ? module.Stream : null
  },
  {
    type: 'MediaCollection',
    when: (module) =>
      module.default &&
      module.default.prototype &&
      (module.default.prototype.processFiles !== undefined ||
        module.default.prototype.processAttachments !== undefined)
        ? module.default
        : null
  },
  {
    type: 'UploadUtils',
    when: (module) =>
      module.default && module.default.encryptAndUpload ? module.default : null
  },
  {
    type: 'blob',
    when: (module) =>
      module.default && module.default.createFromData ? module : null
  },
  {
    type: 'createGroup',
    when: (module) =>
      module.createGroup && module.sendForNeededAddRequest
        ? module.createGroup
        : null
  },
  {
    type: 'GroupDesc',
    when: (module) => (module.setGroupDesc ? module : null)
  },
  {
    type: 'CheckWid',
    when: (module) => (module.validateWid ? module : null)
  },
  {
    type: 'Participants',
    when: (module) =>
      module.addParticipants && module.promoteCommunityParticipants
        ? module
        : null
  },
  {
    type: 'MyStatus',
    when: (module) => (module.getStatus && module.setMyStatus ? module : null)
  },
  {
    type: 'Profile',
    when: (module) =>
      module.sendSetPicture && module.requestDeletePicture ? module : null
  },
  {
    type: 'Contacts',
    when: (module) => (module.ContactCollection ? module : null)
  }
];

```

`src/lib/wapi/help/generate-media-key.js`:

```js
export function generateMediaKey(length) {
  let result = '';
  let characters =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

```

`src/lib/wapi/help/get-file-hash.js`:

```js
import * as jsSHA from '../jssha';
export async function getFileHash(data) {
  let buffer = await data.arrayBuffer();
  var sha = new jsSHA('SHA-256', 'ARRAYBUFFER');
  sha.update(buffer);
  return sha.getHash('B64');
}

```

`src/lib/wapi/help/index.js`:

```js
export { sleep } from './sleep';
export { injectParasiteSnake } from './inject-paresite';
export { processFiles } from './process-files';
export { base64ToFile } from './base64ToFile';
export { generateMediaKey } from './generate-media-key';
export { arrayBufferToBase64 } from './array-buffer-to-base64';
export { getFileHash } from './get-file-hash';
export { encryptAndUploadFile } from './encrypt-and-upload-file';
export { filterModule } from './filter-module';

export { injectConfig } from './inject-config';
export { filterObjects } from './filter-object';

```

`src/lib/wapi/help/inject-config.js`:

```js
export const injectConfig = {
  webpack: 'webpackChunkwhatsapp_web_client',
  parasite: Math.random().toString(36).substring(7)
};

```

`src/lib/wapi/help/inject-paresite.js`:

```js
import { injectConfig, filterObjects, filterModule } from './index';
export const injectParasiteSnake = async () => {
  window[injectConfig.webpack].push([
    [injectConfig.parasite],
    {},
    async function (e) {
      const modules = []; // modules whatsapp array
      Object.keys(e.m).forEach(function (mod) {
        modules[mod] = e(mod);
      });

      const filterMod = await filterModule(filterObjects, modules);

      filterMod.forEach((needObj) => {
        if (needObj.yesModule) {
          if (needObj.type !== 'Module') {
            if (!Store[needObj.type]) {
              Store[needObj.type] = needObj.yesModule;
            }
          }
        }
      });

      const module = filterMod.filter((e) => e.type === 'Module')[0].yesModule;
      Object.keys(module).forEach((key) => {
        if (!['Chat'].includes(key)) {
          if (Store[key]) {
            Store[key + '_'] = module[key];
          } else {
            Store[key] = module[key];
          }
        }
      });
    }
  ]);
};

```

`src/lib/wapi/help/process-files.js`:

```js
export async function processFiles(chat, blobs) {
  if (!Array.isArray(blobs)) {
    blobs = [blobs];
  }

  const mediaCollection = new Store.MediaCollection({
    chatParticipantCount: chat.getParticipantCount()
  });

  await mediaCollection.processAttachments(
    Debug.VERSION === '0.4.613'
      ? blobs
      : blobs.map((blob) => {
          return {
            file: blob
          };
        }),
    chat,
    1
  );

  return mediaCollection;
}

```

`src/lib/wapi/help/sleep.js`:

```js
export function sleep(time) {
  try {
    return new Promise((resolve) => setTimeout(resolve, time));
  } catch (e) {}
}

```

`src/lib/wapi/helper/array-buffer-to-base64.js`:

```js
export function arrayBufferToBase64(arrayBuffer) {
  var base64 = '';
  var encodings =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  var bytes = new Uint8Array(arrayBuffer);
  var byteLength = bytes.byteLength;
  var byteRemainder = byteLength % 3;
  var mainLength = byteLength - byteRemainder;

  var a, b, c, d;
  var chunk;

  // Main loop deals with bytes in chunks of 3
  for (var i = 0; i < mainLength; i = i + 3) {
    // Combine the three bytes into a single integer
    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

    // Use bitmasks to extract 6-bit segments from the triplet
    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
    d = chunk & 63; // 63       = 2^6 - 1

    // Convert the raw binary segments to the appropriate ASCII encoding
    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
  }

  // Deal with the remaining bytes and padding
  if (byteRemainder == 1) {
    chunk = bytes[mainLength];

    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

    // Set the 4 least significant bits to zero
    b = (chunk & 3) << 4; // 3   = 2^2 - 1

    base64 += encodings[a] + encodings[b] + '==';
  } else if (byteRemainder == 2) {
    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4

    // Set the 2 least significant bits to zero
    c = (chunk & 15) << 2; // 15    = 2^4 - 1

    base64 += encodings[a] + encodings[b] + encodings[c] + '=';
  }
  return base64;
}

```

`src/lib/wapi/helper/base64-to-file.js`:

```js
export function base64ToFile(base64, filename) {
  try {
    const arr = base64.split(',');
    let mime = arr[0].match(/(?:data:)?(.*?)(?:;base64)?$/i)[1];
    mime = mime.split(/\s+;\s+/).join('; '); // Fix spaces, like "audio/ogg; codecs=opus"

    const bstr = window.Base64 ? window.Base64.atob(arr[1]) : atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);

    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }

    return new File([u8arr], filename, {
      type: mime
    });
  } catch {
    return false;
  }
}

```

`src/lib/wapi/helper/filter-module.js`:

```js
export async function filterModule(filterObjects, modules) {
  let found = 0;
  for (let i in modules) {
    if (typeof modules[i] === 'object' && modules[i] !== null) {
      filterObjects.forEach((needObj) => {
        if (!needObj.when | needObj.yesModule) return;

        const checkObj = needObj.when(modules[i]);
        if (checkObj !== null) {
          found++;
          needObj.yesModule = checkObj;
        }
      });
      if (found == filterObjects.length) {
        break;
      }
    }
  }
  return filterObjects;
}

```

`src/lib/wapi/helper/filter-object.js`:

```js
export const filterObjects = [
  {
    type: 'Chat',
    when: (module) =>
      module.default && module.default.Chat && module.default.Msg
        ? module.default.Chat
        : null
  },
  {
    type: 'MaybeMeUser',
    when: (module) => (module.getMaybeMeUser ? module : null)
  },
  {
    type: 'Participants',
    when: (module) =>
      module.addParticipants && module.promoteCommunityParticipants
        ? module
        : null
  },
  {
    type: 'checkNumber',
    when: (module) => (module.queryExist ? module : null)
  },
  {
    type: 'checkNumberBeta',
    when: (module) => (module.queryPhoneExists ? module : null)
  }
];

```

`src/lib/wapi/helper/generate-media-key.js`:

```js
export function generateMediaKey(length) {
  let result = '';
  let characters =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

```

`src/lib/wapi/helper/get-file-hash.js`:

```js
import * as jsSHA from '../jssha';
export async function getFileHash(data) {
  let buffer = await data.arrayBuffer();
  var sha = new jsSHA('SHA-256', 'ARRAYBUFFER');
  sha.update(buffer);
  return sha.getHash('B64');
}

```

`src/lib/wapi/helper/index.js`:

```js
export { base64ToFile } from './base64-to-file';
export { getFileHash } from './get-file-hash';
export { generateMediaKey } from './generate-media-key';
export { arrayBufferToBase64 } from './array-buffer-to-base64';
export { sleep } from './sleep';

export { injectConfig } from './inject-config';
export { filterObjects } from './filter-object';
export { filterModule } from './filter-module';

```

`src/lib/wapi/helper/inject-config.js`:

```js
export const injectConfig = {
  webpack: 'webpackChunkwhatsapp_web_client',
  parasite: Math.random().toString(36).substring(7)
};

```

`src/lib/wapi/helper/is-chat-message.js`:

```js
export function isChatMessage(message) {
  if (message.isSentByMe) {
    return false;
  }
  if (message.isNotification) {
    return false;
  }
  if (!message.isUserCreatedType) {
    return false;
  }
  return true;
}

```

`src/lib/wapi/helper/sleep.js`:

```js
export function sleep(time) {
  try {
    return new Promise((resolve) => setTimeout(resolve, time));
  } catch (e) {}
}

```

`src/lib/wapi/jsconfig.json`:

```json
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es6"
  }
}
```

`src/lib/wapi/jssha/index.js`:

```js
'use strict';
(function (aa) {
  function C(e, b, a) {
    var k = 0,
      h = [],
      l = 0,
      g,
      m,
      c,
      f,
      n,
      q,
      u,
      r,
      I = !1,
      v = [],
      x = [],
      t,
      y = !1,
      z = !1,
      w = -1;
    a = a || {};
    g = a.encoding || 'UTF8';
    t = a.numRounds || 1;
    if (t !== parseInt(t, 10) || 1 > t)
      throw Error('numRounds must a integer >= 1');
    if ('SHA-1' === e)
      (n = 512),
        (q = K),
        (u = ba),
        (f = 160),
        (r = function (b) {
          return b.slice();
        });
    else if (0 === e.lastIndexOf('SHA-', 0))
      if (
        ((q = function (b, k) {
          return L(b, k, e);
        }),
        (u = function (b, k, h, a) {
          var d, f;
          if ('SHA-224' === e || 'SHA-256' === e)
            (d = (((k + 65) >>> 9) << 4) + 15), (f = 16);
          else if ('SHA-384' === e || 'SHA-512' === e)
            (d = (((k + 129) >>> 10) << 5) + 31), (f = 32);
          else throw Error('Unexpected error in SHA-2 implementation');
          for (; b.length <= d; ) b.push(0);
          b[k >>> 5] |= 128 << (24 - (k % 32));
          k = k + h;
          b[d] = k & 4294967295;
          b[d - 1] = (k / 4294967296) | 0;
          h = b.length;
          for (k = 0; k < h; k += f) a = L(b.slice(k, k + f), a, e);
          if ('SHA-224' === e) b = [a[0], a[1], a[2], a[3], a[4], a[5], a[6]];
          else if ('SHA-256' === e) b = a;
          else if ('SHA-384' === e)
            b = [
              a[0].a,
              a[0].b,
              a[1].a,
              a[1].b,
              a[2].a,
              a[2].b,
              a[3].a,
              a[3].b,
              a[4].a,
              a[4].b,
              a[5].a,
              a[5].b
            ];
          else if ('SHA-512' === e)
            b = [
              a[0].a,
              a[0].b,
              a[1].a,
              a[1].b,
              a[2].a,
              a[2].b,
              a[3].a,
              a[3].b,
              a[4].a,
              a[4].b,
              a[5].a,
              a[5].b,
              a[6].a,
              a[6].b,
              a[7].a,
              a[7].b
            ];
          else throw Error('Unexpected error in SHA-2 implementation');
          return b;
        }),
        (r = function (b) {
          return b.slice();
        }),
        'SHA-224' === e)
      )
        (n = 512), (f = 224);
      else if ('SHA-256' === e) (n = 512), (f = 256);
      else if ('SHA-384' === e) (n = 1024), (f = 384);
      else if ('SHA-512' === e) (n = 1024), (f = 512);
      else throw Error('Chosen SHA variant is not supported');
    else if (
      0 === e.lastIndexOf('SHA3-', 0) ||
      0 === e.lastIndexOf('SHAKE', 0)
    ) {
      var F = 6;
      q = D;
      r = function (b) {
        var e = [],
          a;
        for (a = 0; 5 > a; a += 1) e[a] = b[a].slice();
        return e;
      };
      w = 1;
      if ('SHA3-224' === e) (n = 1152), (f = 224);
      else if ('SHA3-256' === e) (n = 1088), (f = 256);
      else if ('SHA3-384' === e) (n = 832), (f = 384);
      else if ('SHA3-512' === e) (n = 576), (f = 512);
      else if ('SHAKE128' === e) (n = 1344), (f = -1), (F = 31), (z = !0);
      else if ('SHAKE256' === e) (n = 1088), (f = -1), (F = 31), (z = !0);
      else throw Error('Chosen SHA variant is not supported');
      u = function (b, e, a, k, h) {
        a = n;
        var d = F,
          f,
          g = [],
          l = a >>> 5,
          m = 0,
          c = e >>> 5;
        for (f = 0; f < c && e >= a; f += l)
          (k = D(b.slice(f, f + l), k)), (e -= a);
        b = b.slice(f);
        for (e %= a; b.length < l; ) b.push(0);
        f = e >>> 3;
        b[f >> 2] ^= d << ((f % 4) * 8);
        b[l - 1] ^= 2147483648;
        for (k = D(b, k); 32 * g.length < h; ) {
          b = k[m % 5][(m / 5) | 0];
          g.push(b.b);
          if (32 * g.length >= h) break;
          g.push(b.a);
          m += 1;
          0 === (64 * m) % a && D(null, k);
        }
        return g;
      };
    } else throw Error('Chosen SHA variant is not supported');
    c = M(b, g, w);
    m = A(e);
    this.setHMACKey = function (b, a, h) {
      var d;
      if (!0 === I) throw Error('HMAC key already set');
      if (!0 === y) throw Error('Cannot set HMAC key after calling update');
      if (!0 === z) throw Error('SHAKE is not supported for HMAC');
      g = (h || {}).encoding || 'UTF8';
      a = M(a, g, w)(b);
      b = a.binLen;
      a = a.value;
      d = n >>> 3;
      h = d / 4 - 1;
      if (d < b / 8) {
        for (a = u(a, b, 0, A(e), f); a.length <= h; ) a.push(0);
        a[h] &= 4294967040;
      } else if (d > b / 8) {
        for (; a.length <= h; ) a.push(0);
        a[h] &= 4294967040;
      }
      for (b = 0; b <= h; b += 1)
        (v[b] = a[b] ^ 909522486), (x[b] = a[b] ^ 1549556828);
      m = q(v, m);
      k = n;
      I = !0;
    };
    this.update = function (b) {
      var a,
        e,
        d,
        f = 0,
        g = n >>> 5;
      a = c(b, h, l);
      b = a.binLen;
      e = a.value;
      a = b >>> 5;
      for (d = 0; d < a; d += g)
        f + n <= b && ((m = q(e.slice(d, d + g), m)), (f += n));
      k += f;
      h = e.slice(f >>> 5);
      l = b % n;
      y = !0;
    };
    this.getHash = function (b, a) {
      var d, g, c, n;
      if (!0 === I) throw Error('Cannot call getHash after setting HMAC key');
      c = N(a);
      if (!0 === z) {
        if (-1 === c.shakeLen)
          throw Error('shakeLen must be specified in options');
        f = c.shakeLen;
      }
      switch (b) {
        case 'HEX':
          d = function (b) {
            return O(b, f, w, c);
          };
          break;
        case 'B64':
          d = function (b) {
            return P(b, f, w, c);
          };
          break;
        case 'BYTES':
          d = function (b) {
            return Q(b, f, w);
          };
          break;
        case 'ARRAYBUFFER':
          try {
            g = new ArrayBuffer(0);
          } catch (p) {
            throw Error('ARRAYBUFFER not supported by this environment');
          }
          d = function (b) {
            return R(b, f, w);
          };
          break;
        case 'UINT8ARRAY':
          try {
            g = new Uint8Array(0);
          } catch (p) {
            throw Error('UINT8ARRAY not supported by this environment');
          }
          d = function (b) {
            return S(b, f, w);
          };
          break;
        default:
          throw Error(
            'format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY'
          );
      }
      n = u(h.slice(), l, k, r(m), f);
      for (g = 1; g < t; g += 1)
        !0 === z &&
          0 !== f % 32 &&
          (n[n.length - 1] &= 16777215 >>> (24 - (f % 32))),
          (n = u(n, f, 0, A(e), f));
      return d(n);
    };
    this.getHMAC = function (b, a) {
      var d, g, c, p;
      if (!1 === I)
        throw Error('Cannot call getHMAC without first setting HMAC key');
      c = N(a);
      switch (b) {
        case 'HEX':
          d = function (b) {
            return O(b, f, w, c);
          };
          break;
        case 'B64':
          d = function (b) {
            return P(b, f, w, c);
          };
          break;
        case 'BYTES':
          d = function (b) {
            return Q(b, f, w);
          };
          break;
        case 'ARRAYBUFFER':
          try {
            d = new ArrayBuffer(0);
          } catch (v) {
            throw Error('ARRAYBUFFER not supported by this environment');
          }
          d = function (b) {
            return R(b, f, w);
          };
          break;
        case 'UINT8ARRAY':
          try {
            d = new Uint8Array(0);
          } catch (v) {
            throw Error('UINT8ARRAY not supported by this environment');
          }
          d = function (b) {
            return S(b, f, w);
          };
          break;
        default:
          throw Error(
            'outputFormat must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY'
          );
      }
      g = u(h.slice(), l, k, r(m), f);
      p = q(x, A(e));
      p = u(g, f, n, p, f);
      return d(p);
    };
  }
  function a(a, b) {
    this.a = a;
    this.b = b;
  }
  function T(a, b, d, k) {
    var h, l, g, c, p;
    b = b || [0];
    d = d || 0;
    l = d >>> 3;
    p = -1 === k ? 3 : 0;
    for (h = 0; h < a.length; h += 1)
      (c = h + l),
        (g = c >>> 2),
        b.length <= g && b.push(0),
        (b[g] |= a[h] << (8 * (p + (c % 4) * k)));
    return { value: b, binLen: 8 * a.length + d };
  }
  function O(a, b, d, k) {
    var h = '';
    b /= 8;
    var l, g, c;
    c = -1 === d ? 3 : 0;
    for (l = 0; l < b; l += 1)
      (g = a[l >>> 2] >>> (8 * (c + (l % 4) * d))),
        (h +=
          '0123456789abcdef'.charAt((g >>> 4) & 15) +
          '0123456789abcdef'.charAt(g & 15));
    return k.outputUpper ? h.toUpperCase() : h;
  }
  function P(a, b, d, k) {
    var h = '',
      l = b / 8,
      g,
      c,
      p,
      f;
    f = -1 === d ? 3 : 0;
    for (g = 0; g < l; g += 3)
      for (
        c = g + 1 < l ? a[(g + 1) >>> 2] : 0,
          p = g + 2 < l ? a[(g + 2) >>> 2] : 0,
          p =
            (((a[g >>> 2] >>> (8 * (f + (g % 4) * d))) & 255) << 16) |
            (((c >>> (8 * (f + ((g + 1) % 4) * d))) & 255) << 8) |
            ((p >>> (8 * (f + ((g + 2) % 4) * d))) & 255),
          c = 0;
        4 > c;
        c += 1
      )
        8 * g + 6 * c <= b
          ? (h +=
              'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.charAt(
                (p >>> (6 * (3 - c))) & 63
              ))
          : (h += k.b64Pad);
    return h;
  }
  function Q(a, b, d) {
    var k = '';
    b /= 8;
    var h, c, g;
    g = -1 === d ? 3 : 0;
    for (h = 0; h < b; h += 1)
      (c = (a[h >>> 2] >>> (8 * (g + (h % 4) * d))) & 255),
        (k += String.fromCharCode(c));
    return k;
  }
  function R(a, b, d) {
    b /= 8;
    var k,
      h = new ArrayBuffer(b),
      c,
      g;
    g = new Uint8Array(h);
    c = -1 === d ? 3 : 0;
    for (k = 0; k < b; k += 1)
      g[k] = (a[k >>> 2] >>> (8 * (c + (k % 4) * d))) & 255;
    return h;
  }
  function S(a, b, d) {
    b /= 8;
    var k,
      h = new Uint8Array(b),
      c;
    c = -1 === d ? 3 : 0;
    for (k = 0; k < b; k += 1)
      h[k] = (a[k >>> 2] >>> (8 * (c + (k % 4) * d))) & 255;
    return h;
  }
  function N(a) {
    var b = { outputUpper: !1, b64Pad: '=', shakeLen: -1 };
    a = a || {};
    b.outputUpper = a.outputUpper || !1;
    !0 === a.hasOwnProperty('b64Pad') && (b.b64Pad = a.b64Pad);
    if (!0 === a.hasOwnProperty('shakeLen')) {
      if (0 !== a.shakeLen % 8) throw Error('shakeLen must be a multiple of 8');
      b.shakeLen = a.shakeLen;
    }
    if ('boolean' !== typeof b.outputUpper)
      throw Error('Invalid outputUpper formatting option');
    if ('string' !== typeof b.b64Pad)
      throw Error('Invalid b64Pad formatting option');
    return b;
  }
  function M(a, b, d) {
    switch (b) {
      case 'UTF8':
      case 'UTF16BE':
      case 'UTF16LE':
        break;
      default:
        throw Error('encoding must be UTF8, UTF16BE, or UTF16LE');
    }
    switch (a) {
      case 'HEX':
        a = function (b, a, e) {
          var g = b.length,
            c,
            p,
            f,
            n,
            q,
            u;
          if (0 !== g % 2)
            throw Error('String of HEX type must be in byte increments');
          a = a || [0];
          e = e || 0;
          q = e >>> 3;
          u = -1 === d ? 3 : 0;
          for (c = 0; c < g; c += 2) {
            p = parseInt(b.substr(c, 2), 16);
            if (isNaN(p))
              throw Error('String of HEX type contains invalid characters');
            n = (c >>> 1) + q;
            for (f = n >>> 2; a.length <= f; ) a.push(0);
            a[f] |= p << (8 * (u + (n % 4) * d));
          }
          return { value: a, binLen: 4 * g + e };
        };
        break;
      case 'TEXT':
        a = function (a, e, c) {
          var g,
            m,
            p = 0,
            f,
            n,
            q,
            u,
            r,
            t;
          e = e || [0];
          c = c || 0;
          q = c >>> 3;
          if ('UTF8' === b)
            for (t = -1 === d ? 3 : 0, f = 0; f < a.length; f += 1)
              for (
                g = a.charCodeAt(f),
                  m = [],
                  128 > g
                    ? m.push(g)
                    : 2048 > g
                    ? (m.push(192 | (g >>> 6)), m.push(128 | (g & 63)))
                    : 55296 > g || 57344 <= g
                    ? m.push(
                        224 | (g >>> 12),
                        128 | ((g >>> 6) & 63),
                        128 | (g & 63)
                      )
                    : ((f += 1),
                      (g =
                        65536 +
                        (((g & 1023) << 10) | (a.charCodeAt(f) & 1023))),
                      m.push(
                        240 | (g >>> 18),
                        128 | ((g >>> 12) & 63),
                        128 | ((g >>> 6) & 63),
                        128 | (g & 63)
                      )),
                  n = 0;
                n < m.length;
                n += 1
              ) {
                r = p + q;
                for (u = r >>> 2; e.length <= u; ) e.push(0);
                e[u] |= m[n] << (8 * (t + (r % 4) * d));
                p += 1;
              }
          else if ('UTF16BE' === b || 'UTF16LE' === b)
            for (
              t = -1 === d ? 2 : 0,
                m =
                  ('UTF16LE' === b && 1 !== d) || ('UTF16LE' !== b && 1 === d),
                f = 0;
              f < a.length;
              f += 1
            ) {
              g = a.charCodeAt(f);
              !0 === m && ((n = g & 255), (g = (n << 8) | (g >>> 8)));
              r = p + q;
              for (u = r >>> 2; e.length <= u; ) e.push(0);
              e[u] |= g << (8 * (t + (r % 4) * d));
              p += 2;
            }
          return { value: e, binLen: 8 * p + c };
        };
        break;
      case 'B64':
        a = function (b, a, e) {
          var c = 0,
            m,
            p,
            f,
            n,
            q,
            u,
            r,
            t;
          if (-1 === b.search(/^[a-zA-Z0-9=+\/]+$/))
            throw Error('Invalid character in base-64 string');
          p = b.indexOf('=');
          b = b.replace(/\=/g, '');
          if (-1 !== p && p < b.length)
            throw Error("Invalid '=' found in base-64 string");
          a = a || [0];
          e = e || 0;
          u = e >>> 3;
          t = -1 === d ? 3 : 0;
          for (p = 0; p < b.length; p += 4) {
            q = b.substr(p, 4);
            for (f = n = 0; f < q.length; f += 1)
              (m =
                'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.indexOf(
                  q.charAt(f)
                )),
                (n |= m << (18 - 6 * f));
            for (f = 0; f < q.length - 1; f += 1) {
              r = c + u;
              for (m = r >>> 2; a.length <= m; ) a.push(0);
              a[m] |= ((n >>> (16 - 8 * f)) & 255) << (8 * (t + (r % 4) * d));
              c += 1;
            }
          }
          return { value: a, binLen: 8 * c + e };
        };
        break;
      case 'BYTES':
        a = function (b, a, e) {
          var c, m, p, f, n, q;
          a = a || [0];
          e = e || 0;
          p = e >>> 3;
          q = -1 === d ? 3 : 0;
          for (m = 0; m < b.length; m += 1)
            (c = b.charCodeAt(m)),
              (n = m + p),
              (f = n >>> 2),
              a.length <= f && a.push(0),
              (a[f] |= c << (8 * (q + (n % 4) * d)));
          return { value: a, binLen: 8 * b.length + e };
        };
        break;
      case 'ARRAYBUFFER':
        try {
          a = new ArrayBuffer(0);
        } catch (k) {
          throw Error('ARRAYBUFFER not supported by this environment');
        }
        a = function (b, a, e) {
          return T(new Uint8Array(b), a, e, d);
        };
        break;
      case 'UINT8ARRAY':
        try {
          a = new Uint8Array(0);
        } catch (k) {
          throw Error('UINT8ARRAY not supported by this environment');
        }
        a = function (b, a, e) {
          return T(b, a, e, d);
        };
        break;
      default:
        throw Error(
          'format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY'
        );
    }
    return a;
  }
  function y(a, b) {
    return (a << b) | (a >>> (32 - b));
  }
  function U(e, b) {
    return 32 < b
      ? ((b -= 32),
        new a((e.b << b) | (e.a >>> (32 - b)), (e.a << b) | (e.b >>> (32 - b))))
      : 0 !== b
      ? new a((e.a << b) | (e.b >>> (32 - b)), (e.b << b) | (e.a >>> (32 - b)))
      : e;
  }
  function x(a, b) {
    return (a >>> b) | (a << (32 - b));
  }
  function t(e, b) {
    var d = null,
      d = new a(e.a, e.b);
    return (d =
      32 >= b
        ? new a(
            (d.a >>> b) | ((d.b << (32 - b)) & 4294967295),
            (d.b >>> b) | ((d.a << (32 - b)) & 4294967295)
          )
        : new a(
            (d.b >>> (b - 32)) | ((d.a << (64 - b)) & 4294967295),
            (d.a >>> (b - 32)) | ((d.b << (64 - b)) & 4294967295)
          ));
  }
  function V(e, b) {
    var d = null;
    return (d =
      32 >= b
        ? new a(e.a >>> b, (e.b >>> b) | ((e.a << (32 - b)) & 4294967295))
        : new a(0, e.a >>> (b - 32)));
  }
  function ca(a, b, d) {
    return (a & b) ^ (~a & d);
  }
  function da(e, b, d) {
    return new a((e.a & b.a) ^ (~e.a & d.a), (e.b & b.b) ^ (~e.b & d.b));
  }
  function W(a, b, d) {
    return (a & b) ^ (a & d) ^ (b & d);
  }
  function ea(e, b, d) {
    return new a(
      (e.a & b.a) ^ (e.a & d.a) ^ (b.a & d.a),
      (e.b & b.b) ^ (e.b & d.b) ^ (b.b & d.b)
    );
  }
  function fa(a) {
    return x(a, 2) ^ x(a, 13) ^ x(a, 22);
  }
  function ga(e) {
    var b = t(e, 28),
      d = t(e, 34);
    e = t(e, 39);
    return new a(b.a ^ d.a ^ e.a, b.b ^ d.b ^ e.b);
  }
  function ha(a) {
    return x(a, 6) ^ x(a, 11) ^ x(a, 25);
  }
  function ia(e) {
    var b = t(e, 14),
      d = t(e, 18);
    e = t(e, 41);
    return new a(b.a ^ d.a ^ e.a, b.b ^ d.b ^ e.b);
  }
  function ja(a) {
    return x(a, 7) ^ x(a, 18) ^ (a >>> 3);
  }
  function ka(e) {
    var b = t(e, 1),
      d = t(e, 8);
    e = V(e, 7);
    return new a(b.a ^ d.a ^ e.a, b.b ^ d.b ^ e.b);
  }
  function la(a) {
    return x(a, 17) ^ x(a, 19) ^ (a >>> 10);
  }
  function ma(e) {
    var b = t(e, 19),
      d = t(e, 61);
    e = V(e, 6);
    return new a(b.a ^ d.a ^ e.a, b.b ^ d.b ^ e.b);
  }
  function G(a, b) {
    var d = (a & 65535) + (b & 65535);
    return (
      ((((a >>> 16) + (b >>> 16) + (d >>> 16)) & 65535) << 16) | (d & 65535)
    );
  }
  function na(a, b, d, k) {
    var h = (a & 65535) + (b & 65535) + (d & 65535) + (k & 65535);
    return (
      ((((a >>> 16) + (b >>> 16) + (d >>> 16) + (k >>> 16) + (h >>> 16)) &
        65535) <<
        16) |
      (h & 65535)
    );
  }
  function H(a, b, d, k, h) {
    var c = (a & 65535) + (b & 65535) + (d & 65535) + (k & 65535) + (h & 65535);
    return (
      ((((a >>> 16) +
        (b >>> 16) +
        (d >>> 16) +
        (k >>> 16) +
        (h >>> 16) +
        (c >>> 16)) &
        65535) <<
        16) |
      (c & 65535)
    );
  }
  function oa(e, b) {
    var d, k, c;
    d = (e.b & 65535) + (b.b & 65535);
    k = (e.b >>> 16) + (b.b >>> 16) + (d >>> 16);
    c = ((k & 65535) << 16) | (d & 65535);
    d = (e.a & 65535) + (b.a & 65535) + (k >>> 16);
    k = (e.a >>> 16) + (b.a >>> 16) + (d >>> 16);
    return new a(((k & 65535) << 16) | (d & 65535), c);
  }
  function pa(e, b, d, k) {
    var c, l, g;
    c = (e.b & 65535) + (b.b & 65535) + (d.b & 65535) + (k.b & 65535);
    l = (e.b >>> 16) + (b.b >>> 16) + (d.b >>> 16) + (k.b >>> 16) + (c >>> 16);
    g = ((l & 65535) << 16) | (c & 65535);
    c =
      (e.a & 65535) +
      (b.a & 65535) +
      (d.a & 65535) +
      (k.a & 65535) +
      (l >>> 16);
    l = (e.a >>> 16) + (b.a >>> 16) + (d.a >>> 16) + (k.a >>> 16) + (c >>> 16);
    return new a(((l & 65535) << 16) | (c & 65535), g);
  }
  function qa(e, b, d, k, c) {
    var l, g, m;
    l =
      (e.b & 65535) +
      (b.b & 65535) +
      (d.b & 65535) +
      (k.b & 65535) +
      (c.b & 65535);
    g =
      (e.b >>> 16) +
      (b.b >>> 16) +
      (d.b >>> 16) +
      (k.b >>> 16) +
      (c.b >>> 16) +
      (l >>> 16);
    m = ((g & 65535) << 16) | (l & 65535);
    l =
      (e.a & 65535) +
      (b.a & 65535) +
      (d.a & 65535) +
      (k.a & 65535) +
      (c.a & 65535) +
      (g >>> 16);
    g =
      (e.a >>> 16) +
      (b.a >>> 16) +
      (d.a >>> 16) +
      (k.a >>> 16) +
      (c.a >>> 16) +
      (l >>> 16);
    return new a(((g & 65535) << 16) | (l & 65535), m);
  }
  function B(e, b) {
    return new a(e.a ^ b.a, e.b ^ b.b);
  }
  function A(e) {
    var b = [],
      d;
    if ('SHA-1' === e)
      b = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    else if (0 === e.lastIndexOf('SHA-', 0))
      switch (
        ((b = [
          3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025,
          1694076839, 3204075428
        ]),
        (d = [
          1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
          2600822924, 528734635, 1541459225
        ]),
        e)
      ) {
        case 'SHA-224':
          break;
        case 'SHA-256':
          b = d;
          break;
        case 'SHA-384':
          b = [
            new a(3418070365, b[0]),
            new a(1654270250, b[1]),
            new a(2438529370, b[2]),
            new a(355462360, b[3]),
            new a(1731405415, b[4]),
            new a(41048885895, b[5]),
            new a(3675008525, b[6]),
            new a(1203062813, b[7])
          ];
          break;
        case 'SHA-512':
          b = [
            new a(d[0], 4089235720),
            new a(d[1], 2227873595),
            new a(d[2], 4271175723),
            new a(d[3], 1595750129),
            new a(d[4], 2917565137),
            new a(d[5], 725511199),
            new a(d[6], 4215389547),
            new a(d[7], 327033209)
          ];
          break;
        default:
          throw Error('Unknown SHA variant');
      }
    else if (0 === e.lastIndexOf('SHA3-', 0) || 0 === e.lastIndexOf('SHAKE', 0))
      for (e = 0; 5 > e; e += 1)
        b[e] = [
          new a(0, 0),
          new a(0, 0),
          new a(0, 0),
          new a(0, 0),
          new a(0, 0)
        ];
    else throw Error('No SHA variants supported');
    return b;
  }
  function K(a, b) {
    var d = [],
      k,
      c,
      l,
      g,
      m,
      p,
      f;
    k = b[0];
    c = b[1];
    l = b[2];
    g = b[3];
    m = b[4];
    for (f = 0; 80 > f; f += 1)
      (d[f] =
        16 > f ? a[f] : y(d[f - 3] ^ d[f - 8] ^ d[f - 14] ^ d[f - 16], 1)),
        (p =
          20 > f
            ? H(y(k, 5), (c & l) ^ (~c & g), m, 1518500249, d[f])
            : 40 > f
            ? H(y(k, 5), c ^ l ^ g, m, 1859775393, d[f])
            : 60 > f
            ? H(y(k, 5), W(c, l, g), m, 2400959708, d[f])
            : H(y(k, 5), c ^ l ^ g, m, 3395469782, d[f])),
        (m = g),
        (g = l),
        (l = y(c, 30)),
        (c = k),
        (k = p);
    b[0] = G(k, b[0]);
    b[1] = G(c, b[1]);
    b[2] = G(l, b[2]);
    b[3] = G(g, b[3]);
    b[4] = G(m, b[4]);
    return b;
  }
  function ba(a, b, d, c) {
    var h;
    for (h = (((b + 65) >>> 9) << 4) + 15; a.length <= h; ) a.push(0);
    a[b >>> 5] |= 128 << (24 - (b % 32));
    b += d;
    a[h] = b & 4294967295;
    a[h - 1] = (b / 4294967296) | 0;
    b = a.length;
    for (h = 0; h < b; h += 16) c = K(a.slice(h, h + 16), c);
    return c;
  }
  function L(e, b, d) {
    var k,
      h,
      l,
      g,
      m,
      p,
      f,
      n,
      q,
      u,
      r,
      t,
      v,
      x,
      y,
      A,
      z,
      w,
      F,
      B,
      C,
      D,
      E = [],
      J;
    if ('SHA-224' === d || 'SHA-256' === d)
      (u = 64),
        (t = 1),
        (D = Number),
        (v = G),
        (x = na),
        (y = H),
        (A = ja),
        (z = la),
        (w = fa),
        (F = ha),
        (C = W),
        (B = ca),
        (J = c);
    else if ('SHA-384' === d || 'SHA-512' === d)
      (u = 80),
        (t = 2),
        (D = a),
        (v = oa),
        (x = pa),
        (y = qa),
        (A = ka),
        (z = ma),
        (w = ga),
        (F = ia),
        (C = ea),
        (B = da),
        (J = X);
    else throw Error('Unexpected error in SHA-2 implementation');
    d = b[0];
    k = b[1];
    h = b[2];
    l = b[3];
    g = b[4];
    m = b[5];
    p = b[6];
    f = b[7];
    for (r = 0; r < u; r += 1)
      16 > r
        ? ((q = r * t),
          (n = e.length <= q ? 0 : e[q]),
          (q = e.length <= q + 1 ? 0 : e[q + 1]),
          (E[r] = new D(n, q)))
        : (E[r] = x(z(E[r - 2]), E[r - 7], A(E[r - 15]), E[r - 16])),
        (n = y(f, F(g), B(g, m, p), J[r], E[r])),
        (q = v(w(d), C(d, k, h))),
        (f = p),
        (p = m),
        (m = g),
        (g = v(l, n)),
        (l = h),
        (h = k),
        (k = d),
        (d = v(n, q));
    b[0] = v(d, b[0]);
    b[1] = v(k, b[1]);
    b[2] = v(h, b[2]);
    b[3] = v(l, b[3]);
    b[4] = v(g, b[4]);
    b[5] = v(m, b[5]);
    b[6] = v(p, b[6]);
    b[7] = v(f, b[7]);
    return b;
  }
  function D(e, b) {
    var d,
      c,
      h,
      l,
      g = [],
      m = [];
    if (null !== e)
      for (c = 0; c < e.length; c += 2)
        b[(c >>> 1) % 5][((c >>> 1) / 5) | 0] = B(
          b[(c >>> 1) % 5][((c >>> 1) / 5) | 0],
          new a(e[c + 1], e[c])
        );
    for (d = 0; 24 > d; d += 1) {
      l = A('SHA3-');
      for (c = 0; 5 > c; c += 1) {
        h = b[c][0];
        var p = b[c][1],
          f = b[c][2],
          n = b[c][3],
          q = b[c][4];
        g[c] = new a(h.a ^ p.a ^ f.a ^ n.a ^ q.a, h.b ^ p.b ^ f.b ^ n.b ^ q.b);
      }
      for (c = 0; 5 > c; c += 1) m[c] = B(g[(c + 4) % 5], U(g[(c + 1) % 5], 1));
      for (c = 0; 5 > c; c += 1)
        for (h = 0; 5 > h; h += 1) b[c][h] = B(b[c][h], m[c]);
      for (c = 0; 5 > c; c += 1)
        for (h = 0; 5 > h; h += 1)
          l[h][(2 * c + 3 * h) % 5] = U(b[c][h], Y[c][h]);
      for (c = 0; 5 > c; c += 1)
        for (h = 0; 5 > h; h += 1)
          b[c][h] = B(
            l[c][h],
            new a(
              ~l[(c + 1) % 5][h].a & l[(c + 2) % 5][h].a,
              ~l[(c + 1) % 5][h].b & l[(c + 2) % 5][h].b
            )
          );
      b[0][0] = B(b[0][0], Z[d]);
    }
    return b;
  }
  var c, X, Y, Z;
  c = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298
  ];
  X = [
    new a(c[0], 3609767458),
    new a(c[1], 602891725),
    new a(c[2], 3964484399),
    new a(c[3], 2173295548),
    new a(c[4], 4081628472),
    new a(c[5], 3053834265),
    new a(c[6], 2937671579),
    new a(c[7], 3664609560),
    new a(c[8], 2734883394),
    new a(c[9], 1164996542),
    new a(c[10], 1323610764),
    new a(c[11], 3590304994),
    new a(c[12], 4068182383),
    new a(c[13], 991336113),
    new a(c[14], 633803317),
    new a(c[15], 3479774868),
    new a(c[16], 2666613458),
    new a(c[17], 944711139),
    new a(c[18], 2341262773),
    new a(c[19], 2007800933),
    new a(c[20], 1495990901),
    new a(c[21], 1856431235),
    new a(c[22], 3175218132),
    new a(c[23], 2198950837),
    new a(c[24], 3999719339),
    new a(c[25], 766784016),
    new a(c[26], 2566594879),
    new a(c[27], 3203337956),
    new a(c[28], 1034457026),
    new a(c[29], 2466948901),
    new a(c[30], 3758326383),
    new a(c[31], 168717936),
    new a(c[32], 1188179964),
    new a(c[33], 1546045734),
    new a(c[34], 1522805485),
    new a(c[35], 2643833823),
    new a(c[36], 2343527390),
    new a(c[37], 1014477480),
    new a(c[38], 1206759142),
    new a(c[39], 344077627),
    new a(c[40], 1290863460),
    new a(c[41], 3158454273),
    new a(c[42], 3505952657),
    new a(c[43], 106217008),
    new a(c[44], 3606008344),
    new a(c[45], 1432725776),
    new a(c[46], 1467031594),
    new a(c[47], 851169720),
    new a(c[48], 3100823752),
    new a(c[49], 1363258195),
    new a(c[50], 3750685593),
    new a(c[51], 3785050280),
    new a(c[52], 3318307427),
    new a(c[53], 3812723403),
    new a(c[54], 2003034995),
    new a(c[55], 3602036899),
    new a(c[56], 1575990012),
    new a(c[57], 1125592928),
    new a(c[58], 2716904306),
    new a(c[59], 442776044),
    new a(c[60], 593698344),
    new a(c[61], 3733110249),
    new a(c[62], 2999351573),
    new a(c[63], 3815920427),
    new a(3391569614, 3928383900),
    new a(3515267271, 566280711),
    new a(3940187606, 3454069534),
    new a(4118630271, 4000239992),
    new a(116418474, 1914138554),
    new a(174292421, 2731055270),
    new a(289380356, 3203993006),
    new a(460393269, 320620315),
    new a(685471733, 587496836),
    new a(852142971, 1086792851),
    new a(1017036298, 365543100),
    new a(1126000580, 2618297676),
    new a(1288033470, 3409855158),
    new a(1501505948, 4234509866),
    new a(1607167915, 987167468),
    new a(1816402316, 1246189591)
  ];
  Z = [
    new a(0, 1),
    new a(0, 32898),
    new a(2147483648, 32906),
    new a(2147483648, 2147516416),
    new a(0, 32907),
    new a(0, 2147483649),
    new a(2147483648, 2147516545),
    new a(2147483648, 32777),
    new a(0, 138),
    new a(0, 136),
    new a(0, 2147516425),
    new a(0, 2147483658),
    new a(0, 2147516555),
    new a(2147483648, 139),
    new a(2147483648, 32905),
    new a(2147483648, 32771),
    new a(2147483648, 32770),
    new a(2147483648, 128),
    new a(0, 32778),
    new a(2147483648, 2147483658),
    new a(2147483648, 2147516545),
    new a(2147483648, 32896),
    new a(0, 2147483649),
    new a(2147483648, 2147516424)
  ];
  Y = [
    [0, 36, 3, 41, 18],
    [1, 44, 10, 45, 2],
    [62, 6, 43, 15, 61],
    [28, 55, 25, 21, 56],
    [27, 20, 39, 8, 14]
  ];
  'function' === typeof define && define.amd
    ? define(function () {
        return C;
      })
    : 'undefined' !== typeof exports
    ? ('undefined' !== typeof module && module.exports && (module.exports = C),
      (exports = C))
    : (aa.jsSHA = C);
})(this);

```

`src/lib/wapi/listeners/add-new-messages.js`:

```js
export function addNewMessagesListener() {
  window.WAPI.waitNewMessages = waitNewMessages;
}

/**
 * Registers a callback to be called when a new message arrives the WAPI.
 * @param rmCallbackAfterUse - Boolean - Specify if the callback need to be executed only once
 * @param done - function - Callback function to be called when a new message arrives.
 * @returns {boolean}
 */
function waitNewMessages(rmCallbackAfterUse = true, done) {
  window.WAPI._newMessagesCallbacks.push({
    callback: (e) => {
      done(e);
    },
    rmAfterUse: rmCallbackAfterUse
  });
  return true;
}

```

`src/lib/wapi/listeners/add-on-added-to-group.js`:

```js
export function addOnAddedToGroup() {
  /**
   * Registers a callback that fires when your host phone is added to a group.
   * @param callback - function - Callback function to be called when a message acknowledgement changes. The callback returns 3 variables
   * @returns {boolean}
   */
  window.WAPI.onAddedToGroup = function (callback) {
    window.WAPI.waitForStore(['Chat', 'Msg'], () => {
      Store.Chat.on('add', (chatObject) => {
        if (chatObject && chatObject.isGroup) {
          callback(chatObject);
        }
      });
    });
    return true;
  };
}

```

`src/lib/wapi/listeners/add-on-chatstate-change.js`:

```js
export function addonChatState() {
  window.WAPI.onChatState = function (callback) {
    window.WAPI.waitForStore(['Chat'], () => {
      Store.Chat.on('change:presence.chatstate.type', (e) => {
        const event = e._events.all[0].context;
        const obj = {
          id: event.id,
          isGroup: event.isGroup,
          isUser: event.isUser,
          type: e.type
        };
        callback(obj);
      });
    });
    return true;
  };
}

```

`src/lib/wapi/listeners/add-on-live-location.js`:

```js
export function addOnLiveLocation() {
  window.WAPI.onLiveLocation = async function (chatId, callback) {
    return await window.WAPI.waitForStore(['LiveLocation'], () => {
      var lLChat = Store.LiveLocation.get(chatId);
      if (lLChat) {
        var validLocs = lLChat.participants.validLocations();
        validLocs.map((x) =>
          x.on('change:lastUpdated', (x, y, z) => {
            console.log(x, y, z);
            const { id, lat, lng, accuracy, degrees, speed, lastUpdated } = x;
            const l = {
              id: id.toString(),
              lat,
              lng,
              accuracy,
              degrees,
              speed,
              lastUpdated
            };
            // console.log('newloc',l)
            callback(l);
          })
        );
        return true;
      } else {
        return false;
      }
    });
  };
}

```

`src/lib/wapi/listeners/add-on-new-ack.js`:

```js
export function addOnNewAcks() {
  window.WAPI.onAck = function (callback) {
    window.WAPI.waitForStore(['Chat', 'Msg'], () => {
      Store.Msg.on('change:ack', (e) => {
        callback(e);
      });
    });
    return true;
  };
}

```

`src/lib/wapi/listeners/add-on-participants-change.js`:

```js
let groupParticpiantsEvents = {};

/**
 * Registers on participants change listener
 */
export function addOnParticipantsChange() {
  /**
   * Registers a callback to participant changes on a certain, specific group
   * @param groupId - string - The id of the group that you want to attach the callback to.
   * @param callback - function - Callback function to be called when a message acknowledgement changes. The callback returns 3 variables
   * @returns {boolean}
   */
  window.WAPI.onParticipantsChanged = async function (groupId, callback) {
    return await window.WAPI.waitForStore(['Chat', 'Msg'], () => {
      const subtypeEvents = [
        'invite',
        'add',
        'remove',
        'leave',
        'promote',
        'demote'
      ];
      const chat = window.Store.Chat.get(groupId);
      //attach all group Participants to the events object as 'add'
      const metadata = window.Store.GroupMetadata.get(groupId);
      if (!groupParticpiantsEvents[groupId]) {
        groupParticpiantsEvents[groupId] = {};
        metadata.participants.forEach((participant) => {
          groupParticpiantsEvents[groupId][participant.id.toString()] = {
            subtype: 'add',
            from: metadata.owner
          };
        });
      }
      let i = 0;
      chat.on('change:groupMetadata.participants', (_) =>
        chat.on('all', (x, y) => {
          const { isGroup, previewMessage } = y;
          if (
            isGroup &&
            x === 'change' &&
            previewMessage &&
            previewMessage.type === 'gp2' &&
            subtypeEvents.includes(previewMessage.subtype)
          ) {
            const { subtype, from, recipients } = previewMessage;
            const rec = recipients[0].toString();
            if (
              groupParticpiantsEvents[groupId][rec] &&
              groupParticpiantsEvents[groupId][recipients[0]].subtype == subtype
            ) {
              //ignore, this is a duplicate entry
              // console.log('duplicate event')
            } else {
              //ignore the first message
              if (i == 0) {
                //ignore it, plus 1,
                i++;
              } else {
                groupParticpiantsEvents[groupId][rec] = {
                  subtype,
                  from
                };
                //fire the callback
                // // previewMessage.from.toString()
                // x removed y
                // x added y
                callback({
                  by: from.toString(),
                  action: subtype,
                  who: recipients
                });
                chat.off('all', this);
                i = 0;
              }
            }
          }
        })
      );
      return true;
    });
  };
}

```

`src/lib/wapi/listeners/add-on-pictumb-change.js`:

```js
export function addonFilePicThumb() {
  window.WAPI.onFilePicThumb = function (callback) {
    Store.ProfilePicThumb.on('change:img', (e) => {
      const obj = {
        attributes: e.attributes,
        eurl: e.eurl,
        eurlStale: e.eurlStale,
        fallbackType: e.fallbackType,
        id: e.id,
        img: e.img,
        imgFull: e.imgFull,
        isState: e.isState,
        pendingPic: e.pendingPic,
        raw: e.raw,
        stale: e.stale,
        tag: e.tag,
        token: e.token
      };
      callback(obj);
    });

    return true;
  };
}

```

`src/lib/wapi/listeners/add-on-poll.js`:

```js
export function addOnPoll() {
  window.WAPI.onPoll = function (callback) {
    Store.PollVote.on('change', (e) => {
      callback(e);
    });
    return true;
  };
}

```

`src/lib/wapi/listeners/add-on-state-change.js`:

```js
export function addOnStateChange() {
  let initialized = false;
  const getData = () => {
    return window.Store.State.Socket.state;
  };

  window.WAPI.onStateChange = function (callback) {
    window.WAPI.waitForStore('State', () => {
      window.Store.State.Socket.on('change:state', () => callback(getData()));
      if (!initialized) {
        initialized = true;
        callback(getData());
      }
    });
    return true;
  };
}

export function addOnStreamChange() {
  let initialized = false;
  let getData = () => {
    return window.Store.State.Socket.stream;
  };

  window.WAPI.onStreamChange = function (callback) {
    window.WAPI.waitForStore('State', () => {
      window.Store.State.Socket.on('change:stream', () => callback(getData()));
      if (!initialized) {
        initialized = true;
        callback(getData());
      }
    });
    return true;
  };
}

```

`src/lib/wapi/listeners/add-on-stream.js`:

```js
export function addOnStream() {
  let initialized = false;
  const getData = () => {
    return {
      displayInfo: window.Store.Stream.displayInfo,
      mode: window.Store.Stream.mode,
      info: window.Store.Stream.info
    };
  };

  window.WAPI.onInterfaceChange = (callback) => {
    window.WAPI.waitForStore('Stream', () => {
      window.Store.Stream.on('change:info change:displayInfo change:mode', () =>
        callback(getData())
      );
      if (initialized === false) {
        initialized = true;
        callback(getData());
      }
    });
    return true;
  };
}

```

`src/lib/wapi/listeners/add-unread-message.js`:

```js
export function addonUnreadMessage() {
  window.WAPI.onUnreadMessage = function (callback) {
    Store.Chat.on('change:unreadCount', async (e) => {
      if (e.unreadCount > 0) {
        let arr = [];
        let t = e.msgs._models.slice(-e.unreadCount);
        for (let r in t) {
          let message = await WAPI.processMessageObj(t[r], true, true);
          if (message) {
            arr.push(message);
          }
        }
        callback(arr);
      }
    });
    return true;
  };
}

```

`src/lib/wapi/listeners/index.js`:

```js
export { initNewMessagesListener } from './init-listeners';
export { addNewMessagesListener } from './add-new-messages';
export { addOnStateChange, addOnStreamChange } from './add-on-state-change';
export { addOnNewAcks } from './add-on-new-ack';
export { addOnLiveLocation } from './add-on-live-location';
export { addOnParticipantsChange } from './add-on-participants-change';
export { addOnAddedToGroup } from './add-on-added-to-group';
export { addonFilePicThumb } from './add-on-pictumb-change';
export { addonChatState } from './add-on-chatstate-change';
export { addonUnreadMessage } from './add-unread-message';
export { addOnStream } from './add-on-stream';
export { addOnPoll } from './add-on-poll';

```

`src/lib/wapi/listeners/init-common-listener.js`:

```js
export function initNewMessagesListener() {
  window.WAPI._newMessagesListener = window.Store.Msg.on(
    'add',
    async (newMessage) => {
      if (newMessage && newMessage.isNewMsg && !newMessage.isSentByMe) {
        let message = await window.WAPI.processMessageObj(
          newMessage,
          false,
          false
        );
        if (message) {
          window.WAPI._newMessagesQueue.push(message);
          window.WAPI._newMessagesBuffer.push(message);
        }

        // Starts debouncer time to don't call a callback for each message if more than one message arrives
        // in the same second
        if (
          !window.WAPI._newMessagesDebouncer &&
          window.WAPI._newMessagesQueue.length > 0
        ) {
          window.WAPI._newMessagesDebouncer = setTimeout(() => {
            let queuedMessages = window.WAPI._newMessagesQueue;

            window.WAPI._newMessagesDebouncer = null;
            window.WAPI._newMessagesQueue = [];

            let removeCallbacks = [];

            window.WAPI._newMessagesCallbacks.forEach(function (callbackObj) {
              if (callbackObj.callback !== undefined) {
                callbackObj.callback(queuedMessages);
              }
              if (callbackObj.rmAfterUse === true) {
                removeCallbacks.push(callbackObj);
              }
            });

            // Remove removable callbacks.
            removeCallbacks.forEach(function (rmCallbackObj) {
              let callbackIndex =
                window.WAPI._newMessagesCallbacks.indexOf(rmCallbackObj);
              window.WAPI._newMessagesCallbacks.splice(callbackIndex, 1);
            });
          }, 1000);
        }
      }
    }
  );

  window.WAPI._unloadInform = (event) => {
    // Save in the buffer the ungot unreaded messages
    window.WAPI._newMessagesBuffer.forEach((message) => {
      Object.keys(message).forEach((key) =>
        message[key] === undefined ? delete message[key] : ''
      );
    });
    sessionStorage.setItem(
      'saved_msgs',
      JSON.stringify(window.WAPI._newMessagesBuffer)
    );

    // Inform callbacks that the page will be reloaded.
    window.WAPI._newMessagesCallbacks.forEach(function (callbackObj) {
      if (callbackObj.callback !== undefined) {
        callbackObj.callback({
          status: -1,
          message: 'page will be reloaded, wait and register callback again.'
        });
      }
    });
  };
}

```

`src/lib/wapi/listeners/init-listeners.js`:

```js
export function initNewMessagesListener() {
  window.WAPI.waitForStore(['Chat', 'Msg'], () => {
    window.WAPI._newMessagesListener = window.Store.Msg.on(
      'add',
      async (newMessage) => {
        if (newMessage && newMessage.isNewMsg && !newMessage.isSentByMe) {
          let message = await window.WAPI.processMessageObj(
            newMessage,
            false,
            false
          );
          if (message) {
            window.WAPI._newMessagesQueue.push(message);
            window.WAPI._newMessagesBuffer.push(message);
          }

          // Starts debouncer time to don't call a callback for each message if more than one message arrives
          // in the same second
          if (
            !window.WAPI._newMessagesDebouncer &&
            window.WAPI._newMessagesQueue.length > 0
          ) {
            window.WAPI._newMessagesDebouncer = setTimeout(() => {
              let queuedMessages = window.WAPI._newMessagesQueue;

              window.WAPI._newMessagesDebouncer = null;
              window.WAPI._newMessagesQueue = [];

              let removeCallbacks = [];

              window.WAPI._newMessagesCallbacks.forEach(function (callbackObj) {
                if (callbackObj.callback !== undefined) {
                  callbackObj.callback(queuedMessages);
                }
                if (callbackObj.rmAfterUse === true) {
                  removeCallbacks.push(callbackObj);
                }
              });

              // Remove removable callbacks.
              removeCallbacks.forEach(function (rmCallbackObj) {
                let callbackIndex =
                  window.WAPI._newMessagesCallbacks.indexOf(rmCallbackObj);
                window.WAPI._newMessagesCallbacks.splice(callbackIndex, 1);
              });
            }, 1000);
          }
        }
      }
    );
  });

  window.WAPI._unloadInform = (event) => {
    // Save in the buffer the ungot unreaded messages
    window.WAPI._newMessagesBuffer.forEach((message) => {
      Object.keys(message).forEach((key) =>
        message[key] === undefined ? delete message[key] : ''
      );
    });

    sessionStorage.setItem(
      'saved_msgs',
      JSON.stringify(window.WAPI._newMessagesBuffer)
    );

    // Inform callbacks that the page will be reloaded.
    window.WAPI._newMessagesCallbacks.forEach(function (callbackObj) {
      if (callbackObj.callback !== undefined) {
        callbackObj.callback({
          status: -1,
          message: 'page will be reloaded, wait and register callback again.'
        });
      }
    });
  };
}

```

`src/lib/wapi/serialize/index.js`:

```js
export { serializeMessageObj } from './serialize-message';
export { serializeChatObj } from './serialize-chat';
export { serializeContactObj } from './serialize-contact';
export { serializeProfilePicThumb } from './serialize-profile-pic-thumb';
export { serializeRawObj } from './serialize-raw';
export { serializeMeObj } from './serielize-me';

```

`src/lib/wapi/serialize/serialize-chat.js`:

```js
export const serializeChatObj = (obj) => {
  if (obj == undefined) {
    return null;
  }
  return Object.assign(WAPI.serializeRawObj(obj), {
    kind: obj.kind,
    isGroup: obj.isGroup,
    contact: obj['contact'] ? WAPI.serializeContactObj(obj['contact']) : null,
    groupMetadata: obj['groupMetadata']
      ? WAPI.serializeRawObj(obj['groupMetadata'])
      : null,
    presence: obj['presence'] ? WAPI.serializeRawObj(obj['presence']) : null,
    msgs: null,
    isOnline: obj.__x_presence.attributes.isOnline || null,
    lastSeen:
      obj &&
      obj.previewMessage &&
      obj.previewMessage.__x_ephemeralStartTimestamp
        ? obj.previewMessage.__x_ephemeralStartTimestamp * 1000
        : null
  });
};

```

`src/lib/wapi/serialize/serialize-contact.js`:

```js
export const serializeContactObj = (obj) => {
  if (obj == undefined) {
    return null;
  }

  if (!obj.profilePicThumb && obj.id && Store.ProfilePicThumb) {
    obj.profilePicThumb = Store.ProfilePicThumb.get(obj.id);
  }

  return Object.assign(WAPI.serializeRawObj(obj), {
    formattedName: obj.formattedName,
    displayName: obj.displayName,
    formattedShortName: obj.formattedShortName,
    formattedShortNameWithNonBreakingSpaces:
      obj.formattedShortNameWithNonBreakingSpaces,
    isHighLevelVerified: obj.isHighLevelVerified,
    isMe: obj.isMe,
    mentionName: obj.mentionName,
    notifyName: obj.notifyName,
    isMyContact: obj.isMyContact,
    isPSA: obj.isPSA,
    isUser: obj.isUser,
    isVerified: obj.isVerified,
    isWAContact: obj.isWAContact,
    profilePicThumbObj: obj.profilePicThumb
      ? WAPI.serializeProfilePicThumb(obj.profilePicThumb)
      : {},
    statusMute: obj.statusMute,
    msgs: null
  });
};

```

`src/lib/wapi/serialize/serialize-message.js`:

```js
export const serializeMessageObj = (obj) => {
  if (obj == undefined) {
    return null;
  }

  const chat = obj['chat'] ? WAPI.serializeChatObj(obj['chat']) : {};
  if (obj.quotedMsg) obj.quotedMsgObj();

  return Object.assign(WAPI.serializeRawObj(obj), {
    id: obj.id._serialized,
    from: obj.from._serialized,
    quotedParticipant: obj.quotedParticipant
      ? obj.quotedParticipant._serialized
        ? obj.quotedParticipant._serialized
        : undefined
      : undefined,
    author: obj.author
      ? obj.author._serialized
        ? obj.author._serialized
        : undefined
      : undefined,
    chatId:
      obj.id && obj.id.remote
        ? obj.id.remote
        : obj.chatId && obj.chatId._serialized
        ? obj.chatId._serialized
        : undefined,
    to: obj.to
      ? obj.to._serialized
        ? obj.to._serialized
        : undefined
      : undefined,
    isSentByMe: obj.isSentByMe,
    fromMe: obj.id.fromMe,
    sender: obj.senderObj ? WAPI.serializeContactObj(obj.senderObj) : null,
    timestamp: obj.t,
    content: obj.body,
    body: obj.body,
    isGroupMsg: obj.isGroupMsg,
    contact: obj.contact,
    isLink: obj.isLink,
    isMMS: obj.isMMS,
    isMedia: obj.isMedia,
    isNotification: obj.isNotification,
    isPSA: obj.isPSA,
    type: obj.type,
    chat: chat,
    isOnline: chat.isOnline,
    lastSeen: chat.lastSeen,
    quotedMsgObj: obj.quotedMsg,
    quotedStanzaId: obj.quotedStanzaID ? obj.quotedStanzaID : undefined,
    mediaData: WAPI.serializeRawObj(obj.mediaData),
    caption: obj.caption,
    deprecatedMms3Url: obj.deprecatedMms3Url,
    directPath: obj.directPath,
    encFilehash: obj.encFilehash,
    filehash: obj.filehash,
    filename: obj.filename,
    mimetype: obj.mimetype,
    clientUrl: obj.clientUrl,
    mediaKey: obj.mediaKey,
    size: obj.size,
    t: obj.t,
    isNewMsg: obj.isNewMsg,
    linkPreview: obj.linkPreview,
    text: obj.text,
    height: obj.height,
    width: obj.width,
    self: obj.self,
    initialPageSize: obj.initialPageSize,
    lat: obj.lat ? obj.lat : undefined,
    lng: obj.lng ? obj.lng : undefined,
    ack: obj.ack,
    scanLengths: undefined,
    scansSidecar: undefined,
    streamingSidecar: undefined,
    waveform: undefined,
    replyButtons: undefined,
    dynamicReplyButtons: undefined,
    buttons: undefined,
    hydratedButtons: undefined
  });
};

```

`src/lib/wapi/serialize/serialize-profile-pic-thumb.js`:

```js
export const serializeProfilePicThumb = (obj) => {
  if (obj == undefined) {
    return null;
  }

  return Object.assign(
    {},
    {
      eurl: obj.eurl,
      id: obj.id,
      img: obj.img,
      imgFull: obj.imgFull,
      raw: obj.raw,
      tag: obj.tag
    }
  );
};

```

`src/lib/wapi/serialize/serialize-raw.js`:

```js
export const serializeRawObj = (obj) => {
  if (obj && obj.toJSON) {
    obj.waveform = null;
    return obj.toJSON();
  }
  return {};
};

```

`src/lib/wapi/serialize/serielize-me.js`:

```js
export const serializeMeObj = async (obj) => {
  if (obj == undefined) {
    return null;
  }
  const newObj = {};
  Object.assign(newObj, {
    id: obj.id ? obj.id : null,
    displayName: obj.displayName ? obj.displayName : null,
    verifiedName: obj.verifiedName ? obj.verifiedName : null,
    searchName: obj.searchName ? obj.searchName : null,
    pushname: obj.pushname ? obj.pushname : null,
    notifyName: obj.notifyName ? obj.notifyName : null,
    isBusiness: obj.isBusiness ? obj.isBusiness : null,
    formattedUser: obj.formattedUser ? obj.formattedUser : null,
    eurl: obj.profilePicThumb.attributes.eurl
      ? obj.profilePicThumb.attributes.eurl
      : null,
    ...obj.profilePicThumb.attributes,
    ...obj.businessProfile.attributes
  });
  return newObj;
};

```

`src/lib/wapi/serializers/index.js`:

```js
export { _serializeChatObj } from './serialize-chat';
export { _serializeRawObj } from './serialize-raw';
export { _serializeMessageObj } from './serialize-message';
export { _serializeContactObj } from './serialize-contact';
export { _serializeProfilePicThumb } from './serialize-profile-pic-thumb';
export { _serializeMeObj } from './serielize-me';
export { _serializeForcing } from './serialize-forcing';

```

`src/lib/wapi/serializers/serialize-chat.js`:

```js
import { _serializeRawObj } from './serialize-raw';
/**
 * Serializes a chat object
 * @param rawChat Chat object
 * @returns {Chat}
 */
export const _serializeChatObj = (obj) => {
  if (obj == undefined) {
    return null;
  }
  return Object.assign(window.WAPI._serializeRawObj(obj), {
    kind: obj?.kind,
    isGroup: obj?.isGroup,
    contact: obj?.contact
      ? window.WAPI._serializeContactObj(obj?.contact)
      : null,
    groupMetadata: obj?.groupMetadata
      ? window.WAPI._serializeRawObj(obj?.groupMetadata)
      : null,
    presence: obj?.presence
      ? window.WAPI._serializeRawObj(obj?.presence)
      : null,
    msgs: null,
    tcToken: null,
    isOnline: obj?.__x_presence?.attributes?.isOnline || null,
    lastSeen: obj?.previewMessage?.__x_ephemeralStartTimestamp
      ? obj.previewMessage.__x_ephemeralStartTimestamp * 1000
      : null
  });
};

```

`src/lib/wapi/serializers/serialize-contact.js`:

```js
export const _serializeContactObj = (obj) => {
  if (obj == undefined) {
    return null;
  }

  if (!obj.profilePicThumb && obj.id && Store.ProfilePicThumb) {
    obj.profilePicThumb = Store.ProfilePicThumb.get(obj.id);
  }

  return Object.assign(window.WAPI._serializeRawObj(obj), {
    formattedName: obj?.formattedName,
    displayName: obj?.displayName,
    formattedShortName: obj?.formattedShortName,
    formattedShortNameWithNonBreakingSpaces:
      obj?.formattedShortNameWithNonBreakingSpaces,
    isHighLevelVerified: obj?.isHighLevelVerified,
    isMe: obj?.isMe,
    mentionName: obj?.mentionName,
    notifyName: obj?.notifyName,
    isMyContact: obj?.isMyContact,
    isPSA: obj?.isPSA,
    isUser: obj?.isUser ?? obj?.id?.server === 'c.us' ? true : false,
    isVerified: obj?.isVerified,
    isWAContact: obj?.isWAContact,
    profilePicThumbObj: obj?.profilePicThumb
      ? WAPI._serializeProfilePicThumb(obj?.profilePicThumb)
      : {},
    statusMute: obj?.statusMute,
    msgs: null
  });
};

```

`src/lib/wapi/serializers/serialize-forcing.js`:

```js
export const _serializeForcing = (obj) => {
  if (Array.isArray(obj) && obj.length && obj[0] && obj[0]._value) {
    const refactore = obj[0]._value;
    const newObj = {};
    Object.assign(newObj, {
      ack: refactore?.ack,
      body: refactore?.body,
      from: refactore?.from,
      id: refactore?.id,
      sender: refactore?.sender
    });
    return newObj;
  }

  return null;
};

```

`src/lib/wapi/serializers/serialize-message.js`:

```js
export const _serializeMessageObj = async (obj) => {
  if (obj === undefined) {
    return null;
  }
  const _chat = obj['chat'] ? await WAPI._serializeChatObj(obj['chat']) : {};
  let chats = await WAPI.getAllChats();
  return {
    ...window.WAPI._serializeRawObj(obj),
    id: obj?.id?._serialized,
    from: obj?.from?._serialized,
    quotedParticipant: obj?.quotedParticipant?._serialized
      ? obj?.quotedParticipant?._serialized
      : undefined,
    author: obj?.author?._serialized ? obj?.author?._serialized : undefined,
    chatId: obj?.id?.remote
      ? obj?.id?.remote
      : obj?.chatId?._serialized
      ? obj?.chatId?._serialized
      : undefined,
    to: obj?.to?._serialized ? obj?.to?._serialized : undefined,
    fromMe: obj?.id?.fromMe,
    sender: obj?.senderObj
      ? await WAPI._serializeContactObj(obj?.senderObj)
      : null,
    timestamp: obj?.t,
    content: obj?.body,
    body: obj?.body,
    isLink: obj?.isLink,
    isMMS: obj?.isMMS,
    isMedia: obj?.isMedia,
    isNotification: obj?.isNotification,
    isPSA: obj?.isPSA,
    type: obj?.type,
    chat: _chat,
    isOnline: _chat?.isOnline,
    lastSeen: _chat?.lastSeen,
    quotedMsgObj: obj?.quotedMsg,
    quotedStanzaId: obj?.quotedStanzaID ? obj?.quotedStanzaID : undefined,
    mediaData: window.WAPI._serializeRawObj(obj?.mediaData),
    caption: obj?.caption,
    deprecatedMms3Url: obj?.deprecatedMms3Url,
    directPath: obj?.directPath,
    encFilehash: obj?.encFilehash,
    filehash: obj?.filehash,
    filename: obj?.filename,
    mimetype: obj?.mimetype,
    clientUrl: obj?.clientUrl,
    mediaKey: obj?.mediaKey,
    size: obj?.size,
    t: obj?.t,
    isNewMsg: obj?.isNewMsg,
    linkPreview: obj?.linkPreview,
    text: obj?.text,
    height: obj?.height,
    width: obj?.width,
    self: obj?.self,
    initialPageSize: obj?.initialPageSize,
    lat: obj?.lat ? obj.lat : undefined,
    lng: obj?.lng ? obj.lng : undefined,
    ack: obj?.ack,
    scanLengths: null,
    scansSidecar: null,
    streamingSidecar: null,
    waveform: null,
    replyButtons: null,
    dynamicReplyButtons: null,
    buttons: null,
    hydratedButtons: null,
    isGroupMsg:
      obj?.to?.server === 'g.us' || obj?.from?.server === 'g.us' ? true : false,
    groupInfo:
      obj?.to?.server === 'g.us' || obj?.from?.server === 'g.us'
        ? chats.find((chat) => chat.id._serialized === obj.from._serialized)
            .contact
        : null,
    reply: (body) => window.WAPI.reply(_chat.id._serialized, body, obj)
  };
};

```

`src/lib/wapi/serializers/serialize-profile-pic-thumb.js`:

```js
export const _serializeProfilePicThumb = (obj) => {
  if (obj == undefined) {
    return null;
  }

  return Object.assign(
    {},
    {
      eurl: obj?.eurl,
      id: obj?.id,
      img: obj?.img,
      imgFull: obj?.imgFull,
      raw: obj?.raw,
      tag: obj?.tag
    }
  );
};

```

`src/lib/wapi/serializers/serialize-raw.js`:

```js
export const _serializeRawObj = (obj) => {
  if (obj?.toJSON) {
    obj.waveform = null;
    return obj.toJSON();
  }
  return {};
};

```

`src/lib/wapi/serializers/serializeNumberStatusObj.js`:

```js
export const _serializeNumberStatusObj = (obj) => {
  if (obj == undefined) {
    return null;
  }

  return Object.assign(
    {},
    {
      id: obj.jid,
      status: obj.status,
      isBusiness: obj.biz === true,
      canReceiveMessage: obj.status === 200
    }
  );
};

```

`src/lib/wapi/serializers/serielize-me.js`:

```js
export const _serializeMeObj = async (obj) => {
  if (obj == undefined) {
    return null;
  }

  const connection = window.Store.State?.Socket?.state
    ? window.Store?.State?.Socket?.state
    : undefined;

  const newObj = {};

  console.log(newObj.id);

  Object.assign(newObj, {
    id: obj.id ? obj.id : null,
    displayName: obj.displayName ? obj.displayName : null,
    verifiedName: obj.verifiedName ? obj.verifiedName : null,
    searchName: obj.searchName ? obj.searchName : null,
    pushname: obj.pushname ? obj.pushname : null,
    notifyName: obj.notifyName ? obj.notifyName : null,
    isBusiness: obj.isBusiness ? obj.isBusiness : null,
    formattedUser: obj.formattedUser ? obj.formattedUser : null,
    ...obj.profilePicThumb?.attributes,
    ...obj.businessProfile?.attributes
  });
  return newObj;
};

```

`src/lib/wapi/store/get-store.js`:

```js
/* eslint-disable prettier/prettier */
const { storeObjects } = require('./store-objects');
export async function getStore(modules) {
  let foundCount = 0;
  const neededObjects = storeObjects;
  for (let idx in modules) {
    if (typeof modules[idx] === 'object' && modules[idx] !== null) {
      neededObjects.forEach((needObj) => {
        if (!needObj.conditions || needObj.foundedModule) return;
        // console.log(needObj.id);
        let neededModule = needObj.conditions(modules[idx]);
        if (neededModule !== null) {
          foundCount++;
          needObj.foundedModule = neededModule;
        }
      });
      if (foundCount == neededObjects.length) {
        break;
      }
    }
  }

  neededObjects.forEach((needObj) => {
    if (needObj.foundedModule) {
      if (needObj.id !== "module") {
        window.Store[needObj.id] = needObj.foundedModule;
      }
    }
  });

  const module = (neededObjects.filter((e) => e.id === 'module'))[0].foundedModule;
  Object.keys(module).forEach((key) => {
    if (![
      'Chat',
    ].includes(key)) {
      if (window.Store[key]) {
        window.Store[key + '_'] = module[key];
      } else {
        window.Store[key] = module[key];
      }
    }
  });

  if (window.Store.MediaCollection) {
    window.Store.MediaCollection.prototype.processFiles =
      window.Store.MediaCollection.prototype.processFiles ||
      window.Store.MediaCollection.prototype.processAttachments;
  }

  window.mR = async (find) => {
    return new Promise((resolve) => {
      const parasite = `parasite${Date.now()}`;
      window["webpackChunkwhatsapp_web_client"].push([
        [parasite],
        {},
        function (o) {
          let modules = [];
          for (let idx in o.m) {
            modules.push(o(idx));
          }
          for (let idx in modules) {
            if (typeof modules[idx] === "object" && modules[idx] !== null) {
              let module = modules[idx];

              var evet = module[find] ? module : null;
              if (evet) {
                window[find] = evet;
                return resolve(window[find]);
              }
            }
          }

        },
      ]);
    });
  }

  window.injectToFunction = (selector, callback) => {
    (async () => {
      const Nr = await window.mR(selector);
      const oldFunct = Nr[selector];
      //console.log(selector, oldFunct);
      Nr[selector] = (...args) => callback(oldFunct, args);
    })();
  };

  window.injectToFunction('createMsgProtobuf', (func, args) => {
    const proto = func(...args);
    const [message] = args;

    if (proto.listMessage) {
      proto.viewOnceMessage = {
        message: {
          listMessage: proto.listMessage
        }
      };
      delete proto.listMessage;
    }

    if (proto.buttonsMessage) {
      proto.viewOnceMessage = {
        message: {
          buttonsMessage: proto.buttonsMessage,
        },
      };
      delete proto.buttonsMessage;
    }

    if (proto.templateMessage) {
      proto.viewOnceMessage = {
        message: {
          templateMessage: proto.templateMessage,
        },
      };
      delete proto.templateMessage;
    }

    if (message.hydratedButtons) {
      const hydratedTemplate = {
        hydratedButtons: message.hydratedButtons,
      };

      if (message.footer) {
        hydratedTemplate.hydratedFooterText = message.footer;
      }

      if (message.caption) {
        hydratedTemplate.hydratedContentText = message.caption;
      }

      if (message.title) {
        hydratedTemplate.hydratedTitleText = message.title;
      }

      if (proto.conversation) {
        hydratedTemplate.hydratedContentText = proto.conversation;
        delete proto.conversation;
      } else if (proto.extendedTextMessage?.text) {
        hydratedTemplate.hydratedContentText = proto.extendedTextMessage.text;
        delete proto.extendedTextMessage;
      } else {
        // Search media part in message
        let found;
        const mediaPart = [
          'documentMessage',
          'imageMessage',
          'locationMessage',
          'videoMessage',
        ];
        for (const part of mediaPart) {
          if (part in proto) {
            found = part;
            break;
          }
        }

        if (!found) {
          return proto;
        }

        // Media message doesn't allow title
        hydratedTemplate[found] = proto[found];

        // Copy title to caption if not setted
        if (
          hydratedTemplate.hydratedTitleText &&
          !hydratedTemplate.hydratedContentText
        ) {
          hydratedTemplate.hydratedContentText =
            hydratedTemplate.hydratedTitleText;
        }

        // Remove title for media messages
        delete hydratedTemplate.hydratedTitleText;

        if (found === 'locationMessage') {
          if (
            !hydratedTemplate.hydratedContentText &&
            (proto[found].name || proto[found].address)
          ) {
            hydratedTemplate.hydratedContentText =
              proto[found].name && proto[found].address
                ? `${proto[found].name}\n${proto[found].address}`
                : proto[found].name || proto[found].address || '';
          }
        }

        // Ensure a content text;
        hydratedTemplate.hydratedContentText =
          hydratedTemplate.hydratedContentText || ' ';

        delete proto[found];
      }

      proto.templateMessage = {
        hydratedTemplate,
      };
    }

    return proto;
  });

  window.injectToFunction('mediaTypeFromProtobuf', (func, ...args) => {
    const [proto] = args;
    if (proto.viewOnceMessage?.message.templateMessage.hydratedTemplate) {
      return func(proto.viewOnceMessage?.message.templateMessage.hydratedTemplate);
    }
    return func(...args);
  });

  window.injectToFunction('typeAttributeFromProtobuf', (func, args) => {
    const [proto] = args;
    console.log(`proto`, proto);

    if (proto.viewOnceMessage?.message.listMessage) {
      return 'text';
    }

    if (proto.imageMessage || proto.audioMessage) {
      return 'text';
    }

    if (
      proto.viewOnceMessage?.message?.buttonsMessage?.headerType === 1 ||
      proto.viewOnceMessage?.message?.buttonsMessage?.headerType === 2
    ) {
      return 'text';
    }

    if (proto.viewOnceMessage?.message.templateMessage.hydratedTemplate) {
      return 'text';
    }

    return 'text';
  });

  window.injectToFunction('createFanoutMsgStanza', async (func, args) => {
    const [, proto] = args;

    let buttonNode = null;

    if (proto.viewOnceMessage?.message.listMessage) {
      const listType = proto.viewOnceMessage?.message.listMessage?.listType || 0;

      const types = ['unknown', 'single_select', 'product_list'];

      buttonNode = Store.Websocket.smax('list', {
        v: '2',
        type: types[listType],
      });
    }

    const node = await func(...args);

    if (!buttonNode) {
      return node;
    }

    const content = node.content;

    let bizNode = content.find((c) => c.tag === 'biz');

    if (!bizNode) {
      bizNode = Store.Websocket.smax('biz', {}, null);
      content.push(bizNode);
    }

    let hasButtonNode = false;

    if (Array.isArray(bizNode.content)) {
      hasButtonNode = !!bizNode.content.find((c) => c.tag === buttonNode?.tag);
    } else {
      bizNode.content = [];
    }


    if (!hasButtonNode) {
      bizNode.content.push(buttonNode);
    }

    return node;
  });
}


```

`src/lib/wapi/store/store-objects.js`:

```js
export const storeObjects = [
  {
    id: 'module',
    conditions: (module) =>
      module.default && module.default.Chat && module.default.Msg
        ? module.default
        : null,
  },
  {
    id: 'replyButton',
    conditions: (module) =>
      module.__esModule &&
        module.default &&
        module.default.prototype &&
        module.default.prototype.proxyName === 'replyButton'
        ? module.default
        : null,
  },
  {
    id: 'templateButton',
    conditions: (module) =>
      module.__esModule &&
        module.default &&
        module.default.prototype &&
        module.default.prototype.proxyName === 'templateButton'
        ? module.default
        : null,
  },
  {
    id: 'TemplateButtonCollection',
    conditions: (module) =>
      module.TemplateButtonCollection ? module.TemplateButtonCollection : null,
  },
  {
    id: 'ButtonCollection',
    conditions: (module) =>
      module.ButtonCollection ? module.ButtonCollection : null,
  },
  {
    id: 'MediaCollection',
    conditions: (module) =>
      module.default &&
        module.default.prototype &&
        (module.default.prototype.processFiles !== undefined ||
          module.default.prototype.processAttachments !== undefined)
        ? module.default
        : null,
  },
  { id: 'MediaProcess', conditions: (module) => (module.BLOB ? module : null) },
  {
    id: 'ChatUtil',
    conditions: (module) => (module.sendClear ? module : null),
  },
  {
    id: 'GroupInvite',
    conditions: (module) =>
      module.queryGroupInviteCode
        && module.revokeGroupInvite
        ? module
        : null,
  },
  {
    id: 'Wap',
    conditions: (module) => (module.createGroup ? module : null),
  },
  {
    id: 'ServiceWorker',
    conditions: (module) =>
      module.default && module.default.killServiceWorker ? module : null,
  },
  {
    id: 'WapDelete',
    conditions: (module) =>
      module.sendConversationDelete && module.sendConversationDelete.length == 2
        ? module
        : null,
  },
  {
    id: 'Conn',
    conditions: (module) =>
      module.default && module.default.ref && module.default.refTTL
        ? module.default
        : null,
  },
  {
    id: 'WapQuery',
    conditions: (module) =>
      module.default &&
        module.default.contactFindQuery &&
        module.default.queryExist
        ? module.default
        : null,
  },
  {
    id: 'CryptoLib',
    conditions: (module) => (module.decryptE2EMedia ? module : null),
  },
  {
    id: 'OpenChat',
    conditions: (module) =>
      module.default &&
        module.default.prototype &&
        module.default.prototype.openChat
        ? module.default
        : null,
  },
  {
    id: 'UserConstructor',
    conditions: (module) =>
      module.default &&
        module.default.prototype &&
        module.default.prototype.isServer &&
        module.default.prototype.isUser
        ? module.default
        : null,
  },
  {
    id: 'SendTextMsgToChat',
    conditions: (module) =>
      module.sendTextMsgToChat ? module.sendTextMsgToChat : null,
  },
  {
    id: 'Archive',
    conditions: (module) => (module.setArchive ? module : null),
  },
  {
    id: 'pinChat',
    conditions: (module) => (module.setPin ? module : null),
  },
  {
    id: 'sendDelete',
    conditions: (module) => (module.sendDelete ? module.sendDelete : null),
  },
  {
    id: 'addAndSendMsgToChat',
    conditions: (module) =>
      module.addAndSendMsgToChat ? module.addAndSendMsgToChat : null,
  },
  {
    id: 'sendMsgToChat',
    conditions: (module) =>
      module.sendMsgToChat ? module.sendMsgToChat : null,
  },
  {
    id: 'Catalog',
    conditions: (module) => (module.Catalog ? module.Catalog : null),
  },
  {
    id: 'Perfil',
    conditions: (module) =>
      module.__esModule === true &&
        module.setPushname &&
        !module.getComposeContents
        ? module
        : null,
  },
  {
    id: 'MsgKey',
    conditions: (module) =>
      module.default &&
        module.default.toString &&
        typeof module.default.toString === 'function' &&
        module.default.toString().includes('MsgKey error: obj is null/undefined')
        ? module.default
        : null,
  },
  {
    id: 'Parser',
    conditions: (module) =>
      module.convertToTextWithoutSpecialEmojis ? module.default : null,
  },
  {
    id: 'Builders',
    conditions: (module) =>
      module.TemplateMessage && module.HydratedFourRowTemplate ? module : null,
  },
  {
    id: 'Me',
    conditions: (module) =>
      module.Conn && module.ConnImpl ? module.Conn : null,
  },
  {
    id: 'CallUtils',
    conditions: (module) =>
      module.sendCallEnd && module.parseCall ? module : null,
  },
  {
    id: 'Identity',
    conditions: (module) =>
      module.queryIdentity && module.updateIdentity ? module : null,
  },
  {
    id: 'MyStatus',
    conditions: (module) =>
      module.getStatus && module.setMyStatus ? module : null,
  },
  {
    id: 'ChatStates',
    conditions: (module) =>
      module.sendChatStatePaused &&
        module.sendChatStateRecording &&
        module.sendChatStateComposing
        ? module
        : null,
  },
  {
    id: 'GroupActions',
    conditions: (module) =>
      module.sendExitGroup && module.localExitGroup ? module : null,
  },
  {
    id: 'Features',
    conditions: (module) =>
      module.FEATURE_CHANGE_EVENT && module.features ? module : null,
  },
  {
    id: 'MessageUtils',
    conditions: (module) =>
      module.storeMessages && module.appendMessage ? module : null,
  },
  {
    id: 'createMessageKey',
    conditions: (module) =>
      module.createMessageKey && module.createDeviceSentMessage
        ? module.createMessageKey
        : null,
  },
  {
    id: 'WidFactory',
    conditions: (module) =>
      module.isWidlike && module.createWid && module.createWidFromWidLike
        ? module
        : null,
  },
  {
    id: 'Base',
    conditions: (module) =>
      module.setSubProtocol && module.binSend && module.actionNode
        ? module
        : null,
  },
  {
    id: 'Base2',
    conditions: (module) =>
      module.supportsFeatureFlags &&
        module.parseMsgStubProto &&
        module.binSend &&
        module.subscribeLiveLocation
        ? module
        : null,
  },
  {
    id: 'MaybeMeUser',
    conditions: (module) => (module.getMaybeMeUser ? module : null),
  },
  {
    id: 'Sticker',
    conditions: (module) =>
      module.StickerCollection && module.default ? module : null,
  },
  {
    id: 'MediaObject',
    conditions: (module) =>
      module.getOrCreateMediaObject && module.disassociateMediaFromStickerPack
        ? module
        : null,
  },
  {
    id: 'MediaUpload',
    conditions: (module) =>
      module.default && module.default.mediaUpload ? module.default : null,
  },
  {
    id: 'UploadUtils',
    conditions: (module) =>
      module.default && module.default.encryptAndUpload ? module.default : null,
  },
  {
    id: 'Cmd',
    conditions: (module) => (module.CmdImpl && module.Cmd ? module.Cmd : null),
  },
  {
    id: 'ReadSeen',
    conditions: (module) => (module.sendSeen ? module : null),
  },
  {
    id: 'Block',
    conditions: (module) =>
      module.blockContact && module.unblockContact ? module : null,
  },
  {
    id: 'BlockList',
    conditions: (module) => (module.BlocklistCollection ? module : null),
  },
  {
    id: 'Theme',
    conditions: (module) =>
      module.getTheme && module.setTheme ? module : null,
  },
  {
    id: 'Vcard',
    conditions: (module) => (module.vcardFromContactModel ? module : null),
  },
  {
    id: 'Profile',
    conditions: (module) =>
      module.sendSetPicture && module.requestDeletePicture ? module : null,
  },
  {
    id: 'SendMute',
    conditions: (module) => (module.sendConversationMute ? module : null),
  },
  {
    id: 'Validators',
    conditions: (module) => (module.findLinks ? module : null),
  },
  {
    id: 'Wap2',
    conditions: (module) => (module.Wap ? module : null),
  },
  {
    id: 'genId',
    conditions: (module) =>
      module.default &&
        typeof module.default === 'function' &&
        module.default.toString().match(/crypto/)
        ? module
        : null,
  },
  {
    id: 'GroupMetadata',
    conditions: (module) =>
      module.default && module.default.handlePendingInvite ? module : null,
  },
  {
    id: 'i10n',
    conditions: (module) =>
      module.default && module.default.downloadAppLocale
        ? module.default
        : null,
  },
  {
    id: 'NetworkStatus',
    conditions: (module) =>
      module.default && module.default._logOnlineOffline
        ? module.default
        : null,
  },
  {
    id: 'Stream',
    conditions: (module) =>
      module.Stream && module.StreamInfo ? module.Stream : null,
  },
  {
    id: 'State',
    conditions: (module) => (module.Socket ? module : null),
  },
  {
    id: 'ws2',
    conditions: (module) =>
      module.default && module.default.destroyStorage ? module.default : null,
  },
  {
    id: 'Login',
    conditions: (module) => (module.startLogout ? module : null),
  },
  {
    id: 'BlobCache',
    conditions: (module) =>
      module.default && module.default.getOrCreateURL ? module.default : null,
  },
  {
    id: 'Presence',
    conditions: (module) =>
      module.setPresenceAvailable && module.setPresenceUnavailable
        ? module
        : null,
  },
  {
    id: 'PresenceCollection',
    conditions: (module) =>
      module.default && module.PresenceCollection ? module.default : null,
  },
  {
    id: 'chatOptions',
    conditions: (module) =>
      module.default && module.default.archiveChat ? module.default : null,
  },
  {
    id: 'blob',
    conditions: (module) =>
      module.default && module.default.createFromData ? module : null,
  },
  {
    id: 'GroupDesc',
    conditions: (module) => (module.setGroupDesc ? module : null),
  },
  {
    id: 'infoGroup',
    conditions: (module) => (module.queryGroupInviteInfo ? module : null),
  },
  {
    id: 'GroupTitle',
    conditions: (module) => (module.sendSetGroupSubject ? module : null),
  },
  {
    id: 'GroupSettings',
    conditions: (module) => (module.sendSetGroupProperty ? module : null),
  },
  {
    id: 'createGroup',
    conditions: (module) =>
      module.createGroup && module.sendForNeededAddRequest
        ? module.createGroup
        : null,
  },
  {
    id: 'SetStatusChat',
    conditions: (module) =>
      module.markComposing && module.markRecording ? module : null,
  },
  {
    id: 'Reactions',
    conditions: (module) => (module.sendReactionToMsg ? module : null),
  },
  {
    id: 'CheckWid',
    conditions: (module) => (module.validateWid ? module : null),
  },
  {
    id: 'ProfileBusiness',
    conditions: (module) => (module.BUSINESS_URL_DOMAIN ? module : null),
  },
  {
    id: 'Contacts',
    conditions: (module) => (module.ContactCollection ? module : null),
  },
  {
    id: 'onlySendAdmin',
    conditions: (module) =>
      module.setGroupProperty && module.setGroupDescription ? module : null,
  },
  {
    id: 'SendCommunity',
    conditions: (module) => (module.sendCreateCommunity ? module : null),
  },
  {
    id: 'Websocket',
    conditions: (module) => (module.smax ? module : null),
  },
  {
    id: "Survey",
    conditions: (module) => (module.sendPollCreation ? module : null),
  },
  {
    id: "Cmd",
    conditions: (module) => (module.APP_STATE_SYNC_COMPLETED ? module : null),
  },
  {
    id: "Wap",
    conditions: (module) => (module.BIG_ENDIAN_CONTENT ? module : null),
  },
  {
    id: "WapParser",
    conditions: (module) => (module.WapParser ? module : null),
  },
  {
    id: "SendSocket",
    conditions: (module) => (module.deprecatedSendIq ? module : null),
  }
  ,
  {
    id: "Jid",
    conditions: (module) => (module.WAP_JID_SUBTYPE ? module : null),
  }
 
];

```

`src/lib/wapi/wapi.js`:

```js
import {
  addParticipant,
  areAllMessagesLoaded,
  asyncLoadAllEarlierMessages,
  blockContact,
  unblockContact,
  getBlockList,
  clearChatMessages,
  createGroup,
  deleteConversation,
  deleteMessages,
  demoteParticipant,
  downloadFile,
  encryptAndUploadFile,
  forwardMessages,
  getAllChatIds,
  getAllChats,
  getAllChatsWithMessages,
  getAllContacts,
  getAllGroupMetadata,
  getAllGroups,
  getAllMessagesInChat,
  getBatteryLevel,
  getChat,
  getChatById,
  getChatByName,
  getCommonGroups,
  getContact,
  getGroupAdmins,
  getGroupInviteLink,
  getGroupParticipant,
  getHost,
  getMe,
  getMessageById,
  getMyContacts,
  getNewId,
  getNewMessageId,
  getNumberProfile,
  getProfilePicFromServer,
  getStatus,
  getUnreadMessages,
  isConnected,
  isLoggedIn,
  leaveGroup,
  loadAllEarlierMessages,
  loadAndGetAllMessagesInChat,
  loadChatEarlierMessages,
  loadEarlierMessagesTillDate,
  processFiles,
  processMessageObj,
  promoteParticipant,
  removeParticipant,
  reply,
  revokeGroupInviteLink,
  sendMessageOptions,
  sendChatstate,
  sendContactVcard,
  sendFile,
  sendPtt,
  sendImage,
  sendImageAsSticker,
  sendImageWithProduct,
  sendLocation,
  sendMessage,
  sendMessage2,
  sendMessageWithTags,
  sendMessageWithThumb,
  sendSticker,
  sendVideoAsGif,
  setMyName,
  setMyStatus,
  startTyping,
  startRecording,
  markPaused,
  clearPresence,
  presenceAvailable,
  presenceUnavailable,
  openChat,
  openChatAt,
  getGroupInfoFromInviteLink,
  joinGroup,
  markUnseenMessage,
  markMarkSeenMessage,
  getTheme,
  setTheme,
  restartService,
  killServiceWorker,
  sendLinkPreview,
  scope,
  getchatId,
  sendExist,
  returnChat,
  sendContactVcardList,
  setProfilePic,
  pinChat,
  getSessionTokenBrowser,
  sendMute,
  getListMute,
  interfaceMute,
  downloadMedia,
  checkIdMessage,
  returnReply,
  logout,
  setPresenceOnline,
  setPresenceOffline,
  archiveChat,
  setNewMessageId,
  setGroupDescription,
  sendButtons,
  setGroupTitle,
  setGroupSettings,
  getAllMessagesDate,
  checkNumberStatus,
  sendCheckType,
  sendListMenu,
  getStateConnection,
  isBeta,
  sendReactions,
  addChatWapi,
  sendTypeButtons,
  onlySendAdmin,
  createCommunity,
  pollCreation
} from './functions';
import {
  base64ToFile,
  generateMediaKey,
  getFileHash,
  arrayBufferToBase64,
  sleep,
  injectConfig
} from './helper';
import {
  addNewMessagesListener,
  addOnAddedToGroup,
  addOnLiveLocation,
  addOnNewAcks,
  addOnPoll,
  addOnParticipantsChange,
  addOnStateChange,
  initNewMessagesListener,
  addOnStreamChange,
  addonFilePicThumb,
  addonUnreadMessage,
  addonChatState,
  addOnStream
} from './listeners';
import {
  _serializeChatObj,
  _serializeContactObj,
  _serializeMessageObj,
  _serializeProfilePicThumb,
  _serializeRawObj,
  _serializeMeObj,
  _serializeForcing
} from './serializers';
import { getStore } from './store/get-store';

window.Store = {};

function injectParasite() {
  if (
    window.webpackChunkwhatsapp_web_client &&
    Array.isArray(window.webpackChunkwhatsapp_web_client)
  ) {
    const parasite = injectConfig.parasite;
    window[injectConfig.webpack].push([
      [parasite],
      {},
      async function (o) {
        let modules = [];
        for (let idx in o.m) {
          modules.push(o(idx));
        }
        getStore(modules);
      }
    ]);
  }
}

async function waitForObjects() {
  return new Promise((resolve) => {
    const checkObjects = () => {
      if (
        window[injectConfig.webpack] &&
        Array.isArray(window[injectConfig.webpack]) &&
        window[injectConfig.webpack].every(
          (item) => Array.isArray(item) && item.length > 0
        )
      ) {
        resolve();
      } else {
        setTimeout(checkObjects, 200);
      }
    };

    checkObjects();
  });
}

(async () => {
  await waitForObjects();

  const last = window[injectConfig.webpack].length - 1;
  if (
    !window[injectConfig.webpack][last][0].includes(injectConfig.parasite) &&
    document.querySelectorAll('#app .two').length
  ) {
    injectParasite();
  }
})();

if (typeof window.WAPI === 'undefined') {
  window.WAPI = {};

  //Community
  window.WAPI.createCommunity = createCommunity;

  //others
  window.WAPI.interfaceMute = interfaceMute;
  window.WAPI.checkIdMessage = checkIdMessage;
  window.WAPI.returnReply = returnReply;
  window.WAPI.getStore = getStore;
  window.WAPI.setNewMessageId = setNewMessageId;
  window.WAPI.sendButtons = sendButtons;
  window.WAPI.checkNumberStatus = checkNumberStatus;
  window.WAPI.sendCheckType = sendCheckType;
  window.WAPI.sendListMenu = sendListMenu;
  window.WAPI.getStateConnection = getStateConnection;
  window.WAPI.sleep = sleep;
  window.WAPI.isBeta = isBeta;

  //Profile
  window.WAPI.setProfilePic = setProfilePic;
  window.WAPI.getSessionTokenBrowser = getSessionTokenBrowser;

  // Chat Functions
  window.WAPI.scope = scope;
  window.WAPI.getchatId = getchatId;
  window.WAPI.sendExist = sendExist;
  window.WAPI.returnChat = returnChat;
  window.WAPI.pinChat = pinChat;
  window.WAPI.archiveChat = archiveChat;

  // Layout Functions
  window.WAPI.setTheme = setTheme;
  window.WAPI.getTheme = getTheme;

  // Serializers assignations
  window.WAPI._serializeRawObj = _serializeRawObj;
  window.WAPI._serializeChatObj = _serializeChatObj;
  window.WAPI._serializeContactObj = _serializeContactObj;
  window.WAPI._serializeMessageObj = _serializeMessageObj;
  window.WAPI._serializeProfilePicThumb = _serializeProfilePicThumb;
  window.WAPI._serializeMeObj = _serializeMeObj;
  window.WAPI._serializeForcing = _serializeForcing;

  window.WAPI.onlySendAdmin = onlySendAdmin;

  // Group Functions
  window.WAPI.createGroup = createGroup;
  window.WAPI.leaveGroup = leaveGroup;
  window.WAPI.revokeGroupInviteLink = revokeGroupInviteLink;
  window.WAPI.getGroupInviteLink = getGroupInviteLink;
  window.WAPI.getGroupInfoFromInviteLink = getGroupInfoFromInviteLink;
  window.WAPI.getGroupAdmins = getGroupAdmins;
  window.WAPI.removeParticipant = removeParticipant;
  window.WAPI.addParticipant = addParticipant;
  window.WAPI.promoteParticipant = promoteParticipant;
  window.WAPI.demoteParticipant = demoteParticipant;
  window.WAPI.joinGroup = joinGroup;
  window.WAPI.setGroupDescription = setGroupDescription;
  window.WAPI.setPresenceOnline = setPresenceOnline;
  window.WAPI.setPresenceOffline = setPresenceOffline;
  window.WAPI.setGroupTitle = setGroupTitle;
  window.WAPI.setGroupSettings = setGroupSettings;

  // Chatting functions
  window.WAPI.sendChatstate = sendChatstate;
  window.WAPI.sendMessageWithThumb = sendMessageWithThumb;
  window.WAPI.processMessageObj = processMessageObj;
  window.WAPI.sendMessageWithTags = sendMessageWithTags;
  window.WAPI.sendMessage = sendMessage;
  window.WAPI.sendMessage2 = sendMessage2;
  window.WAPI.deleteConversation = deleteConversation;
  window.WAPI.deleteMessages = deleteMessages;
  window.WAPI.clearChatMessages = clearChatMessages;
  window.WAPI.sendImage = sendImage;
  window.WAPI.sendPtt = sendPtt;
  window.WAPI.sendFile = sendFile;
  window.WAPI.setMyName = setMyName;
  window.WAPI.setMyStatus = setMyStatus;
  window.WAPI.sendVideoAsGif = sendVideoAsGif;
  window.WAPI.processFiles = processFiles;
  window.WAPI.sendImageWithProduct = sendImageWithProduct;
  window.WAPI.sendContactVcard = sendContactVcard;
  window.WAPI.sendContactVcardList = sendContactVcardList;
  window.WAPI.forwardMessages = forwardMessages;
  window.WAPI.reply = reply;
  window.WAPI._sendSticker = sendSticker;
  window.WAPI.encryptAndUploadFile = encryptAndUploadFile;
  window.WAPI.sendImageAsSticker = sendImageAsSticker;
  window.WAPI.sendImageAsStickerGif = sendImageAsSticker;
  window.WAPI.startTyping = startTyping;
  window.WAPI.startRecording = startRecording;
  window.WAPI.markPaused = markPaused;
  window.WAPI.clearPresence = clearPresence;
  window.WAPI.presenceAvailable = presenceAvailable;
  window.WAPI.presenceUnavailable = presenceUnavailable;
  window.WAPI.sendLocation = sendLocation;
  window.WAPI.openChat = openChat;
  window.WAPI.openChatAt = openChatAt;
  window.WAPI.markUnseenMessage = markUnseenMessage;
  window.WAPI.markMarkSeenMessage = markMarkSeenMessage;
  window.WAPI.sendLinkPreview = sendLinkPreview;
  window.WAPI.sendMessageOptions = sendMessageOptions;
  window.WAPI.getAllMessagesDate = getAllMessagesDate;
  window.WAPI.sendReactions = sendReactions;
  window.WAPI.addChatWapi = addChatWapi;
  window.WAPI.sendTypeButtons = sendTypeButtons;
  window.WAPI.sendPollCreation = pollCreation;

  //////block functions
  window.WAPI.blockContact = blockContact;
  window.WAPI.unblockContact = unblockContact;
  window.WAPI.getBlockList = getBlockList;

  // Retrieving functions
  window.WAPI.getAllContacts = getAllContacts;
  window.WAPI.getMyContacts = getMyContacts;
  window.WAPI.getContact = getContact;
  window.WAPI.getAllChats = getAllChats;
  window.WAPI.getAllChatIds = getAllChatIds;
  window.WAPI.getAllChatsWithMessages = getAllChatsWithMessages;
  window.WAPI.getAllGroups = getAllGroups;
  window.WAPI.getChat = getChat;
  window.WAPI.getStatus = getStatus;
  window.WAPI.getChatByName = getChatByName;
  window.WAPI.getNewId = getNewId;
  window.WAPI.getChatById = getChatById;
  window.WAPI.loadEarlierMessages = loadChatEarlierMessages;
  window.WAPI.loadAllEarlierMessages = loadAllEarlierMessages;
  window.WAPI.asyncLoadAllEarlierMessages = asyncLoadAllEarlierMessages;
  window.WAPI.areAllMessagesLoaded = areAllMessagesLoaded;
  window.WAPI.loadEarlierMessagesTillDate = loadEarlierMessagesTillDate;
  window.WAPI.getAllGroupMetadata = getAllGroupMetadata;
  window.WAPI.getGroupParticipant = getGroupParticipant;
  window.WAPI.getAllMessagesInChat = getAllMessagesInChat;
  window.WAPI.loadAndGetAllMessagesInChat = loadAndGetAllMessagesInChat;
  window.WAPI.getUnreadMessages = getUnreadMessages;
  window.WAPI.getCommonGroups = getCommonGroups;
  window.WAPI.getProfilePicFromServer = getProfilePicFromServer;
  window.WAPI.downloadFile = downloadFile;
  window.WAPI.downloadMedia = downloadMedia;
  window.WAPI.getNumberProfile = getNumberProfile;
  window.WAPI.getMessageById = getMessageById;
  window.WAPI.getNewMessageId = getNewMessageId;
  window.WAPI.getFileHash = getFileHash;
  window.WAPI.generateMediaKey = generateMediaKey;
  window.WAPI.arrayBufferToBase64 = arrayBufferToBase64;
  window.WAPI.getListMute = getListMute;

  // Device functions
  window.WAPI.getHost = getHost;
  window.WAPI.getMe = getMe;
  window.WAPI.isConnected = isConnected;
  window.WAPI.isLoggedIn = isLoggedIn;
  window.WAPI.getBatteryLevel = getBatteryLevel;
  window.WAPI.base64ImageToFile = base64ToFile;
  window.WAPI.base64ToFile = base64ToFile;
  window.WAPI.restartService = restartService;
  window.WAPI.killServiceWorker = killServiceWorker;
  window.WAPI.sendMute = sendMute;

  // Listeners initialization
  window.WAPI._newMessagesQueue = [];
  window.WAPI._newMessagesBuffer =
    sessionStorage.getItem('saved_msgs') != null
      ? JSON.parse(sessionStorage.getItem('saved_msgs'))
      : [];
  window.WAPI._newMessagesDebouncer = null;
  window.WAPI._newMessagesCallbacks = [];

  // Listeners
  window.addEventListener('unload', window.WAPI._unloadInform, false);
  window.addEventListener('beforeunload', window.WAPI._unloadInform, false);
  window.addEventListener('pageunload', window.WAPI._unloadInform, false);
  // On-work below:

  /**
   * New version of @tag message
   */
  window.WAPI.sendMessageMentioned = async function (
    chatId,
    message,
    mentioned
  ) {
    if (!Array.isArray(mentioned)) {
      mentioned = [mentioned];
    }

    const chat = await WAPI.getChat(chatId);
    const users = await Store.Contact.serialize().filter((x) =>
      mentioned.includes(x.id.user)
    );

    chat.sendMessage(message, {
      linkPreview: null,
      mentionedJidList: users.map((u) => u.id),
      quotedMsg: null,
      quotedMsgAdminGroupJid: null
    });
  };

  window.WAPI.getProfilePicSmallFromId = async function (id) {
    return await window.Store.ProfilePicThumb.find(id).then(
      async function (d) {
        if (d.img !== undefined) {
          return await window.WAPI.downloadFileWithCredentials(d.img);
        } else {
          return false;
        }
      },
      function (e) {
        return false;
      }
    );
  };

  window.WAPI.getProfilePicFromId = async function (id) {
    return await window.Store.ProfilePicThumb.find(id).then(
      async function (d) {
        if (d.imgFull !== undefined) {
          return await window.WAPI.downloadFileWithCredentials(d.imgFull);
        } else {
          return false;
        }
      },
      function (e) {
        return false;
      }
    );
  };

  window.WAPI.downloadFileWithCredentials = async function (url) {
    if (!axios || !url) return false;
    const ab = (
      await axios.get(url, {
        responseType: 'arraybuffer'
      })
    ).data;
    return btoa(
      new Uint8Array(ab).reduce(
        (data, byte) => data + String.fromCharCode(byte),
        ''
      )
    );
  };

  window.WAPI.getChatIsOnline = async function (chatId) {
    const chat = Store.Chat.get(chatId);
    if (!chat) {
      return false;
    }
    await chat.presence.subscribe();
    return chat.presence.attributes.isOnline;
  };

  window.WAPI.getLastSeen = async function (chatId) {
    const chat = Store.Chat.get(chatId);
    if (!chat) {
      return false;
    }
    await chat.presence.subscribe();
    return chat.presence.chatstate.t || false;
  };

  window.WAPI.getWAVersion = function () {
    return window.Debug.VERSION;
  };

  /**
   * @param id The id of the conversation
   * @param archive boolean true => archive, false => unarchive
   * @return boolean true: worked, false: didnt work (probably already in desired state)
   */
  window.WAPI.archiveChat = async function (id, archive) {
    return await Store.Archive.setArchive(Store.Chat.get(id), archive)
      .then((_) => true)
      .catch((_) => false);
  };

  window.WAPI.takeOver = async function () {
    await window.Store.State.Socket.takeover();
    return true;
  };

  /**
   * Registers a callback to be called when your phone receives a new call request.
   * @param callback - function - Callback function to be called upon a new call. returns a call object.
   * @returns {boolean}
   */
  window.WAPI.onIncomingCall = function (callback) {
    window.WAPI.waitForStore(['Call'], () => {
      window.Store.Call.on('add', callback);
    });
    return true;
  };

  window.WAPI.setMessagesAdminsOnly = async function (chatId, option) {
    await Store.WapQuery.setGroupProperty(chatId, 'announcement', option);
    return true;
  };

  window.WAPI.logout = logout;
  window.WAPI.storePromises = {};
  window.WAPI.waitForStore = async function (stores, callback) {
    if (!Array.isArray(stores)) {
      stores = [stores];
    }

    const isUndefined = (p) => typeof window.Store[p] === 'undefined';
    const missing = stores.filter(isUndefined);

    const promises = missing.map((s) => {
      if (!window.WAPI.storePromises[s]) {
        window.WAPI.storePromises[s] = new Promise((resolve) => {
          let time = null;
          const listen = (e) => {
            const name = (e && e.detail) || '';
            if (name === s || !isUndefined(s)) {
              window.removeEventListener('storeLoaded', listen);
              clearInterval(time);
              resolve(true);
            }
          };
          window.addEventListener('storeLoaded', listen);
          time = setInterval(listen, 1000);
        });
      }
      return window.WAPI.storePromises[s];
    });
    const all = Promise.all(promises);

    if (typeof callback === 'function') {
      all.then(callback);
    }

    return await all;
  };

  addOnPoll();

  addNewMessagesListener();

  addonUnreadMessage();
  addonFilePicThumb();
  addonChatState();

  addOnStreamChange();
  addOnStateChange();
  addOnStream();

  initNewMessagesListener();

  addOnNewAcks();
  addOnAddedToGroup();
  addOnLiveLocation();
  addOnParticipantsChange();
}

```

`src/lib/wapi/webpack.config.cjs`:

```cjs
// eslint-disable-next-line no-undef
const path = require('path');

module.exports = {
  entry: './wapi.js',
  mode: 'development',
  devtool: 'source-map',
  output: {
    // eslint-disable-next-line no-undef
    path: path.resolve(__dirname, '../../../dist/lib/wapi'),
    filename: 'wapi.js'
  }
};

```

`src/lib/wapi/webpack.config.js`:

```js
const path = require('path');

module.exports = {
  entry: './wapi.js',
  // mode: 'development',
  // devtool: 'source-map',
  output: {
    path: path.resolve(__dirname, '../../../dist/lib/wapi'),
    filename: 'wapi.js'
  }
};

```

`src/types/WAPI.d.ts`:

```ts
import {
  Chat,
  Contact,
  ContactStatus,
  GroupCreation,
  Message,
  PartialMessage,
  SendFileResult,
  SendLinkResult,
  SendStickerResult,
  WhatsappProfile
} from '../api/model';

interface WAPI {
  addParticipant: (groupId: string, contactId: string | string[]) => boolean;
  onAnyMessage: (callback: Function) => void;
  archiveChat: (chatId: string, option: boolean) => boolean;
  arrayBufferToBase64: (buffer: ArrayBuffer) => string;
  blockContact: (messageId: string) => boolean;
  checkNumberStatus: (contactId: string) => Promise<WhatsappProfile>;
  clearChatMessages: (chatId: string) => void;
  createGroup: (
    groupName: string,
    contactId: string | string[]
  ) => GroupCreation;
  deleteConversation: (chatId: string) => boolean;
  deleteMessages: (contactId: string, messageId: string[]) => Promise<object>;
  demoteParticipant: (groupId: string, contactId: string | string[]) => void;
  downloadFile: (data: string) => Promise<string | boolean>;
  downloadMedia: (messageId: string) => Promise<string>;
  forwardMessages: (
    to: string,
    messages: string | string[],
    skipMyMessages: boolean
  ) => Promise<object>;
  getAllChats: () => Promise<Chat[] | object[]>;
  getAllChatsWithMessages: (withNewMessageOnly?: boolean) => Chat[];
  getAllChatsWithNewMsg: () => Chat[];
  getAllContacts: () => Contact[];
  getAllMessagesInChat: (
    chatId: string,
    includeMe: boolean,
    includeNotifications: boolean
  ) => Message[];
  getAllMessagesDate: (
    chatId: string,
    type: string,
    idateStart: string,
    time: string,
    limit: number
  ) => Message[];

  getBatteryLevel: () => number;
  getBlockList: () => Contact[];
  getBusinessProfilesProducts: (to: string) => any;
  getChat: (contactId: string) => Chat;
  getChatById: (contactId: string) => Chat;
  getChatIsOnline: (chatId: string) => Promise<boolean>;
  getLastSeen: (chatId: string) => Promise<number | boolean>;
  getContact: (contactId: string) => Contact;
  getGroupAdmins: (groupId: string) => Object;
  getGroupInfoFromInviteLink: (inviteCode: string) => Promise<string | boolean>;
  getGroupInviteLink: (chatId: string) => Promise<string>;
  revokeGroupInviteLink: (chatId: string) => Promise<boolean>;
  getGroupParticipant: (groupId: string, time: string) => Object;
  getHost: () => any; //HostDevice;
  getListMute: (type?: string) => object;
  getStateConnection: () => String;
  getNewMessageId: (chatId: string) => Object;
  getMessageById: (messageId: string) => Promise<Message>;
  getNumberProfile: (contactId: string) => Object;
  getProfilePicFromServer: (chatId: string) => string;
  getStatus: (contactId: string) => ContactStatus;
  getTheme: () => string;
  getUnreadMessages: (unread: boolean) => any;
  getWAVersion: () => string;
  isConnected: () => boolean;
  isLoggedIn: () => boolean;
  isBeta: () => boolean;
  joinGroup: (groupId: string) => Promise<string | boolean>;
  killServiceWorker: () => boolean;
  setPresenceOffline: () => boolean;
  setPresenceOnline: () => boolean;
  leaveGroup: (groupId: string) => any;
  loadAndGetAllMessagesInChat: (
    chatId: string,
    includeMe: boolean,
    includeNotifications: boolean
  ) => Message[];
  loadEarlierMessages: (contactId: string) => Message[];
  logout: () => Promise<boolean>;
  markUnseenMessage: (chatId: string) => boolean;
  markMarkSeenMessage: (chatId: string) => boolean;
  onAddedToGroup: (callback: Function) => any;
  onIncomingCall: (callback: Function) => any;
  onInterfaceChange: (callback: Function) => void;
  onMessage: (callback: Function) => void;
  onAck: (callback: Function) => void;
  onPoll: (callback: Function) => void;
  onLiveLocation: (chatId: string, callback: Function) => any;
  onParticipantsChanged: (groupId: string, callback: Function) => any;
  onStateChange: (callback: Function) => void;
  openChat: (chatId: string, force?: string | boolean) => boolean;
  openChatAt: (
    chatId: string,
    messageId: string
  ) => { wasVisible: boolean; alignAt: string };
  pinChat: (
    chatId: string,
    option: boolean,
    nonExistent?: boolean
  ) => Promise<object>;
  promoteParticipant: (groupId: string, contactId: string | string[]) => void;
  removeParticipant: (groupId: string, contactId: string | string[]) => void;
  reply: (to: string, content: string, quotedMsg: string) => Promise<object>;
  restartService: () => boolean;
  sendChatstate: (chatState: string | any, chatId: string) => void;
  sendContactVcard: (
    to: string,
    contact: string | string[],
    name?: string
  ) => Promise<object>;
  sendContactVcardList: (to: string, contacts: string[]) => Promise<object>;
  sendFile: (
    base64: string,
    to: string,
    filename: string,
    caption: string,
    type?: string,
    status?: boolean,
    passId?: Object,
    checkNumber?: boolean,
    forcingReturn?: boolean,
    delSend?: boolean
  ) => Promise<SendFileResult>;
  sendImage: (
    imgBase64: string,
    to: string,
    filename: string,
    caption?: string,
    type?: string | boolean,
    status?: boolean,
    passId?: Object
  ) => Promise<SendFileResult>;
  sendImageAsSticker: (
    webpBase64: string,
    to: string,
    metadata?: any,
    type?: string
  ) => Promise<SendStickerResult>;
  sendImageAsStickerGif: (
    webpBase64: string,
    to: string,
    metadata?: any
  ) => Promise<SendStickerResult>;
  sendImageWithProduct: (
    base64: string,
    to: string,
    caption: string,
    bizNumber: string,
    productId: string
  ) => any;
  sendLinkPreview: (
    chatId: string,
    url: string,
    title: string,
    thumbnail: string
  ) => Promise<SendLinkResult>;
  sendLocation: (
    to: string,
    latitude: string,
    longitude: string,
    title: string
  ) => Promise<object>;
  sendListMenu: (
    to: string,
    title: string,
    subTitle: string,
    description: string,
    buttonText: string,
    menu: Array<any>
  ) => Promise<Object>;
  sendMessage: (
    to: string,
    content: string,
    status?: boolean,
    passId?: Object,
    checkNumber?: boolean,
    forcingReturn?: boolean,
    delSend?: boolean
  ) => Promise<Object>;
  sendButtons: (
    to: string,
    title: string,
    subtitle: string,
    buttons: object
  ) => Promise<object>;
  sendTypeButtons(
    to: string,
    title: string,
    subtitle: string,
    footer: string,
    buttons: any
  ): Promise<object>;
  sendMessageMentioned: (...args: any) => any;
  sendMessageOptions: (
    chat: any,
    content: any,
    options?: any
  ) => Promise<string>;
  onlySendAdmin: (chatId: string, type: boolean) => Promise<any>;
  sendMessageWithThumb: (
    thumb: string,
    url: string,
    title: string,
    description: string,
    chatId: string
  ) => void;
  sendMute: (id: string, time: number, type: string) => Promise<object>;
  sendPtt: (
    base64: string,
    to: string,
    passId?: object,
    checkNumber?: boolean,
    forcingReturn?: boolean,
    delSend?: boolean
  ) => any;
  sendVideoAsGif: (
    base64: string,
    to: string,
    filename: string,
    caption: string
  ) => void;
  setMessagesAdminsOnly: (chatId: string, option: boolean) => boolean;
  setMyName: (name: string) => void;
  setMyStatus: (to: string) => void;
  setProfilePic: (path: string | object, to?: string) => Promise<boolean>;
  setGroupTitle: (groupId: string, title: string) => object;
  setGroupSettings: (
    groupId: string,
    settings: string,
    value: boolean
  ) => Promise<object>;
  setTheme: (theme?: string) => boolean;
  startTyping: (to: string, checkNumber: boolean) => void;
  startRecording: (to: string, checkNumber: boolean) => void;
  markPaused: (to: string, checkNumber: boolean) => void;
  clearPresence: (to: string) => void;
  presenceAvailable: () => void;
  presenceUnavailable: () => void;
  takeOver: () => boolean;
  unblockContact: (messageId: string) => boolean;
  waitForStore: (store: string | string[], callback?: Function) => Promise<any>;
  waitNewAcknowledgements: (callback: Function) => void;
  waitNewMessages: (rmCallback: boolean, callback: Function) => void;
  returnReply: (message: object) => object;
  onStreamChange: (callback: Function) => void;
  onFilePicThumb: (callback: Function) => void;
  onChatState: (callback: Function) => void;
  onUnreadMessage: (callback: Function) => void;
  setGroupDescription: (groupId: string, description: string) => object;
  sendReactions: (IdMessage: string, emoji: String) => void;
  addChatWapi: () => void;
  processMessageObj: (a: any, b: any, c: any) => any;
  createCommunity: (name: string, description: string) => void;
  sendPollCreation: (to: string, poll: any) => void;
}

declare global {
  interface Window {
    WAPI: WAPI;
  }
  const WAPI: WAPI;
}

```

`src/types/spinnies.d.ts`:

```ts
declare module 'spinnies' {
  namespace Spinnies {
    type StopAllStatus = 'succeed' | 'fail' | 'stopped';
    type SpinnerStatus = StopAllStatus | 'spinning' | 'non-spinnable';

    interface Spinner {
      interval: number;
      frames: string[];
    }

    interface SpinnerOptions {
      /**
       * Optional text to show in the spinner. If none is provided, the name field will be shown.
       */
      text?: string;

      /**
       *  Optional, indent the spinner with the given number of spaces.
       * */
      indent?: number;

      /**
       * Initial status of the spinner. Valid statuses are: succeed, fail, spinning, non-spinnable and stopped.
       */
      status?: SpinnerStatus;

      /**
       * Any valid chalk color.
       */
      color?: string;

      /**
       * Any valid chalk color.
       */
      succeedColor?: string;

      /**
       * Any valid chalk color.
       */
      failColor?: string;
    }

    interface Options {
      /**
       * Any valid chalk color. The default value is white.
       */
      color?: string;

      /**
       * Any valid chalk color. The default value is green.
       */
      succeedColor?: string;

      /**
       * Any valid chalk color. The default value is red.
       */
      failColor?: string;

      /**
       * Any valid chalk color. The default value is greenBright.
       */
      spinnerColor?: string;

      /**
       * The default value is ✓.
       */
      succeedPrefix?: string;

      /**
       * The default value is ✖.
       */
      failPrefix?: string;

      /**
       * Disable spins (will still print raw messages).
       */
      disableSpins?: boolean;

      /**
       * Spinner configuration
       */
      spinner?: Spinner;
    }
  }

  class Spinnies {
    static dots: Spinnies.Spinner;
    static dashes: Spinnies.Spinner;

    constructor(options?: Spinnies.Options);

    /**
     * Add a new spinner with the given name.
     */
    add: (
      name: string,
      options?: Spinnies.SpinnerOptions
    ) => Spinnies.SpinnerOptions;

    /**
     * Get spinner by name.
     */
    pick: (name: string) => Spinnies.SpinnerOptions;

    /**
     * Remove spinner with name.
     */
    remove: (name: string) => Spinnies.SpinnerOptions;

    /**
     * Updates the spinner with name name with the provided options.
     */
    update: (
      name: string,
      options?: Spinnies.SpinnerOptions
    ) => Spinnies.SpinnerOptions;

    /**
     * Sets the specified spinner status as succeed.
     */
    succeed: (
      name: string,
      options?: Spinnies.SpinnerOptions
    ) => Spinnies.SpinnerOptions;

    /**
     * Sets the specified spinner status as fail.
     */
    fail: (
      name: string,
      options?: Spinnies.SpinnerOptions
    ) => Spinnies.SpinnerOptions;

    /**
     * Stops the spinners and sets the non-succeeded and non-failed ones to the provided status.
     */
    stopAll: (status?: Spinnies.StopAllStatus) => {
      [name: string]: Spinnies.SpinnerOptions;
    };

    /**
     * @returns false if all spinners have succeeded, failed or have been stopped
     */
    hasActiveSpinners: () => boolean;
  }

  export = Spinnies;
}

```

`src/utils/semver.ts`:

```ts
const VPAT = /^\d+(\.\d+){0,2}$/;

/**
 * Compares two versions
 * @return true if local is up to date, false otherwise
 * @param local
 * @param remote
 */
export function upToDate(local: string, remote: string) {
  if (!local || !remote || local.length === 0 || remote.length === 0)
    return false;
  if (local == remote) return true;
  if (VPAT.test(local) && VPAT.test(remote)) {
    const lparts = local.split('.');
    while (lparts.length < 3) lparts.push('0');
    const rparts = remote.split('.');
    while (rparts.length < 3) rparts.push('0');
    for (let i = 0; i < 3; i++) {
      const l = parseInt(lparts[i], 10);
      const r = parseInt(rparts[i], 10);
      if (l === r) continue;
      return l > r;
    }
    return true;
  } else {
    return local >= remote;
  }
}

```

`src/utils/sleep.ts`:

```ts
export function sleep(time: number): Promise<void> {
  try {
    return new Promise((resolve: TimerHandler) => setTimeout(resolve, time));
  } catch (e) {}
}

```

`src/utils/spinnies.ts`:

```ts
import Spinnies from 'spinnies';

let spinnies: Spinnies = null;

export function getSpinnies(options?: Spinnies.Options): Spinnies {
  if (!spinnies) {
    spinnies = new Spinnies(options);
  }
  return spinnies;
}

```

`test/index.js`:

```js
const { tree } = require('gulp');
const venom = require('../dist');


venom.create({
  session: 'sessionname', //name of session
  headless: false,
  logQR: true,
}).then((client)=> {
  start(client);
});

async function start(client) {
  const f = await client.getHostDevice();
  console.log(f);
  // client.onMessage((message) => {
  //   console.log(message);
  // });
  // const allMessages = await client.getAllUnreadMessages();
  // console.log(allMessages);
}

```

`tsconfig.json`:

```json
{
  "compilerOptions": {

    /* Basic Options */
    "target": "esnext" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */,
    "resolveJsonModule": true,
    "module": "commonjs" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */,
    // "lib": [],                             /* Specify library files to be included in the compilation. */
    // "allowJs": true,                       /* Allow javascript files to be compiled. */
    // "checkJs": true,                       /* Report errors in .js files. */
    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */
    "declaration": true /* Generates corresponding '.d.ts' file. */,
    // "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */
    "sourceMap": true /* Generates corresponding '.map' file. */,
    // "outFile": "./",                       /* Concatenate and emit output to single file. */
    "outDir": "./dist" /* Redirect output structure to the directory. */,
    // "rootDir": "./src/",                   /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // "composite": true,                     /* Enable project compilation */
    "removeComments": false, /* Do not emit comments to output. */
    // "noEmit": true,                        /* Do not emit outputs. */
    // "importHelpers": true,                 /* Import emit helpers from 'tslib'. */
    // "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */

    /* Strict Type-Checking Options */
    // "strict": true,                        /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,              /* Enable strict null checks. */
    // "strictFunctionTypes": true,           /* Enable strict checking of function types. */
    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */
    // "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */

    /* Additional Checks */
    // "noUnusedLocals": true,                /* Report errors on unused locals. */
    // "noUnusedParameters": true,            /* Report errors on unused parameters. */
    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */
    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */

    /* Module Resolution Options */
    // "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */
    // "paths": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    // "typeRoots": [],                       /* List of folders to include type definitions from. */
    // "types": [],                           /* Type declaration files to be included in compilation. */
    // "allowSyntheticDefaultImports": true   /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */,
       "esModuleInterop": true                /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    // "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */

    /* Source Map Options */
    // "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */
    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */

    /* Experimental Options */
    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */
    // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */
  },
  "typedocOptions": {
    "entryPoints": [
      "src/index.ts",
      "./package.json"
    ],
    "out": "api-docs",
  },
  "include": ["src/**/*"],
  "exclude": ["src/middleware/middleware.ts", "img/*"]
}

```

`typedoc.json`:

```json
{
  "disableSources": true,
  "entryPoints": ["src/index.ts"],
  "excludeExternals": true,
  "excludePrivate": true,
  "excludeProtected": true,
  "includeVersion": true,
  "out": "api-docs",
  "theme": "pages-plugin",
  "media": "media",
  "pages": {
    "groups": [
      {
        "title": "Getting Started",
        "pages": [
          {
            "title": "Installation",
            "source": "./docs/getting-started/installation.md"
          },
          {
            "title": "Creating a Client",
            "source": "./docs/getting-started/creating-client.md"
          },
          {
            "title": "Basic Functions",
            "source": "./docs/getting-started/basic-functions.md"
          }
        ]
      }
    ]
  }
}

```