Project Path: arc_gmh5225_scfw_fxrdtvl7

Source Tree:

```txt
arc_gmh5225_scfw_fxrdtvl7
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── assets
│   ├── kernel_driver.c
│   ├── kernel_query_user.png
│   └── opengl_triangle.png
├── bin
│   ├── x64
│   │   ├── empty.bin
│   │   ├── kernel_query_user.bin
│   │   ├── messagebox.bin
│   │   ├── opengl_triangle.bin
│   │   ├── scrun.exe
│   │   ├── writeconsole.bin
│   │   └── writeconsole_xor.bin
│   └── x86
│       ├── empty.bin
│       ├── kernel_query_user.bin
│       ├── messagebox.bin
│       ├── opengl_triangle.bin
│       ├── scrun.exe
│       ├── writeconsole.bin
│       └── writeconsole_xor.bin
├── cmake
│   ├── llvm_paths.cmake
│   ├── post-build
│   │   ├── print_size.cmake
│   │   └── verify_pe.cmake
│   ├── scfw.cmake
│   ├── toolchain.cmake
│   └── winsdk.cmake
├── examples
│   ├── CMakeLists.txt
│   ├── empty
│   │   ├── CMakeLists.txt
│   │   └── main.cpp
│   ├── kernel_query_user
│   │   ├── CMakeLists.txt
│   │   └── main.cpp
│   ├── messagebox
│   │   ├── CMakeLists.txt
│   │   └── main.cpp
│   ├── opengl_triangle
│   │   ├── CMakeLists.txt
│   │   └── main.cpp
│   ├── writeconsole
│   │   ├── CMakeLists.txt
│   │   └── main.cpp
│   └── writeconsole_xor
│       ├── CMakeLists.txt
│       └── main.cpp
├── lib
│   ├── CMakeLists.txt
│   ├── include
│   │   └── scfw
│   │       ├── crt0.h
│   │       ├── platform
│   │       │   └── windows
│   │       │       ├── common.h
│   │       │       ├── kernelmode.h
│   │       │       └── usermode.h
│   │       ├── runtime
│   │       │   ├── fnv1a.h
│   │       │   ├── pic.h
│   │       │   └── xorstr.h
│   │       └── runtime.h
│   └── src
│       ├── arch
│       │   ├── x64
│       │   │   ├── init.S
│       │   │   └── start.S
│       │   └── x86
│       │       ├── init.S
│       │       └── start.S
│       └── crt0.c
├── scripts
│   ├── build-all.ps1
│   ├── build-all.sh
│   ├── fetch-winsdk.ps1
│   └── fetch-winsdk.sh
└── tools
    ├── CMakeLists.txt
    └── scrun.c

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)
project(scfw C CXX ASM)

if(NOT CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    message(FATAL_ERROR "This project requires Clang or AppleClang")
endif()

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

include(cmake/scfw.cmake)
add_subdirectory(lib)
add_subdirectory(examples)
add_subdirectory(tools)

```

`CMakePresets.json`:

```json
{
    "version": 3,
    "configurePresets": [
        {
            "name": "x64",
            "displayName": "x64 Release",
            "generator": "Ninja",
            "binaryDir": "${sourceDir}/build-x64",
            "toolchainFile": "${sourceDir}/cmake/toolchain.cmake",
            "cacheVariables": {
                "SCFW_TARGET": "x64",
                "CMAKE_BUILD_TYPE": "Release"
            }
        },
        {
            "name": "x64-debug",
            "displayName": "x64 Debug",
            "generator": "Ninja",
            "binaryDir": "${sourceDir}/build-x64-debug",
            "toolchainFile": "${sourceDir}/cmake/toolchain.cmake",
            "cacheVariables": {
                "SCFW_TARGET": "x64",
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "x86",
            "displayName": "x86 Release",
            "generator": "Ninja",
            "binaryDir": "${sourceDir}/build-x86",
            "toolchainFile": "${sourceDir}/cmake/toolchain.cmake",
            "cacheVariables": {
                "SCFW_TARGET": "x86",
                "CMAKE_BUILD_TYPE": "Release"
            }
        },
        {
            "name": "x86-debug",
            "displayName": "x86 Debug",
            "generator": "Ninja",
            "binaryDir": "${sourceDir}/build-x86-debug",
            "toolchainFile": "${sourceDir}/cmake/toolchain.cmake",
            "cacheVariables": {
                "SCFW_TARGET": "x86",
                "CMAKE_BUILD_TYPE": "Debug"
            }
        }
    ],
    "buildPresets": [
        {
            "name": "x64",
            "configurePreset": "x64"
        },
        {
            "name": "x64-debug",
            "configurePreset": "x64-debug"
        },
        {
            "name": "x86",
            "configurePreset": "x86"
        },
        {
            "name": "x86-debug",
            "configurePreset": "x86-debug"
        }
    ]
}

```

`LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2026 Petr Benes

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# scfw

A cross-platform C++ framework for building Windows shellcode.
Supports Linux, macOS, or Windows development environments.
Creates position-independent blob that runs in user-mode or kernel-mode, x86 or x64.

```cpp
#include <scfw/runtime.h>
#include <scfw/platform/windows/usermode.h>

IMPORT_BEGIN();
    IMPORT_MODULE("kernel32.dll");
        IMPORT_SYMBOL(WriteConsoleA);
IMPORT_END();

namespace sc {

extern "C" void __fastcall entry(void* argument1, void* argument2)
{
    HANDLE StdOut = NtCurrentPeb()->ProcessParameters->StandardOutput;
    WriteConsoleA(StdOut, _T("Hello, World!\n"), 14, NULL, NULL);
}

} // namespace sc
```

Build it, extract the `.text` section, and you have a self-contained shellcode binary that resolves its own imports at runtime.

## Motivation

As with all my projects, it boils down to _"I need that, current solutions were unsatisfactory, and I want to learn something"_.

I like to experiment with <abbr title="Virtual Machine Introspection">VMI</abbr> and sometimes it's really useful to be able to inject a piece of code into the memory of some process (and/or kernel) and execute it. And because [`vmi-rs`](https://github.com/vmi-rs/vmi) development happens on Linux, and my daily driver became macOS, I wanted a convenient way to generate Windows shellcode on them.

Although compression and "non-null" shellcode are not the primary goals of this project, they might be interesting additions in the future.

## Table of Contents

- [Motivation](#motivation)
- [Installation](#installation)
- [Building](#building)
- [Running Shellcode](#running-shellcode)
- [Architecture](#architecture)
  - [The Dispatch Table](#the-dispatch-table)
  - [Section Layout](#section-layout)
  - [Position-Independent Code](#position-independent-code)
- [User-Mode Shellcode](#user-mode-shellcode)
- [Kernel-Mode Shellcode](#kernel-mode-shellcode)
- [Compile-Time Options](#compile-time-options)
- [Per-Entry Flags](#per-entry-flags)
- [CMake Build Options](#cmake-build-options)
- [Examples](#examples)
- [License](#license)

## Installation

### Prerequisites

_scfw_ cross-compiles Windows shellcode from any host OS. You don't need a Windows machine to build.

- **CMake** 3.22+
- **Ninja** build system
- **clang** clang 19+
  - _**Note:**_ On Windows, [clang 21+ currently experiences issues with `/FILEALIGN:1` during linking](https://github.com/llvm/llvm-project/issues/180406).
    If you encounter linker errors, try to compile with `-DSCFW_FILE_ALIGNMENT=0` or switch to older clang version.
- **LLVM tools**: `lld-link`, `llvm-objcopy`, `llvm-readobj`
- **Windows SDK** headers and libraries (can be fetched automatically on any platform, see below)

### Dependencies

**[phnt](https://github.com/winsiderss/phnt)** (Windows native API headers) is fetched automatically by CMake via `FetchContent`. No action needed.

**Windows SDK** is the only dependency that requires some setup, especially on non-Windows hosts. On Windows with MSVC, CMake detects the system SDK automatically. On macOS and Linux (or Windows without the SDK), CMake will tell you it's missing and suggest how to fetch it.

The easiest option is to let CMake download it for you:

```bash
cmake --preset x64 -DSCFW_FETCH_WINSDK=ON
```

This runs `scripts/fetch-winsdk.sh` (or `fetch-winsdk.ps1` on Windows), which uses [xwin](https://github.com/Jake-Shadle/xwin) to download the Windows SDK. If `xwin` isn't installed, the script looks for Rust toolchain and installs `xwin` via `cargo install`. If Rust isn't installed either, the script downloads a temporary Rust toolchain, installs `xwin`, downloads the SDK, and then cleans up both the Rust toolchain and `xwin`. Nothing is left behind on your system - the temporary installations are fully isolated.

Alternatively, you can manually place the Windows SDK into the `winsdk/` directory at the project root. The expected structure is:

```
winsdk/
  crt/
    include/
    lib/{x86,x86_64}/
  sdk/
    include/{ucrt,um,shared}/
    lib/{um,ucrt}/{x86,x86_64}/
```

## Building

The project uses CMake presets for convenience:

```bash
# x64 Release
cmake --preset x64
cmake --build build-x64

# x86 Release
cmake --preset x86
cmake --build build-x86
```

Debug builds are also available (`x64-debug`, `x86-debug`), but shellcode extraction is disabled in Debug mode. You get a PE executable for debugging instead.

After building, each example produces both a `.exe` and a `.bin` (the extracted shellcode).

## Running Shellcode

The `scrun` tool loads a shellcode binary into executable memory and runs it. It's built alongside the examples and requires Windows to run.

```
.\build-x64\tools\scrun.exe .\build-x64\examples\writeconsole\writeconsole.bin
.\build-x64\tools\scrun.exe .\build-x64\examples\opengl_triangle\opengl_triangle.bin
.\build-x86\tools\scrun.exe .\build-x86\examples\messagebox\messagebox.bin
```

`scrun` accepts two optional arguments that are passed to the shellcode via the first and second parameters (RCX/ECX and RDX/EDX respectively):

```
.\build-x64\tools\scrun.exe shellcode.bin 0x12345 0x67890
```

After the shellcode returns, `scrun` checks whether the shellcode freed its own memory (i.e. whether `SCFW_OPT_CLEANUP` was enabled) and reports the result.

> **Fun fact:** on Windows on ARM64, the binary translation layer can run both x86 and x64 shellcodes via `scrun`. However, when emulating x64, `xtajit64.dll` (or `xtajit64se.dll`) is the 2nd module in the PEB load order instead of `kernel32.dll`, which breaks the fast-path lookup. If your shellcode imports from `kernel32.dll` and you want it to work under ARM64 emulation, define `SCFW_ENABLE_FULL_MODULE_SEARCH` to use the generic PEB walker instead.

<p align="center">
    <img src="assets/opengl_triangle.png" alt="scrun output" width="600">
    <br>
    <em>Those who'd like to point out that more impressive sub-4kB demos exist will be mercilessly frowned upon.</em>
</p>

## Architecture

_scfw_ compiles your code into a PE executable, then extracts the `.text` section as a raw binary. The trick is getting everything (code, data, constants, and the import resolution logic) into that single section, in the right order, with no absolute address fixups.

### The Dispatch Table

The core of _scfw_ is a dispatch table built entirely at compile time using C++ template metaprogramming. Each `IMPORT_MODULE` and `IMPORT_SYMBOL` macro creates a new template specialization that inherits from the previous one, forming a chain:

```
dispatch_table_impl<0, Mode>         base class
  - holds fn pointers: cleanup_, free_, load_module_, unload_module_, lookup_symbol_
  - provides find_module(), lookup_symbol()
        |
dispatch_table_impl<1, Mode>         IMPORT_MODULE("kernel32.dll")
  - adds: module_ (handle to loaded/found module)
  - init() calls find_module() or load_module()
        |
dispatch_table_impl<2, Mode>         IMPORT_SYMBOL(WriteConsoleA)
  - adds: slot_WriteConsoleA_ (typed function pointer)
  - init() resolves the symbol from the parent module
        |
dispatch_table                       IMPORT_END (final alias)
```

The `__COUNTER__` macro gives each entry a unique ID, and `IMPORT_END()` seals the chain, instantiates a global `__dispatch_table`, and generates the `_entry()` wrapper function. This wrapper initializes the dispatch table (resolving all modules and symbols), calls your `entry()` function, and optionally tears things down (e.g. `FreeLibrary` for dynamically loaded modules).

After `IMPORT_END()`, imported symbols are accessible through proxy objects in the `sc` namespace. When you write `WriteConsoleA(...)` in your code, it reads the function pointer from the dispatch table and calls through it. There's no runtime metadata, no string tables, no relocation records. Just a flat struct of function pointers.

### Section Layout

The linker merges `.data` and `.rdata` into `.text`, producing a single PE section with read/write/execute permissions. Within `.text`, ordering is controlled via MSVC-style subsection naming (`.text$00`, `.text$10`, ...), which the linker sorts alphabetically:

```
Section       Contents                    Source
.text$00      _init                       lib/src/arch/*/init.S
.text$10      _start, _pc, _cleanup_*     lib/src/arch/*/start.S
.text$20      _entry                      generated by IMPORT_END()
.text$aaa     framework code              runtime.h, crt0.h, ...
.text$yyy     user code                   your entry() and everything after
```

`_init` is the PE entry point. It must be at the very beginning of the binary since that's where execution starts when you jump to the shellcode's base address. The startup code, dispatch table initialization, and user code follow in a deterministic order.

After building, a post-build step verifies the PE has exactly one section (or two, if debug info is enabled) and extracts `.text` to the final `.bin` file using `llvm-objcopy`.

### Position-Independent Code

Shellcode can be loaded at any address, so all memory references must be position-independent. This is where x86 and x64 diverge.

**x64** has RIP-relative addressing, so `mov rax, [rip + symbol]` just works. The compiler generates position-independent code by default and `_pic()` is a no-op. Nothing special is needed.

**x86** doesn't have an instruction pointer-relative addressing mode. The compiler generates absolute addresses like `mov eax, offset symbol`, and those addresses are wrong when the shellcode is loaded somewhere other than its compile-time base.

_scfw_ solves this with a runtime PIC relocation scheme. It relies on the fact that while absolute addresses change, the *differences* between addresses stay the same no matter where the code is loaded. The `_pc()` function (implemented via the classic `call`/`pop` trick) returns its own runtime address:

```asm
_pc:
    call    1f
1:  pop     eax
    sub     eax, 5      ; call is 5 bytes
    ret
```

Then `_pic()` computes the correct runtime address of any compile-time symbol:

```
runtime_addr = _pc() - &_pc + compile_time_addr
```

In practice, the `_()` macro wraps this: on x86, `_(ptr)` applies the PIC delta; on x64, it's a pass-through. You'll see this in code like `wc.lpfnWndProc = _(&WndProc)` - on x86, function pointer addresses need the PIC adjustment too.

The linker flag `/FIXED` is used on x86 to suppress base relocations. Since _scfw_'s PIC scheme only relies on address *differences* (which are base-independent), no `.reloc` section is needed.

## User-Mode Shellcode

For user-mode shellcode, include `<scfw/platform/windows/usermode.h>`. Modules are found by walking the PEB's `InLoadOrderModuleList` and matching names. By default, `ntdll.dll` and `kernel32.dll` get a fast-path lookup (they're always the 2nd and 3rd entries in the list), while other modules require either a full PEB walk or `LoadLibraryA`.

The entry point signature is:

```cpp
extern "C" void __fastcall entry(void* argument1, void* argument2);
```

Both parameters are passed through from whoever invokes the shellcode. You can use them for whatever you want, or just ignore them.

If the shellcode doesn't use `SCFW_FLAG_DYNAMIC_LOAD`, then any modules it imports must already be loaded in the target process. If a module or symbol can't be resolved, the shellcode gracefully exits rather than crashing.

You can `#include <windows.h>` normally. Though the platform headers already include it along with _phnt_.

## Kernel-Mode Shellcode

_scfw_ also supports kernel-mode shellcode. Include `<scfw/platform/windows/kernelmode.h>` instead of the usermode header. See the `kernel_query_user` example for demonstration.

Kernel-mode shellcode expects the **ntoskrnl image base** to be passed as the first argument (ECX on x86, RCX on x64). This is deliberate - there isn't a reliable way to locate `ntoskrnl.exe` from kernel-mode code without risking crashes due to gaps between ntoskrnl sections. The example [kernel driver](assets/kernel_driver.c) shows how to obtain the image base using `RtlPcToFileHeader` and pass it to the shellcode:

```c
PVOID KernelBase = NULL;
RtlPcToFileHeader((PVOID)&RtlPcToFileHeader, &KernelBase);

((PSHELLCODE_ROUTINE)Shellcode)(KernelBase, PsGetCurrentProcess());
```

A few things to keep in mind (with not only kernel-mode shellcode):

- **Import only exported functions.** Some functions that appear in ntoskrnl headers are internal and can change between Windows releases or architectures. Stick to documented, exported symbols.
- **Variadic functions work.** You can use the sweet `DbgPrintEx` and `printf`. The `kernel_query_user` example uses `DbgPrintEx` to print formatted output.
- **Data symbol pointers are supported.** The `kernel_query_user` example imports `SeTokenObjectType` as a `POBJECT_TYPE*` - a pointer to a data symbol rather than a function.
- **No WDK required, but you'll need to define kernel types yourself.** Since there's no WDK in the build, you have to redeclare the kernel structures and prototypes you need (see the `kernel_query_user` example for how this looks in practice). The _phnt_ library may provide some useful definitions.
- **If a symbol can't be resolved, the shellcode exits gracefully.** Same as user-mode, no crashes on missing imports.
- **You can't test kernel shellcode with `scrun`.** Obviously. You'll have to take my word for it (or build a [test driver](assets/kernel_driver.c) and try it yourself).

<p align="center">
    <img src="assets/kernel_query_user.png" alt="kernel_query_user output" width="400">
</p>

## Compile-Time Options

These are `#define`d before including `runtime.h`, or set via CMake target definitions. The defaults are chosen to produce the smallest possible shellcode. Each option you enable adds code.

| Option | Default | Description |
|--------|---------|-------------|
| `SCFW_ENABLE_LOAD_MODULE` | Off | Resolves `LoadLibraryA` at init time. Required if any module uses `SCFW_FLAG_DYNAMIC_LOAD` to load DLLs not already present in the target process. |
| `SCFW_ENABLE_UNLOAD_MODULE` | Off | Resolves `FreeLibrary` at init time. Required by `SCFW_FLAG_DYNAMIC_UNLOAD`. Only meaningful together with `DYNAMIC_LOAD`. |
| `SCFW_ENABLE_LOOKUP_SYMBOL` | Off | Resolves `GetProcAddress` at init time. Required by `SCFW_FLAG_DYNAMIC_RESOLVE`. Useful when the manual PE export walker isn't sufficient (e.g. forwarded exports). |
| `SCFW_ENABLE_XOR_STRING` | Off | XOR-encodes all strings passed through `_T()` at compile time. Decoded in-place on first access at runtime. Prevents module names, symbol names, and user strings from appearing in plaintext in the binary. Each string gets a key derived from `__LINE__`, so identical strings at different call sites have different encodings. |
| `SCFW_ENABLE_CLEANUP` | Off | The shellcode frees its own memory on exit via `VirtualFree` (user-mode) or `ExFreePool` (kernel-mode). **Must be set via the CMake option** `SCFW_OPT_CLEANUP`, not just `#define`d, because the assembly startup code depends on it. |
| `SCFW_ENABLE_FULL_MODULE_SEARCH` | Off | Disables the fast-path optimization for `ntdll.dll` and `kernel32.dll` (which reads them from hardcoded PEB offsets). When you're dynamically loading many modules anyway, the fast-path code is dead weight and this saves a few bytes. |
| `SCFW_ENABLE_FIND_MODULE_FORWARDER` | Off | Enables forwarded PE export handling in the manual export walker. Some exports redirect to another DLL (e.g., `user32!DefWindowProcA` forwards to `ntdll!NtdllDefWindowProc_A`). When enabled, the walker detects these and recursively resolves the target. Adds code size. |
| `SCFW_ENABLE_INIT_MODULES_BY_STRING` | Off | Uses string comparison instead of hash for module name matching during the base initialization. Adds plaintext module names to the binary. |
| `SCFW_ENABLE_INIT_SYMBOLS_BY_STRING` | Off | Uses string comparison instead of hash for symbol name matching during the base initialization. Adds plaintext symbol names to the binary. |

The `opengl_triangle` example is a good reference for seeing how these options interact in practice. It demonstrates several configurations with commentary on the size/compatibility trade-offs.

## Per-Entry Flags

Flags are passed via the `FLAGS()` macro in `IMPORT_MODULE` or `IMPORT_SYMBOL` declarations. You can also set defaults that apply to all entries:

```cpp
// Apply DYNAMIC_LOAD to all modules by default
#define SCFW_MODULE_DEFAULT_FLAGS  (SCFW_FLAG_DYNAMIC_LOAD)

// Per-module override: kernel32.dll is always loaded, skip LoadLibraryA
IMPORT_MODULE("kernel32.dll", FLAGS(0));
```

| Flag | Value | Description |
|------|-------|-------------|
| `SCFW_FLAG_DYNAMIC_RESOLVE` | `0x01` | Use `GetProcAddress` for symbol lookup instead of manually walking the PE export table. Implies `STRING_SYMBOL`. Set on a module to apply to all its symbols. Requires `SCFW_ENABLE_LOOKUP_SYMBOL`. |
| `SCFW_FLAG_DYNAMIC_LOAD` | `0x02` | Use `LoadLibraryA` to load the module instead of finding it in the PEB. For DLLs not already loaded in the target process (e.g. `user32.dll`, `opengl32.dll`). Requires `SCFW_ENABLE_LOAD_MODULE`. |
| `SCFW_FLAG_DYNAMIC_UNLOAD` | `0x04` | Call `FreeLibrary` on the module during teardown. Only valid together with `DYNAMIC_LOAD`. Requires `SCFW_ENABLE_UNLOAD_MODULE`. |
| `SCFW_FLAG_STRING_MODULE` | `0x08` | Match module names by string comparison instead of hash. Results in the full module name string being present in the binary. |
| `SCFW_FLAG_STRING_SYMBOL` | `0x10` | Match symbol names by string comparison instead of hash. Results in the full symbol name string being present in the binary. |

The defaults (`SCFW_MODULE_DEFAULT_FLAGS` and `SCFW_ENTRY_DEFAULT_FLAGS`) are both `0` unless you override them before including `runtime.h`.

## CMake Build Options

These are set globally via CMake cache variables and can be overridden per-target using CMake target properties.

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `SCFW_OPT_LTO` | `BOOL` | `ON` | Enable Link-Time Optimization. Generally reduces shellcode size by allowing the linker to eliminate dead code across translation units. However, it can sometimes *increase* size. The `opengl_triangle` example intentionally disables it because LTO produced a larger binary in that case. |
| `SCFW_OPT_DEBUG_INFO` | `BOOL` | `OFF` | Create a `.pdb` file and include CodeView debug info in the output PE. Useful for debugging with a disassembler, but adds an `.rdata` section to the PE. |
| `SCFW_OPT_CLEANUP` | `BOOL` | `OFF` | Enable self-cleanup. The shellcode calls `VirtualFree` (user-mode) or `ExFreePool` (kernel-mode) to free its own memory before returning. This maps to `SCFW_ENABLE_CLEANUP` and also controls whether the assembly startup wrapper (`start.S`) is linked in. |
| `SCFW_FUNCTION_ALIGNMENT` | `STRING` | `1` | Function alignment in bytes. The default of 1 means no padding between functions, producing the smallest binary. Set this to `0` to use the linker's default function alignment. Affects both C++ code (`-falign-functions=N`) and assembly (`.p2align`). |
| `SCFW_FILE_ALIGNMENT` | `STRING` | `1` | PE file alignment in bytes. The default of 1 produces the smallest possible PE, but it's technically an invalid PE. Windows loaders (and even IDA Pro) may reject it. The shellcode itself works fine. Set this to `0` to use the linker's default file alignment, which produces a valid PE that you can execute directly as an `.exe`, at the cost of some padding. |
| `SCFW_OPT_ZERO_BASE` | `BOOL` | `OFF` | x86 only. Sets the PE image base to 0 (`/BASE:0`), so shellcode offsets match raw file offsets. Handy for analysis, but doesn't reduce shellcode size (x86 `imm32` is always 4 bytes regardless of value) and makes the `.exe` non-executable. |

Per-target override example:

```cmake
add_executable(opengl_triangle main.cpp)
target_link_libraries(opengl_triangle PRIVATE scfw)

# LTO makes this particular binary bigger, so disable it
set_target_properties(opengl_triangle PROPERTIES SCFW_OPT_LTO OFF)

scfw_extract_shellcode(opengl_triangle)
```

## Examples

| Example | x86 | x64 | Description |
|---------|----:|----:|-------------|
| `empty` | 16 B | 8 B | Bare-minimum template with an empty `entry()` function. Use as a starting point. |
| `writeconsole` | 319 B | 303 B | Writes "Hello, World!" to the console via `WriteConsoleA`. Simplest useful example. |
| `writeconsole_xor` | 377 B | 373 B | Same as `writeconsole`, but built with `SCFW_ENABLE_XOR_STRING`. All strings are XOR-encoded in the binary and decoded at runtime. |
| `messagebox` | 495 B | 459 B | Shows a `MessageBoxA` dialog. Demonstrates `SCFW_FLAG_DYNAMIC_LOAD` since `user32.dll` isn't loaded by default in console processes. |
| `opengl_triangle` | 2171 B | 2433 B | Renders an OpenGL triangle from shellcode. Dynamically loads `user32.dll`, `gdi32.dll`, and `opengl32.dll`. Extensively documented with commentary on compile-time option trade-offs. Refer to this example for practical demonstrations of options and flags in action. |
| `kernel_query_user` | 3184 B | 3268 B | Kernel-mode shellcode that queries the current process's user information (domain, username, SID) and prints it via `DbgPrintEx`. Demonstrates kernel-mode imports, data symbol pointers (`SeTokenObjectType`), and variadic function calls. |

## See Also

- **[Stardust]**: A similar project by [Cracked5pider].

## License

This project is licensed under the MIT license.

[Stardust]: https://github.com/Cracked5pider/Stardust
[Cracked5pider]: https://github.com/Cracked5pider

```

`assets/kernel_driver.c`:

```c
#include <ntddk.h>

//
// Suppress "nonstandard extension used: nameless struct/union" warnings.
//
#pragma warning (disable : 4201)

#define MEMORY_TAG '  cS'

typedef (__fastcall* PSHELLCODE_ROUTINE)(PVOID Argument1, PVOID Argument2);
UCHAR ShellcodeData[] = {
    // Paste your shellcode bytes here.
    0x90, 0x90, 0xC3
};

NTSYSAPI
PVOID
NTAPI
RtlPcToFileHeader (
    _In_ PVOID PcValue,
    _Out_ PVOID* BaseOfImage
    );

NTSTATUS
NTAPI
DriverEntry (
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    )
{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // Get the ntoskrnl.exe ImageBase.
    //

    PVOID KernelBase = NULL;
    RtlPcToFileHeader((PVOID)&RtlPcToFileHeader, &KernelBase);

    if (!KernelBase)
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   "[!] Cannot determine ntoskrnl.exe ImageBase!\n");
        return STATUS_NOT_FOUND;
    }

    //
    // Allocate memory for the shellcode.
    //

    PVOID Shellcode = ExAllocatePoolWithTag(NonPagedPool,
                                            sizeof(ShellcodeData),
                                            MEMORY_TAG);
    if (!Shellcode)
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   "[!] Cannot allocate memory for the shellcode!\n");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(Shellcode, ShellcodeData, sizeof(ShellcodeData));

    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               DPFLTR_ERROR_LEVEL,
               "[ ] Loaded %lu bytes at 0x%p\n",
               sizeof(ShellcodeData),
               Shellcode);

    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               DPFLTR_ERROR_LEVEL,
               "[ ] Executing shellcode\n\n");

    //
    // Run it!
    //

    ((PSHELLCODE_ROUTINE)Shellcode)(KernelBase, PsGetCurrentProcess());

    //
    // Check if the shellcode cleaned up after itself.
    //
    // N.B. This is obviously dangerous. If it did clean up after itself,
    //      the memory might not be mapped at all.
    //


    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               DPFLTR_ERROR_LEVEL,
               "\n[ ] Shellcode returned\n");

    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               DPFLTR_ERROR_LEVEL,
               "-------------------------------------------------------------\n");

    return STATUS_UNSUCCESSFUL;
}

```

`cmake/llvm_paths.cmake`:

```cmake
# LLVM tool search paths (cross-platform)
# Included by both toolchain.cmake and scfw.cmake
set(SCFW_LLVM_SEARCH_PATHS
    # macOS Homebrew
    /opt/homebrew/opt/llvm/bin
    /usr/local/opt/llvm/bin
    # Linux
    /usr/lib/llvm-22/bin
    /usr/lib/llvm-21/bin
    /usr/lib/llvm-20/bin
    /usr/lib/llvm-19/bin
    /usr/bin
    # Windows
    "$ENV{ProgramFiles}/LLVM/bin"
    "$ENV{ProgramW6432}/LLVM/bin"
)

```

`cmake/post-build/print_size.cmake`:

```cmake
if(NOT DEFINED BIN_FILE)
    message(FATAL_ERROR "BIN_FILE not specified")
endif()

if(NOT EXISTS "${BIN_FILE}")
    message(FATAL_ERROR "Binary file not found: ${BIN_FILE}")
endif()

file(SIZE "${BIN_FILE}" SIZE_BYTES)
message(STATUS "Shellcode size: ${SIZE_BYTES} bytes")

```

`cmake/post-build/verify_pe.cmake`:

```cmake
# verify_pe.cmake
# Build-time verification of PE section layout.
# Accepts .text only, or .text + .rdata (debug/export info kept out of shellcode).

if(NOT LLVM_READOBJ)
    message(FATAL_ERROR "LLVM_READOBJ not specified")
endif()

if(NOT PE_FILE)
    message(FATAL_ERROR "PE_FILE not specified")
endif()

if(NOT EXISTS "${PE_FILE}")
    message(FATAL_ERROR "PE file not found: ${PE_FILE}")
endif()

# Run llvm-readobj to get file headers
execute_process(
    COMMAND ${LLVM_READOBJ} --file-headers ${PE_FILE}
    OUTPUT_VARIABLE HEADERS_OUTPUT
    ERROR_VARIABLE READOBJ_ERROR
    RESULT_VARIABLE READOBJ_RESULT
)

if(NOT READOBJ_RESULT EQUAL 0)
    message(FATAL_ERROR "llvm-readobj failed: ${READOBJ_ERROR}")
endif()

# Extract SectionCount from output
string(REGEX MATCH "SectionCount: ([0-9]+)" MATCH_RESULT "${HEADERS_OUTPUT}")
if(NOT MATCH_RESULT)
    message(FATAL_ERROR "Could not find SectionCount in llvm-readobj output")
endif()

set(SECTION_COUNT "${CMAKE_MATCH_1}")

if(SECTION_COUNT EQUAL 1)
    message(STATUS "PE verification PASSED: 1 section (.text)")
elseif(SECTION_COUNT EQUAL 2)
    # Get section details to verify .rdata is the second section
    execute_process(
        COMMAND ${LLVM_READOBJ} --sections ${PE_FILE}
        OUTPUT_VARIABLE SECTIONS_OUTPUT
    )
    # Check that we have .text and .rdata (debug/export info stays in .rdata, not in .bin)
    string(FIND "${SECTIONS_OUTPUT}" "Name: .text" HAS_TEXT)
    string(FIND "${SECTIONS_OUTPUT}" "Name: .rdata" HAS_RDATA)
    if(HAS_TEXT EQUAL -1 OR HAS_RDATA EQUAL -1)
        string(REGEX MATCHALL "Name: ([^\n]+)" SECTION_NAMES "${SECTIONS_OUTPUT}")
        message(FATAL_ERROR
            "PE verification FAILED!\n"
            "Expected .text and .rdata sections, found: ${SECTION_NAMES}\n"
            "File: ${PE_FILE}"
        )
    endif()
    message(STATUS "PE verification PASSED: 2 sections (.text + .rdata)")
else()
    # Get section details for error message
    execute_process(
        COMMAND ${LLVM_READOBJ} --sections ${PE_FILE}
        OUTPUT_VARIABLE SECTIONS_OUTPUT
    )
    # Extract section names
    string(REGEX MATCHALL "Name: ([^\n]+)" SECTION_NAMES "${SECTIONS_OUTPUT}")
    message(FATAL_ERROR
        "PE verification FAILED!\n"
        "Expected 1-2 sections, found ${SECTION_COUNT}.\n"
        "Sections found: ${SECTION_NAMES}\n"
        "This indicates data sections were not properly merged into .text.\n"
        "Check linker flags: /MERGE:...\n"
        "File: ${PE_FILE}"
    )
endif()

```

`cmake/scfw.cmake`:

```cmake
# Global options (can be overridden per-target via properties)
option(SCFW_OPT_LTO "Enable Link-Time Optimization" ON)
option(SCFW_OPT_DEBUG_INFO "Enable debug info in output binary (PDB/CodeView on Windows)" OFF)
option(SCFW_OPT_CLEANUP "Enable self-cleanup (free shellcode memory on exit)" OFF)
option(SCFW_OPT_ZERO_BASE "Set PE image base to 0 on x86" OFF)
set(SCFW_FUNCTION_ALIGNMENT 1 CACHE STRING "Function alignment in bytes (default=1)")
set(SCFW_FILE_ALIGNMENT 1 CACHE STRING "PE file alignment in bytes (default=1)")

# Target is set by toolchain file via CMAKE_CXX_COMPILER_TARGET
if(NOT CMAKE_CXX_COMPILER_TARGET)
    message(FATAL_ERROR "CMAKE_CXX_COMPILER_TARGET not set. Use a toolchain file.")
endif()

# Force .exe extension for Windows PE files when cross-compiling
set(CMAKE_EXECUTABLE_SUFFIX ".exe")

# Set default build type to Release if not specified
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release CACHE STRING "Build type" FORCE)
endif()

# Load shared cmake modules
include(${CMAKE_CURRENT_LIST_DIR}/llvm_paths.cmake)
include(${CMAKE_CURRENT_LIST_DIR}/winsdk.cmake)

message(STATUS "Target: ${CMAKE_CXX_COMPILER_TARGET}")
message(STATUS "Build type: ${CMAKE_BUILD_TYPE}")

# Base compiler flags for position-independent, stdlib-free shellcode
set(SCFW_COMPILE_FLAGS
    -D_HAS_EXCEPTIONS=0
    -D_ALLOW_COMPILER_AND_STL_VERSION_MISMATCH
    -fno-exceptions
    -fno-rtti
    -fno-stack-protector
    -fno-unwind-tables
    -fno-asynchronous-unwind-tables
    -fdata-sections
    -ffunction-sections
    -fno-builtin
    -ffreestanding
    -fno-threadsafe-statics
    -gcodeview
    -mno-stack-arg-probe           # Disable __chkstk emission
    --target=${CMAKE_CXX_COMPILER_TARGET}

    ${SCFW_WINSDK_COMPILE_OPTIONS}

    # scfw provides implementations for SDK-declared functions
    -Wno-inconsistent-dllimport
)

if(CMAKE_SYSTEM_PROCESSOR STREQUAL "X86")
    list(APPEND SCFW_COMPILE_FLAGS
        -mno-sse
        -Xclang -fdefault-calling-conv=fastcall
    )
endif()

# Build-type specific optimization flags
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    list(APPEND SCFW_COMPILE_FLAGS -O0)
else()
    list(APPEND SCFW_COMPILE_FLAGS
        -Os
        -fmerge-all-constants      # Merge identical string literals and constants
    )
endif()

# Function alignment override
if(SCFW_FUNCTION_ALIGNMENT GREATER 0)
    list(APPEND SCFW_COMPILE_FLAGS -falign-functions=${SCFW_FUNCTION_ALIGNMENT})
endif()

# Linker flags
set(SCFW_LINK_FLAGS
    --target=${CMAKE_CXX_COMPILER_TARGET}
    -nostdlib
    -nostartfiles
    -fuse-ld=lld
    -Wl,/OPT:REF                   # Remove unreferenced code/data
    -Wl,/OPT:ICF                   # Merge identical COMDAT sections (string pooling)
)

# Require lld for linking
find_program(LLD_EXECUTABLE lld-link
    HINTS ${SCFW_LLVM_SEARCH_PATHS}
    REQUIRED
)
message(STATUS "Found lld: ${LLD_EXECUTABLE}")

# Find llvm-objcopy for shellcode extraction
find_program(LLVM_OBJCOPY llvm-objcopy
    HINTS ${SCFW_LLVM_SEARCH_PATHS}
    REQUIRED
)
message(STATUS "Found llvm-objcopy: ${LLVM_OBJCOPY}")

# Find llvm-readobj for PE verification
find_program(LLVM_READOBJ llvm-readobj
    HINTS ${SCFW_LLVM_SEARCH_PATHS}
    REQUIRED
)
message(STATUS "Found llvm-readobj: ${LLVM_READOBJ}")

# Cache paths for use in verification script
set(SCFW_CMAKE_DIR "${CMAKE_CURRENT_LIST_DIR}" CACHE INTERNAL "scfw cmake directory")

# Define inherited properties (target -> directory -> global)
define_property(TARGET PROPERTY SCFW_OPT_LTO INHERITED
    BRIEF_DOCS "Enable Link-Time Optimization"
    FULL_DOCS  "Generally reduces shellcode size by eliminating dead code"
               " across translation units. Can sometimes increase size."
               " Default: ON.")
define_property(DIRECTORY PROPERTY SCFW_OPT_LTO INHERITED
    BRIEF_DOCS "Enable Link-Time Optimization"
    FULL_DOCS  "Generally reduces shellcode size by eliminating dead code"
               " across translation units. Can sometimes increase size."
               " Default: ON.")
set_property(GLOBAL PROPERTY SCFW_OPT_LTO ${SCFW_OPT_LTO})

define_property(TARGET PROPERTY SCFW_OPT_DEBUG_INFO INHERITED
    BRIEF_DOCS "Enable debug info (PDB/CodeView)"
    FULL_DOCS  "Includes CodeView debug info in the output PE via /DEBUG."
               " Adds an .rdata section to the PE."
               " Useful for debugging with a disassembler."
               " Default: OFF.")
define_property(DIRECTORY PROPERTY SCFW_OPT_DEBUG_INFO INHERITED
    BRIEF_DOCS "Enable debug info (PDB/CodeView)"
    FULL_DOCS  "Includes CodeView debug info in the output PE via /DEBUG."
               " Adds an .rdata section to the PE."
               " Useful for debugging with a disassembler."
               " Default: OFF.")
set_property(GLOBAL PROPERTY SCFW_OPT_DEBUG_INFO ${SCFW_OPT_DEBUG_INFO})

define_property(TARGET PROPERTY SCFW_OPT_CLEANUP INHERITED
    BRIEF_DOCS "Enable self-cleanup"
    FULL_DOCS  "The shellcode frees its own memory on exit via VirtualFree"
               " (user-mode) or ExFreePool (kernel-mode)."
               " Maps to SCFW_ENABLE_CLEANUP and controls whether the"
               " assembly startup wrapper (start.S) is linked in."
               " Default: OFF.")
define_property(DIRECTORY PROPERTY SCFW_OPT_CLEANUP INHERITED
    BRIEF_DOCS "Enable self-cleanup"
    FULL_DOCS  "The shellcode frees its own memory on exit via VirtualFree"
               " (user-mode) or ExFreePool (kernel-mode)."
               " Maps to SCFW_ENABLE_CLEANUP and controls whether the"
               " assembly startup wrapper (start.S) is linked in."
               " Default: OFF.")
set_property(GLOBAL PROPERTY SCFW_OPT_CLEANUP ${SCFW_OPT_CLEANUP})

define_property(TARGET PROPERTY SCFW_FUNCTION_ALIGNMENT INHERITED
    BRIEF_DOCS "Function alignment in bytes"
    FULL_DOCS  "Controls padding between functions."
               " Default of 1 means no padding, producing the smallest binary."
               " Set to 0 to use the linker default."
               " Affects both C++ code (-falign-functions=N) and assembly (.p2align)."
               " Default: 1.")
define_property(DIRECTORY PROPERTY SCFW_FUNCTION_ALIGNMENT INHERITED
    BRIEF_DOCS "Function alignment in bytes"
    FULL_DOCS  "Controls padding between functions."
               " Default of 1 means no padding, producing the smallest binary."
               " Set to 0 to use the linker default."
               " Affects both C++ code (-falign-functions=N) and assembly (.p2align)."
               " Default: 1.")
set_property(GLOBAL PROPERTY SCFW_FUNCTION_ALIGNMENT ${SCFW_FUNCTION_ALIGNMENT})

define_property(TARGET PROPERTY SCFW_FILE_ALIGNMENT INHERITED
    BRIEF_DOCS "PE file alignment in bytes"
    FULL_DOCS  "The default of 1 produces the smallest PE, but it is technically"
               " invalid - Windows loaders and IDA Pro may reject it."
               " The shellcode itself works fine."
               " Set to 0 to use the linker default, producing a valid PE"
               " executable at the cost of some padding."
               " Default: 1.")
define_property(DIRECTORY PROPERTY SCFW_FILE_ALIGNMENT INHERITED
    BRIEF_DOCS "PE file alignment in bytes"
    FULL_DOCS  "The default of 1 produces the smallest PE, but it is technically"
               " invalid - Windows loaders and IDA Pro may reject it."
               " The shellcode itself works fine."
               " Set to 0 to use the linker default, producing a valid PE"
               " executable at the cost of some padding."
               " Default: 1.")
set_property(GLOBAL PROPERTY SCFW_FILE_ALIGNMENT ${SCFW_FILE_ALIGNMENT})

# Function to extract .text section to .bin file after building.
function(scfw_extract_shellcode target_name)
    # Apply LTO if enabled
    get_property(_lto TARGET ${target_name} PROPERTY SCFW_OPT_LTO)
    if(_lto)
        target_compile_options(${target_name} PRIVATE -flto)
        target_link_options(${target_name} PRIVATE -flto)
        message(STATUS "LTO enabled for ${target_name}")
    endif()

    # Apply debug info if enabled
    get_property(_debug_info TARGET ${target_name} PROPERTY SCFW_OPT_DEBUG_INFO)
    if(_debug_info)
        target_link_options(${target_name} PRIVATE -Wl,/DEBUG)
        message(STATUS "Debug info enabled for ${target_name}")
    endif()

    # Apply file alignment if set
    get_property(_file_align TARGET ${target_name} PROPERTY SCFW_FILE_ALIGNMENT)
    if(_file_align GREATER 0)
        target_link_options(${target_name} PRIVATE -Wl,/FILEALIGN:${_file_align})
        message(STATUS "File alignment set to ${_file_align} for ${target_name}")
    endif()

    # Extract shellcode only for non-Debug builds
    if(NOT CMAKE_BUILD_TYPE STREQUAL "Debug")
        set(_bin_file "$<TARGET_FILE_DIR:${target_name}>/${target_name}.bin")

        add_custom_command(TARGET ${target_name} POST_BUILD
            COMMAND ${CMAKE_COMMAND}
                -DLLVM_READOBJ=${LLVM_READOBJ}
                -DPE_FILE=$<TARGET_FILE:${target_name}>
                -P ${SCFW_CMAKE_DIR}/post-build/verify_pe.cmake
            COMMAND ${LLVM_OBJCOPY}
                --dump-section=.text=${_bin_file}
                $<TARGET_FILE:${target_name}>
            COMMAND ${CMAKE_COMMAND}
                -DBIN_FILE=${_bin_file}
                -P ${SCFW_CMAKE_DIR}/post-build/print_size.cmake
            COMMENT "Verifying and extracting shellcode: ${target_name}.bin"
            VERBATIM
        )
    else()
        message(STATUS "Shellcode extraction disabled for Debug build: ${target_name}")
    endif()
endfunction()

```

`cmake/toolchain.cmake`:

```cmake
# Unified toolchain for cross-compiling shellcode to Windows
# Usage: cmake -B build -DCMAKE_TOOLCHAIN_FILE=cmake/toolchain.cmake -DSCFW_TARGET=x64

set(CMAKE_SYSTEM_NAME Generic)

# Target architecture (x64 or x86)
if(NOT DEFINED SCFW_TARGET)
    set(SCFW_TARGET "x64" CACHE STRING "Target: x64 or x86")
endif()

if(SCFW_TARGET STREQUAL "x64")
    set(CMAKE_SYSTEM_PROCESSOR AMD64)
    set(SCFW_TRIPLE x86_64-pc-windows-msvc)
elseif(SCFW_TARGET STREQUAL "x86")
    set(CMAKE_SYSTEM_PROCESSOR X86)
    set(SCFW_TRIPLE i686-pc-windows-msvc)
else()
    message(FATAL_ERROR "SCFW_TARGET must be x64 or x86, got: ${SCFW_TARGET}")
endif()

# Load shared LLVM search paths
include(${CMAKE_CURRENT_LIST_DIR}/llvm_paths.cmake)

# Find clang - check common locations
if(NOT CMAKE_C_COMPILER)
    find_program(CLANG_C clang
        PATHS ${SCFW_LLVM_SEARCH_PATHS}
        NO_DEFAULT_PATH
    )
    if(NOT CLANG_C)
        find_program(CLANG_C clang)
    endif()
    if(CLANG_C)
        set(CMAKE_C_COMPILER "${CLANG_C}")
    endif()
endif()

if(NOT CMAKE_CXX_COMPILER)
    find_program(CLANG_CXX clang++
        PATHS ${SCFW_LLVM_SEARCH_PATHS}
        NO_DEFAULT_PATH
    )
    if(NOT CLANG_CXX)
        find_program(CLANG_CXX clang++)
    endif()
    if(CLANG_CXX)
        set(CMAKE_CXX_COMPILER "${CLANG_CXX}")
    endif()
endif()

# ASM uses C compiler
if(NOT CMAKE_ASM_COMPILER AND CMAKE_C_COMPILER)
    set(CMAKE_ASM_COMPILER "${CMAKE_C_COMPILER}")
endif()

# Set target triples
set(CMAKE_C_COMPILER_TARGET ${SCFW_TRIPLE})
set(CMAKE_CXX_COMPILER_TARGET ${SCFW_TRIPLE})
set(CMAKE_ASM_COMPILER_TARGET ${SCFW_TRIPLE})

# Disable macOS-specific settings (only on macOS)
if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin")
    set(CMAKE_OSX_ARCHITECTURES "")
    set(CMAKE_OSX_DEPLOYMENT_TARGET "")
    set(CMAKE_OSX_SYSROOT "")
endif()

# Skip compiler checks for cross-compilation
set(CMAKE_C_COMPILER_WORKS TRUE)
set(CMAKE_CXX_COMPILER_WORKS TRUE)
set(CMAKE_ASM_COMPILER_WORKS TRUE)

```

`cmake/winsdk.cmake`:

```cmake
# Windows SDK and phnt paths
#
# Options:
#   SCFW_FETCH_WINSDK           - download Windows SDK + CRT via xwin if not found (default: OFF)
#
# Sets:
#   SCFW_WINSDK_INCLUDE_DIRS    - include directories for Windows SDK headers + phnt
#   SCFW_WINSDK_LIB_DIRS        - library directories for CRT and SDK libs (xwin only)
#   SCFW_WINSDK_COMPILE_OPTIONS - warning suppressions for SDK/phnt headers

# Fetch phnt (Windows native API headers)
include(FetchContent)
FetchContent_Declare(
    phnt
    GIT_REPOSITORY https://github.com/winsiderss/phnt.git
    GIT_TAG        master
    GIT_SHALLOW    TRUE
)
FetchContent_MakeAvailable(phnt)

set(SCFW_WINSDK_INCLUDE_DIRS
    ${phnt_SOURCE_DIR}
)

set(SCFW_WINSDK_LIB_DIRS)

cmake_path(SET _winsdk_dir NORMALIZE "${CMAKE_CURRENT_LIST_DIR}/../winsdk")

option(SCFW_FETCH_WINSDK "Automatically fetch Windows SDK via xwin" OFF)

# On Windows, check if the compiler can find SDK headers natively (e.g., MSVC installed).
# On other hosts there is never a system Windows SDK, so skip the check entirely.
set(_SCFW_HAVE_SYSTEM_WINSDK FALSE)
if(CMAKE_HOST_WIN32)
    include(CheckIncludeFile)
    set(CMAKE_REQUIRED_QUIET TRUE)
    check_include_file(windows.h _SCFW_HAVE_SYSTEM_WINSDK)
endif()

if(NOT _SCFW_HAVE_SYSTEM_WINSDK AND NOT EXISTS "${_winsdk_dir}/sdk")
    if(SCFW_FETCH_WINSDK)
        set(_fetch_scripts_dir "${CMAKE_CURRENT_LIST_DIR}/../scripts")
        if(CMAKE_HOST_WIN32)
            message(STATUS "Windows SDK not found, running fetch-winsdk.ps1...")
            execute_process(
                COMMAND powershell -ExecutionPolicy Bypass -File
                    "${_fetch_scripts_dir}/fetch-winsdk.ps1"
                    -Output "${_winsdk_dir}"
                RESULT_VARIABLE _fetch_result
            )
        else()
            message(STATUS "Windows SDK not found, running fetch-winsdk.sh...")
            execute_process(
                COMMAND bash "${_fetch_scripts_dir}/fetch-winsdk.sh"
                    --output "${_winsdk_dir}"
                RESULT_VARIABLE _fetch_result
            )
        endif()
        if(NOT _fetch_result EQUAL 0)
            message(FATAL_ERROR "Failed to fetch Windows SDK")
        endif()
    else()
        message(STATUS "Windows SDK not found. To fetch automatically, re-run with -DSCFW_FETCH_WINSDK=ON")
        message(STATUS "  This uses xwin to download the SDK headers and libraries into ${_winsdk_dir}/.")
        message(STATUS "  If cargo is not installed, a temporary Rust toolchain is downloaded and removed after use.")
    endif()
endif()

if(EXISTS "${_winsdk_dir}")
    list(APPEND SCFW_WINSDK_INCLUDE_DIRS
        ${_winsdk_dir}/crt/include
        ${_winsdk_dir}/sdk/include/ucrt
        ${_winsdk_dir}/sdk/include/shared
        ${_winsdk_dir}/sdk/include/um
    )

    # Map architecture to xwin lib subdirectory
    if(CMAKE_SYSTEM_PROCESSOR STREQUAL "AMD64")
        set(_winsdk_arch "x86_64")
    elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL "X86")
        set(_winsdk_arch "x86")
    endif()

    if(_winsdk_arch AND EXISTS "${_winsdk_dir}/crt/lib/${_winsdk_arch}")
        set(SCFW_WINSDK_LIB_DIRS
            ${_winsdk_dir}/crt/lib/${_winsdk_arch}
            ${_winsdk_dir}/sdk/lib/um/${_winsdk_arch}
            ${_winsdk_dir}/sdk/lib/ucrt/${_winsdk_arch}
        )
    endif()
endif()

# Suppress harmless SDK/phnt header warnings when cross-compiling with Clang:
#   pragma-pack:                  SDK uses pshpack/poppack for struct packing (MSVC convention)
#   nonportable-include-path:     Case mismatch (Windows SDK built on case-insensitive FS)
#   ignored-pragma-intrinsic:     MSVC intrinsics Clang doesn't recognize
#   microsoft-enum-forward-reference: Forward enum decls (MS extension, supported)
#   microsoft-anon-tag:           Anonymous structs (MS extension, supported)
#   ignored-attributes:           stdcall on variadic function in phnt (compiler ignores it)
set(SCFW_WINSDK_COMPILE_OPTIONS
    -Wno-pragma-pack
    -Wno-nonportable-include-path
    -Wno-ignored-pragma-intrinsic
    -Wno-microsoft-enum-forward-reference
    -Wno-microsoft-anon-tag
    -Wno-ignored-attributes
)

```

`examples/CMakeLists.txt`:

```txt
add_subdirectory(empty)
add_subdirectory(kernel_query_user)
add_subdirectory(messagebox)
add_subdirectory(opengl_triangle)
add_subdirectory(writeconsole_xor)
add_subdirectory(writeconsole)

```

`examples/empty/CMakeLists.txt`:

```txt
add_executable(empty main.cpp)
target_link_libraries(empty PRIVATE scfw)
scfw_extract_shellcode(empty)

```

`examples/empty/main.cpp`:

```cpp
#include <scfw/runtime.h>
#include <scfw/platform/windows/usermode.h>

IMPORT_BEGIN();

IMPORT_END();

namespace sc {

extern "C" void __fastcall entry(void* argument1, void* argument2)
{
    (void)argument1;
    (void)argument2;
}

} // namespace sc

```

`examples/kernel_query_user/CMakeLists.txt`:

```txt
add_executable(kernel_query_user main.cpp)
target_link_libraries(kernel_query_user PRIVATE scfw)
scfw_extract_shellcode(kernel_query_user)

```

`examples/kernel_query_user/main.cpp`:

```cpp
#include <scfw/runtime.h>
#include <scfw/platform/windows/kernelmode.h>

extern "C" {

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define DPFLTR_IHVDRIVER_ID     77
#define DPFLTR_ERROR_LEVEL      0

#define KSECDDDECLSPEC
#define SEC_ENTRY               __stdcall

//////////////////////////////////////////////////////////////////////////
// Internal Structures.
//////////////////////////////////////////////////////////////////////////

typedef CCHAR KPROCESSOR_MODE;
typedef struct _ACCESS_STATE* PACCESS_STATE;
typedef struct _EPROCESS* PEPROCESS, *PKPROCESS, *PRKPROCESS;
typedef struct _OBJECT_TYPE* POBJECT_TYPE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

typedef _Enum_is_bitflag_ enum _POOL_TYPE {
    NonPagedPool,
} POOL_TYPE;

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

//
// Dbg
//

NTSYSAPI
ULONG
__cdecl
DbgPrintEx (
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_z_ _Printf_format_string_ PCSTR Format,
    ...
    );

//
// Ex
//

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag (
    _In_ __drv_strictTypeMatch(__drv_typeExpr) POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG Tag
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExFreePoolWithTag (
    _Pre_notnull_ __drv_freesMem(Mem) PVOID P,
    _In_ ULONG Tag
    );

//
// Ob
//

NTKERNELAPI
NTSTATUS
ObOpenObjectByPointer (
    _In_ PVOID Object,
    _In_ ULONG HandleAttributes,
    _In_opt_ PACCESS_STATE PassedAccessState,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObCloseHandle (
    _In_ _Post_ptr_invalid_ HANDLE Handle,
    _In_ KPROCESSOR_MODE PreviousMode
    );

//
// Ps
//

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
PACCESS_TOKEN
PsReferencePrimaryToken (
    _Inout_ PEPROCESS Process
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PsDereferencePrimaryToken (
    _In_ PACCESS_TOKEN PrimaryToken
    );

//
// Rtl
//

_IRQL_requires_max_(APC_LEVEL)
NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString (
    _Inout_ PUNICODE_STRING UnicodeString,
    _In_ PSID Sid,
    _In_ BOOLEAN AllocateDestinationString
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString (
    _Inout_ _At_(UnicodeString->Buffer, _Frees_ptr_opt_)
        PUNICODE_STRING UnicodeString
    );

//
// Sec
//

KSECDDDECLSPEC
NTSTATUS
SEC_ENTRY
SecLookupAccountSid (
    _In_      PSID Sid,
    _Out_     PULONG NameSize,
    _Inout_   PUNICODE_STRING NameBuffer,
    _Out_     PULONG DomainSize OPTIONAL,
    _Out_opt_ PUNICODE_STRING DomainBuffer OPTIONAL,
    _Out_     PSID_NAME_USE NameUse
    );

} // extern "C"

IMPORT_BEGIN();
    IMPORT_MODULE("ntoskrnl.exe");
        IMPORT_SYMBOL(DbgPrintEx);
        IMPORT_SYMBOL(ExAllocatePoolWithTag);
        IMPORT_SYMBOL(ExFreePoolWithTag);
        IMPORT_SYMBOL(ObOpenObjectByPointer);
        IMPORT_SYMBOL(ObCloseHandle);
        IMPORT_SYMBOL(PsReferencePrimaryToken);
        IMPORT_SYMBOL(PsDereferencePrimaryToken);
        IMPORT_SYMBOL(RtlConvertSidToUnicodeString);
        IMPORT_SYMBOL(RtlFreeUnicodeString);
        IMPORT_SYMBOL(ZwQueryInformationToken);
        IMPORT_SYMBOL(SeTokenObjectType, POBJECT_TYPE*);

    IMPORT_MODULE("ksecdd.sys");
        IMPORT_SYMBOL(SecLookupAccountSid);
IMPORT_END();

namespace sc {

#define SHELLCODE_MEMORY_TAG    'wfcs'

NTSTATUS
QueryUserInformation(
    _In_ PEPROCESS Process,
    _Out_ PUNICODE_STRING UserName,
    _Out_ PUNICODE_STRING DomainName,
    _Out_ PUNICODE_STRING Sid
    )
{
    NTSTATUS Status;

    //
    // Get the primary token of the process, and open a handle to it.
    //

    PACCESS_TOKEN AccessToken;
    AccessToken = PsReferencePrimaryToken(Process);

    if (!AccessToken)
    {
        return STATUS_NO_TOKEN;
    }

    HANDLE TokenHandle;
    Status = ObOpenObjectByPointer(AccessToken,
                                   0,
                                   NULL,
                                   TOKEN_ALL_ACCESS,
                                   *SeTokenObjectType,
                                   (KPROCESSOR_MODE)KernelMode,
                                   &TokenHandle);

    PsDereferencePrimaryToken(AccessToken);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Query the token for the user SID.
    //

    ULONG ReturnLength;
    SE_TOKEN_USER TokenUserInformation;
    Status = ZwQueryInformationToken(TokenHandle,
                                     TokenUser,
                                     &TokenUserInformation,
                                     static_cast<ULONG>(sizeof(TokenUserInformation)),
                                     &ReturnLength);

    ObCloseHandle(TokenHandle, KernelMode);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Convert the user SID to a Unicode string.
    // N.B. The caller is responsible for freeing the SID string buffer.
    //

    Status = RtlConvertSidToUnicodeString(Sid,
                                          TokenUserInformation.User.Sid,
                                          TRUE);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    ULONG UserNameLength = 0;
    PVOID UserNameBuffer = NULL;

    ULONG DomainNameLength = 0;
    PVOID DomainNameBuffer = NULL;

    do
    {
        if (UserNameLength)
        {
            UserNameBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                                   UserNameLength,
                                                   SHELLCODE_MEMORY_TAG);

            if (!UserNameBuffer)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        }

        if (DomainNameLength)
        {
            DomainNameBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                                     DomainNameLength,
                                                     SHELLCODE_MEMORY_TAG);

            if (!DomainNameBuffer)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        }

        UserName->Length = 0;
        UserName->MaximumLength = (USHORT)UserNameLength;
        UserName->Buffer = (PWCHAR)UserNameBuffer;

        DomainName->Length = 0;
        DomainName->MaximumLength = (USHORT)DomainNameLength;
        DomainName->Buffer = (PWCHAR)DomainNameBuffer;

        SID_NAME_USE NameUse;
        Status = SecLookupAccountSid(&TokenUserInformation.Sid,
                                     &UserNameLength,
                                     UserName,
                                     &DomainNameLength,
                                     DomainName,
                                     &NameUse);

    } while (Status == STATUS_BUFFER_TOO_SMALL);

    if (!NT_SUCCESS(Status))
    {
        if (DomainNameBuffer)
        {
            ExFreePoolWithTag(DomainNameBuffer, SHELLCODE_MEMORY_TAG);
        }

        if (UserNameBuffer)
        {
            ExFreePoolWithTag(UserNameBuffer, SHELLCODE_MEMORY_TAG);
        }

        UserName->Length = 0;
        UserName->MaximumLength = 0;
        UserName->Buffer = NULL;

        DomainName->Length = 0;
        DomainName->MaximumLength = 0;
        DomainName->Buffer = NULL;
    }

    return Status;
}

extern "C" void __fastcall entry(void* argument1, void* argument2)
{
    (void)argument1; // Kernel ImageBase, unused in this example.

    NTSTATUS Status;

    PEPROCESS Process = (PEPROCESS)argument2;

    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;
    UNICODE_STRING Sid;

    Status = QueryUserInformation(Process, &UserName, &DomainName, &Sid);

    if (!NT_SUCCESS(Status))
    {
        return;
    }

    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               DPFLTR_ERROR_LEVEL,
               "DomainName: '%wZ'\n"
               "UserName: '%wZ'\n"
               "SID: %wZ\n",
                   &DomainName,
                   &UserName,
                   &Sid);

    RtlFreeUnicodeString(&Sid);
    RtlFreeUnicodeString(&DomainName);
    RtlFreeUnicodeString(&UserName);
}

}

```

`examples/messagebox/CMakeLists.txt`:

```txt
add_executable(messagebox main.cpp)
target_link_libraries(messagebox PRIVATE scfw)
scfw_extract_shellcode(messagebox)

```

`examples/messagebox/main.cpp`:

```cpp
#define SCFW_ENABLE_LOAD_MODULE

#include <scfw/runtime.h>
#include <scfw/platform/windows/usermode.h>

IMPORT_BEGIN();
    IMPORT_MODULE("user32.dll", FLAGS(SCFW_FLAG_DYNAMIC_LOAD));
        IMPORT_SYMBOL(MessageBoxA);
IMPORT_END();

namespace sc {

extern "C" void __fastcall entry(void* argument1, void* argument2)
{
    (void)argument1;
    (void)argument2;

    MessageBoxA(NULL, _T("Hello, World!"), _T("shellcode"), MB_OK);
}

} // namespace sc

```

`examples/opengl_triangle/CMakeLists.txt`:

```txt
add_executable(opengl_triangle main.cpp)
target_link_libraries(opengl_triangle PRIVATE scfw)

# For some reason LTO causes bigger binary size here, disable it
set_target_properties(opengl_triangle PROPERTIES SCFW_OPT_LTO OFF)

scfw_extract_shellcode(opengl_triangle)

```

`examples/opengl_triangle/main.cpp`:

```cpp
//
//=============================================================================
// OpenGL Triangle
//=============================================================================
//
// A minimal OpenGL triangle rendered from shellcode. This example doubles
// as a guide for understanding scfw's compile-time options and the
// trade-offs between shellcode size and compatibility.
//
// This example dynamically loads user32.dll, gdi32.dll, and opengl32.dll,
// creates a window, sets up an OpenGL context, and renders a colored
// triangle in a message loop.
//
//=============================================================================
// CONFIGURATION
//=============================================================================
//
// Try enabling/disabling these to see how they affect shellcode size:
//
//   USE_GETPROCADDRESS - Use GetProcAddress for symbol lookup instead of
//                        our manual PE export table walker.
//
//   USE_DEFWINDOWPROCA - Import DefWindowProcA from user32.dll directly.
//                        If disabled, we import NtdllDefWindowProc_A from
//                        ntdll.dll instead (see the forwarded export
//                        discussion below).
//
//   USE_FORWARDER      - Enable forwarded export handling in our custom
//                        PE export table walker.
//
// Recommended combinations (from smallest to safest):
//
//   - USE_DEFWINDOWPROCA only:
//     Smallest shellcode. Uses our manual PE walker (no GetProcAddress)
//     and imports DefWindowProcA directly from user32.dll. The catch is
//     that DefWindowProcA is a forwarded export, and our manual walker
//     can't handle those by default. This works IF the OS resolves it
//     for us in the export table (which it usually does), but it's not
//     guaranteed.
//
//   - All USE_* disabled (default):
//     Good middle ground. Uses our manual PE walker without forwarder
//     support, but sidesteps the problem entirely by importing
//     NtdllDefWindowProc_A directly from ntdll.dll. Slightly bigger
//     than USE_DEFWINDOWPROCA alone (extra module import), but doesn't
//     rely on undocumented behavior. Fewer GetProcAddress calls means
//     smaller shellcode than the "safe" option below.
//
//   - USE_GETPROCADDRESS + USE_DEFWINDOWPROCA:
//     Safest option. GetProcAddress handles forwarded exports natively,
//     so importing DefWindowProcA just works. Maximum compatibility at
//     the cost of a bigger shellcode (GetProcAddress resolution code +
//     full module search).
//
//   - USE_DEFWINDOWPROCA + USE_FORWARDER:
//     Alternative safe option. Uses our custom PE walker with built-in
//     forwarder handling instead of GetProcAddress. Correctly resolves
//     DefWindowProcA -> NtdllDefWindowProc_A at runtime. Produces the
//     biggest shellcode because the forwarder code is included.
//
// In general, SCFW_ENABLE_FIND_MODULE_FORWARDER makes sense when:
//   - You have a very large shellcode with many imports, where avoiding
//     GetProcAddress calls saves more bytes than the forwarder code adds.
//   - You want to avoid using GetProcAddress for some reason (stealth,
//     hook avoidance, etc.).
//

//#define USE_GETPROCADDRESS
//#define USE_DEFWINDOWPROCA
//#define USE_FORWARDER

//=============================================================================
// SCFW COMPILE-TIME OPTIONS
//=============================================================================

//
// These must be defined BEFORE including runtime.h.
//

//
// SCFW_ENABLE_FULL_MODULE_SEARCH
//
// By default, scfw has a fast-path for ntdll.dll and kernel32.dll that
// reads them directly from known PEB offsets (2nd and 3rd entries in
// InLoadOrderModuleList) instead of walking the entire list. When we
// import many modules dynamically anyway, the fast-path code is dead
// weight - the generic PEB walker handles everything. Defining this
// disables the fast-path, making the shellcode smaller.
//
// We only need this when USE_GETPROCADDRESS is enabled, because that
// path uses SCFW_FLAG_DYNAMIC_RESOLVE which requires resolving
// GetProcAddress from kernel32.dll - and the fast-path is needed for
// that initial bootstrap.
//

//
// SCFW_ENABLE_LOAD_MODULE
//
// Resolves LoadLibraryA at init time. Required for SCFW_FLAG_DYNAMIC_LOAD,
// which we use to load user32.dll, gdi32.dll, and opengl32.dll - DLLs
// that aren't loaded in the target process by default.
//

//
// SCFW_ENABLE_UNLOAD_MODULE
//
// Resolves FreeLibrary at init time. Required for SCFW_FLAG_DYNAMIC_UNLOAD.
// If we don't care about cleaning up loaded DLLs after ourselves, we can
// leave this disabled to save a few bytes (no FreeLibrary calls emitted).
//

//
// SCFW_ENABLE_LOOKUP_SYMBOL
//
// Resolves GetProcAddress at init time. Required for SCFW_FLAG_DYNAMIC_RESOLVE.
// This is the interesting one - we only need it because DefWindowProcA
// _might be_ a "forwarded export" in user32.dll (forwarding to
// ntdll.dll!NtdllDefWindowProc_A). Our custom PE export table walker
// can't handle forwarded exports by default, so we fall back to
// GetProcAddress which handles them natively.
//
// We have two alternatives to avoid needing GetProcAddress:
//
//   - Define SCFW_ENABLE_FIND_MODULE_FORWARDER to teach our custom walker
//     how to follow forwarded exports.
//
//     Downside: more code in the shellcode binary.
//
//   - Import NtdllDefWindowProc_A directly from ntdll.dll instead of
//     DefWindowProcA from user32.dll, sidestepping the forwarded export
//     entirely.
//
//     Downside: relies on undocumented ntdll internals, and the extra
//               module import may increase shellcode size.
//
//     (Also note: the ntdll.dll module must use FLAGS(0) to override
//     SCFW_MODULE_DEFAULT_FLAGS, since we don't want DYNAMIC_LOAD for
//     ntdll - it's always loaded.)
//

#define SCFW_ENABLE_LOAD_MODULE
// #define SCFW_ENABLE_UNLOAD_MODULE
#define SCFW_ENABLE_LOOKUP_SYMBOL

#ifdef USE_GETPROCADDRESS
#   define SCFW_ENABLE_FULL_MODULE_SEARCH
#   define SCFW_MODULE_DEFAULT_FLAGS   (SCFW_FLAG_DYNAMIC_LOAD | SCFW_FLAG_DYNAMIC_RESOLVE)
#else
    // No SCFW_FLAG_DYNAMIC_RESOLVE in the default flags means we use our
    // manual PE export table walker for symbol lookup instead of GetProcAddress.
#   define SCFW_MODULE_DEFAULT_FLAGS   (SCFW_FLAG_DYNAMIC_LOAD)
#endif

#ifdef USE_FORWARDER
#   define SCFW_ENABLE_FIND_MODULE_FORWARDER
#endif

#include <scfw/runtime.h>
#include <scfw/platform/windows/usermode.h>

#include <gl/gl.h>

//
// Required for floating-point operations. The MSVC CRT normally provides
// this symbol; since we're freestanding, we define it ourselves.
//
// Note on float constants:
//   - On x86 (-mno-sse), the compiler moves float literals directly into
//     FPU registers via integer instructions (no .rdata needed).
//   - On x64, float constants are stored in .rdata (which gets merged
//     into .text) and accessed via RIP-relative addressing.
//
extern "C" __attribute__((used)) int _fltused = 0;

#ifndef USE_DEFWINDOWPROCA
//
// Forward declaration of NtdllDefWindowProc_A from ntdll.dll.
// This is the actual implementation that user32!DefWindowProcA
// forwards to. We import it directly when USE_DEFWINDOWPROCA is
// not defined, avoiding the forwarded export issue.
//
extern "C"
LRESULT
WINAPI
NtdllDefWindowProc_A(
    _In_ HWND hWnd,
    _In_ UINT Msg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam);
#endif

//=============================================================================
// IMPORT TABLE
//=============================================================================

IMPORT_BEGIN();
    //
    // kernel32.dll is always loaded in every process, so we don't need
    // DYNAMIC_LOAD. FLAGS(0) overrides SCFW_MODULE_DEFAULT_FLAGS to skip
    // the LoadLibraryA call.
    //
    IMPORT_MODULE("kernel32.dll", FLAGS(0));
        IMPORT_SYMBOL(LoadLibraryA);
        IMPORT_SYMBOL(GetModuleHandleA);

    IMPORT_MODULE("user32.dll");
        IMPORT_SYMBOL(RegisterClassA);
        IMPORT_SYMBOL(CreateWindowExA);
#ifdef USE_DEFWINDOWPROCA
        IMPORT_SYMBOL(DefWindowProcA);
#endif
        IMPORT_SYMBOL(ShowWindow);
        IMPORT_SYMBOL(PeekMessageA);
        IMPORT_SYMBOL(TranslateMessage);
        IMPORT_SYMBOL(DispatchMessageA);
        IMPORT_SYMBOL(GetDC);
        IMPORT_SYMBOL(PostQuitMessage);

    IMPORT_MODULE("gdi32.dll");
        IMPORT_SYMBOL(ChoosePixelFormat);
        IMPORT_SYMBOL(SetPixelFormat);
        IMPORT_SYMBOL(SwapBuffers);

    IMPORT_MODULE("opengl32.dll");
        IMPORT_SYMBOL(wglCreateContext);
        IMPORT_SYMBOL(wglMakeCurrent);
        IMPORT_SYMBOL(wglDeleteContext);

        IMPORT_SYMBOL(glClearColor);
        IMPORT_SYMBOL(glClear);
        IMPORT_SYMBOL(glBegin);
        IMPORT_SYMBOL(glEnd);
        IMPORT_SYMBOL(glVertex2f);
        IMPORT_SYMBOL(glColor3f);
        IMPORT_SYMBOL(glViewport);
        IMPORT_SYMBOL(glMatrixMode);
        IMPORT_SYMBOL(glLoadIdentity);

#ifndef USE_DEFWINDOWPROCA
    //
    // Import the ntdll version of DefWindowProcA directly, avoiding the
    // forwarded export in user32.dll. FLAGS(0) is required here - without
    // it, SCFW_MODULE_DEFAULT_FLAGS would apply DYNAMIC_LOAD, which would
    // try to LoadLibraryA("ntdll.dll") (unnecessary, it's always loaded).
    //
    IMPORT_MODULE("ntdll.dll", FLAGS(0));
        IMPORT_SYMBOL(NtdllDefWindowProc_A);
#endif
IMPORT_END();

#ifndef USE_DEFWINDOWPROCA
    // Alias so the rest of the code can use DefWindowProcA regardless of
    // which import path was chosen.
#   define DefWindowProcA NtdllDefWindowProc_A
#endif

//
// Global variables. GLOBAL() handles PIC on x86 - these are stored
// in .text and accessed through position-independent wrappers.
//
GLOBAL(HGLRC, g_hglrc);
GLOBAL(HDC,   g_hdc);
GLOBAL(bool,  g_running, true);

namespace sc {

//=============================================================================
// Window Procedure
//=============================================================================

static LRESULT __stdcall WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
        case WM_DESTROY:
            PostQuitMessage(0);
            g_running = false;
            return 0;

        case WM_SIZE:
            glViewport(0, 0, LOWORD(lParam), HIWORD(lParam));
            return 0;
    }
    return DefWindowProcA(hwnd, msg, wParam, lParam);
}

//=============================================================================
// Rendering
//=============================================================================

void RenderTriangle()
{
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glBegin(GL_TRIANGLES);
        glColor3f(1.0f, 0.0f, 0.0f); glVertex2f( 0.0f,  0.5f);  // Red top
        glColor3f(0.0f, 1.0f, 0.0f); glVertex2f(-0.5f, -0.5f);  // Green bottom-left
        glColor3f(0.0f, 0.0f, 1.0f); glVertex2f( 0.5f, -0.5f);  // Blue bottom-right
    glEnd();

    SwapBuffers(g_hdc);
}

//=============================================================================
// Entry Point
//=============================================================================

extern "C" void __fastcall entry(void* argument1, void* argument2)
{
    (void)argument1;
    (void)argument2;

    //
    // Register window class.
    //
    // Note the _(&WndProc) wrapper: on x86, function pointers are
    // compile-time absolute addresses that are wrong when the shellcode
    // is loaded at a different base. _() applies the PIC delta to get
    // the correct runtime address. On x64 this is a no-op (RIP-relative
    // addressing handles it).
    //
    WNDCLASSA wc{};
    wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
    wc.lpfnWndProc = _(&WndProc);
    wc.hInstance = GetModuleHandleA(NULL);
    wc.lpszClassName = _("OpenGLTriangle");

    if (!RegisterClassA(&wc)) return;

    // Create window
    HWND hwnd = CreateWindowExA(
        0,
        _("OpenGLTriangle"),
        _("OpenGL Triangle"),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        800, 600,
        NULL, NULL,
        wc.hInstance,
        NULL
    );

    if (!hwnd) return;

    // Get device context
    g_hdc = GetDC(hwnd);
    if (!g_hdc) return;

    // Set pixel format
    PIXELFORMATDESCRIPTOR pfd{};
    pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 32;
    pfd.cDepthBits = 24;
    pfd.iLayerType = PFD_MAIN_PLANE;

    int pixelFormat = ChoosePixelFormat(g_hdc, &pfd);
    if (!pixelFormat) return;

    if (!SetPixelFormat(g_hdc, pixelFormat, &pfd)) return;

    // Create OpenGL context
    g_hglrc = wglCreateContext(g_hdc);
    if (!g_hglrc) return;

    if (!wglMakeCurrent(g_hdc, g_hglrc)) {
        wglDeleteContext(g_hglrc);
        return;
    }

    // Set initial viewport
    glViewport(0, 0, 800, 600);

    // Show window
    ShowWindow(hwnd, SW_SHOW);

    // Message loop
    MSG msg{};
    while (g_running) {
        while (PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) {
                g_running = false;
                break;
            }
            TranslateMessage(&msg);
            DispatchMessageA(&msg);
        }

        if (g_running) {
            RenderTriangle();
        }
    }

    // Cleanup
    wglMakeCurrent(NULL, NULL);
    wglDeleteContext(g_hglrc);
}

} // namespace sc

```

`examples/writeconsole/CMakeLists.txt`:

```txt
add_executable(writeconsole main.cpp)
target_link_libraries(writeconsole PRIVATE scfw)
scfw_extract_shellcode(writeconsole)

```

`examples/writeconsole/main.cpp`:

```cpp
#include <scfw/runtime.h>
#include <scfw/platform/windows/usermode.h>

IMPORT_BEGIN();
    IMPORT_MODULE("kernel32.dll");
        IMPORT_SYMBOL(WriteConsoleA);
IMPORT_END();

namespace sc {

extern "C" void __fastcall entry(void* argument1, void* argument2)
{
    (void)argument1;
    (void)argument2;

    HANDLE StdOut = NtCurrentPeb()->ProcessParameters->StandardOutput;
    WriteConsoleA(StdOut,
                  _T("Hello, World!\n"),
                  sizeof("Hello, World!\n") - 1,
                  NULL,
                  NULL);
}

} // namespace sc

```

`examples/writeconsole_xor/CMakeLists.txt`:

```txt
add_executable(writeconsole_xor main.cpp)
target_compile_definitions(writeconsole_xor PRIVATE SCFW_ENABLE_XOR_STRING)
target_link_libraries(writeconsole_xor PRIVATE scfw)
scfw_extract_shellcode(writeconsole_xor)

```

`examples/writeconsole_xor/main.cpp`:

```cpp
#include <scfw/runtime.h>
#include <scfw/platform/windows/usermode.h>

IMPORT_BEGIN();
    IMPORT_MODULE("kernel32.dll");
        IMPORT_SYMBOL(WriteConsoleA);
IMPORT_END();

namespace sc {

extern "C" void __fastcall entry(void* argument1, void* argument2)
{
    (void)argument1;
    (void)argument2;

    HANDLE StdOut = NtCurrentPeb()->ProcessParameters->StandardOutput;
    WriteConsoleA(StdOut,
                  _T("Hello, World!\n"),
                  sizeof("Hello, World!\n") - 1,
                  NULL,
                  NULL);
}

} // namespace sc

```

`lib/CMakeLists.txt`:

```txt
# Select assembly sources based on target architecture
get_property(_cleanup GLOBAL PROPERTY SCFW_OPT_CLEANUP)

if(CMAKE_SYSTEM_PROCESSOR STREQUAL "X86")
    set(ASM_SOURCES src/arch/x86/init.S)
    if(_cleanup)
        list(APPEND ASM_SOURCES src/arch/x86/start.S)
    endif()
elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL "AMD64")
    set(ASM_SOURCES src/arch/x64/init.S)
    if(_cleanup)
        list(APPEND ASM_SOURCES src/arch/x64/start.S)
    endif()
else()
    message(FATAL_ERROR "Unsupported architecture: ${CMAKE_SYSTEM_PROCESSOR}")
endif()

add_library(scfw STATIC
    ${ASM_SOURCES}
    src/crt0.c
)

# Include paths: our headers, then phnt, then SDK
target_include_directories(scfw PUBLIC
    include
    ${SCFW_WINSDK_INCLUDE_DIRS}
)
target_compile_options(scfw PUBLIC ${SCFW_COMPILE_FLAGS})

if(_cleanup)
    target_compile_definitions(scfw PUBLIC SCFW_ENABLE_CLEANUP)
endif()

# Link options propagate to consumers
# Note: /MERGE appends sections to the end, preserving .text$* ordering
target_link_options(scfw INTERFACE
    ${SCFW_LINK_FLAGS}
    -Wl,/ENTRY:_init
    -Wl,/SUBSYSTEM:CONSOLE
    -Wl,/NODEFAULTLIB
    -Wl,/OPT:REF
    -Wl,/MERGE:.data=.text
    -Wl,/MERGE:.rdata=.text
    -Xlinker /SECTION:.text,RWE
)

# x86-specific linker options
if(CMAKE_SYSTEM_PROCESSOR STREQUAL "X86")
    target_link_options(scfw INTERFACE
        -Wl,/SAFESEH:NO     # Assembly files lack SEH metadata
        -Wl,/FIXED          # No base relocations - safe because PIC code only uses
                            # address DIFFERENCES which are base-independent
    )

    # Setting /BASE:0 makes shellcode offsets match raw file offsets, which is
    # nice for analysis. However, it makes the .exe non-executable and doesn't
    # actually reduce shellcode size (x86 imm32 is always 4 bytes regardless
    # of the value).
    if(SCFW_OPT_ZERO_BASE)
        target_link_options(scfw INTERFACE -Wl,/BASE:0)
    endif()
endif()

# Assembly compile flags
set(_asm_flags "-masm=intel")

if(_cleanup)
    string(APPEND _asm_flags " -DSCFW_ENABLE_CLEANUP")
endif()

# Function alignment for assembly (convert bytes to p2align power)
get_property(_fn_align GLOBAL PROPERTY SCFW_FUNCTION_ALIGNMENT)
if(_fn_align GREATER 0)
    # Compute log2 of alignment value for .p2align directive
    math(EXPR _p2align "0")
    set(_temp ${_fn_align})
    while(_temp GREATER 1)
        math(EXPR _temp "${_temp} / 2")
        math(EXPR _p2align "${_p2align} + 1")
    endwhile()
    string(APPEND _asm_flags " -DSCFW_P2ALIGN=${_p2align}")
endif()

set_source_files_properties(${ASM_SOURCES} PROPERTIES
    COMPILE_FLAGS "${_asm_flags}"
)

```

`lib/include/scfw/crt0.h`:

```h
#pragma once

//
// Minimal C runtime. Inline implementations of standard C string and
// memory functions. We can't link against the real CRT (no stdlib),
// so these are provided as __forceinline to be inlined at every call
// site with zero overhead.
//
// Also includes _wcsicmpa() for comparing wchar_t* against char*,
// used when searching PEB module names (wide) by ASCII name.
//

#include <cstdint>

extern "C" {

__forceinline
int __cdecl memcmp(const void* lhs, const void* rhs, size_t count)
{
    const unsigned char* p1 = (const unsigned char*)lhs;
    const unsigned char* p2 = (const unsigned char*)rhs;
    while (count--)
    {
        if (*p1 != *p2)
            return *p1 - *p2;
        p1++;
        p2++;
    }
    return 0;
}

__forceinline
void* __cdecl memset(void* dest, int ch, size_t count)
{
    unsigned char* p = (unsigned char*)dest;
    while (count--)
        *p++ = (unsigned char)ch;
    return dest;
}

__forceinline
void* __cdecl memcpy(void* dest, const void* src, size_t count)
{
    unsigned char* d = (unsigned char*)dest;
    const unsigned char* s = (const unsigned char*)src;
    while (count--)
        *d++ = *s++;
    return dest;
}

__forceinline
void* __cdecl memmove(void* dest, const void* src, size_t count)
{
    unsigned char* d = (unsigned char*)dest;
    const unsigned char* s = (const unsigned char*)src;
    if (d < s)
    {
        while (count--)
            *d++ = *s++;
    }
    else
    {
        d += count;
        s += count;
        while (count--)
            *--d = *--s;
    }
    return dest;
}

__forceinline
const void* __cdecl memchr(const void* ptr, int ch, size_t count)
{
    const unsigned char* p = (const unsigned char*)ptr;
    while (count--)
    {
        if (*p == (unsigned char)ch)
            return (const void*)p;
        p++;
    }
    return 0;
}

__forceinline
size_t __cdecl strlen(const char* str)
{
    const char* p = str;
    while (*p)
        p++;
    return (size_t)(p - str);
}

__forceinline
size_t __cdecl wcslen(const wchar_t* str)
{
    const wchar_t* p = str;
    while (*p)
        p++;
    return (size_t)(p - str);
}

__forceinline
char* __cdecl strcpy(char* dest, const char* src)
{
    char* d = dest;
    while ((*d++ = *src++))
        ;
    return dest;
}

__forceinline
wchar_t* __cdecl wcscpy(wchar_t* dest, const wchar_t* src)
{
    wchar_t* d = dest;
    while ((*d++ = *src++))
        ;
    return dest;
}

__forceinline
char* __cdecl strncpy(char* dest, const char* src, size_t count)
{
    char* d = dest;
    while (count && (*d++ = *src++))
        count--;
    while (count--)
        *d++ = '\0';
    return dest;
}

__forceinline
int __cdecl strcmp(const char* lhs, const char* rhs)
{
    while (*lhs && (*lhs == *rhs))
    {
        lhs++;
        rhs++;
    }
    return *(unsigned char*)lhs - *(unsigned char*)rhs;
}

__forceinline
int __cdecl strncmp(const char* lhs, const char* rhs, size_t count)
{
    while (count && *lhs && (*lhs == *rhs))
    {
        lhs++;
        rhs++;
        count--;
    }
    return count ? (*(unsigned char*)lhs - *(unsigned char*)rhs) : 0;
}

__forceinline
int __cdecl _stricmp(const char* lhs, const char* rhs)
{
    char c1, c2;

    do
    {
        c1 = *lhs++;
        c2 = *rhs++;

        if (c1 >= 'A' && c1 <= 'Z')
            c1 += ('a' - 'A');
        if (c2 >= 'A' && c2 <= 'Z')
            c2 += ('a' - 'A');
    } while (c1 && (c1 == c2));

    return (int)((unsigned char)c1 - (unsigned char)c2);
}


__forceinline
int __cdecl _wcsicmp(const wchar_t* lhs, const wchar_t* rhs)
{
    wchar_t c1, c2;

    do
    {
        c1 = *lhs++;
        c2 = *rhs++;

        // Convert to lowercase (ASCII only)
        if (c1 >= L'A' && c1 <= L'Z')
            c1 += (L'a' - L'A');
        if (c2 >= L'A' && c2 <= L'Z')
            c2 += (L'a' - L'A');
    } while (c1 && (c1 == c2));

    return (int)(c1 - c2);
}

//
// constexpr variant of _stricmp. Can be evaluated at compile time.
//
__forceinline
constexpr int __cdecl _Xstricmp(const char* lhs, const char* rhs)
{
    char c1, c2;

    do
    {
        c1 = *lhs++;
        c2 = *rhs++;

        // Convert to lowercase (ASCII only)
        if (c1 >= 'A' && c1 <= 'Z')
            c1 += ('a' - 'A');
        if (c2 >= 'A' && c2 <= 'Z')
            c2 += ('a' - 'A');
    } while (c1 && (c1 == c2));

    return (int)((unsigned char)c1 - (unsigned char)c2);
}

__forceinline
int __cdecl _wcsicmpa(const wchar_t* lhs, const char* rhs)
{
    wchar_t c1;
    char c2;

    do
    {
        c1 = *lhs++;
        c2 = *rhs++;

        if (c1 >= L'A' && c1 <= L'Z')
            c1 += (L'a' - L'A');
        if (c2 >= 'A' && c2 <= 'Z')
            c2 += ('a' - 'A');
    } while (c1 && (c1 == (wchar_t)c2));

    return (int)(c1 - (wchar_t)c2);
}

__forceinline
char* __cdecl strcat(char* dest, const char* src)
{
    char* d = dest;
    while (*d)
        d++;
    while ((*d++ = *src++))
        ;
    return dest;
}

__forceinline
char* __cdecl strncat(char* dest, const char* src, size_t count)
{
    char* d = dest;
    while (*d)
        d++;
    while (count-- && (*d++ = *src++))
        ;
    if (count == (size_t)-1)
        *d = '\0';
    return dest;
}

__forceinline
const char* __cdecl strchr(const char* str, int ch)
{
    while (*str)
    {
        if (*str == (char)ch)
            return (const char*)str;
        str++;
    }
    return (ch == '\0') ? (const char*)str : 0;
}

__forceinline
const wchar_t* __cdecl wcschr(const wchar_t* str, wchar_t ch)
{
    while (*str)
    {
        if (*str == ch)
            return (const wchar_t*)str;
        str++;
    }
    return (ch == L'\0') ? (const wchar_t*)str : 0;
}

__forceinline
const char* __cdecl strrchr(const char* str, int ch)
{
    const char* last = 0;
    while (*str)
    {
        if (*str == (char)ch)
            last = str;
        str++;
    }
    return (ch == '\0') ? (const char*)str : (const char*)last;
}

__forceinline
const char* __cdecl strstr(const char* str, const char* substr)
{
    if (!*substr)
        return (const char*)str;
    while (*str)
    {
        const char* h = str;
        const char* n = substr;
        while (*h && *n && (*h == *n))
        {
            h++;
            n++;
        }
        if (!*n)
            return (const char*)str;
        str++;
    }
    return 0;
}

}

```

`lib/include/scfw/platform/windows/common.h`:

```h
#pragma once

//
// Windows-specific module and symbol resolution.
//
// Provides two core operations:
//   - find_module()    - locate a loaded DLL by walking the PEB.
//   - lookup_symbol()  - find an exported function by parsing PE headers.
//
// These are the building blocks for the dispatch table init. They replace
// `GetModuleHandle` + `GetProcAddress` without calling any Windows APIs.
//

#include <phnt_windows.h>
#include <phnt.h>

#include "../../runtime/fnv1a.h"

namespace sc {
namespace detail {
namespace windows {

//
// Symbol lookup by parsing the PE export directory.
//
// Manually parses the PE export directory to find exported symbols.
// This is equivalent to `GetProcAddress` but doesn't require a function call.
//
//-----------------------------------------------------------------------------
//  PE Export Directory Structure
//-----------------------------------------------------------------------------
//
//   DOS Header --> NT Headers --> Optional Header --> DataDirectory[0]
//                                                           |
//                                                           v
//                                             IMAGE_EXPORT_DIRECTORY
//                                              +- NumberOfNames
//                                              +- AddressOfNames ------+
//                                              +- AddressOfFunctions   |
//                                              +- AddressOfNameOrdinals|
//                                                                      |
//         +------------------------------------------------------------+
//         v
//    Names[]:        Ordinals[]:      Functions[]:
//    +----------+    +--------+       +------------+
//    |"FuncA"   |    |   2    |       | 0x1000 (0) |
//    |"FuncB"   |    |   0    |       | 0x2000 (1) |
//    |"FuncC"   |    |   1    |       | 0x3000 (2) |
//    +----------+    +--------+       +------------+
//
//    To find "FuncA": Names[0]="FuncA" -> Ordinals[0]=2 -> Functions[2]
//
//
// Forwarded Exports (optional, enable with `SCFW_ENABLE_FIND_MODULE_FORWARDER`):
//   Some exports don't contain code - they redirect to another DLL.
//   A forwarded export's RVA falls within the export directory bounds,
//   and points to a string like "NTDLL.RtlAllocateHeap" instead of code.
//   When enabled, we detect this and recursively resolve the target.
//

#ifdef SCFW_ENABLE_FIND_MODULE_FORWARDER
namespace usermode {
    void* find_module(const char* name);
} // namespace usermode

template <typename F>
F lookup_symbol(void* module, const char* name);
#endif

template <typename F, typename C>
__forceinline
F lookup_symbol_impl(void* module, C comparator) {
    PUCHAR ImageBase = (PUCHAR)module;
    PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)module;
    PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)(ImageBase + DosHeader->e_lfanew);

#ifdef SCFW_ENABLE_FIND_MODULE_FORWARDER
    DWORD ExportDirRVA = NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    DWORD ExportDirSize = NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
    PIMAGE_EXPORT_DIRECTORY Exports = (PIMAGE_EXPORT_DIRECTORY)(ImageBase + ExportDirRVA);
#else
    PIMAGE_EXPORT_DIRECTORY Exports =
        (PIMAGE_EXPORT_DIRECTORY)(ImageBase + NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
#endif

    PULONG Names = (PULONG)(ImageBase + Exports->AddressOfNames);
    for (ULONG Index = Exports->NumberOfNames; Index--;) {
        LPCSTR Name = (LPCSTR)(ImageBase + Names[Index]);
        if (comparator(Name)) {
            PULONG Functions = (PULONG)(ImageBase + Exports->AddressOfFunctions);
            PUSHORT Ordinals = (PUSHORT)(ImageBase + Exports->AddressOfNameOrdinals);
            DWORD FunctionRVA = Functions[Ordinals[Index]];

#ifdef SCFW_ENABLE_FIND_MODULE_FORWARDER
            // Check if this is a forwarded export.
            // Forwarded exports have their RVA pointing within the export directory,
            // where a string like "NTDLL.NtdllDefWindowProc_A" is stored.
            if (FunctionRVA >= ExportDirRVA && FunctionRVA < ExportDirRVA + ExportDirSize) {
                LPCSTR ForwardStr = (LPCSTR)(ImageBase + FunctionRVA);
                // Find the dot separator between DLL name and function name.
                LPCSTR Dot = ForwardStr;
                while (*Dot && *Dot != '.') Dot++;
                if (!*Dot) return nullptr;

                // Build DLL name with .dll extension.
                // Forward strings use "NTDLL" not "ntdll.dll", so we append ".dll".
                char DllName[64];
                size_t DllNameLen = Dot - ForwardStr;
                if (DllNameLen + 5 > sizeof(DllName)) return nullptr;

                strcpy(DllName, ForwardStr);
                DllName[DllNameLen + 0] = '.';
                DllName[DllNameLen + 1] = 'd';
                DllName[DllNameLen + 2] = 'l';
                DllName[DllNameLen + 3] = 'l';
                DllName[DllNameLen + 4] = '\0';

                // Function name follows the dot.
                LPCSTR FuncName = Dot + 1;

                // Ordinal forwards start with '#' - not supported.
                if (*FuncName == '#') return nullptr;

                // Find the target module in the PEB.
                // #TODO: Using forwarder in kernel-mode is unsupported for now.
                void* TargetModule = usermode::find_module(DllName);
                if (!TargetModule) return nullptr;

                // Recursively resolve in the target module.
                return lookup_symbol<F>(TargetModule, FuncName);
            }
#endif

            return reinterpret_cast<F>((PVOID)(ImageBase + FunctionRVA));
        }
    }
    return nullptr;
}

template <typename F>
F lookup_symbol(void* module, const char* name) {
    return lookup_symbol_impl<F>(module, [name](const char* export_name) {
        return strcmp(export_name, name) == 0;
    });
}

template <typename F>
F lookup_symbol(void* module, uint32_t hash) {
    return lookup_symbol_impl<F>(module, [hash](const char* export_name) {
        return fnv1a_hash(export_name) == hash;
    });
}

namespace usermode {

//
// Module lookup by walking the PEB loader data structures.
//
// Walks the Process Environment Block (PEB) to find loaded modules.
// The PEB contains the Loader Data (LDR) which maintains a doubly-linked
// list of all modules loaded in the process.
//
//-----------------------------------------------------------------------------
// PEB Structure (simplified)
//-----------------------------------------------------------------------------
//   PEB
//    +--> Ldr (PEB_LDR_DATA)
//           +--> InLoadOrderModuleList <---------------------+
//                  |                                         |
//                  v                                         |
//          +-------------+    +-------------+    +-----------+-+
//          | ntdll.dll   |--->| kernel32.dll|--->| user32.dll  |---> ...
//          | DllBase     |    | DllBase     |    | DllBase     |
//          | BaseDllName |    | BaseDllName |    | BaseDllName |
//          +-------------+    +-------------+    +-------------+
//
//   `ntdll.dll` is always second (after exe), `kernel32.dll` third.
//   `find_module_ntdll()` and `find_module_kernel32()` exploit this.
//

template <typename F>
void* find_module_impl(F comparator) {
    PPEB Peb = NtCurrentPeb();
    PLIST_ENTRY Head = &Peb->Ldr->InLoadOrderModuleList;
    for (PLIST_ENTRY Entry = Head; Entry->Flink != Head; Entry = Entry->Flink) {
        PLDR_DATA_TABLE_ENTRY Ldr = (PLDR_DATA_TABLE_ENTRY)Entry->Flink;
        if (comparator(Ldr->BaseDllName.Buffer)) {
            return Ldr->DllBase;
        }
    }
    return nullptr;
}

__forceinline
void* find_module(const char* name) {
    return find_module_impl([name](const wchar_t* module) {
        return _wcsicmpa(module, name) == 0;
    });
}

__forceinline
void* find_module(const wchar_t* name) {
    return find_module_impl([name](const wchar_t* module) {
        return _wcsicmp(module, name) == 0;
    });
}

__forceinline
void* find_module(uint32_t hash) {
    return find_module_impl([hash](const wchar_t* module) {
        return fnv1a_hash(module) == hash;
    });
}

//
// Fast path: `ntdll.dll` is always the second entry in `InLoadOrderModuleList`
// (first is the exe itself). Skip straight to it instead of searching.
//

__forceinline
void* find_module_ntdll() {
    return ((PLDR_DATA_TABLE_ENTRY)NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink->Flink)->DllBase;
}

//
// Fast path: `kernel32.dll` is always the third entry in `InLoadOrderModuleList`
// (exe -> ntdll -> kernel32). Three Flink hops from the list head.
//

__forceinline
void* find_module_kernel32() {
    return ((PLDR_DATA_TABLE_ENTRY)NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink->Flink->Flink)->DllBase;
}

} // namespace usermode

namespace kernelmode {

extern "C" {

#undef NTKERNELAPI
#undef NTAPI

#define NTKERNELAPI
#define NTAPI __stdcall

typedef _Enum_is_bitflag_ enum _POOL_TYPE {
    NonPagedPool,
} POOL_TYPE;

NTKERNELAPI
PVOID
NTAPI
ExAllocatePool (
    _In_ __drv_strictTypeMatch(__drv_typeExpr) POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExFreePool (
    _Pre_notnull_ __drv_freesMem(Mem) PVOID P
    );

NTKERNELAPI
PVOID
NTAPI
MmGetSystemRoutineAddress (
    _In_ PUNICODE_STRING SystemRoutineName
    );

}

template <typename F>
void* find_module_impl(void* kernel_base, F comparator) {
#ifdef SCFW_ENABLE_INIT_SYMBOLS_BY_STRING
#   define SCFW__SYMBOL(x) _(x)
#else
#   define SCFW__SYMBOL(x) fnv1a_hash(x)
#endif

    auto pExAllocatePool = lookup_symbol<decltype(&ExAllocatePool)>(
        kernel_base, SCFW__SYMBOL("ExAllocatePool"));
    auto pExFreePool = lookup_symbol<decltype(&ExFreePool)>(
        kernel_base, SCFW__SYMBOL("ExFreePool"));
    auto pZwQuerySystemInformation = lookup_symbol<decltype(&ZwQuerySystemInformation)>(
        kernel_base, SCFW__SYMBOL("ZwQuerySystemInformation"));

#undef SCFW__SYMBOL

    NTSTATUS Status;
    PVOID Result = nullptr;
    PVOID Buffer = nullptr;
    ULONG BufferLength = 0;
    ULONG RequiredLength = 0;

    do
    {
        if (RequiredLength) {
            if (Buffer) {
                pExFreePool(Buffer);
            }

            Buffer = pExAllocatePool(NonPagedPool, RequiredLength);
            BufferLength = RequiredLength;
        }

        Status = pZwQuerySystemInformation(SystemModuleInformation,
                                           Buffer,
                                           BufferLength,
                                           &RequiredLength);

    } while (Status == STATUS_INFO_LENGTH_MISMATCH);

    PRTL_PROCESS_MODULES Modules = (PRTL_PROCESS_MODULES)Buffer;
    for (ULONG Index = 0; Index < Modules->NumberOfModules; Index++) {
        PRTL_PROCESS_MODULE_INFORMATION ModuleInfo = &Modules->Modules[Index];

        PCHAR ModuleName = (PCHAR)ModuleInfo->FullPathName + ModuleInfo->OffsetToFileName;
        if (comparator(ModuleName)) {
            Result = ModuleInfo->ImageBase;
            break;
        }
    }

    pExFreePool(Buffer);
    return Result;
}

__forceinline
void* find_module(void* kernel_base, const char* name) {
    return find_module_impl(kernel_base, [name](const char* module_name) {
        return _stricmp(module_name, name) == 0;
    });
}

__forceinline
void* find_module(void* kernel_base, uint32_t hash) {
    return find_module_impl(kernel_base, [hash](const char* module_name) {
        return fnv1a_hash(module_name) == hash;
    });
}

} // namespace kernelmode

} // namespace windows
} // namespace detail
} // namespace sc

```

`lib/include/scfw/platform/windows/kernelmode.h`:

```h
#pragma once

//
// Windows kernel-mode platform backend.
//
// Specializes the dispatch table base class for kernel-mode shellcode.
// Module resolution uses `ZwQuerySystemInformation(SystemModuleInformation)`
// instead of walking the PEB. Symbol resolution reuses the same PE export
// parser as usermode (`lookup_symbol` in `common.h`).
//
// Dynamic module loading and dynamic symbol lookup are not available in
// kernel mode and will trigger a `static_assert` if enabled.
//
// N.B. MmGetSystemRoutineAddress could be used, but since it does not support
//      loading from arbitrary modules, it would not be very useful for our
//      purposes.
//

#include "common.h"
#include "../../runtime.h"

#ifdef SCFW_MODE
#   error "SCFW_MODE already defined!"
#endif

#define SCFW_MODE kernel_mode

#ifdef SCFW_ENABLE_CLEANUP
extern "C" void __fastcall _cleanup_kernelmode(void* table_addr, void* return_addr);
#endif

namespace sc {
namespace detail {

struct kernel_mode;

//
// Kernel-mode type bindings. Maps abstract operations to kernel API
// function signatures. Dynamic load/unload/lookup are not supported.
//

template<>
struct mode_traits<kernel_mode> {
#ifdef SCFW_ENABLE_CLEANUP
    using cleanup_fn = decltype(&::_cleanup_kernelmode);
    using free_fn = decltype(&windows::kernelmode::ExFreePool);
#endif
#ifdef SCFW_ENABLE_LOAD_MODULE
    static_assert(false, "Dynamic module loading is not supported in kernel mode");
    using load_module_fn = void;
#endif
#ifdef SCFW_ENABLE_UNLOAD_MODULE
    static_assert(false, "Dynamic module unloading is not supported in kernel mode");
    using unload_module_fn = void;
#endif
#ifdef SCFW_ENABLE_LOOKUP_SYMBOL
    static_assert(false, "Dynamic symbol lookup is not supported in kernel mode");
    using lookup_symbol_fn = void;
#endif

    void* find_module(const char* name) const {
        if (_stricmp(name, "ntoskrnl.exe") == 0) {
            return kernel_base;
        }
        return windows::kernelmode::find_module(kernel_base, name);
    }

    void* find_module(uint32_t hash) const {
        if (hash == fnv1a_hash("ntoskrnl.exe")) {
            return kernel_base;
        }
        return windows::kernelmode::find_module(kernel_base, hash);
    }

    template <typename F>
    static F lookup_symbol(void* module, const char* name) {
        return windows::lookup_symbol<F>(module, name);
    }

    template <typename F>
    static F lookup_symbol(void* module, uint32_t hash) {
        return windows::lookup_symbol<F>(module, hash);
    }

    void* kernel_base;
};

//
// Kernel-mode init. `argument1` is the ntoskrnl base address,
// used to bootstrap symbol resolution.
//

template<>
__forceinline
int dispatch_table_impl<0, kernel_mode>::init(void* argument1, void* argument2) {
    (void)argument2;
    void* kernel_base = argument1;

#ifdef SCFW_ENABLE_INIT_SYMBOLS_BY_STRING
#   define SCFW__SYMBOL(x) _(x)
#else
#   define SCFW__SYMBOL(x) fnv1a_hash(x)
#endif

#ifdef SCFW_ENABLE_CLEANUP
    this->cleanup_ = reinterpret_cast<typename mode::cleanup_fn>(_(&::_cleanup_kernelmode));
    this->free_ = mode::lookup_symbol<typename mode::free_fn>(kernel_base, SCFW__SYMBOL("ExFreePool"));
#endif

    this->mode_.kernel_base = kernel_base;

    return 0;
}

template<>
__forceinline
void dispatch_table_impl<0, kernel_mode>::destroy(void* argument1, void* argument2) {
    (void)argument1;
    (void)argument2;
}


#ifdef SCFW_ENABLE_LOAD_MODULE
static_assert(false, "Dynamic module loading is not supported in kernel mode");
#endif

#ifdef SCFW_ENABLE_UNLOAD_MODULE
static_assert(false, "Dynamic module unloading is not supported in kernel mode");
#endif

template<>
__forceinline
void* dispatch_table_impl<0, kernel_mode>::find_module(const char* name) const {
    return mode_.find_module(name);
}

template<>
__forceinline
void* dispatch_table_impl<0, kernel_mode>::find_module(uint32_t hash) const {
    return mode_.find_module(hash);
}

#ifdef SCFW_ENABLE_LOOKUP_SYMBOL
static_assert(false, "Dynamic symbol lookup is not supported in kernel mode");
#endif

} // namespace detail
} // namespace sc

```

`lib/include/scfw/platform/windows/usermode.h`:

```h
#pragma once

//
// Windows usermode platform backend.
//
// Specializes the dispatch table base class for user-mode shellcode.
// Handles init-time resolution of kernel32 functions (`VirtualFree`,
// `LoadLibraryA`, `FreeLibrary`, `GetProcAddress`) and module lookup via PEB.
//
//=============================================================================
// USERMODE-SPECIFIC OPTIONS
//=============================================================================
//
//   SCFW_ENABLE_FULL_MODULE_SEARCH
//     Disables the ntdll/kernel32 fast-path optimization. By default,
//     find_module("ntdll.dll") and find_module("kernel32.dll") use
//     hardcoded PEB offsets (2nd and 3rd entries). Define this to always
//     walk the full module list instead.
//
//   SCFW_ENABLE_FIND_MODULE_FORWARDER
//     Enables support for forwarded PE exports. Some exports redirect
//     to another DLL (e.g., kernel32!HeapAlloc -> ntdll!RtlAllocateHeap).
//     When enabled, lookup_symbol detects these and recursively resolves
//     the target. Adds code size; only enable if you need it.
//
//=============================================================================
// DISPATCH TABLE BASE LAYOUT
//=============================================================================
//
// The base `dispatch_table_impl<0, user_mode>` holds optional function
// pointers resolved during `init()`. The assembly startup code accesses
// these at hardcoded offsets (see MEMORY LAYOUT in `runtime.h`):
//
//   cleanup_       -> _cleanup_usermode (asm function that calls free_)
//   free_          -> VirtualFree
//   load_module_   -> LoadLibraryA
//   unload_module_ -> FreeLibrary
//   lookup_symbol_ -> GetProcAddress
//
// After `_entry` returns, the asm startup code reads `cleanup_` from offset
// 0 and tail-calls it. `cleanup_` then reads `free_` (`VirtualFree`) from
// offset 4/8 and tail-calls that to free the shellcode memory.
//

#include "common.h"
#include "../../runtime.h"

#ifdef SCFW_MODE
#   error "SCFW_MODE already defined!"
#endif

#define SCFW_MODE user_mode

#ifdef SCFW_ENABLE_CLEANUP
extern "C" void __fastcall _cleanup_usermode(void* table_addr, void* return_addr);
#endif

namespace sc {
namespace detail {

struct user_mode;

//
// Usermode type bindings. Maps abstract operations to concrete
// Windows API function signatures.
//

template<>
struct mode_traits<user_mode> {
#ifdef SCFW_ENABLE_CLEANUP
    using cleanup_fn = decltype(&::_cleanup_usermode);
    using free_fn = decltype(&::VirtualFree);
#endif
#ifdef SCFW_ENABLE_LOAD_MODULE
    using load_module_fn = decltype(&::LoadLibraryA);
#endif
#ifdef SCFW_ENABLE_UNLOAD_MODULE
    using unload_module_fn = decltype(&::FreeLibrary);
#endif
#ifdef SCFW_ENABLE_LOOKUP_SYMBOL
    using lookup_symbol_fn = decltype(&::GetProcAddress);
#endif

    static void* find_module(const char* name) {
#ifndef SCFW_ENABLE_FULL_MODULE_SEARCH
        // Constant string comparisons - the compiler optimizes these away at
        // compile time, keeping only the matching branch.
        if (_stricmp(name, "ntdll.dll") == 0) {
            return windows::usermode::find_module_ntdll();
        }

        if (_stricmp(name, "kernel32.dll") == 0) {
            return windows::usermode::find_module_kernel32();
        }
#endif
        return windows::usermode::find_module(name);
    }

    static void* find_module(uint32_t hash) {
#ifndef SCFW_ENABLE_FULL_MODULE_SEARCH
        // Constant string comparisons - the compiler optimizes these away at
        // compile time, keeping only the matching branch.
        if (hash == fnv1a_hash("ntdll.dll")) {
            return windows::usermode::find_module_ntdll();
        }
        if (hash == fnv1a_hash("kernel32.dll")) {
            return windows::usermode::find_module_kernel32();
        }
#endif
        return windows::usermode::find_module(hash);
    }

    template <typename F>
    static F lookup_symbol(void* module, const char* name) {
        return windows::lookup_symbol<F>(module, name);
    }

    template <typename F>
    static F lookup_symbol(void* module, uint32_t hash) {
        return windows::lookup_symbol<F>(module, hash);
    }
};

template<>
__forceinline
int dispatch_table_impl<0, user_mode>::init(void* argument1, void* argument2) {
    (void)argument1;
    (void)argument2;

    //
    // These macros control how module/symbol names are passed to
    // `find_module/lookup_symbol` during the base init. By default,
    // names are hashed with FNV-1a so no plaintext appears in the binary.
    // `SCFW_ENABLE_INIT_MODULES_BY_STRING` / `SCFW_ENABLE_INIT_SYMBOLS_BY_STRING`
    // switch to string comparison instead.
    //

#ifdef SCFW_ENABLE_INIT_MODULES_BY_STRING
#   define SCFW__MODULE(x) _(x)
#else
#   define SCFW__MODULE(x) fnv1a_hash(x)
#endif
#ifdef SCFW_ENABLE_INIT_SYMBOLS_BY_STRING
#   define SCFW__SYMBOL(x) _(x)
#else
#   define SCFW__SYMBOL(x) fnv1a_hash(x)
#endif

#ifdef SCFW_ENABLE_CLEANUP
    this->cleanup_ = reinterpret_cast<typename mode::cleanup_fn>(_(&::_cleanup_usermode));
#endif

    //
    // We need `kernel32` to resolve `VirtualFree`, `GetProcAddress`,
    // `LoadLibraryA`, and/or `FreeLibrary`.
    //
    // Only find it if at least one is enabled.
    //
#if defined(SCFW_ENABLE_CLEANUP)                                              \
    || defined(SCFW_ENABLE_LOOKUP_SYMBOL)                                     \
    || defined(SCFW_ENABLE_LOAD_MODULE)                                       \
    || defined(SCFW_ENABLE_UNLOAD_MODULE)
    auto kernel32 = mode::find_module(SCFW__MODULE("kernel32.dll"));
#endif

    //
    // Resolve the `kernel32` functions we need. Each one is looked up
    // from the PE export table (or via hash) and stored in the dispatch
    // table for use by the assembly startup code or by `IMPORT_MODULE`
    // `init`/`destroy` methods.
    //

#ifdef SCFW_ENABLE_CLEANUP
    this->free_ = mode::lookup_symbol<typename mode::free_fn>(kernel32, SCFW__SYMBOL("VirtualFree"));
#endif
#ifdef SCFW_ENABLE_LOOKUP_SYMBOL
    this->lookup_symbol_ = mode::lookup_symbol<typename mode::lookup_symbol_fn>(kernel32, SCFW__SYMBOL("GetProcAddress"));
#endif
#ifdef SCFW_ENABLE_LOAD_MODULE
    this->load_module_ = mode::lookup_symbol<typename mode::load_module_fn>(kernel32, SCFW__SYMBOL("LoadLibraryA"));
#endif
#ifdef SCFW_ENABLE_UNLOAD_MODULE
    this->unload_module_ = mode::lookup_symbol<typename mode::unload_module_fn>(kernel32, SCFW__SYMBOL("FreeLibrary"));
#endif

#undef SCFW__SYMBOL
#undef SCFW__MODULE

    return 0;
}

template<>
__forceinline
void dispatch_table_impl<0, user_mode>::destroy(void* argument1, void* argument2) {
    //
    // Base destroy is intentionally empty. Cleanup (freeing shellcode
    // memory) is handled by the assembly code after `_entry` returns,
    // not here. Module-level destroy handles `FreeLibrary` if needed.
    //

    (void)argument1;
    (void)argument2;
}

#ifdef SCFW_ENABLE_LOAD_MODULE
template<>
__forceinline
void* dispatch_table_impl<0, user_mode>::load_module(const char* name) {
    return this->load_module_(name);
}
#endif

#ifdef SCFW_ENABLE_UNLOAD_MODULE
template<>
__forceinline
void dispatch_table_impl<0, user_mode>::unload_module(void* module) {
    this->unload_module_(static_cast<HMODULE>(module));
}
#endif

template<>
__forceinline
void* dispatch_table_impl<0, user_mode>::find_module(const char* name) const {
    return mode::find_module(name);
}

template<>
__forceinline
void* dispatch_table_impl<0, user_mode>::find_module(uint32_t hash) const {
    return mode::find_module(hash);
}

//
// When `SCFW_ENABLE_LOOKUP_SYMBOL` is active, symbol lookup goes through
// `GetProcAddress` (stored in `lookup_symbol_`) instead of manual PE parsing.
// Used when `SCFW_FLAG_DYNAMIC_RESOLVE` is set.
//

#ifdef SCFW_ENABLE_LOOKUP_SYMBOL
template<>
template <typename F>
__forceinline
F dispatch_table_impl<0, user_mode>::lookup_symbol(void* module, const char* name) const {
    return reinterpret_cast<F>(this->lookup_symbol_(static_cast<HMODULE>(module), name));
}
#endif

} // namespace detail
} // namespace sc

```

`lib/include/scfw/runtime.h`:

```h
#pragma once

//
//=============================================================================
// SCFW
//=============================================================================
//
// A compile-time shellcode framework for building position-independent
// executables.
//
// This module provides compile-time declaration of APIs that are resolved
// at runtime. It uses recursive template inheritance to build a dispatch table
// with zero metadata overhead.
//
//=============================================================================
// USAGE
//=============================================================================
//
//   #include <scfw/runtime.h>
//   #include <scfw/platform/windows/usermode.h>
//
//   IMPORT_BEGIN();
//       IMPORT_MODULE("kernel32.dll");
//           IMPORT_SYMBOL(Sleep);
//       IMPORT_MODULE("user32.dll", FLAGS(SCFW_FLAG_DYNAMIC_LOAD));
//           IMPORT_SYMBOL(MessageBoxA);
//   IMPORT_END();
//
//   namespace sc {
//       void __fastcall entry(void* argument1, void* argument2) {
//           Sleep(1000);
//           MessageBoxA(NULL, _T("Hi"), _T("scfw"), MB_OK);
//       }
//   } // namespace sc
//
//=============================================================================
// COMPILE-TIME OPTIONS
//=============================================================================
//
// These are #define'd before including runtime.h or set via CMake.
// Each one adds code/data to the output, so only enable what you need.
//
//   SCFW_ENABLE_CLEANUP       - Self-cleanup: the shellcode frees its own
//                               memory on exit via VirtualFree. MUST be set
//                               via CMake (not just #define) because the
//                               assembly startup code depends on it too.
//
//   SCFW_ENABLE_LOAD_MODULE   - Resolves LoadLibraryA at init time. Required
//                               by SCFW_FLAG_DYNAMIC_LOAD to load DLLs not
//                               already present in the target process.
//
//   SCFW_ENABLE_UNLOAD_MODULE - Resolves FreeLibrary at init time. Required
//                               by SCFW_FLAG_DYNAMIC_UNLOAD.
//
//   SCFW_ENABLE_LOOKUP_SYMBOL - Resolves GetProcAddress at init time.
//                               Required by SCFW_FLAG_DYNAMIC_RESOLVE.
//
//   SCFW_ENABLE_XOR_STRING    - XOR-encodes all strings passed through _T()
//                               at compile time and decodes them in-place at
//                               runtime on first access. Prevents module and
//                               symbol name strings from appearing in
//                               plaintext in the binary.
//
// PER-ENTRY FLAGS (passed via FLAGS() in IMPORT_MODULE / IMPORT_SYMBOL):
//
//   SCFW_FLAG_DYNAMIC_RESOLVE - Use GetProcAddress for symbol lookup instead
//     (0x01)                    of manually parsing the PE export table.
//                               Implies STRING_SYMBOL (names must be strings).
//                               Set on a module to affect all its symbols.
//                               Requires SCFW_ENABLE_LOOKUP_SYMBOL.
//
//   SCFW_FLAG_DYNAMIC_LOAD    - Use LoadLibraryA to load the module, instead
//     (0x02)                    of finding it in the PEB. For DLLs not already
//                               loaded in the target process (e.g. user32.dll).
//                               Requires SCFW_ENABLE_LOAD_MODULE.
//
//   SCFW_FLAG_DYNAMIC_UNLOAD  - FreeLibrary the module during destroy().
//     (0x04)                    Only valid together with DYNAMIC_LOAD.
//                               Requires SCFW_ENABLE_UNLOAD_MODULE.
//
//   SCFW_FLAG_STRING_MODULE   - Find the module by string name comparison
//     (0x08)                    instead of FNV-1a hash. Larger output
//                               (full module name string in binary).
//
//   SCFW_FLAG_STRING_SYMBOL   - Find the symbol by string name comparison
//     (0x10)                    instead of FNV-1a hash. Larger output
//                               (full symbol name string in binary).
//
// DEFAULT FLAGS (define before including runtime.h):
//
//   SCFW_MODULE_DEFAULT_FLAGS - Default flags for IMPORT_MODULE (default: 0).
//   SCFW_ENTRY_DEFAULT_FLAGS  - Default flags for IMPORT_SYMBOL (default: 0).
//
//=============================================================================
// HOW IT WORKS
//=============================================================================
//
// The dispatch table is built at compile time using C++ template
// metaprogramming. Each IMPORT_MODULE / IMPORT_SYMBOL macro creates a
// new struct (dispatch_table_impl<N+1>) that inherits from the previous
// one (<N>), forming a chain. __COUNTER__ gives each macro a unique ID.
//
//   dispatch_table_impl<0, Mode>    base class
//     - holds optional fn ptrs: cleanup_, free_, load_module_, etc.
//     - provides find_module(), load_module(), lookup_symbol()
//           |
//   dispatch_table_impl<1, Mode>    IMPORT_MODULE("kernel32.dll")
//     - adds: void* module_
//     - init() calls find_module() or load_module()
//     - destroy() optionally calls unload_module()
//           |
//   dispatch_table_impl<2, Mode>    IMPORT_SYMBOL(Sleep)
//     - adds: slot_Sleep_ (function pointer)
//     - init() calls lookup_symbol() on parent's module_
//           |
//   dispatch_table                  final alias (defined by IMPORT_END)
//
// init() chains upward: base first, then each entry in order.
// destroy() chains downward: last entry first, back to base.
//
// After IMPORT_END, user code accesses symbols through proxy objects
// in the sc:: namespace (e.g., sc::Sleep). These proxies read the
// function pointer from __dispatch_table at runtime.
//
//=============================================================================
// SECTION ORDERING
//=============================================================================
//
// Everything is merged into a single .text section (via linker /MERGE).
// The linker orders .text$* subsections alphabetically:
//
//   Section       Contents                  Source
//   ------------- ------------------------- -------------------------
//   .text$00      _init                     lib/src/arch/*/init.S
//   .text$10      _start, _pc, _cleanup_*   lib/src/arch/*/start.S
//   .text$20      _entry                    IMPORT_END() macro
//   .text$aaa     framework code            runtime.h, crt0.h, etc.
//   .text$yyy     user code                 after IMPORT_END()
//
// _init must be first (it's the PE entry point). User code comes last.
//
//=============================================================================
// MEMORY LAYOUT
//=============================================================================
//
// The assembly startup code (lib/src/x64/start.S, lib/src/x86/start.S)
// directly accesses `cleanup_` and `free_` at hardcoded offsets:
//
//   x86 Layout:                      x64 Layout:
//   +-------------------------+      +-------------------------+
//   | +0:  cleanup_           |      | +0:  cleanup_           |
//   | +4:  free_              |      | +8:  free_              |
//   | +8:  load_module_       |      | +16: load_module_       |
//   | +12: unload_module_     |      | +24: unload_module_     |
//   | +16: lookup_symbol_     |      | +32: lookup_symbol_     |
//   +-------------------------+      +-------------------------+
//
// IMPORTANT: DO NOT reorder these members without updating assembly!
//

//
// Place all framework code in `.text$aaa` (after `_entry` in `.text$20`,
// before user code in `.text$yyy`).
//
#pragma code_seg(".text$aaa")

#include "crt0.h"
#include "runtime/fnv1a.h"
#include "runtime/pic.h"
#include "runtime/xorstr.h"

//=============================================================================
// Flags & declarations.
//=============================================================================

//
// Use `GetProcAddress` for symbol lookup instead of manual PE export parsing.
// Implies `STRING_SYMBOL` (names must be passed as strings, not hashes).
// Set on a module to affect all its symbols. Requires `SCFW_ENABLE_LOOKUP_SYMBOL`.
//
#define SCFW_FLAG_DYNAMIC_RESOLVE 0x01

//
// Use `LoadLibraryA` to load the module instead of searching the PEB.
// For DLLs not already loaded in the target process (e.g. `user32.dll`).
// Requires `SCFW_ENABLE_LOAD_MODULE`.
//
#define SCFW_FLAG_DYNAMIC_LOAD    0x02

//
// `FreeLibrary` the module during `destroy()`. Only valid with `DYNAMIC_LOAD`.
// Requires `SCFW_ENABLE_UNLOAD_MODULE`.
//
#define SCFW_FLAG_DYNAMIC_UNLOAD  0x04

//
// Find the module by string comparison instead of FNV-1a hash.
// Larger output (full module name string ends up in the binary).
//
#define SCFW_FLAG_STRING_MODULE   0x08

//
// Find the symbol by string comparison instead of FNV-1a hash.
// Larger output (full symbol name string ends up in the binary).
//
#define SCFW_FLAG_STRING_SYMBOL   0x10

//
// Default flags for `IMPORT_MODULE` / `IMPORT_SYMBOL` when `FLAGS()` is not specified.
// Override these before including `runtime.h` if you want all entries to share
// the same flags (e.g., `#define SCFW_MODULE_DEFAULT_FLAGS SCFW_FLAG_STRING_MODULE`).
//
#ifndef SCFW_MODULE_DEFAULT_FLAGS
#   define SCFW_MODULE_DEFAULT_FLAGS 0
#endif

#ifndef SCFW_ENTRY_DEFAULT_FLAGS
#   define SCFW_ENTRY_DEFAULT_FLAGS 0
#endif

//
// User-defined entry point. Called by the framework after the dispatch table
// is initialized. Must be implemented by the user.
//
extern "C" void __fastcall entry(void* argument1, void* argument2);

//
// FLAGS() macro for passing per-entry flags to `IMPORT_MODULE` / `IMPORT_SYMBOL`.
// Expands to two tokens (`SCFW_F_, value`), which the variadic argument counting
// trick uses to detect the presence of flags and route to the right overload.
//
// Example: IMPORT_MODULE("user32.dll", FLAGS(SCFW_FLAG_DYNAMIC_LOAD))
//   expands to: IMPORT_MODULE("user32.dll", SCFW_F_, SCFW_FLAG_DYNAMIC_LOAD)
//   which is 3 args -> dispatched to SCFW_IM_3.
//
#define FLAGS(x) SCFW_F_, x

//
// IMPORT_BEGIN() - forward-declares the dispatch_table type and the
// `__dispatch_table` global. Must come before any `IMPORT_MODULE` / `IMPORT_SYMBOL`.
//

#define IMPORT_BEGIN()                                                        \
    namespace sc {                                                            \
    namespace detail {                                                        \
    extern "C" dispatch_table __dispatch_table;                               \
    } /* namespace detail */                                                  \
    } /* namespace sc */

//
// IMPORT_END() - seals the dispatch table and generates the _entry function.
//
// - Defines dispatch_table as the final dispatch_table_impl specialization.
// - Instantiates `__dispatch_table` as a global (lands in `.data` -> merged to `.text`).
// - Creates `_entry()` in `.text$20` which:
//     - gets the PIC-adjusted address of `__dispatch_table`,
//     - calls `dt->init()` to resolve all modules and symbols,
//     - calls the user's `entry()` function,
//     - calls `dt->destroy()` for cleanup (e.g., `FreeLibrary`).
// - Switches to `.text$yyy` so all subsequent user code goes there.
//

#define IMPORT_END()                                                          \
    namespace sc {                                                            \
    namespace detail {                                                        \
    struct dispatch_table                                                     \
        : dispatch_table_impl<__COUNTER__, SCFW_MODE> {};                     \
    extern "C" dispatch_table __dispatch_table{};                             \
                                                                              \
    __pragma(code_seg(".text$20"))                                            \
    __declspec(allocate(".text$20"))                                          \
    extern "C" void __fastcall _entry(void* argument1, void* argument2) {     \
        auto dt = reinterpret_cast<dispatch_table*>(_(&__dispatch_table));    \
                                                                              \
        auto err = dt->init(argument1, argument2);                            \
        if (err) return;                                                      \
                                                                              \
        entry(argument1, argument2);                                          \
                                                                              \
        dt->destroy(argument1, argument2);                                    \
    }                                                                         \
    } /* namespace detail */                                                  \
    } /* namespace sc */                                                      \
                                                                              \
    __pragma(code_seg(".text$yyy"))

//
// IMPORT_MODULE(name [, FLAGS(flags)]) - declare a DLL dependency.
//
// Creates a `dispatch_table_impl` entry that resolves the module during init.
// Subsequent `IMPORT_SYMBOL` calls will look up exports from this module.
//
// Argument expansion (`FLAGS()` expands to 2 tokens: `SCFW_F_, value`):
//   1 arg:  "name"                       -> uses SCFW_MODULE_DEFAULT_FLAGS
//   3 args: "name", SCFW_F_, flags       -> uses specified flags
//   (2 args is not possible since FLAGS() always expands to 2 tokens)
//
#define IMPORT_MODULE(...)                                                    \
    SCFW_IM_EXPAND(SCFW_IM_NARGS(__VA_ARGS__, _3, _2, _1)(__COUNTER__, __VA_ARGS__))

#define SCFW_IM_EXPAND(...) __VA_ARGS__
#define SCFW_IM_NARGS(_1, _2, _3, N, ...) SCFW_IM##N

// 1 arg: IMPORT_MODULE("kernel32.dll") -> default flags.
#define SCFW_IM_1(Id, Module)                                                 \
    SCFW_IMPORT_MODULE_IMPL(Id, Module, SCFW_MODULE_DEFAULT_FLAGS)

// 3 args: IMPORT_MODULE("user32.dll", FLAGS(SCFW_FLAG_DYNAMIC_LOAD)) -> custom flags.
#define SCFW_IM_3(Id, Module, Marker, Flags)                                  \
    SCFW_IMPORT_MODULE_IMPL(Id, Module, Flags)

#define SCFW_IMPORT_MODULE_IMPL(Id, Module, Flags)                            \
    namespace sc {                                                            \
    namespace detail {                                                        \
    template<>                                                                \
    struct dispatch_table_impl<Id + 1, SCFW_MODE>                             \
        : dispatch_table_impl<Id, SCFW_MODE>                                  \
    {                                                                         \
        static_assert(!(((Flags) & SCFW_FLAG_DYNAMIC_UNLOAD) &&               \
                       !((Flags) & SCFW_FLAG_DYNAMIC_LOAD)),                  \
            Module ": DYNAMIC_UNLOAD requires DYNAMIC_LOAD");                 \
                                                                              \
        static constexpr entry_kind entry_type = entry_kind::module;          \
        static constexpr uint32_t module_flags = Flags;                       \
                                                                              \
        __forceinline                                                         \
        int init(void* argument1, void* argument2) {                          \
            auto err = dispatch_table_impl<Id, SCFW_MODE>::init(argument1,    \
                                                                argument2);   \
            if (err) return err;                                              \
            if constexpr (module_flags & SCFW_FLAG_DYNAMIC_LOAD) {            \
                module_ = load_module(_T(Module));                            \
            } else if constexpr (module_flags & SCFW_FLAG_STRING_MODULE) {    \
                module_ = find_module(_T(Module));                            \
            } else {                                                          \
                module_ = find_module(fnv1a_hash(Module));                    \
            }                                                                 \
            if (!module_) return Id + 1;                                      \
            return 0;                                                         \
        }                                                                     \
                                                                              \
        __forceinline                                                         \
        void destroy(void* argument1, void* argument2) {                      \
            if constexpr ((module_flags & SCFW_FLAG_DYNAMIC_LOAD) &&          \
                          (module_flags & SCFW_FLAG_DYNAMIC_UNLOAD)) {        \
                if (module_) {                                                \
                    unload_module(current_module());                          \
                }                                                             \
            }                                                                 \
            dispatch_table_impl<Id, SCFW_MODE>::destroy(argument1,            \
                                                        argument2);           \
        }                                                                     \
                                                                              \
    protected:                                                                \
        __forceinline                                                         \
        void* current_module() const {                                        \
            return module_;                                                   \
        }                                                                     \
                                                                              \
    private:                                                                  \
        void* module_{};                                                      \
    };                                                                        \
    } /* namespace detail */                                                  \
    } /* namespace sc */

//
// IMPORT_SYMBOL(name [, type] [, FLAGS(flags)]) - declare an API import.
//
// Two modes:
//   Callable: IMPORT_SYMBOL(Sleep) - type is inferred as `decltype(&::Sleep)`.
//             Creates `sc::Sleep(...)` that forwards to the resolved pointer.
//
//   Value:    IMPORT_SYMBOL(SomeExport, int*) - explicit type, not callable.
//             Creates `sc::SomeExport` as a `proxy_value<int*>`.
//
// Argument expansion (`FLAGS()` expands to 2 tokens: `SCFW_F_, value`):
//   1 arg:  Name                         -> callable, default flags
//   2 args: Name, Type                   -> value, default flags
//   3 args: Name, SCFW_F_, val           -> callable, custom flags
//   4 args: Name, Type, SCFW_F_, val     -> value, custom flags
//
#define IMPORT_SYMBOL(...)                                                    \
    SCFW_IS_EXPAND(SCFW_IS_NARGS(__VA_ARGS__, _4, _3, _2, _1)(__COUNTER__, __VA_ARGS__))

#define SCFW_IS_EXPAND(...) __VA_ARGS__
#define SCFW_IS_NARGS(_1, _2, _3, _4, N, ...) SCFW_IS##N

// 1 arg: IMPORT_SYMBOL(Sleep) -> callable with default flags.
#define SCFW_IS_1(Id, Name)                                                   \
    SCFW_IMPORT_SYMBOL_CALLABLE_IMPL(Id, Name, SCFW_ENTRY_DEFAULT_FLAGS)

// 2 args: IMPORT_SYMBOL(Name, Type) -> value import with default flags.
// Can't be FLAGS() here because FLAGS() always expands to 2 tokens,
// making the total 3 args (routed to SCFW_IS_3 instead).
#define SCFW_IS_2(Id, Name, Type)                                             \
    SCFW_IMPORT_SYMBOL_VALUE_IMPL(Id, Name, Type, SCFW_ENTRY_DEFAULT_FLAGS)

// 3 args: IMPORT_SYMBOL(Sleep, FLAGS(x)) -> callable with custom flags.
#define SCFW_IS_3(Id, Name, Marker, Flags)                                    \
    SCFW_IMPORT_SYMBOL_CALLABLE_IMPL(Id, Name, Flags)

// 4 args: IMPORT_SYMBOL(Name, Type, FLAGS(x)) -> value with custom flags.
#define SCFW_IS_4(Id, Name, Type, Marker, Flags)                              \
    SCFW_IMPORT_SYMBOL_VALUE_IMPL(Id, Name, Type, Flags)

//
// Callable import: infers the type from the Windows SDK declaration,
// creates the dispatch table entry + a callable proxy in `sc::Name`.
//

#define SCFW_IMPORT_SYMBOL_CALLABLE_IMPL(Id, Name, Flags)                     \
    SCFW_IMPORT_SYMBOL(Id, Name, decltype(&::Name), Flags);                   \
    SCFW_CALLABLE_IMPL(Id, Name)

//
// Value import: uses an explicit type, creates the dispatch table entry
// + a value proxy in `sc::Name` (read/write via operator overloads).
//

#define SCFW_IMPORT_SYMBOL_VALUE_IMPL(Id, Name, Type, Flags)                  \
    SCFW_IMPORT_SYMBOL(Id, Name, Type, Flags);                                \
    SCFW_VALUE_IMPL(Id, Name, Type)

//
// Core dispatch table entry for a symbol. Creates a new template
// specialization that inherits from the previous entry and adds
// a `slot_Name_` field. The `init()` method resolves the symbol using
// one of three strategies (in priority order):
//
//   - (default)       -> manual PE parsing with FNV-1a hash comparison.
//   - STRING_SYMBOL   -> manual PE parsing with strcmp.
//   - DYNAMIC_RESOLVE -> `GetProcAddress` (via base class `lookup_symbol_`).
//
// Flags can come from the symbol itself (`entry_flags`) or be inherited
// from the parent module (looked up via `lookup_flags_v`).
//

#define SCFW_IMPORT_SYMBOL(Id, Name, Type, Flags)                             \
    namespace sc {                                                            \
    namespace detail {                                                        \
    template<>                                                                \
    struct dispatch_table_impl<Id + 1, SCFW_MODE>                             \
        : dispatch_table_impl<Id, SCFW_MODE>                                  \
    {                                                                         \
        static_assert(!((Flags) & SCFW_FLAG_DYNAMIC_LOAD),                    \
            #Name ": DYNAMIC_LOAD can only be used with IMPORT_MODULE");      \
        static_assert(!((Flags) & SCFW_FLAG_DYNAMIC_UNLOAD),                  \
            #Name ": DYNAMIC_UNLOAD can only be used with IMPORT_MODULE");    \
        static_assert(!((Flags) & SCFW_FLAG_STRING_MODULE),                   \
            #Name ": STRING_MODULE can only be used with IMPORT_MODULE");     \
                                                                              \
        friend struct callable_##Name;                                        \
        friend struct value_##Name;                                           \
                                                                              \
        static constexpr entry_kind entry_type = entry_kind::symbol;          \
        static constexpr uint32_t entry_flags = Flags;                        \
                                                                              \
        __forceinline                                                         \
        int init(void* argument1, void* argument2) {                          \
            auto err = dispatch_table_impl<Id, SCFW_MODE>::init(argument1,    \
                                                                argument2);   \
            if (err) return err;                                              \
                                                                              \
            constexpr bool dynamic_resolve =                                  \
                (entry_flags & SCFW_FLAG_DYNAMIC_RESOLVE) ||                  \
                (lookup_flags_v<Id, SCFW_MODE, entry_kind::module> &          \
                    SCFW_FLAG_DYNAMIC_RESOLVE);                               \
                                                                              \
            if constexpr (dynamic_resolve) {                                  \
                /* string_symbol is implied */                                \
                slot_##Name##_ =                                              \
                    lookup_symbol<Type>(current_module(), _T(#Name));         \
            } else {                                                          \
                constexpr bool string_symbol =                                \
                    (entry_flags & SCFW_FLAG_STRING_SYMBOL) ||                \
                    (lookup_flags_v<Id, SCFW_MODE, entry_kind::module> &      \
                        SCFW_FLAG_STRING_SYMBOL);                             \
                                                                              \
                if constexpr (string_symbol) {                                \
                    slot_##Name##_ =                                          \
                        mode::lookup_symbol<Type>(current_module(),           \
                                                  _T(#Name));                 \
                } else {                                                      \
                    slot_##Name##_ =                                          \
                        mode::lookup_symbol<Type>(current_module(),           \
                                                  fnv1a_hash(#Name));         \
                }                                                             \
            }                                                                 \
                                                                              \
            return slot_##Name##_ ? 0 : Id + 1;                               \
        }                                                                     \
                                                                              \
        __forceinline                                                         \
        void destroy(void* argument1, void* argument2) {                      \
            dispatch_table_impl<Id, SCFW_MODE>::destroy(argument1,            \
                                                        argument2);           \
        }                                                                     \
                                                                              \
    private:                                                                  \
        Type slot_##Name##_{};                                                \
    };                                                                        \
    } /* namespace detail */                                                  \
    } /* namespace sc */

//
// Callable proxy. Creates `sc::Name` as a zero-size global whose `operator()`
// reads the function pointer from `__dispatch_table` and calls through it.
//
// For `IMPORT_SYMBOL(Sleep)`, this generates:
//
//   struct callable_Sleep : proxy_callable<decltype(&::Sleep), callable_Sleep> {
//       decltype(&::Sleep) get() const {
//           return ((dispatch_table_impl<N>*) _(&__dispatch_table))->slot_Sleep_;
//       }
//   };
//   inline callable_Sleep Sleep{};   // in namespace sc
//

#define SCFW_CALLABLE_IMPL(Id, Name)                                          \
    namespace sc {                                                            \
    namespace detail {                                                        \
    struct callable_##Name                                                    \
        : proxy_callable<decltype(&::Name), callable_##Name>                  \
    {                                                                         \
        friend struct proxy_callable<decltype(&::Name), callable_##Name>;     \
                                                                              \
    private:                                                                  \
        __forceinline                                                         \
        decltype(&::Name) get() const {                                       \
            return reinterpret_cast<dispatch_table_impl<Id + 1, SCFW_MODE>*>(\
                _(&__dispatch_table))->slot_##Name##_;                        \
        }                                                                     \
    };                                                                        \
    } /* namespace detail */                                                  \
    inline detail::callable_##Name Name{};                                    \
    } /* namespace sc */

//
// Value proxy. Creates `sc::Name` as a zero-size global that provides
// read/write access to the slot via operator overloads (`operator T&`,
// `operator=`, `operator&`, `operator bool`).
//
// Used for non-callable exports (data pointers, etc.).
//

#define SCFW_VALUE_IMPL(Id, Name, Type)                                       \
    namespace sc {                                                            \
    namespace detail {                                                        \
    struct value_##Name                                                       \
        : proxy_value<Type, value_##Name>                                     \
    {                                                                         \
        friend struct proxy_value<Type, value_##Name>;                        \
                                                                              \
        using proxy_value<Type, value_##Name>::operator=;                     \
                                                                              \
    private:                                                                  \
        __forceinline                                                         \
        Type* get() const {                                                   \
            return &reinterpret_cast<dispatch_table_impl<Id + 1, SCFW_MODE>*>(\
                _(&__dispatch_table))->slot_##Name##_;                        \
        }                                                                     \
    };                                                                        \
    } /* namespace detail */                                                  \
    inline detail::value_##Name Name{};                                       \
    } /* namespace sc */

//
// GLOBAL(Type, Name [, init]) - declare a global variable in `sc::`.
//
// On x86, global variable addresses require relocation. GLOBAL creates
// a proxy that computes the runtime address using `_pic()`.
//
// Example:
//   GLOBAL(int, counter, 0);       // Declares sc::counter.
//   sc::counter = 42;              // Assignment through proxy.
//   int* ptr = &sc::counter;       // Gets runtime address.
//
// On x64, this is a simple static variable (RIP-relative addressing works).
//

#define GLOBAL(Type, Name, ...)                                               \
    SCFW_GLOBAL_IMPL(Type, Name, SCFW_GLOBAL_DEFAULT_INIT(__VA_ARGS__))

#define SCFW_GLOBAL_DEFAULT_INIT(...)                                         \
    SCFW_GLOBAL_DEFAULT_INIT_I(__VA_ARGS__ __VA_OPT__(,) {}, )
#define SCFW_GLOBAL_DEFAULT_INIT_I(expr, ...) = expr

#if _M_IX86
//
// x86: wraps the global in a proxy_value that uses `_pic()` to compute the
// runtime address. The actual storage is `sc::detail::Name_`, and
// `sc::Name` is a zero-size proxy that redirects all access through `_pic()`.
//
#define SCFW_GLOBAL_IMPL(Type, Name, Initializer)                             \
    namespace sc {                                                            \
    namespace detail {                                                        \
    static Type Name##_ Initializer;                                          \
                                                                              \
    struct global_##Name                                                      \
        : proxy_value<Type, global_##Name>                                    \
    {                                                                         \
        friend struct proxy_value<Type, global_##Name>;                       \
                                                                              \
        using proxy_value<Type, global_##Name>::operator=;                    \
                                                                              \
    private:                                                                  \
        __forceinline                                                         \
        Type* get() const {                                                   \
            return _(&Name##_);                                               \
        }                                                                     \
    };                                                                        \
    } /* namespace detail */                                                  \
    inline detail::global_##Name Name{};                                      \
    } /* namespace sc */
#else
//
// x64: RIP-relative addressing handles relocation, so no proxy needed.
// Just a plain static variable in `namespace sc`.
//
#define SCFW_GLOBAL_IMPL(Type, Name, Initializer)                             \
    namespace sc {                                                            \
    static Type Name Initializer;                                             \
    } /* namespace sc */
#endif

namespace sc {
namespace detail {

//
// Tags for dispatch table entries. Used by `lookup_flags` to walk the
// inheritance chain and find the nearest module or symbol entry.
//

enum class entry_kind {
    module,
    symbol
};

//
// Primary template for platform-specific type bindings. Specialized by
// `usermode.h` / `kernelmode.h` to map abstract operations (`load_module`,
// `lookup_symbol`, etc.) to concrete function pointer types and
// implementations.
//

template <typename Mode>
struct mode_traits {
#ifdef SCFW_ENABLE_CLEANUP
    using cleanup_fn = void;
    using free_fn = void;
#endif
#ifdef SCFW_ENABLE_LOAD_MODULE
    using load_module_fn = void;
#endif
#ifdef SCFW_ENABLE_UNLOAD_MODULE
    using unload_module_fn = void;
#endif
#ifdef SCFW_ENABLE_LOOKUP_SYMBOL
    using lookup_symbol_fn = void;
#endif

    //
    // Manual PE export table lookup. Overloaded for string name and
    // FNV-1a hash. Implemented in `common.h` (parses PE headers directly).
    //

    template <typename F>
    static F lookup_symbol(void* module, const char* name);

    template <typename F>
    static F lookup_symbol(void* module, uint32_t hash);
};

//
// Base-level function pointer storage for the dispatch table.
//

template <typename Mode>
struct dispatch_table_fields {
    using mode = mode_traits<Mode>;

    //
    // Optional function pointers, conditionally compiled.
    // The assembly startup code reads `cleanup_` and `free_` at hardcoded
    // offsets (see `MEMORY LAYOUT` diagram above).
    //

#ifdef SCFW_ENABLE_CLEANUP
    typename mode::cleanup_fn cleanup_;
    typename mode::free_fn free_;
#endif
#ifdef SCFW_ENABLE_LOAD_MODULE
    typename mode::load_module_fn load_module_;
#endif
#ifdef SCFW_ENABLE_UNLOAD_MODULE
    typename mode::unload_module_fn unload_module_;
#endif
#ifdef SCFW_ENABLE_LOOKUP_SYMBOL
    typename mode::lookup_symbol_fn lookup_symbol_;
#endif
};

//
// Combines function pointer storage with optional platform-specific state.
// Uses empty base optimization: when `mode_traits<Mode>` is stateless
// (e.g., usermode), the `mode_` member is omitted to avoid wasting space
// in the dispatch table.
//

template <typename Mode, bool = std::is_empty_v<mode_traits<Mode>>>
struct dispatch_table_storage
    : dispatch_table_fields<Mode>
{
    mode_traits<Mode> mode_;
};

//
// Specialization for stateless `mode_traits<Mode>` (e.g., usermode).
// Inherits function pointer fields without adding a `mode_` member.
//

template <typename Mode>
struct dispatch_table_storage<Mode, true>
    : dispatch_table_fields<Mode>
{};

//
// Forward declaration. The actual type is defined by `IMPORT_END()` as
// the final link in the `dispatch_table_impl` inheritance chain.
//

struct dispatch_table;

//
// Dispatch table template. Each `IMPORT_MODULE` / `IMPORT_SYMBOL` specializes
// `dispatch_table_impl<N+1>` inheriting from `<N>`. The base case `<0>` is
// defined below; platform backends (`usermode.h`, `kernelmode.h`) provide
// the actual `init`/`destroy`/`find_module` implementations.
//

template <size_t N, typename Mode>
struct dispatch_table_impl;

template <typename Mode>
struct dispatch_table_impl<0, Mode>
  : private dispatch_table_storage<Mode>
{
    using mode = mode_traits<Mode>;

    //
    // Initialize base-level function pointers. Implemented in the platform
    // backend (e.g., `usermode.h` resolves `VirtualFree`, `LoadLibraryA`, etc.).
    //

    int init(void* argument1, void* argument2);

    //
    // Base-level teardown. Usually empty (cleanup is handled by asm).
    //

    void destroy(void* argument1, void* argument2);

protected:
    //
    // Returns `nullptr` at the base level. Overridden by `IMPORT_MODULE`
    // entries which store their resolved module handle.
    //

    void* current_module() const;

    //
    // Module/symbol resolution helpers. The platform backend provides
    // the actual implementations. `IMPORT_MODULE`/`IMPORT_SYMBOL` `init()`
    // methods call these through the inheritance chain.
    //

    void* load_module(const char* name);
    void unload_module(void* module);
    void* find_module(const char* name) const;
    void* find_module(uint32_t hash) const;

    template <typename F>
    F lookup_symbol(void* module, const char* name) const;
};

//
// Walks the dispatch table inheritance chain backwards from entry `Id`
// to find the flags of the nearest entry of a given kind.
//
// Used by `IMPORT_SYMBOL` to inherit flags from its parent module.
// For example, if `IMPORT_MODULE` has `SCFW_FLAG_DYNAMIC_RESOLVE`, all
// its child `IMPORT_SYMBOL`s pick that up automatically.
//

template <size_t Id, typename Mode, entry_kind EntryKind>
struct lookup_flags {
    static constexpr uint32_t get() {
        if constexpr (Id == 0) {
            return 0;
        }

        if constexpr (dispatch_table_impl<Id, Mode>::entry_type != EntryKind) {
            return lookup_flags<Id - 1, Mode, EntryKind>::get();
        }

        if constexpr (EntryKind == entry_kind::symbol) {
            return dispatch_table_impl<Id, Mode>::entry_flags;
        } else if constexpr (EntryKind == entry_kind::module) {
            return dispatch_table_impl<Id, Mode>::module_flags;
        }
    }

    static constexpr uint32_t value = get();
};

template <size_t Id, typename Mode, entry_kind EntryKind>
constexpr uint32_t lookup_flags_v = lookup_flags<Id, Mode, EntryKind>::value;

//
// CRTP base for callable proxies. Makes a zero-size struct behave like a
// function pointer. The Derived class must provide `get()` returning the
// actual function pointer from the dispatch table.
//
// sc::Sleep(1000)  =>  callable_Sleep::operator()(1000)
//                  =>  callable_Sleep::get()(1000)
//                  =>  __dispatch_table.slot_Sleep_(1000)
//

template <typename F, typename Derived>
struct proxy_callable;

template <typename R, typename... Args, typename Derived>
struct proxy_callable<R(*)(Args...), Derived> {
    __forceinline
    R operator()(Args... args) const {
        return static_cast<const Derived*>(this)->get()(args...);
    }
};

//
// Specialization for variadic (C-style `...`) function pointers, e.g.
// `sprintf`, `wprintf`. Uses a forwarding parameter pack to pass the
// variable arguments through to the underlying function pointer.
//

template <typename R, typename... Args, typename Derived>
struct proxy_callable<R(*)(Args..., ...), Derived> {
    template <typename... CallArgs>
    __forceinline
    R operator()(CallArgs&&... args) const {
        return static_cast<const Derived*>(this)->get()(std::forward<CallArgs>(args)...);
    }
};

#ifdef _M_IX86

//
// x86 has distinct calling conventions (`__stdcall`, `__fastcall`) which are
// different function pointer types. Need separate specializations.
//

template <typename R, typename... Args, typename Derived>
struct proxy_callable<R(__stdcall*)(Args...), Derived> {
    __forceinline
    R __stdcall operator()(Args... args) const {
        return static_cast<const Derived*>(this)->get()(args...);
    }
};

template <typename R, typename... Args, typename Derived>
struct proxy_callable<R(__fastcall*)(Args...), Derived> {
    __forceinline
    R __fastcall operator()(Args... args) const {
        return static_cast<const Derived*>(this)->get()(args...);
    }
};
#endif

//
// CRTP base for value proxies. Provides transparent read/write access
// to a value stored in the dispatch table (or a PIC-relocated global).
// The Derived class must provide `get()` returning a pointer to the value.
//
// Supports: implicit conversion (`operator T&`), assignment (`operator=`),
// address-of (`operator&`), and boolean conversion.
//

template <typename T, typename Derived>
struct proxy_value {
    using value_type = T;

    template<typename U = value_type>
    __forceinline
    operator bool() const
        requires (
            !std::is_same_v<U, bool> &&
            std::is_convertible_v<U, bool>
        )
    {
        return static_cast<bool>(*static_cast<const Derived*>(this)->get());
    }

    __forceinline
    value_type* operator&() {
        return static_cast<const Derived*>(this)->get();
    }

    __forceinline
    const value_type* operator&() const {
        return static_cast<const Derived*>(this)->get();
    }

    __forceinline
    operator value_type&() {
        return *static_cast<const Derived*>(this)->get();
    }

    __forceinline
    operator const value_type&() const {
        return *static_cast<const Derived*>(this)->get();
    }

    __forceinline
    value_type& operator=(const value_type& value) {
        return *static_cast<const Derived*>(this)->get() = value;
    }
};

} // namespace detail
} // namespace sc

```

`lib/include/scfw/runtime/fnv1a.h`:

```h
#pragma once

//
// FNV-1a hash function for case-insensitive string hashing.
//
// Used to hash module and symbol names so we don't need to store
// plaintext strings in the shellcode binary. At init time, we hash
// the export names from the PE and compare against the compile-time
// hash to find our target function.
//
// The hash is case-insensitive: bytes >= 'a' get 0x20 subtracted
// (effectively uppercasing ASCII letters). We intentionally skip the
// `<= 'z'` check - it saves a cmp+branch at every inlined call site,
// and since this function is inlined into every module/symbol lookup
// loop, those bytes add up. Mangling characters above 'z' doesn't
// matter because both sides of the comparison use the same hash.
// Handles both `char` and `wchar_t` (only the low byte is hashed,
// which is fine for ASCII names).
//

#include <string>
#include <cstdint>

namespace sc {
namespace detail {

template <typename CharT>
constexpr uint32_t fnv1a_hash(const CharT* string, size_t length) {
    uint32_t hash = 0x811c9dc5;
    uint8_t byte = 0;

    while (length--) {
        byte = static_cast<uint8_t>(*string++);

        if (byte >= 'a') {
            byte -= 0x20;
        }

        hash ^= byte;
        hash *= 0x01000193;
    }

    return hash;
}

template <typename CharT>
constexpr uint32_t fnv1a_hash(const CharT* string) {
    return fnv1a_hash(string, std::char_traits<CharT>::length(string));
}

} // namespace detail
} // namespace sc

```

`lib/include/scfw/runtime/pic.h`:

```h
#pragma once

//
// Position-independent code (PIC) helpers.
//
// On x86, the compiler generates absolute addresses for globals and
// string literals. When shellcode is loaded at an arbitrary address,
// those addresses are wrong. `_pic()` fixes them at runtime.
//
// On x64, RIP-relative addressing handles this automatically, so
// `_pic()` is not needed and `_()` is a no-op.
//

#include <cstdint>
#include <type_traits>
#include "xorstr.h"

//
// Returns the runtime address of the `_pc` function itself.
// Implemented in assembly (x86: `call/pop` trick, x64: `lea rip`).
//
extern "C" __attribute__((const)) void* _pc();

//
// On x86, the compiler generates absolute addresses for global variables.
// When shellcode is copied to a new location, these addresses point to the
// wrong memory.
//
// Calculate the runtime address using the difference between where we ARE
// and where we were COMPILED to be.
//
//-----------------------------------------------------------------------------
// How _pic() Works
//-----------------------------------------------------------------------------
//
//   Compile-time layout:          Runtime layout:
//   +------------------+          +------------------+
//   | 0x00401000: _pc  |          | 0x7FFE0000: _pc  |  <-- _pc() returns
//   | ...              |          | ...              |      this address.
//   | 0x00402000: data |          | 0x7FFE1000: data |
//   +------------------+          +------------------+
//
//   Formula: runtime_addr = _pc() - &_pc + compile_time_addr
//
//   Example:
//     _pc() = 0x7FFE0000 (actual runtime address of _pc function).
//     &_pc  = 0x00401000 (compile-time address, embedded in instruction).
//     addr  = 0x00402000 (compile-time address of data).
//
//     result = 0x7FFE0000 - 0x00401000 + 0x00402000
//            = 0x7FFE1000 (correct runtime address of data).
//
// The DIFFERENCE between any two compile-time addresses equals the difference
// between their runtime addresses. The `/fixed` linker flag ensures no `.reloc`
// section is generated, so compile-time addresses are preserved as constants
// in the binary.
//

template <typename T>
__forceinline
T* _pic(T* addr)
{
    return reinterpret_cast<T*>(
      reinterpret_cast<uintptr_t>(_pc()) -
      reinterpret_cast<uintptr_t>(&_pc) +
      reinterpret_cast<uintptr_t>(addr));
}

#ifdef _M_IX86
#   define _(x) _pic(x)
#else
#   define _(x) (x)
#endif

//
// _T(s) - get a runtime-safe pointer to string literal `s`.
//
// Depending on configuration, this either:
//   - just returns the string pointer as-is (x64 without XOR),
//   - returns a PIC-relocated pointer to a static copy (x86 without XOR),
//   - XOR-encodes at compile time and decodes on first use
//     (when `SCFW_ENABLE_XOR_STRING` is defined).
//
// Use `_T()` for any string that ends up in the binary (module names,
// symbol names, user strings). Handles both `char` and `wchar_t`.
//

#ifdef SCFW_ENABLE_XOR_STRING
#   define _T(s) _TX(s)
#else
#   ifdef _M_IX86
#       define _T(s) ([]() { \
            using CharT = std::remove_const_t<std::remove_reference_t<decltype(s[0])>>; \
            static CharT _str[] = s; \
            return _(static_cast<CharT*>(_str)); \
        }())
#   else
#       define _T(s) ([]() { \
            using CharT = std::remove_const_t<std::remove_reference_t<decltype(s[0])>>; \
            return const_cast<CharT*>(s); \
        }())
#   endif
#endif

```

`lib/include/scfw/runtime/xorstr.h`:

```h
#pragma once

//
// Compile-time XOR-encoded strings.
//
// XOR-encoded strings are encoded at compile time and decoded in-place at
// runtime on first access.
//
// Memory layout:
//
//   Before decode:
//     [key][len]['H'^key]['e'^key]['l'^key]['l'^key]['o'^key][0^key]
//      ^    ^    ^-- encoded string data (including null)
//      |    +-- length (N-1, excludes null terminator)
//      +-- XOR key (non-zero when encoded)
//
//   After decode:
//     [0x00][len]['H']['e']['l']['l']['o']['\0']
//      ^         ^-- decoded string (pointer returned to caller)
//      +-- key=0 marks string as decoded
//
//
// The `key` being `0x00` indicates the string has been decoded. This avoids
// needing a separate boolean flag which would have x86 PIC issues.
//

#include <type_traits>

namespace sc {
namespace detail {

//
// Key type: `uint8_t` for `char` strings, `uint16_t` for `wchar_t` strings.
//

template <typename CharT>
struct xor_key {
    using type = std::conditional_t<sizeof(CharT) == 1, uint8_t, uint16_t>;
};

//
// Compile-time encoded string. The consteval constructor XORs each
// character with the `key`, so the encoded data is baked into the binary.
//

template <typename CharT, size_t N>
struct xor_string {
    using key_type = typename xor_key<CharT>::type;

    key_type key;
    key_type len;
    CharT data[N];

    consteval xor_string(const CharT (&str)[N], key_type k)
        : key(k), len(static_cast<key_type>(N - 1)), data{} {
        for (size_t i = 0; i < N; i++) {
            data[i] = str[i] ^ static_cast<CharT>(k);
        }
    }
};

//
// Decode a XOR-encoded string in-place. If `key != 0`, XOR each char
// with the `key` and set `key` to `0` (marking it as decoded). Returns a
// pointer to the decoded string data. Safe to call multiple times -
// subsequent calls see `key=0` and skip decoding.
//

template <typename CharT>
__forceinline
CharT* decode_xor(void* ptr) {
    using key_type = typename xor_key<CharT>::type;

    key_type* p = static_cast<key_type*>(ptr);
    key_type key = p[0];
    if (key != 0) {
        key_type len = p[1];
        CharT* str = reinterpret_cast<CharT*>(p + 2);
        for (key_type i = 0; i <= len; i++) {
            str[i] ^= static_cast<CharT>(key);
        }
        p[0] = 0;
    }
    return reinterpret_cast<CharT*>(p + 2);
}

//
// XOR key derivation from `__LINE__`. We use `__LINE__` instead of `__COUNTER__`
// because `__COUNTER__` is already used by `IMPORT_MODULE`/`IMPORT_SYMBOL` to
// generate unique template IDs. Using it here too would cause ID collisions.
//
// The formula scrambles the line number into a non-zero key.
// The `| 1` ensures the key is never zero, since zero means "already decoded".
//

#define SCFW_XOR_KEY(c, CharT)                                                \
    static_cast<typename sc::detail::xor_key<CharT>::type>(                   \
        (sizeof(CharT) == 1)                                                  \
            ? (((c) * 0x9E + 0x5A) | 1)                                       \
            : (((c) * 0x9E37 + 0x5A5A) | 1))

//
// `_TX(s)` - create a static XOR-encoded string and decode it on first use.
// On x86, the address of the static `xor_string` is PIC-adjusted via `_()`.
//

#ifdef _M_IX86
#   define _TX(s) ([]() { \
        using CharT = std::remove_const_t<std::remove_reference_t<decltype(s[0])>>; \
        static sc::detail::xor_string<CharT, sizeof(s)/sizeof(CharT)> _xstr(s, SCFW_XOR_KEY(__LINE__, CharT)); \
        return decode_xor<CharT>(_(&_xstr)); \
    }())
#else
#   define _TX(s) ([]() { \
        using CharT = std::remove_const_t<std::remove_reference_t<decltype(s[0])>>; \
        static sc::detail::xor_string<CharT, sizeof(s)/sizeof(CharT)> _xstr(s, SCFW_XOR_KEY(__LINE__, CharT)); \
        return decode_xor<CharT>(&_xstr); \
    }())
#endif

} // namespace detail
} // namespace sc

```

`lib/src/arch/x64/init.S`:

```S
    .intel_syntax noprefix

#ifndef SCFW_P2ALIGN
#   define SCFW_P2ALIGN 4
#endif

#
# Externally used symbols.
#

#ifdef SCFW_ENABLE_CLEANUP
    .extern _start
#else
    .extern _entry
#endif

#
# .text$00 is the very first section in the final binary.
# _init is the PE entry point (/ENTRY:_init), so it must be
# placed here to be the first instruction executed.
#

    .section .text$00,"ax"

#++
#
# void
# _init (
#    _In_ void* argument1,
#    _In_ void* argument2
#    )
#
# Routine Description:
#
#    PE entry point. Captures the shellcode's base address (its own
#    location in memory) and jumps to _start (with cleanup) or
#    directly to _entry (without cleanup).
#
# Arguments:
#
#    argument1 - Value of RCX register.
#    argument2 - Value of RDX register.
#
# Return Value:
#
#    None.
#
#--

    .globl _init
    .p2align SCFW_P2ALIGN
_init:

#ifdef SCFW_ENABLE_CLEANUP
#
# Save the shellcode base address in r11 (scratch register, callee-clobbered).
# _start will preserve it across the _entry call and pass it to _cleanup_*
# so VirtualFree knows what memory to free.
#

    lea     r11, [rip + _init]
    jmp     _start
#else
    jmp     _entry
#endif

    .p2align SCFW_P2ALIGN

```

`lib/src/arch/x64/start.S`:

```S
    .intel_syntax noprefix

#ifndef SCFW_P2ALIGN
#   define SCFW_P2ALIGN 4
#endif

#
# Externally used symbols.
#

    .extern _entry
    .extern __dispatch_table

#
# VirtualFree flags.
#

    .equ MEM_RELEASE, 0x8000

#
# .text$10 comes after _init (.text$00).
# Contains _pc, _cleanup_*, and _start - the core runtime functions
# that need to be in shellcode memory (they get freed after execution).
#

    .section .text$10,"ax"

#++
#
# void*
# _pc (
#    void
#    )
#
# Routine Description:
#
#    Returns the runtime address of _pc itself via RIP-relative LEA.
#    Used by _pic() to compute the delta between compile-time and
#    runtime addresses for position-independent memory access.
#
# Return Value:
#
#    Runtime address of this function (in RAX).
#
#--

    .globl _pc
    .p2align SCFW_P2ALIGN
_pc:
    lea     rax, [rip + _pc]
    ret

#++
#
# void
# _cleanup_usermode (
#    void* address
#    )
#
# Routine Description:
#
#    Frees the shellcode's own memory by tail-calling VirtualFree.
#    Called by _start after _entry returns. Since this function is
#    inside the memory being freed, it must not return - it jumps
#    directly to VirtualFree, which returns to the original caller.
#
#    Reads VirtualFree from __dispatch_table.free_ (offset +8).
#
# Return Value:
#
#    None.
#
#--

    .globl _cleanup_usermode
    .p2align SCFW_P2ALIGN
_cleanup_usermode:

#
#   rcx = address to free (set by _start)
#   rax = VirtualFree (from dispatch_table.free_ at offset +8)
#   rdx = 0 (dwSize, must be 0 for MEM_RELEASE)
#   r8  = MEM_RELEASE
#
#   tail call: VirtualFree(address, 0, MEM_RELEASE)
#   VirtualFree returns to whoever originally called the shellcode.
#

    mov     rax, [rip + __dispatch_table + 8]
    xor     rdx, rdx
    mov     r8, MEM_RELEASE
    jmp     rax

#++
#
# void
# _cleanup_kernelmode (
#    void* address
#    )
#
# Routine Description:
#
#    Kernel-mode cleanup. Same idea as _cleanup_usermode but calls
#    ExFreePool instead of VirtualFree (single argument: the pointer).
#    Reads ExFreePool from __dispatch_table.free_ (offset +8).
#
# Return Value:
#
#    None.
#
#--

    .globl _cleanup_kernelmode
    .p2align SCFW_P2ALIGN
_cleanup_kernelmode:

#
#   rcx = address to free (set by _start)
#   rax = ExFreePool (from dispatch_table.free_ at offset +8)
#
#   tail call: ExFreePool(address)
#

    mov     rax, [rip + __dispatch_table + 8]
    jmp     rax

#++
#
# void
# _start (
#    _In_ void* argument1,
#    _In_ void* argument2
#    )
#
# Routine Description:
#
#    Main shellcode startup. Saves callee-preserved registers, calls
#    _entry (which initializes the dispatch table and calls the user's
#    entry function), then tail-calls _cleanup to free shellcode memory.
#
# Arguments:
#
#    argument1 - Value of RCX register (passed through to _entry/entry).
#    argument2 - Value of RDX register (passed through to _entry/entry).
#
#    r11 = shellcode base address (set by _init).
#          Stashed in r15 (callee-preserved) across the _entry call,
#          then passed to _cleanup via rcx.
#
# Return Value:
#
#    None.
#
#--

    .globl _start
    .p2align SCFW_P2ALIGN
_start:

#
# Save callee-preserved registers to the caller's shadow space.
#

    mov     [rsp + 0x08], r12
    mov     [rsp + 0x10], r13
    mov     [rsp + 0x18], r14
    mov     [rsp + 0x20], r15

#
# Allocate shadow space (32 bytes) + 8 bytes alignment = 0x28.
#

    sub     rsp, 0x28

#
# Stash the shellcode base address (from r11, set by _init) into
# r15 (callee-preserved) so it survives the _entry call.
#

    mov     r15, r11

#
# Call _entry to initialize the dispatch table and run user code.
# Using lea+call instead of a direct call to stay position-independent.
#

    lea     r13, [rip + _entry]
    call    r13

#
# Grab the shellcode base address from r15 into rcx (first arg for
# cleanup) BEFORE restoring the caller's r15. None of the register
# restores below touch rcx, so it survives to the tail call.
#

    mov     rcx, r15

#
# Tear down the stack frame and restore callee-preserved registers.
#

    add     rsp, 0x28
    mov     r15, [rsp + 0x20]
    mov     r14, [rsp + 0x18]
    mov     r13, [rsp + 0x10]
    mov     r12, [rsp + 0x08]

#
# Load cleanup_ from offset 0 of the dispatch table and tail-call it.
# rcx = shellcode base address (already set above).
#
# This MUST be a jmp (tail call), not a call. After cleanup runs,
# the shellcode memory (including this function) will be freed.
# VirtualFree returns to whoever originally invoked the shellcode.
#

    mov     rax, [rip + __dispatch_table]
    jmp     rax

```

`lib/src/arch/x86/init.S`:

```S
    .intel_syntax noprefix

#ifndef SCFW_P2ALIGN
#   define SCFW_P2ALIGN 4
#endif

#
# Externally used symbols.
#

#ifdef SCFW_ENABLE_CLEANUP
    .extern __start
#else
    .extern @_entry@8
#endif

#
# .text$00 is the very first section in the final binary.
# __init is the PE entry point (/ENTRY:_init), so it must be
# placed here to be the first instruction executed.
#

    .section .text$00,"ax"

#++
#
# void
# __fastcall
# _init (
#    _In_ void* argument1,
#    _In_ void* argument2
#    )
#
# Routine Description:
#
#    PE entry point (x86). Captures the shellcode base address using
#    the call/pop trick (x86 has no LEA [eip] like x64 has LEA [rip]),
#    then jumps to __start (with cleanup) or directly to _entry
#    (without cleanup).
#
# Arguments:
#
#    argument1 - Value of ECX register (__fastcall).
#    argument2 - Value of EDX register (__fastcall).
#
# Return Value:
#
#    None.
#
#--

    .globl __init
    .p2align SCFW_P2ALIGN
__init:

#ifdef SCFW_ENABLE_CLEANUP
#
# Get the address of __init using the call/pop trick:
#   call pushes EIP+5 onto the stack (call is 5 bytes),
#   pop loads it into esi, then subtract 5 to get __init's address.
# esi is callee-preserved, so it survives until __start uses it.
#

    call    1f
1:  pop     esi                         # esi = EIP after call
    sub     esi, 5                      # esi = address of __init (call is 5 bytes)
    jmp     __start
#else
    jmp     @_entry@8
#endif

#++
#
# void*
# __cdecl
# _pc (
#    void
#    )
#
# Routine Description:
#
#    Returns the runtime address of __pc itself. x86 version uses
#    the call/pop trick since there's no RIP-relative addressing.
#    Used by _pic() to compute compile-time vs runtime delta.
#
# Return Value:
#
#    Runtime address of this function (in EAX).
#
#--

    .globl __pc
    .p2align SCFW_P2ALIGN
__pc:
    call    1f
1:  pop     eax
    sub     eax, 5                          # Adjust for call instruction size
    ret

    .p2align SCFW_P2ALIGN

```

`lib/src/arch/x86/start.S`:

```S
    .intel_syntax noprefix

#ifndef SCFW_P2ALIGN
#   define SCFW_P2ALIGN 4
#endif

#
# Externally used symbols.
#

    .extern @_entry@8
    .extern ___dispatch_table

#
# VirtualFree flags.
#

    .equ MEM_RELEASE, 0x8000

#
# .text$10 comes after __init (.text$00).
# Contains _cleanup_*, __start - the core runtime functions that
# need to be in shellcode memory (they get freed after execution).
#

    .section .text$10,"ax"

#++
#
# void
# __fastcall
# _cleanup_usermode (
#    void* address,
#    void* return_address
#    )
#
# Routine Description:
#
#    Frees the shellcode's own memory by tail-calling VirtualFree.
#    Called by __start after _entry returns. Uses __fastcall: ecx = address
#    to free, edx = return address (where VirtualFree should return to).
#
#    Since x86 VirtualFree is __stdcall, we manually push the args in
#    reverse order plus the return address, then jmp to VirtualFree.
#
# Return Value:
#
#    None.
#
#--

    .globl @_cleanup_usermode@8
    .p2align SCFW_P2ALIGN
@_cleanup_usermode@8:

#
# Get PIC-adjusted address of the dispatch table, then read VirtualFree
# from offset +4 (free_ is the second field, 4 bytes on x86).
#

    call    __pc
    sub     eax, offset __pc
    add     eax, offset ___dispatch_table

    mov     eax, [eax + 4]                  # eax = VirtualFree

#
# Set up stdcall stack frame for VirtualFree(lpAddress, 0, MEM_RELEASE).
# Push return address (edx) below the args so VirtualFree "returns" to
# the original shellcode caller.
#

    push    MEM_RELEASE                     # dwFreeType
    push    0                               # dwSize
    push    ecx                             # lpAddress
    push    edx                             # return address
    jmp     eax                             # tail call: VirtualFree(address, 0, MEM_RELEASE)

#++
#
# void
# __fastcall
# _cleanup_kernelmode (
#    void* address,
#    void* return_address
#    )
#
# Routine Description:
#
#    Kernel-mode cleanup. Same approach as _cleanup_usermode but calls
#    ExFreePool (single argument) instead of VirtualFree.
#
# Return Value:
#
#    None.
#
#--

    .globl @_cleanup_kernelmode@8
    .p2align SCFW_P2ALIGN
@_cleanup_kernelmode@8:

#
# Get PIC-adjusted address of the dispatch table, then read ExFreePool
# from offset +4.
#

    call    __pc
    sub     eax, offset __pc
    add     eax, offset ___dispatch_table

    mov     eax, [eax + 4]                  # eax = ExFreePool

    push    ecx                             # address to free
    push    edx                             # return address
    jmp     eax                             # tail call: ExFreePool(address)

#++
#
# void
# __fastcall
# _start (
#    _In_ void* argument1,
#    _In_ void* argument2
#    )
#
# Routine Description:
#
#    Main shellcode startup (x86). Saves the return address, calls
#    _entry (which initializes the dispatch table and calls the user's
#    entry function), then tail-calls _cleanup to free shellcode memory.
#
# Arguments:
#
#    argument1 - Value of ECX register (__fastcall).
#    argument2 - Value of EDX register (__fastcall).
#
#    esi = shellcode base address (set by __init, callee-preserved).
#
# Return Value:
#
#    None.
#
#--

    .globl __start
    .p2align SCFW_P2ALIGN
__start:

#
# Save the return address from the stack into ebx (callee-preserved).
# We'll need it later to pass to the cleanup function, so VirtualFree
# returns to the original shellcode caller.
#

    mov     ebx, [esp]

#
# Call _entry to initialize the dispatch table and run user code.
# (uses __fastcall, so ecx/edx are passed through.)
#

    call    @_entry@8

#
# Get PIC-adjusted address of the dispatch table.
#

    call    __pc
    sub     eax, offset __pc
    add     eax, offset ___dispatch_table

#
# Load cleanup_ from offset 0 of the dispatch table and tail-call it.
# ecx = shellcode base address (what to free, from esi set by __init).
# edx = original return address (saved in ebx above).
#
# Must be jmp (tail call) - after cleanup, this memory is freed.
# The cleanup function sets up the VirtualFree stdcall frame and
# jumps to VirtualFree, which returns to the original caller.
#

    mov     eax, [eax]                      # eax = __dispatch_table.cleanup_

    mov     ecx, esi                        # shellcode base address (set by __init)
    mov     edx, ebx                        # return address
    jmp     eax                             # tail call

```

`lib/src/crt0.c`:

```c
//
// ???
//

#pragma code_seg(".text$50")

#include <stddef.h>

void* __cdecl memset(void* dest, int ch, size_t count)
{
    unsigned char* p = (unsigned char*)dest;
    while (count--)
        *p++ = (unsigned char)ch;
    return dest;
}

```

`scripts/build-all.ps1`:

```ps1
$ErrorActionPreference = "Stop"

$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$ProjectDir = Split-Path -Parent $ScriptDir
$BinDir = Join-Path $ProjectDir "bin"

# Clean output directory
if (Test-Path $BinDir) { Remove-Item -Recurse -Force $BinDir }
New-Item -ItemType Directory -Path "$BinDir\x86" -Force | Out-Null
New-Item -ItemType Directory -Path "$BinDir\x64" -Force | Out-Null

foreach ($arch in "x86", "x64") {
    Write-Host "=== Building $arch ==="

    $BuildDir = Join-Path $ProjectDir "build-$arch"
    if (Test-Path $BuildDir) { Remove-Item -Recurse -Force $BuildDir }

    cmake --preset $arch -S $ProjectDir
    if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

    cmake --build $BuildDir
    if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

    # Copy scrun
    Copy-Item "$BuildDir\tools\scrun.exe" "$BinDir\$arch\scrun.exe"
    Write-Host "  $arch/scrun.exe"

    # Copy all .bin files
    Get-ChildItem -Path "$BuildDir\examples\*\*.bin" | ForEach-Object {
        Copy-Item $_.FullName "$BinDir\$arch\$($_.Name)"
        $size = $_.Length
        Write-Host "  $arch/$($_.Name) ($size bytes)"
    }

    Write-Host ""
}

Write-Host "Done. Output in $BinDir\"

```

`scripts/build-all.sh`:

```sh
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
BIN_DIR="$PROJECT_DIR/bin"

# Clean output directory
rm -rf "$BIN_DIR"
mkdir -p "$BIN_DIR/x86" "$BIN_DIR/x64"

for arch in x86 x64; do
    echo "=== Building $arch ==="

    BUILD_DIR="$PROJECT_DIR/build-$arch"
    rm -rf "$BUILD_DIR"

    cmake --preset "$arch" -S "$PROJECT_DIR"
    cmake --build "$BUILD_DIR"

    # Copy scrun
    cp "$BUILD_DIR/tools/scrun.exe" "$BIN_DIR/$arch/scrun.exe"
    echo "  $arch/scrun.exe"

    # Copy all .bin files
    for bin in "$BUILD_DIR"/examples/*/*.bin; do
        [ -f "$bin" ] || continue
        name="$(basename "$bin")"
        cp "$bin" "$BIN_DIR/$arch/$name"
        size=$(wc -c < "$bin" | tr -d ' ')
        echo "  $arch/$name ($size bytes)"
    done

    echo ""
done

echo "Done. Output in $BIN_DIR/"

```

`scripts/fetch-winsdk.ps1`:

```ps1
#
# fetch-winsdk.ps1 — Download Windows SDK + CRT headers/libs via xwin.
#
# Uses an isolated CARGO_HOME/RUSTUP_HOME so nothing is left behind
# except the output directory containing crt/ and sdk/.
#

param(
    [string] $Output = ".\winsdk",
    [switch] $Force,
    [switch] $Isolated,
    [switch] $Help
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# ---------- help ----------

if ($Help) {
    Write-Host @"
Usage: fetch-winsdk.ps1 [OPTIONS]

Download Windows SDK and CRT headers/libs via xwin.

Options:
  -Output DIR   Output directory (default: .\winsdk)
  -Force        Re-download even if output directory already exists
  -Isolated     Always download fresh Rust, ignore system Rust
  -Help         Show this help
"@
    exit 0
}

# ---------- helpers ----------

$Script:IsWin = ((Test-Path variable:IsWindows) -and $IsWindows) -or ($env:OS -eq "Windows_NT")
$Script:PathSep = if ($Script:IsWin) { ";" } else { ":" }

function Invoke-NativeCommand {
    param([string] $Description)

    if ($LASTEXITCODE -ne 0) {
        throw "$Description failed (exit code $LASTEXITCODE)"
    }
}

# ---------- skip if already downloaded ----------

if (-not $Force -and (Test-Path (Join-Path $Output "crt")) -and (Test-Path (Join-Path $Output "sdk"))) {
    Write-Host "Windows SDK already present in $Output (use -Force to re-download)"
    exit 0
}

# ---------- temp dir with cleanup ----------

$TmpDir = Join-Path ([System.IO.Path]::GetTempPath()) "fetch-winsdk.$([System.IO.Path]::GetRandomFileName())"
New-Item -ItemType Directory -Path $TmpDir -Force | Out-Null
Write-Host "Temp directory: $TmpDir"

try {
    # ---------- find or install xwin ----------

    $XwinPath = $null

    # 1) Check for existing xwin on PATH
    if (-not $Isolated) {
        $Found = Get-Command xwin -ErrorAction SilentlyContinue
        if ($Found) {
            $XwinPath = $Found.Source
            Write-Host "Using system xwin: $XwinPath"
        }
    }

    # 2) Fall back to cargo install
    if (-not $XwinPath) {
        $XwinRoot = Join-Path $TmpDir "xwin-install"
        New-Item -ItemType Directory -Path $XwinRoot -Force | Out-Null

        $HasCargo = $false
        if (-not $Isolated) {
            $Found = Get-Command cargo -ErrorAction SilentlyContinue
            if ($Found) {
                Write-Host "Using system cargo: $($Found.Source)"
                $HasCargo = $true
            }
        }

        if (-not $HasCargo) {
            Write-Host "Downloading Rust toolchain into temp directory..."
            $env:CARGO_HOME = Join-Path $TmpDir "cargo"
            $env:RUSTUP_HOME = Join-Path $TmpDir "rustup"
            New-Item -ItemType Directory -Path $env:CARGO_HOME -Force | Out-Null
            New-Item -ItemType Directory -Path $env:RUSTUP_HOME -Force | Out-Null

            if ($Script:IsWin) {
                $RustupInit = Join-Path $TmpDir "rustup-init.exe"
                Invoke-WebRequest -Uri "https://win.rustup.rs/x86_64" -OutFile $RustupInit
                & $RustupInit -y --no-modify-path --default-toolchain stable --profile minimal
                Invoke-NativeCommand "rustup-init"
            } else {
                $RustupScript = Join-Path $TmpDir "rustup.sh"
                Invoke-WebRequest -Uri "https://sh.rustup.rs" -OutFile $RustupScript
                & bash $RustupScript -y --no-modify-path --default-toolchain stable --profile minimal
                Invoke-NativeCommand "rustup install"
            }

            $env:PATH = "$(Join-Path $env:CARGO_HOME 'bin')$($Script:PathSep)$env:PATH"
        }

        Write-Host "Using cargo: $((Get-Command cargo).Source)"
        & cargo --version
        Invoke-NativeCommand "cargo"

        Write-Host "Installing xwin..."
        & cargo install xwin --root $XwinRoot
        Invoke-NativeCommand "cargo install xwin"

        $XwinBin = if ($Script:IsWin) { "xwin.exe" } else { "xwin" }
        $XwinPath = Join-Path (Join-Path $XwinRoot "bin") $XwinBin
    }

    # ---------- run xwin ----------

    if ($Force -and (Test-Path $Output)) {
        Write-Host "Removing existing $Output..."
        Remove-Item -Recurse -Force $Output
    }

    New-Item -ItemType Directory -Path $Output -Force | Out-Null
    $Output = (Resolve-Path $Output).Path

    Write-Host "Fetching Windows SDK + CRT into $Output..."
    $XwinCache = Join-Path $TmpDir "xwin-cache"
    & $XwinPath --accept-license --arch x86,x86_64 --cache-dir $XwinCache splat --copy --output $Output
    Invoke-NativeCommand "xwin splat"

    Write-Host "Done. Windows SDK available at $Output"

} finally {
    Write-Host "Cleaning up temp directory..."
    Remove-Item -Recurse -Force $TmpDir -ErrorAction SilentlyContinue
}

```

`scripts/fetch-winsdk.sh`:

```sh
#!/usr/bin/env bash
#
# fetch-winsdk.sh — Download Windows SDK + CRT headers/libs via xwin.
#
# Uses an isolated CARGO_HOME/RUSTUP_HOME so nothing is left behind
# except the output directory containing crt/ and sdk/.
#

set -euo pipefail

# ---------- helpers ----------

# download URL to stdout
download() {
    if command -v curl &>/dev/null; then
        curl --proto '=https' --tlsv1.2 -sSf "$1"
    elif command -v wget &>/dev/null; then
        wget -qO- "$1"
    else
        echo "Error: neither curl nor wget found. Install one and retry." >&2
        exit 1
    fi
}

# ---------- defaults ----------

OUTPUT_DIR="./winsdk"
FORCE=0
ISOLATED=0

# ---------- argument parsing ----------

usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Download Windows SDK and CRT headers/libs via xwin.

Options:
  --output DIR   Output directory (default: ./winsdk)
  --force        Re-download even if output directory already exists
  --isolated     Always download fresh Rust, ignore system Rust
  -h, --help     Show this help
EOF
    exit 0
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --output)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --force)
            FORCE=1
            shift
            ;;
        --isolated)
            ISOLATED=1
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# ---------- skip if already downloaded ----------

if [[ $FORCE -eq 0 && -d "$OUTPUT_DIR/crt" && -d "$OUTPUT_DIR/sdk" ]]; then
    echo "Windows SDK already present in $OUTPUT_DIR (use --force to re-download)"
    exit 0
fi

# ---------- temp dir with cleanup ----------

_tmpbase="${TMPDIR:-/tmp}"
TMPDIR_ROOT="$(mktemp -d "${_tmpbase%/}/fetch-winsdk.XXXXXX")"
echo "Temp directory: $TMPDIR_ROOT"
cleanup() {
    echo "Cleaning up temp directory..."
    rm -rf "$TMPDIR_ROOT"
}
trap cleanup EXIT

# ---------- find or install xwin ----------

XWIN=""

# 1) Check for existing xwin on PATH
if [[ $ISOLATED -eq 0 ]] && command -v xwin &>/dev/null; then
    XWIN="$(command -v xwin)"
    echo "Using system xwin: $XWIN"
fi

# 2) Fall back to cargo install
if [[ -z "$XWIN" ]]; then
    XWIN_ROOT="$TMPDIR_ROOT/xwin-install"
    mkdir -p "$XWIN_ROOT"

    if [[ $ISOLATED -eq 0 ]] && command -v cargo &>/dev/null; then
        echo "Using system cargo: $(command -v cargo)"
    else
        echo "Downloading Rust toolchain into temp directory..."
        export CARGO_HOME="$TMPDIR_ROOT/cargo"
        export RUSTUP_HOME="$TMPDIR_ROOT/rustup"
        mkdir -p "$CARGO_HOME" "$RUSTUP_HOME"
        download https://sh.rustup.rs \
            | sh -s -- -y --no-modify-path --default-toolchain stable --profile minimal
        export PATH="$CARGO_HOME/bin:$PATH"
    fi

    echo "Using cargo: $(which cargo)"
    cargo --version

    echo "Installing xwin..."
    cargo install xwin --root "$XWIN_ROOT"
    XWIN="$XWIN_ROOT/bin/xwin"
fi

# ---------- run xwin ----------

# Remove existing output if --force
if [[ $FORCE -eq 1 && -d "$OUTPUT_DIR" ]]; then
    echo "Removing existing $OUTPUT_DIR..."
    rm -rf "$OUTPUT_DIR"
fi

mkdir -p "$OUTPUT_DIR"

# Resolve to absolute path for xwin
OUTPUT_DIR="$(cd "$OUTPUT_DIR" && pwd)"

echo "Fetching Windows SDK + CRT into $OUTPUT_DIR..."
"$XWIN" \
    --accept-license \
    --arch x86,x86_64 \
    --cache-dir "$TMPDIR_ROOT/xwin-cache" \
    splat \
    --copy \
    --output "$OUTPUT_DIR"

echo "Done. Windows SDK available at $OUTPUT_DIR"

```

`tools/CMakeLists.txt`:

```txt
add_executable(scrun scrun.c)
target_compile_options(scrun PRIVATE
    --target=${CMAKE_C_COMPILER_TARGET}
    ${SCFW_WINSDK_COMPILE_OPTIONS}
)
target_compile_definitions(scrun PRIVATE _CRT_SECURE_NO_WARNINGS)
target_include_directories(scrun PRIVATE ${SCFW_WINSDK_INCLUDE_DIRS})
target_link_options(scrun PRIVATE
    --target=${CMAKE_C_COMPILER_TARGET}
    -fuse-ld=lld
    -Wl,/SUBSYSTEM:CONSOLE
)
foreach(_dir IN LISTS SCFW_WINSDK_LIB_DIRS)
    target_link_options(scrun PRIVATE "-Wl,/LIBPATH:${_dir}")
endforeach()

```

`tools/scrun.c`:

```c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

int
main(
    int argc,
    char** argv
    )
{
    if (argc < 2)
    {
        fprintf(stderr, "Usage: scrun <input.bin> [arg1] [arg2]\n");
        fprintf(stderr, "\n");
        fprintf(stderr, "Loads and executes a shellcode binary.\n");
        fprintf(stderr, "\n");
        fprintf(stderr, "Arguments:\n");
        fprintf(stderr, "  input.bin  Path to the shellcode binary file\n");
        fprintf(stderr, "  arg1       Optional first argument (passed in RCX/ECX)\n");
        fprintf(stderr, "  arg2       Optional second argument (passed in RDX/EDX)\n");
        return 1;
    }

    //
    // Open the shellcode file.
    //

    HANDLE FileHandle = CreateFileA(argv[1],
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "[!] Error: Failed to open file '%s' (error %lu)\n",
                argv[1], GetLastError());
        return 1;
    }

    //
    // Get file size.
    //

    DWORD FileSize = GetFileSize(FileHandle, NULL);

    if (FileSize == INVALID_FILE_SIZE)
    {
        fprintf(stderr, "[!] Error: Failed to get file size (error %lu)\n",
                GetLastError());
        CloseHandle(FileHandle);
        return 1;
    }

    if (FileSize == 0)
    {
        fprintf(stderr, "[!] Error: File is empty\n");
        CloseHandle(FileHandle);
        return 1;
    }

    //
    // Allocate executable memory.
    //

    LPVOID BaseAddress = VirtualAlloc(NULL,
                                      FileSize,
                                      MEM_COMMIT | MEM_RESERVE,
                                      PAGE_EXECUTE_READWRITE);

    if (BaseAddress == NULL)
    {
        fprintf(stderr, "[!] Error: Failed to allocate memory (error %lu)\n",
                GetLastError());
        CloseHandle(FileHandle);
        return 1;
    }

    //
    // Read shellcode into memory.
    //

    DWORD BytesRead = 0;
    BOOL Success = ReadFile(FileHandle,
                            BaseAddress,
                            FileSize,
                            &BytesRead,
                            NULL);

    CloseHandle(FileHandle);

    if (!Success || BytesRead != FileSize)
    {
        fprintf(stderr, "[!] Error: Failed to read file (error %lu)\n",
                GetLastError());
        VirtualFree(BaseAddress, 0, MEM_RELEASE);
        return 1;
    }

    printf("[ ] Loaded %lu bytes at 0x%p\n", FileSize, BaseAddress);
    printf("[ ] Executing shellcode\n\n");

    //
    // Parse optional arguments.
    //

    PVOID Arg1 = (argc > 2) ? (PVOID)(ULONG_PTR)strtoull(argv[2], NULL, 0) : NULL;
    PVOID Arg2 = (argc > 3) ? (PVOID)(ULONG_PTR)strtoull(argv[3], NULL, 0) : NULL;

    //
    // Execute the shellcode.
    //
    // The shellcode entry point signature is:
    //   void __fastcall entry(void* argument1, void* argument2)
    //

    typedef void (__fastcall* ShellcodeEntry)(PVOID, PVOID);
    ShellcodeEntry Shellcode = (ShellcodeEntry)BaseAddress;

    Shellcode(Arg1, Arg2);

    printf("\n[ ] Shellcode returned\n");

    //
    // Test if the shellcode freed itself. If not, free the memory here.
    //

    DWORD OldProtect = 0;
    if (VirtualProtect(BaseAddress, FileSize, PAGE_NOACCESS, &OldProtect))
    {
        printf("[*] Memory freed: NO\n");
        VirtualFree(BaseAddress, 0, MEM_RELEASE);
    }
    else
    {
        printf("[ ] Memory freed: YES\n");
    }

    return 0;
}

```