Project Path: arc_gmh5225_cet-research_24_uucb9

Source Tree:

```txt
arc_gmh5225_cet-research_24_uucb9
├── README.md
├── Xpolicy
│   ├── Xpolicy.vcxproj
│   ├── Xpolicy.vcxproj.filters
│   ├── Xpolicy.vcxproj.user
│   ├── bin
│   │   ├── Xpolicy32.exe
│   │   ├── Xpolicy32.pdb
│   │   ├── Xpolicy64.exe
│   │   └── Xpolicy64.pdb
│   └── xpolicy.c
├── Xpolicy.sln
└── src
    ├── KeVerifyContextIpForUserCet.c
    ├── KeVerifyContextRecord.c
    ├── KeVerifyContextXStateCetU.c
    ├── KiVerifyContextIpForUserCet.c
    ├── KiVerifyContextRecord.c
    ├── KiVerifyContextXStateCetUEnabled.c
    ├── NtSetInformationProcess.c
    └── RtlVerifyUserUnwindTarget.c

```

`README.md`:

```md
# Windows Control Flow Enforcement Technology (CET) Research Repository

A collection of tools, source code, and papers researching Windows' implementation of CET.

Associated blog post: https://www.windows-internals.com/cet-on-windows

(c) By Yarden Shafir (@yarden_shafir) & Alex Ionescu (@aionescu)

```

`Xpolicy.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.852
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Xpolicy", "Xpolicy\Xpolicy.vcxproj", "{A82A784A-5EFB-4E1C-BE43-83169D135076}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A82A784A-5EFB-4E1C-BE43-83169D135076}.Debug|x64.ActiveCfg = Debug|x64
		{A82A784A-5EFB-4E1C-BE43-83169D135076}.Debug|x64.Build.0 = Debug|x64
		{A82A784A-5EFB-4E1C-BE43-83169D135076}.Debug|x86.ActiveCfg = Debug|Win32
		{A82A784A-5EFB-4E1C-BE43-83169D135076}.Debug|x86.Build.0 = Debug|Win32
		{A82A784A-5EFB-4E1C-BE43-83169D135076}.Release|x64.ActiveCfg = Release|x64
		{A82A784A-5EFB-4E1C-BE43-83169D135076}.Release|x64.Build.0 = Release|x64
		{A82A784A-5EFB-4E1C-BE43-83169D135076}.Release|x86.ActiveCfg = Release|Win32
		{A82A784A-5EFB-4E1C-BE43-83169D135076}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {29038274-320C-46F5-8173-5B13D1F41515}
	EndGlobalSection
EndGlobal

```

`Xpolicy/Xpolicy.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{A82A784A-5EFB-4E1C-BE43-83169D135076}</ProjectGuid>
    <RootNamespace>Xpolicy</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19525.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\lib\x86"</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\lib\x64"</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="xpolicy.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Xpolicy/Xpolicy.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="xpolicy.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Xpolicy/Xpolicy.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Xpolicy/xpolicy.c`:

```c
#define UNICODE
#include <windows.h>
#include <wchar.h>
#include <stdio.h>

typedef struct _XSAVE_CPU_INFO
{
    /* 0x0000 */ unsigned char Processor;
    /* 0x0002 */ unsigned short Family;
    /* 0x0004 */ unsigned short Model;
    /* 0x0006 */ unsigned short Stepping;
    /* 0x0008 */ unsigned short ExtendedModel;
    /* 0x000c */ unsigned long ExtendedFamily;
    /* 0x0010 */ unsigned __int64 MicrocodeVersion;
    /* 0x0018 */ unsigned long Reserved;
    /* 0x001c */ long __PADDING__[1];
} XSAVE_CPU_INFO, *PXSAVE_CPU_INFO; /* size: 0x0020 */

typedef struct _XSAVE_CPU_ERRATA
{
    /* 0x0000 */ unsigned long NumberOfErrata;
    /* 0x0008 */ struct _XSAVE_CPU_INFO Errata[1];
} XSAVE_CPU_ERRATA, *PXSAVE_CPU_ERRATA; /* size: 0x0028 */

typedef struct _XSAVE_SUPPORTED_CPU
{
    /* 0x0000 */ struct _XSAVE_CPU_INFO CpuInfo;
    union
    {
        /* 0x0020 */ struct XSAVE_CPU_ERRATA* CpuErrata;
        /* 0x0020 */ unsigned __int64 Unused;
    }; /* size: 0x0008 */
} XSAVE_SUPPORTED_CPU, *PXSAVE_SUPPORTED_CPU; /* size: 0x0028 */

typedef struct _XSAVE_VENDOR
{
    /* 0x0000 */ unsigned long VendorId[3];
    /* 0x0010 */ struct _XSAVE_SUPPORTED_CPU SupportedCpu;
} XSAVE_VENDOR, *PXSAVE_VENDOR; /* size: 0x0038 */

typedef struct _XSAVE_VENDORS
{
    /* 0x0000 */ unsigned long NumberOfVendors;
    /* 0x0008 */ struct _XSAVE_VENDOR Vendor[1];
} XSAVE_VENDORS, *PXSAVE_VENDORS; /* size: 0x0040 */

typedef struct _XSAVE_FEATURE
{
    /* 0x0000 */ unsigned long FeatureId;
    union
    {
        /* 0x0008 */ struct _XSAVE_VENDORS* Vendors;
        /* 0x0008 */ unsigned __int64 Unused;
    }; /* size: 0x0008 */
} XSAVE_FEATURE, *PXSAVE_FEATURE; /* size: 0x0010 */

typedef struct _XSAVE_POLICY
{
    /* 0x0000 */ unsigned long Version;
    /* 0x0004 */ unsigned long Size;
    /* 0x0008 */ unsigned long Flags;
    /* 0x000c */ unsigned long MaxSaveAreaLength;
    /* 0x0010 */ unsigned __int64 FeatureBitmask;
    /* 0x0018 */ unsigned long NumberOfFeatures;
    /* 0x0020 */ struct _XSAVE_FEATURE Features[1];
} XSAVE_POLICY, *PXSAVE_POLICY; /* size: 0x0030 */

PCHAR featureName[] =
{
    "XSTATE_LEGACY_FLOATING_POINT",
    "XSTATE_LEGACY_SSE",
    "XSTATE_AVX",
    "XSTATE_MPX_BNDREGS",
    "XSTATE_MPX_BNDCSR",
    "XSTATE_AVX512_KMASK",
    "XSTATE_AVX512_ZMM_H",
    "XSTATE_AVX512_ZMM",
    "XSTATE_IPT",
    "XSTATE_PKRU",
    "XSTATE_UNKNOWN",
    "XSTATE_CET_U",
};

int main()
{
    UINT res;
    WCHAR filePath[MAX_PATH];
    HMODULE handle;
    HRSRC resource;
    HGLOBAL hResource;
    PXSAVE_POLICY policy;
    PXSAVE_VENDORS xsaveVendors;
    PXSAVE_CPU_INFO cpuInfo;
    PXSAVE_CPU_ERRATA cpuErrata;

    //
    // Build the path and load hwpolicy.sys
    //
    res = GetSystemDirectory(filePath, sizeof(filePath));
    if (res == 0)
    {
        printf("Failed to get system directory. Error: %d\n", GetLastError());
        return 1;
    }
    wcscat_s(filePath, _countof(filePath), L"\\drivers\\hwpolicy.sys");
    handle = LoadLibraryEx(filePath, NULL, LOAD_LIBRARY_AS_IMAGE_RESOURCE);
    if (handle == NULL)
    {
        printf("Failed loading hwpolicy.sys. Error: %d\n", GetLastError()); 
        return 1;
    }

    //
    // Load the resource that contains the errata information
    //
    resource = FindResource(handle, MAKEINTRESOURCE(1), MAKEINTRESOURCE(101));
    if (resource == NULL)
    {
        printf("Failed finding resource. Error: %d\n", GetLastError());
        return 1;
    }
    hResource = LoadResource(handle, resource);
    if (hResource == NULL)
    {
        printf("Failed loading resource. Error: %d\n", GetLastError());
        return 1;
    }

    policy = (PXSAVE_POLICY)LockResource(hResource);

    printf("Xsave policy: %p\n", policy);
    printf("Version: 0x%x\n", policy->Version);
    printf("Size: 0x%x\n", policy->Size);
    printf("Flags: 0x%x\n", policy->Flags);
    printf("MaxSaveAreaLength: 0x%x\n", policy->MaxSaveAreaLength);
    printf("FeatureBitmask: 0x%llx\n", policy->FeatureBitmask);
    printf("NumberOfFeatures: %d\n", policy->NumberOfFeatures);

    printf("\nFeatures:\n");
    for (ULONG i = 0; i < policy->NumberOfFeatures; i++)
    {
        printf("\tFeatureId: %d (%s)\n",
                policy->Features[i].FeatureId,
                policy->Features[i].FeatureId < _countof(featureName) ?
                featureName[policy->Features[i].FeatureId] :
                "UNKNOWN");

        if (policy->Features[i].Unused == 0)
        {
            continue;
        }

        printf("\tVendors:\n");
        xsaveVendors = (PXSAVE_VENDORS)(policy->Features[i].Unused + (ULONG_PTR)policy);
        printf("\tNumber of vendors: %d\n", xsaveVendors->NumberOfVendors);
        for (ULONG j = 0; j < xsaveVendors->NumberOfVendors; j++)
        {
            printf("\t\tVendor Id: %s\n", (PCHAR)xsaveVendors->Vendor[j].VendorId);
            printf("\t\tCpu Info:\n");
            cpuInfo = &xsaveVendors->Vendor[j].SupportedCpu.CpuInfo;
            printf("\t\t\tProcessor: %x\n", cpuInfo->Processor);
            printf("\t\t\tFamily: %x\n", cpuInfo->Family);
            printf("\t\t\tModel: %x\n", cpuInfo->Model);
            printf("\t\t\tStepping: %x\n", cpuInfo->Stepping);
            printf("\t\t\tExtended model: %x\n", cpuInfo->ExtendedModel);
            printf("\t\t\tExtended family: %x\n", cpuInfo->ExtendedFamily);
            printf("\t\t\tMicrocode version: %llx\n", cpuInfo->MicrocodeVersion);
            printf("\n");

            if (xsaveVendors->Vendor[j].SupportedCpu.Unused == 0)
            {
                continue;
            }

            printf("\t\tCpu Errata:\n");
            cpuErrata = (PXSAVE_CPU_ERRATA)(xsaveVendors->Vendor[j].SupportedCpu.Unused + (ULONG_PTR)policy);
            printf("\t\tNumber of errata: %d\n", cpuErrata->NumberOfErrata);

            for (ULONG n = 0; n <cpuErrata->NumberOfErrata; n++)
            {
                cpuInfo = &cpuErrata->Errata[n];
                printf("\t\t\tProcessor: %x\n", cpuInfo->Processor);
                printf("\t\t\tFamily: %x\n", cpuInfo->Family);
                printf("\t\t\tModel: %x\n", cpuInfo->Model);
                printf("\t\t\tStepping: %x\n", cpuInfo->Stepping);
                printf("\t\t\tExtended model: %x\n", cpuInfo->ExtendedModel);
                printf("\t\t\tExtended family: %x\n", cpuInfo->ExtendedFamily);
                printf("\t\t\tMicrocode version: %llx\n", cpuInfo->MicrocodeVersion);
                printf("\n");
            }

            printf("\n");
        }
    }

    UnlockResource(hResource);
    FreeLibrary(handle);

    return 0;
}
```

`src/KeVerifyContextIpForUserCet.c`:

```c
NTSTATUS
KeVerifyContextIpForUserCet (
    _In_ PETHREAD Thread,
    _In_ PCONTEXT Context,
    _In_ PKCONTINUE_TYPE ContinueType,
    _Inout_ PULONG_PTR ShadowStack
    )
{
    PEPROCESS process;
    NTSTATUS status;
    BOOLEAN cetRelaxedMode;
    ULONG64 userRip;
    BOOLEAN notRelaxed;
    KCONTINUE_TYPE continueType;

    //
    // No need to do anything if shadow stack is not enabled
    //
    if (!Thread->Tcb.CetShadowStack)
    {
        return STATUS_SUCCESS;
    }

    //
    // No need to do anything if UserCetSetContextIpValidation is not
    // set in this process or if Rip is not being modified
    //
    process = Thread->Tcb.ApcState.Process;
    if (!(process->MitigationFlags2Values.UserCetSetContextIpValidation) ||
        !(BooleanFlagOn(Context->ContextFlags, CONTEXT_CONTROL)))
    {
        return STATUS_SUCCESS;
    }

    //
    // Verify the new Rip target
    //
    cetRelaxedMode = process->MitigationFlags2Values.UserCetSetContextIpValidationRelaxedMode & 1 != 0;
    status = KiVerifyContextIpForUserCet(Thread, Context, ContinueType, cetRelaxedMode, ShadowStack);

    //
    // Log failure if needed and fake success
    //
    if ( status == STATUS_SET_CONTEXT_DENIED )
    {
        userRip = Context->Rip;
        continueType = *ContinueType;
        notRelaxed = CetRelaxedMode ^ 1;
        if (!(process->MitigationFlags2Values.AuditUserCetSetContextIpValidation))
        {
            KiLogUserCetSetContextIpValidationFailure(2, continueType, userRip, notRelaxed);
            return status;
        }
        KiLogUserCetSetContextIpValidationFailure(1, continueType, userRip, notRelaxed);
    }
    return status;
}
```

`src/KeVerifyContextRecord.c`:

```c
NTSTATUS
KeVerifyContextRecord (
    _In_ PKTHREAD TargetThread,
    _In_ PCONTEXT ContextFrame
    _In_ PKCONTINUE_ARGUMENT ContinueArgument,
    _Outptr_ PULONG_PTR ShadowStack
    )
{
    PKPROCESS targetProcess;
    ULONG_PTR userStack;
    PTEB userTeb;
    PEWOW64PROCESS wow64Process;
    USHORT wowMachine;

    targetProcess = TargetThread->Process;
    if (targetProcess->CheckStackExtents != FALSE)
    {
        if (BooleanFlagOn(ContextFrame->ContextFlags, CONTEXT_CONTROL))
        {
            userStack = ContextFrame->Rsp;
            userTeb = TargetThread->Teb;

            //
            // Get the stack limits from the process' TEB and
            // check if the new stack pointer is inside the native stack
            //
            if (!RtlGuardIsValidStackPointer(userStack, userTeb))
            {
                //
                // New stack pointer is not inside the native stack.
                // Check if this is a wow64 process, and if it is
                // check if the new stack pointer is inside the wow64 stack.
                //
                wowMachine = PsWow64GetProcessMachine(targetProcess);
                if ((wowMachine != IMAGE_FILE_MACHINE_I386) &&
                    (wowMachine != IMAGE_FILE_MACHINE_ARMNT))
                {
                    return STATUS_INVALID_PARAMETER;
                }

                if ((userStack >= (_4GB - 1)) ||
                    !(RtlGuardIsValidWow64StackPointer(userStack, userTeb)))
                {
                    return STATUS_INVALID_PARAMETER;
                }

                //
                // Call KiVerifyContextRecord to validate the new values of CS and RIP
                //
                status = KiVerifyContextRecord(TargetThread,
                                               ContextFrame,
                                               ContinueArgument,
                                               ShadowStack);
            }
        }
    }

    //
    // If this is a non-wow64 process trying to set its CS to something
    // other than KGDT64_R3_CODE, force it to be KGDT64_R3_CODE.
    //
    if ((BooleanFlagOn(ContextFrame->ContextFlags, CONTEXT_CONTROL)) &&
        (PsWow64GetProcessMachine(targetProcess) != IMAGE_FILE_MACHINE_I386))
    {
        ContextFrame->SegCs = KGDT64_R3_CODE | RPL_MASK;
    }

    return STATUS_SUCCESS;
}
```

`src/KeVerifyContextXStateCetU.c`:

```c
NTSTATUS
KeVerifyContextXStateCetU (
    _In_ PKTHREAD Thread,
    _In_ PCONTEXT ContextRecord,
    _Outptr_ PULONG_PTR ShadowStack
    )
{
    PXSAVE_CET_U_FORMAT cetData;
    PXSAVE_AREA_HEADER xsaveData;
    NTSTATUS status;

    if (!BooleanFlagOn(Context->Context.ContextFlags, CONTEXT_XSTATE))
    {
        return STATUS_SUCCESS;
    }

    //
    // Get the address of the CET state from the supplied context
    //
    cetData = (PXSAVE_CET_U_FORMAT)RtlLocateExtendedFeature2((PCONTEXT_EX)(Context + 1),
                                                             XSTATE_CET_U,
                                                             &SharedUserData.XState,
                                                             NULL);
    if (cetData == NULL)
    {
        return STATUS_SUCCESS;
    }

    *ShadowStack = __readmsr(MSR_IA32_PL3_SSP);

    //
    // Check if the context contains values for CET registers.
    // If it doesn't, it means CET registers will not be set, and 
    // will disable CET if it was previously enabled.
    //
    xsaveData = (PXSAVE_AREA_HEADER)RTL_CONTEXT_CHUNK(Context, XState);

    if (Thread->CetUserShadowStack != FALSE)
    {
        if (!BooleanFlagOn(xsaveData->Mask, XSTATE_MASK_CET_U))
        {
            //
            // If the thread has CET enabled but the new context doesn't have
            // CET registers in it, set the CET registers in the context to
            // the current CET values.
            //
            SetFlag(xsaveData->Mask, XSTATE_MASK_CET_U);
            cetData->Ia32CetUMsr = MSR_IA32_CET_SHSTK_EN;
            cetData->Ia32Pl3SspMsr = *ShadowStack;
            return STATUS_SUCCESS;
        }

        //
        // Verify that the new Ssp value is inside the shadow stack
        //
        status = KiVerifyContextXStateCetUEnabled(cetData, *ShadowStack);
        if (NT_SUCCESS(status))
        {
            return STATUS_SUCCESS;
        }

        return status;
    }

    //
    // If the thread doesn't have CET enabled and the new context doesn't
    // have CET registers, or the CET mask is set but the CET registers 
    // don't hold any value, allow because the CET state will not change.
    //
    if (!(BooleanFlagOn(xsaveData->Mask, XSTATE_MASK_CET_U)) ||
        ((cetData->Ia32CetUMsr == 0) &&
        (cetData->Ia32Pl3SspMsr == NULL)))
    {
        return STATUS_SUCCESS;
    }

    return STATUS_SET_CONTEXT_DENIED;
}
```

`src/KiVerifyContextIpForUserCet.c`:

```c
struct _UNWIND_STATE
{
  PVOID ImageBase;
  PIMAGE_LOAD_CONFIG_DIRECTORY64 LoadConfig;
  BOOLEAN CheckedLoadConfig;
} UNWIND_STATE, *PUNWIND_STATE;


NTSTATUS
KiVerifyContextIpForUserCet (
    _In_ PETHREAD Thread, 
    _In_ PCONTEXT Context, 
    _In_ PKCONTINUE_TYPE ContinueType, 
    _In_ BOOLEAN RelaxedMode,
    _Inout_ ULONG_PTR ShadowStack
    )
{
    ULONG64 userRip;
    ULONG_PTR shadowStack;
    UKCONTINUE_TYPE continueType;
    NTSTATUS status;
    BOOLEAN loadConfigChecked;
    UNWIND_STATE unwindState;

    //
    // Deny if the target Rip a kernel address or below 0x10000
    //
    userRip = Context->Rip;
    if ((userRip >= MM_USER_PROBE_ADDRESS) ||
        (userRip < MM_ALLOCATION_GRANULARITY))
    {
        return STATUS_SET_CONTEXT_DENIED;
    }
    //
    // Ignore if target Rip is the previous address in user space
    // (such as the initial thread start address)
    //
    trapFrame = PspGetBaseTrapFrame(Thread);
    if (userRip == trapFrame->Rip)
    {
        return STATUS_SUCCESS;
    }

    shadowStack = *ShadowStack;
    continueType = *ContinueType;
    if (continueType == KCONTINUE_LONGJUMP)
    {
        return RtlVerifyUserUnwindTarget(userRip, KCONTINUE_LONGJUMP, 0);
    }
    else if ((continueType != KCONTINUE_UNWIND) && 
             (continueType != KCONTINUE_RESUME) && 
             (continueType != KCONTINUE_SET))
    {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // Get address of shadow stack if one was not provided by caller.
    // If no shadow stack exists, allow any Rip.
    //
    if (shadowStack == NULL)
    {
        shadowStack = __readmsr(MSR_IA32_PL3_SSP);
        if (shadowStack == NULL)
        {
            return STATUS_SUCCESS;
        }
    }

    if ((continueType == KCONTINUE_UNWIND) && 
        (userRip == PsNtdllExports.RtlUserThreadStart))
    {
        *ContinueType = KCONTINUE_RESUME;
        continueType = KCONTINUE_RESUME;
    }
    RtlZeroMemory(&unwindState, sizeof(unwindState));
    if (continueType == KCONTINUE_UNWIND)
    {
        status = RtlVerifyUserUnwindTarget(userRip, KCONTINUE_UNWIND, &unwindState);
        if (NT_SUCCESS(status))
        {
            return status;
        }
    }
    //
    // This code will run when RelaxedMode is enabled and continueType is
    // either KCONTINUE_SET or KCONTINUE_UNWIND if RtlVerifyUserUnwindTarget failed
    //
    if ((RelaxedMode) && (*ContinueType != KCONTINUE_RESUME))
    {
        if (!unwindState.CheckedLoadConfig)
        {
            status = RtlGetImageBaseAndLoadConfig(userRip, &unwindState.ImageBase, &unwindState.LoadConfig);
            loadConfigChecked = NT_SUCCESS(status) ? 1: unwindState.CheckedLoadConfig;
            unwindState.CheckedLoadConfig = loadConfigChecked;
        }
        if ( loadConfigChecked )
        {
            if ( unwindState.ImageBase )
            {
                //
                // Check if there is a EhContinuationTable in the LoadConfig.
                // If it exists it would be after the XFG data
                // This code is actually just a "probe" to see if there is a point in checking the EhCont flag,
                // and will throw STATUS_ACCESS_VIOLATION if it fails.
                //
                __try
                {
                    ProbeForRead(unwindState.LoadConfig, 
                                 offsetof(IMAGE_LOAD_CONFIG_DIRECTORY64, GuardEHContinuationCount),
                                 RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY64, GuardEHContinuationCount));

                    //
                    // So this code is meant as a "whitelist" for older binaries that don't fully support CET.
                    // There are some FPs with processes using NtSetContextThread to targets that CET does not expect.
                    // For newer processes that were compiled recently with the correct flags,
                    // this will create an EX_CONTINUATION_TABLE that will contain those targets.
                    // But for older processes Windows supports "relaxed mode" CET.
                    // If "relaxed mode" is set for the process, any module that does not have an EX_CONTINUATION_TABLE
                    // will be allowed to set the context to any address.
                    //
                    if ((unwindState.LoadConfig) &&
                        (unwindState.LoadConfig->Size >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY64, GuardEHContinuationCount)) &&
                        ((unwindState.LoadConfig->GuardFlags & IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT) != 0))
                    {
                        goto CheckAddressInShadowStack;
                    }
                }
                __except
                {
                    goto CheckAddressInShadowStack;
                }
                return STATUS_SUCCESS;
            }
            return STATUS_SUCCESS;
        }
    }
CheckAddressInShadowStack:
    //
    // Iterate over shadow stack and check if target Rip is in it.
    // If thread is terminating, only try to find the target Rip
    // in the current page of the shadow stack. 
    //
    __try
    {
        do
        {
            if (*shadowStack == userRip)
            {
                *ShadowStack = shadowStack + sizeof(userRip);
                return STATUS_SUCCESS;
            }
            shadowStack += sizeof(userRip);
        } while (!(PAGE_ALIGNED(shadowStack)) || !(Thread->Terminated));

        return STATUS_THREAD_IS_TERMINATING;
    }
    __except
    {
        return STATUS_SET_CONTEXT_DENIED;
    }
}
```

`src/KiVerifyContextRecord.c`:

```c
NTSTATUS
KiVerifyContextRecord (
    _In_ PKTHREAD TargetThread,
    _In_ PCONTEXT ContextFrame
    _In_ PKCONTINUE_ARGUMENT ContinueArgument,
    _Outptr_ PULONG_PTR ShadowStack
    )
{
    PKPROCESS process;

    process = Thread->Tcb.Process;

    //
    // If control registers (RIP/RSP) aren't beind modified, no checks to do
    //
    if (!BooleanFlagOn(ContextFrame->ContextFlags, CONTEXT_CONTROL))
    {
        return STATUS_SUCCESS;
    }

    //
    // If this is a non-wow64 process trying to set CS to a value other than KGDT64_R3_CODE,
    // Or this is a pico process trying to set CS to a value other than KGDT64_R3_CODE or 
    // KGDT64_R3_CMCODE, Force CS to be KGDT64_R3_CODE.
    //
    if ((PsWow64GetProcessMachine(process) != IMAGE_FILE_MACHINE_I386) &&
        ((process->PicoContext == NULL) ||
        (ContextFrame->SegCs != (KGDT64_R3_CMCODE | RPL_MASK))))
    {
        ContextFrame->SegCs = KGDT64_R3_CODE | RPL_MASK;
    }

    //
    // New context structure is not supported
    //
    if (!ARGUMENT_PRESENT(ContinueArgument))
    {
        return STATUS_SUCCESS;
    }

    //
    // Verify new RIP value in the shadow stack
    //
    status = KeVerifyContextIpForUserCet(TargetThread,
                                         ContextFrame,
                                         ContinueArgument,
                                         ShadowStack);
    if (NT_SUCCESS(status))
    {
        return STATUS_SUCCESS;
    }

    return status;
}

```

`src/KiVerifyContextXStateCetUEnabled.c`:

```c
NTSTATUS
KiVerifyContextXStateCetUEnabled (
    _In_ PXSAVE_CET_U_FORMAT CetData,
    _In_ ULONG_PTR ShadowStack
    )
{
    MEMORY_REGION_INFORMATION regionInfo;
    ULONG_PTR shadowStackEnd;
    ULONG_PTR newShadowStack;

    //
    // If the value for the MSR mask is not 1 (CET enabled), deny the new context
    //
    if (CetData->Ia32CetUMsr != MSR_IA32_CET_SHSTK_EN)
    {
        return STATUS_SET_CONTEXT_DENIED;
    }

    //
    // Deny the context if the new Ssp value is not 8-byte aligned
    //
    newShadowStack = CetData->Ia32Pl3SspMsr;
    if ((newShadowStack & 7) != 0)
    {
        return STATUS_SET_CONTEXT_DENIED;
    }

    //
    // Check if the new Ssp is lower than the current Ssp, 
    // so it will point to uninitialized memory
    //
    if (newShadowStack < ShadowStack)
    {
        return STATUS_SET_CONTEXT_DENIED;
    }

    //
    // Get the end address of the shadow stack
    //
    ZwQueryVirtualMemory(NtCurrentProcess(),
                         ShadowStack,
                         MemoryRegionInformation,
                         &regionInfo,
                         sizeof(regionInfo),
                         NULL);
    shadowStackEnd = MemoryInformation.AllocationBase +
        MemoryInformation.RegionSize -
        PAGE_SIZE;

    //
    // Check if the new Ssp is higher than the end address of 
    // the shadiw stack, so outside the stack bounds
    //
    if (newShadowStack >= shadowStackEnd)
    {
        return STATUS_SET_CONTEXT_DENIED;
    }

    return STATUS_SUCCESS;
}
```

`src/NtSetInformationProcess.c`:

```c
NTSTATUS
NTAPI
NtSetInformationProcess (
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_ PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength
    )
{
    PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION targetInfo;
    ULONG targetsSize;
    PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET targetsArray;
    PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET ehTargets;
    PEPROCESS targetProcess;
    NTSTATUS status;
    KPROCESSOR_MODE previousMode = ExGetPreviousMode();
    ULONG i;
    ULONG targetsProcessed;

    //
    // Handle the dynamic exception handlers information class
    //
    if (ProcessInformationClass == ProcessDynamicEHContinuationTargets)
    {
        //
        // Validate the data is the right size
        //
        if (ProcessInformationLength != sizeof(targetInfo))
        {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // Make a local copy of the data to avoid races
        //
        __try
        {
            targetInfo = *(PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION)ProcessInformation;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            return GetExceptionCode();
        }

        //
        // Check how many targets there are
        //
        targetsSize = sizeof(PROCESS_DYNAMIC_EH_CONTINUATION_TARGET) *
            targetInfo.NumberOfTargets;
        if (targetsSize == 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Make sure there are targets
        //
        targetsArray = targetInfo.Targets;
        if (targetsArray == NULL)
        {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Probe that the targets are all in writeable UM memory
        //
        __try
        {
            ProbeForWrite(targetsArray, targetsSize, 8);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            return GetExceptionCode();
        }

        //
        // These fields aren't used yet
        //
        if ((targetInfo.Reserved != 0) || (targetInfo.Reserved2 != 0))
        {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Only user-mode code should be setting dynamic EH targets
        //
        if (previousMode != UserMode)
        {
            return STATUS_ACCESS_DENIED;
        }

        //
        // Make sure the caller has a full process write handle to the target
        //
        targetProcess = NULL;
        status = ObReferenceObjectByHandle(ProcessHandle,
                                           GENERIC_WRITE & ~SYNCHRONIZE,
                                           (POBJECT_TYPE)PsProcessType,
                                           UserMode,
                                           (PVOID*)&targetProcess,
                                           NULL);
        if (!NT_SUCCESS(status))
        {
            goto Cleanup;
        }

        //
        // Don't allow the current process to add targets to itself
        //
        if (targetProcess == PsGetCurrentProcess())
        {
            status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        //
        // Don't allow setting EH handlers if the target process doesn't have CET
        //
        if (targetProcess->MitigationFlags2Values.CetUserShadowStacks == FALSE)
        {
            status = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }

        //
        // Allocate a kernel copy of the targets
        //
        ehTargets = ExAllocatePoolWithQuotaTag(PagedPool |
                                               POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                               targetsSize,
                                               'NHED');
        if (ehTargets == NULL)
        {
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Copy them in the array
        //
        RtlCopyMemory(ehTargets, targetsArray, targetsSize);

        //
        // Process each target in the array
        //
        targetsProcessed = 0;
        status = PspProcessDynamicEHContinuationTargets(targetProcess,
                                                        ehTargets,
                                                        targetInfo.NumberOfTargets,
                                                        &targetsProcessed);

        //
        // Write out the flags back in the original user buffer, which will
        // basically fill set DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED so the
        // caller knows what wasn't processed
        //
        __try
        {
            for (i = 0; i < targetsProcessed; i++)
            {
                targetsArray[i].Flags = ehTargets[i].Flags;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
        }

    Cleanup:
        //
        // Dereference the target process if needed
        //
        if (targetProcess != NULL)
        {
            ObDereferenceObject(targetProcess);
        }

        //
        // Free the EH target array if needed
        //
        if (ehTargets != NULL)
        {
            ExFreePoolWithTag(ehTargets, 'NHED');
        }
    }

    //
    // Return back to caller
    //
    return status;
}
```

`src/RtlVerifyUserUnwindTarget.c`:

```c
INT
RtlpTargetCompare (
    _In_opt_ PVOID Context,
    _In_ PCVOID Key,
    _In_ PCVOID Datum
    )
{
    ULONG_PTR rva1;
    ULONG_PTR rva2;
    UNREFERENCED_PARAMETER(Context);
    
    //
    // Return if the compared RVA comes before (-1), after (+1), or identical (0)
    //
    rva1 = *(PULONG_PTR)Key;
    rva2 = *(PULONG_PTR)Datum;
    return (INT)(rva1 - rva2);
}

NTSTATUS
RtlVerifyUserUnwindTarget (
    _In_ PVOID TargetRip,
    _In_ KCONTINUE_TYPE ContinueType
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY64 loadConfig;
    INVERTED_FUNCTION_TABLE_ENTRY userFunctionTable;
    ULONGLONG imageSize;
    NTSTATUS status;
    ULONG guardFlags;
    SIZE_T configSize;
    PVOID table;
    ULONGLONG count;
    ULONG rva;
    SIZE_T metaSize;
    BOOLEAN found;
    PVOID entry;
    
    //
    // First, do a quick lookup in the user function table, which should almost always work
    //
    found = RtlpLookupUserFunctionTableInverted(TargetRip, &userFunctionTable);
    if (found == FALSE)
    {
        //
        // This module might not have any exception/unwind data, so do a slow VAD lookup instead
        //
        status = MmGetImageBase(TargetRip, &userFunctionTable.ImageBase, &imageSize);
        if (!NT_SUCCESS(status))
        {
            //
            // There does not appear to be a valid module loaded at this address.
            // The only other possibility is that this is JIT, which we'll handle at the end.
            //
            userFunctionTable.ImageBase = NULL;
        }
        else
        {
            //
            // The VAD lookup can theoretically return a >= 4GB-sized module. This is not expected
            // and not supported for actual PE images.
            //
            if (imageSize >= MAXULONG)
            {
                return STATUS_INTEGER_OVERFLOW;
            }
            //
            // To simplify the code, capture the size in the same structure that the user function
            // table lookup would've returned.
            //
            userFunctionTable.SizeOfImage = (ULONG)imageSize;
        }
    }
    
    //
    // Did we find a loaded module at this address?
    //
    if (userFunctionTable.ImageBase != NULL)
    {
        //
        // We're going to touch user-mode data, so enter an exception handler context
        //
        __try
        {
            //
            // Kind of an arbitrary probe of 64 bytes, since the call below will call
            // RtlImageNtHeaderEx which does a proper probe of the whole header already.
            //
            ProbeForRead(userFunctionTable.ImageBase, 64, 1);
            
            //
            // Get the Image Load Config Directory. Note that this is a user-mode pointer
            //
            loadConfig = LdrImageDirectoryEntryToLoadConfig(userFunctionTable.ImageBase);
            
            //
            // For longjmp, use the longjump table, otherwise, for unwind, use the dynamic
            // exception handler continuation table.
            //
            if (ContinueType == KCONTINUE_LONGJUMP)
            {
                guardFlags = IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT;
                configSize = RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY64,
                                                      GuardLongJumpTargetTable);
            }
            else
            {
                guardFlags = IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT;
                configSize = RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY64,
                                                      GuardEHContinuationTable);
            }
            //
            // Probe the configuration directory, as LdrImageDirectoryEntryToLoadConfig only
            // probes the first 4 bytes to account for the "Size" field.
            //
            // This probe will also raise if loadConfig is NULL (unless this is NTVDM on 32-bit).
            //
            ProbeForRead(loadConfig, configSize, 1);
            
            //
            // Make sure there's a load configuration directory, that it's large enough to have
            // one of the two tables we care about, and that the guard flags indicate that the
            // table we care about is actually present.
            //
            if ((loadConfig == NULL) ||
                (loadConfig->Size < configSize) ||
                !(guardFlags & loadConfig->GuardFlags))
            {
                //
                // We return success here, because this means that the binary is not compatible
                // with CET. As such, for compatibility, allow this jump target.
                //
                return STATUS_SUCCESS;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // Something's wrong with the user address space, bail out
            //
            return GetExceptionCode();
        }
        
        //
        // Use the correct table and count (longjmp vs. unwind)
        //
        if (ContinueType == KCONTINUE_LONGJUMP)
        {
            table = (PVOID)loadConfig->GuardLongJumpTargetTable;
            count = loadConfig->GuardLongJumpTargetCount;
        }
        else
        {
            table = (PVOID)loadConfig->GuardEHContinuationTable;
            count = loadConfig->GuardEHContinuationCount;
        }
        
        //
        // More than 4 billion entries are not allowed
        //
        if (count >= MAXULONG)
        {
            return STATUS_INTEGER_OVERFLOW;
        }
        
        //
        // If the table is empty, then there can't be any valid targets in this image...
        //
        if (count != 0)
        {
            //
            // PE Images are always <= 4GB, so compute the 32-bit RVA
            //
            rva = (ULONG)((ULONG_PTR)TargetRip - (ULONG_PTR)userFunctionTable.ImageBase);
            
            //
            // The guard tables can have n-bytes of metadata, indicated by the upper nibble
            //
            metaSize = loadConfig->GuardFlags >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT;
            
            //
            // Search through the guard table for this RVA
            //
            entry = bsearch_s(&rva, table, count, metaSize + sizeof(rva), RtlpTargetCompare, NULL);
            if (entry != NULL)
            {
                //
                // The entry was found, so this is a valid target
                //
                return STATUS_SUCCESS;
            }
        }
    }
    
    //
    // Either there's no valid image mapped at this address, or there is, but its relevant guard
    // table does not contain the target RIP requested (as a reminder, if there's no table, then
    // the target _is_ allowed, for compatibility reasons).
    //
    // In this case, for exception unwinding (and obviously not longjmp), check if there is a
    // JIT-ted (dynamic) exception handler continuation target registered at this target.
    //
    if (ContinueType == KCONTINUE_UNWIND)
    {
        found = RtlpFindDynamicEHContinuationTarget(TargetRip);
        if (found != FALSE)
        {
            return STATUS_SUCCESS;
        }
    }
    
    //
    // Otherwise, we either didn't find a dynamic handler, or this wasn't an unwind to begin with,
    // so fail the request.
    //
    return STATUS_SET_CONTEXT_DENIED;
}

```