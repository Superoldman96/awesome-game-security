Project Path: arc_gmh5225_WSAPatch_39mgs1s6

Source Tree:

```txt
arc_gmh5225_WSAPatch_39mgs1s6
├── CMakeLists.txt
├── ErrnoRestorer.h
├── Log.cpp
├── Log.h
├── README.md
├── TimeUtils.cpp
├── TimeUtils.h
├── WsaPatch.cpp
├── WsaPatch.h
├── macros.h
└── original.dll.win11.22h2
    └── x86_64
        ├── icu.dll
        └── winhttp.dll

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.23)
project(WsaPatch)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_C_STANDARD 11)

add_library(WsaPatch SHARED WsaPatch.cpp Log.cpp TimeUtils.cpp ErrnoRestorer.h)

```

`ErrnoRestorer.h`:

```h
//
// Created by Administrator on 2022.11.30.
//

#ifndef WSAPATCH_ERRNORESTORER_H
#define WSAPATCH_ERRNORESTORER_H

#include <windows.h>

class ErrnoRestorer {
public:
    ErrnoRestorer() : saved_errno_(GetLastError()) {}

    ~ErrnoRestorer() {
        SetLastError(saved_errno_);
    }

    // disable copy and assign

    ErrnoRestorer(const ErrnoRestorer &) = delete;

    ErrnoRestorer &operator=(const ErrnoRestorer &) = delete;

    ErrnoRestorer(ErrnoRestorer &&) = delete;

    ErrnoRestorer &operator=(ErrnoRestorer &&) = delete;

    // Allow this object to be used as part of && operation.
    explicit operator bool() const { return true; }

private:
    const DWORD saved_errno_;
};

#endif //WSAPATCH_ERRNORESTORER_H

```

`Log.cpp`:

```cpp
//
// Created by Administrator on 2022.11.30.
//

#include "Log.h"

volatile Log::LogHandler Log::mHandler = nullptr;

```

`Log.h`:

```h
//
// Created by Administrator on 2022.11.30.
//

#ifndef WSAPATCH_LOG_H
#define WSAPATCH_LOG_H

#include <cstdarg>
#include <cstdio>
#include <cstring>
#include <malloc.h>
#include <strsafe.h>

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

#ifdef ERROR
#define MACRO_PUSH_ERROR 1
#pragma push_macro("ERROR")
#undef ERROR
#endif

class Log {
public:
    enum class Level {
        UNKNOWN = 0,
        VERBOSE = 2,
        DEBUG = 3,
        INFO = 4,
        WARN = 5,
        ERROR = 6
    };
    using LogHandler = void (*)(Level level, const WCHAR *tag, const WCHAR *msg);
private:
    static volatile LogHandler mHandler;
public:
    static void format(Level level, const WCHAR *tag, _Printf_format_string_ const WCHAR *fmt, ...) {
        va_list varg1;
        LogHandler h = mHandler;
        if (h == nullptr || fmt == nullptr) {
            return;
        }
        WCHAR buffer[1024] = {};
                va_start(varg1, fmt);
        StringCchVPrintfW(buffer, 1024, fmt, varg1);
                va_end(varg1);
        h(level, tag, buffer);
    }

    static void logBuffer(Level level, const WCHAR *tag, const WCHAR *msg) {
        LogHandler h = mHandler;
        if (h == nullptr) {
            return;
        }
        h(level, tag, msg);
    }

    static inline LogHandler getLogHandler() noexcept {
        return mHandler;
    }

    static inline void setLogHandler(LogHandler h) noexcept {
        mHandler = h;
    }

    static constexpr const WCHAR *levelName(Level level) noexcept {
        switch (level) {
            case Level::UNKNOWN:
                return L"UNKNOWN";
            case Level::VERBOSE:
                return L"VERBOSE";
            case Level::DEBUG:
                return L"DEBUG";
            case Level::INFO:
                return L"INFO";
            case Level::WARN:
                return L"WARN";
            case Level::ERROR:
                return L"ERROR";
            default:
                return L"UNKNOWN";
        }
    }
};

#define LOGE(...)  Log::format(static_cast<Log::Level>(6), LOG_TAG, __VA_ARGS__)
#define LOGW(...)  Log::format(Log::Level::WARN, LOG_TAG, __VA_ARGS__)
#define LOGI(...)  Log::format(Log::Level::INFO, LOG_TAG, __VA_ARGS__)
#define LOGD(...)  Log::format(Log::Level::DEBUG, LOG_TAG, __VA_ARGS__)
#define LOGV(...)  Log::format(Log::Level::VERBOSE, LOG_TAG, __VA_ARGS__)

#ifdef MACRO_PUSH_ERROR
#pragma pop_macro("ERROR")
#endif

#endif //WSAPATCH_LOG_H

```

`README.md`:

```md
# WSA patch for Windows 10

This is a patch for WSA to enable WSA (Windows Subsystem for Android) to run on Windows 10.

I have tested it with my Windows 10 22H2. Other versions like Windows 10 21H2 is not tested.

Steps:

1. Get WSA appx zip. You can do this by following instructions in https://github.com/LSPosed/MagiskOnWSALocal
   (You need to "build" this yourself with your local WSL2).
2. Get "icu.dll" from Windows 11 22H2. Note that you MUST use icu.dll from Windows 11.
   The icu.dll from Windows 10 will NOT work.
   (I have made a copy of these DLLs in the original.dll.win11.22h2 dir. They are digitally signed by Microsoft.)
3. Build WsaPatch.dll with source code in this repo.
4. Patch icu.dll: add WsaPatch.dll as an import DLL as icu.dll.
5. Copy patched icu.dll and WsaPatch.dll to WsaClient dir.
6. Patch AppxManifest.xml: Find TargetDeviceFamily node and change the MinVersion attribute to your Windows version.
7. Patch AppxManifest.xml: Delete all nodes about "customInstall" extension in AppxManifest.xml.
8. Run "Run.bat" to register your WSA appx.
9. You should be able to run WSA now.

```

`TimeUtils.cpp`:

```cpp
//
// Created by Administrator on 2022.11.30.
//

#include "TimeUtils.h"

#include <windows.h>

u64 currentTimeMillis() {
    FILETIME ft = {};
    GetSystemTimeAsFileTime(&ft);
    u64 ret = ft.dwHighDateTime;
    ret <<= 32;
    ret |= ft.dwLowDateTime;
    ret /= 10000LLU;
    return ret - 116444736000000000LLU;
}

u64 currentTimeSeconds() {
    return currentTimeMillis() / 1000LLU;
}

void timeMillisToUTCCalendar(u64 timeMillis, int *year, int *month, int *day, int *hour, int *minute, int *second, int *millisecond) {
    SYSTEMTIME st = {};
    FILETIME ft = {};
    u64 fileTime = (timeMillis + 116444736000000000LLU) * 10000LLU;
    ft.dwHighDateTime = (DWORD) (fileTime >> 32);
    ft.dwLowDateTime = (DWORD) fileTime;
    FileTimeToSystemTime(&ft, &st);
    if (year != nullptr) {
        *year = st.wYear;
    }
    if (month != nullptr) {
        *month = st.wMonth;
    }
    if (day != nullptr) {
        *day = st.wDay;
    }
    if (hour != nullptr) {
        *hour = st.wHour;
    }
    if (minute != nullptr) {
        *minute = st.wMinute;
    }
    if (second != nullptr) {
        *second = st.wSecond;
    }
    if (millisecond != nullptr) {
        *millisecond = st.wMilliseconds;
    }
}

static u64 gsTimeBiasSeconds = 0;
static bool gsTimeBiasSecondsInitialized = false;

s32 getLocalTimeBiasSeconds() {
    if (!gsTimeBiasSecondsInitialized) {
        TIME_ZONE_INFORMATION tzi = {};
        GetTimeZoneInformation(&tzi);
        gsTimeBiasSeconds = -tzi.Bias * 60LU;
        gsTimeBiasSecondsInitialized = true;
    }
    return gsTimeBiasSeconds;
}

void timeMillisToLocalCalendar(u64 timeMillis, int *year, int *month, int *day, int *hour, int *minute, int *second, int *millisecond) {
    u64 timeWithBias = timeMillis + getLocalTimeBiasSeconds() * 1000;
    timeMillisToUTCCalendar(timeWithBias, year, month, day, hour, minute, second, millisecond);
}

```

`TimeUtils.h`:

```h
//
// Created by Administrator on 2022.11.30.
//

#ifndef WSAPATCH_TIMEUTILS_H
#define WSAPATCH_TIMEUTILS_H

#include "macros.h"

u64 currentTimeMillis();

u64 currentTimeSeconds();

void timeMillisToLocalCalendar(u64 timeMillis, int *year, int *month, int *day, int *hour, int *minute, int *second, int *millisecond);

void timeMillisToUTCCalendar(u64 timeMillis, int *year, int *month, int *day, int *hour, int *minute, int *second, int *millisecond);

s32 getLocalTimeBiasSeconds();

#endif //WSAPATCH_TIMEUTILS_H

```

`WsaPatch.cpp`:

```cpp
#include "WsaPatch.h"

#include <string>

#include <windows.h>

#include "Log.h"
#include "ErrnoRestorer.h"
#include "TimeUtils.h"

static constexpr auto LOG_TAG = L"WsaPatch";

namespace wsapatch {

constexpr bool kDebug = true;

HINSTANCE gSelfInstance = nullptr;

HANDLE gConsoleOutput = INVALID_HANDLE_VALUE;
bool gConsoleIsAllocated = false;

HMODULE hNtdll = nullptr;
HMODULE hWsaClient = nullptr;

RTL_OSVERSIONINFOEXW gOsVersionInfo = {0};

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

void defaultLogHandler(Log::Level level, const WCHAR *tag, const WCHAR *msg) {
    HANDLE handle = gConsoleOutput;
    if (handle == nullptr || handle == INVALID_HANDLE_VALUE) {
        return;
    }
    WCHAR buffer[1024] = {};
    u64 now = currentTimeMillis();
    const WCHAR *levelName = Log::levelName(level);
    // MM-dd HH:mm:ss.SSS [level] tag: msg
    int month = 0, day = 0, hour = 0, minute = 0, second = 0, millisecond = 0;
    timeMillisToLocalCalendar(now, nullptr, &month, &day, &hour, &minute, &second, &millisecond);
    StringCchPrintfW(buffer, _countof(buffer),
                     L"%02d-%02d %02d:%02d:%02d.%03d %c %s: %s\n",
                     month, day, hour, minute, second, millisecond,
                     WCHAR(*levelName), tag, msg);
    DWORD written = 0;
    WriteConsoleW(handle, buffer, static_cast<DWORD>(wcslen(buffer)), &written, nullptr);
}

using FuncRtlGetVersion = NTSYSAPI NTSTATUS(*)(PRTL_OSVERSIONINFOW lpVersionInformation);

NTSTATUS WINAPI FakeRtlGetVersion(PRTL_OSVERSIONINFOW lpVersionInformation) {
    // 10.0.22000.1
    LOGD(L"-FakeRtlGetVersion");
    DWORD size = lpVersionInformation->dwOSVersionInfoSize;
    memcpy(lpVersionInformation, &gOsVersionInfo, size);
    lpVersionInformation->dwOSVersionInfoSize = size;
    lpVersionInformation->dwBuildNumber = 22000;
    return STATUS_SUCCESS;
}

FARPROC WINAPI BadGetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName) {
    FARPROC result;
    if (hModule == hNtdll && lpProcName != nullptr && strcmp(lpProcName, "RtlGetVersion") == 0) {
        result = reinterpret_cast<FARPROC>(FakeRtlGetVersion);
        SetLastError(0);
    } else {
        result = GetProcAddress(hModule, lpProcName);
        if (result == nullptr) {
            ErrnoRestorer errnoRestorer;
            if (hModule != nullptr) {
                WCHAR buffer[1024] = {};
                GetModuleFileNameW(hModule, buffer, _countof(buffer));
                LOGW(L"-GetProcAddress: hModule=%s(%p), lpProcName=%hs, result=NULL", buffer, hModule, lpProcName);
            } else {
                LOGW(L"-GetProcAddress: hModule=NULL, lpProcName=%hs, result=NULL", lpProcName ? lpProcName : "NULL");
            }
        }
    }
    return result;
}

usize kPageSize = 0;

bool isAddressReadable(void *address) {
    if (kPageSize == 0) {
        SYSTEM_INFO si = {};
        GetSystemInfo(&si);
        kPageSize = si.dwPageSize;
    }
    void *pageBase = reinterpret_cast<void *>(reinterpret_cast<uintptr>(address) & ~(kPageSize - 1));
    MEMORY_BASIC_INFORMATION info = {};
    if (VirtualQuery(pageBase, &info, sizeof(info)) == 0) {
        return false;
    }
    return (info.Protect & PAGE_READONLY) != 0 || (info.Protect & PAGE_READWRITE) != 0;
}

int HookIATProcedure(HMODULE hModule, LPCSTR procName, FARPROC replacement) {
    if (hModule == nullptr || procName == nullptr || replacement == nullptr) {
        LOGE(L"HookIATProcedure: invalid arguments: hModule=%p, procName=%hs, replacement=%p",
             hModule, procName ? procName : "(NULL)", replacement);
        return 0;
    }
    LOGI(L"HookIATProcedure: start, hModule=%p, procName=%hs, replacement=%p", hModule, procName, replacement);
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) hModule;
    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS) ((BYTE *) hModule + pDosHeader->e_lfanew);
    PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)
            ((BYTE *) hModule + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
    int count = 0;
    for (; pImportDesc->Name != 0; pImportDesc++) {
        PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA) ((BYTE *) hModule + pImportDesc->FirstThunk);
        PIMAGE_THUNK_DATA pOrgThunk = (PIMAGE_THUNK_DATA) ((BYTE *) hModule + pImportDesc->OriginalFirstThunk);
        for (; pThunk->u1.Function != 0; pThunk++, pOrgThunk++) {
            if (IMAGE_SNAP_BY_ORDINAL(pOrgThunk->u1.Ordinal)) {
                continue;
            }
            PIMAGE_IMPORT_BY_NAME pImport = (PIMAGE_IMPORT_BY_NAME) ((BYTE *) hModule + pOrgThunk->u1.AddressOfData);
            if (!isAddressReadable((char *) pImport->Name)) {
                LOGE(L"HookIATProcedure: pImport->Name is not readable: %p", pImport->Name);
                WCHAR buffer[1024] = {};
                GetModuleFileNameW(hModule, buffer, _countof(buffer));
                LOGE(L"HookIATProcedure: abort IAT hook, hModule=%s(%p), procName=%hs, replacement=%p",
                     buffer, hModule, procName, replacement);
                return -1;
            }
            if (strcmp((char *) pImport->Name, procName) == 0) {
                LOGI(L"HookIATProcedure: Found %hs at %p", procName, pThunk);
                DWORD oldProtect = 0;
                VirtualProtect(pThunk, sizeof(PVOID), PAGE_READWRITE, &oldProtect);
                pThunk->u1.Function = (DWORD_PTR) replacement;
                VirtualProtect(pThunk, sizeof(PVOID), oldProtect, &oldProtect);
                count++;
            }
        }
    }
    LOGI(L"HookIATProcedure: end, count=%d", count);
    return count;
}

bool OnLoad(HINSTANCE hInstDLL) {
    gSelfInstance = hInstDLL;
    hNtdll = GetModuleHandleW(L"ntdll.dll");
    if (hNtdll == nullptr) {
        return false;
    }
    hWsaClient = GetModuleHandleW(L"WsaClient.exe");
    if (kDebug) {
        if (AllocConsole()) {
            gConsoleIsAllocated = true;
        }
        gConsoleOutput = CreateFileW(L"CONOUT$", GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
        if (gConsoleOutput != INVALID_HANDLE_VALUE) {
            Log::setLogHandler(&defaultLogHandler);
        } else {
            std::wstring msg = std::wstring(L"Error CreateFileW CONOUT$, GetLastError=") + std::to_wstring(GetLastError());
            MessageBoxW(nullptr, msg.c_str(), L"wsapatch.dll", MB_OK | MB_ICONERROR);
        }
    }
    LOGD(L"OnLoad, hInstDLL=%p, hNtdll=%p, hWsaClient=%p", hInstDLL, hNtdll, hWsaClient);
    if (hWsaClient == nullptr) {
        // check if we are loaded into the correct process
        WCHAR filename[MAX_PATH];
        GetModuleFileNameW(nullptr, filename, MAX_PATH);
        // get lower case filename
        for (int i = 0; filename[i] != 0; i++) {
            filename[i] = towlower(filename[i]);
        }
        if (wcsstr(filename, L"\\wsaclinent.exe") == nullptr) {
            WCHAR buf[1024] = {};
            StringCbPrintfW(buf, 1024, L"GetModuleHandleW(L\"WsaClient.dll\") is NULL.\nIs wsapatch.dll loaded into wrong process?\n%s", filename);
            MessageBoxW(nullptr, buf, L"wsapatch.dll", MB_OK | MB_ICONERROR);
            return false;
        }
        return false;
    }
    LOGD(L"ntdll.dll = %p", hNtdll);
    LOGD(L"WsaClient.dll = %p", hWsaClient);
    FuncRtlGetVersion funcRtlGetVersion = reinterpret_cast<FuncRtlGetVersion>(GetProcAddress(hNtdll, "RtlGetVersion"));
    if (funcRtlGetVersion == nullptr) {
        LOGE(L"GetProcAddress(NTDLL.DLL, \"RtlGetVersion\") failed, GetLastError=%d", GetLastError());
        return false;
    }
    gOsVersionInfo.dwOSVersionInfoSize = sizeof(gOsVersionInfo);
    NTSTATUS status = funcRtlGetVersion(reinterpret_cast<PRTL_OSVERSIONINFOW>(&gOsVersionInfo));
    if (!NT_SUCCESS(status)) {
        LOGE(L"funcRtlGetVersion(&osVersionInfo) failed, status=%d", status);
        return false;
    }
    LOGD(L"RtlGetVersion: dwMajorVersion=%d, dwMinorVersion=%d, dwBuildNumber=%d, dwPlatformId=%d",
         gOsVersionInfo.dwMajorVersion, gOsVersionInfo.dwMinorVersion, gOsVersionInfo.dwBuildNumber, gOsVersionInfo.dwPlatformId);
    if (gOsVersionInfo.dwMajorVersion >= 10 && gOsVersionInfo.dwMinorVersion >= 0 && gOsVersionInfo.dwBuildNumber >= 22000) {
        LOGW(L"Windows 11 detected, no need to patch");
        return true;
    }
    int count = HookIATProcedure(hWsaClient, "GetProcAddress", reinterpret_cast<FARPROC>(&BadGetProcAddress));
    if (count == 0) {
        LOGE(L"HookIATProcedure failed, count=%d", count);
        return false;
    } else {
        LOGI(L"HookIATProcedure success, count=%d", count);
    }
    // auxiliary hooks
    // HookIATProcedure(GetModuleHandleW(L"winhttp.dll"), "GetProcAddress", reinterpret_cast<FARPROC>(&BadGetProcAddress));
    // HookIATProcedure(GetModuleHandleW(L"icu.dll"), "GetProcAddress", reinterpret_cast<FARPROC>(&BadGetProcAddress));
    return true;
}

void OnUnload() {
    HANDLE handle = gConsoleOutput;
    if (handle != nullptr && handle != INVALID_HANDLE_VALUE) {
        CloseHandle(handle);
        if (gConsoleIsAllocated) {
            FreeConsole();
            gConsoleIsAllocated = false;
        }
        gConsoleOutput = INVALID_HANDLE_VALUE;
    }
    gSelfInstance = nullptr;
}

}

EXPORT_C void NS_WsaPatch_UnusedSymbol() {
    // nothing
}

BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    // Perform actions based on the reason for calling.
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            return wsapatch::OnLoad(hInstDLL);
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            // no-op
            break;
        case DLL_PROCESS_DETACH:
            if (lpvReserved != nullptr) {
                // do not do cleanup if process termination scenario
                break;
            }
            wsapatch::OnUnload();
            break;
        default:
            break;
    }
    return true;
}

```

`WsaPatch.h`:

```h
#ifndef WSAPATCH_WSAPATCH_H
#define WSAPATCH_WSAPATCH_H

#include "macros.h"

EXPORT_C void NS_WsaPatch_UnusedSymbol();

#endif //WSAPATCH_WSAPATCH_H

```

`macros.h`:

```h
#include <stdint.h>

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;
typedef int64_t s64;

typedef size_t usize;
typedef ptrdiff_t isize;

typedef uintptr_t uintptr;

#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif


#if defined(_MSC_VER)
#define EXPORT __declspec(dllexport)
#elif defined(__GNUC__)
#define EXPORT __attribute__((visibility("default"), used))
#else
#error "Unsupported compiler"
#endif

#define EXPORT_C EXTERN_C EXPORT

```