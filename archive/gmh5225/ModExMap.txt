Project Path: arc_gmh5225_ModExMap_p367i88s

Source Tree:

```txt
arc_gmh5225_ModExMap_p367i88s
├── ModExMap
│   ├── ModExMap.cpp
│   ├── ModExMap.h
│   ├── ModExMap.vcxproj
│   ├── ModExMap.vcxproj.filters
│   ├── ModExMap.vcxproj.user
│   ├── includes.h
│   ├── main.cpp
│   ├── pestruct.h
│   └── shellcode.h
├── ModExMap.sln
└── README.md

```

`ModExMap.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31205.134
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ModExMap", "ModExMap\ModExMap.vcxproj", "{21573076-ED53-402D-BD74-9C46507197F4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{21573076-ED53-402D-BD74-9C46507197F4}.Debug|x64.ActiveCfg = Debug|x64
		{21573076-ED53-402D-BD74-9C46507197F4}.Debug|x64.Build.0 = Debug|x64
		{21573076-ED53-402D-BD74-9C46507197F4}.Debug|x86.ActiveCfg = Debug|Win32
		{21573076-ED53-402D-BD74-9C46507197F4}.Debug|x86.Build.0 = Debug|Win32
		{21573076-ED53-402D-BD74-9C46507197F4}.Release|x64.ActiveCfg = Release|x64
		{21573076-ED53-402D-BD74-9C46507197F4}.Release|x64.Build.0 = Release|x64
		{21573076-ED53-402D-BD74-9C46507197F4}.Release|x86.ActiveCfg = Release|Win32
		{21573076-ED53-402D-BD74-9C46507197F4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C903FFFC-05B5-4326-9DD5-9F7DEBF2B39B}
	EndGlobalSection
EndGlobal

```

`ModExMap/ModExMap.cpp`:

```cpp
#include "includes.h"
#include "shellcode.h"

bool is_32_bit;
int modcount;
DWORD pid;
uintptr_t base;
HANDLE prochandle;

template <typename T>
T read(uintptr_t addy) {
	T buffer;
	ReadProcessMemory(prochandle, (LPVOID)addy, &buffer, sizeof(T), 0);
	return buffer;
}
template <typename T>
void write(uintptr_t addy, T buffer) {
	WriteProcessMemory(prochandle, (LPVOID)addy, &buffer, sizeof(T), 0);
}


DWORD get_pid(const char* exename) {
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap == INVALID_HANDLE_VALUE) {
		printf("Failed opening Snapshot! 0x%x", GetLastError());
		return 0;
	}

	PROCESSENTRY32 pe32{ 0 };
	pe32.dwSize = sizeof(pe32);

	BOOL status = Process32First(hSnap, &pe32);
	while (status) {
		if (!strcmp(pe32.szExeFile, exename)) {
			CloseHandle(hSnap);
			return pe32.th32ProcessID;
		}
		status = Process32Next(hSnap, &pe32);
	}
	CloseHandle(hSnap);
	return 0;
}
uintptr_t get_base(const char* modname, DWORD pid) {
	uintptr_t base_buffer = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
	if (hSnap == INVALID_HANDLE_VALUE) {
		printf("Failed opening Snapshot! 0x%x", GetLastError());
		return 0;
	}

	MODULEENTRY32 me32{ 0 };
	me32.dwSize = sizeof(me32);

	BOOL status = Module32First(hSnap, &me32);
	while (status) {
		if (!strcmp(me32.szModule, modname)) {
			base_buffer = (uintptr_t)me32.modBaseAddr;
			IsWow64Process(prochandle, (PBOOL)&is_32_bit);
		}
		status = Module32Next(hSnap, &me32);
		modcount++;
	}
	CloseHandle(hSnap);
	return base_buffer;
}

bool ModExMap::attach(const char* proc_name) {
	pid = get_pid(proc_name);
	if (!pid) {
		printf("Couldn't find process\n");
		return false;
	}
	prochandle = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
	if (prochandle <= 0) {
		printf("Couldn't open handle with all access\n");
		return false;
	}
	base = get_base(proc_name, pid);
	if (!base) {
		printf("Couldn't get base. Guess its protected\n");
		return false;
	}

	if (is_32_bit)
		printf("Proc is 32bit\n");
	return TRUE;


}

extern "C"{
	__kernel_entry NTSTATUS
		NTAPI
		NtQueryInformationProcess(
			IN HANDLE ProcessHandle,
			IN PROCESSINFOCLASS ProcessInformationClass,
			OUT PVOID ProcessInformation,
			IN ULONG ProcessInformationLength,
			OUT PULONG ReturnLength OPTIONAL
		);

}
uintptr_t find_avail_memory(size_t size) {
	uintptr_t allocation = 0x0;
	PROCESS_BASIC_INFORMATION64 pI;
	NtQueryInformationProcess(prochandle, (PROCESSINFOCLASS)0, &pI, sizeof(pI), 0);
	if (is_32_bit) {
		pI.PebBaseAddress += 0x1000; //32 bit processes have 2 PEBs. Since we are 64 we get the 64 addy. + 1 page = 32bit
		_PEB32 peb = read<_PEB32>(pI.PebBaseAddress);
		
		DWORD first_entry = read<DWORD>(peb.Ldr + 0xC);
		while (peb.Ldr + 0xC != first_entry) { //Iterate all modules
			START:
			DWORD modbase = read<DWORD>(first_entry + 0x18);
			DWORD modsize = read<DWORD>(first_entry + 0x20);

			IMAGE_DOS_HEADER dos = read<IMAGE_DOS_HEADER>(modbase);
			IMAGE_NT_HEADERS32 nt = read<IMAGE_NT_HEADERS32>(modbase + dos.e_lfanew);

			DWORD end_of_curr_module = modbase + nt.OptionalHeader.SizeOfImage;
			DWORD to_allocate = end_of_curr_module;

			while (to_allocate % 0x10000 != 0) {
				to_allocate += 0x1;
			}
			DWORD skipped = to_allocate - end_of_curr_module;
			bool found = false;
			for (int i = 0; i <= (size / 0x1000); i++) {
				MEMORY_BASIC_INFORMATION mbi;
				VirtualQueryEx(prochandle, (LPCVOID)(to_allocate + i * 0x1000), &mbi, sizeof(MEMORY_BASIC_INFORMATION));
				if (mbi.AllocationBase) {
					found = true;
					break;
				}
			}
			if (found) {
				first_entry = read<DWORD>(first_entry);
				goto START;
			}
			write<DWORD>(first_entry + 0x20, (DWORD)(size + modsize + skipped));
			IMAGE_NT_HEADERS32 NTFAKE = nt;
			NTFAKE.OptionalHeader.SizeOfImage = nt.OptionalHeader.SizeOfImage + skipped + size;
			DWORD old;
			VirtualProtectEx(prochandle, (LPVOID)(modbase + dos.e_lfanew), sizeof(IMAGE_NT_HEADERS32), PAGE_READWRITE, &old);
			write<IMAGE_NT_HEADERS32>(modbase + dos.e_lfanew, NTFAKE);
			VirtualProtectEx(prochandle, (LPVOID)(modbase + dos.e_lfanew), sizeof(IMAGE_NT_HEADERS32), old, &old);
			allocation = to_allocate;
			break;
		}
	

	}
	else
	{
		_PEB64 peb = read<_PEB64>(pI.PebBaseAddress);

		uintptr_t first_entry = read<uintptr_t>(peb.Ldr + 0x10);
		while (peb.Ldr + 0x10 != first_entry) { //Iterate all modules
		START2:
			uintptr_t modbase = read<uintptr_t>(first_entry + 0x30);
			uintptr_t modsize = read<uintptr_t>(first_entry + 0x40);

			IMAGE_DOS_HEADER dos = read<IMAGE_DOS_HEADER>(modbase);
			IMAGE_NT_HEADERS nt = read<IMAGE_NT_HEADERS>(modbase + dos.e_lfanew);

			uintptr_t end_of_curr_module = modbase + nt.OptionalHeader.SizeOfImage;
			uintptr_t to_allocate = end_of_curr_module;

			while (to_allocate % 0x10000 != 0) {
				to_allocate += 0x1;
			}
			uintptr_t skipped = to_allocate - end_of_curr_module;
			bool found = false;
			for (int i = 0; i <= (size / 0x1000); i++) {
				MEMORY_BASIC_INFORMATION mbi;
				VirtualQueryEx(prochandle, (LPCVOID)(to_allocate + i * 0x1000), &mbi, sizeof(MEMORY_BASIC_INFORMATION));
				if (mbi.AllocationBase) {
					found = true;
					break;
				}
			}
			if (found) {
				first_entry = read<uintptr_t>(first_entry);
				goto START2;
			}
			write<uintptr_t>(first_entry + 0x40, (uintptr_t)(size + modsize + skipped));
			IMAGE_NT_HEADERS NTFAKE = nt;
			NTFAKE.OptionalHeader.SizeOfImage = nt.OptionalHeader.SizeOfImage + skipped + size;
			DWORD old;
			VirtualProtectEx(prochandle, (LPVOID)(modbase + dos.e_lfanew), sizeof(IMAGE_NT_HEADERS), PAGE_READWRITE, &old);
			write<IMAGE_NT_HEADERS>(modbase + dos.e_lfanew, NTFAKE);
			VirtualProtectEx(prochandle, (LPVOID)(modbase + dos.e_lfanew), sizeof(IMAGE_NT_HEADERS), old, &old);
			allocation = to_allocate;
			break;
		}
	}


	return allocation;
}

DWORD get_export(const char* modname, const char* funcname) {
	uintptr_t base_buffer = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
	if (hSnap == INVALID_HANDLE_VALUE) {
		printf("Failed opening Snapshot! 0x%x", GetLastError());
	}

	MODULEENTRY32 me32{ 0 };
	me32.dwSize = sizeof(me32);

	BOOL status = Module32First(hSnap, &me32);
	while (status) {
		if (!_stricmp(me32.szModule, modname)) {
			uintptr_t base = (uintptr_t)me32.modBaseAddr;
			IMAGE_DOS_HEADER dos_header = { 0 };
			IMAGE_NT_HEADERS32 nt_headers = { 0 };

			if (!ReadProcessMemory(prochandle, (LPVOID)base, &dos_header, sizeof(dos_header), 0) || dos_header.e_magic != IMAGE_DOS_SIGNATURE ||
				!ReadProcessMemory(prochandle, (LPVOID)(base + dos_header.e_lfanew), &nt_headers, sizeof(nt_headers), 0) || nt_headers.Signature != IMAGE_NT_SIGNATURE) {
				printf("ERROR\n");
				return 0;
			}



			const auto export_base = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			const auto export_base_size = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

			if (!export_base || !export_base_size) {
				printf("ERROR\n");
				return 0;
			}


			const auto export_data = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(VirtualAlloc(nullptr, export_base_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

			if (!ReadProcessMemory(prochandle, (LPVOID)(base + export_base), export_data, export_base_size, 0))
			{
				VirtualFree(export_data, 0, MEM_RELEASE);
				printf("ERROR\n");
				return 0;
			}

			const auto delta = reinterpret_cast<uint64_t>(export_data) - export_base;

			const auto name_table = reinterpret_cast<uint32_t*>(export_data->AddressOfNames + delta);
			const auto ordinal_table = reinterpret_cast<uint16_t*>(export_data->AddressOfNameOrdinals + delta);
			const auto function_table = reinterpret_cast<uint32_t*>(export_data->AddressOfFunctions + delta);

			for (auto i = 0u; i < export_data->NumberOfNames; ++i) {
				const std::string current_function_name = std::string(reinterpret_cast<char*>(name_table[i] + delta));

				if (!_stricmp(current_function_name.c_str(), funcname)) {
					const auto function_ordinal = ordinal_table[i];
					const auto function_address = base + function_table[function_ordinal];

					if (function_address >= base + export_base && function_address <= base + export_base + export_base_size) {
						VirtualFree(export_data, 0, MEM_RELEASE);
						return 0; // No forwarded exports on 64bit?
					}

					VirtualFree(export_data, 0, MEM_RELEASE);
					return function_address;
				}
			}

			VirtualFree(export_data, 0, MEM_RELEASE);
			return 0;


			CloseHandle(hSnap);
		}
		status = Module32Next(hSnap, &me32);
	}
	CloseHandle(hSnap);
	return 0;
}
template <typename T>
void map_sections(uintptr_t remote_base, char* img, T nt) {
	PIMAGE_SECTION_HEADER cSectionHeader = IMAGE_FIRST_SECTION(nt);
	for (int i = 0; i < nt->FileHeader.NumberOfSections; ++i, ++cSectionHeader) {
		if (cSectionHeader->SizeOfRawData) {
			if (WriteProcessMemory(prochandle, (char*)remote_base + cSectionHeader->VirtualAddress, (BYTE*)img + cSectionHeader->PointerToRawData, cSectionHeader->SizeOfRawData, 0)) {
				printf("Wrote %i section to %p\n", i, remote_base + cSectionHeader->VirtualAddress);
			}
			else
				printf("Failed writing %i section to %p error %x\n", i, remote_base + cSectionHeader->VirtualAddress, GetLastError());
		}
	}
}
template <typename T>
struct injectiondata {
	T loadlibrary;
	T getprocaddress;
	T dll;
};
bool ModExMap::map_dll(char* img, size_t disksize,bool wait_for_dllreturn, bool erasepeheader) {
	PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)img;
	DWORD shellcodesize = is_32_bit ? sizeof(shellcode32) : sizeof(shellcode64);
	PIMAGE_NT_HEADERS32 nt32 = (PIMAGE_NT_HEADERS32)(img + dos->e_lfanew);
	PIMAGE_NT_HEADERS nt64 = (PIMAGE_NT_HEADERS)(img + dos->e_lfanew);
	DWORD totalsize = (is_32_bit ? nt32->OptionalHeader.SizeOfImage : nt64->OptionalHeader.SizeOfImage) + shellcodesize + disksize;

	uintptr_t remote_base = find_avail_memory(totalsize);
	VirtualAllocEx(prochandle, (LPVOID)remote_base, totalsize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("Allocated at %p\n", remote_base);
	WriteProcessMemory(prochandle, (LPVOID)remote_base, img, 0x1000, 0);
	if(is_32_bit)
		map_sections(remote_base, img, nt32);
	else
		map_sections(remote_base, img, nt64);

	
	if (is_32_bit) {
		injectiondata<DWORD> data;
		data.loadlibrary = get_export("KERNEL32.DLL", "LoadLibraryA");
		data.getprocaddress = get_export("KERNELBASE.DLL", "GetProcAddress");
		data.dll = 0;
		write<injectiondata<DWORD>>(remote_base, data);
	}
	else
	{
		injectiondata<uintptr_t> data;
		data.loadlibrary = (uintptr_t)LoadLibraryA;
		data.getprocaddress = (uintptr_t)GetProcAddress;
		data.dll = 0;
		write<injectiondata<uintptr_t>>(remote_base, data);
	}
	
	WriteProcessMemory(prochandle, (LPVOID)(remote_base + totalsize - 0x1000), (LPVOID)(is_32_bit ? shellcode32 : shellcode64), shellcodesize,0);
	HANDLE ThreadHandle = CreateRemoteThread(prochandle, 0, 0, (LPTHREAD_START_ROUTINE)(remote_base + totalsize - 0x1000), (LPVOID)remote_base, 0, 0);
	CloseHandle(ThreadHandle);

	if (wait_for_dllreturn) {
		DWORD offset = is_32_bit ? 0x8 : 0x10;
		while (!read<DWORD>(remote_base + offset)) {
			Sleep(1000); //Wait for hdll to be set
		}
	}
	else
	{
		Sleep(5000);
	}
	char buffer[0x1000];
	memset(buffer, 0, 0x1000);
	if (erasepeheader) {
		WriteProcessMemory(prochandle, (LPVOID)remote_base, buffer, sizeof(buffer), 0);
	}
	
	WriteProcessMemory(prochandle, (LPVOID)(remote_base + totalsize - 0x1000), buffer, shellcodesize, 0);
	CloseHandle(prochandle);
	free(img);
	return true;
}
```

`ModExMap/ModExMap.h`:

```h
namespace ModExMap {
	bool attach(const char* proc_name);
	bool map_dll(char* img, size_t disksize, bool wait_for_dllreturn, bool erasepeheader);
}
```

`ModExMap/ModExMap.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{21573076-ed53-402d-bd74-9c46507197f4}</ProjectGuid>
    <RootNamespace>ModExMap</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="ModExMap.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h" />
    <ClInclude Include="ModExMap.h" />
    <ClInclude Include="pestruct.h" />
    <ClInclude Include="shellcode.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ModExMap/ModExMap.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Ressourcendateien">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Ressourcendateien</Filter>
    </ClCompile>
    <ClCompile Include="ModExMap.cpp">
      <Filter>Headerdateien</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="ModExMap.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="shellcode.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="pestruct.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ModExMap/ModExMap.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`ModExMap/includes.h`:

```h
#include <Windows.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <TlHelp32.h>

#pragma comment(lib, "ntdll.lib")
#include "pestruct.h"
#include "ModExMap.h"

```

`ModExMap/main.cpp`:

```cpp
#include "includes.h"
bool LoadDLL(const char* path, uintptr_t* copy, size_t* size) {
	if (!GetFileAttributesA(path))
		printf("File doesn't exist\n");

	std::ifstream sFile(path, std::ios::binary | std::ios::ate);

	if (sFile.fail())
		printf("Couldn't open filestream\n");

	*size = sFile.tellg();

	if (!*size)
		printf("File too short");

	*copy = (uintptr_t)malloc(*size);
	if (!*copy)
		printf("Error allocating memory in local process\n");
	printf("Allocated memory for dll in local process at: 0x%p\n", *copy);

	sFile.seekg(0, std::ios::beg);
	sFile.read((char*)*copy, *size);
	sFile.close();
	printf("Read file! Dump {%x, %x}\n", *(uint8_t*)*copy, *(uint8_t*)((uintptr_t)*copy + 1));
	return true;
}



int main() {



	uintptr_t base; size_t size;
	if (!LoadDLL("C:\\Users\\weak\\Desktop\\old projects\\OldStuff\\Helloworld\\x64\\Release\\Helloworld.dll", &base, &size)) {
		printf("Couldn't load dll\n");
		goto END;
	}
	if (!ModExMap::attach("PortalWars-Win64-Shipping.exe")) {
		printf("Couldn't attach to proc\n");
		goto END;
	}
		
	if (!ModExMap::map_dll((char*)base, size, true, true))
	{
		printf("Couldn't map dll\n");
		goto END;
	}
END:
	system("pause");
}
```

`ModExMap/pestruct.h`:

```h
template <typename T>
struct _UNICODE_STRING_T
{
    WORD Length;
    WORD MaximumLength;
    T Buffer;
};

template <typename T>
struct _LIST_ENTRY_T
{
    T Flink;
    T Blink;
};

template <typename T, typename NGF, int A>
struct _PEB_T
{
    typedef T type;

    union
    {
        struct
        {
            BYTE InheritedAddressSpace;
            BYTE ReadImageFileExecOptions;
            BYTE BeingDebugged;
            BYTE BitField;
        };
        T dummy01;
    };
    T Mutant;
    T ImageBaseAddress;
    T Ldr;
    T ProcessParameters;
    T SubSystemData;
    T ProcessHeap;
    T FastPebLock;
    T AtlThunkSListPtr;
    T IFEOKey;
    T CrossProcessFlags;
    T UserSharedInfoPtr;
    DWORD SystemReserved;
    DWORD AtlThunkSListPtr32;
    T ApiSetMap;
    T TlsExpansionCounter;
    T TlsBitmap;
    DWORD TlsBitmapBits[2];
    T ReadOnlySharedMemoryBase;
    T HotpatchInformation;
    T ReadOnlyStaticServerData;
    T AnsiCodePageData;
    T OemCodePageData;
    T UnicodeCaseTableData;
    DWORD NumberOfProcessors;
    union
    {
        DWORD NtGlobalFlag;
        NGF dummy02;
    };
    LARGE_INTEGER CriticalSectionTimeout;
    T HeapSegmentReserve;
    T HeapSegmentCommit;
    T HeapDeCommitTotalFreeThreshold;
    T HeapDeCommitFreeBlockThreshold;
    DWORD NumberOfHeaps;
    DWORD MaximumNumberOfHeaps;
    T ProcessHeaps;
    T GdiSharedHandleTable;
    T ProcessStarterHelper;
    T GdiDCAttributeList;
    T LoaderLock;
    DWORD OSMajorVersion;
    DWORD OSMinorVersion;
    WORD OSBuildNumber;
    WORD OSCSDVersion;
    DWORD OSPlatformId;
    DWORD ImageSubsystem;
    DWORD ImageSubsystemMajorVersion;
    T ImageSubsystemMinorVersion;
    T ActiveProcessAffinityMask;
    T GdiHandleBuffer[A];
    T PostProcessInitRoutine;
    T TlsExpansionBitmap;
    DWORD TlsExpansionBitmapBits[32];
    T SessionId;
    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    T pShimData;
    T AppCompatInfo;
    _UNICODE_STRING_T<T> CSDVersion;
    T ActivationContextData;
    T ProcessAssemblyStorageMap;
    T SystemDefaultActivationContextData;
    T SystemAssemblyStorageMap;
    T MinimumStackCommit;
    T FlsCallback;
    _LIST_ENTRY_T<T> FlsListHead;
    T FlsBitmap;
    DWORD FlsBitmapBits[4];
    T FlsHighIndex;
    T WerRegistrationData;
    T WerShipAssertPtr;
    T pContextData;
    T pImageHeaderHash;
    T TracingFlags;
    T CsrServerReadOnlySharedMemoryBase;
};

typedef _PEB_T<DWORD, DWORD64, 34> _PEB32;
typedef _PEB_T<DWORD64, DWORD, 30> _PEB64;

typedef struct _STRING_32
{
    WORD Length;
    WORD MaximumLength;
    UINT32 Buffer;
} STRING32, * PSTRING32;

typedef struct _STRING_64
{
    WORD Length;
    WORD MaximumLength;
    UINT64 Buffer;
} STRING64, * PSTRING64;

typedef struct _RTL_DRIVE_LETTER_CURDIR_32
{
    WORD Flags;
    WORD Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, * PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR_64
{
    WORD Flags;
    WORD Length;
    ULONG TimeStamp;
    STRING64 DosPath;
} RTL_DRIVE_LETTER_CURDIR64, * PRTL_DRIVE_LETTER_CURDIR64;

typedef struct _UNICODE_STRING_32
{
    WORD Length;
    WORD MaximumLength;
    UINT32 Buffer;
} UNICODE_STRING32, * PUNICODE_STRING32;

typedef struct _UNICODE_STRING_64
{
    WORD Length;
    WORD MaximumLength;
    UINT64 Buffer;
} UNICODE_STRING64, * PUNICODE_STRING64;


typedef struct _CURDIR_32
{
    UNICODE_STRING32 DosPath;
    UINT32 Handle;
} CURDIR32, * PCURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS_32
{
    ULONG MaximumLength;
    ULONG Length;
    ULONG Flags;
    ULONG DebugFlags;
    UINT32 ConsoleHandle;
    ULONG ConsoleFlags;
    UINT32 StandardInput;
    UINT32 StandardOutput;
    UINT32 StandardError;
    CURDIR32 CurrentDirectory;
    UNICODE_STRING32 DllPath;
    UNICODE_STRING32 ImagePathName;
    UNICODE_STRING32 CommandLine;
    UINT32 Environment;
    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;
    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;
    UNICODE_STRING32 DesktopInfo;
    UNICODE_STRING32 ShellInfo;
    UNICODE_STRING32 RuntimeData;
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectores[32];
    ULONG EnvironmentSize;
} RTL_USER_PROCESS_PARAMETERS32, * PRTL_USER_PROCESS_PARAMETERS32;


typedef struct _CURDIR_64
{
    UNICODE_STRING64 DosPath;
    UINT64 Handle;
} CURDIR64, * PCURDIR64;

typedef struct _RTL_USER_PROCESS_PARAMETERS_64
{
    ULONG MaximumLength;
    ULONG Length;
    ULONG Flags;
    ULONG DebugFlags;
    UINT64 ConsoleHandle;
    ULONG ConsoleFlags;
    UINT64 StandardInput;
    UINT64 StandardOutput;
    UINT64 StandardError;
    CURDIR64 CurrentDirectory;
    UNICODE_STRING64 DllPath;
    UNICODE_STRING64 ImagePathName;
    UNICODE_STRING64 CommandLine;
    UINT64 Environment;
    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;
    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING64 WindowTitle;
    UNICODE_STRING64 DesktopInfo;
    UNICODE_STRING64 ShellInfo;
    UNICODE_STRING64 RuntimeData;
    RTL_DRIVE_LETTER_CURDIR64 CurrentDirectores[32];
    ULONG EnvironmentSize;
} RTL_USER_PROCESS_PARAMETERS64, * PRTL_USER_PROCESS_PARAMETERS64;



typedef struct _PROCESS_BASIC_INFORMATION64 {
    NTSTATUS ExitStatus;
    UINT32 Reserved0;
    UINT64 PebBaseAddress;
    UINT64 AffinityMask;
    UINT32 BasePriority;
    UINT32 Reserved1;
    UINT64 UniqueProcessId;
    UINT64 InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION64;

typedef struct _PROCESS_BASIC_INFORMATION32 {
    NTSTATUS ExitStatus;
    UINT32 PebBaseAddress;
    UINT32 AffinityMask;
    UINT32 BasePriority;
    UINT32 UniqueProcessId;
    UINT32 InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION32;

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessDebugPort = 7,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessBreakOnTermination = 29
} PROCESSINFOCLASS;
```

`ModExMap/shellcode.h`:

```h
unsigned char shellcode64[506] = {
	0x48, 0x85, 0xC9, 0x0F, 0x84, 0xF0, 0x01, 0x00, 0x00, 0x56, 0x48, 0x83,
	0xEC, 0x50, 0x48, 0x8B, 0x01, 0x4C, 0x8B, 0xD9, 0x48, 0x89, 0x5C, 0x24,
	0x70, 0x48, 0x8B, 0xF1, 0x48, 0x89, 0x7C, 0x24, 0x40, 0x4C, 0x89, 0x64,
	0x24, 0x38, 0x4C, 0x63, 0x61, 0x3C, 0x4C, 0x89, 0x6C, 0x24, 0x30, 0x4C,
	0x03, 0xE1, 0x4C, 0x89, 0x7C, 0x24, 0x20, 0x4C, 0x8B, 0x79, 0x08, 0x48,
	0x89, 0x44, 0x24, 0x60, 0x45, 0x8B, 0x6C, 0x24, 0x28, 0x4C, 0x03, 0xE9,
	0x4C, 0x89, 0x6C, 0x24, 0x68, 0x4D, 0x2B, 0x5C, 0x24, 0x30, 0x0F, 0x84,
	0x91, 0x00, 0x00, 0x00, 0x41, 0x83, 0xBC, 0x24, 0xB4, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0x84, 0x74, 0x01, 0x00, 0x00, 0x45, 0x8B, 0x8C, 0x24, 0xB0,
	0x00, 0x00, 0x00, 0x4C, 0x03, 0xC9, 0x41, 0x83, 0x39, 0x00, 0x74, 0x71,
	0xBB, 0x00, 0xF0, 0x00, 0x00, 0xBF, 0x00, 0xA0, 0x00, 0x00, 0x0F, 0x1F,
	0x40, 0x00, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x41, 0x8B, 0x49, 0x04, 0x4D, 0x8D, 0x41, 0x08, 0x48, 0x8D, 0x41, 0xF8,
	0x48, 0xD1, 0xE8, 0x85, 0xC0, 0x74, 0x3B, 0x44, 0x8B, 0xD0, 0x66, 0x66,
	0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x0F, 0xB7, 0x10,
	0x0F, 0xB7, 0xC2, 0x66, 0x23, 0xC3, 0x66, 0x3B, 0xC7, 0x75, 0x11, 0x41,
	0x8B, 0x09, 0x81, 0xE2, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x04, 0x16,
	0x4C, 0x01, 0x1C, 0x01, 0x49, 0x83, 0xC0, 0x02, 0x49, 0x83, 0xEA, 0x01,
	0x75, 0xD6, 0x41, 0x8B, 0x49, 0x04, 0x8B, 0xC1, 0x4C, 0x03, 0xC8, 0x41,
	0x83, 0x39, 0x00, 0x75, 0xA7, 0x41, 0x83, 0xBC, 0x24, 0x94, 0x00, 0x00,
	0x00, 0x00, 0x0F, 0x84, 0x98, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x74, 0x24,
	0x28, 0x45, 0x8B, 0xB4, 0x24, 0x90, 0x00, 0x00, 0x00, 0x4C, 0x03, 0xF6,
	0x41, 0x8B, 0x46, 0x0C, 0x85, 0xC0, 0x74, 0x7B, 0x4C, 0x8B, 0x6C, 0x24,
	0x60, 0x48, 0x89, 0x6C, 0x24, 0x48, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
	0x8B, 0xC8, 0x48, 0x03, 0xCE, 0x41, 0xFF, 0xD5, 0x45, 0x8B, 0x06, 0x48,
	0x8B, 0xE8, 0x41, 0x8B, 0x56, 0x10, 0x49, 0x8D, 0x0C, 0x30, 0x48, 0x85,
	0xC9, 0x48, 0x8D, 0x3C, 0x32, 0x41, 0x0F, 0x45, 0xD0, 0x48, 0x8B, 0x0C,
	0x32, 0x48, 0x8D, 0x1C, 0x32, 0x48, 0x85, 0xC9, 0x74, 0x27, 0x79, 0x05,
	0x0F, 0xB7, 0xD1, 0xEB, 0x07, 0x48, 0x8D, 0x56, 0x02, 0x48, 0x03, 0xD1,
	0x48, 0x8B, 0xCD, 0x41, 0xFF, 0xD7, 0x48, 0x83, 0xC3, 0x08, 0x48, 0x89,
	0x07, 0x48, 0x83, 0xC7, 0x08, 0x48, 0x8B, 0x0B, 0x48, 0x85, 0xC9, 0x75,
	0xD9, 0x41, 0x8B, 0x46, 0x20, 0x49, 0x83, 0xC6, 0x14, 0x85, 0xC0, 0x75,
	0x9F, 0x4C, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x4C,
	0x8B, 0x74, 0x24, 0x28, 0x41, 0x83, 0xBC, 0x24, 0xD4, 0x00, 0x00, 0x00,
	0x00, 0x74, 0x2F, 0x41, 0x8B, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x48,
	0x8B, 0x5C, 0x30, 0x18, 0x48, 0x85, 0xDB, 0x74, 0x1D, 0x0F, 0x1F, 0x00,
	0x48, 0x8B, 0x03, 0x48, 0x85, 0xC0, 0x74, 0x12, 0x45, 0x33, 0xC0, 0x48,
	0x8B, 0xCE, 0x41, 0x8D, 0x50, 0x01, 0xFF, 0xD0, 0x48, 0x83, 0xC3, 0x08,
	0x75, 0xE6, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xCE, 0x41, 0x8D, 0x50, 0x01,
	0x41, 0xFF, 0xD5, 0x48, 0x89, 0x76, 0x10, 0x4C, 0x8B, 0x6C, 0x24, 0x30,
	0x4C, 0x8B, 0x64, 0x24, 0x38, 0x48, 0x8B, 0x7C, 0x24, 0x40, 0x48, 0x8B,
	0x5C, 0x24, 0x70, 0x4C, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x83, 0xC4, 0x50,
	0x5E, 0xC3
};
const static unsigned char shellcode32[328] = {
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x14, 0x57, 0x8B, 0x7D, 0x08, 0x85, 0xFF,
	0x0F, 0x84, 0x2F, 0x01, 0x00, 0x00, 0x8B, 0x4F, 0x3C, 0x8B, 0x47, 0x04,
	0x03, 0xCF, 0x8B, 0x17, 0x89, 0x45, 0xFC, 0x53, 0x8B, 0x41, 0x28, 0x03,
	0xC7, 0x89, 0x4D, 0xF0, 0x89, 0x45, 0xEC, 0x8B, 0xC7, 0x2B, 0x41, 0x34,
	0x56, 0x89, 0x55, 0xF4, 0x89, 0x45, 0x08, 0x74, 0x60, 0x83, 0xB9, 0xA4,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0x84, 0xF9, 0x00, 0x00, 0x00, 0x8B, 0xB1,
	0xA0, 0x00, 0x00, 0x00, 0x03, 0xF7, 0x83, 0x3E, 0x00, 0x74, 0x46, 0x8B,
	0x46, 0x04, 0x8D, 0x56, 0x08, 0x8D, 0x58, 0xF8, 0xD1, 0xEB, 0x74, 0x2C,
	0x0F, 0xB7, 0x02, 0x8B, 0xC8, 0x81, 0xE1, 0x00, 0xF0, 0x00, 0x00, 0x81,
	0xF9, 0x00, 0x30, 0x00, 0x00, 0x75, 0x0E, 0x8B, 0x4D, 0x08, 0x25, 0xFF,
	0x0F, 0x00, 0x00, 0x03, 0xC7, 0x03, 0x06, 0x01, 0x08, 0x83, 0xC2, 0x02,
	0x83, 0xEB, 0x01, 0x75, 0xD7, 0x8B, 0x46, 0x04, 0x03, 0xF0, 0x83, 0x3E,
	0x00, 0x75, 0xC0, 0x8B, 0x4D, 0xF0, 0x8B, 0x55, 0xF4, 0x83, 0xB9, 0x84,
	0x00, 0x00, 0x00, 0x00, 0x74, 0x69, 0x8B, 0x99, 0x80, 0x00, 0x00, 0x00,
	0x03, 0xDF, 0x89, 0x5D, 0xF8, 0x8B, 0x43, 0x0C, 0x85, 0xC0, 0x74, 0x57,
	0x03, 0xC7, 0x50, 0xFF, 0xD2, 0x8B, 0x13, 0x8B, 0x73, 0x10, 0x89, 0x45,
	0x08, 0x8D, 0x0C, 0x3A, 0x85, 0xC9, 0x8D, 0x1C, 0x3E, 0x0F, 0x45, 0xF2,
	0x03, 0xF7, 0x8B, 0x06, 0x85, 0xC0, 0x74, 0x21, 0x79, 0x05, 0x0F, 0xB7,
	0xC0, 0xEB, 0x05, 0x83, 0xC0, 0x02, 0x03, 0xC7, 0x50, 0xFF, 0x75, 0x08,
	0xFF, 0x55, 0xFC, 0x83, 0xC6, 0x04, 0x89, 0x03, 0x83, 0xC3, 0x04, 0x8B,
	0x06, 0x85, 0xC0, 0x75, 0xDF, 0x8B, 0x5D, 0xF8, 0x8B, 0x55, 0xF4, 0x83,
	0xC3, 0x14, 0x89, 0x5D, 0xF8, 0x8B, 0x43, 0x0C, 0x85, 0xC0, 0x75, 0xAC,
	0x8B, 0x4D, 0xF0, 0x83, 0xB9, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x74, 0x20,
	0x8B, 0x81, 0xC0, 0x00, 0x00, 0x00, 0x8B, 0x74, 0x38, 0x0C, 0x85, 0xF6,
	0x74, 0x12, 0x8B, 0x06, 0x85, 0xC0, 0x74, 0x0C, 0x6A, 0x00, 0x6A, 0x01,
	0x57, 0xFF, 0xD0, 0x83, 0xC6, 0x04, 0x75, 0xEE, 0x6A, 0x00, 0x6A, 0x01,
	0x57, 0xFF, 0x55, 0xEC, 0x89, 0x7F, 0x08, 0x5E, 0x5B, 0x5F, 0x8B, 0xE5,
	0x5D, 0xC2, 0x04, 0x00
};

```

`README.md`:

```md
# ModExMap
Project inspired by https://github.com/btbd/modmap

x64 Dll manual mapper that can map 64 aswell as 32bit dlls into other processes.
It iterates all modules and checks if your dll fits between them. If thats the case the module is modified and the dll mapped in between

```