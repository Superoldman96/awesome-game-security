Project Path: arc_gmh5225_NastyAlignment_vqbreki8

Source Tree:

```txt
arc_gmh5225_NastyAlignment_vqbreki8
├── helpers.asm
├── main.c
└── nt.h

```

`helpers.asm`:

```asm
PUBLIC ExpectedIp, InstrumentationUnalignedAccessorIp
.CODE

UnalignedAccessor PROC
	pushfq
	or	dword ptr [rsp], 40000h
	popfq
ExpectedIp::
	mov	rax, [rsp + 1]
	ret
UnalignedAccessor ENDP

;
; If any unaligned access occurs here due to the fact that the AC flag is set
; then we are in big trouble and we will crash.
;
; NOTE that this callback should almost be handled as if it was the SYSCALL handler
; which normally has MSR_SYSCALL_MASK MSR to mask off certain EFL on entry etc.
;
InstrumentationCallback PROC
	pushfq	; save their EFL

	;
	; FIX 1: Load EFL with default values (EFLAGS.FIXED, EFLAGS.ID)
	;
;	push	200002h
;	popfq

	;
	; FIX 2:
	; simply just clear the AC flag etc...
	;
;	pushfq
;	and     qword ptr [rsp], not 40100h
;	popfq

	;
	; This is just a simple test to trigger the issue
	; Normally instrumentation code that calls into C or C++
	; or similar code might trigger this problem.
	; or manually drafted ASM code even if not carefully drafted etc.
	;
	; even a printf call will trigger this issue.
	;
	push	rcx
InstrumentationUnalignedAccessorIp::
	mov     rcx, [rsp + 1]
	pop     rcx

	;
	; other logic etc.
	;

	popfq
	jmp	r10
InstrumentationCallback ENDP

END
```

`main.c`:

```c
#include <Windows.h>
#include <stdio.h>
#include <intrin.h>

#include "nt.h"

extern ULONGLONG ExpectedIp;
extern ULONGLONG InstrumentationUnalignedAccessorIp;

extern ULONGLONG UnalignedAccessor(void);
extern void InstrumentationCallback(void);

#pragma comment(lib, "ntdll.lib")

static LONG ehandler(PEXCEPTION_POINTERS Ptrs)
{
	//
	// here the exception can occur inside the instrumentation callback itself
	// if the instrumentation callback has something unaligned, and not where
	// we expected it to be.
	//
	__writeeflags(__readeflags() & ~0x40000);
	if (Ptrs->ExceptionRecord->ExceptionCode == STATUS_DATATYPE_MISALIGNMENT)
	{
		if (Ptrs->ExceptionRecord->ExceptionAddress == &InstrumentationUnalignedAccessorIp)
		{
			//
			// its unlikely that we will get here if the instrumentation callback is broken
			// otherwise it will just crash or infinite loop or eventually AV.
			//
			printf("ac occurred in instrumentation callback\n");
		}
		else if (Ptrs->ExceptionRecord->ExceptionAddress == &ExpectedIp)
		{
			printf("ac occurred in expected ip\n");
		}
		else
		{
			printf("ac occurred in unknown location %p\n", Ptrs->ExceptionRecord->ExceptionAddress);
		}

		Ptrs->ContextRecord->EFlags = (Ptrs->ContextRecord->EFlags & ~0x40000) | 0x10000;
		printf("got ac exception\n");
		return EXCEPTION_EXECUTE_HANDLER;
	}

	printf("got: %lx\n", Ptrs->ExceptionRecord->ExceptionCode);
	return EXCEPTION_CONTINUE_SEARCH;
}

int main()
{
	PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION info = {
		.Version = 0,
		.Reserved = 0,
		.Callback = &InstrumentationCallback,
	};
	NTSTATUS status = NtSetInformationProcess(GetCurrentProcess(), ProcessInstrumentationCallback, &info, sizeof(info));
	printf("set: %lx\n", status);

	printf("triggering unaligned access, %p %p\n", &ExpectedIp, &InstrumentationUnalignedAccessorIp);

	//
	// for debugging purposes: remove it for a more natural behavior
	//
	__debugbreak();

	__try {
		UnalignedAccessor();
		printf("no exception???\n");
	}
	__except (ehandler(GetExceptionInformation()))
	{

	}

	printf("bye\n");
	system("pause");
	return 0;
}
```

`nt.h`:

```h
#pragma once

#define ProcessInstrumentationCallback 0x28

typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION
{
        ULONG Version;  // The version of the instrumentation callback information.
        ULONG Reserved; // Reserved for future use.
        PVOID Callback; // Pointer to the callback function.
} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION, *PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
        _In_ HANDLE ProcessHandle,
        _In_ ULONG ProcessInformationClass,
        _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
        _In_ ULONG ProcessInformationLength
);
```