Project Path: arc_gmh5225_hidden_syscall_monitoring_9o7fkeoi

Source Tree:

```txt
arc_gmh5225_hidden_syscall_monitoring_9o7fkeoi
├── LICENSE
├── README.md
├── game.png
├── pic.png
├── sys_monitor
│   ├── NtAllocateVirtualMemory_Hook.cpp
│   ├── NtAllocateVirtualMemory_Hook.h
│   ├── NtProtectVirtualMemory_Hook.cpp
│   ├── NtProtectVirtualMemory_Hook.h
│   ├── entry.cpp
│   ├── hook_type.h
│   ├── page_guard_hook.cpp
│   ├── page_guard_hook.h
│   ├── sig_scan.cpp
│   ├── sig_scan.h
│   ├── sys_monitor.cpp
│   ├── sys_monitor.h
│   ├── sys_monitor.vcxproj
│   ├── sys_monitor.vcxproj.filters
│   ├── sys_monitor.vcxproj.user
│   ├── syscall_spoofer.h
│   ├── text_section_code.cpp
│   ├── text_section_code.h
│   ├── util.cpp
│   └── util.h
└── sys_monitor.sln

```

`LICENSE`:

```
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

```

`README.md`:

```md
# hidden syscall monitoring
 monitors hidden syscalls called from call of duty anticheat via exception hooking

# poc
the anticheat does not call NtAllocateVirtualMemory for these, they have a large spot in the .text section and they call NtProtectVirtualMemory with PAGE_EXECUTE_READWRITE on it.

# example 
```cpp
int main(int argc, char** argv)
{
	sys_monitor::init();

	while (true)
	{
		const auto syassasd = (unsigned __int64)GetProcAddress(LoadLibraryA("ntdll"), "NtTerminateProcess");
		const auto spoof_start = (unsigned __int64)GetProcAddress(LoadLibraryA("ntdll"), "NtOpenFile");
		syscall_spoofer::spoof_syscall(spoof_start, syassasd, (HANDLE)-1, 1337);

		Sleep(5000);
	}

	getchar();
	return 0;
}  
```

# output
![image info](./pic.png)

# game
![image info](./game.png)

we can see their favorite functions

```

`sys_monitor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.35425.106
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sys_monitor", "sys_monitor\sys_monitor.vcxproj", "{48802D39-DDC8-46A0-A70B-06DF7FE864DB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{48802D39-DDC8-46A0-A70B-06DF7FE864DB}.Debug|x64.ActiveCfg = Debug|x64
		{48802D39-DDC8-46A0-A70B-06DF7FE864DB}.Debug|x64.Build.0 = Debug|x64
		{48802D39-DDC8-46A0-A70B-06DF7FE864DB}.Debug|x86.ActiveCfg = Debug|Win32
		{48802D39-DDC8-46A0-A70B-06DF7FE864DB}.Debug|x86.Build.0 = Debug|Win32
		{48802D39-DDC8-46A0-A70B-06DF7FE864DB}.Release|x64.ActiveCfg = Release|x64
		{48802D39-DDC8-46A0-A70B-06DF7FE864DB}.Release|x64.Build.0 = Release|x64
		{48802D39-DDC8-46A0-A70B-06DF7FE864DB}.Release|x86.ActiveCfg = Release|Win32
		{48802D39-DDC8-46A0-A70B-06DF7FE864DB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {42933690-D713-4C34-8655-7CA0EBDF12DE}
	EndGlobalSection
EndGlobal

```

`sys_monitor/NtAllocateVirtualMemory_Hook.cpp`:

```cpp
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include "NtAllocateVirtualMemory_Hook.h"
#include "page_guard_hook.h"
#ifdef PAGE_GUARD_HOOK
NTSTATUS NtAllocateVirtualMemory_Hook::hook(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect)
{
	const auto result = reinterpret_cast<decltype(&NtAllocateVirtualMemory_Hook::hook)>(NtAllocateVirtualMemory_Hook::original_function)(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);

	if (Protect == PAGE_EXECUTE_READWRITE && BaseAddress && RegionSize && result == 0)
	{
		// page guard memory that wants to be executed
		page_guard_hook::register_guard(reinterpret_cast<unsigned __int64>(*BaseAddress), *RegionSize);
	}

	return result;
}
#endif
```

`sys_monitor/NtAllocateVirtualMemory_Hook.h`:

```h
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once
#include "hook_type.h"

#ifdef PAGE_GUARD_HOOK
#include <Windows.h>
#include <stdio.h>
#include <intrin.h>
#include <thread>
#include <shared_mutex>
#include <atomic>
#include <mutex>

typedef LONG NTSTATUS;

namespace NtAllocateVirtualMemory_Hook
{
	inline unsigned __int64 original_function;

	NTSTATUS hook(
		HANDLE    ProcessHandle,
		PVOID* BaseAddress,
		ULONG_PTR ZeroBits,
		PSIZE_T   RegionSize,
		ULONG     AllocationType,
		ULONG     Protect
	);
};

#endif
```

`sys_monitor/NtProtectVirtualMemory_Hook.cpp`:

```cpp
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include "NtProtectVirtualMemory_Hook.h"
#include "page_guard_hook.h"

#ifdef EXCEPTION_HOOK

NTSTATUS NtProtectVirtualMemory_Hook::hook(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG NewProtection, PULONG OldProtection)
{
	NTSTATUS result = 0;

	if (NewProtection == PAGE_EXECUTE_READWRITE && BaseAddress && RegionSize && OldProtection && result == 0)
	{
		// not the best way, but this lets us know its us changing the memory and not the game
		if (OldProtection != reinterpret_cast<PULONG>(1337))
		{
			// PAGE_READWRITE so that the memory will throw an exception on execution
			result = reinterpret_cast<decltype(&NtProtectVirtualMemory_Hook::hook)>(NtProtectVirtualMemory_Hook::original_function)(ProcessHandle, BaseAddress, RegionSize, PAGE_READWRITE, OldProtection);
			const auto page_address = reinterpret_cast<unsigned __int64>(*BaseAddress);
		}
		else
		{
			// just a temp variable because NtProtectVirtualMemory returns an error if OldProtection isnt a valid pointer
			ULONG fake_old;
			result = reinterpret_cast<decltype(&NtProtectVirtualMemory_Hook::hook)>(NtProtectVirtualMemory_Hook::original_function)(ProcessHandle, BaseAddress, RegionSize, NewProtection, &fake_old);
		}
	}
	else
	{
		// call original
		result = reinterpret_cast<decltype(&NtProtectVirtualMemory_Hook::hook)>(NtProtectVirtualMemory_Hook::original_function)(ProcessHandle, BaseAddress, RegionSize, NewProtection, OldProtection);
	}

	return result;
}

#endif
```

`sys_monitor/NtProtectVirtualMemory_Hook.h`:

```h
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once
#include "hook_type.h"
#include <Windows.h>
#include <stdio.h>
#include <intrin.h>
#include <thread>
#include <shared_mutex>
#include <atomic>
#include <mutex>


typedef LONG NTSTATUS;
#ifdef EXCEPTION_HOOK
namespace NtProtectVirtualMemory_Hook
{
	inline unsigned __int64 original_function;

	NTSTATUS hook(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG NewProtection, PULONG OldProtection);
};
#endif


```

`sys_monitor/entry.cpp`:

```cpp
// entry.cpp : This file contains the 'main' function. Program execution begins and ends there.

#include <Windows.h>
#include <stdio.h>

#include "sys_monitor.h"
#include "syscall_spoofer.h"

int main(int argc, char** argv)
{
	sys_monitor::init();

	while (true)
	{
		const auto syassasd = (unsigned __int64)GetProcAddress(LoadLibraryA("ntdll"), "NtTerminateProcess");
		const auto spoof_start = (unsigned __int64)GetProcAddress(LoadLibraryA("ntdll"), "NtOpenFile");
		syscall_spoofer::spoof_syscall(spoof_start, syassasd, (HANDLE)-1, 1337);

		Sleep(5000);
	}

	getchar();
	return 0;
}  
```

`sys_monitor/hook_type.h`:

```h
#pragma once

// this is what would be used for the game
#define EXCEPTION_HOOK

// this will catch things that use virtual alloc for their syscall stub
#define PAGE_GUARD_HOOK
```

`sys_monitor/page_guard_hook.cpp`:

```cpp
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/


#include "page_guard_hook.h"
#include "sig_scan.h"

struct guarded_page_t
{
	unsigned __int64 virtual_address;
	unsigned __int32 region_size;
};

std::mutex register_mutex;
std::vector<guarded_page_t> guarded_pages;

LONG WINAPI guard_UnhandledExceptionFilter(EXCEPTION_POINTERS* ex);

bool guard_memory(unsigned __int64 address, unsigned __int32 region_size)
{
	// get the original protection
	MEMORY_BASIC_INFORMATION mbi;
	if (!VirtualQuery(reinterpret_cast<void*>(address), &mbi, sizeof(mbi)))
	{
		printf("failed to query memory: %p\n", address);
		return false;
	}

	DWORD old;
	if (!VirtualProtect(reinterpret_cast<void*>(address), region_size, mbi.Protect | PAGE_GUARD, &old))
	{
		printf("failed to adjust memory protection for: %p\n", address);
		return false;
	}

	return true;
}


void page_guard_hook::register_guard(unsigned __int64 address, unsigned __int32 region_size)
{
	std::lock_guard<std::mutex> lock(register_mutex);
	guarded_pages.push_back({ address, region_size });

	if (!guard_memory(address, region_size))
	{
		printf("failed to guard memory: %p\n", address);
	}
}

void page_guard_hook::install_handler()
{
	AddVectoredExceptionHandler(TRUE, guard_UnhandledExceptionFilter);
}

// called under both the single step and page guard violation handlers
// this is because we can't guarentee which one will have the exception address of mov r10, rcx 
// because we are constantly swapping between instructions
bool search_for_syscall_stub(unsigned __int64 start, CONTEXT* context_record)
{
	const auto instructions = reinterpret_cast<unsigned char*>(start);

	// 4c 8b d1
	// mov r10, rcx
	if (instructions[0] == 0x4C && instructions[1] == 0x8B && instructions[2] == 0xD1)
	{		
		__int32 syscall_index = -1;
		__int32* address_of_syscall_index = nullptr;

		// cods stub does a jmp + x, but this is here just incase 
		if (instructions[3] == 0xB8) // mov eax, 0x0000000
		{
			syscall_index = *reinterpret_cast<unsigned __int32*>(&instructions[4]);
			address_of_syscall_index = reinterpret_cast<__int32*>(&instructions[4]);
		}
		else if (instructions[3] == 0xEB)
		{
			// cod only uses a __int8 jmp index
			const auto jmp_index = instructions[4];

			// resolve where its jumping to
			const auto jmp_start = reinterpret_cast<unsigned __int64>(&instructions[3]);
			const auto resolved_address = jmp_start + jmp_index + 2; // 0xEB, 0x0, 2 bytes rva

			// read instructions
			const auto resolved_instructions = reinterpret_cast<unsigned char*>(resolved_address);
			if (resolved_instructions[0] == 0xB8)
			{
				syscall_index = *reinterpret_cast<unsigned __int32*>(&resolved_instructions[1]);
				address_of_syscall_index = reinterpret_cast<__int32*>(&resolved_instructions[1]);
			}	
		}

		if (syscall_index != -1)
		{
			// figure out what the actual syscall is here
			// mov r10, rcx
			// mov eax, 0x0000000
			unsigned char search_bytes[] =
			{
				0x4C, 0x8B, 0xD1,
				0xB8, 0x00, 0x00, 0x00, 0x00
			};

			// add the syscall index to our stub
			*reinterpret_cast<unsigned __int32*>(&search_bytes[4]) = syscall_index;

			// search ntdll for the syscall stub
			const auto result = sig_scan::find_signature(reinterpret_cast<unsigned __int64>(LoadLibraryA("ntdll")), search_bytes, sizeof(search_bytes));

			BYTE symbol_buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME]{ 0 };
			PSYMBOL_INFO symbol_info = reinterpret_cast<PSYMBOL_INFO>(symbol_buffer);
			symbol_info->SizeOfStruct = sizeof(SYMBOL_INFO);
			symbol_info->MaxNameLen = MAX_SYM_NAME;

			if (SymFromAddr(reinterpret_cast<HANDLE>(-1), result, NULL, symbol_info))
			{
				printf("SYSCALL: %s (%p) [index: %x]\n", symbol_info->Name, result, syscall_index);

				CONTEXT ctx_copy = *context_record;

				std::vector<STACKFRAME64> frames;

				STACKFRAME64 stack_frame = {};
				stack_frame.AddrPC.Offset = ctx_copy.Rip;
				stack_frame.AddrPC.Mode = AddrModeFlat;
				stack_frame.AddrFrame.Offset = ctx_copy.Rsp;
				stack_frame.AddrFrame.Mode = AddrModeFlat;
				stack_frame.AddrStack.Offset = ctx_copy.Rsp;
				stack_frame.AddrStack.Mode = AddrModeFlat;

				HANDLE process = GetCurrentProcess();
				HANDLE thread = GetCurrentThread();

				// walk the stack to figure out where this was called from
				while (StackWalk64(
					IMAGE_FILE_MACHINE_AMD64,
					process,
					thread,
					&stack_frame,
					&ctx_copy,
					NULL,
					SymFunctionTableAccess64,
					SymGetModuleBase64,
					NULL))
				{
					// end of stack
					if (stack_frame.AddrPC.Offset == 0)
						break;

					frames.push_back(stack_frame);

				};

				// print it out
				for (auto& stack_frame : frames)
				{
					wchar_t module_name[512];
					memset(module_name, 0, sizeof(module_name));

					HMODULE module;
					RtlPcToFileHeader(reinterpret_cast<PVOID>(stack_frame.AddrPC.Offset), reinterpret_cast<PVOID*>(&module));

					if (GetModuleBaseNameW(reinterpret_cast<HANDLE>(-1), module, module_name, sizeof(module_name)))
					{
						const auto module_base = reinterpret_cast<unsigned __int64>(GetModuleHandleW(module_name));
						const auto rva = stack_frame.AddrPC.Offset - module_base;

						if (module) // nullptr if RtlPcToFileHeader failed to find
						{
							printf("%ws!0x%p\n", module_name, rva);
						}
						else
						{
							printf("0x%p\n", stack_frame.AddrPC.Offset);
						}
					}
				}

			}
			else
			{
				printf("Failed to find syscall %p (index: %x)\n", result, syscall_index);
			}

			// example modification of syscall index
			// in our case this will prevent NtTerminateProcess
			if (address_of_syscall_index)
			{
				*address_of_syscall_index = 0;
			}

			return true;
		}
	}
	return false;
}

// rip, page
std::unordered_map<unsigned __int64, guarded_page_t> guarded_page_restore;
LONG WINAPI guard_UnhandledExceptionFilter(EXCEPTION_POINTERS* ex)
{
	const auto return_address = *reinterpret_cast<unsigned __int64*>(ex->ContextRecord->Rsp);
	const auto exception_address = ex->ExceptionRecord->ExceptionAddress;

#ifdef PAGE_GUARD_HOOK

	if (ex->ExceptionRecord->ExceptionCode == STATUS_GUARD_PAGE_VIOLATION)
	{
		guarded_page_t page_to_restore{ 0, 0 };

		for (const auto& page : guarded_pages)
		{
			if (return_address >= page.virtual_address && return_address <= page.virtual_address + page.region_size)
			{
				page_to_restore.virtual_address = page.virtual_address;
				page_to_restore.region_size = page.region_size;
				break;
			}
		}

		//printf("STATUS_GUARD_PAGE_VIOLATION: %p\n", ex->ContextRecord->Rsp);

		guarded_page_restore[return_address] = page_to_restore;

		if (search_for_syscall_stub(reinterpret_cast<unsigned __int64>(ex->ExceptionRecord->ExceptionAddress), ex->ContextRecord))
		{
			printf("[PAGE GUARD HOOK] FOUND SYSCALL AT: %p\n", reinterpret_cast<unsigned __int64>(ex->ExceptionRecord->ExceptionAddress));
		}

		// enable single step, windows removes PAGE_GUARD after the exception has been fired, so we need to restore it
		ex->ContextRecord->EFlags |= 0x100;
		return EXCEPTION_CONTINUE_EXECUTION;
	}

	if (ex->ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)
	{
		if (guarded_page_restore.find(return_address) != guarded_page_restore.end())
		{
			if (search_for_syscall_stub(reinterpret_cast<unsigned __int64>(ex->ExceptionRecord->ExceptionAddress), ex->ContextRecord))
			{
				printf("[PAGE GUARD HOOK] FOUND SYSCALL AT: %p\n", reinterpret_cast<unsigned __int64>(ex->ExceptionRecord->ExceptionAddress));
			}

			// guard the memory after we mess with it to prevent recursion
			const auto page_to_restore = guarded_page_restore[return_address];
			if (page_to_restore.virtual_address)
			{
				if (!guard_memory(page_to_restore.virtual_address, page_to_restore.region_size))
				{
					printf("failed to guard memory: %p\n", page_to_restore.virtual_address);
				}
			}

		}

		return EXCEPTION_CONTINUE_EXECUTION;
	}
#endif // PAGE_GUARD_HOOK

#ifdef EXCEPTION_HOOK
	if (ex->ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION)
	{
		const auto access_type = ex->ExceptionRecord->ExceptionInformation[0];

		if (access_type == 8) // execute attempt (dep violation)
		{
			MEMORY_BASIC_INFORMATION mbi;
			if (!VirtualQuery(reinterpret_cast<void*>(exception_address), &mbi, sizeof(mbi)))
			{
				printf("Failed to query access violation!\n");
				return EXCEPTION_CONTINUE_SEARCH;
			}

			if (mbi.Protect == PAGE_READWRITE)
			{
				// restore the execute permission
				DWORD old;
				if (!VirtualProtect(exception_address, mbi.RegionSize, PAGE_EXECUTE_READWRITE, reinterpret_cast<PDWORD>(1337)))
				{
					printf("Failed to restore protection\n");
				}

				if (search_for_syscall_stub(reinterpret_cast<unsigned __int64>(exception_address), ex->ContextRecord))
				{
					printf("[EXCEPTION HOOK] FOUND SYSCALL AT: %p\n", exception_address);
				}
			}

			return EXCEPTION_CONTINUE_EXECUTION;
		}

		// we don't know about this access violation
		return EXCEPTION_CONTINUE_SEARCH;
	}
#endif

	return EXCEPTION_CONTINUE_SEARCH;
}
```

`sys_monitor/page_guard_hook.h`:

```h
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once
#include "hook_type.h"
#include <Windows.h>
#include <vector>
#include <mutex>
#include <unordered_map>
#include <DbgHelp.h>
#include <Psapi.h>

namespace page_guard_hook
{
	void register_guard(unsigned __int64 address, unsigned __int32 region_size);
	void install_handler();
};


```

`sys_monitor/sig_scan.cpp`:

```cpp
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include "sig_scan.h"

unsigned __int64 sig_scan::find_signature(unsigned __int64 start, unsigned __int32 size, unsigned char* bytes, unsigned __int32 byte_size)
{
    for (unsigned __int32 i = 0; i < size - byte_size; i++)
    {
        bool found = true;
        for (int j = 0; j < byte_size; j++)
        {
            const auto start_bytes = reinterpret_cast<unsigned char*>(start);
            if (start_bytes[i + j] != bytes[j])
            {
                if (bytes[j] != '\?')
                {
                    found = false;
                }
            }       
        }

        if (found)
        {
            return start + i;
        }
    }

    return 0;
}

unsigned __int64 sig_scan::find_signature(unsigned __int64 start, unsigned char* bytes, unsigned __int32 byte_size)
{
    IMAGE_DOS_HEADER* dos = reinterpret_cast<IMAGE_DOS_HEADER*>(start);
    IMAGE_NT_HEADERS* nt = reinterpret_cast<IMAGE_NT_HEADERS*>(start + dos->e_lfanew);

    return sig_scan::find_signature(start, nt->OptionalHeader.SizeOfImage, bytes, byte_size);
}

```

`sys_monitor/sig_scan.h`:

```h
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once
#include <Windows.h>

namespace sig_scan
{
	unsigned __int64 find_signature(unsigned __int64 start, unsigned __int32 size, unsigned char* bytes, unsigned __int32 byte_size);
	unsigned __int64 find_signature(unsigned __int64 start, unsigned char* bytes, unsigned __int32 byte_size);
};


```

`sys_monitor/sys_monitor.cpp`:

```cpp
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include "sys_monitor.h"
#include "util.h"
#include "NtProtectVirtualMemory_Hook.h"
#include "NtAllocateVirtualMemory_Hook.h"
#include "page_guard_hook.h"

namespace sys_monitor
{
	// a hook is created on NtProtectVirtualMemory/NtAllocateVirtualMemory
	bool init()
	{
		// init sym
		SymSetOptions(SYMOPT_UNDNAME);
		if (!SymInitialize(reinterpret_cast<HANDLE>(-1), nullptr, TRUE)) // invade process required for UNDNAME
		{
			printf("SymInitialize failed\n");
			return false;
		}

		// install the exception handler
		page_guard_hook::install_handler();

#ifdef PAGE_GUARD_HOOK
		if (!install_page_guard_hook())
		{
			printf("Failed to install page guard hook\n");
			return false;
		}
#endif

#ifdef EXCEPTION_HOOK
		if (!install_exception_hook())
		{
			printf("Failed to install exception hook");
			return false;
		}
#endif
		return true;
	}

	bool install_exception_hook()
	{
#ifdef EXCEPTION_HOOK
		return hook_syscall(&NtProtectVirtualMemory_Hook::original_function, reinterpret_cast<unsigned __int64>(&NtProtectVirtualMemory_Hook::hook), "ntdll", "NtProtectVirtualMemory");
#endif
		return false;
	}

	bool install_page_guard_hook()
	{
#ifdef PAGE_GUARD_HOOK
		return hook_syscall(&NtAllocateVirtualMemory_Hook::original_function, reinterpret_cast<unsigned __int64>(&NtAllocateVirtualMemory_Hook::hook), "ntdll", "NtAllocateVirtualMemory");
#endif
		return false;
	}

	bool hook_syscall(unsigned __int64* original_function, unsigned __int64 hook_function, const char* dll, const char* syscall)
	{
		// mov    r10,rcx
		// mov    eax, <syscall index>
		// syscall
		// ret
		unsigned char original_instructions[] =
		{
			0x49, 0x89, 0xCA,
			0xB8, 0x00, 0x00, 0x00, 0x00,
			0x0F, 0x05,
			0xC3
		};

		// mov rax, <jmp_location>
		// jmp rax
		unsigned char hook_stub[] =
		{
			0x48, 0xB8, 0x4C, 0x9C, 0x8C, 0xDA, 0xC1, 0xFC, 0x03, 0x00,
			0xFF, 0xE0
		};

		const auto lib_dll = LoadLibraryA(dll);
		const auto passed_in_syscall = reinterpret_cast<unsigned __int64>(GetProcAddress(lib_dll, syscall));

		// setup the original stub with the correct syscall index
		*reinterpret_cast<DWORD*>(&original_instructions[4]) = util::get_syscall_index(passed_in_syscall);

		// allocate original stub
		const void* original_stub_location = VirtualAlloc(nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (!original_stub_location)
		{
			return false;
		}

		// write the original stub into the process
		memcpy(const_cast<void*>(original_stub_location), original_instructions, sizeof(original_instructions));

		// store it
		*original_function = reinterpret_cast<unsigned __int64>(original_stub_location);

		// setup the hook stub to jump to our hook
		*reinterpret_cast<unsigned __int64*>(&hook_stub[2]) = hook_function;

		// allocate the hook stub
		const void* hook_stub_location = VirtualAlloc(nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (!hook_stub_location)
		{
			return false;
		}

		// write the hook stub
		memcpy(const_cast<void*>(hook_stub_location), hook_stub, sizeof(hook_stub));

		// overwrite the function
		DWORD old;
		if (!VirtualProtect(reinterpret_cast<void*>(passed_in_syscall), 0x1000, PAGE_EXECUTE_READWRITE, &old))
		{
			return false;
		}

		// write in the hook
		memcpy(reinterpret_cast<void*>(passed_in_syscall), hook_stub_location, sizeof(hook_stub));

		// restore protections
		VirtualProtect(reinterpret_cast<void*>(passed_in_syscall), 0x1000, old, &old);

		return true;
	}
};
```

`sys_monitor/sys_monitor.h`:

```h
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once
#include "hook_type.h"
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <DbgHelp.h>
#pragma comment(lib, "dbghelp")

namespace sys_monitor
{
	bool init();
	bool install_exception_hook();
	bool install_page_guard_hook();
	bool hook_syscall(unsigned __int64* original_function, unsigned __int64 hook_function, const char* dll, const char* syscall);
}
```

`sys_monitor/sys_monitor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{48802d39-ddc8-46a0-a70b-06df7fe864db}</ProjectGuid>
    <RootNamespace>sysmonitor</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="NtAllocateVirtualMemory_Hook.cpp" />
    <ClCompile Include="NtProtectVirtualMemory_Hook.cpp" />
    <ClCompile Include="page_guard_hook.cpp" />
    <ClCompile Include="sig_scan.cpp" />
    <ClCompile Include="sys_monitor.cpp" />
    <ClCompile Include="text_section_code.cpp" />
    <ClCompile Include="util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hook_type.h" />
    <ClInclude Include="NtAllocateVirtualMemory_Hook.h" />
    <ClInclude Include="NtProtectVirtualMemory_Hook.h" />
    <ClInclude Include="page_guard_hook.h" />
    <ClInclude Include="sig_scan.h" />
    <ClInclude Include="syscall_spoofer.h" />
    <ClInclude Include="sys_monitor.h" />
    <ClInclude Include="text_section_code.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`sys_monitor/sys_monitor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="sys_monitor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NtProtectVirtualMemory_Hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="page_guard_hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="sig_scan.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="text_section_code.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NtAllocateVirtualMemory_Hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="sys_monitor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NtProtectVirtualMemory_Hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="page_guard_hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="sig_scan.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="syscall_spoofer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="text_section_code.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NtAllocateVirtualMemory_Hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hook_type.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`sys_monitor/sys_monitor.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`sys_monitor/syscall_spoofer.h`:

```h
#pragma once
#include <Windows.h>
#include "util.h"

#include "text_section_code.h"

#define _BYTE  __int8
#define _WORD  __int16
#define _DWORD int
#define _QWORD __int64


namespace syscall_spoofer
{
	__forceinline __int64 get_syscall_instruction_address(unsigned __int64 func)
	{
		const auto distance = 12288LL;
	LABEL_1798:
		const auto starting_distance = __rdtsc() % (distance - 3);
		auto ntdll_exported_func = (char*)func;

		__int64 syscall_instruction_spot = 0;
		for (syscall_instruction_spot = 0LL; ; ++syscall_instruction_spot)
		{
			if (starting_distance + syscall_instruction_spot >= distance)
				goto LABEL_1798;
			if (ntdll_exported_func[syscall_instruction_spot + 1 + starting_distance] == 5
				&& (unsigned __int8)ntdll_exported_func[syscall_instruction_spot + 2 + starting_distance] == 195
				&& ntdll_exported_func[syscall_instruction_spot + starting_distance] == 15)
			{
				break;
			}
		}

		return (unsigned __int64)&ntdll_exported_func[syscall_instruction_spot + starting_distance];
	}

	__forceinline void* generate_syscall_stub_text(unsigned __int64 syscall_instrucion, const int syscall_index, void** base, int* size)
	{
		if (base == nullptr || size == nullptr)
		{
			return nullptr;
		}

		*size = sizeof(large_code_block);

		auto offset = rand() % (*size - 0x40);

		volatile __int64 syscall_stub_memory = (__int64)large_code_block;

		const auto func_NtProtectVirtualMemory = reinterpret_cast<NTSTATUS(*)(HANDLE ProcessHandle, PVOID * BaseAddress, PSIZE_T RegionSize, ULONG NewProtection, PULONG OldProtection)>(GetProcAddress(LoadLibraryA("ntdll"), "NtProtectVirtualMemory"));
		auto region_size = sizeof(large_code_block);
		ULONG old_protection;
		func_NtProtectVirtualMemory(reinterpret_cast<HANDLE>(-1), (PVOID*)(&syscall_stub_memory), reinterpret_cast<PSIZE_T>(&region_size), PAGE_EXECUTE_READWRITE, &old_protection);

		*(_QWORD*)(syscall_stub_memory + offset + 28LL) = (__int64)syscall_instrucion;
		*(_QWORD*)(syscall_stub_memory + offset + 20LL) = 0x63B4B73DD1E509A9LL;
		*(_QWORD*)(syscall_stub_memory + offset + 20LL) ^= 0x7FA6B73DD1E72C56uLL;
		*(_DWORD*)(syscall_stub_memory + offset + 12LL) = syscall_index;
		*(_DWORD*)(syscall_stub_memory + offset + 8LL) = -997864955;
		*(_DWORD*)(syscall_stub_memory + offset + 8LL) ^= 0x7CEB6A07u;
		*(_DWORD*)(syscall_stub_memory + offset) = -1006268688;
		*(_DWORD*)(syscall_stub_memory + offset) ^= 0x62ADC0BFu;
		*(_DWORD*)(syscall_stub_memory + offset + 4LL) = -1637542171;
		*(_DWORD*)(syscall_stub_memory + offset + 4LL) ^= 0x75B49DA9u;
		*(_DWORD*)(syscall_stub_memory + offset + 16LL) = 109211239;
		*(_DWORD*)(syscall_stub_memory + offset + 16LL) ^= 0xBBCA6C8C;

		*base = (void*)syscall_stub_memory;
		return (void*)(syscall_stub_memory + offset + 4LL);
	}

	__forceinline void* generate_syscall_stub_alloc(unsigned __int64 syscall_instrucion, const int syscall_index, void** base, int* size)
	{
		if (base == nullptr || size == nullptr)
		{
			return nullptr;
		}

		*size = 0x4096;

		auto offset = rand() % (*size - 0x40);

		volatile __int64 syscall_stub_memory = (__int64)VirtualAlloc(nullptr, 0x4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

		*(_QWORD*)(syscall_stub_memory + offset + 28LL) = (__int64)syscall_instrucion;
		*(_QWORD*)(syscall_stub_memory + offset + 20LL) = 0x63B4B73DD1E509A9LL;
		*(_QWORD*)(syscall_stub_memory + offset + 20LL) ^= 0x7FA6B73DD1E72C56uLL;
		*(_DWORD*)(syscall_stub_memory + offset + 12LL) = syscall_index;
		*(_DWORD*)(syscall_stub_memory + offset + 8LL) = -997864955;
		*(_DWORD*)(syscall_stub_memory + offset + 8LL) ^= 0x7CEB6A07u;
		*(_DWORD*)(syscall_stub_memory + offset) = -1006268688;
		*(_DWORD*)(syscall_stub_memory + offset) ^= 0x62ADC0BFu;
		*(_DWORD*)(syscall_stub_memory + offset + 4LL) = -1637542171;
		*(_DWORD*)(syscall_stub_memory + offset + 4LL) ^= 0x75B49DA9u;
		*(_DWORD*)(syscall_stub_memory + offset + 16LL) = 109211239;
		*(_DWORD*)(syscall_stub_memory + offset + 16LL) ^= 0xBBCA6C8C;

		*base = (void*)syscall_stub_memory;
		return (void*)(syscall_stub_memory + offset + 4LL);
	}

	__forceinline void free_syscall_stub(void* base, int size)
	{
		memset(base, 0, size);
		VirtualFree(base, 0, MEM_RELEASE);
	} 

	template<typename... Params>
	__forceinline NTSTATUS spoof_syscall(unsigned __int64 exported_ntdll_function, unsigned __int64 function_to_call, Params... params)
	{
		void* base_address_of_stub = nullptr;
		int stub_size = 0;

		const auto nt_syscall_instruction = get_syscall_instruction_address(exported_ntdll_function);
		const auto syscall_index = util::get_syscall_index(function_to_call);
		void* stub = nullptr; 
		NTSTATUS result = 0;

		// first use the allocated .text section
		stub = generate_syscall_stub_text(nt_syscall_instruction, syscall_index, &base_address_of_stub, &stub_size);
		result = reinterpret_cast<NTSTATUS(__fastcall*)(Params...)>(stub)(params...);

		// then just for testing purposes we will allocate our own memory
		stub = generate_syscall_stub_alloc(nt_syscall_instruction, syscall_index, &base_address_of_stub, &stub_size);
		result = reinterpret_cast<NTSTATUS(__fastcall*)(Params...)>(stub)(params...);
		
		free_syscall_stub(base_address_of_stub, stub_size);

		return result;
	}

};


```

`sys_monitor/text_section_code.cpp`:

```cpp
#pragma code_seg(".text")
__declspec(allocate(".text")) unsigned char large_code_block[20480];
```

`sys_monitor/text_section_code.h`:

```h
#pragma once

extern unsigned char large_code_block[20480];
```

`sys_monitor/util.cpp`:

```cpp
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include "util.h"

unsigned __int32 util::get_syscall_index(unsigned __int64 syscall_func)
{
    return *(unsigned __int32*)&reinterpret_cast<char*>(syscall_func)[4];

}

```

`sys_monitor/util.h`:

```h
/*
   Copyright 2025 ssnob

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once
#include <Windows.h>

namespace util
{
	unsigned __int32 get_syscall_index(unsigned __int64 syscall_func);
};


```