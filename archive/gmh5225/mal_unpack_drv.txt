Project Path: arc_gmh5225_mal_unpack_drv_1dsakgeg

Source Tree:

```txt
arc_gmh5225_mal_unpack_drv_1dsakgeg
├── LICENSE
├── MalUnpackCompanion
│   ├── MalUnpackCompanion.filters
│   ├── MalUnpackCompanion.inf
│   ├── MalUnpackCompanion.rc
│   ├── MalUnpackCompanion.vcxproj
│   ├── common.h
│   ├── data_manager.cpp
│   ├── data_manager.h
│   ├── data_structs.cpp
│   ├── data_structs.h
│   ├── file_util.cpp
│   ├── file_util.h
│   ├── filters.cpp
│   ├── filters.h
│   ├── fs_filters.cpp
│   ├── fs_filters.h
│   ├── main.cpp
│   ├── main.h
│   ├── process_data_struct.cpp
│   ├── process_data_struct.h
│   ├── process_util.cpp
│   ├── process_util.h
│   ├── undoc_api.h
│   ├── util.h
│   └── version.h
└── README.md

```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2021, hasherezade
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`MalUnpackCompanion/MalUnpackCompanion.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="data_structs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="filters.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="data_structs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="filters.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="undoc_api.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`MalUnpackCompanion/MalUnpackCompanion.inf`:

```inf
;;;
;;; MalUnpackCompanion
;;;

[Version]
Signature   = "$Windows NT$"
Class       = "ActivityMonitor"                         ;This is determined by the work this filter driver does
ClassGuid   = {b86dff51-a31e-4bac-b3cf-e8cfe75c9fc2}    ;This value is determined by the Class
Provider    = %ManufacturerName%
DriverVer   = 
CatalogFile = MalUnpackCompanion.cat
PnpLockdown=1

[DestinationDirs]
DefaultDestDir          = 12
MiniFilter.DriverFiles  = 12            ;%windir%\system32\drivers

;;
;; Default install sections
;;

[DefaultInstall]
OptionDesc          = %ServiceDescription%
CopyFiles           = MiniFilter.DriverFiles


[DefaultInstall.Services]
AddService          = %ServiceName%,,MiniFilter.Service

;;
;; Default uninstall sections
;;

[DefaultUninstall]
DelFiles   = MiniFilter.DriverFiles

[DefaultUninstall.Services]
DelService = %ServiceName%,0x200      ;Ensure service is stopped before deleting

;
; Services Section
;

[MiniFilter.Service]
DisplayName      = %ServiceName%
Description      = %ServiceDescription%
ServiceBinary    = %12%\%DriverName%.sys        ;%windir%\system32\drivers\
Dependencies     = "FltMgr"
ServiceType      = 2                            ;SERVICE_FILE_SYSTEM_DRIVER
StartType        = 3                            ;SERVICE_DEMAND_START
ErrorControl     = 1                            ;SERVICE_ERROR_NORMAL
LoadOrderGroup = "FSFilter Activity Monitor"
AddReg           = MiniFilter.AddRegistry

;
; Registry Modifications
;

[MiniFilter.AddRegistry]
HKR,,"DebugFlags",0x00010001 ,0x0
HKR,,"SupportedFeatures",0x00010001,0x3
HKR,"Instances","DefaultInstance",0x00000000,%DefaultInstance%
HKR,"Instances\"%Instance1.Name%,"Altitude",0x00000000,%Instance1.Altitude%
HKR,"Instances\"%Instance1.Name%,"Flags",0x00010001,%Instance1.Flags%

;
; Copy Files
;

[MiniFilter.DriverFiles]
%DriverName%.sys

[SourceDisksFiles]
MalUnpackCompanion.sys = 1,,

[SourceDisksNames]
1 = %DiskId1%,,,

;;
;; String Section
;;

[Strings]
; TODO - Add your manufacturer
ManufacturerName        = "Hasherezade"
ServiceDescription      = "MalUnpackCompanion Mini-Filter Driver"
ServiceName             = "MalUnpackCompanion"
DriverName              = "MalUnpackCompanion"
DiskId1                 = "MalUnpackCompanion Device Installation Disk"

;Instances specific information.
DefaultInstance         = "MalUnpackCompanion Instance"
Instance1.Name          = "MalUnpackCompanion Instance"
Instance1.Altitude       = "361337"
Instance1.Flags         = 0x0              ; Allow all attachments

```

`MalUnpackCompanion/MalUnpackCompanion.rc`:

```rc
#include <windows.h>

#include <ntverp.h>
#include "version.h"

#define VER_COMPANYNAME_STR "Hashereware"

#define VER_FILETYPE    VFT_DRV
#define VER_FILESUBTYPE VFT2_DRV_SYSTEM
#define VER_FILEDESCRIPTION_STR     "MalUnpack Companion Driver"
#define VER_INTERNALNAME_STR        "MalUnpackCompaion.sys"

#include "common.ver"

```

`MalUnpackCompanion/MalUnpackCompanion.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A9A58119-D1A4-4186-86B0-8F7714BC657A}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>MalUnpackCompanion</RootNamespace>
    <ProjectName>MalUnpackCompanion</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>fltmgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="data_manager.cpp" />
    <ClCompile Include="file_util.cpp" />
    <ClCompile Include="filters.cpp" />
    <ClCompile Include="data_structs.cpp" />
    <ClCompile Include="fs_filters.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="process_data_struct.cpp" />
    <ClCompile Include="process_util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="data_manager.h" />
    <ClInclude Include="file_util.h" />
    <ClInclude Include="filters.h" />
    <ClInclude Include="common.h" />
    <ClInclude Include="data_structs.h" />
    <ClInclude Include="fs_filters.h" />
    <ClInclude Include="main.h" />
    <ClInclude Include="process_data_struct.h" />
    <ClInclude Include="process_util.h" />
    <ClInclude Include="undoc_api.h" />
    <ClInclude Include="util.h" />
    <ClInclude Include="version.h" />
  </ItemGroup>
  <ItemGroup>
    <Inf Include="MalUnpackCompanion.inf" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="MalUnpackCompanion.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`MalUnpackCompanion/common.h`:

```h
#pragma once

#define DRIVER_PREFIX "MAL_UNP_DRV: "

#define MY_DEVICE_NAME L"MalUnpackCompanion"

#define MY_DEVICE L"\\Device\\MalUnpackCompanion"
#define MY_DRIVER_LINK L"\\??\\MalUnpackCompanion"

#define RENAMED_EXTENSION L".unsafe"

typedef enum {
	NORESP_NO_RESTRICTION = 0,
	NORESP_DROPPED_FILES = 1,
	NORESP_ALL_FILES = 2,
	COUNT_NORESP
} t_noresp;


struct ProcessDataBasic {
	ULONG Pid;
};

struct ProcessDataEx_v1 {
	ULONG Pid;
	LONGLONG fileId;
};

struct ProcessDataEx_v2 {
	ULONG Pid;
	LONGLONG fileId;
	t_noresp noresp; //respawn protection level
};

struct ProcessFileData {
	ULONG Pid;
	WCHAR FileName[1]; //dynamic length
};

typedef ProcessDataEx_v2 ProcessDataEx;


#define MUNPACK_COMPANION_DEVICE 0x8000

#define IOCTL_MUNPACK_COMPANION_VERSION CTL_CODE(MUNPACK_COMPANION_DEVICE, \
	0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_MUNPACK_COMPANION_ADD_TO_WATCHED CTL_CODE(MUNPACK_COMPANION_DEVICE, \
	0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_MUNPACK_COMPANION_TERMINATE_WATCHED CTL_CODE(MUNPACK_COMPANION_DEVICE, \
	0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_MUNPACK_COMPANION_LIST_PROCESSES CTL_CODE(MUNPACK_COMPANION_DEVICE, \
	0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_MUNPACK_COMPANION_LIST_FILES CTL_CODE(MUNPACK_COMPANION_DEVICE, \
	0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_MUNPACK_COMPANION_REMOVE_FROM_WATCHED CTL_CODE(MUNPACK_COMPANION_DEVICE, \
	0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_MUNPACK_COMPANION_COUNT_NODES CTL_CODE(MUNPACK_COMPANION_DEVICE, \
	0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_MUNPACK_COMPANION_DELETE_WATCHED_FILE CTL_CODE(MUNPACK_COMPANION_DEVICE, \
	0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)

```

`MalUnpackCompanion/data_manager.cpp`:

```cpp
#include "data_manager.h"
#include "common.h"
#include "process_data_struct.h"
#include "process_util.h"

namespace Data {
	ProcessNodesList g_ProcessNode;
};

bool Data::AllocGlobals()
{
	g_ProcessNode.init();
	if (!g_ProcessNode.initItems()) {
		DbgPrint(DRIVER_PREFIX ": Failed to initialize data items!\n");
		return false;
	}
	return true;
}

void Data::FreeGlobals()
{
	g_ProcessNode.destroy();
}


bool Data::ContainsFile(LONGLONG fileId)
{
	return (g_ProcessNode.GetFileOwner(fileId) != 0);
}

ULONG Data::GetFileOwner(LONGLONG fileId)
{
	return g_ProcessNode.GetFileOwner(fileId);
}

ULONG Data::GetProcessOwner(ULONG pid)
{
	return g_ProcessNode.GetProcessOwner(pid);
}

bool Data::ContainsProcess(ULONG pid1)
{
	return g_ProcessNode.ContainsProcess(pid1);
}

bool Data::AreSameFamily(ULONG pid1, ULONG pid2)
{
	return g_ProcessNode.AreSameFamily(pid1, pid2);
}


bool Data::IsProcessInFileOwners(ULONG pid, LONGLONG fileId)
{
	return g_ProcessNode.IsProcessInFileOwners(pid, fileId);
}

bool Data::CanAddFile(ULONG parentPid)
{
	return g_ProcessNode.CanAddFile(parentPid);
}

t_add_status Data::AddFile(LONGLONG fileId, ULONG parentPid)
{
	return g_ProcessNode.AddFile(fileId, parentPid);
}

t_add_status Data::AddProcess(ULONG pid, ULONG parentPid)
{
	t_add_status status = g_ProcessNode.AddProcess(pid, parentPid);
	if (status == ADD_LIMIT_EXHAUSTED) {
		DbgPrint(DRIVER_PREFIX __FUNCTION__ ": Cannot add the process: %d, terminating...\n", pid);
		ProcessUtil::TerminateProcess(pid);
	}
	return status;
}

t_add_status Data::AddProcessNode(ULONG pid, LONGLONG imgFileId, t_noresp respawnProtect)
{
	t_add_status status = g_ProcessNode.AddProcessNode(pid, imgFileId, respawnProtect);
	if (status == ADD_LIMIT_EXHAUSTED) {
		DbgPrint(DRIVER_PREFIX __FUNCTION__ ": Cannot add the process: %d, terminating...\n", pid);
		ProcessUtil::TerminateProcess(pid);
	}
	return status;
}

t_add_status Data::AddProcessToFileOwner(ULONG PID, LONGLONG fileId)
{
	t_add_status status = g_ProcessNode.AddProcessToFileOwner(PID, fileId);
	if (status == ADD_LIMIT_EXHAUSTED) {
		DbgPrint(DRIVER_PREFIX __FUNCTION__ ": Cannot add the process: %d, terminating...\n", PID);
		ProcessUtil::TerminateProcess(PID);
	}
	return status;
}

int Data::CountProcessTrees()
{
	return g_ProcessNode.CountNodes();
}

bool Data::DeleteProcess(ULONG pid)
{
	bool isOk = g_ProcessNode.DeleteProcess(pid);
	DbgPrint(DRIVER_PREFIX __FUNCTION__ ": Watched nodes: %d\n", g_ProcessNode.CountNodes());
	return isOk;
}

bool Data::DeleteFile(LONGLONG fileId)
{
	bool isOk = g_ProcessNode.DeleteFile(fileId);
	DbgPrint(DRIVER_PREFIX __FUNCTION__ ": Watched nodes: %d\n", g_ProcessNode.CountNodes());
	return isOk;
}

size_t Data::CopyProcessList(ULONG parentPid, void* data, size_t outBufSize)
{
	return g_ProcessNode.CopyProcessList(parentPid, data, outBufSize);
}

size_t Data::CopyFilesList(ULONG parentPid, void* data, size_t outBufSize)
{
	return g_ProcessNode.CopyFilesList(parentPid, data, outBufSize);
}

NTSTATUS Data::WaitForProcessDeletion(ULONG pid, PLARGE_INTEGER checkInterval)
{
	return g_ProcessNode.WaitForProcessDeletion(pid, checkInterval);
}

```

`MalUnpackCompanion/data_manager.h`:

```h
#pragma once

#include "main.h"
#include "data_structs.h"


namespace Data {
    bool AllocGlobals();

    void FreeGlobals();

    bool ContainsFile(LONGLONG fileId);

    ULONG GetFileOwner(LONGLONG fileId);

    ULONG  GetProcessOwner(ULONG pid);

    bool ContainsProcess(ULONG pid);

    bool AreSameFamily(ULONG pid1, ULONG pid2);

    t_add_status AddFile(LONGLONG fileId, ULONG parentPid);

    bool CanAddFile(ULONG parentPid);

    t_add_status AddProcess(ULONG pid, ULONG parentPid);

    t_add_status AddProcessNode(ULONG pid, LONGLONG imgFileId, t_noresp respawnProtect);

    t_add_status AddProcessToFileOwner(ULONG PID, LONGLONG fileId);

    bool IsProcessInFileOwners(ULONG pid1, LONGLONG fileId);

    int CountProcessTrees();

    bool DeleteProcess(ULONG pid);

    bool DeleteFile(LONGLONG fileId);

    size_t CopyProcessList(ULONG rootPid, void* data, size_t outBufSize);

    size_t CopyFilesList(ULONG rootPid, void* data, size_t outBufSize);

    NTSTATUS WaitForProcessDeletion(ULONG pid, PLARGE_INTEGER checkInterval);
};

```

`MalUnpackCompanion/data_structs.cpp`:

```cpp
#include "data_structs.h"


void FastMutex::Init() {
	ExInitializeFastMutex(&_mutex);
}

void FastMutex::Lock() {
	ExAcquireFastMutex(&_mutex);
}

void FastMutex::Unlock() {
	ExReleaseFastMutex(&_mutex);
}

//---

void Event::Init()
{
	KeInitializeEvent(&_event, NotificationEvent, FALSE);
}

NTSTATUS Event::WaitForEventSet(PLARGE_INTEGER timeout)
{
	return KeWaitForSingleObject(&_event, Executive, KernelMode, TRUE, timeout);
}

LONG Event::SetEvent()
{
	return KeSetEvent(&_event, 0, FALSE);
}

LONG Event::ResetEvent()
{
	return KeResetEvent(&_event);
}

```

`MalUnpackCompanion/data_structs.h`:

```h
#pragma once

#include <ntddk.h>

#define DRIVER_TAG 'nUM!'
#define INVALID_INDEX (-1)
#define MAX_ITEMS 1024

// Mutex locker:

template<typename TLock>
struct AutoLock {
	AutoLock(TLock& lock) : _lock(lock) {
		_lock.Lock();
	}

	~AutoLock() {
		_lock.Unlock();
	}

private:
	TLock& _lock;
};

// Mutex:

class FastMutex {
public:
	void Init();

	void Lock();
	void Unlock();

private:
	FAST_MUTEX _mutex;
};

//Event 

class Event {
public:
	void Init();

	NTSTATUS WaitForEventSet(PLARGE_INTEGER timeout);
	LONG SetEvent();
	LONG ResetEvent();

private:
	KEVENT _event;
};

///
template<typename T>
T* AllocBuffer(size_t itemsCount = 1, bool clear = true)
{
	if (itemsCount == 0) return nullptr;

	const size_t size = itemsCount * sizeof(T);
	T* buf = (T*)ExAllocatePoolWithTag(PagedPool, size, DRIVER_TAG);
	if (clear) {
		::memset(buf, 0, size);
	}
	return buf;
}

template<typename T>
void FreeBuffer(T* Items, size_t MaxItemCount = 1, bool clear = false)
{
	if (Items == nullptr) return;

	if (MaxItemCount && clear) {
		const size_t size = MaxItemCount * sizeof(T);
		::memset(Items, 0, size);
	}
	ExFreePool(Items);
}

///
typedef enum {
	ADD_OK = 0,
	ADD_UNINITIALIZED,
	ADD_ALREADY_EXIST,
	ADD_LIMIT_EXHAUSTED,
	ADD_INVALID_ITEM,
	ADD_NO_PARENT,
	ADD_FORBIDDEN,
	ADD_STATES_COUNT
} t_add_status;


template<typename T>
struct ItemsList
{
public:
	void init()
	{
		Mutex.Init();
		ItemCount = 0;
		MaxItemCount = 0;
		Items = NULL;
	}

	bool initItems(int maxNum = MAX_ITEMS)
	{
		return _initItems(maxNum);
	}

	bool destroy()
	{
		AutoLock<FastMutex> lock(Mutex);
		return _destroyItems();
	}

	size_t copyItems(void* outBuf, size_t outBufSize)
	{
		if (!outBuf || outBufSize < sizeof(T)) {
			return 0;
		}

		AutoLock<FastMutex> lock(Mutex);
		if (!Items || !ItemCount) {
			return 0;
		}
		size_t maxItemsToCopy = outBufSize / sizeof(T);
		size_t itemsToCopy = (maxItemsToCopy > (size_t)ItemCount) ? ItemCount : maxItemsToCopy;

		const size_t size = itemsToCopy * sizeof(T);
		::memset(outBuf, 0, outBufSize);
		::memcpy(outBuf, Items, size);
		return itemsToCopy;
	}

	int countItems()
	{
		AutoLock<FastMutex> lock(Mutex);
		return ItemCount;
	}

	bool canAddItem()
	{
		AutoLock<FastMutex> lock(Mutex);
		if (Items == NULL) {
			if (!_initItems()) {
				return false;
			}
		}
		if (ItemCount >= MaxItemCount) {
			return false;
		}
		return true;
	}

	t_add_status addItem(T it)
	{
		AutoLock<FastMutex> lock(Mutex);
		if (Items == NULL) {
			if (!_initItems()) {
				return ADD_UNINITIALIZED;
			}
		}
		if (ItemCount >= MaxItemCount) {
			return ADD_LIMIT_EXHAUSTED;
		}
		if (_getItemIndex(it) != INVALID_INDEX) {
			return ADD_ALREADY_EXIST;
		}
		if (_addItemSorted(it)) {
			return ADD_OK;
		}
		return ADD_LIMIT_EXHAUSTED;
	}

	bool containsItem(T it)
	{
		AutoLock<FastMutex> lock(Mutex);
		int index = _getItemIndex(it);
		if (index != INVALID_INDEX) {
			return true;
		}
		return false;
	}

	bool deleteItem(T it)
	{
		AutoLock<FastMutex> lock(Mutex);
		int index = _getItemIndex(it);
		if (index == INVALID_INDEX) {
			return false;
		}
		if (!_shiftItemsLeft(index)) {
			return false;
		}
		if (ItemCount == 0) {
			_destroyItems();
		}
		return true;
	}

private:
	T* Items;
	int ItemCount;
	int MaxItemCount;
	FastMutex Mutex;

	bool _initItems(int maxNum = MAX_ITEMS)
	{
		if (Items) {
			return true;
		}
		ItemCount = 0;
		Items = AllocBuffer<T>(maxNum + 1);
		if (Items != NULL) {
			MaxItemCount = maxNum;
			return true;
		}
		return false;
	}

	bool _destroyItems()
	{
		if (!Items) {
			return false;
		}
		FreeBuffer<T>(Items, MaxItemCount);
		ItemCount = 0;
		MaxItemCount = 0;
		Items = NULL;
		return true;
	}

	int _getItemIndex(T it)
	{
		if (!Items || ItemCount == 0) {
			return INVALID_INDEX;
		}
		int start = 0;
		int stop = ItemCount;
		while (start < stop) {
			int mIndx = (start + stop) / 2;
			if (Items[mIndx] == it) {
				return mIndx;
			}
			if (Items[mIndx] < it) {
				start = mIndx + 1;
			}
			else if (Items[mIndx] > it) {
				stop = mIndx;
			}
		}
		return INVALID_INDEX;
	}

	int _findFirstGreater(T it, int startIndx = 0)
	{
		if (ItemCount == 0) {
			return INVALID_INDEX;
		}
		if (startIndx == INVALID_INDEX) {
			startIndx = 0;
		}
		for (int i = startIndx; i < ItemCount; i++)
		{
			if (Items[i] > it) {
				return i;
			}
		}
		return ItemCount;
	}

	bool _shiftItemsRight(int startIndx)
	{
		if (startIndx == INVALID_INDEX) {
			return false;
		}
		if (ItemCount >= MaxItemCount) {
			return false;
		}
		for (int i = ItemCount; i > startIndx; i--) {
			Items[i] = Items[i - 1];
		}
		ItemCount++;
		return true;
	}

	bool _shiftItemsLeft(int startIndx)
	{
		if (startIndx == INVALID_INDEX) {
			return false;
		}
		for (int i = startIndx + 1; i < ItemCount; i++) {
			Items[i - 1] = Items[i];
		}
		Items[ItemCount - 1] = 0;
		ItemCount--;
		return true;
	}

	bool _addItemSorted(T it)
	{
		int itIndx = _getItemIndex(it);
		int indx = _findFirstGreater(it, itIndx);
		if (indx == INVALID_INDEX) {
			Items[ItemCount++] = it;
			return true;
		}
		if (!_shiftItemsRight(indx)) {
			return false;
		}
		Items[indx] = it;
		return true;
	}
};

//---


```

`MalUnpackCompanion/file_util.cpp`:

```cpp
#include "file_util.h"
#include "common.h"

#include <fltKernel.h>

bool FileUtil::RetrieveImagePath(PIMAGE_INFO ImageInfo, WCHAR FileName[FileUtil::MAX_PATH_LEN])
{
    if (KeGetCurrentIrql() != PASSIVE_LEVEL) {
        return false;
    }
    if (!ImageInfo || !ImageInfo->ExtendedInfoPresent) {
        return false;
    }
    PIMAGE_INFO_EX extendedInfo = NULL;
    extendedInfo = CONTAINING_RECORD(ImageInfo, IMAGE_INFO_EX, ImageInfo);
    if (!extendedInfo || !extendedInfo->FileObject) {
        return false;
    }
    PFLT_FILE_NAME_INFORMATION fileNameInformation = NULL;
    NTSTATUS status = FltGetFileNameInformationUnsafe(extendedInfo->FileObject, NULL, FLT_FILE_NAME_NORMALIZED, &fileNameInformation);
    if (!NT_SUCCESS(status)) {
        return false;
    }
    bool isOk = false;
    const size_t len = fileNameInformation->Name.Length < MAX_PATH_LEN ? fileNameInformation->Name.Length : MAX_PATH_LEN;
    if (len) {
        ::memcpy(FileName, fileNameInformation->Name.Buffer, len);
        isOk = true;
    }
    FltReleaseFileNameInformation(fileNameInformation);
    return isOk;
}

NTSTATUS FileUtil::FetchFileId(HANDLE hFile, LONGLONG &FileId)
{
    FileId = FILE_INVALID_FILE_ID;

    if (!hFile) {
        return STATUS_INVALID_PARAMETER;
    }
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    __try
    {
        IO_STATUS_BLOCK ioStatusBlock;
        FILE_INTERNAL_INFORMATION fileIdInfo;
        status = ZwQueryInformationFile(
            hFile,
            &ioStatusBlock,
            &fileIdInfo,
            sizeof(fileIdInfo),
            FileInternalInformation
        );
        if (NT_SUCCESS(status)) {
            FileId = fileIdInfo.IndexNumber.QuadPart;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_UNSUCCESSFUL;
        DbgPrint(DRIVER_PREFIX __FUNCTION__" [!!!] Exception thrown\n");
    }
    return status;
}

NTSTATUS FileUtil::FetchFileSize(HANDLE hFile, LONGLONG& FileSize)
{
    FileSize = INVALID_FILE_SIZE;

    if (!hFile) {
        return STATUS_INVALID_PARAMETER;
    }
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    __try
    {
        IO_STATUS_BLOCK ioStatusBlock = { 0 };
        FILE_STANDARD_INFORMATION fileInfo = { 0 };
        status = ZwQueryInformationFile(
            hFile,
            &ioStatusBlock,
            &fileInfo,
            sizeof(fileInfo),
            FileStandardInformation
        );
        if (NT_SUCCESS(status) && 
            NT_SUCCESS(ioStatusBlock.Status) && 
            !fileInfo.Directory) 
        {
            FileSize = fileInfo.EndOfFile.QuadPart;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        DbgPrint(DRIVER_PREFIX __FUNCTION__" [!!!] Exception thrown\n");
    }
    return status;
}


LONGLONG FileUtil::GetFileIdByPath(PUNICODE_STRING FileName)
{
    if (!FileName || !FileName->Buffer || !FileName->Length) {
        return (FILE_INVALID_FILE_ID);
    }
    if (KeGetCurrentIrql() != PASSIVE_LEVEL) {
        return (FILE_INVALID_FILE_ID);
    }
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, FileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
    LONGLONG FileId = FILE_INVALID_FILE_ID;
    __try
    {
        HANDLE hFile = NULL;
        IO_STATUS_BLOCK ioStatusBlock;
        NTSTATUS status = ZwCreateFile(&hFile, 
            SYNCHRONIZE | FILE_READ_ATTRIBUTES,
            &objAttr, &ioStatusBlock, 
            NULL, 
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ, FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
        );
        if (NT_SUCCESS(status)) {
            FetchFileId(hFile, FileId);
            ZwClose(hFile);
        }
        else {
            DbgPrint(DRIVER_PREFIX "[!!!] Failed to open file by NAME: %S, status: %X\n", FileName->Buffer, status);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        FileId = FILE_INVALID_FILE_ID;
    }
    return FileId;
}

NTSTATUS FileUtil::RequestFileDeletion(PUNICODE_STRING FileName)
{
    if (!FileName || !FileName->Buffer || !FileName->Length) {
        return STATUS_INVALID_PARAMETER;
    }
    if (KeGetCurrentIrql() != PASSIVE_LEVEL) {
        return STATUS_UNSUCCESSFUL;
    }
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, FileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
    __try
    {
        HANDLE hFile = NULL;
        IO_STATUS_BLOCK ioStatusBlock;
        status = ZwCreateFile(&hFile,
            SYNCHRONIZE | DELETE,
            &objAttr, &ioStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_DELETE, FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT | FILE_DELETE_ON_CLOSE,
            NULL,
            0
        );
        if (NT_SUCCESS(status)) {
            FILE_DISPOSITION_INFORMATION disposition = { TRUE };
            status = ZwSetInformationFile(hFile, &ioStatusBlock, &disposition, sizeof(FILE_DISPOSITION_INFORMATION), FileDispositionInformation);
            if (NT_SUCCESS(status)) {
                status = ioStatusBlock.Status;
            }
            ZwClose(hFile);
        }
        else {
            DbgPrint(DRIVER_PREFIX "[!!!] Failed to set the file for deletion, status %X\n", status);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
    }
    return status;
}


```

`MalUnpackCompanion/file_util.h`:

```h
#pragma once

#include "undoc_api.h"

#define INVALID_FILE_SIZE (-1)

namespace FileUtil {

    const USHORT MAX_PATH_LEN = 1024;

    bool RetrieveImagePath(PIMAGE_INFO ImageInfo, WCHAR FileName[MAX_PATH_LEN]);

    NTSTATUS FetchFileId(HANDLE hFile, LONGLONG& FileId);

    NTSTATUS FetchFileSize(HANDLE hFile, LONGLONG& FileSize);

    LONGLONG GetFileIdByPath(PUNICODE_STRING FileName);

    NTSTATUS RequestFileDeletion(PUNICODE_STRING FileName);
};


```

`MalUnpackCompanion/filters.cpp`:

```cpp
#include "filters.h"

#include "common.h"
#include "process_util.h"

#define PROCESS_VM_OPERATION (0x0008)
#define PROCESS_VM_WRITE (0x0020)
#define PROCESS_CREATE_THREAD (0x0002)


OB_PREOP_CALLBACK_STATUS OnPreOpenProcess(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION Info)
{
	UNREFERENCED_PARAMETER(RegistrationContext);
	if (Info->KernelHandle) {
		return OB_PREOP_SUCCESS; //do not interfere in kernel mode operations
	}
	const ULONG sourcePID = HandleToULong(PsGetCurrentProcessId()); //the PID of the process performing the operation
	if (!Data::ContainsProcess(sourcePID)) {
		return OB_PREOP_SUCCESS; //do not interfere
	}

	PEPROCESS targetProcess = (PEPROCESS)Info->Object;
	const ULONG targetPid = HandleToULong(PsGetProcessId(targetProcess));

	const bool isMyProcess = Data::AreSameFamily(targetPid, sourcePID) 
		|| Data::AreSameFamily(ProcessUtil::GetProcessParentPID(targetProcess), sourcePID) ;

	if (isMyProcess) {
		DbgPrint(DRIVER_PREFIX "[%d] Allowing opening handle to a child: [%d]\n", sourcePID, targetPid);
		return OB_PREOP_SUCCESS;
	}
	///
	bool isDenied = false;
	// writing operations:
	{
		if ((Info->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_VM_WRITE)
			|| (Info->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_VM_OPERATION))
		{
			DbgPrint(DRIVER_PREFIX "[%d] trying to open process for writing: [%d]\n", sourcePID, targetPid);
			// disallow the operations:
			if (!isMyProcess) {
				isDenied = true;
				Info->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_OPERATION;
				Info->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_WRITE;
			}
		}

		if ((Info->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_VM_WRITE)
			|| (Info->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_VM_OPERATION))
		{
			DbgPrint(DRIVER_PREFIX "[%d] trying to duplicate handle of the process for writing: [%d]\n", sourcePID, targetPid);
			// disallow the operations:
			if (!isMyProcess) {
				isDenied = true;
				Info->Parameters->DuplicateHandleInformation.DesiredAccess &= ~PROCESS_VM_OPERATION;
				Info->Parameters->DuplicateHandleInformation.DesiredAccess &= ~PROCESS_VM_WRITE;
			}
		}
	}

	// create remote thread:
	{
		if (Info->Parameters->CreateHandleInformation.DesiredAccess & PROCESS_CREATE_THREAD)
		{
			DbgPrint(DRIVER_PREFIX "[%d] trying to open process for creating a Thread: [%d]\n", sourcePID, targetPid);
			// disallow the operations:
			if (!isMyProcess) {
				isDenied = true;
				Info->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_CREATE_THREAD;
			}
		}

		if (Info->Parameters->DuplicateHandleInformation.DesiredAccess & PROCESS_CREATE_THREAD)
		{
			DbgPrint(DRIVER_PREFIX "[%d] trying to duplicate handle of the process for creating a Thread: [%d]\n", sourcePID, targetPid);
			// disallow the operations:
			if (!isMyProcess) {
				isDenied = true;
				Info->Parameters->DuplicateHandleInformation.DesiredAccess &= ~PROCESS_CREATE_THREAD;
			}
		}
	}
	if (isDenied) {
		DbgPrint(DRIVER_PREFIX "[%d] [!] The target PID: [%d] is not watched, ACCESS DENIED\n", sourcePID, targetPid);
		ProcessUtil::ShowProcessPath(targetProcess);
	}
	return OB_PREOP_SUCCESS;
}


NTSTATUS OnRegistryNotify(PVOID context, PVOID regNotifyClass, PVOID arg2)
{
	UNREFERENCED_PARAMETER(context);
	UNREFERENCED_PARAMETER(arg2);
	const ULONG sourcePID = HandleToULong(PsGetCurrentProcessId()); //the PID of the process performing the operation
	if (!Data::ContainsProcess(sourcePID)) {
		return STATUS_SUCCESS; //do not interfere
	}
	const REG_NOTIFY_CLASS regNotify = (REG_NOTIFY_CLASS)(ULONG_PTR)regNotifyClass;
	switch (regNotify) {
		case RegNtPreCreateKey:
		case RegNtSetValueKey:
		case RegNtPreDeleteKey:
		case RegNtPreRenameKey:
			break;
		default:
			return STATUS_SUCCESS; //do not interfere
	}
	DbgPrint(DRIVER_PREFIX "[%d] Process is trying to access registry key, notify type: [%d]\n", sourcePID, regNotify);
	return STATUS_ACCESS_DENIED; //block the access
}

```

`MalUnpackCompanion/filters.h`:

```h
#pragma once

#include <ntifs.h>

#include "data_manager.h"

OB_PREOP_CALLBACK_STATUS OnPreOpenProcess(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION Info);

NTSTATUS OnRegistryNotify(PVOID context, PVOID arg1, PVOID arg2);

```

`MalUnpackCompanion/fs_filters.cpp`:

```cpp
#include "fs_filters.h"
#include "file_util.h"

namespace FltUtil {

	NTSTATUS GetFileId(PCFLT_RELATED_OBJECTS FltObjects, PFLT_CALLBACK_DATA Data, LONGLONG& FileId, char *caller)
	{
		UNREFERENCED_PARAMETER(caller);

		FileId = FILE_INVALID_FILE_ID;

		if (!Data || !FltObjects) {
			return STATUS_INVALID_PARAMETER;
		}
		
		PFLT_FILE_NAME_INFORMATION pFileNameInfo = NULL;
		NTSTATUS status = FltGetFileNameInformation(Data, FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &pFileNameInfo);
		if (!NT_SUCCESS(status)) {
			if (status != STATUS_FLT_INVALID_NAME_REQUEST && 
				status != STATUS_OBJECT_NAME_INVALID &&
				status != STATUS_OBJECT_PATH_NOT_FOUND)
			{
				KdPrint((DRIVER_PREFIX "[!!!][%s] Failed to get filename information, status: %X\n", caller, status));
			}
			return status;
		}

		PUNICODE_STRING FileName = &pFileNameInfo->Name;
		OBJECT_ATTRIBUTES objAttr;
		InitializeObjectAttributes(&objAttr, FileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

		HANDLE hFile;
		IO_STATUS_BLOCK ioStatusBlock;
		status = FltCreateFile(FltObjects->Filter,
			FltObjects->Instance,
			&hFile,
			SYNCHRONIZE | FILE_READ_ATTRIBUTES,
			&objAttr,
			&ioStatusBlock,
			NULL,
			FILE_ATTRIBUTE_NORMAL,
			FILE_SHARE_READ,
			FILE_OPEN,
			FILE_SYNCHRONOUS_IO_NONALERT,
			NULL,
			0,
			IO_IGNORE_SHARE_ACCESS_CHECK
		);
		if (NT_SUCCESS(status)) {
			status = FileUtil::FetchFileId(hFile, FileId);
			FltClose(hFile);
		}
		FltReleaseFileNameInformation(pFileNameInfo);
		return status;
	}

	//WARNING: use it only after the object is verified, otherwise it can cause crash!
	NTSTATUS FltGetFileSize(PCFLT_RELATED_OBJECTS FltObjects, LONGLONG& myFileSize)
	{
		myFileSize = INVALID_FILE_SIZE;
		if (!FltObjects) {
			return STATUS_INVALID_PARAMETER;
		}
		LARGE_INTEGER fileSize;
		NTSTATUS status = FsRtlGetFileSize(FltObjects->FileObject, &fileSize);
		if (NT_SUCCESS(status)) {
			myFileSize = fileSize.QuadPart;
		}
		return status;
	}

	NTSTATUS GetFileSize(PCFLT_RELATED_OBJECTS FltObjects, PFLT_CALLBACK_DATA Data, LONGLONG& myFileSize)
	{
		myFileSize = INVALID_FILE_SIZE;
		if (!Data || !FltObjects) {
			return STATUS_INVALID_PARAMETER;
		}

		PFLT_FILE_NAME_INFORMATION pFileNameInfo = NULL;
		NTSTATUS status = FltGetFileNameInformation(Data, FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &pFileNameInfo);
		if (!NT_SUCCESS(status)) {
			if (status != STATUS_FLT_INVALID_NAME_REQUEST &&
				status != STATUS_OBJECT_NAME_INVALID &&
				status != STATUS_OBJECT_PATH_NOT_FOUND)
			{
				KdPrint((DRIVER_PREFIX __FUNCTION__ "[!!!] Failed to get filename information, status: %X\n", status));
			}
			return status;
		}

		PUNICODE_STRING FileName = &pFileNameInfo->Name;
		OBJECT_ATTRIBUTES objAttr;
		InitializeObjectAttributes(&objAttr, FileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

		HANDLE hFile;
		IO_STATUS_BLOCK ioStatusBlock;
		status = FltCreateFile(FltObjects->Filter,
			FltObjects->Instance,
			&hFile,
			SYNCHRONIZE | FILE_READ_ATTRIBUTES,
			&objAttr,
			&ioStatusBlock,
			NULL,
			FILE_ATTRIBUTE_NORMAL,
			FILE_SHARE_READ,
			FILE_OPEN,
			FILE_SYNCHRONOUS_IO_NONALERT,
			NULL,
			0,
			IO_IGNORE_SHARE_ACCESS_CHECK
		);
		if (NT_SUCCESS(status)) {
			status = FileUtil::FetchFileSize(hFile, myFileSize);
			FltClose(hFile);
		}
		FltReleaseFileNameInformation(pFileNameInfo);
		return status;
	}

	bool _IsAnyCreateOverwriteDisp(ULONG createDisposition)
	{
		switch (createDisposition) {
		case FILE_CREATE:
		case FILE_SUPERSEDE:
		case FILE_OVERWRITE_IF:
		case FILE_OPEN_IF:
		case FILE_OVERWRITE:
			return true;
		}
		return false;
	}

	bool IsCreateOrOverwriteEmpty(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects)
	{
		if (!Data || !FltObjects) return false;

		const auto& params = Data->Iopb->Parameters.Create;

		const ULONG createDisposition = (params.Options >> 24) & 0x000000FF;
		const bool isAnyCreate = _IsAnyCreateOverwriteDisp(createDisposition);

		// Retrieve file size:
		LONGLONG FileSize = INVALID_FILE_SIZE;
		const NTSTATUS fileSizeStatus = FltUtil::GetFileSize(FltObjects, Data, FileSize);

		if (fileSizeStatus == STATUS_OBJECT_NAME_NOT_FOUND || 
			fileSizeStatus == STATUS_OBJECT_PATH_NOT_FOUND)
		{
			FileSize = 0; //name not found, it is a new file
		}
		// Check if it is creating a new file or replacing empty:
		if ((FILE_CREATE == createDisposition)
			|| ((FileSize == 0) && isAnyCreate))
		{
			const ACCESS_MASK DesiredAccess = (params.SecurityContext != nullptr) ? params.SecurityContext->DesiredAccess : 0;
			KdPrint((DRIVER_PREFIX __FUNCTION__ ": Requested creating new file, createDisposition %X, DesiredAccess %X, isAnyCreate: %X, fileSize: %llX\n",
				createDisposition,
				DesiredAccess,
				isAnyCreate,
				FileSize
			));
			return true;
		}
		return false;
	}
}


bool _SetFileContext(PCFLT_RELATED_OBJECTS FltObjects, LONGLONG fileId, char* caller)
{
	FileContext* ctx = nullptr; //STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND
	NTSTATUS ctx_status = FltAllocateContext(FltObjects->Filter, FLT_FILE_CONTEXT, sizeof(FileContext), PagedPool, (PFLT_CONTEXT*)&ctx);
	if (!NT_SUCCESS(ctx_status)) {
		DbgPrint(DRIVER_PREFIX "[CTX][ERR][%s][% llX] Creating the context failed : % x\n", caller, fileId, ctx_status);
		return false;
	}
	bool isSet = false;
	ctx->fileId = fileId;
	ctx_status = FltSetFileContext(FltObjects->Instance, FltObjects->FileObject, FLT_SET_CONTEXT_KEEP_IF_EXISTS, ctx, nullptr);
	if (NT_SUCCESS(ctx_status)) {
		KdPrint((DRIVER_PREFIX "[CTX][OK][%s][%llX] Attached the context to the file\n", caller, fileId));
		isSet = true;
	}
	else {
		if (ctx_status != STATUS_NOT_SUPPORTED && ctx_status != STATUS_FLT_CONTEXT_ALREADY_DEFINED) {
			DbgPrint(DRIVER_PREFIX "[CTX][ERR][%s][% llX] Attaching the context failed : % x\n", caller, fileId, ctx_status);
		}
	}
	FltReleaseContext(ctx); ctx = nullptr;
	return isSet;
}


LONGLONG _GetFileIdFromContext(PFLT_INSTANCE CONST Instance, PFILE_OBJECT CONST FileObject, char* caller)
{
	UNREFERENCED_PARAMETER(caller);
	LONGLONG fileId = FILE_INVALID_FILE_ID;
	FileContext* ctx = nullptr;
	NTSTATUS ctx_status = FltGetFileContext(Instance, FileObject, (PFLT_CONTEXT*)&ctx);
	if (NT_SUCCESS(ctx_status)) {
		if (ctx) {
			fileId = ctx->fileId;
			KdPrint((DRIVER_PREFIX "[CTX][OK][%s] Retrieved fileID: %llX\n", caller, fileId));
		}
		FltReleaseContext(ctx); ctx = nullptr;
	}
	else {
		KdPrint((DRIVER_PREFIX "[CTX][ERR][%s] Couldn't get file context, status: %x\n", caller, ctx_status));
	}
	return fileId;
}

///


FLT_PREOP_CALLBACK_STATUS MyFilterProtectPreCreate(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID* CompletionContext)
{
	UNREFERENCED_PARAMETER(CompletionContext);

	if (Data->RequestorMode == KernelMode) {
		return FLT_PREOP_SUCCESS_NO_CALLBACK;
	}

	auto& params = Data->Iopb->Parameters.Create;
	// chceck if the caller insist if it must be a directory:
	if (params.Options & FILE_DIRECTORY_FILE) {
		return FLT_PREOP_SUCCESS_NO_CALLBACK; // do not interfere
	}
	// check if the process is watched:
	const ULONG sourcePID = HandleToULong(PsGetCurrentProcessId()); //the PID of the process performing the operation
	if (!Data::ContainsProcess(sourcePID)) {
		return FLT_PREOP_SUCCESS_NO_CALLBACK; // not a watched process, do not interfere
	}

	// Check if it is creating a new file:
	if (FltUtil::IsCreateOrOverwriteEmpty(Data, FltObjects)) {
		// check if adding the file is possible:
		if (!Data::CanAddFile(sourcePID)) {
			Data->IoStatus.Status = STATUS_ACCESS_DENIED;
			KdPrint((DRIVER_PREFIX " [%d] Could not add to the files watchlist: limit exhausted\n", sourcePID));
			return FLT_PREOP_COMPLETE;
		}
		return FLT_PREOP_SYNCHRONIZE; // sync with post-op
	}

	const ULONG createDisposition = (Data->Iopb->Parameters.Create.Options >> 24) & 0x000000FF;
	const ACCESS_MASK DesiredAccess = (params.SecurityContext != nullptr) ? params.SecurityContext->DesiredAccess : 0;
	const ULONG all_write = FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA;

	// Retrieve and check the file ID:
	LONGLONG fileId = FILE_INVALID_FILE_ID;
	NTSTATUS fileIdStatus = FltUtil::GetFileId(FltObjects, Data, fileId, __FUNCTION__);
	//It is NOT a creation of new file, and cannot verify the file ID, so deny the access...
	if (FILE_INVALID_FILE_ID == fileId) {
		if ((FILE_OPEN != createDisposition) || (DesiredAccess & all_write)) {

			if (fileIdStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
				Data->IoStatus.Status = fileIdStatus;
				return FLT_PREOP_COMPLETE;
			}
			//if could not check the file ID, and the file will be written, deny the access
			DbgPrint(DRIVER_PREFIX " [%d][!][%s] Could not retrieve ID of the file (status= %X), createDisposition: %X, DesiredAccess: %X-> ACCESS_DENIED!\n",
				sourcePID, 
				__FUNCTION__,
				fileIdStatus, createDisposition, DesiredAccess);
			
			Data->IoStatus.Status = STATUS_ACCESS_DENIED;
			return FLT_PREOP_COMPLETE;
		}
		return FLT_PREOP_SUCCESS_NO_CALLBACK;
	}

	if (DesiredAccess & all_write) {
		if (!Data::IsProcessInFileOwners(sourcePID, fileId)) {
			// this file does not belong to the current process, block the access:
			Data->IoStatus.Status = STATUS_ACCESS_DENIED;
			return FLT_PREOP_COMPLETE;
		}

		DbgPrint(DRIVER_PREFIX __FUNCTION__": Attempted writing to the OWNED file, DesiredAccess: %X createDisposition: %X fileID: %zX\n",
			DesiredAccess,
			createDisposition,
			fileId);
	}

	return FLT_PREOP_SUCCESS_NO_CALLBACK; // no need to execute post-callback
}

FLT_POSTOP_CALLBACK_STATUS MyFilterProtectPostCreate(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID CompletionContext, FLT_POST_OPERATION_FLAGS Flags)
{
	UNREFERENCED_PARAMETER(CompletionContext);

	if (Flags & FLTFL_POST_OPERATION_DRAINING) {
		return FLT_POSTOP_FINISHED_PROCESSING;
	}

	if (Data->RequestorMode == KernelMode) {
		return FLT_POSTOP_FINISHED_PROCESSING;
	}
	if (!NT_SUCCESS(Data->IoStatus.Status)) {
		// the operation has been rejected at pre-create level
		return FLT_POSTOP_FINISHED_PROCESSING;
	}

	auto& params = Data->Iopb->Parameters.Create;
	if (params.Options & FILE_DIRECTORY_FILE) {
		// this is a directory, do not interfere
		return FLT_POSTOP_FINISHED_PROCESSING;
	}

	const ULONG sourcePID = HandleToULong(PsGetCurrentProcessId()); //the PID of the process performing the operation
	if (!Data::ContainsProcess(sourcePID)) {
		return FLT_POSTOP_FINISHED_PROCESSING; // not a watched process, do not interfere
	}

	// Retrieve and check the file ID:
	LONGLONG fileId = FILE_INVALID_FILE_ID;
	NTSTATUS fileIdStatus = FltUtil::GetFileId(FltObjects, Data, fileId, __FUNCTION__);
	if (FILE_INVALID_FILE_ID == fileId) {
		// this should never happend: case handled pre-create
		return FLT_POSTOP_FINISHED_PROCESSING;
	}

	if (Data->IoStatus.Information == FILE_CREATED ||
		Data->IoStatus.Information == FILE_OVERWRITTEN ||
		Data->IoStatus.Information == FILE_SUPERSEDED)
	{
		DbgPrint(DRIVER_PREFIX "[%d][%s] Creating a new OWNED fileID: %zX fileIdStatus: %X\n", sourcePID, __FUNCTION__, fileId, fileIdStatus);
		const PUNICODE_STRING fileName = (Data->Iopb->TargetFileObject) ? &Data->Iopb->TargetFileObject->FileName : nullptr;
		if (fileName) {
			DbgPrint(DRIVER_PREFIX "[%llX] file Name: %wZ\n", fileId, fileName);
		}
		// assign this file to the process that created it:
		const t_add_status add_status =  Data::AddFile(fileId, sourcePID);
		if (add_status == ADD_OK) {
			_SetFileContext(FltObjects, fileId, __FUNCTION__);
		}
		if (add_status == ADD_LIMIT_EXHAUSTED) {
			DbgPrint(DRIVER_PREFIX "[%llX][%s] Could not add to the files watchlist: limit exhausted\n", fileId, __FUNCTION__);
		}
		if (add_status == ADD_FORBIDDEN) {
			DbgPrint(DRIVER_PREFIX "[%llX][%s] Could not add to the file to watchlist: already associated with other process\n", fileId, __FUNCTION__);
		}
		// cancel the open operation if the file was not added to the list
		if (add_status != ADD_OK && add_status != ADD_ALREADY_EXIST) {
			FltCancelFileOpen(FltObjects->Instance, FltObjects->FileObject);
			Data->IoStatus.Status = STATUS_ACCESS_DENIED;
			Data->IoStatus.Information = 0;
			return FLT_POSTOP_FINISHED_PROCESSING;
		}
	}
	return FLT_POSTOP_FINISHED_PROCESSING;
}

FLT_PREOP_CALLBACK_STATUS MyFilterProtectPreSetInformation(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID*)
{
	UNREFERENCED_PARAMETER(FltObjects);

	if (Data->RequestorMode == KernelMode) {
		return FLT_PREOP_SUCCESS_NO_CALLBACK;
	}

	// check if it is a delete operation:
	auto& params = Data->Iopb->Parameters.SetFileInformation;
	if (params.FileInformationClass != FileDispositionInformation && params.FileInformationClass != FileDispositionInformationEx) {
		// not a delete operation
		return FLT_PREOP_SUCCESS_NO_CALLBACK;
	}

	FILE_DISPOSITION_INFORMATION* info = (FILE_DISPOSITION_INFORMATION*)params.InfoBuffer;
	if (!info->DeleteFile) {
		return FLT_PREOP_SUCCESS_NO_CALLBACK;
	}

	// check if it is a watched process:
	const ULONG sourcePID = HandleToULong(PsGetCurrentProcessId()); //the PID of the process performing the operation
	if (!Data::ContainsProcess(sourcePID)) { 
		return FLT_PREOP_SUCCESS_NO_CALLBACK; //do not interfere
	}

	//get the File ID:
	NTSTATUS fileIdStatus = 0;
	LONGLONG fileId = _GetFileIdFromContext(FltObjects->Instance, FltObjects->FileObject,__FUNCTION__);
	if (fileId == FILE_INVALID_FILE_ID) {
		fileIdStatus = FltUtil::GetFileId(FltObjects, Data, fileId, __FUNCTION__);
	}

	const PUNICODE_STRING fileName = (Data->Iopb->TargetFileObject) ? &Data->Iopb->TargetFileObject->FileName : nullptr;

	// check if the watched process is the ower of this file:
	if (Data::IsProcessInFileOwners(sourcePID, fileId)) {
		// report about the operation:
		DbgPrint(DRIVER_PREFIX "[%d] Attempted setting delete disposition for the OWNED file, fileID: %llX status: %X\n",
			sourcePID,
			fileId,
			fileIdStatus);

		if (fileName) {
			DbgPrint(DRIVER_PREFIX "[%zX] file Name: %wZ \n", fileId, fileName);
		}
		return FLT_PREOP_SUCCESS_NO_CALLBACK; //do not interfere
	}

	DbgPrint(DRIVER_PREFIX "[%d] Attempted setting delete disposition for the NOT-owned file, fileID: %llX status: %X -> ACCESS_DENIED\n",
		sourcePID,
		fileId,
		fileIdStatus);
	if (fileName) {
		DbgPrint(DRIVER_PREFIX "[%zX] file Name: %wZ \n", fileId, fileName);
	}

	// this file does not belong to the current process, block the access:
	Data->IoStatus.Status = STATUS_ACCESS_DENIED;
	return FLT_PREOP_COMPLETE; //finish processing
}


FLT_PREOP_CALLBACK_STATUS MyPreCleanup(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID*)
{
	PAGED_CODE();

	ULONG fileOwner = 0;
	LONGLONG fileId = FILE_INVALID_FILE_ID;
	NTSTATUS fileIdStatus = FltUtil::GetFileId(FltObjects, Data, fileId, __FUNCTION__);
	if (NT_SUCCESS(fileIdStatus)) {
		fileOwner = Data::GetFileOwner(fileId);
		if (fileOwner && fileId != FILE_INVALID_FILE_ID) {
			_SetFileContext(FltObjects, fileId, __FUNCTION__);
		}
	}
	return FLT_PREOP_SUCCESS_WITH_CALLBACK;
}

FLT_POSTOP_CALLBACK_STATUS MyPostCleanup(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID CompletionContext, FLT_POST_OPERATION_FLAGS Flags)
{
	UNREFERENCED_PARAMETER(FltObjects);
	UNREFERENCED_PARAMETER(CompletionContext);
	UNREFERENCED_PARAMETER(Flags);

	PAGED_CODE();

	FILE_STANDARD_INFORMATION fileInfo;
	NTSTATUS status = FltQueryInformationFile(Data->Iopb->TargetInstance,
		Data->Iopb->TargetFileObject,
		&fileInfo,
		sizeof(fileInfo),
		FileStandardInformation,
		NULL);

	if (STATUS_FILE_DELETED != status) {
		return FLT_POSTOP_FINISHED_PROCESSING;
	}

	LONGLONG fileId = _GetFileIdFromContext(FltObjects->Instance, FltObjects->FileObject, __FUNCTION__);
	if (fileId != FILE_INVALID_FILE_ID) {
		DbgPrint(DRIVER_PREFIX __FUNCTION__" >>> The watched file was deleted from the disk: %llx\n", fileId);
		if (Data::DeleteFile(fileId)) {
			DbgPrint(DRIVER_PREFIX __FUNCTION__" >>> DELETED from the watch list: %llx\n", fileId);
		}
	}
	return FLT_POSTOP_FINISHED_PROCESSING;
}


NTSTATUS
MyFilterUnload(
	_In_ FLT_FILTER_UNLOAD_FLAGS Flags
)
{
	UNREFERENCED_PARAMETER(Flags);
	PAGED_CODE();

	KdPrint((DRIVER_PREFIX "MyFilterUnload: Entered\n"));
	FltUnregisterFilter(g_Settings.gFilterHandle);
	g_Settings.gFilterHandle = NULL;

	return STATUS_SUCCESS;
}


NTSTATUS
MyFilterInstanceSetup(
	_In_ PCFLT_RELATED_OBJECTS FltObjects,
	_In_ FLT_INSTANCE_SETUP_FLAGS Flags,
	_In_ DEVICE_TYPE VolumeDeviceType,
	_In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType
)
{
	UNREFERENCED_PARAMETER(FltObjects);
	UNREFERENCED_PARAMETER(Flags);
	UNREFERENCED_PARAMETER(VolumeDeviceType);
	UNREFERENCED_PARAMETER(VolumeFilesystemType);

	PAGED_CODE();

	KdPrint((DRIVER_PREFIX "MyFilterInstanceSetup: Entered\n"));
	return STATUS_SUCCESS;
}


NTSTATUS
MyFilterInstanceQueryTeardown(
	_In_ PCFLT_RELATED_OBJECTS FltObjects,
	_In_ FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags
)
{
	UNREFERENCED_PARAMETER(FltObjects);
	UNREFERENCED_PARAMETER(Flags);

	PAGED_CODE();

	KdPrint((DRIVER_PREFIX "MyFilterInstanceQueryTeardown: Entered\n"));
	return STATUS_SUCCESS;
}

VOID
MyFilterInstanceTeardownStart(
	_In_ PCFLT_RELATED_OBJECTS FltObjects,
	_In_ FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags
)
{
	UNREFERENCED_PARAMETER(FltObjects);
	UNREFERENCED_PARAMETER(Flags);

	PAGED_CODE();

	KdPrint((DRIVER_PREFIX "MyFilterInstanceTeardownStart: Entered\n"));
}


VOID
MyFilterInstanceTeardownComplete(
	_In_ PCFLT_RELATED_OBJECTS FltObjects,
	_In_ FLT_INSTANCE_TEARDOWN_FLAGS Flags
)
{
	UNREFERENCED_PARAMETER(FltObjects);
	UNREFERENCED_PARAMETER(Flags);

	PAGED_CODE();

	KdPrint((DRIVER_PREFIX "MyFilterInstanceTeardownComplete: Entered\n"));
}

```

`MalUnpackCompanion/fs_filters.h`:

```h
#pragma once

#include <fltKernel.h>
#include "main.h"

#include "common.h"
#include "data_manager.h"

extern active_settings g_Settings;


struct FileContext
{
	LONGLONG fileId;
};

CONST FLT_CONTEXT_REGISTRATION ContextRegistration[] = {
	{ FLT_FILE_CONTEXT, 0, nullptr, sizeof(FileContext), DRIVER_TAG, nullptr, nullptr, nullptr },
	{ FLT_CONTEXT_END }
};

////
FLT_PREOP_CALLBACK_STATUS MyFilterProtectPreCreate(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID* CompletionContext);
FLT_POSTOP_CALLBACK_STATUS MyFilterProtectPostCreate(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID CompletionContext, FLT_POST_OPERATION_FLAGS Flags);

FLT_PREOP_CALLBACK_STATUS MyFilterProtectPreSetInformation(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID*);

FLT_PREOP_CALLBACK_STATUS MyPreCleanup(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID*);
FLT_POSTOP_CALLBACK_STATUS MyPostCleanup(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID CompletionContext, FLT_POST_OPERATION_FLAGS Flags);
///

CONST FLT_OPERATION_REGISTRATION Callbacks[] = {
	{ IRP_MJ_CREATE, 0, MyFilterProtectPreCreate, MyFilterProtectPostCreate },
	{ IRP_MJ_SET_INFORMATION, 0, MyFilterProtectPreSetInformation, nullptr },
	{ IRP_MJ_CLEANUP, 0, MyPreCleanup, MyPostCleanup},
	{ IRP_MJ_OPERATION_END }
};


NTSTATUS
MyFilterUnload(
	_In_ FLT_FILTER_UNLOAD_FLAGS Flags
);

NTSTATUS
MyFilterInstanceSetup(
	_In_ PCFLT_RELATED_OBJECTS FltObjects,
	_In_ FLT_INSTANCE_SETUP_FLAGS Flags,
	_In_ DEVICE_TYPE VolumeDeviceType,
	_In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType
);


NTSTATUS
MyFilterInstanceQueryTeardown(
	_In_ PCFLT_RELATED_OBJECTS FltObjects,
	_In_ FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags
);

VOID
MyFilterInstanceTeardownStart(
	_In_ PCFLT_RELATED_OBJECTS FltObjects,
	_In_ FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags
);

VOID
MyFilterInstanceTeardownComplete(
	_In_ PCFLT_RELATED_OBJECTS FltObjects,
	_In_ FLT_INSTANCE_TEARDOWN_FLAGS Flags
);

//
//  This defines what we want to filter with FltMgr
//

CONST FLT_REGISTRATION FilterRegistration = {

	sizeof(FLT_REGISTRATION),
	FLT_REGISTRATION_VERSION,
	0,                       //  Flags

	ContextRegistration,                 //  Context
	Callbacks,               //  Operation callbacks

	MyFilterUnload,                   //  MiniFilterUnload

	MyFilterInstanceSetup,            //  InstanceSetup
	MyFilterInstanceQueryTeardown,    //  InstanceQueryTeardown
	MyFilterInstanceTeardownStart,    //  InstanceTeardownStart
	MyFilterInstanceTeardownComplete, //  InstanceTeardownComplete
};

```

`MalUnpackCompanion/main.cpp`:

```cpp
#include <ntifs.h>

#include <fltKernel.h>
#include <dontuse.h>

#include "main.h"
#include "undoc_api.h"

#include "common.h"
#include "data_manager.h"
#include "filters.h"
#include "fs_filters.h"

#include "process_util.h"
#include "file_util.h"
#include "util.h"

#define SLEEP_TIME 1000

#define ALTITUDE_PROCESS_FILTER L"12345.6171"
#define ALTITUDE_REGISTRY_FILTER L"7657.124"

#define SUPPORTED_CLIENT_NAME L"\\mal_unpack.exe"

#define IO_METHOD_FROM_CTL_CODE(cltCode) (cltCode & 0x00000003)

active_settings g_Settings;
//---

bool _AddProcessToParent(ULONG PID, ULONG ParentPID)
{
	if (Data::ContainsProcess(ParentPID)) {
		DbgPrint(DRIVER_PREFIX "[%d] created WATCHED process: [%d]\n", ParentPID, PID);
		t_add_status aStat = Data::AddProcess(PID, ParentPID);
		if (aStat == ADD_OK || aStat == ADD_ALREADY_EXIST) {
			return true;
		}
		if (aStat == ADD_LIMIT_EXHAUSTED) {
			DbgPrint(DRIVER_PREFIX "[%d] Could not add to the watchlist: limit exhausted\n", PID);
		}
	}
	return false;
}

void _OnProcessCreation(_Inout_ PEPROCESS Process, _In_ HANDLE ProcessId, _Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo)
{
	UNREFERENCED_PARAMETER(Process);
	const ULONG PID = HandleToULong(ProcessId);

	USHORT commandLineSize = 0;
	if (CreateInfo->CommandLine) {
		commandLineSize = CreateInfo->CommandLine->Length;
	}
	const ULONG ParentPID = HandleToULong(CreateInfo->ParentProcessId);
	bool isAdded = _AddProcessToParent(PID, ParentPID);

	const ULONG creatorPID = HandleToULong(PsGetCurrentProcessId()); //the PID creating the thread
	if (!isAdded && (ParentPID != creatorPID)) {
		isAdded = _AddProcessToParent(PID, creatorPID);
	}
	if (isAdded && commandLineSize) {
		DbgPrint(DRIVER_PREFIX "Added: [%d] -> %S\n", PID, CreateInfo->CommandLine->Buffer);
	}
}

void _OnProcessExit(_Inout_ PEPROCESS Process, _In_ HANDLE ProcessId)
{
	UNREFERENCED_PARAMETER(Process);

	const ULONG PID = HandleToULong(ProcessId);
	Data::WaitForProcessDeletion(PID, 0);
}

void OnProcessNotify(_Inout_ PEPROCESS Process, _In_ HANDLE ProcessId, _Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo)
{
	if (CreateInfo) {
		//process created:
		_OnProcessCreation(Process, ProcessId, CreateInfo);
	}
	else {
		_OnProcessExit(Process, ProcessId);
	}
}

void OnThreadNotify(HANDLE ProcessId, HANDLE Thread, BOOLEAN Create)
{
	const ULONG creatorPID = HandleToULong(PsGetCurrentProcessId()); //the PID creating the thread
	const ULONG targetPID = HandleToULong(ProcessId);
	const ULONG ThreadId = HandleToULong(Thread);

	if (!Data::ContainsProcess(creatorPID)) {
		return;
	}
	if (Create && (creatorPID != targetPID)) {
		DbgPrint(DRIVER_PREFIX "[%d] THREAD: Creating remote thread! %d -> %d [%x]\n", creatorPID, creatorPID, targetPID, targetPID);
		if (Data::AddProcess(targetPID, creatorPID) == ADD_LIMIT_EXHAUSTED) {
			DbgPrint(DRIVER_PREFIX "[%d] Could not add to the watchlist: limit exhausted\n", targetPID);
		}
	}
}

#define _RETRIEVE_PATH
void OnImageLoadNotify(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo)
{
	if (ProcessId == nullptr) {
		// system process, ignore
		return;
	}
#ifdef _RETRIEVE_PATH
	UNREFERENCED_PARAMETER(FullImageName);
	// retrieve image path manually: backward compatibility with Windows < 10
	WCHAR FileName[FileUtil::MAX_PATH_LEN] = { 0 };
	if (!FileUtil::RetrieveImagePath(ImageInfo, FileName)) {
		return;
	}
	UNICODE_STRING ImageU = { 0 };
	RtlInitUnicodeString(&ImageU, FileName);

	PUNICODE_STRING ImagePath = &ImageU;
#else
	UNREFERENCED_PARAMETER(ImageInfo);
	PUNICODE_STRING ImagePath = FullImageName;
#endif
	if (!ImagePath) {
		return;
	}
	const ULONG PID = HandleToULong(ProcessId);
	//DbgPrint(DRIVER_PREFIX __FUNCTION__" [%d] Retrieved path: %S\n", PID, ImagePath->Buffer);

	LONGLONG fileId = FileUtil::GetFileIdByPath(ImagePath);
	if (fileId == FILE_INVALID_FILE_ID) {
		return;
	}

	const t_add_status aStat = Data::AddProcessToFileOwner(PID, fileId);
	if (aStat == ADD_INVALID_ITEM) {
		return; // this file is not owned by any process
	}
	if (aStat == ADD_LIMIT_EXHAUSTED) {
		DbgPrint(DRIVER_PREFIX "[%d] Could not add to the watchlist: limit exhausted\n");
	}
	if (aStat == ADD_OK) {
		DbgPrint(DRIVER_PREFIX __FUNCTION__" [%d] Added process created from the OWNED file-> %zX\n", PID, fileId);
	}
}

void _UnregisterCallbacks()
{
	if (g_Settings.RegHandle) {
		ObUnRegisterCallbacks(g_Settings.RegHandle);
		g_Settings.RegHandle = NULL;
	}
	if (g_Settings.RegCookie.QuadPart != 0) {
		CmUnRegisterCallback(g_Settings.RegCookie);
		g_Settings.RegCookie.QuadPart = 0;
	}
	if (g_Settings.gFilterHandle) {
		FltUnregisterFilter(g_Settings.gFilterHandle);
		g_Settings.gFilterHandle = NULL;
	}
}

void MyDriverUnload(_In_ PDRIVER_OBJECT DriverObject)
{
	Data::FreeGlobals();

	//unregister the notification
	if (g_Settings.hasImageNotify) {
		PsRemoveLoadImageNotifyRoutine(OnImageLoadNotify);
		g_Settings.hasImageNotify = false;
	}
	if (g_Settings.hasThreadNotify) {
		PsRemoveCreateThreadNotifyRoutine(OnThreadNotify);
		g_Settings.hasThreadNotify = false;
	}
	if (g_Settings.hasProcessNotify) {
		PsSetCreateProcessNotifyRoutineEx(OnProcessNotify, TRUE);
		g_Settings.hasProcessNotify = false;
	}

	_UnregisterCallbacks();

	if (g_Settings.hasLink) {
		UNICODE_STRING symLink = RTL_CONSTANT_STRING(MY_DRIVER_LINK);
		// delete symbolic link
		IoDeleteSymbolicLink(&symLink);
		g_Settings.hasLink = false;
	}

	if (g_Settings.hasDevice) {
		// delete device object
		IoDeleteDevice(DriverObject->DeviceObject);
		g_Settings.hasDevice = false;

		DbgPrint(DRIVER_PREFIX "driver unloaded!\n");
	}
}

#define _ONLY_SUPPORTED_CLIENT
NTSTATUS HandleCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

#ifdef _ONLY_SUPPORTED_CLIENT
	NTSTATUS openStatus = STATUS_ACCESS_DENIED;
	const ULONG sourcePID = HandleToULong(PsGetCurrentProcessId()); //the PID of the process performing the operation
	
	PEPROCESS Process;
	NTSTATUS status = PsLookupProcessByProcessId(ULongToHandle(sourcePID), &Process);
	if (NT_SUCCESS(status)) {
		//TODO: make more fancy check:
		if (ProcessUtil::CheckProcessPath(Process, SUPPORTED_CLIENT_NAME)) {
			openStatus = STATUS_SUCCESS;
		}
		ObDereferenceObject(Process);
	}

	if (openStatus != STATUS_SUCCESS) {
		DbgPrint(DRIVER_PREFIX "[%d] ACCESS DENIED: cannot open the driver with this process\n", sourcePID);
	}
#else
	NTSTATUS openStatus = STATUS_SUCCESS;
#endif //  ONLY_SUPPORTED_CLIENT

	Irp->IoStatus.Status = openStatus;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return openStatus;
}

NTSTATUS FetchInputBufferOfMinSize(IN PIRP Irp, OUT void** inpData, IN const size_t inpDataSize, OUT OPTIONAL size_t *actualSize = nullptr)
{
	if (!Irp || inpData == nullptr) {
		return STATUS_UNSUCCESSFUL;
	}
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG method = IO_METHOD_FROM_CTL_CODE(stack->Parameters.DeviceIoControl.IoControlCode);

	size_t InputBufferLength = 0;

	if (method == METHOD_BUFFERED) {
		InputBufferLength = stack->Parameters.DeviceIoControl.InputBufferLength;
		if (InputBufferLength < inpDataSize) {
			return STATUS_BUFFER_TOO_SMALL;
		}
		*inpData = Irp->AssociatedIrp.SystemBuffer;
	}
	else if (method == METHOD_NEITHER) {
		InputBufferLength = stack->Parameters.DeviceIoControl.InputBufferLength;
		if (InputBufferLength < inpDataSize) {
			return STATUS_BUFFER_TOO_SMALL;
		}
		*inpData = stack->Parameters.DeviceIoControl.Type3InputBuffer;
	}
	else {
		return STATUS_NOT_SUPPORTED;
	}
	if (*inpData == nullptr) {
		return STATUS_INVALID_PARAMETER;
	}
	if (actualSize) {
		*actualSize = InputBufferLength;
	}
	return STATUS_SUCCESS;
}

template<typename DATA_BUF>
NTSTATUS FetchInputBuffer(PIRP Irp, DATA_BUF** inpData)
{
	if (!Irp || inpData == nullptr) {
		return STATUS_UNSUCCESSFUL;
	}
	const size_t inpDataSize = sizeof(DATA_BUF);
	return FetchInputBufferOfMinSize(Irp, (void**)inpData, inpDataSize);
}

//---
t_add_status _AddProcessWatch(ProcessDataEx &settings)
{
	const ULONG PID = settings.Pid;
	const LONGLONG FileId = settings.fileId;

	PEPROCESS Process;
	NTSTATUS status = PsLookupProcessByProcessId(ULongToHandle(PID), &Process);
	if (!NT_SUCCESS(status)) {
		DbgPrint(DRIVER_PREFIX ": Such process does not exist: %d\n", PID);
		return t_add_status::ADD_INVALID_ITEM;
	}

	ObDereferenceObject(Process);

	DbgPrint(DRIVER_PREFIX ": Watching process requested %d, noresp=%d\n", PID, settings.noresp);
	t_add_status add_status = Data::AddProcessNode(PID, FileId, settings.noresp);
	if (status == ADD_OK && FileId != FILE_INVALID_FILE_ID) {
		if (Data::AddFile(FileId, PID) == ADD_OK) {
			DbgPrint(DRIVER_PREFIX ": Watching process file %llx\n", FileId);
		}
	}
	return add_status;
}

NTSTATUS FetchProcessData(PIRP Irp, ProcessDataEx &settings)
{
	NTSTATUS status = STATUS_INVALID_PARAMETER;
	// v2:
	{
		ProcessDataEx_v2* inpDataEx2 = nullptr;
		status = FetchInputBuffer(Irp, &inpDataEx2);
		if (NT_SUCCESS(status)) {
			settings.Pid = inpDataEx2->Pid;
			settings.fileId = inpDataEx2->fileId;
			settings.noresp = inpDataEx2->noresp;
			return status;
		}
	}
	// v1:
	{
		ProcessDataEx_v1* inpDataEx = nullptr;
		status = FetchInputBuffer(Irp, &inpDataEx);
		if (NT_SUCCESS(status)) {
			settings.Pid = inpDataEx->Pid;
			settings.fileId = inpDataEx->fileId;
			return status;
		}
	}
	// basic:
	{
		ProcessDataBasic* inpData = nullptr;
		status = FetchInputBuffer(Irp, &inpData);
		if (NT_SUCCESS(status)) {
			settings.Pid = inpData->Pid;
		}
	}
	return status;
}

NTSTATUS AddProcessWatch(PIRP Irp)
{
	ProcessDataEx settings = { 0 };
	settings.fileId = FILE_INVALID_FILE_ID;

	NTSTATUS status = FetchProcessData(Irp, settings);
	if (!NT_SUCCESS(status)) {
		return status;
	}
	const t_add_status ret = _AddProcessWatch(settings);
	switch (ret) {
		case ADD_OK:
		case ADD_ALREADY_EXIST:
			return STATUS_SUCCESS;
		case ADD_INVALID_ITEM:
			return STATUS_INVALID_PARAMETER;
	}
	const int count = Data::CountProcessTrees();
	DbgPrint(DRIVER_PREFIX "[!][%zd] Failed to add process to the list. Watched nodes = %zd, add status = %d\n", settings.Pid, count, ret);
	return STATUS_UNSUCCESSFUL;
}


NTSTATUS RemoveProcessWatch(PIRP Irp)
{
	ProcessDataBasic* inpData = nullptr;

	NTSTATUS status = FetchInputBuffer(Irp, &inpData);
	if (!NT_SUCCESS(status)) {
		return status;
	}
	const ULONG PID = inpData->Pid;
	DbgPrint(DRIVER_PREFIX "Removing process watch: %d\n", PID);
	if (Data::DeleteProcess(PID)) {
		DbgPrint(DRIVER_PREFIX "Removed from the list: %d\n", PID);
	}
	return STATUS_SUCCESS;
}

NTSTATUS _TerminateWatched(ULONG PID)
{
	if (!Data::ContainsProcess(PID)) {
		return STATUS_SUCCESS;
	}
	NTSTATUS status = ProcessUtil::TerminateProcess(PID);
	if (NT_SUCCESS(status)) {
		Data::DeleteProcess(PID);
	}
	return status;
}

NTSTATUS TerminateWatched(PIRP Irp)
{
	ProcessDataBasic* inpData = nullptr;

	NTSTATUS status = FetchInputBuffer(Irp, &inpData);
	if (!NT_SUCCESS(status)) {
		return status;
	}
	return _TerminateWatched(inpData->Pid);
}

#define _TREAT_RENAMED_AS_DELETED
NTSTATUS _DeleteWatchedFile(ULONG PID, PUNICODE_STRING FileName)
{
	LONGLONG fileId = FileUtil::GetFileIdByPath(FileName);
	const ULONG fileOwnerPid = Data::GetFileOwner(fileId);
	if (fileOwnerPid != PID) {
		DbgPrint(DRIVER_PREFIX __FUNCTION__ "FileID = %llx, PID = %d, fileOwnerPid = %d - owner mismatch!\n", fileId, PID, fileOwnerPid);
		return STATUS_ACCESS_DENIED;
	}
	NTSTATUS status = FileUtil::RequestFileDeletion(FileName);
	DbgPrint(DRIVER_PREFIX __FUNCTION__ "FileID = %llx, PID = %d, status = %X\n", fileId, PID, status);
#ifdef _TREAT_RENAMED_AS_DELETED
	if (status == STATUS_CANNOT_DELETE) {
		if (Util::hasSuffix(FileName, RENAMED_EXTENSION)) {
			if (Data::DeleteFile(fileId)) {
				status = STATUS_SUCCESS;
			}
		}
	}
#endif
	return status;
}

NTSTATUS DeleteWatchedFile(PIRP Irp)
{
	ProcessFileData* inpData = nullptr;
	const size_t minimalLen = 4; // minimal length we expect valid path to be
	const size_t minimalSize = sizeof(ProcessFileData) + (sizeof(WCHAR) * minimalLen);
	size_t actualSize = 0;
	NTSTATUS status = FetchInputBufferOfMinSize(Irp, (void**)&inpData, minimalSize, &actualSize);
	if (!NT_SUCCESS(status)) {
		return status;
	}
	NT_ASSERT(actualSize > sizeof(ProcessFileData));
	const size_t actualLen = (actualSize - sizeof(ProcessFileData)) / sizeof(WCHAR);
	// ensure it is NULL-terminated:
	inpData->FileName[actualLen] = L'\0';
	DbgPrint(DRIVER_PREFIX __FUNCTION__ ": Passed buffer: %S len: %lld size: %lld\n", inpData->FileName, actualLen, actualSize);

	UNICODE_STRING name;
	RtlInitUnicodeString(&name, inpData->FileName);
	KdPrint((DRIVER_PREFIX __FUNCTION__ ": Passed buffer to unicode: %wZ\n", name));
	return _DeleteWatchedFile(inpData->Pid, &name);
}

NTSTATUS _CopyWatchedList(PIRP Irp, ULONG_PTR& outLen, bool files)
{
	ProcessDataBasic* inpData = nullptr;
	NTSTATUS status = FetchInputBuffer(Irp, &inpData);
	if (!NT_SUCCESS(status)) {
		return status;
	}
	
	const size_t elementSize = files ? sizeof(LONGLONG) : sizeof(ULONG);

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	const size_t outBufSize = stack->Parameters.DeviceIoControl.OutputBufferLength;
	if (outBufSize < elementSize) {
		return STATUS_BUFFER_TOO_SMALL;
	}
	void* outData = Irp->AssociatedIrp.SystemBuffer;
	if (outData == nullptr) {
		return STATUS_INVALID_PARAMETER;
	}
	ULONG parentPid = inpData->Pid;
	size_t items = 0;
	if (files) {
		items = Data::CopyFilesList(parentPid, outData, outBufSize);
	}
	else {
		items = Data::CopyProcessList(parentPid, outData, outBufSize);
	}
	if (items > 0) {
		KdPrint((DRIVER_PREFIX "Copied items to system buffer: %d\n", items));
		size_t copiedSize = items * elementSize;
		outLen = ULONG(copiedSize);
	}
	return STATUS_SUCCESS;
}

NTSTATUS CopyProcessesList(PIRP Irp, ULONG_PTR& outLen)
{
	return _CopyWatchedList(Irp, outLen, false);
}

NTSTATUS CopyFilesList(PIRP Irp, ULONG_PTR& outLen)
{
	return _CopyWatchedList(Irp, outLen, true);
}

NTSTATUS FetchDriverVersion(PIRP Irp, ULONG_PTR &outLen)
{
	const char* versionStr = VER_FILEVERSION_STR;
	const size_t versionSize = strlen(versionStr) + 1;

	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	const size_t outBufSize = stack->Parameters.DeviceIoControl.OutputBufferLength;
	if (outBufSize < versionSize) {
		return STATUS_BUFFER_TOO_SMALL;
	}
	void* outBuf = Irp->AssociatedIrp.SystemBuffer;
	if (outBuf == nullptr) {
		return STATUS_INVALID_PARAMETER;
	}
	::memcpy(outBuf, versionStr, versionSize);
	outLen = versionSize;
	return STATUS_SUCCESS;
}

NTSTATUS CountNodes(PIRP Irp, ULONG_PTR& outLen)
{
	auto counter = Data::CountProcessTrees();
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	const size_t outBufSize = stack->Parameters.DeviceIoControl.OutputBufferLength;
	if (outBufSize < sizeof(counter)) {
		return STATUS_BUFFER_TOO_SMALL;
	}
	void* outBuf = Irp->AssociatedIrp.SystemBuffer;
	if (outBuf == nullptr) {
		return STATUS_INVALID_PARAMETER;
	}
	::memcpy(outBuf, &counter, sizeof(counter));
	outLen = sizeof(counter);
	return STATUS_SUCCESS;
}

NTSTATUS HandleDeviceControl(PDEVICE_OBJECT, PIRP Irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	
	NTSTATUS status = STATUS_SUCCESS;

	ULONG_PTR outLen = 0;
	switch (stack->Parameters.DeviceIoControl.IoControlCode) {
		case IOCTL_MUNPACK_COMPANION_VERSION:
		{
			status = FetchDriverVersion(Irp, outLen);
			break;
		}
		case IOCTL_MUNPACK_COMPANION_COUNT_NODES:
		{
			status = CountNodes(Irp, outLen);
			break;
		}
		case IOCTL_MUNPACK_COMPANION_ADD_TO_WATCHED:
		{
			status = AddProcessWatch(Irp);
			break;
		}
#ifdef _ALLOW_DELETE
		case IOCTL_MUNPACK_COMPANION_REMOVE_FROM_WATCHED:
		{
			status = RemoveProcessWatch(Irp);
			break;
		}
#endif
		case IOCTL_MUNPACK_COMPANION_TERMINATE_WATCHED:
		{
			status = TerminateWatched(Irp);
			break;
		}
		case IOCTL_MUNPACK_COMPANION_DELETE_WATCHED_FILE:
		{
			status = DeleteWatchedFile(Irp);
			break;
		}
		case IOCTL_MUNPACK_COMPANION_LIST_PROCESSES:
		{
			status = CopyProcessesList(Irp, outLen);
			break;
		}
		case IOCTL_MUNPACK_COMPANION_LIST_FILES:
		{
			status = CopyFilesList(Irp, outLen);
			break;
		}
		default:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = outLen;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return status;
}


NTSTATUS _RegisterOpenProcessCallbacks()
{
	OB_OPERATION_REGISTRATION operations[] = {
		{
			PsProcessType,		// object type
			OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE,
			OnPreOpenProcess, nullptr	// pre, post
		}
	};
	OB_CALLBACK_REGISTRATION reg = {
		OB_FLT_REGISTRATION_VERSION,
		1,				// operation count
		RTL_CONSTANT_STRING(ALTITUDE_PROCESS_FILTER),	// altitude
		nullptr,		// context
		operations
	};

	NTSTATUS status = ObRegisterCallbacks(&reg, &g_Settings.RegHandle);
	if (!NT_SUCCESS(status)) {
		DbgPrint(DRIVER_PREFIX "failed to register callbacks (status=%08X)\n", status);
		g_Settings.RegHandle = NULL;
		return status;
	}
	return status;
}


NTSTATUS _RegisterRegistryCallbacks(_In_ PDRIVER_OBJECT DriverObject)
{
	UNICODE_STRING altitude = RTL_CONSTANT_STRING(ALTITUDE_REGISTRY_FILTER);
	NTSTATUS status = CmRegisterCallbackEx(OnRegistryNotify, &altitude, DriverObject, nullptr, &g_Settings.RegCookie, nullptr);
	if (!NT_SUCCESS(status)) {
		DbgPrint(DRIVER_PREFIX "failed to set registry callback (%08X)\n", status);
		g_Settings.RegCookie.QuadPart = 0;
		return status;
	}
	return status;
}

NTSTATUS RegisterCallbacks(_In_ PDRIVER_OBJECT DriverObject)
{
	NTSTATUS status = _RegisterOpenProcessCallbacks();
	if (!NT_SUCCESS(status)) {
		return status;
	}
	// Registry operations filtering:
	status = _RegisterRegistryCallbacks(DriverObject);
	return status;
}

NTSTATUS _InitializeDriver(_In_ PDRIVER_OBJECT DriverObject)
{
	UNICODE_STRING devName = RTL_CONSTANT_STRING(MY_DEVICE);

	PDEVICE_OBJECT DeviceObject = nullptr;
	NTSTATUS status = IoCreateDevice(DriverObject, 0, &devName, FILE_DEVICE_UNKNOWN, 0, FALSE, &DeviceObject);
	if (NT_SUCCESS(status)) {
		g_Settings.hasDevice = true;
	} else {
		DbgPrint(DRIVER_PREFIX "Failed to create device (0x%08X)\n", status);
		return status;
	}

	UNICODE_STRING symLink = RTL_CONSTANT_STRING(MY_DRIVER_LINK);
	status = IoCreateSymbolicLink(&symLink, &devName);
	if (NT_SUCCESS(status)) {
		g_Settings.hasLink = true;
	} else {
		DbgPrint(DRIVER_PREFIX "Failed to create symbolic link (0x%08X)\n", status);
		return status;
	}

	status = PsSetCreateProcessNotifyRoutineEx(OnProcessNotify, FALSE);
	if (NT_SUCCESS(status)) {
		g_Settings.hasProcessNotify = true;
	}
	else {
		DbgPrint(DRIVER_PREFIX "failed to register process callback (0x%08X)\n", status);
		return status;
	}

	status = PsSetCreateThreadNotifyRoutine(OnThreadNotify);
	if (NT_SUCCESS(status)) {
		g_Settings.hasThreadNotify = true;
	}
	else {
		DbgPrint(DRIVER_PREFIX "failed to set thread callback (status=%08X)\n", status);
		return status;
	}

	status = PsSetLoadImageNotifyRoutine(OnImageLoadNotify);
	if (NT_SUCCESS(status)) {
		g_Settings.hasImageNotify = true;
	}
	else {
		DbgPrint(DRIVER_PREFIX "failed to set image notify callback (status=%08X)\n", status);
		return status;
	}
	return STATUS_SUCCESS;
}

///

extern "C"
NTSTATUS
DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) 
{
	UNREFERENCED_PARAMETER(RegistryPath);

	// check version:
	RTL_OSVERSIONINFOW version = { 0 };
	RtlGetVersion(&version);
	DbgPrint(DRIVER_PREFIX "OS Version: %d.%d.%d\n", version.dwMajorVersion, version.dwMinorVersion, version.dwBuildNumber);
	DbgPrint(DRIVER_PREFIX "Driver Version: %s\n", VER_FILEVERSION_STR);

	if (!RtlIsNtDdiVersionAvailable(NTDDI_WIN7)) {
		DbgPrint(DRIVER_PREFIX "Windows < 7 is not supported!\n");
		return STATUS_NOT_SUPPORTED;
	}

	// init all global data:
	g_Settings.init();

	if (!Data::AllocGlobals()) {
		DbgPrint(DRIVER_PREFIX "Failed to initialize global data structures\n");
		return STATUS_FATAL_MEMORY_EXHAUSTION;
	}
	else {
		KdPrint((DRIVER_PREFIX "Initialized global data structures!\n"));
	}

	//
	//  Register with FltMgr to tell it our callback routines
	//
	NTSTATUS status = FltRegisterFilter(DriverObject,
		&FilterRegistration,
		&g_Settings.gFilterHandle);

	FLT_ASSERT(NT_SUCCESS(status));

	if (NT_SUCCESS(status)) {
		status = FltStartFiltering(g_Settings.gFilterHandle);
	}
	if (!NT_SUCCESS(status)) {
		MyDriverUnload(DriverObject);
		return status;
	}

	status = RegisterCallbacks(DriverObject);
	if (!NT_SUCCESS(status)) {
		MyDriverUnload(DriverObject);
		return status;
	}

	DriverObject->DriverUnload = MyDriverUnload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = HandleCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = HandleCreateClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = HandleDeviceControl;

	KdPrint((DRIVER_PREFIX "driver loaded!\n"));

	status = _InitializeDriver(DriverObject);
	if (NT_SUCCESS(status)) {
		DbgPrint(DRIVER_PREFIX "DriverEntry completed successfully\n");
	}
	else {
		MyDriverUnload(DriverObject);
	}
	return status;
}

```

`MalUnpackCompanion/main.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include <fltKernel.h>

#include "version.h"
#include "common.h"

typedef struct _active_settings {

	bool hasDevice;
	bool hasLink;
	bool hasProcessNotify;
	bool hasThreadNotify;
	bool hasImageNotify;
	PVOID RegHandle;
	LARGE_INTEGER RegCookie;
	PFLT_FILTER gFilterHandle;

	void init()
	{
		hasDevice = false;
		hasLink = false;
		hasProcessNotify = false;
		hasThreadNotify = false;
		hasImageNotify = false;
		RegHandle = NULL;
		RegCookie.QuadPart = 0;
		gFilterHandle = NULL;
	}
} active_settings;

```

`MalUnpackCompanion/process_data_struct.cpp`:

```cpp
#include "process_data_struct.h"

bool ProcessNode::_containsFile(LONGLONG fileId)
{
	if (!filesList) return false;
	return filesList->containsItem(fileId);
}

bool ProcessNode::_isDeadNode()
{
	if (!processList) return true;
	return (processList->containsItem(rootPid)) ? false : true;
}

bool ProcessNode::_isEmptyNode()
{
	if (!_isDeadNode() || _countProcesses() > 0) {
		return false;
	}
	// all processes terminated, don't check for files:
	if (respawnProtect == t_noresp::NORESP_NO_RESTRICTION) {
		return true;
	}
	const int filesCount = _countFiles();
	if (filesCount == 0) {
		return true;
	}
	// allow for the initial file to still exist:
	if (respawnProtect == t_noresp::NORESP_DROPPED_FILES) {
		if (filesCount == 1) {
			if (imgFile != FILE_INVALID_FILE_ID && _containsFile(imgFile)) {
				return true;
			}
		}
	}
	return false;
}

bool ProcessNode::_containsProcess(ULONG pid)
{
	if (!processList) return false;
	return processList->containsItem(pid);
}

bool ProcessNode::_canAddFile()
{
	if (_isDeadNode()) {
		// the root process terminated, do not allow to add more files to the list
		return false;
	}
	if (!filesList) {
		if (!_initItems()) {
			return false;
		}
	}
	return filesList->canAddItem();
}

t_add_status ProcessNode::_addFile(LONGLONG fileId)
{
	if (_isDeadNode()) {
		// the root process terminated, do not allow to add more files to the list
		return ADD_LIMIT_EXHAUSTED;
	}
	if (!filesList) {
		if (!_initItems()) {
			return ADD_UNINITIALIZED;
		}
	}
	return filesList->addItem(fileId);
}

t_add_status ProcessNode::_addProcess(ULONG pid)
{
	if (!processList) {
		if (!_initItems()) {
			return ADD_UNINITIALIZED;
		}
	}
	if (pid != rootPid) {
		if (_isDeadNode()) {
			// the root process terminated, do not allow to add more processes to this list
			return ADD_LIMIT_EXHAUSTED;
		}
	}
	return processList->addItem(pid);
}

int ProcessNode::_countProcesses()
{
	if (!processList) return 0;
	return processList->countItems();
};

int ProcessNode::_countFiles()
{
	if (!filesList) return 0;
	return filesList->countItems();
}

bool ProcessNode::_deleteProcess(ULONG pid)
{
	if (!processList) return false;
	return processList->deleteItem(pid);
}

bool ProcessNode::_deleteFile(LONGLONG fileId)
{
	if (!filesList) return false;
	return filesList->deleteItem(fileId);
}

size_t ProcessNode::_copyProcessList(void* data, size_t outBufSize)
{
	if (!processList) return 0;
	return processList->copyItems(data, outBufSize);
}

size_t ProcessNode::_copyFilesList(void* data, size_t outBufSize)
{
	if (!filesList) return 0;
	return filesList->copyItems(data, outBufSize);
}

```

`MalUnpackCompanion/process_data_struct.h`:

```h
#pragma once
#include "data_structs.h"
#include "common.h"

#ifndef FILE_INVALID_FILE_ID
	#define FILE_INVALID_FILE_ID               ((LONGLONG)-1LL) 
#endif

struct ProcessNode
{
	friend struct ProcessNodesList;

protected:
	ULONG rootPid;
	LONGLONG imgFile;
	ItemsList<ULONG> *processList;
	ItemsList<LONGLONG> *filesList;
	t_noresp respawnProtect;

	void _init(ULONG _pid, t_noresp _respawnProtect, LONGLONG _imgFile)
	{
		processList = NULL;
		filesList = NULL;
		rootPid = _pid;
		imgFile = _imgFile;
		respawnProtect = _respawnProtect;
	}

	bool _initItems()
	{
		if (!processList) {
			processList = AllocBuffer<ItemsList<ULONG> >();
			if (!processList) {
				_destroy();
				DbgPrint(DRIVER_PREFIX "Failed to initialize processList!\n");
				return false;
			}
		}
		if (!filesList) {
			filesList = AllocBuffer<ItemsList<LONGLONG> >();
			if (!filesList) {
				_destroy();
				DbgPrint(DRIVER_PREFIX "Failed to initialize filesList!\n");
				return false;
			}
		}
		processList->init();
		if (!processList->initItems()) {
			DbgPrint(DRIVER_PREFIX "Failed to initialize processList items!\n");
			_destroy();
			return false;
		}
		filesList->init();
		if (!filesList->initItems()) {
			DbgPrint(DRIVER_PREFIX "Failed to initialize filesList items!\n");
			_destroy();
			return false;
		}
		DbgPrint(DRIVER_PREFIX "ProcessNode: initialized lists!\n");
		return true;
	}

	void _destroy()
	{
		if (processList) {
			processList->destroy();
			FreeBuffer(processList);
			processList = NULL;
		}
		if (filesList) {
			filesList->destroy();
			FreeBuffer(filesList);
			filesList = NULL;
		}
		rootPid = 0;
		imgFile = FILE_INVALID_FILE_ID;
		respawnProtect = t_noresp::NORESP_NO_RESTRICTION;
	}

	bool _copy(const ProcessNode& node)
	{
		::memcpy(this, &node, sizeof(ProcessNode));
		return true;
	}

	// check if the root process terminated
	bool _isDeadNode();

	bool _isEmptyNode();

	bool _containsFile(LONGLONG fileId);

	bool _containsProcess(ULONG pid);

	bool _canAddFile();

	t_add_status _addFile(LONGLONG fileId);

	t_add_status _addProcess(ULONG pid);

	int _countProcesses();

	int _countFiles();

	bool _deleteProcess(ULONG pid);

	bool _deleteFile(LONGLONG);

	size_t _copyProcessList(void* data, size_t outBufSize);

	size_t _copyFilesList(void* data, size_t outBufSize);

};

//---

struct ProcessNodesList
{
public:
	void init()
	{
		Items = 0;
		MaxItemCount = 0;
		ItemCount = 0;
		Mutex.Init();
		deletionEvent.Init();
	}

	bool initItems(int maxNum = MAX_ITEMS)
	{
		AutoLock<FastMutex> lock(Mutex);
		if (Items) {
			return true;
		}
		ItemCount = 0;
		Items = AllocBuffer<ProcessNode>(maxNum + 1);
		if (Items != NULL) {
			MaxItemCount = maxNum;
			return true;
		}
		return false;
	}

	bool destroy()
	{
		AutoLock<FastMutex> lock(Mutex);
		if (Items) {
			_destroyItems();
			FreeBuffer<ProcessNode>(Items, MaxItemCount);
			ItemCount = 0;
			MaxItemCount = 0;
			Items = NULL;
			return true;
		}
		return false;
	}

	t_add_status AddProcess(ULONG pid, ULONG parentPid)
	{
		if (0 == pid) {
			return ADD_INVALID_ITEM;
		}
		if (0 == parentPid) {
			return ADD_NO_PARENT;
		}
		AutoLock<FastMutex> lock(Mutex);
		return _addToExistingTree(pid, parentPid);
	}

	t_add_status AddProcessNode(ULONG pid, LONGLONG imgFile, t_noresp respawnProtect)
	{
		if (0 == pid) {
			return ADD_INVALID_ITEM;
		}
		AutoLock<FastMutex> lock(Mutex);
		if (_ContainsProcess(pid)) {
			return ADD_FORBIDDEN;
		}
		return _createNewProcessNode(pid, imgFile, respawnProtect);
	}

	bool CanAddFile(ULONG parentPid)
	{
		if (0 == parentPid) {
			return false;
		}

		AutoLock<FastMutex> lock(Mutex);
		if (_CanAddFile(parentPid) == ADD_OK) {
			return true;
		}
		return false;
	}

	inline bool _DestroyNodeIfEmpty(int i)
	{
		ProcessNode& n = Items[i];
		if (!n._isEmptyNode()) {
			return false;
		}
		n._destroy();
		//rewrite the last element on the place of the current:
		if (ItemCount > 1) {
			Items[i]._copy(Items[ItemCount - 1]);
		}
		ItemCount--;
		return true;
	}

	t_add_status AddFile(LONGLONG fileId, ULONG parentPid)
	{
		if (0 == parentPid || FILE_INVALID_FILE_ID == fileId) {
			return ADD_INVALID_ITEM;
		}

		AutoLock<FastMutex> lock(Mutex);

		t_add_status canAddStatus = _CanAddFile(parentPid);
		if (canAddStatus == ADD_NO_PARENT) {
			return ADD_INVALID_ITEM;
		}

		if (canAddStatus != ADD_OK) {
			return canAddStatus;
		}
		// if this file belongs to a dead node, delete the association first:
		const t_delete_status delStatus = _deletePreviousFileAssociation(fileId, parentPid);
		if (delStatus == DELETE_FORBIDDEN) {
			return ADD_FORBIDDEN;
		}

		// add the file to the process:
		return _addFile(fileId, parentPid);
	}

	t_add_status AddProcessToFileOwner(ULONG PID, LONGLONG fileId)
	{
		if (0 == PID || FILE_INVALID_FILE_ID == fileId) {
			return ADD_INVALID_ITEM;
		}

		AutoLock<FastMutex> lock(Mutex);

		t_add_status status = ADD_INVALID_ITEM;
		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsFile(fileId)) {
				status = n._addProcess(PID);
				break;
			}
		}
		return status;
	}

	bool IsProcessInFileOwners(ULONG PID, LONGLONG fileId)
	{
		if (0 == PID || FILE_INVALID_FILE_ID == fileId) {
			return false;
		}

		AutoLock<FastMutex> lock(Mutex);
		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsFile(fileId)) {
				if (n._containsProcess(PID)) {
					return true;
				}
				return false;
			}
		}
		return false;
	}

	bool DeleteProcess(ULONG pid)
	{
		if (0 == pid) return false;

		AutoLock<FastMutex> lock(Mutex);

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsProcess(pid)) {
				if (n._deleteProcess(pid)) {
					if (n._isDeadNode()) {
						deletionEvent.SetEvent();
					}
					_DestroyNodeIfEmpty(i);
					return true;
				}
			}
		}
		return false;
	}

	bool DeleteFile(LONGLONG fileId)
	{
		if (FILE_INVALID_FILE_ID == fileId) return false;

		AutoLock<FastMutex> lock(Mutex);

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsFile(fileId)) {
				if (n._deleteFile(fileId)) {
					_DestroyNodeIfEmpty(i);
					return true;
				}
			}
		}
		return false;
	}

	size_t CopyProcessList(ULONG parentPid, void* data, size_t outBufSize)
	{
		if (0 == parentPid) return 0;

		AutoLock<FastMutex> lock(Mutex);

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n.rootPid == parentPid) {
				return n._copyProcessList(data, outBufSize);
			}
		}
		return 0;
	}

	size_t CopyFilesList(ULONG parentPid, void* data, size_t outBufSize)
	{
		if (0 == parentPid) return 0;

		AutoLock<FastMutex> lock(Mutex);

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n.rootPid == parentPid) {
				return n._copyFilesList(data, outBufSize);
			}
		}
		return 0;
	}

	int CountProcesses(ULONG parentPid)
	{
		if (0 == parentPid) return 0;

		AutoLock<FastMutex> lock(Mutex);

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n.rootPid == parentPid) {
				return n._countProcesses();
			}
		}
		return 0;
	}

	int CountNodes()
	{
		AutoLock<FastMutex> lock(Mutex);
		return ItemCount;
	}

	ULONG GetFileOwner(LONGLONG fileId)
	{
		if (FILE_INVALID_FILE_ID == fileId) return 0;

		AutoLock<FastMutex> lock(Mutex);

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsFile(fileId)) {
				return n.rootPid;
			}
		}
		return 0;
	}

	ULONG GetProcessOwner(ULONG pid)
	{
		if (0 == pid) return 0;

		AutoLock<FastMutex> lock(Mutex);

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsProcess(pid)) {
				return n.rootPid;
			}
		}
		return 0;
	}

	bool AreSameFamily(ULONG pid1, ULONG pid2)
	{
		if (pid1 == 0 || pid2 == 0) {
			return false;
		}

		AutoLock<FastMutex> lock(Mutex);

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsProcess(pid1)) {
				if (n._containsProcess(pid2)) {
					return true;
				}
				else {
					return false;
				}
			}
		}
		return false;
	}

	bool ContainsProcess(ULONG pid1)
	{
		if (0 == pid1) return false;

		AutoLock<FastMutex> lock(Mutex);
		return _ContainsProcess(pid1);
	}

	NTSTATUS WaitForProcessDeletion(ULONG pid, PLARGE_INTEGER checkInterval)
	{
		if (0 == pid) return STATUS_INVALID_PARAMETER;

		LONGLONG waitTime = (checkInterval) ? checkInterval->QuadPart : 0;
		bool isRoot = false;

		ULONG ownerPID = 0;
		while ((ownerPID = GetProcessOwner(pid)) == pid) {
			// if the given PID is a root, don't let it terminate without permission
			isRoot = true;

			DbgPrint(DRIVER_PREFIX "[%d] " __FUNCTION__ ": process requested terminate, waitTime: %zx (owner: %d, remaining children: %d)\n", pid, waitTime, pid, CountProcesses(pid));
			deletionEvent.ResetEvent();
			deletionEvent.WaitForEventSet(checkInterval);
		}
		if (isRoot) {
			DbgPrint(DRIVER_PREFIX "[%d] " __FUNCTION__ ": root process termination permitted!\n", pid, waitTime, pid);
		}

		if (ownerPID != 0) {
			// the process is still on the list, so delete it
			// this may happen in case of a child process that is terminating on its own
			DbgPrint(DRIVER_PREFIX "[%d] " __FUNCTION__ ": child process termination permitted!\n", pid, waitTime, pid);
			DeleteProcess(pid);
		}
		return STATUS_SUCCESS;
	}

private:

	ProcessNode* Items;
	int ItemCount;
	int MaxItemCount;
	FastMutex Mutex;
	Event deletionEvent;


	bool _ContainsProcess(ULONG pid1)
	{
		if (0 == pid1) return false;

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsProcess(pid1)) {
				return true;
			}
		}
		return false;
	}

	t_add_status _CanAddFile(ULONG parentPid)
	{
		if (0 == parentPid) {
			return ADD_INVALID_ITEM;
		}
		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsProcess(parentPid)) {
				if (n._canAddFile()) {
					return ADD_OK;
				}
				return ADD_LIMIT_EXHAUSTED;
			}
		}
		return ADD_NO_PARENT;
	}

	t_add_status _addFile(LONGLONG fileId, ULONG parentPid)
	{
		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsProcess(parentPid)) {
				return n._addFile(fileId);
			}
		}
		return ADD_INVALID_ITEM;
	}

	typedef enum {
		DELETE_OK = 0,
		DELETE_NOT_FOUND,
		DELETE_INVALID_ITEM,
		DELETE_FORBIDDEN,
		DELETE_EXCLUDED,
		DELETE_STATES_COUNT
	} t_delete_status;

	t_delete_status _deletePreviousFileAssociation(LONGLONG fileId, ULONG excludedPid)
	{
		if (FILE_INVALID_FILE_ID == fileId) {
			return DELETE_INVALID_ITEM;
		}

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			// this file belongs to a dead node, delete the association first:
			if (n._containsFile(fileId)) {
				if (n._isDeadNode() && n._countProcesses() == 0) {
					n._deleteFile(fileId);
					_DestroyNodeIfEmpty(i);
					return DELETE_OK;
				}
				if (excludedPid && n._containsProcess(excludedPid)) {
					return DELETE_EXCLUDED; // file found in the excluded process, so deleting is not required
				}
				//this process tree is not dead
				return DELETE_FORBIDDEN;
			}
		}
		return DELETE_NOT_FOUND;
	}


	t_add_status _createNewProcessNode(ULONG pid, LONGLONG imgFile, t_noresp respawnProtect)
	{
		//create a new node for the process:
		ProcessNode* newItem = _getNewItemPtr();
		if (!newItem) {
			return ADD_LIMIT_EXHAUSTED;
		}

		newItem->_init(pid, respawnProtect, imgFile);

		//add root process to the list:
		const t_add_status status = newItem->_addProcess(pid);
		if (status == ADD_OK) {
			return ADD_OK;
		}
		newItem->_destroy();
		ItemCount--;
		return ADD_LIMIT_EXHAUSTED;
	}

	t_add_status _addToExistingTree(ULONG pid, ULONG parentPid)
	{
		if (0 == pid) {
			return ADD_INVALID_ITEM;
		}
		if (0 == parentPid) {
			return ADD_NO_PARENT;
		}

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n.rootPid == parentPid) {
				return n._addProcess(pid);
			}
		}

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			if (n._containsProcess(parentPid)) {
				return n._addProcess(pid);
			}
		}
		
		// this no parent tree found for such process
		return ADD_NO_PARENT;
	}

	bool _destroyItems()
	{
		if (!Items) return false;

		for (int i = 0; i < ItemCount; i++)
		{
			ProcessNode& n = Items[i];
			n._destroy();
		}
		deletionEvent.SetEvent();
		return true;
	}

	ProcessNode* _getNewItemPtr()
	{
		if (ItemCount >= MaxItemCount) {
			return nullptr;
		}
		ProcessNode* item = &Items[ItemCount];
		ItemCount++;
		return item;
	}

};


```

`MalUnpackCompanion/process_util.cpp`:

```cpp
#include "process_util.h"
#include "data_structs.h"
#include "common.h"
#include "util.h"

namespace ProcessUtil {


	NTSTATUS RetrieveProcessHandle(const PEPROCESS Process, bool& isCurrentProcess, HANDLE& hProcess)
	{
		NTSTATUS status = STATUS_SUCCESS;
		isCurrentProcess = PsGetCurrentProcess() == Process;
		hProcess = NULL;
		if (isCurrentProcess) {
			hProcess = NtCurrentProcess();
		}
		else {
			status = ObOpenObjectByPointer(Process, OBJ_KERNEL_HANDLE, nullptr, 0, nullptr, KernelMode, &hProcess);
		}
		return status;
	}

};

bool ProcessUtil::CheckProcessPath(const PEPROCESS Process, PWCH supportedName)
{
	bool isCurrentProcess = false;
	HANDLE hProcess = NULL;
	NTSTATUS status = ProcessUtil::RetrieveProcessHandle(Process, isCurrentProcess, hProcess);
	if (!NT_SUCCESS(status)) {
		return false;
	}

	bool allowAccess = false;
	ULONG size = 300;
	UNICODE_STRING* processName = (UNICODE_STRING*)ExAllocatePoolWithTag(PagedPool, size, DRIVER_TAG);

	if (processName) {
		RtlZeroMemory(processName, size); // ensure string will be NULL-terminated
		status = ZwQueryInformationProcess(hProcess, ProcessImageFileName, processName, size - sizeof(WCHAR), nullptr);
		if (NT_SUCCESS(status)) {
			allowAccess = Util::hasSuffix(processName, supportedName);
		}
		ExFreePool(processName);
	}
	if (!isCurrentProcess) {
		ZwClose(hProcess);
	}
	if (!allowAccess) {
		DbgPrint(DRIVER_PREFIX "Access to the driver denied to the process: %wZ!\n", processName);
	}
	return allowAccess;
}

bool ProcessUtil::ShowProcessPath(const PEPROCESS Process)
{
	bool isCurrentProcess = false;
	HANDLE hProcess = NULL;
	NTSTATUS status = ProcessUtil::RetrieveProcessHandle(Process, isCurrentProcess, hProcess);
	if (!NT_SUCCESS(status)) {
		return false;
	}

	bool found = false;
	ULONG size = 300;
	UNICODE_STRING* processName = (UNICODE_STRING*)ExAllocatePoolWithTag(PagedPool, size, DRIVER_TAG);

	if (processName) {
		RtlZeroMemory(processName, size);	// ensure string will be NULL-terminated
		status = ZwQueryInformationProcess(hProcess, ProcessImageFileName, processName, size - sizeof(WCHAR), nullptr);
		if (NT_SUCCESS(status)) {
			DbgPrint(DRIVER_PREFIX "Process name: %wZ!\n", processName);
			found = true;
		}
		ExFreePool(processName);
	}
	if (!isCurrentProcess) {
		ZwClose(hProcess);
	}
	return found;
}

NTSTATUS SetProcessNonCritical(HANDLE hProcess)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	__try
	{
		ULONG IsCritical = 0;
		status = ZwSetInformationProcess(hProcess, ProcessBreakOnTermination, &IsCritical, sizeof(ULONG));
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		status = GetExceptionCode();
	}
	return status;
}

NTSTATUS ProcessUtil::TerminateProcess(ULONG PID)
{
	NTSTATUS status = STATUS_SUCCESS;
	DbgPrint(DRIVER_PREFIX "Terminating process: %d\n", PID);

	OBJECT_ATTRIBUTES ObjectAttributes;
	InitializeObjectAttributes(&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

	CLIENT_ID ClientId;
	ClientId.UniqueProcess = (HANDLE)PID;
	ClientId.UniqueThread = NULL;

	HANDLE hProcess;
	status = ZwOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &ObjectAttributes, &ClientId);
	if (NT_SUCCESS(status))
	{
		if (SetProcessNonCritical(hProcess)) {
			DbgPrint(DRIVER_PREFIX "SetProcessNonCritical failed with status : %X\n", status);
		}
		status = ZwTerminateProcess(hProcess, 0);
		//the terminate operation is already pending
		if (status == STATUS_PROCESS_IS_TERMINATING) {
			status = STATUS_SUCCESS;
			DbgPrint(DRIVER_PREFIX "The terminate operation is already pending\n", status);
		}
		if (!NT_SUCCESS(status)) {
			DbgPrint(DRIVER_PREFIX "ZwTerminateProcess failed with status : %X\n", status);
		}
		ZwClose(hProcess);
	}
	else {
		DbgPrint(DRIVER_PREFIX "ZwOpenProcess failed with status : %08X\n", status);
	}

	return status;
}

ULONG ProcessUtil::GetProcessParentPID(const PEPROCESS Process)
{
	bool isCurrentProcess = false;
	HANDLE hProcess = NULL;
	NTSTATUS status = ProcessUtil::RetrieveProcessHandle(Process, isCurrentProcess, hProcess);
	if (!NT_SUCCESS(status)) {
		return false;
	}

	ULONG_PTR parentPID = 0;
	__try
	{
		PROCESS_BASIC_INFORMATION pBasicInfo = { 0 };

		ULONG retrunLen = 0;
		const ULONG size = sizeof(PROCESS_BASIC_INFORMATION);
		status = ZwQueryInformationProcess(hProcess, ProcessBasicInformation, &pBasicInfo, size, &retrunLen);
		if (NT_SUCCESS(status) && (retrunLen == size)) {
			parentPID = pBasicInfo.InheritedFromUniqueProcessId;
			//DbgPrint(DRIVER_PREFIX "Process ParentID retrieved : [%p]\n", parentPID);
		}
		if (!isCurrentProcess) {
			ZwClose(hProcess);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint(DRIVER_PREFIX __FUNCTION__"failed with an exception");
	}
	return ULONG(parentPID);
}

```

`MalUnpackCompanion/process_util.h`:

```h
#pragma once

#include "undoc_api.h"

namespace ProcessUtil {

    bool CheckProcessPath(const PEPROCESS Process, PWCH supportedName);

    bool ShowProcessPath(const PEPROCESS Process);

    ULONG GetProcessParentPID(const PEPROCESS Process);

    NTSTATUS TerminateProcess(ULONG PID);
};


```

`MalUnpackCompanion/undoc_api.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>

extern "C" NTSTATUS ZwQueryInformationProcess(
	_In_      HANDLE           ProcessHandle,
	_In_      PROCESSINFOCLASS ProcessInformationClass,
	_Out_     PVOID            ProcessInformation,
	_In_      ULONG            ProcessInformationLength,
	_Out_opt_ PULONG           ReturnLength
);

extern "C" NTSTATUS ZwSetInformationProcess(
	_In_      HANDLE           ProcessHandle,
	_In_      PROCESSINFOCLASS ProcessInformationClass,
	_Out_     PVOID            ProcessInformation,
	_In_      ULONG            ProcessInformationLength
);


```

`MalUnpackCompanion/util.h`:

```h
#pragma once

namespace Util {

	inline bool hasSuffix(UNICODE_STRING* targetStr, PWCH searchedSuffix)
	{
		if (!searchedSuffix || !targetStr || !targetStr->Length) {
			return false;
		}
		bool suffixFound = false;
		const wchar_t* found = ::wcsstr(targetStr->Buffer, searchedSuffix);
		while (found != nullptr) {
			if (::wcscmp(found, searchedSuffix) == 0) {
				suffixFound = true;
				break;
			}
		}
		return suffixFound;
	}

};

```

`MalUnpackCompanion/version.h`:

```h
#pragma once

#define VER_FILEVERSION             0,1,1,16
#define VER_FILEVERSION_STR         "0.1.1.16-rc1\0"

```

`README.md`:

```md
# MalUnpackCompanion driver

[![Commit activity](https://img.shields.io/github/commit-activity/m/hasherezade/mal_unpack_drv)](https://github.com/hasherezade/mal_unpack_drv/commits)
[![Last Commit](https://img.shields.io/github/last-commit/hasherezade/mal_unpack_drv/main)](https://github.com/hasherezade/mal_unpack_drv/commits)

[![GitHub release](https://img.shields.io/github/release/hasherezade/mal_unpack_drv.svg)](https://github.com/hasherezade/mal_unpack_drv/releases)
[![GitHub release date](https://img.shields.io/github/release-date/hasherezade/mal_unpack_drv?color=blue)](https://github.com/hasherezade/mal_unpack_drv/releases)
[![Github All Releases](https://img.shields.io/github/downloads/hasherezade/mal_unpack_drv/total.svg)](https://github.com/hasherezade/mal_unpack_drv/releases)
[![Github Latest Release](https://img.shields.io/github/downloads/hasherezade/mal_unpack_drv/latest/total.svg)](https://github.com/hasherezade/mal_unpack_drv/releases)

[![License](https://img.shields.io/badge/License-BSD%202--Clause-blue.svg)](https://github.com/hasherezade/mal_unpack_drv/blob/main/LICENSE)
[![Platform Badge](https://img.shields.io/badge/Windows-0078D6?logo=windows)](https://github.com/hasherezade/mal_unpack_drv)

MalUnpack companion driver: enhances capabilities of [mal_unpack](https://github.com/hasherezade/mal_unpack), isolates the run sample from the environment.

Works with: https://github.com/hasherezade/mal_unpack


Supported systems: Windows, starting from 7. Recommended system: Windows 10.

**WARNING: This is an experimental version, use it on a Virtual Machine only!**

## How to install


1. The driver is signed by a test signature, so, in order for the installation to succeed, Test Signing must be enabled on the target machine. As an Administrator, deploy the following command:

```
bcdedit /set testsigning on
```

Then reboot the system...

2. Right click on `MalUnpackCompanion.inf` from the driver package. From the context menu, choose "Install"
3. After the driver is installed, it remains inactive. In order to activate it, run the following command as Administrator:
```
fltmc load MalUnpackCompanion
```

## How to unload

Run the commandline as Administrator. Deploy the command:
```
fltmc unload MalUnpackCompanion
```

##  How to update

1. Unload the driver (check [How to unload](https://github.com/hasherezade/mal_unpack_drv/blob/main/README.md#how-to-unload))
2. Repeat the installation steps 2 to 3 (check [How to install](https://github.com/hasherezade/mal_unpack_drv/blob/main/README.md#how-to-install))

## Confirm that the driver is loaded

#### Option 1.

Run the commandline as Administrator. Deploy the command:
```
fltmc
```
You should see `MalUnpackCompanion` on the list of installed filter drivers.

#### Option 2.

Install Nirsoft DriversList (available [here](https://www.nirsoft.net/utils/installed_drivers_list.html)). Check if `MalUnpackCompanion` is on the list, and if it is running. This tool allows you also to easily check the version of the currently installed driver.

How to use
---

Download the [`mal_unpack`](https://github.com/hasherezade/mal_unpack) userland application, and use it as it is mentioned in the instructions. If the `MalUnpackCompanion` driver is installed and loaded, the userland application will detect it automatically, and communicate with it.


```