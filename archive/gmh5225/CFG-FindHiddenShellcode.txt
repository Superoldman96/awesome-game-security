Project Path: arc_gmh5225_CFG-FindHiddenShellcode_lbijq61k

Source Tree:

```txt
arc_gmh5225_CFG-FindHiddenShellcode_lbijq61k
├── CFG-FindHiddenShellcode.filters
├── CFG-FindHiddenShellcode.sln
├── CFG-FindHiddenShellcode.vcxproj
├── README.md
├── findhiddenshellcode.png
├── helpers.cpp
└── main.cpp

```

`CFG-FindHiddenShellcode.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`CFG-FindHiddenShellcode.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32630.194
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CFG-FindHiddenShellcode", "CFG-FindHiddenShellcode.vcxproj", "{6306F63E-8CCD-450C-938D-D489F80A5643}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6306F63E-8CCD-450C-938D-D489F80A5643}.Debug|x64.ActiveCfg = Debug|x64
		{6306F63E-8CCD-450C-938D-D489F80A5643}.Debug|x64.Build.0 = Debug|x64
		{6306F63E-8CCD-450C-938D-D489F80A5643}.Release|x64.ActiveCfg = Release|x64
		{6306F63E-8CCD-450C-938D-D489F80A5643}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F5D3CCFD-44EA-4829-AB4E-B61235D35239}
	EndGlobalSection
EndGlobal

```

`CFG-FindHiddenShellcode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{6306f63e-8ccd-450c-938d-d489f80a5643}</ProjectGuid>
    <RootNamespace>CFG-FindHiddenShellcode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="helpers.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`README.md`:

```md

![screenshot](findhiddenshellcode.png)

## Detection of hidden shellcode via CFG bitmap anomalies

1. Memory scanners can only reasonably scan executable memory regions.
1. The kernel memory manager only stores the original protection and the current protection in the Virtual Address Descriptor (VAD) tree.

[Gargoyle](https://lospi.net/security/assembly/c/cpp/developing/software/2017/03/04/gargoyle-memory-analysis-evasion.html) and similiar techniques use these facts and periodically toggle their memory protection to non-executable to hide from memory scanners.

However, [Gabriel Landau](https://twitter.com/GabrielLandau) observed that the Control Flow Guard (CFG) bitmap is only updated whenever a region is marked executable, and specifically that it is not updated when a region is marked non-executable. 
This means that the CFG bitmap (inadvertently) records the location of all private memory addresses that are, **or have previously been**, executable during the lifetime of the process.

This can be used to flag memory regions in CFG-enabled processes that have been changed from executable to non-executable. This makes protection fluctuation stand out beautifully in most host processes.

See [[Black Hat Asia 2023] You Can Run, but You Can't Hide - Finding the Footprints of Hidden Shellcode](https://www.blackhat.com/asia-23/briefings/schedule/index.html#you-can-run-but-you-cant-hide---finding-the-footprints-of-hidden-shellcode-31237) for more details.

#### Related Work
 * https://www.elastic.co/security-labs/get-injectedthreadex-detection-thread-creation-trampolines - detection of thread creation gadgets via CFG bitmap state

```

`helpers.cpp`:

```cpp
#include <Windows.h>
#include <Psapi.h>

#include <string>

// This return the address of PS_SYSTEM_DLL_INIT_BLOCK.CfgBitMap
// https://github.com/processhacker/processhacker/blob/4187c48f24cbf0ad0a0a955c53775b2bd0e49a16/phnt/include/ntldr.h#L618
PVOID GetCfgBitmapPointer()
{
    PVOID pCfgBitmap = NULL;

    // PS_SYSTEM_DLL_INIT_BLOCK is exported from ntdll as LdrSystemDllInitBlock, but the structure itself is not documented
    // and the offset has changed previously.
    // We could hardcode offsets, or bruteforce this block looking for a pointer that matches the expected 2TB MEM_MAPPED
    // region characteristics.
    // However, the first instruction of LdrControlFlowGuardEnforced is usually -
    //   48 83 xx xx xx xx 00 00  cmp PS_SYSTEM_DLL_INIT_BLOCK.CfgBitMap, 0
    // So we can calculate the absolute address from the rel32 offset in this instruction.
    PVOID pLdrControlFlowGuardEnforced = GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "LdrControlFlowGuardEnforced");
    if (!pLdrControlFlowGuardEnforced)
        return NULL;

    PUCHAR Rip = (PUCHAR)pLdrControlFlowGuardEnforced + 8;
    PDWORD pRipRelativeOffset = (PDWORD)((PUCHAR)pLdrControlFlowGuardEnforced + 3);
    DWORD RipRelativeOffset = 0;
    SIZE_T szBytesRead = 0;
    if (!ReadProcessMemory(GetCurrentProcess(), pRipRelativeOffset, &RipRelativeOffset, sizeof(RipRelativeOffset), &szBytesRead))
        return NULL;

    return Rip + RipRelativeOffset;
}

PULONG_PTR GetCfgBitmap(HANDLE hProcess)
{
    static PVOID ppCfgBitmap = GetCfgBitmapPointer();
    PULONG_PTR pCfgBitmap = NULL;
    MEMORY_BASIC_INFORMATION mbi{};
    SIZE_T szBytesRead = 0;
    if (!ppCfgBitmap ||
        !ReadProcessMemory(hProcess, ppCfgBitmap, &pCfgBitmap, sizeof(pCfgBitmap), &szBytesRead) ||
        (0 == pCfgBitmap) ||
        !VirtualQueryEx(hProcess, pCfgBitmap, &mbi, sizeof(mbi)))
    {
        return NULL;
    }

    // Quick sanity check that our CFG bitmap pointer is the base of a MEM_MAPPED allocation.
    // We could also validate that it is 2TB in size.
    if ((mbi.AllocationBase != pCfgBitmap) || (MEM_MAPPED != mbi.Type))
    {
        printf("%p PS_SYSTEM_DLL_INIT_BLOCK.CfgBitMap = %p is invalid\n", ppCfgBitmap, pCfgBitmap);
        pCfgBitmap = NULL;
    }

    return pCfgBitmap;
}

const char *TypeString(MEMORY_BASIC_INFORMATION* pMbi)
{
    switch (pMbi->Type)
    {
    case MEM_PRIVATE:
        return "MEM_PRIVATE";
    case MEM_MAPPED:
        return "MEM_MAPPED";
    case MEM_IMAGE:
        return "MEM_IMAGE";
    }

    if (pMbi->State == MEM_FREE)
        return "MEM_FREE";

    return "<ERROR>";
};

const char *ProtectionString(DWORD protection, DWORD state)
{
    if (state == MEM_RESERVE)
        return "MEM_RESERVE";

    switch (protection)
    {
    case PAGE_EXECUTE:
        return "--X";
    case PAGE_EXECUTE_READ:
        return "R-X";
    case PAGE_EXECUTE_WRITECOPY:
        return "RCX";
    case PAGE_EXECUTE_READWRITE:
        return "RWX";
    case PAGE_READWRITE:
        return "RW-";
    case PAGE_READONLY:
        return "R--";
    case PAGE_WRITECOPY:
        return "RC-";
    case PAGE_NOACCESS:
        return "---";
    }

    return "<ERROR>";
};
```

`main.cpp`:

```cpp
#include <stdio.h>
#include <Windows.h>

#include <Psapi.h>
#include <tlhelp32.h>
#include <assert.h>

#include <string>
#include <vector>

PULONG_PTR GetCfgBitmap(HANDLE hProcess);
const char* TypeString(MEMORY_BASIC_INFORMATION* pMbi);
const char* ProtectionString(DWORD protection, DWORD state);

SYSTEM_INFO g_sysinfo{};

constexpr auto PAGE_EXECUTE_FLAGS = PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY;
constexpr unsigned int CFG_INDEX_SHIFT = 9;

std::vector<PVOID> GetProcessPreviouslyExecutableRegions(HANDLE hProcess, bool bAggressive=false)
{
    std::vector<PVOID> result;

    MEMORY_BASIC_INFORMATION mbi{};
    MEMORY_BASIC_INFORMATION mbiCfg{};
    PULONG_PTR pCfgBitMap = GetCfgBitmap(hProcess);
    ULONG_PTR va;

    if (!pCfgBitMap)
        goto cleanup;
    
    // We walk the VA address space via the CFG Bitmap to find all contiguous private executable regions.
    // For each of these, we compare against the current region state to determine if the region has been hidden.

    va = 0;
    while (va < (ULONG_PTR)g_sysinfo.lpMaximumApplicationAddress)
    {
        PULONG_PTR pCfgEntry = pCfgBitMap + ((ULONG_PTR)va >> CFG_INDEX_SHIFT);
        if (!VirtualQueryEx(hProcess, (PVOID)pCfgEntry, &mbiCfg, sizeof(mbiCfg)))
            break; // process stopped

        if (MEM_COMMIT == mbiCfg.State)
        {
            // Found some committed CFG page(s) - but are they private and exectuable?
            SIZE_T hiddenRegionSize = 0;
            ULONG_PTR hiddenRegionStart = 0;
            ULONG_PTR vaRegionEnd = va + mbiCfg.RegionSize * 64;
            while (va < vaRegionEnd)
            {
                pCfgEntry = pCfgBitMap + ((ULONG_PTR)va >> CFG_INDEX_SHIFT);
                SIZE_T stBytesRead = 0;
                ULONG_PTR ulEntry = 0;
                // TODO(jdu) This per-entry read is inefficient - just read the whole region upfront instead.
                if (!ReadProcessMemory(hProcess, pCfgEntry, &ulEntry, sizeof(ulEntry), &stBytesRead))
                    break;

                // We're only interested in non-executable pages that contain (all) CFG call targets
                if (MAXULONG_PTR == ulEntry)
                {
                    if (0 == hiddenRegionSize)
                    {
                        hiddenRegionStart = va;
                    }
                    hiddenRegionSize += g_sysinfo.dwPageSize;
                }

                va += g_sysinfo.dwPageSize;

                if ((hiddenRegionSize > 0) && ((MAXULONG_PTR != ulEntry) || (va == vaRegionEnd)))
                {
                    // The CFG bitmap indicates that this region has been executable during the lifetime
                    // of the process. Now check the VAD tree.

                    MEMORY_BASIC_INFORMATION mbiStart{};
                    MEMORY_BASIC_INFORMATION mbiEnd{};
                    if (VirtualQueryEx(hProcess, (PVOID)hiddenRegionStart, &mbiStart, sizeof(mbi)) &&
                        (MEM_COMMIT == mbiStart.State) &&
                        VirtualQueryEx(hProcess, (PVOID)(hiddenRegionStart + hiddenRegionSize - 1), &mbiEnd, sizeof(mbi)))
                    {
                        // Is this region non-executable in the VAD tree?
                        bool bHiddenRegion = !(PAGE_EXECUTE_FLAGS & mbiStart.Protect) &&
                            !(PAGE_EXECUTE_FLAGS & mbiStart.AllocationProtect);

                        // Handle a few common (likely) false positives.
                        bool bLikelyFalsePositive = 
                            (mbiStart.AllocationBase != mbiEnd.AllocationBase) || // hidden region overlaps allocation
                            (hiddenRegionSize == 0x3000);                         // 12K region
                        
                        if (bHiddenRegion && (bAggressive || !bLikelyFalsePositive))
                        {
                            result.push_back((PVOID)(hiddenRegionStart));
                        }
                    }

                    hiddenRegionStart = 0;
                    hiddenRegionSize = 0;
                }
            }
        }
        va += mbiCfg.RegionSize * 64; // Each CFG BitMap page corresponds to 64 VA pages
    }

cleanup:
    return result;
}


// Outputs the details of discovered hidden regions.
// If you scanned aggressively, then this includes commentary about FP potential.
void DumpHiddenExecutableAllocations(HANDLE hProcess, const std::vector<PVOID>& hiddenExecutableAllocations)
{
    MEMORY_BASIC_INFORMATION mbi{};
    MEMORY_BASIC_INFORMATION mbiCfg{};
    PULONG_PTR pCfgBitMap = (PULONG_PTR)GetCfgBitmap(hProcess);

    for (const auto& allocation : hiddenExecutableAllocations)
    {
        if (!VirtualQueryEx(hProcess, allocation, &mbi, sizeof(mbi)))
            break;

        printf(" * %p %s\n", allocation, TypeString(&mbi));

        DWORD allocationHiddenPages = 0;
        SIZE_T allocationSize = 0;
        for (ULONG_PTR i = (ULONG_PTR)allocation; mbi.AllocationBase == allocation; i += mbi.RegionSize)
        {
            if (!VirtualQueryEx(hProcess, (PVOID)i, &mbi, sizeof(mbi)))
                break;

            DWORD regionHiddenPages = 0;
            bool HiddenRegionOverlaps = false;

            if (mbi.AllocationBase == allocation && !(PAGE_EXECUTE_FLAGS & mbi.Protect))
            {
                for (ULONG_PTR j = (ULONG_PTR)mbi.BaseAddress; j < ((ULONG_PTR)mbi.BaseAddress + mbi.RegionSize); j += (64 * g_sysinfo.dwPageSize))
                {
                    PULONG_PTR pEntry = pCfgBitMap + ((ULONG_PTR)j >> CFG_INDEX_SHIFT);

                    if (!VirtualQueryEx(hProcess, pEntry, &mbiCfg, sizeof(mbiCfg)) || (MEM_COMMIT != mbiCfg.State) ||
                        (MEM_MAPPED != mbiCfg.Type) || (PAGE_NOACCESS == mbiCfg.Protect))
                        continue; // Skip if no CFG BitMap page

                    // Check the first entry for every VA page on this CFG BitMap page for previous executable protection
                    int cfgPageEnd = 64 - (((ULONG_PTR)j / g_sysinfo.dwPageSize) % 64); // determine where on the CFG page our VA resides
                    for (int k = 0; (k < cfgPageEnd) && (j + k * g_sysinfo.dwPageSize) < ((ULONG_PTR)mbi.BaseAddress + mbi.RegionSize); k++)
                    {
                        PULONG_PTR pEntry = pCfgBitMap + (((ULONG_PTR)j + k * g_sysinfo.dwPageSize) >> CFG_INDEX_SHIFT);
                        SIZE_T stBytesRead = 0;
                        ULONG_PTR ulEntry = 0;
                        if (!ReadProcessMemory(hProcess, pEntry, &ulEntry, sizeof(ulEntry), &stBytesRead))
                            break;

                        // We're only interested in non-executable pages that contain (all) CFG call targets
                        regionHiddenPages += (MAXULONG_PTR == ulEntry);
                    }
                }
            }
            else if ((mbi.AllocationBase != allocation))
            {
                // two cases... ends with MEM_RESERVE, or ends with MEM_FREE?
                bool IsLastPageHidden = false;
                bool IsNextPageHidden = false;
                {

                    PULONG_PTR pEntry = pCfgBitMap + ((i - g_sysinfo.dwPageSize) >> CFG_INDEX_SHIFT);
                    SIZE_T stBytesRead = 0;
                    ULONG_PTR ulEntry = 0;
                    if (!ReadProcessMemory(hProcess, pEntry, &ulEntry, sizeof(ulEntry), &stBytesRead))
                        break;

                    IsLastPageHidden = (MAXULONG_PTR == ulEntry);
                }

                {
                    PULONG_PTR pEntry = pCfgBitMap + (i >> CFG_INDEX_SHIFT);
                    SIZE_T stBytesRead = 0;
                    ULONG_PTR ulEntry = 0;
                    if (!ReadProcessMemory(hProcess, pEntry, &ulEntry, sizeof(ulEntry), &stBytesRead))
                        break;

                    IsNextPageHidden = (MAXULONG_PTR == ulEntry);
                }
                HiddenRegionOverlaps = IsLastPageHidden && IsNextPageHidden;
            }

            if ((0 != mbi.AllocationProtect) && (mbi.AllocationBase == allocation))
            {
                allocationHiddenPages += regionHiddenPages;
                allocationSize += mbi.RegionSize;
                if (0 != regionHiddenPages)
                    printf("   - %p +0x%06zx %s %s %d/%zu hidden pages\n", mbi.BaseAddress, mbi.RegionSize, ProtectionString(mbi.AllocationProtect, 0), ProtectionString(mbi.Protect, mbi.State), regionHiddenPages, mbi.RegionSize / g_sysinfo.dwPageSize);
            }
            else if (HiddenRegionOverlaps)
            {
                printf("   --> likely FP. Hidden region overlaps boundary.\n");
            }
            else if ((allocationSize != allocationHiddenPages * g_sysinfo.dwPageSize) && (mbi.AllocationBase != allocation) && (0 != regionHiddenPages))
            {
                printf("   --> likely FP. allocation<->CFG mismatch. Previously executable dimensions overlap allocation.\n");
                break;
            }

        }
        if ((allocationSize == allocationHiddenPages * g_sysinfo.dwPageSize))
        {
            PULONG_PTR pEntry = pCfgBitMap + (((ULONG_PTR)mbi.AllocationBase + allocationSize) >> CFG_INDEX_SHIFT);
            if (!VirtualQueryEx(hProcess, pEntry, &mbiCfg, sizeof(mbiCfg)) || (MEM_COMMIT != mbiCfg.State) ||
                (MEM_MAPPED != mbiCfg.Type) || (PAGE_NOACCESS == mbiCfg.Protect))
            {
                continue; // Skip if no CFG BitMap page
            }
            SIZE_T stBytesRead = 0;
            ULONG_PTR ulEntry = 0;
            if (!ReadProcessMemory(hProcess, pEntry, &ulEntry, sizeof(ulEntry), &stBytesRead))
                break;

            if (MAXULONG_PTR == ulEntry)
            {
                printf("   --> likely FP. allocation<->CFG mismatch. Previously executable dimensions overlap allocation.\n");
            }
        }
    }
}

int main(int argc, char* argv[])
{
    bool bAggressive = false; // skip some likely false positives

    std::vector<PVOID> hiddenAllocations;
    HANDLE hProcessSnap = NULL;
    PROCESSENTRY32 pe32{};

    GetSystemInfo(&g_sysinfo);

    printf("===== Hidden Executable Pages - %s scanning all processes =====\n", bAggressive ? "aggressively " : "quickly");

    // Take a snapshot of all processes in the system.
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    assert(hProcessSnap != INVALID_HANDLE_VALUE);

    pe32.dwSize = sizeof(PROCESSENTRY32);
    (void)Process32First(hProcessSnap, &pe32);
    assert(NULL != pe32.szExeFile);

    do
    {
        HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pe32.th32ProcessID);
        if (NULL == hProcess)
            continue;  // access is denied, skip

        hiddenAllocations = GetProcessPreviouslyExecutableRegions(hProcess, bAggressive);
        if (hiddenAllocations.size() > 0)
        {
            printf("%ls(%d) - %zu hidden allocations\n", pe32.szExeFile, pe32.th32ProcessID, hiddenAllocations.size());
            DumpHiddenExecutableAllocations(hProcess, hiddenAllocations);
        }

        CloseHandle(hProcess);
    } while (Process32Next(hProcessSnap, &pe32));

    return 0;
}


```