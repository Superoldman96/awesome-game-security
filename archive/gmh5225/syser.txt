Project Path: arc_gmh5225_syser_vk3sh7hh

Source Tree:

```txt
arc_gmh5225_syser_vk3sh7hh
├── addition
│   └── DiaSDK
│       ├── bin
│       │   ├── amd64
│       │   │   ├── msdia80.dll
│       │   │   └── msdia80.pdb
│       │   ├── msdia80.dll
│       │   └── msdia80.pdb
│       ├── idl
│       │   └── dia2.idl
│       ├── include
│       │   ├── cvconst.h
│       │   ├── dia2.h
│       │   └── diacreate.h
│       └── lib
│           ├── amd64
│           │   └── diaguids.lib
│           └── diaguids.lib
├── cmake.bat
├── images
│   ├── SyserDebuggerx64.png
│   ├── SyserDebuggerx64src.png
│   ├── SyserDebuggerx64src1.png
│   ├── attach_struct.png
│   └── struct_viewer.png
├── readme.md
├── source
│   ├── CMakeLists.txt
│   ├── Code
│   │   ├── alt
│   │   │   ├── altarray.hpp
│   │   │   ├── altbase.hpp
│   │   │   ├── altexpcalc.hpp
│   │   │   ├── altfile.hpp
│   │   │   ├── altlist.hpp
│   │   │   ├── altmap.hpp
│   │   │   ├── altobj.hpp
│   │   │   ├── altqueue.hpp
│   │   │   ├── altstack.hpp
│   │   │   └── altstring.hpp
│   │   ├── cmdparser.cpp
│   │   ├── cmdparser.hpp
│   │   ├── compress.cpp
│   │   ├── compress.hpp
│   │   ├── define.h
│   │   ├── fileio.cpp
│   │   ├── fileio.hpp
│   │   ├── fileiont.cpp
│   │   ├── fileiont.hpp
│   │   ├── handle.cpp
│   │   ├── handle.hpp
│   │   ├── imagefile.cpp
│   │   ├── imagefile.hpp
│   │   ├── modf.cpp
│   │   ├── options.cpp
│   │   ├── options.hpp
│   │   ├── osdefine.hpp
│   │   ├── pageimage.hpp
│   │   ├── pagemem.cpp
│   │   ├── pagemem.hpp
│   │   ├── polyfs.cpp
│   │   ├── polyfs.hpp
│   │   ├── srctxtfile.cpp
│   │   ├── srctxtfile.hpp
│   │   ├── strmem.cpp
│   │   ├── sysdep.cpp
│   │   ├── sysdep.hpp
│   │   ├── time.cpp
│   │   ├── time.hpp
│   │   ├── tstrmem.hpp
│   │   ├── txtfile.cpp
│   │   ├── txtfile.hpp
│   │   ├── utxtfile.cpp
│   │   └── utxtfile.hpp
│   ├── EXEAnalyzer
│   │   ├── debugger.cpp
│   │   ├── debugger.hpp
│   │   ├── instrsym.cpp
│   │   ├── instrsym.hpp
│   │   ├── inteldis.cpp
│   │   ├── inteldis.hpp
│   │   ├── mzhead.hpp
│   │   ├── pefile.cpp
│   │   ├── pefile.hpp
│   │   ├── pehead.hpp
│   │   ├── sdsfile.hpp
│   │   ├── sdsmodule.cpp
│   │   ├── sdsmodule.hpp
│   │   ├── sdwin.cpp
│   │   ├── sdwin.hpp
│   │   ├── sourcedebug.cpp
│   │   ├── sourcedebug.hpp
│   │   ├── symbol.cpp
│   │   ├── symbol.hpp
│   │   ├── x86debugger.cpp
│   │   └── x86debugger.hpp
│   ├── MFCSymbols.cpp
│   ├── Syser.dat
│   ├── Syser.ico
│   ├── Wisp
│   │   ├── dibdata.cpp
│   │   ├── utility.cpp
│   │   ├── utility.hpp
│   │   ├── wispapp.cpp
│   │   ├── wispapp.hpp
│   │   ├── wispbase.cpp
│   │   ├── wispbase.hpp
│   │   ├── wispbasewnd.cpp
│   │   ├── wispbasewnd.hpp
│   │   ├── wispbutton.cpp
│   │   ├── wispbutton.hpp
│   │   ├── wispcalcwnd.cpp
│   │   ├── wispcalcwnd.hpp
│   │   ├── wispcheckbox.cpp
│   │   ├── wispcheckbox.hpp
│   │   ├── wispcolorstrwnd.cpp
│   │   ├── wispcolorstrwnd.hpp
│   │   ├── wispcombobox.cpp
│   │   ├── wispcombobox.hpp
│   │   ├── wispconsolewnd.cpp
│   │   ├── wispconsolewnd.hpp
│   │   ├── wispdc.cpp
│   │   ├── wispdc.hpp
│   │   ├── wispdib.cpp
│   │   ├── wispdib.hpp
│   │   ├── wispdraw.cpp
│   │   ├── wispdraw.hpp
│   │   ├── wispdrawobj.cpp
│   │   ├── wispdrawobj.hpp
│   │   ├── wispedit.cpp
│   │   ├── wispedit.hpp
│   │   ├── wispfont.cpp
│   │   ├── wispfont.hpp
│   │   ├── wispform.cpp
│   │   ├── wispform.hpp
│   │   ├── wisphexwnd.cpp
│   │   ├── wisphexwnd.hpp
│   │   ├── wisplist.cpp
│   │   ├── wisplist.hpp
│   │   ├── wispmenu.cpp
│   │   ├── wispmenu.hpp
│   │   ├── wispmsg.hpp
│   │   ├── wispmsgbox.cpp
│   │   ├── wispmsgbox.hpp
│   │   ├── wispmultitabview.cpp
│   │   ├── wispmultitabview.hpp
│   │   ├── wispoptionform.cpp
│   │   ├── wispoptionform.hpp
│   │   ├── wispprogress.cpp
│   │   ├── wispprogress.hpp
│   │   ├── wispprogressform.cpp
│   │   ├── wispprogressform.hpp
│   │   ├── wispradiobox.cpp
│   │   ├── wispradiobox.hpp
│   │   ├── wisprgbselect.cpp
│   │   ├── wisprgbselect.hpp
│   │   ├── wispsoftkeyboard.cpp
│   │   ├── wispsoftkeyboard.hpp
│   │   ├── wispsplitwnd.cpp
│   │   ├── wispsplitwnd.hpp
│   │   ├── wispstatic.cpp
│   │   ├── wispstatic.hpp
│   │   ├── wisptabwnd.cpp
│   │   ├── wisptabwnd.hpp
│   │   ├── wisptipwnd.cpp
│   │   ├── wisptipwnd.hpp
│   │   ├── wisptoolbar.cpp
│   │   ├── wisptoolbar.hpp
│   │   ├── wispwnd.cpp
│   │   └── wispwnd.hpp
│   ├── Wisp.dat
│   ├── WispSyser
│   │   ├── SyserRing3.cpp
│   │   ├── SyserRing3.hpp
│   │   ├── aboutform.cpp
│   │   ├── aboutform.hpp
│   │   ├── breakpointform.cpp
│   │   ├── breakpointform.hpp
│   │   ├── bugcheckcode.cpp
│   │   ├── callstackwnd.cpp
│   │   ├── callstackwnd.hpp
│   │   ├── codebpedit.cpp
│   │   ├── codebpedit.hpp
│   │   ├── codeview.cpp
│   │   ├── codeview.hpp
│   │   ├── commentlist.cpp
│   │   ├── commentlist.hpp
│   │   ├── consolewnd.cpp
│   │   ├── consolewnd.hpp
│   │   ├── crossreferenceform.cpp
│   │   ├── crossreferenceform.hpp
│   │   ├── currentfunction.cpp
│   │   ├── currentfunction.hpp
│   │   ├── databpedit.cpp
│   │   ├── databpedit.hpp
│   │   ├── dataoperatordlg.cpp
│   │   ├── dataoperatordlg.hpp
│   │   ├── dataview.cpp
│   │   ├── dataview.hpp
│   │   ├── dataviewform.cpp
│   │   ├── dataviewform.hpp
│   │   ├── debuggerselectform.cpp
│   │   ├── debuggerselectform.hpp
│   │   ├── findlistwnd.cpp
│   │   ├── findlistwnd.hpp
│   │   ├── findstringform.cpp
│   │   ├── findstringform.hpp
│   │   ├── fpuregisterlist.cpp
│   │   ├── fpuregisterlist.hpp
│   │   ├── functionlistwnd.cpp
│   │   ├── functionlistwnd.hpp
│   │   ├── gdtwnd.cpp
│   │   ├── gdtwnd.hpp
│   │   ├── genereglist.cpp
│   │   ├── genereglist.hpp
│   │   ├── idtwnd.cpp
│   │   ├── idtwnd.hpp
│   │   ├── ioctl.cpp
│   │   ├── keymappingpage.cpp
│   │   ├── keymappingpage.hpp
│   │   ├── lex.cpp
│   │   ├── mainframe.cpp
│   │   ├── mainframe.hpp
│   │   ├── modulelist.cpp
│   │   ├── modulelist.hpp
│   │   ├── multicodeview.cpp
│   │   ├── multicodeview.hpp
│   │   ├── multidataview.cpp
│   │   ├── multidataview.hpp
│   │   ├── multisourcecodeview.cpp
│   │   ├── multisourcecodeview.hpp
│   │   ├── ntstatus.cpp
│   │   ├── othercmd.cpp
│   │   ├── othercmd.hpp
│   │   ├── pagemapwnd.cpp
│   │   ├── pagemapwnd.hpp
│   │   ├── peexplorerform.cpp
│   │   ├── peexplorerform.hpp
│   │   ├── plugin.cpp
│   │   ├── plugin.hpp
│   │   ├── pluginlistform.cpp
│   │   ├── pluginlistform.hpp
│   │   ├── processlist.cpp
│   │   ├── processlist.hpp
│   │   ├── reghelpwnd.cpp
│   │   ├── reghelpwnd.hpp
│   │   ├── resource.cpp
│   │   ├── resource.hpp
│   │   ├── runtrace.cpp
│   │   ├── runtrace.hpp
│   │   ├── runtracewnd.cpp
│   │   ├── runtracewnd.hpp
│   │   ├── sdsmodulelist.cpp
│   │   ├── sdsmodulelist.hpp
│   │   ├── searchdialog.cpp
│   │   ├── searchdialog.hpp
│   │   ├── sehchainwnd.cpp
│   │   ├── sehchainwnd.hpp
│   │   ├── sharecmd.cpp
│   │   ├── sourcecodewnd.cpp
│   │   ├── sourcecodewnd.hpp
│   │   ├── sourcedebugframewnd.cpp
│   │   ├── sourcedebugframewnd.hpp
│   │   ├── sseregisterlist.cpp
│   │   ├── sseregisterlist.hpp
│   │   ├── stackwatchlist.cpp
│   │   ├── stackwatchlist.hpp
│   │   ├── strinputwnd.cpp
│   │   ├── strinputwnd.hpp
│   │   ├── sysercmd.cpp
│   │   ├── syserconfig.cpp
│   │   ├── syserconfig.hpp
│   │   ├── syserdefine.hpp
│   │   ├── syseroptionform.cpp
│   │   ├── syseroptionform.hpp
│   │   ├── syserui.cpp
│   │   ├── syserui.hpp
│   │   ├── systemexplorer.cpp
│   │   ├── systemexplorer.hpp
│   │   ├── terminalwnd.cpp
│   │   ├── terminalwnd.hpp
│   │   ├── typeviewerform.cpp
│   │   ├── typeviewerform.hpp
│   │   ├── typeviewerwnd.cpp
│   │   ├── typeviewerwnd.hpp
│   │   ├── watchlist.cpp
│   │   ├── watchlist.hpp
│   │   ├── windowsmsg.cpp
│   │   ├── winerror.cpp
│   │   ├── winwisp.cpp
│   │   ├── winwisp.hpp
│   │   ├── x87x64double.asm
│   │   └── x87x86double.asm
│   ├── pdb2sds.cpp
│   ├── resource.rc
│   ├── syser.manifest
│   └── unpack.cpp
├── x32
│   ├── README
│   ├── Syser.dat
│   ├── Wisp.dat
│   ├── cmake32_debug.bat
│   ├── cmake32_release.bat
│   ├── cmake_build.bat
│   ├── cmake_clean.bat
│   ├── msdia80.dll
│   ├── pdb2sdsx32.exe
│   ├── plugin.hpp
│   ├── sdx32.dll
│   ├── syserx32.exe
│   ├── syserx32.lib
│   └── unpackx32.exe
└── x64
    ├── README
    ├── Syser.dat
    ├── Wisp.dat
    ├── cmake64_debug.bat
    ├── cmake64_release.bat
    ├── cmake_build.bat
    ├── cmake_clean.bat
    ├── msdia80.dll
    ├── pdb2sdsx64.exe
    ├── plugin.hpp
    ├── sdx64.dll
    ├── syserx64.exe
    ├── syserx64.lib
    └── unpackx64.exe

```

`addition/DiaSDK/idl/dia2.idl`:

```idl
// dia2.idl - Debug Information Access (DIA) interface description
//-----------------------------------------------------------------
//
// Copyright 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
import "objidl.idl";
import "oaidl.idl";
import "propidl.idl";

import "cvconst.h";

enum NameSearchOptions
{
    nsNone = 0,

    nsfCaseSensitive = 0x1,         // apply a case sensitive match
    nsfCaseInsensitive = 0x2,       // apply a case insensitive match
    nsfFNameExt = 0x4,              // treat names as paths and apply a filename.ext match
    nsfRegularExpression = 0x8,     // regular expression
    nsfUndecoratedName = 0x10,      // applies only to symbols that have both undecorated and decorated names

    // predefined names for backward source compatibility

    nsCaseSensitive = nsfCaseSensitive,             // apply a case sensitive match
    nsCaseInsensitive = nsfCaseInsensitive,         // apply a case insensitive match
    nsFNameExt = nsfCaseInsensitive | nsfFNameExt,  // treat names as paths and apply a filename.ext match
    nsRegularExpression = nsfRegularExpression | nsfCaseSensitive,      // regular expression (using only '*' and '?')
    nsCaseInRegularExpression = nsfRegularExpression | nsfCaseInsensitive,  // case insensitive regular expression
};


// the following are error HRESULTS returned by an IDiaDataSource they
// are based on the FACILITY_VISUALCPP (0x6d) defined in delayimp.h

enum 
{
    E_PDB_OK=((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(((LONG)0x6d))<<16) | ((unsigned long)(1))) ),
    E_PDB_USAGE                 ,
    E_PDB_OUT_OF_MEMORY         , // not used, use E_OUTOFMEMORY
    E_PDB_FILE_SYSTEM           ,
    E_PDB_NOT_FOUND             ,
    E_PDB_INVALID_SIG           ,
    E_PDB_INVALID_AGE           ,
    E_PDB_PRECOMP_REQUIRED      ,
    E_PDB_OUT_OF_TI             ,
    E_PDB_NOT_IMPLEMENTED       ,   // use E_NOTIMPL
    E_PDB_V1_PDB                ,
    E_PDB_FORMAT                ,
    E_PDB_LIMIT                 ,
    E_PDB_CORRUPT               ,
    E_PDB_TI16                  ,
    E_PDB_ACCESS_DENIED         ,  // use E_ACCESSDENIED
    E_PDB_ILLEGAL_TYPE_EDIT     ,
    E_PDB_INVALID_EXECUTABLE    ,
    E_PDB_DBG_NOT_FOUND         ,
    E_PDB_NO_DEBUG_INFO         ,
    E_PDB_INVALID_EXE_TIMESTAMP ,
    E_PDB_RESERVED              ,
    E_PDB_DEBUG_INFO_NOT_IN_PDB ,
    E_PDB_SYMSRV_BAD_CACHE_PATH ,
    E_PDB_SYMSRV_CACHE_FULL     ,
    E_PDB_MAX
};

//
// Errors in finding dynamically loaded dlls or functions.
//
enum
{
    DIA_E_MODNOTFOUND = E_PDB_MAX+1,
    DIA_E_PROCNOTFOUND,
};

#define PROPERTY_RW(type, name, prid, help)           \
        [propget, helpstring(help), id(prid)]         \
        HRESULT name([out, retval] type * pRetVal);   \
                                                      \
        [propput, helpstring(help), id(prid)]         \
        HRESULT name([in] type NewVal)

#define PROPERTY_ARRAY_RW(type, itype, name, prid, help)           \
        [propget, helpstring(help), id(prid)]         \
        HRESULT name([in] itype index, [out, retval] type * pRetVal);   \
                                                      \
        [propput, helpstring(help), id(prid)]         \
        HRESULT name([in] itype index, [in] type NewVal)

#define PROPERTY_RO(type, name, prid, help)           \
        [propget, helpstring(help), id(prid)]         \
        HRESULT name([out, retval] type * pRetVal) 

#define PROPERTY_ARRAY_RO(type, itype, name, prid, help)           \
        [propget, helpstring(help), id(prid)]         \
        HRESULT name([in] itype index, [out, retval] type * pRetVal)

// type of callback arg to IDiaDataSource::loadDataForExe
typedef void (__cdecl *PfnPDBDebugDirV)(BOOL, /*const struct _IMAGE_DEBUG_DIRECTORY * */ void*);


interface IDiaSession;
interface IDiaEnumTables;

interface IDiaSymbol;
interface IDiaSourceFile;
interface IDiaLineNumber;
interface IDiaInjectedSource;
interface IDiaSegment;
interface IDiaSectionContrib;
interface IDiaFrameData;
interface IDiaLVarInstance;
interface IDiaStackWalkHelper;
interface IDiaStackFrame;

[
    object,
    uuid(C32ADB82-73F4-421b-95D5-A4706EDF5DBE),
    local,
    helpstring("IDiaLoadCallback interface."),
    pointer_default(unique)
]
interface IDiaLoadCallback: IUnknown
{
    HRESULT NotifyDebugDir(
                [in] BOOL fExecutable, 
                [in] DWORD cbData,
                [in, size_is(cbData)] BYTE *pbData); // really a const struct _IMAGE_DEBUG_DIRECTORY *

    HRESULT NotifyOpenDBG(
                [in] LPCOLESTR dbgPath, 
                [in] HRESULT resultCode);

    HRESULT NotifyOpenPDB(
                [in] LPCOLESTR pdbPath, 
                [in] HRESULT resultCode);

    HRESULT RestrictRegistryAccess();         // return hr != S_OK to prevent querying the registry for symbol search paths
    HRESULT RestrictSymbolServerAccess();     // return hr != S_OK to prevent accessing a symbol server
}

[
    object,
    uuid(4688a074-5a4d-4486-aea8-7b90711d9f7c),
    local,
    helpstring("IDiaLoadCallback interface."),
    pointer_default(unique)
]
interface IDiaLoadCallback2: IDiaLoadCallback
{
    HRESULT RestrictOriginalPathAccess();     // return hr != S_OK to prevent looking up PDB specified in the debug directory
    HRESULT RestrictReferencePathAccess();    // return hr != S_OK to prevent looking up for PDB where the EXE is located.
    HRESULT RestrictDBGAccess();              // return hr != S_OK to prevent looking up debug information from DBG files.
    HRESULT RestrictSystemRootAccess();       // return hr != S_OK to prevent looking up PDBs in system root
}

[
    object,
    uuid(587A461C-B80B-4f54-9194-5032589A6319),
    local,
    helpstring("IDiaReadExeAtOffsetCallback interface."),
    pointer_default(unique)
]
interface IDiaReadExeAtOffsetCallback: IUnknown
{    
    HRESULT ReadExecutableAt(
                [in] DWORDLONG fileOffset, 
                [in] DWORD cbData,
                [out] DWORD *pcbData,
                [out, size_is(cbData)] BYTE *pbData);

}

[
    object,
    uuid(8E3F80CA-7517-432a-BA07-285134AAEA8E),
    local,
    helpstring("IDiaReadExeAtRVACallback interface."),
    pointer_default(unique)
]
interface IDiaReadExeAtRVACallback: IUnknown
{    
    HRESULT ReadExecutableAtRVA(
                [in] DWORD relativeVirtualAddress, 
                [in] DWORD cbData,
                [out] DWORD *pcbData,
                [out, size_is(cbData)] BYTE *pbData);
}

[
    object,
    uuid(79F1BB5F-B66E-48e5-B6A9-1545C323CA3D),
    local,
    helpstring("IDiaDataSource Interface"),
    pointer_default(unique)
]
interface IDiaDataSource: IUnknown
{
    PROPERTY_RO( BSTR, lastError, 1, "Text for last load error." );

    //
    // loadDataFromPdb
    //
   HRESULT loadDataFromPdb(
               [in] LPCOLESTR pdbPath );

    //
    // loadAndValidateDataFromPdb
    //
   HRESULT loadAndValidateDataFromPdb(
               [in] LPCOLESTR pdbPath,
               [in] GUID* pcsig70,
               [in] DWORD sig,
               [in] DWORD age );

    //
    // loadDataForExe
    //
    HRESULT loadDataForExe(
               [in] LPCOLESTR executable,
               [in] LPCOLESTR searchPath,
               [in] IUnknown* pCallback );

    //
    // loadDataFromIStream
    //
    HRESULT loadDataFromIStream(
                [in] IStream *pIStream );


    HRESULT openSession( 
                [out] IDiaSession** ppSession 
                );
}

[
    object,
    uuid(CAB72C48-443B-48f5-9B0B-42F0820AB29A),
    local,
    helpstring("IDiaEnumSymbols Interface"),
    pointer_default(unique)
]
interface IDiaEnumSymbols: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumSymbols." );
    PROPERTY_RO( LONG, Count, 1, "Number of symbols." );

    [id(0), helpstring("Return the symbol for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaSymbol **symbol);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSymbol ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumSymbols **ppenum);
}

[
    object,
    uuid(624B7D9C-24EA-4421-9D06-3B577471C1FA),
    local,
    helpstring("IDiaEnumSymbolsByAddr Interface"),
    pointer_default(unique)
]
interface IDiaEnumSymbolsByAddr: IUnknown
{
    //
    // Item(ByXxx) re-positions the enumerator to the item found
    //
    [helpstring("Return the symbol for the given address.")]
    HRESULT symbolByAddr(
        [in] DWORD isect, 
        [in] DWORD offset, 
        [out, retval]IDiaSymbol** ppSymbol);

    [helpstring("Return the symbol for the given relative virtual address.")]
    HRESULT symbolByRVA(
        [in] DWORD relativeVirtualAddress, 
        [out, retval]IDiaSymbol** ppSymbol);

    [helpstring("Return the symbol for the given virtual address.")]
    HRESULT symbolByVA(
        [in] ULONGLONG virtualAddress, 
        [out, retval]IDiaSymbol** ppSymbol);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSymbol ** rgelt,   
        [out] ULONG * pceltFetched 
    );

    HRESULT Prev(
        [in] ULONG celt,          
        [out] IDiaSymbol ** rgelt,   
        [out] ULONG * pceltFetched 
    );

    HRESULT Clone(
        [out] IDiaEnumSymbolsByAddr **ppenum);
}

[
    object,
    uuid(10F3DBD9-664F-4469-B808-9471C7A50538),
    local,
    helpstring("IDiaEnumSourceFiles Interface"),
    pointer_default(unique)
]
interface IDiaEnumSourceFiles: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumSourceFiles." );
    PROPERTY_RO( LONG, Count, 1, "Number of source files." );

    [id(0), helpstring("Return the source file for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaSourceFile **sourceFile);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSourceFile ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumSourceFiles **ppenum);
}

[
    object,
    uuid(FE30E878-54AC-44f1-81BA-39DE940F6052),
    local,
    helpstring("IDiaEnumLineNumbers Interface"),
    pointer_default(unique)
]
interface IDiaEnumLineNumbers: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumLineNumbers." );
    PROPERTY_RO( LONG, Count, 1, "Number of line numbers." );

    [id(0), helpstring("Return the line number for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaLineNumber **lineNumber);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaLineNumber ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumLineNumbers **ppenum);
}

[
    object,
    uuid(D5612573-6925-4468-8883-98CDEC8C384A),
    local,
    helpstring("IDiaEnumInjectedSources Interface"),
    pointer_default(unique)
]
interface IDiaEnumInjectedSources: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumInjectedSources." );
    PROPERTY_RO( LONG, Count, 1, "Number of injected source files." );

    [id(0), helpstring("Return the injected source for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaInjectedSource **injectedSource);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaInjectedSource ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumInjectedSources **ppenum);
}

[
    object,
    uuid(E8368CA9-01D1-419d-AC0C-E31235DBDA9F),
    local,
    helpstring("IDiaEnumSegments Interface"),
    pointer_default(unique)
]
interface IDiaEnumSegments: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumSegments." );
    PROPERTY_RO( LONG, Count, 1, "Number of segments." );

    [id(0), helpstring("Return the segment for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaSegment **segment);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSegment ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumSegments **ppenum);
}

[
    object,
    uuid(1994DEB2-2C82-4b1d-A57F-AFF424D54A68),
    local,
    helpstring("IDiaEnumSectionContribs Interface"),
    pointer_default(unique)
]
interface IDiaEnumSectionContribs: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumSectionContribs." );
    PROPERTY_RO( LONG, Count, 1, "Number of section contributions." );

    [id(0), helpstring("Return the section contribution for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaSectionContrib **section);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaSectionContrib ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumSectionContribs **ppenum);
}

[
    object,
    uuid(9FC77A4B-3C1C-44ed-A798-6C1DEEA53E1F),
    local,
    helpstring("IDiaEnumFrameData Interface"),
    pointer_default(unique)
]
interface IDiaEnumFrameData: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumFrameData." );
    PROPERTY_RO( LONG, Count, 1, "Number of frames." );

    [id(0), helpstring("Return the frame for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IDiaFrameData **frame);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaFrameData ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumFrameData **ppenum);

    //
    // The following two by-address lookups do not reposition the enumeration
    //
    [helpstring("Return the frame for the given relative virtual address.")]
    HRESULT frameByRVA(
        [in] DWORD relativeVirtualAddress, 
        [out, retval]IDiaFrameData **frame);

    [helpstring("Return the frame for the given virtual address.")]
    HRESULT frameByVA(
        [in] ULONGLONG virtualAddress, 
        [out, retval]IDiaFrameData **frame);
}

[
    object,
    uuid(486943E8-D187-4a6b-A3C4-291259FFF60D),
    local,
    helpstring("IDiaEnumDebugStreamData Interface"),
    pointer_default(unique)
]
interface IDiaEnumDebugStreamData: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumDebugStreamData." );
    PROPERTY_RO( LONG, Count, 1, "Number of elements in the stream." );
    PROPERTY_RO( BSTR, name, 2, "Stream name." );

    [id(0), helpstring("Return the element for the given index.")]
    HRESULT Item(
            [in] DWORD index, 
            [in] DWORD cbData,
            [out] DWORD *pcbData,
            [out, size_is(cbData)] BYTE *pbData
            );

    HRESULT Next(
        [in] ULONG celt,          
        [in] DWORD cbData,
        [out] DWORD *pcbData,
        [out, size_is(cbData)] BYTE *pbData,
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumDebugStreamData **ppenum);
}

[
    object,
    uuid(08CBB41E-47A6-4f87-92F1-1C9C87CED044),
    local,
    helpstring("IDiaEnumDebugStreams Interface"),
    pointer_default(unique)
]
interface IDiaEnumDebugStreams: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumDebugStreams." );
    PROPERTY_RO( LONG, Count, 1, "Number of streams." );

    [id(0), helpstring("Return the stream for the given index.")]
    HRESULT Item([in] VARIANT index, [out, retval]IDiaEnumDebugStreamData **stream);

    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaEnumDebugStreamData ** rgelt,   
        [out] ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumDebugStreams **ppenum);
}

struct DiaAddressMapEntry
{
    DWORD rva;
    DWORD rvaTo;
};

[
    object,
    uuid(B62A2E7A-067A-4ea3-B598-04C09717502C),
    local,
    helpstring("IDiaAddressMap Interface"),
    pointer_default(unique)
]
interface IDiaAddressMap: IUnknown
{
    PROPERTY_RW( BOOL, addressMapEnabled, 3, "Enable address translations." );
    PROPERTY_RW( BOOL, relativeVirtualAddressEnabled, 4, "Enable relative virtual address computations.");
    PROPERTY_RW( DWORD, imageAlign, 5, "Original image alignment." );

    HRESULT set_imageHeaders(
     [in] DWORD cbData,
     [in, size_is(cbData)] BYTE *pbData,      // actual type is IMAGE_SECTION_HEADER[]
     [in] BOOL originalHeaders );            // true: headers are original, that is, they match the debug symbols
                                             // false: headers are current, that is, they match the image

    HRESULT set_addressMap(
     [in] DWORD cData,          // number of entries in rva map
     [in, size_is(cData)] struct DiaAddressMapEntry *pData,      // rva map
     [in] BOOL imageToSymbols );             // true:  map from image to symbols (omapt)
                                             // false: map from symbols to image (omapf)
};

[
    object,
    uuid(67138B34-79CD-4b42-B74A-A18ADBB799DF),
    local,
    helpstring("IDiaSession Interface"),
    pointer_default(unique)
]
interface IDiaSession: IUnknown
{
    PROPERTY_RW( ULONGLONG, loadAddress, 1, "Dll/Exe load address." );
    PROPERTY_RO( IDiaSymbol*, globalScope, 2, "Global scope (exe) symbol." );

    HRESULT getEnumTables( 
        [out] IDiaEnumTables** ppEnumTables );
    HRESULT getSymbolsByAddr( 
        [out] IDiaEnumSymbolsByAddr** ppEnumbyAddr );

    //
    // Queries that return sets of symbols
    //
    HRESULT findChildren( 
        [in] IDiaSymbol* parent, 
        [in] enum SymTagEnum symtag, 
        [in] LPCOLESTR name,
        [in] DWORD compareFlags,
        [out] IDiaEnumSymbols** ppResult );
    HRESULT findSymbolByAddr (
        [in] DWORD isect,
        [in] DWORD offset,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol );
    HRESULT findSymbolByRVA (
        [in] DWORD rva,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol );
    HRESULT findSymbolByVA (
        [in] ULONGLONG va,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol );
    HRESULT findSymbolByToken (
        [in] ULONG token,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol );
    HRESULT symsAreEquiv(
        [in] IDiaSymbol* symbolA, 
        [in] IDiaSymbol* symbolB );
    HRESULT symbolById(
        [in] DWORD id,
        [out] IDiaSymbol** ppSymbol );
    HRESULT findSymbolByRVAEx (
        [in] DWORD rva,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol,
        [out] long* displacement );
    HRESULT findSymbolByVAEx (
        [in] ULONGLONG va,
        [in] enum SymTagEnum symtag, 
        [out] IDiaSymbol** ppSymbol,
        [out] long* displacement );

    //
    // Queries that return source file results
    //
    HRESULT findFile(
        [in] IDiaSymbol* pCompiland, 
        [in] LPCOLESTR name,
        [in] DWORD compareFlags,
        [out] IDiaEnumSourceFiles** ppResult );
    HRESULT findFileById(
        [in] DWORD uniqueId,
        [out] IDiaSourceFile** ppResult );

    //
    // Queries that return line number results
    //
    HRESULT findLines( 
        [in] IDiaSymbol* compiland, 
        [in] IDiaSourceFile* file, 
        [out] IDiaEnumLineNumbers** ppResult );
    HRESULT findLinesByAddr(
        [in] DWORD seg,
        [in] DWORD offset,
        [in] DWORD length,
        [out] IDiaEnumLineNumbers** ppResult );
    HRESULT findLinesByRVA(
        [in] DWORD rva,
        [in] DWORD length,
        [out] IDiaEnumLineNumbers** ppResult );
    HRESULT findLinesByVA(
        [in] ULONGLONG va,
        [in] DWORD length,
        [out] IDiaEnumLineNumbers** ppResult );
    HRESULT findLinesByLinenum(
        [in] IDiaSymbol* compiland, 
        [in] IDiaSourceFile* file,
        [in] DWORD linenum,
        [in] DWORD column,
        [out] IDiaEnumLineNumbers** ppResult );

    //
    // Queries that return injected source
    //
    HRESULT findInjectedSource( 
        [in] LPCOLESTR srcFile, 
        [out] IDiaEnumInjectedSources** ppResult );

    HRESULT getEnumDebugStreams( 
        [out] IDiaEnumDebugStreams** ppEnumDebugStreams );
};

/*
 *  Table Columns
 *
 *  Symbols - a symbol will have values in some subset of the fields
 */
[
    object,
    uuid(cb787b2f-bd6c-4635-ba52-933126bd2dcd),
    local,
    helpstring("IDiaSymbol Interface"),
    pointer_default(unique)
]
interface IDiaSymbol: IUnknown
{
    PROPERTY_RO( DWORD, symIndexId, 0, "Unique symbol identifier." );
    PROPERTY_RO( DWORD, symTag, 1, "Symbol kind tag." );
    PROPERTY_RO( BSTR, name, 2, "Name" );                     
    PROPERTY_RO( IDiaSymbol*, lexicalParent, 3, "Lexical parent symbol.");                  
    PROPERTY_RO( IDiaSymbol*, classParent, 4, ".");
    PROPERTY_RO( IDiaSymbol*, type, 5, ".");
    PROPERTY_RO( DWORD, dataKind, 6, ".");
    PROPERTY_RO( DWORD, locationType, 7, ".");
    PROPERTY_RO( DWORD, addressSection, 8, ".");
    PROPERTY_RO( DWORD, addressOffset, 9, ".");
    PROPERTY_RO( DWORD, relativeVirtualAddress, 10, ".");
    PROPERTY_RO( ULONGLONG, virtualAddress, 11, ".");
    PROPERTY_RO( DWORD, registerId, 12, ".");
    PROPERTY_RO( LONG, offset, 13, ".");
    PROPERTY_RO( ULONGLONG, length, 14, ".");
    PROPERTY_RO( DWORD, slot, 15, ".");
    PROPERTY_RO( BOOL, volatileType, 16, ".");
    PROPERTY_RO( BOOL, constType, 17, ".");
    PROPERTY_RO( BOOL, unalignedType, 18, ".");
    PROPERTY_RO( DWORD, access, 19, ".");
    PROPERTY_RO( BSTR, libraryName, 20, ".");
    PROPERTY_RO( DWORD, platform, 21, ".");
    PROPERTY_RO( DWORD, language, 22, ".");
    PROPERTY_RO( BOOL, editAndContinueEnabled, 23, ".");
    PROPERTY_RO( DWORD, frontEndMajor, 24, ".");
    PROPERTY_RO( DWORD, frontEndMinor, 25, ".");
    PROPERTY_RO( DWORD, frontEndBuild, 26, ".");
    PROPERTY_RO( DWORD, backEndMajor, 27, ".");
    PROPERTY_RO( DWORD, backEndMinor, 28, ".");
    PROPERTY_RO( DWORD, backEndBuild, 29, ".");
    PROPERTY_RO( BSTR, sourceFileName, 30, ".");
    PROPERTY_RO( BSTR, unused, 31, ".");
    PROPERTY_RO( DWORD, thunkOrdinal, 32, ".");
    PROPERTY_RO( LONG, thisAdjust, 33, ".");
    PROPERTY_RO( DWORD, virtualBaseOffset, 34, ".");
    PROPERTY_RO( BOOL, virtual, 35, ".");
    PROPERTY_RO( BOOL, intro, 36, ".");
    PROPERTY_RO( BOOL, pure, 37, ".");
    PROPERTY_RO( DWORD, callingConvention, 38, ".");
    PROPERTY_RO( VARIANT, value, 39, ".");
    PROPERTY_RO( DWORD, baseType, 40, ".");
    PROPERTY_RO( DWORD, token, 41, ".");
    PROPERTY_RO( DWORD, timeStamp, 42, ".");
    PROPERTY_RO( GUID, guid, 43, ".");
    PROPERTY_RO( BSTR, symbolsFileName, 44, ".");
    PROPERTY_RO( BOOL, reference, 46, ".");
    PROPERTY_RO( DWORD, count, 47, ".");
    PROPERTY_RO( DWORD, bitPosition, 49, ".");
    PROPERTY_RO( IDiaSymbol*, arrayIndexType, 50, ".");
    PROPERTY_RO( BOOL, packed, 51, ".");
    PROPERTY_RO( BOOL, constructor, 52, ".");
    PROPERTY_RO( BOOL, overloadedOperator, 53, ".");
    PROPERTY_RO( BOOL, nested, 54, ".");
    PROPERTY_RO( BOOL, hasNestedTypes, 55, ".");
    PROPERTY_RO( BOOL, hasAssignmentOperator, 56, ".");
    PROPERTY_RO( BOOL, hasCastOperator, 57, ".");
    PROPERTY_RO( BOOL, scoped, 58, ".");
    PROPERTY_RO( BOOL, virtualBaseClass, 59, ".");
    PROPERTY_RO( BOOL, indirectVirtualBaseClass, 60, ".");
    PROPERTY_RO( LONG, virtualBasePointerOffset, 61, ".");
    PROPERTY_RO( IDiaSymbol*, virtualTableShape, 62, ".");
    PROPERTY_RO( DWORD, lexicalParentId, 64, "Lexical parent symbol.");                  
    PROPERTY_RO( DWORD, classParentId, 65, ".");
    PROPERTY_RO( DWORD, typeId, 66, ".");
    PROPERTY_RO( DWORD, arrayIndexTypeId, 67, ".");
    PROPERTY_RO( DWORD, virtualTableShapeId, 68, ".");
    PROPERTY_RO( BOOL, code, 69, "Symbol refers to a code address." );
    PROPERTY_RO( BOOL, function, 70, "Symbol refers to a function." );
    PROPERTY_RO( BOOL, managed, 71, "Symbol refers to managed code." );
    PROPERTY_RO( BOOL, msil, 72, "Symbol refers to MSIL code." );
    PROPERTY_RO( DWORD, virtualBaseDispIndex, 73, ".");
    PROPERTY_RO( BSTR, undecoratedName, 74, ".");
    PROPERTY_RO( DWORD, age, 75, "PDB file age." );
    PROPERTY_RO( DWORD, signature, 76, "Signature." ); 
    PROPERTY_RO( BOOL, compilerGenerated, 77, "Symbol is compiler generated." );
    PROPERTY_RO( BOOL, addressTaken, 78, "Symbol is address taken." );
    PROPERTY_RO( DWORD, rank, 79, "Rank of FORTRAN multi-dimension array." );
    PROPERTY_RO( IDiaSymbol*, lowerBound, 80, "Lower bound of a FORTRAN array dimension.");
    PROPERTY_RO( IDiaSymbol*, upperBound, 81, "Upper bound of a FORTRAN array dimension.");
    PROPERTY_RO( DWORD, lowerBoundId, 82, "Symbol Id of the lower bound of a FORTRAN array dimension.");
    PROPERTY_RO( DWORD, upperBoundId, 83, "Symbol Id of the upper bound of a FORTRAN array dimension.");

    HRESULT get_dataBytes(
         [in] DWORD cbData,
         [out] DWORD *pcbData,
         [out, size_is(cbData)] BYTE *pbData
        );

    HRESULT findChildren( 
        [in] enum SymTagEnum symtag, 
        [in] LPCOLESTR name,
        [in] DWORD compareFlags,
        [out] IDiaEnumSymbols** ppResult );

    PROPERTY_RO( DWORD, targetSection, 84, "Thunk target address section.");
    PROPERTY_RO( DWORD, targetOffset, 85, "Thunk target address offset.");
    PROPERTY_RO( DWORD, targetRelativeVirtualAddress, 86, "Thunk target RVA.");
    PROPERTY_RO( ULONGLONG, targetVirtualAddress, 87, "Thunk target virtual address.");
    PROPERTY_RO( DWORD, machineType, 88, "Target machine type." );
    PROPERTY_RO( DWORD, oemId, 89, "Identifier of manufacturer.");
    PROPERTY_RO( DWORD, oemSymbolId, 90, "Manufacturer defined custom symbol identifier." );
    HRESULT get_types(
         [in] DWORD cTypes,
         [out] DWORD *pcTypes,
         [out, size_is(cTypes, )] IDiaSymbol**pTypes
        );
    HRESULT get_typeIds(
         [in] DWORD cTypeIds,
         [out] DWORD *pcTypeIds,
         [out, size_is(cTypeIds)] DWORD *pdwTypeIds
        );
    PROPERTY_RO( IDiaSymbol*, objectPointerType, 91, "Type of method's object pointer." );
    PROPERTY_RO( DWORD, udtKind, 92, "Struct, union or class.");
    HRESULT get_undecoratedNameEx(
        [in] DWORD undecorateOptions,
        [out] BSTR* name
        );

    HRESULT get_liveLVarInstances(                              // Return instances of live locals at va
        [in]  ULONGLONG va,                                     // pass 0 to get all possible instances
        [in]  DWORD cInstances,
        [out] DWORD *pcInstances,
        [out] [size_is(cInstances)] IDiaLVarInstance** instances
        );

    PROPERTY_RO( BOOL, noReturn, 93, "NoReturn" );
    PROPERTY_RO( BOOL, customCallingConvention, 94, "uses custom calling convention" );
    PROPERTY_RO( BOOL, noInline, 95, "NoInline" );
    PROPERTY_RO( BOOL, optimizedCodeDebugInfo, 96, "has debugging Info for optimized code" );
    PROPERTY_RO( BOOL, notReached, 97, "Unreachable" );
    PROPERTY_RO( BOOL, interruptReturn, 98, "return from interrupt" );
    PROPERTY_RO( BOOL, farReturn, 99, "far return" );
    PROPERTY_RO( BOOL, isStatic, 100, "static function" );
    PROPERTY_RO( BOOL, hasDebugInfo, 101, "hasDebugInfo" );
    PROPERTY_RO( BOOL, isLTCG, 102, "Compiled With LTCG" );
    PROPERTY_RO( BOOL, isDataAligned, 103, "Is it compiled with -Bzalign" );
    PROPERTY_RO( BOOL, hasSecurityChecks, 104, "hasSecurityChecks" );
    PROPERTY_RO( BSTR, compilerName, 105, "compiler name" );
    PROPERTY_RO( BOOL, hasAlloca, 106, "hasAlloca" );
    PROPERTY_RO( BOOL, hasSetJump, 107, "hasSetJump" );
    PROPERTY_RO( BOOL, hasLongJump, 108, "hasLongJump" );
    PROPERTY_RO( BOOL, hasInlAsm, 109, "hasInlineAssembly" );
    PROPERTY_RO( BOOL, hasEH, 110, "hasC++EH" );
    PROPERTY_RO( BOOL, hasSEH, 111, "hasStructuredEH" );
    PROPERTY_RO( BOOL, hasEHa, 112, "hasAsynchronousEH" );
    PROPERTY_RO( BOOL, isNaked, 113, "IsNaked" );
    PROPERTY_RO( BOOL, isAggregated, 114, "isAggregated" );
    PROPERTY_RO( BOOL, isSplitted, 115, "isSplitted" );
    PROPERTY_RO( IDiaSymbol *, container, 116, "container" );
    PROPERTY_RO( BOOL, inlSpec, 117, "WasSpecifiedAsInline" );
    PROPERTY_RO( BOOL, noStackOrdering, 118, "BufferChecksWithoutOrdering" );
    PROPERTY_RO( IDiaSymbol *, virtualBaseTableType, 119, "Type of Virtual Base Offset Table" );
    PROPERTY_RO( BOOL, hasManagedCode, 120, "hasManagedCode" );
    PROPERTY_RO( BOOL, isHotpatchable, 121, "isHotpatchable" );
    PROPERTY_RO( BOOL, isCVTCIL, 122, "isCVTCIL" );
    PROPERTY_RO( BOOL, isMSILNetmodule, 123, "isMSILNetmodule" );
    PROPERTY_RO( BOOL, isCTypes, 124, "isCTypes" );
    PROPERTY_RO( BOOL, isStripped, 125, "isStripped" );
};

//
//  SourceFiles
//
[
    object,
    uuid(A2EF5353-F5A8-4eb3-90D2-CB526ACB3CDD),
    local,
    helpstring("IDiaSourceFile Interface"),
    pointer_default(unique)
]
interface IDiaSourceFile: IUnknown
{
    PROPERTY_RO( DWORD, uniqueId, 2, "Unique id for the source file (in this data store)." );
    PROPERTY_RO( BSTR, fileName, 3, "." );
    PROPERTY_RO( DWORD, checksumType, 4, "." );
    PROPERTY_RO( IDiaEnumSymbols*, compilands, 5, "." );

    HRESULT get_checksum(
         [in] DWORD cbData,
         [out] DWORD *pcbData,
         [out, size_is(cbData)] BYTE *pbData
        );
};

//
//  LineNumbers
//
[
    object,
    uuid(B388EB14-BE4D-421d-A8A1-6CF7AB057086),
    local,
    helpstring("IDiaLineNumber Interface"),
    pointer_default(unique)
]
interface IDiaLineNumber: IUnknown
{
    PROPERTY_RO( IDiaSymbol*, compiland, 1, "." );
    PROPERTY_RO( IDiaSourceFile*, sourceFile, 2, "." );
    PROPERTY_RO( DWORD, lineNumber, 3, "." );
    PROPERTY_RO( DWORD, lineNumberEnd, 4, "." );
    PROPERTY_RO( DWORD, columnNumber, 5, "." );
    PROPERTY_RO( DWORD, columnNumberEnd, 6, "." );
    PROPERTY_RO( DWORD, addressSection, 7, "." );
    PROPERTY_RO( DWORD, addressOffset, 8, "." );
    PROPERTY_RO( DWORD, relativeVirtualAddress, 9, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 10, "." );
    PROPERTY_RO( DWORD, length, 11, "." );
    PROPERTY_RO( DWORD, sourceFileId, 12, "." );
    PROPERTY_RO( BOOL, statement, 13, "." );
    PROPERTY_RO( DWORD, compilandId, 14, "." );
};

//
// SectionContributions
//
[
    object,
    uuid(0CF4B60E-35B1-4c6c-BDD8-854B9C8E3857),
    local,
    helpstring("IDiaSectionContrib Interface"),
    pointer_default(unique)
]
interface IDiaSectionContrib: IUnknown
{
    PROPERTY_RO( IDiaSymbol*, compiland, 1, "." );
    PROPERTY_RO( DWORD, addressSection, 2, "." );
    PROPERTY_RO( DWORD, addressOffset, 3, "." );
    PROPERTY_RO( DWORD, relativeVirtualAddress, 4, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 5, "." );
    PROPERTY_RO( DWORD, length, 6, "." );
    // 7
    PROPERTY_RO( BOOL, notPaged, 8, ".");
    PROPERTY_RO( BOOL, code, 9, ".");
    PROPERTY_RO( BOOL, initializedData, 10, ".");
    PROPERTY_RO( BOOL, uninitializedData, 11, ".");
    PROPERTY_RO( BOOL, remove, 12, ".");
    PROPERTY_RO( BOOL, comdat, 13, ".");
    PROPERTY_RO( BOOL, discardable, 14, ".");
    PROPERTY_RO( BOOL, notCached, 15, ".");
    PROPERTY_RO( BOOL, share, 16, ".");
    PROPERTY_RO( BOOL, execute, 17, ".");
    PROPERTY_RO( BOOL, read, 18, ".");
    PROPERTY_RO( BOOL, write, 19, ".");
    PROPERTY_RO( DWORD, dataCrc, 20, "." );
    PROPERTY_RO( DWORD, relocationsCrc, 21, "." );
    PROPERTY_RO( DWORD, compilandId, 22, "." );
    PROPERTY_RO( BOOL, code16bit, 23, ".");
};

//
// SegmentMap
//
[
    object,
    uuid(0775B784-C75B-4449-848B-B7BD3159545B),
    local,
    helpstring("IDiaSegment Interface"),
    pointer_default(unique)
]
interface IDiaSegment: IUnknown
{
    PROPERTY_RO( DWORD, frame, 1, "Frame." );
    PROPERTY_RO( DWORD, offset, 2, "Offset in physical section." );
    PROPERTY_RO( DWORD, length, 3, "Length in bytes of segment." );
    PROPERTY_RO( BOOL, read, 4, "Read allowed." );
    PROPERTY_RO( BOOL, write, 5, "Write allowed." );
    PROPERTY_RO( BOOL, execute, 6, "Execute allowed." );
    PROPERTY_RO( DWORD, addressSection, 7, "." );
    PROPERTY_RO( DWORD, relativeVirtualAddress, 8, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 9, "." );
};

//
// InjectedSource
//
[
    object,
    uuid(AE605CDC-8105-4a23-B710-3259F1E26112),
    local,
    helpstring("IDiaInjectedSource Interface"),
    pointer_default(unique)
]
interface IDiaInjectedSource: IUnknown
{
    PROPERTY_RO( DWORD, crc, 1, "CRC of source bytes." );
    PROPERTY_RO( ULONGLONG, length, 2, "Length of source in bytes." );
    PROPERTY_RO( BSTR, filename, 3, "Source filename." );
    PROPERTY_RO( BSTR, objectFilename, 4, "Object filename." );
    PROPERTY_RO( BSTR, virtualFilename, 5, "Virtual filename." );
    PROPERTY_RO( DWORD, sourceCompression, 6, "Source compression algorithm." );
    HRESULT get_source(
         [in] DWORD cbData,
         [out] DWORD *pcbData,
         [out, size_is(cbData)] BYTE *pbData
        );
};

[
    object,
    uuid(0e425a73-3ced-4964-8cf0-a6caf11bd818),
    local,
    helpstring("IDiaLVarInstance Interface"),
    pointer_default(unique)
]
interface IDiaLVarInstance : IUnknown
{
    PROPERTY_RO( IDiaSymbol *, symbol, 1, "Symbols whose instance is defined" );

    PROPERTY_RO( DWORD, sectionStart, 2, "Section addrStart" );
    PROPERTY_RO( DWORD, offsetStart, 3, "Offset addrStart" );
    PROPERTY_RO( DWORD, rvaStart, 4, "RVA addrStart" );
    PROPERTY_RO( ULONGLONG, vaStart, 5, "VA addrStart" );

    PROPERTY_RO( DWORD, rvaEnd, 6, "RVA addrEnd" );
    PROPERTY_RO( DWORD, sectionEnd, 7, "Section addrEnd" );
    PROPERTY_RO( DWORD, offsetEnd, 8, "Offset addrEnd" );
    PROPERTY_RO( ULONGLONG, vaEnd, 9, "VA addrEnd" );

    PROPERTY_RO( BSTR, program, 10, "Program to evaluate the symbol" );

    HRESULT get_livenessAt(                 // Tells you if the instance is live at va
        [in] ULONGLONG va,
        [out] BOOL *pfLive );

    HRESULT get_location(
        [in]  IDiaStackFrame *pFrame,
        [out] BOOL *pfLocInRegister,
        [out] DWORD *pdwRegId,
        [out] ULONGLONG *pva
    );
};

//
// Errors returned by IDiaFrameData::execute
//
enum 
{
    E_DIA_INPROLOG          // cannot execute stack frame when in prolog
            =((HRESULT) (((unsigned long)(1)<<31) | ((unsigned long)(((LONG)0x6d))<<16) | ((unsigned long)(100))) ),
    E_DIA_SYNTAX,           // error parsing frame program
    E_DIA_FRAME_ACCESS,     // error accessing registers or memory
    E_DIA_VALUE,            // error in computer a value (e.g., divide by zero)
};


[
    object,
    uuid(97F0F1A6-E04E-4ea4-B4F9-B0D0E8D90F5D),
    local,
    helpstring("IDiaStackWalkFrame Interface"),
    pointer_default(unique)
]
interface IDiaStackWalkFrame: IUnknown
{
    PROPERTY_ARRAY_RW( ULONGLONG, DWORD, registerValue, 1, "Register value." ); 
    HRESULT readMemory( 
         [in] ULONGLONG va,
         [in] DWORD cbData,
         [out] DWORD *pcbData,
         [out, size_is(cbData)] BYTE *pbData
         );
    HRESULT searchForReturnAddress(
        [in] IDiaFrameData* frame,
        [out] ULONGLONG* returnAddress
        );
    HRESULT searchForReturnAddressStart(
        [in] IDiaFrameData* frame,
        [in] ULONGLONG startAddress,
        [out] ULONGLONG* returnAddress
        );
};


[
    object,
    uuid(A39184B7-6A36-42de-8EEC-7DF9F3F59F33),
    local,
    helpstring("IDiaFrameData Interface"),
    pointer_default(unique)
]
interface IDiaFrameData: IUnknown
{
    PROPERTY_RO( DWORD, addressSection, 2, "." );
    PROPERTY_RO( DWORD, addressOffset, 3, "." );
    PROPERTY_RO( DWORD, relativeVirtualAddress, 4, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 5, "." );
    PROPERTY_RO( DWORD, lengthBlock, 6, "." );
    PROPERTY_RO( DWORD, lengthLocals, 7, "." );
    PROPERTY_RO( DWORD, lengthParams, 8, "." );
    PROPERTY_RO( DWORD, maxStack, 9, "." );
    PROPERTY_RO( DWORD, lengthProlog, 10, "." );
    PROPERTY_RO( DWORD, lengthSavedRegisters, 11, "." );
    PROPERTY_RO( BSTR, program, 12, "." );
    PROPERTY_RO( BOOL, systemExceptionHandling, 13, "." );
    PROPERTY_RO( BOOL, cplusplusExceptionHandling, 14, "." );
    PROPERTY_RO( BOOL, functionStart, 15, "." );
    PROPERTY_RO( BOOL, allocatesBasePointer, 16, "." );
    PROPERTY_RO( DWORD, type, 17, "." );
    PROPERTY_RO( IDiaFrameData*, functionParent, 18, "Frame data for enclosing function.");                  

    HRESULT execute( IDiaStackWalkFrame* frame );
}

//
// IDiaImageData
//
//      Some debug streams (XDATA, PDATA) contain copies of data also stored in the image. The
//      stream data objects (IDiaEnumDebugStreamData) can be QI'ed for their IDiaImageData.
[
    object,
    uuid(C8E40ED2-A1D9-4221-8692-3CE661184B44),
    local,
    helpstring("IDiaImageData Interface"),
    pointer_default(unique)
]
interface IDiaImageData: IUnknown
{
    PROPERTY_RO( DWORD, relativeVirtualAddress, 2, "." );
    PROPERTY_RO( ULONGLONG, virtualAddress, 3, "." );
    PROPERTY_RO( ULONGLONG, imageBase, 4, "." );
}

//
// IDiaTable
//      Supports enumerating the members of the table
//
[
    object,
    uuid(4A59FB77-ABAC-469b-A30B-9ECC85BFEF14),
    local,
    helpstring("IDiaTable Interface"),
    pointer_default(unique)
]
interface IDiaTable: IEnumUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaTable." );
    PROPERTY_RO( BSTR, name, 1, "Table name." );
    PROPERTY_RO( LONG, Count, 2, "Number of table entries." );

    [id(0), helpstring("Return the table element for the given index.")]
    HRESULT Item([in] DWORD index, [out, retval]IUnknown **element); // ### IDispatch?

};

[
    object,
    uuid(C65C2B0A-1150-4d7a-AFCC-E05BF3DEE81E),
    local,
    helpstring("IDiaEnumTables Interface"),
    pointer_default(unique)
]
interface IDiaEnumTables: IUnknown
{
    PROPERTY_RO( IUnknown*, _NewEnum, DISPID_NEWENUM, "IEnumVARIANT version of IDiaEnumTables." );
    PROPERTY_RO( LONG, Count, 1, "Number of tables." );

    [id(0), helpstring("Return the table for the given index or name.")]
    HRESULT Item([in] VARIANT index, [out, retval]IDiaTable **table);

    HRESULT Next(
        ULONG celt,          
        IDiaTable ** rgelt,   
        ULONG * pceltFetched 
    );
    HRESULT Skip(
        [in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        [out] IDiaEnumTables **ppenum);
};

#ifndef MSAGNOSTIC
[
    uuid(106173A0-0173-4e5c-84E7-E915422BE997),
    version(2.0),
    helpstring("dia 2.0 Type Library")
]
#else
[
    uuid(7e49f738-1f41-46fd-87c2-badce1ce096c),
    version(2.0),
    helpstring("intdia 2.0 Type Library")
]
#endif

library Dia2Lib
{

    importlib("stdole2.tlb");
    [
#ifndef MSAGNOSTIC
        uuid(bce36434-2c24-499e-bf49-8bd99b0eeb68),
#else
        uuid(a287f295-608c-485a-942e-b91ec87991fe),
#endif
        helpstring("DiaSource Class")
    ]
    coclass DiaSource
    {
        [default] interface IDiaDataSource;
    };

    //
    // DiaSourceAlt - a DiaDataSource object that does not use the system heap. 
    //
    // A process may either make DiaSourceAlt objects or DiaSource objects, but not both.
    // When using DiaSourceAlt all returned BSTR's are really LPCOLESTR and should not be 
    // used with other BSTR management routines, in particular they must be released using
    //      LocalFree( bstr )
    [
#ifndef MSAGNOSTIC
        uuid(1fbd5ec4-b8e4-4d94-9efe-7ccaf9132c98),
#else
        uuid(0676f7d4-abc2-4eef-869e-58f1378c86f1),
#endif
        helpstring("Local Heap DiaSource Class")
    ]
    coclass DiaSourceAlt
    {
        [default] interface IDiaDataSource;
    };


    // General stack walking API    
    [
#ifndef MSAGNOSTIC
        uuid(37dfdbcc-40a5-4f4a-8523-123c746d38f0),
#else
        uuid(08db23f4-7aa8-4748-a623-858a6d872c2b),
#endif
        helpstring("General Stackwalk Class")
    ]
    coclass DiaStackWalker
    {
        [default] interface IDiaStackWalker;
    };
};

//
// DebugInfoTable
//
// Each id identifies an underlying table of debug information 
// 

const LPOLESTR DiaTable_Symbols = L"Symbols";
const LPOLESTR DiaTable_Sections = L"Sections";
const LPOLESTR DiaTable_SrcFiles = L"SourceFiles";
const LPOLESTR DiaTable_LineNums = L"LineNumbers";
const LPOLESTR DiaTable_SegMap = L"SegmentMap";
const LPOLESTR DiaTable_Dbg = L"Dbg";
const LPOLESTR DiaTable_InjSrc = L"InjectedSource";
const LPOLESTR DiaTable_FrameData = L"FrameData";


// Generic property broweser interface.
[
    object,
    uuid(9d416f9c-e184-45b2-a4f0-ce517f719e9b),
    local,
    helpstring("IDiaPropertyStorage Interface"),
    pointer_default(unique)
]
interface IDiaPropertyStorage: IUnknown
{

    HRESULT ReadMultiple(
        [in] ULONG cpspec,                                       // Count of properties being read
        [in, size_is(cpspec)] PROPSPEC const *rgpspec,           // Array of the properties to be read
        [out, size_is(cpspec)]PROPVARIANT *rgvar                 // Array of PVARIANTs containing
                                                                 // the property values on return
    );

    HRESULT ReadPropertyNames(
        [in] ULONG cpropid,                                      // Number of elements in rgpropid
        [in, size_is( cpropid )] PROPID const  *rgpropid,        // Property identifiers for
                                                                 // which names are to be retrieved
        [in,out, size_is( cpropid )] BSTR *rglpwstrName          // Array of returned string names
    );

    HRESULT Enum(
        [out] IEnumSTATPROPSTG **ppenum     //Pointer to output variable
                                            // that receives the IEnumPROPSPEC
                                            // interface pointer
    );

    HRESULT ReadDWORD(
        [in] PROPID id,            // property to be read
        [out] DWORD* pValue        // the property value on return
    );

    HRESULT ReadLONG(
        [in] PROPID id,            // property to be read
        [out] LONG* pValue         // the property value on return
    );

    HRESULT ReadBOOL(
        [in] PROPID id,            // property to be read
        [out] BOOL* pValue         // the property value on return
    );

    HRESULT ReadULONGLONG(
        [in] PROPID id,            // property to be read
        [out] ULONGLONG* pValue    // the property value on return
    );

    HRESULT ReadBSTR(
        [in] PROPID id,            // property to be read
        [out] BSTR* pValue         // the property value on return
    );
}

[
    object,
    uuid(5edbc96d-cdd6-4792-afbe-cc89007d9610),
    local,
    helpstring("IDiaStackFrame Interface"),
    pointer_default(unique)
]
interface IDiaStackFrame: IUnknown
{
    PROPERTY_RO( DWORD,     type,                       1,  "type" );
    PROPERTY_RO( ULONGLONG, base,                       2,  "Base of the stack frame" );
    PROPERTY_RO( DWORD,     size,                       3,  "size of frame in bytes" );
    PROPERTY_RO( ULONGLONG, returnAddress,              4,  "return address of the frame" );
    PROPERTY_RO( ULONGLONG, localsBase,                 5,  "base of locals" );
    PROPERTY_RO( DWORD,     lengthLocals,               6,  "cbLocals" );
    PROPERTY_RO( DWORD,     lengthParams,               7,  "cbParams" );
    PROPERTY_RO( DWORD,     lengthProlog,               8,  "cbProlog" );
    PROPERTY_RO( DWORD,     lengthSavedRegisters,       9,  "cbSavedRegs" );
    PROPERTY_RO( BOOL,      systemExceptionHandling,    10, "fHasSEH" );
    PROPERTY_RO( BOOL,      cplusplusExceptionHandling, 11, "fHasEH" );
    PROPERTY_RO( BOOL,      functionStart,              12, "funcStart" );
    PROPERTY_RO( BOOL,      allocatesBasePointer,       13, "fUsesBP" );
    PROPERTY_RO( DWORD,     maxStack,                   14, "maxStack" );

    PROPERTY_ARRAY_RO( ULONGLONG, DWORD, registerValue, 15, "Register value." );

    HRESULT get_rawLVarInstanceValue(
        [in]  IDiaLVarInstance *pInstance,
        [in]  DWORD cbDataMax,
        [out] DWORD *pcbData,
        [out] [size_is(cbDataMax)] BYTE *pbData 
    );

    HRESULT get_lVarInstanceLocation(
        [in]  IDiaLVarInstance *pInstance,
        [out] BOOL *pfLocInRegister,
        [out] DWORD *pdwRegId,
        [out] ULONGLONG *pva
    );
}

[
    object,
    uuid(ec9d461d-ce74-4711-a020-7d8f9a1dd255),
    local,
    helpstring("IDiaEnumStackFrames Interface"),
    pointer_default(unique)
]
interface IDiaEnumStackFrames: IUnknown
{
    HRESULT Next(
        [in] ULONG celt,          
        [out] IDiaStackFrame ** rgelt,
        [out] ULONG * pceltFetched 
    );

    HRESULT Reset();
}

typedef struct {
    DWORD       ulOffStart;             // offset 1st byte of function code
    DWORD       cbProcSize;             // # bytes in function
    DWORD       cdwLocals;              // # bytes in locals/4
    WORD        cdwParams;              // # bytes in params/4
    WORD        cdwFlags;               // Following stuff ...

    /*
    WORD        cbProlog : 8;           // # bytes in prolog
    WORD        cbRegs   : 3;           // # regs saved
    WORD        fHasSEH  : 1;           // TRUE if SEH in func
    WORD        fUseBP   : 1;           // TRUE if EBP has been allocated
    WORD        reserved : 1;           // reserved for future use
    WORD        cbFrame  : 2;           // frame type
    */
} FPODATA;

[
    object,
    uuid(feb0155d-35a8-42d4-8328-bf458f429a3a),
    local,
    helpstring("IDiaStackWalkHelper Interface"),
    pointer_default(unique)
]
interface IDiaStackWalkHelper: IUnknown
{
    PROPERTY_ARRAY_RW( ULONGLONG, DWORD, registerValue, 1, "Register value." );         
    HRESULT readMemory(                     // Read memory for DIA
        [in] enum MemoryTypeEnum type,
        [in] ULONGLONG va,
        [in] DWORD cbData,
        [out] DWORD *pcbData,
        [out, size_is(cbData)] BYTE *pbData
        );
    HRESULT searchForReturnAddress(         // search return address for DIA, return E_NOTIMPL to use DIA default
        [in] IDiaFrameData* frame,
        [out] ULONGLONG* returnAddress
        );
    HRESULT searchForReturnAddressStart(    // search return address for DIA, return E_NOTIMPL to use DIA default
        [in] IDiaFrameData* frame,
        [in] ULONGLONG startAddress,
        [out] ULONGLONG* returnAddress
        );
    HRESULT frameForVA(                     // Get frame data for this address          
        [in] ULONGLONG va,
        [out] IDiaFrameData **ppFrame
        );
    HRESULT symbolForVA(                    // Get symbol at this address, must be a SymTagFunctionType!
        [in] ULONGLONG va,
        [out] IDiaSymbol **ppSymbol
        );
    HRESULT pdataForVA(                      // Get PDATA for this address
        [in]  ULONGLONG va,
        [in]  DWORD cbData,
        [out] DWORD *pcbData,
        [out, size_is(cbData)] BYTE *pbData
        );
    HRESULT imageForVA(                      // Get information about an image
        [in]  ULONGLONG vaContext,           // An address in the image
        [out] ULONGLONG *pvaImageStart       // Beginning of the image
        );
}

[
    object,
    uuid(5485216b-a54c-469f-9670-52b24d5229bb),
    local,
    helpstring("IDiaStackWalker Interface"),
    pointer_default(unique)
]
interface IDiaStackWalker: IUnknown
{
    HRESULT getEnumFrames(                              // Gives you frame enumerator for x86
        [in]  IDiaStackWalkHelper *pHelper,
        [out] IDiaEnumStackFrames **ppEnum
        );

    HRESULT getEnumFrames2(                             // Gives frame enumerator for processor specified by dwMachineId
        [in]  enum CV_CPU_TYPE_e cpuid,
        [in]  IDiaStackWalkHelper *pHelper,
        [out] IDiaEnumStackFrames **ppEnum
        );
}

[
    object,
    uuid(8222c490-507b-4bef-b3bd-41dca7b5934c),
    local,
    helpstring("IDiaStackWalkHelper Interface"),
    pointer_default(unique)
]
interface IDiaStackWalkHelper2 : IDiaStackWalkHelper
{
}

[
    object,
    uuid(7c185885-a015-4cac-9411-0f4fb39b1f3a),
    local,
    helpstring("IDiaStackWalker2 Interface"),
    pointer_default(unique)
]
interface IDiaStackWalker2 : IDiaStackWalker
{
}

```

`addition/DiaSDK/include/cvconst.h`:

```h
// cvconst.h - codeview constant definitions
//-----------------------------------------------------------------
//
// Copyright Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _CVCONST_H_
#define _CVCONST_H_



//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_SHCALL      = 0x10, // Hitachi SuperH call
    CV_CALL_ARMCALL     = 0x11, // ARM call
    CV_CALL_AM33CALL    = 0x12, // AM33 call
    CV_CALL_TRICALL     = 0x13, // TriCore Call
    CV_CALL_SH5CALL     = 0x14, // Hitachi SuperH-5 call
    CV_CALL_M32RCALL    = 0x15, // M32R Call
    CV_CALL_CLRCALL     = 0x16, // clr call
    CV_CALL_RESERVED    = 0x17  // first unused call enumeration

    // Do NOT add any more machine specific conventions.  This is to be used for
    // calling conventions in the source only (e.g. __cdecl, __stdcall).
} CV_call_e;


//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;

typedef enum THUNK_ORDINAL {
    THUNK_ORDINAL_NOTYPE,       // standard thunk
    THUNK_ORDINAL_ADJUSTOR,     // "this" adjustor thunk
    THUNK_ORDINAL_VCALL,        // virtual call thunk
    THUNK_ORDINAL_PCODE,        // pcode thunk
    THUNK_ORDINAL_LOAD,         // thunk which loads the address to jump to
                                //  via unknown means...

 // trampoline thunk ordinals   - only for use in Trampoline thunk symbols
    THUNK_ORDINAL_TRAMP_INCREMENTAL,
    THUNK_ORDINAL_TRAMP_BRANCHISLAND,

} THUNK_ORDINAL;


enum CV_SourceChksum_t {
    CHKSUM_TYPE_NONE = 0,        // indicates no checksum is available
    CHKSUM_TYPE_MD5,
    CHKSUM_TYPE_SHA1
};

//
// DIA enums
//

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

enum LocationType
{
    LocIsNull,
    LocIsStatic,
    LocIsTLS,
    LocIsRegRel,
    LocIsThisRel,
    LocIsEnregistered,
    LocIsBitField,
    LocIsSlot,
    LocIsIlRel,
    LocInMetaData,
    LocIsConstant,
    LocTypeMax
};

enum DataKind
{
    DataIsUnknown,
    DataIsLocal,
    DataIsStaticLocal,
    DataIsParam,
    DataIsObjectPtr,
    DataIsFileStatic,
    DataIsGlobal,
    DataIsMember,
    DataIsStaticMember,
    DataIsConstant
};

enum UdtKind
{
    UdtStruct,
    UdtClass,
    UdtUnion
};

enum BasicType
{
    btNoType = 0,
    btVoid = 1,
    btChar = 2,
    btWChar = 3,
    btInt = 6,
    btUInt = 7,
    btFloat = 8,
    btBCD = 9,
    btBool = 10,
    btLong = 13,
    btULong = 14,
    btCurrency = 25,
    btDate = 26,
    btVariant = 27,
    btComplex = 28,
    btBit = 29,
    btBSTR = 30,
    btHresult = 31
};


//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
    CV_CFL_CVTPGD   = 0x09,
    CV_CFL_CSHARP   = 0x0A,  // C#
    CV_CFL_VB       = 0x0B,  // Visual Basic
    CV_CFL_ILASM    = 0x0C,  // IL (as in CLR) ASM
    CV_CFL_JAVA     = 0x0D,
    CV_CFL_JSCRIPT  = 0x0E,
    CV_CFL_MSIL     = 0x0F,  // Unknown MSIL (LTCG of .NETMODULE)
} CV_CFL_LANG;


//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMII    = 0x06,
    CV_CFL_PENTIUMPRO   = CV_CFL_PENTIUMII,
    CV_CFL_PENTIUMIII   = 0x07,
    CV_CFL_MIPS         = 0x10,
    CV_CFL_MIPSR4000    = CV_CFL_MIPS,  // don't break current code
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_MIPS32       = 0x12,
    CV_CFL_MIPS64       = 0x13,
    CV_CFL_MIPSI        = 0x14,
    CV_CFL_MIPSII       = 0x15,
    CV_CFL_MIPSIII      = 0x16,
    CV_CFL_MIPSIV       = 0x17,
    CV_CFL_MIPSV        = 0x18,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_PPCFP        = 0x44,
    CV_CFL_PPCBE        = 0x45,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_SHMEDIA      = 0x54,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_ARM5         = 0x63,
    CV_CFL_ARM5T        = 0x64,
    CV_CFL_ARM6         = 0x65,
    CV_CFL_ARM_XMAC     = 0x66,
    CV_CFL_ARM_WMMX     = 0x67,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
    CV_CFL_IA64_1       = 0x80,
    CV_CFL_IA64_2       = 0x81,
    CV_CFL_CEE          = 0x90,
    CV_CFL_AM33         = 0xA0,
    CV_CFL_M32R         = 0xB0,
    CV_CFL_TRICORE      = 0xC0,
    CV_CFL_X64          = 0xD0,
    CV_CFL_AMD64        = CV_CFL_X64,
    CV_CFL_EBC          = 0xE0,
    CV_CFL_THUMB        = 0xF0,
} CV_CPU_TYPE_e;

typedef enum CV_HREG_e {
    // Register subset shared by all processor types,
    // must not overlap with any of the ranges below, hence the high values

    CV_ALLREG_ERR   =   30000,
    CV_ALLREG_TEB   =   30001,
    CV_ALLREG_TIMER =   30002,
    CV_ALLREG_EFAD1 =   30003,
    CV_ALLREG_EFAD2 =   30004,
    CV_ALLREG_EFAD3 =   30005,
    CV_ALLREG_VFRAME=   30006,
    CV_ALLREG_HANDLE=   30007,
    CV_ALLREG_PARAMS=   30008,
    CV_ALLREG_LOCALS=   30009,
    CV_ALLREG_TID   =   30010,
    CV_ALLREG_ENV   =   30011,
    CV_ALLREG_CMDLN =   30012,


    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    CV_REG_MM0      =  146,
    CV_REG_MM1      =  147,
    CV_REG_MM2      =  148,
    CV_REG_MM3      =  149,
    CV_REG_MM4      =  150,
    CV_REG_MM5      =  151,
    CV_REG_MM6      =  152,
    CV_REG_MM7      =  153,

    CV_REG_XMM0     =  154, // KATMAI registers
    CV_REG_XMM1     =  155,
    CV_REG_XMM2     =  156,
    CV_REG_XMM3     =  157,
    CV_REG_XMM4     =  158,
    CV_REG_XMM5     =  159,
    CV_REG_XMM6     =  160,
    CV_REG_XMM7     =  161,

    CV_REG_XMM00    =  162, // KATMAI sub-registers
    CV_REG_XMM01    =  163,
    CV_REG_XMM02    =  164,
    CV_REG_XMM03    =  165,
    CV_REG_XMM10    =  166,
    CV_REG_XMM11    =  167,
    CV_REG_XMM12    =  168,
    CV_REG_XMM13    =  169,
    CV_REG_XMM20    =  170,
    CV_REG_XMM21    =  171,
    CV_REG_XMM22    =  172,
    CV_REG_XMM23    =  173,
    CV_REG_XMM30    =  174,
    CV_REG_XMM31    =  175,
    CV_REG_XMM32    =  176,
    CV_REG_XMM33    =  177,
    CV_REG_XMM40    =  178,
    CV_REG_XMM41    =  179,
    CV_REG_XMM42    =  180,
    CV_REG_XMM43    =  181,
    CV_REG_XMM50    =  182,
    CV_REG_XMM51    =  183,
    CV_REG_XMM52    =  184,
    CV_REG_XMM53    =  185,
    CV_REG_XMM60    =  186,
    CV_REG_XMM61    =  187,
    CV_REG_XMM62    =  188,
    CV_REG_XMM63    =  189,
    CV_REG_XMM70    =  190,
    CV_REG_XMM71    =  191,
    CV_REG_XMM72    =  192,
    CV_REG_XMM73    =  193,

    CV_REG_XMM0L    =  194,
    CV_REG_XMM1L    =  195,
    CV_REG_XMM2L    =  196,
    CV_REG_XMM3L    =  197,
    CV_REG_XMM4L    =  198,
    CV_REG_XMM5L    =  199,
    CV_REG_XMM6L    =  200,
    CV_REG_XMM7L    =  201,

    CV_REG_XMM0H    =  202,
    CV_REG_XMM1H    =  203,
    CV_REG_XMM2H    =  204,
    CV_REG_XMM3H    =  205,
    CV_REG_XMM4H    =  206,
    CV_REG_XMM5H    =  207,
    CV_REG_XMM6H    =  208,
    CV_REG_XMM7H    =  209,

    CV_REG_MXCSR    =  211, // XMM status register

    CV_REG_EDXEAX   =  212, // EDX:EAX pair

    CV_REG_EMM0L    =  220, // XMM sub-registers (WNI integer)
    CV_REG_EMM1L    =  221,
    CV_REG_EMM2L    =  222,
    CV_REG_EMM3L    =  223,
    CV_REG_EMM4L    =  224,
    CV_REG_EMM5L    =  225,
    CV_REG_EMM6L    =  226,
    CV_REG_EMM7L    =  227,

    CV_REG_EMM0H    =  228,
    CV_REG_EMM1H    =  229,
    CV_REG_EMM2H    =  230,
    CV_REG_EMM3H    =  231,
    CV_REG_EMM4H    =  232,
    CV_REG_EMM5H    =  233,
    CV_REG_EMM6H    =  234,
    CV_REG_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_REG_MM00     =  236,
    CV_REG_MM01     =  237,
    CV_REG_MM10     =  238,
    CV_REG_MM11     =  239,
    CV_REG_MM20     =  240,
    CV_REG_MM21     =  241,
    CV_REG_MM30     =  242,
    CV_REG_MM31     =  243,
    CV_REG_MM40     =  244,
    CV_REG_MM41     =  245,
    CV_REG_MM50     =  246,
    CV_REG_MM51     =  247,
    CV_REG_MM60     =  248,
    CV_REG_MM61     =  249,
    CV_REG_MM70     =  250,
    CV_REG_MM71     =  251,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

    //
    // JAVA VM registers
    //

    CV_JAVA_PC      = 1,

    //
    // Register set for the Hitachi SH3
    //

    CV_SH3_NOREG    =   CV_REG_NONE,

    CV_SH3_IntR0    =   10,   // CPU REGISTER
    CV_SH3_IntR1    =   11,
    CV_SH3_IntR2    =   12,
    CV_SH3_IntR3    =   13,
    CV_SH3_IntR4    =   14,
    CV_SH3_IntR5    =   15,
    CV_SH3_IntR6    =   16,
    CV_SH3_IntR7    =   17,
    CV_SH3_IntR8    =   18,
    CV_SH3_IntR9    =   19,
    CV_SH3_IntR10   =   20,
    CV_SH3_IntR11   =   21,
    CV_SH3_IntR12   =   22,
    CV_SH3_IntR13   =   23,
    CV_SH3_IntFp    =   24,
    CV_SH3_IntSp    =   25,
    CV_SH3_Gbr      =   38,
    CV_SH3_Pr       =   39,
    CV_SH3_Mach     =   40,
    CV_SH3_Macl     =   41,

    CV_SH3_Pc       =   50,
    CV_SH3_Sr       =   51,

    CV_SH3_BarA     =   60,
    CV_SH3_BasrA    =   61,
    CV_SH3_BamrA    =   62,
    CV_SH3_BbrA     =   63,
    CV_SH3_BarB     =   64,
    CV_SH3_BasrB    =   65,
    CV_SH3_BamrB    =   66,
    CV_SH3_BbrB     =   67,
    CV_SH3_BdrB     =   68,
    CV_SH3_BdmrB    =   69,
    CV_SH3_Brcr     =   70,

    //
    // Additional registers for Hitachi SH processors
    //

    CV_SH_Fpscr    =   75,    // floating point status/control register
    CV_SH_Fpul     =   76,    // floating point communication register

    CV_SH_FpR0     =   80,    // Floating point registers
    CV_SH_FpR1     =   81,
    CV_SH_FpR2     =   82,
    CV_SH_FpR3     =   83,
    CV_SH_FpR4     =   84,
    CV_SH_FpR5     =   85,
    CV_SH_FpR6     =   86,
    CV_SH_FpR7     =   87,
    CV_SH_FpR8     =   88,
    CV_SH_FpR9     =   89,
    CV_SH_FpR10    =   90,
    CV_SH_FpR11    =   91,
    CV_SH_FpR12    =   92,
    CV_SH_FpR13    =   93,
    CV_SH_FpR14    =   94,
    CV_SH_FpR15    =   95,

    CV_SH_XFpR0    =   96,
    CV_SH_XFpR1    =   97,
    CV_SH_XFpR2    =   98,
    CV_SH_XFpR3    =   99,
    CV_SH_XFpR4    =  100,
    CV_SH_XFpR5    =  101,
    CV_SH_XFpR6    =  102,
    CV_SH_XFpR7    =  103,
    CV_SH_XFpR8    =  104,
    CV_SH_XFpR9    =  105,
    CV_SH_XFpR10   =  106,
    CV_SH_XFpR11   =  107,
    CV_SH_XFpR12   =  108,
    CV_SH_XFpR13   =  109,
    CV_SH_XFpR14   =  110,
    CV_SH_XFpR15   =  111,

    //
    // Register set for the ARM processor.
    //

    CV_ARM_NOREG    =   CV_REG_NONE,

    CV_ARM_R0       =   10,
    CV_ARM_R1       =   11,
    CV_ARM_R2       =   12,
    CV_ARM_R3       =   13,
    CV_ARM_R4       =   14,
    CV_ARM_R5       =   15,
    CV_ARM_R6       =   16,
    CV_ARM_R7       =   17,
    CV_ARM_R8       =   18,
    CV_ARM_R9       =   19,
    CV_ARM_R10      =   20,
    CV_ARM_R11      =   21, // Frame pointer, if allocated
    CV_ARM_R12      =   22,
    CV_ARM_SP       =   23, // Stack pointer
    CV_ARM_LR       =   24, // Link Register
    CV_ARM_PC       =   25, // Program counter
    CV_ARM_CPSR     =   26, // Current program status register

    //
    // Register set for Intel IA64
    //

    CV_IA64_NOREG   =   CV_REG_NONE,

    // Branch Registers

    CV_IA64_Br0     =   512,
    CV_IA64_Br1     =   513,
    CV_IA64_Br2     =   514,
    CV_IA64_Br3     =   515,
    CV_IA64_Br4     =   516,
    CV_IA64_Br5     =   517,
    CV_IA64_Br6     =   518,
    CV_IA64_Br7     =   519,

    // Predicate Registers

    CV_IA64_P0    =   704,
    CV_IA64_P1    =   705,
    CV_IA64_P2    =   706,
    CV_IA64_P3    =   707,
    CV_IA64_P4    =   708,
    CV_IA64_P5    =   709,
    CV_IA64_P6    =   710,
    CV_IA64_P7    =   711,
    CV_IA64_P8    =   712,
    CV_IA64_P9    =   713,
    CV_IA64_P10   =   714,
    CV_IA64_P11   =   715,
    CV_IA64_P12   =   716,
    CV_IA64_P13   =   717,
    CV_IA64_P14   =   718,
    CV_IA64_P15   =   719,
    CV_IA64_P16   =   720,
    CV_IA64_P17   =   721,
    CV_IA64_P18   =   722,
    CV_IA64_P19   =   723,
    CV_IA64_P20   =   724,
    CV_IA64_P21   =   725,
    CV_IA64_P22   =   726,
    CV_IA64_P23   =   727,
    CV_IA64_P24   =   728,
    CV_IA64_P25   =   729,
    CV_IA64_P26   =   730,
    CV_IA64_P27   =   731,
    CV_IA64_P28   =   732,
    CV_IA64_P29   =   733,
    CV_IA64_P30   =   734,
    CV_IA64_P31   =   735,
    CV_IA64_P32   =   736,
    CV_IA64_P33   =   737,
    CV_IA64_P34   =   738,
    CV_IA64_P35   =   739,
    CV_IA64_P36   =   740,
    CV_IA64_P37   =   741,
    CV_IA64_P38   =   742,
    CV_IA64_P39   =   743,
    CV_IA64_P40   =   744,
    CV_IA64_P41   =   745,
    CV_IA64_P42   =   746,
    CV_IA64_P43   =   747,
    CV_IA64_P44   =   748,
    CV_IA64_P45   =   749,
    CV_IA64_P46   =   750,
    CV_IA64_P47   =   751,
    CV_IA64_P48   =   752,
    CV_IA64_P49   =   753,
    CV_IA64_P50   =   754,
    CV_IA64_P51   =   755,
    CV_IA64_P52   =   756,
    CV_IA64_P53   =   757,
    CV_IA64_P54   =   758,
    CV_IA64_P55   =   759,
    CV_IA64_P56   =   760,
    CV_IA64_P57   =   761,
    CV_IA64_P58   =   762,
    CV_IA64_P59   =   763,
    CV_IA64_P60   =   764,
    CV_IA64_P61   =   765,
    CV_IA64_P62   =   766,
    CV_IA64_P63   =   767,

    CV_IA64_Preds   =   768,

    // Banked General Registers

    CV_IA64_IntH0   =   832,
    CV_IA64_IntH1   =   833,
    CV_IA64_IntH2   =   834,
    CV_IA64_IntH3   =   835,
    CV_IA64_IntH4   =   836,
    CV_IA64_IntH5   =   837,
    CV_IA64_IntH6   =   838,
    CV_IA64_IntH7   =   839,
    CV_IA64_IntH8   =   840,
    CV_IA64_IntH9   =   841,
    CV_IA64_IntH10  =   842,
    CV_IA64_IntH11  =   843,
    CV_IA64_IntH12  =   844,
    CV_IA64_IntH13  =   845,
    CV_IA64_IntH14  =   846,
    CV_IA64_IntH15  =   847,

    // Special Registers

    CV_IA64_Ip      =   1016,
    CV_IA64_Umask   =   1017,
    CV_IA64_Cfm     =   1018,
    CV_IA64_Psr     =   1019,

    // Banked General Registers

    CV_IA64_Nats    =   1020,
    CV_IA64_Nats2   =   1021,
    CV_IA64_Nats3   =   1022,

    // General-Purpose Registers

    // Integer registers
    CV_IA64_IntR0   =   1024,
    CV_IA64_IntR1   =   1025,
    CV_IA64_IntR2   =   1026,
    CV_IA64_IntR3   =   1027,
    CV_IA64_IntR4   =   1028,
    CV_IA64_IntR5   =   1029,
    CV_IA64_IntR6   =   1030,
    CV_IA64_IntR7   =   1031,
    CV_IA64_IntR8   =   1032,
    CV_IA64_IntR9   =   1033,
    CV_IA64_IntR10  =   1034,
    CV_IA64_IntR11  =   1035,
    CV_IA64_IntR12  =   1036,
    CV_IA64_IntR13  =   1037,
    CV_IA64_IntR14  =   1038,
    CV_IA64_IntR15  =   1039,
    CV_IA64_IntR16  =   1040,
    CV_IA64_IntR17  =   1041,
    CV_IA64_IntR18  =   1042,
    CV_IA64_IntR19  =   1043,
    CV_IA64_IntR20  =   1044,
    CV_IA64_IntR21  =   1045,
    CV_IA64_IntR22  =   1046,
    CV_IA64_IntR23  =   1047,
    CV_IA64_IntR24  =   1048,
    CV_IA64_IntR25  =   1049,
    CV_IA64_IntR26  =   1050,
    CV_IA64_IntR27  =   1051,
    CV_IA64_IntR28  =   1052,
    CV_IA64_IntR29  =   1053,
    CV_IA64_IntR30  =   1054,
    CV_IA64_IntR31  =   1055,

    // Register Stack
    CV_IA64_IntR32  =   1056,
    CV_IA64_IntR33  =   1057,
    CV_IA64_IntR34  =   1058,
    CV_IA64_IntR35  =   1059,
    CV_IA64_IntR36  =   1060,
    CV_IA64_IntR37  =   1061,
    CV_IA64_IntR38  =   1062,
    CV_IA64_IntR39  =   1063,
    CV_IA64_IntR40  =   1064,
    CV_IA64_IntR41  =   1065,
    CV_IA64_IntR42  =   1066,
    CV_IA64_IntR43  =   1067,
    CV_IA64_IntR44  =   1068,
    CV_IA64_IntR45  =   1069,
    CV_IA64_IntR46  =   1070,
    CV_IA64_IntR47  =   1071,
    CV_IA64_IntR48  =   1072,
    CV_IA64_IntR49  =   1073,
    CV_IA64_IntR50  =   1074,
    CV_IA64_IntR51  =   1075,
    CV_IA64_IntR52  =   1076,
    CV_IA64_IntR53  =   1077,
    CV_IA64_IntR54  =   1078,
    CV_IA64_IntR55  =   1079,
    CV_IA64_IntR56  =   1080,
    CV_IA64_IntR57  =   1081,
    CV_IA64_IntR58  =   1082,
    CV_IA64_IntR59  =   1083,
    CV_IA64_IntR60  =   1084,
    CV_IA64_IntR61  =   1085,
    CV_IA64_IntR62  =   1086,
    CV_IA64_IntR63  =   1087,
    CV_IA64_IntR64  =   1088,
    CV_IA64_IntR65  =   1089,
    CV_IA64_IntR66  =   1090,
    CV_IA64_IntR67  =   1091,
    CV_IA64_IntR68  =   1092,
    CV_IA64_IntR69  =   1093,
    CV_IA64_IntR70  =   1094,
    CV_IA64_IntR71  =   1095,
    CV_IA64_IntR72  =   1096,
    CV_IA64_IntR73  =   1097,
    CV_IA64_IntR74  =   1098,
    CV_IA64_IntR75  =   1099,
    CV_IA64_IntR76  =   1100,
    CV_IA64_IntR77  =   1101,
    CV_IA64_IntR78  =   1102,
    CV_IA64_IntR79  =   1103,
    CV_IA64_IntR80  =   1104,
    CV_IA64_IntR81  =   1105,
    CV_IA64_IntR82  =   1106,
    CV_IA64_IntR83  =   1107,
    CV_IA64_IntR84  =   1108,
    CV_IA64_IntR85  =   1109,
    CV_IA64_IntR86  =   1110,
    CV_IA64_IntR87  =   1111,
    CV_IA64_IntR88  =   1112,
    CV_IA64_IntR89  =   1113,
    CV_IA64_IntR90  =   1114,
    CV_IA64_IntR91  =   1115,
    CV_IA64_IntR92  =   1116,
    CV_IA64_IntR93  =   1117,
    CV_IA64_IntR94  =   1118,
    CV_IA64_IntR95  =   1119,
    CV_IA64_IntR96  =   1120,
    CV_IA64_IntR97  =   1121,
    CV_IA64_IntR98  =   1122,
    CV_IA64_IntR99  =   1123,
    CV_IA64_IntR100 =   1124,
    CV_IA64_IntR101 =   1125,
    CV_IA64_IntR102 =   1126,
    CV_IA64_IntR103 =   1127,
    CV_IA64_IntR104 =   1128,
    CV_IA64_IntR105 =   1129,
    CV_IA64_IntR106 =   1130,
    CV_IA64_IntR107 =   1131,
    CV_IA64_IntR108 =   1132,
    CV_IA64_IntR109 =   1133,
    CV_IA64_IntR110 =   1134,
    CV_IA64_IntR111 =   1135,
    CV_IA64_IntR112 =   1136,
    CV_IA64_IntR113 =   1137,
    CV_IA64_IntR114 =   1138,
    CV_IA64_IntR115 =   1139,
    CV_IA64_IntR116 =   1140,
    CV_IA64_IntR117 =   1141,
    CV_IA64_IntR118 =   1142,
    CV_IA64_IntR119 =   1143,
    CV_IA64_IntR120 =   1144,
    CV_IA64_IntR121 =   1145,
    CV_IA64_IntR122 =   1146,
    CV_IA64_IntR123 =   1147,
    CV_IA64_IntR124 =   1148,
    CV_IA64_IntR125 =   1149,
    CV_IA64_IntR126 =   1150,
    CV_IA64_IntR127 =   1151,

    // Floating-Point Registers

    // Low Floating Point Registers
    CV_IA64_FltF0   =   2048,
    CV_IA64_FltF1   =   2049,
    CV_IA64_FltF2   =   2050,
    CV_IA64_FltF3   =   2051,
    CV_IA64_FltF4   =   2052,
    CV_IA64_FltF5   =   2053,
    CV_IA64_FltF6   =   2054,
    CV_IA64_FltF7   =   2055,
    CV_IA64_FltF8   =   2056,
    CV_IA64_FltF9   =   2057,
    CV_IA64_FltF10  =   2058,
    CV_IA64_FltF11  =   2059,
    CV_IA64_FltF12  =   2060,
    CV_IA64_FltF13  =   2061,
    CV_IA64_FltF14  =   2062,
    CV_IA64_FltF15  =   2063,
    CV_IA64_FltF16  =   2064,
    CV_IA64_FltF17  =   2065,
    CV_IA64_FltF18  =   2066,
    CV_IA64_FltF19  =   2067,
    CV_IA64_FltF20  =   2068,
    CV_IA64_FltF21  =   2069,
    CV_IA64_FltF22  =   2070,
    CV_IA64_FltF23  =   2071,
    CV_IA64_FltF24  =   2072,
    CV_IA64_FltF25  =   2073,
    CV_IA64_FltF26  =   2074,
    CV_IA64_FltF27  =   2075,
    CV_IA64_FltF28  =   2076,
    CV_IA64_FltF29  =   2077,
    CV_IA64_FltF30  =   2078,
    CV_IA64_FltF31  =   2079,

    // High Floating Point Registers
    CV_IA64_FltF32  =   2080,
    CV_IA64_FltF33  =   2081,
    CV_IA64_FltF34  =   2082,
    CV_IA64_FltF35  =   2083,
    CV_IA64_FltF36  =   2084,
    CV_IA64_FltF37  =   2085,
    CV_IA64_FltF38  =   2086,
    CV_IA64_FltF39  =   2087,
    CV_IA64_FltF40  =   2088,
    CV_IA64_FltF41  =   2089,
    CV_IA64_FltF42  =   2090,
    CV_IA64_FltF43  =   2091,
    CV_IA64_FltF44  =   2092,
    CV_IA64_FltF45  =   2093,
    CV_IA64_FltF46  =   2094,
    CV_IA64_FltF47  =   2095,
    CV_IA64_FltF48  =   2096,
    CV_IA64_FltF49  =   2097,
    CV_IA64_FltF50  =   2098,
    CV_IA64_FltF51  =   2099,
    CV_IA64_FltF52  =   2100,
    CV_IA64_FltF53  =   2101,
    CV_IA64_FltF54  =   2102,
    CV_IA64_FltF55  =   2103,
    CV_IA64_FltF56  =   2104,
    CV_IA64_FltF57  =   2105,
    CV_IA64_FltF58  =   2106,
    CV_IA64_FltF59  =   2107,
    CV_IA64_FltF60  =   2108,
    CV_IA64_FltF61  =   2109,
    CV_IA64_FltF62  =   2110,
    CV_IA64_FltF63  =   2111,
    CV_IA64_FltF64  =   2112,
    CV_IA64_FltF65  =   2113,
    CV_IA64_FltF66  =   2114,
    CV_IA64_FltF67  =   2115,
    CV_IA64_FltF68  =   2116,
    CV_IA64_FltF69  =   2117,
    CV_IA64_FltF70  =   2118,
    CV_IA64_FltF71  =   2119,
    CV_IA64_FltF72  =   2120,
    CV_IA64_FltF73  =   2121,
    CV_IA64_FltF74  =   2122,
    CV_IA64_FltF75  =   2123,
    CV_IA64_FltF76  =   2124,
    CV_IA64_FltF77  =   2125,
    CV_IA64_FltF78  =   2126,
    CV_IA64_FltF79  =   2127,
    CV_IA64_FltF80  =   2128,
    CV_IA64_FltF81  =   2129,
    CV_IA64_FltF82  =   2130,
    CV_IA64_FltF83  =   2131,
    CV_IA64_FltF84  =   2132,
    CV_IA64_FltF85  =   2133,
    CV_IA64_FltF86  =   2134,
    CV_IA64_FltF87  =   2135,
    CV_IA64_FltF88  =   2136,
    CV_IA64_FltF89  =   2137,
    CV_IA64_FltF90  =   2138,
    CV_IA64_FltF91  =   2139,
    CV_IA64_FltF92  =   2140,
    CV_IA64_FltF93  =   2141,
    CV_IA64_FltF94  =   2142,
    CV_IA64_FltF95  =   2143,
    CV_IA64_FltF96  =   2144,
    CV_IA64_FltF97  =   2145,
    CV_IA64_FltF98  =   2146,
    CV_IA64_FltF99  =   2147,
    CV_IA64_FltF100 =   2148,
    CV_IA64_FltF101 =   2149,
    CV_IA64_FltF102 =   2150,
    CV_IA64_FltF103 =   2151,
    CV_IA64_FltF104 =   2152,
    CV_IA64_FltF105 =   2153,
    CV_IA64_FltF106 =   2154,
    CV_IA64_FltF107 =   2155,
    CV_IA64_FltF108 =   2156,
    CV_IA64_FltF109 =   2157,
    CV_IA64_FltF110 =   2158,
    CV_IA64_FltF111 =   2159,
    CV_IA64_FltF112 =   2160,
    CV_IA64_FltF113 =   2161,
    CV_IA64_FltF114 =   2162,
    CV_IA64_FltF115 =   2163,
    CV_IA64_FltF116 =   2164,
    CV_IA64_FltF117 =   2165,
    CV_IA64_FltF118 =   2166,
    CV_IA64_FltF119 =   2167,
    CV_IA64_FltF120 =   2168,
    CV_IA64_FltF121 =   2169,
    CV_IA64_FltF122 =   2170,
    CV_IA64_FltF123 =   2171,
    CV_IA64_FltF124 =   2172,
    CV_IA64_FltF125 =   2173,
    CV_IA64_FltF126 =   2174,
    CV_IA64_FltF127 =   2175,

    // Application Registers

    CV_IA64_ApKR0   =   3072,
    CV_IA64_ApKR1   =   3073,
    CV_IA64_ApKR2   =   3074,
    CV_IA64_ApKR3   =   3075,
    CV_IA64_ApKR4   =   3076,
    CV_IA64_ApKR5   =   3077,
    CV_IA64_ApKR6   =   3078,
    CV_IA64_ApKR7   =   3079,
    CV_IA64_AR8     =   3080,
    CV_IA64_AR9     =   3081,
    CV_IA64_AR10    =   3082,
    CV_IA64_AR11    =   3083,
    CV_IA64_AR12    =   3084,
    CV_IA64_AR13    =   3085,
    CV_IA64_AR14    =   3086,
    CV_IA64_AR15    =   3087,
    CV_IA64_RsRSC   =   3088,
    CV_IA64_RsBSP   =   3089,
    CV_IA64_RsBSPSTORE  =   3090,
    CV_IA64_RsRNAT  =   3091,
    CV_IA64_AR20    =   3092,
    CV_IA64_StFCR   =   3093,
    CV_IA64_AR22    =   3094,
    CV_IA64_AR23    =   3095,
    CV_IA64_EFLAG   =   3096,
    CV_IA64_CSD     =   3097,
    CV_IA64_SSD     =   3098,
    CV_IA64_CFLG    =   3099,
    CV_IA64_StFSR   =   3100,
    CV_IA64_StFIR   =   3101,
    CV_IA64_StFDR   =   3102,
    CV_IA64_AR31    =   3103,
    CV_IA64_ApCCV   =   3104,
    CV_IA64_AR33    =   3105,
    CV_IA64_AR34    =   3106,
    CV_IA64_AR35    =   3107,
    CV_IA64_ApUNAT  =   3108,
    CV_IA64_AR37    =   3109,
    CV_IA64_AR38    =   3110,
    CV_IA64_AR39    =   3111,
    CV_IA64_StFPSR  =   3112,
    CV_IA64_AR41    =   3113,
    CV_IA64_AR42    =   3114,
    CV_IA64_AR43    =   3115,
    CV_IA64_ApITC   =   3116,
    CV_IA64_AR45    =   3117,
    CV_IA64_AR46    =   3118,
    CV_IA64_AR47    =   3119,
    CV_IA64_AR48    =   3120,
    CV_IA64_AR49    =   3121,
    CV_IA64_AR50    =   3122,
    CV_IA64_AR51    =   3123,
    CV_IA64_AR52    =   3124,
    CV_IA64_AR53    =   3125,
    CV_IA64_AR54    =   3126,
    CV_IA64_AR55    =   3127,
    CV_IA64_AR56    =   3128,
    CV_IA64_AR57    =   3129,
    CV_IA64_AR58    =   3130,
    CV_IA64_AR59    =   3131,
    CV_IA64_AR60    =   3132,
    CV_IA64_AR61    =   3133,
    CV_IA64_AR62    =   3134,
    CV_IA64_AR63    =   3135,
    CV_IA64_RsPFS   =   3136,
    CV_IA64_ApLC    =   3137,
    CV_IA64_ApEC    =   3138,
    CV_IA64_AR67    =   3139,
    CV_IA64_AR68    =   3140,
    CV_IA64_AR69    =   3141,
    CV_IA64_AR70    =   3142,
    CV_IA64_AR71    =   3143,
    CV_IA64_AR72    =   3144,
    CV_IA64_AR73    =   3145,
    CV_IA64_AR74    =   3146,
    CV_IA64_AR75    =   3147,
    CV_IA64_AR76    =   3148,
    CV_IA64_AR77    =   3149,
    CV_IA64_AR78    =   3150,
    CV_IA64_AR79    =   3151,
    CV_IA64_AR80    =   3152,
    CV_IA64_AR81    =   3153,
    CV_IA64_AR82    =   3154,
    CV_IA64_AR83    =   3155,
    CV_IA64_AR84    =   3156,
    CV_IA64_AR85    =   3157,
    CV_IA64_AR86    =   3158,
    CV_IA64_AR87    =   3159,
    CV_IA64_AR88    =   3160,
    CV_IA64_AR89    =   3161,
    CV_IA64_AR90    =   3162,
    CV_IA64_AR91    =   3163,
    CV_IA64_AR92    =   3164,
    CV_IA64_AR93    =   3165,
    CV_IA64_AR94    =   3166,
    CV_IA64_AR95    =   3167,
    CV_IA64_AR96    =   3168,
    CV_IA64_AR97    =   3169,
    CV_IA64_AR98    =   3170,
    CV_IA64_AR99    =   3171,
    CV_IA64_AR100   =   3172,
    CV_IA64_AR101   =   3173,
    CV_IA64_AR102   =   3174,
    CV_IA64_AR103   =   3175,
    CV_IA64_AR104   =   3176,
    CV_IA64_AR105   =   3177,
    CV_IA64_AR106   =   3178,
    CV_IA64_AR107   =   3179,
    CV_IA64_AR108   =   3180,
    CV_IA64_AR109   =   3181,
    CV_IA64_AR110   =   3182,
    CV_IA64_AR111   =   3183,
    CV_IA64_AR112   =   3184,
    CV_IA64_AR113   =   3185,
    CV_IA64_AR114   =   3186,
    CV_IA64_AR115   =   3187,
    CV_IA64_AR116   =   3188,
    CV_IA64_AR117   =   3189,
    CV_IA64_AR118   =   3190,
    CV_IA64_AR119   =   3191,
    CV_IA64_AR120   =   3192,
    CV_IA64_AR121   =   3193,
    CV_IA64_AR122   =   3194,
    CV_IA64_AR123   =   3195,
    CV_IA64_AR124   =   3196,
    CV_IA64_AR125   =   3197,
    CV_IA64_AR126   =   3198,
    CV_IA64_AR127   =   3199,

    // CPUID Registers

    CV_IA64_CPUID0  =   3328,
    CV_IA64_CPUID1  =   3329,
    CV_IA64_CPUID2  =   3330,
    CV_IA64_CPUID3  =   3331,
    CV_IA64_CPUID4  =   3332,

    // Control Registers

    CV_IA64_ApDCR   =   4096,
    CV_IA64_ApITM   =   4097,
    CV_IA64_ApIVA   =   4098,
    CV_IA64_CR3     =   4099,
    CV_IA64_CR4     =   4100,
    CV_IA64_CR5     =   4101,
    CV_IA64_CR6     =   4102,
    CV_IA64_CR7     =   4103,
    CV_IA64_ApPTA   =   4104,
    CV_IA64_ApGPTA  =   4105,
    CV_IA64_CR10    =   4106,
    CV_IA64_CR11    =   4107,
    CV_IA64_CR12    =   4108,
    CV_IA64_CR13    =   4109,
    CV_IA64_CR14    =   4110,
    CV_IA64_CR15    =   4111,
    CV_IA64_StIPSR  =   4112,
    CV_IA64_StISR   =   4113,
    CV_IA64_CR18    =   4114,
    CV_IA64_StIIP   =   4115,
    CV_IA64_StIFA   =   4116,
    CV_IA64_StITIR  =   4117,
    CV_IA64_StIIPA  =   4118,
    CV_IA64_StIFS   =   4119,
    CV_IA64_StIIM   =   4120,
    CV_IA64_StIHA   =   4121,
    CV_IA64_CR26    =   4122,
    CV_IA64_CR27    =   4123,
    CV_IA64_CR28    =   4124,
    CV_IA64_CR29    =   4125,
    CV_IA64_CR30    =   4126,
    CV_IA64_CR31    =   4127,
    CV_IA64_CR32    =   4128,
    CV_IA64_CR33    =   4129,
    CV_IA64_CR34    =   4130,
    CV_IA64_CR35    =   4131,
    CV_IA64_CR36    =   4132,
    CV_IA64_CR37    =   4133,
    CV_IA64_CR38    =   4134,
    CV_IA64_CR39    =   4135,
    CV_IA64_CR40    =   4136,
    CV_IA64_CR41    =   4137,
    CV_IA64_CR42    =   4138,
    CV_IA64_CR43    =   4139,
    CV_IA64_CR44    =   4140,
    CV_IA64_CR45    =   4141,
    CV_IA64_CR46    =   4142,
    CV_IA64_CR47    =   4143,
    CV_IA64_CR48    =   4144,
    CV_IA64_CR49    =   4145,
    CV_IA64_CR50    =   4146,
    CV_IA64_CR51    =   4147,
    CV_IA64_CR52    =   4148,
    CV_IA64_CR53    =   4149,
    CV_IA64_CR54    =   4150,
    CV_IA64_CR55    =   4151,
    CV_IA64_CR56    =   4152,
    CV_IA64_CR57    =   4153,
    CV_IA64_CR58    =   4154,
    CV_IA64_CR59    =   4155,
    CV_IA64_CR60    =   4156,
    CV_IA64_CR61    =   4157,
    CV_IA64_CR62    =   4158,
    CV_IA64_CR63    =   4159,
    CV_IA64_SaLID   =   4160,
    CV_IA64_SaIVR   =   4161,
    CV_IA64_SaTPR   =   4162,
    CV_IA64_SaEOI   =   4163,
    CV_IA64_SaIRR0  =   4164,
    CV_IA64_SaIRR1  =   4165,
    CV_IA64_SaIRR2  =   4166,
    CV_IA64_SaIRR3  =   4167,
    CV_IA64_SaITV   =   4168,
    CV_IA64_SaPMV   =   4169,
    CV_IA64_SaCMCV  =   4170,
    CV_IA64_CR75    =   4171,
    CV_IA64_CR76    =   4172,
    CV_IA64_CR77    =   4173,
    CV_IA64_CR78    =   4174,
    CV_IA64_CR79    =   4175,
    CV_IA64_SaLRR0  =   4176,
    CV_IA64_SaLRR1  =   4177,
    CV_IA64_CR82    =   4178,
    CV_IA64_CR83    =   4179,
    CV_IA64_CR84    =   4180,
    CV_IA64_CR85    =   4181,
    CV_IA64_CR86    =   4182,
    CV_IA64_CR87    =   4183,
    CV_IA64_CR88    =   4184,
    CV_IA64_CR89    =   4185,
    CV_IA64_CR90    =   4186,
    CV_IA64_CR91    =   4187,
    CV_IA64_CR92    =   4188,
    CV_IA64_CR93    =   4189,
    CV_IA64_CR94    =   4190,
    CV_IA64_CR95    =   4191,
    CV_IA64_CR96    =   4192,
    CV_IA64_CR97    =   4193,
    CV_IA64_CR98    =   4194,
    CV_IA64_CR99    =   4195,
    CV_IA64_CR100   =   4196,
    CV_IA64_CR101   =   4197,
    CV_IA64_CR102   =   4198,
    CV_IA64_CR103   =   4199,
    CV_IA64_CR104   =   4200,
    CV_IA64_CR105   =   4201,
    CV_IA64_CR106   =   4202,
    CV_IA64_CR107   =   4203,
    CV_IA64_CR108   =   4204,
    CV_IA64_CR109   =   4205,
    CV_IA64_CR110   =   4206,
    CV_IA64_CR111   =   4207,
    CV_IA64_CR112   =   4208,
    CV_IA64_CR113   =   4209,
    CV_IA64_CR114   =   4210,
    CV_IA64_CR115   =   4211,
    CV_IA64_CR116   =   4212,
    CV_IA64_CR117   =   4213,
    CV_IA64_CR118   =   4214,
    CV_IA64_CR119   =   4215,
    CV_IA64_CR120   =   4216,
    CV_IA64_CR121   =   4217,
    CV_IA64_CR122   =   4218,
    CV_IA64_CR123   =   4219,
    CV_IA64_CR124   =   4220,
    CV_IA64_CR125   =   4221,
    CV_IA64_CR126   =   4222,
    CV_IA64_CR127   =   4223,

    // Protection Key Registers

    CV_IA64_Pkr0    =   5120,
    CV_IA64_Pkr1    =   5121,
    CV_IA64_Pkr2    =   5122,
    CV_IA64_Pkr3    =   5123,
    CV_IA64_Pkr4    =   5124,
    CV_IA64_Pkr5    =   5125,
    CV_IA64_Pkr6    =   5126,
    CV_IA64_Pkr7    =   5127,
    CV_IA64_Pkr8    =   5128,
    CV_IA64_Pkr9    =   5129,
    CV_IA64_Pkr10   =   5130,
    CV_IA64_Pkr11   =   5131,
    CV_IA64_Pkr12   =   5132,
    CV_IA64_Pkr13   =   5133,
    CV_IA64_Pkr14   =   5134,
    CV_IA64_Pkr15   =   5135,

    // Region Registers

    CV_IA64_Rr0     =   6144,
    CV_IA64_Rr1     =   6145,
    CV_IA64_Rr2     =   6146,
    CV_IA64_Rr3     =   6147,
    CV_IA64_Rr4     =   6148,
    CV_IA64_Rr5     =   6149,
    CV_IA64_Rr6     =   6150,
    CV_IA64_Rr7     =   6151,

    // Performance Monitor Data Registers

    CV_IA64_PFD0    =   7168,
    CV_IA64_PFD1    =   7169,
    CV_IA64_PFD2    =   7170,
    CV_IA64_PFD3    =   7171,
    CV_IA64_PFD4    =   7172,
    CV_IA64_PFD5    =   7173,
    CV_IA64_PFD6    =   7174,
    CV_IA64_PFD7    =   7175,
    CV_IA64_PFD8    =   7176,
    CV_IA64_PFD9    =   7177,
    CV_IA64_PFD10   =   7178,
    CV_IA64_PFD11   =   7179,
    CV_IA64_PFD12   =   7180,
    CV_IA64_PFD13   =   7181,
    CV_IA64_PFD14   =   7182,
    CV_IA64_PFD15   =   7183,
    CV_IA64_PFD16   =   7184,
    CV_IA64_PFD17   =   7185,

    // Performance Monitor Config Registers

    CV_IA64_PFC0    =   7424,
    CV_IA64_PFC1    =   7425,
    CV_IA64_PFC2    =   7426,
    CV_IA64_PFC3    =   7427,
    CV_IA64_PFC4    =   7428,
    CV_IA64_PFC5    =   7429,
    CV_IA64_PFC6    =   7430,
    CV_IA64_PFC7    =   7431,
    CV_IA64_PFC8    =   7432,
    CV_IA64_PFC9    =   7433,
    CV_IA64_PFC10   =   7434,
    CV_IA64_PFC11   =   7435,
    CV_IA64_PFC12   =   7436,
    CV_IA64_PFC13   =   7437,
    CV_IA64_PFC14   =   7438,
    CV_IA64_PFC15   =   7439,

    // Instruction Translation Registers

    CV_IA64_TrI0    =   8192,
    CV_IA64_TrI1    =   8193,
    CV_IA64_TrI2    =   8194,
    CV_IA64_TrI3    =   8195,
    CV_IA64_TrI4    =   8196,
    CV_IA64_TrI5    =   8197,
    CV_IA64_TrI6    =   8198,
    CV_IA64_TrI7    =   8199,

    // Data Translation Registers

    CV_IA64_TrD0    =   8320,
    CV_IA64_TrD1    =   8321,
    CV_IA64_TrD2    =   8322,
    CV_IA64_TrD3    =   8323,
    CV_IA64_TrD4    =   8324,
    CV_IA64_TrD5    =   8325,
    CV_IA64_TrD6    =   8326,
    CV_IA64_TrD7    =   8327,

    // Instruction Breakpoint Registers

    CV_IA64_DbI0    =   8448,
    CV_IA64_DbI1    =   8449,
    CV_IA64_DbI2    =   8450,
    CV_IA64_DbI3    =   8451,
    CV_IA64_DbI4    =   8452,
    CV_IA64_DbI5    =   8453,
    CV_IA64_DbI6    =   8454,
    CV_IA64_DbI7    =   8455,

    // Data Breakpoint Registers

    CV_IA64_DbD0    =   8576,
    CV_IA64_DbD1    =   8577,
    CV_IA64_DbD2    =   8578,
    CV_IA64_DbD3    =   8579,
    CV_IA64_DbD4    =   8580,
    CV_IA64_DbD5    =   8581,
    CV_IA64_DbD6    =   8582,
    CV_IA64_DbD7    =   8583,

    //
    // Register set for the TriCore processor.
    //

    CV_TRI_NOREG    =   CV_REG_NONE,

    // General Purpose Data Registers

    CV_TRI_D0   =   10,
    CV_TRI_D1   =   11,
    CV_TRI_D2   =   12,
    CV_TRI_D3   =   13,
    CV_TRI_D4   =   14,
    CV_TRI_D5   =   15,
    CV_TRI_D6   =   16,
    CV_TRI_D7   =   17,
    CV_TRI_D8   =   18,
    CV_TRI_D9   =   19,
    CV_TRI_D10  =   20,
    CV_TRI_D11  =   21,
    CV_TRI_D12  =   22,
    CV_TRI_D13  =   23,
    CV_TRI_D14  =   24,
    CV_TRI_D15  =   25,

    // General Purpose Address Registers

    CV_TRI_A0   =   26,
    CV_TRI_A1   =   27,
    CV_TRI_A2   =   28,
    CV_TRI_A3   =   29,
    CV_TRI_A4   =   30,
    CV_TRI_A5   =   31,
    CV_TRI_A6   =   32,
    CV_TRI_A7   =   33,
    CV_TRI_A8   =   34,
    CV_TRI_A9   =   35,
    CV_TRI_A10  =   36,
    CV_TRI_A11  =   37,
    CV_TRI_A12  =   38,
    CV_TRI_A13  =   39,
    CV_TRI_A14  =   40,
    CV_TRI_A15  =   41,

    // Extended (64-bit) data registers

    CV_TRI_E0   =   42,
    CV_TRI_E2   =   43,
    CV_TRI_E4   =   44,
    CV_TRI_E6   =   45,
    CV_TRI_E8   =   46,
    CV_TRI_E10  =   47,
    CV_TRI_E12  =   48,
    CV_TRI_E14  =   49,

    // Extended (64-bit) address registers

    CV_TRI_EA0  =   50,
    CV_TRI_EA2  =   51,
    CV_TRI_EA4  =   52,
    CV_TRI_EA6  =   53,
    CV_TRI_EA8  =   54,
    CV_TRI_EA10 =   55,
    CV_TRI_EA12 =   56,
    CV_TRI_EA14 =   57,

    CV_TRI_PSW  =   58,
    CV_TRI_PCXI =   59,
    CV_TRI_PC   =   60,
    CV_TRI_FCX  =   61,
    CV_TRI_LCX  =   62,
    CV_TRI_ISP  =   63,
    CV_TRI_ICR  =   64,
    CV_TRI_BIV  =   65,
    CV_TRI_BTV  =   66,
    CV_TRI_SYSCON   =   67,
    CV_TRI_DPRx_0   =   68,
    CV_TRI_DPRx_1   =   69,
    CV_TRI_DPRx_2   =   70,
    CV_TRI_DPRx_3   =   71,
    CV_TRI_CPRx_0   =   68,
    CV_TRI_CPRx_1   =   69,
    CV_TRI_CPRx_2   =   70,
    CV_TRI_CPRx_3   =   71,
    CV_TRI_DPMx_0   =   68,
    CV_TRI_DPMx_1   =   69,
    CV_TRI_DPMx_2   =   70,
    CV_TRI_DPMx_3   =   71,
    CV_TRI_CPMx_0   =   68,
    CV_TRI_CPMx_1   =   69,
    CV_TRI_CPMx_2   =   70,
    CV_TRI_CPMx_3   =   71,
    CV_TRI_DBGSSR   =   72,
    CV_TRI_EXEVT    =   73,
    CV_TRI_SWEVT    =   74,
    CV_TRI_CREVT    =   75,
    CV_TRI_TRnEVT   =   76,
    CV_TRI_MMUCON   =   77,
    CV_TRI_ASI      =   78,
    CV_TRI_TVA      =   79,
    CV_TRI_TPA      =   80,
    CV_TRI_TPX      =   81,
    CV_TRI_TFA      =   82,

    //
    // Register set for the AM33 and related processors.
    //

    CV_AM33_NOREG   =   CV_REG_NONE,

    // "Extended" (general purpose integer) registers
    CV_AM33_E0      =   10,
    CV_AM33_E1      =   11,
    CV_AM33_E2      =   12,
    CV_AM33_E3      =   13,
    CV_AM33_E4      =   14,
    CV_AM33_E5      =   15,
    CV_AM33_E6      =   16,
    CV_AM33_E7      =   17,

    // Address registers
    CV_AM33_A0      =   20,
    CV_AM33_A1      =   21,
    CV_AM33_A2      =   22,
    CV_AM33_A3      =   23,

    // Integer data registers
    CV_AM33_D0      =   30,
    CV_AM33_D1      =   31,
    CV_AM33_D2      =   32,
    CV_AM33_D3      =   33,

    // (Single-precision) floating-point registers
    CV_AM33_FS0     =   40,
    CV_AM33_FS1     =   41,
    CV_AM33_FS2     =   42,
    CV_AM33_FS3     =   43,
    CV_AM33_FS4     =   44,
    CV_AM33_FS5     =   45,
    CV_AM33_FS6     =   46,
    CV_AM33_FS7     =   47,
    CV_AM33_FS8     =   48,
    CV_AM33_FS9     =   49,
    CV_AM33_FS10    =   50,
    CV_AM33_FS11    =   51,
    CV_AM33_FS12    =   52,
    CV_AM33_FS13    =   53,
    CV_AM33_FS14    =   54,
    CV_AM33_FS15    =   55,
    CV_AM33_FS16    =   56,
    CV_AM33_FS17    =   57,
    CV_AM33_FS18    =   58,
    CV_AM33_FS19    =   59,
    CV_AM33_FS20    =   60,
    CV_AM33_FS21    =   61,
    CV_AM33_FS22    =   62,
    CV_AM33_FS23    =   63,
    CV_AM33_FS24    =   64,
    CV_AM33_FS25    =   65,
    CV_AM33_FS26    =   66,
    CV_AM33_FS27    =   67,
    CV_AM33_FS28    =   68,
    CV_AM33_FS29    =   69,
    CV_AM33_FS30    =   70,
    CV_AM33_FS31    =   71,

    // Special purpose registers

    // Stack pointer
    CV_AM33_SP      =   80,

    // Program counter
    CV_AM33_PC      =   81,

    // Multiply-divide/accumulate registers
    CV_AM33_MDR     =   82,
    CV_AM33_MDRQ    =   83,
    CV_AM33_MCRH    =   84,
    CV_AM33_MCRL    =   85,
    CV_AM33_MCVF    =   86,

    // CPU status words
    CV_AM33_EPSW    =   87,
    CV_AM33_FPCR    =   88,

    // Loop buffer registers
    CV_AM33_LIR     =   89,
    CV_AM33_LAR     =   90,

    //
    // Register set for the Mitsubishi M32R
    //

    CV_M32R_NOREG    =   CV_REG_NONE,

    CV_M32R_R0    =   10,
    CV_M32R_R1    =   11,
    CV_M32R_R2    =   12,
    CV_M32R_R3    =   13,
    CV_M32R_R4    =   14,
    CV_M32R_R5    =   15,
    CV_M32R_R6    =   16,
    CV_M32R_R7    =   17,
    CV_M32R_R8    =   18,
    CV_M32R_R9    =   19,
    CV_M32R_R10   =   20,
    CV_M32R_R11   =   21,
    CV_M32R_R12   =   22,   // Gloabal Pointer, if used
    CV_M32R_R13   =   23,   // Frame Pointer, if allocated
    CV_M32R_R14   =   24,   // Link Register
    CV_M32R_R15   =   25,   // Stack Pointer
    CV_M32R_PSW   =   26,   // Preocessor Status Register
    CV_M32R_CBR   =   27,   // Condition Bit Register
    CV_M32R_SPI   =   28,   // Interrupt Stack Pointer
    CV_M32R_SPU   =   29,   // User Stack Pointer
    CV_M32R_SPO   =   30,   // OS Stack Pointer
    CV_M32R_BPC   =   31,   // Backup Program Counter
    CV_M32R_ACHI  =   32,   // Accumulator High
    CV_M32R_ACLO  =   33,   // Accumulator Low
    CV_M32R_PC    =   34,   // Program Counter

    //
    // Register set for the SuperH SHMedia processor including compact
    // mode
    //

    // Integer - 64 bit general registers
    CV_SHMEDIA_NOREG   =   CV_REG_NONE,
    CV_SHMEDIA_R0      =   10,
    CV_SHMEDIA_R1      =   11,
    CV_SHMEDIA_R2      =   12,
    CV_SHMEDIA_R3      =   13,
    CV_SHMEDIA_R4      =   14,
    CV_SHMEDIA_R5      =   15,
    CV_SHMEDIA_R6      =   16,
    CV_SHMEDIA_R7      =   17,
    CV_SHMEDIA_R8      =   18,
    CV_SHMEDIA_R9      =   19,
    CV_SHMEDIA_R10     =   20,
    CV_SHMEDIA_R11     =   21,
    CV_SHMEDIA_R12     =   22,
    CV_SHMEDIA_R13     =   23,
    CV_SHMEDIA_R14     =   24,
    CV_SHMEDIA_R15     =   25,
    CV_SHMEDIA_R16     =   26,
    CV_SHMEDIA_R17     =   27,
    CV_SHMEDIA_R18     =   28,
    CV_SHMEDIA_R19     =   29,
    CV_SHMEDIA_R20     =   30,
    CV_SHMEDIA_R21     =   31,
    CV_SHMEDIA_R22     =   32,
    CV_SHMEDIA_R23     =   33,
    CV_SHMEDIA_R24     =   34,
    CV_SHMEDIA_R25     =   35,
    CV_SHMEDIA_R26     =   36,
    CV_SHMEDIA_R27     =   37,
    CV_SHMEDIA_R28     =   38,
    CV_SHMEDIA_R29     =   39,
    CV_SHMEDIA_R30     =   40,
    CV_SHMEDIA_R31     =   41,
    CV_SHMEDIA_R32     =   42,
    CV_SHMEDIA_R33     =   43,
    CV_SHMEDIA_R34     =   44,
    CV_SHMEDIA_R35     =   45,
    CV_SHMEDIA_R36     =   46,
    CV_SHMEDIA_R37     =   47,
    CV_SHMEDIA_R38     =   48,
    CV_SHMEDIA_R39     =   49,
    CV_SHMEDIA_R40     =   50,
    CV_SHMEDIA_R41     =   51,
    CV_SHMEDIA_R42     =   52,
    CV_SHMEDIA_R43     =   53,
    CV_SHMEDIA_R44     =   54,
    CV_SHMEDIA_R45     =   55,
    CV_SHMEDIA_R46     =   56,
    CV_SHMEDIA_R47     =   57,
    CV_SHMEDIA_R48     =   58,
    CV_SHMEDIA_R49     =   59,
    CV_SHMEDIA_R50     =   60,
    CV_SHMEDIA_R51     =   61,
    CV_SHMEDIA_R52     =   62,
    CV_SHMEDIA_R53     =   63,
    CV_SHMEDIA_R54     =   64,
    CV_SHMEDIA_R55     =   65,
    CV_SHMEDIA_R56     =   66,
    CV_SHMEDIA_R57     =   67,
    CV_SHMEDIA_R58     =   68,
    CV_SHMEDIA_R59     =   69,
    CV_SHMEDIA_R60     =   70,
    CV_SHMEDIA_R61     =   71,
    CV_SHMEDIA_R62     =   72,
    CV_SHMEDIA_R63     =   73,
    
    // Target Registers - 32 bit
    CV_SHMEDIA_TR0     =   74,
    CV_SHMEDIA_TR1     =   75,
    CV_SHMEDIA_TR2     =   76,
    CV_SHMEDIA_TR3     =   77,
    CV_SHMEDIA_TR4     =   78,
    CV_SHMEDIA_TR5     =   79,
    CV_SHMEDIA_TR6     =   80,
    CV_SHMEDIA_TR7     =   81,
    CV_SHMEDIA_TR8     =   82, // future-proof
    CV_SHMEDIA_TR9     =   83, // future-proof
    CV_SHMEDIA_TR10    =   84, // future-proof
    CV_SHMEDIA_TR11    =   85, // future-proof
    CV_SHMEDIA_TR12    =   86, // future-proof
    CV_SHMEDIA_TR13    =   87, // future-proof
    CV_SHMEDIA_TR14    =   88, // future-proof
    CV_SHMEDIA_TR15    =   89, // future-proof

    // Single - 32 bit fp registers
    CV_SHMEDIA_FR0     =   128,
    CV_SHMEDIA_FR1     =   129,
    CV_SHMEDIA_FR2     =   130,
    CV_SHMEDIA_FR3     =   131,
    CV_SHMEDIA_FR4     =   132,
    CV_SHMEDIA_FR5     =   133,
    CV_SHMEDIA_FR6     =   134,
    CV_SHMEDIA_FR7     =   135,
    CV_SHMEDIA_FR8     =   136,
    CV_SHMEDIA_FR9     =   137,
    CV_SHMEDIA_FR10    =   138,
    CV_SHMEDIA_FR11    =   139,
    CV_SHMEDIA_FR12    =   140,
    CV_SHMEDIA_FR13    =   141,
    CV_SHMEDIA_FR14    =   142,
    CV_SHMEDIA_FR15    =   143,
    CV_SHMEDIA_FR16    =   144,
    CV_SHMEDIA_FR17    =   145,
    CV_SHMEDIA_FR18    =   146,
    CV_SHMEDIA_FR19    =   147,
    CV_SHMEDIA_FR20    =   148,
    CV_SHMEDIA_FR21    =   149,
    CV_SHMEDIA_FR22    =   150,
    CV_SHMEDIA_FR23    =   151,
    CV_SHMEDIA_FR24    =   152,
    CV_SHMEDIA_FR25    =   153,
    CV_SHMEDIA_FR26    =   154,
    CV_SHMEDIA_FR27    =   155,
    CV_SHMEDIA_FR28    =   156,
    CV_SHMEDIA_FR29    =   157,
    CV_SHMEDIA_FR30    =   158,
    CV_SHMEDIA_FR31    =   159,
    CV_SHMEDIA_FR32    =   160,
    CV_SHMEDIA_FR33    =   161,
    CV_SHMEDIA_FR34    =   162,
    CV_SHMEDIA_FR35    =   163,
    CV_SHMEDIA_FR36    =   164,
    CV_SHMEDIA_FR37    =   165,
    CV_SHMEDIA_FR38    =   166,
    CV_SHMEDIA_FR39    =   167,
    CV_SHMEDIA_FR40    =   168,
    CV_SHMEDIA_FR41    =   169,
    CV_SHMEDIA_FR42    =   170,
    CV_SHMEDIA_FR43    =   171,
    CV_SHMEDIA_FR44    =   172,
    CV_SHMEDIA_FR45    =   173,
    CV_SHMEDIA_FR46    =   174,
    CV_SHMEDIA_FR47    =   175,
    CV_SHMEDIA_FR48    =   176,
    CV_SHMEDIA_FR49    =   177,
    CV_SHMEDIA_FR50    =   178,
    CV_SHMEDIA_FR51    =   179,
    CV_SHMEDIA_FR52    =   180,
    CV_SHMEDIA_FR53    =   181,
    CV_SHMEDIA_FR54    =   182,
    CV_SHMEDIA_FR55    =   183,
    CV_SHMEDIA_FR56    =   184,
    CV_SHMEDIA_FR57    =   185,
    CV_SHMEDIA_FR58    =   186,
    CV_SHMEDIA_FR59    =   187,
    CV_SHMEDIA_FR60    =   188,
    CV_SHMEDIA_FR61    =   189,
    CV_SHMEDIA_FR62    =   190,
    CV_SHMEDIA_FR63    =   191,

    // Double - 64 bit synonyms for 32bit fp register pairs
    //          subtract 128 to find first base single register
    CV_SHMEDIA_DR0     =   256,
    CV_SHMEDIA_DR2     =   258,
    CV_SHMEDIA_DR4     =   260,
    CV_SHMEDIA_DR6     =   262,
    CV_SHMEDIA_DR8     =   264,
    CV_SHMEDIA_DR10    =   266,
    CV_SHMEDIA_DR12    =   268,
    CV_SHMEDIA_DR14    =   270,
    CV_SHMEDIA_DR16    =   272,
    CV_SHMEDIA_DR18    =   274,
    CV_SHMEDIA_DR20    =   276,
    CV_SHMEDIA_DR22    =   278,
    CV_SHMEDIA_DR24    =   280,
    CV_SHMEDIA_DR26    =   282,
    CV_SHMEDIA_DR28    =   284,
    CV_SHMEDIA_DR30    =   286,
    CV_SHMEDIA_DR32    =   288,
    CV_SHMEDIA_DR34    =   290,
    CV_SHMEDIA_DR36    =   292,
    CV_SHMEDIA_DR38    =   294,
    CV_SHMEDIA_DR40    =   296,
    CV_SHMEDIA_DR42    =   298,
    CV_SHMEDIA_DR44    =   300,
    CV_SHMEDIA_DR46    =   302,
    CV_SHMEDIA_DR48    =   304,
    CV_SHMEDIA_DR50    =   306,
    CV_SHMEDIA_DR52    =   308,
    CV_SHMEDIA_DR54    =   310,
    CV_SHMEDIA_DR56    =   312,
    CV_SHMEDIA_DR58    =   314,
    CV_SHMEDIA_DR60    =   316,
    CV_SHMEDIA_DR62    =   318,

    // Vector - 128 bit synonyms for 32bit fp register quads
    //          subtract 384 to find first base single register
    CV_SHMEDIA_FV0     =   512,
    CV_SHMEDIA_FV4     =   516,
    CV_SHMEDIA_FV8     =   520,
    CV_SHMEDIA_FV12    =   524,
    CV_SHMEDIA_FV16    =   528,
    CV_SHMEDIA_FV20    =   532,
    CV_SHMEDIA_FV24    =   536,
    CV_SHMEDIA_FV28    =   540,
    CV_SHMEDIA_FV32    =   544,
    CV_SHMEDIA_FV36    =   548,
    CV_SHMEDIA_FV40    =   552,
    CV_SHMEDIA_FV44    =   556,
    CV_SHMEDIA_FV48    =   560,
    CV_SHMEDIA_FV52    =   564,
    CV_SHMEDIA_FV56    =   568,
    CV_SHMEDIA_FV60    =   572,

    // Matrix - 512 bit synonyms for 16 adjacent 32bit fp registers
    //          subtract 896 to find first base single register
    CV_SHMEDIA_MTRX0   =   1024,
    CV_SHMEDIA_MTRX16  =   1040,
    CV_SHMEDIA_MTRX32  =   1056,
    CV_SHMEDIA_MTRX48  =   1072,

    // Control - Implementation defined 64bit control registers
    CV_SHMEDIA_CR0     =   2000,
    CV_SHMEDIA_CR1     =   2001,
    CV_SHMEDIA_CR2     =   2002,
    CV_SHMEDIA_CR3     =   2003,
    CV_SHMEDIA_CR4     =   2004,
    CV_SHMEDIA_CR5     =   2005,
    CV_SHMEDIA_CR6     =   2006,
    CV_SHMEDIA_CR7     =   2007,
    CV_SHMEDIA_CR8     =   2008,
    CV_SHMEDIA_CR9     =   2009,
    CV_SHMEDIA_CR10    =   2010,
    CV_SHMEDIA_CR11    =   2011,
    CV_SHMEDIA_CR12    =   2012,
    CV_SHMEDIA_CR13    =   2013,
    CV_SHMEDIA_CR14    =   2014,
    CV_SHMEDIA_CR15    =   2015,
    CV_SHMEDIA_CR16    =   2016,
    CV_SHMEDIA_CR17    =   2017,
    CV_SHMEDIA_CR18    =   2018,
    CV_SHMEDIA_CR19    =   2019,
    CV_SHMEDIA_CR20    =   2020,
    CV_SHMEDIA_CR21    =   2021,
    CV_SHMEDIA_CR22    =   2022,
    CV_SHMEDIA_CR23    =   2023,
    CV_SHMEDIA_CR24    =   2024,
    CV_SHMEDIA_CR25    =   2025,
    CV_SHMEDIA_CR26    =   2026,
    CV_SHMEDIA_CR27    =   2027,
    CV_SHMEDIA_CR28    =   2028,
    CV_SHMEDIA_CR29    =   2029,
    CV_SHMEDIA_CR30    =   2030,
    CV_SHMEDIA_CR31    =   2031,
    CV_SHMEDIA_CR32    =   2032,
    CV_SHMEDIA_CR33    =   2033,
    CV_SHMEDIA_CR34    =   2034,
    CV_SHMEDIA_CR35    =   2035,
    CV_SHMEDIA_CR36    =   2036,
    CV_SHMEDIA_CR37    =   2037,
    CV_SHMEDIA_CR38    =   2038,
    CV_SHMEDIA_CR39    =   2039,
    CV_SHMEDIA_CR40    =   2040,
    CV_SHMEDIA_CR41    =   2041,
    CV_SHMEDIA_CR42    =   2042,
    CV_SHMEDIA_CR43    =   2043,
    CV_SHMEDIA_CR44    =   2044,
    CV_SHMEDIA_CR45    =   2045,
    CV_SHMEDIA_CR46    =   2046,
    CV_SHMEDIA_CR47    =   2047,
    CV_SHMEDIA_CR48    =   2048,
    CV_SHMEDIA_CR49    =   2049,
    CV_SHMEDIA_CR50    =   2050,
    CV_SHMEDIA_CR51    =   2051,
    CV_SHMEDIA_CR52    =   2052,
    CV_SHMEDIA_CR53    =   2053,
    CV_SHMEDIA_CR54    =   2054,
    CV_SHMEDIA_CR55    =   2055,
    CV_SHMEDIA_CR56    =   2056,
    CV_SHMEDIA_CR57    =   2057,
    CV_SHMEDIA_CR58    =   2058,
    CV_SHMEDIA_CR59    =   2059,
    CV_SHMEDIA_CR60    =   2060,
    CV_SHMEDIA_CR61    =   2061,
    CV_SHMEDIA_CR62    =   2062,
    CV_SHMEDIA_CR63    =   2063,

    CV_SHMEDIA_FPSCR   =   2064,

    // Compact mode synonyms
    CV_SHMEDIA_GBR     =   CV_SHMEDIA_R16,
    CV_SHMEDIA_MACL    =   90, // synonym for lower 32bits of media R17
    CV_SHMEDIA_MACH    =   91, // synonym for upper 32bits of media R17
    CV_SHMEDIA_PR      =   CV_SHMEDIA_R18,
    CV_SHMEDIA_T       =   92, // synonym for lowest bit of media R19
    CV_SHMEDIA_FPUL    =   CV_SHMEDIA_FR32,
    CV_SHMEDIA_PC      =   93,
    CV_SHMEDIA_SR      =   CV_SHMEDIA_CR0,

    //
    // AMD64 registers
    //

    CV_AMD64_AL       =   1,
    CV_AMD64_CL       =   2,
    CV_AMD64_DL       =   3,
    CV_AMD64_BL       =   4,
    CV_AMD64_AH       =   5,
    CV_AMD64_CH       =   6,
    CV_AMD64_DH       =   7,
    CV_AMD64_BH       =   8,
    CV_AMD64_AX       =   9,
    CV_AMD64_CX       =  10,
    CV_AMD64_DX       =  11,
    CV_AMD64_BX       =  12,
    CV_AMD64_SP       =  13,
    CV_AMD64_BP       =  14,
    CV_AMD64_SI       =  15,
    CV_AMD64_DI       =  16,
    CV_AMD64_EAX      =  17,
    CV_AMD64_ECX      =  18,
    CV_AMD64_EDX      =  19,
    CV_AMD64_EBX      =  20,
    CV_AMD64_ESP      =  21,
    CV_AMD64_EBP      =  22,
    CV_AMD64_ESI      =  23,
    CV_AMD64_EDI      =  24,
    CV_AMD64_ES       =  25,
    CV_AMD64_CS       =  26,
    CV_AMD64_SS       =  27,
    CV_AMD64_DS       =  28,
    CV_AMD64_FS       =  29,
    CV_AMD64_GS       =  30,
    CV_AMD64_FLAGS    =  32,
    CV_AMD64_RIP      =  33,
    CV_AMD64_EFLAGS   =  34,

    // Control registers
    CV_AMD64_CR0      =  80,
    CV_AMD64_CR1      =  81,
    CV_AMD64_CR2      =  82,
    CV_AMD64_CR3      =  83,
    CV_AMD64_CR4      =  84,
    CV_AMD64_CR8      =  88,

    // Debug registers
    CV_AMD64_DR0      =  90,
    CV_AMD64_DR1      =  91,
    CV_AMD64_DR2      =  92,
    CV_AMD64_DR3      =  93,
    CV_AMD64_DR4      =  94,
    CV_AMD64_DR5      =  95,
    CV_AMD64_DR6      =  96,
    CV_AMD64_DR7      =  97,
    CV_AMD64_DR8      =  98,
    CV_AMD64_DR9      =  99,
    CV_AMD64_DR10     =  100,
    CV_AMD64_DR11     =  101,
    CV_AMD64_DR12     =  102,
    CV_AMD64_DR13     =  103,
    CV_AMD64_DR14     =  104,
    CV_AMD64_DR15     =  105,

    CV_AMD64_GDTR     =  110,
    CV_AMD64_GDTL     =  111,
    CV_AMD64_IDTR     =  112,
    CV_AMD64_IDTL     =  113,
    CV_AMD64_LDTR     =  114,
    CV_AMD64_TR       =  115,

    CV_AMD64_ST0      =  128,
    CV_AMD64_ST1      =  129,
    CV_AMD64_ST2      =  130,
    CV_AMD64_ST3      =  131,
    CV_AMD64_ST4      =  132,
    CV_AMD64_ST5      =  133,
    CV_AMD64_ST6      =  134,
    CV_AMD64_ST7      =  135,
    CV_AMD64_CTRL     =  136,
    CV_AMD64_STAT     =  137,
    CV_AMD64_TAG      =  138,
    CV_AMD64_FPIP     =  139,
    CV_AMD64_FPCS     =  140,
    CV_AMD64_FPDO     =  141,
    CV_AMD64_FPDS     =  142,
    CV_AMD64_ISEM     =  143,
    CV_AMD64_FPEIP    =  144,
    CV_AMD64_FPEDO    =  145,

    CV_AMD64_MM0      =  146,
    CV_AMD64_MM1      =  147,
    CV_AMD64_MM2      =  148,
    CV_AMD64_MM3      =  149,
    CV_AMD64_MM4      =  150,
    CV_AMD64_MM5      =  151,
    CV_AMD64_MM6      =  152,
    CV_AMD64_MM7      =  153,

    CV_AMD64_XMM0     =  154,   // KATMAI registers
    CV_AMD64_XMM1     =  155,
    CV_AMD64_XMM2     =  156,
    CV_AMD64_XMM3     =  157,
    CV_AMD64_XMM4     =  158,
    CV_AMD64_XMM5     =  159,
    CV_AMD64_XMM6     =  160,
    CV_AMD64_XMM7     =  161,

    CV_AMD64_XMM0_0   =  162,   // KATMAI sub-registers
    CV_AMD64_XMM0_1   =  163,
    CV_AMD64_XMM0_2   =  164,
    CV_AMD64_XMM0_3   =  165,
    CV_AMD64_XMM1_0   =  166,
    CV_AMD64_XMM1_1   =  167,
    CV_AMD64_XMM1_2   =  168,
    CV_AMD64_XMM1_3   =  169,
    CV_AMD64_XMM2_0   =  170,
    CV_AMD64_XMM2_1   =  171,
    CV_AMD64_XMM2_2   =  172,
    CV_AMD64_XMM2_3   =  173,
    CV_AMD64_XMM3_0   =  174,
    CV_AMD64_XMM3_1   =  175,
    CV_AMD64_XMM3_2   =  176,
    CV_AMD64_XMM3_3   =  177,
    CV_AMD64_XMM4_0   =  178,
    CV_AMD64_XMM4_1   =  179,
    CV_AMD64_XMM4_2   =  180,
    CV_AMD64_XMM4_3   =  181,
    CV_AMD64_XMM5_0   =  182,
    CV_AMD64_XMM5_1   =  183,
    CV_AMD64_XMM5_2   =  184,
    CV_AMD64_XMM5_3   =  185,
    CV_AMD64_XMM6_0   =  186,
    CV_AMD64_XMM6_1   =  187,
    CV_AMD64_XMM6_2   =  188,
    CV_AMD64_XMM6_3   =  189,
    CV_AMD64_XMM7_0   =  190,
    CV_AMD64_XMM7_1   =  191,
    CV_AMD64_XMM7_2   =  192,
    CV_AMD64_XMM7_3   =  193,

    CV_AMD64_XMM0L    =  194,
    CV_AMD64_XMM1L    =  195,
    CV_AMD64_XMM2L    =  196,
    CV_AMD64_XMM3L    =  197,
    CV_AMD64_XMM4L    =  198,
    CV_AMD64_XMM5L    =  199,
    CV_AMD64_XMM6L    =  200,
    CV_AMD64_XMM7L    =  201,

    CV_AMD64_XMM0H    =  202,
    CV_AMD64_XMM1H    =  203,
    CV_AMD64_XMM2H    =  204,
    CV_AMD64_XMM3H    =  205,
    CV_AMD64_XMM4H    =  206,
    CV_AMD64_XMM5H    =  207,
    CV_AMD64_XMM6H    =  208,
    CV_AMD64_XMM7H    =  209,

    CV_AMD64_MXCSR    =  211,   // XMM status register

    CV_AMD64_EMM0L    =  220,   // XMM sub-registers (WNI integer)
    CV_AMD64_EMM1L    =  221,
    CV_AMD64_EMM2L    =  222,
    CV_AMD64_EMM3L    =  223,
    CV_AMD64_EMM4L    =  224,
    CV_AMD64_EMM5L    =  225,
    CV_AMD64_EMM6L    =  226,
    CV_AMD64_EMM7L    =  227,

    CV_AMD64_EMM0H    =  228,
    CV_AMD64_EMM1H    =  229,
    CV_AMD64_EMM2H    =  230,
    CV_AMD64_EMM3H    =  231,
    CV_AMD64_EMM4H    =  232,
    CV_AMD64_EMM5H    =  233,
    CV_AMD64_EMM6H    =  234,
    CV_AMD64_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_AMD64_MM00     =  236,
    CV_AMD64_MM01     =  237,
    CV_AMD64_MM10     =  238,
    CV_AMD64_MM11     =  239,
    CV_AMD64_MM20     =  240,
    CV_AMD64_MM21     =  241,
    CV_AMD64_MM30     =  242,
    CV_AMD64_MM31     =  243,
    CV_AMD64_MM40     =  244,
    CV_AMD64_MM41     =  245,
    CV_AMD64_MM50     =  246,
    CV_AMD64_MM51     =  247,
    CV_AMD64_MM60     =  248,
    CV_AMD64_MM61     =  249,
    CV_AMD64_MM70     =  250,
    CV_AMD64_MM71     =  251,

    // Extended KATMAI registers
    CV_AMD64_XMM8     =  252,   // KATMAI registers
    CV_AMD64_XMM9     =  253,
    CV_AMD64_XMM10    =  254,
    CV_AMD64_XMM11    =  255,
    CV_AMD64_XMM12    =  256,
    CV_AMD64_XMM13    =  257,
    CV_AMD64_XMM14    =  258,
    CV_AMD64_XMM15    =  259,

    CV_AMD64_XMM8_0   =  260,   // KATMAI sub-registers
    CV_AMD64_XMM8_1   =  261,
    CV_AMD64_XMM8_2   =  262,
    CV_AMD64_XMM8_3   =  263,
    CV_AMD64_XMM9_0   =  264,
    CV_AMD64_XMM9_1   =  265,
    CV_AMD64_XMM9_2   =  266,
    CV_AMD64_XMM9_3   =  267,
    CV_AMD64_XMM10_0  =  268,
    CV_AMD64_XMM10_1  =  269,
    CV_AMD64_XMM10_2  =  270,
    CV_AMD64_XMM10_3  =  271,
    CV_AMD64_XMM11_0  =  272,
    CV_AMD64_XMM11_1  =  273,
    CV_AMD64_XMM11_2  =  274,
    CV_AMD64_XMM11_3  =  275,
    CV_AMD64_XMM12_0  =  276,
    CV_AMD64_XMM12_1  =  277,
    CV_AMD64_XMM12_2  =  278,
    CV_AMD64_XMM12_3  =  279,
    CV_AMD64_XMM13_0  =  280,
    CV_AMD64_XMM13_1  =  281,
    CV_AMD64_XMM13_2  =  282,
    CV_AMD64_XMM13_3  =  283,
    CV_AMD64_XMM14_0  =  284,
    CV_AMD64_XMM14_1  =  285,
    CV_AMD64_XMM14_2  =  286,
    CV_AMD64_XMM14_3  =  287,
    CV_AMD64_XMM15_0  =  288,
    CV_AMD64_XMM15_1  =  289,
    CV_AMD64_XMM15_2  =  290,
    CV_AMD64_XMM15_3  =  291,

    CV_AMD64_XMM8L    =  292,
    CV_AMD64_XMM9L    =  293,
    CV_AMD64_XMM10L   =  294,
    CV_AMD64_XMM11L   =  295,
    CV_AMD64_XMM12L   =  296,
    CV_AMD64_XMM13L   =  297,
    CV_AMD64_XMM14L   =  298,
    CV_AMD64_XMM15L   =  299,

    CV_AMD64_XMM8H    =  300,
    CV_AMD64_XMM9H    =  301,
    CV_AMD64_XMM10H   =  302,
    CV_AMD64_XMM11H   =  303,
    CV_AMD64_XMM12H   =  304,
    CV_AMD64_XMM13H   =  305,
    CV_AMD64_XMM14H   =  306,
    CV_AMD64_XMM15H   =  307,

    CV_AMD64_EMM8L    =  308,   // XMM sub-registers (WNI integer)
    CV_AMD64_EMM9L    =  309,
    CV_AMD64_EMM10L   =  310,
    CV_AMD64_EMM11L   =  311,
    CV_AMD64_EMM12L   =  312,
    CV_AMD64_EMM13L   =  313,
    CV_AMD64_EMM14L   =  314,
    CV_AMD64_EMM15L   =  315,

    CV_AMD64_EMM8H    =  316,
    CV_AMD64_EMM9H    =  317,
    CV_AMD64_EMM10H   =  318,
    CV_AMD64_EMM11H   =  319,
    CV_AMD64_EMM12H   =  320,
    CV_AMD64_EMM13H   =  321,
    CV_AMD64_EMM14H   =  322,
    CV_AMD64_EMM15H   =  323,

    // Low byte forms of some standard registers
    CV_AMD64_SIL      =  324,
    CV_AMD64_DIL      =  325,
    CV_AMD64_BPL      =  326,
    CV_AMD64_SPL      =  327,

    // 64-bit regular registers
    CV_AMD64_RAX      =  328,
    CV_AMD64_RBX      =  329,
    CV_AMD64_RCX      =  330,
    CV_AMD64_RDX      =  331,
    CV_AMD64_RSI      =  332,
    CV_AMD64_RDI      =  333,
    CV_AMD64_RBP      =  334,
    CV_AMD64_RSP      =  335,

    // 64-bit integer registers with 8-, 16-, and 32-bit forms (B, W, and D)
    CV_AMD64_R8       =  336,
    CV_AMD64_R9       =  337,
    CV_AMD64_R10      =  338,
    CV_AMD64_R11      =  339,
    CV_AMD64_R12      =  340,
    CV_AMD64_R13      =  341,
    CV_AMD64_R14      =  342,
    CV_AMD64_R15      =  343,

    CV_AMD64_R8B      =  344,
    CV_AMD64_R9B      =  345,
    CV_AMD64_R10B     =  346,
    CV_AMD64_R11B     =  347,
    CV_AMD64_R12B     =  348,
    CV_AMD64_R13B     =  349,
    CV_AMD64_R14B     =  350,
    CV_AMD64_R15B     =  351,

    CV_AMD64_R8W      =  352,
    CV_AMD64_R9W      =  353,
    CV_AMD64_R10W     =  354,
    CV_AMD64_R11W     =  355,
    CV_AMD64_R12W     =  356,
    CV_AMD64_R13W     =  357,
    CV_AMD64_R14W     =  358,
    CV_AMD64_R15W     =  359,

    CV_AMD64_R8D      =  360,
    CV_AMD64_R9D      =  361,
    CV_AMD64_R10D     =  362,
    CV_AMD64_R11D     =  363,
    CV_AMD64_R12D     =  364,
    CV_AMD64_R13D     =  365,
    CV_AMD64_R14D     =  366,
    CV_AMD64_R15D     =  367,

    // Note:  Next set of platform registers need to go into a new enum...
    // this one is above 44K now.

} CV_HREG_e;

enum StackFrameTypeEnum
{
    FrameTypeFPO,                   // Frame pointer omitted, FPO info available
    FrameTypeTrap,                  // Kernel Trap frame
    FrameTypeTSS,                   // Kernel Trap frame
    FrameTypeStandard,              // Standard EBP stackframe
    FrameTypeFrameData,             // Frame pointer omitted, FrameData info available

    FrameTypeUnknown = -1,          // Frame which does not have any debug info
};

enum MemoryTypeEnum
{
    MemTypeCode,                    // Read only code memory
    MemTypeData,                    // Read only data/stack memory
    MemTypeStack,                   // Read only stack memory

    MemTypeAny = -1,
};

#endif

```

`addition/DiaSDK/include/dia2.h`:

```h


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for dia2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dia2_h__
#define __dia2_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDiaLoadCallback_FWD_DEFINED__
#define __IDiaLoadCallback_FWD_DEFINED__
typedef interface IDiaLoadCallback IDiaLoadCallback;
#endif 	/* __IDiaLoadCallback_FWD_DEFINED__ */


#ifndef __IDiaLoadCallback2_FWD_DEFINED__
#define __IDiaLoadCallback2_FWD_DEFINED__
typedef interface IDiaLoadCallback2 IDiaLoadCallback2;
#endif 	/* __IDiaLoadCallback2_FWD_DEFINED__ */


#ifndef __IDiaReadExeAtOffsetCallback_FWD_DEFINED__
#define __IDiaReadExeAtOffsetCallback_FWD_DEFINED__
typedef interface IDiaReadExeAtOffsetCallback IDiaReadExeAtOffsetCallback;
#endif 	/* __IDiaReadExeAtOffsetCallback_FWD_DEFINED__ */


#ifndef __IDiaReadExeAtRVACallback_FWD_DEFINED__
#define __IDiaReadExeAtRVACallback_FWD_DEFINED__
typedef interface IDiaReadExeAtRVACallback IDiaReadExeAtRVACallback;
#endif 	/* __IDiaReadExeAtRVACallback_FWD_DEFINED__ */


#ifndef __IDiaDataSource_FWD_DEFINED__
#define __IDiaDataSource_FWD_DEFINED__
typedef interface IDiaDataSource IDiaDataSource;
#endif 	/* __IDiaDataSource_FWD_DEFINED__ */


#ifndef __IDiaEnumSymbols_FWD_DEFINED__
#define __IDiaEnumSymbols_FWD_DEFINED__
typedef interface IDiaEnumSymbols IDiaEnumSymbols;
#endif 	/* __IDiaEnumSymbols_FWD_DEFINED__ */


#ifndef __IDiaEnumSymbolsByAddr_FWD_DEFINED__
#define __IDiaEnumSymbolsByAddr_FWD_DEFINED__
typedef interface IDiaEnumSymbolsByAddr IDiaEnumSymbolsByAddr;
#endif 	/* __IDiaEnumSymbolsByAddr_FWD_DEFINED__ */


#ifndef __IDiaEnumSourceFiles_FWD_DEFINED__
#define __IDiaEnumSourceFiles_FWD_DEFINED__
typedef interface IDiaEnumSourceFiles IDiaEnumSourceFiles;
#endif 	/* __IDiaEnumSourceFiles_FWD_DEFINED__ */


#ifndef __IDiaEnumLineNumbers_FWD_DEFINED__
#define __IDiaEnumLineNumbers_FWD_DEFINED__
typedef interface IDiaEnumLineNumbers IDiaEnumLineNumbers;
#endif 	/* __IDiaEnumLineNumbers_FWD_DEFINED__ */


#ifndef __IDiaEnumInjectedSources_FWD_DEFINED__
#define __IDiaEnumInjectedSources_FWD_DEFINED__
typedef interface IDiaEnumInjectedSources IDiaEnumInjectedSources;
#endif 	/* __IDiaEnumInjectedSources_FWD_DEFINED__ */


#ifndef __IDiaEnumSegments_FWD_DEFINED__
#define __IDiaEnumSegments_FWD_DEFINED__
typedef interface IDiaEnumSegments IDiaEnumSegments;
#endif 	/* __IDiaEnumSegments_FWD_DEFINED__ */


#ifndef __IDiaEnumSectionContribs_FWD_DEFINED__
#define __IDiaEnumSectionContribs_FWD_DEFINED__
typedef interface IDiaEnumSectionContribs IDiaEnumSectionContribs;
#endif 	/* __IDiaEnumSectionContribs_FWD_DEFINED__ */


#ifndef __IDiaEnumFrameData_FWD_DEFINED__
#define __IDiaEnumFrameData_FWD_DEFINED__
typedef interface IDiaEnumFrameData IDiaEnumFrameData;
#endif 	/* __IDiaEnumFrameData_FWD_DEFINED__ */


#ifndef __IDiaEnumDebugStreamData_FWD_DEFINED__
#define __IDiaEnumDebugStreamData_FWD_DEFINED__
typedef interface IDiaEnumDebugStreamData IDiaEnumDebugStreamData;
#endif 	/* __IDiaEnumDebugStreamData_FWD_DEFINED__ */


#ifndef __IDiaEnumDebugStreams_FWD_DEFINED__
#define __IDiaEnumDebugStreams_FWD_DEFINED__
typedef interface IDiaEnumDebugStreams IDiaEnumDebugStreams;
#endif 	/* __IDiaEnumDebugStreams_FWD_DEFINED__ */


#ifndef __IDiaAddressMap_FWD_DEFINED__
#define __IDiaAddressMap_FWD_DEFINED__
typedef interface IDiaAddressMap IDiaAddressMap;
#endif 	/* __IDiaAddressMap_FWD_DEFINED__ */


#ifndef __IDiaSession_FWD_DEFINED__
#define __IDiaSession_FWD_DEFINED__
typedef interface IDiaSession IDiaSession;
#endif 	/* __IDiaSession_FWD_DEFINED__ */


#ifndef __IDiaSymbol_FWD_DEFINED__
#define __IDiaSymbol_FWD_DEFINED__
typedef interface IDiaSymbol IDiaSymbol;
#endif 	/* __IDiaSymbol_FWD_DEFINED__ */


#ifndef __IDiaSourceFile_FWD_DEFINED__
#define __IDiaSourceFile_FWD_DEFINED__
typedef interface IDiaSourceFile IDiaSourceFile;
#endif 	/* __IDiaSourceFile_FWD_DEFINED__ */


#ifndef __IDiaLineNumber_FWD_DEFINED__
#define __IDiaLineNumber_FWD_DEFINED__
typedef interface IDiaLineNumber IDiaLineNumber;
#endif 	/* __IDiaLineNumber_FWD_DEFINED__ */


#ifndef __IDiaSectionContrib_FWD_DEFINED__
#define __IDiaSectionContrib_FWD_DEFINED__
typedef interface IDiaSectionContrib IDiaSectionContrib;
#endif 	/* __IDiaSectionContrib_FWD_DEFINED__ */


#ifndef __IDiaSegment_FWD_DEFINED__
#define __IDiaSegment_FWD_DEFINED__
typedef interface IDiaSegment IDiaSegment;
#endif 	/* __IDiaSegment_FWD_DEFINED__ */


#ifndef __IDiaInjectedSource_FWD_DEFINED__
#define __IDiaInjectedSource_FWD_DEFINED__
typedef interface IDiaInjectedSource IDiaInjectedSource;
#endif 	/* __IDiaInjectedSource_FWD_DEFINED__ */


#ifndef __IDiaLVarInstance_FWD_DEFINED__
#define __IDiaLVarInstance_FWD_DEFINED__
typedef interface IDiaLVarInstance IDiaLVarInstance;
#endif 	/* __IDiaLVarInstance_FWD_DEFINED__ */


#ifndef __IDiaStackWalkFrame_FWD_DEFINED__
#define __IDiaStackWalkFrame_FWD_DEFINED__
typedef interface IDiaStackWalkFrame IDiaStackWalkFrame;
#endif 	/* __IDiaStackWalkFrame_FWD_DEFINED__ */


#ifndef __IDiaFrameData_FWD_DEFINED__
#define __IDiaFrameData_FWD_DEFINED__
typedef interface IDiaFrameData IDiaFrameData;
#endif 	/* __IDiaFrameData_FWD_DEFINED__ */


#ifndef __IDiaImageData_FWD_DEFINED__
#define __IDiaImageData_FWD_DEFINED__
typedef interface IDiaImageData IDiaImageData;
#endif 	/* __IDiaImageData_FWD_DEFINED__ */


#ifndef __IDiaTable_FWD_DEFINED__
#define __IDiaTable_FWD_DEFINED__
typedef interface IDiaTable IDiaTable;
#endif 	/* __IDiaTable_FWD_DEFINED__ */


#ifndef __IDiaEnumTables_FWD_DEFINED__
#define __IDiaEnumTables_FWD_DEFINED__
typedef interface IDiaEnumTables IDiaEnumTables;
#endif 	/* __IDiaEnumTables_FWD_DEFINED__ */


#ifndef __DiaSource_FWD_DEFINED__
#define __DiaSource_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaSource DiaSource;
#else
typedef struct DiaSource DiaSource;
#endif /* __cplusplus */

#endif 	/* __DiaSource_FWD_DEFINED__ */


#ifndef __DiaSourceAlt_FWD_DEFINED__
#define __DiaSourceAlt_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaSourceAlt DiaSourceAlt;
#else
typedef struct DiaSourceAlt DiaSourceAlt;
#endif /* __cplusplus */

#endif 	/* __DiaSourceAlt_FWD_DEFINED__ */


#ifndef __DiaStackWalker_FWD_DEFINED__
#define __DiaStackWalker_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaStackWalker DiaStackWalker;
#else
typedef struct DiaStackWalker DiaStackWalker;
#endif /* __cplusplus */

#endif 	/* __DiaStackWalker_FWD_DEFINED__ */


#ifndef __IDiaPropertyStorage_FWD_DEFINED__
#define __IDiaPropertyStorage_FWD_DEFINED__
typedef interface IDiaPropertyStorage IDiaPropertyStorage;
#endif 	/* __IDiaPropertyStorage_FWD_DEFINED__ */


#ifndef __IDiaStackFrame_FWD_DEFINED__
#define __IDiaStackFrame_FWD_DEFINED__
typedef interface IDiaStackFrame IDiaStackFrame;
#endif 	/* __IDiaStackFrame_FWD_DEFINED__ */


#ifndef __IDiaEnumStackFrames_FWD_DEFINED__
#define __IDiaEnumStackFrames_FWD_DEFINED__
typedef interface IDiaEnumStackFrames IDiaEnumStackFrames;
#endif 	/* __IDiaEnumStackFrames_FWD_DEFINED__ */


#ifndef __IDiaStackWalkHelper_FWD_DEFINED__
#define __IDiaStackWalkHelper_FWD_DEFINED__
typedef interface IDiaStackWalkHelper IDiaStackWalkHelper;
#endif 	/* __IDiaStackWalkHelper_FWD_DEFINED__ */


#ifndef __IDiaStackWalker_FWD_DEFINED__
#define __IDiaStackWalker_FWD_DEFINED__
typedef interface IDiaStackWalker IDiaStackWalker;
#endif 	/* __IDiaStackWalker_FWD_DEFINED__ */


#ifndef __IDiaStackWalkHelper2_FWD_DEFINED__
#define __IDiaStackWalkHelper2_FWD_DEFINED__
typedef interface IDiaStackWalkHelper2 IDiaStackWalkHelper2;
#endif 	/* __IDiaStackWalkHelper2_FWD_DEFINED__ */


#ifndef __IDiaStackWalker2_FWD_DEFINED__
#define __IDiaStackWalker2_FWD_DEFINED__
typedef interface IDiaStackWalker2 IDiaStackWalker2;
#endif 	/* __IDiaStackWalker2_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"
#include "propidl.h"
#include "cvconst.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dia2_0000 */
/* [local] */ 


enum NameSearchOptions
    {	nsNone	= 0,
	nsfCaseSensitive	= 0x1,
	nsfCaseInsensitive	= 0x2,
	nsfFNameExt	= 0x4,
	nsfRegularExpression	= 0x8,
	nsfUndecoratedName	= 0x10,
	nsCaseSensitive	= nsfCaseSensitive,
	nsCaseInsensitive	= nsfCaseInsensitive,
	nsFNameExt	= nsfCaseInsensitive | nsfFNameExt,
	nsRegularExpression	= nsfRegularExpression | nsfCaseSensitive,
	nsCaseInRegularExpression	= nsfRegularExpression | nsfCaseInsensitive
    } ;

enum __MIDL___MIDL_itf_dia2_0000_0001
    {	E_PDB_OK	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )1),
	E_PDB_USAGE	= E_PDB_OK + 1,
	E_PDB_OUT_OF_MEMORY	= E_PDB_USAGE + 1,
	E_PDB_FILE_SYSTEM	= E_PDB_OUT_OF_MEMORY + 1,
	E_PDB_NOT_FOUND	= E_PDB_FILE_SYSTEM + 1,
	E_PDB_INVALID_SIG	= E_PDB_NOT_FOUND + 1,
	E_PDB_INVALID_AGE	= E_PDB_INVALID_SIG + 1,
	E_PDB_PRECOMP_REQUIRED	= E_PDB_INVALID_AGE + 1,
	E_PDB_OUT_OF_TI	= E_PDB_PRECOMP_REQUIRED + 1,
	E_PDB_NOT_IMPLEMENTED	= E_PDB_OUT_OF_TI + 1,
	E_PDB_V1_PDB	= E_PDB_NOT_IMPLEMENTED + 1,
	E_PDB_FORMAT	= E_PDB_V1_PDB + 1,
	E_PDB_LIMIT	= E_PDB_FORMAT + 1,
	E_PDB_CORRUPT	= E_PDB_LIMIT + 1,
	E_PDB_TI16	= E_PDB_CORRUPT + 1,
	E_PDB_ACCESS_DENIED	= E_PDB_TI16 + 1,
	E_PDB_ILLEGAL_TYPE_EDIT	= E_PDB_ACCESS_DENIED + 1,
	E_PDB_INVALID_EXECUTABLE	= E_PDB_ILLEGAL_TYPE_EDIT + 1,
	E_PDB_DBG_NOT_FOUND	= E_PDB_INVALID_EXECUTABLE + 1,
	E_PDB_NO_DEBUG_INFO	= E_PDB_DBG_NOT_FOUND + 1,
	E_PDB_INVALID_EXE_TIMESTAMP	= E_PDB_NO_DEBUG_INFO + 1,
	E_PDB_RESERVED	= E_PDB_INVALID_EXE_TIMESTAMP + 1,
	E_PDB_DEBUG_INFO_NOT_IN_PDB	= E_PDB_RESERVED + 1,
	E_PDB_SYMSRV_BAD_CACHE_PATH	= E_PDB_DEBUG_INFO_NOT_IN_PDB + 1,
	E_PDB_SYMSRV_CACHE_FULL	= E_PDB_SYMSRV_BAD_CACHE_PATH + 1,
	E_PDB_MAX	= E_PDB_SYMSRV_CACHE_FULL + 1
    } ;

enum __MIDL___MIDL_itf_dia2_0000_0002
    {	DIA_E_MODNOTFOUND	= E_PDB_MAX + 1,
	DIA_E_PROCNOTFOUND	= DIA_E_MODNOTFOUND + 1
    } ;
typedef void ( __cdecl *PfnPDBDebugDirV )( 
    BOOL __MIDL_0014,
    void *__MIDL_0015);















extern RPC_IF_HANDLE __MIDL_itf_dia2_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0000_v0_0_s_ifspec;

#ifndef __IDiaLoadCallback_INTERFACE_DEFINED__
#define __IDiaLoadCallback_INTERFACE_DEFINED__

/* interface IDiaLoadCallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLoadCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C32ADB82-73F4-421b-95D5-A4706EDF5DBE")
    IDiaLoadCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyDebugDir( 
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE *pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOpenDBG( 
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOpenPDB( 
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictRegistryAccess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictSymbolServerAccess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLoadCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLoadCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLoadCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLoadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyDebugDir )( 
            IDiaLoadCallback * This,
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenDBG )( 
            IDiaLoadCallback * This,
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenPDB )( 
            IDiaLoadCallback * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictRegistryAccess )( 
            IDiaLoadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictSymbolServerAccess )( 
            IDiaLoadCallback * This);
        
        END_INTERFACE
    } IDiaLoadCallbackVtbl;

    interface IDiaLoadCallback
    {
        CONST_VTBL struct IDiaLoadCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLoadCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLoadCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLoadCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLoadCallback_NotifyDebugDir(This,fExecutable,cbData,pbData)	\
    (This)->lpVtbl -> NotifyDebugDir(This,fExecutable,cbData,pbData)

#define IDiaLoadCallback_NotifyOpenDBG(This,dbgPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenDBG(This,dbgPath,resultCode)

#define IDiaLoadCallback_NotifyOpenPDB(This,pdbPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenPDB(This,pdbPath,resultCode)

#define IDiaLoadCallback_RestrictRegistryAccess(This)	\
    (This)->lpVtbl -> RestrictRegistryAccess(This)

#define IDiaLoadCallback_RestrictSymbolServerAccess(This)	\
    (This)->lpVtbl -> RestrictSymbolServerAccess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyDebugDir_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ BOOL fExecutable,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE *pbData);


void __RPC_STUB IDiaLoadCallback_NotifyDebugDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyOpenDBG_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ LPCOLESTR dbgPath,
    /* [in] */ HRESULT resultCode);


void __RPC_STUB IDiaLoadCallback_NotifyOpenDBG_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyOpenPDB_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ LPCOLESTR pdbPath,
    /* [in] */ HRESULT resultCode);


void __RPC_STUB IDiaLoadCallback_NotifyOpenPDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_RestrictRegistryAccess_Proxy( 
    IDiaLoadCallback * This);


void __RPC_STUB IDiaLoadCallback_RestrictRegistryAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_RestrictSymbolServerAccess_Proxy( 
    IDiaLoadCallback * This);


void __RPC_STUB IDiaLoadCallback_RestrictSymbolServerAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLoadCallback_INTERFACE_DEFINED__ */


#ifndef __IDiaLoadCallback2_INTERFACE_DEFINED__
#define __IDiaLoadCallback2_INTERFACE_DEFINED__

/* interface IDiaLoadCallback2 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLoadCallback2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4688a074-5a4d-4486-aea8-7b90711d9f7c")
    IDiaLoadCallback2 : public IDiaLoadCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RestrictOriginalPathAccess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictReferencePathAccess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictDBGAccess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictSystemRootAccess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLoadCallback2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLoadCallback2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLoadCallback2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyDebugDir )( 
            IDiaLoadCallback2 * This,
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenDBG )( 
            IDiaLoadCallback2 * This,
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenPDB )( 
            IDiaLoadCallback2 * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictRegistryAccess )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictSymbolServerAccess )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictOriginalPathAccess )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictReferencePathAccess )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictDBGAccess )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictSystemRootAccess )( 
            IDiaLoadCallback2 * This);
        
        END_INTERFACE
    } IDiaLoadCallback2Vtbl;

    interface IDiaLoadCallback2
    {
        CONST_VTBL struct IDiaLoadCallback2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLoadCallback2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLoadCallback2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLoadCallback2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLoadCallback2_NotifyDebugDir(This,fExecutable,cbData,pbData)	\
    (This)->lpVtbl -> NotifyDebugDir(This,fExecutable,cbData,pbData)

#define IDiaLoadCallback2_NotifyOpenDBG(This,dbgPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenDBG(This,dbgPath,resultCode)

#define IDiaLoadCallback2_NotifyOpenPDB(This,pdbPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenPDB(This,pdbPath,resultCode)

#define IDiaLoadCallback2_RestrictRegistryAccess(This)	\
    (This)->lpVtbl -> RestrictRegistryAccess(This)

#define IDiaLoadCallback2_RestrictSymbolServerAccess(This)	\
    (This)->lpVtbl -> RestrictSymbolServerAccess(This)


#define IDiaLoadCallback2_RestrictOriginalPathAccess(This)	\
    (This)->lpVtbl -> RestrictOriginalPathAccess(This)

#define IDiaLoadCallback2_RestrictReferencePathAccess(This)	\
    (This)->lpVtbl -> RestrictReferencePathAccess(This)

#define IDiaLoadCallback2_RestrictDBGAccess(This)	\
    (This)->lpVtbl -> RestrictDBGAccess(This)

#define IDiaLoadCallback2_RestrictSystemRootAccess(This)	\
    (This)->lpVtbl -> RestrictSystemRootAccess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaLoadCallback2_RestrictOriginalPathAccess_Proxy( 
    IDiaLoadCallback2 * This);


void __RPC_STUB IDiaLoadCallback2_RestrictOriginalPathAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback2_RestrictReferencePathAccess_Proxy( 
    IDiaLoadCallback2 * This);


void __RPC_STUB IDiaLoadCallback2_RestrictReferencePathAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback2_RestrictDBGAccess_Proxy( 
    IDiaLoadCallback2 * This);


void __RPC_STUB IDiaLoadCallback2_RestrictDBGAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback2_RestrictSystemRootAccess_Proxy( 
    IDiaLoadCallback2 * This);


void __RPC_STUB IDiaLoadCallback2_RestrictSystemRootAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLoadCallback2_INTERFACE_DEFINED__ */


#ifndef __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__
#define __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__

/* interface IDiaReadExeAtOffsetCallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaReadExeAtOffsetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587A461C-B80B-4f54-9194-5032589A6319")
    IDiaReadExeAtOffsetCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadExecutableAt( 
            /* [in] */ DWORDLONG fileOffset,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaReadExeAtOffsetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaReadExeAtOffsetCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaReadExeAtOffsetCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaReadExeAtOffsetCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadExecutableAt )( 
            IDiaReadExeAtOffsetCallback * This,
            /* [in] */ DWORDLONG fileOffset,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        END_INTERFACE
    } IDiaReadExeAtOffsetCallbackVtbl;

    interface IDiaReadExeAtOffsetCallback
    {
        CONST_VTBL struct IDiaReadExeAtOffsetCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaReadExeAtOffsetCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaReadExeAtOffsetCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaReadExeAtOffsetCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaReadExeAtOffsetCallback_ReadExecutableAt(This,fileOffset,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> ReadExecutableAt(This,fileOffset,cbData,pcbData,pbData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaReadExeAtOffsetCallback_ReadExecutableAt_Proxy( 
    IDiaReadExeAtOffsetCallback * This,
    /* [in] */ DWORDLONG fileOffset,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaReadExeAtOffsetCallback_ReadExecutableAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__ */


#ifndef __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__
#define __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__

/* interface IDiaReadExeAtRVACallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaReadExeAtRVACallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E3F80CA-7517-432a-BA07-285134AAEA8E")
    IDiaReadExeAtRVACallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadExecutableAtRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaReadExeAtRVACallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaReadExeAtRVACallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaReadExeAtRVACallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaReadExeAtRVACallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadExecutableAtRVA )( 
            IDiaReadExeAtRVACallback * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        END_INTERFACE
    } IDiaReadExeAtRVACallbackVtbl;

    interface IDiaReadExeAtRVACallback
    {
        CONST_VTBL struct IDiaReadExeAtRVACallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaReadExeAtRVACallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaReadExeAtRVACallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaReadExeAtRVACallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaReadExeAtRVACallback_ReadExecutableAtRVA(This,relativeVirtualAddress,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> ReadExecutableAtRVA(This,relativeVirtualAddress,cbData,pcbData,pbData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaReadExeAtRVACallback_ReadExecutableAtRVA_Proxy( 
    IDiaReadExeAtRVACallback * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaReadExeAtRVACallback_ReadExecutableAtRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__ */


#ifndef __IDiaDataSource_INTERFACE_DEFINED__
#define __IDiaDataSource_INTERFACE_DEFINED__

/* interface IDiaDataSource */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaDataSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79F1BB5F-B66E-48e5-B6A9-1545C323CA3D")
    IDiaDataSource : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lastError( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataFromPdb( 
            /* [in] */ LPCOLESTR pdbPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadAndValidateDataFromPdb( 
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ GUID *pcsig70,
            /* [in] */ DWORD sig,
            /* [in] */ DWORD age) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataForExe( 
            /* [in] */ LPCOLESTR executable,
            /* [in] */ LPCOLESTR searchPath,
            /* [in] */ IUnknown *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataFromIStream( 
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE openSession( 
            /* [out] */ IDiaSession **ppSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaDataSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaDataSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaDataSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaDataSource * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastError )( 
            IDiaDataSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromPdb )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR pdbPath);
        
        HRESULT ( STDMETHODCALLTYPE *loadAndValidateDataFromPdb )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ GUID *pcsig70,
            /* [in] */ DWORD sig,
            /* [in] */ DWORD age);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataForExe )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR executable,
            /* [in] */ LPCOLESTR searchPath,
            /* [in] */ IUnknown *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromIStream )( 
            IDiaDataSource * This,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *openSession )( 
            IDiaDataSource * This,
            /* [out] */ IDiaSession **ppSession);
        
        END_INTERFACE
    } IDiaDataSourceVtbl;

    interface IDiaDataSource
    {
        CONST_VTBL struct IDiaDataSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaDataSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaDataSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaDataSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaDataSource_get_lastError(This,pRetVal)	\
    (This)->lpVtbl -> get_lastError(This,pRetVal)

#define IDiaDataSource_loadDataFromPdb(This,pdbPath)	\
    (This)->lpVtbl -> loadDataFromPdb(This,pdbPath)

#define IDiaDataSource_loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)	\
    (This)->lpVtbl -> loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)

#define IDiaDataSource_loadDataForExe(This,executable,searchPath,pCallback)	\
    (This)->lpVtbl -> loadDataForExe(This,executable,searchPath,pCallback)

#define IDiaDataSource_loadDataFromIStream(This,pIStream)	\
    (This)->lpVtbl -> loadDataFromIStream(This,pIStream)

#define IDiaDataSource_openSession(This,ppSession)	\
    (This)->lpVtbl -> openSession(This,ppSession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaDataSource_get_lastError_Proxy( 
    IDiaDataSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaDataSource_get_lastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataFromPdb_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR pdbPath);


void __RPC_STUB IDiaDataSource_loadDataFromPdb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadAndValidateDataFromPdb_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR pdbPath,
    /* [in] */ GUID *pcsig70,
    /* [in] */ DWORD sig,
    /* [in] */ DWORD age);


void __RPC_STUB IDiaDataSource_loadAndValidateDataFromPdb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataForExe_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR executable,
    /* [in] */ LPCOLESTR searchPath,
    /* [in] */ IUnknown *pCallback);


void __RPC_STUB IDiaDataSource_loadDataForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataFromIStream_Proxy( 
    IDiaDataSource * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB IDiaDataSource_loadDataFromIStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_openSession_Proxy( 
    IDiaDataSource * This,
    /* [out] */ IDiaSession **ppSession);


void __RPC_STUB IDiaDataSource_openSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaDataSource_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSymbols_INTERFACE_DEFINED__
#define __IDiaEnumSymbols_INTERFACE_DEFINED__

/* interface IDiaEnumSymbols */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSymbols;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAB72C48-443B-48f5-9B0B-42F0820AB29A")
    IDiaEnumSymbols : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSymbol **symbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSymbols **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSymbolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSymbols * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSymbols * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSymbols * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSymbols * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSymbols * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSymbols * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSymbol **symbol);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSymbols * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSymbols * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSymbols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSymbols * This,
            /* [out] */ IDiaEnumSymbols **ppenum);
        
        END_INTERFACE
    } IDiaEnumSymbolsVtbl;

    interface IDiaEnumSymbols
    {
        CONST_VTBL struct IDiaEnumSymbolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSymbols_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSymbols_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSymbols_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSymbols_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSymbols_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSymbols_Item(This,index,symbol)	\
    (This)->lpVtbl -> Item(This,index,symbol)

#define IDiaEnumSymbols_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbols_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSymbols_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSymbols_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_get__NewEnum_Proxy( 
    IDiaEnumSymbols * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSymbols_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_get_Count_Proxy( 
    IDiaEnumSymbols * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSymbols_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Item_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSymbol **symbol);


void __RPC_STUB IDiaEnumSymbols_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Next_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbols_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Skip_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSymbols_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Reset_Proxy( 
    IDiaEnumSymbols * This);


void __RPC_STUB IDiaEnumSymbols_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Clone_Proxy( 
    IDiaEnumSymbols * This,
    /* [out] */ IDiaEnumSymbols **ppenum);


void __RPC_STUB IDiaEnumSymbols_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSymbols_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__
#define __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__

/* interface IDiaEnumSymbolsByAddr */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSymbolsByAddr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("624B7D9C-24EA-4421-9D06-3B577471C1FA")
    IDiaEnumSymbolsByAddr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByAddr( 
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByVA( 
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prev( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSymbolsByAddr **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSymbolsByAddrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSymbolsByAddr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSymbolsByAddr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByAddr )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByRVA )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByVA )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Prev )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSymbolsByAddr * This,
            /* [out] */ IDiaEnumSymbolsByAddr **ppenum);
        
        END_INTERFACE
    } IDiaEnumSymbolsByAddrVtbl;

    interface IDiaEnumSymbolsByAddr
    {
        CONST_VTBL struct IDiaEnumSymbolsByAddrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSymbolsByAddr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSymbolsByAddr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSymbolsByAddr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSymbolsByAddr_symbolByAddr(This,isect,offset,ppSymbol)	\
    (This)->lpVtbl -> symbolByAddr(This,isect,offset,ppSymbol)

#define IDiaEnumSymbolsByAddr_symbolByRVA(This,relativeVirtualAddress,ppSymbol)	\
    (This)->lpVtbl -> symbolByRVA(This,relativeVirtualAddress,ppSymbol)

#define IDiaEnumSymbolsByAddr_symbolByVA(This,virtualAddress,ppSymbol)	\
    (This)->lpVtbl -> symbolByVA(This,virtualAddress,ppSymbol)

#define IDiaEnumSymbolsByAddr_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbolsByAddr_Prev(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Prev(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbolsByAddr_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByAddr_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ DWORD isect,
    /* [in] */ DWORD offset,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByRVA_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByVA_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONGLONG virtualAddress,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Next_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbolsByAddr_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Prev_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbolsByAddr_Prev_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Clone_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [out] */ IDiaEnumSymbolsByAddr **ppenum);


void __RPC_STUB IDiaEnumSymbolsByAddr_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSourceFiles_INTERFACE_DEFINED__
#define __IDiaEnumSourceFiles_INTERFACE_DEFINED__

/* interface IDiaEnumSourceFiles */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSourceFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10F3DBD9-664F-4469-B808-9471C7A50538")
    IDiaEnumSourceFiles : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSourceFile **sourceFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSourceFile **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSourceFiles **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSourceFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSourceFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSourceFiles * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSourceFiles * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSourceFiles * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSourceFile **sourceFile);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSourceFile **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSourceFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSourceFiles * This,
            /* [out] */ IDiaEnumSourceFiles **ppenum);
        
        END_INTERFACE
    } IDiaEnumSourceFilesVtbl;

    interface IDiaEnumSourceFiles
    {
        CONST_VTBL struct IDiaEnumSourceFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSourceFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSourceFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSourceFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSourceFiles_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSourceFiles_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSourceFiles_Item(This,index,sourceFile)	\
    (This)->lpVtbl -> Item(This,index,sourceFile)

#define IDiaEnumSourceFiles_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSourceFiles_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSourceFiles_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSourceFiles_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_get__NewEnum_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSourceFiles_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_get_Count_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSourceFiles_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Item_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSourceFile **sourceFile);


void __RPC_STUB IDiaEnumSourceFiles_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Next_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSourceFile **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSourceFiles_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Skip_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSourceFiles_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Reset_Proxy( 
    IDiaEnumSourceFiles * This);


void __RPC_STUB IDiaEnumSourceFiles_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Clone_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [out] */ IDiaEnumSourceFiles **ppenum);


void __RPC_STUB IDiaEnumSourceFiles_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSourceFiles_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumLineNumbers_INTERFACE_DEFINED__
#define __IDiaEnumLineNumbers_INTERFACE_DEFINED__

/* interface IDiaEnumLineNumbers */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumLineNumbers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE30E878-54AC-44f1-81BA-39DE940F6052")
    IDiaEnumLineNumbers : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaLineNumber **lineNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaLineNumber **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumLineNumbers **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumLineNumbersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumLineNumbers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumLineNumbers * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumLineNumbers * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumLineNumbers * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaLineNumber **lineNumber);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaLineNumber **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumLineNumbers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumLineNumbers * This,
            /* [out] */ IDiaEnumLineNumbers **ppenum);
        
        END_INTERFACE
    } IDiaEnumLineNumbersVtbl;

    interface IDiaEnumLineNumbers
    {
        CONST_VTBL struct IDiaEnumLineNumbersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumLineNumbers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumLineNumbers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumLineNumbers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumLineNumbers_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumLineNumbers_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumLineNumbers_Item(This,index,lineNumber)	\
    (This)->lpVtbl -> Item(This,index,lineNumber)

#define IDiaEnumLineNumbers_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumLineNumbers_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumLineNumbers_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumLineNumbers_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_get__NewEnum_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumLineNumbers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_get_Count_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumLineNumbers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Item_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaLineNumber **lineNumber);


void __RPC_STUB IDiaEnumLineNumbers_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Next_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaLineNumber **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumLineNumbers_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Skip_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumLineNumbers_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Reset_Proxy( 
    IDiaEnumLineNumbers * This);


void __RPC_STUB IDiaEnumLineNumbers_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Clone_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [out] */ IDiaEnumLineNumbers **ppenum);


void __RPC_STUB IDiaEnumLineNumbers_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumLineNumbers_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumInjectedSources_INTERFACE_DEFINED__
#define __IDiaEnumInjectedSources_INTERFACE_DEFINED__

/* interface IDiaEnumInjectedSources */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumInjectedSources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D5612573-6925-4468-8883-98CDEC8C384A")
    IDiaEnumInjectedSources : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaInjectedSource **injectedSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaInjectedSource **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumInjectedSources **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumInjectedSourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumInjectedSources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumInjectedSources * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumInjectedSources * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumInjectedSources * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaInjectedSource **injectedSource);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaInjectedSource **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumInjectedSources * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumInjectedSources * This,
            /* [out] */ IDiaEnumInjectedSources **ppenum);
        
        END_INTERFACE
    } IDiaEnumInjectedSourcesVtbl;

    interface IDiaEnumInjectedSources
    {
        CONST_VTBL struct IDiaEnumInjectedSourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumInjectedSources_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumInjectedSources_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumInjectedSources_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumInjectedSources_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumInjectedSources_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumInjectedSources_Item(This,index,injectedSource)	\
    (This)->lpVtbl -> Item(This,index,injectedSource)

#define IDiaEnumInjectedSources_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumInjectedSources_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumInjectedSources_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumInjectedSources_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_get__NewEnum_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumInjectedSources_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_get_Count_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumInjectedSources_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Item_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaInjectedSource **injectedSource);


void __RPC_STUB IDiaEnumInjectedSources_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Next_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaInjectedSource **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumInjectedSources_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Skip_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumInjectedSources_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Reset_Proxy( 
    IDiaEnumInjectedSources * This);


void __RPC_STUB IDiaEnumInjectedSources_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Clone_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [out] */ IDiaEnumInjectedSources **ppenum);


void __RPC_STUB IDiaEnumInjectedSources_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumInjectedSources_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSegments_INTERFACE_DEFINED__
#define __IDiaEnumSegments_INTERFACE_DEFINED__

/* interface IDiaEnumSegments */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSegments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8368CA9-01D1-419d-AC0C-E31235DBDA9F")
    IDiaEnumSegments : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSegment **segment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSegment **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSegments **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSegmentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSegments * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSegments * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSegments * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSegments * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSegments * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSegments * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSegment **segment);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSegments * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSegment **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSegments * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSegments * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSegments * This,
            /* [out] */ IDiaEnumSegments **ppenum);
        
        END_INTERFACE
    } IDiaEnumSegmentsVtbl;

    interface IDiaEnumSegments
    {
        CONST_VTBL struct IDiaEnumSegmentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSegments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSegments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSegments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSegments_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSegments_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSegments_Item(This,index,segment)	\
    (This)->lpVtbl -> Item(This,index,segment)

#define IDiaEnumSegments_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSegments_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSegments_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSegments_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_get__NewEnum_Proxy( 
    IDiaEnumSegments * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSegments_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_get_Count_Proxy( 
    IDiaEnumSegments * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSegments_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Item_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSegment **segment);


void __RPC_STUB IDiaEnumSegments_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Next_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSegment **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSegments_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Skip_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSegments_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Reset_Proxy( 
    IDiaEnumSegments * This);


void __RPC_STUB IDiaEnumSegments_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Clone_Proxy( 
    IDiaEnumSegments * This,
    /* [out] */ IDiaEnumSegments **ppenum);


void __RPC_STUB IDiaEnumSegments_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSegments_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSectionContribs_INTERFACE_DEFINED__
#define __IDiaEnumSectionContribs_INTERFACE_DEFINED__

/* interface IDiaEnumSectionContribs */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSectionContribs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1994DEB2-2C82-4b1d-A57F-AFF424D54A68")
    IDiaEnumSectionContribs : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSectionContrib **section) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSectionContrib **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSectionContribs **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSectionContribsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSectionContribs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSectionContribs * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSectionContribs * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSectionContribs * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSectionContrib **section);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSectionContrib **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSectionContribs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSectionContribs * This,
            /* [out] */ IDiaEnumSectionContribs **ppenum);
        
        END_INTERFACE
    } IDiaEnumSectionContribsVtbl;

    interface IDiaEnumSectionContribs
    {
        CONST_VTBL struct IDiaEnumSectionContribsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSectionContribs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSectionContribs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSectionContribs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSectionContribs_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSectionContribs_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSectionContribs_Item(This,index,section)	\
    (This)->lpVtbl -> Item(This,index,section)

#define IDiaEnumSectionContribs_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSectionContribs_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSectionContribs_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSectionContribs_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_get__NewEnum_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSectionContribs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_get_Count_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSectionContribs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Item_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSectionContrib **section);


void __RPC_STUB IDiaEnumSectionContribs_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Next_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSectionContrib **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSectionContribs_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Skip_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSectionContribs_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Reset_Proxy( 
    IDiaEnumSectionContribs * This);


void __RPC_STUB IDiaEnumSectionContribs_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Clone_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [out] */ IDiaEnumSectionContribs **ppenum);


void __RPC_STUB IDiaEnumSectionContribs_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSectionContribs_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumFrameData_INTERFACE_DEFINED__
#define __IDiaEnumFrameData_INTERFACE_DEFINED__

/* interface IDiaEnumFrameData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumFrameData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FC77A4B-3C1C-44ed-A798-6C1DEEA53E1F")
    IDiaEnumFrameData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaFrameData **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumFrameData **ppenum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE frameByRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE frameByVA( 
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumFrameDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumFrameData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumFrameData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumFrameData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumFrameData * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumFrameData * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumFrameData * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaFrameData **frame);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaFrameData **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumFrameData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumFrameData * This,
            /* [out] */ IDiaEnumFrameData **ppenum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *frameByRVA )( 
            IDiaEnumFrameData * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaFrameData **frame);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *frameByVA )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaFrameData **frame);
        
        END_INTERFACE
    } IDiaEnumFrameDataVtbl;

    interface IDiaEnumFrameData
    {
        CONST_VTBL struct IDiaEnumFrameDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumFrameData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumFrameData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumFrameData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumFrameData_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumFrameData_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumFrameData_Item(This,index,frame)	\
    (This)->lpVtbl -> Item(This,index,frame)

#define IDiaEnumFrameData_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumFrameData_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumFrameData_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumFrameData_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IDiaEnumFrameData_frameByRVA(This,relativeVirtualAddress,frame)	\
    (This)->lpVtbl -> frameByRVA(This,relativeVirtualAddress,frame)

#define IDiaEnumFrameData_frameByVA(This,virtualAddress,frame)	\
    (This)->lpVtbl -> frameByVA(This,virtualAddress,frame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_get__NewEnum_Proxy( 
    IDiaEnumFrameData * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumFrameData_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_get_Count_Proxy( 
    IDiaEnumFrameData * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumFrameData_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Item_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Next_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaFrameData **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumFrameData_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Skip_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumFrameData_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Reset_Proxy( 
    IDiaEnumFrameData * This);


void __RPC_STUB IDiaEnumFrameData_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Clone_Proxy( 
    IDiaEnumFrameData * This,
    /* [out] */ IDiaEnumFrameData **ppenum);


void __RPC_STUB IDiaEnumFrameData_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_frameByRVA_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_frameByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_frameByVA_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONGLONG virtualAddress,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_frameByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumFrameData_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumDebugStreamData_INTERFACE_DEFINED__
#define __IDiaEnumDebugStreamData_INTERFACE_DEFINED__

/* interface IDiaEnumDebugStreamData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumDebugStreamData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("486943E8-D187-4a6b-A3C4-291259FFF60D")
    IDiaEnumDebugStreamData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumDebugStreamData **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumDebugStreamDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumDebugStreamData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumDebugStreamData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ DWORD index,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ ULONG celt,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumDebugStreamData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumDebugStreamData * This,
            /* [out] */ IDiaEnumDebugStreamData **ppenum);
        
        END_INTERFACE
    } IDiaEnumDebugStreamDataVtbl;

    interface IDiaEnumDebugStreamData
    {
        CONST_VTBL struct IDiaEnumDebugStreamDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumDebugStreamData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumDebugStreamData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumDebugStreamData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumDebugStreamData_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumDebugStreamData_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumDebugStreamData_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaEnumDebugStreamData_Item(This,index,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> Item(This,index,cbData,pcbData,pbData)

#define IDiaEnumDebugStreamData_Next(This,celt,cbData,pcbData,pbData,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,cbData,pcbData,pbData,pceltFetched)

#define IDiaEnumDebugStreamData_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumDebugStreamData_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumDebugStreamData_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get__NewEnum_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get_Count_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get_name_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Item_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ DWORD index,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaEnumDebugStreamData_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Next_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ ULONG celt,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumDebugStreamData_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Skip_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumDebugStreamData_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Reset_Proxy( 
    IDiaEnumDebugStreamData * This);


void __RPC_STUB IDiaEnumDebugStreamData_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Clone_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [out] */ IDiaEnumDebugStreamData **ppenum);


void __RPC_STUB IDiaEnumDebugStreamData_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumDebugStreamData_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumDebugStreams_INTERFACE_DEFINED__
#define __IDiaEnumDebugStreams_INTERFACE_DEFINED__

/* interface IDiaEnumDebugStreams */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumDebugStreams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08CBB41E-47A6-4f87-92F1-1C9C87CED044")
    IDiaEnumDebugStreams : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaEnumDebugStreamData **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaEnumDebugStreamData **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumDebugStreams **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumDebugStreamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumDebugStreams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumDebugStreams * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumDebugStreams * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumDebugStreams * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaEnumDebugStreamData **stream);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaEnumDebugStreamData **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumDebugStreams * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumDebugStreams * This,
            /* [out] */ IDiaEnumDebugStreams **ppenum);
        
        END_INTERFACE
    } IDiaEnumDebugStreamsVtbl;

    interface IDiaEnumDebugStreams
    {
        CONST_VTBL struct IDiaEnumDebugStreamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumDebugStreams_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumDebugStreams_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumDebugStreams_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumDebugStreams_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumDebugStreams_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumDebugStreams_Item(This,index,stream)	\
    (This)->lpVtbl -> Item(This,index,stream)

#define IDiaEnumDebugStreams_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumDebugStreams_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumDebugStreams_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumDebugStreams_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_get__NewEnum_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumDebugStreams_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_get_Count_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumDebugStreams_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Item_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDiaEnumDebugStreamData **stream);


void __RPC_STUB IDiaEnumDebugStreams_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Next_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaEnumDebugStreamData **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumDebugStreams_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Skip_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumDebugStreams_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Reset_Proxy( 
    IDiaEnumDebugStreams * This);


void __RPC_STUB IDiaEnumDebugStreams_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Clone_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [out] */ IDiaEnumDebugStreams **ppenum);


void __RPC_STUB IDiaEnumDebugStreams_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumDebugStreams_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_0138 */
/* [local] */ 

struct DiaAddressMapEntry
    {
    DWORD rva;
    DWORD rvaTo;
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dia2_0138_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0138_v0_0_s_ifspec;

#ifndef __IDiaAddressMap_INTERFACE_DEFINED__
#define __IDiaAddressMap_INTERFACE_DEFINED__

/* interface IDiaAddressMap */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaAddressMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B62A2E7A-067A-4ea3-B598-04C09717502C")
    IDiaAddressMap : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressMapEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_addressMapEnabled( 
            /* [in] */ BOOL NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddressEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_relativeVirtualAddressEnabled( 
            /* [in] */ BOOL NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_imageAlign( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_imageAlign( 
            /* [in] */ DWORD NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_imageHeaders( 
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE *pbData,
            /* [in] */ BOOL originalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_addressMap( 
            /* [in] */ DWORD cData,
            /* [size_is][in] */ struct DiaAddressMapEntry *pData,
            /* [in] */ BOOL imageToSymbols) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaAddressMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaAddressMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaAddressMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaAddressMap * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressMapEnabled )( 
            IDiaAddressMap * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_addressMapEnabled )( 
            IDiaAddressMap * This,
            /* [in] */ BOOL NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddressEnabled )( 
            IDiaAddressMap * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_relativeVirtualAddressEnabled )( 
            IDiaAddressMap * This,
            /* [in] */ BOOL NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageAlign )( 
            IDiaAddressMap * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_imageAlign )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *set_imageHeaders )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE *pbData,
            /* [in] */ BOOL originalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *set_addressMap )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD cData,
            /* [size_is][in] */ struct DiaAddressMapEntry *pData,
            /* [in] */ BOOL imageToSymbols);
        
        END_INTERFACE
    } IDiaAddressMapVtbl;

    interface IDiaAddressMap
    {
        CONST_VTBL struct IDiaAddressMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaAddressMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaAddressMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaAddressMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaAddressMap_get_addressMapEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_addressMapEnabled(This,pRetVal)

#define IDiaAddressMap_put_addressMapEnabled(This,NewVal)	\
    (This)->lpVtbl -> put_addressMapEnabled(This,NewVal)

#define IDiaAddressMap_get_relativeVirtualAddressEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddressEnabled(This,pRetVal)

#define IDiaAddressMap_put_relativeVirtualAddressEnabled(This,NewVal)	\
    (This)->lpVtbl -> put_relativeVirtualAddressEnabled(This,NewVal)

#define IDiaAddressMap_get_imageAlign(This,pRetVal)	\
    (This)->lpVtbl -> get_imageAlign(This,pRetVal)

#define IDiaAddressMap_put_imageAlign(This,NewVal)	\
    (This)->lpVtbl -> put_imageAlign(This,NewVal)

#define IDiaAddressMap_set_imageHeaders(This,cbData,pbData,originalHeaders)	\
    (This)->lpVtbl -> set_imageHeaders(This,cbData,pbData,originalHeaders)

#define IDiaAddressMap_set_addressMap(This,cData,pData,imageToSymbols)	\
    (This)->lpVtbl -> set_addressMap(This,cData,pData,imageToSymbols)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_addressMapEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaAddressMap_get_addressMapEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_addressMapEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ BOOL NewVal);


void __RPC_STUB IDiaAddressMap_put_addressMapEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_relativeVirtualAddressEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaAddressMap_get_relativeVirtualAddressEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_relativeVirtualAddressEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ BOOL NewVal);


void __RPC_STUB IDiaAddressMap_put_relativeVirtualAddressEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_imageAlign_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaAddressMap_get_imageAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_imageAlign_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD NewVal);


void __RPC_STUB IDiaAddressMap_put_imageAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaAddressMap_set_imageHeaders_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE *pbData,
    /* [in] */ BOOL originalHeaders);


void __RPC_STUB IDiaAddressMap_set_imageHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaAddressMap_set_addressMap_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD cData,
    /* [size_is][in] */ struct DiaAddressMapEntry *pData,
    /* [in] */ BOOL imageToSymbols);


void __RPC_STUB IDiaAddressMap_set_addressMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaAddressMap_INTERFACE_DEFINED__ */


#ifndef __IDiaSession_INTERFACE_DEFINED__
#define __IDiaSession_INTERFACE_DEFINED__

/* interface IDiaSession */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67138B34-79CD-4b42-B74A-A18ADBB799DF")
    IDiaSession : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_loadAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_loadAddress( 
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_globalScope( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEnumTables( 
            /* [out] */ IDiaEnumTables **ppEnumTables) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSymbolsByAddr( 
            /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findChildren( 
            /* [in] */ IDiaSymbol *parent,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByAddr( 
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByRVA( 
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByVA( 
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByToken( 
            /* [in] */ ULONG token,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symsAreEquiv( 
            /* [in] */ IDiaSymbol *symbolA,
            /* [in] */ IDiaSymbol *symbolB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symbolById( 
            /* [in] */ DWORD id,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByRVAEx( 
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByVAEx( 
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findFile( 
            /* [in] */ IDiaSymbol *pCompiland,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSourceFiles **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findFileById( 
            /* [in] */ DWORD uniqueId,
            /* [out] */ IDiaSourceFile **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLines( 
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByAddr( 
            /* [in] */ DWORD seg,
            /* [in] */ DWORD offset,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByRVA( 
            /* [in] */ DWORD rva,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByVA( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByLinenum( 
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [in] */ DWORD linenum,
            /* [in] */ DWORD column,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findInjectedSource( 
            /* [in] */ LPCOLESTR srcFile,
            /* [out] */ IDiaEnumInjectedSources **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEnumDebugStreams( 
            /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSession * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_loadAddress )( 
            IDiaSession * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_loadAddress )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_globalScope )( 
            IDiaSession * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumTables )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumTables **ppEnumTables);
        
        HRESULT ( STDMETHODCALLTYPE *getSymbolsByAddr )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr);
        
        HRESULT ( STDMETHODCALLTYPE *findChildren )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *parent,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByAddr )( 
            IDiaSession * This,
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByRVA )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByVA )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByToken )( 
            IDiaSession * This,
            /* [in] */ ULONG token,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *symsAreEquiv )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *symbolA,
            /* [in] */ IDiaSymbol *symbolB);
        
        HRESULT ( STDMETHODCALLTYPE *symbolById )( 
            IDiaSession * This,
            /* [in] */ DWORD id,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByRVAEx )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByVAEx )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *findFile )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *pCompiland,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSourceFiles **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findFileById )( 
            IDiaSession * This,
            /* [in] */ DWORD uniqueId,
            /* [out] */ IDiaSourceFile **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLines )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByAddr )( 
            IDiaSession * This,
            /* [in] */ DWORD seg,
            /* [in] */ DWORD offset,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByRVA )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByVA )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByLinenum )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [in] */ DWORD linenum,
            /* [in] */ DWORD column,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findInjectedSource )( 
            IDiaSession * This,
            /* [in] */ LPCOLESTR srcFile,
            /* [out] */ IDiaEnumInjectedSources **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumDebugStreams )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams);
        
        END_INTERFACE
    } IDiaSessionVtbl;

    interface IDiaSession
    {
        CONST_VTBL struct IDiaSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSession_get_loadAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_loadAddress(This,pRetVal)

#define IDiaSession_put_loadAddress(This,NewVal)	\
    (This)->lpVtbl -> put_loadAddress(This,NewVal)

#define IDiaSession_get_globalScope(This,pRetVal)	\
    (This)->lpVtbl -> get_globalScope(This,pRetVal)

#define IDiaSession_getEnumTables(This,ppEnumTables)	\
    (This)->lpVtbl -> getEnumTables(This,ppEnumTables)

#define IDiaSession_getSymbolsByAddr(This,ppEnumbyAddr)	\
    (This)->lpVtbl -> getSymbolsByAddr(This,ppEnumbyAddr)

#define IDiaSession_findChildren(This,parent,symtag,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findChildren(This,parent,symtag,name,compareFlags,ppResult)

#define IDiaSession_findSymbolByAddr(This,isect,offset,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByAddr(This,isect,offset,symtag,ppSymbol)

#define IDiaSession_findSymbolByRVA(This,rva,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByRVA(This,rva,symtag,ppSymbol)

#define IDiaSession_findSymbolByVA(This,va,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByVA(This,va,symtag,ppSymbol)

#define IDiaSession_findSymbolByToken(This,token,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByToken(This,token,symtag,ppSymbol)

#define IDiaSession_symsAreEquiv(This,symbolA,symbolB)	\
    (This)->lpVtbl -> symsAreEquiv(This,symbolA,symbolB)

#define IDiaSession_symbolById(This,id,ppSymbol)	\
    (This)->lpVtbl -> symbolById(This,id,ppSymbol)

#define IDiaSession_findSymbolByRVAEx(This,rva,symtag,ppSymbol,displacement)	\
    (This)->lpVtbl -> findSymbolByRVAEx(This,rva,symtag,ppSymbol,displacement)

#define IDiaSession_findSymbolByVAEx(This,va,symtag,ppSymbol,displacement)	\
    (This)->lpVtbl -> findSymbolByVAEx(This,va,symtag,ppSymbol,displacement)

#define IDiaSession_findFile(This,pCompiland,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findFile(This,pCompiland,name,compareFlags,ppResult)

#define IDiaSession_findFileById(This,uniqueId,ppResult)	\
    (This)->lpVtbl -> findFileById(This,uniqueId,ppResult)

#define IDiaSession_findLines(This,compiland,file,ppResult)	\
    (This)->lpVtbl -> findLines(This,compiland,file,ppResult)

#define IDiaSession_findLinesByAddr(This,seg,offset,length,ppResult)	\
    (This)->lpVtbl -> findLinesByAddr(This,seg,offset,length,ppResult)

#define IDiaSession_findLinesByRVA(This,rva,length,ppResult)	\
    (This)->lpVtbl -> findLinesByRVA(This,rva,length,ppResult)

#define IDiaSession_findLinesByVA(This,va,length,ppResult)	\
    (This)->lpVtbl -> findLinesByVA(This,va,length,ppResult)

#define IDiaSession_findLinesByLinenum(This,compiland,file,linenum,column,ppResult)	\
    (This)->lpVtbl -> findLinesByLinenum(This,compiland,file,linenum,column,ppResult)

#define IDiaSession_findInjectedSource(This,srcFile,ppResult)	\
    (This)->lpVtbl -> findInjectedSource(This,srcFile,ppResult)

#define IDiaSession_getEnumDebugStreams(This,ppEnumDebugStreams)	\
    (This)->lpVtbl -> getEnumDebugStreams(This,ppEnumDebugStreams)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSession_get_loadAddress_Proxy( 
    IDiaSession * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSession_get_loadAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaSession_put_loadAddress_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaSession_put_loadAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSession_get_globalScope_Proxy( 
    IDiaSession * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSession_get_globalScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getEnumTables_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumTables **ppEnumTables);


void __RPC_STUB IDiaSession_getEnumTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getSymbolsByAddr_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr);


void __RPC_STUB IDiaSession_getSymbolsByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findChildren_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *parent,
    /* [in] */ enum SymTagEnum symtag,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSymbols **ppResult);


void __RPC_STUB IDiaSession_findChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByAddr_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD isect,
    /* [in] */ DWORD offset,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByRVA_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByVA_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByToken_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONG token,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_symsAreEquiv_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *symbolA,
    /* [in] */ IDiaSymbol *symbolB);


void __RPC_STUB IDiaSession_symsAreEquiv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_symbolById_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD id,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_symbolById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByRVAEx_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol,
    /* [out] */ long *displacement);


void __RPC_STUB IDiaSession_findSymbolByRVAEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByVAEx_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol,
    /* [out] */ long *displacement);


void __RPC_STUB IDiaSession_findSymbolByVAEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findFile_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *pCompiland,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSourceFiles **ppResult);


void __RPC_STUB IDiaSession_findFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findFileById_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD uniqueId,
    /* [out] */ IDiaSourceFile **ppResult);


void __RPC_STUB IDiaSession_findFileById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLines_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *compiland,
    /* [in] */ IDiaSourceFile *file,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByAddr_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD seg,
    /* [in] */ DWORD offset,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByRVA_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByVA_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByLinenum_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *compiland,
    /* [in] */ IDiaSourceFile *file,
    /* [in] */ DWORD linenum,
    /* [in] */ DWORD column,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByLinenum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findInjectedSource_Proxy( 
    IDiaSession * This,
    /* [in] */ LPCOLESTR srcFile,
    /* [out] */ IDiaEnumInjectedSources **ppResult);


void __RPC_STUB IDiaSession_findInjectedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getEnumDebugStreams_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams);


void __RPC_STUB IDiaSession_getEnumDebugStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSession_INTERFACE_DEFINED__ */


#ifndef __IDiaSymbol_INTERFACE_DEFINED__
#define __IDiaSymbol_INTERFACE_DEFINED__

/* interface IDiaSymbol */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSymbol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb787b2f-bd6c-4635-ba52-933126bd2dcd")
    IDiaSymbol : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symIndexId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symTag( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lexicalParent( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_classParent( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_dataKind( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_locationType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offset( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_slot( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_volatileType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_constType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_unalignedType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_access( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_libraryName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_platform( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_editAndContinueEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndMajor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndMinor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndBuild( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndMajor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndMinor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndBuild( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_unused( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_thunkOrdinal( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_thisAdjust( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtual( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_intro( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_pure( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_callingConvention( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [retval][out] */ VARIANT *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_baseType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_token( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_timeStamp( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_guid( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symbolsFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_reference( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_bitPosition( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_arrayIndexType( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_packed( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_constructor( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_overloadedOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_nested( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasNestedTypes( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasAssignmentOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasCastOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_scoped( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseClass( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_indirectVirtualBaseClass( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBasePointerOffset( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualTableShape( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lexicalParentId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_classParentId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_typeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_arrayIndexTypeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualTableShapeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_code( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_function( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_managed( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_msil( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseDispIndex( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_undecoratedName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_age( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_signature( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilerGenerated( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressTaken( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_rank( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lowerBound( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_upperBound( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lowerBoundId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_upperBoundId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_dataBytes( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findChildren( 
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetRelativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetVirtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_machineType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_oemId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_oemSymbolId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_types( 
            /* [in] */ DWORD cTypes,
            /* [out] */ DWORD *pcTypes,
            /* [size_is][size_is][out] */ IDiaSymbol **pTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_typeIds( 
            /* [in] */ DWORD cTypeIds,
            /* [out] */ DWORD *pcTypeIds,
            /* [size_is][out] */ DWORD *pdwTypeIds) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_objectPointerType( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_udtKind( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_undecoratedNameEx( 
            /* [in] */ DWORD undecorateOptions,
            /* [out] */ BSTR *name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_liveLVarInstances( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cInstances,
            /* [out] */ DWORD *pcInstances,
            /* [size_is][out] */ IDiaLVarInstance **instances) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_noReturn( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_customCallingConvention( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_noInline( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_optimizedCodeDebugInfo( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_notReached( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_interruptReturn( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_farReturn( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isStatic( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasDebugInfo( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isLTCG( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isDataAligned( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasSecurityChecks( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilerName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasAlloca( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasSetJump( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasLongJump( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasInlAsm( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasEH( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasSEH( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasEHa( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isNaked( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isAggregated( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isSplitted( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_container( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_inlSpec( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_noStackOrdering( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseTableType( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasManagedCode( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isHotpatchable( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isCVTCIL( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isMSILNetmodule( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isCTypes( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_isStripped( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSymbolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSymbol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSymbol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSymbol * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symIndexId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symTag )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lexicalParent )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_classParent )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataKind )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_locationType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offset )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_slot )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_volatileType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_constType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unalignedType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_access )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_libraryName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_platform )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_language )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_editAndContinueEnabled )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndMajor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndMinor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndBuild )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndMajor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndMinor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndBuild )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unused )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_thunkOrdinal )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_thisAdjust )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtual )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_intro )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_pure )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_callingConvention )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_value )( 
            IDiaSymbol * This,
            /* [retval][out] */ VARIANT *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_token )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_timeStamp )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_guid )( 
            IDiaSymbol * This,
            /* [retval][out] */ GUID *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symbolsFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_reference )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_count )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_bitPosition )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_arrayIndexType )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_packed )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_constructor )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_overloadedOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nested )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasNestedTypes )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasAssignmentOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasCastOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_scoped )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseClass )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_indirectVirtualBaseClass )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBasePointerOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualTableShape )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lexicalParentId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_classParentId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_typeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_arrayIndexTypeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualTableShapeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_code )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_function )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_managed )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_msil )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseDispIndex )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_undecoratedName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_age )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_signature )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilerGenerated )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressTaken )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_rank )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lowerBound )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_upperBound )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lowerBoundId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_upperBoundId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_dataBytes )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *findChildren )( 
            IDiaSymbol * This,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetSection )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetRelativeVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_machineType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_oemId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_oemSymbolId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_types )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cTypes,
            /* [out] */ DWORD *pcTypes,
            /* [size_is][size_is][out] */ IDiaSymbol **pTypes);
        
        HRESULT ( STDMETHODCALLTYPE *get_typeIds )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cTypeIds,
            /* [out] */ DWORD *pcTypeIds,
            /* [size_is][out] */ DWORD *pdwTypeIds);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_objectPointerType )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_udtKind )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_undecoratedNameEx )( 
            IDiaSymbol * This,
            /* [in] */ DWORD undecorateOptions,
            /* [out] */ BSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *get_liveLVarInstances )( 
            IDiaSymbol * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cInstances,
            /* [out] */ DWORD *pcInstances,
            /* [size_is][out] */ IDiaLVarInstance **instances);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_noReturn )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_customCallingConvention )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_noInline )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_optimizedCodeDebugInfo )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notReached )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_interruptReturn )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_farReturn )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isStatic )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasDebugInfo )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isLTCG )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isDataAligned )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasSecurityChecks )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilerName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasAlloca )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasSetJump )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasLongJump )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasInlAsm )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasEH )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasSEH )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasEHa )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isNaked )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isAggregated )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isSplitted )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_container )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_inlSpec )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_noStackOrdering )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseTableType )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasManagedCode )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isHotpatchable )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isCVTCIL )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isMSILNetmodule )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isCTypes )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_isStripped )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        END_INTERFACE
    } IDiaSymbolVtbl;

    interface IDiaSymbol
    {
        CONST_VTBL struct IDiaSymbolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSymbol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSymbol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSymbol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSymbol_get_symIndexId(This,pRetVal)	\
    (This)->lpVtbl -> get_symIndexId(This,pRetVal)

#define IDiaSymbol_get_symTag(This,pRetVal)	\
    (This)->lpVtbl -> get_symTag(This,pRetVal)

#define IDiaSymbol_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaSymbol_get_lexicalParent(This,pRetVal)	\
    (This)->lpVtbl -> get_lexicalParent(This,pRetVal)

#define IDiaSymbol_get_classParent(This,pRetVal)	\
    (This)->lpVtbl -> get_classParent(This,pRetVal)

#define IDiaSymbol_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaSymbol_get_dataKind(This,pRetVal)	\
    (This)->lpVtbl -> get_dataKind(This,pRetVal)

#define IDiaSymbol_get_locationType(This,pRetVal)	\
    (This)->lpVtbl -> get_locationType(This,pRetVal)

#define IDiaSymbol_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSymbol_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaSymbol_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaSymbol_get_registerId(This,pRetVal)	\
    (This)->lpVtbl -> get_registerId(This,pRetVal)

#define IDiaSymbol_get_offset(This,pRetVal)	\
    (This)->lpVtbl -> get_offset(This,pRetVal)

#define IDiaSymbol_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSymbol_get_slot(This,pRetVal)	\
    (This)->lpVtbl -> get_slot(This,pRetVal)

#define IDiaSymbol_get_volatileType(This,pRetVal)	\
    (This)->lpVtbl -> get_volatileType(This,pRetVal)

#define IDiaSymbol_get_constType(This,pRetVal)	\
    (This)->lpVtbl -> get_constType(This,pRetVal)

#define IDiaSymbol_get_unalignedType(This,pRetVal)	\
    (This)->lpVtbl -> get_unalignedType(This,pRetVal)

#define IDiaSymbol_get_access(This,pRetVal)	\
    (This)->lpVtbl -> get_access(This,pRetVal)

#define IDiaSymbol_get_libraryName(This,pRetVal)	\
    (This)->lpVtbl -> get_libraryName(This,pRetVal)

#define IDiaSymbol_get_platform(This,pRetVal)	\
    (This)->lpVtbl -> get_platform(This,pRetVal)

#define IDiaSymbol_get_language(This,pRetVal)	\
    (This)->lpVtbl -> get_language(This,pRetVal)

#define IDiaSymbol_get_editAndContinueEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_editAndContinueEnabled(This,pRetVal)

#define IDiaSymbol_get_frontEndMajor(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndMajor(This,pRetVal)

#define IDiaSymbol_get_frontEndMinor(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndMinor(This,pRetVal)

#define IDiaSymbol_get_frontEndBuild(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndBuild(This,pRetVal)

#define IDiaSymbol_get_backEndMajor(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndMajor(This,pRetVal)

#define IDiaSymbol_get_backEndMinor(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndMinor(This,pRetVal)

#define IDiaSymbol_get_backEndBuild(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndBuild(This,pRetVal)

#define IDiaSymbol_get_sourceFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFileName(This,pRetVal)

#define IDiaSymbol_get_unused(This,pRetVal)	\
    (This)->lpVtbl -> get_unused(This,pRetVal)

#define IDiaSymbol_get_thunkOrdinal(This,pRetVal)	\
    (This)->lpVtbl -> get_thunkOrdinal(This,pRetVal)

#define IDiaSymbol_get_thisAdjust(This,pRetVal)	\
    (This)->lpVtbl -> get_thisAdjust(This,pRetVal)

#define IDiaSymbol_get_virtualBaseOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseOffset(This,pRetVal)

#define IDiaSymbol_get_virtual(This,pRetVal)	\
    (This)->lpVtbl -> get_virtual(This,pRetVal)

#define IDiaSymbol_get_intro(This,pRetVal)	\
    (This)->lpVtbl -> get_intro(This,pRetVal)

#define IDiaSymbol_get_pure(This,pRetVal)	\
    (This)->lpVtbl -> get_pure(This,pRetVal)

#define IDiaSymbol_get_callingConvention(This,pRetVal)	\
    (This)->lpVtbl -> get_callingConvention(This,pRetVal)

#define IDiaSymbol_get_value(This,pRetVal)	\
    (This)->lpVtbl -> get_value(This,pRetVal)

#define IDiaSymbol_get_baseType(This,pRetVal)	\
    (This)->lpVtbl -> get_baseType(This,pRetVal)

#define IDiaSymbol_get_token(This,pRetVal)	\
    (This)->lpVtbl -> get_token(This,pRetVal)

#define IDiaSymbol_get_timeStamp(This,pRetVal)	\
    (This)->lpVtbl -> get_timeStamp(This,pRetVal)

#define IDiaSymbol_get_guid(This,pRetVal)	\
    (This)->lpVtbl -> get_guid(This,pRetVal)

#define IDiaSymbol_get_symbolsFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_symbolsFileName(This,pRetVal)

#define IDiaSymbol_get_reference(This,pRetVal)	\
    (This)->lpVtbl -> get_reference(This,pRetVal)

#define IDiaSymbol_get_count(This,pRetVal)	\
    (This)->lpVtbl -> get_count(This,pRetVal)

#define IDiaSymbol_get_bitPosition(This,pRetVal)	\
    (This)->lpVtbl -> get_bitPosition(This,pRetVal)

#define IDiaSymbol_get_arrayIndexType(This,pRetVal)	\
    (This)->lpVtbl -> get_arrayIndexType(This,pRetVal)

#define IDiaSymbol_get_packed(This,pRetVal)	\
    (This)->lpVtbl -> get_packed(This,pRetVal)

#define IDiaSymbol_get_constructor(This,pRetVal)	\
    (This)->lpVtbl -> get_constructor(This,pRetVal)

#define IDiaSymbol_get_overloadedOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_overloadedOperator(This,pRetVal)

#define IDiaSymbol_get_nested(This,pRetVal)	\
    (This)->lpVtbl -> get_nested(This,pRetVal)

#define IDiaSymbol_get_hasNestedTypes(This,pRetVal)	\
    (This)->lpVtbl -> get_hasNestedTypes(This,pRetVal)

#define IDiaSymbol_get_hasAssignmentOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_hasAssignmentOperator(This,pRetVal)

#define IDiaSymbol_get_hasCastOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_hasCastOperator(This,pRetVal)

#define IDiaSymbol_get_scoped(This,pRetVal)	\
    (This)->lpVtbl -> get_scoped(This,pRetVal)

#define IDiaSymbol_get_virtualBaseClass(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseClass(This,pRetVal)

#define IDiaSymbol_get_indirectVirtualBaseClass(This,pRetVal)	\
    (This)->lpVtbl -> get_indirectVirtualBaseClass(This,pRetVal)

#define IDiaSymbol_get_virtualBasePointerOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBasePointerOffset(This,pRetVal)

#define IDiaSymbol_get_virtualTableShape(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualTableShape(This,pRetVal)

#define IDiaSymbol_get_lexicalParentId(This,pRetVal)	\
    (This)->lpVtbl -> get_lexicalParentId(This,pRetVal)

#define IDiaSymbol_get_classParentId(This,pRetVal)	\
    (This)->lpVtbl -> get_classParentId(This,pRetVal)

#define IDiaSymbol_get_typeId(This,pRetVal)	\
    (This)->lpVtbl -> get_typeId(This,pRetVal)

#define IDiaSymbol_get_arrayIndexTypeId(This,pRetVal)	\
    (This)->lpVtbl -> get_arrayIndexTypeId(This,pRetVal)

#define IDiaSymbol_get_virtualTableShapeId(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualTableShapeId(This,pRetVal)

#define IDiaSymbol_get_code(This,pRetVal)	\
    (This)->lpVtbl -> get_code(This,pRetVal)

#define IDiaSymbol_get_function(This,pRetVal)	\
    (This)->lpVtbl -> get_function(This,pRetVal)

#define IDiaSymbol_get_managed(This,pRetVal)	\
    (This)->lpVtbl -> get_managed(This,pRetVal)

#define IDiaSymbol_get_msil(This,pRetVal)	\
    (This)->lpVtbl -> get_msil(This,pRetVal)

#define IDiaSymbol_get_virtualBaseDispIndex(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseDispIndex(This,pRetVal)

#define IDiaSymbol_get_undecoratedName(This,pRetVal)	\
    (This)->lpVtbl -> get_undecoratedName(This,pRetVal)

#define IDiaSymbol_get_age(This,pRetVal)	\
    (This)->lpVtbl -> get_age(This,pRetVal)

#define IDiaSymbol_get_signature(This,pRetVal)	\
    (This)->lpVtbl -> get_signature(This,pRetVal)

#define IDiaSymbol_get_compilerGenerated(This,pRetVal)	\
    (This)->lpVtbl -> get_compilerGenerated(This,pRetVal)

#define IDiaSymbol_get_addressTaken(This,pRetVal)	\
    (This)->lpVtbl -> get_addressTaken(This,pRetVal)

#define IDiaSymbol_get_rank(This,pRetVal)	\
    (This)->lpVtbl -> get_rank(This,pRetVal)

#define IDiaSymbol_get_lowerBound(This,pRetVal)	\
    (This)->lpVtbl -> get_lowerBound(This,pRetVal)

#define IDiaSymbol_get_upperBound(This,pRetVal)	\
    (This)->lpVtbl -> get_upperBound(This,pRetVal)

#define IDiaSymbol_get_lowerBoundId(This,pRetVal)	\
    (This)->lpVtbl -> get_lowerBoundId(This,pRetVal)

#define IDiaSymbol_get_upperBoundId(This,pRetVal)	\
    (This)->lpVtbl -> get_upperBoundId(This,pRetVal)

#define IDiaSymbol_get_dataBytes(This,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> get_dataBytes(This,cbData,pcbData,pbData)

#define IDiaSymbol_findChildren(This,symtag,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findChildren(This,symtag,name,compareFlags,ppResult)

#define IDiaSymbol_get_targetSection(This,pRetVal)	\
    (This)->lpVtbl -> get_targetSection(This,pRetVal)

#define IDiaSymbol_get_targetOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_targetOffset(This,pRetVal)

#define IDiaSymbol_get_targetRelativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_targetRelativeVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_targetVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_targetVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_machineType(This,pRetVal)	\
    (This)->lpVtbl -> get_machineType(This,pRetVal)

#define IDiaSymbol_get_oemId(This,pRetVal)	\
    (This)->lpVtbl -> get_oemId(This,pRetVal)

#define IDiaSymbol_get_oemSymbolId(This,pRetVal)	\
    (This)->lpVtbl -> get_oemSymbolId(This,pRetVal)

#define IDiaSymbol_get_types(This,cTypes,pcTypes,pTypes)	\
    (This)->lpVtbl -> get_types(This,cTypes,pcTypes,pTypes)

#define IDiaSymbol_get_typeIds(This,cTypeIds,pcTypeIds,pdwTypeIds)	\
    (This)->lpVtbl -> get_typeIds(This,cTypeIds,pcTypeIds,pdwTypeIds)

#define IDiaSymbol_get_objectPointerType(This,pRetVal)	\
    (This)->lpVtbl -> get_objectPointerType(This,pRetVal)

#define IDiaSymbol_get_udtKind(This,pRetVal)	\
    (This)->lpVtbl -> get_udtKind(This,pRetVal)

#define IDiaSymbol_get_undecoratedNameEx(This,undecorateOptions,name)	\
    (This)->lpVtbl -> get_undecoratedNameEx(This,undecorateOptions,name)

#define IDiaSymbol_get_liveLVarInstances(This,va,cInstances,pcInstances,instances)	\
    (This)->lpVtbl -> get_liveLVarInstances(This,va,cInstances,pcInstances,instances)

#define IDiaSymbol_get_noReturn(This,pRetVal)	\
    (This)->lpVtbl -> get_noReturn(This,pRetVal)

#define IDiaSymbol_get_customCallingConvention(This,pRetVal)	\
    (This)->lpVtbl -> get_customCallingConvention(This,pRetVal)

#define IDiaSymbol_get_noInline(This,pRetVal)	\
    (This)->lpVtbl -> get_noInline(This,pRetVal)

#define IDiaSymbol_get_optimizedCodeDebugInfo(This,pRetVal)	\
    (This)->lpVtbl -> get_optimizedCodeDebugInfo(This,pRetVal)

#define IDiaSymbol_get_notReached(This,pRetVal)	\
    (This)->lpVtbl -> get_notReached(This,pRetVal)

#define IDiaSymbol_get_interruptReturn(This,pRetVal)	\
    (This)->lpVtbl -> get_interruptReturn(This,pRetVal)

#define IDiaSymbol_get_farReturn(This,pRetVal)	\
    (This)->lpVtbl -> get_farReturn(This,pRetVal)

#define IDiaSymbol_get_isStatic(This,pRetVal)	\
    (This)->lpVtbl -> get_isStatic(This,pRetVal)

#define IDiaSymbol_get_hasDebugInfo(This,pRetVal)	\
    (This)->lpVtbl -> get_hasDebugInfo(This,pRetVal)

#define IDiaSymbol_get_isLTCG(This,pRetVal)	\
    (This)->lpVtbl -> get_isLTCG(This,pRetVal)

#define IDiaSymbol_get_isDataAligned(This,pRetVal)	\
    (This)->lpVtbl -> get_isDataAligned(This,pRetVal)

#define IDiaSymbol_get_hasSecurityChecks(This,pRetVal)	\
    (This)->lpVtbl -> get_hasSecurityChecks(This,pRetVal)

#define IDiaSymbol_get_compilerName(This,pRetVal)	\
    (This)->lpVtbl -> get_compilerName(This,pRetVal)

#define IDiaSymbol_get_hasAlloca(This,pRetVal)	\
    (This)->lpVtbl -> get_hasAlloca(This,pRetVal)

#define IDiaSymbol_get_hasSetJump(This,pRetVal)	\
    (This)->lpVtbl -> get_hasSetJump(This,pRetVal)

#define IDiaSymbol_get_hasLongJump(This,pRetVal)	\
    (This)->lpVtbl -> get_hasLongJump(This,pRetVal)

#define IDiaSymbol_get_hasInlAsm(This,pRetVal)	\
    (This)->lpVtbl -> get_hasInlAsm(This,pRetVal)

#define IDiaSymbol_get_hasEH(This,pRetVal)	\
    (This)->lpVtbl -> get_hasEH(This,pRetVal)

#define IDiaSymbol_get_hasSEH(This,pRetVal)	\
    (This)->lpVtbl -> get_hasSEH(This,pRetVal)

#define IDiaSymbol_get_hasEHa(This,pRetVal)	\
    (This)->lpVtbl -> get_hasEHa(This,pRetVal)

#define IDiaSymbol_get_isNaked(This,pRetVal)	\
    (This)->lpVtbl -> get_isNaked(This,pRetVal)

#define IDiaSymbol_get_isAggregated(This,pRetVal)	\
    (This)->lpVtbl -> get_isAggregated(This,pRetVal)

#define IDiaSymbol_get_isSplitted(This,pRetVal)	\
    (This)->lpVtbl -> get_isSplitted(This,pRetVal)

#define IDiaSymbol_get_container(This,pRetVal)	\
    (This)->lpVtbl -> get_container(This,pRetVal)

#define IDiaSymbol_get_inlSpec(This,pRetVal)	\
    (This)->lpVtbl -> get_inlSpec(This,pRetVal)

#define IDiaSymbol_get_noStackOrdering(This,pRetVal)	\
    (This)->lpVtbl -> get_noStackOrdering(This,pRetVal)

#define IDiaSymbol_get_virtualBaseTableType(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseTableType(This,pRetVal)

#define IDiaSymbol_get_hasManagedCode(This,pRetVal)	\
    (This)->lpVtbl -> get_hasManagedCode(This,pRetVal)

#define IDiaSymbol_get_isHotpatchable(This,pRetVal)	\
    (This)->lpVtbl -> get_isHotpatchable(This,pRetVal)

#define IDiaSymbol_get_isCVTCIL(This,pRetVal)	\
    (This)->lpVtbl -> get_isCVTCIL(This,pRetVal)

#define IDiaSymbol_get_isMSILNetmodule(This,pRetVal)	\
    (This)->lpVtbl -> get_isMSILNetmodule(This,pRetVal)

#define IDiaSymbol_get_isCTypes(This,pRetVal)	\
    (This)->lpVtbl -> get_isCTypes(This,pRetVal)

#define IDiaSymbol_get_isStripped(This,pRetVal)	\
    (This)->lpVtbl -> get_isStripped(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symIndexId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_symIndexId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symTag_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_symTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_name_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lexicalParent_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_lexicalParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_classParent_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_classParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_type_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_dataKind_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_dataKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_locationType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_locationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressSection_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_relativeVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_registerId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_registerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_offset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_offset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_length_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_slot_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_slot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_volatileType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_volatileType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_constType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_constType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_unalignedType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_unalignedType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_access_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_libraryName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_libraryName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_platform_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_platform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_language_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_editAndContinueEnabled_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_editAndContinueEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndMajor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndMajor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndMinor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndMinor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndBuild_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndMajor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndMajor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndMinor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndMinor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndBuild_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_sourceFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_sourceFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_unused_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_unused_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_thunkOrdinal_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_thunkOrdinal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_thisAdjust_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_thisAdjust_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtual_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_intro_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_intro_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_pure_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_pure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_callingConvention_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_callingConvention_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_value_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ VARIANT *pRetVal);


void __RPC_STUB IDiaSymbol_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_baseType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_baseType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_token_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_token_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_timeStamp_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_timeStamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_guid_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB IDiaSymbol_get_guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symbolsFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_symbolsFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_reference_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_reference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_count_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_bitPosition_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_bitPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_arrayIndexType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_arrayIndexType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_packed_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_packed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_constructor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_constructor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_overloadedOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_overloadedOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_nested_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_nested_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasNestedTypes_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasNestedTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasAssignmentOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasAssignmentOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasCastOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasCastOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_scoped_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_scoped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseClass_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_indirectVirtualBaseClass_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_indirectVirtualBaseClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBasePointerOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBasePointerOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualTableShape_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualTableShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lexicalParentId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_lexicalParentId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_classParentId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_classParentId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_typeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_typeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_arrayIndexTypeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_arrayIndexTypeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualTableShapeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualTableShapeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_code_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_code_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_function_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_managed_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_managed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_msil_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_msil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseDispIndex_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseDispIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_undecoratedName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_undecoratedName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_age_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_age_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_signature_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_compilerGenerated_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_compilerGenerated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressTaken_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressTaken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_rank_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_rank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lowerBound_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_lowerBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_upperBound_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_upperBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lowerBoundId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_lowerBoundId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_upperBoundId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_upperBoundId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_dataBytes_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaSymbol_get_dataBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_findChildren_Proxy( 
    IDiaSymbol * This,
    /* [in] */ enum SymTagEnum symtag,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSymbols **ppResult);


void __RPC_STUB IDiaSymbol_findChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetSection_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetRelativeVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetRelativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_machineType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_machineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_oemId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_oemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_oemSymbolId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_oemSymbolId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_types_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cTypes,
    /* [out] */ DWORD *pcTypes,
    /* [size_is][size_is][out] */ IDiaSymbol **pTypes);


void __RPC_STUB IDiaSymbol_get_types_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_typeIds_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cTypeIds,
    /* [out] */ DWORD *pcTypeIds,
    /* [size_is][out] */ DWORD *pdwTypeIds);


void __RPC_STUB IDiaSymbol_get_typeIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_objectPointerType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_objectPointerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_udtKind_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_udtKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_undecoratedNameEx_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD undecorateOptions,
    /* [out] */ BSTR *name);


void __RPC_STUB IDiaSymbol_get_undecoratedNameEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_liveLVarInstances_Proxy( 
    IDiaSymbol * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD cInstances,
    /* [out] */ DWORD *pcInstances,
    /* [size_is][out] */ IDiaLVarInstance **instances);


void __RPC_STUB IDiaSymbol_get_liveLVarInstances_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_noReturn_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_noReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_customCallingConvention_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_customCallingConvention_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_noInline_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_noInline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_optimizedCodeDebugInfo_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_optimizedCodeDebugInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_notReached_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_notReached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_interruptReturn_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_interruptReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_farReturn_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_farReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isStatic_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isStatic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasDebugInfo_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasDebugInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isLTCG_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isLTCG_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isDataAligned_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isDataAligned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasSecurityChecks_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasSecurityChecks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_compilerName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_compilerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasAlloca_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasAlloca_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasSetJump_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasSetJump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasLongJump_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasLongJump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasInlAsm_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasInlAsm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasEH_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasEH_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasSEH_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasSEH_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasEHa_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasEHa_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isNaked_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isNaked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isAggregated_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isAggregated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isSplitted_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isSplitted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_container_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_container_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_inlSpec_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_inlSpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_noStackOrdering_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_noStackOrdering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseTableType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseTableType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasManagedCode_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasManagedCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isHotpatchable_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isHotpatchable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isCVTCIL_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isCVTCIL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isMSILNetmodule_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isMSILNetmodule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isCTypes_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isCTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_isStripped_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_isStripped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSymbol_INTERFACE_DEFINED__ */


#ifndef __IDiaSourceFile_INTERFACE_DEFINED__
#define __IDiaSourceFile_INTERFACE_DEFINED__

/* interface IDiaSourceFile */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSourceFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2EF5353-F5A8-4eb3-90D2-CB526ACB3CDD")
    IDiaSourceFile : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_uniqueId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_fileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_checksumType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilands( 
            /* [retval][out] */ IDiaEnumSymbols **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_checksum( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSourceFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSourceFile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSourceFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSourceFile * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_uniqueId )( 
            IDiaSourceFile * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileName )( 
            IDiaSourceFile * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_checksumType )( 
            IDiaSourceFile * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilands )( 
            IDiaSourceFile * This,
            /* [retval][out] */ IDiaEnumSymbols **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_checksum )( 
            IDiaSourceFile * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        END_INTERFACE
    } IDiaSourceFileVtbl;

    interface IDiaSourceFile
    {
        CONST_VTBL struct IDiaSourceFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSourceFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSourceFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSourceFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSourceFile_get_uniqueId(This,pRetVal)	\
    (This)->lpVtbl -> get_uniqueId(This,pRetVal)

#define IDiaSourceFile_get_fileName(This,pRetVal)	\
    (This)->lpVtbl -> get_fileName(This,pRetVal)

#define IDiaSourceFile_get_checksumType(This,pRetVal)	\
    (This)->lpVtbl -> get_checksumType(This,pRetVal)

#define IDiaSourceFile_get_compilands(This,pRetVal)	\
    (This)->lpVtbl -> get_compilands(This,pRetVal)

#define IDiaSourceFile_get_checksum(This,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> get_checksum(This,cbData,pcbData,pbData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_uniqueId_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSourceFile_get_uniqueId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_fileName_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSourceFile_get_fileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_checksumType_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSourceFile_get_checksumType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_compilands_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ IDiaEnumSymbols **pRetVal);


void __RPC_STUB IDiaSourceFile_get_compilands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_checksum_Proxy( 
    IDiaSourceFile * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaSourceFile_get_checksum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSourceFile_INTERFACE_DEFINED__ */


#ifndef __IDiaLineNumber_INTERFACE_DEFINED__
#define __IDiaLineNumber_INTERFACE_DEFINED__

/* interface IDiaLineNumber */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLineNumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B388EB14-BE4D-421d-A8A1-6CF7AB057086")
    IDiaLineNumber : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compiland( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFile( 
            /* [retval][out] */ IDiaSourceFile **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumber( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumberEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumber( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumberEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFileId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_statement( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilandId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLineNumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLineNumber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLineNumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLineNumber * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compiland )( 
            IDiaLineNumber * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFile )( 
            IDiaLineNumber * This,
            /* [retval][out] */ IDiaSourceFile **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumber )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumberEnd )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumber )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumberEnd )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaLineNumber * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFileId )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statement )( 
            IDiaLineNumber * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilandId )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        END_INTERFACE
    } IDiaLineNumberVtbl;

    interface IDiaLineNumber
    {
        CONST_VTBL struct IDiaLineNumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLineNumber_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLineNumber_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLineNumber_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLineNumber_get_compiland(This,pRetVal)	\
    (This)->lpVtbl -> get_compiland(This,pRetVal)

#define IDiaLineNumber_get_sourceFile(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFile(This,pRetVal)

#define IDiaLineNumber_get_lineNumber(This,pRetVal)	\
    (This)->lpVtbl -> get_lineNumber(This,pRetVal)

#define IDiaLineNumber_get_lineNumberEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_lineNumberEnd(This,pRetVal)

#define IDiaLineNumber_get_columnNumber(This,pRetVal)	\
    (This)->lpVtbl -> get_columnNumber(This,pRetVal)

#define IDiaLineNumber_get_columnNumberEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_columnNumberEnd(This,pRetVal)

#define IDiaLineNumber_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaLineNumber_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaLineNumber_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaLineNumber_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaLineNumber_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaLineNumber_get_sourceFileId(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFileId(This,pRetVal)

#define IDiaLineNumber_get_statement(This,pRetVal)	\
    (This)->lpVtbl -> get_statement(This,pRetVal)

#define IDiaLineNumber_get_compilandId(This,pRetVal)	\
    (This)->lpVtbl -> get_compilandId(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_compiland_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaLineNumber_get_compiland_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_sourceFile_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ IDiaSourceFile **pRetVal);


void __RPC_STUB IDiaLineNumber_get_sourceFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_lineNumber_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_lineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_lineNumberEnd_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_lineNumberEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_columnNumber_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_columnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_columnNumberEnd_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_columnNumberEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_addressSection_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_addressOffset_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_relativeVirtualAddress_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_virtualAddress_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaLineNumber_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_length_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_sourceFileId_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_sourceFileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_statement_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaLineNumber_get_statement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_compilandId_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_compilandId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLineNumber_INTERFACE_DEFINED__ */


#ifndef __IDiaSectionContrib_INTERFACE_DEFINED__
#define __IDiaSectionContrib_INTERFACE_DEFINED__

/* interface IDiaSectionContrib */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSectionContrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0CF4B60E-35B1-4c6c-BDD8-854B9C8E3857")
    IDiaSectionContrib : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compiland( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_notPaged( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_code( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_initializedData( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_uninitializedData( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_remove( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_comdat( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_discardable( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_notCached( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_share( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_execute( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_read( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_write( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_dataCrc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relocationsCrc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilandId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_code16bit( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSectionContribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSectionContrib * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSectionContrib * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSectionContrib * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compiland )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notPaged )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_code )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_initializedData )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_uninitializedData )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_remove )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_comdat )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_discardable )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notCached )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_share )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_execute )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_read )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_write )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataCrc )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relocationsCrc )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilandId )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_code16bit )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        END_INTERFACE
    } IDiaSectionContribVtbl;

    interface IDiaSectionContrib
    {
        CONST_VTBL struct IDiaSectionContribVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSectionContrib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSectionContrib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSectionContrib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSectionContrib_get_compiland(This,pRetVal)	\
    (This)->lpVtbl -> get_compiland(This,pRetVal)

#define IDiaSectionContrib_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSectionContrib_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaSectionContrib_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSectionContrib_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaSectionContrib_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSectionContrib_get_notPaged(This,pRetVal)	\
    (This)->lpVtbl -> get_notPaged(This,pRetVal)

#define IDiaSectionContrib_get_code(This,pRetVal)	\
    (This)->lpVtbl -> get_code(This,pRetVal)

#define IDiaSectionContrib_get_initializedData(This,pRetVal)	\
    (This)->lpVtbl -> get_initializedData(This,pRetVal)

#define IDiaSectionContrib_get_uninitializedData(This,pRetVal)	\
    (This)->lpVtbl -> get_uninitializedData(This,pRetVal)

#define IDiaSectionContrib_get_remove(This,pRetVal)	\
    (This)->lpVtbl -> get_remove(This,pRetVal)

#define IDiaSectionContrib_get_comdat(This,pRetVal)	\
    (This)->lpVtbl -> get_comdat(This,pRetVal)

#define IDiaSectionContrib_get_discardable(This,pRetVal)	\
    (This)->lpVtbl -> get_discardable(This,pRetVal)

#define IDiaSectionContrib_get_notCached(This,pRetVal)	\
    (This)->lpVtbl -> get_notCached(This,pRetVal)

#define IDiaSectionContrib_get_share(This,pRetVal)	\
    (This)->lpVtbl -> get_share(This,pRetVal)

#define IDiaSectionContrib_get_execute(This,pRetVal)	\
    (This)->lpVtbl -> get_execute(This,pRetVal)

#define IDiaSectionContrib_get_read(This,pRetVal)	\
    (This)->lpVtbl -> get_read(This,pRetVal)

#define IDiaSectionContrib_get_write(This,pRetVal)	\
    (This)->lpVtbl -> get_write(This,pRetVal)

#define IDiaSectionContrib_get_dataCrc(This,pRetVal)	\
    (This)->lpVtbl -> get_dataCrc(This,pRetVal)

#define IDiaSectionContrib_get_relocationsCrc(This,pRetVal)	\
    (This)->lpVtbl -> get_relocationsCrc(This,pRetVal)

#define IDiaSectionContrib_get_compilandId(This,pRetVal)	\
    (This)->lpVtbl -> get_compilandId(This,pRetVal)

#define IDiaSectionContrib_get_code16bit(This,pRetVal)	\
    (This)->lpVtbl -> get_code16bit(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_compiland_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSectionContrib_get_compiland_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_addressSection_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_addressOffset_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_relativeVirtualAddress_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_virtualAddress_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_length_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_notPaged_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_notPaged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_code_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_code_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_initializedData_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_initializedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_uninitializedData_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_uninitializedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_remove_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_comdat_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_comdat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_discardable_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_discardable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_notCached_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_notCached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_share_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_share_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_execute_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_read_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_write_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_dataCrc_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_dataCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_relocationsCrc_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_relocationsCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_compilandId_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_compilandId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_code16bit_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_code16bit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSectionContrib_INTERFACE_DEFINED__ */


#ifndef __IDiaSegment_INTERFACE_DEFINED__
#define __IDiaSegment_INTERFACE_DEFINED__

/* interface IDiaSegment */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSegment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0775B784-C75B-4449-848B-B7BD3159545B")
    IDiaSegment : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frame( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_read( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_write( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_execute( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSegmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSegment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSegment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSegment * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frame )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offset )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_read )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_write )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_execute )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSegment * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        END_INTERFACE
    } IDiaSegmentVtbl;

    interface IDiaSegment
    {
        CONST_VTBL struct IDiaSegmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSegment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSegment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSegment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSegment_get_frame(This,pRetVal)	\
    (This)->lpVtbl -> get_frame(This,pRetVal)

#define IDiaSegment_get_offset(This,pRetVal)	\
    (This)->lpVtbl -> get_offset(This,pRetVal)

#define IDiaSegment_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSegment_get_read(This,pRetVal)	\
    (This)->lpVtbl -> get_read(This,pRetVal)

#define IDiaSegment_get_write(This,pRetVal)	\
    (This)->lpVtbl -> get_write(This,pRetVal)

#define IDiaSegment_get_execute(This,pRetVal)	\
    (This)->lpVtbl -> get_execute(This,pRetVal)

#define IDiaSegment_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSegment_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSegment_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_frame_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_frame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_offset_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_offset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_length_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_read_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_write_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_execute_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_addressSection_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_relativeVirtualAddress_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_virtualAddress_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSegment_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSegment_INTERFACE_DEFINED__ */


#ifndef __IDiaInjectedSource_INTERFACE_DEFINED__
#define __IDiaInjectedSource_INTERFACE_DEFINED__

/* interface IDiaInjectedSource */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaInjectedSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE605CDC-8105-4a23-B710-3259F1E26112")
    IDiaInjectedSource : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_crc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_filename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_objectFilename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualFilename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceCompression( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_source( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaInjectedSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaInjectedSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaInjectedSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaInjectedSource * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_crc )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_filename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_objectFilename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualFilename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceCompression )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_source )( 
            IDiaInjectedSource * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        END_INTERFACE
    } IDiaInjectedSourceVtbl;

    interface IDiaInjectedSource
    {
        CONST_VTBL struct IDiaInjectedSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaInjectedSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaInjectedSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaInjectedSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaInjectedSource_get_crc(This,pRetVal)	\
    (This)->lpVtbl -> get_crc(This,pRetVal)

#define IDiaInjectedSource_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaInjectedSource_get_filename(This,pRetVal)	\
    (This)->lpVtbl -> get_filename(This,pRetVal)

#define IDiaInjectedSource_get_objectFilename(This,pRetVal)	\
    (This)->lpVtbl -> get_objectFilename(This,pRetVal)

#define IDiaInjectedSource_get_virtualFilename(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualFilename(This,pRetVal)

#define IDiaInjectedSource_get_sourceCompression(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceCompression(This,pRetVal)

#define IDiaInjectedSource_get_source(This,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> get_source(This,cbData,pcbData,pbData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_crc_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_crc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_length_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_filename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_objectFilename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_objectFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_virtualFilename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_virtualFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_sourceCompression_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_sourceCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_source_Proxy( 
    IDiaInjectedSource * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaInjectedSource_get_source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaInjectedSource_INTERFACE_DEFINED__ */


#ifndef __IDiaLVarInstance_INTERFACE_DEFINED__
#define __IDiaLVarInstance_INTERFACE_DEFINED__

/* interface IDiaLVarInstance */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLVarInstance;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0e425a73-3ced-4964-8cf0-a6caf11bd818")
    IDiaLVarInstance : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symbol( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sectionStart( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offsetStart( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_rvaStart( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_vaStart( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_rvaEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sectionEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offsetEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_vaEnd( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_program( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_livenessAt( 
            /* [in] */ ULONGLONG va,
            /* [out] */ BOOL *pfLive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_location( 
            /* [in] */ IDiaStackFrame *pFrame,
            /* [out] */ BOOL *pfLocInRegister,
            /* [out] */ DWORD *pdwRegId,
            /* [out] */ ULONGLONG *pva) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLVarInstanceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLVarInstance * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLVarInstance * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLVarInstance * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symbol )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sectionStart )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offsetStart )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_rvaStart )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_vaStart )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_rvaEnd )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sectionEnd )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offsetEnd )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_vaEnd )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_program )( 
            IDiaLVarInstance * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_livenessAt )( 
            IDiaLVarInstance * This,
            /* [in] */ ULONGLONG va,
            /* [out] */ BOOL *pfLive);
        
        HRESULT ( STDMETHODCALLTYPE *get_location )( 
            IDiaLVarInstance * This,
            /* [in] */ IDiaStackFrame *pFrame,
            /* [out] */ BOOL *pfLocInRegister,
            /* [out] */ DWORD *pdwRegId,
            /* [out] */ ULONGLONG *pva);
        
        END_INTERFACE
    } IDiaLVarInstanceVtbl;

    interface IDiaLVarInstance
    {
        CONST_VTBL struct IDiaLVarInstanceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLVarInstance_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLVarInstance_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLVarInstance_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLVarInstance_get_symbol(This,pRetVal)	\
    (This)->lpVtbl -> get_symbol(This,pRetVal)

#define IDiaLVarInstance_get_sectionStart(This,pRetVal)	\
    (This)->lpVtbl -> get_sectionStart(This,pRetVal)

#define IDiaLVarInstance_get_offsetStart(This,pRetVal)	\
    (This)->lpVtbl -> get_offsetStart(This,pRetVal)

#define IDiaLVarInstance_get_rvaStart(This,pRetVal)	\
    (This)->lpVtbl -> get_rvaStart(This,pRetVal)

#define IDiaLVarInstance_get_vaStart(This,pRetVal)	\
    (This)->lpVtbl -> get_vaStart(This,pRetVal)

#define IDiaLVarInstance_get_rvaEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_rvaEnd(This,pRetVal)

#define IDiaLVarInstance_get_sectionEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_sectionEnd(This,pRetVal)

#define IDiaLVarInstance_get_offsetEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_offsetEnd(This,pRetVal)

#define IDiaLVarInstance_get_vaEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_vaEnd(This,pRetVal)

#define IDiaLVarInstance_get_program(This,pRetVal)	\
    (This)->lpVtbl -> get_program(This,pRetVal)

#define IDiaLVarInstance_get_livenessAt(This,va,pfLive)	\
    (This)->lpVtbl -> get_livenessAt(This,va,pfLive)

#define IDiaLVarInstance_get_location(This,pFrame,pfLocInRegister,pdwRegId,pva)	\
    (This)->lpVtbl -> get_location(This,pFrame,pfLocInRegister,pdwRegId,pva)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_symbol_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaLVarInstance_get_symbol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_sectionStart_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLVarInstance_get_sectionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_offsetStart_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLVarInstance_get_offsetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_rvaStart_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLVarInstance_get_rvaStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_vaStart_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaLVarInstance_get_vaStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_rvaEnd_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLVarInstance_get_rvaEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_sectionEnd_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLVarInstance_get_sectionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_offsetEnd_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLVarInstance_get_offsetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_vaEnd_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaLVarInstance_get_vaEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_program_Proxy( 
    IDiaLVarInstance * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaLVarInstance_get_program_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_livenessAt_Proxy( 
    IDiaLVarInstance * This,
    /* [in] */ ULONGLONG va,
    /* [out] */ BOOL *pfLive);


void __RPC_STUB IDiaLVarInstance_get_livenessAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLVarInstance_get_location_Proxy( 
    IDiaLVarInstance * This,
    /* [in] */ IDiaStackFrame *pFrame,
    /* [out] */ BOOL *pfLocInRegister,
    /* [out] */ DWORD *pdwRegId,
    /* [out] */ ULONGLONG *pva);


void __RPC_STUB IDiaLVarInstance_get_location_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLVarInstance_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_0147 */
/* [local] */ 


enum __MIDL___MIDL_itf_dia2_0147_0001
    {	E_DIA_INPROLOG	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )100),
	E_DIA_SYNTAX	= E_DIA_INPROLOG + 1,
	E_DIA_FRAME_ACCESS	= E_DIA_SYNTAX + 1,
	E_DIA_VALUE	= E_DIA_FRAME_ACCESS + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dia2_0147_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0147_v0_0_s_ifspec;

#ifndef __IDiaStackWalkFrame_INTERFACE_DEFINED__
#define __IDiaStackWalkFrame_INTERFACE_DEFINED__

/* interface IDiaStackWalkFrame */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalkFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97F0F1A6-E04E-4ea4-B4F9-B0D0E8D90F5D")
    IDiaStackWalkFrame : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerValue( 
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_registerValue( 
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE readMemory( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddress( 
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddressStart( 
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalkFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalkFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalkFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalkFrame * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerValue )( 
            IDiaStackWalkFrame * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_registerValue )( 
            IDiaStackWalkFrame * This,
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *readMemory )( 
            IDiaStackWalkFrame * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddress )( 
            IDiaStackWalkFrame * This,
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddressStart )( 
            IDiaStackWalkFrame * This,
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress);
        
        END_INTERFACE
    } IDiaStackWalkFrameVtbl;

    interface IDiaStackWalkFrame
    {
        CONST_VTBL struct IDiaStackWalkFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalkFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalkFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalkFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalkFrame_get_registerValue(This,index,pRetVal)	\
    (This)->lpVtbl -> get_registerValue(This,index,pRetVal)

#define IDiaStackWalkFrame_put_registerValue(This,index,NewVal)	\
    (This)->lpVtbl -> put_registerValue(This,index,NewVal)

#define IDiaStackWalkFrame_readMemory(This,va,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> readMemory(This,va,cbData,pcbData,pbData)

#define IDiaStackWalkFrame_searchForReturnAddress(This,frame,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddress(This,frame,returnAddress)

#define IDiaStackWalkFrame_searchForReturnAddressStart(This,frame,startAddress,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddressStart(This,frame,startAddress,returnAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_get_registerValue_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackWalkFrame_get_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_put_registerValue_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ DWORD index,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaStackWalkFrame_put_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_readMemory_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaStackWalkFrame_readMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_searchForReturnAddress_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ IDiaFrameData *frame,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkFrame_searchForReturnAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_searchForReturnAddressStart_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ IDiaFrameData *frame,
    /* [in] */ ULONGLONG startAddress,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkFrame_searchForReturnAddressStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackWalkFrame_INTERFACE_DEFINED__ */


#ifndef __IDiaFrameData_INTERFACE_DEFINED__
#define __IDiaFrameData_INTERFACE_DEFINED__

/* interface IDiaFrameData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaFrameData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A39184B7-6A36-42de-8EEC-7DF9F3F59F33")
    IDiaFrameData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthBlock( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthLocals( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthParams( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_maxStack( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthProlog( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthSavedRegisters( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_program( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_systemExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_cplusplusExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionStart( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_allocatesBasePointer( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionParent( 
            /* [retval][out] */ IDiaFrameData **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE execute( 
            IDiaStackWalkFrame *frame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaFrameDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaFrameData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaFrameData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaFrameData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaFrameData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthBlock )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthLocals )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthParams )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_maxStack )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthProlog )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthSavedRegisters )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_program )( 
            IDiaFrameData * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemExceptionHandling )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_cplusplusExceptionHandling )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionStart )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_allocatesBasePointer )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionParent )( 
            IDiaFrameData * This,
            /* [retval][out] */ IDiaFrameData **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *execute )( 
            IDiaFrameData * This,
            IDiaStackWalkFrame *frame);
        
        END_INTERFACE
    } IDiaFrameDataVtbl;

    interface IDiaFrameData
    {
        CONST_VTBL struct IDiaFrameDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaFrameData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaFrameData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaFrameData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaFrameData_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaFrameData_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaFrameData_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaFrameData_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaFrameData_get_lengthBlock(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthBlock(This,pRetVal)

#define IDiaFrameData_get_lengthLocals(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthLocals(This,pRetVal)

#define IDiaFrameData_get_lengthParams(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthParams(This,pRetVal)

#define IDiaFrameData_get_maxStack(This,pRetVal)	\
    (This)->lpVtbl -> get_maxStack(This,pRetVal)

#define IDiaFrameData_get_lengthProlog(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthProlog(This,pRetVal)

#define IDiaFrameData_get_lengthSavedRegisters(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthSavedRegisters(This,pRetVal)

#define IDiaFrameData_get_program(This,pRetVal)	\
    (This)->lpVtbl -> get_program(This,pRetVal)

#define IDiaFrameData_get_systemExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_systemExceptionHandling(This,pRetVal)

#define IDiaFrameData_get_cplusplusExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_cplusplusExceptionHandling(This,pRetVal)

#define IDiaFrameData_get_functionStart(This,pRetVal)	\
    (This)->lpVtbl -> get_functionStart(This,pRetVal)

#define IDiaFrameData_get_allocatesBasePointer(This,pRetVal)	\
    (This)->lpVtbl -> get_allocatesBasePointer(This,pRetVal)

#define IDiaFrameData_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaFrameData_get_functionParent(This,pRetVal)	\
    (This)->lpVtbl -> get_functionParent(This,pRetVal)

#define IDiaFrameData_execute(This,frame)	\
    (This)->lpVtbl -> execute(This,frame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_addressSection_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_addressOffset_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_relativeVirtualAddress_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_virtualAddress_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaFrameData_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthBlock_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthLocals_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthLocals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthParams_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_maxStack_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_maxStack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthProlog_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthProlog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthSavedRegisters_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthSavedRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_program_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaFrameData_get_program_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_systemExceptionHandling_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_systemExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_cplusplusExceptionHandling_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_cplusplusExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_functionStart_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_functionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_allocatesBasePointer_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_allocatesBasePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_type_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_functionParent_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ IDiaFrameData **pRetVal);


void __RPC_STUB IDiaFrameData_get_functionParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaFrameData_execute_Proxy( 
    IDiaFrameData * This,
    IDiaStackWalkFrame *frame);


void __RPC_STUB IDiaFrameData_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaFrameData_INTERFACE_DEFINED__ */


#ifndef __IDiaImageData_INTERFACE_DEFINED__
#define __IDiaImageData_INTERFACE_DEFINED__

/* interface IDiaImageData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaImageData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C8E40ED2-A1D9-4221-8692-3CE661184B44")
    IDiaImageData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_imageBase( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaImageDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaImageData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaImageData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaImageData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaImageData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaImageData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageBase )( 
            IDiaImageData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        END_INTERFACE
    } IDiaImageDataVtbl;

    interface IDiaImageData
    {
        CONST_VTBL struct IDiaImageDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaImageData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaImageData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaImageData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaImageData_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaImageData_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaImageData_get_imageBase(This,pRetVal)	\
    (This)->lpVtbl -> get_imageBase(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_relativeVirtualAddress_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaImageData_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_virtualAddress_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaImageData_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_imageBase_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaImageData_get_imageBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaImageData_INTERFACE_DEFINED__ */


#ifndef __IDiaTable_INTERFACE_DEFINED__
#define __IDiaTable_INTERFACE_DEFINED__

/* interface IDiaTable */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4A59FB77-ABAC-469b-A30B-9ECC85BFEF14")
    IDiaTable : public IEnumUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IUnknown **element) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaTable * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaTable * This,
            /* [in] */ ULONG celt,
            /* [out] */ IUnknown **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaTable * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaTable * This,
            /* [out] */ IEnumUnknown **ppenum);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaTable * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaTable * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaTable * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaTable * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IUnknown **element);
        
        END_INTERFACE
    } IDiaTableVtbl;

    interface IDiaTable
    {
        CONST_VTBL struct IDiaTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaTable_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaTable_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaTable_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaTable_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)


#define IDiaTable_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaTable_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaTable_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaTable_Item(This,index,element)	\
    (This)->lpVtbl -> Item(This,index,element)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get__NewEnum_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaTable_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get_name_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaTable_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get_Count_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaTable_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaTable_Item_Proxy( 
    IDiaTable * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IUnknown **element);


void __RPC_STUB IDiaTable_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaTable_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumTables_INTERFACE_DEFINED__
#define __IDiaEnumTables_INTERFACE_DEFINED__

/* interface IDiaEnumTables */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumTables;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C65C2B0A-1150-4d7a-AFCC-E05BF3DEE81E")
    IDiaEnumTables : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaTable **table) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            ULONG celt,
            IDiaTable **rgelt,
            ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumTables **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumTablesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumTables * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumTables * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumTables * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumTables * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumTables * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumTables * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaTable **table);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumTables * This,
            ULONG celt,
            IDiaTable **rgelt,
            ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumTables * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumTables * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumTables * This,
            /* [out] */ IDiaEnumTables **ppenum);
        
        END_INTERFACE
    } IDiaEnumTablesVtbl;

    interface IDiaEnumTables
    {
        CONST_VTBL struct IDiaEnumTablesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumTables_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumTables_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumTables_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumTables_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumTables_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumTables_Item(This,index,table)	\
    (This)->lpVtbl -> Item(This,index,table)

#define IDiaEnumTables_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumTables_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumTables_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumTables_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_get__NewEnum_Proxy( 
    IDiaEnumTables * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumTables_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_get_Count_Proxy( 
    IDiaEnumTables * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumTables_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_Item_Proxy( 
    IDiaEnumTables * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDiaTable **table);


void __RPC_STUB IDiaEnumTables_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Next_Proxy( 
    IDiaEnumTables * This,
    ULONG celt,
    IDiaTable **rgelt,
    ULONG *pceltFetched);


void __RPC_STUB IDiaEnumTables_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Skip_Proxy( 
    IDiaEnumTables * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumTables_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Reset_Proxy( 
    IDiaEnumTables * This);


void __RPC_STUB IDiaEnumTables_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Clone_Proxy( 
    IDiaEnumTables * This,
    /* [out] */ IDiaEnumTables **ppenum);


void __RPC_STUB IDiaEnumTables_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumTables_INTERFACE_DEFINED__ */



#ifndef __Dia2Lib_LIBRARY_DEFINED__
#define __Dia2Lib_LIBRARY_DEFINED__

/* library Dia2Lib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_Dia2Lib;

EXTERN_C const CLSID CLSID_DiaSource;

#ifdef __cplusplus

class DECLSPEC_UUID("bce36434-2c24-499e-bf49-8bd99b0eeb68")
DiaSource;
#endif

EXTERN_C const CLSID CLSID_DiaSourceAlt;

#ifdef __cplusplus

class DECLSPEC_UUID("1fbd5ec4-b8e4-4d94-9efe-7ccaf9132c98")
DiaSourceAlt;
#endif

EXTERN_C const CLSID CLSID_DiaStackWalker;

#ifdef __cplusplus

class DECLSPEC_UUID("37dfdbcc-40a5-4f4a-8523-123c746d38f0")
DiaStackWalker;
#endif
#endif /* __Dia2Lib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_dia2_0152 */
/* [local] */ 

#define	DiaTable_Symbols	( L"Symbols" )

#define	DiaTable_Sections	( L"Sections" )

#define	DiaTable_SrcFiles	( L"SourceFiles" )

#define	DiaTable_LineNums	( L"LineNumbers" )

#define	DiaTable_SegMap	( L"SegmentMap" )

#define	DiaTable_Dbg	( L"Dbg" )

#define	DiaTable_InjSrc	( L"InjectedSource" )

#define	DiaTable_FrameData	( L"FrameData" )



extern RPC_IF_HANDLE __MIDL_itf_dia2_0152_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0152_v0_0_s_ifspec;

#ifndef __IDiaPropertyStorage_INTERFACE_DEFINED__
#define __IDiaPropertyStorage_INTERFACE_DEFINED__

/* interface IDiaPropertyStorage */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9d416f9c-e184-45b2-a4f0-ce517f719e9b")
    IDiaPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC *rgpspec,
            /* [size_is][out] */ PROPVARIANT *rgvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID *rgpropid,
            /* [size_is][out][in] */ BSTR *rglpwstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ IEnumSTATPROPSTG **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadDWORD( 
            /* [in] */ PROPID id,
            /* [out] */ DWORD *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadLONG( 
            /* [in] */ PROPID id,
            /* [out] */ LONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadBOOL( 
            /* [in] */ PROPID id,
            /* [out] */ BOOL *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadULONGLONG( 
            /* [in] */ PROPID id,
            /* [out] */ ULONGLONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadBSTR( 
            /* [in] */ PROPID id,
            /* [out] */ BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaPropertyStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaPropertyStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            IDiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC *rgpspec,
            /* [size_is][out] */ PROPVARIANT *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyNames )( 
            IDiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID *rgpropid,
            /* [size_is][out][in] */ BSTR *rglpwstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IDiaPropertyStorage * This,
            /* [out] */ IEnumSTATPROPSTG **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *ReadDWORD )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ DWORD *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadLONG )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ LONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadBOOL )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ BOOL *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadULONGLONG )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ ULONGLONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadBSTR )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ BSTR *pValue);
        
        END_INTERFACE
    } IDiaPropertyStorageVtbl;

    interface IDiaPropertyStorage
    {
        CONST_VTBL struct IDiaPropertyStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaPropertyStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaPropertyStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgvar)	\
    (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgvar)

#define IDiaPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)

#define IDiaPropertyStorage_Enum(This,ppenum)	\
    (This)->lpVtbl -> Enum(This,ppenum)

#define IDiaPropertyStorage_ReadDWORD(This,id,pValue)	\
    (This)->lpVtbl -> ReadDWORD(This,id,pValue)

#define IDiaPropertyStorage_ReadLONG(This,id,pValue)	\
    (This)->lpVtbl -> ReadLONG(This,id,pValue)

#define IDiaPropertyStorage_ReadBOOL(This,id,pValue)	\
    (This)->lpVtbl -> ReadBOOL(This,id,pValue)

#define IDiaPropertyStorage_ReadULONGLONG(This,id,pValue)	\
    (This)->lpVtbl -> ReadULONGLONG(This,id,pValue)

#define IDiaPropertyStorage_ReadBSTR(This,id,pValue)	\
    (This)->lpVtbl -> ReadBSTR(This,id,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadMultiple_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC *rgpspec,
    /* [size_is][out] */ PROPVARIANT *rgvar);


void __RPC_STUB IDiaPropertyStorage_ReadMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadPropertyNames_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ ULONG cpropid,
    /* [size_is][in] */ const PROPID *rgpropid,
    /* [size_is][out][in] */ BSTR *rglpwstrName);


void __RPC_STUB IDiaPropertyStorage_ReadPropertyNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_Enum_Proxy( 
    IDiaPropertyStorage * This,
    /* [out] */ IEnumSTATPROPSTG **ppenum);


void __RPC_STUB IDiaPropertyStorage_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadDWORD_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ DWORD *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadLONG_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ LONG *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadLONG_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadBOOL_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ BOOL *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadBOOL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadULONGLONG_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ ULONGLONG *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadULONGLONG_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadBSTR_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ BSTR *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadBSTR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IDiaStackFrame_INTERFACE_DEFINED__
#define __IDiaStackFrame_INTERFACE_DEFINED__

/* interface IDiaStackFrame */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5edbc96d-cdd6-4792-afbe-cc89007d9610")
    IDiaStackFrame : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_base( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_size( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_returnAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_localsBase( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthLocals( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthParams( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthProlog( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthSavedRegisters( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_systemExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_cplusplusExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionStart( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_allocatesBasePointer( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_maxStack( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerValue( 
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_rawLVarInstanceValue( 
            /* [in] */ IDiaLVarInstance *pInstance,
            /* [in] */ DWORD cbDataMax,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_lVarInstanceLocation( 
            /* [in] */ IDiaLVarInstance *pInstance,
            /* [out] */ BOOL *pfLocInRegister,
            /* [out] */ DWORD *pdwRegId,
            /* [out] */ ULONGLONG *pva) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackFrame * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_base )( 
            IDiaStackFrame * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_size )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_returnAddress )( 
            IDiaStackFrame * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_localsBase )( 
            IDiaStackFrame * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthLocals )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthParams )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthProlog )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthSavedRegisters )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemExceptionHandling )( 
            IDiaStackFrame * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_cplusplusExceptionHandling )( 
            IDiaStackFrame * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionStart )( 
            IDiaStackFrame * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_allocatesBasePointer )( 
            IDiaStackFrame * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_maxStack )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerValue )( 
            IDiaStackFrame * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_rawLVarInstanceValue )( 
            IDiaStackFrame * This,
            /* [in] */ IDiaLVarInstance *pInstance,
            /* [in] */ DWORD cbDataMax,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *get_lVarInstanceLocation )( 
            IDiaStackFrame * This,
            /* [in] */ IDiaLVarInstance *pInstance,
            /* [out] */ BOOL *pfLocInRegister,
            /* [out] */ DWORD *pdwRegId,
            /* [out] */ ULONGLONG *pva);
        
        END_INTERFACE
    } IDiaStackFrameVtbl;

    interface IDiaStackFrame
    {
        CONST_VTBL struct IDiaStackFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackFrame_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaStackFrame_get_base(This,pRetVal)	\
    (This)->lpVtbl -> get_base(This,pRetVal)

#define IDiaStackFrame_get_size(This,pRetVal)	\
    (This)->lpVtbl -> get_size(This,pRetVal)

#define IDiaStackFrame_get_returnAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_returnAddress(This,pRetVal)

#define IDiaStackFrame_get_localsBase(This,pRetVal)	\
    (This)->lpVtbl -> get_localsBase(This,pRetVal)

#define IDiaStackFrame_get_lengthLocals(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthLocals(This,pRetVal)

#define IDiaStackFrame_get_lengthParams(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthParams(This,pRetVal)

#define IDiaStackFrame_get_lengthProlog(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthProlog(This,pRetVal)

#define IDiaStackFrame_get_lengthSavedRegisters(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthSavedRegisters(This,pRetVal)

#define IDiaStackFrame_get_systemExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_systemExceptionHandling(This,pRetVal)

#define IDiaStackFrame_get_cplusplusExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_cplusplusExceptionHandling(This,pRetVal)

#define IDiaStackFrame_get_functionStart(This,pRetVal)	\
    (This)->lpVtbl -> get_functionStart(This,pRetVal)

#define IDiaStackFrame_get_allocatesBasePointer(This,pRetVal)	\
    (This)->lpVtbl -> get_allocatesBasePointer(This,pRetVal)

#define IDiaStackFrame_get_maxStack(This,pRetVal)	\
    (This)->lpVtbl -> get_maxStack(This,pRetVal)

#define IDiaStackFrame_get_registerValue(This,index,pRetVal)	\
    (This)->lpVtbl -> get_registerValue(This,index,pRetVal)

#define IDiaStackFrame_get_rawLVarInstanceValue(This,pInstance,cbDataMax,pcbData,pbData)	\
    (This)->lpVtbl -> get_rawLVarInstanceValue(This,pInstance,cbDataMax,pcbData,pbData)

#define IDiaStackFrame_get_lVarInstanceLocation(This,pInstance,pfLocInRegister,pdwRegId,pva)	\
    (This)->lpVtbl -> get_lVarInstanceLocation(This,pInstance,pfLocInRegister,pdwRegId,pva)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_type_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_base_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackFrame_get_base_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_size_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_returnAddress_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackFrame_get_returnAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_localsBase_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackFrame_get_localsBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_lengthLocals_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_lengthLocals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_lengthParams_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_lengthParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_lengthProlog_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_lengthProlog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_lengthSavedRegisters_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_lengthSavedRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_systemExceptionHandling_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaStackFrame_get_systemExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_cplusplusExceptionHandling_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaStackFrame_get_cplusplusExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_functionStart_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaStackFrame_get_functionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_allocatesBasePointer_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaStackFrame_get_allocatesBasePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_maxStack_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_maxStack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_registerValue_Proxy( 
    IDiaStackFrame * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackFrame_get_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_rawLVarInstanceValue_Proxy( 
    IDiaStackFrame * This,
    /* [in] */ IDiaLVarInstance *pInstance,
    /* [in] */ DWORD cbDataMax,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaStackFrame_get_rawLVarInstanceValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_lVarInstanceLocation_Proxy( 
    IDiaStackFrame * This,
    /* [in] */ IDiaLVarInstance *pInstance,
    /* [out] */ BOOL *pfLocInRegister,
    /* [out] */ DWORD *pdwRegId,
    /* [out] */ ULONGLONG *pva);


void __RPC_STUB IDiaStackFrame_get_lVarInstanceLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackFrame_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumStackFrames_INTERFACE_DEFINED__
#define __IDiaEnumStackFrames_INTERFACE_DEFINED__

/* interface IDiaEnumStackFrames */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumStackFrames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ec9d461d-ce74-4711-a020-7d8f9a1dd255")
    IDiaEnumStackFrames : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaStackFrame **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumStackFramesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumStackFrames * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumStackFrames * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumStackFrames * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumStackFrames * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaStackFrame **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumStackFrames * This);
        
        END_INTERFACE
    } IDiaEnumStackFramesVtbl;

    interface IDiaEnumStackFrames
    {
        CONST_VTBL struct IDiaEnumStackFramesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumStackFrames_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumStackFrames_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumStackFrames_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumStackFrames_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumStackFrames_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaEnumStackFrames_Next_Proxy( 
    IDiaEnumStackFrames * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaStackFrame **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumStackFrames_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumStackFrames_Reset_Proxy( 
    IDiaEnumStackFrames * This);


void __RPC_STUB IDiaEnumStackFrames_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumStackFrames_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_0156 */
/* [local] */ 

typedef /* [public] */ struct __MIDL___MIDL_itf_dia2_0156_0001
    {
    DWORD ulOffStart;
    DWORD cbProcSize;
    DWORD cdwLocals;
    WORD cdwParams;
    WORD cdwFlags;
    } 	FPODATA;



extern RPC_IF_HANDLE __MIDL_itf_dia2_0156_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0156_v0_0_s_ifspec;

#ifndef __IDiaStackWalkHelper_INTERFACE_DEFINED__
#define __IDiaStackWalkHelper_INTERFACE_DEFINED__

/* interface IDiaStackWalkHelper */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalkHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("feb0155d-35a8-42d4-8328-bf458f429a3a")
    IDiaStackWalkHelper : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerValue( 
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_registerValue( 
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE readMemory( 
            /* [in] */ enum MemoryTypeEnum type,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddress( 
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddressStart( 
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE frameForVA( 
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaFrameData **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symbolForVA( 
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE pdataForVA( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE imageForVA( 
            /* [in] */ ULONGLONG vaContext,
            /* [out] */ ULONGLONG *pvaImageStart) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalkHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalkHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalkHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalkHelper * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerValue )( 
            IDiaStackWalkHelper * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_registerValue )( 
            IDiaStackWalkHelper * This,
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *readMemory )( 
            IDiaStackWalkHelper * This,
            /* [in] */ enum MemoryTypeEnum type,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddress )( 
            IDiaStackWalkHelper * This,
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddressStart )( 
            IDiaStackWalkHelper * This,
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *frameForVA )( 
            IDiaStackWalkHelper * This,
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaFrameData **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *symbolForVA )( 
            IDiaStackWalkHelper * This,
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *pdataForVA )( 
            IDiaStackWalkHelper * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *imageForVA )( 
            IDiaStackWalkHelper * This,
            /* [in] */ ULONGLONG vaContext,
            /* [out] */ ULONGLONG *pvaImageStart);
        
        END_INTERFACE
    } IDiaStackWalkHelperVtbl;

    interface IDiaStackWalkHelper
    {
        CONST_VTBL struct IDiaStackWalkHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalkHelper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalkHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalkHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalkHelper_get_registerValue(This,index,pRetVal)	\
    (This)->lpVtbl -> get_registerValue(This,index,pRetVal)

#define IDiaStackWalkHelper_put_registerValue(This,index,NewVal)	\
    (This)->lpVtbl -> put_registerValue(This,index,NewVal)

#define IDiaStackWalkHelper_readMemory(This,type,va,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> readMemory(This,type,va,cbData,pcbData,pbData)

#define IDiaStackWalkHelper_searchForReturnAddress(This,frame,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddress(This,frame,returnAddress)

#define IDiaStackWalkHelper_searchForReturnAddressStart(This,frame,startAddress,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddressStart(This,frame,startAddress,returnAddress)

#define IDiaStackWalkHelper_frameForVA(This,va,ppFrame)	\
    (This)->lpVtbl -> frameForVA(This,va,ppFrame)

#define IDiaStackWalkHelper_symbolForVA(This,va,ppSymbol)	\
    (This)->lpVtbl -> symbolForVA(This,va,ppSymbol)

#define IDiaStackWalkHelper_pdataForVA(This,va,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> pdataForVA(This,va,cbData,pcbData,pbData)

#define IDiaStackWalkHelper_imageForVA(This,vaContext,pvaImageStart)	\
    (This)->lpVtbl -> imageForVA(This,vaContext,pvaImageStart)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_get_registerValue_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackWalkHelper_get_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_put_registerValue_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ DWORD index,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaStackWalkHelper_put_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_readMemory_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ enum MemoryTypeEnum type,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaStackWalkHelper_readMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_searchForReturnAddress_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ IDiaFrameData *frame,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkHelper_searchForReturnAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_searchForReturnAddressStart_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ IDiaFrameData *frame,
    /* [in] */ ULONGLONG startAddress,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkHelper_searchForReturnAddressStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_frameForVA_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ ULONGLONG va,
    /* [out] */ IDiaFrameData **ppFrame);


void __RPC_STUB IDiaStackWalkHelper_frameForVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_symbolForVA_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ ULONGLONG va,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaStackWalkHelper_symbolForVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_pdataForVA_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [size_is][out] */ BYTE *pbData);


void __RPC_STUB IDiaStackWalkHelper_pdataForVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_imageForVA_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ ULONGLONG vaContext,
    /* [out] */ ULONGLONG *pvaImageStart);


void __RPC_STUB IDiaStackWalkHelper_imageForVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackWalkHelper_INTERFACE_DEFINED__ */


#ifndef __IDiaStackWalker_INTERFACE_DEFINED__
#define __IDiaStackWalker_INTERFACE_DEFINED__

/* interface IDiaStackWalker */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5485216b-a54c-469f-9670-52b24d5229bb")
    IDiaStackWalker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getEnumFrames( 
            /* [in] */ IDiaStackWalkHelper *pHelper,
            /* [out] */ IDiaEnumStackFrames **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEnumFrames2( 
            /* [in] */ enum CV_CPU_TYPE_e cpuid,
            /* [in] */ IDiaStackWalkHelper *pHelper,
            /* [out] */ IDiaEnumStackFrames **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalkerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalker * This);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumFrames )( 
            IDiaStackWalker * This,
            /* [in] */ IDiaStackWalkHelper *pHelper,
            /* [out] */ IDiaEnumStackFrames **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumFrames2 )( 
            IDiaStackWalker * This,
            /* [in] */ enum CV_CPU_TYPE_e cpuid,
            /* [in] */ IDiaStackWalkHelper *pHelper,
            /* [out] */ IDiaEnumStackFrames **ppEnum);
        
        END_INTERFACE
    } IDiaStackWalkerVtbl;

    interface IDiaStackWalker
    {
        CONST_VTBL struct IDiaStackWalkerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalker_getEnumFrames(This,pHelper,ppEnum)	\
    (This)->lpVtbl -> getEnumFrames(This,pHelper,ppEnum)

#define IDiaStackWalker_getEnumFrames2(This,cpuid,pHelper,ppEnum)	\
    (This)->lpVtbl -> getEnumFrames2(This,cpuid,pHelper,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaStackWalker_getEnumFrames_Proxy( 
    IDiaStackWalker * This,
    /* [in] */ IDiaStackWalkHelper *pHelper,
    /* [out] */ IDiaEnumStackFrames **ppEnum);


void __RPC_STUB IDiaStackWalker_getEnumFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalker_getEnumFrames2_Proxy( 
    IDiaStackWalker * This,
    /* [in] */ enum CV_CPU_TYPE_e cpuid,
    /* [in] */ IDiaStackWalkHelper *pHelper,
    /* [out] */ IDiaEnumStackFrames **ppEnum);


void __RPC_STUB IDiaStackWalker_getEnumFrames2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackWalker_INTERFACE_DEFINED__ */


#ifndef __IDiaStackWalkHelper2_INTERFACE_DEFINED__
#define __IDiaStackWalkHelper2_INTERFACE_DEFINED__

/* interface IDiaStackWalkHelper2 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalkHelper2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8222c490-507b-4bef-b3bd-41dca7b5934c")
    IDiaStackWalkHelper2 : public IDiaStackWalkHelper
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalkHelper2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalkHelper2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalkHelper2 * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerValue )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_registerValue )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *readMemory )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ enum MemoryTypeEnum type,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddress )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddressStart )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *frameForVA )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaFrameData **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *symbolForVA )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *pdataForVA )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [size_is][out] */ BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *imageForVA )( 
            IDiaStackWalkHelper2 * This,
            /* [in] */ ULONGLONG vaContext,
            /* [out] */ ULONGLONG *pvaImageStart);
        
        END_INTERFACE
    } IDiaStackWalkHelper2Vtbl;

    interface IDiaStackWalkHelper2
    {
        CONST_VTBL struct IDiaStackWalkHelper2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalkHelper2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalkHelper2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalkHelper2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalkHelper2_get_registerValue(This,index,pRetVal)	\
    (This)->lpVtbl -> get_registerValue(This,index,pRetVal)

#define IDiaStackWalkHelper2_put_registerValue(This,index,NewVal)	\
    (This)->lpVtbl -> put_registerValue(This,index,NewVal)

#define IDiaStackWalkHelper2_readMemory(This,type,va,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> readMemory(This,type,va,cbData,pcbData,pbData)

#define IDiaStackWalkHelper2_searchForReturnAddress(This,frame,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddress(This,frame,returnAddress)

#define IDiaStackWalkHelper2_searchForReturnAddressStart(This,frame,startAddress,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddressStart(This,frame,startAddress,returnAddress)

#define IDiaStackWalkHelper2_frameForVA(This,va,ppFrame)	\
    (This)->lpVtbl -> frameForVA(This,va,ppFrame)

#define IDiaStackWalkHelper2_symbolForVA(This,va,ppSymbol)	\
    (This)->lpVtbl -> symbolForVA(This,va,ppSymbol)

#define IDiaStackWalkHelper2_pdataForVA(This,va,cbData,pcbData,pbData)	\
    (This)->lpVtbl -> pdataForVA(This,va,cbData,pcbData,pbData)

#define IDiaStackWalkHelper2_imageForVA(This,vaContext,pvaImageStart)	\
    (This)->lpVtbl -> imageForVA(This,vaContext,pvaImageStart)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiaStackWalkHelper2_INTERFACE_DEFINED__ */


#ifndef __IDiaStackWalker2_INTERFACE_DEFINED__
#define __IDiaStackWalker2_INTERFACE_DEFINED__

/* interface IDiaStackWalker2 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalker2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c185885-a015-4cac-9411-0f4fb39b1f3a")
    IDiaStackWalker2 : public IDiaStackWalker
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalker2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalker2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalker2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalker2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumFrames )( 
            IDiaStackWalker2 * This,
            /* [in] */ IDiaStackWalkHelper *pHelper,
            /* [out] */ IDiaEnumStackFrames **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumFrames2 )( 
            IDiaStackWalker2 * This,
            /* [in] */ enum CV_CPU_TYPE_e cpuid,
            /* [in] */ IDiaStackWalkHelper *pHelper,
            /* [out] */ IDiaEnumStackFrames **ppEnum);
        
        END_INTERFACE
    } IDiaStackWalker2Vtbl;

    interface IDiaStackWalker2
    {
        CONST_VTBL struct IDiaStackWalker2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalker2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalker2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalker2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalker2_getEnumFrames(This,pHelper,ppEnum)	\
    (This)->lpVtbl -> getEnumFrames(This,pHelper,ppEnum)

#define IDiaStackWalker2_getEnumFrames2(This,cpuid,pHelper,ppEnum)	\
    (This)->lpVtbl -> getEnumFrames2(This,cpuid,pHelper,ppEnum)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiaStackWalker2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif



```

`addition/DiaSDK/include/diacreate.h`:

```h
// diacreate.h - creation helper functions for DIA initialization
//-----------------------------------------------------------------
// 
// Copyright Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _DIACREATE_H_
#define _DIACREATE_H_

//
// Create a dia data source object from the dia dll (by dll name - does not access the registry).
//

HRESULT STDMETHODCALLTYPE NoRegCoCreate(  const __wchar_t *dllName,
                        REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);

#ifndef _NATIVE_WCHAR_T_DEFINED
#ifdef __cplusplus

HRESULT STDMETHODCALLTYPE NoRegCoCreate(  const wchar_t *dllName,
                        REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv) 
{
    return NoRegCoCreate( (const __wchar_t *)dllName, rclsid, riid, ppv );
}

#endif
#endif



//
// Create a dia data source object from the dia dll (looks up the class id in the registry).
//
HRESULT STDMETHODCALLTYPE NoOleCoCreate(  REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);

#endif

```

`cmake.bat`:

```bat
"D:\Dev\cmake-3.23.1-windows-x86_64\bin\cmake.exe" %*
```

`readme.md`:

```md

reverse engineering old syser win32 debugger<br>
improved handle x64 arch and fix some bugs<br>

struct viewer<br>
note: pdb2sds.exe .pdb .sds must be same arch!<br>
for source level debugging don't convert .exe to .sds<br>
syser debugger will automatic detect .pdb for .exe<br>
pdb2sds.exe while convert doest include source level debug info<br>
only structs and variables<br>

convert any .pdb or .exe by util pdb2sds.exe<br>
load .sds file from syser menu<br>
Menu "File"->"Load Symbol File"<br>
check from console by command<br>
>sdsmod<br>
File BP(s) Size(k) CheckSum TimeStamp ModuleName<br>
0          0k 00000001 00000001  testx64.pdb<br>
1 Module(s)<br>

start debug .exe<br>
open popup menu on data window by right mouse button<br>
choose a struct by select it<br>
choose "Attach type to Addr"<br>
choose "Lock Type"<br>
enter at "Address" address of struct<br>

[sources](source)<br>

<img width="100%" src="https://raw.githubusercontent.com/marakew/syser/master/images/struct_viewer.png">
<img width="100%" src="https://raw.githubusercontent.com/marakew/syser/master/images/attach_struct.png">
<img width="100%" src="https://raw.githubusercontent.com/marakew/syser/master/images/SyserDebuggerx64src1.png">
<img width="100%" src="https://raw.githubusercontent.com/marakew/syser/master/images/SyserDebuggerx64src.png">
<img width="100%" src="https://raw.githubusercontent.com/marakew/syser/master/images/SyserDebuggerx64.png">

```

`source/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

#set(CMAKE_TOOLCHAIN_FILE L:/git_my/cmake/msvc-tools.cmake)

project(syser CXX C ASM_MASM RC)
#include(L:/git_my/cmake/msvc-showcmd.cmake)

# there are no move semantics
set(CMAKE_CXX_STANDARD 98)

set(ADDITION_PATH "${CMAKE_CURRENT_SOURCE_DIR}/../addition")
set(DIASDK_INCLUDE ${ADDITION_PATH}/DiaSDK/include)
if(PLATFORM STREQUAL "x32")
set(DIASDK_LIBRARY ${ADDITION_PATH}/DiaSDK/lib/diaguids.lib)
elseif(PLATFORM STREQUAL "x64")
set(DIASDK_LIBRARY ${ADDITION_PATH}/DiaSDK/lib/amd64/diaguids.lib)
endif()

add_library(DIASDK UNKNOWN IMPORTED)
set_target_properties(DIASDK PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${DIASDK_INCLUDE}")
set_target_properties(DIASDK PROPERTIES IMPORTED_LINK_INTERFACE_LANGUAGES "C" IMPORTED_LOCATION "${DIASDK_LIBRARY}")
set_property(TARGET DIASDK APPEND PROPERTY INTERFACE_LINK_LIBRARIES ole32)
set_property(TARGET DIASDK APPEND PROPERTY INTERFACE_LINK_LIBRARIES oleaut32)

# debugger

file(GLOB_RECURSE SD_SOURCES
	Code/strmem.cpp
	Code/sysdep.cpp
	Code/fileio.cpp
	Code/fileiont.cpp
	EXEAnalyzer/symbol.cpp
	EXEAnalyzer/debugger.cpp
	EXEAnalyzer/x86debugger.cpp
	EXEAnalyzer/sdwin.cpp
)

file(GLOB_RECURSE SOURCES 

# syser
	Code/heap.cpp
	Code/strmem.cpp
	Code/time.cpp
	Code/modf.cpp
	Code/sysdep.cpp
	Code/cmdparser.cpp
	Code/options.cpp
	Code/handle.cpp
	Code/fileio.cpp
	Code/fileiont.cpp
	Code/txtfile.cpp
	Code/srctxtfile.cpp
	Code/utxtfile.cpp
	Code/imagefile.cpp
	Code/compress.cpp
	Code/pagemem.cpp
	Code/polyfs.cpp

	EXEAnalyzer/inteldis.cpp
	EXEAnalyzer/instrsym.cpp
	EXEAnalyzer/pefile.cpp
	EXEAnalyzer/symbol.cpp
	EXEAnalyzer/debugger.cpp

	EXEAnalyzer/sdsmodule.cpp 

	Wisp/utility.cpp
	Wisp/dibdata.cpp
	Wisp/wispdraw.cpp
	Wisp/wispfont.cpp
	Wisp/wispdib.cpp
	Wisp/wispdc.cpp
	Wisp/wispdrawobj.cpp
	Wisp/wispbase.cpp
	Wisp/wispapp.cpp
	Wisp/wispbasewnd.cpp
	Wisp/wispwnd.cpp
	Wisp/wisptipwnd.cpp
	Wisp/wispbutton.cpp
	Wisp/wispstatic.cpp
	Wisp/wispprogress.cpp
	Wisp/wispsoftkeyboard.cpp
	Wisp/wisptoolbar.cpp
	Wisp/wisptabwnd.cpp
	Wisp/wispmultitabview.cpp
	Wisp/wispform.cpp
	Wisp/wispprogressform.cpp
	Wisp/wispcolorstrwnd.cpp
	Wisp/wispconsolewnd.cpp
	Wisp/wisptestwnd.cpp
	Wisp/wispradiobox.cpp
	Wisp/wispcheckbox.cpp
	Wisp/wispsplitwnd.cpp
	Wisp/wispmenu.cpp
	Wisp/wispmsgbox.cpp
	Wisp/wisphexwnd.cpp
	Wisp/wisprgbselect.cpp
	Wisp/wispedit.cpp
	Wisp/wisplist.cpp
	Wisp/wispcombobox.cpp
	Wisp/wispoptionform.cpp
	Wisp/wispcalcwnd.cpp

	WispSyser/resource.cpp
	WispSyser/consolewnd.cpp
	WispSyser/terminalwnd.cpp
	WispSyser/syserui.cpp
	WispSyser/peexplorerform.cpp
	WispSyser/codeview.cpp
	WispSyser/multicodeview.cpp
	WispSyser/dataview.cpp
	WispSyser/dataviewform.cpp
	WispSyser/dataoperatordlg.cpp
	WispSyser/multidataview.cpp
	WispSyser/watchlist.cpp
	WispSyser/stackwatchlist.cpp
	WispSyser/findstringform.cpp
	WispSyser/findlistwnd.cpp
	WispSyser/breakpointform.cpp
	WispSyser/codebpedit.cpp
	WispSyser/databpedit.cpp
	WispSyser/processlist.cpp
	WispSyser/debuggerselectform.cpp
	WispSyser/pluginlistform.cpp
	WispSyser/syseroptionform.cpp
	WispSyser/systemexplorer.cpp
	WispSyser/searchdialog.cpp
	WispSyser/runtracewnd.cpp
	WispSyser/runtrace.cpp

	WispSyser/modulelist.cpp
	WispSyser/commentlist.cpp
	WispSyser/callstackwnd.cpp
	WispSyser/functionlistwnd.cpp
	WispSyser/genereglist.cpp
	WispSyser/fpuregisterlist.cpp
	WispSyser/sseregisterlist.cpp
	WispSyser/sdsmodulelist.cpp
	WispSyser/strinputwnd.cpp
	WispSyser/currentfunction.cpp
	WispSyser/sourcecodewnd.cpp
	WispSyser/lex.cpp
	WispSyser/multisourcecodeview.cpp
	WispSyser/typeviewerwnd.cpp
	WispSyser/typeviewerform.cpp
	WispSyser/sourcedebugframewnd.cpp
	WispSyser/aboutform.cpp
	WispSyser/keymappingpage.cpp
	WispSyser/crossreferenceform.cpp
	WispSyser/mainframe.cpp
	WispSyser/idtwnd.cpp
	WispSyser/gdtwnd.cpp
	WispSyser/reghelpwnd.cpp
	WispSyser/pagemapwnd.cpp
	WispSyser/syserconfig.cpp
	WispSyser/sysercmd.cpp
	WispSyser/sharecmd.cpp
	WispSyser/othercmd.cpp
	WispSyser/ioctl.cpp
	WispSyser/ntstatus.cpp
	WispSyser/winerror.cpp
	WispSyser/bugcheckcode.cpp
	WispSyser/windowsmsg.cpp
)

file(GLOB_RECURSE USERMODE_SOURCES
	EXEAnalyzer/sourcedebug.cpp

	WispSyser/winwisp.cpp
	WispSyser/SyserRing3.cpp
	resource.rc
	syser.manifest
)
list(APPEND SOURCES ${USERMODE_SOURCES})

if(PLATFORM STREQUAL "x32")
  list(APPEND SOURCES
	WispSyser/x87x86double.asm
	WispSyser/sehchainwnd.cpp
  )
elseif(PLATFORM STREQUAL "x64")
  list(APPEND SOURCES
	WispSyser/x87x64double.asm
  )
endif()

add_executable(syser${PLATFORM} WIN32 ${SOURCES})

target_link_libraries(syser${PLATFORM}
	DIASDK
)

target_link_libraries(syser${PLATFORM}
	psapi
)

if(PLATFORM STREQUAL "x64")
	target_compile_options(syser${PLATFORM} PUBLIC /GS- /D_X64_)
endif()
target_include_directories(syser${PLATFORM} PUBLIC .)

add_library(sd${PLATFORM} SHARED ${SD_SOURCES})
if(PLATFORM STREQUAL "x64")
	target_compile_options(sd${PLATFORM} PUBLIC /GS- /D_X64_)
endif()
target_include_directories(sd${PLATFORM} PUBLIC .)

add_executable(mfcsymbols${PLATFORM}
	Code/fileio.cpp
	Code/fileiont.cpp
	Code/sysdep.cpp
	Code/strmem.cpp
	mfcsymbols.cpp
)
if(PLATFORM STREQUAL "x64")
	target_compile_options(mfcsymbols${PLATFORM} PUBLIC /GS- /D_X64_)
endif()
target_include_directories(mfcsymbols${PLATFORM} PUBLIC .)

add_executable(pdb2sds${PLATFORM}
	EXEAnalyzer/sourcedebug.cpp
	EXEAnalyzer/sdsmodule.cpp
	EXEAnalyzer/pefile.cpp
	Code/strmem.cpp
	Code/fileio.cpp
	Code/fileiont.cpp
	Code/imagefile.cpp
	Code/compress.cpp
	pdb2sds.cpp
)
target_link_libraries(pdb2sds${PLATFORM}
	DIASDK
)
if(PLATFORM STREQUAL "x64")
	target_compile_options(pdb2sds${PLATFORM} PUBLIC /GS- /D_X64_)
endif()
target_include_directories(pdb2sds${PLATFORM} PUBLIC .)

add_executable(unpack${PLATFORM}
	Code/fileio.cpp
	Code/fileiont.cpp
	Code/polyfs.cpp
	Code/handle.cpp
	Code/pagemem.cpp
	Code/imagefile.cpp
	Code/compress.cpp
	unpack.cpp
)
if(PLATFORM STREQUAL "x64")
	target_compile_options(unpack${PLATFORM} PUBLIC /GS- /D_X64_)
endif()
target_include_directories(unpack${PLATFORM} PUBLIC .)

```

`source/Code/alt/altarray.hpp`:

```hpp

#ifndef _ALT_ARRAY_HPP_
#define _ALT_ARRAY_HPP_

#include "../define.h"

template<class T, int N>
struct TArray
{
	int Count;
	int Size;
	T *m_ValueAry;
public:
	//TArray(const TArray &) {}
	//TArray(T *, int) {}
	TArray()
		: Count(0)
		, Size(0)
		, m_ValueAry(nullptr)
	{
		Resize(N);
	}

	~TArray()
	{
		SafeDeleteAry(m_ValueAry);
		Size = 0;
		Count = 0;
	}

	//void CopyConstruct(const TArray &) { }

	void Clear()
	{
		int OldSize = Size;
		SafeDeleteAry(m_ValueAry);
		Size = 0;
		Count = 0;
		Resize(OldSize);
	}

	bool Resize(int NewSize)
	{
	        if (NewSize != Size)
		{
			SafeDeleteAry(m_ValueAry);
			Size = NewSize;
			Count = 0;
			m_ValueAry = new T[NewSize];
		}
		return true;
	}

	bool Append(const T & Value)
	{
		if (Count >= Size)
			return false;
		m_ValueAry[Count] = Value;
		++Count;
		return true;
	}

	bool Remove()
	{
		if (Count <= 0)
			return false;
		--Count;
		return true;
	}

	T & operator[](int n)
	{
		int POS = (Size-Count+n)%Size;
		return m_ValueAry[POS];
	}

	//void Attach(T *, int) {}
	//void Detach() {}

	int Find(const T & Value) const
	{
		for (int n = 0; n < Count; ++n)
		{
			if (m_ValueAry[n] == Value)
				return n;
		}
		return 0;
	}
};

#endif
```

`source/Code/alt/altbase.hpp`:

```hpp

#ifndef _ALT_BASE_HPP_
#define _ALT_BASE_HPP_

#endif

```

`source/Code/alt/altexpcalc.hpp`:

```hpp

#ifndef _ALT_CALCEXP_HPP_
#define _ALT_CALCEXP_HPP_

#include "../define.h"
#include "../tstrmem.hpp"
#include "altlist.hpp"
#include "altmap.hpp"

//TExpCalc<char, unsigned long, 1>
//TEST altexpcalc.exe 4*(2+1)/(12/6)
//OK 4

//TEST altexpcalc.exe ffffffff+1
//OK 0

template<typename T, typename R, int NoCaseCmp>
struct TExpCalc
{
	TExpCalc()
	{
		AddFunc("&&", 5, LogicAnd, this);
		AddFunc("||", 5, LogicOr, this);
		AddFunc("^^", 5, LogicXor, this);

		AddFunc(">=", 4, NotBelow, this);
		AddFunc("<=", 4, NotAbove, this);
		AddFunc("==", 4, Equal, this);
		AddFunc("!=", 4, NotEqual, this);

		AddFunc(">>", 1, ShiftRight, this);
		AddFunc("<<", 1, ShiftLeft, this);

		AddFunc(">", 4, Above, this);
		AddFunc("<", 4, Below, this);

		AddFunc("+", 3, Add, this);
		AddFunc("-", 3, Sub, this);

		AddFunc("*", 2, Mul, this);
		AddFunc("/", 2, Div, this);
		AddFunc("%", 2, Mod, this);

		AddFunc("@", 1, Addr, this);
		AddFunc("^", 1, Xor, this);
		AddFunc("!", 1, Not, this);
		AddFunc("&", 1, And, this);
		AddFunc("|", 1, Or, this);

		AddFunc("(", 0, LeftBracket, this);
		AddFunc(")", 0, RightBracket, this);

		AddFunc("\"", 0, ExpVar, this);
		AddFunc("'", 0, ExpVar, this);
	}

	~TExpCalc()
	{
	}

	enum
	{
		SYM_VAL = 0,
		SYM_MEM = 1,
		SYM_FUNC = 2,
	};

	struct SYM_EXP_ITEM
	{
		union
		{
			R Val;
			void *Mem;
			R (*Func)(const char *Str, unsigned long Len);
		};
		int Length;
		int Type;
	};

	map<TString<T,NoCaseCmp,8>, SYM_EXP_ITEM> m_SymExpItem;

	void Reset()
	{
		m_SymExpItem.clear();
	}

	enum
	{
		EXP_RESULT	= 0,
		EXP_NEEDCALC	= 1,
		EXP_SYM		= 2,
		EXP_OPT		= 3,
	};

	struct EXPITEM
	{
		union
		{
			R Value;
			const char *StrValue;
			void *OptSymFunc;

		};
		int Type;
		int Length;
		const char *Str;
	};

	struct OPTSYMFUNC
	{
		TAnsiString OptStr;
		int Level;
		EXPITEM *(*OptFunc)(TListIter<EXPITEM> It, TList<EXPITEM> & Expressions, TExpCalc *This);
		TExpCalc *This;
	};

	TList<OPTSYMFUNC> m_OptFunc;

	void AddFunc(const char *OptStr, int Level, EXPITEM *(*OptFunc)(TListIter<EXPITEM> It, TList<EXPITEM> & Expressions, TExpCalc *This), TExpCalc *This)
	{
		int Len = TStrLen(OptStr);
		TListIter<OPTSYMFUNC> It = m_OptFunc.Begin();
		while (It != m_OptFunc.End())
		{
			if (It->Level > Level || (It->Level == Level && Len >= It->OptStr.m_nLength))
				break;
			++It;
		}
		It = m_OptFunc.InsertBefore(It);
		It->OptStr = OptStr;
		It->Level = Level;
		It->OptFunc = OptFunc;
		It->This = This;
	}

	OPTSYMFUNC * GetOptFunc(const char *OptStr) const
	{
		if (!TStrChr("`~!@#$%^&*()-+=|{}:;\"'<>,.?/\\'\"", OptStr[0]))
			return nullptr;

		for (int Len = 2; Len > 0; Len--)
		{
			TListIter<OPTSYMFUNC> It = m_OptFunc.Begin();
			while (It != m_OptFunc.End())
			{
				if (Len == It->OptStr.m_nLength &&
					!TStrNCmp(OptStr, It->OptStr.operator const char*(), It->OptStr.m_nLength))
				{
					//printf("%s:%d OP %s level %d\n",__func__,__LINE__, It->OptStr.operator const char*(), It->Level);
					return &*It;
				}
				++It;
			}
		}
		return nullptr;
	}

//
	bool InsertSym(const char *szSym, R Value)
	{
		typename map<TString<T,NoCaseCmp,8>, SYM_EXP_ITEM>::IT it = m_SymExpItem.insert(_Tmap_pair<TString<T,NoCaseCmp,8>, SYM_EXP_ITEM>(szSym,SYM_EXP_ITEM()));
		if (it == m_SymExpItem.end())
			return false;
		it->second.Val = Value;
		it->second.Type = SYM_VAL;
		return true;
	}
//
	bool InsertSym(const char *szSym, R *Mem, int Length)
	{
		typename map<TString<T,NoCaseCmp,8>, SYM_EXP_ITEM>::IT it = m_SymExpItem.insert(_Tmap_pair<TString<T,NoCaseCmp,8>, SYM_EXP_ITEM>(szSym,SYM_EXP_ITEM()));
		if (it == m_SymExpItem.end())
			return false;
		it->second.Mem = Mem;
		it->second.Length = Length;
		it->second.Type = SYM_MEM;
		return true;
	}

	bool UpdateSym(const char *szSym, R Mem)
	{
		typename map<TString<T,NoCaseCmp,8>, SYM_EXP_ITEM>::IT it = m_SymExpItem.find(szSym);
		if (it == m_SymExpItem.end())
			return false;
		if (it->second.Type != SYM_MEM)
			return false;
		memcpy(it->second.Mem, &Mem, it->second.Length);
		return true;
	}

	virtual bool GetValue(const char *szItem, R *pValue) const
	{
		if (USHexStrToNum(szItem, pValue))
		{
			//printf("%s:%d %s %d\n",__func__,__LINE__, szItem, *pValue);
			return true;
		}

		//printf("%s:%d CONTINUE\n",__func__,__LINE__);
		typename map<TString<T,NoCaseCmp,8>, SYM_EXP_ITEM>::const_iterator It = m_SymExpItem.find(szItem);

		if (It == m_SymExpItem.end())
			return false;
		
		if (It->second.Type == SYM_VAL)
		{
			*pValue = It->second.Val;
		} else
		if (It->second.Type == SYM_MEM)
		{
			*pValue = 0;
			TMemCpy((unsigned char*)pValue, (unsigned char*)It->second.Mem, It->second.Length);
		} else
		if (It->second.Type == SYM_FUNC)
		{
			*pValue = It->second.Func(It->first.operator const T*(), It->second.Length);
		}
		return true;
	}

	virtual R ReadValue(R Address)
	{
		R Value = 0;
		return Value;
	}
//
	virtual int ReadString(unsigned long Address, char *Buffer, int Length)
	{
		int nRet = 0;
		while (nRet<Length)
		{
			char Byte = ReadValue(Address+nRet*sizeof(char));
			if (Byte==0) break;
			Buffer[nRet++]=Byte;
		}
		Buffer[nRet]=0;
		return nRet;
	}
//
	virtual int ReadString(unsigned long Address, short *Buffer, int Length)
	{
		int nRet = 0;
		while (nRet<Length)
		{
			short Word = ReadValue(Address+nRet*sizeof(short));
			if (Word==0) break;
			Buffer[nRet++]=Word;
		}
		Buffer[nRet]=0;
		return nRet;
	}
//
	virtual void ReadMemory(R Address, void *Buffer, int Length)
	{
		int nRet = 0;
		while (nRet<Length)
		{
			((unsigned char*)Buffer)[nRet] = ReadValue(Address+nRet*sizeof(unsigned char));
			++nRet;
		}
	}
//
	bool ReadVar(EXPITEM *ExpItem) const
	{
		char Buffer[128];
		TStrCpyLimit(Buffer, ExpItem->Str, ExpItem->Length+1);
		if (GetValue(Buffer, &ExpItem->Value))
		{
			ExpItem->Type = EXP_RESULT;
			return true;
		}
		ExpItem->Type = EXP_NEEDCALC;
		return false;
	}

	bool BuildExpression(const char *ExpStr, TList<EXPITEM> & Expressions) const
	{
		EXPITEM *ExpItem = nullptr;
		int Len = TStrLen(ExpStr);

		int start = 0;
		int end = 0;

		while (start < Len)
		{
			const char *pCur = (const char *)&ExpStr[start];
			if (TStrChr("\r\n\t ", pCur[0]))
			{
				if (ExpItem)
				{
					ExpItem->Length = start - end;
					ReadVar(ExpItem);
					ExpItem = nullptr;
				}
			} else
			{
				OPTSYMFUNC *OptSymFunc = GetOptFunc(pCur);
				if (OptSymFunc)
				{
					if (ExpItem)
					{
						ExpItem->Length = start - end;
						ReadVar(ExpItem);
						ExpItem = nullptr;
					}

					if (pCur[0] == '"' || pCur[0] == '\'')
					{
						TListIter<EXPITEM> It = Expressions.Append();
						++start;
						It->Str = (char *)&ExpStr[start];
						It->StrValue = (char *)&ExpStr[start];
						end = start;
						while (ExpStr[start] &&
							ExpStr[start] != '"' &&
							ExpStr[start] != '\'')
							++start;
						It->Length = start - end;
						It->Type = EXP_SYM;
						//printf("%s:%d ADD SYM\n",__func__,__LINE__);
					} else
					{
						TListIter<EXPITEM> It = Expressions.Append();
						It->Str = pCur;
						It->Length = OptSymFunc->OptStr.m_nLength;
						It->OptSymFunc = OptSymFunc;
						It->Type = EXP_OPT;
						start += It->Length - 1;
						//printf("%s:%d ADD OPT\n",__func__,__LINE__);
					}
					end = start;
				} else
				if (ExpItem == nullptr)
				{
					TListIter<EXPITEM> It = Expressions.Append();
					ExpItem = &*It;
					ExpItem->Value = 0;
					ExpItem->Str = pCur;
					//ExpItem->Type = 0; //EXP_RESULT ???
					end = start;
					//printf("%s:%d ADD\n",__func__,__LINE__);
				}
				
			}
			++start;
		}

		if (ExpItem)
		{
			ExpItem->Length = start - end;
			ReadVar(ExpItem);
		}
		return true;
	}

	bool SolveExpression(TListIter<EXPITEM> Iter, TList<EXPITEM> & Expressions)// const
	{
		for (int level = 0; level < 6; ++level)
		{
			TListIter<EXPITEM> It = Iter;
			while (It != Expressions.End())
			{
				if (It->Type == EXP_OPT)
				{
					OPTSYMFUNC *OptSymFunc = (OPTSYMFUNC *)It->OptSymFunc;
					if (OptSymFunc->Level == level)
					{
						//printf("%s:%d %s level %d >>\n",__func__,__LINE__, OptSymFunc->OptStr.operator const char*(), level);
						EXPITEM *ExpItem = OptSymFunc->OptFunc(It, Expressions, this);
						if (ExpItem == nullptr) return false;
						//printf("%s:%d %s level %d Value %ld <<\n",__func__,__LINE__, OptSymFunc->OptStr.operator const char*(), level, ExpItem->Value);
						ExpItem->Type = EXP_RESULT;
						It = ExpItem; //???
					}
				}
				++It;
			}
		}
		return Expressions.Size() == 1 && Expressions.Begin()->Type == EXP_RESULT;
	}

	bool CalcExpression(const char *ExpStr, R *Result) //const
	{
		if (ExpStr == nullptr || ExpStr[0] == 0)
		{
			*Result = 0;
			return true;
		}
		
		TList<EXPITEM> Expressions;

		if (!BuildExpression(ExpStr, Expressions))
		{
			//printf("%s:%d BUILD FAIL\n",__func__,__LINE__);
			return false;
		}

		if (!SolveExpression(Expressions.Begin(), Expressions))
			return false;

		if (Result) *Result =  Expressions.Begin()->Value;
		return true;
	}

	static bool CheckResult(int LLevel, TListIter<EXPITEM> It, int RLevel, TList<EXPITEM> & Expressions)
	{
	#if 0
		TListIter<EXPITEM> Iter = It-1;
		int Index = 0;
		while (Index < LLevel)
		{
			if (Iter == Expressions.End() || Iter->Type!=EXP_RESULT)
				return false;
			--Iter;
			++Index;
		}

		//TListIter<EXPITEM>
		Iter = It+1;
		//int
		Index = 0;
		while (Index < LLevel)
		{
			if (Iter == Expressions.End() || Iter->Type!=EXP_RESULT)
				return false;
			++Iter;
			++Index;
		}
		return true;
	#else
		int PrevIndex = 0;
		if (LLevel <= 0)
		{
	AGAIN:
			TListIter<EXPITEM> NextIter = It+1;
			int NextIndex = 0;
			if (LLevel <= 0)
				return true;
			while (NextIter != Expressions.End() && NextIter->Type==EXP_RESULT)
			{
				++NextIter;
				++NextIndex;
				if (NextIndex>=LLevel)
					return true;
			}
		} else
		{
			TListIter<EXPITEM> PrevIter = It-1;
			while (PrevIter != Expressions.End() && PrevIter->Type==EXP_RESULT)
			{
				--PrevIter;
				++PrevIndex;
				if (PrevIndex>=LLevel)
				{
					goto AGAIN;
				}
			}
			
		}
		return false;
	#endif
	}

	static bool RemoveExpr(TListIter<EXPITEM> It, int Level, TList<EXPITEM> & Expressions)
	{
	#if 0
		TListIter<EXPITEM> Iter = It;
		int Index = 0;
		while (Index<Level)
		{
			if (Iter==Expressions.End()) return false;
			++Iter;
			++Index;
		}
		Expressions.Remove(It, Iter);
		return true;
	#else
		TListIter<EXPITEM> First = It;
		if (Level <= 0)
		{
			Expressions.Remove(First, First);//+1
			return true;
		}
		int Index = 0;
		TListIter<EXPITEM> Iter = It;
		while (Iter != Expressions.End())
		{
			++Iter;
			++Index;
			if (Level<=Index)
			{
				Expressions.Remove(First, Iter);
				return true;
			}
		}
		return false;
	#endif
	}

	static EXPITEM * LogicAnd(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value = ExpItem->Value && It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * LogicOr(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value = ExpItem->Value || It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * LogicXor(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			if (ExpItem->Value == 0)
			{
				if (It.Next()->Value == 1)
					ExpItem->Value = 1;
				else	ExpItem->Value = 0;
			} else
			if (ExpItem->Value == 1)
			{
				if (It.Next()->Value == 1)
					ExpItem->Value = 0;
				else	ExpItem->Value = 1;
			}
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}

	static EXPITEM * NotBelow(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value = ExpItem->Value >= It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * NotAbove(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value = ExpItem->Value <= It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * Below(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value = ExpItem->Value < It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * Above(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value = ExpItem->Value > It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}

	static EXPITEM * Equal(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
			{
				if (It-1 != Expression.End() && It+1 != Expression.End())
				{
					char Buffer[64];
					if (It.Prev()->Type == EXP_SYM && It.Next()->Type == EXP_RESULT)
					{
						pThis->ReadMemory(It.Next()->Value, Buffer, MIN(It.Prev()->Length*2,64));
						int r = !TStrNICmp((const char*)Buffer, (const char*)It.Prev()->StrValue, MIN(It.Prev()->Length,64)) ||
							!TStrNICmp((const short*)Buffer, (const short*)It.Prev()->StrValue, MIN(It.Prev()->Length,32));
						It.Prev()->Type = EXP_RESULT;
						It.Prev()->Value = r;
						RemoveExpr(It, 2, Expression);
						return &*It;
					} else
					if (It.Prev()->Type == EXP_RESULT && It.Next()->Type == EXP_SYM)
					{
						pThis->ReadMemory(It.Prev()->Value, Buffer, MIN(It.Next()->Length*2,64));
						int r = !TStrNICmp((const char*)Buffer, (const char*)It.Next()->StrValue, MIN(It.Next()->Length,64)) ||
							!TStrNICmp((const short*)Buffer, (const short*)It.Next()->StrValue, MIN(It.Next()->Length,32));
						It.Prev()->Type = EXP_RESULT;
						It.Prev()->Value = r;
						RemoveExpr(It, 2, Expression);
						return &*It;
					}
				}
				return nullptr;
			}
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value = ExpItem->Value == It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * NotEqual(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value = ExpItem->Value != It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}

	static EXPITEM * ShiftRight(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value >>= It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * ShiftLeft(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value <<= It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}

	static EXPITEM * Add(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			//printf("%s:%d\n",__func__,__LINE__);
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			//printf("%s:%d %ld %ld Size %d\n",__func__,__LINE__, It.Prev()->Value, It.Next()->Value, Expression.Size());
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value += It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			//printf("%s:%d Size %d\n",__func__,__LINE__, Expression.Size());
			return ExpItem;
		}
	static EXPITEM * Sub(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (CheckResult(1, It, 1, Expression))
			{
				EXPITEM *ExpItem = It.Prev();
				ExpItem->Value = ExpItem->Value - It.Next()->Value;
				RemoveExpr(It, 2, Expression);
				return ExpItem;
			} else
			if (CheckResult(0, It, 1, Expression))
			{
				EXPITEM *ExpItem = &*It;
				ExpItem->Value = -It.Next()->Value;
				RemoveExpr(It+1, 1, Expression);
				return ExpItem;
			}
			return nullptr;
		}

	static EXPITEM * Mul(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (CheckResult(1, It, 1, Expression))
			{
				EXPITEM *ExpItem = It.Prev();
				ExpItem->Value = ExpItem->Value * It.Next()->Value;
				RemoveExpr(It, 2, Expression);
				return ExpItem;
			} else
			if (CheckResult(0, It, 1, Expression))
			{
				EXPITEM *ExpItem = &*It;
				ExpItem->Value = pThis->ReadValue(It.Next()->Value);
				RemoveExpr(It+1, 1, Expression);
				return ExpItem;
			}
			return nullptr;
		}
	static EXPITEM * Div(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			if (It.Next() == 0)
				return nullptr;
			ExpItem->Value /= It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * Mod(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value %= It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}

	static EXPITEM * Xor(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value ^= It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * Not(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(0, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = &*It;
			ExpItem->Value = It.Next()->Value == 0;
			RemoveExpr(It+1, 1, Expression);
			return ExpItem;
		}
	static EXPITEM * And(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value &= It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * Or(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(1, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = It.Prev();
			ExpItem->Value |= It.Next()->Value;
			RemoveExpr(It, 2, Expression);
			return ExpItem;
		}
	static EXPITEM * Addr(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			if (!CheckResult(0, It, 1, Expression))
				return nullptr;
			EXPITEM *ExpItem = &*It;
			ExpItem->Value = pThis->ReadValue(It.Next()->Value);
			RemoveExpr(It+1, 1, Expression);
			return ExpItem;
		}

	static EXPITEM * LeftBracket(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{
			int level = 0;
			TListIter<EXPITEM> Iter = It+1;
			TListIter<EXPITEM> First = Iter;
			TListIter<EXPITEM> Last = First;
			while (Iter != Expression.End())
			{
				if (!TStrNCmp(Iter->Str, "(", Iter->Length))
					++level;
				if (!TStrNCmp(Iter->Str, ")", Iter->Length))
				{
					if (level==0) break;
					--level;
				}
				++Iter;
				Last = Iter;
			}
			if (Iter == Expression.End())
				return nullptr;

			TList<EXPITEM> SubExpressions;
			TListIter<EXPITEM> End = SubExpressions.End();
			Expression.Splice(First, Last, SubExpressions, End);
			if (!pThis->SolveExpression(SubExpressions.Begin(), SubExpressions))
				return nullptr;
			It->Value = SubExpressions.Begin()->Value;
			RemoveExpr(It+1, 1, Expression);
			return &*It;
		}
	static EXPITEM * RightBracket(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{ return nullptr; }

	static EXPITEM * ExpVar(TListIter<EXPITEM> It, TList<EXPITEM> & Expression, TExpCalc *pThis)
		{ return nullptr; }
};

#endif

//#define TEST
#ifdef TEST
#include "../../define.h"
//#include "altexpcalc.hpp"

#include <stdio.h>
#include <stdlib.h>

typedef TExpCalc<char, unsigned long, 1> ExpCalc;

int main(int argc, char **argv)
{
	ExpCalc calc;
	unsigned long Result = 0;
	printf("Calc %s\n", argv[1]);
	if (calc.CalcExpression(argv[1], &Result))
	{
		printf("Calc %s\n", argv[1]);
		printf("OK %ld %08x\n", Result, Result);
	} else
	{
		printf("Calc %s\n", argv[1]);
		printf("FAIL\n");
	}
return 0;
}
#endif

```

`source/Code/alt/altfile.hpp`:

```hpp

#ifndef _ALT_FILE_HPP_
#define _ALT_FILE_HPP_

#include "../define.h"

namespace ALT
{
	struct ALTFileStream
	{
		virtual unsigned long Write(const void *Buffer, unsigned long Size) { return 0; }
		virtual unsigned long Read(void *Buffer, unsigned long Size) { return 0; }
	};
}

#endif
```

`source/Code/alt/altlist.hpp`:

```hpp

#ifndef _ALT_LIST_HPP_
#define _ALT_LIST_HPP_

#include "../define.h"

struct TListNode
{
	TListNode *Next;
	TListNode *Prev;
};

template <typename T>
struct TListNodeValue : public TListNode
{
	T Value;
};

template <class T>
struct TListIter
{
public:
	typedef TListNodeValue<T> NODE;
	TListIter() { pNode = 0; }
	TListIter(NODE *Node) { pNode = Node; }
//	TListIter(T *Value) { pNode =  CONTAINING_RECORD_MY(Value, NODE, sizeof(TListNode)); }
	TListIter(T *Value) { pNode =  CONTAINING_RECORD_MY1(Value, NODE, Value); }
	T&  operator*() { return pNode->Value; }
	T* operator->() { return &pNode->Value; }

	T* Next() { NODE *p = (NODE*)pNode->Next; return &p->Value; }
	T* Prev() { NODE *p = (NODE*)pNode->Prev; return &p->Value; }

	bool operator==(const TListIter & Iter) const { return pNode==Iter.pNode; }
	bool operator!=(const TListIter & Iter) const { return pNode!=Iter.pNode; }
	operator bool() const { return pNode != 0; } //IsValid ?

	void Reset() { pNode = 0; }

	TListIter & operator++() //prefix ++i
	{
		pNode = (NODE*)pNode->Next;
		return *this;
	}
	TListIter & operator++(int n) //postfix i++
	{
		pNode = (NODE*)pNode->Next;
		return *this;
	}
	TListIter & operator+=(int n) //postfix i+=n
	{
		while (n-- > 0) pNode = (NODE*)pNode->Next;
		return *this;
	}
	TListIter operator+(int n) const
	{
		TListIter _Tmp = *this;
		_Tmp += n;
		return _Tmp;
	}
	TListIter & operator--() //prefix --i
	{
		pNode = (NODE*)pNode->Prev;
		return *this;
	}
	TListIter & operator--(int n) //postfix i--
	{
		pNode = (NODE*)pNode->Prev;
		return *this;
	}
	TListIter & operator-=(int n) //postfix i-=n
	{
//printf("[-= %d], ",n);
		while (n-- > 0) pNode = (NODE*)pNode->Prev;
		return *this;
	}
	TListIter operator-(int n) const
	{
//printf("[- %d], ",n);
		TListIter _Tmp = *this;
		_Tmp -= n;
		return _Tmp;
	}
//protected:
	NODE *pNode;
};

template<typename T>
struct compare_traits
{
	int operator()(const T a1, const T a2) const
	{
		return a1 != a2;
	}
};

template <typename T, typename compare = compare_traits<T> >
struct TList : public TListNode
{
public:
	typedef TListNodeValue<T> NODE;
	typedef TListIter<T> IT;
	TList()
	{
		Init();
	}
	TList(const TList & other)
	{
		Init();//Clear();
		if (other.Size())
		{
			for (IT it = other.Begin(); it != other.End(); ++it)
				Append(&*it);
		}
	}
	~TList()
	{
		Clear();
	}
	IT Begin() const { return (NODE*)pHead->Next; }
	IT End() const { return (NODE*)pHead; }
	int Size() const { return nSize; }
	bool Empty() const { return nSize == 0; }
	IT Find(const T & Value) const
	{
		IT Iter = Begin();
		while (Iter != End() &&
			//*Iter != Value)
			(compare()(*Iter, Value))!=0) //compare_not_eq
			++Iter;
		return Iter;
	}
	IT _Search(IT _First, IT _Last, const T & _Val) const
	{
		unsigned long _Count = 0;
		//_Distance(_First, _Last, _Count);
		IT First = _First;
		for (; First != _Last; ++First)
			++_Count;

		for (; 0 < _Count; )
		{       // divide and conquer, find half that contains answer
			unsigned long _Count2 = _Count / 2;
			IT _Mid = _First;
			//std::advance(_Mid, _Count2);
			unsigned long _Off = _Count2;
			for (; 0 < _Off; --_Off)
				++_Mid;

			//if (!(*_Mid < _Val)) //UPPER
			if (*_Mid < _Val) //LOWER
				_First = ++_Mid, _Count -= _Count2 + 1;
			else
				_Count = _Count2;
		}
		return (_First);		
	}
	IT Search(const T & Value) const
	{
		return _Search(Begin(), End(), Value);
	}
	IT AppendSort(const T &Value)
	{
		return InsertBefore(Search(Value), &Value);
	}
	
	IT operator[](int nIndex) const
	{
		if (nIndex==nSize-1)
		{
	//printf("[%d]==%d-1 ",nIndex,nSize-1);
			return End()-1;
		}
		if (nIndex>=nSize)
		{
	//printf("[%d]>=%d ",nIndex,nSize);
			return End();
		}
		if (nIndex>0)
		{
	//printf("[%d]>0 ",nIndex);
			return Begin()+(nIndex);
		}
	//printf("[%d]<=0 ",nIndex);
		return Begin()-(-nIndex);
	}
	//Cut [First,Last] and move to after Iter+[First,Last]
	int Splice(IT & First, IT & Last, TList & List, IT & Iter) //const,const,,const - clang
	{
		int n = 0;
		IT it=First;
		while (it != Last) it++,n++;
		if (n==0) return 0;

		NODE *tmp = (NODE*)Last.pNode->Prev;
		First.pNode->Prev->Next = Last.pNode;
		Last.pNode->Prev = First.pNode->Prev;
		
		nSize -= n;

		First.pNode->Prev = Iter.pNode;
		tmp->Next = Iter.pNode->Next;
		Iter.pNode->Next = First.pNode;
		tmp->Next->Prev = tmp;

		List.nSize += n;

//		First.pNode->Prev->Next = Last.pNode;
//		Last.pNode->Prev->Next = Iter.pNode;
//		Iter.pNode->Prev->Next = First.pNode;
//		NODE *Pnode = (NODE*)Iter.pNode->Prev;
//		Iter.pNode->Prev = Last.pNode->Prev;
//		Last.pNode->Prev = First.pNode->Prev;
//		First.pNode->Prev = Pnode;
		return n;
	}

	//Cut [First,Last] and move to after Iter+[First,Last]
	int _Splice(IT & First, IT & Last, TList & List, IT & Iter) //const,const,,const - clang
	{
		int n = 1;
	//	IT it=First;
	//	while (it != Last) it++,n++;
	//	if (n==0) return 0;

		NODE *tmp = (NODE*)Last.pNode->Prev;
		First.pNode->Prev->Next = Last.pNode;
		Last.pNode->Prev = First.pNode->Prev;
		
		nSize -= n;

		First.pNode->Prev = Iter.pNode;
		tmp->Next = Iter.pNode->Next;
		Iter.pNode->Next = First.pNode;
		tmp->Next->Prev = tmp;

		List.nSize += n;

//		First.pNode->Prev->Next = Last.pNode;
//		Last.pNode->Prev->Next = Iter.pNode;
//		Iter.pNode->Prev->Next = First.pNode;
//		NODE *Pnode = (NODE*)Iter.pNode->Prev;
//		Iter.pNode->Prev = Last.pNode->Prev;
//		Last.pNode->Prev = First.pNode->Prev;
//		First.pNode->Prev = Pnode;
		return n;
	}

	void Reverse()
	{
		if (2 <= Size())
		{
			IT Last = End();
			IT Next = ++Begin();
			while (Next != Last)
			{
				IT Before = Next;
				IT End = this->End();
				_Splice(Before, ++Next, *this, End);//Begin());
			}
		}
	}

	IT Append(const T *Value = 0)
	{
		NODE *Pnode = (NODE *)pHead;
		NODE *Newnode = new NODE;
		if (Value) Newnode->Value = *Value;
		if (nSize == 0) Pnode->Next = Newnode;
		Newnode->Next = Pnode;
		Newnode->Prev = Pnode->Prev;
		Newnode->Prev->Next = Newnode;
		Pnode->Prev = Newnode;
		++nSize;
		return Newnode;
	}
	IT InsertBefore(IT Iter, const T *Value = 0)
	{
		return InsertAfter(Iter-1, Value);
	}
//	IT InsertAfterNext(IT Iter, const T *Value = 0)
//	{
//		return InsertAfter(Iter+1, Value);
//	}
	IT InsertAfter(IT Iter, const T *Value = 0)
	{
		NODE *Pnode = Iter.pNode;
		NODE *Newnode = new NODE;
		if (Value) Newnode->Value = *Value;
		Newnode->Next = Pnode->Next;
		Newnode->Prev = Pnode;
		Pnode->Next->Prev = Newnode;
		Pnode->Next = Newnode;
		++nSize;
		return Newnode;
	}
//	IT push_back(IT Iter, const T *Value = 0)
//	{
//		NODE *Pnode = Iter.pNode;
//		NODE *Newnode = new NODE;
//		if (Value) Newnode->Value = *Value;
//		Newnode->Next = Pnode->Next->Next;
//		Newnode->Prev = Pnode->Next;
//		Pnode->Next->Next->Prev = Newnode;
//		Pnode->Next->Next = Newnode;
//		++Size;
//		return Newnode;
//	}
	IT Remove(IT First, IT Last)
	{
		IT it = First;
		while (it != Last)
			it = Remove(it)++;
		return First-1;
	}
	IT Remove(IT Iter)
	{
		NODE *Pnode = Iter.pNode;
		if (Pnode != pHead)
		{
			Pnode->Prev->Next = Pnode->Next;
			Pnode->Next->Prev = Pnode->Prev;
			NODE *ret = (NODE*)Pnode->Prev;
			delete Pnode;
			Pnode = ret;
			--nSize;
		}
		return Pnode;
	}
	IT Remove(const T & Value)
	{
		return Remove(Find(Value));
	}
	void Init()
	{
		pHead = this;
		pHead->Next = pHead;
		pHead->Prev = pHead;
		nSize = 0;
	}
	void Clear()
	{
		NODE *Pnext;
		NODE *Pnode = (NODE*)pHead->Next;
		for (;Pnode != (NODE*)pHead; Pnode = Pnext)
		{
			Pnext = (NODE*)Pnode->Next;
			delete Pnode;
		}
		Init();
	}
protected:
	TListNode *pHead;
	int nSize;
};

#endif

//#define TEST
#ifdef TEST
#include <stdio.h>
#include <stdlib.h>

int main()
{
	TList<long> List;
/////////////
	printf("Size %d\n", List.Size());
	printf("Fill\n");
	for (long i=0;i<20;++i)
	{
		printf("%d,",i);
		List.Append(&i);
	}
	printf("\n");
///////////
	printf("Show[-2]=%d,[-1]=%d,[0]=%d,[1]=%d %d\n", *List[-2],*List[-1],*List[-0],*List[1],List.Size());
#if 1
#if 0
///////////
	printf("Size %d\n", List.Size());
	printf("ShowList\n");
	for (auto it = List.Begin(); it!=List.End();++it)
	{
		printf("%d,", *it);
	}
	printf("\n");
///////////
	printf("Size %d\n", List.Size());
	printf("ShowListReverse\n");
	int j = 40;
	for (auto it = List.Begin(); j-- >0;++it)
	{
		printf("%d,", *it);
	}
	printf("\n");
///////////
	printf("Size %d\n", List.Size());
	printf("Show[]\n");
	for (long i=-20;i<20;++i)
	{
		printf("%d,", *(List[i]));
	}
	printf("\n");
///////////////
	long i = 66;
	List.InsertAfter(List[7],&i);

	printf("InsertAfter[7],%d Size %d\n", i,List.Size());
	printf("Show[]\n");
	for (long i=-20;i<20;++i)
	{
		printf("%d,", *(List[i]));
	}
	printf("\n");
////////////////
	List.Remove(List[3]);

	printf("Remove[3] Size %d\n", List.Size());
	printf("Show[]\n");
	for (long i=-20;i<20;++i)
	{
		printf("%d,", *(List[i]));
	}
	printf("\n");
///////////
	List.Remove(List[1], List[9]);

	printf("Remove[1],[9] Size %d\n", List.Size());
	printf("Show[]\n");
	for (long i=-20;i<20;++i)
	{
		printf("%d,", *(List[i]));
	}
	printf("\n");
#endif
/////////////
	TList<long> List2;
	printf("Splice [10] %d,[15] %d ", *List[10],*List[15]);
	List.Splice(List[10],List[15],List2,List2.End());

	printf("Size %d,Size2 %d\n", List.Size(),List2.Size());
	printf("Show[]\n");
	for (long i=0;i<20;++i)
	{
		printf("%d,", *(List[i]));
	}
	printf("\n");
	printf("Show2[]\n");
	for (long i=0;i<20;++i)
	{
		printf("%d,", *(List2[i]));
	}
	printf("\n");
#endif
return 0;
}
#endif

```

`source/Code/alt/altmap.hpp`:

```hpp

#ifndef _ALT_MAP_HPP_
#define _ALT_MAP_HPP_

#include "../define.h"
//#include <map>
//TMapNode
//TMap
#include <new>

		// TEMPLATE FUNCTION swap (from <algorithm>)
template<class _Ty> inline
	void swap(_Ty& _Left, _Ty& _Right)
	{	// exchange values stored at _Left and _Right
	_Ty _Tmp = _Left;
	_Left = _Right, _Right = _Tmp;
	}

//functional
template<class _Arg1, class _Arg2, class _Result>
	struct binary_function
	{
		typedef _Arg1 first_argument_type;
		typedef _Arg2 second_argument_type;
		typedef _Result result_type;
	};

template<class _Ty>
	struct less : public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty& _Left, const _Ty& _Right) const { return (_Left < _Right); }
	};

//xmemory
	#define _CPOINTER_X(T, A)	typename A::template rebind<T>::other::const_pointer
	#define _CREFERENCE_X(T, A)	typename A::template rebind<T>::other::const_reference
	#define _POINTER_X(T, A)	typename A::template rebind<T>::other::pointer
	#define _REFERENCE_X(T, A)	typename A::template rebind<T>::other::reference

	template<class _Ty> inline
	_Ty *_Allocate(size_t _Count, _Ty *) { return ((_Ty *)operator new(_Count * sizeof (_Ty))); }

	template<class _Ty, class _Tv> inline
	void _Construct(_Ty *_Ptr, const _Tv& _Val) { new ((void *)_Ptr) _Ty(_Val); }

	template<class _Ty> inline
	void _Destroy(_Ty *_Ptr) { _Ptr->~_Ty(); }

//	template<> inline
//	void _Destroy(char *) {}

//	template<> inline
//	void _Destroy(wchar_t *) {}

	template<class _Ty>
	struct _Allocator_base
	{
		typedef _Ty value_type;
	};

	template<class _Ty>
	struct _Allocator_base<const _Ty>
	{
		typedef _Ty value_type;
	};

template<class _Ty>
class allocator	: public _Allocator_base<_Ty>
	{
public:
	typedef _Allocator_base<_Ty> _Mybase;
	typedef typename _Mybase::value_type value_type;

	typedef value_type *pointer;
	typedef value_type & reference;
	typedef const value_type *const_pointer;
	typedef const value_type & const_reference;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	template<class _Other>
	struct rebind
	{
		typedef allocator<_Other> other;
	};

	pointer address(reference _Val) const {	return (&_Val);	}
	const_pointer address(const_reference _Val) const { return (&_Val); }

	allocator() {}
	allocator(const allocator<_Ty>&) {}
	template<class _Other>
	allocator(const allocator<_Other>&) {}
	template<class _Other>
	allocator<_Ty>& operator=(const allocator<_Other>&) { return (*this); }
	void deallocate(pointer _Ptr, size_type) { operator delete(_Ptr); }
	pointer allocate(size_type _Count) { return (_Allocate(_Count, (pointer)0)); }
	pointer allocate(size_type _Count, const void *) { return (allocate(_Count)); }
	void construct(pointer _Ptr, const _Ty& _Val) { _Construct(_Ptr, _Val); }
	void destroy(pointer _Ptr) { _Destroy(_Ptr); }

	size_t max_size() const
		{
		size_t _Count = (size_t)(-1) / sizeof(_Ty);
		return (0 < _Count ? _Count : 1);
		}
	};

	template<class _Ty, class _Other> inline
	bool operator==(const allocator<_Ty>&, const allocator<_Other>&) { return (true); }

	template<class _Ty, class _Other> inline
	bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) { return (false); }

template<>
class allocator<void>
	{
public:
	typedef void _Ty;

	typedef _Ty *pointer;
	typedef const _Ty *const_pointer;
	typedef _Ty value_type;

	template<class _Other>
	struct rebind
	{
		typedef allocator<_Other> other;
	};

	allocator() {}
	allocator(const allocator<_Ty>&) {}

	template<class _Other>
	allocator(const allocator<_Other>&) {}

	template<class _Other>
	allocator<_Ty>& operator=(const allocator<_Other>&) { return (*this); }
	};

//utility
		// TEMPLATE STRUCT pair
template<class _Ty1, class _Ty2>
	struct pair
	{
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	pair()
		: first(_Ty1()), second(_Ty2())
		{
		}

	pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{
		}

	template<class _Other1,	class _Other2>
		pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{
		}

//	void swap(_Myt& _Right)
//		{
//		std::swap(first, _Right.first);
//		std::swap(second, _Right.second);
//		}

	_Ty1 first;
	_Ty2 second;
	};


//xutility
		// ITERATOR TAGS
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag	{};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};
struct _Int_iterator_tag {};

		// POINTER ITERATOR TAGS
struct _Nonscalar_ptr_iterator_tag {};
struct _Scalar_ptr_iterator_tag {};

		// TEMPLATE CLASS iterator
template<class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty *, class _Reference = _Ty&>
	struct iterator
	{
		typedef _Category iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};

template<class _Ty, class _Diff, class _Pointer, class _Reference>
	struct _Bidit : public iterator<bidirectional_iterator_tag, _Ty, _Diff, _Pointer, _Reference>
	{
	};

template<class _Ty, class _Diff, class _Pointer, class _Reference>
	struct _Ranit : public iterator<random_access_iterator_tag, _Ty, _Diff, _Pointer, _Reference>
	{
	};

struct _Outit : public iterator<output_iterator_tag, void, void, void, void>
	{
	};

		// TEMPLATE CLASS iterator_traits
template<class _Iter>
	struct iterator_traits
	{
		typedef typename _Iter::iterator_category iterator_category;
		typedef typename _Iter::value_type value_type;
		typedef typename _Iter::difference_type difference_type;
		typedef difference_type distance_type;
		typedef typename _Iter::pointer pointer;
		typedef typename _Iter::reference reference;
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef ptrdiff_t difference_type;
		typedef ptrdiff_t distance_type;
		typedef _Ty *pointer;
		typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef ptrdiff_t difference_type;
		typedef ptrdiff_t distance_type;
		typedef const _Ty *pointer;
		typedef const _Ty& reference;
	};

//TMap only
//_Tree only
		// TEMPLATE CLASS _Tree_nod
template<class _Traits>
	class _Tree_nod	: public _Traits
	{
protected:
	struct _Node;
	friend struct _Node;

	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename _Traits::value_type value_type;
	typedef typename allocator_type::template rebind<_Node>::other::pointer _Genptr;

	struct _Node
	{
		_Node()
			: _Isnode(false)
			{
			}

		_Node(_Genptr _Larg, _Genptr _Parg, _Genptr _Rarg, char _Carg)
			: _Left(_Larg), _Parent(_Parg), _Right(_Rarg), _Color(_Carg), _Isnode(true)
			{
			}

		_Genptr _Left;
		_Genptr _Right;
		_Genptr _Parent;
		char _Color;
		char _Isnode;
	};

	struct _NodeValue : public _Node
		{
		_NodeValue(_Genptr _Larg, _Genptr _Parg, _Genptr _Rarg,
			const value_type& _Val, char _Carg)
			: _Node(_Larg, _Parg, _Rarg, _Carg),
				_Myval(_Val)
			{
			}

		value_type _Myval;
		};

	_Tree_nod(const key_compare& _Parg, allocator_type _Al)
		: _Traits(_Parg), _Alnod(_Al)
		{
		}

	typename allocator_type::template rebind<_NodeValue>::other _Alnod;
	};

		// TEMPLATE CLASS _Tree_ptr
template<class _Traits>
	class _Tree_ptr	: public _Tree_nod<_Traits>
	{
protected:
	typedef typename _Tree_nod<_Traits>::_Node _Node;
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename allocator_type::template rebind<_Node>::other::pointer _Nodeptr;

	_Tree_ptr(const key_compare& _Parg, allocator_type _Al)
		: _Tree_nod<_Traits>(_Parg, _Al), _Alptr(_Al)
		{
		}

	typename allocator_type::template rebind<_Nodeptr>::other _Alptr;
	};

		// TEMPLATE CLASS _Tree_val
template<class _Traits>
	class _Tree_val	: public _Tree_ptr<_Traits>
	{
protected:
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;

	_Tree_val(const key_compare& _Parg, allocator_type _Al)
		: _Tree_ptr<_Traits>(_Parg, _Al), _Alval(_Al)
		{
		}

	allocator_type _Alval;
	};

		// TEMPLATE CLASS _Tree
template<class _Traits>
	class _Tree : public _Tree_val<_Traits>
	{
public:
	typedef typename _Tree_nod<_Traits>::_NodeValue _NodeValue; //+++

	typedef _Tree<_Traits> _Myt;
	typedef _Tree_val<_Traits> _Mybase;
	typedef typename _Traits::key_type key_type;
	typedef typename _Traits::mapped_type mapped_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename _Traits::value_compare value_compare;
	typedef typename _Traits::value_type value_type;
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::_ITptr _ITptr;
	typedef typename _Traits::_IReft _IReft;

protected:
	typedef typename _Tree_nod<_Traits>::_Genptr _Genptr;
	typedef typename _Tree_nod<_Traits>::_Node _Node;

	enum _Redbl {_Black, _Red};
	typedef _POINTER_X(_Node, allocator_type) _Nodeptr;
	typedef _REFERENCE_X(_Nodeptr, allocator_type) _Nodepref;
	typedef _CREFERENCE_X(key_type, allocator_type) _Keyref;
	typedef _CREFERENCE_X(mapped_type, allocator_type) _Mapref;
	typedef _REFERENCE_X(char, allocator_type) _Charref;
	typedef _REFERENCE_X(value_type, allocator_type) _Vref;

	static _Charref _Color(_Nodeptr _Pnode) { return ((_Charref)(*_Pnode)._Color); }
	static _Charref _Isnode(_Nodeptr _Pnode) { return ((_Charref)(*_Pnode)._Isnode); }
	static _Keyref _Key(_Nodeptr _Pnode) { return (_Mybase::_Kfn(_Myval(_Pnode))); }
	static _Mapref _Map(_Nodeptr _Pnode) { return (_Mybase::_Tfn(_Myval(_Pnode))); }
	static _Nodepref _Left(_Nodeptr _Pnode) { return ((_Nodepref)(*_Pnode)._Left); }
	static _Nodepref _Parent(_Nodeptr _Pnode) { return ((_Nodepref)(*_Pnode)._Parent); }
	static _Nodepref _Right(_Nodeptr _Pnode) { return ((_Nodepref)(*_Pnode)._Right); }
	static _Vref _Myval(_Nodeptr _Pnode) { return ((_Vref)(*((_NodeValue *)_Pnode))._Myval); }
public:
	typedef typename allocator_type::size_type size_type;
	typedef typename allocator_type::difference_type _Dift;
	typedef _Dift difference_type;
	typedef _POINTER_X(value_type, allocator_type) _Tptr;
	typedef _CPOINTER_X(value_type, allocator_type) _Ctptr;
	typedef _REFERENCE_X(value_type, allocator_type) _Reft;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef _Reft reference;
	typedef _CREFERENCE_X(value_type, allocator_type) const_reference;

		// CLASS const_iterator
	class const_iterator;
	friend class const_iterator;

	class const_iterator : public _Bidit<value_type, _Dift, _Ctptr, const_reference>
	{
	public:
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Dift difference_type;
		typedef _Ctptr pointer;
		typedef const_reference reference;

		const_iterator(const mapped_type *Mapped)
			: _Ptr(CONTAINING_RECORD_MY1(((unsigned char*)Mapped-sizeof(key_type)), _NodeValue, _Myval))
			{
				//_Ptr = (unsigned char*)_Ptr-sizeof(key_type);
			}

		const_iterator()
			: _Ptr(0)
			{
			}

 #define _TREE_CONST_ITERATOR(ppnode)	const_iterator(ppnode)

		const_iterator(_Nodeptr _Pnode)
			: _Ptr(_Pnode)
			{
			}

		const_reference operator*() const
			{
			return (_Myval(_Ptr));
			}

		_Ctptr operator->() const
			{
			return (&**this);
			}

		const_iterator& operator++()
			{
			_Inc();
			return (*this);
			}

		const_iterator operator++(int)
			{
			const_iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		const_iterator& operator--()
			{
			_Dec();
			return (*this);
			}

		const_iterator operator--(int)
			{
			const_iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}

		bool operator==(const const_iterator& _Right) const
			{
			return (_Ptr == _Right._Ptr);
			}

		bool operator!=(const const_iterator& _Right) const
			{
			return (!(*this == _Right));
			}

		void _Dec()
			{
			if (!_Ptr) return;
				// move to node with next smaller value
			if (!_Isnode(_Ptr))
				_Ptr = _Right(_Ptr);	// end() ==> rightmost
			else if (_Isnode(_Left(_Ptr)))
				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree
			else
				{	// climb looking for left subtree
				_Nodeptr _Pnode;
				while (_Isnode(_Pnode = _Parent(_Ptr))
					&& _Ptr == _Left(_Pnode))
					_Ptr = _Pnode;	// ==> parent while left subtree
				_Ptr = _Pnode;	// ==> parent (tail if begin())
				}
			}

		void _Inc()
			{
			if (!_Ptr) return;
				// move to node with next larger value
			if (!_Isnode(_Ptr))
				_Ptr = _Left(_Ptr);	// end() ==> leftmost
			else if (_Isnode(_Right(_Ptr)))
				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree
			else
				{	// climb looking for right subtree
				_Nodeptr _Pnode;
				while (_Isnode(_Pnode = _Parent(_Ptr))
					&& _Ptr == _Right(_Pnode))
					_Ptr = _Pnode;	// ==> parent while right subtree
				_Ptr = _Pnode;	// ==> parent (head if end())
				}
			}

		_Nodeptr _Mynode() const
			{
			return (_Ptr);
			}

		operator bool() const
			{
			return _Ptr != 0 && _Isnode(_Ptr);
			}
	protected:
		_Nodeptr _Ptr;
		};

		// CLASS iterator
	class iterator;
	friend class iterator;

	class iterator : public const_iterator
	{
	public:
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Dift difference_type;
		typedef _ITptr pointer;
		typedef _IReft reference;

		iterator(const mapped_type *Mapped)
			: const_iterator(Mapped) //_Ptr(CONTAINING_RECORD_MY1(((unsigned char*)Mapped-sizeof(key_type)), _NodeValue, _Myval))
			{
				//_Ptr = (unsigned char*)_Ptr-sizeof(key_type);
			}

		iterator()
			{
			}

 #define _TREE_ITERATOR(ppnode)	iterator(ppnode)

		iterator(_Nodeptr _Pnode)
			: const_iterator(_Pnode)
			{
			}

		reference operator*() const
			{
			return ((reference)**(const_iterator *)this);
			}

		pointer operator->() const
			{
			return (&**this);
			}

		iterator& operator++()
			{
			++(*(const_iterator *)this);
			return (*this);
			}

		iterator operator++(int)
			{
			iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		iterator& operator--()
			{
			--(*(const_iterator *)this);
			return (*this);
			}

		iterator operator--(int)
			{
			iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}
		};


//	typedef reverse_iterator<iterator> reverse_iterator;
//	typedef reverse_iterator<const_iterator> const_reverse_iterator;
	typedef pair<iterator, bool> _Pairib;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;

	explicit _Tree(const key_compare& _Parg, const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{
		_Init();
		}

//	_Tree(const value_type *_First, const value_type *_Last,
//		const key_compare& _Parg, const allocator_type& _Al)
//		: _Mybase(_Parg, _Al)
//		{	// construct tree from [_First, _Last) array
//		_Init();
//		_TRY_BEGIN
//		insert(_First, _Last);
//		_CATCH_ALL
//		_Tidy();
//		_RERAISE;
//		_CATCH_END
//		}

	_Tree(const _Myt& _Right)
		: _Mybase(_Right.key_comp(), _Right.get_allocator())
		{
		_Init();
		_Copy(_Right);
		}

	~_Tree()
		{
		clear();
		}

	_Myt& operator=(const _Myt& _Right)
		{
		if (this != &_Right)
			{
			clear();
			this->comp = _Right.comp;
			_Copy(_Right);
			}
		return (*this);
		}

	iterator begin() { return (_TREE_ITERATOR(_Lmost())); }
	const_iterator begin() const { return (_TREE_CONST_ITERATOR(_Lmost()));	}
	iterator end() { return (_TREE_ITERATOR(_Myhead)); }
	const_iterator end() const { return (_TREE_CONST_ITERATOR(_Myhead)); }

	iterator rbegin() { return (_TREE_ITERATOR(_Rmost())); }
	const_iterator rbegin() const { return (_TREE_CONST_ITERATOR(_Rmost())); }
	iterator rend() { return (_TREE_ITERATOR(_Myhead)); }
	const_iterator rend() const { return (_TREE_CONST_ITERATOR(_Myhead)); }

//	reverse_iterator rbegin() { return (reverse_iterator(end())); }
//	const_reverse_iterator rbegin() const { return (const_reverse_iterator(end()));	}
//	reverse_iterator rend()	{ return (reverse_iterator(begin())); }
//	const_reverse_iterator rend() const { return (const_reverse_iterator(begin())); }

	size_type size() const { return (_Mysize); }
	size_type max_size() const { return (this->_Alval.max_size()); }
	bool empty() const { return (size() == 0); }

	allocator_type get_allocator() const { return (this->_Alval); }
	key_compare key_comp() const { return (this->comp); }
	value_compare value_comp() const { return (value_compare(key_comp())); }

	iterator insert(const value_type& _Val)
		{	// try to insert node with value _Val
		_Nodeptr _Trynode = _Myroot;
		_Nodeptr _Wherenode = _Myhead;
		bool _Addleft = true;	// add to left of head if tree empty
		while (_Isnode(_Trynode))
			{	// look for leaf to insert before (_Addleft) or after
			_Wherenode = _Trynode;
			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);
			}

		if (this->_Multi)
			return _Insert(_Addleft, _Wherenode, _Val);
		else
			{	// insert only if unique
			iterator _Where = _TREE_ITERATOR(_Wherenode);
			if (!_Addleft)
				;	// need to test if insert after is okay
			else if (_Where == begin())
				return _Insert(true, _Wherenode, _Val);
			else
				--_Where;	// need to test if insert before is okay

			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
				return _Insert(_Addleft, _Wherenode, _Val);
			else
				return _Myhead;
			}
		}

//???
	iterator insert(iterator _Where,
		const value_type& _Val)
		{	// try to insert node with value _Val using _Where as a hint
		iterator _Next;

		if (size() == 0)
			return (_Insert(true, _Myhead, _Val));	// insert into empty tree
		else if (this->_Multi)
			{	// insert even if duplicate
			if (_Where == begin())
				{	// insert at beginning if before first element
				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (_Where == end())
				{	// insert at end if after last element
				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
					return (_Insert(false, _Rmost(), _Val));
				}
			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
				&& !this->comp(this->_Kfn(_Val),
					_Key((--(_Next = _Where))._Mynode())))
				{	// insert before _Where
				if (!_Isnode(_Right(_Next._Mynode())))
					return (_Insert(false, _Next._Mynode(), _Val));
				else
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
				&& (++(_Next = _Where) == end()
					|| !this->comp(_Key(_Next._Mynode()),
						this->_Kfn(_Val))))
				{	// insert after _Where
				if (!_Isnode(_Right(_Where._Mynode())))
					return (_Insert(false, _Where._Mynode(), _Val));
				else
					return (_Insert(true, _Next._Mynode(), _Val));
				}
			}
		else
			{	// insert only if unique
			if (_Where == begin())
				{	// insert at beginning if before first element
				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (_Where == end())
				{	// insert at end if after last element
				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))
					return (_Insert(false, _Rmost(), _Val));
				}
			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
					this->_Kfn(_Val)))
				{	// insert before _Where
				if (!_Isnode(_Right(_Next._Mynode())))
					return (_Insert(false, _Next._Mynode(), _Val));
				else
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
				&& (++(_Next = _Where) == end()
					|| this->comp(this->_Kfn(_Val),
						_Key(_Next._Mynode()))))
				{	// insert after _Where
				if (!_Isnode(_Right(_Where._Mynode())))
					return (_Insert(false, _Where._Mynode(), _Val));
				else
					return (_Insert(true, _Next._Mynode(), _Val));
				}
			}

		return (insert(_Val));	// try usual insert if all else fails
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	// insert [_First, _Last) one at a time
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	iterator erase(iterator _Where)
		{	// erase element at _Where
		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
		++_Where;	// save successor iterator for return

		_Nodeptr _Fixnode;	// the node to recolor as needed
		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
		_Nodeptr _Pnode = _Erasednode;

		if (!_Isnode(_Left(_Pnode)))
			_Fixnode = _Right(_Pnode);	// must stitch up right subtree
		else if (!_Isnode(_Right(_Pnode)))
			_Fixnode = _Left(_Pnode);	// must stitch up left subtree
		else
			{	// two subtrees, must lift successor node to replace erased
			_Pnode = _Where._Mynode();	// _Pnode is successor node
			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree
			}

		if (_Pnode == _Erasednode)
			{	// at most one subtree, relink it
			_Fixnodeparent = _Parent(_Erasednode);
			if (_Isnode(_Fixnode))
				_Parent(_Fixnode) = _Fixnodeparent;	// link up

			if (_Myroot == _Erasednode)
				_Myroot = _Fixnode;	// link down from root
			else if (_Left(_Fixnodeparent) == _Erasednode)
				_Left(_Fixnodeparent) = _Fixnode;	// link down to left
			else
				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

			if (_Lmost() == _Erasednode)
				_Lmost() = !_Isnode(_Fixnode)
					? _Fixnodeparent	// smallest is parent of erased node
					: _Min(_Fixnode);	// smallest in relinked subtree

			if (_Rmost() == _Erasednode)
				_Rmost() = !_Isnode(_Fixnode)
					? _Fixnodeparent	// largest is parent of erased node
					: _Max(_Fixnode);	// largest in relinked subtree
			}
		else
			{	// erased has two subtrees, _Pnode is successor to erased
			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up
			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

			if (_Pnode == _Right(_Erasednode))
				_Fixnodeparent = _Pnode;	// successor is next to erased
			else
				{	// successor further down, link in place of erased
				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
				if (_Isnode(_Fixnode))
					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
				_Left(_Fixnodeparent) = _Fixnode;	// link fix down
				_Right(_Pnode) = _Right(_Erasednode);	// link successor down
				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up
				}

			if (_Myroot == _Erasednode)
				_Myroot = _Pnode;	// link down from root
			else if (_Left(_Parent(_Erasednode)) == _Erasednode)
				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left
			else
				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up
			swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it
			}

		if (_Color(_Erasednode) == _Black)
			{	// erasing black link, must recolor/rebalance tree
			for (; _Fixnode != _Myroot && _Color(_Fixnode) == _Black;
				_Fixnodeparent = _Parent(_Fixnode))
				if (_Fixnode == _Left(_Fixnodeparent))
					{	// fixup left subtree
					_Pnode = _Right(_Fixnodeparent);
					if (_Color(_Pnode) == _Red)
						{	// rotate red up from right subtree
						_Color(_Pnode) = _Black;
						_Color(_Fixnodeparent) = _Red;
						_Lrotate(_Fixnodeparent);
						_Pnode = _Right(_Fixnodeparent);
						}

					if (!_Isnode(_Pnode))
						_Fixnode = _Fixnodeparent;	// shouldn't happen
					else if (_Color(_Left(_Pnode)) == _Black
						&& _Color(_Right(_Pnode)) == _Black)
						{	// redden right subtree with black children
						_Color(_Pnode) = _Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	// must rearrange right subtree
						if (_Color(_Right(_Pnode)) == _Black)
							{	// rotate red up from left sub-subtree
							_Color(_Left(_Pnode)) = _Black;
							_Color(_Pnode) = _Red;
							_Rrotate(_Pnode);
							_Pnode = _Right(_Fixnodeparent);
							}

						_Color(_Pnode) = _Color(_Fixnodeparent);
						_Color(_Fixnodeparent) = _Black;
						_Color(_Right(_Pnode)) = _Black;
						_Lrotate(_Fixnodeparent);
						break;	// tree now recolored/rebalanced
						}
					}
				else
					{	// fixup right subtree
					_Pnode = _Left(_Fixnodeparent);
					if (_Color(_Pnode) == _Red)
						{	// rotate red up from left subtree
						_Color(_Pnode) = _Black;
						_Color(_Fixnodeparent) = _Red;
						_Rrotate(_Fixnodeparent);
						_Pnode = _Left(_Fixnodeparent);
						}
					if (!_Isnode(_Pnode))
						_Fixnode = _Fixnodeparent;	// shouldn't happen
					else if (_Color(_Right(_Pnode)) == _Black
						&& _Color(_Left(_Pnode)) == _Black)
						{	// redden left subtree with black children
						_Color(_Pnode) = _Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	// must rearrange left subtree
						if (_Color(_Left(_Pnode)) == _Black)
							{	// rotate red up from right sub-subtree
							_Color(_Right(_Pnode)) = _Black;
							_Color(_Pnode) = _Red;
							_Lrotate(_Pnode);
							_Pnode = _Left(_Fixnodeparent);
							}

						_Color(_Pnode) = _Color(_Fixnodeparent);
						_Color(_Fixnodeparent) = _Black;
						_Color(_Left(_Pnode)) = _Black;
						_Rrotate(_Fixnodeparent);
						break;	// tree now recolored/rebalanced
						}
					}

			_Color(_Fixnode) = _Black;	// ensure stopping node is black
			}

		this->_Alnod.destroy((_NodeValue*)_Erasednode);	// destroy, free erased node
		this->_Alnod.deallocate((_NodeValue*)_Erasednode, 1);

		if (0 < _Mysize)
			--_Mysize;

		return (_Where);	// return successor iterator
		}

	iterator erase(iterator _First, iterator _Last)
		{	// erase [_First, _Last)
		if (_First == begin() && _Last == end())
			{	// erase all
			clear();
			return (begin());
			}
		else
			{	// partial erase, one at a time
			while (_First != _Last)
				erase(_First++);
			return (_First);
			}
		}

	size_type erase(const key_type& _Keyval)
		{
		size_type _Num = 0;
		iterator _Where = find(_Keyval);
		while (_Where != end() && _Keyval == _Key(_Where._Mynode()))
			{
			erase(_Where++);
			++_Num;
			}
		return (_Num);
		}

	void clear()
		{
		if (_Mysize != 0)
			{
			_Erase(_Myroot);
			_Init();
			}
		}

	iterator find_near(const key_type& _Keyval)
		{
		iterator _Where = lower_bound(_Keyval);
		if (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode())))
			{
				if (_Where == end()) return end();
				if (this->comp(_Key(_Where._Mynode()), _Keyval)) return _Where;
				iterator _Next = _Where;
				_Next--;
				return (_Next == end() ? _Where : _Next);
			}
		return _Where;
		}

	iterator find_near(const key_type& _Keyval) const
		{
		const_iterator _Where = lower_bound(_Keyval);
		if (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode())))
			{
				if (_Where == end()) return end();
				if (this->comp(_Key(_Where._Mynode()), _Keyval)) return _Where;
				const_iterator _Next = _Where;
				_Next--;
				return (_Next == end() ? _Where : _Next);
			}
		return _Where;
		}

	iterator find(const key_type& _Keyval)
		{
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
			? end() : _Where);
		}

	const_iterator find(const key_type& _Keyval) const
		{
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
			? end() : _Where);
		}

	size_type count(const key_type& _Keyval) const
		{
		size_type _Num = 0;
		const_iterator _Where = find(_Keyval);
		while (_Where != end() && _Keyval == _Key(_Where._Mynode()))
			{
			_Where++;
			++_Num;
			}
		return (_Num);
		}

	iterator lower_bound(const key_type& _Keyval)
		{
		return (_TREE_ITERATOR(_Lbound(_Keyval)));
		}

	const_iterator lower_bound(const key_type& _Keyval) const
		{
		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));
		}

	iterator upper_bound(const key_type& _Keyval)
		{
		return (_TREE_ITERATOR(_Ubound(_Keyval)));
		}

	const_iterator upper_bound(const key_type& _Keyval) const
		{
		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));
		}

//	void swap(_Myt& _Right)
//		{
//		if (get_allocator() == _Right.get_allocator())
//			{
//			std::swap(this->comp, _Right.comp);
//			std::swap(_Myhead, _Right._Myhead);
//			std::swap(_Mysize, _Right._Mysize);
//			}
//		else
//			{
//			_Myt _Tmp = *this; *this = _Right, _Right = _Tmp;
//			}
//		}

protected:
	void _Copy(const _Myt& _Right)
		{	// copy entire tree from _Right
//		_Root() = _Copy(_Right._Root(), _Myhead);
//		_Mysize = _Right.size();
//		if (!_Isnode(_Root()))
//			{	// nonempty tree, look for new smallest and largest
//			_Lmost() = _Min(_Root());
//			_Rmost() = _Max(_Root());
//			}
//		else
//			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

			if (_Right.size())
			{
				const_iterator _Where = _Right.begin();
				while (_Where != _Right.end())
				{
					insert(_Myval(_Where._Mynode())); //multi
					_Where++;
				}
			}
		}

//	_Nodeptr _Copy(_Nodeptr _Rootnode, _Nodeptr _Wherenode)
//		{	// copy entire subtree, recursively
//		_Nodeptr _Newroot = _Myhead;	// point at nil node
//
//		if (!_Isnode(_Rootnode))
//			{	// copy a node, then any subtrees
//			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
//				_Myval(_Rootnode), _Color(_Rootnode));
//			if (_Isnode(_Newroot))
//				_Newroot = _Pnode;	// memorize new root
//
//			_TRY_BEGIN
//			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);
//			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);
//			_CATCH_ALL
//			_Erase(_Newroot);	// subtree copy failed, bail out
//			_RERAISE;
//			_CATCH_END
//			}
//
//		return (_Newroot);	// return newly constructed tree
//		}

	void _Erase(_Nodeptr _Rootnode)
		{	// free entire subtree, recursively
			if (_Isnode(_Rootnode))
			{
				if (_Isnode(_Left(_Rootnode)))
					_Erase(_Left(_Rootnode));

				if (_Isnode(_Right(_Rootnode)))
					_Erase(_Right(_Rootnode));

				if (_Myroot == _Rootnode)
					_Myroot = _Myhead;

				if (_Left(_Parent(_Rootnode)) == _Rootnode)
					_Left(_Parent(_Rootnode)) = _Myhead;
				else	_Right(_Parent(_Rootnode)) = _Myhead;

				if (_Left(_Myhead) == _Rootnode)
				{
					iterator _Where = _TREE_ITERATOR(_Rootnode);
					_Where++;
					_Lmost() = _Where._Mynode();
				}

				if (_Right(_Myhead) == _Rootnode)
				{
					iterator _Where = _TREE_ITERATOR(_Rootnode);
					_Where--;
					_Lmost() = _Where._Mynode();
				}
				--_Mysize;
				this->_Alnod.destroy((_NodeValue*)_Rootnode);
				this->_Alnod.deallocate((_NodeValue*)_Rootnode, 1);
			}
		}

	void _Init()
		{
		_Myhead = _Buynode();
		//_Isnode(_Myhead) = false;
		_Myroot = _Myhead;
		_Root() = _Myhead;
		_Lmost() = _Myhead, _Rmost() = _Myhead;
		_Mysize = 0;
		}

	iterator _Insert(bool _Addleft, _Nodeptr _Wherenode,
		const value_type& _Val)
		{	// add node with value next to _Wherenode, to left if _Addnode
		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
			_Val, _Red);

		++_Mysize;
		if (_Wherenode == _Myhead)
			{	// first node in tree, just set head values
			_Myroot = _Newnode;
			_Lmost() = _Newnode, _Rmost() = _Newnode;
			}
		else if (_Addleft)
			{	// add to left of _Wherenode
			_Left(_Wherenode) = _Newnode;
			if (_Wherenode == _Lmost())
				_Lmost() = _Newnode;
			}
		else
			{	// add to right of _Wherenode
			_Right(_Wherenode) = _Newnode;
			if (_Wherenode == _Rmost())
				_Rmost() = _Newnode;
			}

		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )
			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))
				{	// fixup red-red in left subtree
				_Wherenode = _Right(_Parent(_Parent(_Pnode)));
				if (_Color(_Wherenode) == _Red)
					{	// parent has two red children, blacken both
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Wherenode) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Pnode = _Parent(_Parent(_Pnode));
					}
				else
					{	// parent has red and black children
					if (_Pnode == _Right(_Parent(_Pnode)))
						{	// rotate right child to left
						_Pnode = _Parent(_Pnode);
						_Lrotate(_Pnode);
						}
					_Color(_Parent(_Pnode)) = _Black;	// propagate red up
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Rrotate(_Parent(_Parent(_Pnode)));
					}
				}
			else
				{	// fixup red-red in right subtree
				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
				if (_Color(_Wherenode) == _Red)
					{	// parent has two red children, blacken both
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Wherenode) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Pnode = _Parent(_Parent(_Pnode));
					}
				else
					{	// parent has red and black children
					if (_Pnode == _Left(_Parent(_Pnode)))
						{	// rotate left child to right
						_Pnode = _Parent(_Pnode);
						_Rrotate(_Pnode);
						}
					_Color(_Parent(_Pnode)) = _Black;	// propagate red up
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Lrotate(_Parent(_Parent(_Pnode)));
					}
				}

		_Color(_Myroot) = _Black;	// root is always black
		return (_TREE_ITERATOR(_Newnode));
		}

	_Nodeptr _Lbound(const key_type& _Keyval) const
		{	// find leftmost node not less than _Keyval
		_Nodeptr _Pnode = _Myroot;
		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

		while (_Isnode(_Pnode))
			if (this->comp(_Key(_Pnode), _Keyval))
				_Pnode = _Right(_Pnode);	// descend right subtree
			else
				{	// _Pnode not less than _Keyval, remember it
				_Wherenode = _Pnode;
				_Pnode = _Left(_Pnode);	// descend left subtree
				}

		return (_Wherenode);	// return best remembered candidate
		}

	_Nodeptr& _Lmost() { return (_Left(_Myhead)); }
	_Nodeptr& _Lmost() const { return (_Left(_Myhead)); }

	void _Lrotate(_Nodeptr _Wherenode)
		{	// promote right node to root of subtree
		_Nodeptr _Pnode = _Right(_Wherenode);
		_Right(_Wherenode) = _Left(_Pnode);

		if (_Isnode(_Left(_Pnode)))
			_Parent(_Left(_Pnode)) = _Wherenode;
		_Parent(_Pnode) = _Parent(_Wherenode);

		if (_Wherenode == _Myroot)
			_Myroot = _Pnode;
		else if (_Wherenode == _Left(_Parent(_Wherenode)))
			_Left(_Parent(_Wherenode)) = _Pnode;
		else
			_Right(_Parent(_Wherenode)) = _Pnode;

		_Left(_Pnode) = _Wherenode;
		_Parent(_Wherenode) = _Pnode;
		}

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{	// return rightmost node in subtree at _Pnode
		while (_Isnode(_Right(_Pnode)))
			_Pnode = _Right(_Pnode);
		return (_Pnode);
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{	// return leftmost node in subtree at _Pnode
		while (_Isnode(_Left(_Pnode)))
			_Pnode = _Left(_Pnode);
		return (_Pnode);
		}

	_Nodeptr& _Rmost() { return (_Right(_Myhead)); }
	_Nodeptr& _Rmost() const { return (_Right(_Myhead)); }

	_Nodeptr& _Root() { return (_Parent(_Myhead)); }
	_Nodeptr& _Root() const	{ return (_Parent(_Myhead)); }

	void _Rrotate(_Nodeptr _Wherenode)
		{	// promote left node to root of subtree
		_Nodeptr _Pnode = _Left(_Wherenode);
		_Left(_Wherenode) = _Right(_Pnode);

		if (_Isnode(_Right(_Pnode)))
			_Parent(_Right(_Pnode)) = _Wherenode;
		_Parent(_Pnode) = _Parent(_Wherenode);

		if (_Wherenode == _Myroot)
			_Myroot = _Pnode;
		else if (_Wherenode == _Right(_Parent(_Wherenode)))
			_Right(_Parent(_Wherenode)) = _Pnode;
		else
			_Left(_Parent(_Wherenode)) = _Pnode;

		_Right(_Pnode) = _Wherenode;
		_Parent(_Wherenode) = _Pnode;
		}

	_Nodeptr _Ubound(const key_type& _Keyval) const
		{	// find leftmost node greater than _Keyval
		_Nodeptr _Pnode = _Myroot;
		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

		while (_Isnode(_Pnode))
			if (this->comp(_Keyval, _Key(_Pnode)))
				{	// _Pnode greater than _Keyval, remember it
				_Wherenode = _Pnode;
				_Pnode = _Left(_Pnode);	// descend left subtree
				}
			else
				_Pnode = _Right(_Pnode);	// descend right subtree

		return (_Wherenode);	// return best remembered candidate
		}

	_Nodeptr _Buynode()
		{	// allocate a head/nil node
		_Nodeptr _Wherenode = &_Base;
		_Color(_Wherenode) = _Black;
		_Isnode(_Wherenode) = false;
		return (_Wherenode);
		}

	_Nodeptr _Buynode(_Nodeptr _Larg, _Nodeptr _Parg,
		_Nodeptr _Rarg, const value_type& _Val, char _Carg)
		{	// allocate a node with pointers, value, and color
		_Nodeptr _Wherenode = this->_Alnod.allocate(1);
//		_TRY_BEGIN
		new (_Wherenode) _NodeValue(_Larg, _Parg, _Rarg, _Val, _Carg);
//		_CATCH_ALL
//		this->_Alnod.deallocate(_Wherenode, 1);
//		_RERAISE;
//		_CATCH_END
		return (_Wherenode);
		}

//	void _Tidy()
//		{	// free all storage
//		erase(begin(), end());
//		this->_Alptr.destroy(&_Left(_Myhead));
//		this->_Alptr.destroy(&_Parent(_Myhead));
//		this->_Alptr.destroy(&_Right(_Myhead));
//		this->_Alnod.deallocate(_Myhead, 1);
//		_Myhead = 0, _Mysize = 0;
//		}

	_Node _Base;
	_Nodeptr _Myroot;
	_Nodeptr _Myhead;
	size_type _Mysize;
	};

//TMap
template<class _Ty1, class _Ty2>
	struct _Tmap_pair
	{
	typedef _Tmap_pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	_Tmap_pair()
		: first(_Ty1()), second(_Ty2())
		{
		}

	_Tmap_pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{
		}

	_Tmap_pair(const _Ty1& _Val1, const _Ty2* _Val2 = nullptr)
		: first(_Val1)//, second(_Val2)
		{
			if (_Val2) second = *_Val2;
		}

	template<class _Other1, class _Other2>
		_Tmap_pair(const _Tmap_pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{
		}

//	void swap(_Myt& _Right)
//		{
//		std::swap(first, _Right.first);
//		std::swap(second, _Right.second);
//		}

	_Ty1 first;
	_Ty2 second;
	};

//TMap
template<class _Kty,	// key type
	class _Ty,	// mapped type
	class _Pr,	// comparator predicate type
	class _Alloc,	// actual allocator type (should be value allocator)
	bool _Mfl>	// true if multiple equivalent keys are permitted
	class _Tmap_traits
	{
public:
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;
	typedef _Tmap_pair<const _Kty, _Ty> value_type;
	typedef _Pr key_compare;
	typedef typename _Alloc::template rebind<value_type>::other allocator_type;
	typedef _POINTER_X(value_type, allocator_type) _ITptr;
	typedef _REFERENCE_X(value_type, allocator_type) _IReft;

	enum {_Multi = _Mfl};

	_Tmap_traits()
		: comp()
		{
		}

	_Tmap_traits(_Pr _Parg)
		: comp(_Parg)
		{
		}

	class value_compare : public binary_function<value_type, value_type, bool>
		{
		friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

	public:
		bool operator()(const value_type& _Left, const value_type& _Right) const
			{
			return (comp(_Left.first, _Right.first));
			}

		value_compare(key_compare _Pred)
			: comp(_Pred)
			{
			}
	protected:
		key_compare comp;
		};

	static const _Kty& _Kfn(const value_type& _Val)	{ return (_Val.first); }
	static const _Ty& _Tfn(const value_type& _Val)	{ return (_Val.second); }

	_Pr comp;
	};

		// TEMPLATE CLASS map
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<_Tmap_pair<const _Kty, _Ty> > >
	class map : public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
	{
public:
	typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator IT; //iterator;
	typedef typename _Mybase::const_iterator const_iterator;
//	typedef typename _Mybase::reverse_iterator reverse_iterator;
//	typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	map()
		: _Mybase(key_compare(), allocator_type())
		{
		}

	explicit map(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{
		}

	map(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	// construct map from [_First, _Last), defaults
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,	const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	// construct map from [_First, _Last), comparator
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last, const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct map from [_First, _Last), comparator, and allocator
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	mapped_type& operator[](const key_type& _Keyval)
		{
		iterator _Where = this->lower_bound(_Keyval);
		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))
			_Where = this->insert(_Where,
				value_type(_Keyval, mapped_type()));
		return ((*_Where).second);
		}

		IT Insert(const key_type &Key, mapped_type Value)
		{
			return this->insert(_Tmap_pair<const key_type, mapped_type>(Key, Value));
		}

		IT Insert(const key_type &Key)
		{
			return this->insert(_Tmap_pair<const key_type, mapped_type>(Key, nullptr));
		}
	};

//template<class _Kty, class _Ty, class _Pr, class _Alloc> inline
//	void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left, map<_Kty, _Ty, _Pr, _Alloc>& _Right)
//	{
//		_Left.swap(_Right);
//	}

//TSet
template<class _Kty,	// key/value type
	class _Pr,	// comparator predicate type
	class _Alloc,	// actual allocator type (should be value allocator)
	bool _Mfl>	// true if multiple equivalent keys are permitted
	class _Tset_traits
	{
public:
	typedef _Kty key_type;
	typedef _Kty mapped_type;
	typedef _Kty value_type;
	typedef _Pr key_compare;
	typedef typename _Alloc::template rebind<value_type>::other allocator_type;
	typedef _POINTER_X(value_type, allocator_type) _ITptr;
	typedef _REFERENCE_X(value_type, allocator_type) _IReft;

	enum {_Multi = _Mfl};

	_Tset_traits()
		: comp()
		{
		}

	_Tset_traits(_Pr _Parg)
		: comp(_Parg)
		{
		}

	typedef key_compare value_compare;

	static const _Kty& _Kfn(const value_type& _Val)	{ return (_Val); }

	_Pr comp;
	};

		// TEMPLATE CLASS set
template<class _Kty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<_Kty> >
	class set
		: public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> >
	{	// ordered red-black tree of key values, unique keys
public:
	typedef set<_Kty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator IT; //iterator;
	typedef typename _Mybase::const_iterator const_iterator;
//	typedef typename _Mybase::reverse_iterator reverse_iterator;
//	typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	set()
		: _Mybase(key_compare(), allocator_type())
		{
		}

	explicit set(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{
		}

	set(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{
		}

	template<class _Iter>
		set(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	// construct set from [_First, _Last), defaults
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		set(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	// construct set from [_First, _Last), comparator
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		set(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct set from [_First, _Last), defaults, and allocator
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}
	};

//template<class _Kty,
//	class _Pr,
//	class _Alloc> inline
//	void swap(set<_Kty, _Pr, _Alloc>& _Left,
//		set<_Kty, _Pr, _Alloc>& _Right)
//	{	// swap _Left and _Right sets
//	_Left.swap(_Right);
//	}

#endif
```

`source/Code/alt/altqueue.hpp`:

```hpp

#ifndef _ALT_QUEUE_HPP_
#define _ALT_QUEUE_HPP_

#include "../define.h"
#include "altarray.hpp"

template<class T, int N>
struct TQueue : public TArray<T,N>
{
	int m_HeadIndex;
public:
	TQueue()
	{
		m_HeadIndex = -1;
	}
	~TQueue()
	{
	}

	void Clear()
	{
		TArray<T,N>::Clear();
		m_HeadIndex = -1;
	}

	bool Append(const T & Value)
	{
		if (this->Size == 0) return false;
		if (this->Count < this->Size) this->Count++;
		m_HeadIndex = (m_HeadIndex+1)%this->Size;
		this->m_ValueAry[m_HeadIndex] = Value;
		return true;
	}

	T * Append(const T *Value)
	{
		if (this->Size == 0) return 0;
		if (this->Count < this->Size) this->Count++;
		m_HeadIndex = (m_HeadIndex+1)%this->Size;
		if (Value)
			this->m_ValueAry[m_HeadIndex] = *Value;
		return &this->m_ValueAry[m_HeadIndex];
	}

	T & operator[](int n)
	{
		int POS = m_HeadIndex+1+n;
		return TArray<T,N>::operator[](POS);
	}
};

#endif
```

`source/Code/alt/altstack.hpp`:

```hpp

#ifndef _ALT_STACK_HPP_
#define _ALT_STACK_HPP_

#include "../define.h"
#include "altqueue.hpp"

template<typename T, int N>
struct TStack : public TQueue<T,N>
{
public:
	//TStack(const TStack&) {}
	TStack() {}
	~TStack() {}

	void Push(const T & Value); //???
	bool Pop(T & Value); //???
	T & operator[](int n)
	{
		int POS = this->Count-1-n;
		return TQueue<T,N>::operator[](POS);
	}
};

#endif
```

`source/Code/alt/altstring.hpp`:

```hpp

#ifndef _ALT_STRING_HPP_
#define _ALT_STRING_HPP_

#endif

```

`source/Code/cmdparser.cpp`:

```cpp

#include "cmdparser.hpp"

	CCmdParser::CCmdParser()
	{
		//EMPTY
	}

	CCmdParser::~CCmdParser()
	{
		//EMPTY
	}

	void CCmdParser::PrintString(const WCHAR *szStr)
	{
		//EMPTY
	}

	void CCmdParser::Reset()
	{
		m_CmdMap.clear();
	}

	bool CCmdParser::InsertCmd(const WCHAR *szCmd, CMDPROC pCmdProc, void *pUserData, const WCHAR *pComment, const WCHAR *pUsage)
	{
		WCHAR CmdStr[258];
		TStrCpy(CmdStr, szCmd);
		TStrLwr(CmdStr);

		map<TWideNoCaseString, COMMAND_ENTRY>::IT it = m_CmdMap.Insert(CmdStr);
		if (it == m_CmdMap.end())
			return false;

		it->second.pCmdProc = pCmdProc;
		it->second.pUserData = pUserData;
		it->second.pComment = pComment;
		it->second.pUsage = pUsage;

		return true;
	}

	void CCmdParser::RemoveCmd(const WCHAR *szCmd)
	{
		TWideNoCaseString Cmd(szCmd);
		Cmd.MakeLower();
		m_CmdMap.erase(Cmd);
	}

	int CCmdParser::GetParam(WCHAR *pStr, const WCHAR **pParam)
	{
		int Len = TStrLen(pStr);
		while (Len--)
		{
			if (pStr[Len] == '\n')
				pStr[Len] = 0;
		}
		int Count = 1;
		WCHAR *pPrm = pStr;
		*pParam = pStr;
		while (*pPrm)
		{
			pPrm = TStrChr(pPrm, ' ');
			if (!pPrm)
				break;
			while (*pPrm == ' ')
				*pPrm++ = 0;
			if (*pPrm)
				pParam[Count++] = pPrm;
		}
		return Count;
	}

	bool CCmdParser::CompareParam(const WCHAR *pParam1, const WCHAR *pParam2)
	{
		WCHAR Param1[256];
		WCHAR Param2[256];
		TStrCpyLimit(Param1, pParam1, lenof(Param1));
		TStrCpyLimit(Param2, pParam2, lenof(Param2));

		const WCHAR *Prm1[33];
		const WCHAR *Prm2[33];

		int nParam1 = GetParam(Param1, Prm1);
		int nParam2 = GetParam(Param2, Prm2);
		if (nParam1 != nParam2)
			return false;
		for (int n = 0; n < nParam1; ++n)
		{
			if (TStrCmp(Prm1[n], Prm2[n]))
				return false;
		}
		return true;
	}

	bool CCmdParser::ParseCmd(const WCHAR *szCmd, unsigned long *pResult)
	{
		WCHAR CmdStr[258];
		const WCHAR *ParamStr[32];

		while (*szCmd == 32 || *szCmd == 9) ++szCmd; //is_space

		if (TStrCpyLimit(CmdStr, szCmd, 256) == 0)
			return false;

		int ParamCount = GetParam(CmdStr, ParamStr);

		map<TWideNoCaseString, COMMAND_ENTRY>::IT it = m_CmdMap.find(CmdStr);
		if (it == m_CmdMap.end())
			return false;

		unsigned long ret = it->second.pCmdProc(ParamCount, ParamStr, szCmd, it->second.pUserData);
		if (pResult) *pResult = ret;
		return true;
	}

	void CCmdParser::ParseCmds(const WCHAR *szCmds, WCHAR Delim)
	{
		WCHAR CmdStr[514];
		while (szCmds && *szCmds)
		{
			while (*szCmds == Delim) ++szCmds;
			WCHAR *pStrDelim = TStrChr(szCmds, Delim);
			if (pStrDelim)
			{
				TStrCpyLimit(CmdStr, szCmds, MIN(pStrDelim - szCmds, 512));
				szCmds = pStrDelim;
			} else
			{
				TStrCpyLimit(CmdStr, szCmds, 512);
				szCmds = NULL;
			}
			ParseCmd(CmdStr, NULL);
		}
	}

```

`source/Code/cmdparser.hpp`:

```hpp

#ifndef _CMDPARSER_HPP_
#define _CMDPARSER_HPP_

#include "define.h"
#include "alt/altmap.hpp"
#include "tstrmem.hpp"

typedef int (*CMDPROC)(int argc, const WCHAR *argv[], const WCHAR *szCmd, void *pUserData);

struct COMMAND_ENTRY
{
	const WCHAR *pComment;
	const WCHAR *pUsage;
	CMDPROC pCmdProc;
	void *pUserData;
};

struct CCmdParser
{
	CCmdParser();

	virtual ~CCmdParser(); //???

	virtual void PrintString(const WCHAR *szStr); //???

	map<TWideNoCaseString,COMMAND_ENTRY> m_CmdMap;

	virtual void Reset();
	virtual bool InsertCmd(const WCHAR *szCmd, CMDPROC pCmdProc, void *pUserData, const WCHAR *pComment, const WCHAR *pUsage);
	virtual void RemoveCmd(const WCHAR *szCmd);

	bool CompareParam(const WCHAR *pParam1, const WCHAR *pParam2);
	int GetParam(WCHAR *pStr, const WCHAR **pParam);
	bool ParseCmd(const WCHAR *szCmd, unsigned long *pResult);
	void ParseCmds(const WCHAR *szCmds, WCHAR Delim);
};

#endif

```

`source/Code/compress.cpp`:

```cpp

#include "compress.hpp"
#include "define.h"

//https://lwn.net/Articles/235121/
//https://lwn.net/Articles/237112/
//https://lore.kernel.org/lkml/20181127161913.23863-7-dave.rodgman@arm.com/
//https://git.kontron-electronics.de/linux/uboot-exceet/blob/a874c8c65f57ecfbb8c7961525ac4376b6fbab8b/fs/jffs2/compr_lzo.c
//https://www.codingnow.com/windsoul/package/lzoc.htm
//compress TODO

long _do_compress(BYTE *in, unsigned in_len, BYTE *out, unsigned *out_len, long *wrkmem)
{
    register BYTE *ip;
    BYTE *op;
    BYTE *in_end = in + in_len;
    BYTE *ip_end = in + in_len - 13;
    BYTE *ii;
    BYTE **dict = (BYTE **)wrkmem;
    op = out;
    ip = in;
    ii = ip;
    ip += 4;

    for(;;)
    {
		register BYTE *m_pos;
		unsigned m_off;
		unsigned m_len;
		unsigned dindex;
		dindex = ((0x21*(((((((unsigned)(ip[3])<<6)^ip[2])<<5)^ip[1])<<5)^ip[0]))>>5) & 0x3fff;
		m_pos = dict [dindex];
		if(((ULONG_PTR)m_pos < (ULONG_PTR)in) ||
			(m_off = (unsigned)((ULONG_PTR)ip-(ULONG_PTR)m_pos) ) <= 0 ||
			m_off > 0xbfff)
			goto literal;
		if(m_off <= 0x0800 || m_pos[3] == ip[3])
			goto try_match;
		dindex = (dindex & 0x7ff ) ^ 0x201f;
		m_pos = dict[dindex];
		if((ULONG_PTR)(m_pos) < (ULONG_PTR)(in) ||
			(m_off = (unsigned)( (int)((ULONG_PTR)ip-(ULONG_PTR)m_pos))) <= 0 ||
			m_off > 0xbfff)
		    goto literal;
		if (m_off <= 0x0800 || m_pos[3] == ip[3])
			goto try_match;
		goto literal;
try_match:
		if(*(unsigned short*)m_pos == *(unsigned short*)ip && m_pos[2]==ip[2])
			goto match;
literal:
		dict[dindex] = ip;
		++ip;
		if (ip >= ip_end)
			break;
		continue;
match:
		dict[dindex] = ip;
		if(ip - ii > 0)
		{
			register unsigned t = ip - ii;
			
			if (t <= 3)
				op[-2] |= (BYTE)t;
			else if(t <= 18)
				*op++ = (BYTE)(t-3);
			else
			{
				register unsigned tt = t-18;
				*op++ = 0;
				while(tt > 255)
				{
					tt -= 255;
					*op++ = 0;
				}
				*op++ = (BYTE)tt;
			}
			do *op++ = *ii++; while (--t > 0);
		}
		ip += 3;
		if(m_pos[3] != *ip++ || m_pos[4] != *ip++ || m_pos[5] != *ip++ ||
			m_pos[6] != *ip++ || m_pos[7] != *ip++ || m_pos[8] != *ip++ )
		{
			--ip;
			m_len = ip - ii;
			
			if(m_off <= 0x0800 )
			{
				--m_off;
				*op++ = (BYTE)(((m_len - 1) << 5) | ((m_off & 7) << 2));
				*op++ = (BYTE)(m_off >> 3);
			}
			else
				if (m_off <= 0x4000 )
				{
					-- m_off;
					*op++ = (BYTE)(32 | (m_len - 2));
					goto m3_m4_offset;
				} else
				{
					m_off -= 0x4000;
					*op++ = (BYTE)(16 | ((m_off & 0x4000) >> 11) | (m_len - 2));
					goto m3_m4_offset;
				}
		} else
		{
			{
				BYTE *end = in_end;
				BYTE *m = m_pos + 9;
				while (ip < end && *m == *ip)
					m++, ip++;
				m_len = (ip - ii);
			}
			
			if(m_off <= 0x4000)
			{
				--m_off;
				if (m_len <= 33)
					*op++ = (BYTE)(32 | (m_len - 2));
				else
				{
					m_len -= 33;
					*op++=32;
					goto m3_m4_len;
				}
			} else
			{
				m_off -= 0x4000;
				if(m_len <= 9)
					*op++ = (BYTE)(16|((m_off & 0x4000) >> 11) | (m_len - 2));
				else
				{
					m_len -= 9;
					*op++ = (BYTE)(16 | ((m_off & 0x4000) >> 11));
m3_m4_len:
					while (m_len > 255)
					{
						m_len -= 255;
						*op++ = 0;
					}
					*op++ = (BYTE)m_len;
				}
			}
m3_m4_offset:
			*op++ = (BYTE)((m_off & 63) << 2);
			*op++ = (BYTE)(m_off >> 6);
		}
		ii = ip;
		if (ip >= ip_end)
			break;
    }
    *out_len = op - out;
    return (unsigned) (in_end - ii);
}

long lzo_compress(void *in, long in_len, void *out)
{
    BYTE *op = (BYTE*)out + 4; //reserv for size
    unsigned t, out_len;
    if (in_len <= 13)
		t = in_len;
    else
    {
		long wrkmem[16384];
		t = _do_compress((BYTE*)in, in_len, op, &out_len, wrkmem);
		op += out_len;
    }
    if (t > 0)
    {
		BYTE *ii = (BYTE*)in + in_len - t;
		if (op == (BYTE*)out+4 && t <= 238)
			*op++ = (BYTE) (17 + t);
		else
			if (t <= 3)
				op[-2] |= (BYTE)t;
			else
				if (t <= 18)
					*op++ = (BYTE)(t-3);
				else
				{
					unsigned tt = t - 18;
					*op++ = 0;
					while (tt > 255) 
					{
						tt -= 255;
						*op++ = 0;
					}
					*op++ = (BYTE)tt;
				}
				do *op++ = *ii++; while (--t > 0);
    }
    *op++ = 17;
    *op++ = 0;
    *op++ = 0;
    *(unsigned int*)out = in_len; //write size
    return (op - (BYTE*)out);
}

long lzo_decompress(void *in, long in_len, void *out)
{
    register BYTE *op;
    register BYTE *ip;
    register unsigned int t;
    register BYTE *m_pos;

    BYTE *ip_end = (BYTE *)in + in_len; //not used

    op = (BYTE *)out;
    ip = (BYTE *)in+4; //skip size

    if (*ip > 17)
    {
        t = *ip++ - 17;
        if (t < 4)
            goto match_next;
        do { *op++ = *ip++; } while(--t > 0);
        goto first_literal_run;
    }

    while(1)
    {
        t = *ip++;
        if (t >= 16) goto match;
        if (t == 0)
        {
            while(*ip == 0)
            {
                t += 255;
                ip++;
            }
            t += 15 + *ip++;
        }

        *(unsigned *)op = *(unsigned *)ip;
        op += 4; ip += 4;
        if (--t > 0)    
        {
            if (t >= 4)
            {
                do {
                    *(unsigned *)op = *(unsigned *)ip;
                    op += 4; ip += 4; t -= 4;
                } while(t >= 4);
                if (t > 0) do { *op++ = *ip++; } while(--t > 0);
            } else
                do { *op++ = *ip++; } while(--t > 0);
        }

first_literal_run:

        t = *ip++;
        if (t >= 16)
            goto match;

        m_pos = op - 0x0801;
        m_pos -= t >> 2;
        m_pos -= *ip++ << 2;

        *op++ = *m_pos++;
        *op++ = *m_pos++;
        *op++ = *m_pos;

        goto match_done;

        while (1)
        {
match:
            if (t >= 64)
            {
                m_pos = op - 1;
                m_pos -= (t >> 2) & 7;
                m_pos -= *ip++ << 3;
                t = (t >> 5) - 1;
    
                goto copy_match;
            } else
            if (t >= 32)
            {
                t &= 31;
                if (t == 0)
                {
                    while (*ip == 0)
                    {
                        t += 255;
                        ip++;
                    }
                    t += 31 + *ip++;
                }
#if defined(__LITTLE_ENDIAN)
                m_pos = op - 1;
                m_pos -= (*(unsigned short *)ip) >> 2;
#else
                m_pos = op - 1;
                m_pos -= (ip[0] >> 2) + (ip[1] << 6);
#endif
                ip += 2;
            } else
            if (t >= 16)
            {
                m_pos = op;
                m_pos -= (t & 8) << 11;
                t &= 7;
                if (t == 0) 
                {
                    while (*ip == 0) 
                    {
                        t += 255;
                        ip++;
                    }
                    t += 7 + *ip++;
                }
#if defined(__LITTLE_ENDIAN)
                m_pos -= (*(unsigned short *)ip) >> 2;
#else
		m_pos -= (ip[0] >> 2) + (ip[1] << 6);
#endif
                ip += 2;
                if (m_pos == op)
                    goto eof_found;
                m_pos -= 0x4000;
            } else 
            {
                m_pos = op - 1;
                m_pos -= t >> 2;
                m_pos -= *ip++ << 2;
                *op++ = *m_pos++; 
                *op++ = *m_pos;
                goto match_done;
            }

            if (t >= 6 && (op - m_pos) >= 4) 
            {
                *(unsigned *)op = *(unsigned *)m_pos;
                op += 4; m_pos += 4; t -= 2;
                do {
                    *(unsigned *)op = *(unsigned *)m_pos;
                    op += 4; m_pos += 4; t -= 4;
                } while(t >= 4);
                if (t > 0) do { *op++ = *m_pos++; } while(--t > 0);
            } else
            {
copy_match:
               *op++ = *m_pos++; *op++ = *m_pos++;
               do { *op++ = *m_pos++; } while(--t > 0);
            }

match_done:

            t = ip[-2] & 3;
            if (t == 0) break;

match_next:
            do { *op++ = *ip++; } while(--t > 0);
            t = *ip++;
        }
   }

eof_found:
   return (op - (BYTE*)out);
}



```

`source/Code/compress.hpp`:

```hpp

#ifndef _COMPRESS_HPP_
#define _COMPRESS_HPP_

long lzo_compress(void *in, long in_len, void *out);
long lzo_decompress(void *in, long in_len, void *out);

#endif

```

`source/Code/define.h`:

```h

#ifndef _DEFINE_H_
#define _DEFINE_H_

#ifdef _X64_
typedef unsigned long long ADDR;
typedef signed long long SADDR;
#define ADDR_SIZE 16
#define ADDR_BYTES 8
#define F0ADDR "%016I64"
#define FADDR "%I64"
//#define ADDRFMT "%016I64X"
//#define HEXADDRFMT "0x%016I64X"
#define HEXFMT "%I64X"
#define DECFMT "%I64d"
#define UNREADSTR "????????????????"
#define CIPSTR "RIP"
#define CSPSTR "RSP"
#define CBPSTR "RBP"
#define Eip Rip
#define STACKREG 4 //ESP_IDX
#define CODE_MODE CODE_MODE_64
//  "0%I64X"
//   "%I64X"
#else
typedef unsigned long ADDR;
typedef signed long SADDR;
#define ADDR_SIZE 8
#define ADDR_BYTES 4
#define F0ADDR "%08"
#define FADDR "%"
//#define ADDRFMT "%08X"
//#define HEXADDRFMT "0x%08X"
#define HEXFMT "%X"
#define DECFMT "%d"
#define UNREADSTR "????????"
#define CIPSTR "EIP"
#define CSPSTR "ESP"
#define CBPSTR "EBP"
#define STACKREG 5 //EBP_IDX
#define CODE_MODE CODE_MODE_32
#endif

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

//#ifdef WIN32
//#ifndef CODE_OS_NT_DRV
//#define CODE_OS_WIN

#define _WIN32_WINDOWS 0x0410
#define _WIN32_WINNT 0x0501

//#define WIN32_LEAN_AND_MEAN

//#include <winresrc.h>
//#include <winuser.h>

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>

//suxx
#if 1
#undef CreateFile
#undef DeleteFile
#undef FindFirstFile
#undef FindNextFile
#undef GetOpenFileName
#undef SendMessage
#undef PostMessage
#undef DispatchMessage
#undef GetCharWidth
#undef SetWindowText
#undef AppendMenu
#undef MoveMemory
#endif

//#endif
//#else   //WIN32
//#ifndef CODE_OS_CATOS
//#define CODE_OS_UNIX
//#endif
//#endif

#ifndef NULL
#define NULL			0
#endif

#ifndef TRUE
#define TRUE			1
#endif

#ifndef FALSE
#define FALSE			0
#endif

#define ERROR_USCODE		-1
#define PI			3.141592653549
#define MAX_FN_LEN		260
#define MAX_SHORT_NAME_LEN	32
#define MAX_NAME_LEN		64
#define MAX_LONG_NAME_LEN	128

#ifndef MAX_PATH
#define MAX_PATH		260
#endif

#define MAX_BYTE		0xFF
#define MAX_WORD		0xFFFF
#define MAX_DWORD		0xFFFFFFFF

#define IN
#define OUT
#define INOUT
#define OPTIONAL

#ifdef	CODE_OS_UNIX
#define PATH_SEPARATOR_CHAR	'/'
#define PATH_SEPARATOR_STR	"/"
#define PATH_SEPARATOR_WCHAR	L'/'
#define PATH_SEPARATOR_WSTR	L"/"
#else
#define PATH_SEPARATOR_CHAR	'\\'
#define PATH_SEPARATOR_STR	"\\"
#define PATH_SEPARATOR_WCHAR	L'\\'
#define PATH_SEPARATOR_WSTR	L"\\"
#endif

#define WSTR(s)			(L##s)

#ifdef _MSC_VER

typedef __int64			LONGLONG;
typedef unsigned __int64	ULONGLONG;
typedef unsigned __int64	NUM_PTR;

#ifndef _WCHAR_T_DEFINED
typedef unsigned short		wchar_t;
#define _WCHAR_T_DEFINED
#endif

#else //_MSC_VER

typedef long long		LONGLONG;
typedef unsigned long long	ULONGLONG;
typedef unsigned long long	NUM_PTR;

#endif //_MSC_VER

typedef ULONGLONG		QWORD;
typedef unsigned long		DWORD;
typedef unsigned short		WORD;
typedef unsigned char		BYTE;

typedef long			LONG;
typedef int			INT;
typedef short			SHORT;
typedef char			CHAR;
typedef unsigned long		ULONG;
typedef unsigned int		UINT;
typedef unsigned short		USHORT;
typedef unsigned char		UCHAR;
typedef int			BOOL;
typedef wchar_t			WCHAR;
typedef void*			HANDLE;

typedef DWORD			COLOR;
#define GetRColor(x)		(BYTE)((x)>>16)
#define GetGColor(x)		(BYTE)((x)>> 8)
#define GetBColor(x)		(BYTE)((x)>> 0)
#define RGBColor(r,g,b)		(((((DWORD)(r))<<16) | (((DWORD)(g))<<8) | ((DWORD)(b))<<0))

//
#define MAKE_WORD(HB,LB)		((WORD)(  (WORD)(LB) | ((WORD)(HB)<<8)   )) 
#define MAKE_DWORD(HW,LW)		((DWORD)(  (DWORD)(LW) | ((DWORD)(HW)<<16)  ))
#define MAKE_QDWORD(HD,LD)		((ULONGLONG)( (ULONGLONG)(LD) | ((ULONGLONG)(HD)<<32) ))

#define GET_BIT(Ptr,BitOff)		((RT_BYTE(Ptr,((BitOff)>>3)) >>((BitOff)&7)) & 1)
#define SET_BIT(Ptr,BitOff)		RT_BYTE(Ptr,((BitOff)>>3))|=1<<((BitOff)&7)
#define CLR_BIT(Ptr,BitOff)		RT_BYTE(Ptr,((BitOff)>>3))&=~(1<<((BitOff)&7))

#define PTR_TO_NUM(Ptr)			((unsigned int)(NUM_PTR)(Ptr))
#define NUM_TO_PTR(Num)			((void*)(NUM_PTR)(Num))

#define PTR_DELTA(__Ptr1,__Ptr2)	((UINT)(__Ptr2-__Ptr1))

#define LOW_BYTE(w)			((BYTE)(w))
#define HIGH_BYTE(w)			((BYTE)((WORD)(w)>>8))

#define LOW_WORD(l)			((WORD)(l))
#define HIGH_WORD(l)			((WORD)((DWORD)(l)>>16))

#define LOW_DWORD(l)			((DWORD)(l))
#define HIGH_DWORD(l)			((DWORD)((QWORD)(l)>>32))

#define RT_PVOID(ptr,off)		((void*)( (BYTE*)(ptr) + (off) ))
#define RT_LPVOID(ptr,off)		((void*)( (BYTE*)(ptr) + (off) ))
#define RT_PDWORD(ptr,off)		((DWORD*)( (BYTE*)(ptr) + (off) ))
#define RT_PWORD(ptr,off)		((WORD *)( (BYTE*)(ptr) + (off) ))
#define RT_PBYTE(ptr,off)		((BYTE *)( (BYTE*)(ptr) + (off) ))
#define RT_PCHAR(ptr,off)		((CHAR *)( (BYTE*)(ptr) + (off) ))

#define RT_BYTE(ptr,off)		(*( (BYTE*)(ptr) + (off) ))

#define _RT_PDWORD(ptr)			((DWORD*)(ptr) )
#define _RT_PWORD(ptr)			((WORD *)(ptr) )
#define _RT_PBYTE(ptr)			((BYTE *)(ptr) )
#define _RT_PCHAR(ptr)			((CHAR *)(ptr) )
#define _RT_PVOID(ptr)			((void *)(ptr) )

#define GET_CHAR(ptr,off)		(*(CHAR *)( (BYTE*)(ptr) + (off) ) )
#define _GET_CHAR(ptr)			(*(CHAR *)(ptr) )
#define _GET_CCHAR(ptr)			(*(const CHAR *)(ptr) )

#define PUT_CHAR(ptr,off,val)		do{(*(CHAR *)( (BYTE*)(ptr) + (off) ) ) = val;}while(0)
#define _PUT_CHAR(ptr,val)		do{(*(CHAR *)(ptr) ) = val;}while(0)

#define GET_BYTE(ptr,off)		(*(BYTE *)( (BYTE*)(ptr) + (off) ) )
#define _GET_BYTE(ptr)			(*(BYTE *)(ptr) )

#define PUT_BYTE(ptr,off,val)		do{(*(BYTE *)( (BYTE*)(ptr) + (off) ) ) = val;}while(0)
#define _PUT_BYTE(ptr,val)		do{(*(BYTE *)(ptr) ) = val;}while(0)

#ifdef CODE_BIG_ENDIAN

#define GET_WORD(ptr,off)		(*RT_PBYTE(ptr,off)+(*RT_PBYTE(ptr,(off)+1)<<8))
#define _GET_WORD(ptr)			(*_RT_PBYTE(ptr)+(*RT_PBYTE(ptr,1)<<8))

#define PUT_WORD(ptr,off,val)		do{PUT_BYTE(ptr,off,LOW_BYTE(val));PUT_BYTE(ptr,(off)+1,HIGH_BYTE(val));}while(0)
#define _PUT_WORD(ptr,val)		PUT_WORD(ptr,0,val)
#define GET_3BYTES(ptr,off)		(*RT_PBYTE(ptr,off)+(*RT_PBYTE(ptr,(off)+1)<<8)+(*RT_PBYTE(ptr,(off)+2)<<16))
#define _GET_3BYTES(ptr)		(*_RT_PBYTE(ptr)+(*RT_PBYTE(ptr,1)<<8)+(*RT_PBYTE(ptr,2)<<16))
#define PUT_3BYTES(ptr,off,val)		do{PUT_WORD(ptr,(off)+1,(WORD)((val)>>8));PUT_BYTE(ptr,off,LOW_BYTE(val));}while(0)
#define _PUT_3BYTES(ptr,val)		PUT_3BYTES(ptr,0,val)
#define GET_DWORD(ptr,off)		(*RT_PBYTE(ptr,off)+(*RT_PBYTE(ptr,(off)+1)<<8)+(*RT_PBYTE(ptr,(off)+2)<<16)+(*RT_PBYTE(ptr,(off)+3)<<24))
#define _GET_DWORD(ptr)			(*_RT_PBYTE(ptr)+(*RT_PBYTE(ptr,1)<<8)+(*RT_PBYTE(ptr,2)<<16)+(*RT_PBYTE(ptr,3)<<24))
#define PUT_DWORD(ptr,off,val)		do{PUT_WORD(ptr,off,LOW_WORD(val));PUT_WORD(ptr,(off)+2,HIGH_WORD(val));}while(0)
#define _PUT_DWORD(ptr,val)		PUT_DWORD(ptr,0,val)

#define BIG_ENDIAN_DWORD(x)		(x = _GET_DWORD(&(x)))
#define BIG_ENDIAN_WORD(x)		(x = _GET_WORD(&(x)))

#else//CODE_BIG_ENDIAN

#define GET_WORD(ptr,off)		(*(WORD*)( (BYTE*)(ptr) + (off) ) )
#define _GET_WORD(ptr)			(*(WORD*)( (BYTE*)(ptr)) )
#define PUT_WORD(ptr,off,val)		do{(*(WORD*)( (BYTE*)(ptr) + (off) ) )=val;}while(0)
#define _PUT_WORD(ptr,val)		do{(*(WORD*)( (BYTE*)(ptr)) )=val;}while(0)

#define GET_3BYTES(ptr,off)		MAKE_DWORD((BYTE)GET_WORD(ptr,(off)+2),GET_BYTE(ptr,off))
#define _GET_3BYTES(ptr)		MAKE_DWORD((BYTE)GET_WORD(ptr,2),_GET_BYTE(ptr))

#define PUT_3BYTES(ptr,off,val)		do{PUT_WORD(ptr,off,LOW_WORD(val));PUT_BYTE(ptr,(off)+2,(BYTE)HIGH_WORD(val));}while(0)
#define _PUT_3BYTES(ptr,val)		PUT_3BYTES(ptr,0,val)

#define GET_DWORD(ptr,off)		(*(DWORD*)( (BYTE*)(ptr) + (off) ) )
#define _GET_DWORD(ptr)			(*(DWORD*)( (BYTE*)(ptr) ) )

#define PUT_DWORD(ptr,off,val)		do{(*(DWORD*)( (BYTE*)(ptr) + (off) ) )=(DWORD)(val);}while(0)
#define _PUT_DWORD(ptr,val)		do{(*(DWORD*)( (BYTE*)(ptr) ) )=(DWORD)(val);}while(0)

#define BIG_ENDIAN_DWORD
#define BIG_ENDIAN_WORD

#endif//CODE_BIG_ENDIAN

//
#ifndef ABS
#define ABS(a)		((a)>=0?(a):-(a))
#endif

#ifndef MIN
#define MIN(a,b)	((a)>(b)?(b):(a))
#endif

#ifndef MAX
#define MAX(a,b)	((a)>(b)?(a):(b))
#endif

#ifndef CLAMP
//#define CLAMP(x,l,h)	MIN((h), MAX((l),(x)))
#define CLAMP(x,l,h)	(((x)<(l)) ? (l): (((h)<(x)) ? (h):(x)))
#endif

//
template<class T>
bool is_digit(T c);//		{ return c>='0'&&c<='9'; }
template<class T>
bool is_lower(T c);//		{ return c>='a'&&c<='z'; }
template<class T>
bool is_upper(T c);//		{ return c>='A'&&c<='Z'; }
template<class T>
bool is_letter(T c);//		{ return is_lower(c) || is_upper(c); }
template<class T>
bool is_hex_letter(T c);//	{ return (c>='a'&&c<='f') || (c>='A'&&c<='F'); }
template<class T>
bool is_hex_digit(T c);//	{ return is_digit(c) || is_hex_letter(c); }

template<>
inline bool is_digit<char>(char c)		{ return c>='0'&&c<='9'; }
template<>
inline bool is_lower<char>(char c)		{ return c>='a'&&c<='z'; }
template<>
inline bool is_upper<char>(char c)		{ return c>='A'&&c<='Z'; }
template<>
inline bool is_letter<char>(char c)		{ return is_lower(c) || is_upper(c); }
template<>
inline bool is_hex_letter<char>(char c)		{ return (c>='a'&&c<='f') || (c>='A'&&c<='F'); }
template<>
inline bool is_hex_digit<char>(char c)		{ return is_digit(c) || is_hex_letter(c); }
//
template<>
inline bool is_digit<WCHAR>(WCHAR c)		{ return c>=L'0'&&c<=L'9'; }
template<>
inline bool is_lower<WCHAR>(WCHAR c)		{ return c>=L'a'&&c<=L'z'; }
template<>
inline bool is_upper<WCHAR>(WCHAR c)		{ return c>=L'A'&&c<=L'Z'; }
template<>
inline bool is_letter<WCHAR>(WCHAR c)		{ return is_lower(c) || is_upper(c); }
template<>
inline bool is_hex_letter<WCHAR>(WCHAR c)	{ return (c>=L'a'&&c<=L'f') || (c>=L'A'&&c<=L'F'); }
template<>
inline bool is_hex_digit<WCHAR>(WCHAR c)	{ return is_digit(c) || is_hex_letter(c); }

#ifndef IS_DIGIT
#define IS_DIGIT(c)		((c)>='0'&&(c)<='9')
#endif

#ifndef IS_LOWER
#define IS_LOWER(c)		((c)>='a'&&(c)<='z')
#endif

#ifndef IS_UPPER
#define IS_UPPER(c)		((c)>='A'&&(c)<='Z')
#endif

#ifndef IS_LETTER
#define IS_LETTER(c)		(IS_LOWER(c) || IS_UPPER(c))
#endif

#ifndef IS_HEX_LETTER
#define IS_HEX_LETTER(c)	( ((c)>='a'&&(c)<='f') || ((c)>='A'&&(c)<='F') )
#endif

#ifndef IS_HEX_DIGIT
#define IS_HEX_DIGIT(c)		(IS_DIGIT(c) || IS_HEX_LETTER(c))
#endif

#ifndef SWAP
#define SWAP(a,b)	{a=a^b;b=a^b;a=a^b;}
#endif

#define PAGE_COUNT(__size,__page)	((__size)/(__page)+(((__size)%(__page))?1:0))
#define ALIGN_SIZE(__size,__page)	(PAGE_COUNT((__size),(__page))*(__page))
#define CENTER_ALGN(__size,__total)	(((__total)-(__size))/2)

#define SafeDelete(__Ptr)		if(__Ptr){delete __Ptr;__Ptr=NULL;}
#define SafeDeleteAry(__Ptr)		if(__Ptr){delete[] __Ptr;__Ptr=NULL;}
#define SafeRelease(__Ptr)		if(__Ptr){__Ptr->Release();__Ptr=NULL;}

template<class T>
void make_char_upper(T & __c);//	{ if(__c>='a' && __c <='z')__c +='A'-'a'; }
template<class T>
void make_char_lower(T & __c);//	{ if(__c>='a' && __c <='z')__c +='a'-'A'; }
template<class T>
T upper_char(T __c);//			{ return ((__c>='a' && __c<='z')?__c+'A'-'a':__c); }
template<class T>
T lower_char(T __c);//			{ return ((__c>='A' && __c<='Z')?__c+'a'-'A':__c); }

template<>
inline void make_char_upper<char>(char & __c)	{ if(__c>='a' && __c <='z')__c +='A'-'a'; }
template<>
inline void make_char_lower<char>(char & __c)	{ if(__c>='a' && __c <='z')__c +='a'-'A'; }
template<>
inline char upper_char<char>(char __c)		{ return ((__c>='a' && __c<='z')?__c+'A'-'a':__c); }
template<>
inline char lower_char<char>(char __c)		{ return ((__c>='A' && __c<='Z')?__c+'a'-'A':__c); }

template<>
inline void make_char_upper<WCHAR>(WCHAR & __c)	{ if(__c>=L'a' && __c <=L'z')__c +=L'A'-L'a'; }
template<>
inline void make_char_lower<WCHAR>(WCHAR & __c)	{ if(__c>=L'a' && __c <=L'z')__c +=L'a'-L'A'; }
template<>
inline WCHAR upper_char<WCHAR>(WCHAR __c)	{ return ((__c>=L'a' && __c<=L'z')?__c+L'A'-L'a':__c); }
template<>
inline WCHAR lower_char<WCHAR>(WCHAR __c)	{ return ((__c>=L'A' && __c<=L'Z')?__c+L'a'-L'A':__c); }

#define MAKE_CHAR_UPPER(__c)	if(__c>='a' && __c <='z')__c +='A'-'a'
#define MAKE_CHAR_LOWER(__c)	if(__c>='A' && __c <='Z')__c +='a'-'A'
#define UPPER_CHAR(__c)		((__c>='a' && __c<='z')?__c+'A'-'a':__c)
#define LOWER_CHAR(__c)		((__c>='A' && __c<='Z')?__c+'a'-'A':__c)

#define MAX_LIMIT(__L,__M)	if((__L)>(__M))__L=__M
#define MIN_LIMIT(__L,__M)	if((__L)<(__M))__L=__M

//#include <winnt.h>
//#define CONTAINING_RECORD(address, type, field) ((type *)( \
//                                                  (PCHAR)(address) - \
//                                                  (ULONG_PTR)(&((type *)0)->field)))

#define CONTAINING_RECORD_MY1(address, type, field) (\
    (type *)((char*)(address) -(LONG_PTR)(&((type *)0)->field)))

#define CONTAINING_RECORD_MY(address, type, field) (\
    (type *)( (char*)(address) -(LONG_PTR)(field) ) )

#define ALIGNUP(__M,__N)	(((__M)+(__N)-1)/(__N))
#define ALIGNDOWN(__M,__N)	((__M)/(__N))

#define ROUNDNEXT(__M,__N)		((__M)+(__N)-((__M)%(__N)))
#define ROUNDPREV(__M,__N)		((__M)      -((__M)%(__N)))

#define ROUNDREVERSE(__M,__N)		((__N)      -((__M)%(__N)))

#define lenof(x) sizeof(x)/sizeof(x[0])

struct FILESIG
{
	DWORD TimeStamp;
	DWORD CheckSum;

	FILESIG(DWORD TimeStamp, DWORD CheckSum):TimeStamp(TimeStamp), CheckSum(CheckSum) {}

	bool operator<(const FILESIG & other) const
	{
		if (TimeStamp < other.TimeStamp) return true;
		if (TimeStamp > other.TimeStamp) return false;
		if (CheckSum < other.CheckSum) return true;
		return false;
	}
};

#endif

```

`source/Code/fileio.cpp`:

```cpp

#include "fileio.hpp"
#include "tstrmem.hpp"
//++
//#include "osdefine.hpp"

//	CFileIO *gpFileIO = nullptr;

	CFileIO::CFileIO()
	{
		m_pszSepar = "\\";
	}

	bool CFileIO::OpenFile(const char *FileName, HANDLE *phFile, unsigned long Mode) { return false; }

	bool CFileIO::CreateFile(const char *FileName, HANDLE *phFile, unsigned long Mode) { return false; }

	bool CFileIO::CreateDir(const char *FileName) { return false; }

	bool CFileIO::CloseHandle(HANDLE hFile) { return false; }

	unsigned long CFileIO::ReadFile(HANDLE hFile, void *Buffer, unsigned long Size) { return 0; }

	unsigned long CFileIO::ReadFile(HANDLE hFile, void *Buffer, unsigned long Size, unsigned __int64 Offset) { return 0; }

	unsigned long CFileIO::WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size) { return 0; }

	unsigned long CFileIO::WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size, unsigned __int64 Offset) { return 0; }

	unsigned __int64 CFileIO::SetFilePointer(HANDLE hFile, __int64 Offset, unsigned long Pos) { return 0; }

	unsigned __int64 CFileIO::GetFileLength(HANDLE hFile) { return 0; }

	bool CFileIO::SetFileLength(HANDLE hFile, unsigned __int64 Length) { return false; }

	bool CFileIO::DeleteFile(const char *FileName) { return false; }

	bool CFileIO::RenameFile(const char *FileName, const char *NewFileName) { return false; }

	bool CFileIO::GetFileTime(const char *FileName, void *lpLastWriteTime, void *lpCreationTime, void *lpLastAccessTime) { return false; } //new+

	bool CFileIO::IsDir(const char *FileName) { return false; }

	bool CFileIO::DeleteDir(const char *FileName) { return false; }

	bool CFileIO::SetFileAttr(const char *FileName, unsigned long Attr) { return false; }

	unsigned long CFileIO::GetFileAttr(const char *FileName) { return -1; }

	bool CFileIO::FindFirstFile(const char *DirName, FILE_FIND_DATA *pFindData) { if (pFindData) pFindData->FileName[0] = 0; return false; }

	bool CFileIO::FindNextFile(FILE_FIND_DATA *pFindData) { if (pFindData) pFindData->FileName[0] = 0; return false; }

	bool CFileIO::FindClose(FILE_FIND_DATA *pFindData) { if (pFindData) pFindData->FileName[0] = 0; return false; }

	void CFileIO::FlushFile(HANDLE hFile) { } //new+

	bool CFileIO::WriteToFile(const char *FileName, const void *Buffer, unsigned long BufSize)
	{
		HANDLE hFile;
		if (!CreateFile(FileName, &hFile, 0x10001)) //FILE_MODE_RW|FILE_MODE_SHR
			return false;

		WriteFile(hFile, Buffer, BufSize, 0);
		CloseHandle(hFile);
		return true;
	}

	unsigned long CFileIO::ReadFromFile(const char *FileName, void *Buffer, unsigned long BufSize)
	{
		HANDLE hFile;
		if (!OpenFile(FileName, &hFile, 0x10000)) //FILE_MODE_RO|FILE_MODE_SHR
			return 0;

		unsigned long Size = BufSize;
		if (BufSize==0)
			Size = GetFileLength(hFile);
		unsigned long Result = ReadFile(hFile, Buffer, Size, 0);
		CloseHandle(hFile);
		return Result;
	}

	unsigned __int64 CFileIO::GetFileSize(const char *FileName)
	{
		unsigned int Len = TStrLen(FileName);
		if ((Len == 2 || Len == 3) && FileName[1] == ':')
		{
			ULARGE_INTEGER freeBytesAvailable;
			ULARGE_INTEGER totalNumberOfBytes;
			ULARGE_INTEGER totalNumberOfFreeBytes;

			freeBytesAvailable.QuadPart = 0;
			totalNumberOfBytes.QuadPart = 0;
			totalNumberOfFreeBytes.QuadPart = 0;

			GetDiskFreeSpaceExA(FileName, &freeBytesAvailable, &totalNumberOfBytes, &totalNumberOfFreeBytes);
			return totalNumberOfBytes.QuadPart;
		}

		HANDLE hFile;
		if (!OpenFile(FileName, &hFile, 0x10000)) //FILE_MODE_RO|FILE_MODE_SHR
			return -1;
			
		unsigned __int64 Length = GetFileLength(hFile);
		CloseHandle(hFile);
		return Length;
	}

	bool CFileIO::IsFileExist(const char *FileName)
	{
		HANDLE hFile;
		if (!OpenFile(FileName, &hFile, 0x10000)) //FILE_MODE_RO|FILE_MODE_SHR
			return false;

		return CloseHandle(hFile);
	}

	//bool CFileIO::XXXXX(const char *FileName) { return false; } // new+

	bool CFileIO::DeleteDirTree(const char *FileName)
	{
		FILE_FIND_DATA FileData;
		if (!FindFirstFile(FileName, &FileData))
		{
			FindClose(&FileData);
			return true;
		}
		
		do {
			if (FileData.FileAttribute & FILE_ATTRIBUTE_DIRECTORY)
			{
				if (!DeleteDirTree(FileName))
				{
					FindClose(&FileData);
					return false;
				}
			} else
			{
				DeleteFile(FileName);
			}
		} while (FindNextFile(&FileData));
		FindClose(&FileData);
		return true;
	}

	bool CFileIO::XDelete(const char *FileName)
	{
		if (!IsDir(FileName))
			return DeleteFile(FileName);
		return DeleteDirTree(FileName);
	}

	int CFileIO::XFind(const char *FullFileName, FUNC_XFIND_CB XFindCB, void *pData, bool bRoot, int *bReturnFlag)
	{
		int ret = 0;
		int FLAG;
		if (!bReturnFlag)
		{
			bReturnFlag = &FLAG;
			FLAG = 0;
		}
		char FileName[MAX_FN_LEN];
		char FilePath[MAX_FN_LEN];
		char *pStr = TGetFileName(FullFileName);
		if (TStrChr(pStr,'*') || TStrChr(pStr,'?'))
		{
			pStr = TGetFileName(FullFileName);
			TStrCpy(FileName, pStr);
			TGetFilePath(FullFileName, FilePath);
			FullFileName = FilePath;
		} else
		{
			FileName[0] = 0;
			if (!IsDir(FullFileName) && IsFileExist(FullFileName))
			{
				if (!XFindCB(this, FullFileName, GetFileSize(FullFileName), pData))
					++ret;
				return ret;
			}
		}
		
		FILE_FIND_DATA FindData;
		if (!FindFirstFile(FullFileName, &FindData))
		{
			FindClose(&FindData);
			return ret;
		}
		
		char CurFilePath[MAX_FN_LEN];
		do {
			if ((FindData.FileName[0] == '.' && FindData.FileName[1] == 0) ||
			    (FindData.FileName[0] == '.' && FindData.FileName[1] == '.' && FindData.FileName[2] == 0))
				continue; //skip "." ".."
			{
				int Len = TStrCpy(CurFilePath, FilePath);
				if (Len && CurFilePath[Len-1] != m_pszSepar[0])
					TStrCat(CurFilePath, m_pszSepar);
				TStrCat(CurFilePath, FindData.FileName);
				if (!(FindData.FileAttribute & FILE_ATTRIBUTE_DIRECTORY) ||
				      FindData.FileAttribute & FILE_ATTRIBUTE_DEVICE)
				{
					if ((!(FindData.FileAttribute & 0x80000000) && FileName[0] == 0) ||
						TIMultiMatchWithPattern(FileName, CurFilePath))
					{
						if (!XFindCB(this, CurFilePath, FindData.FileLength, pData))
						{
							++ret;
						} else
						{
							*bReturnFlag = 1;
							break;
						}
					}
				} else
				if (bRoot)
				{
					if (FileName[0])
					{
						TStrCat(CurFilePath, "\\");
						TStrCat(CurFilePath, FileName);
					}
					ret += XFind(CurFilePath, XFindCB, pData, bRoot, bReturnFlag);
					if (*bReturnFlag) break;
				}
			}
		} while (FindNextFile(&FindData));
		FindClose(&FindData);
		return ret;
	}

	bool CFileIO::XCopy(CFileIO *pSrcIO, CFileIO *pDstIO, const char *pSrcPath, const char *pDstPath, FUNC_XCOPY_CB XCOPY, void *pData)
	{
		if (!pSrcIO->IsDir(pSrcPath))
		{
			unsigned int Length = pSrcIO->GetFileSize(pSrcPath);
			if (XCOPY)
			{
				int res = XCOPY(pSrcIO, pDstIO, pSrcPath, pDstPath, Length, pData);
				if (res == 1)
					return true; //continue recursive copy
				if (res == 2)
					return false; //finish copy
			}
			unsigned char *pFileData = new unsigned char[Length];
			pSrcIO->ReadFromFile(pSrcPath, pFileData, 0);
			pDstIO->WriteToFile(pDstPath, pFileData, Length);
			delete []pFileData;
			return true;
		}
		if (!pDstIO->IsDir(pDstPath) && !pDstIO->CreateDir(pDstPath))
			return false;

		FILE_FIND_DATA FileData;
		if (!pSrcIO->FindFirstFile(pSrcPath, &FileData))
		{
			pSrcIO->FindClose(&FileData);
			return true;
		}
		do {
			if ((FileData.FileName[0] == '.' && FileData.FileName[1] == 0) ||
			    (FileData.FileName[0] == '.' && FileData.FileName[1] == '.' && FileData.FileName[2] == 0))
				continue;
			{
				char DstFullPath[MAX_PATH];
				char SrcFullPath[MAX_PATH];
				int Pos;

				Pos = TStrCpy(SrcFullPath, pSrcPath);
				if (Pos && SrcFullPath[Pos-1] != pSrcIO->m_pszSepar[0])
					TStrCat(SrcFullPath, pSrcIO->m_pszSepar);
				TStrCat(SrcFullPath, FileData.FileName);

				Pos = TStrCpy(DstFullPath, pDstPath);
				if (Pos && DstFullPath[Pos-1] != pDstIO->m_pszSepar[0])
					TStrCat(DstFullPath, pDstIO->m_pszSepar);
				TStrCat(DstFullPath, FileData.FileName);

				if (!XCopy(pSrcIO, pDstIO, SrcFullPath, DstFullPath, XCOPY, pData))
					break;
			}
		} while (pSrcIO->FindNextFile(&FileData));
		pSrcIO->FindClose(&FileData);
		return true;
	}

```

`source/Code/fileio.hpp`:

```hpp

#ifndef _FILEIO_HPP_
#define _FILEIO_HPP_

#include "define.h"
//#include "osdefine.hpp"
//#include <windows.h>

struct CFileIO;

#define XCOPY_FOUND 0
#define XCOPY_NEXT  1
#define XCOPY_END 2

typedef int (*FUNC_XCOPY_CB)(CFileIO *pSrcIO, CFileIO *pDstIO, const char *pSrcPath, const char *pDstPath, unsigned long Length, void *pData);

#define XFIND_END 0
#define XFIND_NEXT 1

typedef int (*FUNC_XFIND_CB)(CFileIO *This, const char *FullFileName, int FileLength, void *pData);

struct FILE_FIND_DATA
{
	char FileName[MAX_FN_LEN];
	unsigned long FileAttribute; //??? as win
	HANDLE hFindFile;
	void *FindDataBuffer;
	unsigned __int64 FileLength;
};

#define FILE_MODE_RO    0x00000
#define FILE_MODE_RW    0x00001

#define FILE_MODE_SHR	0x10000
#define FILE_MODE_SHW	0x20000

struct CFileIO
{
	const char *m_pszSepar;

	CFileIO();
//	{
//		m_pszSepar = "\\";
//	}


	virtual bool OpenFile(const char *FileName, HANDLE *phFile, unsigned long Mode); //{ return false; }
	virtual bool CreateFile(const char *FileName, HANDLE *phFile, unsigned long Mode); //{ return false; }
	virtual bool CreateDir(const char *FileName); //{ return false; }
	virtual bool CloseHandle(HANDLE hFile); //{ return false; }
	virtual unsigned long ReadFile(HANDLE hFile, void *Buffer, unsigned long Size); //{ return 0; }
	virtual unsigned long ReadFile(HANDLE hFile, void *Buffer, unsigned long Size, unsigned __int64 Offset); //{ return 0; }
	virtual unsigned long WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size); //{ return 0; }
	virtual unsigned long WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size, unsigned __int64 Offset); //{ return 0; }
	virtual unsigned __int64 SetFilePointer(HANDLE hFile, __int64 Offset, unsigned long Pos); //{ return 0; }
	virtual unsigned __int64 GetFileLength(HANDLE hFile); //{ return 0; }
	virtual bool SetFileLength(HANDLE hFile, unsigned __int64 Length); //{ return false; }
	virtual bool DeleteFile(const char *FileName); //{ return false; }
	virtual bool RenameFile(const char *FileName, const char *NewFileName); //{ return false; }
	virtual bool GetFileTime(const char *FileName, void *pWriteTime, void *pCreationTime, void *pAccessTime); //new+ { return false; }
	virtual bool IsDir(const char *FileName); //{ return false; }
	virtual bool DeleteDir(const char *FileName); //{ return false; }
	virtual bool SetFileAttr(const char *FileName, unsigned long Attr); //{ return false; }
	virtual unsigned long GetFileAttr(const char *FileName); //{ return -1; }

	virtual bool FindFirstFile(const char *DirName, FILE_FIND_DATA *pFindData); //{ *pFindData = 0; return false; }
	virtual bool FindNextFile(FILE_FIND_DATA *pFindData); //{ *pFindData = 0; return false; }
	virtual bool FindClose(FILE_FIND_DATA *pFindData); //{ *pFindData = 0; return false; }

	virtual void FlushFile(HANDLE hFile); //new+ {}

	virtual bool WriteToFile(const char *FileName, const void *Buffer, unsigned long BufSize); 
	virtual unsigned long ReadFromFile(const char *FileName, void *Buffer, unsigned long BufSize);

	virtual unsigned __int64 GetFileSize(const char *FileName);

	virtual bool IsFileExist(const char *FileName);

	//virtual bool XXXXX(const char *FileName) { return false; } // new+

	virtual bool DeleteDirTree(const char *FileName);
	virtual bool XDelete(const char *FileName);
	virtual int XFind(const char *FullFileName, FUNC_XFIND_CB XFindCB, void *pData, bool bRoot, int *ReturnFlag);
	
	static bool XCopy(CFileIO *pSrcFileIO, CFileIO *pDstFileIO, const char *pSrcPath, const char *pDstPath, FUNC_XCOPY_CB XCopyCB, void *pXCopyData);
};

	extern CFileIO *gpFileIO;

#endif

```

`source/Code/fileiont.cpp`:

```cpp

#include "define.h"
//#include "../Code/osdefine.hpp"

#include "tstrmem.hpp"
#include "fileiont.hpp"

//#include <windows.h>
// //#include <stdio.h>
// //#include <winbase.h>
//#include <windowsx.h>
//#include <winnt.h>

	CLocalFileIO gFileIO;
	CFileIO *gpFileIO = (CFileIO*)&gFileIO;

	WCHAR CLocalFileIO::m_CurDirName[MAX_PATH]; // = "";


	void CLocalFileIO::SetCurDir(const WCHAR *DirName)
	{
		int Length = TStrCpy(m_CurDirName, DirName);
		MAX_LIMIT(Length, MAX_PATH-1);
		if (Length)
		{
			if (m_CurDirName[Length - 1] != '\\' &&
			    m_CurDirName[Length - 1] != '/' )
			{
				m_CurDirName[Length] = '\\';
				m_CurDirName[Length + 1] = 0;
			}
		}
	}

	bool CLocalFileIO::OpenFile(const char *FileName, HANDLE *phFile, unsigned long Mode)
	{
		DWORD OpenMode = GENERIC_READ; //0x80000000;
		if (Mode & 1)
			OpenMode = GENERIC_READ | GENERIC_WRITE; //0xC0000000;
		DWORD ShareMode = 0;
		if (Mode & 0x10000)
			ShareMode = FILE_SHARE_READ; //1;
		if (Mode & 0x20000)
			ShareMode |= FILE_SHARE_WRITE; //2;
		*phFile = ::CreateFileA(FileName, OpenMode, ShareMode, 0, OPEN_EXISTING, 0, 0); //3
		return *phFile != INVALID_HANDLE_VALUE;
	}

	bool CLocalFileIO::CreateFile(const char *FileName, HANDLE *phFile, unsigned long Mode)
	{
		DWORD CreatedMode = CREATE_NEW; //1;
		if (Mode & 1)
			CreatedMode = CREATE_ALWAYS; //2;
		DWORD ShareMode = 0;
		if (Mode & 0x10000)
			ShareMode = FILE_SHARE_READ; //1;
		if (Mode & 0x20000)
			ShareMode |= FILE_SHARE_WRITE; //2;
		*phFile = ::CreateFileA(FileName, GENERIC_READ | GENERIC_WRITE, ShareMode, 0, CreatedMode, 0, 0); //0xC0000000
		return *phFile != INVALID_HANDLE_VALUE;
	}

	bool CLocalFileIO::CreateDir(const char *FileName) //
	{
		return ::CreateDirectoryA(FileName, 0) != 0;
	}

	bool CLocalFileIO::CloseHandle(HANDLE hFile)
	{
		return ::CloseHandle(hFile) != 0;
	}

	void CLocalFileIO::FlushFile(HANDLE hFile) //new+
	{
		::FlushFileBuffers(hFile);
	}

	unsigned long CLocalFileIO::ReadFile(HANDLE hFile, void *Buffer, unsigned long Size, unsigned __int64 Offset)
	{
		unsigned long RDSize = 0;

		if (this->SetFilePointer(hFile, Offset, 0) == -1)
			return 0;
		::ReadFile(hFile, Buffer, Size, (LPDWORD)&RDSize, 0);
		return RDSize;
	}

	unsigned long CLocalFileIO::WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size, unsigned __int64 Offset)
	{
		unsigned long WRSize = 0;
		if (this->SetFilePointer(hFile, Offset, 0) == -1)
			return 0;
		::WriteFile(hFile, Buffer, Size, (LPDWORD)&WRSize, 0);
		return WRSize;
	}

	unsigned long CLocalFileIO::ReadFile(HANDLE hFile, void *Buffer, unsigned long Size)
	{
		unsigned long RDSize = 0;
		::ReadFile(hFile, Buffer, Size, (LPDWORD)&RDSize, 0);
		return RDSize;
	}

	unsigned long CLocalFileIO::WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size)
	{
		unsigned long WRSize = 0;
		::WriteFile(hFile, Buffer, Size, (LPDWORD)&WRSize, 0);
		return WRSize;
	}

	unsigned __int64 CLocalFileIO::SetFilePointer(HANDLE hFile, __int64 Offset, unsigned long Pos)
	{
		unsigned long HiOffset = Offset>>32;
		int result = ::SetFilePointer(hFile, Offset, (PLONG)&HiOffset, Pos);
		if (result == -1)
			return -1;
		return ((unsigned __int64)HiOffset)<<32|result;
	}

	unsigned __int64 CLocalFileIO::GetFileLength(HANDLE hFile)
	{
		unsigned __int64 Size = ::GetFileSize(hFile, 0);
		if (Size == -1LL)
		{
			::GetLastError(); //TODO
			Size = 0;
		}
		return Size;
	}

	bool CLocalFileIO::SetFileLength(HANDLE hFile, unsigned __int64 Length)
	{
		unsigned long HiLength = Length>>32;
		if (::SetFilePointer(hFile, Length, (PLONG)&HiLength, 0) == -1)
			return false;

		return ::SetEndOfFile(hFile) != 0;
	}

	bool CLocalFileIO::DeleteFile(const char *FileName)
	{
		return ::DeleteFileA(FileName) != 0;
	}

	bool CLocalFileIO::RenameFile(const char *FileName, const char *NewFileName)
	{
		return ::MoveFileA(FileName, NewFileName) != 0;
	}

	bool CLocalFileIO::GetFileTime(const char *FileName, void *pWriteTime, void *pCreationTime, void *pAccessTime) //new+
	{
		HANDLE hFile = ::CreateFileA(FileName, 0x80000000, 3, 0, 3, 0, 0);
		if (hFile == INVALID_HANDLE_VALUE)
			return false;
		bool Result = ::GetFileTime(hFile, (LPFILETIME)pCreationTime, (LPFILETIME)pAccessTime, (LPFILETIME)pWriteTime) == 1;
		this->CloseHandle(hFile);
		return Result;
	}
	bool CLocalFileIO::IsDir(const char *FileName)
	{
		DWORD Attributes = ::GetFileAttributesA(FileName);
		if (Attributes == -1)
			return ::GetDriveTypeA(FileName) != 1;
		return (Attributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
	}

	bool CLocalFileIO::DeleteDir(const char *FileName)
	{
		return ::RemoveDirectoryA(FileName) != 0;
	}
	
	bool CLocalFileIO::FindFirstFile(const char *DirName, FILE_FIND_DATA *pFindData)
	{
		LPWIN32_FIND_DATA pWin32FindData = new WIN32_FIND_DATA; //sizeof 0x140
		pFindData->FindDataBuffer = pWin32FindData;
		char szPath[268];
		TStrCpy(szPath, DirName);
		if (!TStrChr(DirName, '*') && !TStrChr(DirName, '?'))
		{
			TStrCat(szPath, m_pszSepar);
			TStrCat(szPath, "*");
		}
		pFindData->hFindFile = ::FindFirstFileA(szPath, pWin32FindData);
		if (pFindData->hFindFile == INVALID_HANDLE_VALUE)
		{
			delete pWin32FindData;
			pFindData->FindDataBuffer = 0;
			return false;
		}
		
		TStrCpy(pFindData->FileName, pWin32FindData->cFileName);
		pFindData->FileAttribute = 0;
		if (pWin32FindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
			pFindData->FileAttribute |= FILE_ATTRIBUTE_READONLY;
		if (pWin32FindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
			pFindData->FileAttribute |= FILE_ATTRIBUTE_HIDDEN;
		if (pWin32FindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
			pFindData->FileAttribute |= FILE_ATTRIBUTE_SYSTEM;
		if (pWin32FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			pFindData->FileAttribute |= FILE_ATTRIBUTE_DIRECTORY;
		pFindData->FileLength = pWin32FindData->nFileSizeLow;
		
		return true;
	}

	bool CLocalFileIO::FindNextFile(FILE_FIND_DATA *pFindData)
	{
		LPWIN32_FIND_DATA pWin32FindData = (LPWIN32_FIND_DATAA)pFindData->FindDataBuffer;

		bool Result = ::FindNextFileA(pFindData->hFindFile, pWin32FindData) != 0;
		strcpy_s(pFindData->FileName, MAX_FN_LEN, pWin32FindData->cFileName); //??? TODO
		//pFindData->FileAttribute = pWin32FindData->dwFileAttributes;
		pFindData->FileAttribute = 0;

		if (pWin32FindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
			pFindData->FileAttribute |= FILE_ATTRIBUTE_READONLY;
		if (pWin32FindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
			pFindData->FileAttribute |= FILE_ATTRIBUTE_HIDDEN;
		if (pWin32FindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
			pFindData->FileAttribute |= FILE_ATTRIBUTE_SYSTEM;
		if (pWin32FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			pFindData->FileAttribute |= FILE_ATTRIBUTE_DIRECTORY;
		pFindData->FileLength = pWin32FindData->nFileSizeLow;
		return Result;
	}

	bool CLocalFileIO::FindClose(FILE_FIND_DATA *pFindData)
	{
		LPWIN32_FIND_DATA pWin32FindData = (LPWIN32_FIND_DATAA)pFindData->FindDataBuffer;
		if (pWin32FindData)
			delete pWin32FindData;
		return ::FindClose(pFindData->hFindFile) != 0;
	}


```

`source/Code/fileiont.hpp`:

```hpp

#ifndef _LOCALFILEIO_HPP_
#define _LOCALFILEIO_HPP_

#include "define.h"
#include "fileio.hpp"

struct CLocalFileIO : public CFileIO
{
	static WCHAR m_CurDirName[MAX_PATH];

	void SetCurDir(const WCHAR *DirName);

	virtual bool OpenFile(const char *FileName, HANDLE *phFile, unsigned long Mode) override;
	virtual bool CreateFile(const char *FileName, HANDLE *phFile, unsigned long Mode) override;
	virtual bool CreateDir(const char *FileName) override;
	virtual bool CloseHandle(HANDLE hFile) override;

	virtual void FlushFile(HANDLE hFile) override;

	virtual unsigned long ReadFile(HANDLE hFile, void *Buffer, unsigned long Size) override;
	virtual unsigned long ReadFile(HANDLE hFile, void *Buffer, unsigned long Size, unsigned __int64 Offset) override;

	virtual unsigned long WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size) override;
	virtual unsigned long WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size, unsigned __int64 Offset) override;

	virtual unsigned __int64 SetFilePointer(HANDLE hFile, __int64 Offset, unsigned long Pos) override;

	virtual unsigned __int64 GetFileLength(HANDLE hFile) override;
	virtual bool SetFileLength(HANDLE hFile, unsigned __int64 Length) override;

	virtual bool DeleteFile(const char *FileName) override;
	virtual bool RenameFile(const char *FileName, const char *NewFileName) override;

	virtual bool GetFileTime(const char *FileName, void *lpLastWriteTime, void *lpCreationTime, void *lpLastAccessTime) override; //new+

	virtual bool IsDir(const char *FileName) override;
	virtual bool DeleteDir(const char *FileName) override;
	
	virtual bool FindFirstFile(const char *DirName, FILE_FIND_DATA *pFindData) override;
	virtual bool FindNextFile(FILE_FIND_DATA *pFindData) override;
	virtual bool FindClose(FILE_FIND_DATA *pFindData) override;
};

#endif

```

`source/Code/handle.cpp`:

```cpp

#include <string.h>
#include "handle.hpp"

	CHandle::CHandle()
	{
		memset(m_RegisterType, 0, sizeof(m_RegisterType));
		memset(m_HandleInfoDir, 0, sizeof(m_HandleInfoDir));
	}

	ULONG_PTR CHandle::CreateHandle(void *HandleInfo, unsigned long Type)
	{
		for (unsigned long nDir = 0; nDir < 64; ++nDir)
		{
			if (!m_HandleInfoDir[nDir])
			{
				m_HandleInfoDir[nDir] = new HANDLE_INFO[1024];
				memset(m_HandleInfoDir[nDir], 0, sizeof(HANDLE_INFO)*1024);
			}

			for (unsigned long nSlot = 0; nSlot < 1024; ++nSlot)
			{
				if (!m_HandleInfoDir[nDir][nSlot].Attribute)
				{
					HANDLE_INFO *pFreeSlot = &m_HandleInfoDir[nDir][nSlot];
					pFreeSlot->HandleInfo = HandleInfo;
					pFreeSlot->Attribute = (Type << 16) | 1;
					return (Type << 16) | (nDir << 10) | nSlot;
				}
			}
		}
		return 0;
	}

	bool CHandle::CloseHandle(ULONG_PTR Handle)
	{
		unsigned long Type = GetHandleType(Handle);
		unsigned long nSlot = GetHandleSlot(Handle);
		unsigned long nDir = GetHandleDir(Handle);

		if (!m_HandleInfoDir[nDir])
			return false;

		if (!(m_HandleInfoDir[nDir][nSlot].Attribute & 1))
			return false;

		if ((unsigned long)m_HandleInfoDir[nDir][nSlot].Attribute >> 16 != Type)
			return false;

		if (Type >= 256 || !m_RegisterType[Type].bExist)
			return false;

		HANDLE_INFO *pHandleInfo = &m_HandleInfoDir[nDir][nSlot];

		if (m_RegisterType[Type].RelHIFunc)
			m_RegisterType[Type].RelHIFunc(m_RegisterType[Type].Param, pHandleInfo->HandleInfo);
		else delete pHandleInfo->HandleInfo;

		pHandleInfo->HandleInfo = 0;
		pHandleInfo->Attribute = 0;

		for (unsigned long n = 0; n < 1024; ++n)
		{
			if (m_HandleInfoDir[nDir][n].Attribute & 1)
				return true;
		}

		delete []m_HandleInfoDir[nDir];
		m_HandleInfoDir[nDir] = NULL;
		return true;
	}

	void CHandle::CloseAllHandle()
	{
		for (unsigned long nDir = 0; nDir < 64; ++nDir)
		{
			HANDLE_INFO *pInfo = m_HandleInfoDir[nDir];
			if (pInfo)
			{
				for (unsigned long nSlot = 0; (signed int)nSlot < 1024; ++nSlot) //???
				{
					unsigned long Type = (unsigned long)pInfo[nSlot].Attribute >> 16;
					if (Type < 256 && m_RegisterType[Type].bExist && pInfo[nSlot].Attribute & 1)
					{
						if (m_RegisterType[Type].RelHIFunc)
							m_RegisterType[Type].RelHIFunc(m_RegisterType[Type].Param, pInfo[nSlot].HandleInfo);
						else	delete pInfo[nSlot].HandleInfo;
					}
				}
				delete []pInfo;
				m_HandleInfoDir[nDir] = NULL;
			}
		}
	}

	void CHandle::Reset()
	{
		CloseAllHandle();
		memset(m_RegisterType, 0, sizeof(m_RegisterType));
		memset(m_HandleInfoDir, 0, sizeof(m_HandleInfoDir));
	}


	bool CHandle::IsHandleExist(ULONG_PTR Handle) const
	{
		unsigned long Type = GetHandleType(Handle);
		unsigned long nSlot = GetHandleSlot(Handle);
		unsigned long nDir = GetHandleDir(Handle);

		return m_HandleInfoDir[nDir]
			&& m_HandleInfoDir[nDir][nSlot].Attribute & 1
			&& (unsigned long)m_HandleInfoDir[nDir][nSlot].Attribute >> 16 == Type;
	}

	void *CHandle::GetHandleInfo(ULONG_PTR Handle) const
	{
		unsigned long Type = GetHandleType(Handle);
		unsigned long nSlot = GetHandleSlot(Handle);
		unsigned long nDir = GetHandleDir(Handle);

		if (Type >= 256 || !m_RegisterType[Type].bExist)
			return nullptr;

		if (IsHandleExist(Handle))
			return m_HandleInfoDir[nDir][nSlot].HandleInfo;
		return nullptr;
	}

	unsigned long CHandle::GetHandleType(ULONG_PTR Handle) const
	{
		return Handle >> 16;
	}

	unsigned long CHandle::GetHandleSlot(ULONG_PTR Handle) const
	{
		return Handle & 1023;
	}

	unsigned long CHandle::GetHandleDir(ULONG_PTR Handle) const
	{
		return (unsigned short)Handle >> 10;
	}

	ULONG_PTR CHandle::GetFirstHandle(unsigned long Type) const
	{
		if (Type >= 256 || !m_RegisterType[Type].bExist)
			return 0;

		for (unsigned long nDir = 0; nDir < 64; ++nDir)
		{
			if (m_HandleInfoDir[nDir])
			{
				for (unsigned long nSlot = 0; nSlot < 1024; ++nSlot)
				{
					if ( (unsigned long)m_HandleInfoDir[nDir][nSlot].Attribute >> 16 == Type
						&& m_HandleInfoDir[0][0].Attribute & 1)
					{
						return (Type << 16) | (nDir << 10) | nSlot;
					}
				}
			}
		}
		return 0;
	}

	ULONG_PTR CHandle::GetNextHandle(ULONG_PTR Handle) const
	{
		unsigned long Type = GetHandleType(Handle);

		if (Type >= 256 || !m_RegisterType[Type].bExist)
			return 0;

		unsigned long nFirstSlot = GetHandleSlot(Handle) + 1;

		for (unsigned long nDir = GetHandleDir(Handle); nDir < 64; ++nDir)
		{
			if (m_HandleInfoDir[nDir])
			{
				for (unsigned long nSlot = nFirstSlot; nSlot < 1024; ++nSlot)
				{
					if ( (unsigned long)m_HandleInfoDir[nDir][nSlot].Attribute >> 16 == Type
						&& m_HandleInfoDir[GetHandleDir(Handle)][nFirstSlot].Attribute & 1)
					{
						return (Type << 16) | (nDir << 10) | nSlot;
					}
				}
			}
			nFirstSlot = 0;
		}
		return 0;
	}

	unsigned long CHandle::Register(REL_HI_FUNC RelHIFunc, void *Param)
	{
		for (unsigned long Type = 1; Type < 256; ++Type)
			if (!m_RegisterType[Type].bExist)
			{
				m_RegisterType[Type].RelHIFunc = RelHIFunc;
				m_RegisterType[Type].Param = Param;
				m_RegisterType[Type].bExist = true;
				return Type;
			}
		return 0;
	}

	bool CHandle::Unregister(unsigned long Type)
	{
		if (Type >= 256 || !m_RegisterType[Type].bExist)
			return false;

		m_RegisterType[Type].RelHIFunc = 0;
		m_RegisterType[Type].Param = nullptr;
		m_RegisterType[Type].bExist = false;
		return true;
	}


```

`source/Code/handle.hpp`:

```hpp

#ifndef _HANDLE_HPP_
#define _HANDLE_HPP_

#include "define.h"

//for CPFSFileIO

//	(Type << 16) | (nDir << 10) | nSlot;

typedef bool (*REL_HI_FUNC)(void *, void *);

struct HANDLE_INFO
{
	void *HandleInfo;
	unsigned long Attribute;
};

struct HANDLE_TYPE_INFO
{
	REL_HI_FUNC RelHIFunc;
	void *Param;
	bool bExist;
};

struct CHandle
{
	HANDLE_INFO *m_HandleInfoDir[64];
	HANDLE_TYPE_INFO m_RegisterType[256];

	CHandle();

	ULONG_PTR CreateHandle(void *HandleInfo, unsigned long Type);
	bool CloseHandle(ULONG_PTR Handle);
	void CloseAllHandle();
	void Reset();
	ULONG_PTR GetFirstHandle(unsigned long Type) const;
	ULONG_PTR GetNextHandle(ULONG_PTR Handle) const;
	bool IsHandleExist(ULONG_PTR Handle) const;
	void *GetHandleInfo(ULONG_PTR Handle) const;
	unsigned long GetHandleType(ULONG_PTR Handle) const;
	unsigned long GetHandleSlot(ULONG_PTR Handle) const;
	unsigned long GetHandleDir(ULONG_PTR Handle) const;

	unsigned long Register(REL_HI_FUNC RelHIFunc, void *Param);
	bool Unregister(unsigned long Type);
};

#endif

```

`source/Code/imagefile.cpp`:

```cpp

#include <string.h>

#include "imagefile.hpp"
#include "compress.hpp"

	CImageFile::CImageFile()
		: m_hHandle(0)
		, m_EntryPoint(0)
		, m_FileType(1)
		, m_FileObjType(0)
		, m_PageAttribute(0)
		, m_FileSize(0)
		, m_BaseOffset(0)
		, m_FilePointer(0)
		, m_Buffer(nullptr)
		, m_pFileIO(gpFileIO)
	{
		m_ReadMemory = CImageFile::ReadMemory;
		m_RMObj = this;
		m_WriteMemory = CImageFile::WriteMemory;
		m_WRObj = this;
	}

	void CImageFile::InitParam()
	{
		m_PageAttribute = 0x16; //??? PAGE_MAPPED|PAGE_WRITE|PAGE_READ
		m_EntryPoint = 0;
		m_BaseOffset = 0;
		m_ImageBase = 0;
		m_ImageSize = m_FileSize;
		m_ImageHighBase = m_ImageBase + m_ImageSize;
		m_FileType = 1;
		m_FilePointer = 0;
	}

	bool CImageFile::Create(const char *FileName, unsigned long Size)
	{
		if (!m_pFileIO) m_pFileIO = gpFileIO;

		if (!m_pFileIO->CreateFile(FileName, &m_hHandle, 0x10001)) //FILE_MODE_RW|FILE_MODE_SHR
			return false;

		m_FileName = FileName;

		m_FileObjType = FILE_OBJ_FILE;
		SetFileLength(Size);
		GetFileLength();
		InitParam();
		return true;
	}

	bool CImageFile::Create(unsigned long Size, unsigned char *Buffer, bool bCompress)
	{
		if (Buffer && !bCompress)
		{
			m_Buffer = Buffer;
			m_FileObjType |= FILE_OBJ_BUFFER;
		} else
		{
			m_Buffer = new unsigned char[Size];
			m_FileObjType |= FILE_OBJ_COMPRESS;
		}

		if (bCompress)
		{
			if (!Buffer || !Size)
				return false;

			if (lzo_decompress(Buffer, Size, m_Buffer) != Size)
			{
				delete []m_Buffer;
				m_FileObjType &= ~FILE_OBJ_COMPRESS;
				return false;
			}
		}

		m_FileSize = Size;
		m_FilePointer = 0;
		InitParam();
		return true;
	}

	bool CImageFile::Open(const char *FileName, HANDLE HandleOpen)
	{
		if (!m_pFileIO) m_pFileIO = gpFileIO;

		if (FileName)
		{
			m_FileObjType = 0;
			if (!m_pFileIO->OpenFile(FileName, &m_hHandle, 0x10000)) //FILE_MODE_RO|FILE_MODE_SHR
				return false;

			m_FileName = FileName;
		} else
		{
			m_FileObjType |= FILE_OBJ_FILE;

			if (m_FileObjType & 0x6000000) //??? FILE_OBJ_BUFFER | FILE_OBJ_MEMORY
				return true;

			m_hHandle = HandleOpen;
			m_FileName.Empty();
			m_FileObjType |= FILE_OBJ_HANDLE;
		}

		m_FilePointer = 0;
		m_FileSize = m_pFileIO->GetFileLength(m_hHandle);
		InitParam();
		return true;
	}

	void CImageFile::Close()
	{
		m_FileName.Empty();

		if ((m_FileObjType & FILE_OBJ_COMPRESS) && m_Buffer)
		{
			delete []m_Buffer;
			m_Buffer = 0;
		}

		if ( !(m_FileObjType & FILE_OBJ_HANDLE) )
		{
			m_pFileIO->CloseHandle(m_hHandle);
			m_hHandle = 0;
		}

		m_ImageBase = 0;
		m_ImageHighBase = 0;
		m_ImageSize = 0;
		m_FilePointer = 0;

		if (m_FileObjType & FILE_OBJ_DESTROY)
		{
			delete this;
		} else
		{
			m_FileObjType = 0;
		}
	}

	void CImageFile::ChangeFileIO(CFileIO *pFileIO)
	{
		m_pFileIO = pFileIO;
	}

	bool CImageFile::ReadFile(unsigned long Pos, void *Buffer, unsigned long Size)
	{
		if (m_Buffer)
		{
			if (Pos < m_FileSize)
			{
				unsigned long RDSize_ = MIN(m_FileSize - Pos, Size);
				memcpy(Buffer, &m_Buffer[m_BaseOffset + Pos], RDSize_);
				m_FilePointer = RDSize_ + Pos;
				return true;
			}
			return false;
		}
		
		if (!m_FileSize)
			GetFileLength(); //???

		if (Pos > m_FileSize)
			return false;
		
		unsigned long RDSize = m_pFileIO->ReadFile(m_hHandle, Buffer, Size, m_BaseOffset + Pos);
		m_FilePointer = RDSize + m_BaseOffset + Pos;
		return RDSize == Size;
	}

	bool CImageFile::WriteFile(unsigned long Pos, const void *Buffer, unsigned long Size)
	{
		if (m_Buffer)
		{
			if (Pos < m_FileSize)
			{
				unsigned long WRSize_ = MIN(m_FileSize - Pos, Size);
				memcpy(&m_Buffer[m_BaseOffset + Pos], Buffer, WRSize_);
				m_FilePointer = WRSize_ + Pos;
				return true;
			}
			return false;
		}

		if ( !(m_FileObjType & FILE_OBJ_FILE) )
		{
			m_pFileIO->CloseHandle(m_hHandle);

			if (!m_pFileIO->OpenFile(m_FileName, &m_hHandle, 0x10001)) //FILE_MODE_RW|FILE_MODE_SHR
				return false;

			m_FileObjType |= FILE_OBJ_FILE;
		}

		unsigned long WRSize = m_pFileIO->WriteFile(m_hHandle, Buffer, Size, m_BaseOffset + Pos);
		m_FilePointer = WRSize + m_BaseOffset + Pos;
		MIN_LIMIT(m_FileSize, m_FilePointer);
		return WRSize == Size;
	}

	bool CImageFile::ReadFile(void *Buffer, unsigned long Size)
	{
		if (m_Buffer)
		{
			if (m_FilePointer < m_FileSize)
			{
				unsigned long RDSize_ = MIN(m_FileSize - m_FilePointer, Size);
				memcpy(Buffer, &m_Buffer[m_FilePointer], RDSize_);
				m_FilePointer += RDSize_;
				return true;
			}
			return false;
		}

		unsigned long RDSize = m_pFileIO->ReadFile(m_hHandle, Buffer, Size, m_FilePointer);
		m_FilePointer += RDSize;
		return RDSize == Size;
	}

	bool CImageFile::WriteFile(const void *Buffer, unsigned long Size)
	{
		if (m_Buffer)
		{
			if (m_FilePointer < m_FileSize)
			{
				unsigned long WRSize_ = MIN(m_FileSize - m_FilePointer, Size);
				memcpy(&m_Buffer[m_FilePointer], Buffer, WRSize_);
				m_FilePointer += WRSize_;
				return true;
			}
			return false;
		}
		
		unsigned long WRSize = m_pFileIO->WriteFile(m_hHandle, Buffer, Size, m_FilePointer);
		m_FilePointer += WRSize;
		MIN_LIMIT(m_FileSize, m_FilePointer);
		return WRSize == Size;
	}

	bool CImageFile::DeleteMemory(unsigned long Pos, unsigned long Size)
	{
		if (Size + Pos > m_FileSize)
			return false;

		unsigned long DeleteSize = m_FileSize - Pos - Size;

		if (DeleteSize > 0x100000)
		{
			char *pBuffer = new char[0x100000];
			if (!pBuffer)
				return false;

			unsigned long BlockSize = 0;
			unsigned long BlockCount = PAGE_COUNT(DeleteSize,0x100000);

			for (int i = 1; i < BlockCount; ++i)
			{
				ReadFile(Pos+Size+BlockSize, pBuffer, 0x100000);
				WriteFile(Pos+BlockSize, pBuffer, 0x100000);
				BlockSize += 0x100000;
			}

			ReadFile(Pos+Size+BlockSize, pBuffer, DeleteSize % 0x100000);
			WriteFile(Pos+BlockSize, pBuffer, DeleteSize % 0x100000);
			SetFileLength(Pos+DeleteSize);
			delete []pBuffer;
		} else
		{
			char *pBuffer = new char[DeleteSize];
			if (!pBuffer)
				return false;

			ReadFile(Pos+Size, pBuffer, DeleteSize);
			WriteFile(Pos, pBuffer, DeleteSize);
			SetFileLength(Pos+DeleteSize);
			delete []pBuffer;
		}
		return true;
	}

	bool CImageFile::DeleteFile()
	{
		return m_pFileIO->DeleteFile(m_FileName);
	}

	unsigned long CImageFile::ReadString(ULONG_PTR Address, char *Buffer, unsigned long MaxLen, unsigned long AlignLen)
	{
		if (!MaxLen)
			return 0;

		unsigned int Offset = 0;
		while (Offset < MaxLen)
		{
			unsigned int Len = MIN(MaxLen - Offset, AlignLen);

			ReadMemory(Address + 1 * Offset, &Buffer[Offset], 1 * Len);

			for (unsigned int n = 0; n < Len; ++n)
			{
				if (!Buffer[n + Offset])
					return n + Offset;
			}
			Offset += Len;
		}

		Buffer[MaxLen - 1] = 0;
		return MaxLen - 1;
	}

	unsigned long CImageFile::ReadString(ULONG_PTR Address, unsigned short *Buffer, unsigned long MaxLen, unsigned long AlignLen)
	{
		if (!MaxLen)
			return 0;

		unsigned int Offset = 0;
		while (Offset < MaxLen)
		{
			unsigned int Len = MIN(MaxLen - Offset, AlignLen);

			ReadMemory(Address + 2 * Offset, &Buffer[Offset], 2 * Len);

			for (unsigned int n = 0; n < Len; ++n)
			{
				if (!Buffer[n + Offset])
					return n + Offset;
			}
			Offset += Len;
		}

		Buffer[MaxLen - 1] = 0;
		return MaxLen - 1;
	}

	unsigned long CImageFile::ReadString(ULONG_PTR Address, unsigned long *Buffer, unsigned long MaxLen, unsigned long AlignLen)
	{
		if (!MaxLen)
			return 0;

		unsigned int Offset = 0;
		while (Offset < MaxLen)
		{
			unsigned int Len = MIN(MaxLen - Offset, AlignLen);

			ReadMemory(Address + 4 * Offset, &Buffer[Offset], 4 * Len);

			for (unsigned int n = 0; n < Len; ++n)
			{
				if (!Buffer[n + Offset])
					return n + Offset;
			}
			Offset += Len;
		}

		Buffer[MaxLen - 1] = 0;
		return MaxLen - 1;
	}

	unsigned long CImageFile::ReadString(ULONG_PTR Address, unsigned long long *Buffer, unsigned long MaxLen, unsigned long AlignLen)
	{
		if (!MaxLen)
			return 0;

		unsigned int Offset = 0;
		while (Offset < MaxLen)
		{
			unsigned int Len = MIN(MaxLen - Offset, AlignLen);

			ReadMemory(Address + 8 * Offset, &Buffer[Offset], 8 * Len);

			for (unsigned int n = 0; n < Len; ++n)
			{
				if (!Buffer[n + Offset])
					return n + Offset;
			}
			Offset += Len;
		}

		Buffer[MaxLen - 1] = 0;
		return MaxLen - 1;
	}

	unsigned long CImageFile::GetFileLength()
	{
		if (!m_Buffer)
			m_FileSize = m_pFileIO->GetFileLength(m_hHandle);
		return m_FileSize;
	}

	bool CImageFile::SetFileLength(unsigned long Length)
	{
		if (m_Buffer)
			return false;

		if ( !(m_FileObjType & FILE_OBJ_FILE) )
		{
			m_pFileIO->CloseHandle(m_hHandle);

			if (!m_pFileIO->OpenFile(m_FileName, &m_hHandle, 0x10001)) //FILE_MODE_RW|FILE_MODE_SHR
				return false;

			m_FileObjType |= FILE_OBJ_FILE;
		}

		if (!m_pFileIO->SetFileLength(m_hHandle, Length))
			return false;

		m_FileSize = m_pFileIO->GetFileLength(m_hHandle);
		return true;
	}

	unsigned long CImageFile::ReadImageMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
	//	if (Address < m_ImageBase || Address >= m_ImageHighBase)
		if (OutOfBaseRange(Address))
			return 0;

		//if (Address < m_ImageHighBase && Size + Address > m_ImageHighBase)
		//	Size = m_ImageHighBase - Address;
		MAX_LIMIT(Size, m_ImageHighBase - Address);

		ReadFile(Address - m_ImageBase, Buffer, Size);
		return Size;
	}

	unsigned long CImageFile::WriteImageMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size)
	{
	//	if (Address < m_ImageBase || Address >= m_ImageHighBase)
		if (OutOfBaseRange(Address))
			return 0;

		//if (Address < m_ImageHighBase && Size + Address > m_ImageHighBase)
		//	Size = m_ImageHighBase - Address;
		MAX_LIMIT(Size, m_ImageHighBase - Address);

		WriteFile(Address - m_ImageBase, Buffer, Size);
		return Size;
	}

	bool CImageFile::LoadPage(ULONG_PTR Address, void *Buffer)
	{
		memset(Buffer, 0, PAGE_SIZE);
		ReadMemory(Address - m_ImageBase, Buffer, PAGE_SIZE);
		return true;

	}

	bool CImageFile::SavePage(ULONG_PTR Address, const void *Buffer)
	{
		return WriteFile(Address - m_ImageBase, Buffer, PAGE_SIZE);
	}

	unsigned long CImageFile::GetPageAttribute(ULONG_PTR Address)
	{
		return m_PageAttribute;
	}

	void CImageFile::RelocLoad(ULONG_PTR BaseAddr)
	{
		ULONG_PTR Delta = BaseAddr - m_ImageBase;
		m_ImageBase = BaseAddr;
		m_ImageHighBase += Delta;
		m_EntryPoint += Delta;
	}

	void CImageFile::SetRelocRead(unsigned long (*RMFunc)(ULONG_PTR, void*, unsigned long, void*), void *RMObj)
	{
		m_ReadMemory = RMFunc;
		m_RMObj = RMObj;
	}

	void CImageFile::SetRelocWrite(unsigned long (*WRFunc)(ULONG_PTR, const void*, unsigned long, void*), void *WRObj)
	{
		m_WriteMemory = WRFunc;
		m_WRObj = WRObj;
	}

	unsigned long CImageFile::ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		if (m_ReadMemory) return m_ReadMemory(Address, Buffer, Size, m_RMObj);
		return 0;
	}

	unsigned long CImageFile::WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size)
	{
		if (m_WriteMemory) return m_WriteMemory(Address, Buffer, Size, m_WRObj);
		return 0;
	}

	unsigned long CImageFile::ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size, void *RMObj)
	{
		CImageFile *pImageFile = (CImageFile *)RMObj;
		return pImageFile->ReadImageMemory(Address, Buffer, Size);
	}

	unsigned long CImageFile::WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size, void *WRObj)
	{
		CImageFile *pImageFile = (CImageFile *)WRObj;
		return pImageFile->WriteImageMemory(Address, Buffer, Size);
	}

	bool CImageFile::OutOfBaseRange(ULONG_PTR BaseAddr)
	{
		//return ???.!InBaseRange(BaseAddr);
		return BaseAddr < m_ImageBase || BaseAddr >= m_ImageHighBase;
	}

//
	unsigned long CImageFileStream::Write(const void *Buffer, unsigned long Size)
	{
		return CImageFile::WriteFile(Buffer, Size) != 0 ? Size:0;
	}

	unsigned long CImageFileStream::Read(void *Buffer, unsigned long Size)
	{
		return CImageFile::ReadFile(Buffer, Size) != 0 ? Size:0;
	}	


```

`source/Code/imagefile.hpp`:

```hpp

#ifndef _IMAGEFILE_HPP_
#define _IMAGEFILE_HPP_

#include "define.h"
#include "pageimage.hpp"
#include "fileio.hpp"
#include "alt/altfile.hpp"

#define PAGE_SIZE	4096

#define FILE_OBJ_DESTROY  0x00010000
#define FILE_OBJ_HANDLE   0x00020000
#define FILE_OBJ_FILE     0x00040000

#define FILE_OBJ_COMPRESS 0x01000000
#define FILE_OBJ_BUFFER   0x02000000
#define FILE_OBJ_MEMORY   0x04000000

//0x06000000

struct CImageFile : public CPageImage
{
	CImageFile();

	virtual bool LoadPage(ULONG_PTR Address, void *Buffer) override;
	virtual bool SavePage(ULONG_PTR Address, const void *Buffer) override;
	virtual unsigned long GetPageAttribute(ULONG_PTR Address) override;
	virtual bool Create(unsigned long Size, unsigned char *Buffer, bool bCompress);
	virtual bool Create(const char *FileName, unsigned long Size);
	virtual bool Open(const char *FileName, HANDLE HandleOpen);
	virtual void Close();
	virtual unsigned long ReadImageMemory(ULONG_PTR Address, void *Buffer, unsigned long Size);
	virtual unsigned long WriteImageMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size);
	virtual void RelocLoad(ULONG_PTR BaseAddr);
	virtual void SetRelocRead(unsigned long (*RMFunc)(ULONG_PTR, void*, unsigned long, void*), void *RMObj);
	virtual void SetRelocWrite(unsigned long (*WRFunc)(ULONG_PTR, const void*, unsigned long, void*), void *WRObj);
	virtual bool OutOfBaseRange(ULONG_PTR BaseAddr);
	virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size);
	virtual unsigned long WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size);
	virtual void XXX() {} //????

	static unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size, void *RMObj);
	static unsigned long WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size, void *WRObj);

	void InitParam();
	void ChangeFileIO(CFileIO *pFileIO);
	bool ReadFile(void *Buffer, unsigned long Size);
	bool ReadFile(unsigned long Pos, void *Buffer, unsigned long Size);
	bool WriteFile(const void *Buffer, unsigned long Size);
	bool WriteFile(unsigned long Pos, const void *Buffer, unsigned long Size);

	unsigned long ReadString(ULONG_PTR Address, unsigned long long *Buffer, unsigned long MaxLen, unsigned long AlignLen);
	unsigned long ReadString(ULONG_PTR Address, unsigned long *Buffer, unsigned long MaxLen, unsigned long AlignLen);
	unsigned long ReadString(ULONG_PTR Address, unsigned short *Buffer, unsigned long MaxLen, unsigned long AlignLen);
	unsigned long ReadString(ULONG_PTR Address, char *Buffer, unsigned long MaxLen, unsigned long AlignLen);

	unsigned long GetFileLength();
	bool SetFileLength(unsigned long Length);

	bool DeleteMemory(unsigned long Pos, unsigned long Size);
	bool DeleteFile();
#if 0
	CImageFile(const CImageFile & other) { operator=(other); }
	CImageFile & operator=(const CImageFile & other)
	{
		CPageImage::operator=((CPageImage&)other);
		m_hHandle = other.m_hHandle;
		m_ReadMemory = other.m_ReadMemory;
		m_WriteMemory = other.m_WriteMemory;
		m_RMObj = this;
		m_WRObj = this;
		m_EntryPoint = other.m_EntryPoint;
		m_FileType = other.m_FileType;
		m_FileObjType = other.m_FileObjType;
		m_PageAttribute = other.m_PageAttribute;
		m_FileSize = other.m_FileSize;
		m_BaseOffset = other.m_BaseOffset;
		m_FilePointer = other.m_FilePointer;
		m_Buffer = other.m_Buffer;
		m_pFileIO =  other.m_pFileIO;
	};
#endif
	HANDLE m_hHandle;
	unsigned long (*m_ReadMemory)(ULONG_PTR, void*, unsigned long, void*);
	unsigned long (*m_WriteMemory)(ULONG_PTR, const void*, unsigned long, void*);
	void *m_RMObj;
	void *m_WRObj;
	ULONG_PTR m_EntryPoint;
	unsigned long m_FileType;
	unsigned long m_FileObjType;
	unsigned long m_PageAttribute;
	unsigned long m_FileSize;
	unsigned long m_BaseOffset;
	unsigned long m_FilePointer;
	unsigned char *m_Buffer;
	CFileIO *m_pFileIO;
};

struct CImageFileStream : public ALT::ALTFileStream, CImageFile
{
	virtual unsigned long Write(const void *Buffer, unsigned long Size) override;
	virtual unsigned long Read(void *Buffer, unsigned long Size) override;
};

#endif


```

`source/Code/modf.cpp`:

```cpp

	extern "C" double __cdecl modf(double x, double *iptr)
	{
		union {double f; unsigned long long i;} u = {x};
		unsigned long long mask;
		int e = (int)(u.i>>52 & 0x7ff) - 0x3ff;

		/* no fractional part */
		if (e >= 52) {
			*iptr = x;
			if (e == 0x400 && u.i<<12 != 0) /* nan */
				return x;
			u.i &= 1ULL<<63;
			return u.f;
		}

		/* no integral part*/
		if (e < 0) {
			u.i &= 1ULL<<63;
			*iptr = u.f;
			return x;
		}

		mask = -1ULL>>12>>e;
		if ((u.i & mask) == 0) {
			*iptr = x;
			u.i &= 1ULL<<63;
			return u.f;
		}
		u.i &= ~mask;
		*iptr = u.f;
		return x - u.f;
	}

```

`source/Code/options.cpp`:

```cpp

#include "options.hpp"

	void COptions::Parse(SETOPTION *Opt)
	{
		while (Opt->Key)
		{
			switch (Opt->Type)
			{
			case SETOPTION_STR: SetStr(Opt->Key, Opt->Value, Opt->Size); break;
			case SETOPTION_INT: SetInt(Opt->Key, Opt->Value); break;
			case SETOPTION_UINT: SetUInt(Opt->Key, Opt->Value); break;
			case SETOPTION_VOID: SetVoid(Opt->Key, Opt->Value); break;
			default:;
			}
			++Opt;
		}
	}
	bool COptions::SetStr(const WCHAR *Key, void *Str, int Size)
	{
		map<TWideNoCaseString, SETOPTION>::IT it = insert(_Tmap_pair<TWideNoCaseString, SETOPTION>(Key, SETOPTION()));
		if (it == end()) return false;
		it->second.Type = 1;
		it->second.Value = (void*)Str;
		it->second.Size = Size;
		return true;
	}
	bool COptions::SetInt(const WCHAR *Key, void *Int)
	{
		map<TWideNoCaseString, SETOPTION>::IT it = insert(_Tmap_pair<TWideNoCaseString, SETOPTION>(Key, SETOPTION()));
		if (it == end()) return false;
		it->second.Type = 2;
		it->second.Value = (void*)Int;
		it->second.Size = 4;
		return true;
	}
	bool COptions::SetUInt(const WCHAR *Key, void *UInt)
	{
		map<TWideNoCaseString, SETOPTION>::IT it = insert(_Tmap_pair<TWideNoCaseString, SETOPTION>(Key, SETOPTION()));
		if (it == end()) return false;
		it->second.Type = 3;
		it->second.Value = (void*)UInt;
		it->second.Size = 4;
		return true;
	}
	bool COptions::SetVoid(const WCHAR *Key, void *Void)
	{
		map<TWideNoCaseString, SETOPTION>::IT it = insert(_Tmap_pair<TWideNoCaseString, SETOPTION>(Key, SETOPTION()));
		if (it == end()) return false;
		it->second.Type = 4;
		it->second.Value = (void*)Void;
		it->second.Size = 4;
		return true;
	}

	bool COptions::Remove(const WCHAR *Key)
	{
		return erase(Key) != 0;
	}

	int COptions::Get(const WCHAR *Key, void *Value, int *pSize)
	{
		map<TWideNoCaseString, SETOPTION>::IT It = find(Key);
		if (It == end()) return 0;
		//*((unsigned long*)Value) = (unsigned long)It->second.Value;
		memcpy(Value, &(It->second.Value), sizeof(ULONG_PTR));
		if (pSize) *pSize = It->second.Size;
		return It->second.Type;
	}
	WCHAR * COptions::GetStr(const WCHAR *Key, int *pSize)
	{
		map<TWideNoCaseString, SETOPTION>::IT It = find(Key);
		if (It == end()) return nullptr;
		if (It->second.Type != 1) return nullptr;
		if (pSize) *pSize = It->second.Size;
		return (WCHAR*)It->second.Value;
	}
	int COptions::GetInt(const WCHAR *Key)
	{
		map<TWideNoCaseString, SETOPTION>::IT It = find(Key);
		if (It == end()) return 0;
		if (It->second.Type != 2) return 0;
		return *(int*)It->second.Value;
	}
	unsigned int COptions::GetUInt(const WCHAR *Key)
	{
		map<TWideNoCaseString, SETOPTION>::IT It = find(Key);
		if (It == end()) return 0;
		if (It->second.Type != 3) return 0;
		return *(unsigned int*)It->second.Value;
	}
	void *COptions::GetVoid(const WCHAR *Key)
	{
		map<TWideNoCaseString, SETOPTION>::IT It = find(Key);
		if (It == end()) return nullptr;
		if (It->second.Type != 4) return nullptr;
		return It->second.Value;
	}
	
	bool COptions::SetStr(const char *Key, void *Str, int Size)
	{
		WCHAR wszKey[130];
		AnsiToUnicode(Key, wszKey, lenof(wszKey)-2);
		return SetStr(wszKey, Str, Size);
	}
	bool COptions::SetInt(const char *Key, void *Int)
	{
		WCHAR wszKey[130];
		AnsiToUnicode(Key, wszKey, lenof(wszKey)-2);
		return SetInt(wszKey, Int);
	}
	bool COptions::SetUInt(const char *Key, void *UInt)
	{
		WCHAR wszKey[130];
		AnsiToUnicode(Key, wszKey, lenof(wszKey)-2);
		return SetUInt(wszKey, UInt);
	}
	bool COptions::SetVoid(const char *Key, void *Void)
	{
		WCHAR wszKey[130];
		AnsiToUnicode(Key, wszKey, lenof(wszKey)-2);
		return SetVoid(wszKey, Void);
	}
	bool COptions::Remove(const char *Key)
	{
		WCHAR wszKey[130];
		AnsiToUnicode(Key, wszKey, lenof(wszKey)-2);
		return Remove(wszKey);
	}

```

`source/Code/options.hpp`:

```hpp

#ifndef _SETOPTIONS_HPP_
#define _SETOPTIONS_HPP_

#include "define.h"
#include "alt/altmap.hpp"
#include "tstrmem.hpp"

enum
{
	SETOPTION_INVALID = 0,
	SETOPTION_STR = 1,
	SETOPTION_INT = 2,
	SETOPTION_UINT = 3,
	SETOPTION_VOID = 4,
};

struct SETOPTION
{
	const WCHAR *Key;
	int Type;
	void *Value;
	int Size;
};

struct COptions : public map<TWideNoCaseString, SETOPTION>
{
//	map<TWideNoCaseString, OPTION> m_Options;

	void Parse(SETOPTION *Opt);
	bool SetStr(const WCHAR *Key, void *Str, int Size);
	bool SetInt(const WCHAR *Key, void *Int);
	bool SetUInt(const WCHAR *Key, void *UInt);
	bool SetVoid(const WCHAR *Key, void *Void);

	bool Remove(const WCHAR *Key);

	int Get(const WCHAR *Key, void *Value, int *pSize);
	WCHAR * GetStr(const WCHAR *Key, int *pSize);
	int GetInt(const WCHAR *Key);
	unsigned int GetUInt(const WCHAR *Key);
	void *GetVoid(const WCHAR *Key);
	
	bool SetStr(const char *Key, void *Str, int Size);
	bool SetInt(const char *Key, void *Int);
	bool SetUInt(const char *Key, void *UInt);
	bool SetVoid(const char *Key, void *Void);
	bool Remove(const char *Key);
};

#endif

```

`source/Code/osdefine.hpp`:

```hpp

#ifndef _OSDEFINE_HPP_
#define _OSDEFINE_HPP_

#define _WIN32_WINDOWS 0x0410
#define _WIN32_WINNT 0x0500

//#define WIN32_LEAN_AND_MEAN

//#include <winresrc.h>
//#include <winuser.h>

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>

//suxx
#if 1
#undef CreateFile
#undef DeleteFile
#undef FindFirstFile
#undef FindNextFile
#undef GetOpenFileName
#undef SendMessage
#undef PostMessage
#undef DispatchMessage
#undef GetCharWidth
#undef SetWindowText
#undef AppendMenu
#undef MoveMemory
#endif

#endif
```

`source/Code/pageimage.hpp`:

```hpp

#ifndef _PAGEIMAGE_HPP_
#define _PAGEIMAGE_HPP_

#include "define.h"
#include "tstrmem.hpp"

struct CMemoryImage
{
	ULONG_PTR ImageBase = 0;
	ULONG_PTR ImageHighBase = 0;

	CMemoryImage(ULONG_PTR Address) : ImageBase(Address), ImageHighBase(Address) {}
	CMemoryImage(ULONG_PTR Address, ULONG_PTR HighAddress) : ImageBase(Address), ImageHighBase(HighAddress) {}

	bool InBaseRange(ULONG_PTR Address)
	{
	        return Address >= ImageBase && Address < ImageHighBase;
	}
};

inline bool operator<(const CMemoryImage & l, const CMemoryImage & r)
{
	return (r.ImageBase == r.ImageHighBase) ?
		(l.ImageHighBase < r.ImageBase) : (l.ImageBase < r.ImageBase);
}

#define PAGE_READ 2
#define PAGE_WRITE 4

//0x0001 PAGE_ACCESS PAGE_MODIFY
//0x0002 PAGE_READ
//0x0004 PAGE_WRITE
//0x0008
//0x0010 PAGE_MAPPED
//0x0020 PAGE_DATA PAGE_ALLOCED
//0x0040
//0x0080
//0x1000
//0x2000
//0x4000 PAGE_DIRTY
//0x8000

struct CPageImage
{
	virtual bool LoadPage(ULONG_PTR Address, void *Buffer) = 0;
	virtual bool SavePage(ULONG_PTR Address, const void *Buffer) { return false; }
	virtual unsigned long GetPageAttribute(ULONG_PTR Address) { return 6; } //PAGE_WRITE PAGE_READ

	TAnsiString m_FileName;

	unsigned long m_ImageSize = 0;
	ULONG_PTR m_ImageBase = 0;
	ULONG_PTR m_ImageHighBase = 0;
};

#endif
```

`source/Code/pagemem.cpp`:

```cpp

#include "pagemem.hpp"

	CPageMemory::CPageMemory()
		: m_PageUsedCount(0)
		, m_PageCount(0)
		, m_PhysMemory(nullptr)
		, m_PageExistMap(nullptr)
		, m_WriteAccessPageCount(0)
		, m_FreePhysIndex(0)
		, m_Style(0)
	{
		memset(m_PageDir, 0, sizeof(m_PageDir));
	}

	CPageMemory::~CPageMemory()
	{
	}

	bool CPageMemory::Init(int PageCount, unsigned long Style)
	{
		m_Style = Style;

		if (m_Style & 2)
		{
			memset(m_PageDir, 0, sizeof(m_PageDir));
			memset(&m_PageDataCache1, 0, sizeof(MEMORY_PAGE_CACHE));
			memset(&m_PageDataCache2, 0, sizeof(MEMORY_PAGE_CACHE));
			m_PageCount = PageCount;
			m_PageUsedCount = 0;
			m_FreePhysIndex = 0;
			m_WriteAccessPageCount = 0;
			return true;
		}

		m_PhysMemory = new unsigned char[PageCount*PAGE_SIZE]; //MEMORY_PAGE new[PageCount] //???
		if (!m_PhysMemory)
		{
			return false;
		}

		m_PageExistMap = new unsigned char[PageCount];
		if (!m_PageExistMap)
		{
			SafeDeleteAry(m_PhysMemory);
			return false;
		}
		
		memset(m_PageExistMap, 0, PageCount);
	//???
		memset(m_PageDir, 0, sizeof(m_PageDir));
		memset(&m_PageDataCache1, 0, sizeof(MEMORY_PAGE_CACHE));
		memset(&m_PageDataCache2, 0, sizeof(MEMORY_PAGE_CACHE));
		m_PageCount = PageCount;
		m_PageUsedCount = 0;
		m_FreePhysIndex = 0;
		m_WriteAccessPageCount = 0;
		return true;
	}

	void CPageMemory::Release()
	{
		if (m_Style & 2)
		{
			for (int n = 0; n < 1024; ++n)
			{
				if (m_PageDir[n])
				{
					for (int m = 0; m < 1024; ++m)
					{
						SafeDeleteAry(m_PageDir[n][m].PhysAddr);
					}
				}
			}
		} else
		{
			SafeDeleteAry(m_PhysMemory);
			SafeDeleteAry(m_PageExistMap);
		}

		for (int i = 0; i < 1024; ++i)
		{
			SafeDeleteAry(m_PageDir[i]);
		}
		m_ImageList.clear();
	}

	void CPageMemory::RefreshCache(MEMORY_PAGE *pPage)
	{
		if (pPage == m_PageDataCache1.MemoryPage)
			memset(&m_PageDataCache1, 0, sizeof(MEMORY_PAGE_CACHE));
		if (pPage == m_PageDataCache2.MemoryPage)
			memset(&m_PageDataCache2, 0, sizeof(MEMORY_PAGE_CACHE));
	}

	bool CPageMemory::ExchangePage()
	{
		if (ReleaseClearPage())
			return true;

		if (m_Style & 1)
			return FlushAllPage() != 0;

		return false;
	}

	int CPageMemory::FlushAllPage()
	{
		int count = 0;
		for (unsigned long n = 0; n < 1024; ++n)
		{
			if (m_PageDir[n])
			{
				for (unsigned long m = 0; m < 1024; ++m)
				{
					MEMORY_PAGE *pPage = &m_PageDir[n][m];
					if (pPage->Attribute & 1 && !(pPage->Attribute & 0x8000) && pPage->PhysAddr)
					{
						unsigned long Address = (m << 12) + (n << 22);
						if (SavePage(Address, pPage))
							++count;
					}
				}
			}
		}
		return count;
	}


	CPageImage *CPageMemory::GetImage(const char *FileName)
	{
		for (map<CMemoryImage, CPageImage*>::IT it = m_ImageList.begin();
			it != m_ImageList.end(); ++it)
		{
			if (TCmpModuleName(it->second->m_FileName.operator const char *(), FileName))
				return it->second;
		}
		return NULL;
	}

	CPageImage *CPageMemory::GetImage(unsigned long Address)
	{
		map<CMemoryImage, CPageImage*>::IT it = m_ImageList.find(CMemoryImage(Address));
		if (it == m_ImageList.end())
			return NULL;

		return it->second;
	}


	bool CPageMemory::MapImage(CPageImage *pImageFile)
	{
		map<CMemoryImage, CPageImage*>::IT it = m_ImageList.find(CMemoryImage(pImageFile->m_ImageBase));
		if (it != m_ImageList.end())
			return false;

		unsigned long Address = pImageFile->m_ImageBase;
		unsigned long Size = pImageFile->m_ImageSize;
		unsigned long PageIndex = (Address >> 12) & 1023;
		unsigned long DirIndex = Address >> 22;
		unsigned long PageCount = PAGE_COUNT(Size,PAGE_SIZE);
		while (DirIndex < 1024 && PageCount)
		{
			if (!m_PageDir[DirIndex])
			{
				m_PageDir[DirIndex] = new MEMORY_PAGE[1024];
				memset(m_PageDir[DirIndex], 0, sizeof(MEMORY_PAGE)*1024);
			}

			while (PageIndex < 1024 && PageCount)
			{
				MEMORY_PAGE *pPage = &m_PageDir[DirIndex][PageIndex];
				if (pPage->Attribute)
					return false;

				pPage->Attribute = pImageFile->GetPageAttribute(Address) | 0x10;
				pPage->PhysAddr = NULL;
				pPage->AccessReadCount = 0;
				pPage->AccessWriteCount = 0;
				--PageCount;
				Address += PAGE_SIZE;
				++PageIndex;
			}
			++DirIndex;
			PageIndex = 0;
		}
		m_ImageList.insert(_Tmap_pair<CMemoryImage, CPageImage*>(CMemoryImage(pImageFile->m_ImageBase, pImageFile->m_ImageHighBase-1), pImageFile));
		return true;
	}

	bool CPageMemory::UnmapImage(CPageImage *pImageFile)
	{
		map<CMemoryImage, CPageImage*>::IT it = m_ImageList.find(CMemoryImage(pImageFile->m_ImageBase));
		if (it == m_ImageList.end())
			return false;

		unsigned long Address = pImageFile->m_ImageBase;
		unsigned long PageIndex = (Address >> 12) & 1023;
		unsigned long DirIndex = Address >> 22;
		unsigned long PageCount = pImageFile->m_ImageSize >> 12; //PAGE_COUNT(pImageFile->m_ImageSize,PAGE_SIZE) //???
		while (DirIndex < 1024 && PageCount)
		{
			if (!m_PageDir[DirIndex])
				return false;

			while (PageIndex < 1024 && PageCount)
			{
				MEMORY_PAGE *pPage = &m_PageDir[DirIndex][PageIndex];
				DeletePage(pPage);
				memset(pPage, 0, sizeof(MEMORY_PAGE));
				--PageCount;
				Address += PAGE_SIZE;
						//WTF ++PageIndex; ???
			}
			++DirIndex;
			PageIndex = 0;
		}
		m_ImageList.erase(it);
		return true;
	}

	bool CPageMemory::AllocatePage(unsigned long Address, unsigned long Attr, void *Buffer, unsigned long Size)
	{
		if (m_PageUsedCount >= m_PageCount && !ExchangePage())
			return false;

		unsigned long DirIndex = Address >> 22;
		unsigned long PageIndex = (Address >> 12) & 1023;

		if (!m_PageDir[DirIndex])
		{
			m_PageDir[DirIndex] = new MEMORY_PAGE[1024];
			memset(m_PageDir[DirIndex], 0, sizeof(MEMORY_PAGE)*1024);
		}

		MEMORY_PAGE *pPage = &m_PageDir[DirIndex][PageIndex];

		if (pPage->Attribute)
			return false;

		pPage->Attribute = Attr;
		if ( !(pPage->Attribute & 0x4000) )
		{
			if (!NewPage(pPage))
			{
				pPage->Attribute = 0;
				return false;
			}
			pPage->Attribute |= 1;
		}
		pPage->AccessReadCount = 0;
		pPage->AccessWriteCount = 0;
		MAX_LIMIT(Size, PAGE_SIZE);

		if ( !(pPage->Attribute & 0x4000) )
		{
			if (Buffer)
			{
				MAX_LIMIT(Size, PAGE_SIZE);

				memcpy(pPage->PhysAddr, Buffer, Size);
				if (Size < PAGE_SIZE)
					memset(&pPage->PhysAddr[Size], 0, PAGE_SIZE - Size);
			} else
			{
				memset(pPage->PhysAddr, 0, PAGE_SIZE);
			}
		}
		return true;
	}

	bool CPageMemory::AllocatePage(unsigned long Address, unsigned long Attribute, unsigned char PageData)
	{
		unsigned long DirIndex = (Address >> 22);
		unsigned long PageIndex = (Address >> 12) & 1023;

		if (!m_PageDir[DirIndex])
		{
			m_PageDir[DirIndex] = new MEMORY_PAGE[1024];
			memset(m_PageDir[DirIndex], 0, sizeof(MEMORY_PAGE));
		}

		MEMORY_PAGE *pPage = &m_PageDir[DirIndex][PageIndex];

		if (pPage->Attribute)
			return false;

		memset(pPage, 0, sizeof(MEMORY_PAGE));
		pPage->Attribute = Attribute | 0x20;
		pPage->PageData = PageData;
		return true;
	}


	bool CPageMemory::ReleasePage(unsigned long Address)
	{
		unsigned long DirIndex = (Address >> 22);
		unsigned long PageIndex = (Address >> 12) & 1023;

		MEMORY_PAGE *pPage = &m_PageDir[DirIndex][PageIndex];

		if (!m_PageDir[DirIndex] || !pPage->PhysAddr)
			return false;

		DeletePage(pPage);
		memset(pPage, 0, sizeof(MEMORY_PAGE));
		return true;
	}

	unsigned long CPageMemory::ReleaseClearPage()
	{
		int Count = 0;
		for (int n = 0; n < 1024; ++n)
		{
			if (m_PageDir[n])
			{
				for (int m = 0; m < 1024; ++m)
				{
					MEMORY_PAGE *pPage = &m_PageDir[n][m];
					if ( !(pPage->Attribute & 1) && !(pPage->Attribute & 0x8000) && pPage->PhysAddr)
					{
						DeletePage(pPage);
						if (pPage->Attribute & 0x10)
							pPage->PhysAddr = 0;
						else	memset(pPage, 0, sizeof(MEMORY_PAGE));
						++Count;
						if (m_PageUsedCount <= 0)
							return Count;
					}
				}
			}
		}
		return Count;
	}

	bool CPageMemory::IsPageExist(unsigned long Address)
	{
		unsigned long DirIndex = (Address >> 22);
		unsigned long PageIndex = (Address >> 12) & 1023;

		MEMORY_PAGE *pPage = m_PageDir[DirIndex];
		return pPage && pPage[PageIndex].Attribute;
	}

	bool CPageMemory::IsPageDirExist(unsigned long Address)
	{
		unsigned long DirIndex = Address >> 22;
		return m_PageDir[DirIndex] != 0;
	}

	MEMORY_PAGE *CPageMemory::GetDataPage(unsigned long Address, bool bWrite)
	{
		Address &= 0xFFFFF000;

		if (m_PageDataCache1.bExist && Address == m_PageDataCache1.BaseAddr)
		{
			++m_PageDataCache1.AccessCount;
			return m_PageDataCache1.MemoryPage;
		}
		if (m_PageDataCache2.bExist && Address == m_PageDataCache2.BaseAddr)
		{
			++m_PageDataCache2.AccessCount;
			return m_PageDataCache2.MemoryPage;
		}

		unsigned long DirIndex = (Address >> 22);
		unsigned long PageIndex = (Address >> 12) & 1023;

		MEMORY_PAGE *pPage = &m_PageDir[DirIndex][PageIndex];

		if (!m_PageDir[DirIndex] || !pPage->Attribute)	//!IsPageExist(Address)
			return NULL;

		if (pPage->Attribute & 0x4000)
		{
			if (!NewPage(pPage))
				return NULL;
		} else
		if (pPage->Attribute & 0x10 && !pPage->PhysAddr && !LoadPage(Address, pPage))
		{
			return NULL;
		}

		if (m_PageDataCache1.AccessCount <= m_PageDataCache2.AccessCount)
		{
			m_PageDataCache1.bExist = true;
			m_PageDataCache1.BaseAddr = Address;
			m_PageDataCache1.AccessCount = 0;
			m_PageDataCache1.MemoryPage = pPage;
		} else
		{
			m_PageDataCache2.bExist = true;
			m_PageDataCache2.BaseAddr = Address;
			m_PageDataCache2.AccessCount = 0;
			m_PageDataCache2.MemoryPage = pPage;
		}
		return pPage;
	}

	bool CPageMemory::LoadPage(unsigned long Address, MEMORY_PAGE *pPage)
	{
		if (m_PageUsedCount >= m_PageCount && !ExchangePage())
			return false;

		map<CMemoryImage, CPageImage*>::IT it = m_ImageList.find(CMemoryImage(Address));
		if (it == m_ImageList.end())
			return false;

		if (!NewPage(pPage))
			return false;

		if (it->second->LoadPage(Address, pPage->PhysAddr))
			return true;

		DeletePage(pPage);
		memset(pPage, 0, sizeof(MEMORY_PAGE));
		return false;
	}

	bool CPageMemory::SavePage(unsigned long Address, MEMORY_PAGE *pPage)
	{
		if ( !(pPage->Attribute & 0x10) || !(m_Style & 1) || !pPage->PhysAddr)
			return false;

		map<CMemoryImage, CPageImage*>::IT it = m_ImageList.find(CMemoryImage(Address));
		if (it == m_ImageList.end())
			return false;

		if (!it->second->SavePage(Address, pPage->PhysAddr))
			return false;

		DeletePage(pPage);
		pPage->Attribute &= ~1;
		return true;
	}


	unsigned long CPageMemory::ReadMemX(unsigned long Address, void *Buffer, unsigned long Size)
	{
		unsigned long RAddr = Address;
		unsigned long RSize = MIN(Size,(PAGE_SIZE - Address % PAGE_SIZE));
		while (Size)
		{
			MEMORY_PAGE *pPage = GetDataPage(RAddr, 0);
			if (!pPage)
				return RAddr - Address;

			if ( !(pPage->Attribute & 0x20))
				memcpy((char *)Buffer + RAddr - Address, &pPage->PhysAddr[RAddr & 0xFFF], RSize);
			else	memset((char *)Buffer + RAddr - Address, pPage->PageData & 0xff, RSize);
			Size -= RSize;
			RAddr += RSize;
			RSize = MIN(Size,PAGE_SIZE);
		}
		return RAddr - Address;

	}

	unsigned long CPageMemory::WriteMemX(unsigned long Address, const void *Buffer, unsigned long Size)
	{
		unsigned long WAddr = Address;
		unsigned long WSize = MIN(Size,(PAGE_SIZE - Address % PAGE_SIZE));
		while (Size)
		{
			MEMORY_PAGE *pPage = GetDataPage(WAddr, 1);
			if (!pPage)
				return WAddr - Address;

			if ( !(pPage->Attribute & 0x20))
				memcpy(&pPage->PhysAddr[WAddr & 0xFFF], (char *)Buffer + WAddr - Address, WSize);
			pPage->Attribute |= 1;
			Size -= WSize;
			WAddr += WSize;
			WSize = MIN(Size,PAGE_SIZE);
		}
		return WAddr - Address;
	}

	unsigned long CPageMemory::ZeroMemX(unsigned long Address, unsigned long Size)
	{
		unsigned long WAddr = Address;
		unsigned long WSize = MIN(Size,(PAGE_SIZE - Address % PAGE_SIZE));
		while (Size)
		{
			MEMORY_PAGE *pPage = GetDataPage(WAddr, 1);
			if (!pPage)
				return WAddr - Address;

			if ( !(pPage->Attribute & 0x20))
				memset(&pPage->PhysAddr[WAddr & 0xFFF], 0, WSize);
			pPage->Attribute |= 1;
			Size -= WSize;
			WAddr += WSize;
			WSize = MIN(Size,PAGE_SIZE);
		}
		return WAddr - Address;
	}

	unsigned long CPageMemory::ReadMemory(unsigned long Address, void*Buffer, unsigned long Size, CPageMemory*pPageMemory)
	{
		return pPageMemory->ReadMemX(Address, Buffer, Size);
	}

	unsigned long CPageMemory::WriteMemory(unsigned long Address, const void*Buffer, unsigned long Size, CPageMemory*pPageMemory)
	{
		return pPageMemory->WriteMemX(Address, Buffer, Size);
	}

	unsigned long CPageMemory::ReadString(unsigned long Address, char *Buffer, unsigned long Size)
	{
		unsigned char Byte;
		unsigned int i;

		for (i = 0; i < Size-1 && ReadMemB(Address+i, &Byte); ++i)
		{
			if (Buffer)
				Buffer[i] = Byte;
			if (!Byte)
				return i;
		}
		if (Buffer)
			Buffer[i] = 0;
		return i;
	}
	unsigned long CPageMemory::WriteString(unsigned long Address, const char *Buffer, unsigned long Size)
	{
		unsigned int i;
		static const unsigned char Null = 0;

		for (i = 0; i < Size && WriteMemB(Address+i, &Buffer[i]); ++i)
		{
			if (!Buffer[i])
				return i-1;
		}
		if (i >= Size)
			WriteMemB(Address+i-1, &Null);
		return i - 1;
	}

	unsigned long CPageMemory::ReadString(unsigned long Address, unsigned short *Buffer, unsigned long Size)
	{
		unsigned short Word;
		unsigned int i;

		for (i = 0; i < Size-1 && ReadMemW(Address+2*i, &Word); ++i)
		{
			if (Buffer)
				Buffer[i] = Word;
			if (!Word)
				return i;
		}
		if (Buffer)
			Buffer[i] = 0;
		return i;
	}
	unsigned long CPageMemory::WriteString(unsigned long Address, const unsigned short *Buffer, unsigned long Size)
	{
		unsigned int i;
		static const unsigned short Null = 0;

		for (i = 0; i < Size && WriteMemW(Address+2*i, &Buffer[i]); ++i)
		{
			if (!Buffer[i])
				return i-1;
		}
		if (i >= Size)
			WriteMemW(Address+2*(i-1), &Null);
		return i - 1;
	}

	unsigned long CPageMemory::ReadString(unsigned long Address, unsigned long *Buffer, unsigned long Size)
	{
		unsigned short DWord;
		unsigned int i;

		for (i = 0; i < Size-1 && ReadMemD(Address+4*i, &DWord); ++i)
		{
			if (Buffer)
				Buffer[i] = DWord;
			if (!DWord)
				return i;
		}
		if (Buffer)
			Buffer[i] = 0;
		return i;

	}

	unsigned long CPageMemory::WriteString(unsigned long Address, const unsigned long *Buffer, unsigned long Size)
	{
		unsigned int i;
		static const unsigned long Null = 0;

		for (i = 0; i < Size && WriteMemD(Address+4*i, &Buffer[i]); ++i)
		{
			if (!Buffer[i])
				return i-1;
		}
		if (i >= Size)
			WriteMemD(Address+4*(i-1), &Null);
		return i-1;
	}

	bool CPageMemory::ReadMemB(unsigned long Address, void *Buffer)
	{
		MEMORY_PAGE *pPage = GetDataPage(Address, false);
		if (!pPage)
			return false;

		if (pPage->Attribute & 0x20)
			*(char*)Buffer = pPage->PageData;
		else
			*(char*)Buffer = pPage->PhysAddr[Address & 0xFFF];
		++pPage->AccessReadCount;
		return true;
	}

	bool CPageMemory::ReadMemW(unsigned long Address, void *Buffer)
	{
		MEMORY_PAGE *pPage = GetDataPage(Address, false);
		if ( (Address & 0xFFF) > 0xFFE)
			return ReadMemB(Address, Buffer) && ReadMemB(Address + 1, (char *)Buffer + 1);

		if (!pPage)
			return false;

		if (pPage->Attribute & 0x20)
		{
			((char*)Buffer)[0] = pPage->PageData;
			((char*)Buffer)[1] = pPage->PageData;
		} else
		{
			((short*)Buffer)[0] = *(short*)&pPage->PhysAddr[Address & 0xFFF];
		}
		++pPage->AccessReadCount;
		return true;
	}

	bool CPageMemory::ReadMemD(unsigned long Address, void *Buffer)
	{
		MEMORY_PAGE *pPage = GetDataPage(Address, false);
		if ( (Address & 0x1000) > 0xFFC)
			return ReadMemW(Address, Buffer) && ReadMemW(Address+2, (char *)Buffer+2);

		if (!pPage)
			return false;

		if (pPage->Attribute & 0x20)
		{
			((char*)Buffer)[0] = pPage->PageData;
			((char*)Buffer)[1] = pPage->PageData;
			((char*)Buffer)[2] = pPage->PageData;
			((char*)Buffer)[4] = pPage->PageData;
		} else
		{
			((long*)Buffer)[0] = *(long*)&pPage->PhysAddr[Address & 0xFFF];
		}
		++pPage->AccessReadCount;
		return true;
	}

	bool CPageMemory::WriteMemB(unsigned long Address, const void *Buffer)
	{
		MEMORY_PAGE *pPage = GetDataPage(Address, true);
		if (!pPage)
			return false;

		if ( !(pPage->Attribute & 0x20))
			pPage->PhysAddr[Address & 0xFFF] = *(char*)Buffer;

		if ( !(pPage->Attribute & 1))
		{
			++m_WriteAccessPageCount;
			pPage->Attribute |= 1;
		}
		++pPage->AccessWriteCount;
		return true;
	}

	bool CPageMemory::WriteMemW(unsigned long Address, const void *Buffer)
	{
		MEMORY_PAGE *pPage = GetDataPage(Address, true);
		if ( (Address & 0xFFF) > 0xFFE)
			return WriteMemB(Address, Buffer) && WriteMemB(Address+1, (char*)Buffer+1);

		if (!pPage)
			return false;

		if ( !(pPage->Attribute & 0x20))
			*(short*)&pPage->PhysAddr[Address & 0xFFF] = *(short*)Buffer;

		if ( !(pPage->Attribute & 1))
		{
			++m_WriteAccessPageCount;
			pPage->Attribute |= 1;
		}
		++pPage->AccessWriteCount;
		return true;
	}

	bool CPageMemory::WriteMemD(unsigned long Address, const void *Buffer)
	{
		MEMORY_PAGE *pPage = GetDataPage(Address, true);
		if ( (Address & 0xFFF) > 0xFFC)
			return WriteMemW(Address, Buffer) && WriteMemW(Address+2, (char*)Buffer+2);

		if (!pPage)
			return false;

		if ( !(pPage->Attribute & 0x20))
			*(long*)&pPage->PhysAddr[Address & 0xFFF] = *(long*)Buffer;

		if ( !(pPage->Attribute & 1))
		{
			++m_WriteAccessPageCount;
			pPage->Attribute |= 1;
		}
		++pPage->AccessWriteCount;
		return true;
	}


	bool CPageMemory::NewPage(MEMORY_PAGE *pPage)
	{
		if (m_Style & 2)
		{
			pPage->PhysAddr = new unsigned char[PAGE_SIZE];
			memset(pPage->PhysAddr, 0, PAGE_SIZE);
		} else
		{
			if (m_FreePhysIndex >= m_PageCount)
				return false;

			pPage->PhysAddr = &m_PhysMemory[PAGE_SIZE * m_FreePhysIndex];
			m_PageExistMap[m_FreePhysIndex] = 1;
			while (m_FreePhysIndex < m_PageCount && m_PageExistMap[m_FreePhysIndex])
				++m_FreePhysIndex;
		}
		pPage->Attribute &= ~0x4000;
		++m_PageUsedCount;
		return true;
	}

	bool CPageMemory::DeletePage(MEMORY_PAGE *pPage)
	{
		if ( !(pPage->Attribute & 0x4000) && pPage->PhysAddr)
		{
			if (m_Style & 2)
			{
				delete []pPage->PhysAddr;
				pPage->PhysAddr = NULL;
			} else
			{
				int PhysIndex = (pPage->PhysAddr - m_PhysMemory) / PAGE_SIZE; //???
				m_PageExistMap[PhysIndex] = 0;
				pPage->PhysAddr = NULL;
				MAX_LIMIT(m_FreePhysIndex, PhysIndex);
			}
			--m_PageUsedCount;
		}
		RefreshCache(pPage);
		return true;
	}


```

`source/Code/pagemem.hpp`:

```hpp

#ifndef _PAGEMEM_HPP_
#define _PAGEMEM_HPP_

#include "define.h"
#include "alt/altmap.hpp"
#include "pageimage.hpp"

#define PAGE_SIZE 4096

//for CPolyFS

struct MEMORY_PAGE
{
	unsigned char *PhysAddr;
	unsigned long Attribute;
	unsigned long AccessReadCount;
	unsigned long AccessWriteCount;
	unsigned long AccessExecuteCount;
	unsigned long AccessLoaderWriteCount;
	unsigned long PageData;
};

struct MEMORY_PAGE_CACHE
{
	MEMORY_PAGE *MemoryPage;
	unsigned long BaseAddr;
	unsigned long AccessCount;
	bool bExist;
};

struct CPageMemory
{
public:
	CPageMemory();
	virtual ~CPageMemory();
 
	MEMORY_PAGE_CACHE m_PageDataCache1;
	MEMORY_PAGE_CACHE m_PageDataCache2;
	int m_PageUsedCount;
	int m_PageCount;
	unsigned char *m_PhysMemory;
	unsigned char *m_PageExistMap;
	MEMORY_PAGE *m_PageDir[1024];
	int m_WriteAccessPageCount;
	int m_FreePhysIndex;
	unsigned long m_Style;
	map<CMemoryImage, CPageImage*> m_ImageList;

	virtual bool Init(int PageCount, unsigned long Style);
	virtual void Release();
	virtual void RefreshCache(MEMORY_PAGE *pPage);
	virtual bool LoadPage(unsigned long Address, MEMORY_PAGE *pPage);
	virtual bool SavePage(unsigned long Address, MEMORY_PAGE *pPage);
	virtual bool ExchangePage();
	virtual int FlushAllPage();
	virtual bool MapImage(CPageImage *pImageFile);
	virtual bool UnmapImage(CPageImage *pImageFile);

	MEMORY_PAGE *GetDataPage(unsigned long Address, bool bWrite);

	CPageImage *GetImage(unsigned long Address);
	CPageImage *GetImage(const char *FileName);
	bool AllocatePage(unsigned long Address, unsigned long Attr, void *Buffer, unsigned long Size);
	bool AllocatePage(unsigned long Address, unsigned long Attr, unsigned char Data);
	bool ReleasePage(unsigned long Address);
	unsigned long ReleaseClearPage();
	bool IsPageExist(unsigned long Address);
	bool IsPageDirExist(unsigned long Address);

	static unsigned long ReadMemory(unsigned long Address, void *Buffer, unsigned long Size, CPageMemory *pPageMemory);
	static unsigned long WriteMemory(unsigned long Address, const void *Buffer, unsigned long Size, CPageMemory *pPageMemory);

	unsigned long ReadString(unsigned long Address, char *Buffer, unsigned long Size);
	unsigned long WriteString(unsigned long Address, const char *Buffer, unsigned long Size);

	unsigned long ReadString(unsigned long Address, unsigned short *Buffer, unsigned long Size);
	unsigned long WriteString(unsigned long Address, const unsigned short *Buffer, unsigned long Size);

	unsigned long ReadString(unsigned long Address, unsigned long *Buffer, unsigned long Size);
	unsigned long WriteString(unsigned long Address, const unsigned long *Buffer, unsigned long Size);


	unsigned long ReadMemX(unsigned long Address, void *Buffer, unsigned long Size);
	unsigned long WriteMemX(unsigned long Address, const void *Buffer, unsigned long Size);
	unsigned long ZeroMemX(unsigned long Fill, unsigned long size);

	bool ReadMemB(unsigned long Address, void *Buffer);
	bool ReadMemW(unsigned long Address, void *Buffer);
	bool ReadMemD(unsigned long Address, void *Buffer);

	bool WriteMemB(unsigned long Address, const void *Buffer);
	bool WriteMemW(unsigned long Address, const void *Buffer);
	bool WriteMemD(unsigned long Address, const void *Buffer);

	bool NewPage(MEMORY_PAGE *pPage);
	bool DeletePage(MEMORY_PAGE *pPage);
};

#endif

```

`source/Code/polyfs.cpp`:

```cpp

#include "polyfs.hpp"
#include "compress.hpp"

	CPolyFS::CPolyFS()
		: m_pFileIO(gpFileIO)
		, m_MaxCachePageCount(256)
		, m_FatOff(0)
		, m_ClusSize(0)
		, m_ClusCount(0)
		, m_Style(0)
		, m_ZeroBuffer(nullptr)
	{
	}

	CPolyFS::~CPolyFS()
	{
		CloseDisk();
	}

	void CPolyFS::ChangeFileIO(CFileIO *pFileIO)
	{
		m_pFileIO = pFileIO;
	}

	bool CPolyFS::Format(const char *FileName, unsigned long ClusCount, unsigned long ClusSize)
	{
		unsigned long j;
		unsigned long i;
		unsigned long v8;
		PFS_FILE_ENTRY FileEntry;
		unsigned long v10;
		PFS_HEAD PFSHead;
		//int ClusCounta;

		if (ClusCount == 0)
			return false;

		if (ClusSize == 0)
			ClusSize = 4096;

		m_DiskImage.ChangeFileIO(m_pFileIO);
		if (!m_DiskImage.Create(FileName, 0))
			return false;

		m_ClusSize = ALIGN_SIZE(ClusSize, 256);

		memset(&PFSHead, 0, sizeof(PFS_HEAD));
		TStrCpy(PFSHead.Sign, "PFS");
		PFSHead.ClusCount = ALIGN_SIZE((ClusCount/m_ClusSize), (m_ClusSize/4));

		m_ClusCount = PFSHead.ClusCount;
		//ClusCounta = m_ClusSize * m_ClusCount;
		PFSHead.ClusSize = m_ClusSize;
		TStrCpy(PFSHead.FatEntry.FileName, "*FAT*");
		PFSHead.FatEntry.Attribute = 0x10; //PFS_SYSTEM
		PFSHead.FatEntry.BeginClus = 1;
		PFSHead.FatEntry.FileSize = 4 * PFSHead.ClusCount;
		PFSHead.FatEntry.NameCode = TGetNameCode(PFSHead.FatEntry.FileName);

		m_DiskImage.m_FileSize = m_ClusCount * m_ClusSize;
		m_Style = 0;
		InitParam();

		m_FatOff = m_ClusSize * PFSHead.FatEntry.BeginClus;

		if (!WriteDiskFile(0, &PFSHead, sizeof(PFS_HEAD)))
		{
			CloseDisk();
			return false;
		}

		v10 = (unsigned int)PFSHead.FatEntry.FileSize / m_ClusSize;
		for (i = 0; i < v10; ++i)
		{
			if (!WriteDiskFile(m_FatOff + m_ClusSize * i, m_ZeroBuffer, m_ClusSize))
			{
				CloseDisk();
				return false;
			}
		}

		v8 = -1;
		if (!WriteFatCell(0, &v8))
		{
			CloseDisk();
			return false;
		}
		
		for (j = 1; j < v10; ++j)
		{
			v8 = PFSHead.FatEntry.BeginClus + j;
			if (!WriteFatCell(j, &v8))
			{
				CloseDisk();
				return false;
			}
		}

		v8 = -1;
		if (!WriteFatCell(v10, &v8))
		{
			CloseDisk();
			return false;
		}

		
		memset(&FileEntry, 0, sizeof(PFS_FILE_ENTRY));
		FileEntry.BeginClus = 0;
		FileEntry.FileSize = m_ClusSize;
		CreateFile("*ROOT*", 0x11, m_ClusSize, &FileEntry, 0x40); //PFS_SYSTEM PFS_DIRECTORY
		ReadDiskFile(0x40, &m_RootEntry, sizeof(PFS_FILE_ENTRY));
		CloseDisk();
		return true;
	}

	bool CPolyFS::ReadDiskFile(unsigned long Pos, void *Buffer, unsigned long Size)
	{
		return m_PageMemory.ReadMemX(Pos, Buffer, Size) == Size;
	}

	bool CPolyFS::WriteDiskFile(unsigned long Pos, const void *Buffer, unsigned long Size)
	{
		return m_PageMemory.WriteMemX(Pos, Buffer, Size) == Size;
	}

	bool CPolyFS::ReadFatCell(unsigned long Index, void *Buffer)
	{
		return ReadDiskFile(m_FatOff + 4 * Index, Buffer, 4);
	}

	bool CPolyFS::WriteFatCell(unsigned long Index, const void *Buffer)
	{
		return WriteDiskFile(m_FatOff + 4 * Index, Buffer, 4);
	}

	bool CPolyFS::ReadClus(unsigned long Index, void *Buffer)
	{
		if (Index < m_ClusCount)
			return ReadDiskFile(m_ClusSize * Index, Buffer, m_ClusSize);
		return false;
	}

	bool CPolyFS::WriteClus(unsigned long Index, const void *Buffer)
	{
		if (Index < m_ClusCount)
			return WriteDiskFile(m_ClusSize * Index, Buffer, m_ClusSize);
		return false;
	}

	unsigned long CPolyFS::FileOffToDP(unsigned long ClusIndex, unsigned long Offset)
	{
		for (; Offset >= m_ClusSize; Offset -= m_ClusSize)
		{
			if (!ReadFatCell(ClusIndex, &ClusIndex))
				return 0;
			if (ClusIndex == -1)
				return 0;
		}
		return Offset + m_ClusSize * ClusIndex;
	}

	unsigned long CPolyFS::FileOffToClus(unsigned long ClusIndex, unsigned long Offset)
	{
		for (; Offset >= m_ClusSize; Offset -= m_ClusSize)
		{
			if (!ReadFatCell(ClusIndex, &ClusIndex))
				return -1;
			if (ClusIndex == -1)
				return -1;
		}
		return ClusIndex;
	}

	unsigned long CPolyFS::ReadFile(struct PFS_FILE_DATA *pHandleData, unsigned long Offset, void *Buffer, unsigned long Size)
	{
		if ( !(pHandleData->ThisFileEntry.Attribute & 0x20) ) //PFS_ARCHIVE
			return ReadFile(&pHandleData->ThisFileEntry, Offset, Buffer, Size);

		unsigned long FileSize;
		if (ReadFile(&pHandleData->ThisFileEntry, 0, &FileSize, 4) != 4)
			return 0;

		if (Offset || Size != FileSize)
			return 0;

		unsigned long nSize = pHandleData->ThisFileEntry.FileSize;
		unsigned char *pBuffer = new unsigned char[nSize];
		if (!pBuffer)
			return 0;

		if (ReadFile(&pHandleData->ThisFileEntry, 0, pBuffer, nSize) != nSize)
		{
			delete []pBuffer;
			return 0;
		}

		int sz = lzo_decompress(pBuffer, nSize, Buffer);

		delete []pBuffer;
		return Size;
	}

	unsigned long CPolyFS::WriteFile(struct PFS_FILE_DATA *pHandleData, unsigned long Offset, const void *Buffer, unsigned long Size)
	{
		if (Size + Offset > pHandleData->ThisFileEntry.FileSize)
		{
			if (!SetFileLength(pHandleData, Size + Offset))
				return 0;
		}

		//TODO lzo_compress may be in another funcs

		return WriteFile(&pHandleData->ThisFileEntry, Offset, Buffer, Size);
	}

	unsigned long CPolyFS::ReadFile(struct PFS_FILE_ENTRY *pFileEntry, unsigned long Offset, void *Buffer, unsigned long Size)
	{
		unsigned long v6;
		unsigned long n;
		unsigned long ClusIndex;
		unsigned long PageSize;
		unsigned long nBytes;
		unsigned long FileDP_v12;
		unsigned long FileDP_v12a;

		if (Offset >= pFileEntry->FileSize || !Size)
			return 0;
		nBytes = 0;
		PageSize = Offset % m_ClusSize;
		if (PageSize)
		{
			FileDP_v12 = FileOffToDP(pFileEntry->BeginClus, Offset);
			if (!FileDP_v12)
				return 0;
			v6 = MIN(m_ClusSize - PageSize, Size);
			if (!ReadDiskFile(FileDP_v12, Buffer, v6))
				return 0;
			nBytes = v6;
		}

		ClusIndex = FileOffToClus(pFileEntry->BeginClus, nBytes + Offset);
		for (n = (Size-nBytes)/m_ClusSize; n && nBytes + Offset < pFileEntry->FileSize; --n)
		{
			if (ClusIndex == -1 || !ReadClus(ClusIndex, nBytes + (char*)Buffer))
				return 0;
			nBytes += m_ClusSize;
			ClusIndex = FileOffToClus(ClusIndex, m_ClusSize);
		}

		if (Size != nBytes && nBytes + Offset < pFileEntry->FileSize)
		{
			FileDP_v12a = FileOffToDP(ClusIndex, (nBytes + Offset) % m_ClusSize);
			if (!FileDP_v12a)
				return nBytes;
			if (!ReadDiskFile(FileDP_v12a, nBytes + (char*)Buffer, Size - nBytes))
				return nBytes;
			nBytes = Size;
		}
		return nBytes;
	}

	unsigned long CPolyFS::WriteFile(struct PFS_FILE_ENTRY *pFileEntry, unsigned long Offset, const void *Buffer, unsigned long Size)
	{
		unsigned long v6;
		unsigned long n;
		unsigned long ClusIndex;
		unsigned long PageSize;
		unsigned long nBytes;
		unsigned long FileDP_v12;
		unsigned long FileDP_v13;

		if (Offset >= pFileEntry->FileSize || !Size)
			return 0;
		nBytes = 0;
		PageSize = Offset % m_ClusSize;
		if (PageSize)
		{
			FileDP_v12 = FileOffToDP(pFileEntry->BeginClus, Offset);
			if (!FileDP_v12)
				return 0;
			v6 = MIN(m_ClusSize - PageSize, Size);
			if (!WriteDiskFile(FileDP_v12, (void*)Buffer, v6))
				return 0;
			nBytes = v6;
		}

		ClusIndex = FileOffToClus(pFileEntry->BeginClus, nBytes + Offset);
		for (n = (Size - nBytes) / m_ClusSize; n && nBytes + Offset < pFileEntry->FileSize; --n)
		{
			if (ClusIndex == -1 || !WriteClus(ClusIndex, nBytes + (char*)Buffer))
				return 0;
			nBytes += m_ClusSize;
			ClusIndex = FileOffToClus(ClusIndex, m_ClusSize);
		}

		if (Size != nBytes && nBytes + Offset < pFileEntry->FileSize)
		{
			FileDP_v13 = FileOffToDP(ClusIndex, (nBytes + Offset) % m_ClusSize);
			if (!FileDP_v13)
				return nBytes;
			if (!WriteDiskFile(FileDP_v13, nBytes + (char*)Buffer, Size - nBytes) )
				return nBytes;
			nBytes = Size;
		}
		return nBytes;
	}

	unsigned long CPolyFS::FindFreeFileEntryFP(PFS_FILE_ENTRY *pParentEntry)
	{
		for (unsigned long Off = 0;
			Off < pParentEntry->FileSize;
			Off += sizeof(PFS_FILE_ENTRY))
		{
			PFS_FILE_ENTRY FileEntry;
			if (ReadFile(pParentEntry, Off, &FileEntry, sizeof(PFS_FILE_ENTRY)) != sizeof(PFS_FILE_ENTRY))
				return -1;
			if (!FileEntry.NameCode || FileEntry.NameCode == 0xFFFFFF)
				return Off;
		}
		return -1;
	}

	bool CPolyFS::CreateFile(const char *FileName, unsigned long Attr, unsigned long Size, PFS_FILE_ENTRY *pParentDirEntry, unsigned long ParentFileEntryFP)
	{
		unsigned long i;
		PFS_FILE_ENTRY FileEntry;
		unsigned long PrevClus;
		unsigned long n;
		unsigned long BeginClus;
		unsigned long nClus;
		unsigned long Off;

		nClus = PAGE_COUNT(Size, m_ClusSize);
		if (nClus)
		{
			Off = FindNextFreeClus(0);
			BeginClus = Off;
			for (i = 0; i < nClus - 1; ++i)
			{
				PrevClus = Off;
				Off = FindNextFreeClus(Off + 1);
				if (Off == -1)
					return false;
				if (!WriteFatCell(PrevClus, &Off))
					return false;
			}
			PrevClus = Off;
			Off = -1;
			if (!WriteFatCell(PrevClus, &Off))
				return false;
		} else
		{
			BeginClus = -1;
		}
		memset(&FileEntry, 0, sizeof(PFS_FILE_ENTRY));
		FileEntry.Attribute = Attr;
		FileEntry.FileSize = Size;
		FileEntry.BeginClus = BeginClus;
		TStrCpyLimit(FileEntry.FileName, FileName, 32);
		FileEntry.NameCode = TGetNameCode(FileEntry.FileName);
		if (WriteFile(pParentDirEntry, ParentFileEntryFP, &FileEntry, sizeof(PFS_FILE_ENTRY)) != sizeof(PFS_FILE_ENTRY))
			return false;

		if (Size == 0)
			return true;

		for (n = 0; n < Size && WriteFile(&FileEntry, n, m_ZeroBuffer, m_ClusSize); n += m_ClusSize)
		{
			;
		}
		return true;
	}

	bool CPolyFS::CreateFile(const char *FullFileName, unsigned long Attr, unsigned long Size, PFS_FILE_DATA *pHandleData)
	{
		PFS_FIND_DATA FindData;
		char FileName[256];
		char PathName[256];
		unsigned long FreeFileEntryFP;

		if (FullFileName[0] != '\\' )
			return false;

		if (FullFileName[1] == 0)
			return false;

		if (FindFirstFile(FullFileName, &FindData))
		{
			FreeFileEntryFP = FindData.FileEntryFP;
			if (!SetFileLength(FullFileName, Size))
				return false;
			
			pHandleData->FilePoint = 0;
			memcpy(&pHandleData->ParentEntry, &FindData.ParentEntry, sizeof(PFS_FILE_ENTRY));
			pHandleData->FileEntryFP = FreeFileEntryFP;
			return ReadFile(&pHandleData->ParentEntry, FreeFileEntryFP,
				&pHandleData->ThisFileEntry, sizeof(PFS_FILE_ENTRY)) == sizeof(PFS_FILE_ENTRY);
		}
		
		TStrCpy(FileName, TGetFileName(FullFileName));
		TGetFilePath(FullFileName, PathName);
		if (!PathName[0])
			TStrCpy(PathName, "\\");

		if (!FindFirstFile(PathName, &FindData))
			return false;

		FreeFileEntryFP = FindFreeFileEntryFP(&FindData.ThisFileEntry);
		if (FreeFileEntryFP == -1)
		{
			if (!SetFileLength(PathName, m_ClusSize + FindData.ThisFileEntry.FileSize))
			return false;
			FindData.ThisFileEntry.FileSize += m_ClusSize;
			if (PathName[0] == '\\' && !PathName[1])
				memcpy(&m_RootEntry, &FindData.ThisFileEntry, sizeof(PFS_FILE_ENTRY));
			FreeFileEntryFP = FindFreeFileEntryFP(&FindData.ThisFileEntry);
			if (FreeFileEntryFP == -1)
				return false;
		}

		pHandleData->FilePoint = 0;
		if (!CreateFile(FileName, Attr, Size, &FindData.ThisFileEntry, FreeFileEntryFP))
			return false;
		
		memcpy(&pHandleData->ParentEntry, &FindData.ThisFileEntry, sizeof(PFS_FILE_ENTRY));
		pHandleData->FileEntryFP = FreeFileEntryFP;
		return ReadFile(&pHandleData->ParentEntry, FreeFileEntryFP,
			&pHandleData->ThisFileEntry, sizeof(PFS_FILE_ENTRY)) == sizeof(PFS_FILE_ENTRY);
	}

	bool CPolyFS::OpenFile(const char *FullFileName, PFS_FILE_DATA *pHandleData)
	{
		PFS_FIND_DATA FindData;
		if (!FindFirstFile(FullFileName, &FindData))
			return false;

		pHandleData->FilePoint = 0;
		memcpy(&pHandleData->ThisFileEntry, &FindData.ThisFileEntry, sizeof(PFS_FILE_ENTRY));
		memcpy(&pHandleData->ParentEntry, &FindData.ParentEntry, sizeof(PFS_FILE_ENTRY));
		pHandleData->FileEntryFP = FindData.FileEntryFP;
		return true;
	}

	unsigned long CPolyFS::FindNextFreeClus(unsigned long ClusIdx)
	{
		for (unsigned long Index = ClusIdx; Index < m_ClusCount; ++Index)
		{
			unsigned long Data; //??? = 0;
			if (!ReadFatCell(Index, &Data))
				return -1;
			if (!Data)
				return Index;
		}
		return -1;
	}

	bool CPolyFS::SetFileLength(const char *FileName, unsigned long Length)
	{
		PFS_FILE_DATA FileData;
		if (!OpenFile(FileName, &FileData))
			return false;
		return SetFileLength(&FileData, Length);
	}

	bool CPolyFS::SetFileLength(PFS_FILE_DATA *pHandleData, unsigned long Length)
	{
		unsigned long WTSize;
		unsigned long ni;
		unsigned long Off;
		unsigned long Data;
		unsigned long PrevFatDP;
		unsigned long ClusIdx;
		unsigned long PrevIdx;
		unsigned long nNewClus;
		unsigned long nOldClus;

		nOldClus = PAGE_COUNT(Length, m_ClusSize);
		nNewClus = PAGE_COUNT(pHandleData->ThisFileEntry.FileSize, m_ClusSize);

		if (nOldClus <= nNewClus)
		{
			if (nOldClus >= nNewClus)
			{
				pHandleData->ThisFileEntry.FileSize = Length;
			} else
			{
				ClusIdx = FileOffToClus(pHandleData->ThisFileEntry.BeginClus, m_ClusSize * nOldClus);
				if (!DeleteFileClus(ClusIdx))
					return false;
				Data = -1;
				if (!WriteFatCell(ClusIdx, &Data))
					return false;
				pHandleData->ThisFileEntry.FileSize = Length;
			}
		} else
		{
			if (nNewClus)
			{
				ClusIdx = FileOffToClus(pHandleData->ThisFileEntry.BeginClus, m_ClusSize * (nNewClus - 1));
				if (ClusIdx == -1)
					return false;
			}

			for (ni = nNewClus; ni < nOldClus; ++ni)
			{
				if (ni)
				{
					PrevIdx = ClusIdx;
					ClusIdx = FindNextFreeClus(ClusIdx + 1);
					if (ClusIdx == -1)
						return false;
					if (!WriteFatCell(PrevIdx, &ClusIdx))
						return false;
				} else
				{
					PrevFatDP = FileOffToDP(pHandleData->ParentEntry.BeginClus,
								pHandleData->FileEntryFP);
					if (!PrevFatDP)
						return false;

					ClusIdx = FindNextFreeClus(1);
					pHandleData->ThisFileEntry.BeginClus = ClusIdx;
					if (!WriteDiskFile(PrevFatDP, &ClusIdx, 4))
						return false;
				}
			}
			Data = -1;
			if (!WriteFatCell(ClusIdx, &Data))
				return false;

			Off = pHandleData->ThisFileEntry.FileSize;
			pHandleData->ThisFileEntry.FileSize = Length;
			while (Off < pHandleData->ThisFileEntry.FileSize)
			{
				WTSize = MIN(m_ClusSize, pHandleData->ThisFileEntry.FileSize - Off);
				WriteFile(&pHandleData->ThisFileEntry, Off, m_ZeroBuffer, WTSize);
				Off += WTSize;
			}
		}
		return WriteFile(&pHandleData->ParentEntry, pHandleData->FileEntryFP + 4, &Length, 4) == 4;
	}

	unsigned long CPolyFS::GetFileLength(const char *FileName)
	{
		PFS_FIND_DATA FindData;
		if (!FindFirstFile(FileName, &FindData))
			return 0;
		if ( !(FindData.ThisFileEntry.Attribute & 0x20) ) //PFS_ARCHIVE
			return FindData.ThisFileEntry.FileSize;
		unsigned long Length;
		if (ReadFile(&FindData.ThisFileEntry, 0, &Length, 4) != 4)
			return 0;
		return Length;
	}

	bool CPolyFS::DeleteFile(const char *FullFileName)
	{
		if (FullFileName[0] != '\\' || FullFileName[1] == 0)
			return false;

		PFS_FIND_DATA FindData;
		if (!FindFirstFile(FullFileName, &FindData))
			return false;
		if (!DeleteFileClus(FindData.ThisFileEntry.BeginClus))
			return false;

		PFS_FILE_ENTRY FileEntry;
		memset(&FileEntry, 0, sizeof(PFS_FILE_ENTRY));
		FileEntry.NameCode = 0xFFFFFF;
		return WriteFile(&FindData.ParentEntry, FindData.FileEntryFP, &FileEntry, sizeof(PFS_FILE_ENTRY)) == sizeof(PFS_FILE_ENTRY);
	}

	bool CPolyFS::DeleteFileClus(unsigned long BeginClus)
	{
		unsigned long nThisClus = BeginClus;
		unsigned long Data = 0;
		while (nThisClus != -1)
		{
			unsigned long nNextClus = nThisClus;
			if (!ReadFatCell(nThisClus, &nThisClus))
				return false;
			if (!WriteFatCell(nNextClus, &Data))
				return false;
		}
		return true;
	}

	bool CPolyFS::FindFirstFile(const char *FullFileName, PFS_FIND_DATA *pFindData)
	{
		//char FileName[MAX_FN_LEN];
		//const char *pStr;
		//PFS_FIND_DATA FindData;

		if (FullFileName[0] == '\\')
		{
			PFS_FIND_DATA FindData;
			memset(&FindData, 0, sizeof(PFS_FIND_DATA));
			memcpy(&FindData.ThisFileEntry, &m_RootEntry, sizeof(PFS_FILE_ENTRY));
			FindData.ParentEntry.BeginClus = 0;
			FindData.ParentEntry.FileSize = 0x70;
			FindData.ParentEntry.Attribute = m_RootEntry.Attribute;
			FindData.FileEntryFP = 0x40;
			const char *pStr = FullFileName;
			while (*pStr)
			{
				char FileName[MAX_FN_LEN];
				int Length = 0;
				while (*pStr && *pStr != '\\' && Length < MAX_FN_LEN-1)
					FileName[Length++] = *pStr++;
				FileName[Length] = 0;
				if (Length)
				{
					memcpy(&FindData.ParentEntry, &FindData.ThisFileEntry, sizeof(PFS_FILE_ENTRY));
					if (!FindFirstFile(FileName, &FindData))
						return false;
				}
				while (*pStr == '\\') ++pStr;
			}
			memcpy(pFindData, &FindData, sizeof(PFS_FIND_DATA));
			return true;
		} 

		for (unsigned long Off = 0;
			Off < pFindData->ParentEntry.FileSize;
			Off += sizeof(PFS_FILE_ENTRY))
		{
			if (ReadFile(&pFindData->ParentEntry, Off, &pFindData->ThisFileEntry, sizeof(PFS_FILE_ENTRY)) != sizeof(PFS_FILE_ENTRY))
				return false;
			if (CmpFileName(FullFileName, &pFindData->ThisFileEntry))
			{
				TStrCpyLimit(pFindData->FileName, pFindData->ThisFileEntry.FileName, 256);
				pFindData->FileEntryFP = Off;
				TStrCpyLimit(pFindData->PattenName, FullFileName, 256);
				return true;
			}
		}
		return false;
	}

	bool CPolyFS::FindNextFile(PFS_FIND_DATA *pFindData)
	{
		for (unsigned long Off = pFindData->FileEntryFP + sizeof(PFS_FILE_ENTRY);
			Off < pFindData->ParentEntry.FileSize;
			Off += sizeof(PFS_FILE_ENTRY))
		{
			if (ReadFile(&pFindData->ParentEntry, Off, &pFindData->ThisFileEntry, sizeof(PFS_FILE_ENTRY)) != sizeof(PFS_FILE_ENTRY))
					return false;
			if (!pFindData->ThisFileEntry.NameCode)
				return false;
			if (CmpFileName(pFindData->PattenName, &pFindData->ThisFileEntry))
			{
				TStrCpyLimit(pFindData->FileName, pFindData->ThisFileEntry.FileName, 256);
				pFindData->FileEntryFP = Off;
				return true;
			}
		}
		return false;
	}

	bool CPolyFS::CmpFileName(const char *FilePatternName, PFS_FILE_ENTRY *pFileEntry)
	{
		if (!pFileEntry->FileName[0])
			return false;
		if (FilePatternName[0] == '*' && FilePatternName[1] == '0')
			return true;
		if (TStrChr(FilePatternName, '*') || TStrChr(FilePatternName, '?'))
			return TIMultiMatchWithPattern(FilePatternName, pFileEntry->FileName);
		return TStrICmp(FilePatternName, pFileEntry->FileName) == 0;
	}

	bool CPolyFS::SetFileAttribute(const char *FileName, unsigned long Attr)
	{
		PFS_FIND_DATA FindData;
		if (!FindFirstFile(FileName, &FindData))
			return false;

		return WriteFile(&FindData.ParentEntry, FindData.FileEntryFP + 8, &Attr, 4) == 4;
	}

	unsigned long CPolyFS::GetFileAttribute(const char *FileName)
	{
		PFS_FIND_DATA FindData;
		if (!FindFirstFile(FileName, &FindData))
			return 0;
		return FindData.ThisFileEntry.Attribute;
	}

	void CPolyFS::InitParam()
	{
		unsigned long PageCount;
		if (m_Style & 2)
			PageCount = PAGE_COUNT(m_DiskImage.m_FileSize, 4096);
		else	PageCount = MIN(PAGE_COUNT(m_DiskImage.m_FileSize, 4096), m_MaxCachePageCount);

		m_PageMemory.Init(PageCount, (m_Style & 1) == 0);
		m_DiskImage.m_ImageBase = 0;
		m_DiskImage.m_ImageSize = m_ClusCount * m_ClusSize;
		m_DiskImage.m_ImageHighBase = m_DiskImage.m_ImageBase + m_DiskImage.m_ImageSize;
		m_PageMemory.MapImage(&m_DiskImage);
		m_ZeroBuffer = new unsigned char[m_ClusSize];
		if (m_Style & 2)
		{
			for (unsigned long Address = m_DiskImage.m_ImageBase; Address < PageCount<<12; Address += m_ClusSize)
				ReadDiskFile(Address, m_ZeroBuffer, m_ClusSize);
		}
		memset(m_ZeroBuffer, 0, m_ClusSize);
	}

	bool CPolyFS::OpenDisk(const char *FileName, unsigned int Style)
	{
		PFS_HEAD PFSHead;

		m_Style = Style;
		m_DiskImage.ChangeFileIO(m_pFileIO);

		//hack++
		//m_DiskImage.m_RMObj = &m_DiskImage;
		//m_DiskImage.m_WRObj = &m_DiskImage;

		if (!m_DiskImage.Open(FileName, 0))
			return false;
		if (!m_DiskImage.ReadFile(&PFSHead, sizeof(PFSHead)))
			return false;
		if (TStrNCmp(PFSHead.Sign, "PFS", 3))
		{
			m_DiskImage.Close();
			return false;
		}
		m_ClusSize = PFSHead.ClusSize;
		m_ClusCount = PFSHead.ClusCount;
		m_FatOff = m_ClusSize * PFSHead.FatEntry.BeginClus;
		memcpy(&m_RootEntry, &PFSHead.RootEntry, sizeof(m_RootEntry));
		InitParam();
		return true;
	}

	void CPolyFS::CloseDisk()
	{
		if (m_DiskImage.m_hHandle || m_DiskImage.m_Buffer)
		{
			if ( !(m_Style & 1) )
				m_PageMemory.FlushAllPage();
			m_PageMemory.Release();
			SafeDeleteAry(m_ZeroBuffer);
			m_DiskImage.Close();
		}
	}


///
	CPFSFileIO::CPFSFileIO()
	{
		m_pszSepar = "\\";
		m_pFileIO = 0;
	}


	void CPFSFileIO::ChangeFileIO(CFileIO *pFileIO)
	{
		m_pFileIO = pFileIO;
	}

	bool CPFSFileIO::OpenDisk(const char *FileName, unsigned int Style)
	{
		m_Handle.Reset();
		m_Handle.Register(0, 0);

		TListIter<CPolyFS> It = m_PolyFSDisk.Append();
		if (m_pFileIO) It->ChangeFileIO(m_pFileIO);
		if (!It->OpenDisk(FileName, Style))
		{
			m_PolyFSDisk.Remove(It);
			return false;
		}
		return true;
	}

	void CPFSFileIO::CloseDisk()
	{
		m_Handle.CloseAllHandle();
		m_PolyFSDisk.Clear();
	}


	bool CPFSFileIO::OpenFile(const char *FileName, HANDLE *phFile, unsigned long Mode)
	{
		TListIter<CPolyFS> It = m_PolyFSDisk.Begin();
		for (; It != m_PolyFSDisk.End(); ++It)
		{
			PFS_FILE_DATA FileData;
			if (It->OpenFile(FileName, &FileData))
			{
				MY_PFS_FILE_DATA *pPFSFileData = new MY_PFS_FILE_DATA;
				memcpy(&pPFSFileData->m_FileData, &FileData, sizeof(PFS_FILE_DATA));
				pPFSFileData->m_pPolyFS = &*It;
				*phFile = (HANDLE)m_Handle.CreateHandle(pPFSFileData, 1);
				return true;
			}
		}
		return false;
	}

	bool CPFSFileIO::CreateFile(const char *FileName, HANDLE *phFile, unsigned long Mode)
	{
		if (m_PolyFSDisk.Size() == 0)
			return false;

		TListIter<CPolyFS> It = m_PolyFSDisk.Begin();

		PFS_FILE_DATA FileData;
		if (!It->CreateFile(FileName, 2, 0, &FileData)) //PFS_???
			return false;

		MY_PFS_FILE_DATA *pPFSFileData = new MY_PFS_FILE_DATA;
		memcpy(&pPFSFileData->m_FileData, &FileData, sizeof(PFS_FILE_DATA));
		pPFSFileData->m_pPolyFS = &*It;
		*phFile = (HANDLE)m_Handle.CreateHandle(pPFSFileData, 1);
		return true;
	}

	bool CPFSFileIO::CreateDir(const char *FileName)
	{
		if (m_PolyFSDisk.Size() == 0)
			return false;

		PFS_FILE_DATA FileData;
		return m_PolyFSDisk.Begin()->CreateFile(FileName, 1, //PFS_DIRECTORY
					m_PolyFSDisk.Begin()->m_ClusSize, &FileData);
	}

	bool CPFSFileIO::CloseHandle(HANDLE hFile)
	{
		return m_Handle.CloseHandle((ULONG_PTR)hFile);
	}

	unsigned long CPFSFileIO::ReadFile(HANDLE hFile, void *Buffer, unsigned long Size, unsigned __int64 Offset)
	{
		MY_PFS_FILE_DATA *pInfo = (MY_PFS_FILE_DATA *)m_Handle.GetHandleInfo((ULONG_PTR)hFile);
		if (!pInfo) return 0;
		return pInfo->m_pPolyFS->ReadFile(&pInfo->m_FileData, Offset, Buffer, Size);
	}
	unsigned long CPFSFileIO::WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size, unsigned __int64 Offset)
	{
		MY_PFS_FILE_DATA *pInfo = (MY_PFS_FILE_DATA *)m_Handle.GetHandleInfo((ULONG_PTR)hFile);
		if (!pInfo) return 0;
		return pInfo->m_pPolyFS->WriteFile(&pInfo->m_FileData, Offset, Buffer, Size);
	}

	unsigned long CPFSFileIO::ReadFile(HANDLE hFile, void *Buffer, unsigned long Size)
	{
		return 0;
	}

	unsigned long CPFSFileIO::WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size)
	{
		return 0;
	}

	unsigned __int64 CPFSFileIO::SetFilePointer(HANDLE hFile, __int64 Offset, unsigned long Pos)
	{
		return 0;
	}

	unsigned __int64 CPFSFileIO::GetFileLength(HANDLE hFile)
	{
		MY_PFS_FILE_DATA *pInfo = (MY_PFS_FILE_DATA *)m_Handle.GetHandleInfo((ULONG_PTR)hFile);
		if (!pInfo) return -1;
		if ( !(pInfo->m_FileData.ThisFileEntry.Attribute & 0x20) ) //PFS_ARCHIVE
			return pInfo->m_FileData.ThisFileEntry.FileSize;
		unsigned long Length;
		if (pInfo->m_pPolyFS->ReadFile(&pInfo->m_FileData.ThisFileEntry, 0, &Length, 4) == 4)
			return Length;
		return 0;
	}

	bool CPFSFileIO::SetFileLength(HANDLE hFile, unsigned __int64 Length)
	{
		MY_PFS_FILE_DATA *pInfo = (MY_PFS_FILE_DATA *)m_Handle.GetHandleInfo((ULONG_PTR)hFile);
		if (!pInfo) return false;
		return pInfo->m_pPolyFS->SetFileLength(&pInfo->m_FileData, Length);
	}

	bool CPFSFileIO::DeleteFile(const char *FileName)
	{
		int Count = 0;
		TListIter<CPolyFS> It = m_PolyFSDisk.Begin();
		for (; It != m_PolyFSDisk.End(); ++It)
			if (It->DeleteFile(FileName))
				Count++;
		return Count>0;
	}

	bool CPFSFileIO::RenameFile(const char *FileName, const char *NewFileName)
	{
		return false;
	}

	bool CPFSFileIO::SetFileAttr(const char *FileName, unsigned long Attr)
	{
		unsigned long PFSAttr = 0;
		if (Attr & 0x01) PFSAttr  = 0x04; //FILE_ATTRIBUTE_READONLY	PFS_READONLY	0x04
		if (Attr & 0x04) PFSAttr |= 0x10; //FILE_ATTRIBUTE_SYSTEM	PFS_SYSTEM	0x10
		if (Attr & 0x10) PFSAttr |= 0x01; //FILE_ATTRIBUTE_DIRECTORY	PFS_DIRECTORY	0x01
		if (Attr & 0x02) PFSAttr |= 0x08; //FILE_ATTRIBUTE_HIDDEN	PFS_HIDDEN	0x08
		if (Attr & 0x20) PFSAttr |= 0x20; //FILE_ATTRIBUTE_ARCHIVE	PFS_ARCHIVE	0x20
		int Count = 0;
		TListIter<CPolyFS> It = m_PolyFSDisk.Begin();
		for (; It != m_PolyFSDisk.End(); ++It)
			if (It->SetFileAttribute(FileName, PFSAttr))
				Count++;
		return Count>0;
	}

	unsigned long CPFSFileIO::GetFileAttr(const char *FileName)
	{
		TListIter<CPolyFS> It = m_PolyFSDisk.Begin();
		for (; It != m_PolyFSDisk.End(); ++It)
		{
			unsigned long PFSAttr = It->GetFileAttribute(FileName);
			if (PFSAttr != 0)
			{
				unsigned long FIOAttr = 0;
				if (PFSAttr & 0x10) FIOAttr  = 0x04; //FILE_ATTRIBUTE_SYSTEM
				if (PFSAttr & 0x04) FIOAttr |= 0x01; //FILE_ATTRIBUTE_READONLY
				if (PFSAttr & 0x08) FIOAttr |= 0x02; //FILE_ATTRIBUTE_HIDDEN
				if (PFSAttr & 0x01) FIOAttr |= 0x10; //FILE_ATTRIBUTE_DIRECTORY
				if (PFSAttr & 0x20) FIOAttr |= 0x20; //FILE_ATTRIBUTE_ARCHIVE
				return FIOAttr;
			}
		}

		return -1;
	}

	bool CPFSFileIO::IsDir(const char *FileName)
	{
		PFS_FIND_DATA FindData;
		TListIter<CPolyFS> It = m_PolyFSDisk.Begin();
		for (; It != m_PolyFSDisk.End(); ++It)
		{
			if (It->FindFirstFile(FileName, &FindData))
				return (FindData.ThisFileEntry.Attribute & 1) != 0; //PFS_DIRECTORY
		}
		return false;
	}

	bool CPFSFileIO::DeleteDir(const char *FileName)
	{
		char szBuffer[MAX_FN_LEN];
		TStrCpy(szBuffer, FileName); //??? Limit 260
		TStrCat(szBuffer, "\\*");

		TListIter<CPolyFS> It = m_PolyFSDisk.Begin();
		for (; It != m_PolyFSDisk.End(); ++It)
		{
			PFS_FIND_DATA FindData;
			if (It->FindFirstFile(FileName, &FindData))
				return It->DeleteFile(szBuffer);
		}
		return false;
	}

	bool CPFSFileIO::FindFirstFile(const char *FullFileName, FILE_FIND_DATA *pFindData)
	{
		char FileName[MAX_FN_LEN];
		PFS_FIND_DATA FindData;
		MY_PFS_FIND_DATA *pPFSFindData;

		memset(pFindData, 0, 0x118); //sizeof
		int Len = TStrCpy(FileName, FullFileName); //??? Limit 260
		MAX_LIMIT(Len, MAX_FN_LEN-2);
		if (Len && FileName[Len-1] == '\\')
			TStrCat(FileName, "*");
		else	TStrCat(FileName, "\\*");

		TListIter<CPolyFS> It = m_PolyFSDisk.Begin();
		for (; It != m_PolyFSDisk.End(); ++It)
		{
			if (It->FindFirstFile(FileName, &FindData))
				break;
		}
		if (It == m_PolyFSDisk.End())
			return false;

		pPFSFindData = new MY_PFS_FIND_DATA;
		memcpy(&pPFSFindData->m_FindData, &FindData, sizeof(PFS_FIND_DATA));
		pPFSFindData->m_pPolyFS = &*It;
		pFindData->FindDataBuffer = pPFSFindData;
		TStrCpy(pFindData->FileName, pPFSFindData->m_FindData.FileName);
		pFindData->FileAttribute = 0;

		if (FindData.ThisFileEntry.Attribute & 0x04)
				pFindData->FileAttribute |= 0x01; //FILE_ATTRIBUTE_READONLY
		if (FindData.ThisFileEntry.Attribute & 0x08)
				pFindData->FileAttribute |= 0x02; //FILE_ATTRIBUTE_HIDDEN
		if (FindData.ThisFileEntry.Attribute & 0x10)
				pFindData->FileAttribute |= 0x04; //FILE_ATTRIBUTE_SYSTEM
		if (FindData.ThisFileEntry.Attribute & 0x01)
				pFindData->FileAttribute |= 0x10; //FILE_ATTRIBUTE_DIRECTORY
		if (FindData.ThisFileEntry.Attribute & 0x20)
				pFindData->FileAttribute |= 0x20; //FILE_ATTRIBUTE_ARCHIVE

		pFindData->FileLength = pPFSFindData->m_FindData.ThisFileEntry.FileSize;
		pFindData->hFindFile = 0;
		return true;
	}

	bool CPFSFileIO::FindNextFile(FILE_FIND_DATA *pFindData)
	{
		MY_PFS_FIND_DATA *pPFSFindData = (MY_PFS_FIND_DATA *)pFindData->FindDataBuffer;
		if (!pPFSFindData->m_pPolyFS->FindNextFile(&pPFSFindData->m_FindData))
			return false;

		TStrCpy(pFindData->FileName, pPFSFindData->m_FindData.FileName);
		pFindData->FileAttribute = 0;

		if (pPFSFindData->m_FindData.ThisFileEntry.Attribute & 0x04)
				pFindData->FileAttribute |= 0x01; //FILE_ATTRIBUTE_READONLY
		if (pPFSFindData->m_FindData.ThisFileEntry.Attribute & 0x08)
				pFindData->FileAttribute |= 0x02; //FILE_ATTRIBUTE_HIDDEN
		if (pPFSFindData->m_FindData.ThisFileEntry.Attribute & 0x10)
				pFindData->FileAttribute |= 0x04; //FILE_ATTRIBUTE_SYSTEM
		if (pPFSFindData->m_FindData.ThisFileEntry.Attribute & 0x01)
				pFindData->FileAttribute |= 0x10; //FILE_ATTRIBUTE_DIRECTORY
		if (pPFSFindData->m_FindData.ThisFileEntry.Attribute & 0x20)
				pFindData->FileAttribute |= 0x20; //FILE_ATTRIBUTE_ARCHIVE

		pFindData->FileLength = pPFSFindData->m_FindData.ThisFileEntry.FileSize;
		pFindData->hFindFile = 0;
		return true;
	}

	bool CPFSFileIO::FindClose(FILE_FIND_DATA *pFindData)
	{
		MY_PFS_FIND_DATA *pPFSFindData = (MY_PFS_FIND_DATA *)pFindData->FindDataBuffer;
		delete pPFSFindData;
		return true;
	}


```

`source/Code/polyfs.hpp`:

```hpp

#ifndef _POLYFS_HPP_
#define _POLYFS_HPP_

#include "define.h"
//#include "osdefine.hpp"
#include "imagefile.hpp"
#include "pagemem.hpp"
#include "fileio.hpp"
#include "handle.hpp"
#include "alt/altlist.hpp"

#define PFS_DIRECTORY	0x01
//0x02
#define PFS_READONLY	0x04
#define PFS_HIDDEN	0x08
#define PFS_SYSTEM	0x10
#define PFS_ARCHIVE	0x20


#pragma pack(push,1)
struct PFS_FILE_ENTRY //0x30
{
	unsigned long BeginClus;
	unsigned long FileSize;
	unsigned long Attribute;
	unsigned long NameCode;
	char FileName[32];
};
#pragma pack(pop)

#pragma pack(push,1)
struct PFS_FILE_DATA //0x68
{
	unsigned long FilePoint;
	unsigned long FileEntryFP;
	PFS_FILE_ENTRY ThisFileEntry;
	PFS_FILE_ENTRY ParentEntry;
};
#pragma pack(pop)

#pragma pack(push,1)
struct PFS_FIND_DATA //0x264
{
	char FileName[256];
	char PattenName[256];
	PFS_FILE_ENTRY ParentEntry;
	PFS_FILE_ENTRY ThisFileEntry;
	unsigned long FileEntryFP;
};
#pragma pack(pop)

#pragma pack(push,1)
struct PFS_HEAD //0x70
{
	char Sign[8];
	unsigned long ClusSize;
	unsigned long ClusCount;
	PFS_FILE_ENTRY FatEntry;
	PFS_FILE_ENTRY RootEntry;
};
#pragma pack(pop)

struct CPolyFS
{
	CPolyFS();
	virtual ~CPolyFS();

	CImageFile m_DiskImage;
	CPageMemory m_PageMemory;
	CFileIO *m_pFileIO;
	unsigned long m_MaxCachePageCount;
	unsigned long m_FatOff;
	unsigned long m_ClusSize;
	unsigned long m_ClusCount;
	unsigned int m_Style;
	PFS_FILE_ENTRY m_RootEntry;
	unsigned char *m_ZeroBuffer;

	bool ReadDiskFile(unsigned long Pos, void *Buffer, unsigned long Size);
	bool WriteDiskFile(unsigned long Pos, const void *Buffer, unsigned long Size);
	bool ReadClus(unsigned long Index, void *Buffer);
	bool WriteClus(unsigned long Index, const void *Buffer);
	bool ReadFatCell(unsigned long Index, void *Buffer);
	bool WriteFatCell(unsigned long Index, const void *Buffer);
	unsigned long FindFreeFileEntryFP(PFS_FILE_ENTRY *pParentEntry);
	unsigned long FindNextFreeClus(unsigned long ClusIdx);
	bool CreateFile(const char *FullFileName, unsigned long Attr, unsigned long Size, PFS_FILE_DATA *pHandleData);
	bool CreateFile(const char *FileName, unsigned long Attr, unsigned long Size, PFS_FILE_ENTRY *pParentDirEntry, unsigned long ParentFileEntryFP);
	unsigned long ReadFile(struct PFS_FILE_DATA *pHandleData, unsigned long Offset, void *Buffer, unsigned long Size);
	unsigned long ReadFile(struct PFS_FILE_ENTRY *pFileEntry, unsigned long Offset, void *Buffer, unsigned long Size);
	unsigned long WriteFile(struct PFS_FILE_DATA *pHandleData, unsigned long Offset, const void *Buffer, unsigned long Size);
	unsigned long WriteFile(struct PFS_FILE_ENTRY *pFileEntry, unsigned long Offset, const void *Buffer, unsigned long Size);
	bool DeleteFileClus(unsigned long BeginClus);
	unsigned long FileOffToDP(unsigned long ClusIndex, unsigned long Offset);
	unsigned long FileOffToClus(unsigned long ClusIndex, unsigned long Offset);
	bool CmpFileName(const char *FilePatternName, PFS_FILE_ENTRY *pFileEntry);
	void ChangeFileIO(CFileIO *pFileIO);

	virtual bool OpenDisk(const char *FileName, unsigned int Style);
	virtual void CloseDisk();
	virtual void InitParam();

	bool Format(const char*, unsigned long, unsigned long);

	bool DeleteFile(const char *FullFileName);

	bool FindFirstFile(const char *FullFileName, PFS_FIND_DATA *pFindData);
	bool FindNextFile(PFS_FIND_DATA *pFindData);

	bool OpenFile(const char *FullFileName, PFS_FILE_DATA *pHandleData);

	bool SetFileLength(const char *FileName, unsigned long Length);
	bool SetFileLength(PFS_FILE_DATA *pHandleData, unsigned long Length);
	unsigned long GetFileLength(const char *FileName);

	bool SetFileAttribute(const char *FileName, unsigned long Attr);
	unsigned long GetFileAttribute(const char *FileName);
};


struct MY_PFS_FILE_DATA
{
	CPolyFS *m_pPolyFS;
	PFS_FILE_DATA m_FileData;
};

struct MY_PFS_FIND_DATA
{
	CPolyFS *m_pPolyFS;
	PFS_FIND_DATA m_FindData;
};

struct CPFSFileIO : public CFileIO
{
	CHandle m_Handle;
	TList<CPolyFS> m_PolyFSDisk;
	CFileIO *m_pFileIO;

	CPFSFileIO();

	virtual bool OpenFile(const char *FileName, HANDLE *phFile, unsigned long Mode) override;
	virtual bool CreateFile(const char *FileName, HANDLE *phFile, unsigned long Mode) override;
	virtual bool CreateDir(const char *FileName) override;
	virtual bool CloseHandle(HANDLE hFile) override;
	virtual unsigned long ReadFile(HANDLE hFile, void *Buffer, unsigned long Size) override; //
	virtual unsigned long ReadFile(HANDLE hFile, void *Buffer, unsigned long Size, unsigned __int64 Offset) override;
	virtual unsigned long WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size) override; //
	virtual unsigned long WriteFile(HANDLE hFile, const void *Buffer, unsigned long Size, unsigned __int64 Offset) override;
	virtual unsigned __int64 SetFilePointer(HANDLE hFile, __int64 Offset, unsigned long Pos) override; //
	virtual unsigned __int64 GetFileLength(HANDLE hFile) override;
	virtual bool SetFileLength(HANDLE hFile, unsigned __int64 Length) override;
	virtual bool DeleteFile(const char *FileName) override;
	virtual bool RenameFile(const char *FileName, const char *NewFileName) override; //

	virtual bool SetFileAttr(const char *FileName, unsigned long Attr) override;
	virtual unsigned long GetFileAttr(const char *FileName) override;

	virtual bool IsDir(const char *FileName) override;
	virtual bool DeleteDir(const char *FileName) override;

	virtual bool FindFirstFile(const char *FileName, FILE_FIND_DATA *pFindData) override;
	virtual bool FindNextFile(FILE_FIND_DATA *pFindData) override;
	virtual bool FindClose(FILE_FIND_DATA *pFindData) override;

	void ChangeFileIO(CFileIO *pFileIO);

	virtual bool OpenDisk(const char *FileName, unsigned int Style);
	virtual void CloseDisk();
};

#endif


```

`source/Code/srctxtfile.cpp`:

```cpp

#include "srctxtfile.hpp"

	bool CSrcTXTFile::OpenEx(const char *FileName, HANDLE OpenHandle, unsigned long Mode)
	{
		if (!CImageFile::Open(FileName, OpenHandle))
			return false;

		char *Buffer = new char[m_FileSize+1];
		Buffer[m_FileSize] = 0;

		CImageFile::ReadFile(0, Buffer, m_FileSize);
		m_Mode = Mode;
		if (m_FileSize)
		{
			unsigned long Start = 0;
			unsigned long Index = 0;
			while (Index < m_FileSize)
			{
				if (Buffer[Index] == 13 || Buffer[Index] == 10)
				{
					unsigned long Skip = Index+1;
					if (Buffer[Index] == 13 && Buffer[Index+1] == 10)
						Skip = Index+2;
					
					unsigned long Len = ((m_Mode & 1) ? Skip : Index) - Start;
					char *Line = new char[Len+1];
					TStrNCpy(Line, &Buffer[Start], Len);
					Line[Len] = 0;
					m_StrList.Append(&Line);
					if (m_Mode & 2)
					{
						m_Lines.Append(&Start);
					}
					Start = Skip;
					Index = Skip;
				} else
				{
					++Index;
				}
			}

			if (Index != Start)
			{
				unsigned long Len = Index - Start;
				char *Line = new char[Len+1];
				TStrNCpy(Line, &Buffer[Start], Len);
				Line[Len] = 0;
				m_StrList.Append(&Line);
				if (m_Mode & 2)
				{
					m_Lines.Append(&Start);
				}
			}
		}
		delete []Buffer;
		return true;
	}

```

`source/Code/srctxtfile.hpp`:

```hpp

#ifndef _SRCTXTFILE_HPP_
#define _SRCTXTFILE_HPP_

#include "txtfile.hpp"

struct CSrcTXTFile : public CTXTFile
{
	TList<unsigned long> m_Lines;
	unsigned long m_Mode;

	bool OpenEx(const char *FileName, HANDLE OpenHandle, unsigned long Mode);
};

#endif
```

`source/Code/strmem.cpp`:

```cpp

#include "tstrmem.hpp"
//#include <windows.h>
#include "define.h"
//#include "osdefine.hpp"

int TVSPrintf(char *buffer, const char *format, va_list ParamList)
{
	return TVSPrintf_(buffer, format, ParamList);
}

int TVSPrintf(WCHAR *buffer, const WCHAR *format, va_list ParamList)
{
	return TVSPrintf_(buffer, format, ParamList);
}

/*
static char * InvalidVarStr = " \|-={}[]/?*,:.&^%$#@!~`();"<>^"
.data:0006D8F8 ?InvalidVarStr@@3PADA db ' \|-={}[]/?*,:.&^%$#@!~`();"<>^',0

int TStrPrint(char *pStr, int Count)
{
	int Len = 0;

	while ( *pStr && Count )
	{
		if (TStrChr(InvalidVarStr, *pStr))
			*pStr = '_';
		++pStr;
		--Count;
		++Len;
	}
	*pStr = 0;
	return Len;
}
*/

int UnicodeToAnsi(const WCHAR *WszBuf, char *szBuf, int MaxLen)
{
	int Length = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)WszBuf, -1, szBuf, MaxLen, nullptr, nullptr);
	if (Length)
		return Length - 1;
	return 0;
}

int AnsiToUnicode(const char *szBuf, WCHAR *WszBuf, int MaxLen)
{
	int Length = MultiByteToWideChar(CP_ACP, 0, szBuf, -1, (LPWSTR)WszBuf, MaxLen);
	if (Length)
		return Length - 1;
	return 0;
}

	bool IS_PRINT(unsigned char Char)
	{
		return Char >= 0x20 && Char <= 0x7F;
	}

	bool UNormalize(char *InBuffer, unsigned long InLen, char *OutBuffer, unsigned long MaxOutLen, unsigned long *Len)
	{
		unsigned long total = 0;
		*OutBuffer = 0;
		bool rOK = true;
		unsigned long i = 0;
		while (i < InLen && total < MaxOutLen - 2)
		{
			char Char = InBuffer[i];
			if (Char == 0 && InBuffer[i+1] == 0) break;
			switch (Char)
			{
			case '\r': *OutBuffer++ = '\\'; *OutBuffer++ = 0;
				   *OutBuffer++ = 'r'; *OutBuffer++ = 0; total += 4; break;
			case '\n': *OutBuffer++ = '\\'; *OutBuffer++ = 0;
				   *OutBuffer++ = 'n'; *OutBuffer++ = 0; total += 4; break;
			case '\t': *OutBuffer++ = '\\'; *OutBuffer++ = 0;
				   *OutBuffer++ = 't'; *OutBuffer++ = 0; total += 4; break;
			default:
				if (IS_PRINT(Char))
				{
					*OutBuffer++ = Char;
					if (InBuffer[i+1] == 0)
					{
						*OutBuffer++ = 0; total += 2;
					} else
					{
						rOK = false;
						break;
					}
				}
				break;
			}
			i += 2;
		}

		if (total == 0)
			rOK = false;
		*OutBuffer++ = 0;
		*OutBuffer++ = 0;
		if (rOK)
		{
			if (i < InLen)
			{
				total += 2;
			} else
			{
				TStrCpy(&OutBuffer[InLen - 2], " ...");
				total = InLen;
			}
		}
		if (Len) *Len = total;
		return rOK;
	}

	bool ANormalize(char *InBuffer, unsigned long InLen, char *OutBuffer, unsigned long MaxOutLen, unsigned long *Len)
	{
		unsigned long total = 0;
		*OutBuffer = 0;
		bool rOK = true;
		unsigned long  i = 0;
		while (i < InLen && total < MaxOutLen - 2)
		{
			char Char = InBuffer[i];
			if (Char == 0) break;
			switch (Char)
			{
			case '\r': *OutBuffer++ = '\\'; *OutBuffer++ = 'r'; total += 2; break;
			case '\n': *OutBuffer++ = '\\'; *OutBuffer++ = 'n'; total += 2; break;
			case '\t': *OutBuffer++ = '\\'; *OutBuffer++ = 't'; total += 2; break;
			default:
				if (IS_PRINT(Char))
				{
					*OutBuffer++ = Char; total += 1;
				} else
				{
					rOK = false;
				}
				break;
			}
			i += 1;
		}

		if (total == 0)
			rOK = false;
		*OutBuffer = 0;
		if (rOK)
		{
			if (i < InLen)
			{
				total += 1;
			} else
			{
				TStrCpy(&OutBuffer[InLen - 4], " ...");
				total = InLen;
			}
		}
		if (Len) *Len = total;
		return rOK;
	}

```

`source/Code/sysdep.cpp`:

```cpp

#include "sysdep.hpp"
#include "tstrmem.hpp"
#include <windows.h>

int GetModulePath(char *szPathName, bool bSeparator)
{
	*szPathName = 0;
	GetModuleFileNameA(0, szPathName, MAX_FN_LEN);
	if (szPathName[1] == ':')
	{
		MAKE_CHAR_UPPER(szPathName[0]);
	}

	char *sep = TStrRChr(szPathName, '\\');
	if (sep)
	{
		if (bSeparator) ++sep;
		*sep = 0;
	}
	return TStrLen(szPathName);
}

int GetModulePath(WCHAR *szPathName, bool bSeparator)
{
	*szPathName = 0;
	GetModuleFileNameW(0, szPathName, MAX_FN_LEN);
	if (szPathName[1] == ':')
	{
		MAKE_CHAR_UPPER(szPathName[0]);
	}

	WCHAR *sep = TStrRChr(szPathName, L'\\');
	if (sep)
	{
		if (bSeparator) ++sep;
		*sep = 0;
	}
	return TStrLen(szPathName);
}

int DebugPrintf(const char *format, ...)
{
	char OutputString[1024];
	va_list Next;
	va_start(Next, format);
	int Len = TVSPrintf(OutputString, format, Next);
	va_end(Next);
	OutputDebugStringA(OutputString);
	return Len;
}

int DebugPrintf(const WCHAR *format, ...)
{
	WCHAR OutputString[1024];
	va_list Next;
	va_start(Next, format);
	int Len = TVSPrintf(OutputString, format, Next);
	va_end(Next);
	OutputDebugStringW(OutputString);
	return Len;
}

//?gRandomMem@@3PAKA 27x5 = 135 + 2
unsigned long gRandomMem[] = {
	0x5A2B2E15, 0x15562E15, 0x9742A171, 0x8515582E, 0x0F510693,
	0x0708C533, 0x14C80E0B, 0xFE161780, 0x712A3DC2, 0xEB494746,
	0x08F9900A, 0xF7B908D0, 0x0384D5B6, 0x1B212C2B, 0x2022743F,
	0x3416E197, 0x06777BC9, 0xBAB7C768, 0xE9837D6B, 0x2AF10303,
	0xA6D7EB26, 0xE103EB3E, 0x90B7D0BD, 0x59CDE23D, 0x25EBEB07,
	0x0A4A0690, 0x1207C337, 0x6920EE83, 0x690B739E, 0xEDDA9417,
	0x6010EB06, 0x55F2E920, 0xE959CBF4, 0x089DF8FD, 0x525706F9,
	0x43C35351, 0xFE9BB757, 0x5BE2809A, 0x4315191D, 0x34DBC2FB,
	0x0F740504, 0x74280B52, 0x0D820552, 0x4C5CDFFC, 0x1E8DAB6E,
	0x058A0E79, 0x0B72803C, 0xBADF5154, 0x776B6E07, 0x30D77509,
	0x36E68A24, 0x76B669A1, 0x3B03FDB3, 0x18721A44, 0x721E6708,
	0x650A1F0F, 0x6C0BFF46, 0xEB2D721C, 0x58F99002, 0x5F5A595B,
	0xE23BB494, 0x1E0CECB7, 0x160AB907, 0x0DEA75AE, 0x1B7FB26C,
	0xE0090666, 0x0000DAEB, 0x76DA06FF, 0x02F9DB83, 0xFE012A40,
	0x6A0B0807, 0x0FEC5A2E, 0xC9706854, 0x0B40C803, 0x6D555419,
	0x0ADDB179, 0x2073037D, 0x6968116F, 0x1F6E6407, 0xFFDE61A1,
	0x54204350, 0x59736C27, 0x2DE40D43, 0x2EA36370, 0x9D5DC358,
	0x1E2F06D4, 0x8071B569, 0x2F701B11, 0x7F014B70, 0x1A7307C2,
	0x2A7550D9, 0xC52C2C52, 0xEAC518B8, 0x16431995, 0x63226066,
	0xDC0C0BB7, 0x08CE0EE2, 0x0283C010, 0xDB40CCE9, 0x5A0C940C,
	0xB78A50B8, 0x8781B15E, 0xD6821CB4, 0xBDA35C16, 0xFE15EEFD,
	0x0E8920C2, 0xF9810352, 0xB90373CE, 0xB6EC4F04, 0x320E7037,
	0x8A0354DD, 0x095C0507, 0x36230327, 0xEF1C49DD, 0x085F7789,
	0x2DAF4E97, 0x2C1EC524, 0xF8A67060, 0x28E09740, 0x032A9303,
	0xDB80AD79, 0x730470B6, 0xBB23A886, 0x0E6E344C, 0x4D1544DE,
	0x6B754EA6, 0x1ADB6E82, 0x6A39A52C, 0x0D176109, 0xDA1B7313,
	0x570954B6, 0x745F0E13, 0x1D22E44F, 0xFE7F8DDD, 0x123C1975,
	0, 0
	};

```

`source/Code/sysdep.hpp`:

```hpp

#ifndef _SYSDEP_HPP_
#define _SYSDEP_HPP_

#include "define.h"

int GetModulePath(char *szPathName, bool bSeparator);
int GetModulePath(WCHAR *szPathName, bool bSeparator);
int DebugPrintf(const char *format, ...);
int DebugPrintf(const WCHAR *format, ...);
#endif
```

`source/Code/time.cpp`:

```cpp

#include "time.hpp"
#include "tstrmem.hpp"

	bool IsLeapYear(int Year) { return (!(Year & 3) && Year != (Year/100)*100) || Year == (Year/400)*400; }
	int LeapYears(int Year) { return (Year/4) - Year/100 + Year/400 - 477; }

	char *Time2Str(unsigned long TimeStamp, char *szBuffer)
	{
		int DayInMonth[12] = {31,28,31,30,31,30,31,31,30,31,30,31};

		unsigned long nHour = TimeStamp / 86400;
		unsigned long Hour = TimeStamp % 86400 / 3600;
		unsigned long nMinute = TimeStamp % 86400 % 3600;
		unsigned long Minute = nMinute / 60;
		unsigned long Year = TimeStamp / 86400 / 365 + 1970;
		unsigned long Second = nMinute % 60;
		unsigned long nDays = TimeStamp / 86400 % 365;
		unsigned long nDaysLeapYear = LeapYears(Year); //(Year/4) - Year/100 + Year/400 - 477;
		if (IsLeapYear(Year))// (!(Year & 3) && Year != (Year/100)*100) || Year == (Year/400)*400)
			--nDaysLeapYear;

		if (nDays < nDaysLeapYear)
			--Year;

		unsigned long v7 = 365*(Year-1970) + LeapYears(Year); //(Year/4) - Year/100 + Year/400 - 477;
		if (IsLeapYear(Year))//  (!(Year & 3) && Year != (Year/100)*100) || Year == (Year/400)*400)
		{
			--v7;
			DayInMonth[1] = 29;
		}

		unsigned long Day = nHour - v7;
		unsigned long Month;
		for (Month = 0; Month < 12; ++Month)
		{
			unsigned long v10 = DayInMonth[Month];
			if (Day < v10) break;
			Day -= v10;
		}
		TSPrintf(szBuffer, "%02d/%02d/%d %02d:%02d:%02d",
			(unsigned short)(Day + 1), (unsigned short)(Month + 1), (unsigned short)Year,
			(unsigned short)Hour, (unsigned short)Minute, (unsigned short)Second);
		return szBuffer;
	}

```

`source/Code/time.hpp`:

```hpp

#ifndef _TIME_HPP_
#define _TIME_HPP_

char *Time2Str(unsigned long TimeStamp, char *szBuffer);

#endif
```

`source/Code/tstrmem.hpp`:

```hpp

#ifndef _TSTRMEM_HPP_
#define _TSTRMEM_HPP_

#include <stdarg.h>
#include "define.h"
#include "alt/altfile.hpp"

int UnicodeToAnsi(const WCHAR *WszBuf, char *szBuf, int MaxLen);
int AnsiToUnicode(const char *szBuf, WCHAR *WszBuf, int MaxLen);

bool UNormalize(char *InBuffer, unsigned long InLen, char *OutBuffer, unsigned long MaxOutLen, unsigned long *Len);
bool ANormalize(char *InBuffer, unsigned long InLen, char *OutBuffer, unsigned long MaxOutLen, unsigned long *Len);

	template<class T>
	inline T *TMemCpy(T *dst, const T *src, int count)
	{
		T *ret = dst;
		//if (dst && src) //???
		while (count) --count,*dst++ = *src++;
		return ret;
	}

	template<class T, class R>
	inline int TMemICmp(const T *dst, const R *src, int count)
	{
		char l = 0;//T l; //???
		char r = 0;//R r; //f;

		//if (dst && src) //???
		while (count && l == r)
		{
			--count;
			l = *dst++; MAKE_CHAR_LOWER(l);
			r = *src++; MAKE_CHAR_LOWER(r);
		}
		return l - r;
#if 0
		while (count && *dst && ((*dst|32) == (*src|32))) { --count; ++dst; ++src; }
		return *dst - *src;
#endif
	}

	//TAB

	template<class T>
	inline T *TMemSet(T *dst, T val, int count)
	{
		T *start = dst;
		//if (dst) //???
		while (count--) *start++ = val;
		return dst;
	}

	template<class T, class S>
	inline int TStrCpy(T *dst, const S *src)
	{
		int len = 0;
		T *cp;
		if (dst && src)	while ((*dst++=*src++) != (T)0) ++len; //copy \0
		return len;
	}

	template<class T>
	inline T *TStrNCpy(T *dst, const T *src, int count)
	{
		T *start = dst;
		if (dst && src && count > 0)
		{
			while ((*dst++=*src++) != (T)0 && count--); //copy \0
			while (count>0) *dst++ = 0,count--;
		}
		return start;
	}

	template<class T>
	inline int TStrLen(const T *str)
	{
		if (!str) return 0;
		const T *eos = str;
		while (*eos++);
		return eos-str-1;
	}

	template<class T, class S>
	inline T *TStrCat(T *dst, const S *src)
	{
		if (dst && src)
		{
			T *cp = dst; while (*cp) ++cp;
			while ((*cp++ = *src++) != (T)0);
		}
		return dst;
	}

	template<class T, class R>
	inline T *TStrChr(const T *string, R ch) //class R char
	{
		if (!string) return NULL;

	while (*string && *string != ch) string++;
//	return (T*)string;
	return *string == ch ? (T*)string : (T*)0;

//		while (*string) { if (*string == ch) return string; else ++string; }
//		return ch ? 0 : string;
	}

	template<class T>
	inline T *TStrIChr(const T *string, T ch)
	{
		if (!IS_LETTER(ch)) return TStrChr(string, ch);

		if (!string) return NULL;
		T LChar = LOWER_CHAR(ch);
		T UChar = UPPER_CHAR(ch);
	while (*string && (*string != LChar && *string != UChar)) string++;
//	while (*string && (*string != ch && *string != LChar)) string++;
//	return (T*)string;
	return *string == ch ? (T*)string : (T*)0;

//		while (*string) { if (*string == ch) return string; else ++string; }
//		return ch ? 0 : string;
	}

	template<class T>
	inline T *TStrRChr(const T *string, char ch)
	{
		T *start = (T*)string;
		while (*start++);
		while (--start != string && *start != ch);
		return *start == ch ? (T*)start : (T*)0;
	}

	template<class T>
	inline T *TStrRChr(const T *string, const T *start, char ch)
	{
	//	T *start = (T*)string;
	//	while (*start++);
		while (--start != string && *start != ch);
		return *start == ch ? (T*)start : (T*)0;
	}

	template<class T, class R>
	inline int TStrCmp(const T *dst, const R *src)
	{
	#if 1
		if (!dst || !src)
		{
			if (!dst && src) return -(R)*src;
			if (dst && !src) return (T)*dst;
			return 0;
		}
	#else
		if (!dst)
		{
			if (src) return -(R)*src;
			return 0;
		}
		if (!src) return *dst;
	#endif
		int ret = 0;
		while (*dst && (*dst == *src)) { ++dst; ++src; } //== |
		ret = *dst - *src;
		//return ret < 0 ? -1 : (ret > 0 ? 1 : 0);
		if (ret < 0) return -1;
		if (ret > 0) return 1;
		return 0;
	}

	template<class T>
	inline int TStrNCmp(const T *dst, const T *src, int count)
	{
		if (!count) return 0;
	#if 1
		if (!dst || !src)
		{
			if (!dst && src) return -(T)*src;
			if (dst && !src) return (T)*dst;
			return 0;
		}
	#else
		if (!dst)
		{
			if (src) return -(T)*src;
			return 0;
		}
		if (!src) return *dst;
	#endif
		int ret = 0;
		while (--count && *dst && (*dst == *src)) { ++dst; ++src; } //== |
		ret = *dst - *src;
		//return ret < 0 ? -1 : (ret > 0 ? 1 : 0);
		if (ret < 0) return -1;
		if (ret > 0) return 1;
		return 0;
	}

	template<class T, class R>
	inline int TStrICmp(const T *dst, const R *src)
	{
		char l;//T l;
		char r;//R r; //f;
	#if 1
		if (!dst || !src)
		{
			if (!dst && src) return -(R)*src;
			if (dst && !src) return (T)*dst;
			return 0;
		}
	#else
		if (!dst)
		{
			if (src) return -(T)*src;
			return 0;
		}
		if (!src) return *dst;
	#endif
#if 0
		while (*dst && ((*dst|32) == (*src|32))) { ++dst; ++src; }
		return *dst - *src;
#else
		do {
			l = *dst++; MAKE_CHAR_LOWER(l);
			r = *src++; MAKE_CHAR_LOWER(r);
		} while (l && l == r);
		return l - r;
#endif
	}

	template<class T, class R>
	inline int TStrNICmp(const T *dst, const R *src, int count) //TODO check cmp
	{
		char l;//T l; //???
		char r;//R r; //f;

		if (!count) return 0;
	#if 1
		if (!dst || !src)
		{
			if (!dst && src) return -(R)*src;
			if (dst && !src) return (T)*dst;
			return 0;
		}
	#else
		if (!dst)
		{
			if (src) return -(R)*src;
			return 0;
		}
		if (!src) return *dst;
	#endif
#if 0
		while (count && *dst && ((*dst|32) == (*src|32))) { --count; ++dst; ++src; }
		return *dst - *src;
#else
		do {
			l = *dst++; MAKE_CHAR_LOWER(l);
			r = *src++; MAKE_CHAR_LOWER(r);
		} while (--count && l && l == r);
		return l - r;
#endif
	}

	template<class T>
	inline T *TStrUpr(T *string)
	{
		if (!string) return NULL;
		for (T *cp = string; *cp; ++cp) MAKE_CHAR_UPPER(*cp); //TODO cast letter
		return string;
	}

	template<class T>
	inline T *TStrLwr(T *string)
	{
		if (!string) return NULL;
		for (T *cp = string; *cp; ++cp) MAKE_CHAR_LOWER(*cp); //TODO cast letter
		return string;
	}

	template<class T, class S>
	inline int TStrToStr(const T *Src, S *Des)
	{
		int Count = 0;
		if (Src && Des)
		{
			while (Src[Count]) Des[Count]=Src[Count],++Count;
			Des[Count] = 0;
		}
		return Count;
	}

	template<class T, class S>
	inline int TStrToPrint(const T *Src, S *Des, int Len)
	{
		int Count = 0;
		for (Count=0;Count<Len;++Count)
		{
			Des[Count]=Src[Count]<32?46:Src[Count];
		}
		Des[Count] = 0;
		return Count;
	}

	template<class T>
	inline int TStrFillTail(T *Str, int MaxLen, T FillChar)
	{
		int StrLen = TStrLen(Str);
		if (StrLen < MaxLen)
		{
			TMemSet(&Str[StrLen], FillChar, MaxLen - StrLen);
			Str[MaxLen] = 0;
			StrLen = MaxLen;
		}
		return StrLen;
	}

	template<class T, class S>
	inline int TStrCpyLimit(T *Des, const S *Src, int Limit)
	{
		int Len = 0;
		while (*Src && (Len < Limit-1)) *Des++ = *Src++, ++Len;
		*Des = 0;
		return Len;
	}

	inline int TStrOmit(const WCHAR *Src, WCHAR *Des, int MaxLen)
	{
		int i = MaxLen - 1;
		if (i <= 0 || !Src || !Des)
			return 0;

		int StrLen = TStrLen(Src);
		if (StrLen > i)
		{
			TStrCpyLimit(Des, Src, MaxLen);
			Des[i - 1] = '.';
			Des[i - 2] = '.';
			Des[i - 3] = '.';
			return i;
		}
		TStrCpy(Des, Src);
		return StrLen;
	}

	template<class T>
	bool ConvertFileNameByMacro(T *FileName, const T *szMacro, const T *szMacroStr)
	{
		int Len = TStrLen(szMacro);
		if (TStrNICmp(FileName, szMacro, Len)==0)
		{
			T szBuffer[MAX_FN_LEN];
			TStrCpy(szBuffer, &FileName[Len]);
			TStrCpy(FileName, szMacroStr);
			TStrCat(FileName, szBuffer);
			return true;
		}
		return false;
	}

	//TAB

	template<class T>
	inline T *TGetFileName(const T *szFullName)
	{
		if (!*szFullName) return NULL;
		T *pStr = TStrRChr(szFullName, '\\');
		if (!pStr) return (T*)szFullName;
		return pStr+1;
	}

	template<class T>
	inline T *TGetFileExt(const T *szFullName)
	{
		T *pFullName = TGetFileName(szFullName);
		if (!pFullName) return NULL;
		T *pStr = TStrRChr(pFullName, '.');
		if (!pStr) return NULL;
		++pStr;
		if (!*pStr) return NULL;
		return pStr;
	}

	//TAB

	template<class T>
	inline int TGetFileTitle(const T *szFullName, T *szTitle)
	{
		if (!szTitle) return 0;
		T *pStr = TGetFileName(szFullName);
		if (!pStr) { *szTitle = 0; return 0; }
		T *pDot = TStrRChr(pStr, '.');
		if (!pDot) return TStrCpy(szTitle, pStr);
		int Length = pDot - pStr;
		TMemCpy(szTitle, pStr, Length);
		szTitle[Length] = 0;
		return Length;
	}

	template<class T>
	inline int TGetFilePath(const T *szFullName, T *szPath)
	{
		T *pStr = TGetFileName(szFullName);
		if (!pStr) return TStrCpy(szPath, szFullName);
		int Length = pStr - szFullName;
		if (Length > 0) Length--;
		TMemCpy(szPath, szFullName, Length);
		szPath[Length] = 0;
		return Length;
	}

	template<class T, class S>
	inline bool TCmpModuleName(const T *FileName, const S *ModuleName)
	{
		T FileCmpName[512];
		S ModuleCmpName[512];

		if (TStrRChr(ModuleName, '\\'))
			return TStrICmp(FileName, ModuleName) == 0;
		T *pStr = TStrRChr(ModuleName, '.');
		if (pStr && !TStrRChr(FileName, '.'))
			pStr = NULL;
		if (pStr)
		{
			TStrCpy(FileCmpName, TGetFileName(FileName));
			TStrCpy(ModuleCmpName, TGetFileName(ModuleName));
		} else
		{
			TGetFileTitle(FileName, FileCmpName);
			TGetFileTitle(ModuleName, ModuleCmpName);
		}
		return TStrICmp(FileCmpName, ModuleCmpName) == 0;
	}

	template<class T, class S>
	T *uNumToStr(S Num, T *String, int Radix);

	template<class T, class S>
	T *NumToStr(S Num, T *String, int Radix);

	int TVSPrintf(char *buffer, const char *format, va_list ParamList);
	int TVSPrintf(WCHAR *buffer, const WCHAR *format, va_list ParamList);

	template<class T>
	inline int TSPrintf(T *buffer, const T *format, ...)
	{
		va_list next;
		va_start(next, format);
		int ret = TVSPrintf(buffer, format, next);
		va_end(next);
		return ret;
	}

#define ZEROPAD		(1<<0)	/* Pad with zero */
#define SIGN		(1<<1)	/* Unsigned/signed long */
#define PLUS		(1<<2)	/* Show plus */
#define SPACE		(1<<3)	/* Spacer */
#define LEFT		(1<<4)	/* Left justified */
#define HEX_PREP	(1<<5)	/* 0x */
#define UPPERCASE	(1<<6)	/* 'ABCDEF' */

#define HAS_FLOAT
#ifdef HAS_FLOAT
#if 1
	extern "C" double __cdecl modf(double,double*);
#else
	extern "C" {
	#include <math.h>
	}

	#ifdef _RING0_
	extern "C" double __cdecl _modf_default(double,double*);
	#define modf _modf_default
	#endif
#endif
	#include <float.h>
	//http://www.jbox.dk/sanos/source/lib/fcvt.c.html
	#define CVTBUFSIZE  2 * DBL_MAX_10_EXP + 10

	template<class T>
	T *cvt(double arg, int ndigits, int *decpt, int *sign, T *buf, int eflag)
	{
		int r2;
		double fi, fj;
		T *p, *p1;
 
		if (ndigits >= CVTBUFSIZE - 1) ndigits = CVTBUFSIZE - 2;
		r2 = 0;
		*sign = 0;
		p = &buf[0];
		if (arg < 0)
		{
			*sign = 1;
			arg = -arg;
		}
		arg = modf(arg, &fi);
		p1 = &buf[CVTBUFSIZE];
 
		if (fi != 0)
		{
			p1 = &buf[CVTBUFSIZE];
			while (fi != 0)
			{
				fj = modf(fi / 10, &fi);
				*--p1 = (int)((fj + .03) * 10) + '0';
				r2++;
			} while (p1 < &buf[CVTBUFSIZE]) *p++ = *p1++;
		} else
		if (arg > 0)
		{
			while ((fj = arg * 10) < 1)
			{
				arg = fj;
				r2--;
			}
		}
		p1 = &buf[ndigits];
		if (eflag == 0) p1 += r2;
		*decpt = r2;
		if (p1 < &buf[0])
		{
			buf[0] = '\0';
			return buf;
		}
		while (p <= p1 && p < &buf[CVTBUFSIZE])
		{
			arg *= 10;
			arg = modf(arg, &fj);
			*p++ = (int) fj + '0';
		}
		if (p1 >= &buf[CVTBUFSIZE])
		{
			buf[CVTBUFSIZE - 1] = '\0';
			return buf;
		}
		p = p1;
		*p1 += 5;
		while (*p1 > '9')
		{
			*p1 = '0';
			if (p1 > buf)
				++*--p1;
			else
			{
				*p1 = '1';
				(*decpt)++;
				if (eflag == 0)
				{
					if (p > buf) *p = '0';
					p++;
				}
			}
		}
		*p = '\0';
		return buf;
	}
 
	template<class T>
	T *ecvtbuf(double arg, int ndigits, int *decpt, int *sign, T *buf)
	{
		return cvt(arg, ndigits, decpt, sign, buf, 1);
	}

	template<class T>
	T *fcvtbuf(double arg, int ndigits, int *decpt, int *sign, T *buf)
	{
		return cvt(arg, ndigits, decpt, sign, buf, 0);
	}

	//TMemCpy
 	template<class T>
	void ee_bufcpy(T *pd, T *ps, int count) {
		T *pe=ps+count;
		while (ps!=pe)
			*pd++=*ps++;
	}

	template<class T>
	void parse_float(double value, T *buffer, T fmt, int precision)
	{
		int decpt, sign, exp, pos;
		T *fdigits = NULL;
		T cvtbuf[80];
		int capexp = 0;
		int magnitude;

		if (fmt == 'G' || fmt == 'E')
		{
			capexp = 1;
			fmt += (T)'a' - 'A';
		}

		if (fmt == 'g')
		{
			fdigits = ecvtbuf(value, precision, &decpt, &sign, cvtbuf);
			magnitude = decpt - 1;
			if (magnitude < -4  ||  magnitude > precision - 1)
			{
				fmt = 'e';
				precision -= 1;
			} else
			{
				fmt = 'f';
				precision -= decpt;
			}
		}

		if (fmt == 'e')
		{
			fdigits = ecvtbuf(value, precision + 1, &decpt, &sign, cvtbuf);

			if (sign) *buffer++ = '-';
			*buffer++ = *fdigits;
			if (precision > 0) *buffer++ = '.';
			ee_bufcpy(buffer, fdigits + 1, precision); //TMemCpy(buffer, fdigits + 1, precision);
			buffer += precision;
			*buffer++ = capexp ? 'E' : 'e';

			if (decpt == 0)
			{
				if (value == 0.0)
					exp = 0;
				else
					exp = -1;
			} else
				exp = decpt - 1;

			if (exp < 0)
			{
				*buffer++ = '-';
				exp = -exp;
			} else
				*buffer++ = '+';

			buffer[2] = (exp % 10) + '0';
			exp = exp / 10;
			buffer[1] = (exp % 10) + '0';
			exp = exp / 10;
			buffer[0] = (exp % 10) + '0';
			buffer += 3;
		} else
		if (fmt == 'f')
		{
			fdigits = fcvtbuf(value, precision, &decpt, &sign, cvtbuf);
			if (sign) *buffer++ = '-';
			if (*fdigits)
			{
				if (decpt <= 0)
				{
					*buffer++ = '0';
					*buffer++ = '.';
					for (pos = 0; pos < -decpt; pos++) *buffer++ = '0';
					while (*fdigits) *buffer++ = *fdigits++;
				} else
				{
					pos = 0;
					while (*fdigits)
					{
						if (pos++ == decpt) *buffer++ = '.';
						*buffer++ = *fdigits++;
					}
				}
			} else
			{
				*buffer++ = '0';
				if (precision > 0)
				{
					*buffer++ = '.';
					for (pos = 0; pos < precision; pos++) *buffer++ = '0';
				}
			}
		}

		*buffer = '\0';
	}

	template<class T>
	void decimal_point(T *buffer)
	{
		while (*buffer)
		{
			if (*buffer == '.') return;
			if (*buffer == 'e' || *buffer == 'E') break;
			buffer++;
		}

		if (*buffer)
		{
			int n = TStrLen(buffer);
			while (n > 0) 
			{
				buffer[n + 1] = buffer[n];
				n--;
			}

			*buffer = '.';
		} else
		{
			*buffer++ = '.';
			*buffer = '\0';
		}
	}

	template<class T>
	void cropzeros(T *buffer)
	{
		while (*buffer && *buffer != '.') buffer++;
		if (*buffer++)
		{
			while (*buffer && *buffer != 'e' && *buffer != 'E') buffer++;
			T *stop = buffer--;
			while (*buffer == '0') buffer--;
			if (*buffer == '.') buffer--;
			//while (buffer!=stop)
			//	*++buffer=0;
			TStrCpy(stop, buffer);
		}
	}

	template<class T>
	T *flt(T *str, double num, int size, int precision, T fmt, int flags)
	{
		T tmp[80];
		//T c, sign;
		//int n, i;

		// Left align means no zero padding
		if (flags & LEFT) flags &= ~ZEROPAD;

		// Determine padding and sign char
		T c = (flags & ZEROPAD) ? '0' : ' ';
		T sign = 0;
		if (flags & SIGN)
		{
			if (num < 0.0)
			{
				sign = '-';
				num = -num;
				size--;
			} else
			if (flags & PLUS)
			{
				sign = '+';
				size--;
			} else
			if (flags & SPACE)
			{
				sign = ' ';
				size--;
			}
		}

		// Compute the precision value
		if (precision < 0)
			precision = 6; // Default precision: 6

		// Convert floating point number to text
		parse_float(num, tmp, fmt, precision);

		if ((flags & HEX_PREP) && precision == 0) decimal_point(tmp);
		if (fmt == 'g' && !(flags & HEX_PREP)) cropzeros(tmp);

		int n = TStrLen(tmp);

		// Output number with alignment and padding
		size -= n;
		if (!(flags & (ZEROPAD | LEFT)))
			while (size-- > 0) *str++ = ' '; //if (size>0) { TMemSet(str, ' ', size); str += size*2; }
		if (sign) *str++ = sign;
		if (!(flags & LEFT))
			while (size-- > 0) *str++ = c; //if (size>0) { TMemSet(str, c, size); str += size*2; }
		for (int i = 0; i < n; i++) *str++ = tmp[i];
		while (size-- > 0) *str++ = ' '; //if (size>0) { TMemSet(str, ' ', size); str += size*2; }

		return str;
	}
#endif

	//https://github.com/jpbonn/coremark_lm32/blob/master/ee_printf.c
	#include <stdarg.h>

	#define LITERAL(T,x) CString_traits<T>::choose(x, L##x)

	template<typename T>
	struct CString_traits
	{
		typedef char char_type;
		static const char *choose(const char *narrow, const WCHAR *wide) { return narrow; }
		//static char choose(char narrow, wchar_t wide) { return narrow; }
	};

	template<>
	struct CString_traits<WCHAR>
	{
		typedef WCHAR char_type;
		static const WCHAR *choose(const char *narrow, const WCHAR *wide) { return wide; }
		//static WCHAR choose(char narrow, wchar_t wide) { return wide; }
	};


	template<class T>
	inline int TVSPrintf_(T *buffer, const T *format, va_list Next)//ParamList)
	{
		//EmitNumber
		//EmitString
		//Done

		const T *str;
		bool bIsShort;
		static const T *strSub = LITERAL(T, "-");//[2];
		static const T *strSpace = LITERAL(T, " ");//[2];
		static const T *strZero = LITERAL(T, "0");//[2];
		int Precision;
		bool bLeftJustify;
		bool bIsLong;
		bool bMore;
		bool bPlusSign;
		T * savestr;
		T strbuf[1025]; //??? increase 36
		bool bZeroPrefix;
	//	va_list Next;
		static const T *str0X = LITERAL(T, "0X");//[3];
		unsigned long val;
		static const T *strPlus = LITERAL(T, "+");//[2];
		int Flags;
		T cPad;
		static const T *strNULL = LITERAL(T, "");//[1];
		int len;
		__int64 val64;
		bool bBlankSign;
		bool bIsLonglong;
		int Length;
		int Width;
		int nPad;
		static const T *strError = LITERAL(T, "<Error>");//[8];
		int nLeadingZeros;
		const T * sPrefix;
		static const T *str0x = LITERAL(T, "0X");//[3];

	#define OutPut(x,y)	(if (x) *x++ = *y;)

		//Next = ParamList;

		Length = 0;
		while (*format)
		{
			if (*format != '%')
			{
				if (buffer) *buffer++ = *format;
				++Length;
				++format;
				continue;
			}

			Width = 0;
			Precision = -1;
			bLeftJustify = false;
			bPlusSign = false;
			bBlankSign = false;
			bZeroPrefix = false;
			bIsLonglong = false;
			Flags = 0;
			cPad = 0x20;
			sPrefix = strNULL;

			format++;

			bool bMore = true;
			while (bMore)
			{
				switch (*format)
				{
				case ' ': /*Width = 0;*/ bBlankSign = true; format++; Flags |= SPACE; break;
				case '#': bZeroPrefix = true; format++; Flags |= HEX_PREP; break;
				case '+': bPlusSign = true; format++; Flags |= PLUS; break;
				case '-': /*Width = 0;*/ bLeftJustify = true; format++; Flags |= LEFT; break;
				case '0': cPad = '0'; format++; Flags |= ZEROPAD; break;
				default: bMore = false; break;
				}
			}

			if (*format == '*')
			{
				Width = va_arg(Next, int);
				format++;
				if (Width < 0)
				{
					Width = 0;
					bLeftJustify = true;
					Flags |= LEFT;
				}
			} else
			if (IS_DIGIT(*format))
			{
				while (IS_DIGIT(*format))
					Width = 10 * Width + *format++ - '0';
			}

			//switch TODO
			if (*format == '.')
			{
				format++;
				Precision = 0;
				if (*format == '*')
				{
					Precision = va_arg(Next, int);
					format++;
				} else
				{
					while (IS_DIGIT(*format))
						Precision = 10 * Precision + *format++ - '0';
				}
				if (Precision < 0) Precision = 0;
			}

			if (format[0] == 'I')
			{
				if (format[1] == '6' && format[2] == '4')
				{
					format += 3;
					bIsLonglong = true;
					
				}
			} else
			if (*format == 'h') ++format;
			else
			if (*format == 'l') ++format;

			switch (*format++)
			{
			case '%':
				strbuf[0] = '%';
				str = strbuf;
				len = 1;
				goto EmitString;
		#ifdef HAS_FLOAT
			case 'E':
			case 'G':
			case 'e':
			case 'f':
			case 'g': {
				double valDouble = va_arg(Next, double);

//unsigned long NaN[2] = {0xffffffff, 0x7fffffff}
//A quiet NaN is represented by any bit pattern between X'7FF80000 00000000' and X'7FFFFFFF FFFFFFFF' 
//or between X'FFF80000 00000000' and X'FFFFFFFF FFFFFFFF'.
//https://stackoverflow.com/questions/2249110/how-do-i-make-a-portable-isnan-isinf-function/2249173

				if (_fpclass(valDouble) == _FPCLASS_QNAN || _fpclass(valDouble) == _FPCLASS_SNAN)
				{
					TStrCpy(strbuf, ("Nan"));
					str = strbuf;
					len = TStrLen(strbuf);
					goto EmitString;
				} else
				if (_fpclass(valDouble) == _FPCLASS_NINF)
				{
					TStrCpy(strbuf, ("-Inf"));
					str = strbuf;
					len = TStrLen(strbuf);
					goto EmitString;
				} else
				if (_fpclass(valDouble) == _FPCLASS_PINF)
				{
					TStrCpy(strbuf, ("+Inf"));
					str = strbuf;
					len = TStrLen(strbuf);
					goto EmitString;
				}
				//_FPCLASS_NN
				//_FPCLASS_ND
				//_FPCLASS_NZ
				//_FPCLASS_PZ
				//_FPCLASS_PD
				//_FPCLASS_PN
				else {

				T *fstr = flt(strbuf, valDouble, Width, Precision, *(format-1), Flags | SIGN);
				*fstr = (T)0;
				str = strbuf;
				len = TStrLen(strbuf);
				goto EmitNumber; }}
		#endif
			case 'X':
				if (bZeroPrefix) sPrefix = str0x;
				if (bIsLonglong)
				{
					unsigned long long val64 = va_arg(Next, unsigned long long);
					NumToStr(val64, strbuf, 16);
					if (!val64) sPrefix = strNULL;
				} else
				{
					unsigned long val = va_arg(Next, unsigned long);
					NumToStr(val, strbuf, 16);
					if (!val) sPrefix = strNULL;
				}
				TStrUpr(strbuf);
				goto EmitNumber;
			case 'c':
				strbuf[0] = (T)va_arg(Next, int); //??? char/WCHAR
				str = strbuf;
				len = 1;
				goto EmitString;
			case 'd':
			case 'i':
				Flags |= SIGN;
				if (bIsLonglong)
				{
					long long val64 = va_arg(Next, long long);
					NumToStr(val64, strbuf, 10);
				} else
				{
					long val = va_arg(Next, long);
					NumToStr(val, strbuf, 10);
				}
				if (strbuf[0] == '-') sPrefix = strSub;
				else
				if (bPlusSign) sPrefix = strPlus;
				else
				if (bBlankSign) sPrefix = strSpace;
				goto EmitNumber;
			case 'n':
				goto EmitNumber;
			case 'o':
				if (bIsLonglong)
				{
					//goto EmitLongLongNumber;
					unsigned long long val64 = va_arg(Next, unsigned long long);	
					NumToStr(val64, strbuf, 8); //??? 8/was 10
				} else
				{
					if (bZeroPrefix) sPrefix = strZero;
					unsigned long val = va_arg(Next, unsigned long);
					NumToStr(val, strbuf, 8);
					if (!val) sPrefix = strNULL;
				}
				goto EmitNumber;
			case 'p':
			case 'x':
				if (bZeroPrefix) sPrefix = str0X;
				if (bIsLonglong)
				{
					unsigned long long val64 = va_arg(Next, unsigned long long);
					NumToStr(val64, strbuf, 16);
					if (!val64) sPrefix = strNULL;
				} else
				{
					unsigned long val = va_arg(Next, unsigned long);
					NumToStr(val, strbuf, 16);
					if (!val) sPrefix = strNULL;
				}
				TStrLwr(strbuf);
				goto EmitNumber;
			case 's':
				str = va_arg(Next, T*);
				len = TStrLen(str);
				if (Precision != -1 && Precision < len)
					len = Precision;
				goto EmitString;
			case 'u':
				if (bIsLonglong)
				{
//EmitLongLongNumber:
					unsigned long long val64 = va_arg(Next, unsigned long long);
					NumToStr(val64, strbuf, 10);
				} else
				{	
					unsigned long val = va_arg(Next, unsigned long);
					NumToStr(val, strbuf, 10);		
				}
EmitNumber:
				if (Precision == -1) Precision = 1;
				savestr = strbuf;
				if (strbuf[0] == '-')
					savestr = &strbuf[1];
				len = TStrLen(savestr);
				nLeadingZeros = Precision - len;
				if (nLeadingZeros < 0)
					nLeadingZeros = 0;
				nPad = Width - (TStrLen(sPrefix) + nLeadingZeros + len);
				if (nPad < 0) nPad = 0;
				if (cPad == '0')
				{
					while (*sPrefix)
					{
						if (buffer) *buffer++ = *sPrefix++;
						++Length;
					}
				}
				if (nPad && !bLeftJustify)
				{
					while (nPad--)
					{
						if (buffer) *buffer++ = cPad;
						++Length;
					}
					nPad = 0;
				}
				while (*sPrefix)
				{
					if (buffer) *buffer++ = *sPrefix++;
					++Length;
				}
				while (nLeadingZeros--)
				{
					if (buffer) *buffer++ = 0x30;
					++Length;
				}
				while (len--)
				{
					if (buffer) *buffer++ = *savestr++;
					++Length;
				}
				if (nPad)
				{
					while (nPad--)
					{
						if (buffer) *buffer++ = 0x20;
						++Length;
					}
				}
				break;
			default:
				str = strError;
				len = TStrLen(str);
			EmitString:
				if (Width <= len)
					nPad = 0;
				else	nPad = Width - len;
				if (nPad && !bLeftJustify)
				{
					while (nPad--)
					{
						if (buffer) *buffer++ = cPad;
						++Length;
					}
				} 
				while (len--)
				{
					if (buffer) *buffer++ = *str++;
					++Length;
				}
				if (nPad && bLeftJustify)
				{
					while (nPad--)
					{
						if (buffer) *buffer++ = 0x20;
						++Length;
					}
				}
				break;
			}
		}

		if (buffer) *buffer = 0;
	#undef OutPut
		return Length;
	}

	//////////////////


//=====
	template<class T, class S>
	inline T *TStrStr(T *Str, const S *Sub)
	{
		if (!Str || !Sub) return NULL;
		if (!*Sub) return Str;
		while (*Str)
		{
			const S *Sub_ = Sub;
			const T *Str_ = Str;
			while (*Str_ && *Sub_)
			{
				if (*Str_ != *Sub_) break;
				++Sub_;
				++Str_;
			}
			if (!*Sub_) return Str;
			++Str;
		}
		return NULL;
	}

	template<class T, class S>
	inline T *TStrIStr(T *Str, const S *Sub)
	{
		if (!Str || !Sub) return NULL;
		if (!*Sub) return Str;
		while (*Str)
		{
			const S *Sub_ = Sub;
			const T *Str_ = Str;
			while (*Str_ && *Sub_)
			{
				if (LOWER_CHAR(*Str_) != LOWER_CHAR(*Sub_)) break;
				++Sub_;
				++Str_;
			}
			if (!*Sub_) return Str;
			++Str;
		}
		return NULL;
	}

	template<class T, class S>
	inline T *TStrIStrX(T *Str, const S *Sub, const S *NewSub)
	{
		if (!Str || !Sub) return NULL;
		if (!*Sub) return Str;

		if (!TStrNICmp(Str, NewSub, TStrLen(NewSub)))
		{
			const S *Sub_ = Sub;
			while (*Sub_)
			{
				if (!Str[TStrLen(NewSub)]) return Str;
				if (*Sub_ == Str[TStrLen(NewSub)]) return Str;
				++Sub_;
			}
		}

		while (*Str)
		{
			const S *Sub_ = Sub;
			while (*Sub_)
			{
				if (*Str == *Sub_ && !TStrNICmp(Str+1, NewSub, TStrLen(NewSub)) )
				{
					const S *Sub2 = Sub; //Sub_ ???
					while (*Sub2)
					{
						if (!Str[TStrLen(NewSub)+1]) return Str+1;
						if (*Sub2 == Str[TStrLen(NewSub)+1]) return Str+1;
						++Sub2;
					}
				}
				++Sub_;
			}
			++Str;
		}
		return NULL;
	}

	inline char *TStrFunc(char *pStr)
	{
		int Level = 0;
		char *pClose = TStrRChr(pStr, ')');
		int pCloseLen = TStrLen(pClose);
		int i = TStrLen(pStr) - pCloseLen; //WTF ??? just pCloseLen ? pCloseLen : TStrLen(pStr)
		while (i >= 0)
		{
			if (pStr[i] == ')')
			{
				++Level;
			} else
			if (pStr[i] == '(' )
			{
				--Level;
			}
			if (!Level)
				break;
			--i;
		}
		//if (Level) return nullptr; //+++ ???
		return &pStr[i];
	}

template<class T, int NoCaseCmp, int N>
struct TString
{
	T *m_pData;
	int m_nLength;
	int m_nMaxLength;
public:
	void Init() { m_pData = NULL; m_nLength = 0; m_nMaxLength = 0; }

	TString(const TString & String)
	{
		Init();
		if (String.m_nLength) Preallocate(String.m_nLength+1, String.m_pData);
	}

	TString(const T *pString)
	{
		Init();
		m_pData = (T*)pString; //TODO const cast
		m_nLength = TStrLen(pString);
	}

	TString() { Init(); }
	virtual ~TString() { Empty(); }

	virtual void Preallocate(int nLength, const T *pNewString)
	{
		T *pNewData = m_pData;

		int OldLen = m_nMaxLength;
		if (nLength > m_nMaxLength)
		{
			m_nMaxLength = ROUNDNEXT(nLength, N);
			pNewData = new T[m_nMaxLength]; //???
			*pNewData = 0;
		}
		if (pNewString && pNewString != pNewData)
		{
			m_nLength = TStrLen(pNewString);
			TStrCpyLimit(pNewData, pNewString, m_nMaxLength);
		}
		if (m_pData && pNewData != m_pData)
		{
			if (OldLen)
				delete []m_pData;
			m_pData = NULL;
		}
		m_pData = pNewData;
	}

	int GetLength() const { return m_nLength; }

	virtual void Empty()
	{
		if (m_pData) { if (m_nMaxLength) delete []m_pData; m_pData = NULL; } 
		m_nLength = 0;
		m_nMaxLength = 0;
	}
	bool IsEmpty() const { return !m_pData || !m_nLength || !m_pData[0]; }
	int Compare(const TString StrObj) const { return TStrCmp(m_pData, StrObj.m_pData); }
	int CompareNoCase(const TString StrObj) const { return TStrICmp(m_pData, StrObj.m_pData); }
	T GetAt(int nIndex) const { return m_pData[nIndex]; }
	T SetAt(int nIndex, T Char)
	{
		if (!m_pData) Preallocate(m_nLength+1, NULL);
		m_pData[nIndex] = Char;
		if (!Char) m_nLength = TStrLen(m_pData);
		return Char;
	}

	void Truncate(int nLength)
	{
		if (!m_pData) Preallocate(nLength+1, NULL);
		m_pData[nLength] = 0;
		if (m_pData) m_nLength = TStrLen(m_pData);
		else m_nLength = 0;
		//return m_nLength;
	}

	void ReverseCpy(T *dst, const T *src, int count)
	{
		dst += count;
		src += count;
		while(count) dst--,src--,*dst=*src,count--;
	}

	TString & Fill(T Char, int nCount)
	{
		Preallocate(nCount+1, NULL);
		for (int i = 0; i < nCount; ++i)
		{
			m_pData[i] = Char;
			++m_nLength;
		}
		m_pData[m_nLength] = 0;
		return *this;
	}

	int Insert(int nIndex, T Char)
	{
		if (!m_pData) Preallocate(nIndex+1, NULL);
		int v4 = m_nLength + 1;
		if (v4 >= m_nMaxLength) Preallocate(v4+1, m_pData);
		ReverseCpy(&m_pData[nIndex + 1], &m_pData[nIndex], m_nLength - nIndex);
		m_pData[nIndex] = Char;
		m_nLength += 1;
		m_pData[m_nLength] = 0;
		return m_nLength;
	}

	int Insert(int nIndex, const T *pString)
	{
		if (!m_pData) Preallocate(nIndex+1, NULL);
		int newLength = TStrLen(pString);

		int v7 = m_nLength + newLength;
		if (v7 >= m_nMaxLength)	Preallocate(v7+1, m_pData);
		ReverseCpy(&m_pData[nIndex + newLength], &m_pData[nIndex], m_nLength - nIndex);
		ReverseCpy(&m_pData[nIndex], pString, newLength);
		m_nLength += newLength;
		m_pData[m_nLength] = 0;
		return m_nLength;
	}

	int Delete(int nIndex, int nCount)
	{
		if (nIndex < 0 || nIndex >= m_nLength)
			return m_nLength;
		
		int v5 = MIN(nCount, m_nLength-nIndex);
		TMemCpy(&m_pData[nIndex], &m_pData[nIndex + v5], m_nLength - nIndex - v5);
		m_nLength -= v5;
		m_pData[m_nLength] = 0;
		return m_nLength;
	}

	TString & operator=(const T *pString)
	{
		if (pString) Preallocate(TStrLen(pString)+1, pString);
		else Empty();
		return *this;
	}

	TString & operator=(const TString & String)
	{
		if (String.m_nLength) Preallocate(String.m_nLength+1, String.m_pData);
		else Empty();
		return *this;
	}

	TString & operator+=(T Char)
	{
		Preallocate(m_nLength+2, m_pData); //??? 2
		m_pData[m_nLength++] = Char;
		m_pData[m_nLength] = 0;
		return *this;
	}

	TString & operator+=(const TString & String)
	{
		Preallocate(m_nLength+String.m_nLength+1, m_pData);
		TStrCat(m_pData, String.m_pData);
		m_nLength += String.m_nLength;
		return *this;
	}

	TString & operator+=(const T *pString)
	{
		int Length = TStrLen(pString);
		Preallocate(m_nLength+Length+1, m_pData);
		TStrCat(m_pData, pString);
		m_nLength += Length;
		return *this;
	}

	const T *cstr() const
	{
		static const T NullChar = 0;
		if (m_pData) return m_pData;
		return &NullChar;
	}

	operator const T *() const
	{
		static const T NullChar = 0;
		if (m_pData) return m_pData;
		return &NullChar;
	}

	T *data()// const
	{
		static T NullChar = 0;
		if (m_pData) return m_pData;
		return &NullChar;
	}

	TString operator+(const T *pNewString) const
	{
		TString tmp = *this;
		tmp += pNewString;
		return tmp;
	}

	TString operator+(const TString & String) const
	{
		TString tmp = *this;
		tmp += String;
		return tmp;
	}

	T & operator[](int nIndex) { return &m_pData[nIndex]; }

	bool operator==(const T *pString) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, pString)==0;
		return TStrCmp(m_pData, pString)==0;
	}
	bool operator==(const TString & StrObj) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, StrObj.m_pData)==0;
		return TStrCmp(m_pData, StrObj.m_pData)==0;
	}

	bool operator!=(const T *pString) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, pString)!=0;
		return TStrCmp(m_pData, pString)!=0;
	}
	bool operator!=(const TString & StrObj) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, StrObj.m_pData)!=0;
		return TStrCmp(m_pData, StrObj.m_pData)!=0;
	}

	bool operator<(const T *pString) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, pString)<0;
		return TStrCmp(m_pData, pString)<0;
	}
	bool operator<(const TString & StrObj) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, StrObj.m_pData)<0;
		return TStrCmp(m_pData, StrObj.m_pData)<0;
	}

	bool operator>(const T *pString) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, pString)>0;
		return TStrCmp(m_pData, pString)>0;
	}
	bool operator>(const TString & StrObj) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, StrObj.m_pData)>0;
		return TStrCmp(m_pData, StrObj.m_pData)>0;
	}

	bool operator<=(const T *pString) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, pString)<=0;
		return TStrCmp(m_pData, pString)<=0;
	}
	bool operator<=(const TString & StrObj) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, StrObj.m_pData)<=0;
		return TStrCmp(m_pData, StrObj.m_pData)<=0;
	}

	bool operator>=(const T *pString) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, pString)>=0;
		return TStrCmp(m_pData, pString)>=0;
	}
	bool operator>=(const TString & StrObj) const
	{
		if (NoCaseCmp)
			return TStrICmp(m_pData, StrObj.m_pData)>=0;
		return TStrCmp(m_pData, StrObj.m_pData)>=0;
	}

	void FormatV(const T *format, va_list Next)
	{
		int Len = TVSPrintf((T*)NULL, format, Next);
		Preallocate(Len+1, NULL);
		TVSPrintf(m_pData, format, Next);
		m_nLength = Len;
	}

	void Format(const T *format, ...)
	{
		va_list Next;
		va_start(Next, format);
		FormatV(format, Next);
		va_end(Next);
	}

	TString & MakeUpper() { if (m_pData) TStrUpr(m_pData); return *this; }
	TString & MakeLower() { if (m_pData) TStrLwr(m_pData); return *this; }

	T * GetFileName() const { return TGetFileName(operator T*()); }
	T * GetFileExt() const { return TGetFileExt(operator T*()); }
	int GetFileTitle(T *pStr) const { return TGetFileTitle(operator T*(), pStr); }
	int GetFilePath(T *pStr) const { return TGetFilePath(operator T*(), pStr); }

	int Write(ALT::ALTFileStream & Stream) const
	{
		int nRet = Stream.Write(&m_nLength, sizeof(m_nLength));
		if  (m_nLength>0)
			nRet += Stream.Write(m_pData, m_nLength);
		return nRet;
	}

	int Read(ALT::ALTFileStream & Stream)
	{
		if (Stream.Read(&m_nLength, sizeof(m_nLength)) != sizeof(m_nLength))
			return 0;
		if (m_nLength==0)
			return 4;
		Preallocate(m_nLength+1, NULL);
		int nRet = Stream.Read(m_pData, m_nLength);
		if (nRet != m_nLength)
			return 0;
		m_pData[m_nLength] = 0;
		return nRet + sizeof(m_nLength);
	}
};

	typedef TString<unsigned long,0,8> TColorString;
	typedef TString<WCHAR,0,8> TWideString;
	typedef TString<char,0,8> TAnsiString;

	typedef TString<WCHAR,1,8> TWideNoCaseString;
	typedef TString<char,1,8> TAnsiNoCaseString;

	struct MY_char_compare
	{
		bool operator()(const char *s1, const char *s2) const
		{
			return TStrCmp(s1, s2) < 0;
		}
	};

	template<typename S, typename T>
	T *THexBytesToStr(S *Hex, T *String, int nHex, int Length, const T *szSpc)
	{
		//S Data;
		//int LeftLen;
		//T *pStr;
		//S tmp;
		//int Turn;
		//int StrLen;
		int n;

		int Turn = 2 * Length;
		int StrLen = 0;
		if (szSpc)
		{
			StrLen = TStrLen(szSpc);
			Turn += StrLen;
		}
		for (n = 0; n < nHex / Length; ++n)
		{
			T *pStr = &String[(Turn * n + 2 * Length)];
			if (szSpc)
				TStrCpy(pStr, szSpc);
			for (int m = 0; m < Length; ++m)
			{
				S Data = Hex[m + Length * n];
				S tmp = Data & 0xf; // % 16
				pStr--,*pStr = tmp > 9 ? tmp+'7':tmp+'0';
				tmp = Data >> 4; // /16
				pStr--,*pStr = tmp > 9 ? tmp+'7':tmp+'0';
			}
			
		}
		int LeftLen = nHex % Length;
		if (LeftLen)
		{
			T *pStr = &String[(StrLen * n + 2 * LeftLen)];

			for (int m = 0; m < LeftLen; ++m)
			{
				S Data = Hex[m + Length * n];
				S tmp = Data & 0xf; // % 16
				pStr--,*pStr = tmp > 9 ? tmp+'7':tmp+'0';
				tmp = Data >> 4; // /16
				pStr--,*pStr = tmp > 9 ? tmp+'7':tmp+'0';
			}
			StrLen = 0;
		}
		String[(Turn * n -StrLen + 2 * LeftLen)] = 0;
		return &String[(Turn * n -StrLen + 2 * LeftLen)];
	}

	//ushort,char
	template<typename S, typename T>
	int THexBytesToASCII(S *Hex, T *String, int nHex)
	{
		T LOW,HI;
		int n = 0;
		while (Hex[0] && n < nHex)
		{
			if (Hex[1]>= 0x30 && Hex[1]<= 0x39) LOW = Hex[1]-0x30;
			else
			if (Hex[1]>= 0x41 && Hex[1]<= 0x46) LOW = Hex[1]-0x37;
			else
			if (Hex[1]>= 0x61 && Hex[1]<= 0x66) LOW = Hex[1]-0x57;
			else return 0;
			if (Hex[0]>= 0x30 && Hex[0]<= 0x39) HI = Hex[0]-0x30;
			else
			if (Hex[0]>= 0x41 && Hex[0]<= 0x46) HI = Hex[0]-0x37;
			else
			if (Hex[0]>= 0x61 && Hex[0]<= 0x66) HI = Hex[0]-0x57;
			else return 0;
			Hex += 2;
			String[n] = (HI<<4) + LOW;
			if (Hex[0] == 0x20 || Hex[0] == 0x2c) ++Hex;
			++n;
		}
		return n;
	}

	//ushort,char
	template<typename S, typename T>
	int THexBytesToPrint(S *Hex, T *String, int Count)
	{
		int i;
		for (i = 0; i < Count; ++i)
		{
			String[i] = Hex[i];
			if (String[i] < 32) //' '
				String[i] = 46; //','
		}
		String[i] = 0;
		return i;
	}

	//TAB
	inline unsigned long TGetCodeID(const unsigned char *Buffer, int Len)
	{
		unsigned short HighWord = 0;
		unsigned short LowWord = 0;
		for (int n = 0; n < Len; ++n)
		{
			LowWord += Buffer[n];
			if (n+2 <= Len)
				HighWord += *(unsigned short*)&(Buffer[n]);
		}
		return MAKE_DWORD(HighWord, LowWord);
	}


	inline unsigned long TGetNameCode(const char *Name, int Len) //??? unsigned
	{
		unsigned short Word = 0;
		unsigned char Byte = 0;
		for (int n = 0; n < Len; ++n)
		{
			Byte += Name[n];
			Word += Name[n];
		}
		return MAKE_DWORD(Word, MAKE_WORD(Byte, Len));
	//	return ((unsigned long)Word<<16) | (((unsigned short)Byte << 8) | Len);
	}

	inline unsigned long TGetNameCode(const char *Name) //??? unsigned
	{
		return TGetNameCode(Name, TStrLen(Name));
	}

	//TAB
	template<class T>
	inline bool TIMatchWithPattern(const T *Pattern, const T *Name)
	{
		if (Pattern[0] == 0) return true;
		if (Pattern[0] == '*')
		{
			++Pattern;
			if (Pattern[0] == 0) return true;
			while (Name[0])
			{
				if ((LOWER_CHAR(Pattern[0]) == LOWER_CHAR(Name[0]) || Pattern[0] == '?') &&
					TIMatchWithPattern(&Pattern[1], &Name[1]))
					return true;
				++Name;
			}
		} else
		{
			while (Name[0] && Pattern[0] != '*')
			{
				if (LOWER_CHAR(Pattern[0]) != LOWER_CHAR(Name[0]) && Pattern[0] != '?')
					return false;
				++Name;
				++Pattern;
			}
			if (Name[0]) return TIMatchWithPattern(Pattern, Name);
		}
		return Pattern[0] == 0 || Pattern[0] == '*';
	}

	template<class T>
	inline bool TIMultiMatchWithPattern(const T *Pattern, const T *Name)
	{
		T buf[256];
		//bool Result;
		//T *pEnd;
		//T *pBegin;

		if (Pattern[0] == 0) return true;
		TStrCpy(buf, Pattern);

		T *pEnd = &buf[TStrLen(buf)-1];
		if (*pEnd == ';') *pEnd = 0;

		T *pBegin = buf;
		while ((pEnd = TStrChr(pBegin, ';')))
		{
			*pEnd = 0;
			if (TIMatchWithPattern(pBegin, Name))
				return true;
			pBegin++;
		}
		return TIMatchWithPattern(pBegin, Name);
	}

	//TAB

	template<class T, class S>
	inline T *uNumToStr(S Num, T *String, int Radix)
	{
		if (Num == 0)
		{
			String[0] = '0';
			String[1] = 0;
			return String;
		}

		if (Radix < 2 || Radix > 36)
		{
			String[0] = 0;
			return String;
		}

		S PrevPow = 0;
		S Pow = 1;
		while (Num >= Pow && (!(Pow%Radix) || Pow == 1) && Pow > PrevPow)
		{
				PrevPow = Pow;
				Pow *= Radix;
		}

		S Digit = PrevPow;
		while (Digit)
		{
			*String++ = (Num/Digit)>9?(Num/Digit)+'7':(Num/Digit)+'0';
			Num -= (Num/Digit) * Digit;
			Digit /= Radix;
		}
		*String = 0;
		return String;
	}

	template<class T, class S>
	inline T *NumToStr(S Num, T *String, int Radix)
	{
		if (Num == 0)
		{
			String[0] = '0';
			String[1] = 0;
			return String;
		}

		if (Radix < 2 || Radix > 36)
		{
			String[0] = 0;
			return String;
		}

		if (Num < 0)
		{
			*String++ = '-';
			Num = -Num;
		}

		S PrevPow = 0;
		S Pow = 1;
		while (Num >= Pow && (!(Pow%Radix) || Pow == 1) && Pow > PrevPow)
		{
				PrevPow = Pow;
				Pow *= Radix;
		}

		S Digit = PrevPow;
		while (Digit)
		{
			*String++ = (Num/Digit)>9?(Num/Digit)+'7':(Num/Digit)+'0';
			Num -= (Num/Digit) * Digit;
			Digit /= Radix;
		}
		*String = 0;
		return String;
	}

	template<class T, class S>
	inline bool USHexStrToNum(const T *String, S *USHex)
	{
		S Result = 0;
		S Len = 0; //TStrLen(String);
		while(String[Len]) ++Len;
		if (Len == 0) return false;
		if (Len > sizeof(S)*2) return false;
		for (S n = 0; n < Len; ++n)
		{
			S Num = 0;
			T Char = String[Len-n-1];
			if (Char >= (T)'0' && Char <= (T)'9') Num = (S)Char-(S)'0';
			else
			if (Char >= (T)'A' && Char <= (T)'F') Num = (S)Char-(S)'7'; //-'A'+10
			else
			if (Char >= (T)'a' && Char <= (T)'f') Num = (S)Char-(S)'W'; //-'a'+10
			else return false;
			//printf("%s:%d C %c Num %ld n %d Len %d\n",__func__,__LINE__, Char,Num, n,Len);
			Result |= Num<<(n*4);
		}
		if (USHex) *USHex = Result;
		return true;
	}

	template<class T, class S>
	inline bool SHexStrToNum(const T *String, S *SHex)
	{
		S tmp;

		if (*String == '-')
		{
			tmp = -1;
			++String;
		} else
		{
			if (*String == '+')
			{
				++String;
			}
			tmp = 1;  
		}

		S Result = 0;
		S Len = 0; //TStrLen(String);
		while(String[Len]) ++Len;
		if (Len == 0) return false;
		if (Len > sizeof(S)*2) return false;
		for (S n = 0; n < Len; ++n)
		{
			S Num = 0;
			T Char = String[Len-n-1];
			if (Char >= (T)'0' && Char <= (T)'9') Num = (S)Char-(S)'0';
			else
			if (Char >= (T)'A' && Char <= (T)'F') Num = (S)Char-(S)'7'; //-'A'+10
			else
			if (Char >= (T)'a' && Char <= (T)'f') Num = (S)Char-(S)'W'; //-'a'+10
			else return false;
			//printf("%s:%d C %c Num %ld n %d Len %d\n",__func__,__LINE__, Char,Num, n,Len);
			Result |= Num<<(n*4);
		}
		if (SHex) *SHex = tmp * Result;
		return true;
	}

	template<class T, class S>
	inline bool USDecStrToNum(const T *String, S *USDec)
	{
		S Result = 0;
		S Len = 0; //TStrLen(String);
		while (String[Len]) ++Len;
		if (Len == 0) return false;
		S X10Base = 1;
		for (S n = 0; n < Len; ++n)
		{
			T c = String[Len-n-1];
			if (!IS_DIGIT(c)) return false;
			Result += X10Base * (c-'0');
			X10Base *= 10;
		}
		if (USDec) *USDec = Result;
		return true;
	}

	template<class T, class S>
	inline bool SDecStrToNum(const T *String, S *SDec)
	{
		S tmp;

		if (*String == '-')
		{
			tmp = -1;
			++String;
		} else
		{
			if (*String == '+')
			{
				++String;
			}
			tmp = 1;  
		}

		S Result = 0;
		S Len = 0;//TStrLen(String);
		while (String[Len]) ++Len;
		if (Len == 0) return false;
		S X10Base = 1;
		for (S n = 0; n < Len; ++n)
		{
			T c = String[Len-n-1];
			if (!IS_DIGIT(c)) return false;
			Result += X10Base * (c-'0');
			X10Base *= 10;
		}
		if (SDec) *SDec = tmp * Result;
		return true;
	}

	template <typename T, int N = 256>
	struct TStaticString
	{
		T Buffer[N];
		T *pBuffer;

		TStaticString()
		{
			pBuffer = Buffer;
			
		}
		TStaticString(int Len)
		{
			pBuffer = Buffer;
			if (Len >= N)
				pBuffer = new T[Len];
			*pBuffer = 0; //+++
		}
		template <typename I>
		TStaticString(const I *Str)
		{
			pBuffer = Buffer;
			int Len = TStrLen(Str)+1;
			if (Len >= N)
				pBuffer = new T[Len];
			*pBuffer = 0; //+++
			TStrCpy(pBuffer, Str);
		}
		~TStaticString()
		{
			if (pBuffer != Buffer) delete []pBuffer;
		}
		T *data() const { return pBuffer; }
		operator T *() const { return pBuffer; }
	};

	typedef TStaticString<WCHAR,256> TStaticWideString;
	typedef TStaticString<char,256> TStaticAnsiString;
#endif

```

`source/Code/txtfile.cpp`:

```cpp

#include "txtfile.hpp"

	CTXTFile::CTXTFile()
	{
	}

	CTXTFile::~CTXTFile()
	{
		TListIter<char*> It = m_StrList.Begin();
		while (It != m_StrList.End())
		{
			delete []*It;
			++It;
		}
		m_StrList.Clear();
	}

	bool CTXTFile::Open(const char *FileName, HANDLE OpenHandle)
	{
		if (!CImageFile::Open(FileName, OpenHandle))
			return false;

		char *Buffer = new char[m_FileSize + 1];
		Buffer[m_FileSize] = 0;
		CImageFile::ReadFile(0, Buffer, m_FileSize);
		if (*(unsigned short*)Buffer == 0xFEFF)
		{
			delete []Buffer;
			Close();
			return false;
		}
		SetLineEndIdentity(Buffer, m_FileSize);
		delete []Buffer;
		return true;
	}
	bool CTXTFile::Save(const char *FileName)
	{
		bool Exist = false;
		if (FileName == m_FileName)
		{
			CImageFile::Close();
			Exist = true;
		}
		int Len = 0;
		{
		TListIter<char*> It = m_StrList.Begin();
		while (It != m_StrList.End())
		{
			Len += TStrLen(*It);
			++It;
		}
		}
		char *Buffer = new char[Len+1];
		Buffer[Len] = 0;
		char *pStr = Buffer;
		{
		TListIter<char*> It = m_StrList.Begin();
		while (It != m_StrList.End())
		{
			TStrCpy(pStr, *It);
			TStrCat(pStr, "\r\n");
			pStr += TStrLen(pStr);
			++It;
		}
		}
		m_pFileIO->WriteToFile(FileName, Buffer, Len);
		return Exist ? CImageFile::Open(FileName, 0) : true;
	}
	void CTXTFile::Close()
	{
		CImageFile::Close();
		TListIter<char*> It = m_StrList.Begin();
		while (It != m_StrList.End())
		{
			delete []*It;
			++It;
		}
		m_StrList.Clear();
	}
	int CTXTFile::SetLineEndIdentity(const char *Buffer, unsigned long long Length)
	{
		unsigned int CurLine = 0;
		unsigned int LastLine = 0;
		while (CurLine < Length)
		{
			if (Buffer[CurLine] != 13 && Buffer[CurLine] != 10)
			{
				++CurLine;
			} else
			{
				unsigned int Start = CurLine;
				if (Buffer[CurLine] != 13 || Buffer[CurLine + 1] != 10)
					++CurLine;
				else	CurLine = Start + 2;
				char *NewStr = new char[Start - LastLine + 1];
				TStrNCpy(NewStr, &Buffer[LastLine], Start - LastLine);
				NewStr[Start - LastLine] = 0;
				m_StrList.Append(&NewStr);
				LastLine = CurLine;
			}
		}

		if (CurLine != LastLine)
		{
			unsigned int Start = CurLine;
			char *NewStr = new char[CurLine - LastLine + 1];
			TStrNCpy(NewStr, &Buffer[LastLine], Start - LastLine);
			NewStr[Start - LastLine] = 0;
			m_StrList.Append(&NewStr);
		}
		return m_StrList.Size();
	}
	bool CTXTFile::Insert(unsigned long Line, unsigned long Length, const char *String)
	{
		TListIter<char*> Iter = m_StrList.Begin();
		while (Line)
		{
			if (Iter == m_StrList.End())
				return false;
			--Line;
			++Iter;
		}

		int TotalLen = TStrLen(*Iter);
		if (TotalLen <= Length)
			return false;

		TotalLen += TStrLen(String);
		char *Buffer = new char[TotalLen+1];
		char *pStr = Buffer;
		TStrNCpy(Buffer, *Iter, Length);
		Buffer[Length] = 0;
		pStr += TStrLen(pStr);
		TStrCpy(pStr, String);
		pStr += TStrLen(pStr);
		TStrCpy(pStr, (*Iter)+Length);

		delete []*Iter;

		m_StrList.Remove(Iter);

		int CurLine = 0;
		int LastLine = 0;
		while (CurLine < TotalLen)
		{
			if (Buffer[CurLine] != 13 && Buffer[CurLine] != 10)
			{
				++CurLine;
			} else
			{
				int Start = CurLine;
				if (Buffer[CurLine] != 13 || Buffer[CurLine+1] != 10)
					++CurLine;
				else	CurLine = Start + 2;
				char *NewStr = new char[Start-LastLine+1];
				TStrNCpy(NewStr, &Buffer[LastLine], Start-LastLine);
				NewStr[Start-LastLine] = 0;
				m_StrList.InsertAfter(Iter, &NewStr);
				LastLine = CurLine;
			}
		}
		delete []Buffer;
		return true;
	}
	bool CTXTFile::Replace(unsigned long Line, unsigned long Length, const char *String, unsigned long NewPos)
	{
		TListIter<char*> Iter = m_StrList.Begin();
		while (Line)
		{
			if (Iter == m_StrList.End())
				return false;
			--Line;
			++Iter;
		}

		int TotalLen = TStrLen(*Iter);
		if (TotalLen <= NewPos+Length)
			return false;

		TotalLen += TStrLen(String);
		char *Buffer = new char[TotalLen+1];
		char *pStr = Buffer;
		TStrNCpy(Buffer, *Iter, Length);
		Buffer[Length] = 0;
		pStr += TStrLen(pStr);
		TStrCpy(pStr, String);
		pStr += TStrLen(pStr);
		TStrCpy(pStr, (*Iter)+NewPos+Length);

		delete []*Iter;

		m_StrList.Remove(Iter);

		int CurLine = 0;
		int LastLine = 0;
		while (CurLine < TotalLen)
		{
			if (Buffer[CurLine] != 13 && Buffer[CurLine] != 10)
			{
				++CurLine;
			} else
			{
				int Start = CurLine;
				if (Buffer[CurLine] != 13 || Buffer[CurLine+1] != 10)
					++CurLine;
				else	CurLine = Start + 2;
				char *NewStr = new char[Start-LastLine+1];
				TStrNCpy(NewStr, &Buffer[LastLine], Start-LastLine);
				NewStr[Start-LastLine] = 0;
				m_StrList.InsertAfter(Iter, &NewStr);
				LastLine = CurLine;
			}
		}
		delete []Buffer;
		return true;
	}

```

`source/Code/txtfile.hpp`:

```hpp

#ifndef _TXTFILE_HPP_
#define _TXTFILE_HPP_

#include "define.h"
#include "imagefile.hpp"
#include "alt/altlist.hpp"

struct CTXTFile : public CImageFile
{
	CTXTFile();
	~CTXTFile();

	virtual bool Open(const char *FileName, HANDLE OpenHandle) override;
	bool Save(const char *FileName);
	virtual void Close() override;
	int SetLineEndIdentity(const char *Buffer, unsigned long long Length);
	bool Insert(unsigned long Pos, unsigned long Length, const char *String);
	bool Replace(unsigned long Pos, unsigned long Length, const char *String, unsigned long NewPos);

	TList<char *> m_StrList;
};

#endif

```

`source/Code/utxtfile.cpp`:

```cpp

#include "utxtfile.hpp"

	UCTXTFile::UCTXTFile()
	{
	}

	UCTXTFile::~UCTXTFile()
	{
		TListIter<WCHAR*> It = m_StrList.Begin();
		while (It != m_StrList.End())
		{
			delete []*It;
			++It;
		}
		m_StrList.Clear();
	}

	bool UCTXTFile::Open(const char *FileName, HANDLE OpenHandle)
	{
		if (!CImageFile::Open(FileName, OpenHandle))
			return false;

		WCHAR *Buffer = new WCHAR[m_FileSize + 1];
		Buffer[m_FileSize] = 0;
		CImageFile::ReadFile(0, Buffer, m_FileSize);
		if (*(unsigned short*)Buffer == 0xFEFF)
		{
			delete []Buffer;
			Close();
			return false;
		}
		SetLineEndIdentity(Buffer+1, m_FileSize);
		delete []Buffer;
		return true;
	}
	bool UCTXTFile::Save(const char *FileName)
	{
		bool Exist = false;
		if (FileName == m_FileName)
		{
			CImageFile::Close();
			Exist = true;
		}
		int Len = 0;
		{
		TListIter<WCHAR*> It = m_StrList.Begin();
		while (It != m_StrList.End())
		{
			Len += TStrLen(*It);
			++It;
		}
		}
		WCHAR *Buffer = new WCHAR[Len+1];
		Buffer[Len] = 0;
		WCHAR *pStr = Buffer;
		{
		TListIter<WCHAR*> It = m_StrList.Begin();
		while (It != m_StrList.End())
		{
			TStrCpy(pStr, *It);
			TStrCat(pStr, "\r\n");
			pStr += TStrLen(pStr);
			++It;
		}
		}
		m_pFileIO->WriteToFile(FileName, Buffer, Len*2);
		return Exist ? CImageFile::Open(FileName, 0) : true;
	}
	void UCTXTFile::Close()
	{
		CImageFile::Close();
		TListIter<WCHAR*>It = m_StrList.Begin();
		while (It != m_StrList.End())
		{
			delete []*It;
			++It;
		}
		m_StrList.Clear();
	}
	int UCTXTFile::SetLineEndIdentity(const WCHAR *Buffer, unsigned long long Length)
	{
		unsigned int CurLine = 0;
		unsigned int LastLine = 0;
		while (CurLine < Length/2)
		{
			if (Buffer[CurLine] != 13 && Buffer[CurLine] != 10)
			{
				++CurLine;
			} else
			{
				unsigned int Start = CurLine;
				if (Buffer[CurLine] != 13 || Buffer[CurLine + 1] != 10)
					++CurLine;
				else	CurLine = Start + 2;
				WCHAR *NewStr = new WCHAR[Start - LastLine + 1];
				TStrNCpy(NewStr, &Buffer[LastLine], Start - LastLine);
				NewStr[Start - LastLine] = 0;
				m_StrList.Append(&NewStr);
				LastLine = CurLine;
			}
		}

		if (CurLine != LastLine)
		{
			unsigned int Start = CurLine;
			WCHAR *NewStr = new WCHAR[CurLine - LastLine + 1];
			TStrNCpy(NewStr, &Buffer[LastLine], Start - LastLine);
			NewStr[Start - LastLine] = 0;
			m_StrList.Append(&NewStr);
		}
		return m_StrList.Size();
	}
	bool UCTXTFile::Insert(unsigned long Line, unsigned long Length, const WCHAR *String)
	{
		TListIter<WCHAR*> Iter = m_StrList.Begin();
		while (Line)
		{
			if (Iter == m_StrList.End())
				return false;
			--Line;
			++Iter;
		}

		int TotalLen = TStrLen(*Iter);
		if (TotalLen <= Length)
			return false;

		TotalLen += TStrLen(String);
		WCHAR *Buffer = new WCHAR[TotalLen+1];
		WCHAR *pStr = Buffer;
		TStrNCpy(Buffer, *Iter, Length);
		Buffer[Length] = 0;
		pStr += TStrLen(pStr);
		TStrCpy(pStr, String);
		pStr += TStrLen(pStr);
		TStrCpy(pStr, (*Iter)+Length);

		delete []*Iter;

		m_StrList.Remove(Iter);

		int CurLine = 0;
		int LastLine = 0;
		while (CurLine < TotalLen)
		{
			if (Buffer[CurLine] != 13 && Buffer[CurLine] != 10)
			{
				++CurLine;
			} else
			{
				int Start = CurLine;
				if (Buffer[CurLine] != 13 || Buffer[CurLine+1] != 10)
					++CurLine;
				else	CurLine = Start + 2;
				WCHAR *NewStr = new WCHAR[Start-LastLine+1];
				TStrNCpy(NewStr, &Buffer[LastLine], Start-LastLine);
				NewStr[Start-LastLine] = 0;
				m_StrList.InsertAfter(Iter, &NewStr);
				LastLine = CurLine;
			}
		}
		delete []Buffer;
		return true;
	}
	bool UCTXTFile::Replace(unsigned long Line, unsigned long Length, const WCHAR *String, unsigned long NewPos)
	{
		TListIter<WCHAR*> Iter = m_StrList.Begin();
		while (Line)
		{
			if (Iter == m_StrList.End())
				return false;
			--Line;
			++Iter;
		}

		int TotalLen = TStrLen(*Iter);
		if (TotalLen <= NewPos+Length)
			return false;

		TotalLen += TStrLen(String);
		WCHAR *Buffer = new WCHAR[TotalLen+1];
		WCHAR *pStr = Buffer;
		TStrNCpy(Buffer, *Iter, Length);
		Buffer[Length] = 0;
		pStr += TStrLen(pStr);
		TStrCpy(pStr, String);
		pStr += TStrLen(pStr);
		TStrCpy(pStr, (*Iter)+NewPos+Length);

		delete []*Iter;

		m_StrList.Remove(Iter);

		int CurLine = 0;
		int LastLine = 0;
		while (CurLine < TotalLen)
		{
			if (Buffer[CurLine] != 13 && Buffer[CurLine] != 10)
			{
				++CurLine;
			} else
			{
				int Start = CurLine;
				if (Buffer[CurLine] != 13 || Buffer[CurLine+1] != 10)
					++CurLine;
				else	CurLine = Start + 2;
				WCHAR *NewStr = new WCHAR[Start-LastLine+1];
				TStrNCpy(NewStr, &Buffer[LastLine], Start-LastLine);
				NewStr[Start-LastLine] = 0;
				m_StrList.InsertAfter(Iter, &NewStr);
				LastLine = CurLine;
			}
		}
		delete []Buffer;
		return true;
	}

```

`source/Code/utxtfile.hpp`:

```hpp

#ifndef _UTXTFILE_HPP_
#define _UTXTFILE_HPP_

#include "define.h"
#include "imagefile.hpp"
#include "alt/altlist.hpp"

struct UCTXTFile : public CImageFile
{
	UCTXTFile();
	~UCTXTFile();

	virtual bool Open(const char *FileName, HANDLE OpenHandle) override;
	bool Save(const char *FileName);
	virtual void Close() override;
	int SetLineEndIdentity(const WCHAR *Buffer, unsigned long long Length);
	bool Insert(unsigned long Pos, unsigned long Length, const WCHAR *String);
	bool Replace(unsigned long Pos, unsigned long Length, const WCHAR *String, unsigned long NewPos);

	TList<WCHAR *> m_StrList;
};

#endif

```

`source/EXEAnalyzer/debugger.cpp`:

```cpp

#include "debugger.hpp"


	bool CDebugger::CheckAllowType(unsigned int TypeInc, unsigned int TypeExc, const BREAK_POINT & BP)
	{
		if (TypeInc & 0x80000000)
		{
			if (((TypeInc & ~0x80000000) & BP.Type) != (TypeInc & ~0x80000000))
				return false;
		} else
		if (TypeInc && !(TypeInc & BP.Type))
		{
			return false;
		}

		if (TypeExc & 0x80000000)
		{
			if (((TypeExc & ~0x80000000) & BP.Type) == (TypeExc & ~0x80000000))
				return false;
		} else
		if (TypeExc & BP.Type)
		{
			return false;
		}
		return true;
	}

	//CODE

	BREAK_POINT *CDebugger::GetCodeBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc)
	{
		unsigned long long RealAddress;
		if (!GetMemoryAddress(Address, &RealAddress))
			return nullptr;

		map<unsigned long long, BREAK_POINT>::IT it = m_pCodeBPMap->find(RealAddress);
		if (!it)
		//if (it == m_pCodeBPMap->end())
			return nullptr;

		if (!CheckAllowType(TypeInc, TypeExc, it->second))
			return nullptr;

		return &it->second;
	}

	//
	BREAK_POINT *CDebugger::SetCodeBP(ULONG_PTR Address, unsigned int Type, unsigned int State)
	{
		if (!OpenProcess(m_dwProcessId))
		{
			m_Status = BP_STATUS_NO_PID;
			return nullptr;
		}

		unsigned long long RealAddress;
		if (!GetMemoryAddress(Address, &RealAddress))
		{
			CloseProcess();
			m_Status = BP_STATUS_NO_ADDR;
			return nullptr;
		}

		map<unsigned long long, BREAK_POINT>::IT it = m_pCodeBPMap->find(RealAddress);
		if (it)
		//if (it != m_pCodeBPMap->end())
		{
			CloseProcess();
			m_Status = BP_STATUS_EXIST_BP;
			return nullptr;
		}

		map<unsigned long long, BREAK_POINT>::IT iit = m_pCodeBPMap->insert(_Tmap_pair<unsigned long long, BREAK_POINT>(RealAddress,BREAK_POINT()));
		iit->second.Address = Address;
		iit->second.Type = Type;
		iit->second.State = BP_STATE_DISABLE;
		iit->second.Size = 0;
		iit->second.PatchFN = 0;
		iit->second.ProcessID = m_dwProcessId;
		iit->second.Owner = m_MainModuleName;
		iit->second.pModule = nullptr;
		iit->second.HitCount = 0;

		if (State != BP_STATE_ENABLE || SetCodeBreakPoint(iit->second))
		{
			iit->second.State = State;
			CloseProcess();
			m_Status = BP_STATUS_NEW_BP;
			return &iit->second;
		} else
		{
			m_pCodeBPMap->erase(iit);
			CloseProcess();
			m_Status = BP_STATUS_FAIL_ADD_BP;
			return nullptr;
		}
		//???
	}

	//
	bool CDebugger::DelCodeBP(BREAK_POINT & BP)
	{
#if 1
		map<unsigned long long, BREAK_POINT>::IT it = &BP; //???

		if (!OpenProcess(BP.ProcessID))
			return false;

		unsigned long long RealAddress;
		if (!GetMemoryAddress(it->second.Address, &RealAddress) || (RealAddress != it->first)) //???
		{
			CloseProcess();
			return false;
		}
#else
		map<unsigned long long, BREAK_POINT>::IT it = m_pCodeBPMap->begin();
		while (it != m_pCodeBPMap->end())
		{
			if (it->second == BP) break;
			++it;
		}

		if (it == m_pCodeBPMap->end())
			return false;
#endif
		if (it->second.State != BP_STATE_ENABLE || ClearCodeBreakPoint(it->second))
		{
			m_pCodeBPMap->erase(it);
			CloseProcess();
			return true;
		} else
		{
			CloseProcess();
			return false;
		}
	}
	bool CDebugger::DelCodeBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc)
	{
		if (!OpenProcess(m_dwProcessId))
		{
			m_Status = BP_STATUS_NO_PID;
			return false;
		}

		unsigned long long RealAddress;
		if (!GetMemoryAddress(Address, &RealAddress))
		{
			CloseProcess();
			m_Status = BP_STATUS_NO_ADDR;
			return false;
		}

		map<unsigned long long, BREAK_POINT>::IT it = m_pCodeBPMap->find(RealAddress);
		if (!it)
		//if (it == m_pCodeBPMap->end())
		{
			CloseProcess();
			m_Status = BP_STATUS_NOT_EXIST_BP;
			return false;
		}

		if (!CheckAllowType(TypeInc, TypeExc, it->second))
		{
			CloseProcess();
			return false;
		}

		if (it->second.State != BP_STATE_ENABLE || ClearCodeBreakPoint(it->second))
		{
			m_pCodeBPMap->erase(it);
			CloseProcess();
			m_Status = 0; //STATUS_OK
			return true;
		} else
		{
			CloseProcess();
			m_Status = BP_STATUS_FAIL_DEL_BP;
			return false;
		}
	}

	//
	int CDebugger::DelAllCodeBP(unsigned int TypeInc, unsigned int TypeExc)
	{
		int Count = 0;
		map<unsigned long long, BREAK_POINT>::IT it = m_pCodeBPMap->begin();
		//for (; it != m_pCodeBPMap->end(); )
		while (it)
		{
			if (CheckAllowType(TypeInc, TypeExc, it->second))
			{
				if (DelCodeBP(it++->second))
					Count++;
			} else
			{
				it++;
			}
		}
		return Count;
	}

	//
	int CDebugger::EnableAllCodeBP(unsigned int TypeInc, unsigned int TypeExc)
	{
		int Count = 0;
		for (map<unsigned long long, BREAK_POINT>::IT it = m_pCodeBPMap->begin();
			it != m_pCodeBPMap->end(); ++it)
		{
			if (CheckAllowType(TypeInc, TypeExc, it->second))
			{
				if (EnableCodeBP(it->second))
					Count++;
			}
		}
		return Count;
	}
	int CDebugger::DisableAllCodeBP(unsigned int TypeInc, unsigned int TypeExc)
	{
		int Count = 0;
		for (map<unsigned long long, BREAK_POINT>::IT it = m_pCodeBPMap->begin();
			it != m_pCodeBPMap->end(); ++it)
		{
			if (CheckAllowType(TypeInc, TypeExc, it->second))
			{
				if (DisableCodeBP(it->second))
					Count++;
			}
		}
		return Count;
	}

	//
	bool CDebugger::EnableCodeBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc)
	{
		BREAK_POINT *BP = GetCodeBP(Address, TypeInc, TypeExc);
		if (BP)
			return EnableCodeBP(*BP);
		return false;
	}
	bool CDebugger::EnableCodeBP(BREAK_POINT & BP)
	{
		if (BP.State == BP_STATE_ENABLE || BP.State == BP_STATE_RECOV)
			return true;

		if (!OpenProcess(BP.ProcessID))
			return false;

		if (SetCodeBreakPoint(BP))
		{
			BP.State = BP_STATE_ENABLE;
			CloseProcess();
			return true;
		} else
		{
			CloseProcess();
			return false;
		}
	}

	//
	bool CDebugger::DisableCodeBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc)
	{
		BREAK_POINT *BP = GetCodeBP(Address, TypeInc, TypeExc);
		if (BP)
			return DisableCodeBP(*BP);
		return false;
	}

	bool CDebugger::DisableCodeBP(BREAK_POINT & BP)
	{
		if (BP.State == BP_STATE_DISABLE)
			return true;

		if (BP.State == BP_STATE_ENABLE)
		{
			if (!OpenProcess(BP.ProcessID))
				return false;

			if (!ClearCodeBreakPoint(BP))
			{
				CloseProcess();
				return false;
			}
			CloseProcess();
		}
		BP.State = BP_STATE_DISABLE;
		return true;
	}

	//DATA
	BREAK_POINT *CDebugger::GetDataBP1(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc)
	{
		TListIter<BREAK_POINT> it = m_pDataBPList->Begin();
		while (it != m_pDataBPList->End())
		{
			if (it->Address == Address && CheckAllowType(TypeInc, TypeExc, *it))
			{
				return &*it;
			}
			++it;
		}
		return nullptr;
	}

	BREAK_POINT *CDebugger::SetDataBP(ULONG_PTR Address, unsigned int Type, unsigned int State, unsigned int Size)
	{
		TListIter<BREAK_POINT> it = m_pDataBPList->Append();
		it->Address = Address;
		it->Type = Type;
		it->State = BP_STATE_DISABLE;
		it->Size = Size;
		it->PatchFN = 0;
		it->ProcessID = m_dwProcessId;
		it->HitCount = 0;
		it->Owner = m_MainModuleName;

		if (State != BP_STATE_ENABLE || SetDataBreakPoint(*it))
		{
			it->State = State;
			return &*it;
		} else
		{
			m_pDataBPList->Remove(it);
			return nullptr;
		}
	}

	//
	bool CDebugger::DelDataBP(BREAK_POINT & BP)
	{
		TListIter<BREAK_POINT> it = &BP;

		if (BP.State == BP_STATE_ENABLE && !ClearDataBreakPoint(BP))
			return false;

		m_pDataBPList->Remove(it);
		return true;

	}
	int CDebugger::DelDataBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc)
	{
		int Count = 0;
		TListIter<BREAK_POINT> it = m_pDataBPList->Begin();
		for (; it != m_pDataBPList->End(); ++it)
		{
			if (it->Address == Address && CheckAllowType(TypeInc, TypeExc, *it))
			{
				DelDataBP(*it);
				Count++;
			}
		}
		return Count;
	}

	//
	int CDebugger::DelAllDataBP(unsigned int TypeInc, unsigned int TypeExc)
	{
		int Count = 0;
		TListIter<BREAK_POINT> it = m_pDataBPList->Begin();
		for (; it != m_pDataBPList->End(); )
		{
			if (CheckAllowType(TypeInc, TypeExc, *it))
			{
				DelDataBP(*it++);
				Count++;
			} else
			{
				it++;
			}
		}
		return Count;

	}

	//
	int CDebugger::EnableAllDataBP(unsigned int TypeInc, unsigned int TypeExc)
	{
		int Count = 0;
		TListIter<BREAK_POINT> it = m_pDataBPList->Begin();
		for (; it != m_pDataBPList->End(); ++it)
		{
			if (CheckAllowType(TypeInc, TypeExc, *it))
			{
				if (EnableDataBP(*it))
					Count++;
			}
		}
		return Count;
	}
	int CDebugger::DisableAllDataBP(unsigned int TypeInc, unsigned int TypeExc)
	{
		int Count = 0;
		TListIter<BREAK_POINT> it = m_pDataBPList->Begin();
		for (; it != m_pDataBPList->End(); ++it)
		{
			if (CheckAllowType(TypeInc, TypeExc, *it))
			{
				if (DisableDataBP(*it))
					Count++;
			}
		}
		return Count;
	}

	//
	int CDebugger::EnableDataBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc)
	{
		int Count = 0;
		TListIter<BREAK_POINT> it = m_pDataBPList->Begin();
		for (; it != m_pDataBPList->End(); ++it)
		{
			if (it->Address == Address && CheckAllowType(TypeInc, TypeExc, *it))
			{
				if (EnableDataBP(*it))
					Count++;
			}
		}
		return Count;
	}
	bool CDebugger::EnableDataBP(BREAK_POINT & BP)
	{
		if (BP.State == BP_STATE_ENABLE || BP.State == BP_STATE_RECOV)
			return true;
		if (!SetDataBreakPoint(BP))
			return false;
		BP.State = BP_STATE_ENABLE;
		return true;
	}

	//
	int CDebugger::DisableDataBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc)
	{
		int Count = 0;
		TListIter<BREAK_POINT> it = m_pDataBPList->Begin();
		for (; it != m_pDataBPList->End(); ++it)
		{
			if (it->Address == Address && CheckAllowType(TypeInc, TypeExc, *it))
			{
				if (DisableDataBP(*it))
					Count++;
			}
		}
		return Count;
	}
	bool CDebugger::DisableDataBP(BREAK_POINT & BP)
	{
		if (BP.State == BP_STATE_DISABLE)
			return true;
		if (BP.State == BP_STATE_ENABLE && !ClearDataBreakPoint(BP))
			return false;
		BP.State = BP_STATE_DISABLE;
		return true;
	}

	//
	int CDebugger::GetDataBP(unsigned int TypeInc, unsigned int TypeExc, TList<BREAK_POINT> *pBPList)
	{
		int Count = 0;
		TListIter<BREAK_POINT> it = m_pDataBPList->Begin();
		for (; it != m_pDataBPList->End(); ++it)
		{
			if (CheckAllowType(TypeInc, TypeExc, *it))
			{
				if (pBPList) pBPList->Append(&*it);
				Count++;
			}
		}
		return Count;
	}

	CDebugger::CDebugger()
		: m_dwProcessId(0)
		, m_dwThreadId(0)
		, m_pCIP(nullptr)
		, m_pDebugInterface(nullptr)
		, m_Status(0)
		, m_pCodeBPMap(&m_CodeBPMap)
		, m_pDataBPList(&m_DataBPList)
	{
	}

	CDebugger::~CDebugger()
	{
	}

	unsigned long CDebugger::Read(ULONG_PTR Address, void *Buffer, unsigned long Size, void *Obj)
	{
		CDebugger *pDebugger = (CDebugger *)Obj;
		return pDebugger->ReadMemory(Address, Buffer, Size);
	}

	bool CDebugger::Init(CDebugInterface *pDebugInterface)
	{
		m_pDebugInterface = pDebugInterface;
		return true;
	}

	void CDebugger::Release()
	{
		m_pDebugInterface = nullptr;
	}

	bool CDebugger::Open(const char *Name) //TODO PARAM
	{
		return true;
	}

	bool CDebugger::Close()
	{
		for (map<CMemoryImage, CDbgModule>::IT it = m_DbgModuleList.m_DbgModuleMap.begin();
			it != m_DbgModuleList.m_DbgModuleMap.end(); ++it)
		{
			if (it->second.m_pSymbolModule) (it->second.m_pSymbolModule->m_RefCount)--;
			if (it->second.m_pCommentModule) (it->second.m_pCommentModule->m_RefCount)--;
		}

		if (m_pDebugInterface)
		{
			if (m_pDebugInterface->m_pSymbolContainer)
				m_pDebugInterface->m_pSymbolContainer->Reset();
			if (m_pDebugInterface->m_pCommentContainer)
				m_pDebugInterface->m_pCommentContainer->Reset();
		}
		m_DbgModuleList.m_DbgModuleMap.clear();
		m_MainModuleName.Empty();
		return true;
	}

	unsigned long CDebugger::WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size)
	{
		return 0;
	}

	unsigned long CDebugger::ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		return 0;
	}

	unsigned long CDebugger::MoveMemory(ULONG_PTR Des, ULONG_PTR Src, unsigned long Length)
	{
		unsigned char Buffer[256];
		unsigned long Count = 0;
		while (Length)
		{
			unsigned long Size = MIN(Length, lenof(Buffer));

			unsigned long RSize = ReadMemory(Src + Count, Buffer, Size);
			if (RSize != Size)
				return Count;

			unsigned long WSize = WriteMemory(Des + Count, Buffer, Size);
			if (WSize != Size)
				return Count;

			Count += Size;
			if (Length < Size)
				break;
			Length -= Size;
		}
		return Count;
	}

	unsigned long CDebugger::CompareMemory(ULONG_PTR Des, ULONG_PTR Src, unsigned long Length)
	{
		if (Length == 0)
			return 0;

		unsigned char *pSrcBuf = new unsigned char[Length];
		unsigned char *pDesBuf = new unsigned char[Length];

		unsigned long RSrcSize = ReadMemory(Src, pSrcBuf, Length);
		MAX_LIMIT(Length, RSrcSize);

		unsigned long RDesSize = ReadMemory(Des, pDesBuf, Length);
		MAX_LIMIT(Length, RDesSize);

		unsigned long i;
		for (i = 0; i < Length; ++i)
		{
			if (pSrcBuf[i] != pDesBuf[i])
				break;
		}

		delete []pSrcBuf;
		delete []pDesBuf;
		return i;
	}

	ULONG_PTR CDebugger::SearchMemory(ULONG_PTR Address, unsigned long Length, const void *Pattern, unsigned long PatternLength, bool bCaseCmp)
	{
		unsigned char PatternBuffer[4096];

		if (PatternLength > 4096)
			return -1;

		unsigned long next = 0;
		unsigned long last = 0;
		for (unsigned long i = 0; i < Length - PatternLength; ++i)
		{
			if (next < PatternLength + i)
			{
				unsigned long RDSize = MIN(Length - i, 4096);
				ULONG_PTR offset = Address + i;
				last = i;
				RDSize = ReadMemory(offset, PatternBuffer, RDSize);
				if (RDSize == 0)
				{
					i = (offset & ~((ULONG_PTR)4096-1)) + 4096 - Address - 1;
					next = i;
					continue;
				}
				next = RDSize + i;
			}

			if (bCaseCmp)
			{
				if (!memcmp(&PatternBuffer[i - last], Pattern, PatternLength))
					return Address + i;
			} else
			if (!TMemICmp((char*)&PatternBuffer[i - last], (char*)Pattern, PatternLength))
			{
				return Address + i;
			}
		}
		return -1;
	}

	bool CDebugger::SetSingleStep()
	{
		return true;
	}
	bool CDebugger::RemoveSingleStep()
	{
		return true;
	}

	bool CDebugger::SaveRegisters()
	{
		return true;
	}

	bool CDebugger::UpdateRegisters()
	{
		return true;
	}

	bool CDebugger::SetCodeBreakPoint(BREAK_POINT & BP)
	{
		return true;
	}
	bool CDebugger::ClearCodeBreakPoint(BREAK_POINT & BP)
	{
		return true;
	}
	bool CDebugger::SetDataBreakPoint(BREAK_POINT & BP)
	{
		return true;
	}
	bool CDebugger::ClearDataBreakPoint(BREAK_POINT & BP)
	{
		return true;
	}

	bool CDebugger::GetMemoryAddress(ULONG_PTR Address, unsigned long long *RealAddress)
	{
		*RealAddress = (unsigned long long)Address;
		return true;
	}

	bool CDebugger::OpenProcess(unsigned long dwProcessId)
	{
		return true;
	}

	void CDebugger::CloseProcess()
	{
	}

	bool CDebugger::Pause()
	{
		return true;
	}

	bool CDebugger::ContinueDebug(bool bRestoreScr)
	{
		return false;
	}
#if 0
	bool CDebugger::GetStack(STACK_FRAME *pStackFrame)
	{
		return false;
	}
#endif
///
	bool CDebugInterface::Continue()
	{
		switch (m_State)
		{
		case 0:
			return true;

		case TRACE_RANGE_IN:
			if (*GetDebugger()->m_pCIP < m_MinCIP || *GetDebugger()->m_pCIP >= m_MaxCIP)
			{
				RunCmd("T");
				return false;
			}
			Reset();
			return true;
		case TRACE_RANGE_OUT:
			if (*GetDebugger()->m_pCIP >= m_MinCIP && *GetDebugger()->m_pCIP < m_MaxCIP)
			{
				RunCmd("T");
				return false;
			}
			Reset();
			return true;

		case STEP_RANGE_IN:
			if (*GetDebugger()->m_pCIP < m_MinCIP || *GetDebugger()->m_pCIP >= m_MaxCIP)
			{
				RunCmd("P");
				return false;
			}
			Reset();
			return true;
		case STEP_RANGE_OUT:
			if (*GetDebugger()->m_pCIP >= m_MinCIP && *GetDebugger()->m_pCIP < m_MaxCIP)
			{
				RunCmd("P");
				return false;
			}
			Reset();
			return true;

		case TRACE_UNTIL:
			if (--m_Until > 0)
			{
				RunCmd("T");
				return false;
			}
			Reset();
			return true;

		case STEP_UNTIL:
			if (--m_Until > 0)
			{
				RunCmd("P");
				return false;
			}
			Reset();
			return true;

		case TRACE_CONDITION:
			OnTestCondition();
			if (!TestCondition(m_Condition, 0))
			{
				if (++m_Until < 0x100000)
				{
					RunCmd("T");
					return false;
				}
				Reset();
				return false;
			}
			Reset();
			return true;

		case STEP_CONDITION:
			OnTestCondition();
			if (!TestCondition(m_Condition, 0))
			{
				if (++m_Until < 0x100000)
				{
					RunCmd("P");
					return false;
				}
				Reset();
				return false;
			}
			Reset();
			return true;

		case RETURN_UNTIL:
			unsigned char Data;

			if (m_pCodeDoc->ReadMemory(*GetDebugger()->m_pCIP, &Data, 1))
			{
				//ProcessPCommandRetCode
				switch (Data)
				{
				case 0xC2: //RETN
				case 0xC3: //RETN imm16
				case 0xCA: //RETF imm16
				case 0xCB: //RETF
				case 0xCF: //IRET/IRETD
					Reset();
					return true;
				}
			}

			if (++m_Until < 0x100000)
			{
				RunCmd("P");
				return false;
			}

			Reset();
			return false;

		case BPR_IN:
			return BreakBPR();

		case RESET_STATE:
			Reset();
			return false;

		default:
			return false;
		}
		return false; //???
	}

	void CDebugInterface::Trace(ULONG_PTR MinCIP, ULONG_PTR MaxCIP, bool State)
	{
		m_State = State ? TRACE_RANGE_IN:TRACE_RANGE_OUT;
		m_MinCIP = MinCIP;
		m_MaxCIP = MaxCIP;
	}

	void CDebugInterface::Step(ULONG_PTR MinCIP, ULONG_PTR MaxCIP, bool State)
	{
		m_State = State ? STEP_RANGE_IN:STEP_RANGE_OUT;
		m_MinCIP = MinCIP;
		m_MaxCIP = MaxCIP;
	}

	void CDebugInterface::Trace(const char *Condition)
	{
		m_State = TRACE_CONDITION;
		m_Condition = Condition;
		m_Until = 0;
	}

	void CDebugInterface::Step(const char *Condition)
	{
		m_State = STEP_CONDITION;
		m_Condition = Condition;
		m_Until = 0;
	}

	void CDebugInterface::SetBPR(ULONG_PTR PageAddress, ULONG_PTR Address) //++
	{
		m_State = BPR_IN;
		m_PageAddress = PageAddress;
		m_Address = Address;
	}

	void CDebugInterface::Trace(unsigned long Count)
	{
		m_State = TRACE_UNTIL;
		m_Until = Count;
	}

	void CDebugInterface::Step(unsigned long Count)
	{
		m_State = STEP_UNTIL;
		m_Until = Count;
	}

	void CDebugInterface::Return(CDebugger *pDebugger)
	{
		m_State = RETURN_UNTIL;
		m_Until = 0;
		m_pReturn = pDebugger;
	}

	void CDebugInterface::Reset()
	{
		m_State = 0;
		m_Until = 0;
		m_MaxCIP = 0;
		m_MinCIP = 0;
		m_Condition.Empty();
	}

```

`source/EXEAnalyzer/debugger.hpp`:

```hpp

#ifndef _DEBUGGER_HPP_
#define _DEBUGGER_HPP_

//#define CODE_OS_DEFINED

//modules
#include "../Code/define.h"
#include "../Code/tstrmem.hpp"
#include "../Code/alt/altlist.hpp"
#include "../Code/alt/altmap.hpp"
#include "symbol.hpp"

	enum BP_STATE
	{
		BP_STATE_DISABLE = 0,
		BP_STATE_ENABLE = 1,
		BP_STATE_RECOV = 2,
		BP_STATE_REMOVE = 3,
	};

	//0x001 //BP_CODE ??? GLOBAL
	//0x002 //BP_EXECUTE
	//0x004 //BP_WRITE
	//0x008 //BP_READ ???
	//0x010 //IO
	//0x020 //IO
	//0x040
	//0x080
	//0x100 //BP_PATCH
	//0x200 //BP_SLNC
	//0x400 //BP_ONCE ONLOAD
	//0x800

	struct BREAK_POINT
	{
		struct MODULE
		{
			TAnsiString ModuleName;
			TAnsiString Condition;
			TAnsiString Name;
			TAnsiString Command;
			unsigned int State; //BP_STATE
			//???
		};

		TAnsiString Name;
		TAnsiString TypeName;
		TAnsiString Condition;
		TAnsiString Owner;
		TAnsiString Command;
		unsigned long HitCount;
		ULONG_PTR Address;
		unsigned long ProcessID;
		unsigned int State; //BP_STATE
		unsigned int Type;
		unsigned long Size;
		unsigned long long PatchFN;
		MODULE *pModule;
		union
		{
			struct 
			{
				unsigned char DRIndex;
				unsigned char Align;
			} X86_DR;
			unsigned char CCBackup;
		};
#if 0
		bool operator==(const BREAK_POINT & BP) const
		{
			if (Name != BP.Name) return false;
			if (TypeName != BP.TypeName) return false;
			if (Condition != BP.Condition) return false;
			if (Owner != BP.Owner) return false;
			if (Command != BP.Command) return false;
			if (HitCount != BP.HitCount) return false;
			if (Address != BP.Address) return false;
			if (ProcessID != BP.ProcessID) return false;
			if (State != BP.State) return false;
			if (Type != BP.Type) return false;
			if (Size != BP.Size) return false;
			if (PatchFN != BP.PatchFN) return false;
			if (pModule != BP.pModule) return false;
			//???
			return true;
		} //??? TODO std::map require
#endif
	};

	enum BP_STATUS
	{
		BP_STATUS_NEW_BP  = 0, //OK
		BP_STATUS_NO_PID  = 1,
		BP_STATUS_NO_ADDR  = 2,
		BP_STATUS_EXIST_BP  = 3,
		BP_STATUS_NOT_EXIST_BP  = 4,
		BP_STATUS_FAIL_ADD_BP  = 5,
		BP_STATUS_FAIL_DEL_BP  = 6,
	};

	struct STACK_FRAME
	{
		ULONG_PTR AddrPC;
		ULONG_PTR AddrReturn;
		ULONG_PTR AddrFrame;
		ULONG_PTR AddrStack;		
	};

	struct CDebugInterface;
	struct CDebugger
	{
		map<unsigned long long, BREAK_POINT> m_CodeBPMap;
		TList<BREAK_POINT> m_DataBPList;
		unsigned long m_dwProcessId;
		unsigned long m_dwThreadId;
		TAnsiString m_MainModuleName;
		ULONG_PTR *m_pCIP;
		CDebugInterface *m_pDebugInterface;
	//	unsigned long m_DebugParam;
	//	void *m_DebugParamPtr;
		CDbgModuleList m_DbgModuleList;
		map<unsigned long long, BREAK_POINT> *m_pCodeBPMap;
		TList<BREAK_POINT> *m_pDataBPList;
		unsigned int m_Status;
	public:
		CDebugger();
		virtual ~CDebugger();

		static unsigned long Read(ULONG_PTR Address, void *Buffer, unsigned long Size, void *Obj);

		virtual bool Init(CDebugInterface *pDebugInterface);
		virtual void Release();
		virtual bool Open(const char *Name); //{ return true; } //unsigned long DebugParam, void *DebugParamPtr
		virtual bool Close();
		virtual unsigned long WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size); //{ return false; }
		virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size); //{ return false; }
		virtual unsigned long MoveMemory(ULONG_PTR Des, ULONG_PTR Src, unsigned long Length);
		virtual unsigned long CompareMemory(ULONG_PTR Des, ULONG_PTR Src, unsigned long Length);
		virtual ULONG_PTR SearchMemory(ULONG_PTR Address, unsigned long Length, const void *Pattern, unsigned long PatternLength, bool bCaseCmp);

		virtual bool SaveRegisters(); //{ return true; }
		virtual bool UpdateRegisters(); //{ return true; }

		virtual bool SetCodeBreakPoint(BREAK_POINT & BP); //{ return true; }
		virtual bool ClearCodeBreakPoint(BREAK_POINT & BP); //{ return true; }
		virtual bool SetDataBreakPoint(BREAK_POINT & BP); //{ return true; }
		virtual bool ClearDataBreakPoint(BREAK_POINT & BP); //{ return true; }

		virtual bool GetMemoryAddress(ULONG_PTR, unsigned long long *RealAddress);
		virtual bool OpenProcess(unsigned long dwProcessId); //{ return true; }
		virtual void CloseProcess(); //{ }

		virtual bool SetSingleStep(); //{ return true; }
		virtual bool RemoveSingleStep(); //{ return true; }
	//	virtual bool Reset();
		virtual bool Pause(); //{ return true; }
		virtual bool ContinueDebug(bool bRestoreScr); //{ return false; }
#if 0
		virtual bool GetStack(STACK_FRAME *pStackFrame);// { return false; }
#endif
		static bool CheckAllowType(unsigned int TypeInc, unsigned int TypeExc, const BREAK_POINT & BP);

		// CODE

		virtual BREAK_POINT *GetCodeBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc);

		virtual BREAK_POINT *SetCodeBP(ULONG_PTR Address, unsigned int Type, unsigned int State);

		virtual bool DelCodeBP(BREAK_POINT & BP);
		virtual bool DelCodeBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc);

		virtual int DelAllCodeBP(unsigned int TypeInc, unsigned int TypeExc);

		virtual int EnableAllCodeBP(unsigned int TypeInc, unsigned int TypeExc);
		virtual int DisableAllCodeBP(unsigned int TypeInc, unsigned int TypeExc);

		virtual bool EnableCodeBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc);
		virtual bool EnableCodeBP(BREAK_POINT & BP);

		virtual bool DisableCodeBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc);
		virtual bool DisableCodeBP(BREAK_POINT & BP);

		// DATA
		virtual BREAK_POINT *GetDataBP1(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc);

		virtual int GetDataBP(unsigned int TypeInc, unsigned int TypeExc, TList<BREAK_POINT> *pBPList);

		virtual BREAK_POINT *SetDataBP(ULONG_PTR Address, unsigned int Type, unsigned int State, unsigned int Size);

		virtual bool DelDataBP(BREAK_POINT & BP);
		virtual int DelDataBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc);

		virtual int DelAllDataBP(unsigned int TypeInc, unsigned int TypeExc);

		virtual int EnableAllDataBP(unsigned int TypeInc, unsigned int TypeExc);
		virtual int DisableAllDataBP(unsigned int TypeInc, unsigned int TypeExc);

		virtual int EnableDataBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc);
		virtual bool EnableDataBP(BREAK_POINT & BP);

		virtual int DisableDataBP(ULONG_PTR Address, unsigned int TypeInc, unsigned int TypeExc);
		virtual bool DisableDataBP(BREAK_POINT & BP);
	};

	struct CCodeDoc
	{
		bool m_bOpen;

		ULONG_PTR m_BeginAddr;
		ULONG_PTR m_EndAddr;
	public:
		CCodeDoc()
			: m_bOpen(false)
			, m_BeginAddr(0) //m_ImageBase
			, m_EndAddr(-1) //m_ImageHighBase
		{
		}

		virtual ~CCodeDoc()
		{
		}

		virtual bool Open(const char *szModule) //04 //TODO PARAM
		{
			m_bOpen = true;
			return true;
		}
		virtual void Close()			//08
		{
			m_bOpen = false;
		}
		virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) = 0;	//0C
		virtual ULONG_PTR GetInstrAddress(ULONG_PTR Address, long Count) = 0;	//10

		virtual bool GetSymbol(ULONG_PTR Address, WCHAR *szName, int Length) { return false; }	//14
		virtual bool GetComment(ULONG_PTR Address, WCHAR *szName, int Length) { return false; }	//18
		virtual bool SetComment(ULONG_PTR Address, const WCHAR *szName) { return false; }			//1C
		virtual bool GetFunction(ULONG_PTR Address, WCHAR *szName, int Length) { return GetSymbol(Address, szName, Length); }	//20
		virtual unsigned long GetPic(ULONG_PTR Address) { return 1; } //24
	};

	enum
	{
		CONTINUE	= 0,
		TRACE_RANGE_IN	= 1,
		TRACE_RANGE_OUT	= 2,
		STEP_RANGE_IN	= 3,
		STEP_RANGE_OUT	= 4,
		
		TRACE_UNTIL	= 5,
		STEP_UNTIL	= 6,

		TRACE_CONDITION	= 7,
		STEP_CONDITION	= 8,

		RETURN_UNTIL	= 9,
		
		BPR_IN		= 10,
		RESET_STATE	= 11,
	};

	enum
	{
		PLUNGE_START = 0,
		PLUNGE_BREAK_POINT = 1,

		PLUNGE_ACCESS_VIOLATION = 4,
		PLUNGE_BREAK = 5,
	};

	struct CDebugInterface
	{
		CCodeDoc *m_pCodeDoc;
		CSymbolContainer *m_pSymbolContainer;
		CCommentContainer *m_pCommentContainer;
		TAnsiString m_Condition;
		CDebugger *m_pReturn;
		unsigned int m_Until;
		unsigned int m_State;
		ULONG_PTR m_MinCIP;
		ULONG_PTR m_MaxCIP;
		ULONG_PTR m_PageAddress;
		ULONG_PTR m_Address;
	public:
		virtual void OnLoadModule(CDebugger *pDebugger, const char *szName, ULONG_PTR ImageBase, unsigned long ImageSize, unsigned long TimeStamp, unsigned long CheckSum) = 0;
		virtual void OnUnloadModule(CDebugger *pDebugger, ULONG_PTR ImageBase) = 0;
		virtual void OnTestCondition() {}

		virtual bool Close(bool bExit) = 0;
		virtual bool Plunge(unsigned int Code) = 0;

		virtual bool OnExit(bool bExit) = 0;
		virtual bool OnDebugException(unsigned int Code) = 0;

		virtual void DisplayMsg(const char *szMsg) {}
		virtual void UpdateContext() {}
		virtual bool TestCondition(const char *Condition, BREAK_POINT *BreakPoint) { return true; }
		virtual bool RunCmd(const char *szCmd) { return false; }
		virtual void RunCmds(const char *szCmds) {}

		virtual bool Continue();
		virtual void Trace(ULONG_PTR MinCIP, ULONG_PTR MaxCIP, bool State);
		virtual void Step(ULONG_PTR MinCIP, ULONG_PTR MaxCIP, bool State);
		virtual void Trace(const char *Condition);
		virtual void Step(const char *Condition);
		virtual void SetBPR(ULONG_PTR PageAddress, ULONG_PTR Address); //++
		virtual void Trace(unsigned long Count);
		virtual void Step(unsigned long Count);
		virtual void Return(CDebugger *pDebugger);
		virtual void Reset();
		virtual bool BreakBPR() { return true; } //++
		virtual CDebugger *GetDebugger() = 0;
	};


#endif

```

`source/EXEAnalyzer/instrsym.cpp`:

```cpp

#include "instrsym.hpp"

	const WCHAR *CInstrSym::m_RegStr[3][GENE_IDX_MAX] = {
		{WSTR("AX"),WSTR("CX"),WSTR("DX"),WSTR("BX"),WSTR("SP"),WSTR("BP"),WSTR("SI"),WSTR("DI"),
		WSTR("R8W"),WSTR("R9W"),WSTR("R10W"),WSTR("R11W"),WSTR("R12W"),WSTR("R13W"),WSTR("R14W"),WSTR("R15W"),},

		{WSTR("EAX"),WSTR("ECX"),WSTR("EDX"),WSTR("EBX"),WSTR("ESP"),WSTR("EBP"),WSTR("ESI"),WSTR("EDI"),
		WSTR("R8D"),WSTR("R9D"),WSTR("R10D"),WSTR("R11D"),WSTR("R12D"),WSTR("R13D"),WSTR("R14D"),WSTR("R15D"),},

		{WSTR("RAX"),WSTR("RCX"),WSTR("RDX"),WSTR("RBX"),WSTR("RSP"),WSTR("RBP"),WSTR("RSI"),WSTR("RDI"),
		WSTR("R8"),WSTR("R9"),WSTR("R10"),WSTR("R11"),WSTR("R12"),WSTR("R13"),WSTR("R14"),WSTR("R15"),}};

	const WCHAR *CInstrSym::m_ScaleStr[4] = {
		WSTR("1"),WSTR("2"),WSTR("4"),WSTR("8")};

	const WCHAR *CInstrSym::m_SizePtr[8+1] = {
		WSTR("Err"),WSTR("%X"),WSTR("%X"),WSTR("Err"),WSTR("%X"),WSTR("Err"),WSTR("Err"),WSTR("Err"),WSTR("%I64X")};

	const WCHAR *CInstrSym::m_SizeSym[10+1] = {
		WSTR(""),WSTR("BYTE"),WSTR("WORD"),WSTR(""),WSTR("DWORD"),WSTR(""),WSTR("FWORD"),WSTR(""),WSTR("QWORD"),WSTR(""),WSTR("TWORD")};

	const WCHAR *CInstrSym::m_SegStr[SEG_IDX_MAX] = {
		WSTR("ES"),WSTR("CS"),WSTR("SS"),WSTR("DS"),WSTR("FS"),WSTR("GS")};

	const WCHAR *CInstrSym::m_LengthStr[4+1] = {
		WSTR("DB"),WSTR("DB"),WSTR("DW"),WSTR("Err"),WSTR("DD")};

	const WCHAR *CInstrSym::m_DefaultOPSize[3] = {
		WSTR("%04X"),WSTR("%08X"), WSTR("%016I64X")};

	unsigned int GetSize(unsigned long long Address)
	{
	//#ifdef _X64_
		if (Address & 0xFFFFFFFF00000000) return 8;
	//#endif
		if (Address & 0xFFFF0000) return 4;
		if (Address & 0xFF00) return 2;
		return 1;
	}

	bool GetSign(_DIS_ADDRESS *dis_a)
	{
		switch (dis_a->displacement_size)
		{
		case 1:
			//return dis_a->displacement < 0x80;
		case 2:
			return dis_a->displacement < 0xFFFFFF00;
		case 4:
			return dis_a->displacement < 0xFFFF0000;
		case 8:
			return true;
		default:;
		}
		return false;
	}

	bool CInstrSym::AddrToSym(ULONG_PTR Address, char *szSym, unsigned int SymLen)
	{
		return false;
	}

	unsigned long CInstrSym::ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		for (unsigned long i = 0; i < Size; ++i)
			static_cast<BYTE*>(Buffer)[i] = Address + i;
		return Size;
	}

	bool CInstrSym::GetSymbolBase(ULONG_PTR *BaseAddr)
	{
		return false;
	}

	WCHAR *CInstrSym::OptItemToCS(_OPERAND_ITEM *OpArray, int nOp, WCHAR *pString, _INSTRUCTION_INFORMATION *pDasmInstr)
	{
		WCHAR szBuffer[32];

		for (int i = 0; i < nOp; ++i)
		{
			_OPERAND_ITEM *pOp = &OpArray[i];
			if (OpArray[i].mode == OP_Invalid)
				break;

			if (i > 0)
				pString += TStrCpy(pString, ",");

			if (pOp->mode == OP_Address)
			{
				_DIS_ADDRESS *pAddr = (_DIS_ADDRESS *)&pOp->addr;
				pString += TStrCpy(pString, ",");
				if (pOp->opersize != -1)
				{
					pString += TStrCpy(pString, CInstrSym::m_SizeSym[pOp->opersize]);
					pString += TStrCpy(pString, " PTR ");
				}

				if (pDasmInstr->SegmentPrefix != -1)
				{
					pString += TStrCpy(pString, CInstrSym::m_SegStr[pDasmInstr->SegmentPrefix]);
					pString += TStrCpy(pString, ":");
				}

				pString += TStrCpy(pString, "[");
				if (pAddr->base != -1)
					pString += TStrCpy(pString, CInstrSym::m_RegStr[pAddr->address_size][pAddr->base]);

				if (pAddr->index != -1)
				{
					if (pAddr->base != -1)
						pString += TStrCpy(pString, "+");

					pString += TStrCpy(pString, CInstrSym::m_RegStr[pAddr->address_size][pAddr->index]);
					if (pAddr->scale > 1)
					{
						pString += TStrCpy(pString, "*");
						pString += TStrCpy(pString, CInstrSym::m_ScaleStr[pAddr->scale]);
					}
				}

				if (pAddr->displacement || (pAddr->base == -1 && pAddr->index == -1))
				{
					if (pAddr->index != -1 || pAddr->base != -1)
					{
						if (GetSign(pAddr))
						{
							pString += TStrCpy(pString, "+");
							TSPrintf(szBuffer, CInstrSym::m_SizePtr[GetSize(pAddr->displacement)], pAddr->displacement);
						} else
						{
							pString += TStrCpy(pString, "-");
							TSPrintf(szBuffer, CInstrSym::m_SizePtr[GetSize(pAddr->displacement)], -pAddr->displacement);
						}
					} else
					{
						TSPrintf(szBuffer, CInstrSym::m_SizePtr[GetSize(pAddr->displacement)], pAddr->displacement);
					}

					pString += TStrCpy(pString, szBuffer);
				}
				pString += TStrCpy(pString, "]");
			} else
			{
				switch (pOp->mode)
				{

				case OP_Register:
				case OP_Segment:
				case OP_Immed:
				case OP_Near:
					pString += TStrCpy(pString, pOp->string);
					break;
				case OP_Far:
					TSPrintf(szBuffer, WSTR("%04X"), pOp->farptr.segment);
					pString += TStrCpy(pString, szBuffer);
					pString += TStrCpy(pString, WSTR(":"));
					TSPrintf(szBuffer, CInstrSym::m_SizePtr[pOp->opersize+2], pOp->farptr.offset); //???
					pString += TStrCpy(pString, szBuffer);
					break;
				case OP_Datadup:
					if (i <= 0)
					for (i = 0; i < pOp->datadup.count; ++i)
					{
						if (i > 0)
							pString += TStrCpy(pString, WSTR(","));
						TSPrintf(szBuffer, WSTR("%02X"), pOp->datadup.buffer[i]);
						pString += TStrCpy(pString, szBuffer);
					}
					break;
				case OP_Symbol:
					if (pOp->symbol.boffset)
						pString += TStrCpy(pString, WSTR("OFFSET "));
					pString +=TStrCpy(pString, pOp->symbol.string);
					break;
				case OP_Align:
					if (i <= 0)
					{
						TSPrintf(szBuffer, WSTR("%X"), pOp->align.nBytes);
						pString += TStrCpy(pString, szBuffer);
					}
					break;
				default: break;
				}
			}
		}
		return pString;
	}

	void CInstrSym::OptItemSymToCS(_OPERAND_ITEM *OpArray, WCHAR *pString, _INSTRUCTION_INFORMATION *pDasmInstr)
	{
		pString = OptItemToCS(OpArray, 1, pString, pDasmInstr);
		pString += TStrCpy(pString, " = ");

		if (OpArray->addr.base != -1 || OpArray->addr.index != -1 || pDasmInstr->SegmentPrefix != -1)
		{
			pString += TStrCpy(pString, "[");
			pString += TSPrintf(pString, CInstrSym::m_SizePtr[GetSize(OpArray->addr.line_address)], OpArray->addr.line_address);
			pString += TStrCpy(pString, "] = ");
		}
		//TODO
		unsigned long Size = OpArray->opersize;
		if (Size < 1 || Size > 8)
			Size = 8;
		unsigned long long Value = 0;
		if (ReadMemory(OpArray->addr.line_address, &Value, Size) == Size)
		{
			pString += TSPrintf(pString, CInstrSym::m_SizePtr[GetSize(Value)], Value);
			char szSym[64+64];
			if (AddrToSym(Value, szSym, 64))
			{
				pString += TStrCpy(pString, " = ");
				TStrCpy(pString, szSym);
			}
		} else
		{
			TStrCpy(pString, "????");
		}		
	}

	WCHAR *CInstrSym::InstrToCS(_INSTRUCTION_INFORMATION *pInstrInfo, WCHAR *pString)
	{
		bool bFirstStr = true;
		if (pInstrInfo->Lock != -1)
		{
			TStrCpy(pString, pInstrInfo->LockName);
			TStrCat(pString, " ");
			pString += TStrFillTail(pString, 6, (WCHAR)0x20);
			bFirstStr = false;
		}

		if (pInstrInfo->Repeat != -1)
		{
			TStrCpy(pString, pInstrInfo->RepeatName);
			TStrCat(pString, " ");

			if (bFirstStr)
			{
				pString += TStrFillTail(pString, 6, (WCHAR)0x20);
				bFirstStr = false;
			} else
			{
				pString += TStrLen(pString);
			}
			pString += TStrLen(pString);
		}

		TStrCpy(pString, pInstrInfo->Name);
		TStrCat(pString, " ");

		if (pInstrInfo->Name[0] && bFirstStr)
			pString += TStrFillTail(pString, 6, (WCHAR)0x20);
		else	pString += TStrLen(pString);
		return OptItemToCS(pInstrInfo->op, 3, pString, pInstrInfo);
	}


	CInstrSym::CInstrSym()
		: m_bUseSym(true)
		, m_ImageBase(0)
		, m_ImageHighBase(0)
		, m_UxAlign(6)
		, m_Style(3) //2|1
	{
	#ifdef _X64_
		m_Mode = CODE_MODE_64;
	#else
		m_Mode = CODE_MODE_32;
	#endif
	}

	CInstrSym::~CInstrSym()
	{
	}

	void CInstrSym::SetDasmStyle(unsigned long Style)
	{
		m_Style = Style;
	}
	unsigned long CInstrSym::GetDasmStyle() const
	{
		return m_Style;
	}

	bool CInstrSym::GetJump(unsigned char *CodeBuff, ULONG_PTR Address, ULONG_PTR *target)
	{
		//jear
		if (CodeBuff[0] == 0xEB) //JMP rel8
		{
			if (target)
				*target = Address + (char)CodeBuff[1] + 2;
			return true;
		}

		if (CodeBuff[0] >= 0x70 && CodeBuff[0] <= 0x7F) //Jxx rel8
		{
			if (target)
				*target = Address + (char)CodeBuff[1] + 2;
			return true;
		}

		//short
		if (CodeBuff[0] == 0xF && CodeBuff[1] >= 0x80 && CodeBuff[1] <= 0x8F) //+++ Jxx near rel16/32
		{
			if (target)
				*target = Address + *(unsigned long*)(CodeBuff+2) + 6;
			return true;
		}

		//far
		if (CodeBuff[0] == 0xE8 || CodeBuff[0] == 0xE9) //+++
		{
			if (target)
				*target = Address + *(unsigned long*)(CodeBuff+1) + 5;
			return true;
		}
		return false;
	}

	bool CInstrSym::CheckJump(unsigned char *CodeBuff, unsigned long eflags)
	{
		bool result = false;
		switch (CodeBuff[0]) //TODO EFL
		{
		case 0x70:
			result = (eflags & 0x800) != 0;
			break;
		case 0x71:
			result = (eflags & 0x800) == 0;
			break;
		case 0x72:
			result = (eflags & 1) != 0;
			break;
		case 0x73:
			result = (eflags & 1) == 0;
			break;
		case 0x74:
			result = (eflags & 0x40) != 0;
			break;
		case 0x75:
			result = (eflags & 0x40) == 0;
			break;
		case 0x76:
			result = (eflags & 0x40) && (eflags & 1);
			break;
		case 0x77:
			result = !(eflags & 0x40) && !(eflags & 1);
			break;
		case 0x78:
			result = (eflags & 0x80) != 0;
			break;
		case 0x79:
			result = (eflags & 0x80) == 0;
			break;
		case 0x7A:
			result = (eflags & 4) != 0;
			break;
		case 0x7B:
			result = (eflags & 4) == 0;
			break;
		case 0x7C:
			result = (unsigned short)(eflags & 0x800) >> 11 != (unsigned char)(eflags & 0x80) >> 7;
			break;
		case 0x7D:
			result = (unsigned short)(eflags & 0x800) >> 11 == (unsigned char)(eflags & 0x80) >> 7;
			break;
		case 0x7E:
			result = (unsigned short)(eflags & 0x800) >> 11 != (unsigned char)(eflags & 0x80) >> 7 && (eflags & 0x40);
			break;
		case 0x7F:
			result = (unsigned short)(eflags & 0x800) >> 11 == (unsigned char)(eflags & 0x80) >> 7 && !(eflags & 0x40);
			break;
		default:
			result = 0;
			break;
		}
		return result;
	}

	unsigned long CInstrSym::Dasm(_INSTRUCTION_INFORMATION *pDasmInstr, DIS_CPU *pDisCPU, unsigned long MaxSize)
	{
		unsigned long Size = ReadMemory(pDasmInstr->eip, pDasmInstr->CodeBuff, MAX_INSTR_LEN);
		if (Size == 0)
		{
			pDasmInstr->OpCode = -1;
			strcpy(pDasmInstr->Name, "???");
			pDasmInstr->Lock = -1;
			pDasmInstr->Repeat = -1;
			pDasmInstr->SegmentPrefix = -1;
			pDasmInstr->op[0].mode = OP_Invalid;
			pDasmInstr->op[1].mode = OP_Invalid;
			pDasmInstr->op[2].mode = OP_Invalid;
			return 0;
		}

		MAX_LIMIT(Size, MaxSize);
		unsigned long CodeLen = CIntelDisassembler::Disassembler(pDasmInstr, pDisCPU);
		if (CodeLen == 0 || CodeLen > Size)
		{
			MAX_LIMIT(CodeLen, Size);
			pDasmInstr->OpCode = -1;
			strcpy(pDasmInstr->Name, "DB");
			pDasmInstr->Lock = -1;
			pDasmInstr->Repeat = -1;
			pDasmInstr->SegmentPrefix = -1;
			pDasmInstr->op[1].mode = OP_Invalid;
			pDasmInstr->op[2].mode = OP_Invalid;

			pDasmInstr->op[0].mode = OP_Datadup;
			pDasmInstr->op[0].datadup.count = 1;
			if (pDasmInstr->CodeBuff)
				memcpy(pDasmInstr->op[0].datadup.buffer, pDasmInstr->CodeBuff, 1);
			return 0;
		}

		if (m_Style & 1)
		{
#define X86_INSTR_CALL_IND      0x15FF      // call dword ptr[addr32]
#define X86_INSTR_JMP_IND       0x25FF      // jmp dword ptr[addr32]
#define X86_INSTR_JMP_REL32     0xE9        // jmp rel32
			ULONG_PTR Addr;

			bool Decode = false;

			if ((*(WORD*)pDasmInstr->CodeBuff == 0x15FF ||
			     *(WORD*)pDasmInstr->CodeBuff == 0x25FF) &&
				ReadMemory(*(DWORD*)(pDasmInstr->CodeBuff + 2), &Addr, sizeof(Addr)) == sizeof(Addr)
			   )
			{
				if (AddrToSym(Addr, pDasmInstr->op[0].symbol.string, 64))
				{
					pDasmInstr->op[0].symbol.mode = pDasmInstr->op[0].mode;
					pDasmInstr->op[0].mode = OP_Symbol;
					pDasmInstr->op[0].symbol.boffset = 0;
					pDasmInstr->op[0].symbol.offset = Addr;
					return CodeLen;
				}
			} else
				Decode = true;

			if (Decode || ((m_Style & 2) && !TStrCmp(pDasmInstr->Name, "CALL") &&
				pDasmInstr->op[0].mode == OP_Near))
			{
				unsigned char Buffer[MAX_INSTR_LEN]; 
				_INSTRUCTION_INFORMATION DasmInstr;

				DasmInstr.pasm = nullptr;
				DasmInstr.CodeMode = pDasmInstr->CodeMode;
				DasmInstr.eip = pDasmInstr->op[0].nearptr.label;
				DasmInstr.CodeBuff = Buffer;

				unsigned long OldStyle = m_Style;
				m_Style &= ~2;
				Dasm(&DasmInstr, 0, sizeof(Buffer));
				m_Style = OldStyle;

				if (*(WORD *)DasmInstr.CodeBuff == 0x15FF || 
				    *(WORD *)DasmInstr.CodeBuff == 0x25FF ||
					(*DasmInstr.CodeBuff == 0xE9 && DasmInstr.op[0].mode == OP_Symbol))
				{
					TStrCpy(pDasmInstr->op[0].symbol.string, DasmInstr.op[0].symbol.string);
					pDasmInstr->op[0].symbol.mode = pDasmInstr->op[0].mode;
					pDasmInstr->op[0].mode = OP_Symbol;
					pDasmInstr->op[0].symbol.boffset = 0;
					pDasmInstr->op[0].symbol.offset = DasmInstr.op[0].symbol.offset;
					return CodeLen;
				}
			}

			for (int i = 0; i < 3; ++i)
			{
				switch (pDasmInstr->op[i].mode)
				{
				case OP_Immed:
					Addr = pDasmInstr->op[i].immed.immed_value;
					if (AddrToSym(Addr, pDasmInstr->op[i].symbol.string, 64))
					{
						pDasmInstr->op[i].symbol.mode = pDasmInstr->op[i].mode;
						pDasmInstr->op[i].mode = OP_Symbol;
						pDasmInstr->op[i].symbol.boffset = 1;
						pDasmInstr->op[i].symbol.offset = Addr;
					}
					break;
				case OP_Near:
					Addr = CodeLen + pDasmInstr->op[i].nearptr.offset + pDasmInstr->eip;
					if (AddrToSym(Addr, pDasmInstr->op[i].symbol.string, 64))
					{
						pDasmInstr->op[i].symbol.mode = pDasmInstr->op[i].mode;
						pDasmInstr->op[i].mode = OP_Symbol;
						pDasmInstr->op[i].symbol.boffset = 0;
						pDasmInstr->op[i].symbol.offset = Addr;
					}
					break;
				case OP_Address:
					if (pDasmInstr->SegmentPrefix == -1 &&
					    pDasmInstr->op[i].addr.base == -1 &&
					    pDasmInstr->op[i].addr.index == -1)
					{
						Addr = pDasmInstr->op[i].addr.displacement; //effect_address;
						if (AddrToSym(Addr, pDasmInstr->op[i].symbol.string, 64))
						{
							pDasmInstr->op[i].symbol.mode = pDasmInstr->op[i].mode;
							pDasmInstr->op[i].mode = OP_Symbol;
							pDasmInstr->op[i].symbol.boffset = 0;
							pDasmInstr->op[i].symbol.offset = Addr;
						} else
						if (pDasmInstr->op[i].opersize == sizeof(ULONG_PTR) &&
							ReadMemory(pDasmInstr->op[i].addr.displacement, &Addr, sizeof(Addr)) == sizeof(Addr) && //effect_address
							AddrToSym(Addr, pDasmInstr->op[i].symbol.string, 64))
						{
							pDasmInstr->op[i].symbol.mode = pDasmInstr->op[i].mode;
							pDasmInstr->op[i].mode = OP_Symbol;
							pDasmInstr->op[i].symbol.boffset = 0;
							pDasmInstr->op[i].symbol.offset = Addr;
						}
						
					}
					break;
				default:;
				}
			}
		}
		return CodeLen;
	}
	unsigned long CInstrSym::Asm(char *pAsmString, unsigned char *CodeBuffer, ULONG_PTR Address)
	{
		return CIntelDisassembler::Assembler(pAsmString, CodeBuffer, Address, m_Mode);
	}

	unsigned long CInstrSym::PrevInstrLen(ULONG_PTR Address)
	{
		unsigned char Buffer[32];
		unsigned long Size = MIN(Address - m_ImageBase, 32);
		for (; Size; --Size)
		{
			if (ReadMemory(Address - Size, Buffer, Size) != 0) break;
		}
		if (Size == 0)
			return 1;

		unsigned char CountArry[32];
		int Count = 0;
		for (unsigned long i = 1; i <= Size; ++i)
		{
			unsigned char CodeLenArray[32];
			unsigned long MaxCount = InstrCount((ULONG_PTR)&Buffer[Size - i], i, CodeLenArray); //???
			if (MaxCount)
				CountArry[Count++] = CodeLenArray[MaxCount-1]; //???
		}
		if (Count == 0)
			return 1;

		unsigned char TestArray[32];
		memset(TestArray, 0, sizeof(TestArray));

		ULONG_PTR BaseAddr = Address;
		if (GetSymbolBase(&BaseAddr) != 0 && BaseAddr < Address && Address - BaseAddr < 32)
		{
			unsigned long Size = Address - BaseAddr;
			for (int i = 0; i < Count; ++i)
			{
				if (Size == CountArry[i])
					TestArray[CountArry[i]] = 33;
				else	++TestArray[CountArry[i]];
			}
		} else
		{
			for (int i = 0; i < Count; ++i)
				++TestArray[CountArry[i]];
		}
		unsigned long TestInstLen = 0;
		unsigned long InstrLen = 0;
		for (unsigned long i = 0; i < 32; ++i)
		{
			if (TestInstLen < TestArray[i])
			{
				InstrLen = i;
				TestInstLen = TestArray[i];
			}
		}
		return InstrLen;
	}

	unsigned long CInstrSym::InstrCount(ULONG_PTR Address, unsigned long CodeSize, unsigned char *LenAry)
	{
		unsigned long Off = 0;
		unsigned long Count = 0;
		while (Off < CodeSize)
		{
		#ifdef _X64_
			unsigned long CodeLen = CInstrSym::InstrLen64((unsigned char *)(Off + Address), MAX_INSTR_LEN);
		#else
			unsigned long CodeLen = CInstrSym::InstrLen32((unsigned char *)(Off + Address), MAX_INSTR_LEN);
		#endif
			if (CodeLen == 0)
				return 0;
			Off += CodeLen;
			if (LenAry)
				LenAry[Count] = CodeLen;
			++Count;
		}
		return Off == CodeSize ? Count : 0;
	}

	bool CInstrSym::IsProcessCode(ULONG_PTR Address)
	{
		_INSTRUCTION_INFORMATION InstInfo;
		unsigned char CodeBuff[MAX_INSTR_LEN];

		InstInfo.eip = Address;
		InstInfo.pasm = nullptr;
		InstInfo.CodeBuff = CodeBuff;
		unsigned long CodeLen = Dasm(&InstInfo, 0, sizeof(CodeBuff));
		if (CodeLen < 2)
			return false;
		if (TStrICmp(InstInfo.Name, "CALL") == 0) //eq
			return true;
	//	if (TStrICmp(InstInfo.Name, "PUSHF") == 0) //eq
	//		return true;
	//	if (TStrICmp(InstInfo.Name, "REP") == 0) //eq
	//		return true;
		return InstInfo.Repeat != -1;
	}

	bool CInstrSym::GetAddr(ULONG_PTR Address, ULONG_PTR *Addr)
	{
		_INSTRUCTION_INFORMATION InstInfo;
		unsigned char CodeBuff[MAX_INSTR_LEN];

		InstInfo.eip = Address;
		InstInfo.pasm = nullptr;
		InstInfo.CodeBuff = CodeBuff;
		unsigned long Size = ReadMemory(Address, CodeBuff, sizeof(CodeBuff));
		if (Size == 0)
			return false;

		unsigned long CodeLen = CIntelDisassembler::Disassembler(&InstInfo, 0);
		if (CodeLen == 0 || CodeLen > Size || CodeLen < 2)
			return false;

		if (InstInfo.op[0].mode == OP_Invalid || InstInfo.op[1].mode != OP_Invalid)
			return false;

		if (!CInstrSym::GetJump(CodeBuff, 0, nullptr))
		{
			static const char *Str[] = {"CALL","JMP",0};
			int i = 0;
			for (; Str[i]; ++i)
				if (!TStrICmp(InstInfo.Name, Str[i])) break;
			if (!Str[i])
				return false;
		}

		switch (InstInfo.op[0].mode)
		{
		case OP_Address:
			if (InstInfo.SegmentPrefix == -1
				&& InstInfo.op[0].addr.base == -1
				&& InstInfo.op[0].addr.index == -1
				&& InstInfo.op[0].addr.displacement_size == sizeof(ULONG_PTR))
			{
				*Addr = 0;
				return ReadMemory(InstInfo.op[0].addr.displacement, Addr, sizeof(*Addr)) == sizeof(*Addr); //effect_address
			}
			break;
		case OP_Immed:
			*Addr = InstInfo.op[0].immed.immed_value;
			return true;
		case OP_Near:
			*Addr = InstInfo.op[0].nearptr.label;
			return true;
		}
		return false;
	}
	
	bool CInstrSym::GetReturn(ULONG_PTR Address, ULONG_PTR *Value)
	{
		_INSTRUCTION_INFORMATION InstInfo;
		unsigned char CodeBuff[MAX_INSTR_LEN];

		InstInfo.eip = Address;
		InstInfo.pasm = nullptr;
		InstInfo.CodeBuff = CodeBuff;
		unsigned long Size = ReadMemory(Address, CodeBuff, sizeof(CodeBuff));
		if (Size == 0)
			return false;

		unsigned long CodeLen = CIntelDisassembler::Disassembler(&InstInfo, 0);
		if (CodeLen == 0 || CodeLen > Size || CodeLen < 2)
			return false;

		for (int i = 0; i < 3; ++i)
		{
			switch (InstInfo.op[i].mode)
			{
			case OP_Near:
				*Value = CodeLen + InstInfo.eip + InstInfo.op[i].nearptr.offset;
				return true;
			case OP_Address:
				if (InstInfo.SegmentPrefix == -1
					&& InstInfo.op[i].addr.base == -1
					&& InstInfo.op[i].addr.index == -1
					&& InstInfo.op[i].addr.displacement_size == sizeof(ULONG_PTR))
				{
					*Value = 0;
					return ReadMemory(InstInfo.op[i].addr.displacement, Value, sizeof(*Value)) == sizeof(*Value); //effect_address
				}
				break;
			case OP_Immed:
				*Value = InstInfo.op[i].immed.immed_value;
				return true;
			default:;
			}
		}
		return false;
	}

	int CInstrSym::GetAddrImm(ULONG_PTR Address, ULONG_PTR *Addr, ULONG_PTR *Imm)
	{
		int n = 0;
		_INSTRUCTION_INFORMATION InstInfo;
		unsigned char CodeBuff[MAX_INSTR_LEN];

		InstInfo.eip = Address;
		InstInfo.pasm = nullptr;
		InstInfo.CodeBuff = CodeBuff;
		unsigned long Size = ReadMemory(Address, CodeBuff, sizeof(CodeBuff));

		*Addr = -1;
		*Imm = -1;

		if (Size == 0)
			return n;

		unsigned long CodeLen = CIntelDisassembler::Disassembler(&InstInfo, 0);
		if (CodeLen == 0 || CodeLen > Size || CodeLen < 2)
			return n;

		ULONG_PTR Data;
		for (int i = 0; i < 3; ++i)
		{
			switch (InstInfo.op[i].mode)
			{
			case OP_Address:
				if (InstInfo.SegmentPrefix == -1 &&
					InstInfo.op[i].addr.base == -1 &&
					InstInfo.op[i].addr.index == -1 &&
					InstInfo.op[i].addr.displacement_size == sizeof(ULONG_PTR)) //???
				{
					*Addr = -1;
					if (ReadMemory(InstInfo.op[i].addr.displacement, &Data, sizeof(Data)) == sizeof(Data)) //effect_address
					{
						++n;
						*Addr = InstInfo.op[i].addr.displacement;	//effect_address
					}
				}
				break;
			case OP_Immed:
				if (ReadMemory(InstInfo.op[i].immed.immed_value, &Data, sizeof(Data)) == sizeof(Data))
				{
					++n;
					*Imm = InstInfo.op[i].immed.immed_value;
				}
				break;
			default:;
			}
		}
		return n;
	}

	bool CInstrSym::GetAddrValue(ULONG_PTR Address, ULONG_PTR *Return)
	{
		_INSTRUCTION_INFORMATION InstInfo;
		unsigned char CodeBuff[MAX_INSTR_LEN];

		InstInfo.eip = Address;
		InstInfo.pasm = nullptr;
		InstInfo.CodeBuff = CodeBuff;
		unsigned long Size = ReadMemory(Address, CodeBuff, sizeof(CodeBuff));

		if (Size == 0)
			return false;

		unsigned long CodeLen = CIntelDisassembler::Disassembler(&InstInfo, 0);
		if (CodeLen == 0 || CodeLen > Size || CodeLen < 2)
			return false;

		for (int i = 0; i < 3; ++i)
		{
			if (InstInfo.op[i].mode == OP_Address &&
				InstInfo.SegmentPrefix == -1 &&
				InstInfo.op[i].addr.base == -1 &&
				InstInfo.op[i].addr.index == -1)
			{
				*Return = InstInfo.op[i].addr.displacement;//effect_address;
				return true;
			}
		}

		if (*InstInfo.CodeBuff == 0x68)	// PUSH
		{
			*Return = InstInfo.op[0].immed.immed_value;
			return true;
		}
		return false;
	}

	unsigned long CInstrSym::GetCall(ULONG_PTR Address, char *FunctionName, ULONG_PTR *Return)
	{
		_INSTRUCTION_INFORMATION InstInfo;
		unsigned char CodeBuff[MAX_INSTR_LEN];
		unsigned long CodeLen;

		static const unsigned long CallCodeLen[] = {6, 5, 4, 3, 2}; //???

		for (int i = 0; i < 5; ++i) //lenof(CallCodeLen)
		{
			InstInfo.eip = Address - CallCodeLen[i];
			InstInfo.pasm = nullptr;
			InstInfo.CodeBuff = CodeBuff;
			CodeLen = Dasm(&InstInfo, 0, sizeof(CodeBuff));
			if (CodeLen == CallCodeLen[i] && !TStrICmp(InstInfo.Name, "CALL"))
			{
				switch (InstInfo.op[0].mode)
				{
				case OP_Address:
					if (FunctionName)
						*FunctionName = 0;
					if (Return)
						*Return = 0;
					if (InstInfo.SegmentPrefix == -1 &&
					    InstInfo.op[0].addr.base == -1 &&
					    InstInfo.op[0].addr.index == -1 &&
					    Return)
						ReadMemory(InstInfo.op[0].addr.displacement, Return, sizeof(*Return)); //effect_address
					break;
				case OP_Near:
					if (FunctionName)
						*FunctionName = 0;
					if (Return)
						*Return = InstInfo.op[0].nearptr.label;
					break;
				case OP_Symbol:
					if (FunctionName)
						TStrCpy(FunctionName, InstInfo.op[0].symbol.string);
					if (Return)
						*Return = InstInfo.op[0].symbol.offset;
					break;
				default:
					if (FunctionName)
						*FunctionName = 0;
					if (Return)
						*Return = 0;
					break;
				}
				return CodeLen;
			}
		}
		return 0;
	}

	bool CInstrSym::GetFunctionName(ULONG_PTR Address, char *FunctionName)
	{
		_INSTRUCTION_INFORMATION InstInfo;
		unsigned char CodeBuff[MAX_INSTR_LEN];

		InstInfo.eip = Address;
		InstInfo.pasm = nullptr;
		InstInfo.CodeBuff = CodeBuff;
		unsigned long CodeLen = Dasm(&InstInfo, 0, sizeof(CodeBuff));
		if (CodeLen < 2)
			return false;
		if (TStrICmp(InstInfo.Name, "CALL") == 0)
		{
			if (FunctionName)
			{
				FunctionName[0] = 0;
				if (InstInfo.op[0].mode == OP_Symbol)
					TStrCpy(FunctionName, InstInfo.op[0].symbol.string);
			}
			return true;
		}
		return false;
	}

	unsigned long CInstrSym::InstrLen(ULONG_PTR Address, unsigned long MaxSize)
	{
		unsigned char Buffer[MAX_INSTR_LEN];
		unsigned long Size = ReadMemory(Address, Buffer, MaxSize);
		if (!Size)
			return 0;
	#ifdef _X64_
		unsigned long CodeLen = CInstrSym::InstrLen64(Buffer, Size);
	#else
		unsigned long CodeLen = CInstrSym::InstrLen32(Buffer, Size);
	#endif
		MAX_LIMIT(CodeLen, Size);
		return CodeLen;
	}

	unsigned long CInstrSym::InstrLen64(unsigned char *inbuff, unsigned long MaxSize)
	{
		unsigned long CodeLen = Disassembly(0, inbuff, 0, CODE_MODE_64, 0, 8);
		return CodeLen <= MaxSize ? CodeLen : 0;
	}

	unsigned long CInstrSym::InstrLen32(unsigned char *inbuff, unsigned long MaxSize)
	{
		unsigned long CodeLen = Disassembly(0, inbuff, 0, CODE_MODE_32, 0, 8);
		return CodeLen <= MaxSize ? CodeLen : 0;
	}

	unsigned long CInstrSym::InstrLen16(unsigned char *inbuff, unsigned long MaxSize)
	{
		unsigned long CodeLen = Disassembly(0, inbuff, 0, CODE_MODE_16, 0, 8);
		return CodeLen <= MaxSize ? CodeLen : 0;
	}

```

`source/EXEAnalyzer/instrsym.hpp`:

```hpp

#ifndef _INSTRSYM_HPP_
#define _INSTRSYM_HPP_

#include "../Code/define.h"
#include "../Code/tstrmem.hpp"

#include "inteldis.hpp"

#define MAX_INSTR_LEN 16

unsigned int GetSize(unsigned long long Address);
bool GetSign(_DIS_ADDRESS *dis_a);

struct CInstrSym : public CIntelDisassembler
{

	unsigned char m_CodeBuffer[MAX_INSTR_LEN];
	bool m_bUseSym;

	ULONG_PTR m_ImageBase;
	ULONG_PTR m_ImageHighBase;
	unsigned long m_UxAlign;
	unsigned long m_Style;

	virtual bool AddrToSym(ULONG_PTR Address, char *szSym, unsigned int SymLen);
	virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size);
	virtual bool GetSymbolBase(ULONG_PTR *BaseAddr);

	WCHAR *OptItemToCS(_OPERAND_ITEM *OpArray, int nOp, WCHAR *pString, _INSTRUCTION_INFORMATION *pDasmInstr);
	void OptItemSymToCS(_OPERAND_ITEM *OpArray, WCHAR *pString, _INSTRUCTION_INFORMATION *pDasmInstr);
	WCHAR *InstrToCS(_INSTRUCTION_INFORMATION *pInstrInfo, WCHAR *pString);

	CInstrSym();
	virtual ~CInstrSym();

	void SetDasmStyle(unsigned long Style);
	unsigned long GetDasmStyle() const;

	static bool GetJump(unsigned char *CodeBuff, ULONG_PTR Address, ULONG_PTR *target);
	static bool CheckJump(unsigned char *CodeBuff, unsigned long eflags);

	unsigned long Dasm(_INSTRUCTION_INFORMATION *pDasmInstr, DIS_CPU *pDisCPU, unsigned long MaxSize);
	unsigned long Asm(char *pAsmString, unsigned char *CodeBuffer, ULONG_PTR Address);

	unsigned long PrevInstrLen(ULONG_PTR Address);

	unsigned long InstrCount(ULONG_PTR Address, unsigned long CodeSize, unsigned char *LenAry);

	bool IsProcessCode(ULONG_PTR Address);

	bool GetAddr(ULONG_PTR Address, ULONG_PTR *Addr);
	bool GetReturn(ULONG_PTR Address, ULONG_PTR *Value);

	int GetAddrImm(ULONG_PTR Address, ULONG_PTR *Addr, ULONG_PTR *Imm);

	bool GetAddrValue(ULONG_PTR Address, ULONG_PTR *Return);

	unsigned long GetCall(ULONG_PTR Address, char *FunctionName, ULONG_PTR *Return);

	bool GetFunctionName(ULONG_PTR Address, char *FunctionName);

	unsigned long InstrLen(ULONG_PTR Address, unsigned long MaxSize);

	static unsigned long InstrLen64(unsigned char *inbuff, unsigned long MaxSize);
	static unsigned long InstrLen32(unsigned char *inbuff, unsigned long MaxSize);
	static unsigned long InstrLen16(unsigned char *inbuff, unsigned long MaxSize);

	static const WCHAR *m_RegStr[3][GENE_IDX_MAX];
	static const WCHAR *m_ScaleStr[4];
	static const WCHAR *m_SizePtr[8+1];
	static const WCHAR *m_SizeSym[10+1];
	static const WCHAR *m_SegStr[SEG_IDX_MAX];
	static const WCHAR *m_LengthStr[4+1];
	static const WCHAR *m_DefaultOPSize[3];
};

#endif
```

`source/EXEAnalyzer/inteldis.cpp`:

```cpp

#include <stdio.h>
#include "inteldis.hpp"
#include "../Code/tstrmem.hpp"

struct _tagLOCKREPXX
{
	const char *Name;
	unsigned char Code;
} LockRepxx[] = {
	{"LOCK ", 0xF0},
	{"REP ",0xF3},
	{"REPZ ",0xF3},
	{"REPE ",0xF3},
	{"REPNE ",0xF2},
	{"REPNZ ",0xF2},
};

struct _OPDATAWIDE
{
	int Size;
	const char *Xptr;
} OpDataWide[] = {{1,"SHORT PTR"},
		{2,"NEAR PTR"},
		{4,"FAR PTR"},

		{1,"BYTE PTR"},
		{2,"WORD PTR"},
		{4,"DWORD PTR"},

		{6,"FWORD PTR"},
		{8,"QWORD PTR"},
		{10,"TBYTE PTR"},
		{16,"OWORD PTR"}};

const char *RegAddr16[] = {
	"[BX+SI]","[SI+BX]",
	"[BX][SI]","[SI][BX]",
	"[BX+DI]","[DI+BX]",
	"[BX][DI]","[DI][BX]",
	"[BP+SI]","[SI+BP]",
	"[BP][SI]","[SI][BP]",
	"[BP+DI]","[DI+BP]",
	"[BP][DI]","[DI][BP]",
	"[SI]","[SI]",
	"[SI]","[SI]",
	"[DI]","[DI]",
	"[DI]","[DI]",
	"[BP]","[BP]",
	"[BP]","[BP]",
	"[BX]","[BX]",
	"[BX]","[BX]"};

const char *xxxxptr[] = {0, "BYTE", "WORD", 0, "DWORD", 0, "FWORD", 0, "QWORD", 0, "TBYTE", 0,0,0,0,0, "OWORD"};

const char SegmentValue[] =
	{0x26,0x2E,0x36,0x3E,0x64,0x65,0};
const char *SegReg[] =
	{"ES","CS","SS","DS","FS","GS","??","??"};

const char *RegByte[] = {"AL","CL","DL","BL",
			"AH","CH","DH","BH",};

const char *RegSTx[] = {"ST(0)","ST(1)","ST(2)","ST(3)","ST(4)","ST(5)","ST(6)","ST(7)","ST"};

const char *RegByteRex[GENE_IDX_MAX] = 
{"AL","CL","DL","BL","SPL","BPL","SIL","DIL","R8B","R9B","R10B","R11B","R12B","R13B","R14B","R15B"};
const char *RegWord[GENE_IDX_MAX] = 
{"AX","CX","DX","BX","SP","BP","SI","DI","R8W","R9W","R10W","R11W","R12W","R13W","R14W","R15W"};
const char *RegQWord[GENE_IDX_MAX] = 
{"RAX","RCX","RDX","RBX","RSP","RBP","RSI","RDI","R8","R9","R10","R11","R12","R13","R14","R15"};
const char *RegDWord[GENE_IDX_MAX] = 
{"EAX","ECX","EDX","EBX","ESP","EBP","ESI","EDI","R8D","R9D","R10D","R11D","R12D","R13D","R14D","R15D"};

//80
const char *RegMMx[] = {"MM0","MM1","MM2","MM3","MM4","MM5","MM6","MM7"}; //ST()/MM()

//LIMIT 8
const char *RegCRx[] = {"CR0","CR1","CR2","CR3","CR4","CR5","CR6","CR7","CR8","CR9","CR10","CR11","CR12","CR13","CR14","CR15"};
const char *RegTRx[] = {"TR0","TR1","TR2","TR3","TR4","TR5","TR6","TR7","TR8","TR9","TR10","TR11","TR12","TR13","TR14","TR15"};
const char *RegDRx[] = {"DR0","DR1","DR2","DR3","DR4","DR5","DR6","DR7","DR8","DR9","DR10","DR11","DR12","DR13","DR14","DR15"};
//128 XMM31
const char *RegXMMx[] = {"XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7","XMM8","XMM9","XMM10","XMM11","XMM12","XMM13","XMM14","XMM15"};

const char *FlagS[] = {"NV","UP","DI","PL","NZ","NA","PO","NC","OV","DN","EI","NG","ZR","AC","PE","CY"};
const char *FlagICE[] = {"o","d","i","s","z","a","p","c",
		   "O","D","I","S","Z","A","P","C"};

#if 0
#ifndef _INTELDIS_HPP_
#define _INTELDIS_HPP_


enum _IMMEDIATE___
{
  Immediate_ = 0,
  Immediate_1 = 1,
  Immediate_CL = 2,
  Immediate_Ib = 3,
  Immediate_sIb = 4,
  Immediate_zIb = 5,
  Immediate_Iv = 6,
  Immediate_Iw = 7,
  Immediate_IvIw = 8,
  Immediate_IwIb = 9,
  Immediate_O = 10,
  Immediate_BrOff8 = 11,
  Immediate_BrOff16 = 12,
  Immediate_BrOff32 = 13,
  Immediate_Jb = 14,
  Immediate_Jv = 15,
  PREFIX_ES = 16,
  PREFIX_CS = 17,
  PREFIX_SS = 18,
  PREFIX_DS = 19,
  PREFIX_FS = 20,
  PREFIX_GS = 21,
  PREFIX_66 = 22,
  PREFIX_67 = 23,
  PREFIX_F0 = 24,
  PREFIX_F2 = 25,
  PREFIX_F3 = 26,
  STRING_Move = 27,
  STRING_Comp = 28,
  Extended_2byte = 29,
  Extended_Group = 30,
  Extended_Float = 31,
  Extended_Group1 = 32,
  OPCODE_UD = 33,
};


// asm

struct _OPER_ITEM
{
	unsigned short mode;
	unsigned char rwflag;

	int opersize;

	union
	{
		struct
		{
			int seg_index;
			int reg_size;
			int base_reg_index;
			int off_reg_index;
			int off_reg_scale;
			unsigned long off_value;
		} addr;

		struct
		{
			int reg_index;
		} reg;

		struct
		{
			int sreg_index;
		} sreg;

		struct
		{
			unsigned long immed_value;
		} immed;

		struct
		{
			unsigned long offset;
		} nearptr;

		struct
		{
			unsigned long segment;
			unsigned long offset;
		} farptr;

		char string[128];
	};
};


// asm

struct _DIS_MODR_M
{
	unsigned int r_m : 3;
	unsigned int reg : 3;
	unsigned int mod : 2;
	unsigned int base : 3;
	unsigned int index : 3;
	unsigned int scale : 2;
	unsigned int disp0 : 8;
	unsigned int disp1 : 8;
	unsigned int disp2 : 8;
	unsigned int disp3 : 8;
};

// asm

struct ASSEMBLY_ERROR
{
	unsigned int name : 1;
	unsigned int Type : 1;
	unsigned int P1 : 1;
	unsigned int P2 : 1;
	unsigned int P3 : 1;
	unsigned int P4 : 1;
	unsigned int PX : 1;
	unsigned int Size : 1;
};

// asm
struct _ASSEMBLY_INFOMATION
{
	int NameSize;
	unsigned char Lock;
	unsigned char Repeat;

	int OperandSize;
	int AddressSize;
	unsigned char SegmentPrefix;

	int OpcodeType;
	char *Name;
	_OPER_ITEM op[3];
	unsigned long eip;
	_DIS_MODR_M *pmodr_m;
	int InstLength;
	int PrefixLength;
	int CodeMode;
	int ByteCount;
	unsigned char *CodeBuff;
	ASSEMBLY_ERROR error;
};


#endif
#endif
/////

struct _DISP_INSTRUCTION_T
{
	unsigned int attr;
	unsigned int b1;
	unsigned int sse_prefix; //++
	unsigned int rep_used;
	unsigned int lock;
	unsigned int rex_prefix; //++

	//unsigned char/int
	unsigned char modrm;
	unsigned int mod;
	unsigned int nnn;
	unsigned int rm;

	unsigned short displ16u;
	unsigned long displ32u;

	unsigned int seg;

	//unsigned char/int
	unsigned char sib;
	unsigned int scale;
	unsigned int index;
	unsigned int base;

	unsigned int __unused;//++ ALIGN

	unsigned long long addr_displacement;
	unsigned long long rm_addr;
	unsigned long long Iq; //++
	unsigned long Id; //++
	unsigned short Iw;
	unsigned char Ib;
	unsigned char Ib2;
	unsigned short Iw2;
	unsigned short UNUSEDW; //???
	unsigned int ilen;
	unsigned int modrm_length;
	unsigned int displacement_size;
	unsigned int os_32;
	unsigned int as_32;
	unsigned int flags_in;
	unsigned int flags_out;
	unsigned int destination;
	unsigned int source;
	unsigned int other;

	unsigned int opcount; //++
	unsigned int prefixes; //++
	unsigned int regrm; //++
	unsigned int sib1; //++
	unsigned int osx_32; //++
	unsigned int x64; //++
};

struct _DIS_OPCODE_T
{
	unsigned int Attr;
	unsigned int OpcodeType;
	unsigned int Opdata1;
	unsigned int Opdata2;
	unsigned int Opdata3;
	const char *name;
//asm
	unsigned int CodePrefix; //unsigned char CodePrefix[4];
	unsigned int AttrCodePrefixLen;
	unsigned int Byte;
};

#define DECODE_MODRM(modrm_byte, mod, opcode, rm) { \
  rm     =  modrm_byte & 0x07;       \
  opcode = (modrm_byte >> 3) & 0x07; \
  mod    = (modrm_byte >> 6) & 0x03; \
}

#define DECODE_SIB(sib_byte, scale, index, base) { \
  base  =  sib_byte & 0x07;        \
  index = (sib_byte >> 3) & 0x07;  \
  scale = (sib_byte >> 6) & 0x03;  \
}

int GetEffectAddress32Dis(DIS_CPU *pDisCPU, unsigned char *pbuff, _DISP_INSTRUCTION_T *disp_i)
{
	//int mod;
	//int reg;
	unsigned long long base_register_val;
	unsigned long base_index;
	//int index;
	//int r_m;
	//int base;
	//int scale;
	int length;

	if (disp_i->rex_prefix & 8)
		disp_i->os_32 = CODE_MODE_64;

	disp_i->modrm = *pbuff++;
	DECODE_MODRM(disp_i->modrm, disp_i->mod, disp_i->nnn, disp_i->rm)
	//disp_i->rm = *(unsigned int*)pbuff & 7;
	//disp_i->nnn = (*(unsigned int*)pbuff >> 3) & 7;// | (2 * (disp_i->rex_prefix & 4));
	//disp_i->mod = (*(unsigned int*)pbuff >> 6) & 3;

	disp_i->nnn |= (2 * (disp_i->rex_prefix & 4)); //rex_r

	disp_i->regrm = 1;
	disp_i->sib1 = -1;

	if (disp_i->rm == 4)
	{
		disp_i->sib = *pbuff++;
		unsigned int base;
		unsigned int index;
		DECODE_SIB(disp_i->sib, disp_i->scale, index, base);
		//base = (*(unsigned int*)pbuff >> 8) & 7;
		//index = (*(unsigned int*)pbuff >> (8+3)) & 7;
		//disp_i->scale = (unsigned char)(*(unsigned short*)pbuff >> 8) >> 6;
		//pbuff += 2;

		if (disp_i->osx_32 == CODE_MODE_64)
		{
			index |= 4 * (disp_i->rex_prefix & 2); //rex_x
			base |= 8 * (disp_i->rex_prefix & 1); //rex_b
			disp_i->rm |= 8 * (disp_i->rex_prefix & 1); //rex_b
		}

		disp_i->sib1 = 1;

		disp_i->base = base;
		if ((disp_i->base & 7) == EBP_IDX && disp_i->mod == 0)
			disp_i->base = -1;

		disp_i->index = index;

		if (disp_i->base == -1)
			base_register_val = 0;
		else	base_register_val = pDisCPU->gen_reg[base].rerx;

		if (disp_i->index == ESP_IDX)
			disp_i->index = -1;
		else	base_register_val += (pDisCPU->gen_reg[disp_i->index].rerx << disp_i->scale);

		if (disp_i->base != ESP_IDX && disp_i->base != EBP_IDX)
			disp_i->seg = DS_IDX;
		else	disp_i->seg = SS_IDX;

		switch (disp_i->mod)
		{
		case 0: //effective address
			if ((base & 7) == 5) /* 32 bits displacement */ //EBP_IDX)
			{
				disp_i->addr_displacement = *(signed int*)pbuff;
				disp_i->displacement_size = 4;
				length = 6;
				if (index == ESP_IDX)
					base_register_val = 0;
				else	base_register_val = (pDisCPU->gen_reg[index].rerx << disp_i->scale);
				disp_i->seg = DS_IDX;
			} else
			//register address
			{
				disp_i->addr_displacement = 0;
				disp_i->displacement_size = 0;
				length = 2;
			}
			break;
		case 1: //effective address + 8 bits displacement
			disp_i->addr_displacement = *(signed char*)pbuff;
			disp_i->displacement_size = 1;
			length = 3;
			break;
		case 2: //effective address + 32 bits displacement
			disp_i->addr_displacement = *(signed int*)pbuff;
			disp_i->displacement_size = 4;
			length = 6;
			break;
		case 3: //registers
			disp_i->displacement_size = 0;
			disp_i->sib1 = -1;
			length = 1;
			break;
		default:
			//ASSERT disp_i->mod
			break;
		}
	} else
	{
		//++pbuff;

		base_index = disp_i->rm | (8 * (disp_i->rex_prefix & 1)); //rex_b
		disp_i->base = base_index;
		disp_i->index = -1;
		disp_i->scale = 0;
		disp_i->rm = base_index;

		base_register_val = pDisCPU->gen_reg[disp_i->base].rerx;

		if (disp_i->base != ESP_IDX && disp_i->base != EBP_IDX)
			disp_i->seg = DS_IDX;
		else	disp_i->seg = SS_IDX;

		if (disp_i->mod == 0) //effective address
		{
			if ((disp_i->base & 7) == 5) /* 32 bits displacement */ //EBP_IDX)
			{
				disp_i->addr_displacement = *(signed int*)pbuff;
				disp_i->displacement_size = 4;
				if (disp_i->osx_32 == CODE_MODE_64)
				{
					disp_i->seg = CS_IDX;
					disp_i->x64 = 1;
				} else
				{
					disp_i->seg = DS_IDX;
				}
				base_register_val = 0;
				disp_i->base = -1;
			} else
			//register address
			{
				disp_i->addr_displacement = 0;
				disp_i->displacement_size = 0;
			}
		} else
		if (disp_i->mod == 1) //effective address + 8 bits displacement
		{
			disp_i->addr_displacement = *(signed char*)pbuff;
			disp_i->displacement_size = 1;
		} else
		if (disp_i->mod == 2) //effective address + 32 bits displacement
		{
			disp_i->addr_displacement = *(signed int*)pbuff; //TODO will fix on x32 incorrect off
			disp_i->displacement_size = 4;
		} else
		//registers
		{
			disp_i->displacement_size = 0;
		}

		length = disp_i->displacement_size + 1;
	}
	disp_i->rm_addr = base_register_val + disp_i->addr_displacement;
	return length;
}

int GetEffectAddress16Dis(DIS_CPU *pDisCPU, unsigned char *pbuff, _DISP_INSTRUCTION_T *disp_i)
{
	//int mod;
	//int reg;
	unsigned long base_register_val;
	//int r_m;
	int length;

	disp_i->modrm = *pbuff++;
	DECODE_MODRM(disp_i->modrm, disp_i->mod, disp_i->nnn, disp_i->rm);
	//disp_i->rm = *(unsigned int*)pbuff & 7;
	//disp_i->nnn = (*(unsigned int*)pbuff >> 3) & 7;
	//disp_i->mod = (*(unsigned int*)pbuff >> 6) & 3;
	//++pbuff;

	disp_i->regrm = 1;
	disp_i->sib1 = -1;


	disp_i->as_32 = CODE_MODE_16;
	disp_i->scale = 0;

	switch (disp_i->rm)
	{
	case 0:
		base_register_val = pDisCPU->gen_reg[EBX_IDX].word.u_word.rx + pDisCPU->gen_reg[ESI_IDX].word.u_word.rx;
		disp_i->seg = DS_IDX;
		disp_i->base = EBX_IDX;
		disp_i->index = ESI_IDX;
		break;
	case 1:
		base_register_val = pDisCPU->gen_reg[EBX_IDX].word.u_word.rx + pDisCPU->gen_reg[EDI_IDX].word.u_word.rx;
		disp_i->seg = DS_IDX;
		disp_i->base = EBX_IDX;
		disp_i->index = EDI_IDX;
		break;
	case 2:
		base_register_val = pDisCPU->gen_reg[EBP_IDX].word.u_word.rx + pDisCPU->gen_reg[ESI_IDX].word.u_word.rx;
		disp_i->seg = SS_IDX;
		disp_i->base = EBP_IDX;
		disp_i->index = ESI_IDX;
		break;
	case 3:
		base_register_val = pDisCPU->gen_reg[EBP_IDX].word.u_word.rx + pDisCPU->gen_reg[EDI_IDX].word.u_word.rx;
		disp_i->seg = SS_IDX;
		disp_i->base = EBP_IDX;
		disp_i->index = EDI_IDX;
		break;
	case 4:
		base_register_val = pDisCPU->gen_reg[ESI_IDX].word.u_word.rx;
		disp_i->seg = DS_IDX;
		disp_i->base = ESI_IDX;
		disp_i->index = -1;
		break;
	case 5:
		base_register_val = pDisCPU->gen_reg[EDI_IDX].word.u_word.rx;
		disp_i->seg = DS_IDX;
		disp_i->base = EDI_IDX;
		disp_i->index = -1;
		break;
	case 6:
		base_register_val = pDisCPU->gen_reg[EBP_IDX].word.u_word.rx;
		disp_i->seg = SS_IDX;
		disp_i->base = EBP_IDX;
		disp_i->index = -1;
		break;
	case 7:
		base_register_val = pDisCPU->gen_reg[EBX_IDX].word.u_word.rx;
		disp_i->seg = DS_IDX;
		disp_i->base = EBX_IDX;
		disp_i->index = -1;
		break;
	default:
		//ASSERT disp_i->rm
		break;
	}

	if (disp_i->mod == 0) //effective address
	{
		if (disp_i->rm == 6) //16 bits displacement
		{
			disp_i->addr_displacement = *(unsigned short*)pbuff;
			disp_i->displacement_size = 2;
			base_register_val = 0;
			disp_i->seg = DS_IDX;
			disp_i->base = -1;
			disp_i->index = -1;
		} else
		{
			disp_i->addr_displacement = 0;
			disp_i->displacement_size = 0;
		}
	} else
	if (disp_i->mod == 1) //effective address + 8 bits displacement
	{
		disp_i->addr_displacement = *(signed char*)pbuff;
		disp_i->displacement_size = 1;
	} else
	if (disp_i->mod == 2) //effective address + 16 bits displacement
	{
		disp_i->addr_displacement = *(unsigned short*)pbuff; //??? signed short
		disp_i->displacement_size = 2;
	} else
	//registers
	{
		disp_i->displacement_size = 0;
	}
	length = disp_i->displacement_size + 1;
	disp_i->rm_addr = (unsigned short)(base_register_val + disp_i->addr_displacement);
	return length;
}

int GetImmediateData(unsigned int imm_mode, unsigned char *iptr, _DISP_INSTRUCTION_T *insruction)
{
	return 0;
}

void DispTranDis(_DIS_ADDRESS *dis_a, _DISP_INSTRUCTION_T *disp_i, unsigned long long eip)
{
	dis_a->mod = disp_i->mod;
	dis_a->reg = disp_i->nnn;
	dis_a->r_m = disp_i->rm;
	dis_a->base = disp_i->base;
	dis_a->index = disp_i->index;
	dis_a->scale = disp_i->scale;
	dis_a->segment = disp_i->seg;
	dis_a->address_size = disp_i->as_32;
	dis_a->displacement_size = disp_i->displacement_size;

	if (disp_i->x64)
	{
		disp_i->addr_displacement += eip + disp_i->ilen;
		dis_a->displacement_size = 8;
	}

	dis_a->displacement = disp_i->addr_displacement;
	dis_a->effect_address = disp_i->rm_addr;
}

bool ProcessName_dis(_INSTRUCTION_INFORMATION *pInstInfo, _DIS_OPCODE_T *pIntelOpcode, int OperandSize, int AddressSize)
{
	if (pInstInfo->Lock == 0xF0)
	{
		strcpy(pInstInfo->LockName, "LOCK");
	} else
	{
		pInstInfo->LockName[0] = 0;
	}
	
	if (pInstInfo->Repeat == 0xF2)
	{
		strcpy(pInstInfo->RepeatName, "REPNE");
	} else
	if (pInstInfo->Repeat == 0xF3)
	{
		strcpy(pInstInfo->RepeatName, "REP");
	} else
	{
		pInstInfo->RepeatName[0] = 0;
	}

	if (pIntelOpcode->OpcodeType == C_NULL)
		return false;

	strcpy(pInstInfo->Name, (const char *)pIntelOpcode->name);

	if ((pIntelOpcode->Opdata1 >= D__Xb && pIntelOpcode->Opdata1 <= D_wXb) ||
	    (pIntelOpcode->Opdata1 >= D__Yb && pIntelOpcode->Opdata1 <= D_wYb) ||

	    (pIntelOpcode->Opdata2 >= D__Xb && pIntelOpcode->Opdata2 <= D_wXb) ||
	    (pIntelOpcode->Opdata2 >= D__Yb && pIntelOpcode->Opdata2 <= D_wYb))
	{
		sprintf(pInstInfo->Name, "%sB", (const char *)pIntelOpcode->name);
	}

	if ((pIntelOpcode->Opdata1 >= D__Xv && pIntelOpcode->Opdata1 <= D_wXv) ||
	    (pIntelOpcode->Opdata1 >= D__Yv && pIntelOpcode->Opdata1 <= D_wYv) ||

	    (pIntelOpcode->Opdata2 >= D__Xv && pIntelOpcode->Opdata2 <= D_wXv) ||
	    (pIntelOpcode->Opdata2 >= D__Yv && pIntelOpcode->Opdata2 <= D_wYv))
	{
		switch (OperandSize)
		{
		case CODE_MODE_16: sprintf(pInstInfo->Name, "%sW", (const char *)pIntelOpcode->name); break;
		case CODE_MODE_32: sprintf(pInstInfo->Name, "%sD", (const char *)pIntelOpcode->name); break;
		case CODE_MODE_64: sprintf(pInstInfo->Name, "%sQ", (const char *)pIntelOpcode->name); break;
		}
	}

	if (OperandSize == CODE_MODE_32)
	{
		switch (pIntelOpcode->OpcodeType)
		{
		case C_MOVD: strcpy(pInstInfo->Name, "MOVD"); break;
		case C_PEXTRD: strcpy(pInstInfo->Name, "pextrd"); break;
		case C_PINSRD: strcpy(pInstInfo->Name, "pinsrd"); break;
		case C_IRET: strcpy(pInstInfo->Name, "IRETD"); break;
		case C_CWD: strcpy(pInstInfo->Name, "CDQ"); break;
		case C_PUSHF: strcpy(pInstInfo->Name, "PUSHFD"); break;
		case C_POPF: strcpy(pInstInfo->Name, "POPFD"); break;
		case C_CBW: strcpy(pInstInfo->Name, "CWDE"); break;
		case C_JCXZ: strcpy(pInstInfo->Name, "JECXZ"); break;
		case C_PUSHA: strcpy(pInstInfo->Name, "PUSHAD"); break;
		case C_POPA: strcpy(pInstInfo->Name, "POPAD"); break;
		}
	} else
	if (OperandSize == CODE_MODE_64)
	{
		switch (pIntelOpcode->OpcodeType)
		{
		case C_MOVD: strcpy(pInstInfo->Name, "MOVQ"); break;
		case C_PEXTRD: strcpy(pInstInfo->Name, "pextrq"); break;
		case C_PINSRD: strcpy(pInstInfo->Name, "pinsrq"); break;
		case C_IRET: strcpy(pInstInfo->Name, "IRETQ"); break;
		case C_CWD: strcpy(pInstInfo->Name, "CQO"); break;
		case C_PUSHF: strcpy(pInstInfo->Name, "PUSHFQ"); break;
		case C_POPF: strcpy(pInstInfo->Name, "POPFQ"); break;
		case C_CBW: strcpy(pInstInfo->Name, "CDQE"); break;
		case C_JCXZ: strcpy(pInstInfo->Name, "JRCXZ"); break;
		case C_PUSHA: strcpy(pInstInfo->Name, ""); break;
		case C_POPA: strcpy(pInstInfo->Name, ""); break;
		case C_CMPXCHG8B: if (pInstInfo->RexPrefix & 8) strcpy(pInstInfo->Name, "CMPXCHG16B"); break;
		}
	}	
	//TStrUpr(pInstInfo->Name); //TODO
	return true;
}

#define OP_READ 1
#define OP_WRITE 2

#define OP_SIZE(x,n)	if (!(x)->opersize) { (x)->opersize = (n); }

#define OP_SIZE_(x,n,a)	if (!(x)->opersize) { (x)->opersize = (n); (x)->rwflag = (a); }
#define OP_SIZE_R(x,n)	if (!(x)->opersize) { (x)->opersize = (n); (x)->rwflag = OP_READ; }
#define OP_SIZE_W(x,n)	if (!(x)->opersize) { (x)->opersize = (n); (x)->rwflag = OP_WRITE; }
#define OP_SIZE_RW(x,n)	if (!(x)->opersize) { (x)->opersize = (n); (x)->rwflag = OP_READ|OP_WRITE; }

int ProcessOpdata_dis(int opdata, _OPERAND_ITEM *op, unsigned long long eip, _DISP_INSTRUCTION_T *disp_i, DIS_CPU *dis_cpu)
{
	int OperandSize = disp_i->os_32;
	int AddressSize = disp_i->as_32;

	int SIZE_v;
	int SIZE_p;
	int SIZE_z;
	int SIZE_y;

	if (OperandSize == CODE_MODE_16)
	{
		SIZE_v = 2;
		SIZE_p = 4;
		SIZE_z = 2;
		SIZE_y = 4;
	} else
	if (OperandSize == CODE_MODE_32)
	{
		SIZE_v = 4;
		SIZE_p = 6;
		SIZE_z = 4;
		SIZE_y = 4;
	} else
	if (OperandSize == CODE_MODE_64)
	{
		SIZE_v = 8;
		SIZE_p = 10;
		SIZE_z = 4;
		SIZE_y = 8;
	}

	int opimmedlength = 0;
	op->mode = OP_Invalid;
	op->opersize = 0;

	switch (opdata)
	{
	case D__NONE:
	case D__Fv:
	case D__NTA:
		return opimmedlength;

	case D__Cd:
		if (disp_i->osx_32 == CODE_MODE_64)
			op->opersize = 8;
		else	op->opersize = 4;
		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		strcpy(op->string, RegCRx[op->reg.reg_index]);
		return opimmedlength;

	case D__Dd:
		if (disp_i->osx_32 == CODE_MODE_64)
			op->opersize = 8;
		else	op->opersize = 4;
		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		strcpy(op->string, RegDRx[op->reg.reg_index]);
		return opimmedlength;

	case D__Td:
		if (disp_i->osx_32 == CODE_MODE_64)
			op->opersize = 8;
		else	op->opersize = 4;
		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		strcpy(op->string, RegTRx[op->reg.reg_index]);
		return opimmedlength;

	case D__Gb: OP_SIZE_RW(op, 1);
	case D_rGb: OP_SIZE_R(op,1);
	case D_wGb: OP_SIZE_W(op,1);

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		if (disp_i->osx_32 == CODE_MODE_64 && disp_i->rex_prefix)
			strcpy(op->string, RegByteRex[op->reg.reg_index]);
		else	strcpy(op->string, RegByte[op->reg.reg_index]);
		return opimmedlength;

	case D__Gw: OP_SIZE_RW(op,2);
	case D_rGw: OP_SIZE_R(op, 2);
	case D_wGw: OP_SIZE_W(op, 2);

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		strcpy(op->string, RegWord[op->reg.reg_index]);
		return opimmedlength;

	case D__Gv: OP_SIZE_RW(op, SIZE_v);
	case D_rGv: OP_SIZE_R(op, SIZE_v);
	case D_wGv: OP_SIZE_W(op, SIZE_v);
	case D_dGv: OP_SIZE_RW(op, SIZE_v);

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		switch (op->opersize)
		{
		case 2:
			strcpy(op->string, RegWord[op->reg.reg_index]);
			break;
		case 4:
			strcpy(op->string, RegDWord[op->reg.reg_index]);
			break;
		case 8:
			strcpy(op->string, RegQWord[op->reg.reg_index]);
			break;
		}
		return opimmedlength;

	case D__Gd: OP_SIZE_RW(op, 4);
	case D_rGd: OP_SIZE_R(op, 4);
	case D_wGd: OP_SIZE_W(op, 4);
	case D_dGd: OP_SIZE_RW(op, 4);

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		strcpy(op->string, RegDWord[op->reg.reg_index]);
		return opimmedlength;

	case D__Gy: OP_SIZE_RW(op, SIZE_y);
	case D_rGy: OP_SIZE_R(op, SIZE_y);
	case D_wGy: OP_SIZE_W(op, SIZE_y);
	case D_dGy: OP_SIZE_RW(op, SIZE_y);

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		if (op->opersize == 4)
			strcpy(op->string, RegDWord[op->reg.reg_index]);
		else	strcpy(op->string, RegQWord[op->reg.reg_index]);
		return opimmedlength;

	case D__Ib:
		op->mode = OP_Immed;
		op->opersize = 1;
		opimmedlength = 1;
		op->immed.immed_value = disp_i->Ib;
		if ((int)disp_i->Ib < 0xA0)
			sprintf(op->string, "%X", (unsigned int)op->immed.immed_value);
		else	sprintf(op->string, "0%X", (unsigned int)op->immed.immed_value);
		return opimmedlength;

	case D_zIb:
		op->mode = OP_Immed;
		op->opersize = 1;
		opimmedlength = 1;
		op->immed.immed_value = disp_i->Ib2;
		if ((int)disp_i->Ib2 < 0xA0)
			sprintf(op->string, "%X", (unsigned int)op->immed.immed_value);
		else	sprintf(op->string, "0%X", (unsigned int)op->immed.immed_value);
		return opimmedlength;

	case D_sIb:
		op->mode = OP_Immed;
		op->opersize = 1;
		opimmedlength = 1;
		op->immed.immed_value = disp_i->Ib;
		if (op->immed.immed_value < 0x80) //???
			sprintf(op->string, "%X", (unsigned char)(op->immed.immed_value));
		else	sprintf(op->string, "-%X", (unsigned char)-(signed char)(op->immed.immed_value));
		return opimmedlength;

	case D__Iw:
		op->mode = OP_Immed;
		op->opersize = 2;
		opimmedlength = 2;
		op->immed.immed_value = disp_i->Iw;
		sprintf(op->string, "%X", (unsigned short)(op->immed.immed_value));
		return opimmedlength;

	case D__Iv:
		op->mode = OP_Immed;
		op->opersize = SIZE_v;
		opimmedlength = SIZE_v;

		if (SIZE_v == 2)
		{
			op->immed.immed_value = disp_i->Iw;
			if ((int)disp_i->Iw < 0xA000)
				sprintf(op->string, "%X", (unsigned int)op->immed.immed_value);
			else	sprintf(op->string, "0%X", (unsigned int)op->immed.immed_value);
		} else
		if (SIZE_v == 4)
		{
			op->immed.immed_value = disp_i->Id;
			if (disp_i->Id < 0xA0000000)
				sprintf(op->string, "%X", (unsigned int)op->immed.immed_value);
			else	sprintf(op->string, "0%X", (unsigned int)op->immed.immed_value);
		} else
		if (SIZE_v == 8)
		{
			op->immed.immed_value = disp_i->Iq;
			if (disp_i->Iq < 0xA000000000000000)
				sprintf(op->string, "%I64X", op->immed.immed_value);
			else	sprintf(op->string, "0%I64X", op->immed.immed_value);
		}
		return opimmedlength;

	case D__1:
		op->mode = OP_Immed;
		op->opersize = 1;
		op->immed.immed_value = 1;
		strcpy(op->string, "1");
		return opimmedlength;

	case D__Iz:
		op->mode = OP_Immed;
		op->opersize = SIZE_z;
		opimmedlength = SIZE_z;
		if (SIZE_z == 2)
		{
			op->immed.immed_value = disp_i->Iw;
			if ((int)disp_i->Iw < 0xA000)
				sprintf(op->string, "%X", (unsigned int)op->immed.immed_value);
			else	sprintf(op->string, "0%X", (unsigned int)op->immed.immed_value);
			return opimmedlength;
		}

		if (OperandSize == CODE_MODE_64)
		{
			//op->immed.immed_value = disp_i->Id; //???
			if (disp_i->Id >= 0)
				sprintf(op->string, "%I64X", (unsigned long long)disp_i->Id);
			else	sprintf(op->string, "0%I64X", (unsigned long long)disp_i->Id);
			return opimmedlength;
		} else
		{
			op->immed.immed_value = disp_i->Id;
			if (disp_i->Id < 0xA0000000)
				sprintf(op->string, "%X", (unsigned int)(op->immed.immed_value));
			else	sprintf(op->string, "0%X", (unsigned int)(op->immed.immed_value));
			return opimmedlength;
		}

	case D__Jb:
		op->mode = OP_Near;
		op->opersize = 1;
		op->nearptr.offset = (char)disp_i->Ib;
		opimmedlength = 1;
		op->nearptr.label = eip + op->nearptr.offset + disp_i->ilen;
		if (OperandSize == CODE_MODE_16)
		{
			sprintf(op->string, "%04X", (unsigned short)op->nearptr.label);
		} else
		if (OperandSize == CODE_MODE_32)
		{
			sprintf(op->string, "%08X", (unsigned int)op->nearptr.label);
		} else
		if (OperandSize == CODE_MODE_64)
		{
			sprintf(op->string, "%016I64X", (unsigned long long)op->nearptr.label);
		}
		return opimmedlength;

	case D__Jz:
		op->mode = OP_Near;
		op->opersize = SIZE_z;
		if (SIZE_z == 2)
		{
			op->nearptr.offset = (short)disp_i->Iw;
		} else
		if (SIZE_z == 4)
		{
			op->nearptr.offset = (int)disp_i->Id;
		}
		opimmedlength = SIZE_z;
		op->nearptr.label = eip + op->nearptr.offset + disp_i->ilen;
		if (OperandSize == CODE_MODE_16)
		{
			sprintf(op->string, "%04X", (unsigned short)op->nearptr.label);
		} else
		if (OperandSize == CODE_MODE_32)
		{
			sprintf(op->string, "%08X", (unsigned int)op->nearptr.label);
		} else
		if (OperandSize == CODE_MODE_64)
		{
			sprintf(op->string, "%016I64X", (unsigned long long)op->nearptr.label);
		}
		return opimmedlength;

	case D__Ob: OP_SIZE_RW(op, 1);
	case D_rOb: OP_SIZE_R(op, 1);
	case D_wOb: OP_SIZE_W(op, 1);
	case D_dOb: OP_SIZE_RW(op, 1);

	case D__Ov: OP_SIZE_RW(op, SIZE_v);
	case D_rOv: OP_SIZE_R(op, SIZE_v);
	case D_wOv: OP_SIZE_W(op, SIZE_v);
	case D_dOv: OP_SIZE_RW(op, SIZE_v);

		disp_i->base = -1;
		disp_i->index = -1;
		disp_i->scale = 0;
		disp_i->seg = 3; //DS_IDX

		if (AddressSize == CODE_MODE_64)
		{
			disp_i->as_32 = CODE_MODE_64;
			disp_i->displacement_size = 8;
			disp_i->addr_displacement = disp_i->Iq;
			opimmedlength = 8;
			sprintf(op->string, "%016I64X", disp_i->addr_displacement);
		} else
		if (AddressSize == CODE_MODE_32)
		{
			disp_i->as_32 = CODE_MODE_32;
			disp_i->displacement_size = 4;
			disp_i->addr_displacement = disp_i->Id;
			opimmedlength = 4;
			sprintf(op->string, "%08X", disp_i->Id); //???
		} else
		{
			disp_i->as_32 = CODE_MODE_16;
			disp_i->displacement_size = 2;
			disp_i->addr_displacement = disp_i->Iw;
			opimmedlength = 2;
			sprintf(op->string, "%04X", disp_i->Iw); //???
		}
		disp_i->rm_addr = disp_i->addr_displacement;
		op->mode = OP_Address;
		DispTranDis(&op->addr, disp_i, eip);
		return opimmedlength;

	case D__Ap:
		op->mode = OP_Far;
		if (OperandSize == CODE_MODE_32)
			op->farptr.offset = disp_i->Id;
		else	op->farptr.offset = disp_i->Iw;
		op->farptr.segment = disp_i->Iw2;
		op->opersize = SIZE_p;
		opimmedlength = SIZE_p;
		if (OperandSize == CODE_MODE_32)
			sprintf(op->string, "%04X:%08X", op->farptr.segment, op->farptr.offset);
		else	sprintf(op->string, "%04X:%04X", op->farptr.segment, op->farptr.offset);
		return opimmedlength;

	case D__Pd: OP_SIZE(op, 4);
	case D_rPd: OP_SIZE_R(op, 4);
	case D_wPd: OP_SIZE_W(op, 4);
	case D_dPd: OP_SIZE_RW(op, 4);

	case D__Pq: OP_SIZE(op, 8);
	case D_rPq: OP_SIZE_R(op, 8);
	case D_wPq: OP_SIZE_W(op, 8);
	case D_dPq: OP_SIZE_RW(op, 8);

	case D__Ppi: OP_SIZE(op, 8);
	case D_rPpi: OP_SIZE_R(op, 8);
	case D_wPpi: OP_SIZE_W(op, 8);
	case D_dPpi: OP_SIZE_RW(op, 8);

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn; //???
		strcpy(op->string, RegMMx[disp_i->nnn & 7]);
		return opimmedlength;

	case D__Rv:
		if (disp_i->mod != 3)
			return -1;

		op->mode = OP_Register;
		op->opersize = 4;
		op->reg.reg_index = disp_i->rm;
		strcpy(op->string, RegDWord[op->reg.reg_index]);
		return opimmedlength;

	case D__Rd:
		if (disp_i->mod != 3)
			return -1;

		op->mode = OP_Register;
		op->opersize = SIZE_y;
		op->reg.reg_index = disp_i->rm;
		if (op->opersize == 4)
			strcpy(op->string, RegDWord[op->reg.reg_index]);
		else	strcpy(op->string, RegQWord[op->reg.reg_index]);
		return opimmedlength;

	case D__Sw:
		op->mode = OP_Segment;
		op->opersize = 2;
		op->seg.seg_index = disp_i->nnn & 7; //???
		strcpy(op->string, SegReg[op->seg.seg_index]);
		return opimmedlength;

	case D__T0:
	case D__T1:
	case D__T2:
		op->mode = OP_Register;
		op->opersize = 4;
		op->reg.reg_index = opdata - D__T0;
		sprintf(op->string, "T%x", opdata - D__T0);
		return opimmedlength;

	case D__Xb: OP_SIZE(op, 1);
	case D_rXb: OP_SIZE(op, 1);
	case D_wXb: OP_SIZE(op, 1);

	case D__Xw: OP_SIZE(op, 2);
	case D_rXw: OP_SIZE(op, 2);
	case D_wXw: OP_SIZE(op, 2);

	case D__Xv: OP_SIZE(op, SIZE_v);
	case D_rXv: OP_SIZE(op, SIZE_v);
	case D_wXv: OP_SIZE(op, SIZE_v);

	case D__Xd: OP_SIZE(op, 4);
	case D_rXd: OP_SIZE(op, 4);
	case D_wXd: OP_SIZE(op, 4);

	case D__Xz: OP_SIZE(op, SIZE_z);
	case D_rXz: OP_SIZE(op, SIZE_z);
	case D_wXz: OP_SIZE(op, SIZE_z);

		opimmedlength = 0;
		op->mode = OP_Address;
		disp_i->seg = 3; //DS_IDX
		disp_i->addr_displacement = 0;
		disp_i->displacement_size = 0;
		disp_i->index = -1;
		disp_i->base = 6;                         // ESI_IDX
		disp_i->scale = 0;
		disp_i->rm_addr = dis_cpu->gen_reg[disp_i->base].rerx;
		DispTranDis(&op->addr, disp_i, eip);
		return opimmedlength;

	case D__Yb: OP_SIZE(op, 1);
	case D_rYb: OP_SIZE(op, 1);
	case D_wYb: OP_SIZE(op, 1);

	case D__Yw: OP_SIZE(op, 2);
	case D_rYw: OP_SIZE(op, 2);
	case D_wYw: OP_SIZE(op, 2);

	case D__Yv: OP_SIZE(op, SIZE_v);
	case D_rYv: OP_SIZE(op, SIZE_v);
	case D_wYv: OP_SIZE(op, SIZE_v);

	case D__Yd: OP_SIZE(op, 4);
	case D_rYd: OP_SIZE(op, 4);
	case D_wYd: OP_SIZE(op, 4);

	case D__Yz: OP_SIZE(op, SIZE_z);
	case D_rYz: OP_SIZE(op, SIZE_z);
	case D_wYz: OP_SIZE(op, SIZE_z);

		opimmedlength = 0;
		op->mode = OP_Address;
		disp_i->seg = 0; //ES_IDX
		disp_i->addr_displacement = 0;
		disp_i->displacement_size = 0;
		disp_i->index = -1;
		disp_i->base = 7;                         // EDI_IDX
		disp_i->scale = 0;
		disp_i->rm_addr = dis_cpu->gen_reg[disp_i->base].rerx;
		DispTranDis(&op->addr, disp_i, eip);
		return opimmedlength;

	case D__AL:
	case D__CL:
	case D__DL:
	case D__BL:
	case D__AH:
	case D__CH:
	case D__DH:
	case D__BH:
		op->mode = OP_Register;
		op->opersize = 1;
		op->reg.reg_index = opdata - D__AL;
		strcpy(op->string, RegByte[op->reg.reg_index]);
		return opimmedlength;

	case D__RAL:
	case D__RCL:
	case D__RDL:
	case D__RBL:
	case D__RAH:
	case D__RCH:
	case D__RDH:
	case D__RBH:
		op->mode = OP_Register;
		op->opersize = 1;
		op->reg.reg_index = (8 * (disp_i->rex_prefix & 1)) | (opdata - D__RAL);
		if (disp_i->osx_32 == CODE_MODE_64)
			strcpy(op->string, RegByteRex[op->reg.reg_index]);
		else	strcpy(op->string, RegByte[op->reg.reg_index]);
		return opimmedlength;

	case D__AX:
	case D__CX:
	case D__DX:
	case D__BX:
	case D__SP:
	case D__BP:
	case D__SI:
	case D__DI:
		op->mode = OP_Register;
		op->opersize = 2;
		op->reg.reg_index = opdata - D__AX;
		strcpy(op->string, RegWord[op->reg.reg_index]);
		return opimmedlength;

	case D__eAX:
	case D__eCX:
	case D__eDX:
	case D__eBX:
	case D__eSP:
	case D__eBP:
	case D__eSI:
	case D__eDI:
		op->mode = OP_Register;
		op->opersize = SIZE_v;
		op->reg.reg_index = opdata - D__eAX;
		if (op->opersize == 2)
			strcpy(op->string, RegWord[op->reg.reg_index]);
		else	strcpy(op->string, RegDWord[op->reg.reg_index]);
		return opimmedlength;

	case D__erAX:
	case D__erCX:
	case D__erDX:
	case D__erBX:
	case D__erSP:
	case D__erBP:
	case D__erSI:
	case D__erDI:
		op->mode = OP_Register;
		op->opersize = SIZE_v;
		op->reg.reg_index = (8 * (disp_i->rex_prefix & 1)) | (opdata - D__erAX);
		switch (op->opersize)
		{
		case 2:
			strcpy(op->string, RegWord[op->reg.reg_index]);
			break;
		case 4:
			strcpy(op->string, RegDWord[op->reg.reg_index]);
			break;
		case 8:
			strcpy(op->string, RegQWord[op->reg.reg_index]);
			break;
		}
		return opimmedlength;

	case D__rAX:
	case D__rCX:
	case D__rDX:
	case D__rBX:
	case D__rSP:
	case D__rBP:
	case D__rSI:
	case D__rDI:
		op->mode = OP_Register;
		op->opersize = SIZE_v;
		op->reg.reg_index = opdata - D__rAX;
		switch (op->opersize)
		{
		case 2:
			strcpy(op->string, RegWord[op->reg.reg_index]);
			break;
		case 4:
			strcpy(op->string, RegDWord[op->reg.reg_index]);
			break;
		case 8:
			strcpy(op->string, RegQWord[op->reg.reg_index]);
			break;
		}
		return opimmedlength;

	case D__EAX:
	case D__ECX:
	case D__EDX:
	case D__EBX:
	case D__ESP:
	case D__EBP:
	case D__ESI:
	case D__EDI:
		op->mode = OP_Register;
		op->opersize = 4;
		op->reg.reg_index = opdata - D__EAX;
		strcpy(op->string, RegDWord[op->reg.reg_index]);
		return opimmedlength;

	case D__RAX:
	case D__RCX:
	case D__RDX:
	case D__RBX:
	case D__RSP:
	case D__RBP:
	case D__RSI:
	case D__RDI:
		op->mode = OP_Register;
		op->reg.reg_index = (8 * (disp_i->rex_prefix & 1)) | (opdata - D__RAX);
		if (disp_i->os_32 == CODE_MODE_64)
		{
			op->opersize = 8;
			strcpy(op->string, RegQWord[op->reg.reg_index]);
		} else
		{
			op->opersize = 4;
			strcpy(op->string, RegDWord[op->reg.reg_index]);
		}
		return opimmedlength;

	case D__ES:
	case D__CS:
	case D__SS:
	case D__DS:
	case D__FS:
	case D__GS:
		op->mode = OP_Segment;
		op->opersize = 2;
		op->seg.seg_index = opdata - D__ES;
		strcpy(op->string, SegReg[op->seg.seg_index]);
		return opimmedlength;

	case D__st:
		op->mode = OP_Register;
		op->opersize = 10;
		op->reg.reg_index = 0;
		strcpy(op->string, "ST");
		return opimmedlength;

	case D__st0:
	case D__st1:
	case D__st2:
	case D__st3:
	case D__st4:
	case D__st5:
	case D__st6:
	case D__st7:
		op->mode = OP_Register;
		op->opersize = 10;
		op->reg.reg_index = opdata - D__st0;
		sprintf(op->string, "ST(%x)", op->reg.reg_index);
		return opimmedlength;

	case D__Eb: OP_SIZE_RW(op, 1);
	case D_rEb: OP_SIZE_R(op, 1);
	case D_wEb: OP_SIZE_W(op, 1);
	case D_dEb: OP_SIZE_W(op, 1); //??? w/r

	case D__Ew: OP_SIZE_RW(op, 2);
	case D_rEw: OP_SIZE_R(op, 2);
	case D_wEw: OP_SIZE_W(op, 2);
	case D_dEw: OP_SIZE_W(op, 2); //??? w/r

	case D__Ev: OP_SIZE_RW(op, SIZE_v);
	case D_rEv: OP_SIZE_R(op, SIZE_v);
	case D_wEv: OP_SIZE_W(op, SIZE_v);
	case D_dEv: OP_SIZE_W(op, SIZE_v);

	case D__Ed: OP_SIZE_RW(op, 4);
	case D_rEd: OP_SIZE_R(op, 4);
	case D_wEd: OP_SIZE_W(op, 4);
	case D_dEd: OP_SIZE_RW(op, 4);

	case D__Ep: OP_SIZE_RW(op, SIZE_p);
	case D_rEp: OP_SIZE_R(op, SIZE_p);
	case D_wEp: OP_SIZE_W(op, SIZE_p);
	case D_dEp: OP_SIZE_RW(op, SIZE_p);

		if (disp_i->mod != 3)
		{
			op->mode = OP_Address;
			DispTranDis(&op->addr, disp_i, eip);
			return opimmedlength;
		}

		if (opdata == D__Ep || opdata == D_rEp)
			return -1;

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->rm;

		switch (op->opersize)
		{
		case 1:
			if (disp_i->osx_32 == CODE_MODE_64 && disp_i->rex_prefix)
				strcpy(op->string, RegByteRex[op->reg.reg_index]);
			else	strcpy(op->string, RegByte[op->reg.reg_index]);
			break;
		case 2:
			strcpy(op->string, RegWord[op->reg.reg_index]);
			break;
		case 4:
			strcpy(op->string, RegDWord[op->reg.reg_index]);
			break;
		case 8:
			strcpy(op->string, RegQWord[op->reg.reg_index]);
			break;
		}
		return opimmedlength;

	case D__Ey: OP_SIZE_RW(op, SIZE_y);
	case D_rEy: OP_SIZE_R(op, SIZE_y);
	case D_wEy: OP_SIZE_W(op, SIZE_y);
	case D_dEy: OP_SIZE_RW(op, SIZE_y);

		if (disp_i->mod != 3)
		{
			op->mode = OP_Address;
			DispTranDis(&op->addr, disp_i, eip);
			return opimmedlength;
		}

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->rm;
		if (op->opersize == 4)
			strcpy(op->string, RegDWord[op->reg.reg_index]);
		else	strcpy(op->string, RegQWord[op->reg.reg_index]);
		return opimmedlength;

	case D__Mxdq: OP_SIZE_RW(op, (disp_i->rex_prefix & 8) != 0 ? 16 : 8);
	case D_rMxdq: OP_SIZE_R(op, (disp_i->rex_prefix & 8) != 0 ? 16 : 8);
	case D_wMxdq: OP_SIZE_W(op, (disp_i->rex_prefix & 8) != 0 ? 16 : 8);
	case D_dMxdq: OP_SIZE_RW(op, (disp_i->rex_prefix & 8) != 0 ? 16 : 8);

		if (disp_i->mod == 3)
			return -1;
		
		op->mode = OP_Address;
		DispTranDis(&op->addr, disp_i, eip);
		return opimmedlength;

	case D_wEx: OP_SIZE_W(op, (disp_i->mod == 3) ? SIZE_v : 2);

		if (disp_i->mod != 3)
		{
			op->mode = OP_Address;
			DispTranDis(&op->addr, disp_i, eip);
			return opimmedlength;
		}

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->rm;
		switch (op->opersize)
		{
		case 2:
			strcpy(op->string, RegWord[op->reg.reg_index]);
			break;
		case 4:
			strcpy(op->string, RegDWord[op->reg.reg_index]);
			break;
		case 8:
			strcpy(op->string, RegQWord[op->reg.reg_index]);
			break;
		}
		return opimmedlength;

	case D__M: OP_SIZE_RW(op, -1);
	case D_rM: OP_SIZE_R(op, -1);
	case D_wM: OP_SIZE_W(op, -1);
	case D_dM: OP_SIZE_RW(op, -1);

	case D__Ma: OP_SIZE_RW(op, 8);
	case D_rMa: OP_SIZE_R(op, 8);
	case D_wMa: OP_SIZE_W(op, 8);
	case D_dMa: OP_SIZE_RW(op, 8);

	case D__Mb: OP_SIZE_RW(op, 1);
	case D_rMb: OP_SIZE_R(op, 1);
	case D_wMb: OP_SIZE_W(op, 1);
	case D_dMb: OP_SIZE_RW(op, 1);

	case D__Mp: OP_SIZE_RW(op, SIZE_p);
	case D_rMp: OP_SIZE_R(op, SIZE_p);
	case D_wMp: OP_SIZE_W(op, SIZE_p);
	case D_dMp: OP_SIZE_RW(op, SIZE_p);

	case D__Ms: OP_SIZE_RW(op, 6);
	case D_rMs: OP_SIZE_R(op, 6);
	case D_wMs: OP_SIZE_W(op, 6);
	case D_dMs: OP_SIZE_W(op, 6);

	case D__Mq: OP_SIZE_RW(op, 8);
	case D_rMq: OP_SIZE_R(op, 8);
	case D_wMq: OP_SIZE_W(op, 8);
	case D_dMq: OP_SIZE_RW(op, 8);

	case D__Mw: OP_SIZE_RW(op, 2);
	case D_rMw: OP_SIZE_R(op, 2);
	case D_wMw: OP_SIZE_W(op, 2);
	case D_dMw: OP_SIZE_RW(op, 2);

	case D__Md: OP_SIZE_RW(op, 4);
	case D_rMd: OP_SIZE_R(op, 4);
	case D_wMd: OP_SIZE_W(op, 4);
	case D_dMd: OP_SIZE_RW(op, 4);

	case D__My: OP_SIZE_RW(op, SIZE_y);
	case D_rMy: OP_SIZE_R(op, SIZE_y);
	case D_wMy: OP_SIZE_W(op, SIZE_y);
	case D_dMy: OP_SIZE_RW(op, SIZE_y);

	case D__cVV: OP_SIZE_RW(op, SIZE_v);
	case D_rcVV: OP_SIZE_R(op, SIZE_v);
	case D_wcVV: OP_SIZE_W(op, SIZE_v);
	case D_dcVV: OP_SIZE_RW(op, SIZE_v);

	case D__Mdq: OP_SIZE(op, 16);
	case D_rMdq: OP_SIZE_R(op, 16);
	case D_wMdq: OP_SIZE_W(op, 16);
	case D_dMdq: OP_SIZE_RW(op, 16);

	case D__Mpd: OP_SIZE_RW(op, 16);
	case D_rMpd: OP_SIZE_R(op, 16);
	case D_wMpd: OP_SIZE_W(op, 16);
	case D_dMpd: OP_SIZE_RW(op, 16);

	case D__Mps: OP_SIZE_RW(op, 8);
	case D_rMps: OP_SIZE_R(op, 8);
	case D_wMps: OP_SIZE_W(op, 8);
	case D_dMps: OP_SIZE_RW(op, 8);

		if (disp_i->mod == 3)
			return -1;
		
		op->mode = OP_Address;
		DispTranDis(&op->addr, disp_i, eip);
		return opimmedlength;

	case D__Hm: OP_SIZE(op, 4);
	case D_rHm: OP_SIZE_R(op, 4);
	case D_wHm: OP_SIZE_W(op, 4);
	case D_dHm: OP_SIZE_RW(op, 4);

	case D__Qq: OP_SIZE(op, 8);
	case D_rQq: OP_SIZE_R(op, 8);
	case D_wQq: OP_SIZE_W(op, 8);
	case D_dQq: OP_SIZE_RW(op, 8);

	case D__Qpi: OP_SIZE(op, 8);
	case D_rQpi: OP_SIZE_R(op, 8);
	case D_wQpi: OP_SIZE_W(op, 8);
	case D_dQpi: OP_SIZE_RW(op, 8);

		if (disp_i->mod != 3)
		{
			op->mode = OP_Address;
			DispTranDis(&op->addr, disp_i, eip);
			return opimmedlength;
		}

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->rm; //???
		strcpy(op->string, RegMMx[disp_i->rm & 7]);
		return opimmedlength;

	case D__Vq: OP_SIZE(op, 8);
	case D_rVq: OP_SIZE_R(op, 8);
	case D_wVq: OP_SIZE_W(op, 8);
	case D_dVq: OP_SIZE_RW(op, 8);

	case D__Vdq: OP_SIZE(op, 16);
	case D_rVdq: OP_SIZE_R(op, 16);
	case D_wVdq: OP_SIZE_W(op, 16);
	case D_dVdq: OP_SIZE_RW(op, 16);

	case D__Vps: OP_SIZE(op, 8);
	case D_rVps: OP_SIZE_R(op, 8);
	case D_wVps: OP_SIZE_W(op, 8);
	case D_dVps: OP_SIZE_RW(op, 8);

	case D__Vss: OP_SIZE(op, 16);
	case D_rVss: OP_SIZE_R(op, 16);
	case D_wVss: OP_SIZE_W(op, 16);
	case D_dVss: OP_SIZE_RW(op, 16);

	case D__Vsd: OP_SIZE(op, 16);
	case D_rVsd: OP_SIZE_R(op, 16);
	case D_wVsd: OP_SIZE_W(op, 16);
	case D_dVsd: OP_SIZE_RW(op, 16);

	case D__Vpd: OP_SIZE(op, 16);
	case D_rVpd: OP_SIZE_R(op, 16);
	case D_wVpd: OP_SIZE_W(op, 16);
	case D_dVpd: OP_SIZE_RW(op, 16);

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		strcpy(op->string, RegXMMx[op->reg.reg_index]);
		return opimmedlength;

	case D__sXX: OP_SIZE(op, SIZE_y);
	case D_rsXX: OP_SIZE_R(op, SIZE_y);
	case D_wsXX: OP_SIZE_W(op, SIZE_y);
	case D_dsXX: OP_SIZE_RW(op, SIZE_y);

		if (op->opersize != 4)
			op->opersize = 8;

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->nnn;
		strcpy(op->string, RegXMMx[op->reg.reg_index]);
		return opimmedlength;

	case D__Wq: OP_SIZE(op, 8);
	case D_rWq: OP_SIZE_R(op, 8);
	case D_wWq: OP_SIZE_W(op, 8);
	case D_dWq: OP_SIZE_RW(op, 8);

	case D__Wdq: OP_SIZE(op, 16);
	case D_rWdq: OP_SIZE_R(op, 16);
	case D_wWdq: OP_SIZE_W(op, 16);
	case D_dWdq: OP_SIZE_RW(op, 16);

	case D__Wps: OP_SIZE(op, 8);
	case D_rWps: OP_SIZE_R(op, 8);
	case D_wWps: OP_SIZE_W(op, 8);
	case D_dWps: OP_SIZE_RW(op, 8);

	case D__Wss: OP_SIZE(op, 16);
	case D_rWss: OP_SIZE_R(op, 16);
	case D_wWss: OP_SIZE_W(op, 16);
	case D_dWss: OP_SIZE_RW(op, 16);

	case D__Wpd: OP_SIZE(op, 16);
	case D_rWpd: OP_SIZE_R(op, 16);
	case D_wWpd: OP_SIZE_W(op, 16);
	case D_dWpd: OP_SIZE_RW(op, 16);

	case D__Wsd: OP_SIZE(op, 16);
	case D_rWsd: OP_SIZE_R(op, 16);
	case D_wWsd: OP_SIZE_W(op, 16);
	case D_dWsd: OP_SIZE_RW(op, 16);

		if (disp_i->mod != 3)
		{
			op->mode = OP_Address;
			DispTranDis(&op->addr, disp_i, eip);
			return opimmedlength;
		}

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->rm;
		strcpy(op->string, RegXMMx[op->reg.reg_index]);
		return opimmedlength;

	case D__Ups: OP_SIZE(op, 8);
	case D_rUps: OP_SIZE_R(op, 8);
	case D_wUps: OP_SIZE_W(op, 8);
	case D_dUps: OP_SIZE_RW(op, 8);

	case D__Upd: OP_SIZE(op, 16);
	case D_rUpd: OP_SIZE_R(op, 16);
	case D_wUpd: OP_SIZE_W(op, 16);
	case D_dUpd: OP_SIZE_RW(op, 16);


	case D__Udq: OP_SIZE(op, 16);
	case D_rUdq: OP_SIZE_R(op, 16);
	case D_wUdq: OP_SIZE_W(op, 16);
	case D_dUdq: OP_SIZE_RW(op, 16);

		if (disp_i->mod != 3)
			return -1;

		op->mode = OP_Register;
		op->reg.reg_index = disp_i->rm;
		strcpy(op->string, RegXMMx[op->reg.reg_index]); //sprintf
		return opimmedlength;

	case D__Nq: OP_SIZE(op, 8);
	case D_rNq: OP_SIZE_R(op, 8);
	case D_wNq: OP_SIZE_W(op, 8)
	case D_dNq: OP_SIZE_RW(op, 8);

		if (disp_i->mod != 3)
			return -1;

		op->mode = OP_Register;
		op->opersize = 8;
		op->reg.reg_index = disp_i->rm; //???
		strcpy(op->string, RegMMx[disp_i->rm & 7]);
		return opimmedlength;

	case D__Uq: OP_SIZE(op, 8);
	case D_rUq: OP_SIZE_R(op, 8);
	case D_wUq: OP_SIZE_W(op, 8);
	case D_dUq: OP_SIZE_RW(op, 8);

		if (disp_i->mod != 3)
			return -1;

		op->mode = OP_Register;
		op->opersize = 8;
		op->reg.reg_index = disp_i->rm;
		strcpy(op->string, RegXMMx[op->reg.reg_index]);
		return opimmedlength;

	case D__word_int: OP_SIZE(op, 2);
	case D__dword_int: OP_SIZE(op, 4);
	case D__qword_int: OP_SIZE(op, 8);
	case D__single_real: OP_SIZE(op, 4);
	case D__double_real: OP_SIZE(op, 8);
	case D__extend_real: OP_SIZE(op, 10);
	case D__packed_BCD: OP_SIZE(op, 10);
	case D__2b: OP_SIZE(op, 2);
	case D__14_28b: OP_SIZE(op, 10);
	case D__98_108b: OP_SIZE(op, 10);

		if (disp_i->mod == 3)
			return -1;

		op->mode = OP_Address;
		DispTranDis(&op->addr, disp_i, eip);
		return opimmedlength;
	default:
		opimmedlength = 0;
		op->mode = OP_Invalid;
		op->opersize = 0;
	}

	return opimmedlength;
}

int ProcessOpdata_immde(int opdata, unsigned char *inbuff, _DISP_INSTRUCTION_T *disp_i)
{
	int as; //SIZE_v
	int jp;

	if (disp_i->os_32 == CODE_MODE_16)
	{
		as = 2;
		jp = 2;
	} else
	if (disp_i->os_32 == CODE_MODE_32)
	{
		as = 4;
		jp = 4;
	} else
	if (disp_i->os_32 == CODE_MODE_64)
	{
		as = 8;
		jp = 4;
	}

	int opimmedlength = 0;

	switch (opdata)
	{
	case D__Ib:
	case D_sIb:
	case D__Jb:
		disp_i->Ib = *(unsigned char*)inbuff;
		opimmedlength = 1;
		break;

	case D_zIb:
		disp_i->Ib2 = *(unsigned char*)inbuff;
		opimmedlength = 1;
		break;

	case D__Iw:
		disp_i->Iw = *(unsigned short*)inbuff;
		opimmedlength = 2;
		break;

	case D__Iv:
		opimmedlength = as;
		switch (as)
		{
		case 2:
			disp_i->Iw = *(unsigned short*)inbuff;
			break;
		case 4:
			disp_i->Id = *(unsigned int*)inbuff;
			break;
		case 8:
			disp_i->Iq = *(unsigned long long*)inbuff;
			break;
		}
		break;

	case D__1:
		disp_i->Ib = 1;
		opimmedlength = 0;
		break;

	case D__Iz:
	case D__Jz:
		if (jp == 2)
			disp_i->Iw = *(unsigned short*)inbuff;
		else	disp_i->Id = *(unsigned int*)inbuff;
		opimmedlength = jp;
		break;

	case D__Ob:
	case D_rOb:
	case D_wOb:
	case D_dOb:

	case D__Ov:
	case D_rOv:
	case D_wOv:
	case D_dOv:

		if (disp_i->as_32 == CODE_MODE_16)
		{
			disp_i->Iw = *(unsigned short*)inbuff;
			opimmedlength = 2;
		} else
		if (disp_i->as_32 == CODE_MODE_32)
		{
			disp_i->Id = *(unsigned int*)inbuff;
			opimmedlength = 4;
		} else
		if (disp_i->as_32 == CODE_MODE_64)
		{
			disp_i->Iq = *(unsigned long long*)inbuff;
			opimmedlength = 8;
		}
		//ASSERT
		break;
	case D__Ap:
		opimmedlength = as+2;
		if (as == 2)
		{
			disp_i->Iw = *(unsigned short*)inbuff;
			disp_i->Iw2 = *((unsigned short*)inbuff + 1);
		} else
		//as == 4
		//as == 8
		{
			disp_i->Id = *(unsigned int*)inbuff;
			disp_i->Iw2 = *((unsigned short*)inbuff + 2);
		}
		break;
	}
	return opimmedlength;
}

int PutStr(char *buff, const char *s)
{
	int i;
	for (i = 0; s[i]; ++i)
		buff[i] = s[i];
	return i;
}

int PrintPasm(_INSTRUCTION_INFORMATION *pInstInfo, char *pasm, int u_x1, int u_x2)
{
	int i;
	char buff[32];
	int length;
	const char **preg;

	for (i = 0; i <= 80; ++i)
		pasm[i] = 0x20;
	pasm[i] = 0;

	if (pInstInfo->Lock != -1)
	{
		length = PutStr(&pasm[u_x1], pInstInfo->LockName);
		if (length)
			u_x1 += length + 1;
	}

	if (pInstInfo->Repeat != -1)
	{
		length = PutStr(&pasm[u_x1], pInstInfo->RepeatName);
		if (length)
			u_x1 += length + 1;
	}

	u_x1 += PutStr(&pasm[u_x1], pInstInfo->Name);

	_OPERAND_ITEM *op = pInstInfo->op;

	bool stack = false;
	for (i = 0; i < 3; ++i)
	{
		if (op[i].mode == OP_Register &&
			(op[i].opersize == 4 || op[i].opersize == 8) &&
			op[i].reg.reg_index == ESP_IDX)
		{
			stack = true;
			break;
		}
	}

	for (i = 0; i < 3; ++i)
	{
		if (op->mode == OP_Invalid) break;

		if (!i)
		{
			if (u_x1 >= u_x2)
				++u_x1;
			else	u_x1 = u_x2;
		}

		if (i > 0)
		{
			u_x1 += PutStr(&pasm[u_x1], ",");
		}

		if (op->mode == OP_Address)
		{
			if (pInstInfo->xxxxptr != -1 && pInstInfo->xxxxptr)
			{
				u_x1 += PutStr(&pasm[u_x1], xxxxptr[pInstInfo->xxxxptr]);
				u_x1 += PutStr(&pasm[u_x1], " PTR ");
			}

			if (pInstInfo->SegmentPrefix != -1)
			{
				u_x1 += PutStr(&pasm[u_x1], SegReg[pInstInfo->SegmentPrefix]);
				u_x1 += PutStr(&pasm[u_x1], ":");
			}

			if (op->addr.address_size == 1)
			{
				preg = RegDWord;
			} else
			if (op->addr.address_size == 2)
			{
				preg = RegQWord;
			} else
			{
				preg = RegWord;
			}

			u_x1 += PutStr(&pasm[u_x1], "[");

			if (op->addr.base != -1)
			{
				u_x1 += PutStr(&pasm[u_x1], preg[op->addr.base]);
			}

			if (op->addr.index != -1)
			{
				if (op->addr.base != -1)
				{
					u_x1 += PutStr(&pasm[u_x1], "+");
				}

				u_x1 += PutStr(&pasm[u_x1], preg[op->addr.index]);

				if (op->addr.scale)
				{
					sprintf(buff, "*%1x", 1 << op->addr.scale);
					u_x1 += PutStr(&pasm[u_x1], buff);
				}
			}

			if (op->addr.displacement_size >= 1 &&
				(op->addr.base != -1 || op->addr.index != -1) &&
				(op->addr.displacement_size != 1 || op->addr.displacement))
			{
				u_x1 += PutStr(&pasm[u_x1], "+");
			}

			//TODO reimplement

			switch (op->addr.displacement_size)
			{
			case 1:
				if (op->addr.displacement)
				{
					if (op->addr.displacement < 0x80)
					{
						sprintf(buff, "%X", (unsigned char)op->addr.displacement);
					} else
					{
						--u_x1;
						sprintf(buff, "-%X", -(unsigned char)op->addr.displacement);
					}
				} else
				{
					buff[0] = 0;
				}
				u_x1 += PutStr(&pasm[u_x1], buff);
				break;
			case 2:
				sprintf(buff, "%04X", (unsigned short)op->addr.displacement);
				u_x1 += PutStr(&pasm[u_x1], buff);
				break;
			case 4:
				sprintf(buff, "%08X", (unsigned int)op->addr.displacement);
				u_x1 += PutStr(&pasm[u_x1], buff);
				break;
			case 8:
				sprintf(buff, "%016I64X", (unsigned long long)op->addr.displacement);
				u_x1 += PutStr(&pasm[u_x1], buff);
				break;
			}
			u_x1 += PutStr(&pasm[u_x1], "]");
		} else
		{
			u_x1 += PutStr(&pasm[u_x1], op->string);
		}
		++op;
 
	}

	pasm[u_x1] = 0;

	for (i = 0; i < u_x1; ++i)
	{
		MAKE_CHAR_LOWER(pasm[i]);
	}
	return u_x1;
}

#define ATTR_B		1
#define ATTR_W		2
#define ATTR_D		4
#define ATTR_X64	8
#define ATTR_COND	0x10
#define ATTR_MODRM	0x200
//0x400
//0x800
//0x1000
//0x2000
//0x4000
//0x8000
//0x10000
//0x20000
//0x40000
//0x80000
//0x100000
//0x200000
//0x400000
//0x800000
//0x1000000
//0x2000000
#define ATTR_JMP	0x4000000
#define ATTR_SP		0x8000000
#define ATTR_X64_ONLY	 0x10000000
#define ATTR_X64_INVALID 0x20000000

_DIS_OPCODE_T GroupG6[] = {
      {ATTR_MODRM,C_SLDT,D_wEx,D__NONE,D__NONE,"SLDT",0xf,0x202,0x2},
      {ATTR_MODRM,C_STR,D_wEx,D__NONE,D__NONE,"STR",0xf,0x10202,0x2},
      {ATTR_MODRM,C_LLDT,D_rEw,D__NONE,D__NONE,"LLDT",0xf,0x20202,0x1},
      {ATTR_MODRM,C_LTR,D_rEw,D__NONE,D__NONE,"LTR",0xf,0x30202,0x1},
      {ATTR_MODRM,C_VERR,D_rEw,D__NONE,D__NONE,"VERR",0xf,0x40202,0x1},
      {ATTR_MODRM,C_VERW,D_rEw,D__NONE,D__NONE,"VERW",0xf,0x50202,0x1},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG8EvIb[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_BT,D_rEv,D__Ib,D__NONE,"BT",0xba0f,0x40202,0x5},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_BTS,D__Ev,D__Ib,D__NONE,"BTS",0xba0f,0x50202,0x6},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_BTR,D__Ev,D__Ib,D__NONE,"BTR",0xba0f,0x60202,0x6},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_BTC,D__Ev,D__Ib,D__NONE,"BTC",0xba0f,0x70202,0x6},
};
_DIS_OPCODE_T GroupG1_80[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ADD,D__Eb,D__Ib,D__NONE,"ADD",0x80,0x201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_OR,D__Eb,D__Ib,D__NONE,"OR",0x80,0x10201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ADC,D__Eb,D__Ib,D__NONE,"ADC",0x80,0x20201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SBB,D__Eb,D__Ib,D__NONE,"SBB",0x80,0x30201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_AND,D__Eb,D__Ib,D__NONE,"AND",0x80,0x40201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SUB,D__Eb,D__Ib,D__NONE,"SUB",0x80,0x50201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_XOR,D__Eb,D__Ib,D__NONE,"XOR",0x80,0x60201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_CMP,D_rEb,D__Ib,D__NONE,"CMP",0x80,0x70201,0x5},
};
_DIS_OPCODE_T GroupG1_81[] = {
      {ATTR_X64|ATTR_MODRM,C_ADD,D__Ev,D__Iz,D__NONE,"ADD",0x81,0x201,0x7},
      {ATTR_X64|ATTR_MODRM,C_OR,D__Ev,D__Iz,D__NONE,"OR",0x81,0x10201,0x7},
      {ATTR_X64|ATTR_MODRM,C_ADC,D__Ev,D__Iz,D__NONE,"ADC",0x81,0x20201,0x7},
      {ATTR_X64|ATTR_MODRM,C_SBB,D__Ev,D__Iz,D__NONE,"SBB",0x81,0x30201,0x7},
      {ATTR_X64|ATTR_MODRM,C_AND,D__Ev,D__Iz,D__NONE,"AND",0x81,0x40201,0x7},
      {ATTR_X64|ATTR_MODRM,C_SUB,D__Ev,D__Iz,D__NONE,"SUB",0x81,0x50201,0x7},
      {ATTR_X64|ATTR_MODRM,C_XOR,D__Ev,D__Iz,D__NONE,"XOR",0x81,0x60201,0x7},
      {ATTR_X64|ATTR_MODRM,C_CMP,D_rEv,D__Iz,D__NONE,"CMP",0x81,0x70201,0x5},
};
_DIS_OPCODE_T GroupG1_82[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_X64_INVALID,C_ADD,D__Eb,D__Ib,D__NONE,"ADD",0x82,0x201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_X64_INVALID,C_OR,D__Eb,D__Ib,D__NONE,"OR",0x82,0x10201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_X64_INVALID,C_ADC,D__Eb,D__Ib,D__NONE,"ADC",0x82,0x20201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_X64_INVALID,C_SBB,D__Eb,D__Ib,D__NONE,"SBB",0x82,0x30201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_X64_INVALID,C_AND,D__Eb,D__Ib,D__NONE,"AND",0x82,0x40201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_X64_INVALID,C_SUB,D__Eb,D__Ib,D__NONE,"SUB",0x82,0x50201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_X64_INVALID,C_XOR,D__Eb,D__Ib,D__NONE,"XOR",0x82,0x60201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_X64_INVALID,C_CMP,D_rEb,D__Ib,D__NONE,"CMP",0x82,0x70201,0x5},
};
_DIS_OPCODE_T GroupG1_83[] = {
      {ATTR_D|ATTR_MODRM,C_ADD,D__Ev,D_sIb,D__NONE,"ADD",0x83,0x201,0x7},
      {ATTR_D|ATTR_MODRM,C_OR,D__Ev,D_sIb,D__NONE,"OR",0x83,0x10201,0x7},
      {ATTR_D|ATTR_MODRM,C_ADC,D__Ev,D_sIb,D__NONE,"ADC",0x83,0x20201,0x7},
      {ATTR_D|ATTR_MODRM,C_SBB,D__Ev,D_sIb,D__NONE,"SBB",0x83,0x30201,0x7},
      {ATTR_D|ATTR_MODRM,C_AND,D__Ev,D_sIb,D__NONE,"AND",0x83,0x40201,0x7},
      {ATTR_D|ATTR_MODRM,C_SUB,D__Ev,D_sIb,D__NONE,"SUB",0x83,0x50201,0x7},
      {ATTR_D|ATTR_MODRM,C_XOR,D__Ev,D_sIb,D__NONE,"XOR",0x83,0x60201,0x7},
      {ATTR_D|ATTR_MODRM,C_CMP,D_rEv,D_sIb,D__NONE,"CMP",0x83,0x70201,0x5},
};
_DIS_OPCODE_T GroupG2Eb[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ROL,D__Eb,D__Ib,D__NONE,"ROL",0xc0,0x201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ROR,D__Eb,D__Ib,D__NONE,"ROR",0xc0,0x10201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_RCL,D__Eb,D__Ib,D__NONE,"RCL",0xc0,0x20201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_RCR,D__Eb,D__Ib,D__NONE,"RCR",0xc0,0x30201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SHL,D__Eb,D__Ib,D__NONE,"SHL",0xc0,0x40201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SHR,D__Eb,D__Ib,D__NONE,"SHR",0xc0,0x50201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SAL,D__Eb,D__Ib,D__NONE,"SAL",0xc0,0x60201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SAR,D__Eb,D__Ib,D__NONE,"SAR",0xc0,0x70201,0x7},
};
_DIS_OPCODE_T GroupG2Ew[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ROL,D__Ev,D__Ib,D__NONE,"ROL",0xc1,0x201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ROR,D__Ev,D__Ib,D__NONE,"ROR",0xc1,0x10201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_RCL,D__Ev,D__Ib,D__NONE,"RCL",0xc1,0x20201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_RCR,D__Ev,D__Ib,D__NONE,"RCR",0xc1,0x30201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SHL,D__Ev,D__Ib,D__NONE,"SHL",0xc1,0x40201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SHR,D__Ev,D__Ib,D__NONE,"SHR",0xc1,0x50201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SAL,D__Ev,D__Ib,D__NONE,"SAL",0xc1,0x60201,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SAR,D__Ev,D__Ib,D__NONE,"SAR",0xc1,0x70201,0x7},
};
_DIS_OPCODE_T GroupG11Eb[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_MOV,D_wEb,D__Ib,D__NONE,"MOV",0xc6,0x201,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG11Ew[] = {
      {ATTR_X64|ATTR_MODRM,C_MOV,D_wEv,D__Iz,D__NONE,"MOV",0xc7,0x201,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG2EbI1[] = {
      {ATTR_B|ATTR_MODRM,C_ROL,D__Eb,D__1,D__NONE,"ROL",0xd0,0x201,0x7},
      {ATTR_B|ATTR_MODRM,C_ROR,D__Eb,D__1,D__NONE,"ROR",0xd0,0x10201,0x7},
      {ATTR_B|ATTR_MODRM,C_RCL,D__Eb,D__1,D__NONE,"RCL",0xd0,0x20201,0x7},
      {ATTR_B|ATTR_MODRM,C_RCR,D__Eb,D__1,D__NONE,"RCR",0xd0,0x30201,0x7},
      {ATTR_B|ATTR_MODRM,C_SHL,D__Eb,D__1,D__NONE,"SHL",0xd0,0x40201,0x7},
      {ATTR_B|ATTR_MODRM,C_SHR,D__Eb,D__1,D__NONE,"SHR",0xd0,0x50201,0x7},
      {ATTR_B|ATTR_MODRM,C_SAL,D__Eb,D__1,D__NONE,"SAL",0xd0,0x60201,0x7},
      {ATTR_B|ATTR_MODRM,C_SAR,D__Eb,D__1,D__NONE,"SAR",0xd0,0x70201,0x7},
};
_DIS_OPCODE_T GroupG2EvI1[] = {
      {ATTR_B|ATTR_MODRM,C_ROL,D__Ev,D__1,D__NONE,"ROL",0xd1,0x201,0x7},
      {ATTR_B|ATTR_MODRM,C_ROR,D__Ev,D__1,D__NONE,"ROR",0xd1,0x10201,0x7},
      {ATTR_B|ATTR_MODRM,C_RCL,D__Ev,D__1,D__NONE,"RCL",0xd1,0x20201,0x7},
      {ATTR_B|ATTR_MODRM,C_RCR,D__Ev,D__1,D__NONE,"RCR",0xd1,0x30201,0x7},
      {ATTR_B|ATTR_MODRM,C_SHL,D__Ev,D__1,D__NONE,"SHL",0xd1,0x40201,0x7},
      {ATTR_B|ATTR_MODRM,C_SHR,D__Ev,D__1,D__NONE,"SHR",0xd1,0x50201,0x7},
      {ATTR_B|ATTR_MODRM,C_SAL,D__Ev,D__1,D__NONE,"SAL",0xd1,0x60201,0x7},
      {ATTR_B|ATTR_MODRM,C_SAR,D__Ev,D__1,D__NONE,"SAR",0xd1,0x70201,0x7},
};
_DIS_OPCODE_T GroupG2EbCL[] = {
      {ATTR_MODRM,C_ROL,D__Eb,D__CL,D__NONE,"ROL",0xd2,0x201,0x7},
      {ATTR_MODRM,C_ROR,D__Eb,D__CL,D__NONE,"ROR",0xd2,0x10201,0x7},
      {ATTR_MODRM,C_RCL,D__Eb,D__CL,D__NONE,"RCL",0xd2,0x20201,0x7},
      {ATTR_MODRM,C_RCR,D__Eb,D__CL,D__NONE,"RCR",0xd2,0x30201,0x7},
      {ATTR_MODRM,C_SHL,D__Eb,D__CL,D__NONE,"SHL",0xd2,0x40201,0x7},
      {ATTR_MODRM,C_SHR,D__Eb,D__CL,D__NONE,"SHR",0xd2,0x50201,0x7},
      {ATTR_MODRM,C_SAL,D__Eb,D__CL,D__NONE,"SAL",0xd2,0x60201,0x7},
      {ATTR_MODRM,C_SAR,D__Eb,D__CL,D__NONE,"SAR",0xd2,0x70201,0x7},
};
_DIS_OPCODE_T GroupG2EvCL[] = {
      {ATTR_MODRM,C_ROL,D__Ev,D__CL,D__NONE,"ROL",0xd3,0x201,0x7},
      {ATTR_MODRM,C_ROR,D__Ev,D__CL,D__NONE,"ROR",0xd3,0x10201,0x7},
      {ATTR_MODRM,C_RCL,D__Ev,D__CL,D__NONE,"RCL",0xd3,0x20201,0x7},
      {ATTR_MODRM,C_RCR,D__Ev,D__CL,D__NONE,"RCR",0xd3,0x30201,0x7},
      {ATTR_MODRM,C_SHL,D__Ev,D__CL,D__NONE,"SHL",0xd3,0x40201,0x7},
      {ATTR_MODRM,C_SHR,D__Ev,D__CL,D__NONE,"SHR",0xd3,0x50201,0x7},
      {ATTR_MODRM,C_SAL,D__Ev,D__CL,D__NONE,"SAL",0xd3,0x60201,0x7},
      {ATTR_MODRM,C_SAR,D__Ev,D__CL,D__NONE,"SAR",0xd3,0x70201,0x7},
};
_DIS_OPCODE_T GroupG3Eb[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_TEST,D_rEb,D__Ib,D__NONE,"TEST",0xf6,0x201,0x5},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf6,0x10201,0x0},
      {ATTR_MODRM,C_NOT,D__Eb,D__NONE,D__NONE,"NOT",0xf6,0x20201,0x3},
      {ATTR_MODRM,C_NEG,D__Eb,D__NONE,D__NONE,"NEG",0xf6,0x30201,0x3},
      {ATTR_MODRM,C_MUL,D_rEb,D__NONE,D__NONE,"MUL",0xf6,0x40201,0x1},
      {ATTR_MODRM,C_IMUL,D_rEb,D__NONE,D__NONE,"IMUL",0xf6,0x50201,0x1},
      {ATTR_MODRM,C_DIV,D_rEb,D__NONE,D__NONE,"DIV",0xf6,0x60201,0x1},
      {ATTR_MODRM,C_IDIV,D_rEb,D__NONE,D__NONE,"IDIV",0xf6,0x70201,0x1},
};
_DIS_OPCODE_T GroupG3Ev[] = {
      {ATTR_X64|ATTR_MODRM,C_TEST,D_rEv,D__Iz,D__NONE,"TEST",0xf7,0x201,0x5},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf7,0x10201,0x0},
      {ATTR_MODRM,C_NOT,D__Ev,D__NONE,D__NONE,"NOT",0xf7,0x20201,0x3},
      {ATTR_MODRM,C_NEG,D__Ev,D__NONE,D__NONE,"NEG",0xf7,0x30201,0x3},
      {ATTR_MODRM,C_MUL,D_rEv,D__NONE,D__NONE,"MUL",0xf7,0x40201,0x1},
      {ATTR_MODRM,C_IMUL,D_rEv,D__NONE,D__NONE,"IMUL",0xf7,0x50201,0x1},
      {ATTR_MODRM,C_DIV,D_rEv,D__NONE,D__NONE,"DIV",0xf7,0x60201,0x1},
      {ATTR_MODRM,C_IDIV,D_rEv,D__NONE,D__NONE,"IDIV",0xf7,0x70201,0x1},
};
_DIS_OPCODE_T GroupG4[] = {
      {ATTR_MODRM,C_INC,D__Eb,D__NONE,D__NONE,"INC",0xfe,0x201,0x3},
      {ATTR_MODRM,C_DEC,D__Eb,D__NONE,D__NONE,"DEC",0xfe,0x10201,0x3},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG5v[] = {
      {ATTR_MODRM,C_INC,D_dEv,D__NONE,D__NONE,"INC",0xff,0x201,0x3},
      {ATTR_MODRM,C_DEC,D_dEv,D__NONE,D__NONE,"DEC",0xff,0x10201,0x3},
      {ATTR_MODRM|ATTR_JMP,C_CALL,D_rEv,D__NONE,D__NONE,"CALL",0xff,0x20201,0x1},
      {ATTR_MODRM,C_CALL,D_rEp,D__NONE,D__NONE,"CALL",0xff,0x30201,0x1},
      {ATTR_MODRM|ATTR_JMP,C_JMP,D_rEv,D__NONE,D__NONE,"JMP",0xff,0x40201,0x1},
      {ATTR_MODRM,C_JMP,D_rEp,D__NONE,D__NONE,"JMP",0xff,0x50201,0x1},
      {ATTR_MODRM|ATTR_SP,C_PUSH,D_rEv,D__NONE,D__NONE,"PUSH",0xff,0x60201,0x1},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG1_8f[] = {
      {ATTR_MODRM|ATTR_SP,C_POP,D_wEv,D__NONE,D__NONE,"POP",0x8f,0x201,0x2},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T FPGroupd8[] = {
      {ATTR_MODRM,C_FADD,D__single_real,D__NONE,D__NONE,"FADD",0xd8,0x101,0x1},
      {ATTR_MODRM,C_FMUL,D__single_real,D__NONE,D__NONE,"FMUL",0xd8,0x10101,0x1},
      {ATTR_MODRM,C_FCOM,D__single_real,D__NONE,D__NONE,"FCOM",0xd8,0x20101,0x1},
      {ATTR_MODRM,C_FCOMP,D__single_real,D__NONE,D__NONE,"FCOMP",0xd8,0x30101,0x1},
      {ATTR_MODRM,C_FSUB,D__single_real,D__NONE,D__NONE,"FSUB",0xd8,0x40101,0x1},
      {ATTR_MODRM,C_FSUBR,D__single_real,D__NONE,D__NONE,"FSUBR",0xd8,0x50101,0x1},
      {ATTR_MODRM,C_FDIV,D__single_real,D__NONE,D__NONE,"FDIV",0xd8,0x60101,0x1},
      {ATTR_MODRM,C_FDIVR,D__single_real,D__NONE,D__NONE,"FDIVR",0xd8,0x70101,0x1},
      {0,C_FADD,D__st,D__st0,D__NONE,"FADD",0xc0d8,0x80102,0x7},
      {0,C_FADD,D__st,D__st1,D__NONE,"FADD",0xc1d8,0x90102,0x7},
      {0,C_FADD,D__st,D__st2,D__NONE,"FADD",0xc2d8,0xa0102,0x7},
      {0,C_FADD,D__st,D__st3,D__NONE,"FADD",0xc3d8,0xb0102,0x7},
      {0,C_FADD,D__st,D__st4,D__NONE,"FADD",0xc4d8,0xc0102,0x7},
      {0,C_FADD,D__st,D__st5,D__NONE,"FADD",0xc5d8,0xd0102,0x7},
      {0,C_FADD,D__st,D__st6,D__NONE,"FADD",0xc6d8,0xe0102,0x7},
      {0,C_FADD,D__st,D__st7,D__NONE,"FADD",0xc7d8,0xf0102,0x7},
      {0,C_FMUL,D__st,D__st0,D__NONE,"FMUL",0xc8d8,0x100102,0x7},
      {0,C_FMUL,D__st,D__st1,D__NONE,"FMUL",0xc9d8,0x110102,0x7},
      {0,C_FMUL,D__st,D__st2,D__NONE,"FMUL",0xcad8,0x120102,0x7},
      {0,C_FMUL,D__st,D__st3,D__NONE,"FMUL",0xcbd8,0x130102,0x7},
      {0,C_FMUL,D__st,D__st4,D__NONE,"FMUL",0xccd8,0x140102,0x7},
      {0,C_FMUL,D__st,D__st5,D__NONE,"FMUL",0xcdd8,0x150102,0x7},
      {0,C_FMUL,D__st,D__st6,D__NONE,"FMUL",0xced8,0x160102,0x7},
      {0,C_FMUL,D__st,D__st7,D__NONE,"FMUL",0xcfd8,0x170102,0x7},
      {0,C_FCOM,D__st,D__st0,D__NONE,"FCOM",0xd0d8,0x180102,0x5},
      {0,C_FCOM,D__st,D__st1,D__NONE,"FCOM",0xd1d8,0x190102,0x5},
      {0,C_FCOM,D__st,D__st2,D__NONE,"FCOM",0xd2d8,0x1a0102,0x5},
      {0,C_FCOM,D__st,D__st3,D__NONE,"FCOM",0xd3d8,0x1b0102,0x5},
      {0,C_FCOM,D__st,D__st4,D__NONE,"FCOM",0xd4d8,0x1c0102,0x5},
      {0,C_FCOM,D__st,D__st5,D__NONE,"FCOM",0xd5d8,0x1d0102,0x5},
      {0,C_FCOM,D__st,D__st6,D__NONE,"FCOM",0xd6d8,0x1e0102,0x5},
      {0,C_FCOM,D__st,D__st7,D__NONE,"FCOM",0xd7d8,0x1f0102,0x5},
      {0,C_FCOMP,D__st,D__st0,D__NONE,"FCOMP",0xd8d8,0x200102,0x5},
      {0,C_FCOMP,D__st,D__st1,D__NONE,"FCOMP",0xd9d8,0x210102,0x5},
      {0,C_FCOMP,D__st,D__st2,D__NONE,"FCOMP",0xdad8,0x220102,0x5},
      {0,C_FCOMP,D__st,D__st3,D__NONE,"FCOMP",0xdbd8,0x230102,0x5},
      {0,C_FCOMP,D__st,D__st4,D__NONE,"FCOMP",0xdcd8,0x240102,0x5},
      {0,C_FCOMP,D__st,D__st5,D__NONE,"FCOMP",0xddd8,0x250102,0x5},
      {0,C_FCOMP,D__st,D__st6,D__NONE,"FCOMP",0xded8,0x260102,0x5},
      {0,C_FCOMP,D__st,D__st7,D__NONE,"FCOMP",0xdfd8,0x270102,0x5},
      {0,C_FSUB,D__st,D__st0,D__NONE,"FSUB",0xe0d8,0x280102,0x7},
      {0,C_FSUB,D__st,D__st1,D__NONE,"FSUB",0xe1d8,0x290102,0x7},
      {0,C_FSUB,D__st,D__st2,D__NONE,"FSUB",0xe2d8,0x2a0102,0x7},
      {0,C_FSUB,D__st,D__st3,D__NONE,"FSUB",0xe3d8,0x2b0102,0x7},
      {0,C_FSUB,D__st,D__st4,D__NONE,"FSUB",0xe4d8,0x2c0102,0x7},
      {0,C_FSUB,D__st,D__st5,D__NONE,"FSUB",0xe5d8,0x2d0102,0x7},
      {0,C_FSUB,D__st,D__st6,D__NONE,"FSUB",0xe6d8,0x2e0102,0x7},
      {0,C_FSUB,D__st,D__st7,D__NONE,"FSUB",0xe7d8,0x2f0102,0x7},
      {0,C_FSUBR,D__st,D__st0,D__NONE,"FSUBR",0xe8d8,0x300102,0x7},
      {0,C_FSUBR,D__st,D__st1,D__NONE,"FSUBR",0xe9d8,0x310102,0x7},
      {0,C_FSUBR,D__st,D__st2,D__NONE,"FSUBR",0xead8,0x320102,0x7},
      {0,C_FSUBR,D__st,D__st3,D__NONE,"FSUBR",0xebd8,0x330102,0x7},
      {0,C_FSUBR,D__st,D__st4,D__NONE,"FSUBR",0xecd8,0x340102,0x7},
      {0,C_FSUBR,D__st,D__st5,D__NONE,"FSUBR",0xedd8,0x350102,0x7},
      {0,C_FSUBR,D__st,D__st6,D__NONE,"FSUBR",0xeed8,0x360102,0x7},
      {0,C_FSUBR,D__st,D__st7,D__NONE,"FSUBR",0xefd8,0x370102,0x7},
      {0,C_FDIV,D__st,D__st0,D__NONE,"FDIV",0xf0d8,0x380102,0x7},
      {0,C_FDIV,D__st,D__st1,D__NONE,"FDIV",0xf1d8,0x390102,0x7},
      {0,C_FDIV,D__st,D__st2,D__NONE,"FDIV",0xf2d8,0x3a0102,0x7},
      {0,C_FDIV,D__st,D__st3,D__NONE,"FDIV",0xf3d8,0x3b0102,0x7},
      {0,C_FDIV,D__st,D__st4,D__NONE,"FDIV",0xf4d8,0x3c0102,0x7},
      {0,C_FDIV,D__st,D__st5,D__NONE,"FDIV",0xf5d8,0x3d0102,0x7},
      {0,C_FDIV,D__st,D__st6,D__NONE,"FDIV",0xf6d8,0x3e0102,0x7},
      {0,C_FDIV,D__st,D__st7,D__NONE,"FDIV",0xf7d8,0x3f0102,0x7},
      {0,C_FDIVR,D__st,D__st0,D__NONE,"FDIVR",0xf8d8,0x400102,0x7},
      {0,C_FDIVR,D__st,D__st1,D__NONE,"FDIVR",0xf9d8,0x410102,0x7},
      {0,C_FDIVR,D__st,D__st2,D__NONE,"FDIVR",0xfad8,0x420102,0x7},
      {0,C_FDIVR,D__st,D__st3,D__NONE,"FDIVR",0xfbd8,0x430102,0x7},
      {0,C_FDIVR,D__st,D__st4,D__NONE,"FDIVR",0xfcd8,0x440102,0x7},
      {0,C_FDIVR,D__st,D__st5,D__NONE,"FDIVR",0xfdd8,0x450102,0x7},
      {0,C_FDIVR,D__st,D__st6,D__NONE,"FDIVR",0xfed8,0x460102,0x7},
      {0,C_FDIVR,D__st,D__st7,D__NONE,"FDIVR",0xffd8,0x470102,0x7},
};
_DIS_OPCODE_T FPGroupd9[] = {
      {ATTR_MODRM,C_FLD,D__single_real,D__NONE,D__NONE,"FLD",0xd9,0x101,0x1},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_FST,D__single_real,D__NONE,D__NONE,"FST",0xd9,0x20101,0x2},
      {ATTR_MODRM,C_FSTP,D__single_real,D__NONE,D__NONE,"FSTP",0xd9,0x30101,0x2},
      {ATTR_MODRM,C_FLDENV,D__14_28b,D__NONE,D__NONE,"FLDENV",0xd9,0x40101,0x1},
      {ATTR_MODRM,C_FLDCW,D__2b,D__NONE,D__NONE,"FLDCW",0xd9,0x50101,0x1},
      {ATTR_MODRM,C_FSTENV,D__14_28b,D__NONE,D__NONE,"FSTENV",0xd9,0x60101,0x2},
      {ATTR_MODRM,C_FSTCW,D__2b,D__NONE,D__NONE,"FSTCW",0xd9,0x70101,0x2},
      {0,C_FLD,D__st,D__st0,D__NONE,"FLD",0xc0d9,0x80102,0x7},
      {0,C_FLD,D__st,D__st1,D__NONE,"FLD",0xc1d9,0x90102,0x7},
      {0,C_FLD,D__st,D__st2,D__NONE,"FLD",0xc2d9,0xa0102,0x7},
      {0,C_FLD,D__st,D__st3,D__NONE,"FLD",0xc3d9,0xb0102,0x7},
      {0,C_FLD,D__st,D__st4,D__NONE,"FLD",0xc4d9,0xc0102,0x7},
      {0,C_FLD,D__st,D__st5,D__NONE,"FLD",0xc5d9,0xd0102,0x7},
      {0,C_FLD,D__st,D__st6,D__NONE,"FLD",0xc6d9,0xe0102,0x7},
      {0,C_FLD,D__st,D__st7,D__NONE,"FLD",0xc7d9,0xf0102,0x7},
      {0,C_FXCH,D__st,D__st0,D__NONE,"FXCH",0xc8d9,0x100102,0xf},
      {0,C_FXCH,D__st,D__st1,D__NONE,"FXCH",0xc9d9,0x110102,0xf},
      {0,C_FXCH,D__st,D__st2,D__NONE,"FXCH",0xcad9,0x120102,0xf},
      {0,C_FXCH,D__st,D__st3,D__NONE,"FXCH",0xcbd9,0x130102,0xf},
      {0,C_FXCH,D__st,D__st4,D__NONE,"FXCH",0xccd9,0x140102,0xf},
      {0,C_FXCH,D__st,D__st5,D__NONE,"FXCH",0xcdd9,0x150102,0xf},
      {0,C_FXCH,D__st,D__st6,D__NONE,"FXCH",0xced9,0x160102,0xf},
      {0,C_FXCH,D__st,D__st7,D__NONE,"FXCH",0xcfd9,0x170102,0xf},
      {0,C_FNOP,D__NONE,D__NONE,D__NONE,"FNOP",0xd0d9,0x180102,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d8 "FSTP" sti0
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d9 "FSTP" sti1
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//da "FSTP" sti2
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//db "FSTP" sti3
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//dc "FSTP" sti4
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//dd "FSTP" sti5
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//de "FSTP" sti6
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//df "FSTP" sti7
      {0,C_FCHS,D__NONE,D__NONE,D__NONE,"FCHS",0xe0d9,0x280102,0x0},
      {0,C_FABS,D__NONE,D__NONE,D__NONE,"FABS",0xe1d9,0x290102,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_FTST,D__NONE,D__NONE,D__NONE,"FTST",0xe4d9,0x2c0102,0x0},
      {0,C_FXAM,D__NONE,D__NONE,D__NONE,"FXAM",0xe5d9,0x2d0102,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_FLD1,D__NONE,D__NONE,D__NONE,"FLD1",0xe8d9,0x300102,0x0},
      {0,C_FLDL2T,D__NONE,D__NONE,D__NONE,"FLDL2T",0xe9d9,0x310102,0x0},
      {0,C_FLDL2E,D__NONE,D__NONE,D__NONE,"FLDL2E",0xead9,0x320102,0x0},
      {0,C_FLDPI,D__NONE,D__NONE,D__NONE,"FLDPI",0xebd9,0x330102,0x0},
      {0,C_FLDLG2,D__NONE,D__NONE,D__NONE,"FLDLG2",0xecd9,0x340102,0x0},
      {0,C_FLDLN2,D__NONE,D__NONE,D__NONE,"FLDLN2",0xedd9,0x350102,0x0},
      {0,C_FLDZ,D__NONE,D__NONE,D__NONE,"FLDZ",0xeed9,0x360102,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_F2XM1,D__NONE,D__NONE,D__NONE,"F2XM1",0xf0d9,0x380102,0x0},
      {0,C_FYL2X,D__NONE,D__NONE,D__NONE,"FYL2X",0xf1d9,0x390102,0x0},
      {0,C_FPTAN,D__NONE,D__NONE,D__NONE,"FPTAN",0xf2d9,0x3a0102,0x0},
      {0,C_FPATAN,D__NONE,D__NONE,D__NONE,"FPATAN",0xf3d9,0x3b0102,0x0},
      {0,C_FXTRACT,D__NONE,D__NONE,D__NONE,"FXTRACT",0xf4d9,0x3c0102,0x0},
      {0,C_FPREM1,D__NONE,D__NONE,D__NONE,"FPREM1",0xf5d9,0x3d0102,0x0},
      {0,C_FDECSTP,D__NONE,D__NONE,D__NONE,"FDECSTP",0xf6d9,0x3e0102,0x0},
      {0,C_FINCSTP,D__NONE,D__NONE,D__NONE,"FINCSTP",0xf7d9,0x3f0102,0x0},
      {0,C_FPREM,D__NONE,D__NONE,D__NONE,"FPREM",0xf8d9,0x400102,0x0},
      {0,C_FYL2XP1,D__NONE,D__NONE,D__NONE,"FYL2XP1",0xf9d9,0x410102,0x0},
      {0,C_FSQRT,D__NONE,D__NONE,D__NONE,"FSQRT",0xfad9,0x420102,0x0},
      {0,C_FSINCOS,D__NONE,D__NONE,D__NONE,"FSINCOS",0xfbd9,0x430102,0x0},
      {0,C_FRNDINT,D__NONE,D__NONE,D__NONE,"FRNDINT",0xfcd9,0x440102,0x0},
      {0,C_FSCALE,D__NONE,D__NONE,D__NONE,"FSCALE",0xfdd9,0x450102,0x0},
      {0,C_FSIN,D__NONE,D__NONE,D__NONE,"FSIN",0xfed9,0x460102,0x0},
      {0,C_FCOS,D__NONE,D__NONE,D__NONE,"FCOS",0xffd9,0x470102,0x0},
};
_DIS_OPCODE_T FPGroupda[] = {
      {ATTR_MODRM,C_FIADD,D__dword_int,D__NONE,D__NONE,"FIADD",0xda,0x101,0x1},
      {ATTR_MODRM,C_FIMUL,D__dword_int,D__NONE,D__NONE,"FIMUL",0xda,0x10101,0x1},
      {ATTR_MODRM,C_FICOM,D__dword_int,D__NONE,D__NONE,"FICOM",0xda,0x20101,0x1},
      {ATTR_MODRM,C_FICOMP,D__dword_int,D__NONE,D__NONE,"FICOMP",0xda,0x30101,0x1},
      {ATTR_MODRM,C_FISUB,D__dword_int,D__NONE,D__NONE,"FISUB",0xda,0x40101,0x1},
      {ATTR_MODRM,C_FISUBR,D__dword_int,D__NONE,D__NONE,"FISUBR",0xda,0x50101,0x1},
      {ATTR_MODRM,C_FIDIV,D__dword_int,D__NONE,D__NONE,"FIDIV",0xda,0x60101,0x1},
      {ATTR_MODRM,C_FIDIVR,D__dword_int,D__NONE,D__NONE,"FIDIVR",0xda,0x70101,0x1},
      {0,C_FCMOVB,D__st,D__st0,D__NONE,"FCMOVB",0xc0da,0x80102,0x5},
      {0,C_FCMOVB,D__st,D__st1,D__NONE,"FCMOVB",0xc1da,0x90102,0x5},
      {0,C_FCMOVB,D__st,D__st2,D__NONE,"FCMOVB",0xc2da,0xa0102,0x5},
      {0,C_FCMOVB,D__st,D__st3,D__NONE,"FCMOVB",0xc3da,0xb0102,0x5},
      {0,C_FCMOVB,D__st,D__st4,D__NONE,"FCMOVB",0xc4da,0xc0102,0x5},
      {0,C_FCMOVB,D__st,D__st5,D__NONE,"FCMOVB",0xc5da,0xd0102,0x5},
      {0,C_FCMOVB,D__st,D__st6,D__NONE,"FCMOVB",0xc6da,0xe0102,0x5},
      {0,C_FCMOVB,D__st,D__st7,D__NONE,"FCMOVB",0xc7da,0xf0102,0x5},
      {0,C_FCMOVE,D__st,D__st0,D__NONE,"FCMOVE",0xc8da,0x100102,0x5},
      {0,C_FCMOVE,D__st,D__st1,D__NONE,"FCMOVE",0xc9da,0x110102,0x5},
      {0,C_FCMOVE,D__st,D__st2,D__NONE,"FCMOVE",0xcada,0x120102,0x5},
      {0,C_FCMOVE,D__st,D__st3,D__NONE,"FCMOVE",0xcbda,0x130102,0x5},
      {0,C_FCMOVE,D__st,D__st4,D__NONE,"FCMOVE",0xccda,0x140102,0x5},
      {0,C_FCMOVE,D__st,D__st5,D__NONE,"FCMOVE",0xcdda,0x150102,0x5},
      {0,C_FCMOVE,D__st,D__st6,D__NONE,"FCMOVE",0xceda,0x160102,0x5},
      {0,C_FCMOVE,D__st,D__st7,D__NONE,"FCMOVE",0xcfda,0x170102,0x5},
      {0,C_FCMOVBE,D__st,D__st0,D__NONE,"FCMOVBE",0xd0da,0x180102,0x5},
      {0,C_FCMOVBE,D__st,D__st1,D__NONE,"FCMOVBE",0xd1da,0x190102,0x5},
      {0,C_FCMOVBE,D__st,D__st2,D__NONE,"FCMOVBE",0xd2da,0x1a0102,0x5},
      {0,C_FCMOVBE,D__st,D__st3,D__NONE,"FCMOVBE",0xd3da,0x1b0102,0x5},
      {0,C_FCMOVBE,D__st,D__st4,D__NONE,"FCMOVBE",0xd4da,0x1c0102,0x5},
      {0,C_FCMOVBE,D__st,D__st5,D__NONE,"FCMOVBE",0xd5da,0x1d0102,0x5},
      {0,C_FCMOVBE,D__st,D__st6,D__NONE,"FCMOVBE",0xd6da,0x1e0102,0x5},
      {0,C_FCMOVBE,D__st,D__st7,D__NONE,"FCMOVBE",0xd7da,0x1f0102,0x5},
      {0,C_FCMOVU,D__st,D__st0,D__NONE,"FCMOVU",0xd8da,0x200102,0x5},
      {0,C_FCMOVU,D__st,D__st1,D__NONE,"FCMOVU",0xd9da,0x210102,0x5},
      {0,C_FCMOVU,D__st,D__st2,D__NONE,"FCMOVU",0xdada,0x220102,0x5},
      {0,C_FCMOVU,D__st,D__st3,D__NONE,"FCMOVU",0xdbda,0x230102,0x5},
      {0,C_FCMOVU,D__st,D__st4,D__NONE,"FCMOVU",0xdcda,0x240102,0x5},
      {0,C_FCMOVU,D__st,D__st5,D__NONE,"FCMOVU",0xddda,0x250102,0x5},
      {0,C_FCMOVU,D__st,D__st6,D__NONE,"FCMOVU",0xdeda,0x260102,0x5},
      {0,C_FCMOVU,D__st,D__st7,D__NONE,"FCMOVU",0xdfda,0x270102,0x5},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_FUCOMPP,D__NONE,D__NONE,D__NONE,"FUCOMPP",0xe9da,0x310102,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T FPGroupdb[] = {
      {ATTR_MODRM,C_FILD,D__dword_int,D__NONE,D__NONE,"FILD",0xdb,0x101,0x1},
      {ATTR_MODRM,C_FISTTP,D__dword_int,D__NONE,D__NONE,"FISTTP",0xdb,0x10101,0x2},
      {ATTR_MODRM,C_FIST,D__dword_int,D__NONE,D__NONE,"FIST",0xdb,0x20101,0x2},
      {ATTR_MODRM,C_FISTP,D__dword_int,D__NONE,D__NONE,"FISTP",0xdb,0x30101,0x2},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_FLD,D__extend_real,D__NONE,D__NONE,"FLD",0xdb,0x50101,0x1},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_FSTP,D__extend_real,D__NONE,D__NONE,"FSTP",0xdb,0x70101,0x2},
      {0,C_FCMOVNB,D__st,D__st0,D__NONE,"FCMOVNB",0xc0db,0x80102,0x4},
      {0,C_FCMOVNB,D__st,D__st1,D__NONE,"FCMOVNB",0xc1db,0x90102,0x4},
      {0,C_FCMOVNB,D__st,D__st2,D__NONE,"FCMOVNB",0xc2db,0xa0102,0x4},
      {0,C_FCMOVNB,D__st,D__st3,D__NONE,"FCMOVNB",0xc3db,0xb0102,0x4},
      {0,C_FCMOVNB,D__st,D__st4,D__NONE,"FCMOVNB",0xc4db,0xc0102,0x4},
      {0,C_FCMOVNB,D__st,D__st5,D__NONE,"FCMOVNB",0xc5db,0xd0102,0x4},
      {0,C_FCMOVNB,D__st,D__st6,D__NONE,"FCMOVNB",0xc6db,0xe0102,0x4},
      {0,C_FCMOVNB,D__st,D__st7,D__NONE,"FCMOVNB",0xc7db,0xf0102,0x4},
      {0,C_FCMOVNE,D__st,D__st0,D__NONE,"FCMOVNE",0xc8db,0x100102,0x4},
      {0,C_FCMOVNE,D__st,D__st1,D__NONE,"FCMOVNE",0xc9db,0x110102,0x4},
      {0,C_FCMOVNE,D__st,D__st2,D__NONE,"FCMOVNE",0xcadb,0x120102,0x4},
      {0,C_FCMOVNE,D__st,D__st3,D__NONE,"FCMOVNE",0xcbdb,0x130102,0x4},
      {0,C_FCMOVNE,D__st,D__st4,D__NONE,"FCMOVNE",0xccdb,0x140102,0x4},
      {0,C_FCMOVNE,D__st,D__st5,D__NONE,"FCMOVNE",0xcddb,0x150102,0x4},
      {0,C_FCMOVNE,D__st,D__st6,D__NONE,"FCMOVNE",0xcedb,0x160102,0x4},
      {0,C_FCMOVNE,D__st,D__st7,D__NONE,"FCMOVNE",0xcfdb,0x170102,0x4},
      {0,C_FCMOVNBE,D__st,D__st0,D__NONE,"FCMOVNBE",0xd0db,0x180102,0x4},
      {0,C_FCMOVNBE,D__st,D__st1,D__NONE,"FCMOVNBE",0xd1db,0x190102,0x4},
      {0,C_FCMOVNBE,D__st,D__st2,D__NONE,"FCMOVNBE",0xd2db,0x1a0102,0x4},
      {0,C_FCMOVNBE,D__st,D__st3,D__NONE,"FCMOVNBE",0xd3db,0x1b0102,0x4},
      {0,C_FCMOVNBE,D__st,D__st4,D__NONE,"FCMOVNBE",0xd4db,0x1c0102,0x4},
      {0,C_FCMOVNBE,D__st,D__st5,D__NONE,"FCMOVNBE",0xd5db,0x1d0102,0x4},
      {0,C_FCMOVNBE,D__st,D__st6,D__NONE,"FCMOVNBE",0xd6db,0x1e0102,0x4},
      {0,C_FCMOVNBE,D__st,D__st7,D__NONE,"FCMOVNBE",0xd7db,0x1f0102,0x4},
      {0,C_FCMOVNU,D__st,D__st0,D__NONE,"FCMOVNU",0xd8db,0x200102,0x4},
      {0,C_FCMOVNU,D__st,D__st1,D__NONE,"FCMOVNU",0xd9db,0x210102,0x4},
      {0,C_FCMOVNU,D__st,D__st2,D__NONE,"FCMOVNU",0xdadb,0x220102,0x4},
      {0,C_FCMOVNU,D__st,D__st3,D__NONE,"FCMOVNU",0xdbdb,0x230102,0x4},
      {0,C_FCMOVNU,D__st,D__st4,D__NONE,"FCMOVNU",0xdcdb,0x240102,0x4},
      {0,C_FCMOVNU,D__st,D__st5,D__NONE,"FCMOVNU",0xdddb,0x250102,0x4},
      {0,C_FCMOVNU,D__st,D__st6,D__NONE,"FCMOVNU",0xdedb,0x260102,0x4},
      {0,C_FCMOVNU,D__st,D__st7,D__NONE,"FCMOVNU",0xdfdb,0x270102,0x4},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_FCLEX,D__NONE,D__NONE,D__NONE,"FCLEX",0xe2db,0x2a0102,0x0},
      {0,C_FINIT,D__NONE,D__NONE,D__NONE,"FINIT",0xe3db,0x2b0102,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_FUCOMI,D__st,D__st0,D__NONE,"FUCOMI",0xe8db,0x300102,0x5},
      {0,C_FUCOMI,D__st,D__st1,D__NONE,"FUCOMI",0xe9db,0x310102,0x5},
      {0,C_FUCOMI,D__st,D__st2,D__NONE,"FUCOMI",0xeadb,0x320102,0x5},
      {0,C_FUCOMI,D__st,D__st3,D__NONE,"FUCOMI",0xebdb,0x330102,0x5},
      {0,C_FUCOMI,D__st,D__st4,D__NONE,"FUCOMI",0xecdb,0x340102,0x5},
      {0,C_FUCOMI,D__st,D__st5,D__NONE,"FUCOMI",0xeddb,0x350102,0x5},
      {0,C_FUCOMI,D__st,D__st6,D__NONE,"FUCOMI",0xeedb,0x360102,0x5},
      {0,C_FUCOMI,D__st,D__st7,D__NONE,"FUCOMI",0xefdb,0x370102,0x5},
      {0,C_FCOMI,D__st,D__st0,D__NONE,"FCOMI",0xf0db,0x380102,0x5},
      {0,C_FCOMI,D__st,D__st1,D__NONE,"FCOMI",0xf1db,0x390102,0x5},
      {0,C_FCOMI,D__st,D__st2,D__NONE,"FCOMI",0xf2db,0x3a0102,0x5},
      {0,C_FCOMI,D__st,D__st3,D__NONE,"FCOMI",0xf3db,0x3b0102,0x5},
      {0,C_FCOMI,D__st,D__st4,D__NONE,"FCOMI",0xf4db,0x3c0102,0x5},
      {0,C_FCOMI,D__st,D__st5,D__NONE,"FCOMI",0xf5db,0x3d0102,0x5},
      {0,C_FCOMI,D__st,D__st6,D__NONE,"FCOMI",0xf6db,0x3e0102,0x5},
      {0,C_FCOMI,D__st,D__st7,D__NONE,"FCOMI",0xf7db,0x3f0102,0x5},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T FPGroupdc[] = {
      {ATTR_MODRM,C_FADD,D__double_real,D__NONE,D__NONE,"FADD",0xdc,0x101,0x1},
      {ATTR_MODRM,C_FMUL,D__double_real,D__NONE,D__NONE,"FMUL",0xdc,0x10101,0x1},
      {ATTR_MODRM,C_FCOM,D__double_real,D__NONE,D__NONE,"FCOM",0xdc,0x20101,0x1},
      {ATTR_MODRM,C_FCOMP,D__double_real,D__NONE,D__NONE,"FCOMP",0xdc,0x30101,0x1},
      {ATTR_MODRM,C_FSUB,D__double_real,D__NONE,D__NONE,"FSUB",0xdc,0x40101,0x1},
      {ATTR_MODRM,C_FSUBR,D__double_real,D__NONE,D__NONE,"FSUBR",0xdc,0x50101,0x1},
      {ATTR_MODRM,C_FDIV,D__double_real,D__NONE,D__NONE,"FDIV",0xdc,0x60101,0x1},
      {ATTR_MODRM,C_FDIVR,D__double_real,D__NONE,D__NONE,"FDIVR",0xdc,0x70101,0x1},
      {0,C_FADD,D__st0,D__st,D__NONE,"FADD",0xc0dc,0x80102,0x7},
      {0,C_FADD,D__st1,D__st,D__NONE,"FADD",0xc1dc,0x90102,0x7},
      {0,C_FADD,D__st2,D__st,D__NONE,"FADD",0xc2dc,0xa0102,0x7},
      {0,C_FADD,D__st3,D__st,D__NONE,"FADD",0xc3dc,0xb0102,0x7},
      {0,C_FADD,D__st4,D__st,D__NONE,"FADD",0xc4dc,0xc0102,0x7},
      {0,C_FADD,D__st5,D__st,D__NONE,"FADD",0xc5dc,0xd0102,0x7},
      {0,C_FADD,D__st6,D__st,D__NONE,"FADD",0xc6dc,0xe0102,0x7},
      {0,C_FADD,D__st7,D__st,D__NONE,"FADD",0xc7dc,0xf0102,0x7},
      {0,C_FMUL,D__st0,D__st,D__NONE,"FMUL",0xc8dc,0x100102,0x7},
      {0,C_FMUL,D__st1,D__st,D__NONE,"FMUL",0xc9dc,0x110102,0x7},
      {0,C_FMUL,D__st2,D__st,D__NONE,"FMUL",0xcadc,0x120102,0x7},
      {0,C_FMUL,D__st3,D__st,D__NONE,"FMUL",0xcbdc,0x130102,0x7},
      {0,C_FMUL,D__st4,D__st,D__NONE,"FMUL",0xccdc,0x140102,0x7},
      {0,C_FMUL,D__st5,D__st,D__NONE,"FMUL",0xcddc,0x150102,0x7},
      {0,C_FMUL,D__st6,D__st,D__NONE,"FMUL",0xcedc,0x160102,0x7},
      {0,C_FMUL,D__st7,D__st,D__NONE,"FMUL",0xcfdc,0x170102,0x7},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d0 FCOM st sti0
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d1 FCOM st sti1
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d2 FCOM st sti2
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d3 FCOM st sti3
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d4 FCOM st sti4
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d5 FCOM st sti5
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d6 FCOM st sti6
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d7 FCOM st sti7
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d8 FCOMP st sti0
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d9 FCOMP st sti1
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//da FCOMP st sti2
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//db FCOMP st sti3
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//dc FCOMP st sti4
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//dd FCOMP st sti5
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//de FCOMP st sti6
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//df FCOMP st sti7
      {0,C_FSUBR,D__st0,D__st,D__NONE,"FSUBR",0xe0dc,0x280102,0x7},
      {0,C_FSUBR,D__st1,D__st,D__NONE,"FSUBR",0xe1dc,0x290102,0x7},
      {0,C_FSUBR,D__st2,D__st,D__NONE,"FSUBR",0xe2dc,0x2a0102,0x7},
      {0,C_FSUBR,D__st3,D__st,D__NONE,"FSUBR",0xe3dc,0x2b0102,0x7},
      {0,C_FSUBR,D__st4,D__st,D__NONE,"FSUBR",0xe4dc,0x2c0102,0x7},
      {0,C_FSUBR,D__st5,D__st,D__NONE,"FSUBR",0xe5dc,0x2d0102,0x7},
      {0,C_FSUBR,D__st6,D__st,D__NONE,"FSUBR",0xe6dc,0x2e0102,0x7},
      {0,C_FSUBR,D__st7,D__st,D__NONE,"FSUBR",0xe7dc,0x2f0102,0x7},
      {0,C_FSUB,D__st0,D__st,D__NONE,"FSUB",0xe8dc,0x300102,0x7},
      {0,C_FSUB,D__st1,D__st,D__NONE,"FSUB",0xe9dc,0x310102,0x7},
      {0,C_FSUB,D__st2,D__st,D__NONE,"FSUB",0xeadc,0x320102,0x7},
      {0,C_FSUB,D__st3,D__st,D__NONE,"FSUB",0xebdc,0x330102,0x7},
      {0,C_FSUB,D__st4,D__st,D__NONE,"FSUB",0xecdc,0x340102,0x7},
      {0,C_FSUB,D__st5,D__st,D__NONE,"FSUB",0xeddc,0x350102,0x7},
      {0,C_FSUB,D__st6,D__st,D__NONE,"FSUB",0xeedc,0x360102,0x7},
      {0,C_FSUB,D__st7,D__st,D__NONE,"FSUB",0xefdc,0x370102,0x7},
      {0,C_FDIVR,D__st0,D__st,D__NONE,"FDIVR",0xf0dc,0x380102,0x7},
      {0,C_FDIVR,D__st1,D__st,D__NONE,"FDIVR",0xf1dc,0x390102,0x7},
      {0,C_FDIVR,D__st2,D__st,D__NONE,"FDIVR",0xf2dc,0x3a0102,0x7},
      {0,C_FDIVR,D__st3,D__st,D__NONE,"FDIVR",0xf3dc,0x3b0102,0x7},
      {0,C_FDIVR,D__st4,D__st,D__NONE,"FDIVR",0xf4dc,0x3c0102,0x7},
      {0,C_FDIVR,D__st5,D__st,D__NONE,"FDIVR",0xf5dc,0x3d0102,0x7},
      {0,C_FDIVR,D__st6,D__st,D__NONE,"FDIVR",0xf6dc,0x3e0102,0x7},
      {0,C_FDIVR,D__st7,D__st,D__NONE,"FDIVR",0xf7dc,0x3f0102,0x7},
      {0,C_FDIV,D__st0,D__st,D__NONE,"FDIV",0xf8dc,0x400102,0x7},
      {0,C_FDIV,D__st1,D__st,D__NONE,"FDIV",0xf9dc,0x410102,0x7},
      {0,C_FDIV,D__st2,D__st,D__NONE,"FDIV",0xfadc,0x420102,0x7},
      {0,C_FDIV,D__st3,D__st,D__NONE,"FDIV",0xfbdc,0x430102,0x7},
      {0,C_FDIV,D__st4,D__st,D__NONE,"FDIV",0xfcdc,0x440102,0x7},
      {0,C_FDIV,D__st5,D__st,D__NONE,"FDIV",0xfddc,0x450102,0x7},
      {0,C_FDIV,D__st6,D__st,D__NONE,"FDIV",0xfedc,0x460102,0x7},
      {0,C_FDIV,D__st7,D__st,D__NONE,"FDIV",0xffdc,0x470102,0x7},
};
_DIS_OPCODE_T FPGroupdd[] = {
      {ATTR_MODRM,C_FLD,D__double_real,D__NONE,D__NONE,"FLD",0xdd,0x101,0x1},
      {ATTR_MODRM,C_FISTTP,D__double_real,D__NONE,D__NONE,"FISTTP",0xdd,0x10101,0x2},
      {ATTR_MODRM,C_FST,D__double_real,D__NONE,D__NONE,"FST",0xdd,0x20101,0x2},
      {ATTR_MODRM,C_FSTP,D__double_real,D__NONE,D__NONE,"FSTP",0xdd,0x30101,0x2},
      {ATTR_MODRM,C_FRSTOR,D__98_108b,D__NONE,D__NONE,"FRSTOR",0xdd,0x40101,0x1},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_FSAVE,D__98_108b,D__NONE,D__NONE,"FSAVE",0xdd,0x60101,0x2},
      {ATTR_MODRM,C_FSTSW,D__2b,D__NONE,D__NONE,"FSTSW",0xdd,0x70101,0x2},
      {0,C_FFREE,D__st0,D__NONE,D__NONE,"FFREE",0xc0dd,0x80102,0x0},
      {0,C_FFREE,D__st1,D__NONE,D__NONE,"FFREE",0xc1dd,0x90102,0x0},
      {0,C_FFREE,D__st2,D__NONE,D__NONE,"FFREE",0xc2dd,0xa0102,0x0},
      {0,C_FFREE,D__st3,D__NONE,D__NONE,"FFREE",0xc3dd,0xb0102,0x0},
      {0,C_FFREE,D__st4,D__NONE,D__NONE,"FFREE",0xc4dd,0xc0102,0x0},
      {0,C_FFREE,D__st5,D__NONE,D__NONE,"FFREE",0xc5dd,0xd0102,0x0},
      {0,C_FFREE,D__st6,D__NONE,D__NONE,"FFREE",0xc6dd,0xe0102,0x0},
      {0,C_FFREE,D__st7,D__NONE,D__NONE,"FFREE",0xc7dd,0xf0102,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c8 FXCH st st0
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c9 FXCH st st1
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//ca FXCH st st2
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//cb FXCH st st3
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//cc FXCH st st4
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//cd FXCH st st5
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//ce FXCH st st6
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//cf FXCH st st7
      {0,C_FST,D__st0,D__NONE,D__NONE,"FST",0xd0dd,0x180102,0x1},
      {0,C_FST,D__st1,D__NONE,D__NONE,"FST",0xd1dd,0x190102,0x1},
      {0,C_FST,D__st2,D__NONE,D__NONE,"FST",0xd2dd,0x1a0102,0x1},
      {0,C_FST,D__st3,D__NONE,D__NONE,"FST",0xd3dd,0x1b0102,0x1},
      {0,C_FST,D__st4,D__NONE,D__NONE,"FST",0xd4dd,0x1c0102,0x1},
      {0,C_FST,D__st5,D__NONE,D__NONE,"FST",0xd5dd,0x1d0102,0x1},
      {0,C_FST,D__st6,D__NONE,D__NONE,"FST",0xd6dd,0x1e0102,0x1},
      {0,C_FST,D__st7,D__NONE,D__NONE,"FST",0xd7dd,0x1f0102,0x1},
      {0,C_FSTP,D__st0,D__NONE,D__NONE,"FSTP",0xd8dd,0x200102,0x1},
      {0,C_FSTP,D__st1,D__NONE,D__NONE,"FSTP",0xd9dd,0x210102,0x1},
      {0,C_FSTP,D__st2,D__NONE,D__NONE,"FSTP",0xdadd,0x220102,0x1},
      {0,C_FSTP,D__st3,D__NONE,D__NONE,"FSTP",0xdbdd,0x230102,0x1},
      {0,C_FSTP,D__st4,D__NONE,D__NONE,"FSTP",0xdcdd,0x240102,0x1},
      {0,C_FSTP,D__st5,D__NONE,D__NONE,"FSTP",0xdddd,0x250102,0x1},
      {0,C_FSTP,D__st6,D__NONE,D__NONE,"FSTP",0xdedd,0x260102,0x1},
      {0,C_FSTP,D__st7,D__NONE,D__NONE,"FSTP",0xdfdd,0x270102,0x1},
      {0,C_FUCOM,D__st0,D__st,D__NONE,"FUCOM",0xe0dd,0x280102,0x5},
      {0,C_FUCOM,D__st1,D__st,D__NONE,"FUCOM",0xe1dd,0x290102,0x5},
      {0,C_FUCOM,D__st2,D__st,D__NONE,"FUCOM",0xe2dd,0x2a0102,0x5},
      {0,C_FUCOM,D__st3,D__st,D__NONE,"FUCOM",0xe3dd,0x2b0102,0x5},
      {0,C_FUCOM,D__st4,D__st,D__NONE,"FUCOM",0xe4dd,0x2c0102,0x5},
      {0,C_FUCOM,D__st5,D__st,D__NONE,"FUCOM",0xe5dd,0x2d0102,0x5},
      {0,C_FUCOM,D__st6,D__st,D__NONE,"FUCOM",0xe6dd,0x2e0102,0x5},
      {0,C_FUCOM,D__st7,D__st,D__NONE,"FUCOM",0xe7dd,0x2f0102,0x5},
      {0,C_FUCOMP,D__st0,D__NONE,D__NONE,"FUCOMP",0xe8dd,0x300102,0x1},
      {0,C_FUCOMP,D__st1,D__NONE,D__NONE,"FUCOMP",0xe9dd,0x310102,0x1},
      {0,C_FUCOMP,D__st2,D__NONE,D__NONE,"FUCOMP",0xeadd,0x320102,0x1},
      {0,C_FUCOMP,D__st3,D__NONE,D__NONE,"FUCOMP",0xebdd,0x330102,0x1},
      {0,C_FUCOMP,D__st4,D__NONE,D__NONE,"FUCOMP",0xecdd,0x340102,0x1},
      {0,C_FUCOMP,D__st5,D__NONE,D__NONE,"FUCOMP",0xeddd,0x350102,0x1},
      {0,C_FUCOMP,D__st6,D__NONE,D__NONE,"FUCOMP",0xeedd,0x360102,0x1},
      {0,C_FUCOMP,D__st7,D__NONE,D__NONE,"FUCOMP",0xefdd,0x370102,0x1},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T FPGroupde[] = {
      {ATTR_MODRM,C_FIADD,D__word_int,D__NONE,D__NONE,"FIADD",0xde,0x101,0x7},
      {ATTR_MODRM,C_FIMUL,D__word_int,D__NONE,D__NONE,"FIMUL",0xde,0x10101,0x7},
      {ATTR_MODRM,C_FICOM,D__word_int,D__NONE,D__NONE,"FICOM",0xde,0x20101,0x5},
      {ATTR_MODRM,C_FICOMP,D__word_int,D__NONE,D__NONE,"FICOMP",0xde,0x30101,0x5},
      {ATTR_MODRM,C_FISUB,D__word_int,D__NONE,D__NONE,"FISUB",0xde,0x40101,0x7},
      {ATTR_MODRM,C_FISUBR,D__word_int,D__NONE,D__NONE,"FISUBR",0xde,0x50101,0x7},
      {ATTR_MODRM,C_FIDIV,D__word_int,D__NONE,D__NONE,"FIDIV",0xde,0x60101,0x7},
      {ATTR_MODRM,C_FIDIVR,D__word_int,D__NONE,D__NONE,"FIDIVR",0xde,0x70101,0x7},
      {0,C_FADDP,D__st0,D__st,D__NONE,"FADDP",0xc0de,0x80102,0x7},
      {0,C_FADDP,D__st1,D__st,D__NONE,"FADDP",0xc1de,0x90102,0x7},
      {0,C_FADDP,D__st2,D__st,D__NONE,"FADDP",0xc2de,0xa0102,0x7},
      {0,C_FADDP,D__st3,D__st,D__NONE,"FADDP",0xc3de,0xb0102,0x7},
      {0,C_FADDP,D__st4,D__st,D__NONE,"FADDP",0xc4de,0xc0102,0x7},
      {0,C_FADDP,D__st5,D__st,D__NONE,"FADDP",0xc5de,0xd0102,0x7},
      {0,C_FADDP,D__st6,D__st,D__NONE,"FADDP",0xc6de,0xe0102,0x7},
      {0,C_FADDP,D__st7,D__st,D__NONE,"FADDP",0xc7de,0xf0102,0x7},
      {0,C_FMULP,D__st0,D__st,D__NONE,"FMULP",0xc8de,0x100102,0x7},
      {0,C_FMULP,D__st1,D__st,D__NONE,"FMULP",0xc9de,0x110102,0x7},
      {0,C_FMULP,D__st2,D__st,D__NONE,"FMULP",0xcade,0x120102,0x7},
      {0,C_FMULP,D__st3,D__st,D__NONE,"FMULP",0xcbde,0x130102,0x7},
      {0,C_FMULP,D__st4,D__st,D__NONE,"FMULP",0xccde,0x140102,0x7},
      {0,C_FMULP,D__st5,D__st,D__NONE,"FMULP",0xcdde,0x150102,0x7},
      {0,C_FMULP,D__st6,D__st,D__NONE,"FMULP",0xcede,0x160102,0x7},
      {0,C_FMULP,D__st7,D__st,D__NONE,"FMULP",0xcfde,0x170102,0x7},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d0 FCOMP sti0
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d1 FCOMP sti1
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d2 FCOMP sti2
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d3 FCOMP sti3
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d4 FCOMP sti4
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d5 FCOMP sti5
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d6 FCOMP sti6
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d7 FCOMP sti7
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_FCOMPP,D__NONE,D__NONE,D__NONE,"FCOMPP",0xd9de,0x210102,0x5},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_FSUBRP,D__st0,D__st,D__NONE,"FSUBRP",0xe0de,0x280102,0x7},
      {0,C_FSUBRP,D__st1,D__st,D__NONE,"FSUBRP",0xe1de,0x290102,0x7},
      {0,C_FSUBRP,D__st2,D__st,D__NONE,"FSUBRP",0xe2de,0x2a0102,0x7},
      {0,C_FSUBRP,D__st3,D__st,D__NONE,"FSUBRP",0xe3de,0x2b0102,0x7},
      {0,C_FSUBRP,D__st4,D__st,D__NONE,"FSUBRP",0xe4de,0x2c0102,0x7},
      {0,C_FSUBRP,D__st5,D__st,D__NONE,"FSUBRP",0xe5de,0x2d0102,0x7},
      {0,C_FSUBRP,D__st6,D__st,D__NONE,"FSUBRP",0xe6de,0x2e0102,0x7},
      {0,C_FSUBRP,D__st7,D__st,D__NONE,"FSUBRP",0xe7de,0x2f0102,0x7},
      {0,C_FSUBP,D__st0,D__st,D__NONE,"FSUBP",0xe8de,0x300102,0x7},
      {0,C_FSUBP,D__st1,D__st,D__NONE,"FSUBP",0xe9de,0x310102,0x7},
      {0,C_FSUBP,D__st2,D__st,D__NONE,"FSUBP",0xeade,0x320102,0x7},
      {0,C_FSUBP,D__st3,D__st,D__NONE,"FSUBP",0xebde,0x330102,0x7},
      {0,C_FSUBP,D__st4,D__st,D__NONE,"FSUBP",0xecde,0x340102,0x7},
      {0,C_FSUBP,D__st5,D__st,D__NONE,"FSUBP",0xedde,0x350102,0x7},
      {0,C_FSUBP,D__st6,D__st,D__NONE,"FSUBP",0xeede,0x360102,0x7},
      {0,C_FSUBP,D__st7,D__st,D__NONE,"FSUBP",0xefde,0x370102,0x7},
      {0,C_FDIVRP,D__st0,D__st,D__NONE,"FDIVRP",0xf0de,0x380102,0x7},
      {0,C_FDIVRP,D__st1,D__st,D__NONE,"FDIVRP",0xf1de,0x390102,0x7},
      {0,C_FDIVRP,D__st2,D__st,D__NONE,"FDIVRP",0xf2de,0x3a0102,0x7},
      {0,C_FDIVRP,D__st3,D__st,D__NONE,"FDIVRP",0xf3de,0x3b0102,0x7},
      {0,C_FDIVRP,D__st4,D__st,D__NONE,"FDIVRP",0xf4de,0x3c0102,0x7},
      {0,C_FDIVRP,D__st5,D__st,D__NONE,"FDIVRP",0xf5de,0x3d0102,0x7},
      {0,C_FDIVRP,D__st6,D__st,D__NONE,"FDIVRP",0xf6de,0x3e0102,0x7},
      {0,C_FDIVRP,D__st7,D__st,D__NONE,"FDIVRP",0xf7de,0x3f0102,0x7},
      {0,C_FDIVP,D__st0,D__st,D__NONE,"FDIVP",0xf8de,0x400102,0x7},
      {0,C_FDIVP,D__st1,D__st,D__NONE,"FDIVP",0xf9de,0x410102,0x7},
      {0,C_FDIVP,D__st2,D__st,D__NONE,"FDIVP",0xfade,0x420102,0x7},
      {0,C_FDIVP,D__st3,D__st,D__NONE,"FDIVP",0xfbde,0x430102,0x7},
      {0,C_FDIVP,D__st4,D__st,D__NONE,"FDIVP",0xfcde,0x440102,0x7},
      {0,C_FDIVP,D__st5,D__st,D__NONE,"FDIVP",0xfdde,0x450102,0x7},
      {0,C_FDIVP,D__st6,D__st,D__NONE,"FDIVP",0xfede,0x460102,0x7},
      {0,C_FDIVP,D__st7,D__st,D__NONE,"FDIVP",0xffde,0x470102,0x7},
};
_DIS_OPCODE_T FPGroupdf[] = {
      {ATTR_MODRM,C_FILD,D__word_int,D__NONE,D__NONE,"FILD",0xdf,0x101,0x1},//7
      {ATTR_MODRM,C_FISTTP,D__word_int,D__NONE,D__NONE,"FISTTP",0xdf,0x10101,0x1},//8
      {ATTR_MODRM,C_FIST,D__word_int,D__NONE,D__NONE,"FIST",0xdf,0x20101,0x2},//9
      {ATTR_MODRM,C_FISTP,D__word_int,D__NONE,D__NONE,"FISTP",0xdf,0x30101,0x2},//a
      {ATTR_MODRM,C_FBLD,D__packed_BCD,D__NONE,D__NONE,"FBLD",0xdf,0x40101,0x1},//b
      {ATTR_MODRM,C_FILD,D__qword_int,D__NONE,D__NONE,"FILD",0xdf,0x50101,0x1},//c
      {ATTR_MODRM,C_FBSTP,D__packed_BCD,D__NONE,D__NONE,"FBSTP",0xdf,0x60101,0x2},//d
      {ATTR_MODRM,C_FISTP,D__qword_int,D__NONE,D__NONE,"FISTP",0xdf,0x70101,0x2},//e
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//bf
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c0
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c1
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c2
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c3
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c4
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c5
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c7
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c8 FXCH
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//c9 FXCH
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//ca FXCH
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//cb FXCH
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//cc FXCH
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//cd FXCH
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//ce FXCH
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//cf FXCH
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d0 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d1 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d2 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d3 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d4 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d5 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d6 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d7 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d8 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//d9 FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//da FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//db FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//dc FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//dd FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//de FSTP sti
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},//df FSTP sti
      {0,C_FSTSW,D__AX,D__NONE,D__NONE,"FSTSW",0xe0df,0x280102,0x2},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_FUCOMIP,D__st0,D__st,D__NONE,"FUCOMIP",0xe8df,0x300102,0x5},
      {0,C_FUCOMIP,D__st1,D__st,D__NONE,"FUCOMIP",0xe9df,0x310102,0x5},
      {0,C_FUCOMIP,D__st2,D__st,D__NONE,"FUCOMIP",0xeadf,0x320102,0x5},
      {0,C_FUCOMIP,D__st3,D__st,D__NONE,"FUCOMIP",0xebdf,0x330102,0x5},
      {0,C_FUCOMIP,D__st4,D__st,D__NONE,"FUCOMIP",0xecdf,0x340102,0x5},
      {0,C_FUCOMIP,D__st5,D__st,D__NONE,"FUCOMIP",0xeddf,0x350102,0x5},
      {0,C_FUCOMIP,D__st6,D__st,D__NONE,"FUCOMIP",0xeedf,0x360102,0x5},
      {0,C_FUCOMIP,D__st7,D__st,D__NONE,"FUCOMIP",0xefdf,0x370102,0x5},
      {0,C_FCOMIP,D__st0,D__st,D__NONE,"FCOMIP",0xf0df,0x380102,0x5},
      {0,C_FCOMIP,D__st1,D__st,D__NONE,"FCOMIP",0xf1df,0x390102,0x5},
      {0,C_FCOMIP,D__st2,D__st,D__NONE,"FCOMIP",0xf2df,0x3a0102,0x5},
      {0,C_FCOMIP,D__st3,D__st,D__NONE,"FCOMIP",0xf3df,0x3b0102,0x5},
      {0,C_FCOMIP,D__st4,D__st,D__NONE,"FCOMIP",0xf4df,0x3c0102,0x5},
      {0,C_FCOMIP,D__st5,D__st,D__NONE,"FCOMIP",0xf5df,0x3d0102,0x5},
      {0,C_FCOMIP,D__st6,D__st,D__NONE,"FCOMIP",0xf6df,0x3e0102,0x5},
      {0,C_FCOMIP,D__st7,D__st,D__NONE,"FCOMIP",0xf7df,0x3f0102,0x5},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG7M[] = {
      {ATTR_MODRM,C_SGDT,D_wMs,D__NONE,D__NONE,"SGDT",0x10f,0x802,0x2},
      {ATTR_MODRM,C_SIDT,D_wMs,D__NONE,D__NONE,"SIDT",0x10f,0x10802,0x2},
      {ATTR_MODRM,C_LGDT,D_rMs,D__NONE,D__NONE,"LGDT",0x10f,0x20802,0x1},
      {ATTR_MODRM,C_LIDT,D_rMs,D__NONE,D__NONE,"LIDT",0x10f,0x30802,0x1},
      {ATTR_MODRM,C_SMSW,D_wEx,D__NONE,D__NONE,"SMSW",0x10f,0x40802,0x2},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_LMSW,D_rEw,D__NONE,D__NONE,"LMSW",0x10f,0x60802,0x1},
      {ATTR_MODRM,C_INVLPG,D__Mb,D__NONE,D__NONE,"INVLPG",0x10f,0x70802,0x1},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_VMCALL,D__NONE,D__NONE,D__NONE,"VMCALL",0x10f,0x90802,0x0},
      {ATTR_MODRM,C_VMLAUNCH,D__NONE,D__NONE,D__NONE,"VMLAUNCH",0x10f,0xa0802,0x0},
      {ATTR_MODRM,C_VMRESUME,D__NONE,D__NONE,D__NONE,"VMRESUME",0x10f,0xb0802,0x0},
      {ATTR_MODRM,C_VMXOFF,D__NONE,D__NONE,D__NONE,"VMXOFF",0x10f,0xc0802,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MONITOR,D__NONE,D__NONE,D__NONE,"monitor",0x10f,0x100802,0x0},
      {ATTR_MODRM,C_MWAIT,D__NONE,D__NONE,D__NONE,"mwait",0x10f,0x110802,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_XGETBV,D__NONE,D__NONE,D__NONE,"xgetbv",0x10f,0x180802,0x0},
      {ATTR_MODRM,C_XSETBV,D__NONE,D__NONE,D__NONE,"xsetbv",0x10f,0x190802,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_VMRUN,D__EAX,D__NONE,D__NONE,"VMRUN",0x10f,0x200802,0x1},
      {ATTR_MODRM,C_VMMCALL,D__NONE,D__NONE,D__NONE,"VMMCALL",0x10f,0x210802,0x0},
      {ATTR_MODRM,C_VMLOAD,D__EAX,D__NONE,D__NONE,"VMLOAD",0x10f,0x220802,0x1},
      {ATTR_MODRM,C_VMSAVE,D__EAX,D__NONE,D__NONE,"VMSAVE",0x10f,0x230802,0x2},
      {ATTR_MODRM,C_STGI,D__NONE,D__NONE,D__NONE,"STGI",0x10f,0x240802,0x0},
      {ATTR_MODRM,C_CLGI,D__NONE,D__NONE,D__NONE,"CLGI",0x10f,0x250802,0x0},
      {ATTR_MODRM,C_SKINIT,D__EAX,D__NONE,D__NONE,"SKINIT",0x10f,0x260802,0x0},
      {ATTR_MODRM,C_INVLPGA,D__EAX,D__ECX,D__NONE,"INVLPGA",0x10f,0x270802,0x0},
      {ATTR_MODRM,C_SMSW,D_wEx,D__NONE,D__NONE,"SMSW",0x10f,0x280802,0x2},
      {ATTR_MODRM,C_SMSW,D_wEx,D__NONE,D__NONE,"SMSW",0x10f,0x290802,0x2},
      {ATTR_MODRM,C_SMSW,D_wEx,D__NONE,D__NONE,"SMSW",0x10f,0x2a0802,0x2},
      {ATTR_MODRM,C_SMSW,D_wEx,D__NONE,D__NONE,"SMSW",0x10f,0x2b0802,0x2},
      {ATTR_MODRM,C_SMSW,D_wEx,D__NONE,D__NONE,"SMSW",0x10f,0x2c0802,0x2},
      {ATTR_MODRM,C_SMSW,D_wEx,D__NONE,D__NONE,"SMSW",0x10f,0x2d0802,0x2},
      {ATTR_MODRM,C_SMSW,D_wEx,D__NONE,D__NONE,"SMSW",0x10f,0x2e0802,0x2},
      {ATTR_MODRM,C_SMSW,D_wEx,D__NONE,D__NONE,"SMSW",0x10f,0x2f0802,0x2},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_LMSW,D_rEw,D__NONE,D__NONE,"LMSW",0x10f,0x380802,0x1},
      {ATTR_MODRM,C_LMSW,D_rEw,D__NONE,D__NONE,"LMSW",0x10f,0x390802,0x1},
      {ATTR_MODRM,C_LMSW,D_rEw,D__NONE,D__NONE,"LMSW",0x10f,0x3a0802,0x1},
      {ATTR_MODRM,C_LMSW,D_rEw,D__NONE,D__NONE,"LMSW",0x10f,0x3b0802,0x1},
      {ATTR_MODRM,C_LMSW,D_rEw,D__NONE,D__NONE,"LMSW",0x10f,0x3c0802,0x1},
      {ATTR_MODRM,C_LMSW,D_rEw,D__NONE,D__NONE,"LMSW",0x10f,0x3d0802,0x1},
      {ATTR_MODRM,C_LMSW,D_rEw,D__NONE,D__NONE,"LMSW",0x10f,0x3e0802,0x1},
      {ATTR_MODRM,C_LMSW,D_rEw,D__NONE,D__NONE,"LMSW",0x10f,0x3f0802,0x1},
      {ATTR_MODRM,C_SWAPGS,D__NONE,D__NONE,D__NONE,"SWAPGS",0x10f,0x400802,0x0},
      {ATTR_MODRM,C_RDTSCP,D__NONE,D__NONE,D__NONE,"RDTSCP",0x10f,0x410802,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG16[] = {
      {ATTR_MODRM,C_PREFETCHNTA,D__Mb,D__NONE,D__NONE,"prefetchnta",0x180f,0x202,0x1},
      {ATTR_MODRM,C_PREFETCHNTA,D__Mb,D__NONE,D__NONE,"prefetcht0",0x180f,0x10202,0x1},
      {ATTR_MODRM,C_PREFETCHNTA,D__Mb,D__NONE,D__NONE,"prefetcht1",0x180f,0x20202,0x1},
      {ATTR_MODRM,C_PREFETCHNTA,D__Mb,D__NONE,D__NONE,"prefetcht2",0x180f,0x30202,0x1},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1202[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRLW,D__Nq,D__Ib,D__NONE,"psrlw",0x710f,0x24002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRLW,D__Udq,D__Ib,D__NONE,"psrlw",0x710f66,0x24003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1204[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRAW,D__Nq,D__Ib,D__NONE,"psraw",0x710f,0x44002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRAW,D__Udq,D__Ib,D__NONE,"psraw",0x710f66,0x44003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1206[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSLLW,D__Nq,D__Ib,D__NONE,"psllw",0x710f,0x64002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSLLW,D__Udq,D__Ib,D__NONE,"psllw",0x710f66,0x64003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG12[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_G1202,0x710f,0xa0202,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_G1204,0x710f,0xc0202,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_G1206,0x710f,0xe0202,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1302[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRLD,D__Nq,D__Ib,D__NONE,"psrld",0x720f,0x24002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRLD,D__Udq,D__Ib,D__NONE,"psrld",0x720f66,0x24003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1304[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRAD,D__Nq,D__Ib,D__NONE,"psrad",0x720f,0x44002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRAD,D__Udq,D__Ib,D__NONE,"psrad",0x720f66,0x44003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1306[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSLLD,D__Nq,D__Ib,D__NONE,"pslld",0x720f,0x64002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSLLD,D__Udq,D__Ib,D__NONE,"pslld",0x720f66,0x64003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG13[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRPSSE,D__Pq,D__Ib,D__NONE,(const char*)GroupSSE_G1302,0x720f,0xa0402,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRPSSE,D__Pq,D__Ib,D__NONE,(const char*)GroupSSE_G1304,0x720f,0xc0402,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRPSSE,D__Pq,D__Ib,D__NONE,(const char*)GroupSSE_G1306,0x720f,0xe0402,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1402[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRLQ,D__Nq,D__Ib,D__NONE,"psrlq",0x730f,0x24002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRLQ,D__Udq,D__Ib,D__NONE,"psrlq",0x730f66,0x24003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1403[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSRLDQ,D__Udq,D__Ib,D__NONE,"psrldq",0x730f66,0x34003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1406[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSLLQ,D__Nq,D__Ib,D__NONE,"psllq",0x730f,0x64002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSLLQ,D__Udq,D__Ib,D__NONE,"psllq",0x730f66,0x64003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G1407[] = {
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSLLDQ,D__Udq,D__Ib,D__NONE,"pslldq",0x730f66,0x74003,0x17},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG14[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_G1402,0x730f,0xa4002,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_G1403,0x730f,0xa4002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_G1406,0x730f,0xe4002,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_G1407,0x730f,0xe4002,0x0},
};
_DIS_OPCODE_T GroupG15[] = {
      {ATTR_MODRM,C_FXSAVE,D__M,D__NONE,D__NONE,"fxsave",0xae0f,0x402,0x1},
      {ATTR_MODRM,C_FXRSTOR,D__M,D__NONE,D__NONE,"fxrstor",0xae0f,0x10402,0x1},
      {ATTR_MODRM,C_LDMXCSR,D__Ed,D__NONE,D__NONE,"ldmxcsr",0xae0f,0x20402,0x1},
      {ATTR_MODRM,C_STMXCSR,D__Ed,D__NONE,D__NONE,"stmxcsr",0xae0f,0x30402,0x2},
      {ATTR_MODRM,C_XSAVE,D__M,D__NONE,D__NONE,"XSAVE",0xae0f,0x40402,0x2},
      {ATTR_MODRM,C_XRSTOR,D__M,D__NONE,D__NONE,"XRSTOR",0xae0f,0x50402,0x1},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_CLFLUSH,D__Eb,D__NONE,D__NONE,"clflush",0xae0f,0x70402,0x2},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_LFENCE,D__NONE,D__NONE,D__NONE,"lfence",0xae0f,0xd0402,0x0},
      {ATTR_MODRM,C_MFENCE,D__NONE,D__NONE,D__NONE,"mfence",0xae0f,0xe0402,0x0},
      {ATTR_MODRM,C_SFENCE,D__NONE,D__NONE,D__NONE,"sfence",0xae0f,0xf0402,0x0},
      {ATTR_MODRM|ATTR_JMP,C_CMPXCHG8B,D__Mxdq,D__NONE,D__NONE,"CMPXCHG8B",0xc70f,0x14002,0x3},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_G9VMX6[] = {
      {ATTR_MODRM,C_VMPTRLD,D__Mq,D__NONE,D__NONE,"VMPTRLD",0xc70f,0x64002,0x1},
      {ATTR_MODRM,C_VMCLEAR,D__Mq,D__NONE,D__NONE,"VMCLEAR",0xc70f66,0x64003,0x1},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_VMXON,D__Mq,D__NONE,D__NONE,"VMXON",0xc70ff3,0x64003,0x1},
};
_DIS_OPCODE_T GroupSSE_G9VMX7[] = {
      {ATTR_MODRM|ATTR_JMP,C_VMPTRST,D__Mq,D__NONE,D__NONE,"VMPTRST",0xc70f,0x74002,0x1},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupG9[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM|ATTR_JMP,C_CMPXCHG8B,D__Mxdq,D__NONE,D__NONE,"CMPXCHG8B",0xc70f,0x10202,0x3},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_G9VMX6,0xc70f,0x60202,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_G9VMX7,0xc70f,0x70202,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3800[] = {
      {ATTR_MODRM,C_PSHUFB,D__Pq,D__Qq,D__NONE,"pshufb",0x380f,0x1003,0x7},
      {ATTR_MODRM,C_PSHUFB,D__Vdq,D__Wdq,D__NONE,"pshufb",0x380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3801[] = {
      {ATTR_MODRM,C_PHADDW,D__Pq,D__Qq,D__NONE,"phaddw",0x1380f,0x1003,0x7},
      {ATTR_MODRM,C_PHADDW,D__Vdq,D__Wdq,D__NONE,"phaddw",0x1380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3802[] = {
      {ATTR_MODRM,C_PHADDD,D__Pq,D__Qq,D__NONE,"phaddd",0x2380f,0x1003,0x7},
      {ATTR_MODRM,C_PHADDD,D__Vdq,D__Wdq,D__NONE,"phaddd",0x2380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3803[] = {
      {ATTR_MODRM,C_PHADDSW,D__Pq,D__Qq,D__NONE,"phaddsw",0x3380f,0x1003,0x7},
      {ATTR_MODRM,C_PHADDSW,D__Vdq,D__Wdq,D__NONE,"phaddsw",0x3380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3804[] = {
      {ATTR_MODRM,C_PMADDUBSW,D__Pq,D__Qq,D__NONE,"pmaddubsw",0x4380f,0x1003,0x7},
      {ATTR_MODRM,C_PMADDUBSW,D__Vdq,D__Wdq,D__NONE,"pmaddubsw",0x4380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3805[] = {
      {ATTR_MODRM,C_PHSUBW,D__Pq,D__Qq,D__NONE,"phsubw",0x5380f,0x1003,0x7},
      {ATTR_MODRM,C_PHSUBW,D__Vdq,D__Wdq,D__NONE,"phsubw",0x5380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3806[] = {
      {ATTR_MODRM,C_PHSUBD,D__Pq,D__Qq,D__NONE,"phsubd",0x6380f,0x1003,0x7},
      {ATTR_MODRM,C_PHSUBD,D__Vdq,D__Wdq,D__NONE,"phsubd",0x6380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3807[] = {
      {ATTR_MODRM,C_PHSUBSW,D__Pq,D__Qq,D__NONE,"phsubsw",0x7380f,0x1003,0x7},
      {ATTR_MODRM,C_PHSUBSW,D__Vdq,D__Wdq,D__NONE,"phsubsw",0x7380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3808[] = {
      {ATTR_MODRM,C_PSIGNB,D__Pq,D__Qq,D__NONE,"psignb",0x8380f,0x1003,0x7},
      {ATTR_MODRM,C_PSIGNB,D__Vdq,D__Wdq,D__NONE,"psignb",0x8380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3809[] = {
      {ATTR_MODRM,C_PSIGNW,D__Pq,D__Qq,D__NONE,"psignw",0x9380f,0x1003,0x7},
      {ATTR_MODRM,C_PSIGNW,D__Vdq,D__Wdq,D__NONE,"psignw",0x9380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f380a[] = {
      {ATTR_MODRM,C_PSIGND,D__Pq,D__Qq,D__NONE,"psignd",0xa380f,0x1003,0x7},
      {ATTR_MODRM,C_PSIGND,D__Vdq,D__Wdq,D__NONE,"psignd",0xa380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f380b[] = {
      {ATTR_MODRM,C_PMULHRSW,D__Pq,D__Qq,D__NONE,"pmulhrsw",0xb380f,0x1003,0x7},
      {ATTR_MODRM,C_PMULHRSW,D__Vdq,D__Wdq,D__NONE,"pmulhrsw",0xb380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3810[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PBLENDVB,D__Vdq,D__Wdq,D__NONE,"pblendvb",0x10380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3814[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_BLENDVPS,D__Vdq,D__Wdq,D__NONE,"blendvps",0x14380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3815[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_BLENDVPD,D__Vdq,D__Wdq,D__NONE,"blendvpd",0x15380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3817[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PTEST,D__Vdq,D__Wdq,D__NONE,"ptest",0x17380f66,0x1004,0x5},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f381c[] = {
      {ATTR_MODRM,C_PABSB,D__Pq,D__Qq,D__NONE,"pabsb",0x1c380f,0x1003,0x6},
      {ATTR_MODRM,C_PABSB,D__Vdq,D__Wdq,D__NONE,"pabsb",0x1c380f66,0x1004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f381d[] = {
      {ATTR_MODRM,C_PABSW,D__Pq,D__Qq,D__NONE,"pabsw",0x1d380f,0x1003,0x6},
      {ATTR_MODRM,C_PABSW,D__Vdq,D__Wdq,D__NONE,"pabsw",0x1d380f66,0x1004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f381e[] = {
      {ATTR_MODRM,C_PABSD,D__Pq,D__Qq,D__NONE,"pabsd",0x1e380f,0x1003,0x6},
      {ATTR_MODRM,C_PABSD,D__Vdq,D__Wdq,D__NONE,"pabsd",0x1e380f66,0x1004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3820[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXBW,D__Vdq,D__Mq,D__NONE,"pmovsxbw",0x20380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXBW,D__Vdq,D__Udq,D__NONE,"pmovsxbw",0x20380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3821[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXBD,D__Vdq,D__Md,D__NONE,"pmovsxbd",0x21380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXBW,D__Vdq,D__Udq,D__NONE,"pmovsxbd",0x21380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3822[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXBQ,D__Vdq,D__Mw,D__NONE,"pmovsxbq",0x22380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXBQ,D__Vdq,D__Udq,D__NONE,"pmovsxbq",0x22380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3823[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXWD,D__Vdq,D__Mq,D__NONE,"pmovsxwd",0x23380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXWD,D__Vdq,D__Udq,D__NONE,"pmovsxwd",0x23380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3824[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXWQ,D__Vdq,D__Md,D__NONE,"pmovsxwq",0x24380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXBQ,D__Vdq,D__Udq,D__NONE,"pmovsxwq",0x24380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3825[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXDQ,D__Vdq,D__Mq,D__NONE,"pmovsxdq",0x25380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVSXDQ,D__Vdq,D__Udq,D__NONE,"pmovsxdq",0x25380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3828[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMULDQ,D__Vdq,D__Wdq,D__NONE,"pmuldq",0x28380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3829[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PCMPEQQ,D__Vdq,D__Wdq,D__NONE,"pcmpeqq",0x29380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f382a[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MOVNTDQA,D__Vdq,D__Mdq,D__NONE,"movntdqa",0x2a380f66,0x1004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f382b[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PACKUSDW,D__Vdq,D__Wdq,D__NONE,"packusdw",0x2b380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3830[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXBW,D__Vdq,D__Mq,D__NONE,"pmovzxbw",0x30380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXBW,D__Vdq,D__Udq,D__NONE,"pmovzxbw",0x30380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3831[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXBD,D__Vdq,D__Md,D__NONE,"pmovzxbd",0x31380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXBW,D__Vdq,D__Udq,D__NONE,"pmovzxbd",0x31380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3832[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXBQ,D__Vdq,D__Mw,D__NONE,"pmovzxbq",0x32380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXBQ,D__Vdq,D__Udq,D__NONE,"pmovzxbq",0x32380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3833[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXWD,D__Vdq,D__Mq,D__NONE,"pmovzxwd",0x33380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXWD,D__Vdq,D__Udq,D__NONE,"pmovzxwd",0x33380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3834[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXWQ,D__Vdq,D__Md,D__NONE,"pmovzxwq",0x34380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXBQ,D__Vdq,D__Udq,D__NONE,"pmovzxwq",0x34380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3835[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXDQ,D__Vdq,D__Mq,D__NONE,"pmovzxdq",0x35380f66,0x12004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMOVZXDQ,D__Vdq,D__Udq,D__NONE,"pmovzxdq",0x35380f66,0x52004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3837[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PCMPGTQ,D__Vdq,D__Wdq,D__NONE,"pcmpgtq",0x37380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3838[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMINSB,D__Vdq,D__Wdq,D__NONE,"pminsb",0x38380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3839[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMINSD,D__Vdq,D__Wdq,D__NONE,"pminsd",0x39380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f383a[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMINUW,D__Vdq,D__Wdq,D__NONE,"pminuw",0x3a380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f383b[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMINUD,D__Vdq,D__Wdq,D__NONE,"pminud",0x3b380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f383c[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMAXSB,D__Vdq,D__Wdq,D__NONE,"pmaxsb",0x3c380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f383d[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMAXSD,D__Vdq,D__Wdq,D__NONE,"pmaxsd",0x3d380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f383e[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMAXUW,D__Vdq,D__Wdq,D__NONE,"pmaxuw",0x3e380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f383f[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMAXUD,D__Vdq,D__Wdq,D__NONE,"pmaxud",0x3f380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3840[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PMULLD,D__Vdq,D__Wdq,D__NONE,"pmulld",0x40380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3841[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PHMINPOSUW,D__Vdq,D__Wdq,D__NONE,"phminposuw",0x41380f66,0x1004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3880[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_INVEPT,D__Gy,D__Mdq,D__NONE,"invept",0x80380f66,0x12004,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3881[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_INVVPID,D__Gy,D__Mdq,D__NONE,"invvpid",0x81380f66,0x12004,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f38db[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_AESIMC,D__Vdq,D__Wdq,D__NONE,"aesimc",0xdb380f66,0x1004,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f38dc[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_AESENC,D__Vdq,D__Wdq,D__NONE,"aesenc",0xdc380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f38dd[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_AESENCLAST,D__Vdq,D__Wdq,D__NONE,"aesenclast",0xdd380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f38de[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_AESDEC,D__Vdq,D__Wdq,D__NONE,"aesdec",0xde380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f38df[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_AESDECLAST,D__Vdq,D__Wdq,D__NONE,"aesdeclast",0xdf380f66,0x1004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f38f0[] = {
      {ATTR_MODRM,C_MOVBE,D__Gy,D__My,D__NONE,"movbe",0xf0380f,0x2003,0x6},
      {ATTR_MODRM,C_MOVBE,D__Gw,D__Mw,D__NONE,"movbe",0xf0380f,0x12003,0x6},
      {ATTR_MODRM,C_CRC32,D__Gy,D__Eb,D__NONE,"crc32",0xf0380ff2,0x22004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_CRC32,D__Gy,D__Eb,D__NONE,"crc32",0xf0380ff2,0x62004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f38f1[] = {
      {ATTR_MODRM,C_MOVBE,D__My,D__Gy,D__NONE,"movbe",0xf1380f,0x2003,0x6},
      {ATTR_MODRM,C_MOVBE,D__Mw,D__Gw,D__NONE,"movbe",0xf1380f,0x12003,0x6},
      {ATTR_MODRM,C_CRC32,D__Gy,D__Ey,D__NONE,"crc32",0xf1380ff2,0x22004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_CRC32,D__Gy,D__Ev,D__NONE,"crc32",0xf1380ff2,0x62004,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T OpTable3Byte0f38[] = {
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3800,0x380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3801,0x1380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3802,0x2380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3803,0x3380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3804,0x4380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3805,0x5380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3806,0x6380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3807,0x7380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3808,0x8380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f3809,0x9380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f380a,0xa380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f380b,0xb380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3810,0x10380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3814,0x14380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3815,0x15380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3817,0x17380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f381c,0x1c380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f381d,0x1d380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0f381e,0x1e380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3820,0x20380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3821,0x21380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3822,0x22380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3823,0x23380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3824,0x24380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3825,0x25380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3828,0x28380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3829,0x29380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f382a,0x2a380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f382b,0x2b380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3830,0x30380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3831,0x31380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3832,0x32380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3833,0x33380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3834,0x34380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3835,0x35380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3837,0x37380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3838,0x38380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3839,0x39380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f383a,0x3a380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f383b,0x3b380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f383c,0x3c380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f383d,0x3d380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f383e,0x3e380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f383f,0x3f380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3840,0x40380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3841,0x41380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3880,0x80380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3881,0x81380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f38db,0xdb380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f38dc,0xdc380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f38dd,0xdd380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f38de,0xde380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f38df,0xdf380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f38f0,0xf0380f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f38f1,0xf1380f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a08[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ROUNDPS,D__Vdq,D__Wdq,D__Ib,"roundps",0x83a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a09[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ROUNDPD,D__Vdq,D__Wdq,D__Ib,"roundpd",0x93a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a0a[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ROUNDSS,D__Vdq,D__Wdq,D__Ib,"roundss",0xa3a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a0b[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_ROUNDSD,D__Vdq,D__Wdq,D__Ib,"roundsd",0xb3a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a0c[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_BLENDPS,D__Vdq,D__Wdq,D__Ib,"blendps",0xc3a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a0d[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_BLENDPD,D__Vdq,D__Wdq,D__Ib,"blendpd",0xd3a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a0e[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PBLENDW,D__Vdq,D__Wdq,D__Ib,"pblendw",0xe3a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a0f[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PALIGNR,D__Pq,D__Qq,D__Ib,"palignr",0xf3a0f,0x1003,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PALIGNR,D__Vdq,D__Wdq,D__Ib,"palignr",0xf3a0f66,0x1004,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a14[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PEXTRB,D__Mb,D__Vdq,D__Ib,"pextrb",0x143a0f66,0x12004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_SP,C_PEXTRB,D__Rd,D__Vdq,D__Ib,"pextrb",0x143a0f66,0x52004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a15[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PEXTRW,D__Mw,D__Vdq,D__Ib,"pextrw",0x153a0f66,0x12004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM|ATTR_SP,C_PEXTRW,D__Rd,D__Vdq,D__Ib,"pextrw",0x153a0f66,0x52004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a16[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PEXTRD,D__Ey,D__Vdq,D__Ib,"pextrd",0x163a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a17[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_EXTRACTPS,D__Ed,D__Vdq,D__Ib,"extractps",0x173a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a20[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PINSRB,D__Vdq,D__Mb,D__Ib,"pinsrb",0x203a0f66,0x11004,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PINSRB,D__Vdq,D__Rd,D__Ib,"pinsrb",0x203a0f66,0x51004,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a21[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_INSERTPS,D__Vdq,D__Md,D__Ib,"insertps",0x213a0f66,0x12004,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_INSERTPS,D__Vdq,D__Udq,D__Ib,"insertps",0x213a0f66,0x52004,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a22[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PINSRD,D__Vdq,D__Ey,D__Ib,"pinsrd",0x223a0f66,0x1004,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a40[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_DPPS,D__Vdq,D__Wdq,D__Ib,"dpps",0x403a0f66,0x1004,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a41[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_DPPD,D__Vdq,D__Wdq,D__Ib,"dppd",0x413a0f66,0x1004,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a42[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_MPSADBW,D__Vdq,D__Wdq,D__Ib,"mpsadbw",0x423a0f66,0x1004,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a44[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PCLMULQDQ,D__Vdq,D__Wdq,D__Ib,"pclmulqdq",0x443a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a60[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PCMPESTRM,D__Vdq,D__Wdq,D__Ib,"pcmpestrm",0x603a0f66,0x1004,0x15},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a61[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PCMPESTRI,D__Vdq,D__Wdq,D__Ib,"pcmpestri",0x613a0f66,0x1004,0x15},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a62[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PCMPISTRM,D__Vdq,D__Wdq,D__Ib,"pcmpistrm",0x623a0f66,0x1004,0x15},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3a63[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PCMPISTRI,D__Vdq,D__Wdq,D__Ib,"pcmpistri",0x633a0f66,0x1004,0x15},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f3adf[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_AESKEYGENASSIST,D__Vdq,D__Wdq,D__Ib,"aeskeygenassist",0xdf3a0f66,0x1004,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T OpTable3Byte0f3a[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a08,0x83a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a09,0x93a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a0a,0xa3a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a0b,0xb3a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a0c,0xc3a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a0d,0xd3a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a0e,0xe3a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a0f,0xf3a0f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a14,0x143a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a15,0x153a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a16,0x163a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a17,0x173a0f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a20,0x203a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a21,0x213a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a22,0x223a0f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a40,0x403a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a41,0x413a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a42,0x423a0f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a44,0x443a0f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a60,0x603a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a61,0x613a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a62,0x623a0f,0x3,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3a63,0x633a0f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f3adf,0xdf3a0f,0x3,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f70[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSHUFW,D__Pq,D__Qq,D__Ib,"pshufw",0x700f,0x1002,0x16},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSHUFD,D__Vdq,D__Wdq,D__Ib,"pshufd",0x700f66,0x1003,0x16},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSHUFLW,D__Vdq,D__Wdq,D__Ib,"pshuflw",0x700ff2,0x1003,0x16},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PSHUFHW,D__Vdq,D__Wdq,D__Ib,"pshufhw",0x700ff3,0x1003,0x16},
};
_DIS_OPCODE_T GroupSSE_0f74[] = {
      {ATTR_MODRM,C_PCMPEQB,D__Pq,D__Qq,D__NONE,"pcmpeqb",0x740f,0x1002,0x7},
      {ATTR_MODRM,C_PCMPEQB,D__Vdq,D__Wdq,D__NONE,"pcmpeqb",0x740f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f75[] = {
      {ATTR_MODRM,C_PCMPEQW,D__Pq,D__Qq,D__NONE,"pcmpeqw",0x750f,0x1002,0x7},
      {ATTR_MODRM,C_PCMPEQW,D__Vdq,D__Wdq,D__NONE,"pcmpeqw",0x750f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f76[] = {
      {ATTR_MODRM,C_PCMPEQD,D__Pq,D__Qq,D__NONE,"pcmpeqd",0x760f,0x1002,0x7},
      {ATTR_MODRM,C_PCMPEQD,D__Vdq,D__Wdq,D__NONE,"pcmpeqd",0x760f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f78[] = {
      {ATTR_MODRM|ATTR_JMP,C_VMREAD,D__Ey,D__Gy,D__NONE,"VMREAD",0x780f,0x1002,0x6},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_EXTRQ,D__Vdq,D__Ib,D_zIb,"extrq",0x780f66,0x1003,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f79[] = {
      {ATTR_MODRM|ATTR_JMP,C_VMWRITE,D__Gy,D__Ey,D__NONE,"VMWRITE",0x790f,0x1002,0x5},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f7c[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_HADDPD,D__Vdq,D__Wdq,D__NONE,"haddpd",0x7c0f66,0x1003,0x7},
      {ATTR_MODRM,C_HADDPS,D__Vps,D__Wps,D__NONE,"haddps",0x7c0ff2,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f7d[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_HSUBPD,D__Vdq,D__Wdq,D__NONE,"hsubpd",0x7d0f66,0x1003,0x7},
      {ATTR_MODRM,C_HSUBPS,D__Vps,D__Wps,D__NONE,"hsubps",0x7d0ff2,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f7e[] = {
      {ATTR_MODRM,C_MOVD,D__Ey,D__Pd,D__NONE,"movd",0x7e0f,0x1002,0x6},
      {ATTR_MODRM,C_MOVD,D__Ey,D__Vdq,D__NONE,"movd",0x7e0f66,0x1003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MOVQ,D__Vq,D__Wq,D__NONE,"movq",0x7e0ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f7f[] = {
      {ATTR_MODRM,C_MOVQ,D__Qq,D__Pq,D__NONE,"movq",0x7f0f,0x1002,0x6},
      {ATTR_MODRM,C_MOVDQA,D__Wdq,D__Vdq,D__NONE,"movdqa",0x7f0f66,0x1003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MOVDQU,D__Wdq,D__Vdq,D__NONE,"movdqu",0x7f0ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f60[] = {
      {ATTR_MODRM,C_PUNPCKLBW,D__Pq,D__Qq,D__NONE,"punpcklbw",0x600f,0x1002,0x7},
      {ATTR_MODRM,C_PUNPCKLBW,D__Vdq,D__Wdq,D__NONE,"punpcklbw",0x600f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f61[] = {
      {ATTR_MODRM,C_PUNPCKLWD,D__Pq,D__Qq,D__NONE,"punpcklwd",0x610f,0x1002,0x7},
      {ATTR_MODRM,C_PUNPCKLWD,D__Vdq,D__Wdq,D__NONE,"punpcklwd",0x610f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f62[] = {
      {ATTR_MODRM,C_PUNPCKLDQ,D__Pq,D__Qq,D__NONE,"punpckldq",0x620f,0x1002,0x7},
      {ATTR_MODRM,C_PUNPCKLDQ,D__Vdq,D__Wdq,D__NONE,"punpckldq",0x620f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f63[] = {
      {ATTR_MODRM,C_PACKSSWB,D__Pq,D__Qq,D__NONE,"packsswb",0x630f,0x1002,0x7},
      {ATTR_MODRM,C_PACKSSWB,D__Vdq,D__Wdq,D__NONE,"packsswb",0x630f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f64[] = {
      {ATTR_MODRM,C_PCMPGTB,D__Pq,D__Qq,D__NONE,"pcmpgtb",0x640f,0x1002,0x7},
      {ATTR_MODRM,C_PCMPGTB,D__Vdq,D__Wdq,D__NONE,"pcmpgtb",0x640f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f65[] = {
      {ATTR_MODRM,C_PCMPGTW,D__Pq,D__Qq,D__NONE,"pcmpgtw",0x650f,0x1002,0x7},
      {ATTR_MODRM,C_PCMPGTW,D__Vdq,D__Wdq,D__NONE,"pcmpgtw",0x650f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f66[] = {
      {ATTR_MODRM,C_PCMPGTD,D__Pq,D__Qq,D__NONE,"pcmpgtd",0x660f,0x1002,0x7},
      {ATTR_MODRM,C_PCMPGTD,D__Vdq,D__Wdq,D__NONE,"pcmpgtd",0x660f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f67[] = {
      {ATTR_MODRM,C_PACKUSWB,D__Pq,D__Qq,D__NONE,"packuswb",0x670f,0x1002,0x7},
      {ATTR_MODRM,C_PACKUSWB,D__Vdq,D__Wdq,D__NONE,"packuswb",0x670f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f68[] = {
      {ATTR_MODRM,C_PUNPCKHBW,D__Pq,D__Qq,D__NONE,"punpckhbw",0x680f,0x1002,0x7},
      {ATTR_MODRM,C_PUNPCKHBW,D__Vdq,D__Wdq,D__NONE,"punpckhbw",0x680f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f69[] = {
      {ATTR_MODRM,C_PUNPCKHWD,D__Pq,D__Qq,D__NONE,"punpckhwd",0x690f,0x1002,0x7},
      {ATTR_MODRM,C_PUNPCKHWD,D__Vdq,D__Wdq,D__NONE,"punpckhwd",0x690f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f6a[] = {
      {ATTR_MODRM,C_PUNPCKHDQ,D__Pq,D__Qq,D__NONE,"punpckhdq",0x6a0f,0x1002,0x7},
      {ATTR_MODRM,C_PUNPCKHDQ,D__Vdq,D__Wdq,D__NONE,"punpckhdq",0x6a0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f6b[] = {
      {ATTR_MODRM,C_PACKSSDW,D__Pq,D__Qq,D__NONE,"packssdw",0x6b0f,0x1002,0x7},
      {ATTR_MODRM,C_PACKSSDW,D__Vdq,D__Wdq,D__NONE,"packssdw",0x6b0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f6c[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PUNPCKLQDQ,D__Vdq,D__Wdq,D__NONE,"punpcklqdq",0x6c0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f6d[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_PUNPCKHQDQ,D__Vdq,D__Wdq,D__NONE,"punpckhqdq",0x6d0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f6e[] = {
      {ATTR_MODRM,C_MOVD,D__Pq,D__Ey,D__NONE,"movd",0x6e0f,0x1002,0x6},
      {ATTR_MODRM,C_MOVD,D__Vdq,D__Ey,D__NONE,"movd",0x6e0f66,0x1003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f6f[] = {
      {ATTR_MODRM,C_MOVQ,D__Pq,D__Qq,D__NONE,"movq",0x6f0f,0x1002,0x6},
      {ATTR_MODRM,C_MOVDQA,D__Vdq,D__Wdq,D__NONE,"movdqa",0x6f0f66,0x1003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MOVDQU,D__Vdq,D__Wdq,D__NONE,"movdqu",0x6f0ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f50[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MOVMSKPS,D__Gy,D__Ups,D__NONE,"movmskps",0x500f,0x42002,0x6},
      {ATTR_MODRM,C_MOVMSKPD,D__Gy,D__Upd,D__NONE,"movmskpd",0x500f66,0x52003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f51[] = {
      {ATTR_MODRM,C_SQRTPS,D__Vps,D__Wps,D__NONE,"sqrtps",0x510f,0x1002,0x6},
      {ATTR_MODRM,C_SQRTPD,D__Vpd,D__Wpd,D__NONE,"sqrtpd",0x510f66,0x1003,0x6},
      {ATTR_MODRM,C_SQRTSD,D__Vsd,D__Wsd,D__NONE,"sqrtsd",0x510ff2,0x1003,0x6},
      {ATTR_MODRM,C_SQRTSS,D__Vss,D__Wss,D__NONE,"sqrtss",0x510ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f52[] = {
      {ATTR_MODRM,C_RSQRTPS,D__Vps,D__Wps,D__NONE,"rsqrtps",0x520f,0x1002,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_RSQRTSS,D__Vss,D__Wss,D__NONE,"rsqrtss",0x520ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f53[] = {
      {ATTR_MODRM,C_RCPPS,D__Vps,D__Wps,D__NONE,"rcpps",0x530f,0x1002,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_RCPSS,D__Vss,D__Wss,D__NONE,"rcpss",0x530ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f54[] = {
      {ATTR_MODRM,C_ANDPS,D__Vps,D__Wps,D__NONE,"andps",0x540f,0x1002,0x7},
      {ATTR_MODRM,C_ANDPD,D__Vpd,D__Wpd,D__NONE,"andpd",0x540f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f55[] = {
      {ATTR_MODRM,C_ANDNPS,D__Vps,D__Wps,D__NONE,"andnps",0x550f,0x1002,0x7},
      {ATTR_MODRM,C_ANDNPD,D__Vpd,D__Wpd,D__NONE,"andnpd",0x550f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f56[] = {
      {ATTR_MODRM,C_ORPS,D__Vps,D__Wps,D__NONE,"orps",0x560f,0x1002,0x7},
      {ATTR_MODRM,C_ORPD,D__Vpd,D__Wpd,D__NONE,"orpd",0x560f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f57[] = {
      {ATTR_MODRM,C_XORPS,D__Vps,D__Wps,D__NONE,"xorps",0x570f,0x1002,0x7},
      {ATTR_MODRM,C_XORPD,D__Vpd,D__Wpd,D__NONE,"xorpd",0x570f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f58[] = {
      {ATTR_MODRM,C_ADDPS,D_dVps,D_rWps,D__NONE,"addps",0x580f,0x1002,0x7},
      {ATTR_MODRM,C_ADDPD,D_dVpd,D_rWpd,D__NONE,"addpd",0x580f66,0x1003,0x7},
      {ATTR_MODRM,C_ADDSD,D_dVsd,D_rWsd,D__NONE,"addsd",0x580ff2,0x1003,0x7},
      {ATTR_MODRM,C_ADDSS,D_dVss,D_rWss,D__NONE,"addss",0x580ff3,0x1003,0x7},
};
_DIS_OPCODE_T GroupSSE_0f59[] = {
      {ATTR_MODRM,C_MULPS,D_dVps,D_rWps,D__NONE,"mulps",0x590f,0x1002,0x7},
      {ATTR_MODRM,C_MULPD,D_dVpd,D_rWpd,D__NONE,"mulpd",0x590f66,0x1003,0x7},
      {ATTR_MODRM,C_MULSD,D_dVsd,D_rWsd,D__NONE,"mulsd",0x590ff2,0x1003,0x7},
      {ATTR_MODRM,C_MULSS,D_dVss,D_rWss,D__NONE,"mulss",0x590ff3,0x1003,0x7},
};
_DIS_OPCODE_T GroupSSE_0f5a[] = {
      {ATTR_MODRM,C_CVTPS2PD,D_wVpd,D_rWps,D__NONE,"cvtps2pd",0x5a0f,0x1002,0x6},
      {ATTR_MODRM,C_CVTPD2PS,D_wVps,D_rWpd,D__NONE,"cvtpd2ps",0x5a0f66,0x1003,0x6},
      {ATTR_MODRM,C_CVTSD2SS,D_wVsd,D_rWsd,D__NONE,"cvtsd2ss",0x5a0ff2,0x1003,0x6},
      {ATTR_MODRM,C_CVTSS2SD,D_wVss,D_rWss,D__NONE,"cvtss2sd",0x5a0ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f5b[] = {
      {ATTR_MODRM,C_CVTDQ2PS,D_wVps,D_rWdq,D__NONE,"cvtdq2ps",0x5b0f,0x1002,0x6},
      {ATTR_MODRM,C_CVTPS2DQ,D_wVdq,D_rWps,D__NONE,"cvtps2dq",0x5b0f66,0x1003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_CVTTPS2DQ,D_wVss,D_rWss,D__NONE,"cvttps2dq",0x5b0ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f5c[] = {
      {ATTR_MODRM,C_SUBPS,D_dVps,D_rWps,D__NONE,"subps",0x5c0f,0x1002,0x7},
      {ATTR_MODRM,C_SUBPD,D_dVpd,D_rWpd,D__NONE,"subpd",0x5c0f66,0x1003,0x7},
      {ATTR_MODRM,C_SUBSD,D_dVsd,D_rWsd,D__NONE,"subsd",0x5c0ff2,0x1003,0x7},
      {ATTR_MODRM,C_SUBSS,D_dVss,D_rWss,D__NONE,"subss",0x5c0ff3,0x1003,0x7},
};
_DIS_OPCODE_T GroupSSE_0f5d[] = {
      {ATTR_MODRM,C_MINPS,D_dVps,D_rWps,D__NONE,"minps",0x5d0f,0x1002,0x7},
      {ATTR_MODRM,C_MINPD,D_dVpd,D_rWpd,D__NONE,"minpd",0x5d0f66,0x1003,0x7},
      {ATTR_MODRM,C_MINSD,D_dVsd,D_rWsd,D__NONE,"minsd",0x5d0ff2,0x1003,0x7},
      {ATTR_MODRM,C_MINSS,D_dVss,D_rWss,D__NONE,"minss",0x5d0ff3,0x1003,0x7},
};
_DIS_OPCODE_T GroupSSE_0f5e[] = {
      {ATTR_MODRM,C_DIVPS,D__Vps,D__Wps,D__NONE,"divps",0x5e0f,0x1002,0x7},
      {ATTR_MODRM,C_DIVPD,D__Vpd,D__Wpd,D__NONE,"divpd",0x5e0f66,0x1003,0x7},
      {ATTR_MODRM,C_DIVSD,D__Vsd,D__Wsd,D__NONE,"divsd",0x5e0ff2,0x1003,0x7},
      {ATTR_MODRM,C_DIVSS,D__Vss,D__Wss,D__NONE,"divss",0x5e0ff3,0x1003,0x7},
};
_DIS_OPCODE_T GroupSSE_0f5f[] = {
      {ATTR_MODRM,C_MAXPS,D__Vps,D__Wps,D__NONE,"maxps",0x5f0f,0x1002,0x7},
      {ATTR_MODRM,C_MAXPD,D__Vpd,D__Wpd,D__NONE,"maxpd",0x5f0f66,0x1003,0x7},
      {ATTR_MODRM,C_MAXSD,D__Vsd,D__Wsd,D__NONE,"maxsd",0x5f0ff2,0x1003,0x7},
      {ATTR_MODRM,C_MAXSS,D__Vss,D__Wss,D__NONE,"maxss",0x5f0ff3,0x1003,0x7},
};
_DIS_OPCODE_T GroupSSE_0f10[] = {
      {ATTR_MODRM,C_MOVUPS,D__Vps,D__Wps,D__NONE,"movups",0x100f,0x1002,0x6},
      {ATTR_MODRM,C_MOVUPD,D__Vpd,D__Wpd,D__NONE,"movupd",0x100f66,0x1003,0x6},
      {ATTR_MODRM,C_MOVSD,D__Vsd,D__Wsd,D__NONE,"movsd",0x100ff2,0x1003,0x6},
      {ATTR_MODRM,C_MOVSS,D__Vss,D__Wss,D__NONE,"movss",0x100ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f11[] = {
      {ATTR_MODRM,C_MOVUPS,D__Wps,D__Vps,D__NONE,"movups",0x110f,0x1002,0x6},
      {ATTR_MODRM,C_MOVUPD,D__Wpd,D__Vpd,D__NONE,"movupd",0x110f66,0x1003,0x6},
      {ATTR_MODRM,C_MOVSD,D__Wsd,D__Vsd,D__NONE,"movsd",0x110ff2,0x1003,0x6},
      {ATTR_MODRM,C_MOVSS,D__Wss,D__Vss,D__NONE,"movss",0x110ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f12[] = {
      {ATTR_MODRM,C_MOVLPS,D__Vq,D__Mq,D__NONE,"movlps",0x120f,0x2002,0x7},
      {ATTR_MODRM,C_MOVLPD,D__Vq,D__Mq,D__NONE,"movlpd",0x120f66,0x12003,0x7},
      {ATTR_MODRM,C_MOVDDUP,D__Vq,D__Wq,D__NONE,"movddup",0x120ff2,0x22003,0x6},
      {ATTR_MODRM,C_MOVSLDUP,D__Vq,D__Wq,D__NONE,"movsldup",0x120ff3,0x32003,0x6},
      {ATTR_MODRM,C_MOVHLPS,D__Vq,D__Uq,D__NONE,"movhlps",0x120f,0x42002,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MOVDDUP,D__Vq,D__Wq,D__NONE,"movddup",0x120ff2,0x62003,0x6},
      {ATTR_MODRM,C_MOVSLDUP,D__Vq,D__Wq,D__NONE,"movsldup",0x120ff3,0x72003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f13[] = {
      {ATTR_MODRM,C_MOVLPS,D__Mq,D__Vq,D__NONE,"movlps",0x130f,0x2002,0x6},
      {ATTR_MODRM,C_MOVLPD,D__Mq,D__Vq,D__NONE,"movlpd",0x130f66,0x12003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f14[] = {
      {ATTR_MODRM,C_UNPCKLPS,D__Vps,D__Wq,D__NONE,"unpcklps",0x140f,0x1002,0x7},
      {ATTR_MODRM,C_UNPCKLPD,D__Vpd,D__Wq,D__NONE,"unpcklpd",0x140f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f15[] = {
      {ATTR_MODRM,C_UNPCKHPS,D__Vps,D__Wq,D__NONE,"unpckhps",0x150f,0x1002,0x7},
      {ATTR_MODRM,C_UNPCKHPD,D__Vpd,D__Wq,D__NONE,"unpckhpd",0x150f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__Vq,D__Mq,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__Vq,D__Mq,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f16[] = {
      {ATTR_MODRM,C_MOVHPS,D__Vq,D__Mq,D__NONE,"movhps",0x160f,0x2002,0x7},
      {ATTR_MODRM,C_MOVHPD,D__Vpd,D__Mq,D__NONE,"movhpd",0x160f66,0x12003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MOVSHDUP,D__Vq,D__Wq,D__NONE,"movshdup",0x160ff3,0x32003,0x6},
      {ATTR_MODRM,C_MOVLHPS,D__Vq,D__Uq,D__NONE,"movlhps",0x160f,0x42002,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MOVSHDUP,D__Vq,D__Wq,D__NONE,"movshdup",0x160ff3,0x72003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f17[] = {
      {ATTR_MODRM,C_MOVHPS,D__Mq,D__Vq,D__NONE,"movhps",0x170f,0x1002,0x6},
      {ATTR_MODRM,C_MOVHPD,D__Mq,D__Vq,D__NONE,"movhpd",0x170f66,0x1003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f28[] = {
      {ATTR_MODRM,C_MOVAPS,D__Vps,D__Wps,D__NONE,"movaps",0x280f,0x1002,0x6},
      {ATTR_MODRM,C_MOVAPD,D__Vpd,D__Wpd,D__NONE,"movapd",0x280f66,0x1003,0x6},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f29[] = {
      {ATTR_MODRM,C_MOVAPS,D__Wps,D__Vps,D__NONE,"movaps",0x290f,0x1002,0x6},
      {ATTR_MODRM,C_MOVAPD,D__Wpd,D__Vpd,D__NONE,"movapd",0x290f66,0x1003,0x6},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f2a[] = {
      {ATTR_MODRM,C_CVTPI2PS,D__Vps,D__Qpi,D__NONE,"cvtpi2ps",0x2a0f,0x1002,0x6},
      {ATTR_MODRM,C_CVTPI2PD,D__Vpd,D__Qpi,D__NONE,"cvtpi2pd",0x2a0f66,0x1003,0x6},
      {ATTR_MODRM,C_CVTSI2SD,D__Vsd,D__Ey,D__NONE,"cvtsi2sd",0x2a0ff2,0x1003,0x6},
      {ATTR_MODRM,C_CVTSI2SS,D__Vss,D__Ey,D__NONE,"cvtsi2ss",0x2a0ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f2b[] = {
      {ATTR_MODRM,C_MOVNTPS,D__Mps,D__Vps,D__NONE,"movntps",0x2b0f,0x1002,0x6},
      {ATTR_MODRM,C_MOVNTPD,D__Mpd,D__Vpd,D__NONE,"movntpd",0x2b0f66,0x11003,0x6},
      {ATTR_MODRM,C_MOVNTSD,D__Mq,D__Vsd,D__NONE,"movntsd",0x2b0ff2,0x21003,0x6},
      {ATTR_MODRM,C_MOVNTSS,D__Md,D__Vss,D__NONE,"movntss",0x2b0ff3,0x31003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f2c[] = {
      {ATTR_MODRM,C_CVTTPS2PI,D__Ppi,D__Wps,D__NONE,"cvttps2pi",0x2c0f,0x1002,0x6},
      {ATTR_MODRM,C_CVTTPD2PI,D__Ppi,D__Wpd,D__NONE,"cvttpd2pi",0x2c0f66,0x1003,0x6},
      {ATTR_MODRM,C_CVTTSD2SI,D__Gy,D__Wsd,D__NONE,"cvttsd2si",0x2c0ff2,0x1003,0x6},
      {ATTR_MODRM,C_CVTTSS2SI,D__Gy,D__Wss,D__NONE,"cvttss2si",0x2c0ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f2d[] = {
      {ATTR_MODRM,C_CVTPS2PI,D__Ppi,D__Wps,D__NONE,"cvtps2pi",0x2d0f,0x1002,0x6},
      {ATTR_MODRM,C_CVTPD2PI,D__Ppi,D__Wpd,D__NONE,"cvtpd2pi",0x2d0f66,0x1003,0x6},
      {ATTR_MODRM,C_CVTSD2SI,D__Gy,D__Wsd,D__NONE,"cvtsd2si",0x2d0ff2,0x1003,0x6},
      {ATTR_MODRM,C_CVTSS2SI,D__Gy,D__Wss,D__NONE,"cvtss2si",0x2d0ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0f2e[] = {
      {ATTR_MODRM,C_UCOMISS,D__Vss,D__Wss,D__NONE,"ucomiss",0x2e0f,0x1002,0x5},
      {ATTR_MODRM,C_UCOMISD,D__Vsd,D__Wsd,D__NONE,"ucomisd",0x2e0f66,0x1003,0x5},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0f2f[] = {
      {ATTR_MODRM,C_COMISS,D__Vss,D__Wss,D__NONE,"comiss",0x2f0f,0x1002,0x5},
      {ATTR_MODRM,C_COMISD,D__Vsd,D__Wsd,D__NONE,"comisd",0x2f0f66,0x1003,0x5},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fd0[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_ADDSUBPD,D_dVpd,D_rWpd,D__NONE,"addsubpd",0xd00f66,0x1003,0x7},
      {ATTR_MODRM,C_ADDSUBPS,D_dVps,D_rWps,D__NONE,"addsubps",0xd00ff2,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fd1[] = {
      {ATTR_MODRM,C_PSRLW,D__Pq,D__Qq,D__NONE,"psrlw",0xd10f,0x1002,0x7},
      {ATTR_MODRM,C_PSRLW,D__Vdq,D__Wdq,D__NONE,"psrlw",0xd10f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fd2[] = {
      {ATTR_MODRM,C_PSRLD,D__Pq,D__Qq,D__NONE,"psrld",0xd20f,0x1002,0x7},
      {ATTR_MODRM,C_PSRLD,D__Vdq,D__Wdq,D__NONE,"psrld",0xd20f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fd3[] = {
      {ATTR_MODRM,C_PSRLQ,D__Pq,D__Qq,D__NONE,"psrlq",0xd30f,0x1002,0x7},
      {ATTR_MODRM,C_PSRLQ,D__Vdq,D__Wdq,D__NONE,"psrlq",0xd30f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fd4[] = {
      {ATTR_MODRM,C_PADDQ,D__Pq,D__Qq,D__NONE,"paddq",0xd40f,0x1002,0x7},
      {ATTR_MODRM,C_PADDQ,D__Vdq,D__Wdq,D__NONE,"paddq",0xd40f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fd5[] = {
      {ATTR_MODRM,C_PMULLW,D__Pq,D__Qq,D__NONE,"pmullw",0xd50f,0x1002,0x7},
      {ATTR_MODRM,C_PMULLW,D__Vdq,D__Wdq,D__NONE,"pmullw",0xd50f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fd6[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_MOVQ,D__Wq,D__Vq,D__NONE,"movq",0xd60f66,0x52003,0x6},
      {ATTR_MODRM,C_MOVDQ2Q,D__Pq,D__Uq,D__NONE,"movdq2q",0xd60ff2,0x62003,0x6},
      {ATTR_MODRM,C_MOVQ2DQ,D__Vdq,D__Nq,D__NONE,"movq2dq",0xd60ff3,0x72003,0x6},
};
_DIS_OPCODE_T GroupSSE_0fd7[] = {
      {ATTR_MODRM,C_PMOVMSKB,D__Gy,D__Nq,D__NONE,"pmovmskb",0xd70f,0x42002,0x6},
      {ATTR_MODRM,C_PMOVMSKB,D__Gy,D__Udq,D__NONE,"pmovmskb",0xd70f66,0x52003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fd8[] = {
      {ATTR_MODRM,C_PSUBUSB,D__Pq,D__Qq,D__NONE,"psubusb",0xd80f,0x1002,0x7},
      {ATTR_MODRM,C_PSUBUSB,D__Vdq,D__Wdq,D__NONE,"psubusb",0xd80f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fd9[] = {
      {ATTR_MODRM,C_PSUBUSW,D__Pq,D__Qq,D__NONE,"psubusw",0xd90f,0x1002,0x7},
      {ATTR_MODRM,C_PSUBUSW,D__Vdq,D__Wdq,D__NONE,"psubusw",0xd90f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fda[] = {
      {ATTR_MODRM,C_PMINUB,D__Pq,D__Qq,D__NONE,"pminub",0xda0f,0x1002,0x7},
      {ATTR_MODRM,C_PMINUB,D__Vdq,D__Wdq,D__NONE,"pminub",0xda0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fdb[] = {
      {ATTR_MODRM,C_PAND,D__Pq,D__Qq,D__NONE,"pand",0xdb0f,0x1002,0x7},
      {ATTR_MODRM,C_PAND,D__Vdq,D__Wdq,D__NONE,"pand",0xdb0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fdc[] = {
      {ATTR_MODRM,C_PADDUSB,D__Pq,D__Qq,D__NONE,"paddusb",0xdc0f,0x1002,0x7},
      {ATTR_MODRM,C_PADDUSB,D__Vdq,D__Wdq,D__NONE,"paddusb",0xdc0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fdd[] = {
      {ATTR_MODRM,C_PADDUSW,D__Pq,D__Qq,D__NONE,"paddusw",0xdd0f,0x1002,0x7},
      {ATTR_MODRM,C_PADDUSW,D__Vdq,D__Wdq,D__NONE,"paddusw",0xdd0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fde[] = {
      {ATTR_MODRM,C_PMAXUB,D__Pq,D__Qq,D__NONE,"pmaxub",0xde0f,0x1002,0x7},
      {ATTR_MODRM,C_PMAXUB,D__Vdq,D__Wdq,D__NONE,"pmaxub",0xde0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fdf[] = {
      {ATTR_MODRM,C_PANDN,D__Pq,D__Qq,D__NONE,"pandn",0xdf0f,0x1002,0x7},
      {ATTR_MODRM,C_PANDN,D__Vdq,D__Wdq,D__NONE,"pandn",0xdf0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fe0[] = {
      {ATTR_MODRM,C_PAVGB,D__Pq,D__Qq,D__NONE,"pavgb",0xe00f,0x1002,0x7},
      {ATTR_MODRM,C_PAVGB,D__Vdq,D__Wdq,D__NONE,"pavgb",0xe00f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fe1[] = {
      {ATTR_MODRM,C_PSRAW,D__Pq,D__Qq,D__NONE,"psraw",0xe10f,0x1002,0x7},
      {ATTR_MODRM,C_PSRAW,D__Vdq,D__Wdq,D__NONE,"psraw",0xe10f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fe2[] = {
      {ATTR_MODRM,C_PSRAD,D__Pq,D__Qq,D__NONE,"psrad",0xe20f,0x1002,0x7},
      {ATTR_MODRM,C_PSRAD,D__Vdq,D__Wdq,D__NONE,"psrad",0xe20f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fe3[] = {
      {ATTR_MODRM,C_PAVGW,D__Pq,D__Qq,D__NONE,"pavgw",0xe30f,0x1002,0x7},
      {ATTR_MODRM,C_PAVGW,D__Vdq,D__Wdq,D__NONE,"pavgw",0xe30f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fe4[] = {
      {ATTR_MODRM,C_PMULHUW,D__Pq,D__Qq,D__NONE,"pmulhuw",0xe40f,0x1002,0x7},
      {ATTR_MODRM,C_PMULHUW,D__Vdq,D__Wdq,D__NONE,"pmulhuw",0xe40f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fe5[] = {
      {ATTR_MODRM,C_PMULHW,D__Pq,D__Qq,D__NONE,"pmulhw",0xe50f,0x1002,0x7},
      {ATTR_MODRM,C_PMULHW,D__Vdq,D__Wdq,D__NONE,"pmulhw",0xe50f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fe6[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_CVTTPD2DQ,D__Vdq,D__Wpd,D__NONE,"cvttpd2dq",0xe60f66,0x1003,0x6},
      {ATTR_MODRM,C_CVTPD2DQ,D__Vdq,D__Wpd,D__NONE,"cvtpd2dq",0xe60ff2,0x1003,0x6},
      {ATTR_MODRM,C_CVTDQ2PD,D__Vpd,D__Wdq,D__NONE,"cvtdq2pd",0xe60ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0fe7[] = {
      {ATTR_MODRM,C_MOVNTQ,D__Mq,D__Pq,D__NONE,"movntq",0xe70f,0x2002,0x6},
      {ATTR_MODRM,C_MOVNTDQ,D__Mdq,D__Vdq,D__NONE,"movntdq",0xe70f66,0x12003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fe8[] = {
      {ATTR_MODRM,C_PSUBSB,D__Pq,D__Qq,D__NONE,"psubsb",0xe80f,0x1002,0x7},
      {ATTR_MODRM,C_PSUBSB,D__Vdq,D__Wdq,D__NONE,"psubsb",0xe80f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fe9[] = {
      {ATTR_MODRM,C_PSUBSW,D__Pq,D__Qq,D__NONE,"psubsw",0xe90f,0x1002,0x7},
      {ATTR_MODRM,C_PSUBSW,D__Vdq,D__Wdq,D__NONE,"psubsw",0xe90f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fea[] = {
      {ATTR_MODRM,C_PMINSW,D__Pq,D__Qq,D__NONE,"pminsw",0xea0f,0x1002,0x7},
      {ATTR_MODRM,C_PMINSW,D__Vdq,D__Wdq,D__NONE,"pminsw",0xea0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0feb[] = {
      {ATTR_MODRM,C_POR,D__Pq,D__Qq,D__NONE,"por",0xeb0f,0x1002,0x7},
      {ATTR_MODRM,C_POR,D__Vdq,D__Wdq,D__NONE,"por",0xeb0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fec[] = {
      {ATTR_MODRM,C_PADDSB,D__Pq,D__Qq,D__NONE,"paddsb",0xec0f,0x1002,0x7},
      {ATTR_MODRM,C_PADDSB,D__Vdq,D__Wdq,D__NONE,"paddsb",0xec0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fed[] = {
      {ATTR_MODRM,C_PADDSW,D__Pq,D__Qq,D__NONE,"paddsw",0xed0f,0x1002,0x7},
      {ATTR_MODRM,C_PADDSW,D__Vdq,D__Wdq,D__NONE,"paddsw",0xed0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fee[] = {
      {ATTR_MODRM,C_PMAXSW,D__Pq,D__Qq,D__NONE,"pmaxsw",0xee0f,0x1002,0x7},
      {ATTR_MODRM,C_PMAXSW,D__Vdq,D__Wdq,D__NONE,"pmaxsw",0xee0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fef[] = {
      {ATTR_MODRM,C_PXOR,D__Pq,D__Qq,D__NONE,"pxor",0xef0f,0x1002,0x7},
      {ATTR_MODRM,C_PXOR,D__Vdq,D__Wdq,D__NONE,"pxor",0xef0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff0[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_LDDQU,D__Vdq,D__Mdq,D__NONE,"lddqu",0xf00ff2,0x22003,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff1[] = {
      {ATTR_MODRM,C_PSLLW,D__Pq,D__Qq,D__NONE,"psllw",0xf10f,0x1002,0x7},
      {ATTR_MODRM,C_PSLLW,D__Vdq,D__Wdq,D__NONE,"psllw",0xf10f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff2[] = {
      {ATTR_MODRM,C_PSLLD,D__Pq,D__Qq,D__NONE,"pslld",0xf20f,0x1002,0x7},
      {ATTR_MODRM,C_PSLLD,D__Vdq,D__Wdq,D__NONE,"pslld",0xf20f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff3[] = {
      {ATTR_MODRM,C_PSLLQ,D__Pq,D__Qq,D__NONE,"psllq",0xf30f,0x1002,0x7},
      {ATTR_MODRM,C_PSLLQ,D__Vdq,D__Wdq,D__NONE,"psllq",0xf30f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff4[] = {
      {ATTR_MODRM,C_PMULUDQ,D__Pq,D__Qq,D__NONE,"pmuludq",0xf40f,0x1002,0x7},
      {ATTR_MODRM,C_PMULUDQ,D__Vdq,D__Wdq,D__NONE,"pmuludq",0xf40f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff5[] = {
      {ATTR_MODRM,C_PMADDWD,D__Pq,D__Qq,D__NONE,"pmaddwd",0xf50f,0x1002,0x7},
      {ATTR_MODRM,C_PMADDWD,D__Vdq,D__Wdq,D__NONE,"pmaddwd",0xf50f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff6[] = {
      {ATTR_MODRM,C_PSADBW,D__Pq,D__Qq,D__NONE,"psadbw",0xf60f,0x1002,0x7},
      {ATTR_MODRM,C_PSADBW,D__Vdq,D__Wdq,D__NONE,"psadbw",0xf60f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff7[] = {
      {ATTR_MODRM,C_MASKMOVQ,D__Pq,D__Nq,D__NONE,"maskmovq",0xf70f,0x42002,0x5},
      {ATTR_MODRM,C_MASKMOVDQU,D__Vdq,D__Udq,D__NONE,"maskmovdqu",0xf70f66,0x52003,0x5},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff8[] = {
      {ATTR_MODRM,C_PSUBB,D__Pq,D__Qq,D__NONE,"psubb",0xf80f,0x1002,0x7},
      {ATTR_MODRM,C_PSUBB,D__Vdq,D__Wdq,D__NONE,"psubb",0xf80f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ff9[] = {
      {ATTR_MODRM,C_PSUBW,D__Pq,D__Qq,D__NONE,"psubw",0xf90f,0x1002,0x7},
      {ATTR_MODRM,C_PSUBW,D__Vdq,D__Wdq,D__NONE,"psubw",0xf90f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ffa[] = {
      {ATTR_MODRM,C_PSUBD,D__Pq,D__Qq,D__NONE,"psubd",0xfa0f,0x1002,0x7},
      {ATTR_MODRM,C_PSUBD,D__Vdq,D__Wdq,D__NONE,"psubd",0xfa0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ffb[] = {
      {ATTR_MODRM,C_PSUBQ,D__Pq,D__Qq,D__NONE,"psubq",0xfb0f,0x1002,0x7},
      {ATTR_MODRM,C_PSUBQ,D__Vdq,D__Wdq,D__NONE,"psubq",0xfb0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ffc[] = {
      {ATTR_MODRM,C_PADDB,D__Pq,D__Qq,D__NONE,"paddb",0xfc0f,0x1002,0x7},
      {ATTR_MODRM,C_PADDB,D__Vdq,D__Wdq,D__NONE,"paddb",0xfc0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ffd[] = {
      {ATTR_MODRM,C_PADDW,D__Pq,D__Qq,D__NONE,"paddw",0xfd0f,0x1002,0x7},
      {ATTR_MODRM,C_PADDW,D__Vdq,D__Wdq,D__NONE,"paddw",0xfd0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0ffe[] = {
      {ATTR_MODRM,C_PADDD,D__Pq,D__Qq,D__NONE,"paddd",0xfe0f,0x1002,0x7},
      {ATTR_MODRM,C_PADDD,D__Vdq,D__Wdq,D__NONE,"paddd",0xfe0f66,0x1003,0x7},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fc2[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_CMPPS,D__Vps,D__Wps,D__Ib,"cmpps",0xc20f,0x1002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_CMPPD,D__Vpd,D__Wpd,D__Ib,"cmppd",0xc20f66,0x1003,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_CMPSD,D__Vsd,D__Wsd,D__Ib,"cmpsd",0xc20ff2,0x1003,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_CMPSS,D__Vss,D__Wss,D__Ib,"cmpss",0xc20ff3,0x1003,0x17},
};
_DIS_OPCODE_T GroupSSE_0fb8[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_POPCNT,D__Gv,D__Ev,D__NONE,"popcnt",0xb80ff3,0x1003,0x6},
};
_DIS_OPCODE_T GroupSSE_0fc4[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PINSRW,D__Pq,D__Mw,D__Ib,"pinsrw",0xc40f,0x2002,0x16},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PINSRW,D__Vdq,D__Mw,D__Ib,"pinsrw",0xc40f66,0x12003,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PINSRW,D__Pq,D__Rv,D__Ib,"pinsrw",0xc40f,0x42002,0x16},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PINSRW,D__Vdq,D__Rv,D__Ib,"pinsrw",0xc40f66,0x52003,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fc5[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PEXTRW,D__Gy,D__Nq,D__Ib,"pextrw",0xc50f,0x42002,0x16},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_PEXTRW,D__Gy,D__Udq,D__Ib,"pextrw",0xc50f66,0x52003,0x16},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T GroupSSE_0fc6[] = {
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SHUFPS,D__Vps,D__Wps,D__Ib,"shufps",0xc60f,0x1002,0x17},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SHUFPD,D__Vpd,D__Wpd,D__Ib,"shufpd",0xc60f66,0x1003,0x17},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,_C_XCHG,D__rAX,D__erAX,D__NONE,"XCHG",0x90,0x1001,0xf},
      {0,_C_XCHG,D__rAX,D__erAX,D__NONE,"XCHG",0x9066,0x1002,0xf},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_PAUSE,D__NONE,D__NONE,D__NONE,"PAUSE",0x90f3,0x1002,0x0},
};
_DIS_OPCODE_T Group_amd3dnow[] = {
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PI2FW,D__Pq,D__Qq,D__NONE,"PI2FW",0xf0f,0xc8002,0x0},
      {ATTR_MODRM,C_PI2FD,D__Pq,D__Qq,D__NONE,"PI2FD",0xf0f,0xd8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PF2IW,D__Pq,D__Qq,D__NONE,"PF2IW",0xf0f,0x1c8002,0x0},
      {ATTR_MODRM,C_PF2ID,D__Pq,D__Qq,D__NONE,"PF2ID",0xf0f,0x1d8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFNACC,D__Pq,D__Qq,D__NONE,"PFNACC",0xf0f,0x8a8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFPNACC,D__Pq,D__Qq,D__NONE,"PFPNACC",0xf0f,0x8e8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFCMPGE,D__Pq,D__Qq,D__NONE,"PFCMPGE",0xf0f,0x908002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFMIN,D__Pq,D__Qq,D__NONE,"PFMIN",0xf0f,0x948002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFRCP,D__Pq,D__Qq,D__NONE,"PFRCP",0xf0f,0x968002,0x0},
      {ATTR_MODRM,C_PFRSQRT,D__Pq,D__Qq,D__NONE,"PFRSQRT",0xf0f,0x978002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFSUB,D__Pq,D__Qq,D__NONE,"PFSUB",0xf0f,0x9a8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFADD,D__Pq,D__Qq,D__NONE,"PFADD",0xf0f,0x9e8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFCMPGT,D__Pq,D__Qq,D__NONE,"PFCMPGT",0xf0f,0xa08002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFMAX,D__Pq,D__Qq,D__NONE,"PFMAX",0xf0f,0xa48002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFRCPIT1,D__Pq,D__Qq,D__NONE,"PFRCPIT1",0xf0f,0xa68002,0x0},
      {ATTR_MODRM,C_PFRSQIT1,D__Pq,D__Qq,D__NONE,"PFRSQIT1",0xf0f,0xa78002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFSUBR,D__Pq,D__Qq,D__NONE,"PFSUBR",0xf0f,0xaa8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFACC,D__Pq,D__Qq,D__NONE,"PFACC",0xf0f,0xae8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFCMPEQ,D__Pq,D__Qq,D__NONE,"PFCMPEQ",0xf0f,0xb08002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFMUL,D__Pq,D__Qq,D__NONE,"PFMUL",0xf0f,0xb48002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PFRCPIT2,D__Pq,D__Qq,D__NONE,"PFRCPIT2",0xf0f,0xb68002,0x0},
      {ATTR_MODRM,C_PMULHRW,D__Pq,D__Qq,D__NONE,"PMULHRW",0xf0f,0xb78002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PSWAPD,D__Pq,D__Qq,D__NONE,"PSWAPD",0xf0f,0xbb8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_PAVGUSB,D__Pq,D__Qq,D__NONE,"PAVGUSB",0xf0f,0xbf8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0xf0f,0x8002,0x0},
};
_DIS_OPCODE_T OpTable2Byte0f[] = {
      {ATTR_MODRM,C_GRP,D__NONE,D__NONE,D__NONE,(const char*)GroupG6,0xf,0x2,0x0},
      {ATTR_MODRM,C_GRPRM,D__NONE,D__NONE,D__NONE,(const char*)GroupG7M,0x10f,0x2,0x0},
      {ATTR_MODRM,C_LAR,D__Gv,D_rEv,D__NONE,"LAR",0x20f,0x2,0x6},
      {ATTR_MODRM,C_LSL,D__Gv,D_rEv,D__NONE,"LSL",0x30f,0x2,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_X64_ONLY,C_SYSCALL,D__NONE,D__NONE,D__NONE,"SYSCALL",0x50f,0x2,0x0},
      {0,C_CLTS,D__NONE,D__NONE,D__NONE,"CLTS",0x60f,0x2,0x0},
      {ATTR_X64_ONLY,C_SYSRET,D__NONE,D__NONE,D__NONE,"SYSRET",0x70f,0x2,0x0},
      {0,C_INVD,D__NONE,D__NONE,D__NONE,"INVD",0x80f,0x2,0x0},
      {0,C_WBINVD,D__NONE,D__NONE,D__NONE,"WBINVD",0x90f,0x2,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_UD2,D__NONE,D__NONE,D__NONE,"UD2",0xb0f,0x2,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NOP,D__Ev,D__NONE,D__NONE,"NOP",0xd0f,0x2,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_3DNOW,D__Pq,D__Qq,D__NONE,"",0xf0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f10,0x100f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f11,0x110f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f12,0x120f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f13,0x130f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f14,0x140f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f15,0x150f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f16,0x160f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f17,0x170f,0x2,0x0},
      {ATTR_MODRM,C_GRP,D__NONE,D__NONE,D__NONE,(const char*)GroupG16,0x180f,0x2,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NOP,D__Ev,D__NONE,D__NONE,"NOP",0x1f0f,0x2,0x0},
      {ATTR_MODRM|ATTR_JMP,C_MOV,D__Rd,D__Cd,D__NONE,"MOV",0x200f,0x2,0x6},
      {ATTR_MODRM|ATTR_JMP,C_MOV,D__Rd,D__Dd,D__NONE,"MOV",0x210f,0x2,0x6},
      {ATTR_MODRM|ATTR_JMP,C_MOV,D__Cd,D__Rd,D__NONE,"MOV",0x220f,0x2,0x6},
      {ATTR_MODRM|ATTR_JMP,C_MOV,D__Dd,D__Rd,D__NONE,"MOV",0x230f,0x2,0x6},
      {ATTR_MODRM|ATTR_JMP,C_MOV,D__Rd,D__Td,D__NONE,"MOV",0x240f,0x2,0x6},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM|ATTR_JMP,C_MOV,D__Td,D__Rd,D__NONE,"MOV",0x260f,0x2,0x6},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f28,0x280f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f29,0x290f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f2a,0x2a0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f2b,0x2b0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f2c,0x2c0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f2d,0x2d0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f2e,0x2e0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f2f,0x2f0f,0x2,0x0},
      {0,C_WRMSR,D__NONE,D__NONE,D__NONE,"WRMSR",0x300f,0x2,0x0},
      {0,C_RDTSC,D__NONE,D__NONE,D__NONE,"RDTSC",0x310f,0x2,0x0},
      {0,C_RDMSR,D__NONE,D__NONE,D__NONE,"RDMSR",0x320f,0x2,0x0},
      {0,C_RDPMC,D__NONE,D__NONE,D__NONE,"RDPMC",0x330f,0x2,0x0},
      {0,C_SYSENTER,D__NONE,D__NONE,D__NONE,"SYSENTER",0x340f,0x2,0x0},
      {0,C_SYSEXIT,D__NONE,D__NONE,D__NONE,"SYSEXIT",0x350f,0x2,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_GETSEC,D__NONE,D__NONE,D__NONE,"GETSEC",0x370f,0x2,0x0},
      {ATTR_MODRM,C_3BYTE_1,D__NONE,D__NONE,D__NONE,(const char*)OpTable3Byte0f38,0x380f,0x2,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_3BYTE_2,D__NONE,D__NONE,D__NONE,(const char*)OpTable3Byte0f3a,0x3a0f,0x2,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_MODRM,C_CMOVtO,D__Gv,D_rEv,D__tO,"CMOVO",0x400f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfO,D__Gv,D_rEv,D__fO,"CMOVNO",0x410f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtC,D__Gv,D_rEv,D__tC,"CMOVB",0x420f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfC,D__Gv,D_rEv,D__fC,"CMOVNB",0x430f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtZ,D__Gv,D_rEv,D__tZ,"CMOVZ",0x440f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfZ,D__Gv,D_rEv,D__fZ,"CMOVNZ",0x450f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfA,D__Gv,D_rEv,D__fA,"CMOVBE",0x460f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtA,D__Gv,D_rEv,D__tA,"CMOVA",0x470f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtS,D__Gv,D_rEv,D__fS,"CMOVS",0x480f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfS,D__Gv,D_rEv,D__fP,"CMOVNS",0x490f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtP,D__Gv,D_rEv,D__tP,"CMOVP",0x4a0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfP,D__Gv,D_rEv,D__tS,"CMOVNP",0x4b0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtL,D__Gv,D_rEv,D__tL,"CMOVL",0x4c0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfL,D__Gv,D_rEv,D__fL,"CMOVGE",0x4d0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfG,D__Gv,D_rEv,D__fG,"CMOVLE",0x4e0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtG,D__Gv,D_rEv,D__tG,"CMOVG",0x4f0f,0x2,0x7},
      {ATTR_MODRM,C_GRPSSEFIX,D__Ed,D__Vps,D__NONE,(const char*)GroupSSE_0f50,0x500f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f51,0x510f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f52,0x520f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f53,0x530f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f54,0x540f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f55,0x550f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f56,0x560f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f57,0x570f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f58,0x580f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f59,0x590f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vpd,D__Wps,D__NONE,(const char*)GroupSSE_0f5a,0x5a0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wdq,D__NONE,(const char*)GroupSSE_0f5b,0x5b0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f5c,0x5c0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f5d,0x5d0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f5e,0x5e0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Vps,D__Wps,D__NONE,(const char*)GroupSSE_0f5f,0x5f0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f60,0x600f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f61,0x610f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f62,0x620f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f63,0x630f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f64,0x640f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f65,0x650f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f66,0x660f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f67,0x670f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f68,0x680f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f69,0x690f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f6a,0x6a0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f6b,0x6b0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f6c,0x6c0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f6d,0x6d0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f6e,0x6e0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f6f,0x6f0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f70,0x700f,0x2,0x0},
      {ATTR_MODRM,C_GRP7,D__NONE,D__NONE,D__NONE,(const char*)GroupG12,0x710f,0x2,0x0},
      {ATTR_MODRM,C_GRP7,D__NONE,D__NONE,D__NONE,(const char*)GroupG13,0x720f,0x2,0x0},
      {ATTR_MODRM,C_GRP7,D__NONE,D__NONE,D__NONE,(const char*)GroupG14,0x730f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f74,0x740f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f75,0x750f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f76,0x760f,0x2,0x0},
      {0,C_EMMS,D__NONE,D__NONE,D__NONE,"emms",0x770f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f78,0x780f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f79,0x790f,0x2,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,"MMX UD",0x0,0x0,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,"MMX UD",0x0,0x0,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f7c,0x7c0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f7d,0x7d0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f7e,0x7e0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0f7f,0x7f0f,0x2,0x0},
      {ATTR_JMP,C_JtO,D__Jz,D__tO,D__NONE,"JO",0x800f,0x2,0x0},
      {ATTR_JMP,C_JfO,D__Jz,D__fO,D__NONE,"JNO",0x810f,0x2,0x0},
      {ATTR_JMP,C_JtC,D__Jz,D__tC,D__NONE,"JC",0x820f,0x2,0x0},
      {ATTR_JMP,C_JfC,D__Jz,D__fC,D__NONE,"JNC",0x830f,0x2,0x0},
      {ATTR_JMP,C_JtZ,D__Jz,D__tZ,D__NONE,"JZ",0x840f,0x2,0x0},
      {ATTR_JMP,C_JfZ,D__Jz,D__fZ,D__NONE,"JNZ",0x850f,0x2,0x0},
      {ATTR_JMP,C_JfA,D__Jz,D__fA,D__NONE,"JNA",0x860f,0x2,0x0},
      {ATTR_JMP,C_JtA,D__Jz,D__tA,D__NONE,"JA",0x870f,0x2,0x0},
      {ATTR_JMP,C_JtS,D__Jz,D__fS,D__NONE,"JS",0x880f,0x2,0x0},
      {ATTR_JMP,C_JfS,D__Jz,D__fP,D__NONE,"JNS",0x890f,0x2,0x0},
      {ATTR_JMP,C_JtP,D__Jz,D__tP,D__NONE,"JP",0x8a0f,0x2,0x0},
      {ATTR_JMP,C_JfP,D__Jz,D__tS,D__NONE,"JNP",0x8b0f,0x2,0x0},
      {ATTR_JMP,C_JtL,D__Jz,D__tL,D__NONE,"JL",0x8c0f,0x2,0x0},
      {ATTR_JMP,C_JfL,D__Jz,D__fL,D__NONE,"JNL",0x8d0f,0x2,0x0},
      {ATTR_JMP,C_JfG,D__Jz,D__fG,D__NONE,"JNG",0x8e0f,0x2,0x0},
      {ATTR_JMP,C_JtG,D__Jz,D__tG,D__NONE,"JG",0x8f0f,0x2,0x0},
      {ATTR_MODRM,C_SETtO,D_wEb,D__tO,D__NONE,"SETO",0x900f,0x2,0x1},
      {ATTR_MODRM,C_SETfO,D_wEb,D__fO,D__NONE,"SETNO",0x910f,0x2,0x1},
      {ATTR_MODRM,C_SETtC,D_wEb,D__tC,D__NONE,"SETC",0x920f,0x2,0x1},
      {ATTR_MODRM,C_SETfC,D_wEb,D__fC,D__NONE,"SETNC",0x930f,0x2,0x1},
      {ATTR_MODRM,C_SETtZ,D_wEb,D__tZ,D__NONE,"SETZ",0x940f,0x2,0x1},
      {ATTR_MODRM,C_SETfZ,D_wEb,D__fZ,D__NONE,"SETNZ",0x950f,0x2,0x1},
      {ATTR_MODRM,C_SETfA,D_wEb,D__fA,D__NONE,"SETNA",0x960f,0x2,0x1},
      {ATTR_MODRM,C_SETtA,D_wEb,D__tA,D__NONE,"SETA",0x970f,0x2,0x1},
      {ATTR_MODRM,C_SETtS,D_wEb,D__fS,D__NONE,"SETS",0x980f,0x2,0x1},
      {ATTR_MODRM,C_SETfS,D_wEb,D__fP,D__NONE,"SETNS",0x990f,0x2,0x1},
      {ATTR_MODRM,C_SETtP,D_wEb,D__tP,D__NONE,"SETP",0x9a0f,0x2,0x1},
      {ATTR_MODRM,C_SETfP,D_wEb,D__tS,D__NONE,"SETNP",0x9b0f,0x2,0x1},
      {ATTR_MODRM,C_SETtL,D_wEb,D__tL,D__NONE,"SETL",0x9c0f,0x2,0x1},
      {ATTR_MODRM,C_SETfL,D_wEb,D__fL,D__NONE,"SETNL",0x9d0f,0x2,0x1},
      {ATTR_MODRM,C_SETfG,D_wEb,D__fG,D__NONE,"SETNG",0x9e0f,0x2,0x1},
      {ATTR_MODRM,C_SETtG,D_wEb,D__tG,D__NONE,"SETG",0x9f0f,0x2,0x1},
      {ATTR_SP,C_PUSH,D__FS,D__NONE,D__NONE,"PUSH",0xa00f,0x2,0x1},
      {ATTR_SP,C_POP,D__FS,D__NONE,D__NONE,"POP",0xa10f,0x2,0x2},
      {0,C_CPUID,D__NONE,D__NONE,D__NONE,"CPUID",0xa20f,0x2,0x0},
      {ATTR_MODRM,C_BT,D_rEv,D__Gv,D__NONE,"BT",0xa30f,0x2,0x5},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SHLD,D__Ev,D__Gv,D__Ib,"SHLD",0xa40f,0x2,0x16},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SHLD,D__Ev,D__Gv,D__CL,"SHLD",0xa50f,0x2,0x16},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {0,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_SP,C_PUSH,D__GS,D__NONE,D__NONE,"PUSP",0xa80f,0x2,0x1},
      {ATTR_SP,C_POP,D__GS,D__NONE,D__NONE,"POP",0xa90f,0x2,0x2},
      {0,C_RSM,D__NONE,D__NONE,D__NONE,"RSM",0xaa0f,0x2,0x0},
      {ATTR_MODRM,C_BTS,D__Ev,D__Gv,D__NONE,"BTS",0xab0f,0x2,0x7},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_SHRD,D__Ev,D__Gv,D__Ib,"SHRD",0xac0f,0x2,0x16},
      {ATTR_MODRM,C_SHRD,D__Ev,D__Gv,D__CL,"SHRD",0xad0f,0x2,0x16},
      {ATTR_MODRM,C_GRPMOD,D__NONE,D__NONE,D__NONE,(const char*)GroupG15,0xae0f,0x2,0x0},
      {ATTR_MODRM,C_IMUL,D__Gv,D_rEv,D__NONE,"IMUL",0xaf0f,0x2,0x7},
      {ATTR_MODRM,C_CMPXCHG,D__Eb,D__Gb,D__NONE,"CMPXCHG",0xb00f,0x2,0xf},
      {ATTR_MODRM,C_CMPXCHG,D__Ev,D__Gv,D__NONE,"CMPXCHG",0xb10f,0x2,0xf},
      {ATTR_MODRM,C_LSS,D__Gv,D_rMp,D__NONE,"LSS",0xb20f,0x2,0x6},
      {ATTR_MODRM,C_BTR,D__Ev,D__Gv,D__NONE,"BTR",0xb30f,0x2,0x6},
      {ATTR_MODRM,C_LFS,D__Gv,D_rMp,D__NONE,"LFS",0xb40f,0x2,0x6},
      {ATTR_MODRM,C_LGS,D__Gv,D_rMp,D__NONE,"LGS",0xb50f,0x2,0x6},
      {ATTR_MODRM,C_MOVZX,D__Gv,D_rEb,D__NONE,"MOVZX",0xb60f,0x2,0x6},
      {ATTR_MODRM,C_MOVZX,D__Gv,D_rEw,D__NONE,"MOVZX",0xb70f,0x2,0x6},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0fb8,0xb80f,0x2,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRP,D__Ev,D__Ib,D__NONE,(const char*)GroupG8EvIb,0xba0f,0x2,0x0},
      {ATTR_MODRM,C_BTC,D__Ev,D__Gv,D__NONE,"BTC",0xbb0f,0x2,0x7},
      {ATTR_MODRM,C_BSF,D__Gv,D__Ev,D__NONE,"BSF",0xbc0f,0x2,0x6},
      {ATTR_MODRM,C_BSR,D__Gv,D__Ev,D__NONE,"BSR",0xbd0f,0x2,0x6},
      {ATTR_MODRM,C_MOVSX,D__Gv,D_rEb,D__NONE,"MOVSX",0xbe0f,0x2,0x6},
      {ATTR_MODRM,C_MOVSX,D__Gv,D_rEw,D__NONE,"MOVSX",0xbf0f,0x2,0x6},
      {ATTR_MODRM,C_XADD,D__Eb,D__Gb,D__NONE,"XADD",0xc00f,0x2,0x7},
      {ATTR_MODRM,C_XADD,D__Ev,D__Gv,D__NONE,"XADD",0xc10f,0x2,0x7},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0fc2,0xc20f,0x2,0x0},
      {ATTR_MODRM,C_MOVNTI,D__My,D__Gy,D__NONE,"movnti",0xc30f,0x2,0x6},
      {ATTR_MODRM,C_GRPSSEFIX,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0fc4,0xc40f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0fc5,0xc50f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0fc6,0xc60f,0x2,0x0},
      {ATTR_MODRM,C_GRP7,D__NONE,D__NONE,D__NONE,(const char*)GroupG9,0xc70f,0x2,0x0},
      {0,C_BSWAP,D__RAX,D__NONE,D__NONE,"BSWAP",0xc80f,0x2,0x3},
      {0,C_BSWAP,D__RCX,D__NONE,D__NONE,"BSWAP",0xc90f,0x2,0x3},
      {0,C_BSWAP,D__RDX,D__NONE,D__NONE,"BSWAP",0xca0f,0x2,0x3},
      {0,C_BSWAP,D__RBX,D__NONE,D__NONE,"BSWAP",0xcb0f,0x2,0x3},
      {0,C_BSWAP,D__RSP,D__NONE,D__NONE,"BSWAP",0xcc0f,0x2,0x3},
      {0,C_BSWAP,D__RBP,D__NONE,D__NONE,"BSWAP",0xcd0f,0x2,0x3},
      {0,C_BSWAP,D__RSI,D__NONE,D__NONE,"BSWAP",0xce0f,0x2,0x3},
      {0,C_BSWAP,D__RDI,D__NONE,D__NONE,"BSWAP",0xcf0f,0x2,0x3},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Pq,D__NONE,(const char*)GroupSSE_0fd0,0xd00f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fd1,0xd10f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fd2,0xd20f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fd3,0xd30f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fd4,0xd40f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fd5,0xd50f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Wq,D__Vq,D__NONE,(const char*)GroupSSE_0fd6,0xd60f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Gd,D__Pq,D__NONE,(const char*)GroupSSE_0fd7,0xd70f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fd8,0xd80f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fd9,0xd90f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fda,0xda0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fdb,0xdb0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fdc,0xdc0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fdd,0xdd0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fde,0xde0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fdf,0xdf0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fe0,0xe00f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fe1,0xe10f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fe2,0xe20f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fe3,0xe30f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fe4,0xe40f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fe5,0xe50f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__NONE,D__NONE,D__NONE,(const char*)GroupSSE_0fe6,0xe60f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Wq,D__Vq,D__NONE,(const char*)GroupSSE_0fe7,0xe70f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fe8,0xe80f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fe9,0xe90f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fea,0xea0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0feb,0xeb0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fec,0xec0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fed,0xed0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fee,0xee0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0fef,0xef0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSEFIX,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ff0,0xf00f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ff1,0xf10f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ff2,0xf20f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ff3,0xf30f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ff4,0xf40f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ff5,0xf50f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ff6,0xf60f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Ppi,D__Qpi,D__NONE,(const char*)GroupSSE_0ff7,0xf70f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ff8,0xf80f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ff9,0xf90f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ffa,0xfa0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ffb,0xfb0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ffc,0xfc0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ffd,0xfd0f,0x2,0x0},
      {ATTR_MODRM,C_GRPSSE,D__Pq,D__Qq,D__NONE,(const char*)GroupSSE_0ffe,0xfe0f,0x2,0x0},
      {ATTR_MODRM,C_NULL,D__NONE,D__NONE,D__NONE,0,0x0,0x0,0x0},
};
_DIS_OPCODE_T Group0x63[] = {
      {ATTR_MODRM|ATTR_X64_INVALID,C_ARPL,D__Ew,D__Gw,D__NONE,"ARPL",0x63,0x1,0x6},
      {ATTR_MODRM|ATTR_X64_ONLY,C_MOVSXD,D__Gv,D__Ev,D__NONE,"MOVSXD",0x63,0x1,0x6},
};
_DIS_OPCODE_T Group_main[] = {
      {ATTR_MODRM,C_ADD,D__Eb,D__Gb,D__NONE,"ADD",0x0,0x1,0x7},
      {ATTR_MODRM,C_ADD,D__Ev,D__Gv,D__NONE,"ADD",0x1,0x1,0x7},
      {ATTR_MODRM,C_ADD,D__Gb,D_rEb,D__NONE,"ADD",0x2,0x1,0x7},
      {ATTR_MODRM,C_ADD,D__Gv,D_rEv,D__NONE,"ADD",0x3,0x1,0x7},
      {ATTR_B|ATTR_W,C_ADD,D__AL,D__Ib,D__NONE,"ADD",0x4,0x1,0x7},
      {ATTR_X64,C_ADD,D__rAX,D__Iz,D__NONE,"ADD",0x5,0x1,0x7},
      {ATTR_X64_INVALID,C_PUSH,D__ES,D__NONE,D__NONE,"PUSH",0x6,0x1,0x1},
      {ATTR_X64_INVALID,C_POP,D__ES,D__NONE,D__NONE,"POP",0x7,0x1,0x2},
      {ATTR_MODRM,C_OR,D__Eb,D__Gb,D__NONE,"OR",0x8,0x1,0x7},
      {ATTR_MODRM,C_OR,D__Ev,D__Gv,D__NONE,"OR",0x9,0x1,0x7},
      {ATTR_MODRM,C_OR,D__Gb,D_rEb,D__NONE,"OR",0xa,0x1,0x7},
      {ATTR_MODRM,C_OR,D__Gv,D_rEv,D__NONE,"OR",0xb,0x1,0x7},
      {ATTR_B|ATTR_W,C_OR,D__AL,D__Ib,D__NONE,"OR",0xc,0x1,0x7},
      {ATTR_X64,C_OR,D__rAX,D__Iz,D__NONE,"OR",0xd,0x1,0x7},
      {ATTR_X64_INVALID,C_PUSH,D__CS,D__NONE,D__NONE,"PUSH",0xe,0x1,0x1},
      {0,C_2BYTE,D__CS,D__NONE,D__NONE,(const char*)OpTable2Byte0f,0xf,0x1,0x0},
      {ATTR_MODRM,C_ADC,D__Eb,D__Gb,D__NONE,"ADC",0x10,0x1,0x7},
      {ATTR_MODRM,C_ADC,D__Ev,D__Gv,D__NONE,"ADC",0x11,0x1,0x7},
      {ATTR_MODRM,C_ADC,D__Gb,D_rEb,D__NONE,"ADC",0x12,0x1,0x7},
      {ATTR_MODRM,C_ADC,D__Gv,D_rEv,D__NONE,"ADC",0x13,0x1,0x7},
      {ATTR_B|ATTR_W,C_ADC,D__AL,D__Ib,D__NONE,"ADC",0x14,0x1,0x7},
      {ATTR_X64,C_ADC,D__rAX,D__Iz,D__NONE,"ADC",0x15,0x1,0x7},
      {ATTR_X64_INVALID,C_PUSH,D__SS,D__NONE,D__NONE,"PUSH",0x16,0x1,0x1},
      {ATTR_X64_INVALID,C_POP,D__SS,D__NONE,D__NONE,"POP",0x17,0x1,0x2},
      {ATTR_MODRM,C_SBB,D__Eb,D__Gb,D__NONE,"SBB",0x18,0x1,0x7},
      {ATTR_MODRM,C_SBB,D__Ev,D__Gv,D__NONE,"SBB",0x19,0x1,0x7},
      {ATTR_MODRM,C_SBB,D__Gb,D_rEb,D__NONE,"SBB",0x1a,0x1,0x7},
      {ATTR_MODRM,C_SBB,D__Gv,D_rEv,D__NONE,"SBB",0x1b,0x1,0x7},
      {ATTR_B|ATTR_W,C_SBB,D__AL,D__Ib,D__NONE,"SBB",0x1c,0x1,0x7},
      {ATTR_X64,C_SBB,D__rAX,D__Iz,D__NONE,"SBB",0x1d,0x1,0x7},
      {ATTR_X64_INVALID,C_PUSH,D__DS,D__NONE,D__NONE,"PUSH",0x1e,0x1,0x1},
      {ATTR_X64_INVALID,C_POP,D__DS,D__NONE,D__NONE,"POP",0x1f,0x1,0x2},
      {ATTR_MODRM,C_AND,D__Eb,D__Gb,D__NONE,"AND",0x20,0x1,0x7},
      {ATTR_MODRM,C_AND,D__Ev,D__Gv,D__NONE,"AND",0x21,0x1,0x7},
      {ATTR_MODRM,C_AND,D__Gb,D_rEb,D__NONE,"AND",0x22,0x1,0x7},
      {ATTR_MODRM,C_AND,D__Gv,D_rEv,D__NONE,"AND",0x23,0x1,0x7},
      {ATTR_B|ATTR_W,C_AND,D__AL,D__Ib,D__NONE,"AND",0x24,0x1,0x7},
      {ATTR_X64,C_AND,D__rAX,D__Iz,D__NONE,"AND",0x25,0x1,0x7},
      {0,C_ES,D__NONE,D__NONE,D__NONE,"ES:",0x26,0x1,0x0},
      {ATTR_X64_INVALID,C_DAA,D__NONE,D__NONE,D__NONE,"DAA",0x27,0x1,0x0},
      {ATTR_MODRM,C_SUB,D__Eb,D__Gb,D__NONE,"SUB",0x28,0x1,0x7},
      {ATTR_MODRM,C_SUB,D__Ev,D__Gv,D__NONE,"SUB",0x29,0x1,0x7},
      {ATTR_MODRM,C_SUB,D__Gb,D_rEb,D__NONE,"SUB",0x2a,0x1,0x7},
      {ATTR_MODRM,C_SUB,D__Gv,D_rEv,D__NONE,"SUB",0x2b,0x1,0x7},
      {ATTR_B|ATTR_W,C_SUB,D__AL,D__Ib,D__NONE,"SUB",0x2c,0x1,0x7},
      {ATTR_X64,C_SUB,D__rAX,D__Iz,D__NONE,"SUB",0x2d,0x1,0x7},
      {0,C_CS,D__NONE,D__NONE,D__NONE,"CS:",0x2e,0x1,0x0},
      {ATTR_X64_INVALID,C_DAS,D__NONE,D__NONE,D__NONE,"DAS",0x2f,0x1,0x0},
      {ATTR_MODRM,C_XOR,D__Eb,D__Gb,D__NONE,"XOR",0x30,0x1,0x7},
      {ATTR_MODRM,C_XOR,D__Ev,D__Gv,D__NONE,"XOR",0x31,0x1,0x7},
      {ATTR_MODRM,C_XOR,D__Gb,D_rEb,D__NONE,"XOR",0x32,0x1,0x7},
      {ATTR_MODRM,C_XOR,D__Gv,D_rEv,D__NONE,"XOR",0x33,0x1,0x7},
      {ATTR_B|ATTR_W,C_XOR,D__AL,D__Ib,D__NONE,"XOR",0x34,0x1,0x7},
      {ATTR_X64,C_XOR,D__rAX,D__Iz,D__NONE,"XOR",0x35,0x1,0x7},
      {0,C_SS,D__NONE,D__NONE,D__NONE,"SS:",0x36,0x1,0x0},
      {ATTR_X64_INVALID,C_AAA,D__NONE,D__NONE,D__NONE,"AAA",0x37,0x1,0x0},
      {ATTR_MODRM,C_CMP,D_rEb,D__Gb,D__NONE,"CMP",0x38,0x1,0x5},
      {ATTR_MODRM,C_CMP,D_rEv,D__Gv,D__NONE,"CMP",0x39,0x1,0x5},
      {ATTR_MODRM,C_CMP,D__Gb,D_rEb,D__NONE,"CMP",0x3a,0x1,0x5},
      {ATTR_MODRM,C_CMP,D__Gv,D_rEv,D__NONE,"CMP",0x3b,0x1,0x5},
      {ATTR_B|ATTR_W,C_CMP,D__AL,D__Ib,D__NONE,"CMP",0x3c,0x1,0x5},
      {ATTR_X64,C_CMP,D__rAX,D__Iz,D__NONE,"CMP",0x3d,0x1,0x5},
      {0,C_DS,D__NONE,D__NONE,D__NONE,"DS:",0x3e,0x1,0x0},
      {ATTR_X64_INVALID,C_AAS,D__NONE,D__NONE,D__NONE,"AAS",0x3f,0x1,0x0},
      {ATTR_X64_INVALID,C_INC,D__eAX,D__NONE,D__NONE,"INC",0x40,0x1,0x3},
      {ATTR_X64_INVALID,C_INC,D__eCX,D__NONE,D__NONE,"INC",0x41,0x1,0x3},
      {ATTR_X64_INVALID,C_INC,D__eDX,D__NONE,D__NONE,"INC",0x42,0x1,0x3},
      {ATTR_X64_INVALID,C_INC,D__eBX,D__NONE,D__NONE,"INC",0x43,0x1,0x3},
      {ATTR_X64_INVALID,C_INC,D__eSP,D__NONE,D__NONE,"INC",0x44,0x1,0x3},
      {ATTR_X64_INVALID,C_INC,D__eBP,D__NONE,D__NONE,"INC",0x45,0x1,0x3},
      {ATTR_X64_INVALID,C_INC,D__eSI,D__NONE,D__NONE,"INC",0x46,0x1,0x3},
      {ATTR_X64_INVALID,C_INC,D__eDI,D__NONE,D__NONE,"INC",0x47,0x1,0x3},
      {ATTR_X64_INVALID,C_DEC,D__eAX,D__NONE,D__NONE,"DEC",0x48,0x1,0x3},
      {ATTR_X64_INVALID,C_DEC,D__eCX,D__NONE,D__NONE,"DEC",0x49,0x1,0x3},
      {ATTR_X64_INVALID,C_DEC,D__eDX,D__NONE,D__NONE,"DEC",0x4a,0x1,0x3},
      {ATTR_X64_INVALID,C_DEC,D__eBX,D__NONE,D__NONE,"DEC",0x4b,0x1,0x3},
      {ATTR_X64_INVALID,C_DEC,D__eSP,D__NONE,D__NONE,"DEC",0x4c,0x1,0x3},
      {ATTR_X64_INVALID,C_DEC,D__eBP,D__NONE,D__NONE,"DEC",0x4d,0x1,0x3},
      {ATTR_X64_INVALID,C_DEC,D__eSI,D__NONE,D__NONE,"DEC",0x4e,0x1,0x3},
      {ATTR_X64_INVALID,C_DEC,D__eDI,D__NONE,D__NONE,"DEC",0x4f,0x1,0x3},
      {ATTR_SP,C_PUSH,D__erAX,D__NONE,D__NONE,"PUSH",0x50,0x1,0x1},
      {ATTR_SP,C_PUSH,D__erCX,D__NONE,D__NONE,"PUSH",0x51,0x1,0x1},
      {ATTR_SP,C_PUSH,D__erDX,D__NONE,D__NONE,"PUSH",0x52,0x1,0x1},
      {ATTR_SP,C_PUSH,D__erBX,D__NONE,D__NONE,"PUSH",0x53,0x1,0x1},
      {ATTR_SP,C_PUSH,D__erSP,D__NONE,D__NONE,"PUSH",0x54,0x1,0x1},
      {ATTR_SP,C_PUSH,D__erBP,D__NONE,D__NONE,"PUSH",0x55,0x1,0x1},
      {ATTR_SP,C_PUSH,D__erSI,D__NONE,D__NONE,"PUSH",0x56,0x1,0x1},
      {ATTR_SP,C_PUSH,D__erDI,D__NONE,D__NONE,"PUSH",0x57,0x1,0x1},
      {ATTR_SP,C_POP,D__erAX,D__NONE,D__NONE,"POP",0x58,0x1,0x2},
      {ATTR_SP,C_POP,D__erCX,D__NONE,D__NONE,"POP",0x59,0x1,0x2},
      {ATTR_SP,C_POP,D__erDX,D__NONE,D__NONE,"POP",0x5a,0x1,0x2},
      {ATTR_SP,C_POP,D__erBX,D__NONE,D__NONE,"POP",0x5b,0x1,0x2},
      {ATTR_SP,C_POP,D__erSP,D__NONE,D__NONE,"POP",0x5c,0x1,0x2},
      {ATTR_SP,C_POP,D__erBP,D__NONE,D__NONE,"POP",0x5d,0x1,0x2},
      {ATTR_SP,C_POP,D__erSI,D__NONE,D__NONE,"POP",0x5e,0x1,0x2},
      {ATTR_SP,C_POP,D__erDI,D__NONE,D__NONE,"POP",0x5f,0x1,0x2},
      {ATTR_X64_INVALID,C_PUSHA,D__NONE,D__NONE,D__NONE,"PUSHA",0x60,0x1,0x1},
      {ATTR_X64_INVALID,C_POPA,D__NONE,D__NONE,D__NONE,"POPA",0x61,0x1,0x2},
      {ATTR_MODRM|ATTR_X64_INVALID,C_BOUND,D__Gv,D_rMa,D__NONE,"BOUND",0x62,0x1,0x5},
      {ATTR_MODRM,C_GRPX64,D__NONE,D__NONE,D__NONE,(const char*)Group0x63,0x63,0x1,0x0},
      {0,C_FS,D__NONE,D__NONE,D__NONE,"FS:",0x64,0x1,0x0},
      {0,C_GS,D__NONE,D__NONE,D__NONE,"GS:",0x65,0x1,0x0},
      {0,C_OPER,D__AH,D__Cd,D__NONE,0,0x0,0x0,0x0},
      {0,C_ADDR,D__CH,D__Cd,D__NONE,0,0x0,0x0,0x0},
      {ATTR_X64|ATTR_SP,C_PUSH,D__Iz,D__NONE,D__NONE,"PUSH",0x68,0x1,0x1},
      {ATTR_X64|ATTR_MODRM,C_IMUL,D__Gv,D_rEv,D__Iz,"IMUL",0x69,0x1,0x17},
      {ATTR_D|ATTR_SP,C_PUSH,D_sIb,D__NONE,D__NONE,"PUSH",0x6a,0x1,0x1},
      {ATTR_D|ATTR_MODRM,C_IMUL,D__Gv,D_rEv,D_sIb,"IMUL",0x6b,0x1,0x17},
      {0,C_INS,D__Yb,D__DX,D__NONE,"INS",0x6c,0x1,0x6},
      {0,C_INS,D__Yz,D__DX,D__NONE,"INS",0x6d,0x1,0x6},
      {0,C_OUTS,D__DX,D__Xb,D__NONE,"OUTS",0x6e,0x1,0x5},
      {0,C_OUTS,D__DX,D__Xz,D__NONE,"OUTS",0x6f,0x1,0x5},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JtO,D__Jb,D__tO,D__NONE,"JO",0x70,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JfO,D__Jb,D__fO,D__NONE,"JNO",0x71,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JtC,D__Jb,D__tC,D__NONE,"JC",0x72,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JfC,D__Jb,D__fC,D__NONE,"JNC",0x73,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JtZ,D__Jb,D__tZ,D__NONE,"JZ",0x74,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JfZ,D__Jb,D__fZ,D__NONE,"JNZ",0x75,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JfA,D__Jb,D__fA,D__NONE,"JNA",0x76,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JtA,D__Jb,D__tA,D__NONE,"JA",0x77,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JfS,D__Jb,D__tS,D__NONE,"JS",0x78,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JtS,D__Jb,D__fS,D__NONE,"JNS",0x79,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JtP,D__Jb,D__tP,D__NONE,"JP",0x7a,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JfP,D__Jb,D__fP,D__NONE,"JNP",0x7b,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JtL,D__Jb,D__tL,D__NONE,"JL",0x7c,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JfL,D__Jb,D__fL,D__NONE,"JNL",0x7d,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JfG,D__Jb,D__fG,D__NONE,"JNG",0x7e,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JtG,D__Jb,D__tG,D__NONE,"JG",0x7f,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRP,D__Eb,D__Ib,D__NONE,(const char*)GroupG1_80,0x80,0x1,0x0},
      {ATTR_X64|ATTR_MODRM,C_GRP,D__Ev,D__Iz,D__NONE,(const char*)GroupG1_81,0x81,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRP,D__Eb,D__Ib,D__NONE,(const char*)GroupG1_82,0x82,0x1,0x0},
      {ATTR_D|ATTR_MODRM,C_GRP,D__Ev,D_sIb,D__NONE,(const char*)GroupG1_83,0x83,0x1,0x0},
      {ATTR_MODRM,C_TEST,D_rEb,D__Gb,D__NONE,"TEST",0x84,0x1,0x5},
      {ATTR_MODRM,C_TEST,D_rEv,D__Gv,D__NONE,"TEST",0x85,0x1,0x5},
      {ATTR_MODRM,C_XCHG,D__Gb,D__Eb,D__NONE,"XCHG",0x86,0x1,0xf},
      {ATTR_MODRM,C_XCHG,D__Gv,D__Ev,D__NONE,"XCHG",0x87,0x1,0xf},
      {ATTR_MODRM,C_MOV,D_wEb,D__Gb,D__NONE,"MOV",0x88,0x1,0x6},
      {ATTR_MODRM,C_MOV,D_wEv,D__Gv,D__NONE,"MOV",0x89,0x1,0x6},
      {ATTR_MODRM,C_MOV,D__Gb,D_rEb,D__NONE,"MOV",0x8a,0x1,0x6},
      {ATTR_MODRM,C_MOV,D__Gv,D_rEv,D__NONE,"MOV",0x8b,0x1,0x6},
      {ATTR_MODRM,C_MOV,D_wEw,D__Sw,D__NONE,"MOV",0x8c,0x1,0x6},
      {ATTR_MODRM,C_LEA,D__Gv,D__M,D__NONE,"LEA",0x8d,0x1,0x6},
      {ATTR_MODRM,C_MOV,D__Sw,D_rEw,D__NONE,"MOV",0x8e,0x1,0x6},
      {ATTR_MODRM,C_GRP,D__Ev,D__NONE,D__NONE,(const char*)GroupG1_8f,0x8f,0x1,0x0},
      {0,_C_XCHG,D__rAX,D__erAX,D__NONE,"XCHG",0x90,0x1,0x0},
      {0,C_XCHG,D__rAX,D__erCX,D__NONE,"XCHG",0x91,0x1,0xf},
      {0,C_XCHG,D__rAX,D__erDX,D__NONE,"XCHG",0x92,0x1,0xf},
      {0,C_XCHG,D__rAX,D__erBX,D__NONE,"XCHG",0x93,0x1,0xf},
      {0,C_XCHG,D__rAX,D__erSP,D__NONE,"XCHG",0x94,0x1,0xf},
      {0,C_XCHG,D__rAX,D__erBP,D__NONE,"XCHG",0x95,0x1,0xf},
      {0,C_XCHG,D__rAX,D__erSI,D__NONE,"XCHG",0x96,0x1,0xf},
      {0,C_XCHG,D__rAX,D__erDI,D__NONE,"XCHG",0x97,0x1,0xf},
      {0,C_CBW,D__NONE,D__NONE,D__NONE,"CBW",0x98,0x1,0x0},
      {0,C_CWD,D__NONE,D__NONE,D__NONE,"CWD",0x99,0x1,0x0},
      {ATTR_B|ATTR_X64|ATTR_X64_INVALID,C_CALL,D__Ap,D__NONE,D__NONE,"CALL",0x9a,0x1,0x1},
      {0,C_WAIT,D__NONE,D__NONE,D__NONE,"WAIT",0x9b,0x1,0x0},
      {ATTR_SP,C_PUSHF,D__Fv,D__NONE,D__NONE,"PUSHF",0x9c,0x1,0x1},
      {ATTR_SP,C_POPF,D__Fv,D__NONE,D__NONE,"POPF",0x9d,0x1,0x2},
      {0,C_SAHF,D__NONE,D__NONE,D__NONE,"SAHF",0x9e,0x1,0x0},
      {0,C_LAHF,D__NONE,D__NONE,D__NONE,"LAHF",0x9f,0x1,0x0},
      {0,C_MOV,D__AL,D_rOb,D__NONE,"MOV",0xa0,0x1,0x6},
      {0,C_MOV,D__rAX,D_rOv,D__NONE,"MOV",0xa1,0x1,0x6},
      {0,C_MOV,D_wOb,D__AL,D__NONE,"MOV",0xa2,0x1,0x6},
      {0,C_MOV,D_wOv,D__rAX,D__NONE,"MOV",0xa3,0x1,0x6},
      {0,C_MOVS,D_wYb,D_rXb,D__NONE,"MOVS",0xa4,0x1,0x6},
      {0,C_MOVS,D_wYv,D_rXv,D__NONE,"MOVS",0xa5,0x1,0x6},
      {0,C_CMPS,D_rXb,D_rYb,D__NONE,"CMPS",0xa6,0x1,0x5},
      {0,C_CMPS,D_rXv,D_rYv,D__NONE,"CMPS",0xa7,0x1,0x5},
      {ATTR_B|ATTR_W,C_TEST,D__AL,D__Ib,D__NONE,"TEST",0xa8,0x1,0x5},
      {ATTR_X64,C_TEST,D__rAX,D__Iz,D__NONE,"TEST",0xa9,0x1,0x5},
      {0,C_STOS,D_wYb,D__AL,D__NONE,"STOS",0xaa,0x1,0x6},
      {0,C_STOS,D_wYv,D__rAX,D__NONE,"STOS",0xab,0x1,0x6},
      {0,C_LODS,D__AL,D_rXb,D__NONE,"LODS",0xac,0x1,0x6},
      {0,C_LODS,D__rAX,D_rXv,D__NONE,"LODS",0xad,0x1,0x6},
      {0,C_SCAS,D_rYb,D__AL,D__NONE,"SCAS",0xae,0x1,0x5},
      {0,C_SCAS,D_rYv,D__rAX,D__NONE,"SCAS",0xaf,0x1,0x5},
      {ATTR_B|ATTR_W,C_MOV,D__RAL,D__Ib,D__NONE,"MOV",0xb0,0x1,0x6},
      {ATTR_B|ATTR_W,C_MOV,D__RCL,D__Ib,D__NONE,"MOV",0xb1,0x1,0x6},
      {ATTR_B|ATTR_W,C_MOV,D__RDL,D__Ib,D__NONE,"MOV",0xb2,0x1,0x6},
      {ATTR_B|ATTR_W,C_MOV,D__RBL,D__Ib,D__NONE,"MOV",0xb3,0x1,0x6},
      {ATTR_B|ATTR_W,C_MOV,D__RAH,D__Ib,D__NONE,"MOV",0xb4,0x1,0x6},
      {ATTR_B|ATTR_W,C_MOV,D__RCH,D__Ib,D__NONE,"MOV",0xb5,0x1,0x6},
      {ATTR_B|ATTR_W,C_MOV,D__RDH,D__Ib,D__NONE,"MOV",0xb6,0x1,0x6},
      {ATTR_B|ATTR_W,C_MOV,D__RBH,D__Ib,D__NONE,"MOV",0xb7,0x1,0x6},
      {ATTR_W|ATTR_D,C_MOV,D__erAX,D__Iv,D__NONE,"MOV",0xb8,0x1,0x6},
      {ATTR_W|ATTR_D,C_MOV,D__erCX,D__Iv,D__NONE,"MOV",0xb9,0x1,0x6},
      {ATTR_W|ATTR_D,C_MOV,D__erDX,D__Iv,D__NONE,"MOV",0xba,0x1,0x6},
      {ATTR_W|ATTR_D,C_MOV,D__erBX,D__Iv,D__NONE,"MOV",0xbb,0x1,0x6},
      {ATTR_W|ATTR_D,C_MOV,D__erSP,D__Iv,D__NONE,"MOV",0xbc,0x1,0x6},
      {ATTR_W|ATTR_D,C_MOV,D__erBP,D__Iv,D__NONE,"MOV",0xbd,0x1,0x6},
      {ATTR_W|ATTR_D,C_MOV,D__erSI,D__Iv,D__NONE,"MOV",0xbe,0x1,0x6},
      {ATTR_W|ATTR_D,C_MOV,D__erDI,D__Iv,D__NONE,"MOV",0xbf,0x1,0x6},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRP,D__NONE,D__NONE,D__NONE,(const char*)GroupG2Eb,0xc0,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_MODRM,C_GRP,D__NONE,D__NONE,D__NONE,(const char*)GroupG2Ew,0xc1,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_JMP,C_RET,D__Iw,D__NONE,D__NONE,"RET",0xc2,0x1,0x1},
      {ATTR_JMP,C_RET,D__NONE,D__NONE,D__NONE,"RET",0xc3,0x1,0x0},
      {ATTR_MODRM|ATTR_X64_INVALID,C_LES,D__Gv,D_rMp,D__NONE,"LES",0xc4,0x1,0x6},
      {ATTR_MODRM|ATTR_X64_INVALID,C_LDS,D__Gv,D_rMp,D__NONE,"LDS",0xc5,0x1,0x6},
      {ATTR_MODRM,C_GRP,D__NONE,D__NONE,D__NONE,(const char*)GroupG11Eb,0xc6,0x1,0x0},
      {ATTR_MODRM,C_GRP,D__NONE,D__NONE,D__NONE,(const char*)GroupG11Ew,0xc7,0x1,0x0},
      {ATTR_W|ATTR_X64,C_ENTER,D__Iw,D__Ib,D__NONE,"ENTER",0xc8,0x1,0x5},
      {ATTR_SP,C_LEAVE,D__NONE,D__NONE,D__NONE,"LEAVE",0xc9,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D,C_RETF,D__Iw,D__NONE,D__NONE,"RETF",0xca,0x1,0x1},
      {0,C_RETF,D__NONE,D__NONE,D__NONE,"RETF",0xcb,0x1,0x0},
      {0,C_INT3,D__NONE,D__NONE,D__NONE,"INT3",0xcc,0x1,0x0},
      {ATTR_B|ATTR_W,C_INT,D__Ib,D__NONE,D__NONE,"INT",0xcd,0x1,0x1},
      {ATTR_X64_INVALID,C_INTO,D__NONE,D__NONE,D__NONE,"INTO",0xce,0x1,0x0},
      {0,C_IRET,D__NONE,D__NONE,D__NONE,"IRET",0xcf,0x1,0x0},
      {ATTR_MODRM,C_GRP,D__Eb,D__1,D__NONE,(const char*)GroupG2EbI1,0xd0,0x1,0x0},
      {ATTR_MODRM,C_GRP,D__Ev,D__1,D__NONE,(const char*)GroupG2EvI1,0xd1,0x1,0x0},
      {ATTR_MODRM,C_GRP,D__Eb,D__CL,D__NONE,(const char*)GroupG2EbCL,0xd2,0x1,0x0},
      {ATTR_MODRM,C_GRP,D__Ev,D__CL,D__NONE,(const char*)GroupG2EvCL,0xd3,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_X64_INVALID,C_AAM,D__Ib,D__NONE,D__NONE,"AAM",0xd4,0x1,0x1},
      {ATTR_B|ATTR_W|ATTR_X64_INVALID,C_AAD,D__Ib,D__NONE,D__NONE,"AAD",0xd5,0x1,0x1},
      {0,C_SALC,D__NONE,D__NONE,D__NONE,"SALC",0xd6,0x1,0x0},
      {0,C_XLAT,D__NONE,D__NONE,D__NONE,"XLAT",0xd7,0x1,0x0},
      {ATTR_MODRM,C_ESC,D__NONE,D__NONE,D__NONE,(const char*)FPGroupd8,0xd8,0x1,0x0},
      {ATTR_MODRM,C_ESC,D__NONE,D__NONE,D__NONE,(const char*)FPGroupd9,0xd9,0x1,0x0},
      {ATTR_MODRM,C_ESC,D__NONE,D__NONE,D__NONE,(const char*)FPGroupda,0xda,0x1,0x0},
      {ATTR_MODRM,C_ESC,D__NONE,D__NONE,D__NONE,(const char*)FPGroupdb,0xdb,0x1,0x0},
      {ATTR_MODRM,C_ESC,D__NONE,D__NONE,D__NONE,(const char*)FPGroupdc,0xdc,0x1,0x0},
      {ATTR_MODRM,C_ESC,D__NONE,D__NONE,D__NONE,(const char*)FPGroupdd,0xdd,0x1,0x0},
      {ATTR_MODRM,C_ESC,D__NONE,D__NONE,D__NONE,(const char*)FPGroupde,0xde,0x1,0x0},
      {ATTR_MODRM,C_ESC,D__NONE,D__NONE,D__NONE,(const char*)FPGroupdf,0xdf,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_LOOPNZ,D__Jb,D__NONE,D__NONE,"LOOPNZ",0xe0,0x1,0x1},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_LOOPZ,D__Jb,D__NONE,D__NONE,"LOOPZ",0xe1,0x1,0x1},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_LOOP,D__Jb,D__NONE,D__NONE,"LOOP",0xe2,0x1,0x1},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_JCXZ,D__Jb,D__NONE,D__NONE,"JCXZ",0xe3,0x1,0x1},
      {ATTR_B|ATTR_W,C_IN,D__AL,D__Ib,D__NONE,"IN",0xe4,0x1,0x6},
      {ATTR_B|ATTR_W,C_IN,D__eAX,D__Ib,D__NONE,"IN",0xe5,0x1,0x6},
      {ATTR_B|ATTR_W,C_OUT,D__Ib,D__AL,D__NONE,"OUT",0xe6,0x1,0x5},
      {ATTR_B|ATTR_W,C_OUT,D__Ib,D__eAX,D__NONE,"OUT",0xe7,0x1,0x5},
      {ATTR_JMP,C_CALL,D__Jz,D__NONE,D__NONE,"CALL",0xe8,0x1,0x1},
      {ATTR_JMP,C_JMP,D__Jz,D__NONE,D__NONE,"JMP",0xe9,0x1,0x1},
      {ATTR_B|ATTR_X64|ATTR_X64_INVALID,C_JMP,D__Ap,D__NONE,D__NONE,"JMP",0xea,0x1,0x1},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64|ATTR_JMP,C_JMP,D__Jb,D__NONE,D__NONE,"JMP",0xeb,0x1,0x1},
      {0,C_IN,D__AL,D__DX,D__NONE,"IN",0xec,0x1,0x6},
      {0,C_IN,D__eAX,D__DX,D__NONE,"IN",0xed,0x1,0x6},
      {0,C_OUT,D__DX,D__AL,D__NONE,"OUT",0xee,0x1,0x5},
      {0,C_OUT,D__DX,D__eAX,D__NONE,"OUT",0xef,0x1,0x5},
      {0,C_LOCK,D__NONE,D__NONE,D__NONE,"LOCK",0xf0,0x1,0x0},
      {0,C_INT1,D__NONE,D__NONE,D__NONE,"INT1",0xf1,0x1,0x0},
      {0,C_REPN,D__NONE,D__NONE,D__NONE,"REPNE",0xf2,0x1,0x0},
      {0,C_REPZ,D__NONE,D__NONE,D__NONE,"REP",0xf3,0x1,0x0},
      {0,C_HLT,D__NONE,D__NONE,D__NONE,"HLT",0xf4,0x1,0x0},
      {0,C_CMC,D__NONE,D__NONE,D__NONE,"CMC",0xf5,0x1,0x0},
      {ATTR_MODRM,C_GRP,D__Eb,D__NONE,D__NONE,(const char*)GroupG3Eb,0xf6,0x1,0x0},
      {ATTR_MODRM,C_GRP,D__Ev,D__NONE,D__NONE,(const char*)GroupG3Ev,0xf7,0x1,0x0},
      {0,C_CLC,D__NONE,D__NONE,D__NONE,"CLC",0xf8,0x1,0x0},
      {0,C_STC,D__NONE,D__NONE,D__NONE,"STC",0xf9,0x1,0x0},
      {0,C_CLI,D__NONE,D__NONE,D__NONE,"CLI",0xfa,0x1,0x0},
      {0,C_STI,D__NONE,D__NONE,D__NONE,"STI",0xfb,0x1,0x0},
      {0,C_CLD,D__NONE,D__NONE,D__NONE,"CLD",0xfc,0x1,0x0},
      {0,C_STD,D__NONE,D__NONE,D__NONE,"STD",0xfd,0x1,0x0},
      {ATTR_MODRM,C_GRP,D__Eb,D__NONE,D__NONE,(const char*)GroupG4,0xfe,0x1,0x0},
      {ATTR_MODRM,C_GRP,D__Ev,D__NONE,D__NONE,(const char*)GroupG5v,0xff,0x1,0x0},
      {ATTR_MODRM,C_INS,D__Yb,D__DX,D__NONE,"INSB",0x6c,0x1,0x6},
      {ATTR_MODRM,C_INS,D__Yw,D__DX,D__NONE,"INSW",0x6d,0x1,0x6},
      {ATTR_MODRM,C_INS,D__Yd,D__DX,D__NONE,"INSD",0x6d,0x1,0x6},
      {ATTR_MODRM,C_OUTS,D__DX,D__Xb,D__NONE,"OUTSB",0x6e,0x1,0x5},
      {ATTR_MODRM,C_OUTS,D__DX,D__Xw,D__NONE,"OUTSW",0x6f,0x1,0x5},
      {ATTR_MODRM,C_OUTS,D__DX,D__Xd,D__NONE,"OUTSD",0x6f,0x1,0x5},
      {ATTR_SP,C_PUSHF,D__NONE,D__NONE,D__NONE,"PUSHFD",0x9c,0x1,0x1},
      {ATTR_SP,C_POPF,D__NONE,D__NONE,D__NONE,"POPFD",0x9d,0x1,0x2},
      {0,C_PUSHA,D__NONE,D__NONE,D__NONE,"PUSHAD",0x60,0x1,0x1},
      {0,C_POPA,D__NONE,D__NONE,D__NONE,"POPAD",0x61,0x1,0x2},
      {ATTR_MODRM,C_MOVS,D__Yb,D__NONE,D__NONE,"MOVSB",0xa4,0x1,0x6},
      {ATTR_MODRM,C_MOVS,D__Yw,D__NONE,D__NONE,"MOVSW",0xa5,0x1,0x6},
      {ATTR_MODRM,C_MOVS,D__Yd,D__NONE,D__NONE,"MOVSD",0xa5,0x1,0x6},
      {ATTR_MODRM,C_MOVS,D__Yd,D__NONE,D__NONE,"MOVSQ",0xa5,0x1,0x6},
      {ATTR_MODRM,C_CMPS,D__Yb,D__NONE,D__NONE,"CMPSB",0xa6,0x1,0x5},
      {ATTR_MODRM,C_CMPS,D__Yw,D__NONE,D__NONE,"CMPSW",0xa7,0x1,0x5},
      {ATTR_MODRM,C_CMPS,D__Yd,D__NONE,D__NONE,"CMPSD",0xa7,0x1,0x5},
      {ATTR_MODRM,C_CMPS,D__Yd,D__NONE,D__NONE,"CMPSQ",0xa7,0x1,0x5},
      {ATTR_MODRM,C_STOS,D__Yb,D__NONE,D__NONE,"STOSB",0xaa,0x1,0x2},
      {ATTR_MODRM,C_STOS,D__Yw,D__NONE,D__NONE,"STOSW",0xab,0x1,0x2},
      {ATTR_MODRM,C_STOS,D__Yd,D__NONE,D__NONE,"STOSD",0xab,0x1,0x2},
      {ATTR_MODRM,C_STOS,D__Yd,D__NONE,D__NONE,"STOSQ",0xab,0x1,0x2},
      {ATTR_MODRM,C_LODS,D__AL,D__Xb,D__NONE,"LODSB",0xac,0x1,0x6},
      {ATTR_MODRM,C_LODS,D__AX,D__Xw,D__NONE,"LODSW",0xad,0x1,0x6},
      {ATTR_MODRM,C_LODS,D__EAX,D__Xd,D__NONE,"LODSD",0xad,0x1,0x6},
      {ATTR_MODRM,C_LODS,D__EAX,D__Xd,D__NONE,"LODSQ",0xad,0x1,0x6},
      {ATTR_MODRM,C_SCAS,D__Yb,D__NONE,D__NONE,"SCASB",0xae,0x1,0x5},
      {ATTR_MODRM,C_SCAS,D__Yw,D__NONE,D__NONE,"SCASW",0xaf,0x1,0x5},
      {ATTR_MODRM,C_SCAS,D__Yd,D__NONE,D__NONE,"SCASD",0xaf,0x1,0x5},
      {ATTR_MODRM,C_SCAS,D__Yd,D__NONE,D__NONE,"SCASQ",0xaf,0x1,0x5},
      {0,C_XLAT,D__NONE,D__NONE,D__NONE,"XLATB",0xd7,0x1,0x0},
      {0,C_REPN,D__NONE,D__NONE,D__NONE,"REPNZ",0xf2,0x1,0x0},
      {0,C_REPZ,D__NONE,D__NONE,D__NONE,"REPZ",0xf3,0x1,0x0},
      {0,C_REPZ,D__NONE,D__NONE,D__NONE,"REPE",0xf3,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_JtC,D__Jb,D__NONE,D__NONE,"JB",0x72,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_JtC,D__Jb,D__NONE,D__NONE,"JNAE",0x72,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_JfC,D__Jb,D__NONE,D__NONE,"JAE",0x73,0x1,0x0},
      {ATTR_B|ATTR_W,C_JfC,D__Jb,D__NONE,D__NONE,"JNB",0x73,0x1,0x0},
      {ATTR_B|ATTR_W,C_JtZ,D__Jb,D__NONE,D__NONE,"JE",0x74,0x1,0x0},
      {ATTR_B|ATTR_W,C_JfZ,D__Jb,D__NONE,D__NONE,"JNE",0x75,0x1,0x0},
      {ATTR_B|ATTR_W,C_JfA,D__Jb,D__NONE,D__NONE,"JBE",0x76,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_JtA,D__Jb,D__NONE,D__NONE,"JNBE",0x77,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_JtP,D__Jb,D__NONE,D__NONE,"JPE",0x7a,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_JfP,D__Jb,D__NONE,D__NONE,"JPO",0x7b,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_JtL,D__Jb,D__NONE,D__NONE,"JNGE",0x7c,0x1,0x0},
      {ATTR_B|ATTR_W,C_JfL,D__Jb,D__NONE,D__NONE,"JGE",0x7d,0x1,0x0},
      {ATTR_B|ATTR_W,C_JfG,D__Jb,D__NONE,D__NONE,"JLE",0x7e,0x1,0x0},
      {ATTR_B|ATTR_W,C_JtG,D__Jb,D__NONE,D__NONE,"JNLE",0x7f,0x1,0x0},
      {ATTR_JMP,C_JtC,D__Jz,D__tC,D__NONE,"JB",0x820f,0x2,0x0},
      {ATTR_JMP,C_JtC,D__Jz,D__tC,D__NONE,"JNAE",0x820f,0x2,0x0},
      {ATTR_JMP,C_JfC,D__Jz,D__fC,D__NONE,"JNB",0x830f,0x2,0x0},
      {ATTR_JMP,C_JfC,D__Jz,D__fC,D__NONE,"JAE",0x830f,0x2,0x0},
      {ATTR_JMP,C_JtZ,D__Jz,D__tZ,D__NONE,"JE",0x840f,0x2,0x0},
      {ATTR_JMP,C_JfZ,D__Jz,D__fZ,D__NONE,"JNE",0x850f,0x2,0x0},
      {ATTR_JMP,C_JfA,D__Jz,D__fA,D__NONE,"JBE",0x860f,0x2,0x0},
      {ATTR_JMP,C_JtA,D__Jz,D__tA,D__NONE,"JNBE",0x870f,0x2,0x0},
      {ATTR_JMP,C_JtP,D__Jz,D__tP,D__NONE,"JPE",0x8a0f,0x2,0x0},
      {ATTR_JMP,C_JfP,D__Jz,D__tS,D__NONE,"JPO",0x8b0f,0x2,0x0},
      {ATTR_JMP,C_JtL,D__Jz,D__tL,D__NONE,"JNGE",0x8c0f,0x2,0x0},
      {ATTR_JMP,C_JfL,D__Jz,D__fL,D__NONE,"JGE",0x8d0f,0x2,0x0},
      {ATTR_JMP,C_JfG,D__Jz,D__fG,D__NONE,"JLE",0x8e0f,0x2,0x0},
      {ATTR_JMP,C_JtG,D__Jz,D__tG,D__NONE,"JNLE",0x8f0f,0x2,0x0},
      {ATTR_MODRM,C_SETtC,D_wEb,D__tC,D__NONE,"SETB",0x920f,0x2,0x1},
      {ATTR_MODRM,C_SETtC,D_wEb,D__tC,D__NONE,"SETNAE",0x920f,0x2,0x1},
      {ATTR_MODRM,C_SETfC,D_wEb,D__fC,D__NONE,"SETNB",0x930f,0x2,0x1},
      {ATTR_MODRM,C_SETfC,D_wEb,D__fC,D__NONE,"SETAE",0x930f,0x2,0x1},
      {ATTR_MODRM,C_SETtZ,D_wEb,D__tZ,D__NONE,"SETE",0x940f,0x2,0x1},
      {ATTR_MODRM,C_SETfZ,D_wEb,D__fZ,D__NONE,"SETNE",0x950f,0x2,0x1},
      {ATTR_MODRM,C_SETfA,D_wEb,D__fA,D__NONE,"SETBE",0x960f,0x2,0x1},
      {ATTR_MODRM,C_SETtA,D_wEb,D__tA,D__NONE,"SETNBE",0x970f,0x2,0x1},
      {ATTR_MODRM,C_SETtP,D_wEb,D__tP,D__NONE,"SETPE",0x9a0f,0x2,0x1},
      {ATTR_MODRM,C_SETfP,D_wEb,D__tS,D__NONE,"SETPO",0x9b0f,0x2,0x1},
      {ATTR_MODRM,C_SETtL,D_wEb,D__tL,D__NONE,"SETNGE",0x9c0f,0x2,0x1},
      {ATTR_MODRM,C_SETfL,D_wEb,D__fL,D__NONE,"SETGE",0x9d0f,0x2,0x1},
      {ATTR_MODRM,C_SETfG,D_wEb,D__fG,D__NONE,"SETLE",0x9e0f,0x2,0x1},
      {ATTR_MODRM,C_SETtG,D_wEb,D__tG,D__NONE,"SETNLE",0x9f0f,0x2,0x1},
      {ATTR_MODRM,C_CMOVtC,D__Gv,D_rEv,D__tC,"CMOVNAE",0x420f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtC,D__Gv,D_rEv,D__tC,"CMOVC",0x420f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfC,D__Gv,D_rEv,D__fC,"CMOVNC",0x430f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfC,D__Gv,D_rEv,D__fC,"CMOVAE",0x430f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtZ,D__Gv,D_rEv,D__tZ,"CMOVE",0x440f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfZ,D__Gv,D_rEv,D__fZ,"CMOVNE",0x450f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfA,D__Gv,D_rEv,D__fA,"CMOVNA",0x460f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtA,D__Gv,D_rEv,D__tA,"CMOVNBE",0x470f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtP,D__Gv,D_rEv,D__tP,"CMOVPE",0x4a0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfP,D__Gv,D_rEv,D__tS,"CMOVPO",0x4b0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtL,D__Gv,D_rEv,D__tL,"CMOVNGE",0x4c0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfL,D__Gv,D_rEv,D__fL,"CMOVNL",0x4d0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVfG,D__Gv,D_rEv,D__fG,"CMOVNG",0x4e0f,0x2,0x7},
      {ATTR_MODRM,C_CMOVtG,D__Gv,D_rEv,D__tG,"CMOVNLE",0x4f0f,0x2,0x7},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_LOOPNZ,D__Jb,D__NONE,D__NONE,"LOOPNE",0xe0,0x1,0x0},
      {ATTR_B|ATTR_W|ATTR_D|ATTR_X64,C_LOOPZ,D__Jb,D__NONE,D__NONE,"LOOPE",0xe1,0x1,0x0},
      {0,C_NOP,D__NONE,D__NONE,D__NONE,"NOP",0x90,0x1,0x0},
      {ATTR_MODRM,C_DBYTE,D_DBYTE,D__NONE,D__NONE,"DB",0x0,0x0,0x0},
      {ATTR_MODRM,C_DWORD,D_DWORD,D__NONE,D__NONE,"DW",0x0,0x0,0x0},
      {ATTR_MODRM,C_DDWORD,D_DDWORD,D__NONE,D__NONE,"DD",0x0,0x0,0x0},
      {ATTR_MODRM,C_DBYTE,D_STRING,D__NONE,D__NONE,"DB",0x0,0x0,0x0},
      {0,C_TAIL,D__NONE,D__NONE,D__NONE,"",0x0,0x0,0x0},
};

#define SSE_PREFIX_NONE 0
#define SSE_PREFIX_66   1
#define SSE_PREFIX_F3   3
#define SSE_PREFIX_F2   2

#define OPCODE(entry) ((_DIS_OPCODE_T*)(entry)->name)

#define MODRM_REG(x) (((x)>>3)&0x7)

//extern
int Disassembly(_INSTRUCTION_INFORMATION *pInstInfo, unsigned char *inbuff, unsigned long long eip, int mode, DIS_CPU *DisCPU)
{

	DIS_CPU DisCPU_T;
	if (!DisCPU)
		DisCPU = &DisCPU_T;

	unsigned int ByteCount = 0;
	unsigned int Segment = -1;

	_DISP_INSTRUCTION_T disp_i;
	disp_i.opcount = 1;
	disp_i.as_32 = mode;
	disp_i.os_32 = mode;
	disp_i.osx_32 = mode;
	if (mode == CODE_MODE_64)
		disp_i.os_32 = CODE_MODE_32;

	int os_32 = disp_i.os_32;

	disp_i.rep_used = -1;
	disp_i.lock = -1;
	disp_i.x64 = 0;
	disp_i.sse_prefix = SSE_PREFIX_NONE;
	disp_i.prefixes = 0;
	disp_i.regrm = -1;
	disp_i.sib1 = -1;
	disp_i.rex_prefix = 0;

	pInstInfo->AMD3DNow = -1;

	_DIS_OPCODE_T *pIntelOpcode;

	for (;;)
	{
		if (ByteCount >= 15)
			return 0;

		disp_i.b1 = inbuff[ByteCount++];
		pIntelOpcode = &Group_main[disp_i.b1];

		if (mode == CODE_MODE_64 && disp_i.b1 >= 0x40 && disp_i.b1 <= 0x4F)// INC DEC
		{
			disp_i.rex_prefix = disp_i.b1;
			pIntelOpcode = &Group_main[sizeof(Group_main)/sizeof(Group_main[0])-1];
		}
	again:
		switch (pIntelOpcode->OpcodeType)
		{
		case C_ES:
		case C_CS:
		case C_SS:
		case C_DS:
		case C_FS:
		case C_GS:
			++disp_i.prefixes;
			Segment = pIntelOpcode->OpcodeType - 1;
			disp_i.rex_prefix = 0;
			disp_i.sse_prefix = SSE_PREFIX_NONE;
			continue;
		case C_TAIL:
			++disp_i.prefixes;
			if (disp_i.rex_prefix & 8)
			{
				disp_i.os_32 = CODE_MODE_64;
				os_32 = CODE_MODE_64;
			}
			continue;
		case C_OPER:
			if (mode == CODE_MODE_16)
				disp_i.os_32 = CODE_MODE_32;
			else
			if (mode == CODE_MODE_32)
				disp_i.os_32 = CODE_MODE_16;
			else
			if (mode == CODE_MODE_64)
				disp_i.os_32 = CODE_MODE_16;
			++disp_i.prefixes;
			disp_i.sse_prefix = SSE_PREFIX_66;
			disp_i.rex_prefix = 0;
			continue;
		case C_ADDR:
			if (mode == CODE_MODE_16)
				disp_i.as_32 = CODE_MODE_32;
			else
			if (mode == CODE_MODE_32)
				disp_i.as_32 = CODE_MODE_16;
			else
			if (mode == CODE_MODE_64)
				disp_i.as_32 = CODE_MODE_32;
			++disp_i.prefixes;
			disp_i.sse_prefix = SSE_PREFIX_NONE;
			disp_i.rex_prefix = 0;
			continue;
		case C_LOCK:
			disp_i.lock = 0xF0;
			++disp_i.prefixes;
			disp_i.sse_prefix = SSE_PREFIX_NONE;
			disp_i.rex_prefix = 0;
			continue;
		case C_REPN:
			++disp_i.prefixes;
			disp_i.rep_used = 0xF2;
			disp_i.sse_prefix = SSE_PREFIX_F2;
			disp_i.rex_prefix = 0;
			continue;
		case C_REPZ:
			disp_i.rep_used = 0xF3;
			disp_i.sse_prefix = SSE_PREFIX_F3;
			++disp_i.prefixes;
			disp_i.rex_prefix = 0;
			continue;
		case C_GRP:
			pIntelOpcode = &(OPCODE(pIntelOpcode)[MODRM_REG((int)inbuff[ByteCount])]);
			break;
		case C_ESC:
			disp_i.opcount = 2;
			if ((int)inbuff[ByteCount] >= 0xC0)
				pIntelOpcode = &(OPCODE(pIntelOpcode)[inbuff[ByteCount++] - 0xB8]);
			else	pIntelOpcode = &(OPCODE(pIntelOpcode)[MODRM_REG((int)inbuff[ByteCount])]);
			break;
		case C_2BYTE:
			disp_i.opcount = 2;
			disp_i.b1 = inbuff[ByteCount++];
			pIntelOpcode = &(OPCODE(pIntelOpcode)[disp_i.b1]);
			goto again;
		case C_GRPMOD:
			if ((int)inbuff[ByteCount] >= 0xC0)
				pIntelOpcode = &(OPCODE(pIntelOpcode)[MODRM_REG((int)inbuff[ByteCount]) + 8]);
			else	pIntelOpcode = &(OPCODE(pIntelOpcode)[MODRM_REG((int)inbuff[ByteCount])]);
			break;
		case C_GRPRM:
			if ((int)inbuff[ByteCount] >= 0xC0)
				pIntelOpcode = &(OPCODE(pIntelOpcode)[MODRM_REG((int)inbuff[ByteCount]) * 8 + 8 + (inbuff[ByteCount] & 7)]);
			else	pIntelOpcode = &(OPCODE(pIntelOpcode)[MODRM_REG((int)inbuff[ByteCount])]);
			break;
		case C_3BYTE_1:
			disp_i.opcount = 3;
			disp_i.b1 = inbuff[ByteCount++];
			pIntelOpcode = &(OPCODE(pIntelOpcode)[disp_i.b1]);
			goto again;
		case C_3BYTE_2:
			disp_i.opcount = 3;
			disp_i.b1 = inbuff[ByteCount++];
			pIntelOpcode = &(OPCODE(pIntelOpcode)[disp_i.b1]);
			goto again;
		case C_GRPSSE:
			pIntelOpcode = &(OPCODE(pIntelOpcode)[disp_i.sse_prefix]);
			if (disp_i.sse_prefix == SSE_PREFIX_F2 ||
			    disp_i.sse_prefix == SSE_PREFIX_F3)
				disp_i.rep_used = -1;
			else
			if (disp_i.sse_prefix == SSE_PREFIX_66)
				disp_i.os_32 = os_32;
			break;
		case C_GRPSSEFIX:
			if ((int)inbuff[ByteCount] >= 0xC0)
				pIntelOpcode = &(OPCODE(pIntelOpcode)[disp_i.sse_prefix + 4]);
			else	pIntelOpcode = &(OPCODE(pIntelOpcode)[disp_i.sse_prefix]);
			if (disp_i.sse_prefix == SSE_PREFIX_F2 ||
			    disp_i.sse_prefix == SSE_PREFIX_F3)
				disp_i.rep_used = -1;
			else
			if (disp_i.sse_prefix == SSE_PREFIX_66)
				disp_i.os_32 = os_32;
			break;
		case C_GRP7:
			pIntelOpcode = &(OPCODE(pIntelOpcode)[MODRM_REG((int)inbuff[ByteCount])]);
			if (pIntelOpcode->OpcodeType == C_GRPSSE)
			{
				pIntelOpcode = &(OPCODE(pIntelOpcode)[disp_i.sse_prefix]);
				if (disp_i.sse_prefix == SSE_PREFIX_F2 ||
				    disp_i.sse_prefix == SSE_PREFIX_F3)
					disp_i.rep_used = -1;
				else
				if (disp_i.sse_prefix == SSE_PREFIX_66)
					disp_i.os_32 = os_32;
			}
			break;
		case C_GRPX64:
			if (mode == CODE_MODE_64)
				pIntelOpcode = OPCODE(pIntelOpcode)+1;
			else	pIntelOpcode = OPCODE(pIntelOpcode);
			break;
		default:
			break;
		}
		break;
	}

	if (!pIntelOpcode->name)
		return 0;

	if (pIntelOpcode->Attr & ATTR_X64_INVALID && mode == CODE_MODE_64)
		return 0;

	if (pIntelOpcode->Attr & ATTR_X64_ONLY && mode != CODE_MODE_64)
		return 0;

	if (pIntelOpcode->Attr & ATTR_SP && mode == CODE_MODE_64 && disp_i.os_32 == CODE_MODE_32)
		disp_i.os_32 = CODE_MODE_64;

	if (pIntelOpcode->Attr & ATTR_JMP && mode == CODE_MODE_64)
		disp_i.os_32 = CODE_MODE_64;

	disp_i.attr = pIntelOpcode->Attr;
	disp_i.destination = pIntelOpcode->Opdata1;
	disp_i.source = pIntelOpcode->Opdata2;
	disp_i.other = pIntelOpcode->Opdata3;

	if (disp_i.attr & ATTR_MODRM)
	{
		if (disp_i.as_32 == CODE_MODE_16)
			ByteCount += GetEffectAddress16Dis(DisCPU, &inbuff[ByteCount], &disp_i);
		else	ByteCount += GetEffectAddress32Dis(DisCPU, &inbuff[ByteCount], &disp_i);
	}

	ByteCount += ProcessOpdata_immde(disp_i.destination, &inbuff[ByteCount], &disp_i);
	ByteCount += ProcessOpdata_immde(disp_i.source, &inbuff[ByteCount], &disp_i);
	ByteCount += ProcessOpdata_immde(disp_i.other, &inbuff[ByteCount], &disp_i);
	
	if (ByteCount >= 15)
		return 0;

	disp_i.ilen = ByteCount;

	pInstInfo->OpCode = pIntelOpcode->OpcodeType;
	pInstInfo->OpType = 0;
	pInstInfo->CodeType = 0;
	pInstInfo->Length = disp_i.ilen;
	pInstInfo->Repeat = disp_i.rep_used;
	pInstInfo->Lock = disp_i.lock;
	pInstInfo->OpCount = disp_i.opcount;
	pInstInfo->Prefixes = disp_i.prefixes;
	pInstInfo->RegRM = disp_i.regrm;
	pInstInfo->Sib1 = disp_i.sib1;
	pInstInfo->RexPrefix = disp_i.rex_prefix;

	if (!ProcessName_dis(pInstInfo, pIntelOpcode, disp_i.os_32, disp_i.as_32))
		return 0;


        if (ProcessOpdata_dis(pIntelOpcode->Opdata1, &pInstInfo->op[0], eip, &disp_i, DisCPU) == -1)
		return 0;

        if (ProcessOpdata_dis(pIntelOpcode->Opdata2, &pInstInfo->op[1], eip, &disp_i, DisCPU) == -1)
		return 0;

        if (ProcessOpdata_dis(pIntelOpcode->Opdata3, &pInstInfo->op[2], eip, &disp_i, DisCPU) == -1)
		return 0;

	if (disp_i.seg == Segment || Segment == -1)
	{
		pInstInfo->SegmentPrefix = -1;
		for (int j = 0; j < 3; ++j)
		{
			if (pInstInfo->op[j].mode == OP_Address)
				pInstInfo->op[j].addr.line_address = pInstInfo->op[j].addr.effect_address + DisCPU->SEG_BASE[disp_i.seg];
		}
	} else
	{
		pInstInfo->SegmentPrefix = Segment;
		for (int j = 0; j < 3; ++j)
		{
			if (pInstInfo->op[j].mode == OP_Address)
				pInstInfo->op[j].addr.line_address = pInstInfo->op[j].addr.effect_address + DisCPU->SEG_BASE[Segment];
		}
	}

	pInstInfo->xxxxptr = -1;

	if (pInstInfo->OpCode == C_3DNOW)
	{
		if (!Group_amd3dnow[inbuff[ByteCount]].OpcodeType)
			return 0;
		if (!Group_amd3dnow[inbuff[ByteCount]].name)
			return 0;
		
		strcpy(pInstInfo->Name, (const char *)Group_amd3dnow[inbuff[ByteCount]].name);
		pInstInfo->OpCode = Group_amd3dnow[inbuff[ByteCount]].OpcodeType;
		pInstInfo->AMD3DNow = 1;
		++pInstInfo->Length;
		++ByteCount;
	}

	if (pInstInfo->OpCode == _C_XCHG)
	{
		if (pInstInfo->op[1].reg.reg_index == 0)
		{
			if (disp_i.sse_prefix == SSE_PREFIX_F3 && disp_i.rex_prefix == 0)
			{
				pInstInfo->OpCode = C_PAUSE;
				pInstInfo->Repeat = -1;
				strcpy(pInstInfo->Name, "PAUSE");
				pInstInfo->op[0].mode = OP_Invalid;
				pInstInfo->op[1].mode = OP_Invalid;
			} else
			if (pInstInfo->Prefixes == 0)
			{
				pInstInfo->OpCode = C_NOP;
				strcpy(pInstInfo->Name, "NOP");
				pInstInfo->op[0].mode = OP_Invalid;
				pInstInfo->op[1].mode = OP_Invalid;
			} else
			{
				pInstInfo->OpCode = C_XCHG;
			}
		} else
		{
			pInstInfo->OpCode = C_XCHG;
		}
	}

	if (pInstInfo->pasm)	
		pInstInfo->U_x3 = PrintPasm(pInstInfo, pInstInfo->pasm, pInstInfo->U_x1, pInstInfo->U_x2);
	TStrUpr(pInstInfo->Name); //TODO
	return ByteCount;
}

//extern
int Disassembly(char *pasm, unsigned char *inbuff, unsigned long long eip, int mode, int U_x1, int U_x2)
{
	DIS_CPU DisCPU;
	_INSTRUCTION_INFORMATION InstInfo;

	InstInfo.pasm = pasm;
	InstInfo.U_x1 = U_x1;
	InstInfo.U_x2 = U_x2;
	return Disassembly(&InstInfo, inbuff, eip, mode, &DisCPU);
}

int Assembly(const char *AsmString, unsigned char *CodeBuffer, unsigned long eip, int mode)
{
	//TODO
	return 0;
}

```

`source/EXEAnalyzer/inteldis.hpp`:

```hpp

#ifndef _INTELDIS_HPP_
#define _INTELDIS_HPP_

#include "../Code/define.h"

	enum
	{
		CODE_MODE_16 = 0,
		CODE_MODE_32 = 1,
		CODE_MODE_64 = 2,
	};

enum enum_1
{
  D__NONE = 0,
  D__Cd = 1,
  D__Dd = 2,
  D__Td = 3,
  D__Fv = 4,
  D__Gb = 5,
  D_rGb = 6,
  D_wGb = 7,
  D_dGb = 8,
  D__Gw = 9,
  D_rGw = 10,
  D_wGw = 11,
  D_dGw = 12,
  D__Gv = 13,
  D_rGv = 14,
  D_wGv = 15,
  D_dGv = 16,
  D__Gd = 17,
  D_rGd = 18,
  D_wGd = 19,
  D_dGd = 20,
  D__Gy = 21,
  D_rGy = 22,
  D_wGy = 23,
  D_dGy = 24,
  D__Ib = 25,
  D_zIb = 26,
  D_sIb = 27,
  D__Iw = 28,
  D__Id = 29,
  D__Iv = 30,
  D__1 = 31,
  D__Iz = 32,
  D__Jb = 33,
  D__Jz = 34,
  D__Ob = 35,
  D_rOb = 36,
  D_wOb = 37,
  D_dOb = 38,
  D__Ov = 39,
  D_rOv = 40,
  D_wOv = 41,
  D_dOv = 42,
  D__Ap = 43,
  D__Pd = 44,
  D_rPd = 45,
  D_wPd = 46,
  D_dPd = 47,
  D__Pq = 48,
  D_rPq = 49,
  D_wPq = 50,
  D_dPq = 51,
  D__Ppi = 52,
  D_rPpi = 53,
  D_wPpi = 54,
  D_dPpi = 55,
  D__Rv = 56,
  D__Rd = 57,
  D__Sw = 58,
  D__NTA = 59,
  D__T0 = 60,
  D__T1 = 61,
  D__T2 = 62,
  D__T3 = 63,
  D__T4 = 64,
  D__T5 = 65,
  D__T6 = 66,
  D__T7 = 67,
  D__Xb = 68,
  D_rXb = 69,
  D_wXb = 70,
  D__Xw = 71,
  D_rXw = 72,
  D_wXw = 73,
  D__Xv = 74,
  D_rXv = 75,
  D_wXv = 76,
  D__Xd = 77,
  D_rXd = 78,
  D_wXd = 79,
  D__Xz = 80,
  D_rXz = 81,
  D_wXz = 82,
  D__Yb = 83,
  D_rYb = 84,
  D_wYb = 85,
  D__Yw = 86,
  D_rYw = 87,
  D_wYw = 88,
  D__Yv = 89,
  D_rYv = 90,
  D_wYv = 91,
  D__Yd = 92,
  D_rYd = 93,
  D_wYd = 94,
  D__Yz = 95,
  D_rYz = 96,
  D_wYz = 97,
  D__AL = 98,
  D__CL = 99,
  D__DL = 100,
  D__BL = 101,
  D__AH = 102,
  D__CH = 103,
  D__DH = 104,
  D__BH = 105,
  D__RAL = 106,
  D__RCL = 107,
  D__RDL = 108,
  D__RBL = 109,
  D__RAH = 110,
  D__RCH = 111,
  D__RDH = 112,
  D__RBH = 113,
  D__AX = 114,
  D__CX = 115,
  D__DX = 116,
  D__BX = 117,
  D__SP = 118,
  D__BP = 119,
  D__SI = 120,
  D__DI = 121,
  D__eAX = 122,
  D__eCX = 123,
  D__eDX = 124,
  D__eBX = 125,
  D__eSP = 126,
  D__eBP = 127,
  D__eSI = 128,
  D__eDI = 129,
  D__erAX = 130,
  D__erCX = 131,
  D__erDX = 132,
  D__erBX = 133,
  D__erSP = 134,
  D__erBP = 135,
  D__erSI = 136,
  D__erDI = 137,
  D__rAX = 138,
  D__rCX = 139,
  D__rDX = 140,
  D__rBX = 141,
  D__rSP = 142,
  D__rBP = 143,
  D__rSI = 144,
  D__rDI = 145,
  D__EAX = 146,
  D__ECX = 147,
  D__EDX = 148,
  D__EBX = 149,
  D__ESP = 150,
  D__EBP = 151,
  D__ESI = 152,
  D__EDI = 153,
  D__RAX = 154,
  D__RCX = 155,
  D__RDX = 156,
  D__RBX = 157,
  D__RSP = 158,
  D__RBP = 159,
  D__RSI = 160,
  D__RDI = 161,
  D__ES = 162,
  D__CS = 163,
  D__SS = 164,
  D__DS = 165,
  D__FS = 166,
  D__GS = 167,
  D__st = 168,
  D__st0 = 169,
  D__st1 = 170,
  D__st2 = 171,
  D__st3 = 172,
  D__st4 = 173,
  D__st5 = 174,
  D__st6 = 175,
  D__st7 = 176,
  D__Eb = 177,
  D_rEb = 178,
  D_wEb = 179,
  D_dEb = 180,
  D__Ew = 181,
  D_rEw = 182,
  D_wEw = 183,
  D_dEw = 184,
  D__Ev = 185,
  D_rEv = 186,
  D_wEv = 187,
  D_dEv = 188,
  D__Ed = 189,
  D_rEd = 190,
  D_wEd = 191,
  D_dEd = 192,
  D__Ep = 193,
  D_rEp = 194,
  D_wEp = 195,
  D_dEp = 196,
  D__Ey = 197,
  D_rEy = 198,
  D_wEy = 199,
  D_dEy = 200,
  D__M = 201,
  D_rM = 202,
  D_wM = 203,
  D_dM = 204,
  D__Ma = 205,
  D_rMa = 206,
  D_wMa = 207,
  D_dMa = 208,
  D__Mb = 209,
  D_rMb = 210,
  D_wMb = 211,
  D_dMb = 212,
  D__Mp = 213,
  D_rMp = 214,
  D_wMp = 215,
  D_dMp = 216,
  D__Ms = 217,
  D_rMs = 218,
  D_wMs = 219,
  D_dMs = 220,
  D__Mq = 221,
  D_wMq = 222,
  D_rMq = 223,
  D_dMq = 224,
  D__Mxdq = 225,
  D_wMxdq = 226,
  D_rMxdq = 227,
  D_dMxdq = 228,
  D__Mps = 229,
  D_wMps = 230,
  D_rMps = 231,
  D_dMps = 232,
  D__Mpd = 233,
  D_wMpd = 234,
  D_rMpd = 235,
  D_dMpd = 236,
  D__Mdq = 237,
  D_wMdq = 238,
  D_rMdq = 239,
  D_dMdq = 240,
  D__Md = 241,
  D_rMd = 242,
  D_wMd = 243,
  D_dMd = 244,
  D__Mw = 245,
  D_rMw = 246,
  D_wMw = 247,
  D_dMw = 248,
  D_wEx = 249,
  D__cVV = 250,
  D_rcVV = 251,
  D_wcVV = 252,
  D_dcVV = 253,
  D__My = 254,
  D_rMy = 255,
  D_wMy = 256,
  D_dMy = 257,
  D__Hm = 258,
  D_wHm = 259,
  D_rHm = 260,
  D_dHm = 261,
  D__Qq = 262,
  D_wQq = 263,
  D_rQq = 264,
  D_dQq = 265,
  D__Qpi = 266,
  D_wQpi = 267,
  D_rQpi = 268,
  D_dQpi = 269,
  D__xXX = 270,
  D_wxXX = 271,
  D_rxXX = 272,
  D_dxXX = 273,
  D__Vpd = 274,
  D_rVpd = 275,
  D_wVpd = 276,
  D_dVpd = 277,
  D__Vdq = 278,
  D_rVdq = 279,
  D_wVdq = 280,
  D_dVdq = 281,
  D__Vsd = 282,
  D_wVsd = 283,
  D_rVsd = 284,
  D_dVsd = 285,
  D__Vq = 286,
  D_wVq = 287,
  D_rVq = 288,
  D_dVq = 289,
  D__Vps = 290,
  D_wVps = 291,
  D_rVps = 292,
  D_dVps = 293,
  D__Vss = 294,
  D_wVss = 295,
  D_rVss = 296,
  D_dVss = 297,
  D__sXX = 298,
  D_wsXX = 299,
  D_rsXX = 300,
  D_dsXX = 301,
  D__Wsd = 302,
  D_wWsd = 303,
  D_rWsd = 304,
  D_dWsd = 305,
  D__Wdq = 306,
  D_rWdq = 307,
  D_wWdq = 308,
  D_dWdq = 309,
  D__Wpd = 310,
  D_wWpd = 311,
  D_rWpd = 312,
  D_dWpd = 313,
  D__Wq = 314,
  D_wWq = 315,
  D_rWq = 316,
  D_dWq = 317,
  D__Wps = 318,
  D_wWps = 319,
  D_rWps = 320,
  D_dWps = 321,
  D__Wss = 322,
  D_wWss = 323,
  D_rWss = 324,
  D_dWss = 325,
  D__Ups = 326,
  D_wUps = 327,
  D_rUps = 328,
  D_dUps = 329,
  D__Upd = 330,
  D_wUpd = 331,
  D_rUpd = 332,
  D_dUpd = 333,
  D__Uq = 334,
  D_wUq = 335,
  D_rUq = 336,
  D_dUq = 337,
  D__Udq = 338,
  D_wUdq = 339,
  D_rUdq = 340,
  D_dUdq = 341,
  D__Nq = 342,
  D_wNq = 343,
  D_rNq = 344,
  D_dNq = 345,
  D__word_int = 346,
  D__dword_int = 347,
  D__qword_int = 348,
  D__single_real = 349,
  D__double_real = 350,
  D__extend_real = 351,
  D__packed_BCD = 352,
  D__2b = 353,
  D__14_28b = 354,
  D__98_108b = 355,
  D__tO = 356,
  D__fO = 357,
  D__tC = 358,
  D__fC = 359,
  D__tZ = 360,
  D__fZ = 361,
  D__fA = 362,
  D__tA = 363,
  D__fS = 364,
  D__fP = 365,
  D__tP = 366,
  D__tS = 367,
  D__tL = 368,
  D__fL = 369,
  D__fG = 370,
  D__tG = 371,
  D__LOOPNZ = 372,
  D__LOOPZ = 373,
  D__LOOP = 374,
  D__JCXZ = 375,
  D__JMP = 376,
  D_NEAR = 377,
  D_MFAR = 378,
  D_DBYTE = 379,
  D_DWORD = 380,
  D_DDWORD = 381,
  D_STRING = 382,
};

enum _OPCODETYPE
{
C_NULL		= 0,
C_ES		= 1,
C_CS		= 2,
C_SS		= 3,
C_DS		= 4,
C_FS		= 5,
C_GS		= 6,

C_TAIL           = 7,

C_OPER           = 8,
C_ADDR           = 9,
C_LOCK           = 10,
C_REPN           = 11,
C_REPZ           = 12,
C_GRP            = 13,
C_ESC            = 14,
C_2BYTE          = 15,
C_GRPMOD         = 16,
C_GRPRM          = 17,
C_3BYTE_1        = 18,
C_3BYTE_2        = 19,
C_GRPSSE         = 20,
C_GRPSSEFIX      = 21,
C_GRP7           = 22,
C_GRP8           = 23,
C_GRPX64         = 24,

C_MOVS           = 25,
C_STOS           = 26,
C_LODS           = 27,
C_INS            = 28,
C_OUTS           = 29,
C_CMPS           = 30,
C_SCAS           = 31,
C_IN             = 32,
C_OUT            = 33,
C_LES            = 34,
C_LCS            = 35,
C_LSS            = 36,
C_LDS            = 37,
C_LFS            = 38,
C_LGS            = 39,
C_POPCNT         = 40,//	++
C_LOOPNZ         = 42,
C_LOOPZ          = 43,
C_LOOP           = 44,
C_JCXZ           = 45,
C_JMP            = 46,
C_MOVUPS         = 47,
C_MOVUSS         = 48,
C_MOVLPS         = 49,
C_UNPCKLPS       = 50,
C_UNPCKHPS       = 51,
C_MOVHLPS        = 52,
C_MOVHPS         = 53,
C_CVTPS2PS       = 54,//+
C_CVTPS2SS       = 55,//+
C_CVTTPS2PI      = 56,
C_CVTTPS2SI      = 57,//+
C_CVTPS2PI       = 58,
C_CVTPS2SI       = 59,//+
C_SQRTPS         = 60,
C_SQRTSS         = 61,
C_RSQRTPS        = 62,
C_RSQRTSS        = 63,
C_RCPPS          = 64,
C_RCPSS          = 65,
C_ADDPS          = 66,
C_ADDSS          = 67,
C_MULPS          = 68,
C_MULSS          = 69,
C_SUBPS          = 70,
C_SUBSS          = 71,
C_MINPS          = 72,
C_MINSS          = 73,
C_DIVPS          = 74,
C_DIVSS          = 75,
C_MAXPS          = 76,
C_MAXSS          = 77,
C_CMPPS          = 78,
C_CMPSS          = 79,
C_ADD            = 80,
C_OR             = 81,
C_ADC            = 82,
C_SBB            = 83,
C_AND            = 84,
C_SUB            = 85,
C_XOR            = 86,
C_CMP            = 87,
C_ROL            = 88,
C_ROR            = 89,
C_RCL            = 90,
C_RCR            = 91,
C_SHL            = 92,
C_SHR            = 93,
C_SAL            = 94,
C_SAR            = 95,
C_DAA            = 96,
C_DAS            = 97,
C_AAA            = 98,
C_AAS            = 99,
C_INC            = 100,
C_DEC            = 101,
C_PUSH           = 102,
C_POP            = 103,
C_PUSHA          = 104,
C_POPA           = 105,
C_BOUND          = 106,
C_ARPL           = 107,
C_IMUL           = 108,
//--> 64 bits instruction
C_MOVSXD         = 109,//	++
//<--
C_JtO            = 110,
C_JfO            = 111,
C_JtC            = 112,
C_JfC            = 113,
C_JtZ            = 114,
C_JfZ            = 115,
C_JfA            = 116,
C_JtA            = 117,
C_JtS            = 118,
C_JfS            = 119,
C_JtP            = 120,
C_JfP            = 121,
C_JtL            = 122,
C_JfL            = 123,
C_JfG            = 124,
C_JtG            = 125,
C_SETtO		= 126,
C_SETfO		= 127,
C_SETtC		= 128,
C_SETfC		= 129,
C_SETtZ		= 130,
C_SETfZ		= 131,
C_SETfA		= 132,
C_SETtA		= 133,
C_SETtS		= 134,
C_SETfS		= 135,
C_SETtP		= 136,
C_SETfP		= 137,
C_SETtL		= 138,
C_SETfL		= 139,
C_SETfG		= 140,
C_SETtG		= 141,
C_CMOVtO	= 142,
C_CMOVfO	= 143,
C_CMOVtC	= 144,
C_CMOVfC	= 145,
C_CMOVtZ	= 146,
C_CMOVfZ	= 147,
C_CMOVfA	= 148,
C_CMOVtA	= 149,
C_CMOVtS	= 150,
C_CMOVfS	= 151,
C_CMOVtP	= 152,
C_CMOVfP	= 153,
C_CMOVtL	= 154,
C_CMOVfL	= 155,
C_CMOVfG	= 156,
C_CMOVtG	= 157,
C_TEST           = 158,
C_NOP            = 159,
C_XCHG           = 160,
C_MOV            = 161,
C_LEA            = 162,
C_CBW            = 163,
C_CWD            = 164,
C_CALL           = 165,
C_WAIT           = 166,
_C_XCHG          = 167,	//++
C_PUSHF          = 168,
C_POPF           = 169,
C_SAHF           = 170,
C_LAHF           = 171,
C_RET            = 172,
C_ENTER          = 173,
C_LEAVE          = 174,
C_RETF           = 175,
C_INT1           = 176,
C_INT3           = 177,
C_INT            = 178,
C_INTO           = 179,
C_IRET           = 180,
C_AAM            = 181,
C_AAD            = 182,
C_SALC           = 183,
C_XLAT           = 184,
C_HLT            = 185,
C_CMC            = 186,
C_CLC            = 187,
C_STC            = 188,
C_CLI            = 189,
C_STI            = 190,
C_CLD            = 191,
C_STD            = 192,
C_NOT            = 193,
C_NEG            = 194,
C_MUL            = 195,
C_DIV            = 196,
C_IDIV           = 197,

//--> Floating point ops
C_FSTCW          = 198,
C_FSTENV         = 199,
C_FCLEX          = 200,
C_FINIT          = 201,
C_FSAVE          = 202,
C_FSTSW          = 203,
C_FWAIT          = 204,//+
C_FADD           = 205,
C_FMUL           = 206,
C_FCOM           = 207,
C_FCOMP          = 208,
C_FSUB           = 209,
C_FSUBR          = 210,
C_FDIV           = 211,
C_FDIVR          = 212,
C_FLD            = 213,
C_FXCH           = 214,
C_FNOP           = 215,
C_FCHS           = 216,
C_FABS           = 217,
C_FTST           = 218,
C_FLD1           = 219,
C_FLDL2T         = 220,
C_FLDL2E         = 221,
C_FLDPI          = 222,
C_FLDLG2         = 223,
C_FLDLN2         = 224,
C_FLDZ           = 225,
C_F2XM1          = 226,
C_FPTAN          = 227,
C_FPATAN         = 228,
C_FXTRACT        = 229,
C_FPREM1         = 230,
C_FDECSTP        = 231,
C_FINCSTP        = 232,
C_FYL2XP1        = 233,
C_FSQRT          = 234,
C_FSINCOS        = 235,
C_FRNDINT        = 236,
C_FSCALE         = 237,
C_FSIN           = 238,
C_FCOS           = 239,
C_FLDCW          = 240,
C_FLDENV         = 241,
C_FNSTCW         = 242,//+
C_FNSTENV        = 243,//+
C_FST            = 244,
C_FSTP           = 245,
C_FCMOVB         = 246,
C_FCMOVE         = 247,
C_FCMOVBE        = 248,
C_FCMOVU         = 249,
C_FUCOMPP        = 250,
C_FIADD          = 251,
C_FICOM          = 252,
C_FICOMP         = 253,
C_FIDIV          = 254,
C_FIDIVR         = 255,
C_FIMUL          = 256,
C_FISUB          = 257,
C_FISUBR         = 258,
C_FCMOVNB        = 259,
C_FCMOVNE        = 260,
C_FCMOVNBE       = 261,
C_FCMOVNU        = 262,
C_FNCLEX         = 263,//+
C_FNINIT         = 264,//+
C_FUCOMI         = 265,
C_FCOMI          = 266,
C_FILD           = 267,
C_FISTTP         = 268,//	++
C_FIST           = 269,
C_FISTP          = 270,
C_FFREE          = 271,
C_FUCOM          = 272,
C_FUCOMP         = 273,
C_FNSAVE         = 274,//+
C_FNSTSW         = 275,//+
C_FRSTOR         = 276,
C_FADDP          = 277,
C_FMULP          = 278,
C_FCOMPP         = 279,
C_FSUBRP         = 280,
C_FSUBP          = 281,
C_FDIVRP         = 282,
C_FDIVP          = 283,
C_FUCOMIP        = 284,
C_FCOMIP         = 285,
C_FBLD           = 286,
C_FBSTP          = 287,
C_FXAM           = 288,
//C_FLD2T/C_FLDP1  = 289,//+
//-
C_FYL2X          = 290,
C_FPREM          = 291,
//<--

C_SLDT           = 292,
C_STR            = 293,
C_LLDT           = 294,
C_LTR            = 295,
C_VERR           = 296,
C_VERW           = 297,
C_SGDT           = 298,
C_SIDT           = 299,
C_LGDT           = 300,
C_LIDT           = 301,
C_SMSW           = 302,
C_LMSW           = 303,
C_LAR            = 304,
C_LSL            = 305,
C_MOVZX          = 306,
C_MOVSX          = 307,
C_RSM            = 308,
C_BT             = 309,
C_BTR            = 310,
C_BTS            = 311,
C_BTC            = 312,
C_BSF            = 313,
C_BSR            = 314,
C_SHLD           = 315,
C_SHRD           = 316,
C_CMPXCHG_XBTS   = 317,//+
C_CMPXCHG_IBTS   = 318,//+
C_CMPXCHG        = 319,
C_XADD           = 320,
C_BSWAP          = 321,
C_CLTS           = 322,
C_CPUID          = 323,
C_MOVAPS         = 324,
C_CVTPI2PS       = 325,
C_MOVNTPS        = 326,
C_UCOMISS        = 327,
C_COMISS         = 328,
C_MOVMSKPS       = 329,
C_ANDPS          = 330,
C_ANDNPS         = 331,
C_ORPS           = 332,
C_XORPS          = 333,
C_XORPD          = 334,//	++
C_MOVNTI         = 335,
C_PINSRW         = 336,
C_PEXTRW         = 337,
C_SHUFPS         = 338,
C_PSRLW          = 339,
C_PSRLD          = 340,
C_PSRLQ          = 341,
C_PADDQ          = 342,
C_PMULLW         = 343,
C_MOVQ           = 344,
C_PMOVMSKB       = 345,
C_CVTPS2PD       = 346,
C_CVTDQ2PS       = 347,
C_PSHUFW         = 348,
C_PCMPEQB        = 349,
C_PCMPEQW        = 350,
C_PCMPEQD        = 351,
C_EMMS           = 352,
C_PREFETCHNTA    = 353,
C_FXSAVE         = 354,
C_FXRSTOR        = 355,
C_LDMXCSR        = 356,
C_STMXCSR        = 357,
C_XSAVE          = 358,//	++
C_XRSTOR         = 359,//	++
C_WRMSR          = 360,
C_RDTSC          = 361,
C_RDMSR          = 362,
C_RDPMC          = 363,
C_SYSCALL        = 364,
C_SYSRET         = 365,
C_SYSENTER       = 366,
C_SYSEXIT        = 367,
C_GETSEC         = 368,//	++
C_INVD           = 369,
C_WBINVD         = 370,
C_INVLPG         = 371,
C_CMPXCHG8B      = 372,
C_PUNPCKLBW      = 374,
C_PUNPCKLWD      = 375,
C_PUNPCKLDQ      = 376,
C_PACKSSWB       = 377,
C_PCMPGTB        = 378,
C_PCMPGTW        = 379,
C_PCMPGTD        = 380,
C_PACKUSWB       = 381,
C_PUNPCKHBW      = 382,
C_PUNPCKHWD      = 383,
C_PUNPCKHDQ      = 384,
C_PACKSSDW       = 385,
C_PUNPCKLQDQ     = 386,
C_PUNPCKHQDQ     = 387,
C_MOVD           = 388,
C_PSUBB          = 389,
C_PSUBW          = 390,
C_PSUBD          = 391,
C_PSUBQ          = 392,
C_PADDB          = 393,
C_PADDW          = 394,
C_PADDD          = 395,
C_PSUBUSB        = 396,
C_PMINUB         = 398,
C_PAND           = 399,
C_PADDUSB        = 400,
C_PADDUSW        = 401,
C_PMAXUB         = 402,
C_PANDN          = 403,
C_PAVGB          = 404,
C_PSRAW          = 405,
C_PSRAD          = 406,
C_PAVGW          = 407,
C_PMULHUW        = 408,
C_PMULHW         = 409,
C_CVTPD2DQ       = 410,
C_MOVNTQ         = 411,
C_PSUBSB         = 412,
C_PSUBSW         = 413,
C_PMINSW         = 414,
C_POR            = 415,
C_PADDSB         = 416,
C_PADDSW         = 417,
C_PMAXSW         = 418,
C_PXOR           = 419,
C_PSLLW          = 420,
C_PSLLD          = 421,
C_PSLLQ          = 422,
C_PMULUDQ        = 423,
C_PMADDWD        = 424,
C_PSADBW         = 425,
C_MASKMOVQ       = 426,
C_CLFLUSH        = 427,
C_LFENCE         = 428,
C_MFENCE         = 429,
C_SFENCE         = 430,

//++

C_UD2            = 431,
//--> VT-x instructions
C_VMPTRLD        = 432,
C_VMCLEAR        = 433,
C_VMXON          = 434,
C_VMPTRST        = 435,
C_VMCALL         = 436,
C_VMLAUNCH       = 437,
C_VMRESUME       = 438,
C_VMXOFF         = 439,
C_VMREAD         = 440,
C_VMWRITE        = 441,
//<--
C_MONITOR        = 442,
C_MWAIT          = 443,
C_SWAPGS         = 444,
C_PSHUFB         = 445,
C_PHADDW         = 446,
C_PHADDD         = 447,
C_PHADDSW        = 448,
C_PHSUBW         = 450,
C_PHSUBD         = 451,
C_PHSUBSW        = 452,
C_PSIGNB         = 453,
C_PSIGNW         = 454,
C_PSIGND         = 455,
C_PMULHRSW       = 456,
C_PABSB          = 457,
C_PABSW          = 458,
C_PABSD          = 459,
C_PALIGNR        = 460,
C_PSHUFD         = 461,
C_PSHUFHW        = 462,
C_PSHUFLW        = 463,
C_HADDPD         = 464,
C_HADDPS         = 465,
C_HSUBPD         = 466,
C_HSUBPS         = 467,
C_MOVDQA         = 468,
C_MOVDQU         = 469,
C_MOVMSKPD       = 470,
C_SQRTPD         = 471,
C_SQRTSD         = 472,
C_ANDPD          = 473,
C_ANDNPD         = 474,
C_ORPD           = 475,
C_ADDPD          = 476,
C_ADDSD          = 477,
C_MULPD          = 478,
C_MULSD          = 479,
C_CVTPD2PS       = 480,
C_CVTSD2SS       = 481,
C_CVTSS2SD       = 482,
C_CVTPS2DQ       = 483,
C_CVTTPS2DQ      = 484,
C_SUBPD          = 485,
C_SUBSD          = 486,
C_MINPD          = 487,
C_MINSD          = 488,
C_DIVPD          = 489,
C_DIVSD          = 490,
C_MAXPD          = 491,
C_MAXSD          = 492,
C_MOVUPD         = 493,
C_MOVSD          = 494,
C_MOVSS          = 495,
C_MOVLPD         = 496,
C_MOVDDUP        = 497,
C_MOVSLDUP       = 498,
C_UNPCKLPD       = 499,
C_UNPCKHPD       = 500,
C_MOVHPD         = 501,
C_MOVSHDUP       = 502,
C_MOVLHPS        = 503,
C_MOVAPD         = 504,
C_CVTPI2PD       = 505,
C_CVTSI2SD       = 506,
C_CVTSI2SS       = 507,
C_MOVNTPD        = 508,
C_MOVNTSD        = 509,
C_MOVNTSS        = 510,
C_CVTTPD2PI      = 511,
C_CVTTSD2SI      = 512,
C_CVTTSS2SI      = 513,
C_CVTPD2PI       = 514,
C_CVTSD2SI       = 515,
C_CVTSS2SI       = 516,
C_UCOMISD        = 517,
C_COMISD         = 518,
C_ADDSUBPD       = 519,
C_ADDSUBPS       = 520,
C_MOVDQ2Q        = 521,
C_MOVQ2DQ        = 522,
C_PSUBUSW        = 523,
C_CVTTPD2DQ      = 524,
C_CVTDQ2PD       = 525,
C_MOVNTDQ        = 526,
C_LDDQU          = 527,
C_MASKMOVDQU     = 528,
C_PMADDUBSW      = 529,
C_PMOVSXBW       = 530,
C_PMOVSXBD       = 531,
C_PMOVSXBQ       = 532,
C_PMOVSXWD       = 533,
C_PMOVSXWQ       = 534,
C_PMOVSXDQ       = 535,
C_PMULDQ         = 536,
C_PCMPEQQ        = 537,
C_MOVNTDQA       = 538,
C_PACKUSDW       = 539,
C_PMOVZXBW       = 540,
C_PMOVZXBD       = 541,
C_PMOVZXBQ       = 542,
C_PMOVZXWD       = 543,
C_PMOVZXWQ       = 544,
C_PMOVZXDQ       = 545,
C_PCMPGTQ        = 546,
C_PMINSB         = 547,
C_PMINSD         = 548,
C_PMINUW         = 549,
C_PMINUD         = 550,
C_PMAXSB         = 551,
C_PMAXSD         = 552,
C_PMAXUW         = 553,
C_PMAXUD         = 554,
C_PMULLD         = 555,
C_PHMINPOSUW     = 556,
C_CRC32          = 557,
C_PBLENDVB       = 558,
C_BLENDVPS       = 559,
C_BLENDVPD       = 560,
C_PTEST          = 561,
C_ROUNDPS        = 562,
C_ROUNDPD        = 563,
C_ROUNDSS        = 564,
C_ROUNDSD        = 565,
C_BLENDPS        = 566,
C_BLENDPD        = 567,
C_PBLENDW        = 568,
C_PEXTRB         = 569,
C_PEXTRD         = 570,
C_EXTRACTPS      = 572,
C_PINSRB         = 573,
C_INSERTPS       = 574,
C_PINSRD         = 575,
C_DPPS           = 576,
C_DPPD           = 577,
C_MPSADBW        = 578,
C_PCLMULQDQ      = 579,
C_PCMPESTRM      = 580,
C_PCMPESTRI      = 581,
C_PCMPISTRM      = 582,
C_PCMPISTRI      = 583,
C_SHUFPD         = 584,
//--> VT-x instructions
C_INVEPT         = 585,
C_INVVPID        = 586,
//<--
C_MOVBE          = 587,
C_AESKEYGENASSIST  = 588,
C_AESIMC         = 589,
C_AESENC         = 590,
C_AESENCLAST     = 591,
C_AESDEC         = 592,
C_AESDECLAST     = 593,
C_XGETBV         = 594,
C_XSETBV         = 595,
C_RDTSCP         = 596,
C_PAUSE          = 597,
C_CMPPD          = 598,
C_CMPSD          = 599,
C_PSRLDQ         = 600,
C_PSLLDQ         = 601,

//--> AMD-V instructions
C_VMRUN          = 602,
C_VMMCALL        = 603,
C_VMLOAD         = 604,
C_VMSAVE         = 605,
C_STGI           = 606,
C_CLGI           = 607,
C_SKINIT         = 608,
C_INVLPGA        = 609,
//<--
C_EXTRQ          = 610,

//--> 3DNow!
C_PI2FW          = 611,
C_PI2FD          = 612,
C_PF2IW          = 613,
C_PF2ID          = 614,
C_PFNACC         = 615,
C_PFPNACC        = 616,
C_PFCMPGE        = 617,
C_PFMIN          = 618,
C_PFRCP          = 619,
C_PFRSQRT        = 620,
C_PFSUB          = 621,
C_PFADD          = 622,
C_PFCMPGT        = 623,
C_PFMAX          = 624,
C_PFRCPIT1       = 625,
C_PFRSQIT1       = 626,
C_PFSUBR         = 627,
C_PFACC          = 628,
C_PFCMPEQ        = 629,
C_PFMUL          = 630,
C_PFRCPIT2       = 631,
C_PMULHRW        = 632,
C_PSWAPD         = 633,
C_PAVGUSB        = 634,
//<--

//--> AVX instructions
//TODO
//<--

C_3DNOW          = 635,
C_DBYTE          = 636,
C_DWORD          = 637,
C_DDWORD         = 638,
};

// disasm

struct _DIS_ADDRESS
{
	unsigned int address_size;
	unsigned int r_m;
	unsigned int reg;
	unsigned int mod;
	unsigned int base;
	unsigned int index;
	unsigned int scale;
	unsigned int segment;
	unsigned int displacement_size;
	unsigned int __unused; //ALIGN
	unsigned long long displacement;
	unsigned long long effect_address;
	unsigned long long line_address;
};

// disasm

enum
{
	OP_Invalid = 0,
	OP_Address = 1,
	OP_Register = 2,
	OP_Segment = 3,
	OP_Immed = 4,
	OP_Near = 5,
	OP_Far = 6,
	OP_String = 7,

	OP_Datadup = 20,
	OP_Symbol = 21,
	OP_Align = 22,
};

enum RWFLAG
{
	FREAD = 1,
	FWRITE = 2,
};

enum GENE_REG_INDEX
{
	EAX_IDX = 0,
	ECX_IDX = 1,
	EDX_IDX = 2,
	EBX_IDX = 3,
	ESP_IDX = 4,
	EBP_IDX = 5,
	ESI_IDX = 6,
	EDI_IDX = 7,
	R8_IDX = 8,
	R9_IDX = 9,
	R10_IDX = 10,
	R11_IDX = 11,
	R12_IDX = 12,
	R13_IDX = 13,
	R14_IDX = 14,
	R15_IDX = 15,
	GENE_IDX_MAX = 16,
};

enum SEG_REG_INDEX
{
	ES_IDX = 0,
	CS_IDX = 1,
	SS_IDX = 2,
	DS_IDX = 3,
	FS_IDX = 4,
	GS_IDX = 5,
	SEG_IDX_MAX = 6,
};

struct _OPERAND_ITEM
{
	int mode;
	int rwflag;
	int opersize;
	char string[32];

	union
	{
		_DIS_ADDRESS addr;	//1

		struct
		{
			int reg_index;	//GENE_REG_INDEX
		} reg;			//2

		struct
		{
			int seg_index;	//SEG_REG_INDEX
		} seg;			//3

		struct
		{
			unsigned long long immed_value;
		} immed;		//4

		struct
		{
			unsigned long long offset;
			unsigned long long label;
		} nearptr;		//5

		struct
		{
			unsigned long offset;
			unsigned long segment;
		} farptr;		//6

		struct
		{
			int count;
			unsigned char buffer[32];
		} datadup;		//7,20

		struct
		{
			char string[64];
			int boffset;
			int mode;
			unsigned long offset;
		} symbol;		//21

		struct
		{
			unsigned long nBytes;
		} align;		//22
	};
};

struct _INSTRUCTION_INFORMATION
{
	ULONG_PTR eip;
	int CodeMode;
	int Length;
	int OpCode;
	int OpCount;
	int OpType;
	int CodeType;
	char Name[16];
	int Lock;
	char LockName[8];
	int Repeat;
	char RepeatName[8];
	int SegmentPrefix;
	int xxxxptr;
	//
	_OPERAND_ITEM op[3];
	unsigned char *CodeBuff;
	char *pasm;
	int U_x1;
	int U_x2;
	int U_x3;

	int Prefixes;
	int RegRM;
	int Sib1;
	int AMD3DNow;
	int RexPrefix;
};

union DIS_GEN_REG_T
{
	unsigned long long rerx;

	union
	{
		unsigned long erx;
		struct
		{
			union
			{
				union
				{
					unsigned short rx;
					struct
					{
						unsigned char rl;
						unsigned char rh;
					} byte;
				};
			} u_word;
			unsigned short word_filler;
		} word;
	};
};


struct DIS_CPU
{
	DIS_GEN_REG_T gen_reg[GENE_IDX_MAX];
	unsigned long long r[6]; //???
	ULONG_PTR SEG_BASE[SEG_IDX_MAX];
};

int Disassembly(_INSTRUCTION_INFORMATION *pInstInfo, unsigned char *inbuff, unsigned long long eip, int mode, DIS_CPU *DisCPU);

int Disassembly(char *pasm, unsigned char *inbuff, unsigned long long eip, int mode, int U_x1, int U_x2);

int Assembly(const char *AsmString, unsigned char *CodeBuffer, unsigned long eip, int mode);

struct CIntelDisassembler
{
	int m_U_x1;
	int m_U_x2;
	int m_U_x3;
	int m_Mode;

	CIntelDisassembler()
		: m_U_x1(6)
		, m_U_x2(12)
		, m_U_x3(20)
		, m_Mode(CODE_MODE_32)
	{
	}
	~CIntelDisassembler()
	{
	}

	void SetStyle(int u_x1, int u_x2, int u_x3)
	{
		m_U_x1 = u_x1;
		m_U_x2 = u_x2;
		m_U_x3 = u_x3;
	}
	void SetMode(int mode)
	{
		m_Mode = mode;
	}

	static int GetLength(unsigned char *inbuff, int mode)
	{
		return Disassembly(0, inbuff, 0x100, mode, 0, 8);
	}
	static char ** GetIntelConstName(int *size)
	{
		return 0;
	}

	int Disassembler(_INSTRUCTION_INFORMATION *pInstInfo, DIS_CPU *dis_cpu)
	{
		pInstInfo->CodeMode = m_Mode;
		pInstInfo->U_x1 = m_U_x1;
		pInstInfo->U_x2 = m_U_x2;
		return Disassembly(pInstInfo, pInstInfo->CodeBuff, pInstInfo->eip, m_Mode, dis_cpu);
	}

	static int Assembler(const char *AsmString, unsigned char *CodeBuffer, unsigned long eip, int mode)
	{
		return Assembly(AsmString, CodeBuffer, eip, mode);
	}
};

#endif
```

`source/EXEAnalyzer/mzhead.hpp`:

```hpp

#ifndef _MZHEAD_HPP_
#define _MZHEAD_HPP_

#pragma pack(push,1)
struct MZRELOC
{
  /* 0x0000 */ unsigned short Offset;
  /* 0x0002 */ unsigned short Segment;
}; /* size: 0x0004 */
#pragma pack(pop)

#pragma pack(push,1)
struct MZHEAD
{
  /* 0x0000 */ unsigned short Signature;
  /* 0x0002 */ unsigned short cbLastPage;
  /* 0x0004 */ unsigned short nPage;
  /* 0x0006 */ unsigned short nReloc;
  /* 0x0008 */ unsigned short cpHead;
  /* 0x000a */ unsigned short Minalloc;
  /* 0x000c */ unsigned short Maxalloc;
  /* 0x000e */ unsigned short SS;
  /* 0x0010 */ unsigned short SP;
  /* 0x0012 */ unsigned short CheckSum;
  /* 0x0014 */ unsigned short IP;
  /* 0x0016 */ unsigned short CS;
  /* 0x0018 */ unsigned short fpReloc;
  /* 0x001a */ unsigned short nOverlay;
  /* 0x001c */ unsigned short Reserved[4];
  /* 0x0024 */ unsigned short OemID;
  /* 0x0026 */ unsigned short OemInfo;
  /* 0x0028 */ unsigned short Reserved2[10];
  /* 0x003c */ long pfNewHead;
}; /* size: 0x0040 */
#pragma pack(pop)

#endif
```

`source/EXEAnalyzer/pefile.cpp`:

```cpp

#include "pefile.hpp"
#include <string.h>

	CPEFile::CPEFile()
		: m_OpenMode(7) //??? OPEN_DLL OPEN_SYS
		, m_ErrorCode(0)
		, m_PEOff(0)
		, m_Section(nullptr)
		, m_SectCount(0)
		, m_ImportModule(nullptr)
		, m_ImportModuleCount(0)
		, m_ExportFunc(nullptr)
		, m_ExportFuncCount(0)
		, m_ResDir(nullptr)
		, m_ResDirCount(0)
		, m_BaseReloc(nullptr)
		, m_BaseRelocCount(0)
		, m_TLSData(nullptr)
		, m_TLSDataSize(0)
		, m_AddressOfTLSIndex(0)
		, m_TLSCallBackFuncs(nullptr)
		, m_TLSCallBackCount(0)
	{
	}

	bool CPEFile::MapToMemory(unsigned long MemAddr, ULONG_PTR *pPhysAddr, bool bImageBase)
	{
		for (int i = 0; i <= m_SectCount; ++i) //??? =
		{
			if (MemAddr >= m_Section[i].PointerToRawData &&
				MemAddr < m_Section[i].PointerToRawData + m_Section[i].SizeOfRawData)
			{
				if (pPhysAddr)
				{
					*pPhysAddr = MemAddr + m_Section[i].VirtualAddress - m_Section[i].PointerToRawData;
					if (bImageBase)
						*pPhysAddr += m_PEHead.ImageBase;
				}
				return true;
			}
		}
		return false;
	}

	bool CPEFile::MapToFile(ULONG_PTR MemAddr, unsigned long *pPhysAddr, bool bImageBase)
	{
		if (bImageBase)
			MemAddr -= m_PEHead.ImageBase;
		for (int i = 0; i <= m_SectCount; ++i) //??? =
		{
			if (MemAddr >= m_Section[i].VirtualAddress
				&& MemAddr < m_Section[i].VirtualAddress + m_Section[i].VirtualSize
				&& MemAddr - m_Section[i].VirtualAddress <= m_Section[i].SizeOfRawData)
			{
				if (pPhysAddr)
					*pPhysAddr = MemAddr + m_Section[i].PointerToRawData - m_Section[i].VirtualAddress;
				return true;
			}
		}
		return false;
	}

	unsigned long CPEFile::GetPageAttribute(ULONG_PTR Address)
	{
		if (Address < m_ImageBase || Address >= m_ImageHighBase)
			return 0;

		unsigned long VirtualAddress = Address - m_ImageBase;
		for (int i = 0; i <= m_SectCount; ++i) //??? =
		{
			if (VirtualAddress >= m_Section[i].VirtualAddress &&
				VirtualAddress < m_Section[i].VirtualAddress + m_Section[i].VirtualSize)
			{
				unsigned long Attr = 0;
				if (m_Section[i].Characteristics & 0x20000000) //IMAGE_SCN_MEM_EXECUTE Executable section
					Attr = 2;
				if (m_Section[i].Characteristics & 0x40000000) //IMAGE_SCN_MEM_READ Readable section
					Attr |= 2;
				if (m_Section[i].Characteristics & 0x80000000) //IMAGE_SCN_MEM_WRITE Writable section
					Attr |= 6;
				if (m_Section[i].Characteristics == 0)
					Attr = 6;
				return Attr;
			}
		}
		return 6;
	}

	unsigned long CPEFile::ReadImageMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		unsigned long Len;

		unsigned long ReadSize = 0;
		if (Address < m_ImageBase || Address >= m_ImageHighBase)
			return 0;

		if (Address < m_ImageHighBase && Address+Size > m_ImageHighBase)
			Size = m_ImageHighBase - Address;

		unsigned long Pos = Address - m_ImageBase;

		if (!m_SectCount)
			return CImageFile::ReadFile(Pos, Buffer, Size);

		unsigned long dwSize = Size;
		memset(Buffer, 0, Size);
		for (int n = 0; n <= m_SectCount && dwSize; ++n)
		{
			PE_SECTION *pCurSec = &m_Section[n];
			unsigned long RangeStart = pCurSec->VirtualAddress;
			unsigned long RangeEnd = pCurSec->VirtualSize + pCurSec->VirtualAddress;
			if (Pos >= RangeStart && Pos < RangeEnd)
			{
				if (Pos >= RangeStart + pCurSec->SizeOfRawData)
				{
					if (Pos < RangeEnd)
					{
						if (dwSize <= RangeEnd - Pos)
						{
							Len = dwSize;
							dwSize = 0;
						} else
						{
							dwSize -= RangeEnd - Pos;
							Len = RangeEnd - Pos;
						}
						ReadSize += Len;
						Pos += Len;
					}
				} else
				{
					unsigned long LeftSize = RangeStart + pCurSec->SizeOfRawData - Pos;
					if (ReadSize <= LeftSize)
					{
						Len = dwSize;
						ReadSize = 0;
						CImageFile::ReadFile(
							Pos + pCurSec->PointerToRawData - RangeStart,
							&((char*)Buffer)[ReadSize], Len);
					} else
					{
						dwSize -= LeftSize;
						Len = pCurSec->VirtualAddress + pCurSec->SizeOfRawData - Pos;
						CImageFile::ReadFile(
							Pos + pCurSec->PointerToRawData - RangeStart,
							 &((char*)Buffer)[ReadSize], LeftSize);
					}
					ReadSize += Len;
					Pos += Len;
				}
			}
		}
		return Size;
	}

	unsigned long CPEFile::WriteImageMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size)
	{
		//???
		return 0;
	}

	bool CPEFile::LoadPage(ULONG_PTR Address, void *Buffer)
	{
		unsigned short TypeOffset_v4;
		int v5;
		unsigned short TypeOffset_v6;
		unsigned int k;
		int j;
		//int i;
		int Delta;
		//unsigned long VirtualAddress;
		signed int Size;
		unsigned short Type_v14;
		unsigned short Type_v15;

		if (!m_SectCount || !m_Section)
			return false;

		memset(Buffer, 0, 0x1000);
	#ifdef _X64_
		unsigned long VirtualAddress = (Address & 0xFFFFFFFFFFFFF000ULL) - m_ImageBase;
	#else
		unsigned long VirtualAddress = (Address & 0xFFFFF000) - m_ImageBase;
	#endif

		int i;
		for (i = 0; ; ++i)
		{
			if (i > m_SectCount)
				return false;

			if (VirtualAddress >= m_Section[i].VirtualAddress
				&& VirtualAddress < m_Section[i].VirtualSize + m_Section[i].VirtualAddress)
			{
				break;
			}
		}

		Size = m_Section[i].SizeOfRawData + m_Section[i].VirtualAddress - VirtualAddress;
		if (Size <= 0)
			return true;

		
		MAX_LIMIT(Size, 4096);

		CImageFile::ReadFile(
			m_Section[i].PointerToRawData + VirtualAddress - m_Section[i].VirtualAddress,
			Buffer,  Size);

		if (m_ImageBase == m_PEHead.ImageBase)
			return true;

		for (j = 0; j < m_BaseRelocCount; ++j)
		{
			if (VirtualAddress == m_BaseReloc[j].VirtualAddr + 4096)
			{
				if (m_BaseReloc[j].Count)
				{
					TypeOffset_v4 = m_BaseReloc[j].TypeOffset[m_BaseReloc[j].Count - 1];
					Type_v14 = TypeOffset_v4 & 0xFFF;
					if ( (unsigned __int16)((signed int)TypeOffset_v4 >> 12) == 3 && (signed int)Type_v14 > 4092)
					{
						Delta = m_ImageBase - m_PEHead.ImageBase;
						switch (Type_v14)
						{
						case 0xFFD:
							v5 = Delta + ((((char*)Buffer)[Type_v14 + 2] << 16) | ((char*)Buffer)[Type_v14]);
							*(short*)&((char*)Buffer)[Type_v14] = Delta + ((char*)Buffer)[Type_v14];
						//	((char*)Buffer)[Type_v14 + 2] = (Delta + ((((char*)Buffer)[Type_v14 + 2] << 16) | (unsigned int)((char*)Buffer)[Type_v14])) >> 16;
							((char*)Buffer)[Type_v14 + 2] = v5 >> 16;
							break;
						case 0xFFE:
							*(short *)&((char*)Buffer)[Type_v14] += Delta;
							break;
						case 0xFFF:
							((char*)Buffer)[Type_v14] += Delta;
							break;
						}
					}
				}
			}

			if (VirtualAddress == m_BaseReloc[j].VirtualAddr)
			{
				for (k = 0; k < m_BaseReloc[j].Count; ++k)
				{
					TypeOffset_v6 = m_BaseReloc[j].TypeOffset[k];
					Type_v15 = TypeOffset_v6 & 0xFFF;
					if ( (unsigned __int16)((signed int)TypeOffset_v6 >> 12) == 3 && (signed int)Type_v15 <= 4092)
					{
						Delta = m_ImageBase - m_PEHead.ImageBase;
						*(long*)&((char*)Buffer)[Type_v15] += Delta;//m_ImageBase
					//	+ *(long*)&((char*)Buffer)[Type_v15]
					//	- m_PEHead.ImageBase;
					}
				}
			}
		}
		
		return true;
	}

	bool CPEFile::Open(const char *FileName, HANDLE HandleOpen)
	{
		signed int i;
		int MinLowSectAddrFilePos;
		int FixAddress;

		if (!CImageFile::Open(FileName, HandleOpen))
			return false;

		MZHEAD HeadBuffer;
		if (!ReadMemory(m_ImageBase, &HeadBuffer, sizeof(MZHEAD)))
		{
			CImageFile::Close();
			return false;
		}

		if (HeadBuffer.Signature != 0x4D5A &&
		    HeadBuffer.Signature != 0x5A4D)
		{
			CImageFile::Close();
			return false;
		}

		m_PEOff = HeadBuffer.pfNewHead;
		if (m_PEOff >= m_FileSize - sizeof(PE_HEAD))
		{
			CImageFile::Close();
			return false;
		}

		if (!ReadMemory(m_PEOff + m_ImageBase, &m_PEHead, sizeof(PE_HEAD)))
		{
			CImageFile::Close();
			return false;
		}

		m_FileType = 0x1313;

		for (int i = 0; i < 16; ++i)
		{
			//TODO
		}

		if (m_PEHead.Signature != 0x4550)
		{
			CImageFile::Close();
			m_ErrorCode = PE_ERROR_SIGN;
			return false;
		}

		if (m_PEHead.Characteristics & 0x2000) //DLL
		{
			if (!(m_OpenMode & PE_OPEN_DLL))
			{
				CImageFile::Close();
				m_ErrorCode = PE_ERROR_MODULE_TYPE;
				return false;
			}
			m_FileType = 0x2313;
		}

		if (m_PEHead.Subsystem == 1) //SYS
		{
			if (!(m_OpenMode & PE_OPEN_SYS))
			{
				CImageFile::Close();
				m_ErrorCode = PE_ERROR_MODULE_TYPE;
				return false;
			}
			m_FileType = 0x4313;
		}

	#ifdef _X64_
		if (m_PEHead.Machine != 0x8664)	//IMAGE_FILE_MACHINE_AMD64
	#else
		if (m_PEHead.Machine != 0x14C)	//IMAGE_FILE_MACHINE_I386
	#endif
		{
			if (m_OpenMode & 8) //PE_???
			{
				CImageFile::Close();
				m_ErrorCode = PE_ERROR_MODULE_TYPE;
				return false;
			}
			m_FileType |= 4; //???
		}

		unsigned int SectionAlignment = m_PEHead.SectionAlignment;
		unsigned int FileAlignment = m_PEHead.FileAlignment;

		if (SectionAlignment == 0 || SectionAlignment > 65536)
				SectionAlignment = 4096;

		if (FileAlignment == 0 || FileAlignment > 8192)
				FileAlignment = 512;

		if (m_PEHead.NumberOfSections < 1 || m_PEHead.NumberOfSections > 128)
		{
			CImageFile::Close();
			m_ErrorCode = PE_ERROR_SECTION;
			return false;
		}
		
		m_Section = new PE_SECTION[m_PEHead.NumberOfSections + 1];
		if (!m_Section)
		{
			CImageFile::Close();
			m_ErrorCode = PE_ERROR_SECTION;
			return false;
		}


		if (!ReadMemory(m_PEHead.SizeOfOptionalHeader + m_ImageBase + m_PEOff + 0x18, //???
			&m_Section[1], sizeof(PE_SECTION) * m_PEHead.NumberOfSections) )
		{
			if (m_Section)
			{
				delete []m_Section;
				m_Section = nullptr;
			}
			CImageFile::Close();
			m_ErrorCode = PE_ERROR_SECTION;
			return false;
		}

		m_SectCount = m_PEHead.NumberOfSections;
		for (int secj = 1; secj <= m_SectCount; ++secj)
		{
			//TODO
		}

		memset(m_Section, 0, sizeof(PE_SECTION)); //???
		m_Section->VirtualAddress = 0;
		m_Section->PointerToRawData = 0;
		m_Section->VirtualSize = m_PEHead.SizeOfHeaders;
		m_Section->SizeOfRawData = m_Section->VirtualSize;
		m_Section->Characteristics = 0xC0000000; //IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE

		unsigned long MaxHighSectAddr = 0;
		unsigned long MinLowSectAddr = -1;

		for (int nSec = 1; nSec <= m_SectCount; ++nSec)
		{
			if (!m_Section[nSec].VirtualSize)
				m_Section[nSec].VirtualSize = m_Section[nSec].SizeOfRawData;

			if (m_Section[nSec].SizeOfRawData % FileAlignment)
				m_Section[nSec].SizeOfRawData = ALIGN_SIZE(m_Section[nSec].SizeOfRawData, FileAlignment);

			if (m_Section[nSec].VirtualSize % SectionAlignment)
				m_Section[nSec].VirtualSize = ALIGN_SIZE(m_Section[nSec].VirtualSize, SectionAlignment);

			if (nSec == m_SectCount && m_Section[nSec].VirtualSize < m_Section[nSec].SizeOfRawData)
			{
				FixAddress = ALIGN_SIZE(m_Section[nSec].SizeOfRawData, SectionAlignment);

				if (FixAddress + m_Section[nSec].VirtualAddress <= ALIGN_SIZE(m_PEHead.SizeOfImage, 4096))
					m_Section[nSec].VirtualSize = FixAddress;
			}

			if (m_Section[nSec].VirtualAddress < m_Section[nSec-1].VirtualSize
					+ m_Section[nSec-1].VirtualAddress
				&& m_Section[nSec-1].VirtualAddress < m_Section[nSec].VirtualAddress)
			{
				m_Section[nSec-1].VirtualSize = m_Section[nSec].VirtualAddress
					- m_Section[nSec-1].VirtualAddress;
			}

			if (nSec < m_SectCount
				&& m_Section[nSec].VirtualAddress == m_Section[nSec + 1].VirtualAddress)
			{
				m_Section[nSec].VirtualSize = 0;
			}

			if (m_Section[nSec].PointerToRawData > m_FileSize)
				m_Section[nSec].SizeOfRawData = 0;

			if (m_Section[nSec].SizeOfRawData > 0x1000000)
				m_Section[nSec].SizeOfRawData = m_Section[nSec].VirtualSize;

			MAX_LIMIT(m_Section[nSec].SizeOfRawData, m_FileSize - m_Section[nSec].PointerToRawData);

			if (m_Section[nSec].VirtualSize > 0x1000000)
				m_Section[nSec].VirtualSize = m_Section[nSec].SizeOfRawData;

			MIN_LIMIT(MaxHighSectAddr, m_Section[nSec].VirtualSize + m_Section[nSec].VirtualAddress);

			if (m_Section[nSec].VirtualAddress < MinLowSectAddr)
			{
				MinLowSectAddr = m_Section[nSec].VirtualAddress;
				MinLowSectAddrFilePos = m_Section[nSec].PointerToRawData;
			}
		}

		if (m_Section->SizeOfRawData < MinLowSectAddr && MinLowSectAddr != -1)
		{
			m_Section->VirtualSize = MinLowSectAddr;
			if (MinLowSectAddrFilePos)
				m_Section->SizeOfRawData = MinLowSectAddrFilePos;
		}

		if (m_SectCount > 0
			&& m_PEHead.AddressOfEntryPoint >= m_Section[m_SectCount].VirtualSize
							+ m_Section[m_SectCount].VirtualAddress)
		{
			if (m_PEHead.AddressOfEntryPoint >= m_PEHead.SizeOfImage)
			{
				if (m_FileSize >= m_Section[m_SectCount].PointerToRawData)
					m_Section[m_SectCount].SizeOfRawData = m_FileSize
								- m_Section[m_SectCount].PointerToRawData;
			} else
			{
				m_Section[m_SectCount].VirtualSize = m_PEHead.SizeOfImage
								- m_Section[m_SectCount].VirtualAddress;
			}
		}
		m_FileType = 0x313;

		if ( !(m_FileObjType & 0x4000000)) //FILE_OBJ_MEMORY
			m_ImageBase = m_PEHead.ImageBase;

		m_ImageSize = ALIGN_SIZE(m_PEHead.SizeOfImage, 4096);

		if (m_SectCount > 0
			&& m_Section[m_SectCount].SizeOfRawData + m_Section[m_SectCount].VirtualAddress > m_ImageSize)
		{
			m_ImageSize = m_Section[m_SectCount].SizeOfRawData + m_Section[m_SectCount].VirtualAddress;
			MIN_LIMIT(m_Section[m_SectCount].VirtualSize, m_Section[m_SectCount].SizeOfRawData);
		}

		m_EntryPoint = m_ImageBase + m_PEHead.AddressOfEntryPoint;
		if (m_ImageSize < MaxHighSectAddr && MaxHighSectAddr < 0x1000000)
			m_ImageSize = MaxHighSectAddr;
		if (m_ImageSize > 0x1000000 && MaxHighSectAddr < 0x1000000)
			m_ImageSize = MaxHighSectAddr;
		m_ImageHighBase = m_ImageBase + m_ImageSize;

		if (!Check())
		{
			if (m_Section)
			{
				delete []m_Section;
				m_Section = nullptr;
			}
			m_SectCount = 0;
			CImageFile::Close();
			return false;
		}

		GetTLS();

		m_ImportModuleCount = 0;
		m_ImportModule = 0;

		if (!(m_OpenMode & PE_OPEN_NO_IMPORT))
			GetImportModule();

		m_ExportFuncCount = 0;
		m_ExportFunc = 0;

		if (!(m_OpenMode & PE_OPEN_NO_EXPORT))
			GetExportFunc();

		m_ErrorCode = PE_ERROR_SUCCESS;
		return true;
	}

	void CPEFile::Close()
	{
		for (int n = 0; n < m_ImportModuleCount; ++n)
		{
			if (m_ImportModule[n].FuncList)
			{
				delete []m_ImportModule[n].FuncList;
				m_ImportModule[n].FuncList = nullptr;
			}
		}

		if (m_ImportModule)
		{
			delete []m_ImportModule;
			m_ImportModule = nullptr;
		}

		for (int n = 0; n < m_ResDirCount; ++n)
		{
			if (m_ResDir[n].ResDataDir)
			{
				delete []m_ResDir[n].ResDataDir;
				m_ResDir[n].ResDataDir = nullptr;
			}
		}

		if (m_ResDir)
		{
			delete []m_ResDir;
			m_ResDir = nullptr;
		}

		for (int n = 0; n < m_BaseRelocCount; ++n)
		{
			if (m_BaseReloc[n].TypeOffset)
			{
				delete []m_BaseReloc[n].TypeOffset;
				m_BaseReloc[n].TypeOffset = nullptr;
			}
		}

		if (m_BaseReloc)
		{
			delete []m_BaseReloc;
			m_BaseReloc = nullptr;
		}

		if (m_TLSCallBackFuncs)
		{
			delete []m_TLSCallBackFuncs;
			m_TLSCallBackFuncs = nullptr;
		}

		if (m_TLSData)
		{
			delete []m_TLSData;
			m_TLSData = nullptr;
		}

		if (m_ExportFunc)
		{
			delete []m_ExportFunc;
			m_ExportFunc = nullptr;
		}

		if (m_Section)
		{
			delete []m_Section;
			m_Section = nullptr;
		}

		m_ExportFuncCount = 0;
		m_TLSDataSize = 0;
		m_TLSCallBackCount = 0;
		m_AddressOfTLSIndex = 0;
		m_BaseRelocCount = 0;
		m_ResDirCount = 0;
		m_ImportModuleCount = 0;
		m_SectCount = 0;
		CImageFile::Close();
	}

	void CPEFile::RelocLoad(ULONG_PTR BaseAddr)
	{
		ULONG_PTR Delta = BaseAddr - m_ImageBase;
		if (BaseAddr != m_ImageBase && BaseAddr)
		{
			CImageFile::RelocLoad(BaseAddr);

			if (m_TLSCallBackFuncs)
			{
				for (int n = 0; n < m_TLSCallBackCount; ++n)
					m_TLSCallBackFuncs[n] += Delta;
			}

			GetBaseReloc();

			for (int n = 0; n < m_ImportModuleCount; ++n)
			{
				IMPORT_FUNC *pImportFunc = m_ImportModule[n].FuncList;
				for (int m = 0; m < m_ImportModule[n].FuncCount; ++m)
				{
					pImportFunc[m].NameAddr += Delta;
					pImportFunc[m].ThunkAddr += Delta;
				}
			}

			for (int n = 0; n < m_ExportFuncCount; ++n)
			{
				if (m_ExportFunc[n].Address)
					m_ExportFunc[n].Address += Delta;
				if (m_ExportFunc[n].Thunk)
					m_ExportFunc[n].Thunk += Delta;
			}
		}

	}

  bool CPEFile::IsRelocArea(unsigned long HiAddr, unsigned long LowAddr)
	{
		for (int n = 0; n < m_BaseRelocCount; ++n)
		{
			unsigned long low = m_BaseReloc[n].VirtualAddr;
			unsigned long hi = m_BaseReloc[n].VirtualAddr + 4096;

			if (HiAddr >= low && HiAddr < hi)
				return true;
			if (LowAddr > low && LowAddr <= hi)
				return true;
			if (HiAddr <= low && LowAddr >= hi)
				return true;
		}
		return false;
	}

  bool CPEFile::IsImportThunkArea(unsigned long LowAddr, unsigned long HiAddr)
	{
		unsigned long low;
		unsigned long hi;

		if (!GetImportThunkArea(&low, &hi))
			return false;
		if (LowAddr >= low && LowAddr < hi)
			return true;
		if (HiAddr > low && HiAddr <= hi)
			return true;
		if (LowAddr <= low && HiAddr >= hi)
			return true;
		return false;
	}

  bool CPEFile::GetImportThunkArea(unsigned long *LowAddr, unsigned long *HiAddr)
	{
		if (!m_ImportModuleCount)
			return false;
		ULONG_PTR low = -1;
		ULONG_PTR hi = 0;
		IMPORT_MODULE *Import = m_ImportModule;
		for (int i = 0; i < m_ImportModuleCount; ++i)
		{
			IMPORT_FUNC *Func = Import->FuncList;
			for (int j = 0; j < Import->FuncCount; ++j)
			{
				MAX_LIMIT(low, Func->ThunkAddr);
				MIN_LIMIT(hi, Func->ThunkAddr);
				++Func;
			}
			++Import;
		}
		if (low >= hi)
			return false;
		*LowAddr = low - m_ImageBase;
		*HiAddr = hi - m_ImageBase;
		return true;
	}
#ifdef _X64_
	#pragma pack(push,1)
	struct TLS_DIRECTORY64
	{
	  /* 0x0000 */ ULONG_PTR StartAddressOfRawData;
	  /* 0x0004 */ ULONG_PTR EndAddressOfRawData;
	  /* 0x0008 */ ULONG_PTR AddressOfIndex;
	  /* 0x000c */ ULONG_PTR AddressOfCallBacks;
	  /* 0x0010 */ unsigned long SizeOfZeroFill;
	  /* 0x0014 */ unsigned long Characteristics;
	}; /* size: 0x0018 */
	#pragma pack(pop)
#else
	#pragma pack(push,1)
	struct TLS_DIRECTORY32
	{
	  /* 0x0000 */ unsigned long StartAddressOfRawData;
	  /* 0x0004 */ unsigned long EndAddressOfRawData;
	  /* 0x0008 */ unsigned long AddressOfIndex;
	  /* 0x000c */ unsigned long AddressOfCallBacks;
	  /* 0x0010 */ unsigned long SizeOfZeroFill;
	  /* 0x0014 */ unsigned long Characteristics;
	}; /* size: 0x0018 */
	#pragma pack(pop)
#endif
	void CPEFile::GetTLS()
	{
		if (!m_PEHead.DataDirectory[9].VirtualAddress)
			return;

		unsigned long Address; //???
		if (!MapToFile((ULONG_PTR)m_PEHead.DataDirectory[9].VirtualAddress, &Address, false))
			return;
#ifdef _X64_
		TLS_DIRECTORY64 TLSDir;
#else
		TLS_DIRECTORY32 TLSDir;
#endif
		CImageFile::ReadFile(Address, &TLSDir, sizeof(TLSDir));

		if (!TLSDir.AddressOfCallBacks)
			return;

		if (!MapToFile(TLSDir.AddressOfCallBacks, &Address, true))
			return;

		m_TLSCallBackCount = 0;
		m_TLSCallBackFuncs = 0;

		ULONG_PTR Pos;
		while (CImageFile::ReadFile(Address + m_TLSCallBackCount*sizeof(ULONG_PTR), &Pos, sizeof(ULONG_PTR))
				&& m_TLSCallBackCount < 512 && Pos)
			++m_TLSCallBackCount;

		if (m_TLSCallBackCount > 0)
		{
			if (m_TLSCallBackCount >= 512)
			{
				m_TLSCallBackCount = 0;
				return;
			}

			m_TLSCallBackFuncs = new ULONG_PTR[m_TLSCallBackCount];
			if (!m_TLSCallBackFuncs)
				return;
		
			CImageFile::ReadFile(Address, m_TLSCallBackFuncs, sizeof(ULONG_PTR) * m_TLSCallBackCount);
		}

		m_TLSDataSize = 0;
		if (!TLSDir.AddressOfIndex)
			return;
		
		m_TLSDataSize = TLSDir.EndAddressOfRawData - TLSDir.StartAddressOfRawData;
		if (m_TLSDataSize <= 0 || m_TLSDataSize >= 0x10000)
		{
			m_AddressOfTLSIndex = 0;
			m_TLSDataSize = 0;
			return;
		}
		
		m_TLSData = new unsigned char[m_TLSDataSize]; //???
		if (!m_TLSData)
		{
			if (m_TLSCallBackFuncs)
			{
				delete []m_TLSCallBackFuncs;
				m_TLSCallBackFuncs = 0;
			}
		}
		
		ReadMemory(TLSDir.StartAddressOfRawData, m_TLSData, m_TLSDataSize);
		m_AddressOfTLSIndex = TLSDir.AddressOfIndex;
	}

	#pragma pack(push,1)
	struct IMAGE_BASE_RELOC
	{
		unsigned long VirtualAddress;
		unsigned long BlockSize;
	};
	#pragma pack(pop)

	void CPEFile::GetBaseReloc()
	{
		if (!m_PEHead.DataDirectory[5].VirtualAddress)
			return;

		unsigned long Address;
		if (!MapToFile((ULONG_PTR)m_PEHead.DataDirectory[5].VirtualAddress, &Address, false))
			return;
		
		IMAGE_BASE_RELOC BaseReloc;

		m_BaseRelocCount = 0;

		unsigned long ImageRelocBasePos;

		for (ImageRelocBasePos = Address;
			CImageFile::ReadFile(ImageRelocBasePos, &BaseReloc, sizeof(IMAGE_BASE_RELOC))
			&& BaseReloc.BlockSize
			&& BaseReloc.BlockSize > 8 && BaseReloc.BlockSize <= 0x1008;
			ImageRelocBasePos += BaseReloc.BlockSize )
		{
			++m_BaseRelocCount;
		}

		if (m_BaseRelocCount < 1 || m_BaseRelocCount > 4096)
		{
			m_BaseRelocCount = 0;
			return;
		}
		
		m_BaseReloc = new BASE_RELOC[m_BaseRelocCount];
		if (!m_BaseReloc)
			return;
		
		memset(m_BaseReloc, 0, sizeof(BASE_RELOC) * m_BaseRelocCount);
		unsigned long ImageRelocPos = Address;
		for (unsigned long n = 0; n < m_BaseRelocCount; ++n)
		{
			CImageFile::ReadFile(ImageRelocPos, &BaseReloc, sizeof(IMAGE_BASE_RELOC));
			m_BaseReloc[n].VirtualAddr = BaseReloc.VirtualAddress;
			m_BaseReloc[n].Count = (BaseReloc.BlockSize - sizeof(BASE_RELOC))/2;
			if (m_BaseReloc[n].Count <= 1024)
			{
				if (m_BaseReloc[n].Count)
					m_BaseReloc[n].TypeOffset = new unsigned short[m_BaseReloc[n].Count]; //*2

				if (!m_BaseReloc[n].TypeOffset)
				{
					m_BaseRelocCount = n;
					return;
				}

				if (!CImageFile::ReadFile(ImageRelocPos + sizeof(BASE_RELOC), m_BaseReloc[n].TypeOffset,
								m_BaseReloc[n].Count*2))
				{
					delete []m_BaseReloc[n].TypeOffset;
					m_BaseRelocCount = n;
					return;
				}
				ImageRelocPos += BaseReloc.BlockSize;
			} else
			{
				m_BaseReloc[n].Count = 0;
			}
		}
	}

	#pragma pack(push,1)
	struct IMPORT_DESCR
	{
	  union
	  {
	    /* 0x0000 */ unsigned long Characteristics;
	    /* 0x0000 */ unsigned long OriginalFirstThunk;
	  }; /* size: 0x0004 */
	  /* 0x0004 */ unsigned long TimeDateStamp;
	  /* 0x0008 */ unsigned long ForwarderChain;
	  /* 0x000c */ unsigned long Name;
	  /* 0x0010 */ unsigned long FirstThunk;
	}; /* size: 0x0014 */
	#pragma pack(pop)

	void CPEFile::GetImportModule()
	{
		if (!m_PEHead.DataDirectory[1].VirtualAddress)
			return;
		
		m_ImportModuleCount = 0;
		ULONG_PTR ImportDescPos = m_ImageBase + m_PEHead.DataDirectory[1].VirtualAddress;
		IMPORT_DESCR *pImportDesc = new IMPORT_DESCR[256];
		if (!pImportDesc)
			return;
		
		int ModuleCount = 0;
		while (ModuleCount < 256
			&& ReadMemory(ImportDescPos, &pImportDesc[ModuleCount], sizeof(IMPORT_DESCR)) == sizeof(IMPORT_DESCR)
			&& pImportDesc[ModuleCount].FirstThunk)
		{
			++ModuleCount;
			ImportDescPos += sizeof(IMPORT_DESCR);
		}

		if (ModuleCount <= 0 || ModuleCount >= 256)
		{
			delete []pImportDesc;
			return;
		}

		ULONG_PTR *pFuncThunk = new ULONG_PTR[0x1000];
		if (!pFuncThunk)
		{
			delete []pImportDesc;
			return;
		}

		
		m_ImportModuleCount = ModuleCount;
		m_ImportModule = new IMPORT_MODULE[ModuleCount];
		if (!m_ImportModule)
		{
			delete []pFuncThunk;
			delete []pImportDesc;
			return;
		}

		
		memset(m_ImportModule, 0, sizeof(IMPORT_MODULE) * ModuleCount);
		ModuleCount = 0;
		IMPORT_MODULE *pImportModule = m_ImportModule;
		while (ModuleCount < m_ImportModuleCount
			&& pImportDesc[ModuleCount].FirstThunk
			&& CImageFile::ReadString(
				m_ImageBase + pImportDesc[ModuleCount].Name,
				pImportModule->FileName,
				0x40,
				0x18) )
		{
			pImportModule->RVA = m_ImageBase + pImportDesc[ModuleCount].Name;
			TGetFileTitle(pImportModule->FileName, pImportModule->ModuleName);
			int FuncCount = 0;

			if (pImportDesc[ModuleCount].OriginalFirstThunk)
				FuncCount = CImageFile::ReadString(
					m_ImageBase + pImportDesc[ModuleCount].OriginalFirstThunk,
					(ULONG_PTR*)pFuncThunk,
					0x1000,
					0x18);
			if (!FuncCount)
				FuncCount = CImageFile::ReadString(
					m_ImageBase + pImportDesc[ModuleCount].FirstThunk,
					(ULONG_PTR*)pFuncThunk,
					0x1000,
					0x18);
			if (!FuncCount)
				break;

			if (FuncCount < 4096)
			{
				pImportModule->FuncCount = FuncCount;
				IMPORT_FUNC *pImportFunc = new IMPORT_FUNC[FuncCount];
				pImportModule->FuncList = pImportFunc;
				if (!pImportFunc && m_ImportModule)
				{
					delete []m_ImportModule;
					m_ImportModule = 0;
					delete []pFuncThunk;
					delete []pImportDesc;
					return;
				}

				memset(pImportFunc, 0, sizeof(IMPORT_FUNC) * FuncCount);
				int FuncThunkPos = 0;
				unsigned long FuncThunkAddrPos = pImportDesc[ModuleCount].FirstThunk;
				while (FuncThunkPos < pImportModule->FuncCount)
				{
					ULONG_PTR FuncCallAddr = pFuncThunk[FuncThunkPos];
				#ifdef _X64_
					bool bUseOrd = (FuncCallAddr & 0x8000000000000000ULL)!=0
				#else
					bool bUseOrd = (FuncCallAddr & 0x80000000)!=0
				#endif
						&& (FuncCallAddr < m_ImageBase || FuncCallAddr >= m_ImageHighBase); //!InBaseRange(FunCallAddr)
					pImportFunc->bUseOrd = bUseOrd;
					if (pImportFunc->bUseOrd)
					{
						pImportFunc->FuncOrd = (pFuncThunk[FuncThunkPos]) & 0xffff; //???
						TSPrintf(pImportFunc->FuncName, "Function_ORD_%04X", pImportFunc->FuncOrd);
					} else
					{
						pImportFunc->NameAddr = FuncCallAddr;
						if (m_FileObjType & 0x4000000) //FILE_OBJ_MEMORY
						{
							if (FuncCallAddr < m_ImageBase)
								pImportFunc->NameAddr += m_ImageBase;
						} else
						{
							pImportFunc->NameAddr += m_ImageBase;
						}

						if (!CImageFile::ReadString(
							pImportFunc->NameAddr + 2,
							pImportFunc->FuncName,
							0x40,
							0x18) )
						break;
					}
					pImportFunc->ThunkAddr = m_ImageBase + FuncThunkAddrPos;
					++FuncThunkPos;
					FuncThunkAddrPos += sizeof(ULONG_PTR);
					++pImportFunc;
				}
				pImportModule->FuncCount = FuncThunkPos;
			}
			++ModuleCount;
			++pImportModule;
		}
		m_ImportModuleCount = ModuleCount;
		delete []pFuncThunk;
		delete []pImportDesc;
	}

	#pragma pack(push,1)
	struct EXPORT_DESCR
	{
	  /* 0x0000 */ unsigned long Characteristics;
	  /* 0x0004 */ unsigned long TimeDateStamp;
	  /* 0x0008 */ unsigned short MajorVersion;
	  /* 0x000a */ unsigned short MinorVersion;
	  /* 0x000c */ unsigned long Name;
	  /* 0x0010 */ unsigned long Base;
	  /* 0x0014 */ unsigned long NumberOfFunctions;
	  /* 0x0018 */ unsigned long NumberOfNames;
	  /* 0x001c */ unsigned long AddressOfFunctions;
	  /* 0x0020 */ unsigned long AddressOfNames;
	  /* 0x0024 */ unsigned long AddressOfNameOrdinals;
	}; /* size: 0x0028 */
	#pragma pack(pop)

	void CPEFile::GetExportFunc()
	{
		m_ExportFuncCount = 0;

		if (!m_PEHead.DataDirectory[0].VirtualAddress)
			return;
		
		EXPORT_DESCR Export;
		if (ReadMemory(m_ImageBase + m_PEHead.DataDirectory[0].VirtualAddress, &Export, sizeof(EXPORT_DESCR)) != sizeof(EXPORT_DESCR))
			return;
		
		unsigned long FuncSize = Export.NumberOfFunctions;
		unsigned long NameSize = Export.NumberOfNames;

		if (FuncSize < 1 || FuncSize > 65535)
			return;

		if (NameSize > 4096)
			return;

		m_ExportFunc = new EXPORT_FUNC[FuncSize];
		if (!m_ExportFunc)
			return;
		
		memset(m_ExportFunc, 0, sizeof(EXPORT_FUNC) * FuncSize);
		unsigned long FuncNameAddrPos = Export.AddressOfNames;
		unsigned long FuncOrdPos = Export.AddressOfNameOrdinals;
		unsigned long FuncAddrPos = Export.AddressOfFunctions;

		unsigned long n;
		for (n = 0; n < FuncSize; ++n)
		{
			unsigned long FuncName;
			if (!ReadMemory(m_ImageBase + FuncNameAddrPos, &FuncName, 4))
				break;

			unsigned short FuncOrd;
			if (n < NameSize)
			{
				CImageFile::ReadString(m_ImageBase + FuncName, m_ExportFunc[n].FuncName,
							0x40, 0x18);

				ReadMemory(m_ImageBase + FuncOrdPos + n*2, &FuncOrd, 2);
			} else
			{
				FuncOrd = (Export.Base & 0xffff) + n; //???
				TStrCpy(m_ExportFunc[n].FuncName, "Export_by_Ord_");
				uNumToStr(FuncOrd, &m_ExportFunc[n].FuncName[sizeof("Export_by_Ord_")-1], 16);
			}

			if (FuncOrd >= FuncSize)
			{
				m_ExportFunc[n].Address = 0;
				m_ExportFunc[n].Thunk = 0;
			} else
			{
				unsigned long FuncAddr;
				if (!ReadMemory(m_ImageBase + FuncAddrPos + FuncOrd*4, &FuncAddr, 4))
					break;

				if (FuncAddr)
				{
					m_ExportFunc[n].Address = m_ImageBase + FuncAddr;
				}

				m_ExportFunc[n].Thunk = m_ImageBase + FuncAddrPos + FuncOrd*4;
				m_ExportFunc[n].FuncOrd = Export.Base + FuncOrd;
			}
			FuncNameAddrPos += 4;
		}
		m_ExportFuncCount = n;
	}

	#pragma pack(push,1)
	struct RESOURCE_DIRECTORY
	{
	  /* 0x0000 */ unsigned long Characteristics;
	  /* 0x0004 */ unsigned long TimeDateStamp;
	  /* 0x0008 */ unsigned short MajorVersion;
	  /* 0x000a */ unsigned short MinorVersion;
	  /* 0x000c */ unsigned short NumberOfNamedEntries;
	  /* 0x000e */ unsigned short NumberOfIdEntries;
	}; /* size: 0x0010 */

	struct RESOURCE_DATA_ENTRY
	{
	  /* 0x0000 */ unsigned long OffsetToData;
	  /* 0x0004 */ unsigned long Size;
	  /* 0x0008 */ unsigned long CodePage;
	  /* 0x000c */ unsigned long Reserved;
	}; /* size: 0x0010 */

	struct RESOURCE_DIRECTORY_ENTRY
	{
	  /* 0x0000 */ unsigned long Name;
	  /* 0x0004 */ unsigned long OffsetToData;
	}; /* size: 0x0008 */
	
	struct RESOURCE_DIRECTORY_STRING
	{
	  /* 0x0000 */ unsigned short Length;
	  /* 0x0002 */ char NameString[1];
	}; /* size: 0x0004 */
	#pragma pack(pop)


  void CPEFile::GetResource()
	{
		int DataPos;
		int ResPos;
		unsigned int NameSize2;
		unsigned int NameSize2_v5;
		int NameAddress;
		int NameAddr;
		int MixAddress;
		unsigned short NameSize;
		int ResourceAddress;
		int DataAddress;
		RESOURCE_DATA_ENTRY ResourceDataEntry; //???

		if (m_ResDir)
			return;
		
		if (!m_PEHead.DataDirectory[2].VirtualAddress)
			return;
		
		ResourceAddress = m_ImageBase + m_PEHead.DataDirectory[2].VirtualAddress;

		RESOURCE_DIRECTORY ResourceDirectory;
		if (ReadMemory(ResourceAddress, &ResourceDirectory, sizeof(RESOURCE_DIRECTORY)) != sizeof(RESOURCE_DIRECTORY))
			return;
		
		m_ResDirCount = (unsigned __int16)ResourceDirectory.NumberOfNamedEntries
			+ (unsigned __int16)ResourceDirectory.NumberOfIdEntries;

		if (m_ResDirCount < 1 || m_ResDirCount > 1024)
		{
			m_ResDirCount = 0;
			return;
		}

		m_ResDir = new RES_DIR[m_ResDirCount];
		if (!m_ResDir)
			return;

		memset(m_ResDir, 0, sizeof(RES_DIR) * m_ResDirCount);

		for (ResPos = 0; ResPos < m_ResDirCount; ++ResPos)
		{
			//if (ResPos >= m_ResDirCount)
			//	return;

			RESOURCE_DIRECTORY_ENTRY DirEntry;
			if (ReadMemory(ResourceAddress + 8 * ResPos + 0x10, &DirEntry, 8) != 8)
				continue;

			if (!(DirEntry.OffsetToData & 0x80000000))
				continue;

			if (DirEntry.Name & 0x80000000)
			{
				NameAddress = (DirEntry.Name + ResourceAddress) & ~0x10000000;
				if (ReadMemory(NameAddress, &NameSize, 2) != 2)
					continue;

				NameSize2 = 2 * NameSize;

				if (NameSize2 >= 64)
					continue;

				if (ReadMemory(NameAddress + 2, m_ResDir[ResPos].TypeName, NameSize2) != NameSize2)
					continue;

				m_ResDir[ResPos].Type = -1;
			} else
			{
				m_ResDir[ResPos].Type = DirEntry.Name & 0xffff; //???
			}

			DataAddress = (DirEntry.OffsetToData + ResourceAddress) & ~0x80000000;

			if (ReadMemory(DataAddress, &ResourceDirectory, sizeof(RESOURCE_DIRECTORY)) != sizeof(RESOURCE_DIRECTORY))
				continue;

			m_ResDir[ResPos].ResCount = (unsigned __int16)ResourceDirectory.NumberOfNamedEntries
				+ (unsigned __int16)ResourceDirectory.NumberOfIdEntries;

			if (m_ResDir[ResPos].ResCount < 1 || m_ResDir[ResPos].ResCount > 4096)
			{
				m_ResDir[ResPos].ResCount = 0;
				continue;
			}

			if (m_ResDir[ResPos].ResCount)
				m_ResDir[ResPos].ResDataDir = new RES_DATA[m_ResDir[ResPos].ResCount];

			if (!m_ResDir[ResPos].ResDataDir)
				continue;
			
			memset(m_ResDir[ResPos].ResDataDir, 0, sizeof(RES_DATA) * m_ResDir[ResPos].ResCount);

			if (!m_ResDir[ResPos].ResDataDir) //???
				continue;
			
			for (DataPos = 0; DataPos < m_ResDir[ResPos].ResCount; ++DataPos)
			{
				//if (DataPos >= m_ResDir[ResPos].ResCount)
				//	break;

				if (ReadMemory(DataAddress + 8 * DataPos + 0x10, &DirEntry, 8) != 8)
					continue;

				if (!(DirEntry.OffsetToData & 0x80000000))
					continue;
				
				if (DirEntry.Name & 0x80000000)
				{
					NameAddr = (DirEntry.Name + ResourceAddress) & ~0x80000000;
					if (ReadMemory(NameAddr, &NameSize, 2) != 2)
						continue;
				
					MAX_LIMIT(NameSize, 64);

					NameSize2_v5 = 2 * NameSize;
					if (ReadMemory(NameAddr + 2, m_ResDir[ResPos].ResDataDir[DataPos].IDName,
						NameSize2_v5) != NameSize2_v5)
							continue;
				
					m_ResDir[ResPos].ResDataDir[DataPos].IDName[NameSize2_v5 >> 1] = 0;
				} else
				{

					m_ResDir[ResPos].ResDataDir[DataPos].ID = DirEntry.Name & 0xffff; //???
				}

				MixAddress = (DirEntry.OffsetToData + ResourceAddress) & ~0x80000000;

				if (ReadMemory(MixAddress, &ResourceDirectory, sizeof(RESOURCE_DIRECTORY)) != sizeof(RESOURCE_DIRECTORY))
					continue;

				if (ResourceDirectory.NumberOfIdEntries != 1)
					continue;

				if (ReadMemory(MixAddress + 0x10, &DirEntry, 8) != 8)
					continue;

				if ((DirEntry.OffsetToData & 0x80000000))
					continue;

				if (ReadMemory(MixAddress, &ResourceDataEntry, sizeof(RESOURCE_DIRECTORY)) != sizeof(RESOURCE_DIRECTORY))
					continue;
				
				m_ResDir[ResPos].ResDataDir[DataPos].CodePage = ResourceDataEntry.CodePage;
				m_ResDir[ResPos].ResDataDir[DataPos].Size = ResourceDataEntry.Size;
				m_ResDir[ResPos].ResDataDir[DataPos].BufferAddr = m_ImageBase + ResourceDataEntry.OffsetToData;
			}
		}
	}

  int CPEFile::GetLastPhyPosSection() const
	{
		unsigned long Last = 0;
		int Pos = 0;
		for (int i = 1; i < m_SectCount; ++i) //??? <=
		{
			if (Last < m_Section[i].PointerToRawData)
			{
				Last = m_Section[i].PointerToRawData;
				Pos = i;
			}
		}
		return Pos;
	}

  int CPEFile::GetLastMemAddrSection() const
	{
		unsigned long Last = 0;
		int Pos = 0;
		for (int n = 1; n <= m_SectCount; ++n)
		{
			if (Last < m_Section[n].VirtualAddress)
			{
				Last = m_Section[n].VirtualAddress;
				Pos = n;
			}
		}
		return Pos;
	}

  int CPEFile::GetFirstPhyPosSection() const
	{
		int Pos = 0;
		unsigned long First = 0;
		for (int n = 1; n <= m_SectCount; ++n)
		{
			if (First >= m_Section[n].PointerToRawData)
			{
				First = m_Section[n].PointerToRawData;
				Pos = n;
			}
		}
		return Pos;
	}

  int CPEFile::GetFirstMemAddrSection() const
	{
		int Pos = 0;
		unsigned long First = 0;
		for (int n = 1; n <= m_SectCount; ++n)
		{
			if (First >= m_Section[n].VirtualAddress)
			{
				First = m_Section[n].VirtualAddress;
				Pos = n;
			}
		}
		return Pos;
	}

  ULONG_PTR CPEFile::GetExportFunc(const char *Name, unsigned long *Index) const
	{
		for (int n = 0; n < m_ExportFuncCount; ++n)
		{
			if (!TStrCmp(m_ExportFunc[n].FuncName, Name))
			{
				if (Index)
					*Index = n;
				return m_ExportFunc[n].Address;
			}
		}
		return 0;
	}

  ULONG_PTR CPEFile::GetExportFunc(unsigned long Ord) const
	{
		for (int n = 0; n < m_ExportFuncCount; ++n)
		{
			if (m_ExportFunc[n].FuncOrd == Ord)
				return m_ExportFunc[n].Address;
		}
		return 0;
	}

  int CPEFile::LoadStringW(unsigned long ID, WCHAR *Name, int Size)
	{
		int result;
		int nDir;
		int ResDataAddress;
		unsigned int nID;
		int i;
		unsigned int ResDataSize;
		int v12;
		int count_v13;
		char *p_v14;
		unsigned int nv15;
		int nv15a;

		if (Size < 2)
		{
			*Name = 0;
			return 0;
		}
		
		GetResource();
		RES_DIR *pDir = 0;
		for (nDir = 0; nDir < m_ResDirCount; ++nDir)
		{
			if (m_ResDir[nDir].Type == 6) //???
			{
				pDir = &m_ResDir[nDir];
				break;
			}
		}

		if (!pDir)
		{
			return 0;
		}
		
		for (i = 0; i < pDir->ResCount; ++i)
		{
			if ( (ID >> 4) + 1 == pDir->ResDataDir[i].ID)
			{
				ResDataAddress = pDir->ResDataDir[i].BufferAddr;
				ResDataSize = pDir->ResDataDir[i].Size;
				break;
			}
		}

		if (i >= pDir->ResCount || !ResDataAddress)
		{
			*Name = 0;
			return 0;
		}
		
		nID = ID % 16;
		if (ResDataSize >= 0xFFFF)
		{
			*Name = 0;
			return 0;
		}
		
		p_v14 = new char[ResDataSize];
		if (!p_v14)
		{
			*Name = 0;
			return 0;
		}

		
		if (!ReadMemory(ResDataAddress, p_v14, ResDataSize))
		{
			delete []p_v14;
			*Name = 0;
			return 0;
		}

		
		nv15 = 0;
		while (nv15 < ResDataSize && nID)
		{
			v12 = *(unsigned __int16 *)&p_v14[nv15];
			nv15 += 2;
			if (v12)
				nv15 += 2 * v12;
			--nID;
		}

		if (nID || nv15 >= ResDataSize)
		{
			delete []p_v14;
			*Name = 0;
			return 0;
		}
		
		count_v13 = *(unsigned __int16 *)&p_v14[nv15];
		MAX_LIMIT(count_v13, (Size-2)/2);

		nv15a = nv15 + 2;
		if (nv15a + 2 * count_v13 > ResDataSize)
			count_v13 = 0;
		else
			memcpy((void *)Name, &p_v14[nv15a], count_v13*2);
		Name[count_v13] = 0;
		delete p_v14;
		return count_v13;
	}

  int CPEFile::LoadStringA(unsigned long ID, char *Name, int Size)
	{
		WCHAR *pName = new WCHAR[Size]; //2
		if (!pName)
			return 0;
		*pName = 0;
		LoadStringW(ID, pName, Size*2);
		//int i = TStrCpy(Name, pName);
		int n = 0;
		for (; pName[n]; ++n)
			Name[n] = pName[n];
		Name[n] = 0;
		delete []pName;
		return n;
	}

  RES_DATA *CPEFile::FindResource(const unsigned short *IDName, unsigned long ID, const unsigned short *Name, unsigned long Type)
	{
		GetResource();

		RES_DIR *ResDir = 0;
		for (int n = 0; n < m_ResDirCount; ++n)
		{
			if ((Name && !TStrICmp(m_ResDir[n].TypeName, Name)) ||
				m_ResDir[n].Type == Type)
			{
				ResDir = &m_ResDir[n];
				break;
			}
		}
		if (!ResDir)
			return 0;

		for (int n = 0; n < ResDir->ResCount; ++n)
		{
			if (IDName)
			{
				if (!TStrICmp(ResDir->ResDataDir[n].IDName, IDName))
				{
				//	v6 = ResDir->ResDataDir[n].BufferAddr;
				//	v7 = ResDir->ResDataDir[n].Size;
					return &ResDir->ResDataDir[n];
				}
			} else
			if (ID == ResDir->ResDataDir[n].ID)
			{
			//	v8 = ResDir->ResDataDir[n].BufferAddr;
			//	v9 = ResDir->ResDataDir[n].Size;
				return &ResDir->ResDataDir[n];
			}
		}
		return 0;
	}

  bool CPEFile::GetSectionIndex(ULONG_PTR Address, int *Index) const
	{
		unsigned long VirtualAddress = Address - m_ImageBase;
		for (int n = 0; n < m_SectCount; ++n)
		{
			if (VirtualAddress >= m_Section[n].VirtualAddress &&
				VirtualAddress < m_Section[n].VirtualAddress + m_Section[n].VirtualSize)
			{
				if (Index)
					*Index = n;
				return true;
			}
		}
		return false;
	}

	bool CPEFile::Check()
	{
		if (m_ImageBase && m_ImageSize)
			return true;
		m_ErrorCode = PE_ERROR_HEAD;
		return false;
	}

	IMPORT_MODULE *CPEFile::GetImportModule(const char *FileName) const
	{
		for (int n = 0; n < m_ImportModuleCount; ++n)
		{
			if (!TStrICmp(m_ImportModule[n].FileName, FileName) ||
			    !TStrICmp(m_ImportModule[n].ModuleName, FileName))
			{
				return &m_ImportModule[n];
			}
		}
		return nullptr;
	}

	IMPORT_FUNC *CPEFile::GetImportFunc(IMPORT_MODULE *pImportModule, const char *Name) const
	{
		for (int n = 0; n < pImportModule->FuncCount; ++n)
		{
			if (!TStrICmp(pImportModule->FuncList[n].FuncName, Name))
				return &pImportModule->FuncList[n];
		}
		return nullptr;
	}

	IMPORT_FUNC *CPEFile::GetImport(const char *FileName, char *FuncName) const
	{
		IMPORT_MODULE *ImportModule = GetImportModule(FileName);
		if (ImportModule)
			return GetImportFunc(ImportModule, FuncName);
		return nullptr;
	}

	bool CPEFile::GetDataDir(unsigned long Index, PE_DATA_DIR *DataDir) const
	{
		if (Index >= 16)
			return false;

		if (DataDir)
		{
			DataDir->VirtualAddress = m_PEHead.DataDirectory[Index].VirtualAddress;
			DataDir->Size = m_PEHead.DataDirectory[Index].Size;
		}
		return true;

	}

	bool CPEFile::Open(ULONG_PTR ImageBase, int OpenMode, unsigned long (*RMFunc)(ULONG_PTR, void*, unsigned long, void*), void *RMObj)
	{
		if (OpenMode)
			m_OpenMode |= OpenMode;
		SetRelocRead(RMFunc, RMObj);
		m_ImageBase = ImageBase;
		m_FileObjType = 0x4000000; //FILE_OBJ_MEMORY
		return Open(0, 0);
	}


//???
struct DATASTRUCT
{
  /* 0x0000 */ unsigned long Length;
  /* 0x0004 */ unsigned long Size;
}; /* size: 0x0008 */


```

`source/EXEAnalyzer/pefile.hpp`:

```hpp

#ifndef _PEFILE_HPP_
#define _PEFILE_HPP_

#include "../Code/imagefile.hpp"
#include "pehead.hpp"
#include "mzhead.hpp"
	
	struct PE_SECTION
	{
		char Name[8];
		unsigned long VirtualSize; //PhysicalAddress
		unsigned long VirtualAddress;
		unsigned long SizeOfRawData;
		unsigned long PointerToRawData;
		unsigned long PointerToRelocations;
		unsigned long PointerToLinenumbers;
		unsigned short NumberOfRelocations;
		unsigned short NumberOfLinenumbers;
		unsigned long Characteristics;
	};


	struct IMPORT_FUNC
	{
		char FuncName[64];
		ULONG_PTR NameAddr;
		ULONG_PTR ThunkAddr; //RVA
		unsigned long Address;
		unsigned long FuncOrd;
		bool bUseOrd;
	};

	struct IMPORT_MODULE
	{
		char ModuleName[64];
		char FileName[64];
		IMPORT_FUNC *FuncList;
		int FuncCount;
		ULONG_PTR RVA;
	};

	struct EXPORT_FUNC
	{
		char FuncName[64];
		ULONG_PTR Address;
		unsigned long FuncOrd;
		ULONG_PTR Thunk;
	};


	struct RES_DATA
	{
		unsigned long CodePage;
		unsigned long ID;
		unsigned short IDName[64];
		unsigned long BufferAddr;
		unsigned long Size;
	};

	struct RES_DIR
	{
		unsigned long Type;
		unsigned short TypeName[64];
		int ResCount;
		RES_DATA *ResDataDir;
	};

	struct BASE_RELOC
	{
		unsigned long VirtualAddr;
		unsigned long Count;
		unsigned short *TypeOffset;
	};

struct CPEFile : public CImageFile
{
	CPEFile();

	bool MapToFile(ULONG_PTR MemAddr, unsigned long *pPhysAddr, bool bImageBase);
	bool MapToMemory(unsigned long MemAddr, ULONG_PTR *pPhysAddr, bool bImageBase);

	virtual bool Open(const char *FileName, HANDLE HandleOpen) override;
	virtual void Close() override;
	virtual unsigned long ReadImageMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) override;
	virtual unsigned long WriteImageMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size) override;
	virtual bool LoadPage(ULONG_PTR Address, void *Buffer) override;
	virtual unsigned long GetPageAttribute(ULONG_PTR Address) override;
	bool Check();
	virtual void RelocLoad(ULONG_PTR BaseAddr) override;
  bool IsRelocArea(unsigned long HiAddr, unsigned long LowAddr);
  bool IsImportThunkArea(unsigned long LowAddr, unsigned long HiAddr);
  bool GetImportThunkArea(unsigned long *LowAddr, unsigned long *HiAddr);
	void GetBaseReloc();
	void GetImportModule();
  ULONG_PTR GetExportFunc(unsigned long Ord) const;
  ULONG_PTR GetExportFunc(const char *Name, unsigned long *Index) const;
	void GetExportFunc();
	void GetTLS();
  void GetResource();
  int GetLastPhyPosSection() const;
  int GetLastMemAddrSection() const;
  int GetFirstPhyPosSection() const;
  int GetFirstMemAddrSection() const;
  bool GetSectionIndex(ULONG_PTR Address, int *Index) const;
  int LoadStringW(unsigned long ID, WCHAR *Name, int Size);
  int LoadStringA(unsigned long ID, char *Name, int Size);
  RES_DATA *FindResource(const unsigned short *IDName, unsigned long ID, const unsigned short *Name, unsigned long Type);

	IMPORT_MODULE *GetImportModule(const char *FileName) const;
	IMPORT_FUNC *GetImportFunc(IMPORT_MODULE *pImportModule, const char *Name) const;
	IMPORT_FUNC *GetImport(const char *FileName, char *FuncName) const;
	bool GetDataDir(unsigned long Index, PE_DATA_DIR *DataDir) const;
	bool Open(ULONG_PTR ImageBase, int OpenMode, unsigned long (*RMFunc)(ULONG_PTR, void*, unsigned long, void*), void *RMObj);

	//0x01
	#define PE_OPEN_DLL	  0x02
	#define PE_OPEN_SYS	  0x04
	//0x08
	#define PE_OPEN_NO_IMPORT 0x10
	#define PE_OPEN_NO_EXPORT 0x20
	//0x40
	//0x80

	unsigned long m_OpenMode;

	enum
	{
		PE_ERROR_SUCCESS = 0,
		PE_ERROR_SIGN = 1,
		PE_ERROR_SECTION = 2,
		PE_ERROR_MODULE_TYPE = 3,
		PE_ERROR_HEAD = 4,
	};

	unsigned long m_ErrorCode;
	unsigned long m_PEOff;

	PE_SECTION *m_Section;
	int m_SectCount;

	PE_HEAD m_PEHead;

	IMPORT_MODULE *m_ImportModule;
	int m_ImportModuleCount;

	EXPORT_FUNC *m_ExportFunc;
	int m_ExportFuncCount;

	RES_DIR *m_ResDir;
	int m_ResDirCount;

	BASE_RELOC *m_BaseReloc;
	int m_BaseRelocCount;

	unsigned char *m_TLSData;
	int m_TLSDataSize;

	unsigned long m_AddressOfTLSIndex;
	ULONG_PTR *m_TLSCallBackFuncs;
	int m_TLSCallBackCount;
};

#endif
```

`source/EXEAnalyzer/pehead.hpp`:

```hpp

#ifndef _PEHEAD_HPP_
#define _PEHEAD_HPP_

#pragma pack(push,1)
struct PE_DATA_DIR
{
  /* 0x0000 */ unsigned long VirtualAddress;
  /* 0x0004 */ unsigned long Size;
}; /* size: 0x0008 */
#pragma pack(pop)

#pragma pack(push,1)
struct PE_HEAD
{
  /* 0x0000 */ unsigned long Signature;
//_IMAGE_FILE_HEADER
  /* 0x0004 */ unsigned short Machine;
  /* 0x0006 */ unsigned short NumberOfSections;
  /* 0x0008 */ unsigned long TimeDateStamp;
  /* 0x000c */ unsigned long PointerToSymbolTable;
  /* 0x0010 */ unsigned long NumberOfSymbols;
  /* 0x0014 */ unsigned short SizeOfOptionalHeader;
  /* 0x0016 */ unsigned short Characteristics;
//_IMAGE_OPTIONAL_HEADER
  /* 0x0018 */ unsigned short Magic;
  /* 0x001a */ unsigned char MajorLinkerVersion;
  /* 0x001b */ unsigned char MinorLinkerVersion;
  /* 0x001c */ unsigned long SizeOfCode;
  /* 0x0020 */ unsigned long SizeOfInitializedData;
  /* 0x0024 */ unsigned long SizeOfUninitializedData;
  /* 0x0028 */ unsigned long AddressOfEntryPoint;
  /* 0x002c */ unsigned long BaseOfCode;
#ifndef _X64_
  /* 0x0030 */ unsigned long BaseOfData;
#endif
  /* 0x0034 */ ULONG_PTR ImageBase;
  /* 0x0038 */ unsigned long SectionAlignment;
  /* 0x003c */ unsigned long FileAlignment;
  /* 0x0040 */ unsigned short MajorOperatingSystemVersion;
  /* 0x0042 */ unsigned short MinorOperatingSystemVersion;
  /* 0x0044 */ unsigned short MajorImageVersion;
  /* 0x0046 */ unsigned short MinorImageVersion;
  /* 0x0048 */ unsigned short MajorSubsystemVersion;
  /* 0x004a */ unsigned short MinorSubsystemVersion;
  /* 0x004c */ unsigned long Win32VersionValue;
  /* 0x0050 */ unsigned long SizeOfImage;
  /* 0x0054 */ unsigned long SizeOfHeaders;
  /* 0x0058 */ unsigned long CheckSum;
  /* 0x005c */ unsigned short Subsystem;
  /* 0x005e */ unsigned short DllCharacteristics;
  /* 0x0060 */ ULONG_PTR SizeOfStackReserve;
  /* 0x0064 */ ULONG_PTR SizeOfStackCommit;
  /* 0x0068 */ ULONG_PTR SizeOfHeapReserve;
  /* 0x006c */ ULONG_PTR SizeOfHeapCommit;
  /* 0x0070 */ unsigned long LoaderFlags;
  /* 0x0074 */ unsigned long NumberOfRvaAndSizes;
//0 EXPORT
//1 IMPORT
//2 RESOURCE
//5 BASE RELOC
//9 TLS

  /* 0x0078 */ PE_DATA_DIR DataDirectory[16];
}; /* size: 0x00f8 */
#pragma pack(pop)

#endif
```

`source/EXEAnalyzer/sdsfile.hpp`:

```hpp

#ifndef _SDSFILE_HPP_
#define _SDSFILE_HPP_

#include <cvconst.h>

	#pragma pack(push, 1)
	struct SDSFILE
	{
		unsigned long Magic;
		unsigned long Version;
		unsigned long FileSize;
		unsigned long GlobalsLen;
		unsigned long HeaderSize;
		ULONG_PTR Globals; //BASICTYPE** //???
		unsigned long FilesLNLen;
		ULONG_PTR FilesLN; //FilesLN*
		unsigned long StringIndexesLen;
		ULONG_PTR StringIndexes; //unsigned long*	//char**
		ULONG_PTR StringsEntry; //char*
		unsigned long SrcFileNamesLen;
		ULONG_PTR SrcFileNames; //SrcFileNameID*
		unsigned long PublicSymbolsLen;
		ULONG_PTR PublicSymbols; //PUBSYM*
		ULONG_PTR CompilandUnits; // NOT USES
		unsigned long CompilandUnitsLen; // NOT USES
		unsigned long LocalsLen;
		ULONG_PTR Locals; //DATATYPE*
		unsigned long X1;
		unsigned long FunctionsLen;
		ULONG_PTR FunctionsEntry; //FUNCTION*
		ULONG_PTR Functions; //FUNCTION**
		unsigned long Sources; //??? ULONG_PTR
		unsigned long TimeStamp;
		unsigned long CheckSum;
		unsigned long SUB;
		ULONG_PTR ModuleName; //char*
		unsigned long ModuleNameLen;
		ULONG_PTR PDBFullFileName; //char*
		unsigned long PDBFullFileNameLen;
		ULONG_PTR FullFileName; //char*
		unsigned long FullFileNameLen;
		unsigned long CRCSUM;
		unsigned long SourcesCount;
		unsigned long X[40];
	};
	#pragma pack(pop)
	#define SDSFILE_MAGIC 0x53445346 //'SDSF'
	#define SDSFILE_SIZE sizeof(SDSFILE) //300
	#define SDSFILE_VERSION 266

	// GLOBALS
	#pragma pack(push, 1)
	struct NULLTYPE
	{
	};
	#pragma pack(pop)

	enum ELEM_TYPE
	{
		ELEM_BASE_TYPE	= 0,
		ELEM_POINTER	= 1,
		ELEM_POINTERREF	= 2,
		ELEM_ARRAY	= 3,
		ELEM_MANAGED_TYPE = 4,
		ELEM_CUSTOM_TYPE = 5,
		ELEM_ENUM	= 6,
	//{ UD
		ELEM_STRUCT	= 7,
		ELEM_CLASS	= 8,
		ELEM_UNION	= 9,
	//}
		ELEM_TYPEDEF	= 10,
		ELEM_FUNC_TYPE	= 11,

		ELEM_BASE_CLASS	= 13,
		ELEM_FRIEND	= 14,
		ELEM_FRIEND_PAIR= 15,

		ELEM_THUNK	= 16,

		ELEM_BLOCK	= 19,
	};

	#pragma pack(push, 1)
	struct ELEM
	{
		unsigned long Size;
		unsigned long ID;
		unsigned long Length;
		char *Name;
		unsigned long Type;
	};
	#pragma pack(pop)

	// ELEM_BASE_TYPE
	#pragma pack(push, 1)
	struct BASICTYPE : public NULLTYPE
	{
		ELEM Elem;
	};
	#pragma pack(pop)

	// ELEM_POINTER
	#pragma pack(push, 1)
	struct elemPOINTER
	{
		unsigned long Num;
		unsigned long PrevID;
		unsigned long ID;
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct POINTERTYPE : public BASICTYPE, elemPOINTER
	{
	};
	#pragma pack(pop)

	// ELEM_POINTERREF
	#pragma pack(push, 1)
	struct elemPOINTERREF
	{
		unsigned long ID;
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct POINTERREFTYPE : public BASICTYPE, elemPOINTERREF
	{
	};
	#pragma pack(pop)

	// ELEM_ARRAY
	#pragma pack(push, 1)
	struct ARRAYVALUE
	{
		unsigned long ID;
		unsigned long Size;
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct elemARRAY
	{
		unsigned long Size;
		unsigned long ParentID;
		unsigned long ID;
		ARRAYVALUE Values[1];
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct ARRAYTYPE : public BASICTYPE, elemARRAY
	{
	};
	#pragma pack(pop)

	// ...

	// ELEM_ENUM
	#pragma pack(push, 1)
	struct ENUMTYPEVALUE
	{
		char *Name;
		unsigned long X; //???
		unsigned long long Value; //???
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct elemENUM
	{
		unsigned long Length : 30;
		unsigned long Nested : 1;
		unsigned long Scoped : 1;		//CHECKED
		unsigned long ID;
		ENUMTYPEVALUE Values[1];
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct ENUMTYPE : public BASICTYPE, elemENUM
	{
	};
	#pragma pack(pop)

	// ELEM_STRUCT
	// ELEM_CLASS
	// ELEM_UNION
	#pragma pack(push, 1)
	struct CLASSPUBSYM
	{
		unsigned long length;
		unsigned long rva;
		unsigned long ID;
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct elemUDT
	{
		unsigned long BaseClassLen;
		unsigned long FriendLen;
		unsigned long DataLen;
		unsigned long ThisRel; //???
		//unsigned long Flags : 19; //>>20 (0x10'0000) PubSymbolsLen 0xFFF F'FFFF
		unsigned long constructor:1; //1
		unsigned long scoped:1; //2
		unsigned long packed:1; //4
		unsigned long nested:1; //8

		unsigned long hasNestedTypes:1; //10
		unsigned long hasCastOperator:1; //20
		unsigned long hasAssignmentOperator:1; //40
		unsigned long overloadedOperator:1; //80

		unsigned long vtable:1; //100
		unsigned long X1:1; //200
		unsigned long unnamed:1; //400
		unsigned long X3:1; //800

		unsigned long X4:1; //'1000
		unsigned long X5:1; //'2000
		unsigned long X6:1; //'4000
		unsigned long X7:1; //'8000

		unsigned long X8:1; //1'0000
		unsigned long X9:1; //2'0000
		unsigned long X10:1; //4'0000
		unsigned long X11:1; //8'0000 //???

		unsigned long PubSymbolsLen : 12; //TODO BT
		CLASSPUBSYM *PubSymbols;
		unsigned long *BaseClass;
		unsigned long *Data;
		unsigned long FunctionLen;
		unsigned long *Function;
		unsigned long *Friend;
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct UDTYPE : public BASICTYPE, elemUDT
	{
	};
	#pragma pack(pop)

	// ELEM_TYPEDEF
	#pragma pack(push, 1)
	struct elemTYPEDEF
	{
		unsigned long ID;
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct TYPEDEFTYPE : public BASICTYPE, elemTYPEDEF
	{
	};
	#pragma pack(pop)

	// ELEM_FUNC_TYPE
	#pragma pack(push, 1)
	struct elemFUNC
	{
		unsigned long nArgs : 16;
		unsigned long CallingConvention : 16; //CHECKED
		unsigned long ObjPtrID;
		unsigned long FuncTypeID;
		unsigned long ThisAdjust;
		unsigned long ArgsIDs[1];
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct FUNCTYPE : public BASICTYPE, elemFUNC
	{
	};
	#pragma pack(pop)

	// ELEM_BASECLASS
	#pragma pack(push, 1)
	struct elemBASECLASS
	{
		unsigned long ID;
		unsigned long X; //???
		unsigned long Access : 16;
		unsigned long IndirectVirtualBaseClass : 1;
		unsigned long VirtualBaseClass : 1;
		unsigned long XX : 14; //???
		unsigned long Offset;
		unsigned long VirtualBasePointerOffset;
		unsigned long VirtualBaseDispIndex;
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct BASECLASSTYPE : public BASICTYPE, elemBASECLASS
	{
	};
	#pragma pack(pop)

	// ELEM_BLOCK
	#pragma pack(push, 1)
	struct elemBLOCK
	{
		unsigned long rva;
		unsigned long length; //??? ULONGULONG
		unsigned long count; //nIDs
		unsigned long IDs[1];
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct BLOCKTYPE : public BASICTYPE, elemBLOCK
	{
	};
	#pragma pack(pop)

	// ELEM_THUNK
	#pragma pack(push, 1)
	struct elemTHUNK
	{
		unsigned long X; //???
		unsigned long thunkOrdinal;
		unsigned long rva;
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct THUNKTYPE : public BASICTYPE, elemTHUNK
	{
	};
	#pragma pack(pop)


	// FILELN
	#pragma pack(push, 1)
	struct FilesLN
	{
		unsigned long address; //rva always DWORD
		unsigned long statement : 1 ;
		unsigned long UnitID : 15 ;
		unsigned long FileID : 16 ;
		unsigned long lineNumber : 16;
		unsigned long length : 16;
	};
	#pragma pack(pop)

	inline bool operator<(const FilesLN &l, const FilesLN &r) { return l.address < r.address; }

	// SRC FILE NAMES
	#pragma pack(push, 1)
	struct SrcFileNameID
	{
		unsigned long FileID;
		char *FileName;
		char *Text;
		unsigned long FileSize;
	};
	#pragma pack(pop)


	// PUBLIC SYMBOL
	#pragma pack(push, 1)
	struct PUBSYM
	{
		char *name;
		char *moduleName;
		unsigned long rva;
		unsigned long length; //???
		unsigned long options;


		//str	   0x1'0000
		//???
		//export   0x4'0000 //<<
		//import   0x8'0000 //<<19

		//managed 0x10'0000 //<<20
		//msil    0x20'0000 //<<21
		//func	  0x40'0000 //<<22
		//code    0x80'0000 //<<23

		//vtbl	 0x100'0000 //<<24

//		PUBSYM()
//		{
//			name = 0;
//			moduleName = 0;
//			address = 0;
//			length = 0;
//			options = 0;
//		}

//		~PUBSYM()
//		{
//			if (name) delete name;
//			if (moduleName) delete moduleName;
//		}
		bool operator<(const PUBSYM &other) const { return rva < other.rva; }
	};
	#pragma pack(pop)

	//inline bool operator<(const PUBSYM &l, const PUBSYM &r) { return l.rva < r.rva; }

	// COMPILAND UNIT
	#pragma pack(push, 1)
	struct COMPUNIT
	{
		struct FILES
		{
			unsigned long FIRST;
			unsigned long FileID;
			unsigned long nLines;
			unsigned long LAST;
		};

		char *UnitName;
		unsigned long UnitID;
		unsigned long nFiles;
		unsigned long MinRVA;
		unsigned long MaxRVA;
		FILES Files;

//		COMPUNIT()
//		{
//			UnitName = 0;
//		}
//		~COMPUNIT()
//		{
//			if (UnitName) delete UnitName;
//		}
		bool operator<(const COMPUNIT &other) const { return TStrCmp(UnitName, other.UnitName)<0; }
	};
	#pragma pack(pop)

	//inline bool operator<(const COMPUNIT &l, const COMPUNIT &r) { return TStrCmp(l.UnitName, r.UnitName)<0; }

	// DATATYPE
	#pragma pack(push, 1)
	struct DATATYPE : public NULLTYPE
	{
		unsigned long ID;
		unsigned long TypeLength;
		char *name; //VALUE *
		unsigned long ClassID;
		unsigned long TypeID;
	//VALUE
		unsigned long constType : 1;
		unsigned long volatileType : 1;
		unsigned long access : 14;
		unsigned long locationType : 8;
		unsigned long dataKind : 8;

		union 
		{
			struct {
				unsigned long rva;
			} Static;
			struct {
				unsigned long section;
				unsigned long offset;
			} TLS;
			struct {
				long offset;
			} ThisRel;
			struct {
				long offset;
				unsigned long registerId;

			} RegRel;
			struct {
				unsigned long registerId;
			} Enregistered;
			struct {
				unsigned long bitPosition;
				unsigned long length;
				long offset;
			} BitField;

			struct {
				unsigned long slot;
			} Slot;

			struct {
				unsigned long token;
			} MetaData;

			struct {
				unsigned long long value;
			} Constant;

			struct {
			unsigned long a0;
			unsigned long a1;
			unsigned long a2;
			unsigned long a3;
			};
		};
	};
	#pragma pack(pop)

	// FUNCTION
	#pragma pack(push, 1)
	struct FUNCTIONLABEL
	{
		char *Name;
		unsigned long Offset;
	};
	#pragma pack(pop)

	#pragma pack(push, 1)
	struct FUNCTION : public NULLTYPE
	{
		char *name;

		unsigned long LocationType : 16; //0
		unsigned long Access : 8; //16
		unsigned long Virtual : 1; //24
		unsigned long Pure : 1; //25
		unsigned long Intro : 1; //26
		unsigned long XX : 1; //27
		unsigned long SystemExceptionHandling : 1; //28
		unsigned long CplusplusExceptionHandling : 1; //29

		unsigned long virtualOffset;
		unsigned long rva;
		unsigned long debugStart;
		unsigned long debugEnd;
		//ULONGLONG length; //???
		unsigned long length; //??? X64
		unsigned long ID;

		unsigned long ReturnCallID;
		unsigned long ReturnTypeID;

		unsigned long ClassID;

		unsigned long nstack;
		unsigned long *stack;

		unsigned long nblocks;
		unsigned long *blocks;

		unsigned long nlabels;
		FUNCTIONLABEL *labels;
	};
	#pragma pack(pop)
	//

#endif
```

`source/EXEAnalyzer/sdsmodule.cpp`:

```cpp

#include "sdsmodule.hpp"
#include "../Code/imagefile.hpp"

	CSDSModule::CSDSModule()
		: m_LoadOK(false)
		, m_Size(0)
		, m_Handle(0)
		, m_Strings(nullptr)
		, m_Buffer(nullptr)
		, m_pSDSFile(nullptr)
		, m_pDbgModule(nullptr) //+++
		, m_MemSize(0)
		, m_dwProcessId(0)
	{
	}

	CSDSModule::~CSDSModule()
	{
		Close();
	}

	FILESIG CSDSModule::GetFILESIG()
	{
		FILESIG FileSig(0, 0);
		//FileSig.TimeStamp = 0;
		//FileSig.CheckSum = 0;
		if (m_pSDSFile)
		{
			FileSig.TimeStamp = m_pSDSFile->TimeStamp;
			FileSig.CheckSum = m_pSDSFile->CheckSum;
		}
		return FileSig;
	}

	FILESIG CSDSModule::GetFILESIG(const char *FullFileName)
	{
		FILESIG FileSig(0, 0);
		//FileSig.TimeStamp = 0;
		//FileSig.CheckSum = 0;
		HANDLE Handle;
		if (!gpFileIO->OpenFile(FullFileName, &Handle, 0x10000))
			return FileSig;

		SDSFILE SDSFile;
		memset(&SDSFile, 0, sizeof(SDSFile));
		unsigned long Size = gpFileIO->ReadFile(Handle, &SDSFile, SDSFILE_SIZE, 0);
		gpFileIO->CloseHandle(Handle);
		if (Size == SDSFILE_SIZE &&
		   SDSFile.Magic == SDSFILE_MAGIC &&
		  SDSFile.Version == SDSFILE_VERSION)
		{
			FileSig.TimeStamp = SDSFile.TimeStamp;
			FileSig.CheckSum = SDSFile.CheckSum;
		}
		return FileSig;
	}

	void CSDSModule::Dump(SDSFILE *SDSFile)
	{
#if 0
		setbuf(stdout, NULL);
		printf(" Magic %08x \n", SDSFile->Magic);
		printf(" Version %d \n", SDSFile->Version);
		printf(" FileSize %d \n", SDSFile->FileSize);
		printf(" GlobalsLen %d \n", SDSFile->GlobalsLen);
		printf(" HeaderSize %d \n", SDSFile->HeaderSize);
		printf(" Globals %08x \n", SDSFile->Globals); //BASICTYPE** //???
		printf(" FilesLNLen %d \n", SDSFile->FilesLNLen);
		printf(" FilesLN %08x \n", SDSFile->FilesLN); //FilesLN*
		printf(" StringsLen %d \n", SDSFile->StringsLen);
		printf(" Strings %08x \n", SDSFile->Strings); //char**
		printf(" StringsEntry %08x \n", SDSFile->StringsEntry); //char*
		printf(" SrcFileNamesLen %d \n", SDSFile->SrcFileNamesLen);
		printf(" SrcFileNames %08x \n", SDSFile->SrcFileNames); //SrcFileNameID*
		printf(" PublicSymbolsLen %d \n", SDSFile->PublicSymbolsLen);
		printf(" PublicSymbols %08x \n", SDSFile->PublicSymbols); //PUBSYM*
		printf(" CompilandUnits %08x \n", SDSFile->CompilandUnits); // NOT USES
		printf(" CompilandUnitsLen %d \n", SDSFile->CompilandUnitsLen); // NOT USES
		printf(" LocalsLen %d \n", SDSFile->LocalsLen);
		printf(" Locals %08x \n", SDSFile->Locals); //DATATYPE*
		printf(" X1 %d \n", SDSFile->X1);
		printf(" FunctionsLen %d \n", SDSFile->FunctionsLen);
		printf(" FunctionsEntry %08x \n", SDSFile->FunctionsEntry); //FUNCTION*
		printf(" Functions %08x \n", SDSFile->Functions); //FUNCTION**
		printf(" Sources %08x \n", SDSFile->Sources); //??? ULONG_PTR
		printf(" TimeStamp %08x \n", SDSFile->TimeStamp);
		printf(" CheckSum %08x \n", SDSFile->CheckSum);
		printf(" SUB %d \n", SDSFile->SUB);
		printf(" ModuleName %08x \n", SDSFile->ModuleName); //char*
		printf(" ModuleNameLen %d \n", SDSFile->ModuleNameLen);
		printf(" PDBFullFileName %08x \n", SDSFile->PDBFullFileName); //char*
		printf(" PDBFullFileNameLen %d \n", SDSFile->PDBFullFileNameLen);
		printf(" FullFileName %08x \n", SDSFile->FullFileName); //char*
		printf(" FullFileNameLen %d \n", SDSFile->FullFileNameLen);
		printf(" CRCSUM %08x \n", SDSFile->CRCSUM);
		printf(" SourcesCount %d \n", SDSFile->SourcesCount);
		fflush(stdout);
		//unsigned long X[40];
#endif
	}

	bool CSDSModule::Load(const char *FullFileName)
	{
		if (m_LoadOK) return true;

		if (!gpFileIO->OpenFile(FullFileName, &m_Handle, 0x1'0000))
			return false;

		SDSFILE SDSFile;
		memset(&SDSFile, 0, sizeof(SDSFile));
		if (gpFileIO->ReadFile(m_Handle, &SDSFile, SDSFILE_SIZE, 0) != SDSFILE_SIZE)
		{
			gpFileIO->CloseHandle(m_Handle);
			return false;
		}

		if (SDSFile.Version != SDSFILE_VERSION)
		{
			gpFileIO->CloseHandle(m_Handle);
			return false;
		}

		m_Size = gpFileIO->GetFileLength(m_Handle);
		m_Buffer = new unsigned char[m_Size];
		if (!m_Buffer)
		{
			gpFileIO->CloseHandle(m_Handle);
			return false;
		}

		if (gpFileIO->ReadFile(m_Handle, m_Buffer, m_Size, 0) != m_Size)
		{
			gpFileIO->CloseHandle(m_Handle);
			delete []m_Buffer;
			return false;
		}

		if (!CheckCRC())
		{
			gpFileIO->CloseHandle(m_Handle);
			delete []m_Buffer;
			return false;
		}

		m_pSDSFile = (SDSFILE*)m_Buffer;
		Dump(m_pSDSFile);
		Relocate(m_pSDSFile);
		gpFileIO->CloseHandle(m_Handle);
		InitGlobalsNameID();
		m_SDSFileName = FullFileName;
		m_LoadOK = true;
		return true;
	}

	void CSDSModule::Close()
	{
		if (m_LoadOK)
		{
			if (m_Buffer) delete []m_Buffer;
			m_GlobalsNameID.clear();
			m_LoadOK = false;
		}
	}

	bool CSDSModule::CheckCRC()
	{
		SDSFILE *SDSFile = (SDSFILE *)m_Buffer;
		unsigned long long FileCheckSum = SDSFile->CRCSUM;
		unsigned long long CheckSum = 0;
		SDSFile->CRCSUM = 0;
		for (unsigned long n = 0; n < m_Size/4; ++n)
		{
			CheckSum += ((unsigned long*)m_Buffer)[n];
		}
		SDSFile->CRCSUM = FileCheckSum;
		return ((unsigned long)CheckSum) == FileCheckSum;
	}

//#define TXTDEBUG

#ifdef TXTDEBUG
static FILE *f = NULL;
#endif
	void CSDSModule::Relocate(SDSFILE *SDSFile)
	{
		SDSELEM Elem;
		Elem.type = 0;
		Elem.rva = 0;
		Elem.name = nullptr;
#ifdef TXTDEBUG
	f = fopen("LOG", "w");
fprintf(f,"StringsLen %d\n", SDSFile->StringsLen);
fflush(f);
#endif
		ULONG_PTR *StringIndexes = (ULONG_PTR*)((char*)SDSFile + SDSFile->StringIndexes);
		//m_Strings = (char**)((char*)SDSFile + SDSFile->StringIndexes);
		char *Strings = (char*)((char*)SDSFile + SDSFile->StringsEntry);
		m_Strings = (char**)StringIndexes;
		for (unsigned long n = 0; n < SDSFile->StringIndexesLen; ++n)
		{
			//m_Strings[n] += (ULONG_PTR)((char*)SDSFile + SDSFile->StringsEntry);
			m_Strings[n] = Strings + StringIndexes[n];
#ifdef TXTDEBUG
//fprintf(f,"%d %s\n", n, (char*)m_Strings[n]);
//fflush(f);
#endif
		}

		SDSFile->SrcFileNames = (ULONG_PTR)((char*)SDSFile + SDSFile->SrcFileNames);
		SDSFile->Functions = (ULONG_PTR)((char*)SDSFile + SDSFile->Functions);
		SDSFile->Globals = (ULONG_PTR)((char*)SDSFile + SDSFile->Globals);
		SDSFile->Locals = (ULONG_PTR)((char*)SDSFile + SDSFile->Locals);
		SDSFile->PublicSymbols = (ULONG_PTR)((char*)SDSFile + SDSFile->PublicSymbols);
		SDSFile->FilesLN = (ULONG_PTR)((char*)SDSFile + SDSFile->FilesLN);

		if (SDSFile->PDBFullFileName)
			SDSFile->PDBFullFileName = (ULONG_PTR)((char*)SDSFile + SDSFile->PDBFullFileName);
		else	SDSFile->PDBFullFileName = (ULONG_PTR)((char*)m_Strings[0]);
#ifdef TXTDEBUG
fprintf(f,"PDBFullFileName %s\n", (char*)SDSFile->PDBFullFileName);
fflush(f);
#endif
		if (SDSFile->ModuleName)
			SDSFile->ModuleName = (ULONG_PTR)((char*)SDSFile + SDSFile->ModuleName);
		else	SDSFile->ModuleName = (ULONG_PTR)((char*)m_Strings[0]);
#ifdef TXTDEBUG
fprintf(f,"ModuleName %s\n", (char*)SDSFile->ModuleName);
fflush(f);
#endif
		if (SDSFile->FullFileName)
			SDSFile->FullFileName = (ULONG_PTR)((char*)SDSFile + SDSFile->FullFileName);
		else	SDSFile->FullFileName = (ULONG_PTR)((char*)m_Strings[0]);
#ifdef TXTDEBUG
fprintf(f,"FullFileName %s\n", (char*)SDSFile->FullFileName);
fflush(f);
#endif

#ifdef TXTDEBUG
fprintf(f,"FilesLN\n");
fflush(f);
#endif
		for (unsigned long n = 0; n < SDSFile->FilesLNLen; ++n)
		{
			FilesLN *FileLN = (FilesLN*)SDSFile->FilesLN;
#ifdef TXTDEBUG
//fprintf(f,"N %d, address %08x FileID %d UnitID %d statement %d length %d linenumber %d\n",
//		n, FileLN[n].address, FileLN[n].FileID, FileLN[n].UnitID, FileLN[n].statement, FileLN[n].length, FileLN[n].lineNumber);
//fflush(f);
#endif
		}

		for (unsigned long n = 0; n < SDSFile->SrcFileNamesLen; ++n)
		{
			SrcFileNameID *srcfilename = (SrcFileNameID*)SDSFile->SrcFileNames;
			if (srcfilename[n].Text)
				srcfilename[n].Text += (unsigned long)SDSFile;
			srcfilename[n].FileName = (char*)(m_Strings[(unsigned long)(srcfilename[n].FileName)]);
#ifdef TXTDEBUG
//fprintf(f,"N %d, FileName %s\n", n, srcfilename[n].FileName);
//fflush(f);
#endif
		}
#ifdef TXTDEBUG
fprintf(f,"GLOBAL %d\n", SDSFile->GlobalsLen);
fflush(f);
#endif
#if 1
		for (unsigned long n = 0; n < SDSFile->GlobalsLen; ++n)
		{
			BASICTYPE **type = (BASICTYPE **)SDSFile->Globals;
#ifdef TXTDEBUG
//fprintf(f,"N %d type %08x\n", n, type[n]);
//fflush(f);
#endif
#if 1
#if 1
			if (type[n] == 0)
			{
#ifdef TXTDEBUG
fprintf(f,"N %d, fixup\n", n);
fflush(f);
#endif
				type[n] = type[0];
				continue;
			}
#endif
			type[n] = (BASICTYPE*)((char*)SDSFile + (unsigned long)type[n]);
#ifdef TXTDEBUG
//fprintf(f,"N %d, _GlobalName %d Type %d Size %d\n", n, type[n]->Elem.Name, type[n]->Elem.Type, type[n]->Elem.Size);
//fflush(f);
#endif
			if (((unsigned long)type[n]->Elem.Name) > SDSFile->FileSize)
			{
#ifdef TXTDEBUG
fprintf(f,"N %d, fixup Name\n", n);
fflush(f);
#endif
				continue;
			}
			type[n]->Elem.Name = (char*)m_Strings[(unsigned long)type[n]->Elem.Name];
#ifdef TXTDEBUG
fprintf(f,"N %d, Type %d Size %d GlobalName %s \n", n, type[n]->Elem.Type, type[n]->Elem.Size, type[n]->Elem.Name);
fflush(f);
#endif

			if (type[n]->Elem.Type == ELEM_ENUM)
			{
				ENUMTYPE *et = (ENUMTYPE*)type[n];
				for (unsigned long i = 0; i < et->Length; ++i)
				{
					et->Values[i].Name = (char*)m_Strings[(unsigned long)et->Values[i].Name];
				}
			} else
			if (type[n]->Elem.Type == ELEM_STRUCT ||
			    type[n]->Elem.Type == ELEM_CLASS ||
			    type[n]->Elem.Type == ELEM_UNION)
			{
				UDTYPE *udt = (UDTYPE*)type[n];
				if (udt->DataLen)
					udt->Data = (unsigned long*)((char*)udt + (unsigned long)udt->Data);
				else	udt->Data = 0;
				if (udt->FunctionLen)
					udt->Function = (unsigned long*)((char*)udt + (unsigned long)udt->Function);
				else	udt->Function = 0;
				if (udt->BaseClassLen)
					udt->BaseClass = (unsigned long*)((char*)udt + (unsigned long)udt->BaseClass);
				else	udt->BaseClass = 0;
				if (udt->PubSymbolsLen)
					udt->PubSymbols = (CLASSPUBSYM*)((char*)udt + (unsigned long)udt->PubSymbols);
				else	udt->PubSymbols = 0;

			}
#endif
		}
#endif
#ifdef TXTDEBUG
fprintf(f,"FUNC\n");
fflush(f);
#endif
		Elem.type = 0;

		for (unsigned long n = 1; n < SDSFile->FunctionsLen; ++n)
		{
			FUNCTION **func = (FUNCTION**)SDSFile->Functions;
#ifdef TXTDEBUG
fprintf(f,"FUNC %08x\n", func[n]);
fflush(f);
#endif
		#if 0
			if (func[n] == 0)// || ((unsigned long)func[n]) > SDSFile->FileSize) //+++ >= ???
			{
fprintf(f,"N %d, fixup\n");
fflush(f);
				func[n] = func[0];
				continue;
			}
		#endif
			func[n] = (FUNCTION*)((char*)SDSFile + (unsigned long)func[n]);
			if (func[n]->nstack)// && func[n]->stack) //+++
				func[n]->stack = (unsigned long*)((char*)func[n]->stack + (unsigned long)func[n]);
			else	func[n]->stack = nullptr;

			if (func[n]->nblocks)// && func[n]->blocks) //+++
				func[n]->blocks = (unsigned long*)((char*)func[n]->blocks + (unsigned long)func[n]);
			else	func[n]->blocks = nullptr;
#ifdef TXTDEBUG
fprintf(f,"N %d, _FuncName %u, rva %x, vrva %x, id %d, C %d,S %d,I %d,P %d,V %d,A %d,L %d S(%d),B(%d)\n", n, (unsigned long)func[n]->name, func[n]->rva, func[n]->virtualOffset, func[n]->ID,
			func[n]->CplusplusExceptionHandling, func[n]->SystemExceptionHandling, func[n]->Intro, func[n]->Pure, func[n]->Virtual, func[n]->Access, func[n]->LocationType, func[n]->nstack, func[n]->nblocks);
fflush(f);		if ((unsigned long)func[n]->name > SDSFile->StringsLen) continue;
#endif
			func[n]->name = (char*)m_Strings[(unsigned long)(func[n]->name)];
			//f->name = (char*)m_Strings[(unsigned long)(f->name)];
#ifdef TXTDEBUG
fprintf(f,"N %d, FuncName %s\n", n, func[n]->name);
fflush(f);
#endif
			Elem.name = func[n]->name;
			Elem.rva = func[n]->rva;
			Elem.hash ^= n;
			m_Elems.Append(&Elem);
		}
#ifdef TXTDEBUG
fprintf(f,"DATA\n");
fflush(f);
#endif
		Elem.type = 1;

		for (unsigned long n = 0; n < SDSFile->LocalsLen; ++n)
		{
			DATATYPE *data = (DATATYPE*)SDSFile->Locals;
#ifdef TXTDEBUG
fprintf(f,"N %d, DataName %u LocationType %d\n", n, (unsigned long)data[n].name, data[n].locationType);
fflush(f);
#endif
			data[n].name = (char*)m_Strings[(unsigned long)(data[n].name)];
#ifdef TXTDEBUG
fprintf(f,"N %d, DataName %s\n", n, data[n].name);
fflush(f);
#endif
			if (data[n].locationType == LocIsStatic)
			{
#ifdef TXTDEBUG
fprintf(f,"N %d, rva %08x\n", n, data[n].Static.rva);
fflush(f);
#endif
			Elem.name = data[n].name;
			Elem.rva = data[n].Static.rva;
			Elem.hash ^= n;
			m_Elems.Append(&Elem);
			}

		}
#ifdef TXTDEBUG
fprintf(f,"PUB\n");
fflush(f);
#endif
		Elem.type = 2;

		for (unsigned long n = 0; n < SDSFile->PublicSymbolsLen; ++n)
		{
			PUBSYM *pubsym = (PUBSYM*)SDSFile->PublicSymbols;
			pubsym[n].name = (char *)m_Strings[(unsigned long)(pubsym[n].name)];
#ifdef TXTDEBUG
fprintf(f,"N %d, PUB rva %x length %u options %08x Name %s\n", n, pubsym[n].rva, pubsym[n].length, pubsym[n].options, pubsym[n].name);
fflush(f);
#endif
			pubsym[n].moduleName = (char *)m_Strings[(unsigned long)(pubsym[n].moduleName)];
#ifdef TXTDEBUG
fprintf(f,"N %d, PUB ModuleName %s\n", n, pubsym[n].moduleName);
fflush(f);
#endif
			Elem.name = pubsym[n].name;
			Elem.rva = pubsym[n].rva;
			Elem.hash ^= n;
			m_Elems.Append(&Elem);
		}
#ifdef TXTDEBUG
fclose(f);
#endif
	}

	void CSDSModule::InitGlobalsNameID()
	{
		for (unsigned long n = 1; n < m_pSDSFile->GlobalsLen; ++n)
		{
			BASICTYPE **type = (BASICTYPE **)m_pSDSFile->Globals;
			//m_GlobalsNameID.insert(_Tmap_pair<const char*,unsigned long>(type[n]->Elem.Name, n));
			m_GlobalsNameID.Insert(type[n]->Elem.Name, n);
		}
	}

	SrcFileNameID *CSDSModule::GetSrcFileName(const char *FileName) const
	{
		unsigned long Len = 0;
		SrcFileNameID *SrcFileName = GetSrcFiles(&Len);
		if (!SrcFileName) return nullptr; //+++

		for (unsigned long n = 0; n < Len; ++n)
		{
			const char *pFileName = TStrRChr(SrcFileName[n].FileName, '\\');
			if (!TStrICmp(pFileName, FileName)) return &SrcFileName[n];
		}
		return nullptr;
	}

	SrcFileNameID *CSDSModule::GetSrcFileNameID(unsigned long FileID) const
	{
		unsigned long Len = 0;
		SrcFileNameID *SrcFileName = GetSrcFiles(&Len);
		if (!SrcFileName) return nullptr; //+++

		for (unsigned long n = 0; n < Len; ++n)
		{
			if (SrcFileName[n].FileID == FileID) return &SrcFileName[n];
		}
		return nullptr;
	}
	//unsigned long CSDSModule::GetSrcFilesCount() const { return m_pSrcDbg ? m_pSrcDbg->m_nSrcFilesCount : 0; }

	int CSDSModule::GetFilesLN(unsigned long FileID, map<unsigned long, MAPFilesLN> *FilesLNMap)
	{
		int Count = 0;

		unsigned long Len = 0;
		FilesLN *FileLN = GetFilesLN(&Len);
		if (!FileLN) return Count; //+++

		for (unsigned long n = 0; n < Len; ++n)
		{
			if (FileLN[n].FileID == FileID)
			{
				MAPFilesLN value;
				value.count = 1;
				value.fileln = &FileLN[n];
				if (FilesLNMap)
				{
					map<unsigned long,MAPFilesLN>::IT it = FilesLNMap->insert(_Tmap_pair<unsigned long,MAPFilesLN>(FileLN[n].lineNumber, &value));
					if (it == FilesLNMap->end())
					{
						map<unsigned long,MAPFilesLN>::IT it = FilesLNMap->find(FileLN[n].lineNumber);
						++(it->second.count);
					}
				}
				++Count;
			}
		}
		return Count;
	}

	//unsigned long
	int CSDSModule::GetFilesLN(ULONG_PTR Address, TList<FilesLN*> *ListFilesLN)
	{
		int Count = 0;

		unsigned long Len = 0;
		FilesLN *FileLN = GetFilesLN(&Len);
		if (!FileLN) return Count; //+++

		//TODO unsigned long nstart = binarysearch(0, Len, Address);
		for (unsigned long n = 0; n < Len; ++n)
		{
			if (Address >= FileLN[n].address && Address < FileLN[n].address + FileLN[n].length)
			{
				FilesLN *const fln = &FileLN[n];
				if (ListFilesLN) ListFilesLN->Append(&fln);
				++Count;
			}
		}			
		return Count;
	}

	int CSDSModule::GetFilesLN(unsigned long FileID, unsigned long lineNumber, TList<FilesLN*> *ListFilesLN)
	{
		int Count = 0;

		unsigned long Len = 0;
		FilesLN *FileLN = GetFilesLN(&Len);
		if (!FileLN) return Count; //+++

		for (unsigned long n = 0; n < Len; ++n)
		{
			if (FileLN[n].FileID == FileID && FileLN[n].lineNumber == lineNumber)
			{
				FilesLN *const fln = &FileLN[n];
				if (ListFilesLN) ListFilesLN->Append(&fln);
				++Count;
			}
		}			
		return Count;
	}

	FilesLN *CSDSModule::GetFilesLN(unsigned long FileID, unsigned long lineNumber)
	{
		unsigned long maxLineNumber = -1;
		FilesLN *filesLN = nullptr;

		unsigned long Len = 0;
		FilesLN *FileLN = GetFilesLN(&Len);
		if (!FileLN) return nullptr; //+++

		for (unsigned long n = 0; n < Len; ++n)
		{
			if (FileLN[n].FileID == FileID &&
				FileLN[n].lineNumber > lineNumber && FileLN[n].lineNumber < maxLineNumber)
			{
				maxLineNumber = FileLN[n].lineNumber;
				filesLN = &FileLN[n];
			}
		}
		return filesLN;
	}

	FUNCTION *CSDSModule::GetFunction(const char *FuncName, UDTYPE *Type, bool bSkipClassName)
	{
		if (Type &&
			(Type->Elem.Type == ELEM_STRUCT ||
			 Type->Elem.Type == ELEM_CLASS ||
			 Type->Elem.Type == ELEM_UNION)) //+++
		{
			int nClassNameLen = !bSkipClassName ? TStrLen(Type->Elem.Name)+2 : 0;

			UDTYPE *udt = Type;
			for (int n = 0; n < udt->FunctionLen; ++n)
			{
				FUNCTION *Func = GetFunctionByID(udt->Function[n]);
				if (Func && !TStrCmp(&Func->name[nClassNameLen], FuncName)) //+++
					return Func;
			}

			for (int n = 0; n < udt->BaseClassLen; ++n)
			{
				BASECLASSTYPE *bc = (BASECLASSTYPE *)GetGlobal(udt->BaseClass[n]);
				if (!bc) continue; //+++
				BASICTYPE *bcd = GetGlobal(bc->ID);
				if (!bcd) continue; //+++
				FUNCTION *Func = GetFunction(FuncName, (UDTYPE*)bcd, bSkipClassName);
				if (Func) return Func;
			}
		}
		return nullptr;
	}

	FUNCTION *CSDSModule::GetFunction(const char *FuncName, bool bCase)
	{
		if (!FuncName) return nullptr;
		if (!FuncName[0]) return nullptr;

		unsigned long Len = 0;
		FUNCTION **Func = GetFunctions(&Len);
		if (!Func) return nullptr; //+++

		for (unsigned long n = 1; n < Len; ++n)
		{
			if (bCase && !TStrCmp(Func[n]->name, FuncName))
				return Func[n];
			else
			if (!TStrICmp(Func[n]->name, FuncName))
				return Func[n];
		}
		return nullptr;
	}

	FUNCTION *CSDSModule::GetFunction(unsigned long Address)
	{
		unsigned long Len = 0;
		FUNCTION **Func = GetFunctions(&Len);
		if (!Func) return nullptr; //+++

		for (unsigned long n = 1; n < Len; ++n)
		{
			if (Address >= Func[n]->rva && Address < Func[n]->rva+Func[n]->length)
				return Func[n];
		}
		return nullptr;
	}

	FUNCTION *CSDSModule::GetFunction(unsigned long FileID, unsigned long LineNumber)
	{
		FilesLN *filesLN = nullptr;
		TList<FilesLN*> ListFilesLN;
		if (GetFilesLN(FileID, LineNumber, &ListFilesLN))
			filesLN = *ListFilesLN.Begin();
		else	filesLN = GetFilesLN(FileID, LineNumber);
		if (filesLN)
			return GetFunction(filesLN->address);
		return nullptr;
	}

	FUNCTION *CSDSModule::GetFunctionByID(unsigned long ID)
	{
		if (ID > m_pSDSFile->FunctionsLen)
			ID = 0;
		FUNCTION **funcs = (FUNCTION **)m_pSDSFile->Functions;
		return (FUNCTION *)funcs[ID];
	}

	DATATYPE *CSDSModule::GetLocal(unsigned long ID)
	{
		if (ID >= m_pSDSFile->LocalsLen)
			ID = 0;
		DATATYPE *data = (DATATYPE *)m_pSDSFile->Locals;
		return &data[ID]; //???
	}
	DATATYPE *CSDSModule::GetLocal(const char *Name, unsigned long DT)
	{
		unsigned long Len = 0;
		DATATYPE *data = GetLocal(&Len);
		if (!data) return nullptr; //+++

		for (unsigned long ID = 1; ID < Len; ++ID)
		{
			if (data[ID].dataKind == DT && !TStrCmp(data[ID].name, Name))
				return &data[ID];
		}
		return nullptr;
	}

	BASICTYPE *CSDSModule::GetGlobal(unsigned long ID)
	{
		if (ID >= m_pSDSFile->GlobalsLen)
			ID = 0;
		BASICTYPE **type = (BASICTYPE **)m_pSDSFile->Globals;
		return type[ID];
	}

	char *CSDSModule::GetOutput(BASICTYPE *Type, char *pStr, int *pLen)
	{
		if (pStr) *pStr = 0;
		if (!Type) return pStr;
		
		switch (Type->Elem.Type)
		{
		case ELEM_POINTER: {
			int Len = *pLen;
			TAnsiString String;
			POINTERTYPE *pt = (POINTERTYPE*)Type;
			BASICTYPE *subtype = GetGlobal(pt->ID);
			if (!subtype) return pStr; //???
			GetOutput(pt->ID, pStr, pLen);
			int l = pt->Num;
			String.Fill('*', l);
			if (subtype->Elem.Type == ELEM_FUNC_TYPE)
				l += 2;
			if (*pLen > l)
			{
				if (subtype->Elem.Type == ELEM_FUNC_TYPE)
				{
					const char *pStrCallConv = " "; // GetCallConv(subtype->callingConvention)
					char *p = new char[Len];
					TStrCpy(p, pStr);
					char *b = TStrStr(pStr, pStrCallConv);
					char *pStrFunc = TStrFunc(p);
					int bl = b ? (b-pStr) : (pStrFunc-p);
					pStr[bl] = '(';
					++bl;
					bl += TStrCpy(&pStr[bl], pStrCallConv);
					TStrCpy(&pStr[bl], String.operator const char*());
					TStrCat(pStr, ")");
					TStrCat(pStr, pStrFunc);
					delete []p;
				} else
				{
					TStrCat(pStr, String.operator const char*());
				}
			}
			*pLen -= l;
			} break;
		case ELEM_POINTERREF: {
			POINTERREFTYPE *pt = (POINTERREFTYPE*)Type;
			GetOutput(pt->ID, pStr, pLen);
			TSTRADD(pStr, "&", pLen); //???
			//if (*pLen > 1)
			//	TStrCat(pStr, "&");
			////*pLen -= l; //??? TODO
			} break;
		case ELEM_ARRAY: {
			ARRAYTYPE *at = (ARRAYTYPE *)Type;
			BASICTYPE *subtype = GetGlobal(at->ID);
			if (!subtype) return pStr;
			GetOutput(subtype, pStr, pLen);
			bool bFunc = IsPointerFunction(subtype);
			TAnsiString String;
			char Buffer[32];
			int l = 0;
			for (int n = 0; n < at->Size; ++n)
			{
				l += TSPrintf(Buffer, "%d", at->Values[n].Size) + 2;
				String += "[";
				String += Buffer;
				String += "]";
			}
			if (*pLen > l)
			{
				if (bFunc)
				{
					TAnsiString Str;
					char *pStrFunc = TStrFunc(pStr);
					Str = pStrFunc;
					--pStrFunc;
					*pStrFunc = 0;

					TStrCat(pStr, String.operator const char*());
					TStrCat(pStr, ")");
					TStrCat(pStr, Str.operator const char*());
				} else
				{
					TStrCat(pStr, String.operator const char*());
				}
			}					
			*pLen -= l;
			} break;
		case ELEM_ENUM: {
			char Buf[52];
			TStrCpy(Buf, "enum ");
			TSTRADD(pStr, Buf, pLen);
			goto PrintName;
			} break;
		case ELEM_STRUCT: {
			char Buf[52];
			TStrCpy(Buf, "struct ");
			TSTRADD(pStr, Buf, pLen);
			goto PrintName;
			} break;
		case ELEM_CLASS: { //++
			char Buf[52];
			TStrCpy(Buf, "class ");
			TSTRADD(pStr, Buf, pLen);
			goto PrintName;
			} break;
		case ELEM_UNION: {
			char Buf[52];
			TStrCpy(Buf, "union ");
			TSTRADD(pStr, Buf, pLen);
			goto PrintName;
			} break;
		case ELEM_FUNC_TYPE: {
			FUNCTYPE *ft = (FUNCTYPE*)Type;
			BASICTYPE *bt = (BASICTYPE*)GetGlobal(ft->FuncTypeID);
			if (!bt) return pStr;

			GetOutput(bt, pStr, pLen);

			const char *pStrCallConv = " "; // GetCallConv(ft->callingConvention)
			TSTRADD(pStr, pStrCallConv, pLen);
			TSTRADD(pStr, "(", pLen);

			TAnsiString String;
			int End = TStrLen(pStr);
			for (int n = 0; n < ft->nArgs; ++n)
			{
				End = TStrLen(pStr);
				GetOutput(GetGlobal(ft->ArgsIDs[n]), &pStr[End], pLen);
				End = TStrLen(pStr);
				if (n != ft->nArgs-1)
				{
					TSTRADD(&pStr[End], ",", pLen);
					++End;
				}
			}

			TSTRADD(&pStr[End], ")", pLen);
			} break;
		case ELEM_BASE_CLASS: {
			BASECLASSTYPE *bt = (BASECLASSTYPE*)Type;
			return GetOutput(bt->ID, pStr, pLen);
			} break;
		default:
		PrintName:
			{
			const char *str = Type->Elem.Name;
			if (!str) str = "no name";
			TSTRADD(&pStr[0], str, pLen);
			}
		}
		return pStr;
	}

	char *CSDSModule::GetOutput(unsigned long ID, char *pStr, int *pLen)
	{
		BASICTYPE *type = GetGlobal(ID);
		if (!type) return pStr; //+++
		return GetOutput(type, pStr, pLen);
	}

	bool CSDSModule::IsPointerFunction(BASICTYPE *Type)
	{
		if (Type && Type->Elem.Type == ELEM_POINTER)
		{
			POINTERTYPE *pt = (POINTERTYPE*)Type;
			return GetGlobal(pt->ID)->Elem.Type == ELEM_FUNC_TYPE;
		}
		return false;
	}

	//for src tip
	bool CSDSModule::GetOutputTypedef(TYPEDEFTYPE *Type, TAnsiString & String)
	{
		bool bFuncPtr = false;
		char UDTStr[20];
		memset(UDTStr, 0, sizeof(UDTStr));
		String.Empty();

		BASICTYPE *bt = (BASICTYPE*)GetGlobal(Type->ID);
		switch (bt->Elem.Type)
		{
		case ELEM_POINTER:{
			POINTERTYPE *pt = (POINTERTYPE *)bt;
			BASICTYPE *b = (BASICTYPE *)GetGlobal(pt->ID);
			if (b->Elem.Type == ELEM_FUNC_TYPE)
				bFuncPtr = true;
			} break;
		case ELEM_ENUM:
			TStrCpy(UDTStr, "");
			//TStrCpy(UDTStr, "enum ");
			break;
		case ELEM_STRUCT:
			TStrCpy(UDTStr, "");
			//TStrCpy(UDTStr, "struct ");
			break;
		case ELEM_UNION:
			TStrCpy(UDTStr, "");
			//TStrCpy(UDTStr, "union ");
			break;
		default:;
		}
		char Buffer[1024];
		int Len = 1023;
		GetOutput(Type->ID, Buffer, &Len);
		if (bFuncPtr)
		{
			char *pStrFunc = TStrFunc(Buffer);
			if (pStrFunc)
			{
				--pStrFunc;
				pStrFunc[0] = 0;
				String += "typedef ";
				String += Buffer;
				String += Type->Elem.Name;
				String += ")";
				String += pStrFunc+1;
			} else
			{
				String += "typedef ";
				String += UDTStr;
				String += " ";
				String += Type->Elem.Name;
			}
		} else
		{
			String += "typedef ";
			String += UDTStr;
			String += Buffer;
			String += " ";
			String += Type->Elem.Name;
		}
		return false;
	}

	//for src tip
	bool CSDSModule::GetOutputEnum(ENUMTYPE *Type, TAnsiString & String)
	{
		String.Empty();

		String += "enum ";
		String += Type->Elem.Name;
		String += "{";
		for (int n = 0; n < Type->Length; ++n)
		{
			String += "\t";
			String += Type->Values[n].Name;
			String += "\t=";
			char Buffer[52];
			TSPrintf(Buffer, "0x%08x\t,//%d",
				(unsigned long)Type->Values[n].Value,
				(unsigned long)Type->Values[n].Value); //??? %d
			String += Buffer;
		}
		String += "};";
		return false;
	}

	char *CSDSModule::GetOutputFunc(FUNCTION *pFunc, char *pStr, int *Len)
	{
		char prolog[10];
		int offset = 0;
		TStrCpy(prolog, "virtual ");
		if (pFunc->Virtual)
		{
			offset = TSTRADD(pStr, prolog, Len);
		}

		if (pFunc->ReturnTypeID)
			GetOutput(pFunc->ReturnTypeID, &pStr[offset], Len);

		if (pFunc->ReturnCallID)
		{
			BASICTYPE *subtype = GetGlobal(pFunc->ReturnCallID);
			if (subtype->Elem.Type == ELEM_FUNC_TYPE)
			{
				const char *pStrCallConv = " "; // GetCallConv(subtype->callingConvention)
				TSTRADD(pStr, pStrCallConv, Len);
			}
		}

		TSTRADD(pStr, pFunc->name, Len);
		TSTRADD(pStr, "(", Len);
		
		for (unsigned long n = 0; n < pFunc->nstack; ++n)
		{
			DATATYPE *data = GetLocal(pFunc->stack[n]);
			if (data && data->dataKind == DataIsParam)
			{
				GetOutput(data->TypeID, &pStr[TStrLen(pStr)], Len);

				TSTRADD(pStr, " ", Len);
				TSTRADD(pStr, data->name, Len);
				TSTRADD(pStr, ",", Len);
			}
		}

		//drop remain fake args
		int nStrArg = TStrLen(pStr);
		if (pStr[nStrArg-1] == ',')
			pStr[nStrArg-1] = 0;

		char epilog[10];
		if (pFunc->Pure)
			TStrCpy(epilog, ")=0");
		else	TStrCpy(epilog, ")");

		TSTRADD(pStr, epilog, Len);

		return pStr;
	}

	DATATYPE *CSDSModule::GetClassLocal(const char *Name, FUNCTION *pFunc)
	{
		if (!pFunc) return nullptr;
		if (!Name) return nullptr;
		if (!Name[0]) return nullptr;

		for (int n = 0; n < pFunc->nstack; ++n)
		{
			DATATYPE *data = GetLocal(pFunc->stack[n]);
			if (data && !TStrCmp(data->name, Name))
				return data;
		}

		for (int n = 0; n < pFunc->nblocks; ++n)
		{
			BLOCKTYPE *block = (BLOCKTYPE*)GetGlobal(pFunc->blocks[n]);
			if (block)
			{
				for (int i = 0; i < block->count; ++i)
				{
					DATATYPE *data = GetLocal(block->IDs[i]);
					if (data && !TStrCmp(data->name, Name))
						return data;
				}
			}
		}
		
		if (pFunc->ClassID)
		{
			unsigned long offset = 0;
			UDTYPE *type = (UDTYPE *)GetGlobal(pFunc->ClassID);
			if (type) //+++
				return GetClassMember(Name, type, &offset);
		}
		return nullptr;
	}

	DATATYPE *CSDSModule::GetClassMember(const char *Name, UDTYPE *Type, unsigned long *offset)
	{
		if (Type && (Type->Elem.Type == ELEM_STRUCT ||
		 	     Type->Elem.Type == ELEM_CLASS ||
			      Type->Elem.Type == ELEM_UNION))
		{
			for (int n = 0; n < Type->DataLen; ++n)
			{
				DATATYPE *data = GetLocal(Type->Data[n]);
				if (data && !TStrCmp(data->name, Name))
				{
					if (offset)
					{
						if (data->locationType == LocIsThisRel)
							*offset += data->ThisRel.offset;
						else	*offset = data->ThisRel.offset; //TODO ???
					}
					return data;
				}
			}

			for (int n = 0; n < Type->BaseClassLen; ++n)
			{
				BASECLASSTYPE *bc = (BASECLASSTYPE *)GetGlobal(Type->BaseClass[n]);
				DATATYPE *data = GetClassMember(Name, (UDTYPE*)GetGlobal(bc->ID), offset);
				if (data)
				{
					if (offset)
					{
						if (data->locationType == LocIsStatic)
							*offset = data->Static.rva;
						else
						if (data->locationType == LocIsThisRel)
							*offset += bc->Offset;
					}
					return data;
				}
			}				
		}
		return nullptr;
	}

	void *CSDSModule::GetGlobal(char *Name, FUNCTION *pFunc, bool *bFunc, unsigned long *offset)
	{
		if (offset) *offset = 0;
		if (bFunc) *bFunc = false;
		if (!pFunc) return nullptr;
		int Len = TStrLen(Name);
		int index = 0;
		while (index < Len)
		{
			if (Name[index] == '.')
			{
				Name[index] = 0;
				++index;
				//newindex = index;
				break;
			} else
			if (Name[index] == '-')
			{
				Name[index] = 0;
				index += 2;
				//newindex = index;
				break;
			}
			++index;
			//newindex = index;
		}

		DATATYPE *data = GetClassLocal(Name, pFunc);
		if (!data)
		{
			if (pFunc->ClassID)
				data = GetClassMember(Name, (UDTYPE*)GetGlobal(pFunc->ClassID), nullptr);
			if (!data)
			{
				data = GetLocal(Name, DataIsGlobal);
				if (!data) return nullptr;
				if (offset && data->locationType == LocIsStatic)
					*offset = data->Static.rva;
			}
		}

		if (data->TypeID == 0)
		{
			if (index != Len) return nullptr;

			FUNCTION *func = GetFunction(Name, true);
			if (func)
			{
				if (bFunc) *bFunc = true;
			}
			return func;
		}

		if (index == Len) return data;
		BASICTYPE *type = GetGlobal(data->TypeID);
		if (type->Elem.Type == ELEM_POINTER)
			type = GetGlobal(((POINTERTYPE*)type)->ID);
		if (type->Elem.Type == ELEM_POINTERREF)
			type = GetGlobal(((POINTERREFTYPE*)type)->ID);
		if (!(type && (type->Elem.Type == ELEM_UNION ||
			       type->Elem.Type == ELEM_CLASS ||
				type->Elem.Type == ELEM_STRUCT))) return nullptr;

		Name = &Name[index];
		char *SubName = Name;
		while (index < Len)
		{
			if (SubName[0] == '.')
			{
				SubName[0] = 0;
				data = GetClassMember(Name, (UDTYPE*)type, offset);
				if (!data) goto FUNC;
				++index;
				SubName += 1;

				if (index == Len) return data;
				type = GetGlobal(data->TypeID);
				if (type->Elem.Type == ELEM_POINTER)
					type = GetGlobal(((POINTERTYPE*)type)->ID);
				if (type->Elem.Type == ELEM_POINTERREF)
					type = GetGlobal(((POINTERREFTYPE*)type)->ID);
				if (!(type && (type->Elem.Type == ELEM_UNION ||
						type->Elem.Type == ELEM_CLASS ||
						type->Elem.Type == ELEM_STRUCT))) return nullptr;
				Name = SubName;
			} else
			if (SubName[0] == '-')
			{
				SubName[0] = 0;
				data = GetClassMember(Name, (UDTYPE*)type, offset);
				if (!data) goto FUNC;
				index += 2;
				SubName += 2;

				if (index == Len) return data;
				type = GetGlobal(data->TypeID);
				if (type->Elem.Type == ELEM_POINTER)
					type = GetGlobal(((POINTERTYPE*)type)->ID);
				if (type->Elem.Type == ELEM_POINTERREF)
					type = GetGlobal(((POINTERREFTYPE*)type)->ID);
				if (!(type && (type->Elem.Type == ELEM_UNION ||
						type->Elem.Type == ELEM_CLASS ||
						type->Elem.Type == ELEM_STRUCT))) return nullptr;
				Name = SubName;
			}
			++index;
			++SubName;
		}
		data = GetClassMember(Name, (UDTYPE*)type, offset);
		if (data) return data;
	FUNC:;
		FUNCTION *func = GetFunction(Name, (UDTYPE*)type, false);
		if (func)
		{
			if (bFunc) *bFunc = true;
		}
		return func;
	}

	void *CSDSModule::GetGlobal(char *Name, unsigned long FileID, unsigned long LineNumber, bool *bFunc, unsigned long *offset)
	{
		FUNCTION *func = GetFunction(FileID, LineNumber);
		return GetGlobal(Name, func, bFunc, offset);
	}

	BASICTYPE *CSDSModule::CSDSModule::GetGlobal(const char *Name, bool X)
	{
		if (!Name) return nullptr;
		if (!Name[0]) return nullptr;
		map<const char*, unsigned long, MY_char_compare>::IT it = m_GlobalsNameID.find(Name);
		if (it != m_GlobalsNameID.end())
		{
			return GetGlobal(it->second);
		}
		return nullptr;
	}

	const char *CSDSModule::GetEnumName(unsigned long ID, unsigned long long Value)
	{
		ENUMTYPE *et = (ENUMTYPE *)GetGlobal(ID);
		if (!et) return nullptr;
		for (int n = 0; n < et->Length; ++n)
		{
			if (et->Values[n].Value == Value)
				return et->Values[n].Name;
		}
		return nullptr;
	}

	const char *CSDSModule::GetName(BASICTYPE *Type)
	{
		if (Type)
			return Type->Elem.Name;
		return (const char*)m_Strings[0];
	}

```

`source/EXEAnalyzer/sdsmodule.hpp`:

```hpp

#ifndef _SDSMODULE_HPP_
#define _SDSMODULE_HPP_

#include "../Code/tstrmem.hpp"
#include "../Code/alt/altlist.hpp"
#include "symbol.hpp"
#include "sdsfile.hpp"

inline int TSTRADD(char *d, const char *s, int *l)
{
	int Len = TStrLen(s);
	if (*l > Len)
		TStrCat(d, s);
	*l -= Len;
	return Len;
}

	struct MAPFilesLN
	{
		FilesLN *fileln;
		unsigned long count;
	};

	//0 - FUNC
	//1 - LOCAL
	//2 - PUBLIC

	struct SDSELEM
	{
		unsigned long hash:30; //0x80000000 pub, 0x40000000 - local, hash
		unsigned long type:2;
		unsigned long rva;
		char *name;
	};

	struct CSDSModule
	{
		CSDSModule();
		~CSDSModule();

		bool m_LoadOK;
		unsigned long long m_Size;
		HANDLE m_Handle;
		char **m_Strings;
		unsigned char *m_Buffer;
		map<const char*, unsigned long, MY_char_compare> m_GlobalsNameID;
		TList<SDSELEM> m_Elems;
		SDSFILE *m_pSDSFile;

		static FILESIG GetFILESIG(const char *FullFileName);
		FILESIG GetFILESIG();
		void Dump(SDSFILE *SDSFile);
		bool Load(const char *FullFileName);
		void Close();
		bool CheckCRC();
		void Relocate(SDSFILE *SDSFile);
		void InitGlobalsNameID();

		TList<unsigned long> m_BreakPoints; //lineNumbers
		TAnsiNoCaseString m_ExeFileName;
		TAnsiNoCaseString m_SDSFileName;
		CDbgModule *m_pDbgModule; //uses in original syser
		unsigned long m_MemSize;
		unsigned long m_dwProcessId;

		BASICTYPE **GetGlobal(unsigned long *Count) const
		{
			if (Count) *Count = m_pSDSFile->GlobalsLen;
			return (BASICTYPE**)m_pSDSFile->Globals;
		}

		//!
		DATATYPE *GetLocal(unsigned long *Count) const
		{
			if (Count) *Count = m_pSDSFile->LocalsLen;
			return (DATATYPE*)m_pSDSFile->Locals;
		}

		FilesLN *GetFilesLN(unsigned long *Count) const
		{
			if (Count) *Count = m_pSDSFile->FilesLNLen;
			return (FilesLN*)m_pSDSFile->FilesLN;
		}

		FUNCTION **GetFunctions(unsigned long *Count) const
		{
			if (Count) *Count = m_pSDSFile->FunctionsLen;
			return (FUNCTION **)m_pSDSFile->Functions;
		}
		//!
		PUBSYM *GetPublicSymbols(unsigned long *Count) const
		{
			if (Count) *Count = m_pSDSFile->PublicSymbolsLen;
			return (PUBSYM *)m_pSDSFile->PublicSymbols;
		}
		//!
		SrcFileNameID *GetSrcFiles(unsigned long *Count) const
		{
			if (Count) *Count = m_pSDSFile->SrcFileNamesLen;
			return (SrcFileNameID *)m_pSDSFile->SrcFileNames;
		}

		const char *GetExeFileName() const { return (const char *)m_pSDSFile->FullFileName; }
		const char *GetModuleName() const { return (const char *)m_pSDSFile->ModuleName; }

		SrcFileNameID *GetSrcFileName(const char *FileName) const;
		SrcFileNameID *GetSrcFileNameID(unsigned long FileID) const;
		unsigned long GetSrcFilesCount() const { return m_pSDSFile->SourcesCount; }

		int GetFilesLN(unsigned long FileID, map<unsigned long, MAPFilesLN> *FilesLNMap);
		//unsigned long
		int GetFilesLN(ULONG_PTR Address, TList<FilesLN*> *ListFilesLN);
		int GetFilesLN(unsigned long FileID, unsigned long lineNumber, TList<FilesLN*> *ListFilesLN);

		FilesLN *GetFilesLN(unsigned long FileID, unsigned long lineNumber);

		FUNCTION *GetFunction(const char *FuncName, UDTYPE *Type, bool bSkipClassName);
		FUNCTION *GetFunction(const char *FuncName, bool bCase);
		FUNCTION *GetFunction(unsigned long Address);
		FUNCTION *GetFunction(unsigned long FileID, unsigned long LineNumber);
		FUNCTION *GetFunctionByID(unsigned long ID);

		DATATYPE *GetLocal(unsigned long ID);
		DATATYPE *GetLocal(const char *Name, unsigned long DT);

		BASICTYPE *GetGlobal(unsigned long ID);

		char *GetOutput(BASICTYPE *Type, char *pStr, int *pLen);

		char *GetOutput(unsigned long ID, char *pStr, int *pLen);

		bool IsPointerFunction(BASICTYPE *Type);

		//for src tip
		bool GetOutputTypedef(TYPEDEFTYPE *Type, TAnsiString & String);

		//for src tip
		bool GetOutputEnum(ENUMTYPE *Type, TAnsiString & String);

		char *GetOutputFunc(FUNCTION *pFunc, char *pStr, int *Len);

		DATATYPE *GetClassLocal(const char *Name, FUNCTION *pFunc);

		DATATYPE *GetClassMember(const char *Name, UDTYPE *Type, unsigned long *offset);

		void *GetGlobal(char *Name, FUNCTION *pFunc, bool *bFunc, unsigned long *offset);

		void *GetGlobal(char *Name, unsigned long FileID, unsigned long LineNumber, bool *bFunc, unsigned long *offset);

		//TODO improve binary search or remap
		BASICTYPE *GetGlobal(const char *Name, bool X);

		const char *GetEnumName(unsigned long ID, unsigned long long Value);
		const char *GetName(BASICTYPE *Type);
	};
#endif

```

`source/EXEAnalyzer/sdwin.cpp`:

```cpp
#define MYLIBRARY_EXPORT

#include "sdwin.hpp"
#include "../Code/fileio.hpp"

#include <tlhelp32.h>

	MYAPI void GetFileFilter(WCHAR *pStrFilter)
	{
		TStrCpy(pStrFilter, WSTR("Executable Files|*.exe;*.dll;*.sys;*.scr|All Files|*.*|"));
	}

	MYAPI void GetInfo(char *pStrInfo)
	{
	#ifdef _X64_
		  TStrCpy(pStrInfo, "Win64 User Mode Debugger");
	#else
		  TStrCpy(pStrInfo, "Win32 User Mode Debugger");
	#endif
	}

	CSyserUI *gpPluginUI = 0;

	MYAPI void *CreateDebugger(CSyserUI *pSyserUI)
	{
		gpPluginUI = pSyserUI;
		return new CSDWin;
	}

	CSDWin::CSDWin()
	{
		m_dwCurentProcessId = GetCurrentProcess();
		m_hProcess = 0;
		m_bSuspend = false;
		m_Terminate = false;
		m_pCIP = &m_Context.Eip;
	}

	CSDWin::~CSDWin()
	{
	}
#if 0
	#define SE_DEBUG_PRIVILEGE	20L
	void SetPrivilege(bool Enable)
	{
		HANDLE hToken;
		TOKEN_PRIVILEGES tp;
		if(::OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES ,&hToken)) //| TOKEN_QUERY
		{
			//LUID luid;
			//::LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid);
			tp.PrivilegeCount = 1;
			//tp.Privileges[0].Luid = luid;
			tp.Privileges[0].Luid.LowPart = SE_DEBUG_PRIVILEGE;//Luid = luid;
			tp.Privileges[0].Luid.HighPart = 0;
			tp.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;
			::AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL);
			::CloseHandle(hToken);
		}
	}
#endif
	bool CSDWin::Open(const char *Name)
	{
		if (!gpFileIO->IsFileExist(Name) && TStrNICmp(Name, "\\PID:", 5))
			return false;

		if (!CDebugger::Open(Name)) //CX86Debugger::Open
			return false;

		unsigned long ThreadId;

		m_ProcessFileName = Name;
		m_hWaitExitEvent = ::CreateEventA(0, 0, 0, 0);
		m_hDbgThread = ::CreateThread(0, 0,
			(LPTHREAD_START_ROUTINE)CSDWin::ThreadProc, this, 0, (LPDWORD)&ThreadId);

		if (!m_hDbgThread)
		{
			CloseHandle(m_hWaitExitEvent);
			CDebugger::Close(); //CX86Debugger::Close
			return false;
		}

		::WaitForSingleObject(m_hWaitExitEvent, INFINITE);
		if (!m_dwProcessId)
		{
			::CloseHandle(m_hWaitExitEvent);
			CDebugger::Close(); //CX86Debugger::Close
			return false;
		}
		return true;
	}

	bool CSDWin::Close()
	{
		if (m_hProcess)
		{
			::CloseHandle(m_hProcess);
			m_hProcess = ::OpenProcess(1, 0, m_dwProcessId);
			//if (m_hProcess)
			if (!::TerminateProcess(m_hProcess, -1)) //-1 ???
			{
				//???
				//return false;
			}

			::CloseHandle(m_hProcess);
			m_hProcess = 0;
			m_Terminate = true;
			ContinueDebug(true);
			::CloseHandle(m_hWaitExitEvent);
		}
		return CDebugger::Close(); //CX86Debugger::Close
	}

	void CSDWin::Release()
	{
		CDebugger::Release();
		delete this;
	}

	bool CSDWin::InsertHandle(unsigned long dwThreadId, HANDLE hThread)
	{
		map<unsigned long, HANDLE>::IT it =
			m_ThreadIdMap.insert(_Tmap_pair<unsigned long, HANDLE>(dwThreadId, (HANDLE*)0));

		if (it == m_ThreadIdMap.end())
			return false;

		  return ::DuplicateHandle(m_dwCurentProcessId, hThread, m_dwCurentProcessId,
				&it->second, 0x5A, 0, 0) != 0;

		//	PROCESS_DUP_HANDLE //0x40
		//	PROCESS_VM_READ //0x10
		//	PROCESS_VM_OPERATION //0x08
		//	PROCESS_CREATE_THREAD //0x02

	}

	bool CSDWin::RemoveHandle(unsigned long dwThreadId)
	{
		return m_ThreadIdMap.erase(dwThreadId) != 0;
	}

	void CSDWin::DebugException(unsigned int Type)
	{
		m_pDebugInterface->OnDebugException(Type);
	}

	bool CSDWin::SaveRegisters(unsigned long dwThreadId)
	{
		map<unsigned long, HANDLE>::IT It = m_ThreadIdMap.find(dwThreadId);
		if (It == m_ThreadIdMap.end())
			return false;

		  m_Context.ContextFlags = CONTEXT_ALL;
		return ::GetThreadContext(It->second, &m_Context) != 0;
	}

	bool CSDWin::UpdateRegisters(unsigned long dwThreadId)
	{
		map<unsigned long, HANDLE>::IT It = m_ThreadIdMap.find(dwThreadId);
		if (It == m_ThreadIdMap.end())
			return false;

		  m_Context.ContextFlags = CONTEXT_ALL;
		return ::SetThreadContext(It->second, &m_Context) != 0;
	}

	bool CSDWin::StepBack(unsigned long dwThreadId)
	{
		if (!SaveRegisters(dwThreadId))
			return false;

		--m_Context.Eip;

		return UpdateRegisters(dwThreadId) != 0;
	}

	unsigned long CSDWin::WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size)
	{
		ULONG_PTR WRSize = 0;

		if (!::WriteProcessMemory(m_hProcess, (LPVOID)Address, Buffer, Size, (SIZE_T *)&WRSize))
			return 0;
		::FlushInstructionCache(m_hProcess, 0, 0); //Buffer, Size
		return WRSize;
	}

	unsigned long CSDWin::ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		ULONG_PTR RDSize = 0;

		if (!::ReadProcessMemory(m_hProcess, (LPCVOID)Address, Buffer, Size, (SIZE_T *)&RDSize))
			return 0;
		return RDSize;
	}


	bool CSDWin::SetCodeBreakPoint(BREAK_POINT & BP)
	{
		return SetX86CodeBreakPoint(BP);
	}

	bool CSDWin::ClearCodeBreakPoint(BREAK_POINT & BP)
	{
		return ClearX86CodeBreakPoint(BP);
	}

	bool CSDWin::SetDataBreakPoint(BREAK_POINT & BP)
	{
		return SetX86DataBreakPoint(BP, &m_Context.Dr0, &m_Context.Dr7);
	}

	bool CSDWin::ClearDataBreakPoint(BREAK_POINT & BP)
	{
		return ClearX86DataBreakPoint(BP, &m_Context.Dr0, &m_Context.Dr7);
	}

	bool CSDWin::SetTrace(bool trace)
	{
		for (map<unsigned long, HANDLE>::IT it = m_ThreadIdMap.begin();
			it != m_ThreadIdMap.end(); ++it)
		{
			CONTEXT regs;
			regs.ContextFlags = CONTEXT_FULL; //0x10000B; ???
			if (::GetThreadContext(it->second, &regs))
			{
				if (trace)
					regs.EFlags |= 0x100;
				else	regs.EFlags &= ~0x100;

				regs.ContextFlags = CONTEXT_FULL;
				if (!::SetThreadContext(it->second, &regs))
				{
					//TODO
				}
			}
		}
		return true;
	}

	bool CSDWin::SetSingleStep()
	{
		return SetTrace(true);
	}

	bool CSDWin::RemoveSingleStep()
	{
		return SetTrace(false);
	}

	bool CSDWin::SaveRegisters()
	{
		bool result = SaveRegisters(m_dwThreadId);
#if 0
		if (result)
		{
			memset(&m_StackFrame, 0, sizeof(m_StackFrame));
		#ifdef _X64_
			m_ImageType = IMAGE_FILE_MACHINE_AMD64;
			m_StackFrame.AddrPC.Offset	= m_Context.Rip;
			m_StackFrame.AddrPC.Mode	= AddrModeFlat;
			m_StackFrame.AddrStack.Offset	= m_Context.Rsp;
			m_StackFrame.AddrStack.Mode	= AddrModeFlat;
			m_StackFrame.AddrFrame.Offset	= m_Context.Rbp;
			m_StackFrame.AddrFrame.Mode	= AddrModeFlat;
		#else //X32
			m_ImageType = IMAGE_FILE_MACHINE_I386;
			m_StackFrame.AddrPC.Offset	= m_Context.Eip;
			m_StackFrame.AddrPC.Mode	= AddrModeFlat;
			m_StackFrame.AddrStack.Offset	= m_Context.Esp;
			m_StackFrame.AddrStack.Mode	= AddrModeFlat;
			m_StackFrame.AddrFrame.Offset	= m_Context.Ebp;
			m_StackFrame.AddrFrame.Mode	= AddrModeFlat;
		#endif
			m_StackFrameContext = m_Context;
		}
#endif
		return result;
	}

	bool CSDWin::UpdateRegisters()
	{
		return UpdateRegisters(m_dwThreadId);
	}

	bool CSDWin::Pause()
	{
		//TODO break at our debuggee app
		::DebugBreakProcess(m_hProcess); //TODO RETURN FALSE
		return true;
	}

	bool CSDWin::ContinueDebug(bool bRestoreScr)
	{
		return ::ResumeThread(m_hDbgThread) != 0;
	}

	//TODO StackReadMemory
	//TODO StackFunctionTableAccess64
	//TODO StackGetModuleBase64
	//TODO StackTranslateAddress64
#if 0
	bool CSDWin::GetStack(STACK_FRAME *pStackFrame)
	{
		if (!::StackWalk64(
			m_ImageType,		// __in      DWORD MachineType,
			m_hProcess,		// __in      HANDLE hProcess, //GetCurrentProcess(),
			m_hThread,		// __in      HANDLE hThread, //GetCurrentThread(),
			&m_StackFrame,		// __inout   LP STACKFRAME64 StackFrame,
			&m_StackFrameContext,		// __inout   PVOID ContextRecord,
			NULL,			// __in_opt  PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
			SymFunctionTableAccess64,	// __in_opt  PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
			SymGetModuleBase64,	// __in_opt  PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
			NULL			// __in_opt  PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress
			))
		{
			if (pStackFrame)
			{
				pStackFrame->AddrPC = 0;
				pStackFrame->AddrReturn = 0;
				pStackFrame->AddrFrame = 0;
				pStackFrame->AddrStack = 0;

			}
			return false;
		}
		pStackFrame->AddrPC = m_StackFrame.AddrPC.Offset;
		pStackFrame->AddrReturn = m_StackFrame.AddrReturn.Offset;
		pStackFrame->AddrFrame = m_StackFrame.AddrFrame.Offset;
		pStackFrame->AddrStack = m_StackFrame.AddrStack.Offset;
		return true;
	}
#endif
	void CSDWin::GetX86RegPtr(X86_CPU_REG_PTR *pCPURegPtr, int nCPU)
	{
		GetX86RegPtr(pCPURegPtr);
	}

	void CSDWin::GetX86RegPtr(X86_CPU_REG_PTR *pCPURegPtr)
	{
		pCPURegPtr->pCS = (unsigned short*)&m_Context.SegCs;
		pCPURegPtr->pDS = (unsigned short*)&m_Context.SegDs;
		pCPURegPtr->pES = (unsigned short*)&m_Context.SegEs;
		pCPURegPtr->pFS = (unsigned short*)&m_Context.SegFs;
		pCPURegPtr->pGS = (unsigned short*)&m_Context.SegGs;
		pCPURegPtr->pSS = (unsigned short*)&m_Context.SegSs;
	#ifdef _X64_
		pCPURegPtr->pCAX = &m_Context.Rax;
		pCPURegPtr->pCBX = &m_Context.Rbx;
		pCPURegPtr->pCCX = &m_Context.Rcx;
		pCPURegPtr->pCDX = &m_Context.Rdx;
		pCPURegPtr->pCSI = &m_Context.Rsi;
		pCPURegPtr->pCDI = &m_Context.Rdi;
		pCPURegPtr->pCBP = &m_Context.Rbp;
		pCPURegPtr->pCSP = &m_Context.Rsp;

		pCPURegPtr->pR8 = &m_Context.R8;
		pCPURegPtr->pR9 = &m_Context.R9;
		pCPURegPtr->pR10 = &m_Context.R10;
		pCPURegPtr->pR11 = &m_Context.R11;
		pCPURegPtr->pR12 = &m_Context.R12;
		pCPURegPtr->pR13 = &m_Context.R13;
		pCPURegPtr->pR14 = &m_Context.R14;
		pCPURegPtr->pR15 = &m_Context.R15;

		pCPURegPtr->pEFL = (EFL_REG*)&m_Context.EFlags;
		pCPURegPtr->pCIP = &m_Context.Rip;
	#else
		pCPURegPtr->pCAX = &m_Context.Eax;
		pCPURegPtr->pCBX = &m_Context.Ebx;
		pCPURegPtr->pCCX = &m_Context.Ecx;
		pCPURegPtr->pCDX = &m_Context.Edx;
		pCPURegPtr->pCSI = &m_Context.Esi;
		pCPURegPtr->pCDI = &m_Context.Edi;
		pCPURegPtr->pCBP = &m_Context.Ebp;
		pCPURegPtr->pCSP = &m_Context.Esp;

		pCPURegPtr->pEFL = (EFL_REG*)&m_Context.EFlags;
		pCPURegPtr->pCIP = &m_Context.Eip;
	#endif
		pCPURegPtr->pDR0 = &m_Context.Dr0;
		pCPURegPtr->pDR1 = &m_Context.Dr1;
		pCPURegPtr->pDR2 = &m_Context.Dr2;
		pCPURegPtr->pDR3 = &m_Context.Dr3;
		pCPURegPtr->pDR4 = 0;
		pCPURegPtr->pDR5 = 0;
		pCPURegPtr->pDR6 = &m_Context.Dr6;
		pCPURegPtr->pDR7 = &m_Context.Dr7;

	#ifdef _X64_
		pCPURegPtr->FP_ControlWord = (stFPU_CONTROL_REG *)&m_Context.FltSave.ControlWord;
		pCPURegPtr->FP_StatusWord = (stFPU_STATUS_REG *)&m_Context.FltSave.StatusWord;
		pCPURegPtr->FP_TagWord = (stFPU_TAG_REG *)&m_Context.FltSave.TagWord;
		pCPURegPtr->FP_RegisterArea = (unsigned char*)m_Context.FltSave.FloatRegisters; //10*8
		pCPURegPtr->pXMM = (void *)m_Context.FltSave.XmmRegisters; //16
	#else
		pCPURegPtr->FP_ControlWord = (stFPU_CONTROL_REG *)&m_Context.FloatSave.ControlWord;
		pCPURegPtr->FP_StatusWord = (stFPU_STATUS_REG *)&m_Context.FloatSave.StatusWord;
		pCPURegPtr->FP_TagWord = (stFPU_TAG_REG *)&m_Context.FloatSave.TagWord;
		pCPURegPtr->FP_RegisterArea = (unsigned char*)m_Context.FloatSave.RegisterArea; //10*8
		pCPURegPtr->pXMM = (void *)m_Context.ExtendedRegisters; //8
	#endif
	}



	bool CSDWin::GetSegRegBase(unsigned long Selector, ULONG_PTR *pAddress, unsigned long *pLimit)
	{
		map<unsigned long, HANDLE>::IT it = m_ThreadIdMap.find(m_dwThreadId);
		if (it == m_ThreadIdMap.end())
			return false;

		LDT_ENTRY ldt_entry;
		unsigned int Result = ::GetThreadSelectorEntry(it->second, Selector, &ldt_entry);
		if (Result)
		{
			if (pAddress)
			{
				*pAddress = ldt_entry.HighWord.Bytes.BaseHi << 24;
				*pAddress |= ldt_entry.HighWord.Bytes.BaseMid << 16;
				*pAddress |= ldt_entry.BaseLow;
			}
			if (pLimit)
			{
				*pLimit = (ldt_entry.HighWord.Bits.LimitHi << 16) + ldt_entry.LimitLow;
				if (ldt_entry.HighWord.Bits.Granularity)
					*pLimit = (*pLimit<<12) | 0xFFFF;
			}
		}
		return Result == 1;
	}

	bool CSDWin::ReadPE(MZHEAD *pMZHead, PE_HEAD *pPEHead)
	{
		memset(pPEHead, 0, sizeof(PE_HEAD));

		unsigned long PEOffset;
		if (ReadMemory((unsigned long long)&pMZHead->pfNewHead, &PEOffset, 4) != 4)
			return false;

		if (ReadMemory((ULONG_PTR)pMZHead+PEOffset, pPEHead, sizeof(PE_HEAD)) != sizeof(PE_HEAD))
			return false;

		return pPEHead->Signature == 0x4550;
	}

	unsigned int __stdcall CSDWin::ThreadProc(void *pData) //WINAPI
	{
		CSDWin *p = (CSDWin*)pData;
		
		//unsigned long continueStatus = 0;

		p->m_Terminate = 0;
		p->m_dwProcessId = 0;

		if (TStrStr(p->m_ProcessFileName.operator const char*(), "\\PID:"))
		{
			sscanf(p->m_ProcessFileName, "\\PID:%08X", &p->m_dwProcessId);
			p->m_hProcess = ::OpenProcess(0x1FFFFF, 0, p->m_dwProcessId);
			if (!p->m_hProcess)
			{
				p->m_dwProcessId = 0;
				::SetEvent(p->m_hWaitExitEvent);
				return 0;
			}
			if (!DebugActiveProcess(p->m_dwProcessId))
			{
				::SetEvent(p->m_hWaitExitEvent);
				return 0;
			}
			p->m_Attached = true;
		} else
		{
			_STARTUPINFOA startup_info;
			memset(&startup_info, 0, sizeof(_STARTUPINFOA));
			startup_info.cb = sizeof(_STARTUPINFOA);

			PROCESS_INFORMATION process_info;
			
			char *env = ::GetEnvironmentStringsA();

			char *cmdline = new char[MAX_FN_LEN];
			TStrCpy(cmdline, ""); //TODO

			if (!::CreateProcessA(
				0,//p->m_ProcessFileName,
				(LPSTR)p->m_ProcessFileName.operator const char*(),//0,//cmdline,
				0,
				0,
				TRUE,
				NORMAL_PRIORITY_CLASS|DEBUG_PROCESS,//|DEBUG_ONLY_THIS_PROCESS, //0x21,
				0,//env,
				0,
				&startup_info,
				&process_info))
			{
				::FreeEnvironmentStringsA(env);
				::SetEvent(p->m_hWaitExitEvent);

				if (GetLastError() == ERROR_ELEVATION_REQUIRED)
				{
					char Buffer[1024];
					sprintf(Buffer, "Unable to start: unsufficient privileges!\nRestart debugger as admin\n");
					p->m_pDebugInterface->DisplayMsg(Buffer);
				}
				return 0;
			}
			::FreeEnvironmentStringsA(env);
			p->m_dwProcessId = process_info.dwProcessId;
			p->m_hProcess = process_info.hProcess;
			p->m_hThread = process_info.hThread;
			p->m_Attached = false;
		}

		p->m_MainModuleName = TGetFileName(p->m_ProcessFileName.operator const char*());
		p->m_bSuspend = false;
		memset(&p->m_Context, 0, sizeof(CONTEXT));

		PE_HEAD pe_head;
		char AnsiBuffer[264];
		char DirName[264];
		WCHAR UnicodeBuffer[262];

		DEBUG_EVENT dbg_event;

		while (!p->m_Terminate && ::WaitForDebugEvent(&dbg_event, INFINITE))
		{
			unsigned int continueStatus = DBG_CONTINUE;

			switch (dbg_event.dwDebugEventCode)
			{
			case EXCEPTION_DEBUG_EVENT:
			//	sprintf(AnsiBuffer, "Debug Event : EXCEPTION_EVENT !\n");
			//	p->m_pDebugInterface->DisplayMsg(AnsiBuffer);

				continueStatus = p->ProcessDebugEvent(&dbg_event);
				break;

			case CREATE_THREAD_DEBUG_EVENT:
			//	sprintf(AnsiBuffer, "Debug Event : CREATE_THREAD !\n");
			//	p->m_pDebugInterface->DisplayMsg(AnsiBuffer);

				p->InsertHandle(dbg_event.dwThreadId, dbg_event.u.CreateThread.hThread);
				break;

			case CREATE_PROCESS_DEBUG_EVENT:
			//	sprintf(AnsiBuffer, "Debug Event : CREATE_PROCESS !\n");
			//	p->m_pDebugInterface->DisplayMsg(AnsiBuffer);

				p->m_StepCount = 0;
				p->InsertHandle(dbg_event.dwThreadId, dbg_event.u.CreateProcessInfo.hThread);

				if (!p->m_Attached)
					p->SetCodeBP((ULONG_PTR)dbg_event.u.CreateProcessInfo.lpStartAddress, 0x200, BP_STATE_ENABLE);

				p->ReadPE((MZHEAD*)dbg_event.u.CreateProcessInfo.lpBaseOfImage, &pe_head);


				p->m_pDebugInterface->OnLoadModule(p, p->m_ProcessFileName,
					(ULONG_PTR)dbg_event.u.CreateProcessInfo.lpBaseOfImage,
					pe_head.SizeOfImage,
					pe_head.TimeDateStamp,
					pe_head.CheckSum);

				CloseHandle(dbg_event.u.CreateProcessInfo.hFile);
				break;

			case EXIT_THREAD_DEBUG_EVENT:
			//	sprintf(AnsiBuffer, "Debug Event : EXIT_THREAD !\n");
			//	p->m_pDebugInterface->DisplayMsg(AnsiBuffer);

				p->RemoveHandle(dbg_event.dwThreadId);
				break;

			case EXIT_PROCESS_DEBUG_EVENT:

				p->DelAllCodeBP(0, 0);

				sprintf(AnsiBuffer, "Debug Event : Process Terminated , Exit Code = %d (0x%X) !\n",
					dbg_event.u.ExitProcess.dwExitCode,
					dbg_event.u.ExitProcess.dwExitCode);
				p->m_pDebugInterface->DisplayMsg(AnsiBuffer);

				p->m_pDebugInterface->OnExit(true);
				p->m_Terminate = false;
				break;

			case LOAD_DLL_DEBUG_EVENT:

			//	sprintf(AnsiBuffer, "Debug Event : LOAD_DLL hFile 0x%X lpImage %x!\n",
			//		(unsigned long)dbg_event.u.LoadDll.hFile, dbg_event.u.LoadDll.lpImageName);
			//	p->m_pDebugInterface->DisplayMsg(AnsiBuffer);

				if (dbg_event.u.LoadDll.lpImageName)
				{
					ULONG_PTR AddressName = 0;
					AnsiBuffer[0] = 0;

					p->ReadMemory((ULONG_PTR)dbg_event.u.LoadDll.lpImageName, &AddressName, sizeof(AddressName));
					if (AddressName)
					{
						if (dbg_event.u.LoadDll.fUnicode)
						{
							UnicodeBuffer[0] = 0;
							p->ReadMemory(AddressName, &UnicodeBuffer, MAX_FN_LEN*2);
							WideCharToMultiByte(0, 0, (LPCWSTR)&UnicodeBuffer, -1, AnsiBuffer, MAX_FN_LEN, 0, 0);
						} else
						{
							p->ReadMemory(AddressName, AnsiBuffer, MAX_FN_LEN);
						}
					}
			//		int Len = TStrLen(AnsiBuffer);
			//	if (Len)
			//	p->m_pDebugInterface->DisplayMsg(AnsiBuffer);
			//	sprintf(AnsiBuffer, " Debug Event : LOAD_DLL Len %d !\n",
			//		Len);
			//	p->m_pDebugInterface->DisplayMsg(AnsiBuffer);

					if (TGetFileName(AnsiBuffer) == AnsiBuffer)
					{
						GetSystemDirectoryA(DirName, MAX_PATH);
						TStrCat(DirName, "\\");
						TStrCat(DirName, AnsiBuffer);
						TStrCpy(AnsiBuffer, DirName);
					}

					p->ReadPE((MZHEAD*)dbg_event.u.LoadDll.lpBaseOfDll, &pe_head);

					if (dbg_event.u.LoadDll.lpBaseOfDll && AnsiBuffer[0])
						p->m_pDebugInterface->OnLoadModule(p, AnsiBuffer,
							(ULONG_PTR)dbg_event.u.LoadDll.lpBaseOfDll,
							pe_head.SizeOfImage,
							pe_head.TimeDateStamp,
							pe_head.CheckSum);
				}
				CloseHandle(dbg_event.u.LoadDll.hFile);
				break;

			case UNLOAD_DLL_DEBUG_EVENT:
			//	sprintf(AnsiBuffer, "Debug Event : UNLOAD_DLL !\n");
			//	p->m_pDebugInterface->DisplayMsg(AnsiBuffer);

					if (dbg_event.u.UnloadDll.lpBaseOfDll)
						p->m_pDebugInterface->OnUnloadModule(p,
							(ULONG_PTR)dbg_event.u.UnloadDll.lpBaseOfDll);
				break;

		//	case OUTPUT_DEBUG_STRING_EVENT: u.DebugString
		//	case RIP_EVENT:
			default:
			//	sprintf(AnsiBuffer, "Debug Event : default %x!\n", dbg_event.dwDebugEventCode);
			//	p->m_pDebugInterface->DisplayMsg(AnsiBuffer);

				continueStatus = DBG_EXCEPTION_NOT_HANDLED; //pass exception to debuggee
				break;
			}
			::ContinueDebugEvent(dbg_event.dwProcessId, dbg_event.dwThreadId, continueStatus);
		}

		DebugActiveProcessStop(p->m_dwProcessId);
		DebugSetProcessKillOnExit(0);
		p->m_hProcess = 0;
		::SetEvent(p->m_hWaitExitEvent);
		return 1;
	}

	unsigned int CSDWin::ProcessDebugEvent(DEBUG_EVENT *pEvent)
	{
		unsigned int continueStatus = DBG_CONTINUE;

		DWORD ExceptionCode = pEvent->u.Exception.ExceptionRecord.ExceptionCode;

		if (ExceptionCode == STATUS_BREAKPOINT) //STATUS_WX86_BREAKPOINT
		{
			continueStatus = DBG_CONTINUE;
			if (++m_StepCount == 1)
			{
				if (m_Attached)
				{
					m_dwThreadId = pEvent->dwThreadId;
					SaveRegisters(m_dwThreadId);

					DebugException(0);
					m_bSuspend = true;
					::SetEvent(m_hWaitExitEvent);
					::SuspendThread(m_hDbgThread);
					m_bSuspend = false;

					HANDLE hModules = ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, m_dwProcessId);
					if (hModules == INVALID_HANDLE_VALUE) //-1)
					{
						//???
						return 0;
					}

					MODULEENTRY32 mod;
					mod.dwSize = sizeof(MODULEENTRY32);
					PE_HEAD pe_head;
					if (::Module32First(hModules, &mod))
					{
						do {
							ReadPE((MZHEAD*)mod.modBaseAddr, &pe_head);

							m_pDebugInterface->OnLoadModule(
								this,
								mod.szExePath,
								(ULONG_PTR)mod.modBaseAddr,
								mod.modBaseSize,
								pe_head.TimeDateStamp,
								pe_head.CheckSum);

						} while (::Module32Next(hModules, &mod));
					}
					::CloseHandle(hModules);
				}
			} else
			{
			//HandleInt3(Address)
				m_dwThreadId = pEvent->dwThreadId;
				bool bHandle = false;
				BREAK_POINT *BreakPoint = GetCodeBP((ULONG_PTR)pEvent->u.Exception.ExceptionRecord.ExceptionAddress, 0, 0);
				if (BreakPoint)
				{
					++BreakPoint->HitCount;
					if (BreakPoint->State == BP_STATE_ENABLE)
					{
						StepBack(pEvent->dwThreadId);
						if (WriteMemory(m_Context.Eip,	&BreakPoint->CCBackup, 1))
							BreakPoint->State = BP_STATE_RECOV;

						if (m_pDebugInterface->TestCondition(BreakPoint->Condition, BreakPoint))
						{
							m_pDebugInterface->RunCmds(BreakPoint->Command);
							if (BreakPoint->Type & 0x100)
							{
							//	if (BreakPoint->OnPatchBreakPoint)
							//		BreakPoint->OnPatchBreakPoint();
							} else
							if ( !(BreakPoint->Type & 0x200) ) //0x300
							{
								//???
								m_pDebugInterface->Reset();
								bHandle = true;
							}
						//	if (BreakPoint->Type & 0x400)
						//		DelCodeBP(BreakPoint);
							if (m_pDebugInterface->Continue())
							{
								DelAllCodeBP(0x200, 0);

								DebugException(1);
								m_bSuspend = true;
								if (m_StepCount == 2)
									::SetEvent(m_hWaitExitEvent);
								::SuspendThread(m_hDbgThread);
								m_bSuspend = false;
							}
						}
						if (IsRecoverBreakPoint())
							SetSingleStep();
					}
				}
			}


		} else
		if (ExceptionCode == STATUS_SINGLE_STEP) //STATUS_WX86_SINGLE_STEP
		{
			continueStatus = DBG_CONTINUE;
			m_dwThreadId = pEvent->dwThreadId;
			SaveRegisters(pEvent->dwThreadId);
		//HandleInt1(Address)
			bool bHandle_ = RecoverBreakPoint()>0;
			bool bHandle = false;
			BREAK_POINT *BreakPoint = GetCodeBP(m_Context.Eip, 0, 0);
			if (BreakPoint)
				++BreakPoint->HitCount;
			{
				if (BreakPoint && BreakPoint->State == BP_STATE_ENABLE)
				{
					if (WriteMemory(m_Context.Eip, (char *)&BreakPoint->CCBackup, 1))
						BreakPoint->State = BP_STATE_RECOV;

					if (m_pDebugInterface->TestCondition(BreakPoint->Condition, BreakPoint))
					{
						m_pDebugInterface->RunCmds(BreakPoint->Command);
						if (BreakPoint->Type & 0x100)
						{
						//	if (BreakPoint->OnPatchBreakPoint)
						//		BreakPoint->OnPatchBreakPoint();
						} else
						if ( !(BreakPoint->Type & 0x200) ) //0x300
						{
							m_pDebugInterface->Reset();
							bHandle = true;
						}
					}
					//if (BreakPoint->Type & 0x400)
					//	DelCodeBP(BreakPoint);
				}
			}

			if (m_pDebugInterface->m_State && m_pDebugInterface->Continue())
			{
				bHandle = true;
			} else
			if (GetDataBP(0, 0, 0) > 0)
			{
				bHandle = true;
			}

			if (bHandle)
			{
				DelAllCodeBP(0x200, 0);

				DebugException(1);
				m_bSuspend = true;
				::SuspendThread(m_hDbgThread);
				m_bSuspend = false;
			}
			if (IsRecoverBreakPoint())
				SetSingleStep();
		} else
		if (ExceptionCode == DBG_CONTROL_C ||
		    ExceptionCode == DBG_CONTROL_BREAK)
		{
			continueStatus = DBG_CONTINUE;
			m_dwThreadId = pEvent->dwThreadId;
			SaveRegisters(pEvent->dwThreadId);

			DebugException(5);
			m_bSuspend = true;
			::SuspendThread(m_hDbgThread);
			m_bSuspend = false;
		} else
		if (ExceptionCode == STATUS_ACCESS_VIOLATION)
		{
			continueStatus = DBG_CONTINUE;
			m_dwThreadId = pEvent->dwThreadId;
			SaveRegisters(pEvent->dwThreadId);

			m_ExceptionAddress = (ULONG_PTR)pEvent->u.Exception.ExceptionRecord.ExceptionAddress;
			char Buffer[260];
			sprintf(Buffer, "Debug Event : Access Violation , Address = " F0ADDR "X !\n", m_ExceptionAddress);
			m_pDebugInterface->DisplayMsg(Buffer);

			DebugException(4);
			m_bSuspend = true;
			::SuspendThread(m_hDbgThread);
			SaveRegisters(pEvent->dwThreadId);
			m_bSuspend = false;

		} else
		{
			continueStatus = DBG_EXCEPTION_NOT_HANDLED;
			m_dwThreadId = pEvent->dwThreadId;
			SaveRegisters(pEvent->dwThreadId);

			DebugException(0);
			m_bSuspend = true;
			::SuspendThread(m_hDbgThread);
			SaveRegisters(pEvent->dwThreadId);
			m_bSuspend = false;
		}

		return continueStatus;
	}


```

`source/EXEAnalyzer/sdwin.hpp`:

```hpp

#ifndef _SDWIN_HPP_
#define _SDWIN_HPP_

#include "../Code/define.h"
#include "../Code/alt/altmap.hpp"
#include "x86debugger.hpp"
#include "mzhead.hpp"
#include "pehead.hpp"

//#include "../Code/osdefine.hpp"

//#include <windows.h>
#if 0
#include <dbghelp.h>
#endif
	struct CSDWin : public CX86Debugger
	{
		TAnsiString m_ProcessFileName;
		map<unsigned long, HANDLE> m_ThreadIdMap;

		HANDLE m_hDbgThread;
		HANDLE m_hThread;
		HANDLE m_hProcess;
		HANDLE m_dwCurentProcessId;
		CONTEXT m_Context;
		ULONG_PTR m_ExceptionAddress;
		HANDLE m_hWaitExitEvent;
		bool m_bSuspend;
		bool m_Terminate;
		bool m_Attached;

		unsigned long m_StepCount;
#if 0
		DWORD m_ImageType;
		STACKFRAME64 m_StackFrame;
		CONTEXT m_StackFrameContext;
#endif
	public:
		CSDWin();
		virtual ~CSDWin();

		bool InsertHandle(unsigned long dwThreadId, HANDLE hThread);
		bool RemoveHandle(unsigned long dwThreadId);

		void DebugException(unsigned int Type);

		bool ReadPE(MZHEAD *pMZHead, PE_HEAD *pPEHead);
		unsigned int ProcessDebugEvent(DEBUG_EVENT *pEvent);
		static unsigned int __stdcall ThreadProc(void *pData); //WINAPI

		virtual void Release() override;
		virtual bool Open(const char *Name) override;
		virtual bool Close() override;

		virtual unsigned long WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size) override;
		virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) override;

		bool SaveRegisters(unsigned long dwThreadId);
		bool UpdateRegisters(unsigned long dwThreadId);
		bool StepBack(unsigned long dwThreadId);

		virtual bool SaveRegisters() override;
		virtual bool UpdateRegisters() override;

		virtual bool SetCodeBreakPoint(BREAK_POINT & BP) override;
		virtual bool ClearCodeBreakPoint(BREAK_POINT & BP) override;
		virtual bool SetDataBreakPoint(BREAK_POINT & BP) override;
		virtual bool ClearDataBreakPoint(BREAK_POINT & BP) override;

		bool SetTrace(bool trace); //++
		virtual bool SetSingleStep() override;
		virtual bool RemoveSingleStep() override;
		virtual bool Pause() override;
		virtual bool ContinueDebug(bool bRestoreScr) override;
#if 0
		virtual bool GetStack(STACK_FRAME *pStackFrame) override;
#endif
		virtual void GetX86RegPtr(X86_CPU_REG_PTR *pCPURegPtr) override;
		virtual void GetX86RegPtr(X86_CPU_REG_PTR *pCPURegPtr, int nCPU) override;

		virtual bool GetSegRegBase(unsigned long Selector, ULONG_PTR *pAddress, unsigned long *pBits) override;
	};

	struct CSyserUI; //??? include "plugin.hpp" CSyserPluginUI

#if defined(MYLIBRARY_EXPORT)
#   define MYAPI   __declspec(dllexport)
#else
#   define MYAPI   __declspec(dllimport)
#endif

	extern "C" MYAPI void GetFileFilter(WCHAR *Filter);
	extern "C" MYAPI void GetInfo(char *pInfo);
	extern "C" MYAPI void *CreateDebugger(CSyserUI *pSyserUI);

#endif

```

`source/EXEAnalyzer/sourcedebug.cpp`:

```cpp

//#ifndef _RING0_
#include "pefile.hpp"
#include "sourcedebug.hpp"
#if 1
	class CDiaBSTR 
	{
		WCHAR *m_bstr;
	public:
		CDiaBSTR() { m_bstr = NULL; }
		~CDiaBSTR() { release(); }
		void release() { if (m_bstr != NULL) ::SysFreeString(m_bstr); m_bstr = NULL; } //LocalFree(m_bstr);
		WCHAR **operator &() { /*assert(m_bstr == NULL);*/ return &m_bstr; }
		operator WCHAR*() { /*assert(m_bstr != NULL);*/ return m_bstr; }
	};

	int TStrLen(const WCHAR *s) { return ::TStrLen<WCHAR>(s); }
	int TStrCpy(char *d, const WCHAR *s) { return ::TStrCpy<char,WCHAR>(d, s); }
#else
	typedef WCHAR* BSTR;
	class CDiaBSTR 
	{
		BSTR m_bstr;
	public:
		CDiaBSTR() { m_bstr = NULL; }
		~CDiaBSTR() { release(); }
		void release() { if (m_bstr != NULL) ::SysFreeString(m_bstr); m_bstr = NULL; }
		BSTR *operator &() { /*assert(m_bstr == NULL);*/ return &m_bstr; }
		operator BSTR()	{ /*assert(m_bstr != NULL);*/ return m_bstr; }
	};
#endif

//#define TXTDEBUG

#ifdef TXTDEBUG
FILE *f = NULL;
#endif
	struct Trace
	{
		const char *m_func;
		int level;
		Trace(unsigned long n, const char *func)
		{
			m_func = func;
			level = n;
#ifdef TXTDEBUG
{
	for (int l=0;l<level;++l)
	{
fprintf(f," ");
fflush(f);
	}
}
fprintf(f,"{ %s %d\n", m_func, level);
fflush(f);
#endif
		}
		~Trace()
		{
#ifdef TXTDEBUG
{
	for (int l=0;l<level;++l)
	{
fprintf(f," %d", level);
fflush(f);
	}
}
fprintf(f,"} %s\n", m_func);
fflush(f);
#endif
		}
	};

	CSourceDebug::CSourceDebug()
	{
#ifdef TXTDEBUG
        f = fopen("LOGWATCH", "w");
fprintf(f,"Start logging\n");
fflush(f);
#endif
		m_CompilandFileID = 0;
		m_CompilandUnitID = 0;
	#ifndef _RING0_		
		m_DllGCO = 0;
		m_hLibrary = 0;
	#endif
		m_ModuleName = nullptr;
		m_PDBFullFileName = nullptr;

		m_StringPublicSymbol = nullptr;
		m_HasStringPublicSymbol = false;

	#ifndef _RING0_
		m_Segments = nullptr;
		m_EnumFragmentData = nullptr;

		m_GlobalSymbol = nullptr;
		m_Session = nullptr;
		m_DataSource = nullptr;
	#endif
		m_CreateProgress = nullptr;
		m_UpdateProgress = nullptr;
		m_UpdateCaption = nullptr;
		m_DestroyProgress = nullptr;

		m_DialogAppendSrcFilename = nullptr;

		m_FuncID = 1;

		m_ElemID = 1;

		m_DataID = 1;
		m_Locals.push_back(0);
		
		m_nSrcFilesCount = 0; //TODO remove
	}

	CSourceDebug::~CSourceDebug()
	{
#ifdef TXTDEBUG
fclose(f);
#endif		//Release() from outside
		//???
	}

	unsigned long CSourceDebug::PackString(const char *Str)
	{
		if (!Str || !*Str) return 0;
		int StrLen = TStrLen(Str);

		if ((StrLen + m_StringsCur + 1) >= m_StringsTail)
		{
			stStringChunk Chunk;
			Chunk.StringsBuf = m_StringsBuf;
			Chunk.StringsHead = m_StringsHead;
			Chunk.StringsCur = m_StringsCur;
			m_StringsList.Append(&Chunk);
			m_StringsBuf = new char[(STRINGS_CHUNK_SIZE-(m_StringsCur % STRINGS_CHUNK_SIZE))+STRINGS_CHUNK_SIZE];
			m_StringsTail += STRINGS_CHUNK_SIZE;
			m_StringsHead = m_StringsCur;
		}
		map<const char *, unsigned long, MY_char_compare>::IT it = m_StringIDMap.find(Str);
		if (it != m_StringIDMap.end())
			return it->second;

		char *Dest = (m_StringsBuf + m_StringsCur) - m_StringsHead;
		TStrCpy(Dest, Str);
		m_StringIDMap.insert(_Tmap_pair<const char*,unsigned long>(Dest, m_StringsID));
		m_StringIndexes.push_back(m_StringsCur);
		m_StringsCur += StrLen+1;
		++m_StringsID;
		return m_StringsID-1;
	}

	unsigned long CSourceDebug::PackString(const DATATYPE *data)
	{
		return PackString(data->name);
	}

	unsigned long CSourceDebug::PackString(const DIABASICTYPE *Type)
	{
		if (Type->Elem.Name && *Type->Elem.Name)
			return PackString(Type->Elem.Name);
		return 0;
	}

	void CSourceDebug::Release()
	{

	{
		for (map<unsigned long, DIABASICTYPE*>::IT it = m_Globals.begin();
			it != m_Globals.end(); ++it)
		{
			//TODO second can be NULL if was used operator[]
			DIABASICTYPE *data = it->second;
			if (data->Elem.Type == ELEM_ENUM)
			{
				DIAENUMTYPE *et = (DIAENUMTYPE*)it->second;
				for (unsigned long n = 0; n < et->v.Length; ++n)
				{	
					if (et->v.Values[n].Name) delete []et->v.Values[n].Name;
				}
			} else
			if (data->Elem.Type == ELEM_STRUCT ||
			    data->Elem.Type == ELEM_CLASS ||
			    data->Elem.Type == ELEM_UNION)
			{
				DIAUDTYPE *udt = (DIAUDTYPE*)it->second;
				if (udt->v.BaseClass) delete []udt->v.BaseClass;
				if (udt->v.Data) delete []udt->v.Data;
				if (udt->v.Function) delete []udt->v.Function;
				if (udt->v.Friend) delete []udt->v.Friend;
				if (udt->v.PubSymbols) delete []udt->v.PubSymbols;
			}

			if (data->Elem.Name) delete []data->Elem.Name;
			delete data;
		}
		m_Globals.clear();
	}
	//
	{
		for (map<FUNCTIONKEY, unsigned long>::IT it = m_FunctionsIDMap.begin();
			it != m_FunctionsIDMap.end(); ++it)
		{
			FUNCTION *func = it->first.func;
			if (func->blocks) delete []func->blocks;
			if (func->stack) delete []func->stack;
			delete []func->name;
			delete func;
		}
		m_FunctionsIDMap.clear();
	}
		m_FunctionsRVA.Clear();
		m_FuncID = 1;
	//
	{
		for (set<PUBSYM>::IT it = m_PublicSymbols.begin();
			it != m_PublicSymbols.end(); ++it)
		{
			if (it->name)
				delete []it->name;
		//will delete by m_ImportModules
		//	if (it->moduleName)
		//		delete []it->moduleName;
		}
		m_PublicSymbols.clear();
	}

		m_CompilandFilesLN.clear();
	{
		for (map<char*, COMPUNIT*, MY_char_compare>::IT it = m_CompilandUnitMap.begin();
			it != m_CompilandUnitMap.end(); ++it)
		{
			delete []it->first;
		//	delete []it->second->UnitName; //???
			delete it->second;
		}
	}

	{
		for (map<char*, SrcFileNameID, MY_char_compare>::IT it = m_CompilandSrcMap.begin();
			it != m_CompilandSrcMap.end(); ++it)
		{
			if (it->first)
				delete []it->first;
		}
	}
		if (m_ModuleName) delete []m_ModuleName;
		if (m_PDBFullFileName) delete []m_PDBFullFileName;
	{
		for (TListIter<char*> It = m_ImportModules.Begin();
			It != m_ImportModules.End(); ++It)
		{
			delete []*It;
		}
		m_ImportModules.Clear();
	}

		m_CompilandSrcMap.clear();
		m_CompilandUnitMap.clear();

		//m_Globals.clear(); //???

		m_CompilandFileID = 0;
		m_CompilandUnitID = 0;

		m_CompilandFilesLN.clear(); //dup ???

		m_ElemID = 1;

		m_StaticDatas.clear();
		m_Locals.clear();
		m_Registered.Clear();
		m_DataID = 1;
		m_Locals.push_back(0);

		m_BaseDataTypeIDMap.clear();
		m_StringIDMap.clear();
		m_UDTStrIDMap.clear();

		m_ClassPublicSymbols.clear();
	}
#ifndef _RING0_
	bool CSourceDebug::LoadDIA()
	{
		if (!m_hLibrary)
		{
			m_hLibrary = LoadLibraryA("msdia80.dll");
			if (!m_hLibrary)
		#ifdef _X64_
				 m_hLibrary = LoadLibraryA("..\\..\\Addition\\DiaSDK\\bin\\amd64\\msdia80.dll");
		#else
				 m_hLibrary = LoadLibraryA("..\\..\\Addition\\DiaSDK\\bin\\msdia80.dll");
		#endif
			if (!m_hLibrary)
				return false;
		}
		if (!m_DllGCO)
			m_DllGCO = (DLLGCO)GetProcAddress(m_hLibrary, "DllGetClassObject");
		return true;
	}

	bool CSourceDebug::UnloadDIA()
	{
		if (m_hLibrary)
			FreeLibrary(m_hLibrary);
		m_hLibrary = 0;
		m_DllGCO = 0;
		return true;
	}

	HRESULT CSourceDebug::OpenDIA(void *, REFIID /*const IID *const*/ DiaSource, REFIID/*const IID *const*/ DataSource, void **DiaDataSource)
	{
		HRESULT Result = -1;
		if (!m_hLibrary)
			LoadDIA();
		if (m_DllGCO)
		{
			IClassFactory *ClassFactory;
			Result = m_DllGCO(DiaSource, __uuidof(IClassFactory), &ClassFactory);
			if (FAILED(Result)) return Result;
			ClassFactory->CreateInstance(0, DataSource, DiaDataSource);
			ClassFactory->Release();
		}
		return Result;
	}

	bool CSourceDebug::OpenDIA(const char *FileName, IDiaDataSource **DataSource, IDiaSession **Session, IDiaSymbol **Symbol, bool *LoadFromPDBOK)
	{
		if (FAILED(OpenDIA(0, __uuidof(DiaSource), __uuidof(IDiaDataSource), (void **)DataSource)))
		{
			if (FAILED(OpenDIA(0, __uuidof(DiaSource), __uuidof(IDiaDataSource), (void **)DataSource)))
				return false;
		}

		WCHAR FileNameW[1042];
		AnsiToUnicode(FileName, FileNameW, lenof(FileNameW)); //1024*2); //???

		if (LoadFromPDBOK) *LoadFromPDBOK = true;
		if (FAILED((*DataSource)->loadDataFromPdb(FileNameW)))
		{
			if (LoadFromPDBOK) *LoadFromPDBOK = false;
			if (FAILED((*DataSource)->loadDataForExe(FileNameW, 0, 0)))
				return false;
		}
		if (FAILED((*DataSource)->openSession(Session)))
			return false;
		if (FAILED((*Session)->get_globalScope(Symbol)))
			return false;
		return true;
	}

	void CSourceDebug::CloseDIA()
	{
		SafeRelease(m_Segments);
		SafeRelease(m_EnumFragmentData);
		SafeRelease(m_GlobalSymbol);
		SafeRelease(m_Session);
		SafeRelease(m_DataSource);
		UnloadDIA();
	}

	bool CSourceDebug::GetInfo(IDiaSymbol *Symbol)
	{
	#if 1
		CDiaBSTR ModuleName;
		Symbol->get_name(&ModuleName);
		m_ModuleName = new char[TStrLen(ModuleName)+1];
		TStrCpy(m_ModuleName, ModuleName); ModuleName.release();
	#else
		WCHAR *ModuleName = nullptr;
		Symbol->get_name(&ModuleName);
		m_ModuleName = new char[TStrLen(ModuleName)+1];
		TStrCpy(m_ModuleName, ModuleName);
		::LocalFree(ModuleName);
	#endif
		DWORD TimeStamp = 0;
		Symbol->get_timeStamp(&TimeStamp);

		//CDiaBSTR SymbolsFileName;
		WCHAR *SymbolsFileName = nullptr;
		Symbol->get_symbolsFileName(&SymbolsFileName);
		m_PDBFullFileName = new char[TStrLen(SymbolsFileName)+1];
		TStrCpy(m_PDBFullFileName, SymbolsFileName);
		::LocalFree(SymbolsFileName);

		return false;
	}

#define PROGRESS_SCALE 10
#define TOTAL_PER_STAGE

	bool CSourceDebug::FindHelper()
	{
		IDiaTable *Table = nullptr;
		IDiaEnumTables *EnumTables = nullptr;
		IDiaEnumFrameData *EnumFragmentData = nullptr;
		IDiaEnumSegments *Segments = nullptr;

		m_Segments = nullptr;
		m_EnumFragmentData = nullptr;
		ULONG Count = 0;
		LONG Total = 0;

		if (FAILED(m_Session->getEnumTables(&EnumTables)) || !EnumTables)
			return false;

		Total = 0;
		EnumTables->get_Count(&Total);

	#ifdef TOTAL_PER_STAGE
		if (m_CreateProgress)
		{
			m_CreateProgress(Total);
			m_nTotal = Total / PROGRESS_SCALE;
		}

		m_nProgress = 0;
	#endif
		if (m_UpdateCaption)
			m_UpdateCaption(WSTR("Loading PDB Segment"));

		while (SUCCEEDED(EnumTables->Next(1, &Table, &Count)) && Count == 1)
		{
			if (SUCCEEDED(Table->QueryInterface(__uuidof(IDiaSegment), (void**)&Segments)) && Segments)
			{
				m_Segments = Segments;
				Table->Release();
				Table = nullptr;
				m_nProgress += Total - Count;
				if (m_UpdateProgress && m_nTotal && !(m_nProgress % m_nTotal))
					m_UpdateProgress(m_nProgress);
				break;
			}
			Table->Release();
			Table = nullptr;
			++m_nProgress;
			if (m_UpdateProgress && m_nTotal && !(m_nProgress % m_nTotal))
				m_UpdateProgress(m_nProgress);
		}
		EnumTables->Release();

	#ifdef TOTAL_PER_STAGE
		if (m_DestroyProgress)
			m_DestroyProgress();
	#endif

		if (FAILED(m_Session->getEnumTables(&EnumTables)) || !EnumTables)
			return false;

		Total = 0;
		EnumTables->get_Count(&Total);

	#ifdef TOTAL_PER_STAGE
		if (m_CreateProgress)
		{
			m_CreateProgress(Total);
			m_nTotal = Total / PROGRESS_SCALE;
		}

		m_nProgress = 0;
	#endif
		if (m_UpdateCaption)
			m_UpdateCaption(WSTR("Loading PDB FrameData"));

		while (SUCCEEDED(EnumTables->Next(1, &Table, &Count)) && Count == 1)
		{
			if (SUCCEEDED(Table->QueryInterface(__uuidof(IDiaEnumFrameData), (void**)&EnumFragmentData)) && EnumFragmentData)
			{
				m_EnumFragmentData = EnumFragmentData;
				Table->Release();
				Table = nullptr;
				m_nProgress += Total - Count;
				if (m_UpdateProgress && m_nTotal && !(m_nProgress % m_nTotal))
					m_UpdateProgress(m_nProgress);
				break;
			}
			Table->Release();
			Table = nullptr;
			++m_nProgress;
			if (m_UpdateProgress && m_nTotal && !(m_nProgress % m_nTotal))
				m_UpdateProgress(m_nProgress);
		}
		EnumTables->Release();

	#ifdef TOTAL_PER_STAGE
		if (m_DestroyProgress)
			m_DestroyProgress();
	#endif
 		return true;
	}
#if 0
 //TODO REMOVE
	void CSourceDebug::MapNameID()
	{
		//m_GlobalsID.push_back(0); //??? is first skiped?
		for (map<unsigned long, DIABASICTYPE*>::IT it = m_Globals.begin();
			it != m_Globals.end(); ++it)
		{
			//if (!TStrCmp(it->second->Elem.Name, Name))
			//	return it->second;
			m_GlobalsName.insert(_Tmap_pair<const char*,unsigned long>(it->second->Elem.Name, it->second->Elem.ID));
			m_GlobalsID.push_back(it->second);
		}
	}
#endif
	unsigned long CSourceDebug::GetTotal()
	{
		long Total = 0;
	#ifndef TOTAL_PER_STAGE
		IDiaEnumSymbols *EnumSymbols = nullptr;
		IDiaEnumTables *EnumTables = nullptr;

		//SEGMENT
		if (SUCCEEDED(m_Session->getEnumTables(&EnumTables)) && EnumTables)
		{
			long Count = 0;
			EnumTables->get_Count(&Count);
			Total += Count;
		}

		//FRAGMENTDATA
		if (SUCCEEDED(m_Session->getEnumTables(&EnumTables)) && EnumTables)
		{
			long Count = 0;
			EnumTables->get_Count(&Count);
			Total += Count;
		}

		//PUBLIC
		if (SUCCEEDED(m_GlobalSymbol->findChildren(SymTagPublicSymbol, 0, nsNone, &EnumSymbols))
			&& EnumSymbols)
		{
			long Count = 0;
			EnumSymbols->get_Count(&Count);
			Total += Count;
		}

		//COMPILAND
		if (SUCCEEDED(m_GlobalSymbol->findChildren(SymTagCompiland, 0, nsNone, &EnumSymbols))
			&& EnumSymbols)
		{
			long Count = 0;
			EnumSymbols->get_Count(&Count);
			Total += Count;
		}

		//BASE
		if (SUCCEEDED(m_GlobalSymbol->findChildren(SymTagBaseType, 0, nsNone, &EnumSymbols))
			&& EnumSymbols)
		{
			long Count = 0;
			EnumSymbols->get_Count(&Count);
			Total += Count;
		}

		//NULL
		if (SUCCEEDED(m_GlobalSymbol->findChildren(SymTagNull, 0, nsNone, &EnumSymbols))
			&& EnumSymbols)
		{
			long Count = 0;
			EnumSymbols->get_Count(&Count);
			Total += Count;
		}
	#endif
		return Total;
	}

	bool CSourceDebug::Parse(bool LoadFromPDBOK)
	{
		if (!m_GlobalSymbol)
			return false;

		IDiaEnumSymbols *EnumSymbols = nullptr;
		IDiaSymbol *Symbol = nullptr;
		ULONG Count = 0;
		ULONG level = 0;

		m_nProgress = 0;
		LONG Total = GetTotal();
	#ifndef TOTAL_PER_STAGE
		if (m_CreateProgress)
		{
			m_CreateProgress(Total);
			m_nTotal = Total / PROGRESS_SCALE;
		}

		m_nProgress = 0;
		if (m_UpdateCaption)
			m_UpdateCaption(WSTR("Loading PDB"));
	#endif

		GetInfo(m_GlobalSymbol);

		FindHelper();

		//PUBLIC
		if (FAILED(m_GlobalSymbol->findChildren(SymTagPublicSymbol, 0, nsNone, &EnumSymbols))
			|| !EnumSymbols)
		{
	#ifndef TOTAL_PER_STAGE
			if (m_DestroyProgress)
				m_DestroyProgress();
	#endif
			return false;
		}
	#ifdef TOTAL_PER_STAGE
		if (m_CreateProgress)
		{
			Total = 0;
			EnumSymbols->get_Count(&Total);
			m_CreateProgress(Total);
			m_nTotal = Total / PROGRESS_SCALE;
		}

		m_nProgress = 0;
	#endif
		if (m_UpdateCaption)
			m_UpdateCaption(WSTR("Loading PDB PublicSymbol"));

		while (SUCCEEDED(EnumSymbols->Next(1, &Symbol, &Count)) && Count == 1 && Symbol)
		{
			bool release = true;
			GetPublicSymbol(Symbol, &release, nullptr);
			if (release)
			{
				Symbol->Release();
				Symbol = nullptr;
			}
			++m_nProgress;
			if (m_UpdateProgress && m_nTotal && !(m_nProgress % m_nTotal))
				m_UpdateProgress(m_nProgress);
		}
		EnumSymbols->Release();
		EnumSymbols = nullptr;
	#ifdef TOTAL_PER_STAGE
		if (m_DestroyProgress)
			m_DestroyProgress();
	#endif
		//COMPILAND
		if (FAILED(m_GlobalSymbol->findChildren(SymTagCompiland, 0, nsNone, &EnumSymbols))
			|| !EnumSymbols)
		{
	#ifndef TOTAL_PER_STAGE
			if (m_DestroyProgress)
				m_DestroyProgress();
	#endif
			return false;
		}
	#ifdef TOTAL_PER_STAGE
		if (m_CreateProgress)
		{
			Total = 0;
			EnumSymbols->get_Count(&Total);
			m_CreateProgress(Total);
			m_nTotal = Total / PROGRESS_SCALE;
		}

		m_nProgress = 0;
	#endif
		if (m_UpdateCaption)
			m_UpdateCaption(WSTR("Loading PDB TagCompiland"));

		while (SUCCEEDED(EnumSymbols->Next(1, &Symbol, &Count)) && Count == 1 && Symbol)
		{
			GetCompiland(Symbol);
			Symbol->Release();
			Symbol = nullptr;
			++m_nProgress;
			if (m_UpdateProgress && m_nTotal && !(m_nProgress % m_nTotal))
				m_UpdateProgress(m_nProgress);
		}
		EnumSymbols->Release();
		EnumSymbols = nullptr;
	#ifdef TOTAL_PER_STAGE
		if (m_DestroyProgress)
			m_DestroyProgress();
	#endif
		//INIT BASIC
		InitBasicType();

		//BASE
		if (FAILED(m_GlobalSymbol->findChildren(SymTagBaseType, 0, nsNone, &EnumSymbols)) || !EnumSymbols)
		{
	#ifndef TOTAL_PER_STAGE
			if (m_DestroyProgress)
				m_DestroyProgress();
	#endif
			return true; //???
		}

		//LONG TotalBaseType = 0;
		//EnumSymbols->get_Count(&TotalBaseType);
	#ifdef TOTAL_PER_STAGE
		if (m_CreateProgress)
		{
			Total = 0;
			EnumSymbols->get_Count(&Total);
			m_CreateProgress(Total);
			m_nTotal = Total / PROGRESS_SCALE;
		}

		m_nProgress = 0;
	#endif
		if (m_UpdateCaption)
			m_UpdateCaption(WSTR("Loading PDB TagBase"));
		level = 0;
		while (SUCCEEDED(EnumSymbols->Next(1, &Symbol, &Count)) && Count == 1 && Symbol)
		{
			bool release = true;
			DIABASICTYPE *Type;
			ParseDIASymbol(Symbol, &release, (NULLTYPE**)&Type, level);
			if (release)
			{
				Symbol->Release();
				Symbol = nullptr;
			}
			++level;
			++m_nProgress;
			if (m_UpdateProgress && m_nTotal && !(m_nProgress % m_nTotal))
				m_UpdateProgress(m_nProgress);
		}
		EnumSymbols->Release();
	#ifdef TOTAL_PER_STAGE
		if (m_DestroyProgress)
			m_DestroyProgress();
	#endif
		//NULL
		if (FAILED(m_GlobalSymbol->findChildren(SymTagNull, 0, nsNone, &EnumSymbols)) || !EnumSymbols)
		{
	#ifndef TOTAL_PER_STAGE
			if (m_DestroyProgress)
				m_DestroyProgress();
	#endif
			return true; //???
		}
	#ifdef TOTAL_PER_STAGE
		if (m_CreateProgress)
		{
			Total = 0;
			EnumSymbols->get_Count(&Total);
			m_CreateProgress(Total);
			m_nTotal = Total / PROGRESS_SCALE;
		}

		m_nProgress = 0;
	#endif
		if (m_UpdateCaption)
			m_UpdateCaption(WSTR("Loading PDB"));
		level = 0;
		while (SUCCEEDED(EnumSymbols->Next(1, &Symbol, &Count)) && Count == 1 && Symbol)
		{
			bool release = true;
			DIABASICTYPE *Type;
			ParseDIASymbol(Symbol, &release, (NULLTYPE**)&Type, level);
			if (release)
			{
				Symbol->Release();
				Symbol = nullptr;
			}
			++level;
			++m_nProgress;
			if (m_UpdateProgress && m_nTotal && !(m_nProgress % m_nTotal))
				m_UpdateProgress(m_nProgress);
		}
		EnumSymbols->Release();

		if (m_DestroyProgress)
			m_DestroyProgress();

		ParserRelease();
		//MapNameID(); //++
		return true;
	}

	void CSourceDebug::ParserRelease()
	{
		//m_GlobalTypes_IDType_ID
		for (map<unsigned long, DIABASICTYPE*>::IT it = m_Globals.begin();
			it != m_Globals.end(); ++it)
		{
			DIABASICTYPE *data = it->second;
			if (data->Symbol)
			{
				data->Symbol->Release();
				data->Symbol = nullptr;
			}
		}
	}

	bool CSourceDebug::StripClassName(char *String)
	{
		bool ret = false;

		char *strStruct = TStrStr(String, "struct ");
		char *strClass = TStrStr(String, "class ");
		if (!strStruct && !strClass)
			return true;

		char *pNewString = new char[TStrLen(String)+1];
		*pNewString = 0;

		char *read = String;
		char *write = pNewString;
		
		while (strClass)
		{
			TStrNCpy(write, read, strClass - read);
			write += strClass - read;
			read = strClass + (sizeof("class ")-1);
			strClass = TStrStr(read, "class ");
			ret = true;
		}

		if (ret)
		{
			TStrCpy(write, read);
			TStrCpy(String, pNewString);
			read = String;
			write = pNewString;
			ret = false;
		}

		while ((strStruct = TStrStr(read, "struct ")))
		{
			TStrNCpy(write, read, strStruct - read);
			write += strStruct - read;
			read = strStruct + (sizeof("struct ")-1);
			ret = true;
		}
		
		if (ret)
		{
			TStrCpy(write, read);
			TStrCpy(String, pNewString);
			ret = false;
		}
		delete []pNewString;
		return ret;
	}

	bool CSourceDebug::GetPublicSymbol(IDiaSymbol *Symbol, bool *bRelease, void *Type)
	{
		PUBSYM symbol;
		memset(&symbol, 0, sizeof(symbol));

		//CDiaBSTR Name;
		WCHAR *Name = nullptr;
		if (FAILED(Symbol->get_undecoratedName(&Name)) || !Name)
			return false;

		symbol.name = new char[TStrLen(Name)+1];
		TStrCpy(symbol.name, Name);
		::LocalFree(Name);

		if (TStrStr(symbol.name, "::`vftable'"))
		{
			symbol.options |= 0x100'0000; //<<24
			StripClassName(symbol.name);
		} else
		if (!TStrCmp(symbol.name, "`string'"))
		{
			symbol.options |= 0x1'0000; //<<16
		}

		BOOL Value = 0;

		Value = 0;
		if (SUCCEEDED(Symbol->get_function(&Value)))
			symbol.options = ((Value != 0) << 22) | (symbol.options & ~0x40'0000);

		Value = 0;
		if (SUCCEEDED(Symbol->get_managed(&Value)))
			symbol.options = ((Value != 0) << 20) | (symbol.options & ~0x10'0000);

		Value = 0;
		if (SUCCEEDED(Symbol->get_code(&Value)))
			symbol.options = ((Value != 0) << 23) | (symbol.options & ~0x80'0000);

		Value = 0;
		if (SUCCEEDED(Symbol->get_msil(&Value)))
			symbol.options = ((Value != 0) << 21) | (symbol.options & ~0x20'0000);

		unsigned long rva;
		if (SUCCEEDED(Symbol->get_relativeVirtualAddress(&rva)))
			symbol.rva = rva;

		ULONGLONG Length;
		if (SUCCEEDED(Symbol->get_length(&Length)))
			symbol.length = Length;

		m_PublicSymbols.insert(symbol);
		if (symbol.options & 0x100'0000) //<<24
		{	//+++???
		//	char *name = new char[TStrLen(symbol.name)+1];
		//	TStrCpy(name, symbol.name);
		//	symbol.name = name;
			m_ClassPublicSymbols.insert(symbol);
		}
		return true;
	}

	bool CSourceDebug::GetCompiland(IDiaSymbol *Symbol)
	{
		if (!Symbol)
			return false;

		//CDiaBSTR UnitName;
		WCHAR *UnitName = nullptr;
		if (FAILED(Symbol->get_name(&UnitName)) || !UnitName)
			return false;

		IDiaEnumSourceFiles *EnumSource = nullptr;
		if (FAILED(m_Session->findFile(Symbol, 0, 0, &EnumSource)) && !EnumSource) //??? ||
		{
			::LocalFree(UnitName);
			return false;
		}

		LONG nFiles = 0;
		EnumSource->get_Count(&nFiles);

		unsigned long Size = sizeof(COMPUNIT) + (nFiles ? sizeof(COMPUNIT::FILES)*(nFiles-1) : 0);
		COMPUNIT *CompUnit = (COMPUNIT *)new char[Size];
		memset(CompUnit, 0, Size);
		CompUnit->nFiles = nFiles;
		CompUnit->UnitName = new char[TStrLen(UnitName)+1];
		TStrCpy(CompUnit->UnitName, UnitName);
		::LocalFree(UnitName);
		COMPUNIT::FILES *Files = &CompUnit->Files;

		//CUNKEY Key(CompUnit->UnitName, m_CompilandUnitID);
		map<char*,COMPUNIT*,MY_char_compare>::IT it = m_CompilandUnitMap.find(CompUnit->UnitName);
		if (it != m_CompilandUnitMap.end())
		{
			EnumSource->Release();
			delete []CompUnit->UnitName;
			delete CompUnit;
			return false;
		}

		CompUnit->UnitID = m_CompilandUnitID;
		m_CompilandUnitMap.insert(_Tmap_pair<char*,COMPUNIT*>(CompUnit->UnitName, CompUnit));
		++m_CompilandUnitID;

		if (nFiles == 0)
		{
			EnumSource->Release();
			EnumSource = nullptr;
			return false;
		}

		int Index = 0;

		unsigned long max_rva = -1;
		unsigned long min_rva = 0;

		IDiaSourceFile *SourceFile = nullptr;
		ULONG SourceFileCount = 0;
		while (SUCCEEDED(EnumSource->Next(1, &SourceFile, &SourceFileCount)) && SourceFileCount == 1)
		{
			unsigned long FileID = -1;

			//CDiaBSTR SrcFileName;
			WCHAR *SrcFileName = nullptr;
			if (FAILED(SourceFile->get_fileName(&SrcFileName)) || !SrcFileName) continue;
			
			char *szSrcFileName = new char[TStrLen(SrcFileName)+1];
			TStrCpy(szSrcFileName, SrcFileName);
			::LocalFree(SrcFileName);

			int NewFile;

			//Key(szSrcFileName, m_CompilandFileID);
			map<char*,SrcFileNameID,MY_char_compare>::IT it = m_CompilandSrcMap.find(szSrcFileName);//Key);
			if (it == m_CompilandSrcMap.end())
			{
				FileID = m_CompilandFileID;
				NewFile = 1;
			} else
			{
				FileID = it->second.FileID;
				delete []szSrcFileName;
				NewFile = 0;
			}

			IDiaEnumLineNumbers *EnumLineNumbers = nullptr;
			if (SUCCEEDED(m_Session->findLines(Symbol, SourceFile, &EnumLineNumbers)))
			{
				LONG nLines = 0;
				if (SUCCEEDED(EnumLineNumbers->get_Count(&nLines)) && nLines)
				{
					IDiaLineNumber *LineNumber = nullptr;
					ULONG LineNumberCount = 0;
					while (SUCCEEDED(EnumLineNumbers->Next(1, &LineNumber, &LineNumberCount)) && LineNumberCount == 1)
					{
						DWORD address = 0;
						if (FAILED(LineNumber->get_relativeVirtualAddress(&address))) continue;
						
						int statement = 0;
						if (FAILED(LineNumber->get_statement(&statement))) continue;
						
						MAX_LIMIT(max_rva, address);
						MIN_LIMIT(min_rva, address);

						DWORD lineNumber = 0;
						if (FAILED(LineNumber->get_lineNumber(&lineNumber))) continue;

						DWORD length = 0;
						if (FAILED(LineNumber->get_length(&length))) continue;
						
						FilesLN FLN;
						FLN.UnitID = CompUnit->UnitID;
						FLN.length = length;
						FLN.address = address;
						FLN.statement = statement != 0;
						FLN.lineNumber = lineNumber;	
						FLN.FileID = FileID;
						//m_CompilandFilesLN.Append(&FLN);
						//m_CompilandFilesLN.AppendSort(FLN);
						m_CompilandFilesLN.push_back(FLN);
						LineNumber->Release();
						LineNumber = nullptr;
					}
					
				}
				EnumLineNumbers->Release();
				EnumLineNumbers = nullptr;
				Files[Index].nLines = nLines;
			}

			Files[Index].FileID = FileID;
			SourceFile->Release();
			SourceFile = nullptr;

			if (Files[Index].nLines)
			{
				if (NewFile)
				{
					SrcFileNameID second;
					second.FileID = m_CompilandFileID;
					second.FileName = szSrcFileName;
					second.Text = 0;
					second.FileSize = 0;

					//+++
				#if 0
					if (gpFileIO->IsFileExist(szSrcFileName))
					{
						second.FileSize = gpFileIO->GetFileSize(szSrcFileName);
			//printf("src %s, size %d, %d\n", szSrcFileName, second.FileSize, GetLastError());
					//TODO
					//	second.Text = new char[second.FileSize];
					//	gpFileIO->ReadFromFile(szSrcFileName, second.Text, second.FileSize);
						++m_nSrcFilesCount; //TODO REMOVE
					}
				#endif
					m_CompilandSrcMap.insert(_Tmap_pair<char*,SrcFileNameID>(szSrcFileName, &second));
					++m_CompilandFileID;
				}
				++Index;
			} else
			if (NewFile == 1)
			{
				delete []szSrcFileName;
			}
		}

		if (CompUnit->nFiles != Index)
			CompUnit->nFiles = Index;
		CompUnit->MinRVA = min_rva;
		CompUnit->MaxRVA = max_rva;
		EnumSource->Release();
		EnumSource = nullptr;
		return true;
	}


	static BASEDATATYPENAMED gBasicDataTypeMap[] =
		{
			{{0x80,1},"char"},
			{{0x100,2},"short"},
			{{0x200,4},"int"},
			{{0x400,8},"__int64"},

			{{0x800,1},"unsigned char"},
			{{0x1000,2},"unsigned short"},
			{{0x2000,4},"unsigned int"},
			{{0x4000,8},"unsigned __int64"},

			{{0xD,4},"long"},
			{{0xE,4},"unsigned long"},
		};

	void CSourceDebug::InitBasicType()
	{
		for (unsigned long n = 0; n < lenof(gBasicDataTypeMap); ++n)
		{
			BASEDATATYPE basedata = gBasicDataTypeMap[n].type;

			DIABASICTYPE *Type = new DIABASICTYPE;
			memset(Type, 0, sizeof(*Type));
			Type->Elem.Name = new char[TStrLen(gBasicDataTypeMap[n].name)+1];
			TStrCpy(Type->Elem.Name, gBasicDataTypeMap[n].name);
			Type->Elem.Size = sizeof(*Type);
			Type->Value = 0;
			Type->Elem.Type = ELEM_BASE_TYPE;
			Type->Elem.Length = basedata.length;
			Type->Elem.ID = m_ElemID++;

			m_BaseDataTypeIDMap.insert(std::pair<BASEDATATYPE,unsigned long>(basedata, Type->Elem.ID));

			m_Globals.Insert(Type->Elem.ID, (DIABASICTYPE*)Type);
		}
	}

	bool CSourceDebug::SetDataLocation(DATATYPE *data, IDiaSymbol *Symbol)
	{
		switch (data->locationType)
		{
		case LocIsStatic:{
			Symbol->get_relativeVirtualAddress(&data->Static.rva);
			} break;
		case LocIsTLS:{
			Symbol->get_addressSection(&data->TLS.section);
			Symbol->get_addressOffset(&data->TLS.offset);
			} break;
		case LocIsRegRel:{
			Symbol->get_registerId(&data->RegRel.registerId);
			Symbol->get_offset(&data->RegRel.offset);
			} break;
		case LocIsThisRel:
		case LocIsIlRel:{
			Symbol->get_offset(&data->ThisRel.offset);
			} break;
		case LocIsEnregistered:{
			Symbol->get_registerId(&data->Enregistered.registerId);
			--data->Enregistered.registerId;
			} break;
		case LocIsBitField:{
			Symbol->get_bitPosition(&data->BitField.bitPosition);
			unsigned long long length = 0;
			Symbol->get_length(&length);
			data->BitField.length = length;
			Symbol->get_offset(&data->BitField.offset);
			} break;
		case LocIsSlot:{
			Symbol->get_slot(&data->Slot.slot);
			} break;
		case LocInMetaData:{
			Symbol->get_token(&data->MetaData.token);
			} break;
		case LocIsConstant:{
			unsigned long long Value = 0;
			VARIANT Variant;
			memset(&Variant, 0, sizeof(Variant));
			Symbol->get_value(&Variant);
			switch (Variant.vt)
			{
			case VT_ERROR:
				Value = 0;
				break;
			case VT_I1:
				Value = Variant.cVal;
				break;
			case VT_UI1:
				Value = Variant.bVal;
				break;
			case VT_I2:
				Value = Variant.iVal;
				break;
			case VT_UI2:
				Value = Variant.uiVal;
				break;
			case VT_I4:
				Value = Variant.lVal;
				break;
			case VT_UI4:
				Value = Variant.ulVal;
				break;
			case VT_I8:
				Value = Variant.llVal;
				break;
			case VT_UI8:
				Value = Variant.ullVal;
				break;
			case VT_INT:
				Value = Variant.intVal;
				break;
			case VT_UINT:
				Value = Variant.uintVal;
				break;
			default:
				break;
			}
			data->Constant.value = Value;
			} break;
		}
		return true;
	}

	unsigned long CSourceDebug::ParseData(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		unsigned long ID = 0;
		if (Type) *Type = 0;
		DWORD dataKind = 0;
		if (FAILED(Symbol->get_dataKind(&dataKind)))
			return 0;

		//CDiaBSTR Name;
		WCHAR *Name = nullptr;
		if (FAILED(Symbol->get_name(&Name)))
			return 0;
		if (dataKind == DataIsStaticLocal && !TStrCmp(Name, ""))
		{
			::LocalFree(Name);
			return 0;
		}
		DWORD locationType = 0;
		if (FAILED(Symbol->get_locationType(&locationType)))
		{
			::LocalFree(Name); //+++
			return 0;
		}

		REGISTERED_ Registered;
		bool RegisterType = false;
		if (locationType == LocIsEnregistered && !TStrCmp(Name, "this"))
		{
			DWORD registerId = 0;
			if (FAILED(Symbol->get_registerId(&registerId)))
			{
				::LocalFree(Name); //+++
				return 0;
			}
			--registerId;

			Registered.dataKind = dataKind;
			Registered.registerId = registerId;
			TListIter<REGISTERED_> It = m_Registered.Find(Registered);
			if (It != m_Registered.End())
			{
				::LocalFree(Name); //+++
				if (Type) *Type = It->data;
				return It->ID;
			}
			RegisterType = true;
		}
		BOOL constType = 0;
		Symbol->get_constType(&constType);
		BOOL volatileType = 0;
		Symbol->get_volatileType(&volatileType);

		unsigned long Size = sizeof(DATATYPE)+TStrLen(Name)+1;
		DATATYPE *data = (DATATYPE *)new char[Size];
		memset(data, 0, Size);
		data->ID = m_DataID++;
		data->name = (char *)&data[1]; //name store at end of struct
		data->dataKind = dataKind;
		TStrCpy(data->name, Name);
		::LocalFree(Name);

		if (locationType == LocIsStatic)
		{
			unsigned long rva = 0;
			Symbol->get_relativeVirtualAddress(&rva); //???

			PUBSYM symbol;
			symbol.rva = rva;
			{
			set<PUBSYM>::IT it = m_PublicSymbols.find(symbol);
			if (it != m_PublicSymbols.end())
			{
				//PUBSYM *p = &*it;
				//delete []p->name;
//printf("ERASEDdata %s\n", it->name);
				delete []it->name; //???
				m_PublicSymbols.erase(it);
				//set<PUBSYM>::IT it2 = m_ClassPublicSymbols.find(symbol);
				//m_ClassPublicSymbols.erase(it2);
			}
			}
			DATAKEY key;
			key.name = data->name;
			key.rva = symbol.rva;
			map<DATAKEY,unsigned long>::IT it = m_StaticDatas.find(key);
			if (it != m_StaticDatas.end())
			{
				--m_DataID;
				delete [](char*)data;
				if (Type) //TODO check range m_Locals
					*Type = m_Locals[it->second];
				return it->second;
			}
			m_StaticDatas.insert(_Tmap_pair<DATAKEY,unsigned long>(key, data->ID));
		}
		DWORD access = 0;
		Symbol->get_access(&access); //???
		data->access = access;
		m_Locals.push_back(data);
		data->constType = constType;
		data->volatileType = volatileType;
		if (RegisterType)
		{
			Registered.ID = data->ID;
			Registered.data = data;
			m_Registered.Append(&Registered);
		}

		IDiaSymbol *SymbolType = nullptr;
		if (SUCCEEDED(Symbol->get_type(&SymbolType)) && SymbolType)
		{
			NULLTYPE *type = nullptr;
			bool release = true;
			unsigned long ID = ParseDIASymbol(SymbolType, &release, &type, level);
			if (type)
				data->TypeLength = ((DIABASICTYPE*)type)->Elem.Length;
			data->TypeID = ID;
			if (release)
				SymbolType->Release();
		} else
		{
			if (dataKind == DataIsConstant)
				data->TypeLength = 4;
			else	data->TypeLength = 0;
			data->TypeID = 0;
		}

		data->locationType = locationType;

		SetDataLocation(data, Symbol);

		IDiaSymbol *ClassSymbol = nullptr;
		if (SUCCEEDED(Symbol->get_classParent(&ClassSymbol)) && ClassSymbol)
		{
			bool release = true;
			data->ClassID = ParseDIASymbol(ClassSymbol, &release, nullptr, level);
			if (release)
				ClassSymbol->Release();
		}
		if (Type) *Type = data;
		return data->ID;
	}

	bool CSourceDebug::SameTag(IDiaSymbol *Symbol, unsigned long Tag)
	{
		if (!Symbol)
			return false;
		DWORD symTag = 0;
		if (FAILED(Symbol->get_symTag(&symTag)))
			return false;
		return symTag == Tag;
	}

	unsigned long CSourceDebug::MakeSDBlock(IDiaSymbol *Symbol, TList<unsigned long> *ListsID, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (!Symbol)
			return 0;
		if (!SameTag(Symbol, SymTagBlock))
			return 0;
		IDiaEnumSymbols *EnumSymbol = 0;
		Symbol->findChildren(SymTagData, 0, 0, &EnumSymbol); //???
		long Count = 0;
		EnumSymbol->get_Count(&Count); //???
		unsigned long Size = sizeof(DIABLOCKTYPE);
		if (Count>=1) Size += (Count-1)*4; // Count-1 BUG!!!
		DIABLOCKTYPE *block = (DIABLOCKTYPE *)new char[Size];
		memset(block, 0, Size);
		block->Elem.ID = m_ElemID++;
		block->Elem.Size = Size;
		block->Value = &block->v;

		block->v.count = Count;
		unsigned long rva = -1; //???
		Symbol->get_relativeVirtualAddress(&rva); //???
		block->v.rva = rva;
		ULONGLONG length = 0;
		Symbol->get_length(&length); //???
		block->v.length = length;
		
		int n = 0;

		IDiaSymbol *DataSymbol = nullptr;
		ULONG Celt = 0;
		while (SUCCEEDED(EnumSymbol->Next(1, &DataSymbol, &Celt)) && Celt == 1)
		{
			DATATYPE *data;
			block->v.IDs[n] = ParseData(DataSymbol, nullptr, (NULLTYPE**)&data, level);
			data->ClassID = block->Elem.ID;
			DataSymbol->Release();
			++n;
		}
		EnumSymbol->Release();
		EnumSymbol = nullptr;
		

		ListsID->Append(&block->Elem.ID);
		block->Elem.Type = ELEM_BLOCK;

		//m_Globals.insert(_Tmap_pair<unsigned long, DIABASICTYPE*>(block->Elem.ID, block));
		m_Globals.Insert(block->Elem.ID, (DIABASICTYPE*)block);

		//m_GlobalTypes_IDType_Type insert block
		
		//parse sub blocks
		if (SUCCEEDED(Symbol->findChildren(SymTagBlock, 0, 0, &EnumSymbol)) && EnumSymbol)
		{
			IDiaSymbol *BlockSymbol = nullptr;
			ULONG Celt = 0;
			while (SUCCEEDED(EnumSymbol->Next(1, &BlockSymbol, &Celt)) && Celt == 1)
			{
				MakeSDBlock(BlockSymbol, ListsID, level);
				BlockSymbol->Release();
			}
			EnumSymbol->Release();
			EnumSymbol = nullptr;
		}
		return block->Elem.ID;
	}

	unsigned long CSourceDebug::ParseFunction(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (Type) *Type = 0;

		DWORD rva = 0;
		if (FAILED(Symbol->get_relativeVirtualAddress(&rva)) || !rva)
			return 0;

		//CDiaBSTR Name;
		WCHAR *Name = nullptr;
		if (FAILED(Symbol->get_name(&Name)) || !Name)
			return 0;

		ULONGLONG length = 0;
		if (FAILED(Symbol->get_length(&length)))
		{
			::LocalFree(Name);
			return 0;
		}

		char *pName = new char[TStrLen(Name)+1];
		TStrCpy(pName, Name);
		::LocalFree(Name);

		FUNCTIONKEY funckey;
		funckey.name = pName;
		funckey.rva = rva;
		map<FUNCTIONKEY, unsigned long>::IT it = m_FunctionsIDMap.find(funckey);
		if (it != m_FunctionsIDMap.end())
		{
			FUNCTION *func = it->first.func;
			if (Type) *Type = func;
			delete []pName;
			return func->ID;
		} else
		{
			PUBSYM symbol;
			symbol.rva = rva;
			set<PUBSYM>::IT it = m_PublicSymbols.find(symbol);
			if (it != m_PublicSymbols.end())
			{
				//PUBSYM *p = &*it;
				//delete []p->name;
//printf("ERASEDfunc %s\n", it->name);
				delete []it->name;
				m_PublicSymbols.erase(it);
				//set<PUBSYM>::IT it2 = m_ClassPublicSymbols.find(symbol);
				//m_ClassPublicSymbols.erase(it2);
			}
		}
		
		FUNCTION *func = new FUNCTION;
		memset(func, 0, sizeof(FUNCTION));
		func->rva = rva;
		if (rva) m_FunctionsRVA.Append(&rva);
		func->name = pName;
		func->length = length; //??? IS REALY NEED ULONGLONG ???
		func->ID = m_FuncID++;
		funckey.func = func;
		m_FunctionsIDMap.insert(_Tmap_pair<FUNCTIONKEY, unsigned long>(funckey, &func->ID));

		IDiaFrameData *FrameData = nullptr;
		if (m_EnumFragmentData && SUCCEEDED(m_EnumFragmentData->frameByRVA(rva, &FrameData)) && FrameData)
		{
			BOOL Flag = 0;
			if (SUCCEEDED(FrameData->get_systemExceptionHandling(&Flag)))
				func->SystemExceptionHandling = Flag;
			Flag = 0;
			if (SUCCEEDED(FrameData->get_cplusplusExceptionHandling(&Flag)))
				func->CplusplusExceptionHandling = Flag;
			FrameData->Release();
			FrameData = nullptr;
		}

		if (Type) *Type = func;

		DWORD access = 0;
		if (FAILED(Symbol->get_access(&access)))
			return 0;
		func->Access = access;

		DWORD Location = 0;
		if (FAILED(Symbol->get_locationType(&Location)))
			return 0;
		func->LocationType = Location;

		//func->length = Length;                     // ?????????

		func->XX = 0;

		BOOL Virtual = 0;
		if (FAILED(Symbol->get_virtual(&Virtual)))
			return 0;

		if (Virtual)
		{
			DWORD VirtualOffset = -1;
			if (FAILED(Symbol->get_virtualBaseOffset(&VirtualOffset)))
				return 0;
			func->Virtual = 1;
			func->virtualOffset = VirtualOffset;
		}

		BOOL pure = 0;
		Symbol->get_pure(&pure);
		func->Pure = pure;

		BOOL intro = 0;
		Symbol->get_intro(&intro);
		func->Intro = intro;

		IDiaEnumSymbols *EnumSym = nullptr;

		if (SUCCEEDED(Symbol->findChildren(SymTagFuncDebugEnd, 0, 0, &EnumSym)) && EnumSym)
		{
			IDiaSymbol *SymbolDbgEnd = nullptr;
			DWORD DebugEndCelt = 0;
			LONG count = 0;
			if (SUCCEEDED(EnumSym->get_Count(&count))
				&& count == 1
				&& SUCCEEDED(EnumSym->Next(1, &SymbolDbgEnd, &DebugEndCelt))
				&& DebugEndCelt == 1)
			{
				SymbolDbgEnd->get_relativeVirtualAddress(&func->debugEnd);
				SymbolDbgEnd->Release();
				SymbolDbgEnd = nullptr;
			}
			EnumSym->Release();
			EnumSym = nullptr;
		}

		if (SUCCEEDED(Symbol->findChildren(SymTagFuncDebugStart, 0, 0, &EnumSym)) && EnumSym)
		{
			IDiaSymbol *SymbolDbgStart = nullptr;
			DWORD DebugStartCelt = 0;
			LONG count = 0;
			if (SUCCEEDED(EnumSym->get_Count(&count))
				&& count == 1
				&& SUCCEEDED(EnumSym->Next(1, &SymbolDbgStart, &DebugStartCelt))
				&& DebugStartCelt == 1)
			{
				SymbolDbgStart->get_relativeVirtualAddress(&func->debugStart);
				SymbolDbgStart->Release();
				SymbolDbgStart = nullptr;
			}
			EnumSym->Release();
			EnumSym = nullptr;
		}

		if (SUCCEEDED(Symbol->findChildren(SymTagBlock, 0, 0, &EnumSym)) && EnumSym)
		{
			TList<unsigned long> ListsID;
			
			IDiaSymbol *BlockSymbol = nullptr;
			int n = 0;
			ULONG Celt = 0;
			while (SUCCEEDED(EnumSym->Next(1, &BlockSymbol, &Celt)) && Celt == 1)
			{
				MakeSDBlock(BlockSymbol, &ListsID, level);
				BlockSymbol->Release();
			}
			EnumSym->Release();
			EnumSym = nullptr;

			if (ListsID.Size()>=1)
			{
				func->blocks = new unsigned long[ListsID.Size()];
				memset(func->blocks, 0, sizeof(unsigned long)*ListsID.Size()); //sizeof ???
				func->nblocks = ListsID.Size();

				int n = 0;
				TListIter<unsigned long> It = ListsID.Begin();
				while (It != ListsID.End())
				{
					func->blocks[n++] = *It;
					++It;
				}
			}
			ListsID.Clear();
		}

		if (SUCCEEDED(Symbol->findChildren(SymTagData, 0, 0, &EnumSym)) && EnumSym)
		{
			LONG Count = 0;
			if (SUCCEEDED(EnumSym->get_Count(&Count)) && Count)
			{
				func->nstack = Count;
				func->stack = new unsigned long[Count];
				memset(func->stack, 0, sizeof(*(func->stack))*Count);
			}

			IDiaSymbol *DataSymbol = nullptr;
			int n = 0;
			ULONG Celt = 0;
			while (SUCCEEDED(EnumSym->Next(1, &DataSymbol, &Celt)) && Celt == 1)
			{
				DATATYPE *data;
				func->stack[n] = ParseData(DataSymbol, 0, (NULLTYPE**)&data, level);
				if (func->stack[n])
				{	
				//	if (data) data->ClassID = func->ID; //??? ISSUE
					++n;
				}
				DataSymbol->Release();
			}
			EnumSym->Release();
			EnumSym = nullptr;
			func->nstack = n;
		}

		if (SUCCEEDED(Symbol->findChildren(SymTagLabel, 0, 0, &EnumSym)) && EnumSym)
		{
			LONG Count = 0;
			if (SUCCEEDED(EnumSym->get_Count(&Count)) && Count)
			{
				EnumSym->get_Count(&Count);
				func->nlabels = Count;
				//FUNCTIONLABEL *label = new FUNCTIONLABEL[Count];
				func->labels = new FUNCTIONLABEL[Count];
				memset(func->labels, 0, sizeof(*func->labels)*Count);
			}
			IDiaSymbol *LabelSymbol = nullptr;
			unsigned long n = 0;
			DWORD LabelCelt = 0;
			while (SUCCEEDED(EnumSym->Next(1, &LabelSymbol, &LabelCelt)) && LabelCelt == 1 && LabelSymbol)
			{
				//CDiaBSTR LabelName
				WCHAR *LabelName = nullptr;
				LabelSymbol->get_name(&LabelName);
				func->labels[n].Name = new char[TStrLen(LabelName)+1];
				TStrCpy(func->labels[n].Name, LabelName);
				::LocalFree(LabelName);

				LabelSymbol->get_relativeVirtualAddress(&func->labels[n].Offset);
				LabelSymbol->Release();
				LabelSymbol = nullptr;
				++n;
				LabelCelt = 0;
			}
			//func->labels = label;
			EnumSym->Release();
			EnumSym = nullptr;
		}

		IDiaSymbol *ReturnSymbol = nullptr;
		if (SUCCEEDED(Symbol->get_type(&ReturnSymbol)) && ReturnSymbol)
		{
			bool release = true;
			func->ReturnCallID = ParseDIASymbol(ReturnSymbol, &release, nullptr, level);
			if (release)
			ReturnSymbol->Release();
			map<unsigned long, DIABASICTYPE*>::IT it = m_Globals.find(func->ReturnCallID);
			if (it != m_Globals.end())
			{
				if (it->second->Elem.Type == ELEM_FUNC_TYPE)
				{
					func->ReturnTypeID = ((DIAFUNCTYPE *)it->second)->v.FuncTypeID;
				} else
				{
					func->ReturnTypeID = it->second->Elem.Type;
				}
			}
		}

		IDiaSymbol *ClassSymbol = nullptr;
		if (SUCCEEDED(Symbol->get_classParent(&ClassSymbol)) && ClassSymbol)
		{
			bool release = true;
			func->ClassID = ParseDIASymbol(ClassSymbol, &release, nullptr, level);
			if (release)
				ClassSymbol->Release();
		}

		return func->ID; //??? TODO POSSIBLE ISSUE
	}

	bool IsUnnamedTag(const char *Str)
	{
		char UNMANAGEDTAG[16];
		TStrCpy(UNMANAGEDTAG, "<unnamed-tag>");
		if (!Str) return false;
		int StrLen = TStrLen(Str);
		int Len = TStrLen(UNMANAGEDTAG);
		if (StrLen == 0 || StrLen < Len)
			return false;
		--StrLen;
		--Len;
		while (Len >= 0)
		{
			if (Str[StrLen] != UNMANAGEDTAG[Len])
				return false;
			--StrLen;
			--Len;
		}
		return StrLen <= 0 || Str[StrLen] == ':';
	}

	DIABASICTYPE *CSourceDebug::GetGlobal(unsigned long ID)
	{
		//m_Globals_IDType2ID_SET.begin();
		map<unsigned long, DIABASICTYPE*>::IT it = m_Globals.find(ID);
		if (it != m_Globals.end())
			return it->second;
#ifdef TXTDEBUG
fprintf(f,"%s NULL, ID %d\n", __func__, ID);
fflush(f);
#endif
		return nullptr;
	}

	unsigned long CSourceDebug::ParseUDType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (bRelease) *bRelease = true;

		if (Type) *Type = 0;

		//CDiaBSTR Name;
		WCHAR *Name = nullptr;
		if (FAILED(Symbol->get_name(&Name)) || !Name)
			return 0;

		char *pName = new char[TStrLen(Name)+1];
		TStrCpy(pName, Name);

		bool bUnnamed = false;

		if (IsUnnamedTag(pName))
		{
			char *pUnName = new char[TStrLen(Name)+(sizeof("_00000000")-1)+1];
			TStrCpy(pUnName, pName);
			TSPrintf(&pUnName[TStrLen(pName)], "_%08x", m_ElemID);

			std::list<IDTYPE>::iterator it = m_UDTList.begin();
			while (it != m_UDTList.end())
			{
				if (SUCCEEDED(m_Session->symsAreEquiv(Symbol, it->Type->Symbol)))
				{
					if (Type)
						*Type = it->Type;
					delete []pUnName;
					delete []pName;
			
					return it->Type->Elem.ID;
				}
				++it;
			}
			delete []pName;
			pName = pUnName;
			bUnnamed = true;
		} else
		{
			//( (pName,diatype), diatype->Elem.ID) //pName KEY
			m_StrIDMAPIter = m_UDTStrIDMap.find(pName); //char*,Type*,ID std::set?
			if (m_StrIDMAPIter != m_UDTStrIDMap.end())
			{
				if (Type)
					*Type = GetGlobal(m_StrIDMAPIter->second);
				delete []pName;
				return m_StrIDMAPIter->second;
			}
		}
		
		DWORD udtKind = 0;
		if (FAILED(Symbol->get_udtKind(&udtKind))) return 0;

		ULONGLONG length = 0;
		if (FAILED(Symbol->get_length(&length))) return 0;

		DWORD tag = 0;
		if (FAILED(Symbol->get_symTag(&tag))) return 0;

		unsigned long Size = sizeof(DIAUDTYPE);
		DIAUDTYPE *diatype = (DIAUDTYPE *)new char[Size];
		memset(diatype, 0, Size); //sizeof(DIAUDTYPE));//DIABASICTYPE));
		diatype->Elem.Name = pName;

		::LocalFree(Name);

		if (udtKind == UdtStruct)
			diatype->Elem.Type = ELEM_STRUCT;
		else
		if (udtKind == UdtClass)
			diatype->Elem.Type = ELEM_CLASS;
		else
		if (udtKind == DataIsStaticLocal)
			diatype->Elem.Type = ELEM_UNION;

		diatype->Elem.Length = length;
		elemUDT *v = &diatype->v;
		//memset(&diatype->v, 0, sizeof(diatype->v));
		diatype->Elem.ID = m_ElemID++;
		diatype->Value = v;
		diatype->Elem.Size = Size;

		if (bUnnamed)
		{
			IDTYPE idtype;
			idtype.ID = diatype->Elem.ID;
			idtype.Type = diatype;
			m_UDTList.push_back(idtype);
			v->unnamed = 1;
			diatype->Symbol = Symbol;
			if (bRelease) *bRelease = false;
		}

		m_Globals.Insert(diatype->Elem.ID, (DIABASICTYPE*)diatype);

//		m_NameIDMap.insert(pName, diatype->Elem.ID);

		//m_Globals_IDType2ID_SET ( (diatype->Elem.ID,diatype), diatype->Elem.ID) //ID KEY
		m_UDTStrIDMap.Insert(pName, diatype->Elem.ID);
		//m_UDTMap_STRType2ID_X_MAP ( (pName,diatype), diatype->Elem.ID) //pName KEY
		//m_Globals_ID2Type_MAP (diatype->Elem.ID,diatype) //ID KEY

		BOOL value;

		value = FALSE;
		if (SUCCEEDED(Symbol->get_scoped(&value)))
			v->scoped = value!=0;

		value = FALSE;
		if (SUCCEEDED(Symbol->get_nested(&value)))
			v->nested = value!=0;

		value = FALSE;
		if (SUCCEEDED(Symbol->get_packed(&value)))
			v->packed = value!=0;

		value = FALSE;
		if (SUCCEEDED(Symbol->get_overloadedOperator(&value)))
			v->overloadedOperator = value!=0;

		value = FALSE;
		if (SUCCEEDED(Symbol->get_hasAssignmentOperator(&value)))
			v->hasAssignmentOperator = value!=0;

		value = FALSE;
		if (SUCCEEDED(Symbol->get_hasCastOperator(&value)))
			v->hasCastOperator = value!=0;

		value = FALSE;
		if (SUCCEEDED(Symbol->get_hasNestedTypes(&value)))
			v->hasNestedTypes = value!=0;

		value = FALSE;
		if (SUCCEEDED(Symbol->get_constructor(&value)))
			v->constructor = value!=0;


            // BASECLASS
		IDiaEnumSymbols *EnumSymbols = nullptr;
		if (FAILED(Symbol->findChildren(SymTagBaseClass, 0, 0, &EnumSymbols)) || !EnumSymbols)
			return 0;

		LONG Count = 0;
		if (SUCCEEDED(EnumSymbols->get_Count(&Count)) && Count)
		{
			unsigned long *BaseClassIDs = new unsigned long[Count];
			unsigned long n = 0;
			IDiaSymbol *pDiaSymbol = nullptr;
			ULONG nCel = 0;
			while (SUCCEEDED(EnumSymbols->Next(1, &pDiaSymbol, &nCel)) && nCel == 1 && pDiaSymbol)
			{
				bool release = true;
				unsigned long ID = ParseDIASymbol(pDiaSymbol, &release, nullptr, level);
				if (ID)
				{
					BaseClassIDs[n] = ID;
					DIABASICTYPE *bt = GetGlobal(ID);
					elemBASECLASS *bc = (elemBASECLASS *)bt->Value;
					bc->X = diatype->Elem.ID;
				} else
				{
					BaseClassIDs[n] = 0;
				}

				if (release)
				{
					pDiaSymbol->Release();
					pDiaSymbol = nullptr;
				}
				++n;
			}
			v->BaseClass = BaseClassIDs;
			v->BaseClassLen = Count;
		} else
		{
			v->BaseClassLen = 0;
			v->BaseClass = nullptr;
		}
		EnumSymbols->Release();


		// VTBL
		CLASSPUBSYM *pubsym = new CLASSPUBSYM[(v->BaseClassLen <= 1) ? 1 : v->BaseClassLen];
		memset(pubsym, 0, ((v->BaseClassLen <= 1) ? 1 : v->BaseClassLen)*sizeof(CLASSPUBSYM)); //+++

		unsigned long pubCount = 0;

		set<PUBSYM>::iterator pit = m_ClassPublicSymbols.begin();
#if 1
		while (pit != m_ClassPublicSymbols.end())
		{
			char *name = pit->name;
		//	if (!TStrCmp(diatype->Elem.Name, "pairNode")) { ++pit; printf("SKIP pairNode\n"); continue;}

			char *StrName = TStrStr(name, diatype->Elem.Name);
			if (StrName)
			{
				if (!TStrNCmp(&StrName[TStrLen(diatype->Elem.Name)], "::`vftable'", (sizeof("::`vftable'")-1)))
				{
					v->vtable = 1;

					pubsym[pubCount].length = pit->length;
					pubsym[pubCount].rva = pit->rva;

					if (v->BaseClassLen <= 1)
					{
						pubsym[pubCount].ID = diatype->Elem.ID;
					} else
					{
						char *solvtbl = TStrStr(StrName, "::`vftable'{for `");
						if (solvtbl)
						{
							solvtbl += (sizeof("::`vftable'{for `")-1);
							char *eolvtbl = TStrChr(solvtbl, '\'');
							for (int i = 0; i < v->BaseClassLen; ++i)
							{
								//DIABASECLASSTYPE *bc = (DIABASECLASSTYPE *)GetGlobal(v->BaseClass[i]);
								DIABASICTYPE *bc = (DIABASICTYPE*)GetGlobal(v->BaseClass[i]);
								elemBASECLASS *baseclass = (elemBASECLASS*)bc->Value;

								DIAUDTYPE *udt = (DIAUDTYPE *)GetGlobal(baseclass->ID);
								if (!TStrNCmp(udt->Elem.Name, solvtbl, eolvtbl - solvtbl))
									pubsym[pubCount].ID = baseclass->ID;
							}
						}
					}
					++pubCount;
					break; //???
				}
			}
			++pit;
		}
#endif
		v->PubSymbolsLen = pubCount; //???
		if (pubCount)
		{
			v->PubSymbolsLen = pubCount;
			v->PubSymbols = pubsym;
		} else
		{
			v->PubSymbolsLen = 0;
			v->PubSymbols = nullptr;
			delete []pubsym;
		}


		// FUNCTION
		EnumSymbols = nullptr;
		if (FAILED(Symbol->findChildren(SymTagFunction, 0, 0, &EnumSymbols)) || !EnumSymbols)
			return 0;

		Count = 0;
		if (SUCCEEDED(EnumSymbols->get_Count(&Count)) && Count)
		{
			unsigned long *FuncIDs = new unsigned long[Count];
			memset(FuncIDs, 0, Count*(sizeof(*FuncIDs)));
			unsigned long n = 0;
			IDiaSymbol *pDiaSymbol = nullptr;
			ULONG nCel = 0;
			while (SUCCEEDED(EnumSymbols->Next(1, &pDiaSymbol, &nCel)) && nCel == 1 && pDiaSymbol)
			{
				FUNCTION *func = nullptr;
				bool release = true;
				FuncIDs[n] = ParseFunction(pDiaSymbol, &release, (NULLTYPE**)&func, level);
				if (release)
				{
					pDiaSymbol->Release();
					pDiaSymbol = nullptr;
				}

				if (FuncIDs[n])
				{
					func->ClassID = diatype->Elem.ID;
					++n;
				}
			}

			if (n > 1)
			{
				std::sort(FuncIDs, &FuncIDs[n]);
				unsigned long N = FuncIDs - std::unique(FuncIDs, &FuncIDs[n]);
			#if 0
				//n = sorted(FuncIDs, n);
			#else
				Count = n;
				for (n = 0; n < Count - 1 && FuncIDs[n] < FuncIDs[n + 1]; ++n);
				++n;
			#endif
			}
			v->FunctionLen = n;
			v->Function = FuncIDs;
		} else
		{
			v->FunctionLen = 0;
			v->Function = nullptr;
		}
		EnumSymbols->Release();
		EnumSymbols = nullptr;


		if (FAILED(Symbol->findChildren(SymTagData, 0, 0, &EnumSymbols)) || !EnumSymbols)
			return 0;

		Count = 0;
		if (SUCCEEDED(EnumSymbols->get_Count(&Count)) && Count)
		{
			v->DataLen = Count;
			v->Data = new unsigned long[Count];
			memset(v->Data, 0, Count*(sizeof(*(v->Data))));
			unsigned long n = 0;
			IDiaSymbol *pDiaSymbol = nullptr;
			ULONG nCel = 0;
			while (SUCCEEDED(EnumSymbols->Next(1, &pDiaSymbol, &nCel)) && nCel == 1 && pDiaSymbol)
			{
				DATATYPE *data = nullptr;
				v->Data[n] = ParseData(pDiaSymbol, nullptr, (NULLTYPE**)&data, level);
				if (data)
				{
					data->ClassID = diatype->Elem.ID;
					DIAUDTYPE *diaudt = (DIAUDTYPE *)GetGlobal(data->TypeID);
					if (diaudt) //+++???
					if (diaudt->Elem.Type == ELEM_CLASS ||
					    diaudt->Elem.Type == ELEM_STRUCT ||
					    diaudt->Elem.Type == ELEM_UNION)
					{
						elemUDT *udt = &diaudt->v;
						if (//_v60 != (DIAUDTYPE *)-0x1C && //???
							udt->unnamed)
							udt->X1 = 1;
					}
				}
				pDiaSymbol->Release();
				pDiaSymbol = nullptr;
				++n;
			}
		} else
		{
			v->DataLen = 0;
			v->Data = nullptr;
		}
		EnumSymbols->Release();
		EnumSymbols = nullptr;

                  // SKIP
		if (FAILED(Symbol->findChildren(SymTagFriend, 0, 0, &EnumSymbols)) || !EnumSymbols)
			return 0;

		Count = 0;
		if (SUCCEEDED(EnumSymbols->get_Count(&Count)) && Count)
		{
			unsigned long *FriendIDs = new unsigned long[Count];
			memset(FriendIDs, 0, Count*(sizeof(*FriendIDs)));
			unsigned long n = 0;
			IDiaSymbol *pDiaSymbol = nullptr;
			ULONG nCel = 0;
			while (SUCCEEDED(EnumSymbols->Next(1, &pDiaSymbol, &nCel)) && nCel == 1 && pDiaSymbol)
			{
				FUNCTION *func = nullptr;
				bool release = true;
				v->Friend[n] = ParseFunction(pDiaSymbol, &release, (NULLTYPE**)&func, level);
				if (release)
				{
					pDiaSymbol->Release();
					pDiaSymbol = nullptr;
				}

				if (v->Friend[n])
					++n;
			}

			if (n > 1)
			{
				std::sort(FriendIDs, &FriendIDs[n]);
				unsigned long N = FriendIDs - std::unique(FriendIDs, &FriendIDs[n]);
			#if 0
				//n = sorted(FriendIDs, n);
			#else
				Count = n;
				for (n = 0; n < Count - 1 && FriendIDs[n] < FriendIDs[n + 1]; ++n);
				++n;
			#endif
			}
			v->FriendLen = Count; //???
			v->Friend = FriendIDs;
		} else
		{
			v->FriendLen = 0;
			v->Friend = nullptr;
		}
		EnumSymbols->Release();
		EnumSymbols = nullptr;

		if (Type)
			*Type = diatype;

		return diatype->Elem.ID;
	}

	unsigned long CSourceDebug::ParseEnumType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (Type) *Type = 0;

		if (bRelease) *bRelease = true;

		std::list<IDTYPE>::iterator it = m_EnumList.begin();
		while (it != m_EnumList.end())
		{
			if (SUCCEEDED(m_Session->symsAreEquiv(Symbol, it->Type->Symbol)))
			{
				if (Type)
					*Type = it->Type;
				return it->Type->Elem.ID; //+C
			}
			++it;
		}

		IDiaEnumSymbols *EnumSymbols = nullptr;
		if (FAILED(Symbol->findChildren(SymTagData, 0, 0, &EnumSymbols))) return 0;

		LONG nEnums = 0;
		if (FAILED(EnumSymbols->get_Count(&nEnums))) return 0;

		unsigned long Size = sizeof(DIAENUMTYPE);//0x34;
		if (nEnums)
			Size += (nEnums - 1)*sizeof(ENUMTYPEVALUE);

		DIAENUMTYPE *diatype = (DIAENUMTYPE *)new char[Size];
		memset(diatype, 0, Size);
		elemENUM *v = &diatype->v;
		diatype->v.Length = nEnums;
		diatype->Symbol = Symbol;
		diatype->Elem.ID = m_ElemID++;
		diatype->Elem.Type = ELEM_ENUM;
		diatype->Elem.Size = Size;

		IDTYPE idtype;
		idtype.ID = diatype->Elem.ID;
		idtype.Type = diatype;
		m_EnumList.push_back(idtype);

		//v10 = PAIR_sub_431550((int)v21, (int)&idtype, (int)&idtype);
		//std_map_insert_IDType2ID_sub_430F10(&this->m_Globals_IDType2ID_SET, v20, (int)v10);

		BOOL value = FALSE;
		Symbol->get_nested(&value);
		v->Nested = value != 0;

		value = FALSE;
		Symbol->get_scoped(&value);
		v->Scoped = value != 0;

		//CDiaBSTR Name;
		WCHAR *Name = nullptr;
		if (FAILED(Symbol->get_name(&Name))) return 0;

		ULONGLONG length = 0;
		if (FAILED(Symbol->get_length(&length)))
		{
			::LocalFree(Name); //+++
			return 0;
		}

		diatype->Elem.Length = length;
		diatype->Elem.Name = new char[TStrLen(Name)+1];
		TStrCpy(diatype->Elem.Name, Name);
		::LocalFree(Name); //+++
		diatype->Value = v;
	{
		IDiaSymbol *SymbolType = nullptr;
		if (FAILED(Symbol->get_type(&SymbolType)) && !SymbolType) return 0; //??? ||

		bool release = true;
		v->ID = ParseDIASymbol(SymbolType, &release, nullptr, level);
		if (release)
		{
			SymbolType->Release();
			SymbolType = nullptr;
		}
	}
		IDiaSymbol *SymbolElement = nullptr;
		unsigned long n = 0;
		ULONG Count = 0;
		unsigned long long Val = 0; //???
		while (SUCCEEDED(EnumSymbols->Next(1, &SymbolElement, &Count)) && Count == 1 && SymbolElement)
		{
			DWORD locationType = 0;
			if (FAILED(SymbolElement->get_locationType(&locationType))) return 0;

			if (locationType != LocIsConstant) return 0;

			VARIANT Value = { VT_EMPTY };
			//Value.lVal = 16; //VT_UI1
			if (FAILED(SymbolElement->get_value(&Value))) return 0;

			Val = 0;
			switch (Value.vt)
			{
			case VT_ERROR:
				//???
				break;
			case VT_I1:
				Val = Value.cVal;
				break;
			case VT_UI1:
				Val = Value.bVal;
				break;
			case VT_I2:
				Val = Value.iVal;
				break;
			case VT_UI2:
				Val = Value.uiVal;
				break;
			case VT_I4:
				Val = Value.lVal;
				break;
			case VT_UI4:
				Val = Value.ulVal;
				break;
			case VT_I8:
				Val = Value.llVal;
				break;
			case VT_UI8:
				Val = Value.ullVal;
				break;
			case VT_INT:
				Val = Value.intVal;
				break;
			case VT_UINT:
				Val = Value.uintVal;
				break;
			default:
				Val = 0;
				break;
			}
			v->Values[n].Value = Val;

			VariantClear((VARIANTARG *) &Value); //+++

			//CDiaBSTR ElemName;
			WCHAR *ElemName = nullptr;
			if (FAILED(SymbolElement->get_name(&ElemName)) || !ElemName) return 0;
			v->Values[n].Name = new char[TStrLen(ElemName)+1];
			TStrCpy(v->Values[n].Name, ElemName);
			::LocalFree(ElemName);
			ElemName = nullptr;

			SymbolElement->Release();
			SymbolElement = nullptr;
			Count = 0;
			++n;
		}
		EnumSymbols->Release();

		//v14 = PAIR_sub_4314C0((int)&v17, (int)&diatype->Elem.ID, (int)&diatype);
		//std_map_insert_ID2Type_sub_431180(&this->m_GlobalsIDTypeMap, (int)v16, (int)v14);
		m_Globals.Insert(diatype->Elem.ID, diatype);

		if (bRelease) *bRelease = false;
		if (Type) *Type = diatype;
		return diatype->Elem.ID;
	}

	unsigned long CSourceDebug::ParseFunctionType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (bRelease) *bRelease = false;

		IDiaEnumSymbols *EnumSymbols = nullptr;
		if (FAILED(Symbol->findChildren(SymTagFunctionArgType, 0, 0, &EnumSymbols))) return 0;

		LONG ArgsCount = 0;
		if (FAILED(EnumSymbols->get_Count(&ArgsCount))) return 0;

		unsigned long Size = sizeof(DIAFUNCTYPE);//0x30;
		if (ArgsCount)
			Size += (ArgsCount-1)*4; //sizeof ???

		DIAFUNCTYPE *diatype = (DIAFUNCTYPE *)new char[Size];
		memset(diatype, 0, Size);
		elemFUNC *v = &diatype->v;
		diatype->Value = &diatype->v;
		diatype->Elem.Size = Size;
		diatype->Elem.ID = m_ElemID++;
		diatype->Symbol = Symbol;

		IDTYPE idtype;
		idtype.ID = diatype->Elem.ID;
		idtype.Type = diatype;
		m_FuncTypeList.push_back(idtype);

		//v5 = PAIR_sub_431550((int)v14, (int)&idtype, (int)&idtype);
		//std_map_insert_IDType2ID_sub_430F10(&m_Globals_IDType2ID_SET, v13, (int)v5);


		m_Globals.Insert(diatype->Elem.ID, (DIABASICTYPE*)diatype);
		//v6 = PAIR_sub_4314C0((int)&v12, (int)&diatype->Elem.ID, (int)&diatype);
		//std_map_insert_ID2Type_sub_431180(&m_Globals_ID2Type_MAP, (int)v11, (int)v6);
	{
		IDiaSymbol *SymbolType = nullptr;
		if (FAILED(Symbol->get_type(&SymbolType)) || !SymbolType) return 0;

		bool release = true;
		v->FuncTypeID = ParseDIASymbol(SymbolType, &release, nullptr, level);
		if (release)
		{
			SymbolType->Release();
			SymbolType = nullptr;
		}
	}
	{
		IDiaSymbol *SymbolType = nullptr;
		if (FAILED(Symbol->get_objectPointerType(&SymbolType))) return 0;

		if (SymbolType)
		{
			bool release = true;
			v->ObjPtrID = ParseDIASymbol(SymbolType, &release, nullptr, level);
			if (release)
			{
				SymbolType->Release();
				SymbolType = nullptr;
			}
			LONG Adjust = 0;
			Symbol->get_thisAdjust(&Adjust);
			v->ThisAdjust = Adjust;
		}
	}
		DWORD callingConvention = 0;
		if (FAILED(Symbol->get_callingConvention(&callingConvention))) return 0;

		v->CallingConvention = callingConvention;
		v->nArgs = ArgsCount;

		ULONG Count = ArgsCount; //???
		unsigned long n = 0;
		IDiaSymbol *SymbolArg = nullptr;
		while (SUCCEEDED(EnumSymbols->Next(1, &SymbolArg, &Count)) && Count == 1)
		{
			IDiaSymbol *SymbolArgType = nullptr;
			if (FAILED(SymbolArg->get_type(&SymbolArgType))) return 0;
			bool release = true;
			v->ArgsIDs[n] = ParseDIASymbol(SymbolArgType, &release, nullptr, level);
			if (release)
			{
				SymbolArgType->Release();
				SymbolArgType = nullptr;
			}
			SymbolArg->Release();
			SymbolArg = nullptr;
			++n;
		}
		EnumSymbols->Release();
		EnumSymbols = nullptr;

		diatype->Elem.Type = ELEM_FUNC_TYPE;
		diatype->Elem.Name = nullptr;
		diatype->Symbol = Symbol;

		return diatype->Elem.ID;
	}

	unsigned long CSourceDebug::ParsePointerBase(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		BOOL reference = FALSE;
		if (FAILED(Symbol->get_reference(&reference))) return 0;
		if (reference)
			return ParsePointerRefType(Symbol, bRelease, Type, level);
		return ParsePointerType(Symbol, bRelease, Type, level);
	}

	IDiaSymbol *CSourceDebug::GetSymbolPointer(IDiaSymbol *Symbol, int, unsigned long *Count)
	{
		int Number = 0;
		if (!Symbol) return nullptr;
		if (!SameTag(Symbol, SymTagPointerType)) return nullptr;
		BOOL reference = FALSE;
		if (FAILED(Symbol->get_reference(&reference))) return nullptr;
		if (reference) return nullptr;
		IDiaSymbol *SymbolType = nullptr;
		unsigned long n = 0;
		for (n = 0; ; n = 1)
		{
			if (FAILED(Symbol->get_type(&SymbolType)) || !SymbolType)  return nullptr;
			++Number;
			DWORD tag = 0;
			if (FAILED(SymbolType->get_symTag(&tag)))
			{
				SymbolType->Release();
				return nullptr;
			}
			if (tag != SymTagPointerType) break;

			if (FAILED(SymbolType->get_reference(&reference)))
			{
				SymbolType->Release();
				return nullptr;
			}

			if (reference)
			{
				SymbolType->Release();
				return nullptr;
			}
			if (n)
				Symbol->Release();
			Symbol = SymbolType;
		}
		if (Count) *Count = Number;
		if (n)
			Symbol->Release();
		return SymbolType;
	}

	char * CSourceDebug::GetName(unsigned long ID)
	{
		char *NewStr = nullptr;
		int Len = 0x2000;
		WCHAR *Str = new WCHAR[Len];
		GetName(ID, Str, &Len);
		int StrLen = TStrLen(Str);
		if (StrLen != 0)
		{
			NewStr = new char[StrLen+1];
			TStrCpy(NewStr, Str);
		}
		delete []Str;
		return NewStr;
	}
	WCHAR * CSourceDebug::GetName(unsigned long ID, WCHAR *pStr, int *pLen)
	{
		*pStr = 0;
		DIABASICTYPE *diabase = (DIABASICTYPE *)GetGlobal(ID);
		if (!diabase) return nullptr;
		return GetName(diabase, pStr, pLen, 0);
	}
	WCHAR * CSourceDebug::GetName(DIABASICTYPE *Type, WCHAR *pStr, int *pLen, int)
	{
		if (pStr) *pStr = 0;
		if (!Type) return nullptr;
		switch (Type->Elem.Type)
		{
		case ELEM_POINTER:{
			elemPOINTER *pointer = (elemPOINTER *)Type->Value;
			map<unsigned long, DIABASICTYPE*>::IT it = m_Globals.find(pointer->ID);
			if (it == m_Globals.end())
				return nullptr;
			DIABASICTYPE *bc = it->second;
			GetName(pointer->ID, pStr, pLen);
			//StaticBuffer<10> pBuf(pointer->Num);
			WCHAR Buf[11];
			WCHAR *pBuf = Buf;
			if (pointer->Num > 9)
			{
				pBuf = new WCHAR[pointer->Num + 1];
			}
			int n = 0;
			for (n = 0; n < pointer->Num; ++n)
				pBuf[n] = L'*';
			pBuf[n] = 0;
			if (bc->Elem.Type == ELEM_FUNC_TYPE)
			{
				WCHAR *StrArgs = new WCHAR[*pLen];
				TStrCpy(StrArgs, pStr);
				WCHAR *StrFunc = TStrChr(pStr, L'(');
				if (!StrFunc)
				{
					if (pBuf != Buf) delete pBuf;
					delete []StrArgs;
					return pStr;
				}
				int Pos = StrFunc - pStr;
				pStr[Pos] = '(';
				TStrCpy(&pStr[Pos + 1], pBuf);
				TStrCat(pStr, L")");
				TStrCat(pStr, &StrArgs[Pos]);
			} else
			{
				TStrCat(pStr, pBuf);
			}
			if (pBuf != Buf) delete []pBuf;
			return pStr;
			}break;
		case ELEM_POINTERREF:{
			elemPOINTERREF *pointerref = (elemPOINTERREF *)Type->Value;
			map<unsigned long, DIABASICTYPE*>::IT it = m_Globals.find(pointerref->ID);
			if (it == m_Globals.end())
				return nullptr;
			GetName(it->second, pStr, pLen, 0);
			TStrCat(pStr, WSTR("&"));
			return pStr;
			}break;
		case ELEM_ARRAY:{
			elemARRAY *array = (elemARRAY *)Type->Value;
			//str_find_ID2Type_sub_431350(&this->m_GlobalsIDTypeMap, v19, (int)&array->ID);
			//v8 = std_map_end_sub_401890(&this->m_GlobalsIDTypeMap, (int)v10);
			//if ( IT_eq_sub_4316C0((int)v19, v8) )
			map<unsigned long, DIABASICTYPE*>::IT it = m_Globals.find(array->ID);
			if (it == m_Globals.end())
				return nullptr;
			//v36 = *(DIABASETYPE **)(deref_sub_431A30((int)v19) + 4);
			GetName(it->second, pStr, pLen, 0);
			for (int n = 0; n < array->Size; ++n)
			{
				WCHAR Buffer[256];
				TSPrintf(Buffer, WSTR("%d"), array->Values[n].Size);
				TStrCat(pStr, WSTR("["));
				TStrCat(pStr, Buffer);
				TStrCat(pStr, WSTR("]"));
			}
			return pStr;
			}break;
		case ELEM_FUNC_TYPE:{
			elemFUNC *func = (elemFUNC *)Type->Value;
			GetName(func->FuncTypeID, pStr, pLen);
			switch (func->CallingConvention)
			{
			case CV_CALL_NEAR_C://0:
				TStrCat(pStr, WSTR(" __cdecl "));
				break;
			case CV_CALL_NEAR_FAST://4:
				TStrCat(pStr, WSTR(" __fastcall "));
				break;
			case CV_CALL_NEAR_STD://7:
				TStrCat(pStr, WSTR(" __stdcall "));
				break;
			case CV_CALL_NEAR_SYS://9:
				TStrCat(pStr, WSTR(" __syscall "));
				break;
			case CV_CALL_THISCALL://11:
				TStrCat(pStr, WSTR(" __thiscall "));
				break;
			default:
				TStrCat(pStr, WSTR(" Unknown calling convention in function "));
				break;
			}
			int nArgPos = TStrLen(pStr);
			TStrCat(&pStr[nArgPos++], WSTR("("));
			for (int n = 0; n < func->nArgs; ++n)
			{
				GetName(func->ArgsIDs[n], &pStr[nArgPos], pLen);
				nArgPos = TStrLen(pStr);
				TStrCat(&pStr[nArgPos++], WSTR(","));
			}
			if (func->nArgs)
				pStr[nArgPos - 1] = L')';
			else	TStrCat(&pStr[nArgPos++], WSTR(")"));
			return pStr;
			}break;
		case ELEM_BASE_CLASS:{
			DIABASECLASSTYPE *diabc = (DIABASECLASSTYPE *)Type;
			return GetName(diabc->v.ID, pStr, pLen);
			}break;
		default:
			if (Type->Elem.Name)
				TStrCpy(pStr, Type->Elem.Name);
			else	TStrCpy(pStr, WSTR("no name"));
		}
		return pStr;
	}

	unsigned long CSourceDebug::ParsePointerType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (Type) *Type = 0;
		if (bRelease) *bRelease = true; //??? false
		unsigned long Count = 1;
		IDiaSymbol *SymbolPointer = GetSymbolPointer(Symbol, 0, &Count);
		bool release = true;
		unsigned long ID = ParseDIASymbol(SymbolPointer, &release, nullptr, level);
		if (release)
		{
			SymbolPointer->Release();
			SymbolPointer = nullptr;
		}

		char *Name = GetName(ID);
		unsigned long long length = 0;
		if (FAILED(Symbol->get_length(&length)))
		{
			delete []Name;
			return 0;
		}

		DIAPOINTERTYPE *diatype = nullptr;
		unsigned long PrevID = 0;
		for (unsigned long n = 1; n <= Count; ++n)
		{
			char *pName = nullptr;
			if (Name)
			{
				pName = new char[TStrLen(Name)+(sizeof("_00000000")-1)+1]; //??? sizeof("_00000000")
				//*pName = 0;
				TSPrintf(pName, "%s_%08x", Name, n);
			} else
			{
				pName = new char[(sizeof("00000000_00000000")-1)+1]; //??? sizeof("00000000_00000000")
				//*pName = 0;
				TSPrintf(pName, "%08x_%08x", ID, n);
			}

			m_StrIDMAPIter = m_PointerStrIDMap.find(pName);
			if (m_StrIDMAPIter != m_PointerStrIDMap.end())
			{
				PrevID = m_StrIDMAPIter->second;
				if (n == Count)
				{
					if (Type) *Type = GetGlobal(m_StrIDMAPIter->second);
					delete []pName;
					delete []Name;
					return m_StrIDMAPIter->second;
				}
				delete []pName;
				pName = nullptr;
			} else
			{
				m_PointerStrIDMap.Insert(pName, m_ElemID);

				unsigned long Size = sizeof(DIAPOINTERTYPE);
				diatype = (DIAPOINTERTYPE *)new char[Size];
				memset(diatype, 0, Size);
				elemPOINTER *v = &diatype->v;
				diatype->v.ID = ID;
				v->Num = n;
				v->PrevID = PrevID;
				diatype->Elem.Type = ELEM_POINTER;
				diatype->Value = v;
				diatype->Elem.Size = Size;
				diatype->Elem.Length = length;
				diatype->Elem.Name = pName;
				diatype->Elem.ID = m_ElemID++;

				PrevID = diatype->Elem.ID;

				//v11 = PAIR_sub_4314C0((int)&v17, (int)&diatype->Elem.ID, (int)&diatype);
				//std_map_insert_ID2Type_sub_431180(&this->m_GlobalsIDTypeMap, (int)v16, (int)v11);
				m_Globals.Insert(diatype->Elem.ID, diatype);

				IDTYPE idtype;
				idtype.ID = diatype->Elem.ID;
				idtype.Type = diatype;
				//v12 = PAIR_sub_431550((int)v15, (int)&idtype, (int)&idtype);
				//std_map_insert_IDType2ID_sub_430F10(&this->m_Globals_IDType2ID_SET, v14, (int)v12);

				if (Type) *Type = diatype;
				if (bRelease) *bRelease = true;
			}
		}

		if (Name) delete []Name;
		return diatype ? diatype->Elem.ID : 0;
	}
	unsigned long CSourceDebug::ParsePointerRefType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (Type) *Type = 0;
		if (bRelease) *bRelease = true; //??? false
		IDiaSymbol *SymbolType = nullptr;
		if (FAILED(Symbol->get_type(&SymbolType)) || !SymbolType) return 0;
		bool release = true;
		unsigned long ID = ParseDIASymbol(SymbolType, &release, nullptr, level);
		if (release)
		{
			SymbolType->Release();
			SymbolType = nullptr;
		}
		char *pName = nullptr;
		char *Name = GetName(ID);
		if (Name)
		{
			pName = new char[TStrLen(Name)+1+1];
			TStrCpy(pName, Name);
			TStrCat(pName, "&");
			delete []Name;
		} else
		{
			pName = new char[2];
			pName[0] = '&';
			pName[1] = 0;
		}

		m_StrIDMAPIter = m_PointerRefStrIDMap.find(pName);
		if (m_StrIDMAPIter != m_PointerRefStrIDMap.end())
		{
			if (Type) *Type = GetGlobal(m_StrIDMAPIter->second);
			delete []pName;
			return m_StrIDMAPIter->second;
		}

		m_PointerRefStrIDMap.Insert(pName, m_ElemID);

		unsigned long Size = sizeof(DIAPOINTERREFTYPE);
		DIAPOINTERREFTYPE *diatype = (DIAPOINTERREFTYPE *)new char[Size];
		memset(diatype, 0, Size);
		diatype->Elem.Size = Size;
		elemPOINTERREF *v = &diatype->v;
		diatype->v.ID = ID;
		diatype->Elem.ID = m_ElemID++;
		diatype->Elem.Type = ELEM_POINTERREF;
		diatype->Elem.Name = pName;
		diatype->Value = v;

		//v11 = PAIR_sub_4314C0((int)&v17, (int)&diatype->Elem.ID, (int)&diatype);
		//std_map_insert_ID2Type_sub_431180(&this->m_GlobalsIDTypeMap, (int)v16, (int)v11);
		m_Globals.Insert(diatype->Elem.ID, diatype);

		IDTYPE idtype;
		idtype.ID = diatype->Elem.ID;
		idtype.Type = diatype;
		//v12 = PAIR_sub_431550((int)v15, (int)&idtype, (int)&idtype);
		//std_map_insert_IDType2ID_sub_430F10(&this->m_Globals_IDType2ID_SET, v14, (int)v12);

		DIABASICTYPE*diabase = (DIABASICTYPE*)GetGlobal(v->ID);
		if (diabase)
			diatype->Elem.Length = diabase->Elem.Length;
		if (bRelease) *bRelease = true;
		if (Type) *Type = diatype;
		return diatype->Elem.ID;
	}
	bool CSourceDebug::GetArray(IDiaSymbol *Symbol, std::list<IDiaSymbol *> &Symbols)
	{
		IDiaSymbol *NextSymbol = 0;
		Symbols.clear();
		DWORD tag = 0;
		if (FAILED(Symbol->get_symTag(&tag))) return false;
		while (tag == SymTagArrayType)
		{
			Symbols.push_front(Symbol);
			if (FAILED(Symbol->get_type(&NextSymbol))) return false;
			if (FAILED(NextSymbol->get_symTag(&tag))) return false;
			Symbol = NextSymbol;
		}
		if (NextSymbol)
			NextSymbol->Release();
		return true;
	}

	struct IDSIZE
	{
		unsigned long ID;
		unsigned long Size;
	};

	unsigned long CSourceDebug::ParseArray(IDiaSymbol *Symbol, unsigned long ID, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (Type) *Type = 0;
		if (bRelease) *bRelease = true;
		
		std::list<IDTYPE>::iterator it = m_ArrayList.begin();
		while (it != m_ArrayList.end())
		{
			if (SUCCEEDED(m_Session->symsAreEquiv(Symbol, it->Type->Symbol)))
			{
				if (Type)
					*Type = it->Type;
				return it->Type->Elem.ID; //+C
			}
			++it;
		}
		
		ULONGLONG length = 0;
		if (FAILED(Symbol->get_length(&length))) return 0;

		IDiaSymbol *SymbolIndexType = nullptr;
		if (FAILED(Symbol->get_arrayIndexType(&SymbolIndexType))) return 0;
		IDiaSymbol *SymbolType = nullptr;
		if (FAILED(Symbol->get_type(&SymbolType))) return 0;
		ULONGLONG SymbolTypeLength = 0;
		if (FAILED(SymbolType->get_length(&SymbolTypeLength))) return 0;

		IDiaSymbol *f_Symbol = Symbol;
		ULONGLONG f_length = length;

		std::list<IDSIZE> IDSizeList;
		bool first = true;
		DWORD tag = SymTagArrayType;
		while (tag == SymTagArrayType)
		{
			IDSIZE idsize;
			if (SymbolTypeLength)
			{
				idsize.Size = f_length / SymbolTypeLength;
			} else
			{
				idsize.Size = 0;
			}
			bool release = true;
			idsize.ID = ParseDIASymbol(SymbolIndexType, &release, nullptr, level);
			if (release)
			{
				SymbolIndexType->Release();
				SymbolIndexType = nullptr;
			}
			IDSizeList.push_back(idsize);
			if (!first)
			{
				f_Symbol->Release();
				f_Symbol = nullptr;
			}
			first = false;
			f_Symbol = SymbolType;
			f_length = SymbolTypeLength;

			if (FAILED(SymbolType->get_symTag(&tag))) return 0;

			if (tag != SymTagArrayType) break;
			if (FAILED(f_Symbol->get_arrayIndexType(&SymbolIndexType))) return 0;
			if (FAILED(f_Symbol->get_type(&SymbolType))) return 0;
			if (FAILED(SymbolType->get_length(&SymbolTypeLength))) return 0;
		}

		unsigned long Size = sizeof(DIAARRAYTYPE);
		if (IDSizeList.size()>1)
			Size += (IDSizeList.size()-1)*sizeof(ARRAYVALUE);

		DIAARRAYTYPE *diatype = (DIAARRAYTYPE *)new char[Size];
		diatype->Elem.Size = Size;
		diatype->Symbol = Symbol;
		diatype->Elem.ID = m_ElemID++;

		IDTYPE idtype;
		idtype.ID = diatype->Elem.ID;
		idtype.Type = diatype;
		m_ArrayList.push_back(idtype);

		//v12 = PAIR_sub_431550((int)v33, (int)&idtype, (int)&idtype);
		//std_map_insert_IDType2ID_sub_430F10(&this->m_Globals_IDType2ID_SET, v32, (int)v12);


		//v13 = PAIR_sub_4314C0((int)&v31, (int)&diatype->Elem.ID, (int)&diatype);
		//std_map_insert_ID2Type_sub_431180(&this->m_GlobalsIDTypeMap, (int)v30, (int)v13);
		m_Globals.Insert(diatype->Elem.ID, diatype);

		elemARRAY *v = &diatype->v;
		diatype->Value = &diatype->v;
		bool release = true;
		v->ID = ParseDIASymbol(SymbolType, &release, nullptr, level);
		if (release)
			SymbolType->Release();

		{
		unsigned long n = 0;
		std::list<IDSIZE>::iterator it = IDSizeList.begin();
		while (it != IDSizeList.end())
		{
			v->Values[n].ID = it->ID;
			v->Values[n].Size = it->Size;
			++it;
			++n;
		}
		}

		v->Size = IDSizeList.size();
		v->ParentID = ID;
		IDSizeList.clear();

		diatype->Elem.Type = ELEM_ARRAY;
		diatype->Elem.Length = length;
		diatype->Value = v;
		diatype->Elem.Name = GetName(diatype->Elem.ID);
		if (Type) *Type = diatype;
		if (bRelease) *bRelease = false;
		return diatype->Elem.ID;
	}
	unsigned long CSourceDebug::ParseArrayType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		unsigned long n = 0;
		unsigned long ID = 0;
		std::list<IDiaSymbol *> Symbols;
		if (Type) *Type = 0;
		if (bRelease) *bRelease = true;
		if (!GetArray(Symbol, Symbols)) return 0;
		std::list<IDiaSymbol *>::iterator it = Symbols.begin();
		while (it != Symbols.end())
		{
			if (n) ++n;
			IDiaSymbol *symbol = *it;
			ID = ParseArray(symbol, ID, bRelease, Type, level);
			if (*bRelease) //??? bRelease
			{
				symbol->Release();
				symbol = nullptr;
				*bRelease = false;
			}
			++n;
			++it;
		}
		Symbols.clear();
		return ID;
	}

struct BASETYPEMAP
{
	unsigned long Type;
	const char *Name;
};
	static const BASETYPEMAP gBaseTypeMap[] =
		{
			{ btNoType, "NoType" },
			{ btVoid, "void" },
			{ btChar, "char" },
			{ btWChar, "wchar" },
			{ btInt, "short" },
			{ 0x80, "char" },
			{ 0x100, "short" },
			{ 0x200, "int" },
			{ 0x400, "__int64" },
			{ btUInt, "unsigned short int" },
			{ 0x800, "unsigned char" },
			{ 0x1000, "unsigned short" },
			{ 0x2000, "unsigned int" },
			{ 0x4000, "unsigned __int64" },
			{ btFloat, "float" },
			{ 0x8000, "double" },
			{ btBCD, "BCD" },
			{ btBool, "bool" },
			{ btLong, "long" },
			{ btULong, "unsigned long" },
			{ btCurrency, "Currency" },
			{ btDate, "date" },
			{ btVariant, "variant" },
			{ btComplex, "complex" },
			{ btBit, "bit" },
			{ btBSTR, "BSTR" },
			{ btHresult, "HRESULT" },
		};

	const char *CSourceDebug::GetBaseTypeName(unsigned long type, unsigned long length)
	{
		if (type == btInt)
			type = (length << 7);
		if (type == btUInt)
			type = (length << 11);
		if (type == btFloat && length == 8)
			type = 0x8000;
		for (int i = 0; i < lenof(gBaseTypeMap); ++i)
		{
			if (type == gBaseTypeMap[i].Type)
				return gBaseTypeMap[i].Name;
		}
		return nullptr;
	}

	unsigned long CSourceDebug::ParseBaseType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (bRelease) *bRelease = true;
		if (Type) *Type = 0;

		BASEDATATYPE baseType;

		if (FAILED(Symbol->get_baseType(&baseType.basetype))) return 0;
		if (FAILED(Symbol->get_length(&baseType.length))) return 0;

		const char *Name = GetBaseTypeName(baseType.basetype, baseType.length);

		std::map<BASEDATATYPE, unsigned long>::iterator it = m_BaseDataTypeIDMap.find(baseType);
		if (it != m_BaseDataTypeIDMap.end())
		{
			if (Type)
				*Type = GetGlobal(it->second);
			return it->second;
		}

		unsigned long Size = sizeof(DIABASICTYPE);
		DIABASICTYPE *diatype = (DIABASICTYPE*)new char[Size];
		memset(diatype, 0, sizeof(DIABASICTYPE));
		diatype->Elem.Name = new char[TStrLen(Name)+1];
		TStrCpy(diatype->Elem.Name, Name);
		diatype->Elem.Size = Size;
		diatype->Value = 0;
		diatype->Elem.Type = ELEM_BASE_TYPE;
		diatype->Elem.Length = baseType.length;
		diatype->Elem.ID = m_ElemID++;
		diatype->Symbol = 0;

		m_BaseDataTypeIDMap.insert(std::pair<BASEDATATYPE,unsigned long>(baseType, diatype->Elem.ID));

		//m_Globals.insert(std::pair<unsigned long, DIABASICTYPE*>(diatype->Elem.ID, (DIABASICTYPE*)diatype));
		m_Globals.Insert(diatype->Elem.ID, (DIABASICTYPE*)diatype);
		//v11 = PAIR_sub_4314C0((int)&v17, (int)&diatype->Elem.ID, (int)&diatype);
		//std_map_insert_ID2Type_sub_431180(&this->m_Globals_ID2Type_MAP, (int)v16, (int)v11);

		//a3a[0] = diatype->Elem.ID;
		//a3a[1] = (int)diatype;
		//v12 = PAIR_sub_431550((int)v15, (int)a3a, (int)a3a);
		//std_map_insert_IDType2ID_sub_430F10(&this->m_Globals_IDType2ID_SET, v14, (int)v12);

		if (Type) *Type = diatype;
		if (bRelease) *bRelease = false; //+++
 		return diatype->Elem.ID;
	}
	unsigned long CSourceDebug::ParseTypedefType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (Type) *Type = 0;
		if (bRelease) *bRelease = true;

		//CDiaBSTR Name;
		WCHAR *Name = nullptr;
		if (FAILED(Symbol->get_name(&Name))) return 0;

		ULONGLONG length = 0;
		if (FAILED(Symbol->get_length(&length)))
		{
			::LocalFree(Name); //+++
			return 0;
		}

		unsigned long Size = sizeof(DIATYPEDEFTYPE);
		DIATYPEDEFTYPE *diatype = (DIATYPEDEFTYPE*)new char[Size];
		elemTYPEDEF *v = &diatype->v;
		char *pName = new char[TStrLen(Name)+1];
		TStrCpy(pName, Name);
		::LocalFree(Name);

		IDiaSymbol *SymbolType = nullptr;
		if (FAILED(Symbol->get_type(&SymbolType)) || !SymbolType)
		{
			delete []pName; //+++???
			return 0;
		}

		diatype->Elem.ID = m_ElemID++;
		diatype->Elem.Size = Size;
		diatype->Value = v;
		diatype->Symbol = Symbol;
		diatype->Elem.Type = ELEM_TYPEDEF;
		diatype->Elem.Name = pName;
		diatype->Elem.Length = length;

		//v6 = PAIR_sub_4314C0((int)&v13, (int)&diatype->Elem.ID, (int)&diatype);
		//std_map_insert_ID2Type_sub_431180(&this->m_GlobalsIDTypeMap, (int)v12, (int)v6);
		m_Globals.Insert(diatype->Elem.ID, diatype);

		IDTYPE idtype;
		idtype.ID = diatype->Elem.ID;
		idtype.Type = diatype;
		m_TypedefList.push_back(idtype);

		//v7 = PAIR_sub_431550((int)v11, (int)&idtype, (int)&idtype);
		//std_map_insert_IDType2ID_sub_430F10(&this->m_Globals_IDType2ID_SET, v10, (int)v7);

		if (bRelease) *bRelease = false;

		bool release = true;
		v->ID = ParseDIASymbol(SymbolType, &release, nullptr, level);
		DIABASICTYPE *diabasetype = (DIABASICTYPE *)GetGlobal(v->ID);
		if (diabasetype)
			diatype->Elem.Length = diabasetype->Elem.Length;
		if (release)
		{
			SymbolType->Release();
			SymbolType = nullptr;
		}
		if (Type) *Type = diatype;
		return diatype->Elem.ID;
	}
	unsigned long CSourceDebug::ParseBaseClassType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);

		if (bRelease) *bRelease = true;

		std::list<IDTYPE>::iterator it = m_BaseClassList.begin();
		while (it != m_BaseClassList.end())
		{
			if (SUCCEEDED(m_Session->symsAreEquiv(Symbol, it->Type->Symbol)))
			{
				if (Type)
					*Type = it->Type;
				return it->Type->Elem.ID; //+C
			}
			++it;
		}

		//CDiaBSTR Name;
		WCHAR *Name = nullptr;
		if (FAILED(Symbol->get_name(&Name)) || !Name)
			return 0;

		unsigned long Size = sizeof(DIABASECLASSTYPE);
		DIABASECLASSTYPE *diatype = (DIABASECLASSTYPE *)new char[Size];
		elemBASECLASS *v = &diatype->v;
		memset(diatype, 0, Size);
		diatype->Elem.Size = Size;
		diatype->Elem.Type = ELEM_BASE_CLASS;
		diatype->Symbol = Symbol;
		diatype->Elem.Name = new char[TStrLen(Name)+1];
		TStrCpy(diatype->Elem.Name, Name);
		::LocalFree(Name); //+++
		diatype->Elem.ID = m_ElemID++;
		diatype->Value = v;

		IDTYPE idtype;
		idtype.ID = diatype->Elem.ID;
		idtype.Type = diatype;

		m_BaseClassList.push_back(idtype);

		//v9 = PAIR_sub_431550((int)v16, (int)&idtype, (int)&idtype);

		//std_map_insert_IDType2ID_sub_430F10(&this->m_Globals_IDType2ID_SET, v15, (int)v9);

		//v10 = PAIR_sub_4314C0((int)&v14, (int)&diatype->Elem.ID, (int)&diatype);
		//std_map_insert_ID2Type_sub_431180(&this->m_GlobalsIDTypeMap, (int)v13, (int)v10);
		m_Globals.Insert(diatype->Elem.ID, diatype);

		IDiaSymbol *SymbolType = nullptr;
		if (FAILED(Symbol->get_type(&SymbolType)) || !SymbolType) return 0;

		DIABASICTYPE *R = nullptr;
		bool release = true;
		v->ID = ParseDIASymbol(SymbolType, &release, (NULLTYPE**)&R, level);
		if (R)
			diatype->Elem.Length = R->Elem.Length;
		if (release)
		{
			SymbolType->Release();
			SymbolType = nullptr;
		}

		BOOL virtualBaseClass = 0;
		if (FAILED(Symbol->get_virtualBaseClass(&virtualBaseClass))) return 0;
		v->VirtualBaseClass = virtualBaseClass != 0;

		BOOL indirectVirtualBaseClass = 0;
		if (FAILED(Symbol->get_indirectVirtualBaseClass(&indirectVirtualBaseClass))) return 0;
		v->IndirectVirtualBaseClass = indirectVirtualBaseClass != 0;

		LONG Offset = -1;
		if (FAILED(Symbol->get_offset(&Offset))) return 0;
		v->Offset = Offset;

		DWORD virtualBaseDispIndex = -1;
		if (FAILED(Symbol->get_virtualBaseDispIndex(&virtualBaseDispIndex))) return 0;
		v->VirtualBaseDispIndex = virtualBaseDispIndex;


		LONG virtualBasePointerOffset = 0; //???
		if (FAILED(Symbol->get_virtualBasePointerOffset(&virtualBasePointerOffset))) return 0;

		DWORD access = -1;
		if (FAILED(Symbol->get_access(&access))) return 0;
		v->Access = access;

		v->VirtualBasePointerOffset = virtualBasePointerOffset;

		if (bRelease) *bRelease = false;
		return diatype->Elem.ID;
	}

	unsigned long CSourceDebug::ParseFriend(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		Trace trace(level, __func__);
//printf("%s -------------------------------!!!!!!!!!!!!!!!!!!!",__func__);
		//TODO
		return 0;
	}
	unsigned long CSourceDebug::ParseThunk(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		Trace trace(level, __func__);

		if (Type) *Type = 0;
		if (bRelease) *bRelease = true;
		DWORD rva = 0;
		if (FAILED(Symbol->get_relativeVirtualAddress(&rva))) return 0;
		map<unsigned long, DIABASICTYPE*>::IT it = m_ThunkRVATypeMap.find(rva);
		if (it != m_ThunkRVATypeMap.end())
		{
			if (Type) *Type = it->second;
			return it->second->Elem.ID;
		}

		//CDiaBSTR Name;
		WCHAR *Name = nullptr;
		if (FAILED(Symbol->get_name(&Name)) || !Name) return 0;

		unsigned long Size = sizeof(DIATHUNK);
		DIATHUNK *diatype = (DIATHUNK *)new char[Size];
		memset(diatype, 0, Size);
		elemTHUNK *v = &diatype->v;
		diatype->Elem.Name = new char[TStrLen(Name)+1];
		TStrCpy(diatype->Elem.Name, Name);
		::LocalFree(Name);
		diatype->Elem.Size = Size;
		ULONGLONG length = 0;
		Symbol->get_length(&length);
		Symbol->get_thunkOrdinal(&v->thunkOrdinal);
		diatype->Elem.ID = m_ElemID++;

		//v7 = PAIR_sub_4314C0((int)&v16, (int)&diatype->Elem.ID, (int)&diatype);
		//std_map_insert_ID2Type_sub_431180(&this->m_GlobalsIDTypeMap, (int)v15, (int)v7);
		m_Globals.Insert(diatype->Elem.ID, diatype);

		IDTYPE idtype;
		idtype.ID = diatype->Elem.ID;
		idtype.Type = diatype;
		//v8 = PAIR_sub_431550((int)v14, (int)&idtype, (int)&idtype);
		//std_map_insert_IDType2ID_sub_430F10(&this->m_Globals_IDType2ID_SET, v13, (int)v8);

		//v9 = PAIR_sub_4314C0((int)&v12, (int)&rva, (int)&diatype);
		//std_map_insert_ID2Type_sub_431180(&this->m_ThunkRVATypeMap, (int)v11, (int)v9);
		m_ThunkRVATypeMap.Insert(rva, diatype);

		v->rva = rva;
		diatype->Elem.Length = length;
		diatype->Elem.Type = ELEM_THUNK;
		if (bRelease) *bRelease = false; //+++
		return diatype->Elem.ID;
	}
	unsigned long CSourceDebug::ParseCustomType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		Trace trace(level, __func__);

		if (Type) *Type = 0;
		if (bRelease) *bRelease = true;
//printf("%s -------------------------------!!!!!!!!!!!!!!!!!!!",__func__);
		//TODO
		return 0;
	}
	unsigned long CSourceDebug::ParseManagedType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		Trace trace(level, __func__);

		if (Type) *Type = 0;
		if (bRelease) *bRelease = true;
//printf("%s -------------------------------!!!!!!!!!!!!!!!!!!!",__func__);
		//TODO
		return 0;
	}

	unsigned long CSourceDebug::ParseDIASymbol(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long level)
	{
		++level;
		//Trace trace(level, __func__);
#if 0
#ifdef TXTDEBUG
{
	for (int l=0;l<n;++l)
	{
fprintf(f," ");
fflush(f);
	}
}
fprintf(f,"%s\n", __func__);
fflush(f);
#endif
#endif
		bool release = true;
		unsigned long ID = 0;

		if (Type) *Type = 0;

		if (bRelease) *bRelease = true;

		if (!Symbol)
			return 0;

		DWORD symTag = 0;
		if (FAILED(Symbol->get_symTag(&symTag)))
			return 0;

		DWORD dataKind = 0;

		switch (symTag)
		{
		case SymTagFunction:
			ID = ParseFunction(Symbol, &release, Type, level);
			break;
		case SymTagData:
			if (SUCCEEDED(Symbol->get_dataKind(&dataKind)) &&
				(dataKind == DataIsFileStatic ||
				 dataKind == DataIsGlobal))
			{
				//ID = ???
				ParseData(Symbol, &release, Type, level);
			}
			break;
		case SymTagUDT:
			ID = ParseUDType(Symbol, &release, Type, level);
			break;
		case SymTagEnum:
			ID = ParseEnumType(Symbol, &release, Type, level);
			break;
		case SymTagFunctionType:
			ID = ParseFunctionType(Symbol, &release, Type, level);
			break;
		case SymTagPointerType:
			ID = ParsePointerBase(Symbol, &release, Type, level);
			break;
		case SymTagArrayType:
			ID = ParseArrayType(Symbol, &release, Type, level);
			break;
		case SymTagBaseType:
			ID = ParseBaseType(Symbol, &release, Type, level);
			break;
		case SymTagTypedef:
			ID = ParseTypedefType(Symbol, &release, Type, level);
			break;
		case SymTagBaseClass:
			ID = ParseBaseClassType(Symbol, &release, Type, level);
			break;
		case SymTagFriend:
			ID = ParseFriend(Symbol, &release, Type, level);
			break;
		case SymTagThunk:
			ID = ParseThunk(Symbol, &release, Type, level);
			break;
		case SymTagCustomType:
			ID = ParseCustomType(Symbol, &release, Type, level);
			break;
		case SymTagManagedType:
			ID = ParseManagedType(Symbol, &release, Type, level);
			break;
		default:
			break;
		}
		if (bRelease) *bRelease = release;
		return ID;
	}
	
	bool CSourceDebug::ReadFILESIG(const char *FullFileName, unsigned long *TimeStamp, unsigned long *CheckSum)
	{
		CPEFile PEFile;
		if (TimeStamp) *TimeStamp = 0;
		if (CheckSum) *CheckSum = 0;

		PEFile.m_OpenMode |= 0x30; //???
		if (!PEFile.Open(FullFileName, 0))
			return false;
		if (TimeStamp) *TimeStamp = PEFile.m_PEHead.TimeDateStamp;
		if (CheckSum) *CheckSum = PEFile.m_PEHead.CheckSum;
		PEFile.Close();
		return true;
	}

	bool CSourceDebug::LoadPESym(const char *FullFileName)
	{
		CPEFile PEFile;
		if (!PEFile.Open(FullFileName, 0))
		{
			return false;
		}
		PUBSYM symbol;
		memset(&symbol, 0, sizeof(symbol));
		symbol.options |= 0x8'0000; //<<19
		for (int n = 0; n < PEFile.m_ImportModuleCount; ++n)
		{
			char *Name = nullptr;
			IMPORT_MODULE *pImportModule = &PEFile.m_ImportModule[n];
			TListIter<char*> It = m_ImportModules.Find(PEFile.m_ImportModule[n].ModuleName); //char_compare
			if (It == m_ImportModules.End())
			{
				Name = new char[TStrLen(pImportModule->ModuleName)+1];
				TStrCpy(Name, pImportModule->ModuleName);
				m_ImportModules.Append(&Name);
			} else
			{
				Name = *It;
			}

			for (int m = 0; m < pImportModule->FuncCount; ++m)
			{
				symbol.rva = pImportModule->FuncList[m].ThunkAddr - PEFile.m_PEHead.ImageBase;
				set<PUBSYM>::IT it = m_PublicSymbols.find(symbol);
				if (it == m_PublicSymbols.end())
				{
					char Buffer[1024];
					TSPrintf(Buffer, "Import_%s_%s", pImportModule->ModuleName, pImportModule->FuncList[m].FuncName);
					symbol.name = new char[TStrLen(Buffer)+1];
					TStrCpy(symbol.name, Buffer);
					symbol.length = 0;
					symbol.moduleName = Name;
					m_PublicSymbols.insert(symbol);
				} else
				{
					it->options |= 0x8'0000; //??? //<<19
					it->moduleName = Name; //???
				}
			}
		}

		symbol.options &= ~0x8'0000; //<<19
		symbol.options |= 0x4'0000; //<<18
		symbol.moduleName = nullptr;

		for (int n = 0; n < PEFile.m_ExportFuncCount; ++n)
		{
			symbol.rva = PEFile.m_ExportFunc[n].Address - PEFile.m_PEHead.ImageBase;
			set<PUBSYM>::IT it = m_PublicSymbols.find(symbol);
			if (it == m_PublicSymbols.end())
			{
				char Buffer[1024];
				TStrCpy(Buffer, PEFile.m_ExportFunc[n].FuncName);
				symbol.name = new char[TStrLen(Buffer)+1];
				TStrCpy(symbol.name, Buffer);
				symbol.length = 0;
				m_PublicSymbols.insert(symbol);
			} else
			{
				it->options |= 0x4'0000; //??? //<<18
			}
		}
		PEFile.Close();
		return true;
	}

	bool CSourceDebug::AddSources(const char *SDSFullFileName, UseSourcesEnum UseSources, int (CbProgress)(char *, char *))
	{
		char szNewFileName[1028];
		bool SkipAll = false;
		unsigned long nFiles = 0;
		//CLocalFileIO LocalIO; //NOT USES
		void *Buffer = nullptr;
		
		if (UseSources == eUseSourcesNone)
			return false;

		HANDLE Handle;
		if (!gpFileIO->OpenFile(SDSFullFileName, &Handle, 1))
			return false;

		unsigned long SDSFileSize = gpFileIO->GetFileLength(Handle);
		SDSFILE *SDSFile = (SDSFILE *)new char[SDSFileSize];
		gpFileIO->ReadFile(Handle, SDSFile, SDSFileSize, 0);
		if (SDSFile->Sources)
		{
			delete [](char*)SDSFile;
			gpFileIO->CloseHandle(Handle);
			return false;
		}

		ULONG_PTR *StringIndexes = (ULONG_PTR*)((char *)SDSFile + SDSFile->StringIndexes);
		char *StringsEntry = (char*)((char *)SDSFile + SDSFile->StringsEntry);
		gpFileIO->SetFilePointer(Handle, SDSFile->SrcFileNames, FILE_BEGIN);
		SrcFileNameID *SrcFileName = (SrcFileNameID *)((char *)SDSFile + SDSFile->SrcFileNames);
		for (unsigned long n = 0; n < SDSFile->SrcFileNamesLen; ++n)
		{
			char *pModuleFileName = (char *)StringsEntry + StringIndexes[(unsigned long)SrcFileName[n].FileName];
			bool FileExist = gpFileIO->IsFileExist(pModuleFileName);
			do {
				if (FileExist)
				{
					++nFiles;
					unsigned long FileSize = gpFileIO->GetFileSize(pModuleFileName);
					unsigned long SrcPos = 0;
					if (UseSources != eUseSourcesExtern)
					{
						SrcPos = gpFileIO->SetFilePointer(Handle, 0, FILE_END);
						char *Buffer = new char[FileSize];
						gpFileIO->ReadFromFile(pModuleFileName, Buffer, FileSize);
						gpFileIO->WriteFile(Handle, Buffer, FileSize);
						delete []Buffer;
					}
					SrcFileName[n].Text = (char*)SrcPos;
					SrcFileName[n].FileSize = FileSize;
					break;
				}
				SrcFileName[n].Text = 0;
				SrcFileName[n].FileSize = 0;

				if (!CbProgress || SkipAll) break;
				
				int ProgressResult = CbProgress(pModuleFileName, szNewFileName);
				if (ProgressResult)
				{
					if (ProgressResult == 2)
						SkipAll = true;
					break;
				}
				pModuleFileName = szNewFileName;
				FileExist = gpFileIO->IsFileExist(pModuleFileName);
			} while (FileExist);
		}

		
		gpFileIO->WriteFile(Handle, SrcFileName, SDSFile->SrcFileNamesLen*sizeof(*SrcFileName), SDSFile->SrcFileNames);

		unsigned long End = gpFileIO->SetFilePointer(Handle, 0, FILE_END);
		unsigned long Size = End & 0xFFF;
		if (Size)
		{
			Size = 4096 - Size; // PAGE_SIZE
			char *p = new char[Size];
			if (p)
			{
				memset(p, 0, Size);
				gpFileIO->WriteFile(Handle, p, Size);
				End = gpFileIO->SetFilePointer(Handle, 0, FILE_END);
				delete []p;
			} else
			{
				SDSFile->CRCSUM = 0;
			}
		}

		SDSFile->Sources = SDSFile->FileSize;
		SDSFile->FileSize = End;
		SDSFile->SourcesCount = nFiles;
		gpFileIO->WriteFile(Handle, SDSFile, SDSFILE_SIZE, 0);
		delete [](char*)SDSFile;
		gpFileIO->CloseHandle(Handle);

		WriteSDSCheckSum(SDSFullFileName);		
		return true;
	}
#endif
	bool CSourceDebug::IsExist(const char *FullFileName, bool *LoadFromPDBOK)
	{
		bool result = OpenDIA(FullFileName, &m_DataSource, &m_Session, &m_GlobalSymbol, LoadFromPDBOK);
		CloseDIA();
		return result;
	}

	bool CSourceDebug::CheckSDS(const char *FullFileName, char *NewFullFileName)
	{
		char SDSFullFileName[268]; //MAX_FN_LEN+8
		TStrCpy(SDSFullFileName, FullFileName);
		TStrCat(SDSFullFileName, ".sds");
		if (NewFullFileName)
			TStrCpy(NewFullFileName, SDSFullFileName);

		if (!gpFileIO->IsFileExist(SDSFullFileName))
			return false;

		unsigned long TimeStamp;
		unsigned long CheckSum;

		SDSFILE SDSFile;

		ReadFILESIG(FullFileName, &TimeStamp, &CheckSum);

		if (gpFileIO->ReadFromFile(SDSFullFileName, &SDSFile, SDSFILE_SIZE) != SDSFILE_SIZE)
			return false;

		if (gpFileIO->GetFileSize(SDSFullFileName) != SDSFile.FileSize)
			return false;

		if (SDSFile.TimeStamp != TimeStamp)
			return false;

		if (SDSFile.Version != SDSFILE_VERSION)
			return false;

		if (SDSFile.CheckSum != CheckSum)
			return false;

		return true;
	}

	bool CSourceDebug::Load(const char *FullFileName, char *NewFullFileName, UseSourcesEnum UseSources)
	{
#ifndef _RING0_
		unsigned long TimeDateStamp = 0;
		unsigned long CheckSum = 0;

		if (!gpFileIO->IsFileExist(FullFileName))
			return false;

		char SDSFullFileName[268]; //MAX_FN_LEN+8
		TStrCpy(SDSFullFileName, FullFileName);
		TStrCat(SDSFullFileName, ".sds");

		if (NewFullFileName)
			TStrCpy(NewFullFileName, SDSFullFileName);

		bool LoadFromPDBOK;
		if (!OpenDIA(FullFileName, &m_DataSource, &m_Session, &m_GlobalSymbol, &LoadFromPDBOK))
		{
			CloseDIA();
			return false;
		}

		bool WriteOK = false;

		//LoadFromPDBOK = false; //HACK ???

		if (Parse(LoadFromPDBOK))
		{
			if (LoadFromPDBOK)
			{
				TStrCpy(SDSFullFileName, TGetFileName(SDSFullFileName));
				if (NewFullFileName) TStrCpy(NewFullFileName, SDSFullFileName);//FullFileName = nullptr;
			} else	LoadPESym(FullFileName);

			//WriteDump("c:\\ntddkvista.h");
			if (LoadFromPDBOK)
			{
				TimeDateStamp = 1;
				CheckSum = 1;
			} else
			{
				ReadFILESIG(FullFileName, &TimeDateStamp, &CheckSum);
			}
			m_TimeStamp = TimeDateStamp;
			m_CheckSum = CheckSum;
			//printf("File %s, TimeStamp %d, CheckSum %d\n", FullFileName, m_TimeStamp, m_CheckSum);
			WriteOK = WriteSDS(SDSFullFileName, TimeDateStamp, CheckSum, FullFileName);
		}
		Release();
		CloseDIA();
		if (WriteOK && UseSources != eUseSourcesNone)
			AddSources(SDSFullFileName, UseSources, m_DialogAppendSrcFilename);
		return WriteOK;
#else
		return false;
#endif
	}
//#endif

	bool CSourceDebug::WriteSDSCheckSum(const char *SDSFullFileName)
	{
		HANDLE Handle;
		if (!gpFileIO->OpenFile(SDSFullFileName, &Handle, 1))
			return false;
		unsigned long Len = gpFileIO->GetFileLength(Handle);
		if (Len & 0xFFF)
		{
			gpFileIO->CloseHandle(Handle);
			return false;
		}
		SDSFILE *SDSFile = (SDSFILE *)new char[Len];
		if (!SDSFile)
		{
			gpFileIO->CloseHandle(Handle);
			return false;
		}
		gpFileIO->SetFilePointer(Handle, 0, FILE_CURRENT);
		if (gpFileIO->ReadFile(Handle, SDSFile, Len, 0) != Len)
		{
			delete [](char*)SDSFile;
			gpFileIO->CloseHandle(Handle);
			return false;
		}
		SDSFile->CRCSUM = 0;
		unsigned long long CheckSum = 0;
		for (unsigned long n = 0; n < Len/4; ++n)
			CheckSum += ((unsigned long*)SDSFile)[n];
		SDSFile->CRCSUM = CheckSum;
		gpFileIO->WriteFile(Handle, SDSFile, SDSFILE_SIZE, 0);
		gpFileIO->FlushFile(Handle);
		gpFileIO->CloseHandle(Handle);
		delete [](char*)SDSFile;
		return true;
	}

	void CSourceDebug::WriteAlign(void *Buffer, unsigned long Size)
	{
		unsigned long ModSize = m_nCurPos % Size;
		if (ModSize)
		{
			ModSize = Size - ModSize;
			gpFileIO->WriteFile(m_Handle, Buffer, ModSize);
		}
		m_nCurPos += ModSize;
	}

	unsigned long CSourceDebug::WriteLocals(DATATYPE *data)
	{
		char *name = data->name;
		data->name = (char *)PackString(data);
		gpFileIO->WriteFile(m_Handle, data, sizeof(*data));
		data->name = name;
		return sizeof(*data);
	}

	unsigned long CSourceDebug::WriteFunction(FUNCTION *FUNC)
	{
		FUNCTION *Func = new FUNCTION;
		*Func = *FUNC;
		unsigned long Size = sizeof(*Func);
		Func->stack = (unsigned long*)(Func->nstack!=0 ? Size : 0);  //TODO X64
		Size += Func->nstack*sizeof(*Func->stack);
		Func->blocks = (unsigned long*)(Func->nblocks!=0 ? Size : 0);  //TODO X64
		Size += Func->nblocks*sizeof(*Func->blocks);

		Func->name = (char *)PackString(Func->name);
		gpFileIO->WriteFile(m_Handle, Func, sizeof(*Func));
		if (Func->nstack)
			gpFileIO->WriteFile(m_Handle, FUNC->stack, Func->nstack*sizeof(*Func->stack));
		if (Func->nblocks)
			gpFileIO->WriteFile(m_Handle, FUNC->blocks, Func->nblocks*sizeof(*Func->blocks));
		if (Func->nlabels)
		{
			FUNCTIONLABEL *Labels = new FUNCTIONLABEL[Func->nlabels];
			for (unsigned long n = 0; n < Func->nlabels; ++n)
			{
				Labels[n].Name = (char*)PackString(Func->labels[n].Name);
//printf("label %d(%x) %s\n", Labels[n].Name, Labels[n].Name, Func->labels[n].Name);
				Labels[n].Offset = Func->labels[n].Offset;
			}
			Size += Func->nlabels*sizeof(*Labels);
			gpFileIO->WriteFile(m_Handle, Labels, Func->nlabels*sizeof(*Labels));
			delete []Labels;
		}
		delete Func;
		return Size;
	}

	unsigned long CSourceDebug::WriteFilesLNs(unsigned long *Count)
	{
		FilesLN *Files = new FilesLN[m_CompilandFilesLN.size()];
		memset(Files, 0, m_CompilandFilesLN.size()*sizeof(*Files));
		m_CompilandFilesLN.sort(); //sort by address
		unsigned long n = 0;
		std::list<FilesLN>::iterator it = m_CompilandFilesLN.begin();
		while (it != m_CompilandFilesLN.end())
		{
			Files[n] = *it;
			++n;
			++it;
		}
		gpFileIO->WriteFile(m_Handle, Files, n*sizeof(*Files));
		if (Count)
			*Count = n;
		delete []Files;
		return n*sizeof(*Files);
	}

	unsigned long CSourceDebug::WriteSrcFileNames(unsigned long *Count)
	{
		SrcFileNameID *SrcFileNames = new SrcFileNameID[m_CompilandSrcMap.size()];
		memset(SrcFileNames, 0, m_CompilandSrcMap.size()*sizeof(*SrcFileNames));
		unsigned long n = 0;
		for (map<char*,SrcFileNameID, MY_char_compare>::IT it = m_CompilandSrcMap.begin();
			it != m_CompilandSrcMap.end(); ++it)
		{
			SrcFileNames[n].FileName = (char*)PackString(it->first);
			SrcFileNames[n].FileID = it->second.FileID;
		#if 0 //+++
			SrcFileNames[n].FileSize = it->second.FileSize; //TODO update from add sources
		#endif
			++n;
		}
		gpFileIO->WriteFile(m_Handle, SrcFileNames, n*sizeof(*SrcFileNames));
		if (Count)
			*Count = n;
		delete []SrcFileNames;
		return n*sizeof(*SrcFileNames);
	}

	unsigned long CSourceDebug::WritePublicSymbols(unsigned long *Count)
	{
		PUBSYM *PublicSymbols = new PUBSYM[m_PublicSymbols.size()];
		memset(PublicSymbols, 0, m_PublicSymbols.size()*sizeof(*PublicSymbols));
		unsigned long nstr = 0;
		unsigned long n = 0;
		set<PUBSYM>::IT it = m_PublicSymbols.begin();
		while (it != m_PublicSymbols.end())
		{
			PublicSymbols[n] = *it;
			if (!TStrCmp("`string'", PublicSymbols[n].name))
			{
				if (m_HasStringPublicSymbol)
				{
					++nstr;
					PublicSymbols[n].name = m_StringPublicSymbol;
				} else
				{
					PublicSymbols[n].name = (char *)PackString(PublicSymbols[n].name);
					m_HasStringPublicSymbol = true;
					m_StringPublicSymbol = PublicSymbols[n].name;
				}
			} else
			{
				PublicSymbols[n].name = (char *)PackString(PublicSymbols[n].name);
			}
			PublicSymbols[n].moduleName = (char*)PackString(PublicSymbols[n].moduleName);
			PUBSYM *pubsym = PublicSymbols;
			++n;
			++it;
		}
		gpFileIO->WriteFile(m_Handle, PublicSymbols, n*sizeof(*PublicSymbols));
		if (Count)
			*Count = n;
		delete []PublicSymbols;
		return n*sizeof(*PublicSymbols);
	}

	unsigned long CSourceDebug::WriteCompilandUnits(unsigned long *Count)
	{
		COMPUNIT *CompUnits = new COMPUNIT[m_CompilandUnitMap.size()];
		memset(CompUnits, 0, m_CompilandUnitMap.size()*sizeof(*CompUnits));
		unsigned long n = 0;
		for (map<char*,COMPUNIT*, MY_char_compare>::IT it = m_CompilandUnitMap.begin();
			it != m_CompilandUnitMap.end(); ++it)
		{
			CompUnits[n] = *it->second;
			CompUnits[n].UnitName = (char*)PackString(CompUnits[n].UnitName);
			++n;
		}
		gpFileIO->WriteFile(m_Handle, CompUnits, n*sizeof(*CompUnits));
		if (Count)
			*Count = n;
		delete []CompUnits;
		return n*sizeof(*CompUnits);
	}

	unsigned long CSourceDebug::WriteBaseType(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WritePointer(DIAPOINTERTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		int HidePos = TStrLen(Name) - 9; //???
		int NameLen = TStrLen(Name);
		char *Buffer = new char[NameLen + Type->v.Num + 1];
		TStrCpy(Buffer, Name);
		unsigned long n = 0;
		for (n = 0; n < Type->v.Num; ++n)
			Buffer[n+HidePos] = '*';
		Buffer[n+HidePos] = 0;
		Type->Elem.Name = (char *)PackString(Buffer);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		delete []Buffer;
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WritePointerRef(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteArray(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteManaged(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteCustom(DIABASICTYPE *Type)	
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteEnum(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);

		ENUMTYPE *enumtype = (ENUMTYPE*)new char[Size];
		memcpy(enumtype, &Type->Elem, Size);
		for (unsigned long n = 0; n < enumtype->Length; ++n)
			enumtype->Values[n].Name = (char*)PackString(enumtype->Values[n].Name);

		gpFileIO->WriteFile(m_Handle, enumtype, Size);
		delete [](char*)enumtype;

		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteUDT(DIAUDTYPE *Type)
	{
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		DIAUDTYPE *udtype = (DIAUDTYPE *)new char [Type->Elem.Size];
		memcpy(udtype, Type, Type->Elem.Size);

		udtype->Elem.Name = (char *)PackString(Type);
		udtype->v.Data = (unsigned long*)Size; //TODO X64
		Size += udtype->v.DataLen*sizeof(*udtype->v.Data);
		udtype->v.Function = (unsigned long*)Size; //TODO X64
		Size += udtype->v.FunctionLen*sizeof(*udtype->v.Function);
		udtype->v.Friend = (unsigned long*)Size; //TODO X64
		Size += udtype->v.FriendLen*sizeof(*udtype->v.Friend);
		udtype->v.BaseClass = (unsigned long*)Size; //TODO X64
		Size += udtype->v.BaseClassLen*sizeof(*udtype->v.BaseClass);
		udtype->v.PubSymbols = (CLASSPUBSYM*)Size; //TODO X64
		Size += udtype->v.PubSymbolsLen*sizeof(*udtype->v.PubSymbols);

		gpFileIO->WriteFile(m_Handle, &udtype->Elem, Type->Elem.Size - sizeof(DIASYMBOL));
		if (udtype->v.DataLen)
			gpFileIO->WriteFile(m_Handle, Type->v.Data, udtype->v.DataLen*sizeof(*udtype->v.Data));
		if (udtype->v.FunctionLen)
			gpFileIO->WriteFile(m_Handle, Type->v.Function, udtype->v.FunctionLen*sizeof(*udtype->v.Function));
		if (udtype->v.FriendLen)
			gpFileIO->WriteFile(m_Handle, Type->v.Friend, udtype->v.FriendLen*sizeof(*udtype->v.Friend));
		if (udtype->v.BaseClassLen)
			gpFileIO->WriteFile(m_Handle, Type->v.BaseClass, udtype->v.BaseClassLen*sizeof(*udtype->v.BaseClass));
		if (udtype->v.PubSymbolsLen)
			gpFileIO->WriteFile(m_Handle, Type->v.PubSymbols, udtype->v.PubSymbolsLen*sizeof(*udtype->v.PubSymbols));

		delete [](char*)udtype;
		return Size;
	}

	unsigned long CSourceDebug::WriteTypeDef(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteFunction(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteBaseClass(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteFriend(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteThunk(DIABASICTYPE *Type)
	{
		char *Name = Type->Elem.Name;
		Type->Elem.Name = (char *)PackString(Type);
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		Type->Elem.Name = Name;
		return Size;
	}

	unsigned long CSourceDebug::WriteBlock(DIABASICTYPE *Type)
	{
		unsigned long Size = Type->Elem.Size - sizeof(DIASYMBOL);
		gpFileIO->WriteFile(m_Handle, &Type->Elem, Size);
		return Size;
	}

	bool CSourceDebug::WriteSDS(const char *SDSFullFileName, unsigned long TimeStamp, unsigned long CheckSum, const char *FullFileName)
	{
		char *EmptyPage = new char[PAGE_SIZE];
		memset(EmptyPage, 0, PAGE_SIZE);

		m_StringsHead = 0;
		m_StringsTail = STRINGS_CHUNK_SIZE;
		m_StringsBuf = new char[m_StringsTail];
		memset(m_StringsBuf, 0, m_StringsTail);
		m_StringsCur = 1;
		m_StringsID = 1;

		SDSFILE *SDSFile = (SDSFILE*)new char[SDSFILE_SIZE];
		memset(SDSFile, 0, sizeof(SDSFILE));
		SDSFile->Magic = SDSFILE_MAGIC;
		SDSFile->SUB = 20;
		SDSFile->Version = SDSFILE_VERSION;
		SDSFile->HeaderSize = SDSFILE_SIZE;
		SDSFile->TimeStamp = TimeStamp;
		SDSFile->CheckSum = CheckSum;

		if (!gpFileIO->CreateFile(SDSFullFileName, &m_Handle, 0x10001))
		{
			delete []EmptyPage;
			return false;
		}

		gpFileIO->WriteFile(m_Handle, SDSFile, SDSFILE_SIZE);
		m_nCurPos = SDSFILE_SIZE;

		SDSFile->GlobalsLen = m_Globals.size();
		++SDSFile->GlobalsLen;

		ULONG_PTR *Globals = new ULONG_PTR[SDSFile->GlobalsLen];
		memset(Globals, 0, SDSFile->GlobalsLen*sizeof(*Globals));

		Globals[0] = m_nCurPos;
		//COMMONTYPE
		DIABASICTYPE NullBaseType; //????? TODO MAX SIZE OF ELEM_TYPE
		memset(&NullBaseType, 0, sizeof(NullBaseType));
		//NullBaseType._basic.Elem.Name = ""; //+++
		//NullBaseType._basic.Elem.Name = (char*)PackString(NullBaseType._basic.Elem.Name); //+++
		gpFileIO->WriteFile(m_Handle, &NullBaseType, sizeof(NullBaseType));
		m_nCurPos += sizeof(NullBaseType);

		m_StringIndexes.push_back(0);

		//{ GLOBALS
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
	{
		unsigned long n = 1;
		for (map<unsigned long, DIABASICTYPE*>::IT it = m_Globals.begin();
			it != m_Globals.end(); ++it)
		{
			unsigned long Size = 0;
			Globals[n] = m_nCurPos;
			if (n != it->first)
			{
				//MessageBoxA(0, "Sort error", "error", 0);
#ifdef TXTDEBUG
fprintf(f,"%s n %d != Type %d\n", __func__, n, it->second->Elem.Type);
fflush(f);
#endif
		printf("OutOfOrder! %d m_nCurPos %d(%x) Size %d, Type %d, Name %s\n",
			n, m_nCurPos, m_nCurPos, Size, it->second->Elem.Type, it->second->Elem.Name?it->second->Elem.Name:"");

			}

			switch (it->second->Elem.Type)
			{
			case ELEM_BASE_TYPE:{
				Size = WriteBaseType(it->second);
				} break;
			case ELEM_POINTER:{
				Size = WritePointer((DIAPOINTERTYPE *)it->second);
				} break;
			case ELEM_POINTERREF:{
				Size = WritePointerRef(it->second);
				} break;
			case ELEM_ARRAY:{
				Size = WriteArray(it->second);
				} break;
			case ELEM_MANAGED_TYPE:{
				Size = WriteManaged(it->second);
				} break;
			case ELEM_CUSTOM_TYPE:{
				Size = WriteCustom(it->second);
				} break;
			case ELEM_ENUM:{
				Size = WriteEnum(it->second);
				} break;
			case ELEM_STRUCT:
			case ELEM_CLASS:
			case ELEM_UNION:{
				Size = WriteUDT((DIAUDTYPE *)it->second);
				} break;
			case ELEM_TYPEDEF:{
				Size = WriteTypeDef(it->second);
				} break;
			case ELEM_FUNC_TYPE:{
				Size = WriteFunction(it->second);
				} break;
			case ELEM_BASE_CLASS:{
				Size = WriteBaseClass(it->second);
				} break;
			case ELEM_FRIEND:{
				Size = WriteFriend(it->second);
				} break;
			case ELEM_FRIEND_PAIR:{
				Size = WriteFriend(it->second);
				Size = WriteFriend(it->second);
				} break;
			case ELEM_THUNK:{
				Size = WriteThunk(it->second);
				} break;
			case ELEM_BLOCK:{
				Size = WriteBlock(it->second);
				} break;
			default:;
				//Globals[n] = Globals[0]; //+++ SDSFILE_SIZE;
			}
	#if 0
		printf("%d m_nCurPos %d(%x) Size %d, Type %d, Name %s\n",
			n, m_nCurPos, m_nCurPos, Size, it->second->Elem.Type, it->second->Elem.Name?it->second->Elem.Name:"");
	#endif
			if (Size == 0)
				Globals[n] = Globals[0]; //+++ SDSFILE_SIZE;
			m_nCurPos += Size;
			gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
			++n;
		}
	}
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		// Globals size
		WriteAlign(EmptyPage, 16);
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		SDSFile->Globals = m_nCurPos;
		gpFileIO->WriteFile(m_Handle, Globals, SDSFile->GlobalsLen*sizeof(*Globals));
		delete []Globals;
		m_nCurPos += SDSFile->GlobalsLen*sizeof(*Globals);
		WriteAlign(EmptyPage, 16);
		//}

		//{ LOCALS
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		SDSFile->Locals = m_nCurPos;
		m_nCurPos += sizeof(DATATYPE);
		DATATYPE NullLocal;
		memset(&NullLocal, 0, sizeof(NullLocal));
		//NullLocal.name = "";
		//NullLocal.name = (char*)PackString(NullLocal.name);
		gpFileIO->WriteFile(m_Handle, &NullLocal, sizeof(NullLocal));
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);

		for (unsigned long n = 1; n < m_Locals.size(); ++n)
		{
	#if 0
		printf("%d local m_nCurPos %d(%x) Size %d, Type %d, Name %s\n",
			n, m_nCurPos, m_nCurPos, sizeof(DATATYPE), m_Locals[n]->ID, m_Locals[n]->name);
	#endif
			m_nCurPos += WriteLocals(m_Locals[n]);
			gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		}
		SDSFile->LocalsLen = m_Locals.size();

		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		WriteAlign(EmptyPage, 16);
		//}

		//{ FUNCTION
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		ULONG_PTR *Functions = new ULONG_PTR[m_FunctionsIDMap.size()+1];
		memset(Functions, 0, (m_FunctionsIDMap.size()+1)*sizeof(*Functions));
		SDSFile->FunctionsEntry = m_nCurPos;
		Functions[0] = m_nCurPos;
		FUNCTION NullFunction;
		m_nCurPos += sizeof(NullFunction);
		memset(&NullFunction, 0, sizeof(NullFunction));
		//NullFunction.name = "";
		//NullFunction.name = (char*)PackString(NullFunction.name);
		gpFileIO->WriteFile(m_Handle, &NullFunction, sizeof(NullFunction));

		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
	{
		for (map<FUNCTIONKEY, unsigned long>::IT it = m_FunctionsIDMap.begin();
			it != m_FunctionsIDMap.end(); ++it)
		{
			map<unsigned long, FUNCTIONKEY*>::IT resit = m_IDFunctionsMap.insert(_Tmap_pair<unsigned long, FUNCTIONKEY*>(it->second, (FUNCTIONKEY*)&(it->first)));
		#if 0
			if (resit == m_IDFunctionsMap.end())
			{
				printf("FAILADD rva %08x id %d %s\n", it->first.rva, it->first.func->ID, it->first.name);

				map<unsigned long, FUNCTIONKEY*>::IT rr = m_IDFunctionsMap.find(it->first.rva);
				if (rr != m_IDFunctionsMap.end())
					printf("EXIST rva %08x id %d %s\n", rr->second->rva, rr->second->func->ID, rr->second->name);
			}
		#endif
		}
	}
	{	long n = 0;
		for (map<unsigned long, FUNCTIONKEY*>::IT it = m_IDFunctionsMap.begin();
			it != m_IDFunctionsMap.end(); ++it)
		{
			Functions[it->second->func->ID] = m_nCurPos;
			unsigned long Size = WriteFunction(it->second->func);
			if (Size == 0)
				Functions[it->second->func->ID] = Functions[0];
	#if 0
		printf("%d func m_nCurPos %d(%x) Size %d, Type %d, Name %s\n",
			n, m_nCurPos, m_nCurPos, sizeof(FUNCTION), it->second->func->ID, it->second->func->name);
	#endif
			m_nCurPos += Size;
			++n;
		}
	}
		m_IDFunctionsMap.clear();
		SDSFile->FunctionsLen = m_FunctionsIDMap.size()+1;
		WriteAlign(EmptyPage, 16);

		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		SDSFile->Functions = m_nCurPos;
	#if 0
		for (unsigned long n = 0; n < (m_FunctionsIDMap.size()+1)*sizeof(*Functions); ++n)
		{
			if (!Functions[n])
				printf("func: empty slot %d\n", n);
		}
	#endif
		gpFileIO->WriteFile(m_Handle, Functions, (m_FunctionsIDMap.size()+1)*sizeof(*Functions));
		delete []Functions;
		m_nCurPos += (m_FunctionsIDMap.size()+1)*sizeof(*Functions);
		WriteAlign(EmptyPage, 16);		
		//}

		//{ COMPILAND FILES
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		SDSFile->FilesLN = m_nCurPos;
		m_nCurPos += WriteFilesLNs(&SDSFile->FilesLNLen);
		WriteAlign(EmptyPage, 16);
		//}

		//{ SRC FILE NAMES
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		SDSFile->SrcFileNames = m_nCurPos;
		m_nCurPos += WriteSrcFileNames(&SDSFile->SrcFileNamesLen);
		WriteAlign(EmptyPage, 16);
		SDSFile->SourcesCount = m_CompilandSrcMap.size(); //+++
		//}


		//{ PUBLIC SYMBOLS
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		SDSFile->PublicSymbols = m_nCurPos;
		m_nCurPos += WritePublicSymbols(&SDSFile->PublicSymbolsLen);
		WriteAlign(EmptyPage, 16);
		//}

		//{ COMPILAND UNITS, NOT USES
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		SDSFile->CompilandUnits = m_nCurPos;
		m_nCurPos += WriteCompilandUnits(&SDSFile->CompilandUnitsLen);
		WriteAlign(EmptyPage, 16);
		//}

		//{ STRINGS
		SDSFile->StringIndexesLen = m_StringIndexes.size();
		SDSFile->StringIndexes = m_nCurPos;
		//if (SDSFile->StringIndexsLen > SDSFile->GlobalsLen)
		//{
		ULONG_PTR *StringIndexes = new ULONG_PTR[SDSFile->StringIndexesLen];
		//}
		for (unsigned n = 0; n < SDSFile->StringIndexesLen; ++n)
		{
			StringIndexes[n] = m_StringIndexes[n];
		}
		gpFileIO->WriteFile(m_Handle, StringIndexes, SDSFile->StringIndexesLen*sizeof(*StringIndexes));
		delete []StringIndexes;
		m_nCurPos += SDSFile->StringIndexesLen*sizeof(*StringIndexes);

		WriteAlign(EmptyPage, 16);
		//
		gpFileIO->SetFilePointer(m_Handle, 0, FILE_CURRENT);
		SDSFile->StringsEntry = m_nCurPos;
	{
		TList<stStringChunk>::IT it = m_StringsList.Begin();
		while (it != m_StringsList.End())
		{
			const char *StringsBuf = it->StringsBuf;
			unsigned long Size = it->StringsCur - it->StringsHead;
			gpFileIO->WriteFile(m_Handle, StringsBuf, Size);
			m_nCurPos += Size;
			delete []StringsBuf;
			++it;
		}
	}
		const char *StringsBuf = m_StringsBuf;
		unsigned long Size = m_StringsCur - m_StringsHead;
		gpFileIO->WriteFile(m_Handle, StringsBuf, Size);
		m_nCurPos += Size;
		delete []StringsBuf;
		//} STRINGS
		WriteAlign(EmptyPage, 16);

		unsigned long CurPos = 0;
		//MODULE NAME
	{
		unsigned long Size = TStrLen(m_ModuleName) + 1;
		if (CurPos >= Size)
		{
			SDSFile->ModuleName = SDSFILE_SIZE- CurPos;
			TStrCpy((char *)SDSFile + SDSFILE_SIZE - CurPos, m_ModuleName);
			CurPos -= Size;
		} else
		{
			SDSFile->ModuleName = m_nCurPos;
			gpFileIO->WriteFile(m_Handle, m_ModuleName, Size);
			m_nCurPos += Size;
		}
		SDSFile->ModuleNameLen = Size;
	}
		//PDB FULL FILE NAME
	{
		unsigned long Size = TStrLen(m_PDBFullFileName) + 1;
		if (CurPos >= Size)
		{
			SDSFile->PDBFullFileName = SDSFILE_SIZE - CurPos;
			TStrCpy((char *)SDSFile + SDSFILE_SIZE - CurPos, m_PDBFullFileName);
			CurPos -= Size;
		} else
		{
			SDSFile->PDBFullFileName = m_nCurPos;
			gpFileIO->WriteFile(m_Handle, m_PDBFullFileName, Size);
			m_nCurPos += Size;
		}
		SDSFile->PDBFullFileNameLen = Size;
	}
		//PDB FULL FILE NAME
		if (FullFileName)
	{
		unsigned long Size = TStrLen(FullFileName) + 1;
		if (CurPos >= Size)
		{
			SDSFile->FullFileName = SDSFILE_SIZE - CurPos;
			TStrCpy((char *)SDSFile + SDSFILE_SIZE - CurPos, FullFileName);
			CurPos -= Size;
		} else
		{
			SDSFile->FullFileName = m_nCurPos;
			gpFileIO->WriteFile(m_Handle, FullFileName, Size);
			m_nCurPos += Size;
		}
		SDSFile->FullFileNameLen = Size;
	}

		WriteAlign(EmptyPage, PAGE_SIZE);

		SDSFile->FileSize = m_nCurPos;

		gpFileIO->WriteFile(m_Handle, SDSFile, SDSFILE_SIZE, 0);
		gpFileIO->CloseHandle(m_Handle);
		WriteSDSCheckSum(SDSFullFileName);
		delete []EmptyPage;
		delete []SDSFile;
		return true;
	}

```

`source/EXEAnalyzer/sourcedebug.hpp`:

```hpp

#ifndef _SOURCEDEBUG_HPP_
#define _SOURCEDEBUG_HPP_
#include "../Code/define.h"
#include "../Code/tstrmem.hpp"
#include "../Code/alt/altlist.hpp"
#include "../Code/alt/altmap.hpp"

#ifndef _RING0_
#include <cvconst.h>
#include <dia2.h>
#endif
#include <map>
//#include <set>
#include <list>
#include <vector>
#include <algorithm>

//#define DIASOURCEDEBUG
#include "sdsfile.hpp"

	struct DIASYMBOL : public NULLTYPE
	{
        	void *Value; //
		IDiaSymbol *Symbol;
	};

	struct DIABASICTYPE : public DIASYMBOL { ELEM Elem; };
	struct DIAPOINTERTYPE : public DIABASICTYPE { elemPOINTER v; };
	struct DIAPOINTERREFTYPE : public DIABASICTYPE { elemPOINTERREF v; };
	struct DIAARRAYTYPE : public DIABASICTYPE { elemARRAY v; };
	struct DIAENUMTYPE : public DIABASICTYPE { elemENUM v; };
	struct DIAUDTYPE : public DIABASICTYPE { elemUDT v; };
	struct DIATYPEDEFTYPE : public DIABASICTYPE { elemTYPEDEF v; };
	struct DIAFUNCTYPE : public DIABASICTYPE { elemFUNC v; };
	struct DIABASECLASSTYPE : public DIABASICTYPE { elemBASECLASS v; };
	struct DIABLOCKTYPE  : public DIABASICTYPE { elemBLOCK v; };
	struct DIATHUNK  : public DIABASICTYPE { elemTHUNK v; };

	union COMMONTYPE
	{
		BASICTYPE _basic;
		POINTERTYPE _pointer;
		POINTERREFTYPE _pointerref;
		ARRAYTYPE _array;
		ENUMTYPE _enum;
		UDTYPE _ud;
		TYPEDEFTYPE _typedef;
		FUNCTYPE _func;
		BASECLASSTYPE _baseclass;
		BLOCKTYPE _block;
	};

	struct char_compare
	{
		bool operator()(const char *s1, const char *s2) const
		{
			return TStrICmp(s1, s2) != 0;
		}
	};

//	struct IMPORTMODULE
//	{
//		char *Name;
//		IMPORTMODULE()
//		{
//			Name = 0;
//		}
//		~IMPORTMODULE()
//		{
//			if (Name) delete Name;
//		}
//		bool operator<(const IMPORTMODULE &other) const { return TStrICmp(Name, other.Name)==0; }
//	};

	struct DATAKEY
	{
		char *name;
		unsigned long rva;

		bool operator<(const DATAKEY &other) const
		{
			if (rva < other.rva) return true;
			if (rva != other.rva) return false;
			return TStrCmp(name, other.name)<0;
		}
	};

	struct REGISTERED_
	{
		unsigned long dataKind;
		unsigned long registerId;
		unsigned long ID;
		DATATYPE *data;

		bool operator!=(const REGISTERED_ &other) const
		{
			if (dataKind != other.dataKind) return true;
			if (registerId != other.registerId) return true;
			return false;
		}
	};

	struct FUNCTIONKEY
	{
		char *name;
		unsigned long rva;
		FUNCTION *func;

		bool operator<(const FUNCTIONKEY &other) const
		{
			if (rva < other.rva) return true;
			if (rva > other.rva) return false;
			return TStrCmp(name, other.name)<0;
		}
	};

	struct BASEDATATYPE
	{
		unsigned long basetype;
		unsigned long long length;

		bool operator<(const BASEDATATYPE & other) const
		{
			if (basetype < other.basetype) return true;
			return (basetype == other.basetype) && length < other.length;
		}
	};

	struct BASEDATATYPENAMED
	{
		BASEDATATYPE type;
		char name[32];
	};

	struct IDTYPE
	{
		unsigned long ID;
		DIABASICTYPE *Type;
	};

	enum UseSourcesEnum
	{
		eUseSourcesNone = 0,
		eUseSourcesExtern = 1,
		eUseSourcesText = 2,
		eUseSourcesPacked = 3,
	};

struct CSourceDebug
{
#ifndef _RING0_
	IDiaSymbol *m_GlobalSymbol;
	IDiaSession *m_Session;
	IDiaDataSource *m_DataSource;

	bool IsOpen() const { return m_DataSource && m_Session && m_GlobalSymbol; }

	IDiaEnumFrameData *m_EnumFragmentData;
	IDiaEnumSegments *m_Segments;

	typedef HRESULT(WINAPI*DLLGCO)(REFCLSID, REFIID, LPVOID);
	DLLGCO m_DllGCO;
	HMODULE m_hLibrary;
#endif
	void (*m_CreateProgress)(unsigned long MaxPos);
	void (*m_UpdateProgress)(unsigned long Pos);
	void (*m_UpdateCaption)(const WCHAR *Text);
	void (*m_DestroyProgress)();
	unsigned long m_nTotal;
	unsigned long m_nProgress;

	int (*m_DialogAppendSrcFilename)(char *FullFileName, char *NewFullFileName); //ret 2 - OK

	map<char*, SrcFileNameID, MY_char_compare> m_CompilandSrcMap; //set //char_compare
	map<char*, COMPUNIT*, MY_char_compare> m_CompilandUnitMap; //char_compare

	unsigned long m_CompilandUnitID;
	unsigned long m_CompilandFileID;
	std::list<FilesLN> m_CompilandFilesLN;

	//{ FUNCTION
	unsigned long m_FuncID;
	map<FUNCTIONKEY, unsigned long> m_FunctionsIDMap;
	map<unsigned long, FUNCTIONKEY*> m_IDFunctionsMap;
	TList<unsigned long> m_FunctionsRVA;
	//}

	//{ DATATYPE
	unsigned long m_DataID;
	TList<REGISTERED_> m_Registered;
	map<DATAKEY, unsigned long> m_StaticDatas;
	std::vector<DATATYPE*> m_Locals;
	//}

	//{ PUBSYM
	bool m_HasStringPublicSymbol;
	char *m_StringPublicSymbol;
	set<PUBSYM> m_PublicSymbols;
	set<PUBSYM> m_ClassPublicSymbols;
	//}

	//{ GLOBAL
	unsigned long m_ElemID;
	map<unsigned long, DIABASICTYPE*> m_Globals; //improve speed O(1) vector ???
//	map<const char*, unsigned long, MY_char_compare> m_GlobalsName; //TODO REMOVE
//	std::vector<DIABASICTYPE*> m_GlobalsID; //TODO REMOVE
	//}

	//{ BASECLASS
	std::list<IDTYPE> m_BaseClassList;
	//}

	//{ FUNCTYPE
	std::list<IDTYPE> m_FuncTypeList;
	//}

	//{ TYPEDEF
	std::list<IDTYPE> m_TypedefList;
	//}

	//{ ENUM
	std::list<IDTYPE> m_EnumList;
	//}

	//{ BASE TYPE
	std::map<BASEDATATYPE, unsigned long> m_BaseDataTypeIDMap;
	//}

	//{ POINTER TYPE
	map<const char*,unsigned long, MY_char_compare> m_PointerStrIDMap;
	//}

	//{ POINTERREF TYPE
	map<const char*,unsigned long, MY_char_compare> m_PointerRefStrIDMap;
	//}

	//{ ARRAY TYPE
	std::list<IDTYPE> m_ArrayList;
	//}

	//{ UDTYPE
	std::list<IDTYPE> m_UDTList;
	map<const char*,unsigned long, MY_char_compare> m_UDTStrIDMap;
	map<const char*,unsigned long, MY_char_compare>::IT m_StrIDMAPIter;
	//}

	//{ THUNK
	map<unsigned long, DIABASICTYPE*> m_ThunkRVATypeMap;
	//}

	//{ FILE
	HANDLE m_Handle;
	unsigned long m_nCurPos;
	//} FILE

	//{ STRINGS
	#define STRINGS_CHUNK_SIZE 0x100000
	struct stStringChunk
	{
		const char *StringsBuf;
		unsigned long StringsHead;
		unsigned long StringsCur;
	};

	unsigned long m_StringsID;
	unsigned long m_StringsCur;
	unsigned long m_StringsHead;
	unsigned long m_StringsTail;
	char *m_StringsBuf;
	TList<stStringChunk> m_StringsList;
	std::vector<unsigned long> m_StringIndexes;
	map<const char *, unsigned long, MY_char_compare> m_StringIDMap;

	unsigned long PackString(const char *Str);
	unsigned long PackString(const DATATYPE *data);
	unsigned long PackString(const DIABASICTYPE *Type);
	//} STRINGS

	TList<char*, char_compare> m_ImportModules;

	char *m_ModuleName;
	char *m_PDBFullFileName;

	unsigned long m_nSrcFilesCount; //TODO REMOVE

	//{ FILESIG
	unsigned long m_TimeStamp;
	unsigned long m_CheckSum;

	FILESIG GetFILESIG() const { return FILESIG(m_TimeStamp, m_CheckSum); }
	//}

	CSourceDebug();
	~CSourceDebug();

	void Release();
#ifndef _RING0_
	bool LoadDIA();
	bool UnloadDIA();

	HRESULT OpenDIA(void *, REFIID DiaSource, REFIID DataSource, void **DiaDataSource);
	bool OpenDIA(const char *FileName, IDiaDataSource **DataSource, IDiaSession **Session, IDiaSymbol **Symbol, bool *LoadFromPDBOK);
	void CloseDIA();

	bool GetInfo(IDiaSymbol *Symbol);

	bool FindHelper();

 //TODO REMOVE
//	void MapNameID();

	unsigned long GetTotal();

	bool Parse(bool LoadFromPDBOK);

	void ParserRelease();

	bool StripClassName(char *String);

	bool GetPublicSymbol(IDiaSymbol *Symbol, bool *bRelease, void *Type);

	bool GetCompiland(IDiaSymbol *Symbol);

	void InitBasicType();
	bool SetDataLocation(DATATYPE *data, IDiaSymbol *Symbol);
	unsigned long ParseData(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	bool SameTag(IDiaSymbol *Symbol, unsigned long Tag);
	unsigned long MakeSDBlock(IDiaSymbol *Symbol, TList<unsigned long> *ListsID, unsigned long n);
	unsigned long ParseFunction(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	DIABASICTYPE *GetGlobal(unsigned long ID);
	unsigned long ParseUDType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseEnumType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseFunctionType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParsePointerBase(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	IDiaSymbol *GetSymbolPointer(IDiaSymbol *Symbol, int, unsigned long *Count);
	char * GetName(unsigned long ID);
	WCHAR * GetName(unsigned long ID, WCHAR *pStr, int *pLen);
	WCHAR * GetName(DIABASICTYPE *Type, WCHAR *pStr, int *pLen, int);
	unsigned long ParsePointerType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParsePointerRefType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	bool GetArray(IDiaSymbol *Symbol, std::list<IDiaSymbol *> &Symbols);
	unsigned long ParseArray(IDiaSymbol *Symbol, unsigned long ID, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseArrayType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	const char *GetBaseTypeName(unsigned long type, unsigned long length);
	unsigned long ParseBaseType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseTypedefType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseBaseClassType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseFriend(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseThunk(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseCustomType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseManagedType(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	unsigned long ParseDIASymbol(IDiaSymbol *Symbol, bool *bRelease, NULLTYPE **Type, unsigned long n);
	bool ReadFILESIG(const char *FullFileName, unsigned long *TimeStamp, unsigned long *CheckSum);
	bool LoadPESym(const char *FullFileName);
	bool AddSources(const char *SDSFullFileName, UseSourcesEnum UseSources, int (CbProgress)(char *, char *));
#endif
	bool IsExist(const char *FileName, bool *LoadFromPDBOK);
	bool CheckSDS(const char *FullFileName, char *NewFullFileName);
	bool Load(const char *FullFileName, char *NewFullFileName, UseSourcesEnum UseSources);
	bool WriteSDSCheckSum(const char *SDSFullFileName);
	void WriteAlign(void *Buffer, unsigned long Size);
	unsigned long WriteLocals(DATATYPE *data);
	unsigned long WriteFunction(FUNCTION *FUNC);
	unsigned long WriteFilesLNs(unsigned long *Count);
	unsigned long WriteSrcFileNames(unsigned long *Count);
	unsigned long WritePublicSymbols(unsigned long *Count);
	unsigned long WriteCompilandUnits(unsigned long *Count);

	unsigned long WriteBaseType(DIABASICTYPE *Type);
	unsigned long WritePointer(DIAPOINTERTYPE *Type);
	unsigned long WritePointerRef(DIABASICTYPE *Type);
	unsigned long WriteArray(DIABASICTYPE *Type);
	unsigned long WriteManaged(DIABASICTYPE *Type);
	unsigned long WriteCustom(DIABASICTYPE *Type);
	unsigned long WriteEnum(DIABASICTYPE *Type);
	unsigned long WriteUDT(DIAUDTYPE *Type);
	unsigned long WriteTypeDef(DIABASICTYPE *Type);
	unsigned long WriteFunction(DIABASICTYPE *Type);
	unsigned long WriteBaseClass(DIABASICTYPE *Type);
	unsigned long WriteFriend(DIABASICTYPE *Type);
	unsigned long WriteThunk(DIABASICTYPE *Type);
	unsigned long WriteBlock(DIABASICTYPE *Type);

	bool WriteSDS(const char *SDSFullFileName, unsigned long TimeStamp, unsigned long CheckSum, const char *FullFileName);
};
#endif

```

`source/EXEAnalyzer/symbol.cpp`:

```cpp

#include "symbol.hpp"

// CSymbolModule

	CSymbolModule::CSymbolModule()
		: m_ImageBase(0)
		, m_ImageSize(0)
		, m_RefCount(0)
		, m_TimeStamp(0)
		, m_CheckSum(0)
	{
	}

	bool CSymbolModule::Add(ULONG_PTR Address, const char *Name) //00
	{
		map<ULONG_PTR, TAnsiNoCaseString>::IT it = m_SymbolMap.insert(
			_Tmap_pair<ULONG_PTR,TAnsiNoCaseString>(Address, TAnsiNoCaseString(Name)));
		return it != m_SymbolMap.end();
	}

	bool CSymbolModule::Set(ULONG_PTR Address, const char *Name) //04
	{
		map<ULONG_PTR, TAnsiNoCaseString>::IT it = m_SymbolMap.find(Address);
		if (it == m_SymbolMap.end())
			return Add(Address, Name);

		if (it->second == Name)
			return false;
		it->second = Name;
		return true;
	}

	int CSymbolModule::Del(const char *Name) //08
	{
		int Count = 0;
		map<ULONG_PTR, TAnsiNoCaseString>::IT it = m_SymbolMap.begin();
		for (; it == m_SymbolMap.end(); )
		{
			if (it->second == Name)
			{
				m_SymbolMap.erase(it++), ++Count;
			} else ++it;
		}
		return Count > 0;
	}

	bool CSymbolModule::Del(ULONG_PTR Address) //0C
	{
		return m_SymbolMap.erase(Address) > 0;
	}

	bool CSymbolModule::GetAddr(const char *Name, ULONG_PTR *pAddress) //10
	{
		if (m_ImageBase == 0)
			return false;
		map<ULONG_PTR, TAnsiNoCaseString>::IT it = m_SymbolMap.begin();
		//for (; it == m_SymbolMap.end(); ++it)
		while (it)
		{
			if (it->second == Name)
			{
				if (pAddress)
					*pAddress = m_ImageBase + it->first;
				return true;
			}
			++it;
		}
		return false;
	}
	
	
//CCommentModule

	CCommentModule::CCommentModule()
		: m_RefCount(0)
		, m_TimeStamp(0)
		, m_CheckSum(0)
	{
	}

	bool CCommentModule::Add(ULONG_PTR Address, const char *Name) //00
	{
		map<ULONG_PTR, TAnsiString>::IT it = m_CommentMap.insert(
			_Tmap_pair<ULONG_PTR, TAnsiString>(Address, TAnsiString(Name)));
		return it != m_CommentMap.end();
	}

	bool CCommentModule::Set(ULONG_PTR Address, const char *Name) //04
	{
		map<ULONG_PTR, TAnsiString>::IT it = m_CommentMap.find(Address);
		if (it == m_CommentMap.end())
			return Add(Address, Name);

		if (it->second == Name)
			return false;
		it->second = Name;
		return true;
	}

	bool CCommentModule::Del(ULONG_PTR Address) //08
	{
		return m_CommentMap.erase(Address) > 0;
	}
	
	unsigned long CCommentModule::Write(ALT::ALTFileStream &File)
	{
		unsigned long TotalLen = 0;
		unsigned long Len;
		Len = m_ModuleName.Write(File);
		TotalLen += Len;
		unsigned long Count = m_CommentMap.size();
		Len = File.Write(&Count, 4);
		TotalLen += Len;
		for (map<ULONG_PTR, TAnsiString>::IT it = m_CommentMap.begin();
			it != m_CommentMap.end(); ++it)
		{
			ULONG_PTR Addr = it->first;
			Len = File.Write(&Addr, sizeof(Addr));
			TotalLen += Len;
			Len = it->second.Write(File);
			TotalLen += Len;
		}
		return TotalLen;
	}

	unsigned long CCommentModule::Read(ALT::ALTFileStream &File)
	{
		unsigned long TotalLen = 0;
		unsigned long Len;
		Len = m_ModuleName.Read(File);
		if (!Len) return 0;
		TotalLen += Len;
		unsigned long Count;
		Len = File.Read(&Count, 4);
		if (Len == 0 || Count > 4096) return 0;
		TotalLen += Len;
		while (Count>0)
		{
			ULONG_PTR Addr;
			TotalLen += File.Read(&Addr, sizeof(Addr));
			map<ULONG_PTR, TAnsiString>::IT it = m_CommentMap.insert(_Tmap_pair<ULONG_PTR, TAnsiString>(Addr, TAnsiString()));
			if (it == m_CommentMap.end()) return 0;
			Len = it->second.Read(File);
			if (Len == 0)
			{
				m_CommentMap.erase(it);
				return 0;
			}
			TotalLen += Len;
			--Count;
		}
		return TotalLen;
	}

// CSymbolContainer

	CSymbolModule *CSymbolContainer::FindModule(unsigned int TimeStamp, unsigned int CheckSum) //00
	{
		unsigned long long key = ((unsigned long long)CheckSum)<<32|TimeStamp;
		map<unsigned long long, CSymbolModule>::IT it = m_SymbolModulesMap.find(key);
		//if (it == m_SymbolModulesMap.end())
		if (!it)
			return NULL;
		return &it->second;
	}

	CSymbolModule *CSymbolContainer::InsertModule(unsigned int TimeStamp, unsigned int CheckSum) //04
	{
		unsigned long long key = ((unsigned long long)CheckSum)<<32|TimeStamp;
		map<unsigned long long, CSymbolModule>::IT it =
			m_SymbolModulesMap.insert(
				_Tmap_pair<unsigned long long, CSymbolModule>(key, CSymbolModule()));
		if (!it)
			return NULL;
		it->second.m_TimeStamp = TimeStamp;
		it->second.m_CheckSum = CheckSum;
		return &it->second;
	}

	bool CSymbolContainer::RemoveModule(unsigned int TimeStamp, unsigned int CheckSum) //08
	{
		unsigned long long key = ((unsigned long long)CheckSum)<<32|TimeStamp;
		return m_SymbolModulesMap.erase(key) > 0;
	}

	void CSymbolContainer::Reset() //0C
	{
		map<unsigned long long, CSymbolModule>::IT it = m_SymbolModulesMap.begin();
		//for (; it != m_SymbolModulesMap.end(); )
		while (it)
		{
			if(it->second.m_RefCount > 0)
				++it;
			else
				m_SymbolModulesMap.erase(it++);
		}
	}

	bool CSymbolContainer::GetFullSymbol(ULONG_PTR Address, char *SymbolName, int Limit) //10
	{
		map<unsigned long long, CSymbolModule>::IT it = m_SymbolModulesMap.begin();
		//for (; it != m_SymbolModulesMap.end(); ++it)
		while (it)
		{
			if (it->second.m_ImageBase != 0 &&
				Address >= it->second.m_ImageBase &&
				Address < it->second.m_ImageBase+it->second.m_ImageSize)
			{
				map<ULONG_PTR, TAnsiNoCaseString>::IT si = it->second.m_SymbolMap.find(Address-it->second.m_ImageBase);
				if (si != it->second.m_SymbolMap.end())
				{
					int n = TGetFileTitle(it->second.m_ModuleName.operator const char*(), SymbolName);
					n += TStrCpy(SymbolName+n, "_");
					TStrCpyLimit(SymbolName+n, si->second.operator const char*(), Limit-n);
					return true;
				}
			}
			++it;
		}
		return false;
	}

	const char *CSymbolContainer::GetSymbol(ULONG_PTR Address) //14
	{
		map<unsigned long long, CSymbolModule>::IT it = m_SymbolModulesMap.begin();
		//for (; it != m_SymbolModulesMap.end(); ++it)
		while (it)
		{
			if (it->second.m_ImageBase != 0 &&
				Address >= it->second.m_ImageBase &&
				Address < it->second.m_ImageBase+it->second.m_ImageSize)
			{
				map<ULONG_PTR, TAnsiNoCaseString>::IT si = it->second.m_SymbolMap.find(Address-it->second.m_ImageBase);
				if (si != it->second.m_SymbolMap.end())
				{
					return si->second.operator const char*();
				}
			}
			++it;
		}
		return NULL;
	}
	

// CCommentContainer

	CCommentModule *CCommentContainer::FindModule(unsigned int TimeStamp, unsigned int CheckSum) //00 TimeStamp,CheckSum
	{
		unsigned long long key = ((unsigned long long)CheckSum)<<32|TimeStamp;
		map<unsigned long long, CCommentModule>::IT it = m_CommentModulesMap.find(key);
		//if (it == m_CommentModulesMap.end())
		if (!it)
			return NULL;
		return &it->second;
	}

	CCommentModule *CCommentContainer::InsertModule(unsigned int TimeStamp, unsigned int CheckSum) //04
	{
		unsigned long long key = ((unsigned long long)CheckSum)<<32|TimeStamp;
		map<unsigned long long, CCommentModule>::IT it =
			m_CommentModulesMap.insert(
				_Tmap_pair<unsigned long long, CCommentModule>(key, CCommentModule()));
		if (!it)
			return NULL;
		it->second.m_TimeStamp = TimeStamp;
		it->second.m_CheckSum = CheckSum;
		return &it->second;
	}

	bool CCommentContainer::RemoveModule(unsigned int TimeStamp, unsigned int CheckSum) //08
	{
		unsigned long long key = ((unsigned long long)CheckSum)<<32|TimeStamp;
		return m_CommentModulesMap.erase(key) > 0;
	}

	void CCommentContainer::Reset() //0C
	{
		map<unsigned long long, CCommentModule>::IT it = m_CommentModulesMap.begin();
		//for (; it != m_CommentModulesMap.end(); )
		while (it)
		{
			if(it->second.m_RefCount > 0)
				++it;
			else
				m_CommentModulesMap.erase(it++);
		}
	}
	
	unsigned long CCommentContainer::Write(ALT::ALTFileStream &File)
	{
		unsigned long TotalLen = 0;
		unsigned long Len;
		unsigned long SIG = 0x1000;
		Len = File.Write(&SIG, 4);
		TotalLen += Len;
		unsigned long Count = m_CommentModulesMap.size();
		Len = File.Write(&Count, 4);
		TotalLen += Len;
		for (map<unsigned long long, CCommentModule>::IT it = m_CommentModulesMap.begin();
			it != m_CommentModulesMap.end(); ++it)
		{
			Len = File.Write(&it->first, sizeof(it->first));
			TotalLen += Len;
			Len = it->second.Write(File);
			TotalLen += Len;
		}
		return TotalLen;
	}

	unsigned long CCommentContainer::Read(ALT::ALTFileStream &File)
	{
		unsigned long TotalLen = 0;
		unsigned long Len;
		unsigned long SIG;
		Len = File.Read(&SIG, 4);
		if (Len != 4 || SIG != 0x1000) return 0;
		TotalLen += Len;
		unsigned long Count;
		Len = File.Read(&Count, 4);
		if (Len == 0 || Count > 0x10000) return 0;
		TotalLen += Len;
		//map<unsigned long long, CCommentModule>::IT it;
		while (Count>0)
		{
			unsigned long long Key;
			Len = File.Read(&Key, sizeof(Key));
			if (Len == 0) return 0;
			TotalLen += Len;
			map<unsigned long long, CCommentModule>::IT it = m_CommentModulesMap.insert(_Tmap_pair<unsigned long long, CCommentModule>(Key, CCommentModule()));
			if (it == m_CommentModulesMap.end()) return 0;
			it->second.m_TimeStamp = Key;
			it->second.m_CheckSum = Key>>32;
			Len = it->second.Read(File);
			if (Len == 0)
			{
				m_CommentModulesMap.erase(it);
				return 0;
			}
			TotalLen += Len;
			--Count;
		}
		return TotalLen;
	}

//CDbgModule

	CDbgModule::CDbgModule()
		: m_pSymbolModule(nullptr)
		, m_pCommentModule(nullptr)
		, m_pName(nullptr)
		, m_ImageBase(0)
		, m_ImageSize(0)
		, m_TimeStamp(0)
		, m_CheckSum(0)
		, m_LoadPDB(true)
	{
	}

	bool CDbgModule::GetSymbolAddress(const char *szName, ULONG_PTR *pAddress) //00
	{
		if (!m_pSymbolModule)
			return false;

		for (map<ULONG_PTR, TAnsiNoCaseString>::IT it = m_pSymbolModule->m_SymbolMap.begin();
			it != m_pSymbolModule->m_SymbolMap.end(); ++it)
		{
			if (it->second == szName)
			{
				if (pAddress)
					*pAddress = it->first;
				return true;
			}
		}
		return false;
	}

	bool CDbgModule::GetSymboBaseAddr(const char *szName, ULONG_PTR *pAddress) //04
	{
		if (!GetSymbolAddress(szName, pAddress))
			return false;
		if (pAddress)
			*pAddress += m_ImageBase;
		return true;
	}

	bool CDbgModule::GetFullSymbol(ULONG_PTR Address, char *szName, unsigned int Len) //08
	{
		if (!m_pSymbolModule)
			return false;
		map<ULONG_PTR, TAnsiNoCaseString>::IT it =
			m_pSymbolModule->m_SymbolMap.find(Address-m_ImageBase);
		if (it == m_pSymbolModule->m_SymbolMap.end())
			return false;

		int n = TStrCpyLimit(szName, m_FileTitle.operator const char*(), Len);
		char *nextStr = szName+n;
		int nextLen = Len-n;
		if (nextLen <= 0)
			return false;
		if (m_FileTitle.m_nLength)
		{
			n = TStrCpyLimit(nextStr, "_", nextLen);
			nextStr += n;
			nextLen -= n;
			if (nextLen <= 0)
				return false;
		}
		TStrCpyLimit(nextStr, it->second.operator const char*(), nextLen);
		return true;
	}

	const char *CDbgModule::GetSymbol(ULONG_PTR Address)
	{
		if (!m_pSymbolModule)
			return NULL;
		map<ULONG_PTR, TAnsiNoCaseString>::IT it =
			m_pSymbolModule->m_SymbolMap.find(Address-m_ImageBase);
		if (it == m_pSymbolModule->m_SymbolMap.end())
			return NULL;
		return it->second;
	}

	const char *CDbgModule::GetComment(ULONG_PTR Address)
	{
		if (!m_pCommentModule)
			return NULL;
		map<ULONG_PTR, TAnsiString>::IT it =
			m_pCommentModule->m_CommentMap.find(Address-m_ImageBase);
		if (it == m_pCommentModule->m_CommentMap.end())
			return NULL;
		return it->second;
	}

	bool CDbgModule::GetSymbolBase(ULONG_PTR *pAddress) //14
	{
		if (!m_pSymbolModule)
			return false;
		map<ULONG_PTR, TAnsiNoCaseString>::IT it = m_pSymbolModule->m_SymbolMap.find_near(*pAddress-m_ImageBase);
		if (it == m_pSymbolModule->m_SymbolMap.end())
			return false;
		*pAddress = m_ImageBase + it->first; //???
		return true;
	}

	void CDbgModule::SetSymbolModule(CSymbolModule *pSymbolModule) //18
	{
		m_pSymbolModule = pSymbolModule;
		if (m_pSymbolModule)
			++m_pSymbolModule->m_RefCount;
	}

	void CDbgModule::RemoveSymbolModule(CSymbolContainer *pSymbolContainer) //1C
	{
		if (m_pSymbolModule)
		{
			--m_pSymbolModule->m_RefCount;
			if (pSymbolContainer)
			{
				if (m_pSymbolModule->m_RefCount <= 0)
					pSymbolContainer->RemoveModule(
						m_pSymbolModule->m_TimeStamp,
						m_pSymbolModule->m_CheckSum);
			}
			m_pSymbolModule = NULL;
		}
	}

	void CDbgModule::SetCommentModule(CCommentModule *pCommentModule) //20
	{
		m_pCommentModule = pCommentModule;
		if (m_pCommentModule)
			++m_pCommentModule->m_RefCount;
	}

	void CDbgModule::RemoveCommentModule(CCommentContainer *pCommentContainer) //24
	{
		if (m_pCommentModule)
		{
			--m_pCommentModule->m_RefCount;
			if (pCommentContainer)
			{
				if (m_pCommentModule->m_RefCount <= 0)
					pCommentContainer->RemoveModule(
						m_pCommentModule->m_TimeStamp,
						m_pCommentModule->m_CheckSum);
			}
			m_pCommentModule = NULL;
		}
	}
	

// CDbgModuleList

	CDbgModule *CDbgModuleList::FindModule(ULONG_PTR Address) //00
	{
		map<CMemoryImage, CDbgModule>::IT it = m_DbgModuleMap.find(CMemoryImage(Address));
		if (it == m_DbgModuleMap.end())
			return NULL;
		return &it->second;
	}

	CDbgModule *CDbgModuleList::FindModule(const char *szName) //04
	{
		for (map<CMemoryImage, CDbgModule>::IT it = m_DbgModuleMap.begin();
			it != m_DbgModuleMap.end(); ++it)
		{
			if (TCmpModuleName(it->second.m_FullFileName.operator const char*(), szName))
				return &it->second;
		}

		char *pStr = TStrRChr(szName, '\\');
		if (!pStr) return NULL;

		for (map<CMemoryImage, CDbgModule>::IT its = m_DbgModuleMap.begin();
			its != m_DbgModuleMap.end(); ++its)
		{
			if (TCmpModuleName(its->second.m_FullFileName.operator const char*(), pStr))
				return &its->second;
		}
		return NULL;
	}

	CDbgModule *CDbgModuleList::FindModule(unsigned long TimeStamp, unsigned long CheckSum) //08
	{
		for (map<CMemoryImage, CDbgModule>::IT it = m_DbgModuleMap.begin();
			it != m_DbgModuleMap.end(); ++it)
		{
			if (it->second.m_TimeStamp == TimeStamp &&
			    it->second.m_CheckSum == CheckSum)
				return &it->second;
		}
		return NULL;
	}

	CDbgModule *CDbgModuleList::InsertModule(const char *szModule, ULONG_PTR Address, unsigned long Size, unsigned long TimeStamp, unsigned long CheckSum)
	{
		map<CMemoryImage, CDbgModule>::IT it =
				m_DbgModuleMap.insert(_Tmap_pair<CMemoryImage, CDbgModule>(
					CMemoryImage(Address, Address+Size-1), CDbgModule()));
		if (it == m_DbgModuleMap.end())
			return NULL;
		it->second.m_ImageBase = Address;
		it->second.m_ImageSize = Size;
		it->second.m_FullFileName = szModule;
		it->second.m_TimeStamp = TimeStamp;
		it->second.m_CheckSum = CheckSum;
		char FileTitle[268]; //TODO 260 MAX_FN_LEN
		TGetFileTitle(szModule, FileTitle);
		it->second.m_FileTitle = FileTitle;
		it->second.m_pName = TGetFileName(it->second.m_FullFileName.operator const char*()); //???
		return &it->second;
	}

	bool CDbgModuleList::RemoveModule(ULONG_PTR Address) //10
	{
		map<CMemoryImage, CDbgModule>::IT it = m_DbgModuleMap.find(CMemoryImage(Address));
		if (it == m_DbgModuleMap.end())
			return false;
		if (it->second.m_pSymbolModule)
			--it->second.m_pSymbolModule->m_RefCount;
		m_DbgModuleMap.erase(it);
		return true;
	}

	bool CDbgModuleList::GetFullSymbol(ULONG_PTR Address, char *szName, int Len) //14
	{
		map<CMemoryImage, CDbgModule>::IT it = m_DbgModuleMap.find(CMemoryImage(Address));
		if (it == m_DbgModuleMap.end())
			return false;
		return it->second.GetFullSymbol(Address, szName, Len);
	}

	const char *CDbgModuleList::GetSymbol(ULONG_PTR Address) //18
	{
		map<CMemoryImage, CDbgModule>::IT it = m_DbgModuleMap.find(CMemoryImage(Address));
		if (it == m_DbgModuleMap.end())
			return NULL;
		return it->second.GetSymbol(Address);
	}

	bool CDbgModuleList::GetSymbolBase(ULONG_PTR *pAddress) //1C
	{
		map<CMemoryImage, CDbgModule>::IT it = m_DbgModuleMap.find(CMemoryImage(*pAddress));
		if (it == m_DbgModuleMap.end())
			return false;
		return it->second.GetSymbolBase(pAddress);
	}

	const char *CDbgModuleList::GetComment(ULONG_PTR Address) //20
	{
		map<CMemoryImage, CDbgModule>::IT it = m_DbgModuleMap.find(CMemoryImage(Address));
		if (it == m_DbgModuleMap.end())
			return NULL;
		return it->second.GetComment(Address);
	}

```

`source/EXEAnalyzer/symbol.hpp`:

```hpp

#ifndef _SYMBOL_HPP_
#define _SYMBOL_HPP_

#include "../Code/alt/altmap.hpp"
#include "../Code/alt/altfile.hpp"
#include "../Code/tstrmem.hpp"
#include "../Code/pageimage.hpp"

	struct CSymbolModule
	{
		int field_4;
		ULONG_PTR m_ImageBase;
		unsigned long m_ImageSize;
		map<ULONG_PTR, TAnsiNoCaseString> m_SymbolMap;
		TAnsiNoCaseString m_ModuleName;
		int m_RefCount;
		int _field_44;
		unsigned long m_TimeStamp;
		unsigned long m_CheckSum;

		CSymbolModule();// {}

		virtual bool Add(ULONG_PTR Address, const char *Name); //00
		virtual bool Set(ULONG_PTR Address, const char *Name); //04
		virtual int Del(const char *Name); //08
		virtual bool Del(ULONG_PTR Address); //0C

		virtual bool GetAddr(const char *Name, ULONG_PTR *pAddress); //10
	};

	struct CCommentModule
	{
		int field_4;
		map<ULONG_PTR, TAnsiString> m_CommentMap;
		TAnsiString m_ModuleName;
		int m_RefCount;
		int _field_3C;
		unsigned long m_TimeStamp;
		unsigned long m_CheckSum;

		CCommentModule();// {}

		virtual bool Add(ULONG_PTR Address, const char *Name); //00
		virtual bool Set(ULONG_PTR Address, const char *Name); //04
		virtual bool Del(ULONG_PTR Address); //08

		unsigned long Write(ALT::ALTFileStream &File);
		unsigned long Read(ALT::ALTFileStream &File);
	};


	struct CSymbolContainer
	{
		map<unsigned long long, CSymbolModule> m_SymbolModulesMap;
	public:
		CSymbolContainer() {}

		virtual CSymbolModule *FindModule(unsigned int TimeStamp, unsigned int CheckSum); //00
		virtual CSymbolModule *InsertModule(unsigned int TimeStamp, unsigned int CheckSum); //04
		virtual bool RemoveModule(unsigned int TimeStamp, unsigned int CheckSum); //08
		virtual void Reset(); //0C

		virtual bool GetFullSymbol(ULONG_PTR Address, char *SymbolName, int Limit); //10
		virtual const char *GetSymbol(ULONG_PTR Address); //14
	};

	struct CCommentContainer
	{
		map<unsigned long long, CCommentModule> m_CommentModulesMap;
	public:
		CCommentContainer() {}

		virtual CCommentModule *FindModule(unsigned int TimeStamp, unsigned int CheckSum); //00 TimeStamp,CheckSum
		virtual CCommentModule *InsertModule(unsigned int TimeStamp, unsigned int CheckSum); //04
		virtual bool RemoveModule(unsigned int TimeStamp, unsigned int CheckSum); //08
		virtual void Reset(); //0C

		unsigned long Write(ALT::ALTFileStream &File);
		unsigned long Read(ALT::ALTFileStream &File);
	};

	struct CDbgModule
	{
		int field_4;
		CSymbolModule *m_pSymbolModule;
		CCommentModule *m_pCommentModule;
		TAnsiNoCaseString m_FullFileName; //m_ModuleFullName
		TAnsiNoCaseString m_FileTitle;
		char *m_pName;
		ULONG_PTR m_ImageBase;
		unsigned long m_ImageSize;
		int XXXXXX__field_3C;
		unsigned long m_TimeStamp;
		unsigned long m_CheckSum;
		bool m_LoadPDB;
	public:
		CDbgModule();// {}

		virtual bool GetSymbolAddress(const char *szName, ULONG_PTR *Address); //00
		virtual bool GetSymboBaseAddr(const char *szName, ULONG_PTR *Address); //04
		virtual bool GetFullSymbol(ULONG_PTR Address, char *szName, unsigned int Len); //08

		virtual const char *GetSymbol(ULONG_PTR Address);
		virtual const char *GetComment(ULONG_PTR Address);

		virtual bool GetSymbolBase(ULONG_PTR *Address); //14

		virtual void SetSymbolModule(CSymbolModule *pSymbolModule); //18
		virtual void RemoveSymbolModule(CSymbolContainer *pSymbolContainer); //1C

		virtual void SetCommentModule(CCommentModule *pCommentModule); //20
		virtual void RemoveCommentModule(CCommentContainer *pCommentContainer); //24
	};

	struct CDbgModuleList
	{
		map<CMemoryImage, CDbgModule> m_DbgModuleMap;
	public:
		CDbgModuleList() {}

		virtual CDbgModule *FindModule(ULONG_PTR Address); //00 GetModule
		virtual CDbgModule *FindModule(const char *szName); //04 GetModule
		virtual CDbgModule *FindModule(unsigned long TimeStamp, unsigned long CheckSum); //08 GetModule
		virtual CDbgModule *InsertModule(const char *szModule, ULONG_PTR Address, unsigned long Size, unsigned long TimeStamp, unsigned long CheckSum);
		virtual bool RemoveModule(ULONG_PTR Address); //10
		virtual bool GetFullSymbol(ULONG_PTR Address, char *szName, int Len); //14
		virtual const char *GetSymbol(ULONG_PTR Address); //18
		virtual bool GetSymbolBase(ULONG_PTR *Address); //1C
		virtual const char *GetComment(ULONG_PTR Address); //20
	};


#endif

```

`source/EXEAnalyzer/x86debugger.cpp`:

```cpp

#include "x86debugger.hpp"
#include "inteldis.hpp"

	CX86Debugger::CX86Debugger()
	{
	#ifdef _X64_
		m_CodeMode = CODE_MODE_64;
	#else
		m_CodeMode = CODE_MODE_32;
	#endif
	}

	CX86Debugger::~CX86Debugger()
	{
	}

	void CX86Debugger::GetX86RegPtr(X86_CPU_REG_PTR *pCPURegPtr) { }
	void CX86Debugger::GetX86RegPtr(X86_CPU_REG_PTR *pCPURegPtr, int nCPU) { }

	bool CX86Debugger::GetSegRegBase(unsigned long Selector, ULONG_PTR *pAddress, unsigned long *pBits) { return false; }

	bool CX86Debugger::SetX86CodeBreakPoint(BREAK_POINT & BP)
	{
		static const unsigned char int3[] = { 0xCC };

		if (BP.State == BP_STATE_ENABLE)
			return true;

		if (!ReadMemory(BP.Address, (void*)&BP.CCBackup, 1))
			return false;

		if (BP.CCBackup == 0xCC)
			return false;

		return WriteMemory(BP.Address, int3, 1) != 0;
	}

	bool CX86Debugger::ClearX86CodeBreakPoint(BREAK_POINT & BP)
	{
		if (BP.State == BP_STATE_RECOV || BP.State == BP_STATE_DISABLE)
			return true;

		return WriteMemory(BP.Address, (void *)&BP.CCBackup, 1) != 0;
	}


	bool CX86Debugger::SetRecoverBP(BREAK_POINT & BP)
	{
		static const unsigned char int3[] = { 0xCC };

		unsigned char CCBackup;

		if (BP.State != BP_STATE_RECOV)
			return false;

		if (!ReadMemory(BP.Address, &CCBackup, 1))
				return false;

		if (CCBackup != BP.CCBackup)
				return false;

		return WriteMemory(BP.Address, int3, 1) != 0;
	}

	bool CX86Debugger::SetX86DataBreakPoint(BREAK_POINT & BP, ULONG_PTR DRx[], ULONG_PTR *pDR7)
	{
		unsigned long EnableGL = 3; //G,L
		unsigned long DRIndex = 0;
		while (DRIndex < 4)
		{
			if (!(EnableGL & *pDR7))
				break;
			EnableGL *= 4;
			++DRIndex;
		}

		if (DRIndex >= 4)
			return false;

		unsigned long Type = 0;

		if (BP.Type & 0x30)
		{
			Type = 2;
			BP.TypeName = "IO";
		}

		if (BP.Type & 2)
		{
			Type = 0;
			BP.TypeName = "X";
		}

		if ((BP.Type & 4) && !(BP.Type & 8))
		{
			Type = 1;
			BP.TypeName = "W";

		} else
		if (BP.Type & 0xC)
		{
			Type = 3;
			BP.TypeName = "RW";
		}

		if (BP.Size == 1)
		{
			Type |= 0; //0<<2
		} else
		if (BP.Size == 2)
		{
			Type |= 4; //1<<2
		} else
		if (BP.Size == 4)
		{
			Type |= 0xC; //2<<2
		} else
		if ( !(BP.Type & 2) )
		{
			Type |= 8; //
		}

		*(unsigned long*)pDR7 &= ~(EnableGL | (((unsigned long)0xF) << (4 * DRIndex + 16)) | 0xDF00); //11011 1 11 0000 0000
		*(unsigned long*)pDR7 |= (EnableGL | (Type << (4 * DRIndex + 16)) | 0x700); //       1 11 0000 0000
		DRx[DRIndex] = BP.Address;
		BP.X86_DR.DRIndex = DRIndex;
		UpdateRegisters();
		return true;
	}

	bool CX86Debugger::ClearX86DataBreakPoint(BREAK_POINT & BP, ULONG_PTR DRx[], ULONG_PTR *pDR7)
	{
		unsigned long DRIndex = 0;
		while (DRIndex < 4)
		{
			if (DRx[DRIndex] == BP.Address)
				break;
			++DRIndex;
		}

		if (DRIndex < 4)
		{

			*(unsigned long*)pDR7 &= ~((((unsigned long)3) << (2 * DRIndex)) | (((unsigned long)0xF) << (4 * DRIndex + 16)) | 0xDF00);

			if (*pDR7 & 0xFF)
				*pDR7 |= 0x700; //1 11 0000 0000
			DRx[DRIndex] = 0;
		}
		return true;
	}

	bool CX86Debugger::Halt(unsigned long Type)
	{
		if (Type & 0xE000)
		{
			for (unsigned int i = 1; ; i *= 2)
			{
				//???
			}
		}
		return false;
	}

	bool CX86Debugger::IsRecoverBreakPoint()
	{
		map<unsigned long long, BREAK_POINT>::IT it = m_pCodeBPMap->begin();
		//for (; it != m_pCodeBPMap->end(); ++it)
		while (it)
		{
			if (it->second.State == BP_STATE_RECOV)
				return true;
			++it;
		}
		return false;
	}

	unsigned int CX86Debugger::RecoverBreakPoint()
	{
		unsigned int Count = 0;

		map<unsigned long long, BREAK_POINT>::IT it = m_pCodeBPMap->begin();
		//for (; it != m_pCodeBPMap->end(); ++it)
		while (it)
		{
			if (it->second.State == BP_STATE_RECOV)
			{
				if (OpenProcess(it->second.ProcessID))
				{
					if (SetRecoverBP(it->second))
						it->second.State = BP_STATE_ENABLE;
					CloseProcess();
				}
				++Count;
			}
			++it;
		}
		return Count;
	}


```

`source/EXEAnalyzer/x86debugger.hpp`:

```hpp

#ifndef _X86DEBUGGER_HPP_
#define _X86DEBUGGER_HPP_

#include "debugger.hpp"

	struct EFL_REG
	{
		unsigned long CF : 1;
		unsigned long b1 : 1;
		unsigned long PF : 1;
		unsigned long b3 : 1;

		unsigned long AF : 1;
		unsigned long b5 : 1;
		unsigned long ZF : 1;
		unsigned long SF : 1;

		unsigned long TF : 1;
		unsigned long IF : 1;
		unsigned long DF : 1;
		unsigned long OF : 1;

		unsigned long IOPL : 2;
		unsigned long NT : 1;
		unsigned long bf : 1;

		unsigned long RF : 1;
		unsigned long VM : 1;
		unsigned long AC : 1;
		unsigned long VIF : 1;

		unsigned long VIP : 1;
		unsigned long ID : 1;
		unsigned long _22_23 : 2;

		unsigned long _24_31 : 8;
	};

	struct stFPU_STATUS_REG
	{
		unsigned short IE : 1;
		unsigned short DE : 1;
		unsigned short ZE : 1;
		unsigned short OE : 1;
		unsigned short UE : 1;
		unsigned short PE : 1;
		unsigned short SF : 1;
		unsigned short ES : 1;
		unsigned short C0 : 1;
		unsigned short C1 : 1;
		unsigned short C2 : 1;
		unsigned short TOP : 3;
		unsigned short C3 : 1;
		unsigned short B : 1;
	};

	struct stFPU_CONTROL_REG
	{
		unsigned short IM : 1;
		unsigned short DM : 1;
		unsigned short ZM : 1;
		unsigned short OM : 1;
		unsigned short UM : 1;
		unsigned short PM : 1;
		unsigned short Reserved1 : 2;
		unsigned short PC : 2;
		unsigned short RC : 2;
		unsigned short X : 1;
		unsigned short Reserved2 : 3;
	};

	struct stFPU_TAG_REG
	{
		unsigned short TAG0 : 2;
		unsigned short TAG1 : 2;
		unsigned short TAG2 : 2;
		unsigned short TAG3 : 2;
		unsigned short TAG4 : 2;
		unsigned short TAG5 : 2;
		unsigned short TAG6 : 2;
		unsigned short TAG7 : 2;
	};

	struct X86_CPU_REG
	{
		ULONG_PTR CAX;
		ULONG_PTR CBX;
		ULONG_PTR CCX;
		ULONG_PTR CDX;
		ULONG_PTR CDI;
		ULONG_PTR CSI;
		ULONG_PTR CBP;
		ULONG_PTR CSP;
	#ifdef _X64_
		ULONG_PTR R8;
		ULONG_PTR R9;
		ULONG_PTR R10;
		ULONG_PTR R11;
		ULONG_PTR R12;
		ULONG_PTR R13;
		ULONG_PTR R14;
		ULONG_PTR R15;
	#endif
		ULONG_PTR CIP;
	//???	EFL_REG EFL;
		unsigned long EFL;
		unsigned short CS;
		unsigned short DS;
		unsigned short ES;
		unsigned short FS;
		unsigned short GS;
		unsigned short SS;
		ULONG_PTR DR0;
		ULONG_PTR DR1;
		ULONG_PTR DR2;
		ULONG_PTR DR3;
		ULONG_PTR DR4;
		ULONG_PTR DR5;
		ULONG_PTR DR6;
		ULONG_PTR DR7;
	};

	struct DECLSPEC_ALIGN(16) XMMREG
	{
		unsigned long long Low;
		long long High;
	};

	struct YMMREG
	{
		XMMREG Low; //XMM/SSE
		XMMREG High; //AVX
	};

	struct X86_CPU_REG_PTR
	{
		ULONG_PTR *pCAX;
		ULONG_PTR *pCBX;
		ULONG_PTR *pCCX;
		ULONG_PTR *pCDX;
		ULONG_PTR *pCDI;
		ULONG_PTR *pCSI;
		ULONG_PTR *pCBP;
		ULONG_PTR *pCSP;
	#ifdef _X64_
		ULONG_PTR *pR8;
		ULONG_PTR *pR9;
		ULONG_PTR *pR10;
		ULONG_PTR *pR11;
		ULONG_PTR *pR12;
		ULONG_PTR *pR13;
		ULONG_PTR *pR14;
		ULONG_PTR *pR15;
	#endif
		ULONG_PTR *pCIP;
		EFL_REG *pEFL;
		unsigned short *pCS;
		unsigned short *pDS;
		unsigned short *pES;
		unsigned short *pFS;
		unsigned short *pGS;
		unsigned short *pSS;
		ULONG_PTR *pDR0;
		ULONG_PTR *pDR1;
		ULONG_PTR *pDR2;
		ULONG_PTR *pDR3;
		ULONG_PTR *pDR4;
		ULONG_PTR *pDR5;
		ULONG_PTR *pDR6;
		ULONG_PTR *pDR7;
	#ifdef _RING0_
		unsigned long *pGDT;
		unsigned long *pGDTLimit;
		unsigned long *pIDT;
		unsigned long *pIDTLimit;
		unsigned long *pLDT;
		unsigned long *pTSS;
		unsigned long *pCR2;
	#endif
		stFPU_CONTROL_REG *FP_ControlWord;
		stFPU_STATUS_REG *FP_StatusWord;
		stFPU_TAG_REG *FP_TagWord;
		unsigned char *FP_RegisterArea; //MMX low 8 byte as "unsigned long long" 8-x86,16-x64
		void *pXMM; //8-x32/16-x64
		void *pYMM; //8-x32/16-x64

	#ifdef _X64_
		unsigned char *GetFPU(unsigned long Index)
			{ return (unsigned char*)FP_RegisterArea + (Index*16); }
	#else
		unsigned char *GetFPU(unsigned long Index)
			{ return (unsigned char*)FP_RegisterArea + (Index*10); }
	#endif

	#ifdef _X64_
		unsigned long *GetXMM(unsigned long Index)
			{ return (unsigned long*)pXMM + Index*4; }
	#else
		unsigned long *GetXMM(unsigned long Index)
			{ return (unsigned long*)((unsigned char*)pXMM + (Index+10)*16); }
	#endif
	};

	struct CX86Debugger : public CDebugger
	{
		unsigned int m_CodeMode;

	public:
		CX86Debugger();
		virtual ~CX86Debugger();

		virtual void GetX86RegPtr(X86_CPU_REG_PTR *pCPURegPtr); // { }
		virtual void GetX86RegPtr(X86_CPU_REG_PTR *pCPURegPtr, int nCPU); // { }

		virtual bool GetSegRegBase(unsigned long Selector, ULONG_PTR *pAddress, unsigned long *pLimit); // { return false; }

		virtual bool SetX86CodeBreakPoint(BREAK_POINT & BP);
		virtual bool ClearX86CodeBreakPoint(BREAK_POINT & BP);

		virtual bool SetRecoverBP(BREAK_POINT & BP);

		virtual bool SetX86DataBreakPoint(BREAK_POINT & BP, ULONG_PTR DRx[], ULONG_PTR *pDR7);
		virtual bool ClearX86DataBreakPoint(BREAK_POINT & BP, ULONG_PTR DRx[], ULONG_PTR *pDR7);

		virtual bool Halt(unsigned long Type);

		virtual bool IsRecoverBreakPoint();
		virtual unsigned int RecoverBreakPoint();
	};

#endif

```

`source/MFCSymbols.cpp`:

```cpp

#include <stdlib.h>
#include <stdio.h>

#include "Code/define.h"
#include "Code/tstrmem.hpp"
#include "Code/sysdep.hpp"
#include "Code/fileiont.hpp"

int Find(CFileIO *This, const char *FullFileName, int FileLength, void *pData)
{
	char *Txt = (char*)pData;

	char szModuleName[MAX_FN_LEN];
	//::GetSystemDirectoryA(szModuleName, MAX_FN_LEN);
	GetModulePath(szModuleName, true); //+++

	HANDLE Handle;
	if (!gpFileIO->OpenFile(FullFileName, &Handle, 0x10000))
		return 0;

	unsigned long long Size = gpFileIO->GetFileLength(Handle);
	unsigned long *Sym = (unsigned long *)new char[Size];
	gpFileIO->ReadFile(Handle, Sym, Size, 0);
	gpFileIO->CloseHandle(Handle);

	FullFileName = TGetFileName(FullFileName);
	//TStrCat(szModuleName, "\\drivers\\plugin\\");
	TStrCat(szModuleName, FullFileName);

	char *pStr = TStrIStr(szModuleName, ".sym");
	if (pStr) *pStr = 0;

	FILE *f = fopen(szModuleName, "w");
	if (!f)
	{
		delete [](char*)Sym;
		return 0;
	}
	unsigned long Count = Sym[0];
	unsigned long FuncOrd = Sym[1];

	for (unsigned long n = 0; n < Count; ++n)
	{
		if (Txt[Sym[n+2]])
		{
			fprintf(f,"%d %s\n",FuncOrd+n, &Txt[Sym[n+2]]);
			fflush(f);
		}
	}
	
	fclose(f);

	delete [](char*)Sym;
	return 0;
}

int main()
{
	::FreeConsole();

	char szMfcSymFile[MAX_FN_LEN];
	GetModulePath(szMfcSymFile, true);
	TStrCat(szMfcSymFile, "mfcsym.txt");

	HANDLE Handle;
	if (!gpFileIO->OpenFile(szMfcSymFile, &Handle, 0x10000))
		return 1;

	char *pStr = TStrRChr(szMfcSymFile, '\\');
	if (pStr && *pStr == '\\')
		*pStr = 0;
	//char *pStr = TGetFileName(szMfcSymFile);
	//if (pStr)
	//	*pStr = 0;
	else	::GetCurrentDirectoryA(MAX_FN_LEN, szMfcSymFile);

	TStrCat(szMfcSymFile, "\\*.sym");

	unsigned long long Size = gpFileIO->GetFileLength(Handle);
	char *Txt = new char[Size];

	gpFileIO->ReadFile(Handle, Txt, Size, 0);
	gpFileIO->CloseHandle(Handle);

	gpFileIO->XFind(szMfcSymFile, Find, Txt, false, nullptr); //???

	delete []Txt;
	return 0;
}

```

`source/Wisp/dibdata.cpp`:

```cpp

	unsigned long BTCaret[24] =
	{
		0,
		0,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0x0FFFFFF,
		0,
		0,
	};

```

`source/Wisp/utility.cpp`:

```cpp

#include "utility.hpp"
#include "../Code/tstrmem.hpp"

bool ClipXLine(int *pX1, int *pX2, int *pY1, const WISP_RECT *pRect)
{
	if (*pX1 < pRect->x && *pX2 < pRect->x)
		return false;

	if (*pX1 >= pRect->x2() && *pX2 >= pRect->x2())
		return false;

	if (*pY1 < pRect->y)
		return false;

	if (*pY1 >= pRect->y2())
		return false;

	*pX1 = CLAMP(*pX1, pRect->x, pRect->x2() - 1);
	*pX2 = CLAMP(*pX2, pRect->x, pRect->x2() - 1);
	
	return *pX1 != *pX2;
}

bool ClipYLine(int *pX1, int *pY1, int *pY2, const WISP_RECT *pRect)
{
	if (*pY1 < pRect->y && *pY2 < pRect->y)
		return false;

	if (*pY1 >= pRect->y2() && *pY2 >= pRect->y2())
		return false;

	if (*pX1 < pRect->x)
		return false;

	if (*pX1 >= pRect->x2())
		return false;

	*pY1 = CLAMP(*pY1, pRect->y, pRect->y2() - 1);
	*pY2 = CLAMP(*pY2, pRect->y, pRect->y2() - 1);
	
	return *pY1 != *pY2;
}

void ClipPointX(int *pX, int *pY, const WISP_RECT *pRect, int deltaX, int deltaY)
{
	if (*pX < pRect->x)
	{
		int delta = pRect->x - *pX;
		*pX = pRect->x;
		*pY += (delta * ((deltaY << 16) / deltaX)) >> 16;
	} else
	if (*pX > pRect->x2() - 1)
	{
		int delta = pRect->x2() - 1 - *pX;
		*pX = pRect->x2() - 1;
		*pY += (delta * ((deltaY << 16) / deltaX)) >> 16;
	}
}

void ClipPointY(int *pX, int *pY, const WISP_RECT *pRect, int deltaX, int deltaY)
{
	if (*pY >= pRect->y)
	{
		int delta = pRect->y - *pY;
		*pY = pRect->y;
		*pX += (delta * ((deltaX << 16) / deltaY)) >> 16;
	} else
	if (*pY > pRect->y2() - 1)
	{
		int delta = pRect->y2() - 1 - *pY;
		*pY = pRect->y2() - 1;
		*pX += (delta * ((deltaX << 16) / deltaY)) >> 16;
	}
}

bool ClipLine(int *pX1, int *pY1, int *pX2, int *pY2, const WISP_RECT *pRect)
{
	if (*pX1 == *pX2)
		return ClipYLine(pX1, pY1, pY2, pRect);
	if (*pY1 == *pY2)
		return ClipXLine(pX1, pX2, pY1, pRect);

	if (*pX1 < pRect->x && *pX2 < pRect->x)
		return false;
	if (*pX1 >= pRect->x2() && *pX2 >= pRect->x2())
		return false;
	if (*pY1 < pRect->y && *pY2 < pRect->y)
		return false;
	if (*pY1 >= pRect->y2() && *pY2 >= pRect->y2())
		return false;

	int deltaX = *pX2 - *pX1;
	int deltaY = *pY2 - *pY1;
//X1
	//ClipPointX(pX1,pY1,pRect,deltaX,deltaY);
	if (*pX1 < pRect->x)
	{
		int cx = pRect->x - *pX1;
		*pX1 = pRect->x;
		*pY1 += (cx * ((deltaY << 16) / deltaX)) >> 16;
	} else
	if (*pX1 > pRect->x2() - 1)
	{
		int cx = pRect->x2() - 1 - *pX1;
		*pX1 = pRect->x2() - 1;
		*pY1 += (cx * ((deltaY << 16) / deltaX)) >> 16;
	}
	
//X2
	//ClipPointX(pX2,pY2,pRect,deltaX,deltaY);
	if (*pX2 < pRect->x)
	{
		int cx = pRect->x - *pX2;
		*pX2 = pRect->x;
		*pY2 += (cx * ((deltaY << 16) / deltaX)) >> 16;
	} else
	if (*pX2 > pRect->x2() - 1)
	{
		int cx = pRect->x2() - 1 - *pX2;
		*pX2 = pRect->x2() - 1;
		*pY2 += (cx * ((deltaY << 16) / deltaX)) >> 16;
	}
	
//Y1
	//ClipPointY(pX1,pY1,pRect,deltaX,deltaY);
	if (*pY1 < pRect->y)
	{
		int cy = pRect->y - *pY1;
		*pY1 = pRect->y;
		*pX1 += (cy * ((deltaX << 16) / deltaY)) >> 16;
	} else
	if (*pY1 > pRect->y2() - 1)
	{
		int cy = pRect->y2() - 1 - *pY1;
		*pY1 = pRect->y2() - 1;
		*pX1 += (cy * ((deltaX << 16) / deltaY)) >> 16;
	}
//Y2
	//ClipPointY(pX2,pY2,pRect,deltaX,deltaY);
	if (*pY2 < pRect->y)
	{
		int cy = pRect->y - *pY2;
		*pY2 = pRect->y;
		*pX2 += (cy * ((deltaX << 16) / deltaY)) >> 16;
	} else
	if (*pY2 > pRect->y2() - 1)
	{
		int cy = pRect->y2() - 1 - *pY2;
		*pY2 = pRect->y2() - 1;
		*pX2 += (cy * ((deltaX << 16) / deltaY)) >> 16;
	}

	return *pX1 != *pX2 || *pY1 != *pY2;
}

//Intersec
bool ClipRect(WISP_RECT *pRect, const WISP_RECT *pClipRect)
{
#if 0
	int xx = MAX(pClipRect->x, pRect->x);
	int yy = MAX(pClipRect->y, pRect->y);

	int xcx = MIN(pClipRect->x2(), pRect->x2());
	int ycy = MIN(pClipRect->y2(), pRect->y2());

	pRect->x = xx;
	pRect->y = yy;
	pRect->cx = xcx - xx;
	pRect->cy = ycy - yy;
#else
	if (pRect->x < pClipRect->x)
	{
		pRect->cx += pRect->x - pClipRect->x;
		pRect->x = pClipRect->x;
	}

	if (pRect->y < pClipRect->y)
	{
		pRect->cy += pRect->y - pClipRect->y;
		pRect->y = pClipRect->y;
	}

	if (pRect->x + pRect->cx > pClipRect->x2()) //MAX_LIMIT
		pRect->cx = pClipRect->x2() - pRect->x;

	if (pRect->y + pRect->cy > pClipRect->y2()) //MAX_LIMIT
		pRect->cy = pClipRect->y2() - pRect->y;
#endif
	return !IsInvalidRect(pRect);
}

//Intersec
bool HasClipRect(const WISP_RECT *pRect, const WISP_RECT *pClipRect)
{
	WISP_RECT RectTest = *pRect;
	return ClipRect(&RectTest, pClipRect);
}

unsigned long FindFitColor(unsigned long Color, unsigned long *Pal)
{
	long MinDelta = 0x7FFFFFFF; //MAX_SINT32
	long nDelta = 0;

	for (int n = 0; n < 256; ++n)
	{
		long Delta = (long)(Color - Pal[n]) < 0 ? Pal[n] - Color : Color - Pal[n]; //abs(Color - Pal[n]) ???
		if (!Delta) return n;
		if (MinDelta > Delta)
		{
			MinDelta = Delta;
			nDelta = n;
		}
	}
	return nDelta;
}

int ColorStrNCpy(unsigned long *Des, WCHAR const *Src, int Count, unsigned char TXTColor, unsigned char BKColor)
{
	int len = 0;
	while (*Src && Count--)
	{
		*Des = MAKE_DWORD(MAKE_WORD(BKColor,TXTColor),*Src);
		++Src;
		++Des;
		++len;
	}
	*Des = 0;
	return len;
}

int ColorStrNCpy(unsigned long *Des, char const *Src, int Count, unsigned char TXTColor, unsigned char BKColor)
{
	int len = 0;
	while (*Src && Count--)
	{
		*Des = MAKE_DWORD(MAKE_WORD(BKColor,TXTColor),*Src);
		++Src;
		++Des;
		++len;
	}
	*Des = 0;
	return len;
}

int ColorStrCpy(unsigned long *Des, WCHAR const *Src, unsigned char TXTColor, unsigned char BKColor)
{
	int len = 0;
	while (*Src)
	{
		*Des = MAKE_DWORD(MAKE_WORD(BKColor,TXTColor),*Src);
		++Src;
		++Des;
		++len;
	}
	*Des = 0;
	return len;
}

int ColorStrCpy(unsigned long *Des, char const *Src, unsigned char TXTColor, unsigned char BKColor)
{
	int len = 0;
	while (*Src)
	{
		*Des = MAKE_DWORD(MAKE_WORD(BKColor,TXTColor),*Src);
		++Src;
		++Des;
		++len;
	}
	*Des = 0;
	return len;
}

int ColorStrNCat(unsigned long *Des, WCHAR const *Src, int Count, unsigned char TXTColor, unsigned char BKColor)
{
	Des += TStrLen(Des);
	return ColorStrNCpy(Des, Src, Count, TXTColor, BKColor);
}

int ColorStrNCat(unsigned long *Des, char const *Src, int Count, unsigned char TXTColor, unsigned char BKColor)
{
	Des += TStrLen(Des);
	return ColorStrNCpy(Des, Src, Count, TXTColor, BKColor);
}

int ColorStrCat(unsigned long *Des, WCHAR const *Src, unsigned char TXTColor, unsigned char BKColor)
{
	Des += TStrLen(Des);
	return ColorStrCpy(Des, Src, TXTColor, BKColor);
}

int ColorStrCat(unsigned long *Des, char const *Src, unsigned char TXTColor, unsigned char BKColor)
{
	Des += TStrLen(Des);
	return ColorStrCpy(Des, Src, TXTColor, BKColor);
}

//bool IsInvalidRect(WISP_RECT *pRect) { return pRect->cx == 0 || pRect->cy == 0; }
//bool IsInvalidRect(WISP_RECT *pRect) { return pRect->cx <= 0 || pRect->cy <= 0; }

bool PtInRect(const WISP_RECT *pRect, int x, int y)
	{
	return (!IsInvalidRect(pRect) &&
		x >= pRect->x && x < pRect->x2() &&
		y >= pRect->y && y < pRect->y2());
	}

//bool PtInRect(WISP_RECT *pRect, WISP_POINT & pPoint) { return PtInRect(pRect, pPoint.x, pPoint.y); }
//bool PtInRect(WISP_RECT *pRect, WISP_POINT * pPoint) { return PtInRect(pRect, *pPoint); }

//Union
void RectToRect(const WISP_RECT *pRect, WISP_RECT *pToRect)
{
	if (IsInvalidRect(pRect))
	{
		return;
	}

	if (IsInvalidRect(pToRect))
	{
		*pToRect = *pRect;
		return;
	}

	int xx = MIN(pRect->x, pToRect->x);
	int yy = MIN(pRect->y, pToRect->y);

	int xcx = MAX(pRect->x2(), pToRect->x2());
	int ycy = MAX(pRect->y2(), pToRect->y2());

	pToRect->x = xx;
	pToRect->y = yy;
	pToRect->cx = xcx - xx;
	pToRect->cy = ycy - yy;

	//WISP_RECT ToRect;
	//RectToRect(pRect, pToRect, &ToRect);
	//*pToRect = ToRect;
}

//Union
void RectToRect(const WISP_RECT *lpRect1, const WISP_RECT *lpRect2, WISP_RECT *pToRect)
{
	if (!lpRect1 || !lpRect2) return;
	
	if (IsInvalidRect(lpRect1))
	{
		*pToRect = *lpRect2;
		return;
	}

	if (IsInvalidRect(lpRect2))
	{
		*pToRect = *lpRect1;
		return;
	}

	pToRect->x = MIN(lpRect1->x, lpRect2->x);
	pToRect->y = MIN(lpRect1->y, lpRect2->y);

	pToRect->cx = MAX(lpRect1->x2(), lpRect2->x2()) - pToRect->x;
	pToRect->cy = MAX(lpRect1->y2(), lpRect2->y2()) - pToRect->y;
}

//Intersec
void RectFromRect(const WISP_RECT *pRect, WISP_RECT *pToRect)
{
	if (IsInvalidRect(pRect))
	{
		return;
	}

	if (IsInvalidRect(pToRect))
	{
		*pToRect = *pRect;
		return;
	}

	int xx = MAX(pRect->x, pToRect->x);
	int yy = MAX(pRect->y, pToRect->y);

	int xcx = MIN(pRect->x2(), pToRect->x2());
	int ycy = MIN(pRect->y2(), pToRect->y2());

	pToRect->x = xx;
	pToRect->y = yy;
	pToRect->cx = xcx - xx;
	pToRect->cy = ycy - yy;

	//WISP_RECT ToRect;
	//RectToRect(pRect, pToRect, &ToRect);
	//*pToRect = ToRect;
}

//Intersec
void RectFromRect(const WISP_RECT *lpRect1, const WISP_RECT *lpRect2, WISP_RECT *pToRect)
{
	if (!lpRect1 || !lpRect2) return;
	
	if (IsInvalidRect(lpRect1))
	{
		*pToRect = *lpRect2;
		return;
	}

	if (IsInvalidRect(lpRect2))
	{
		*pToRect = *lpRect1;
		return;
	}

	pToRect->x = MAX(lpRect1->x, lpRect2->x);
	pToRect->y = MAX(lpRect1->y, lpRect2->y);

	pToRect->cx = MIN(lpRect1->x2(), lpRect2->x2()) - pToRect->x;
	pToRect->cy = MIN(lpRect1->y2(), lpRect2->y2()) - pToRect->y;
}


void PointToRect(WISP_POINT *pPoint, const WISP_RECT *pRect) //???
	{
		pPoint->x -= pRect->x;
		pPoint->y -= pRect->y;
	}

```

`source/Wisp/utility.hpp`:

```hpp

#ifndef _UTILITY_HPP_
#define _UTILITY_HPP_

#include "../Code/define.h"

struct WISP_POINT
{
	int x;
	int y;
};

struct WISP_SIZE
{
	int cx;
	int cy;
};

struct WISP_RECT
{
	int x;
	int y;
	int cx;
	int cy;
//???
	int x2() const { return x+cx; }
	int y2() const { return y+cy; }

	bool Valid() const { return cx>0&&cy>0; }
	bool Invalid() const { return !Valid(); }
};

typedef WISP_RECT CWispRect;

#if 0
struct CWispRect : public WISP_RECT
{
	CWispRect(const WISP_POINT & PTL, const WISP_POINT & PTR)
	{
		x = PTL.x; y = PTL.y; cx = PTR.x; cy = PTR.y;
		
	}
	CWispRect(const WISP_POINT & PT, const WISP_SIZE & SZ)
	{
		cx = (x = point.x)+size.cx;
		cy = (y = point.y)+size.cy;
	}
	CWispRect(const WISP_RECT * pRC) { *this = *pRC; }
	CWispRect(const WISP_RECT & rc) { *this = rc; }
	CWispRect(long nx, long ny, long ncx, long ncy) { x=nx;y=ny;cx=ncx;cy=ncy; }
	CWispRect() {} //???

	void DeflateRect(int nX, int nY) //Decreases the width and height of CWispRect.
	{
		cx -= nX;
		cy -= nY;
	}
	void OffsetRect(int nX, int nY) //Moves CWispRect by the specified offsets.
	{
		x += nX;
		y += nY;
		cx += nX;
		cy += nY;
	}

	void operator=(const WISP_RECT & RC) { *this = RC; }

	bool operator==(const WISP_RECT & RC) { return x == RC.x && y == RC.y && cx == RC.cy && cy == RC.cy; }
	bool operator!=(const WISP_RECT & RC) { return !operator==(RC); }

	void operator+=(WISP_RECT & RC) { x += RC.x; y += RC.y; cx += RC.cx; cy += RC.cy; }
	void operator+=(WISP_SIZE SZ) { cx += size.cx; cy += size.cy; }
	void operator+=(WISP_POINT PT) { x += point.x; y += point.y; cx += point.x; cy += point.y; }

	void operator-=(WISP_RECT & RC) { x -= RC.x; y -= RC.y; cx -= RC.cx; cy -= RC.cy; }
	void operator-=(WISP_SIZE SZ) { cx -= size.cx; cy -= size.cy; }
	void operator-=(WISP_POINT PT) { x -= point.x; y -= point.y; cx -= point.x; cy -= point.y; }

	void operator&=(const WISP_RECT & RC);
	void operator|=(const WISP_RECT & RC);

	CWispRect operator+(WISP_SIZE SZ) { return CWispRect(x,y,cx+SZ.cx,cy+SZ.cy); }
	CWispRect operator+(WISP_RECT RC) { return CWispRect(x+RC.x,y+RC.y,cx+RC.cx,cy+RC.cy); }
	CWispRect operator+(WISP_RECT*RC) { return operator+(*RC); }
	CWispRect operator+(WISP_POINT PT) { return CWispRect(x+PT.x,y+PT.y,cx,cy); }

	CWispRect operator-(WISP_SIZE SZ) { return CWispRect(x,y,cx-SZ.cx,cy-SZ.cy); }
	CWispRect operator-(WISP_RECT & RC) { return CWispRect(x-RC.x,y-RC.y,cx-RC.cx,cy-RC.cy); }
	CWispRect operator-(WISP_RECT*RC) { return operator-(*RC); }
	CWispRect operator-(WISP_POINT PT) { return CWispRect(x-PT.x,y-PT.y,cx,cy); }

	CWispRect operator&(const WISP_RECT & RC);
	CWispRect operator|(const WISP_RECT & RC);
	int y2() { return y+cy; }
	int x2() { return x+cx; }
	operator WISP_RECT *() { return this; }
	void SetRect(int nx, int ny, int ncx, int ncy) //Sets the dimensions of CRect.
	{
		x = nx; y = ny; cx = ncx; cy = ncy;
	}
};
#endif

bool ClipLine(int *pX1, int *pY1, int *pX2, int *pY2, const WISP_RECT *pRect);
bool ClipRect(WISP_RECT *pRect, const WISP_RECT *pClipRect);
bool HasClipRect(const WISP_RECT *pRect, const WISP_RECT *pClipRect);

unsigned long FindFitColor(unsigned long Color, unsigned long *Pal);
int ColorStrNCpy(unsigned long *Des, WCHAR const *Src, int Count, unsigned char TXTColor, unsigned char BKColor);
int ColorStrNCpy(unsigned long *Des, char const *Src, int Count, unsigned char TXTColor, unsigned char BKColor);
int ColorStrCpy(unsigned long *Des, WCHAR const *Src, unsigned char TXTColor, unsigned char BKColor);
int ColorStrCpy(unsigned long *Des, char const *Src, unsigned char TXTColor, unsigned char BKColor);
int ColorStrNCat(unsigned long *Des, WCHAR const *Src, int Count, unsigned char TXTColor, unsigned char BKColor);
int ColorStrNCat(unsigned long *Des, char const *Src, int Count, unsigned char TXTColor, unsigned char BKColor);
int ColorStrCat(unsigned long *Des, WCHAR const *Src, unsigned char TXTColor, unsigned char BKColor);
int ColorStrCat(unsigned long *Des, char const *Src, unsigned char TXTColor, unsigned char BKColor);

inline unsigned long *ColorString(const WCHAR *lpString) { return (unsigned long *)(lpString+2); }
inline bool IsColorString(const WCHAR *lpString) { return lpString && lpString[0] == 0xFFFF; }

//inline bool IsInvalidRect(WISP_RECT *pRect); { return pRect->cx == 0 || pRect->cy == 0; }
inline bool IsInvalidRect(const WISP_RECT *pRect) { return pRect->cx <= 0 || pRect->cy <= 0; }

bool PtInRect(const WISP_RECT *pRect, int x, int y);
inline bool PtInRect(const WISP_RECT *pRect, const WISP_POINT & pPoint) { return PtInRect(pRect, pPoint.x, pPoint.y); }
inline bool PtInRect(const WISP_RECT *pRect, const WISP_POINT * pPoint) { return PtInRect(pRect, *pPoint); }
//Union
void RectToRect(const WISP_RECT *pRect, WISP_RECT *pToRect);
void RectToRect(const WISP_RECT *lpRect1, const WISP_RECT *lpRect2, WISP_RECT *pToRect);
//Intersec
void RectFromRect(const WISP_RECT *pRect, WISP_RECT *pToRect);
void RectFromRect(const WISP_RECT *lpRect1, const WISP_RECT *lpRect2, WISP_RECT *pToRect);

void PointToRect(WISP_POINT *pPoint, const WISP_RECT *pRect); //???

#endif

```

`source/Wisp/wispapp.cpp`:

```cpp

#include "wispapp.hpp"

	bool CWispApp::Start()
	{
		return Init(); 
	}

	bool CWispApp::Stop()
	{
		Release();
		return false;
	}

	bool CWispApp::Run()
	{
		Pump();
		return false;
	}

```

`source/Wisp/wispapp.hpp`:

```hpp

#ifndef _WISPAPP_HPP_
#define _WISPAPP_HPP_

#include "wispbase.hpp"

	struct CWispApp : public CWispBase
	{

	public:
		virtual bool Start(); // { return Init(); }
		virtual bool Stop(); // { Release(); return false; }
		virtual bool Run(); // { Pump(); return false; }
	};

#endif
```

`source/Wisp/wispbase.cpp`:

```cpp
#include "../Code/define.h"
//#include "../Code/osdefine.hpp"
#include "../Code/sysdep.hpp"
#include "wispbase.hpp"
#include "wispbasewnd.hpp"
#include "wispwnd.hpp"
#include "wispmsgbox.hpp"


	extern unsigned long BTCaret[24]; //dibdata.cpp

	CWispBase *gpCurWisp;

	unsigned short CWispBase::m_VKKeyChar[2][256][2] = 
	{
		{
		{0,0},    {0,0},   {0,0},   {0,0},   {0,0},       {0,0},    {0,0},    {0,0},    {8,8},   {9,9},
		{0,0},    {0,0},   {0,0},  {0xA,0xA}, {0,0},      {0,0},   {0,0},    {0,0},    {0,0},     {0,0}, 
		{0,0},    {0,0},   {0,0},   {0,0},   {0,0},       {0,0},    {0,0},   {0,0},    {0,0},    {0,0},
		{0,0},    {0,0},  {' ',' '},  {0,0},  {0,0},      {0,0},    {0,0},    {0,0},   {0,0},   {0,0},
		{0,0},    {0,0},   {0,0},   {0,0},    {0,0},     {0,0},    {0,0},    {0,0},   {')','0'},  {'!','1'},
		{'@','2'},  {'#','3'},  {'$','4'},  {'%','5'},  {'^','6'}, {'&','7'},  {'*','8'},  {'(','9'},  {0,0}, {0,0}, 
		{0,0},   {0,0},   {0,0}, {0,0},  {0,0}, {'A','a'}, {'B','b'}, {'C','c'}, {'D','d'}, {'E','e'},
		{'F','f'}, {'G','g'}, {'H','h'}, {'I','i'}, {'J','j'}, {'K','k'}, {'L','l'}, {'M','m'}, {'N','n'}, {'O','o'},
		{'P','p'}, {'Q','q'}, {'R','r'}, {'S','s'}, {'T','t'}, {'U','u'}, {'V','v'}, {'W','w'}, {'X','x'}, {'Y','y'},
		{'Z','z'}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {'0','0'}, {'1','1'}, {'2','2'}, {'3','3'},
		{'4','4'}, {'5','5'}, {'6','6'}, {'7','7'}, {'8','8'}, {'9','9'}, {'*','*'}, {'+','+'}, {'\\','\\'}, {'-','-'},
		{'.','.'}, {'/','/'}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {':',';'}, {'+','='}, {'<',','}, {'_','-'},
		{'>','.'}, {'?','/'}, {'~','`'}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {'{','['},
		{'|','\\'}, {'}',']'}, {'"',0x27}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		},

		{
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {8,8}, {9,9},
		{0,0}, {0,0}, {0,0}, {0xA,0xA}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {' ',' '}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {'0',0xFFE0}, {'1','&'},
		{'2',0xFFE9}, {'3','"'}, {'4',0x27}, {'5','('}, {'6','-'}, {'7',0xFFE0}, {'8','_'}, {'9',0xFFE7}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {'A','a'}, {'B','b'}, {'C','c'}, {'D','d'}, {'E','e'},
		{'F','f'}, {'G','g'}, {'H','h'}, {'I','i'}, {'J','j'}, {'K','k'}, {'L','l'}, {'M','m'}, {'N','n'}, {'O','o'},
		{'P','p'}, {'Q','q'}, {'R','r'}, {'S','s'}, {'T','t'}, {'U','u'}, {'V','v'}, {'W','w'}, {'X','x'}, {'Y','y'},
		{'Z','z'}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {'0','0'}, {'1','1'}, {'2','2'}, {'3','3'},
		{'4','4'}, {'5','5'}, {'6','6'}, {'7','7'}, {'8','8'}, {'9','9'}, {'*','*'}, {'+','+'}, {'\\','\\'}, {'-','-'},
		{'.','.'}, {'/','/'}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{'?',','}, {'+','='}, {'.',';'}, {0xFFB0,')'}, {'/',':'}, {0xFFA7,'!'}, {'~','`'}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0xFFA8,'^'}, {0xFFB5,'*'}, {0xFFA3,'$'}, {'%',0xFFF9}, {0,0}, {0,0}, {0,0}, {'>','<'}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
		{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}
		},
	};

	WISP_PHYS_FONT_INFO CWispBase::m_PhysFontInfo[WISP_FONT_COUNT] = 
	{ { 8, 16, "\\Font\\Font8x16.dat", "\\Font\\WF8x16.dat" },
	  { 6, 12, "\\Font\\Font6x12.dat", "\\Font\\WF6x12.dat" },
	  { 12, 16, "\\Font\\ASCI1216.dat", "\\Font\\ASCI1216.dat" },
	  { 12, 16, "\\Font\\EBCD1216.dat", "\\Font\\EBCD1216.dat" },
	  { 12, 16, "\\Font\\ANSI1216.dat", "\\Font\\ANSI1216.dat" },
	  { 8, 16, "\\Font\\Font8x16.dat", "\\Font\\WF8x16.dat" }, //???
	};

	unsigned long CWispBase::m_DefColorPal[256] =
	{
		0x000000, 0xFFFFFF, 0xC00000, 0xFF0000, 0x00C000, 0x00FF80, 0x0000C0, 0x0080FF,
		0x804040, 0xC86464, 0x00C0C0, 0x00FFFF, 0x808080, 0xC8C8C8, 0xC0C000, 0xFFFF00,
		0x804000, 0xFF8000, 0x000000, 0xC8C8C8, 0xECE9D8, 0x000000, 0xFFFFFF, 0x2398C8,
		0x50B0FF, 0x0080FF, 0x64C8FA, 0x0082E6, 0xDCDCDC, 0x555555, 0xAAAAAA, 0x50E6FF,
		0x32B4E6, 0x0000FF, 0x7F9DB9, 0x7F9DB9, 0x1C5180, 0xFFFFFF, 0xF3F3EF, 0xE2E1DA,
		0x3169C6, 0xF8B330, 0xFFD664, 0xFFFFFF, 0x000000, 0x000080, 0x0000FF, 0x316AC5,
		0xB4C8E4, 0xD2E6FF, 0x8A867A, 0x7898B5, 0x00FFFF, 0xFFFFFF, 0x21A121, 0x000000,
		0x76B1E5, 0xB4D6F1, 0x6492B9, 0xEBEADB, 0xFFFFFF, 0xC7C5B2, 0xE2DECD, 0xD6D2C2,
		0xCBC7B8, 0xF3F3F3, 0xF8A900, 0xF9C654, 0xF8B31F, 0xABEDAC, 0x95E996, 0x7CE47E,
		0x66DF68, 0x4EDA50, 0x35D538, 0x28D22B, 0xE59700, 0xF8B330, 0xFDD889, 0x3D95FF,
		0x2B90FF, 0x0055EA, 0x0046E0, 0x0143CF, 0x003DDC, 0x001DA0, 0x00138C, 0x7B7B7B,
		0xE0E8FE, 0xF1F1F1, 0xE7EBFF, 0x6B79BD, 0xACA899, 0xF1EFE2, 0x716F64, 0xDEDFD8,
		0xA5A597, 0xC1C2B8, 0xD0D1C9, 0xB4FAD4, 0x64C8FF, 0xFFAAAA, 0x009BFF, 0xB42828,
		0x70A2F3, 0xC5C2B8, 0x00FF00, 0xFF00FF, 0xFAFACC, 0x21A221, 0x7BA2E7, 0x6375D6,
		0xB4B1A3, 0xFEFEFF, 0xF0F0F1, 0xE6EAFF, 0xE0E4F9, 0xD2D8F7, 0x6878BF, 0x28080C,
		0x8B3377, 0x2D182C, 0xE8C8E8, 0xF8E8F8, 0x18081D, 0xB888C8, 0xD8B0E8, 0xC098D8,
		0x9A6AC8, 0xD8C8E8, 0x2D2C34, 0xB9B7C8, 0x6C679F, 0x080888, 0x080857, 0x080818,
		0x383880, 0x6868B8, 0xA8A8D8, 0xC8C8F8, 0xB8B8D8, 0xC8C8E8, 0xD8D8F8, 0xD8D8E8,
		0xE8E8F8, 0xC9CAD8, 0x5E6074, 0x92939C, 0x343856, 0x283898, 0x7788E9, 0x283888,
		0x384898, 0x4858A9, 0x5868B8, 0x7888D8, 0x8898E8, 0x5868A8, 0x6878B8, 0x7A88C7,
		0x384886, 0x8898D1, 0xABB8EB, 0x9AA4C7, 0x0837B9, 0x101830, 0x6878A8, 0x95ABEA,
		0x7A86A7, 0x183888, 0x28489A, 0x507FF5, 0x3858A8, 0x4868B9, 0x5878C8, 0x6888D8,
		0x1649B8, 0x16306C, 0x485C8A, 0x586B98, 0x296DF6, 0x284888, 0x385898, 0x4868A8,
		0x5878B8, 0x6888C8, 0x7898D8, 0x687897, 0xA8B8D8, 0xC8D8F8, 0x192840, 0x6E88B3,
		0x3868AE, 0x7898C8, 0x4778BB, 0x5285CC, 0x385985, 0x6799DE, 0xB4D1F8, 0x275998,
		0x587CA8, 0x37485C, 0x8EB1D8, 0xC8D8E8, 0x4FA8F7, 0x6899C8, 0xA8C9E8, 0xB6C8D8,
		0xA8B8C7, 0x084E87, 0x285A84, 0x78A8D0, 0x71BEF8, 0xD8E8F4, 0x8FD1F6, 0x097BB3,
		0x477F9D, 0x47ABC8, 0x5EDCF8, 0x11A7BC, 0x1BCDE7, 0x2BDFF8, 0x85E9F7, 0xB1EFF8,
		0x6DC9CE, 0x2E8587, 0x081818, 0xE8F8F8, 0x146A60, 0x24924C, 0x137C1E, 0xE5F8E7,
		0x69AE69, 0xBFE0BD, 0x42E90F, 0x6FBF31, 0xA9E36E, 0xD9EDA8, 0xF8F8E8, 0xB3A24F,
		0xF8EBA6, 0xF8F2D5, 0x8C6E11, 0xDEC17B, 0xBE811D, 0x522C1F, 0xF2C2BE, 0xF5544B,
		0xEB8581, 0x180808, 0xF8E8E8, 0x191818, 0xF8F8F8, 0xE8E8E8, 0x484848, 0x080808,
	};

	CWispBase::CWispBase()
	{
		m_Metrics[WISP_SM_CAPTION_CY] = 18;
		m_Metrics[WISP_SM_BORDER_SIZE] = 4;
		m_Metrics[WISP_SM_TIP_BORDER_SIZE] = 2;

		m_Metrics[WISP_SM_CAPTION_BT_SIZE] = 16;
		m_Metrics[WISP_SM_SCROLL_BAR_SIZE] = 16;
		m_Metrics[WISP_SM_TOOLBAR_CY] = 18;
		m_Metrics[WISP_SM_RESIZE_SIZE] = 6;

		m_pRootWnd = 0;

		memset(m_PalColors, 0, sizeof(m_PalColors));

		//memset(&m_FrameBufferInfo, 0, sizeof(m_FrameBufferInfo));
		m_FrameBufferInfo.Width = 0;
		m_FrameBufferInfo.Height = 0;
		m_FrameBufferInfo.Bpp = 0;
		m_FrameBufferInfo.PixelFormat = 0;
		m_FrameBufferInfo.Flag = 0;
		m_FrameBufferInfo.VideoBuffer = 0;
		m_FrameBufferInfo.VideoBufferSize = 0;
		m_FrameBufferInfo.LineDistance = 0;
		m_FrameBufferInfo.pWispDrawHAL = 0;

		memcpy(m_PalColors, CWispBase::m_DefColorPal, sizeof(m_PalColors));
		m_bHideMouse = 0;
		m_szWispResource = 0;
		m_bActive = 0;
		GetModulePath(m_szModuleName, true);
		m_FontIndex = WISP_FONT_6X12; //WISP_FONT_8X16
		m_KeyLangMap = 0;
	}

	CWispBase::~CWispBase()
	{
	}

	bool CWispBase::Init()
	{
		gpCurWisp = this;
		m_bActive = 0;
		m_pWispDrawObj = 0;
		m_KeySimulateMouse = 0;
		if (m_szWispResource == 0) m_szWispResource = "Wisp.dat";

		m_PFSFileIO.ChangeFileIO(gpFileIO);

		char szWispDatPath[MAX_PATH];
		int n = TStrCpy(szWispDatPath, m_szModuleName);
		if (n && szWispDatPath[n-1] != '\\')
			TStrCat(szWispDatPath, "\\");

		char *szWispDatPlace = szWispDatPath+TStrLen(szWispDatPath);
		const char *szWispResource = m_szWispResource;

		while (*szWispResource != 0)
		{
			char *delim = TStrChr(szWispResource, ';');
			if (delim)
			{
				TStrCpyLimit(szWispDatPlace, szWispResource, delim+1-szWispResource);
				szWispResource = delim+1;
			} else
			{
				TStrCpy(szWispDatPlace, szWispResource);
				szWispResource += TStrLen(szWispResource);
			}

			if (!m_PFSFileIO.OpenDisk(szWispDatPath, 1))
			{
				WCHAR szWispDatPathW[MAX_FN_LEN];
				AnsiToUnicode(szWispDatPath, szWispDatPathW, lenof(szWispDatPathW));
				ReportMsg(WSTR("Error : Fail to open %s!\n"), szWispDatPathW);
				m_PFSFileIO.CloseDisk();
				return false;
			}
		}

		memset(m_KeyMap, 0, sizeof(m_KeyMap));
		m_LockMap[0] = 0;
		m_LockMap[1] = 0;
		m_LockMap[2] = 0;

		m_MousePT.x = 0;
		m_MousePT.y = 0;
		m_PrevMousePT.x = 0;
		m_PrevMousePT.y = 0;
		m_bUpdate = 0;
		m_UpdateLockRef = 0;

		m_DefDIB[WISP_DI_CARET].Create(2, 12, 3, 0, 0); //COLORREF_PF_565
		memcpy(m_DefDIB[WISP_DI_CARET].m_PixelBuf.VideoBuffer, BTCaret, m_DefDIB[WISP_DI_CARET].m_PixelBuf.VideoBufferSize);

		//m_DefDIB[WISP_DI_CURSOR].Load("\\Arrow.bmp", -1);
		//m_DefDIB[WISP_DI_CURSOR].m_Type = 2; //COLORREF_PF_555
		//m_DefDIB[WISP_DI_CURSOR].m_ColorKey = 0;

		m_pRootWnd = 0;
		m_bNeedUpdate = 0;

		for (int i = 0; i < lenof(CWispBase::m_PhysFontInfo); ++i)
		{
			m_FontList[i].LoadChar(&CWispBase::m_PhysFontInfo[i]); //TODO error
			m_FontList[i].LoadWideChar(&CWispBase::m_PhysFontInfo[i]); //TODO error
		}

		m_pTopMostRootWnd = 0;
		m_pTipWnd = 0;
		m_pModalWnd = 0;
		m_pDragWnd = 0;
		m_pMoveWnd = 0;
		m_RepKeyIndex = 0;
		m_CursorType = 0;
		m_CursorTypeBak = 0;
		m_WndCount = 0;
		m_BaseWndCount = 0;
		m_TimerLockRef = 0;
		m_bKeyMutex = 0;
		m_SpecKey = 0;
		m_PumpLockRef = 0;

		SelectDrawObject(&m_DIBDrawObj);

		return true;
	}

	void CWispBase::Release()
	{
		if (m_pRootWnd)
		{
			m_pRootWnd->Destroy();
			m_pRootWnd = 0;
		}

		if (m_pWispDrawObj)
			m_pWispDrawObj->Release();

		for (int i = 0; i < lenof(m_DefDIB); ++i)
			m_DefDIB[i].Destroy();

		for (int i = 0; i < lenof(m_FontList); ++i)
			m_FontList[i].Destroy();

		m_TimerList.clear();
		m_KeyEventList.Clear();
		m_DIBLib.ReleaseAll();
		m_PFSFileIO.CloseDisk();
	}

//	bool CreateFrame(const WCHAR *WndName, int Width, int Height, int Bpp) = 0;
//	void DestroyFrame() = 0;

//	bool CWispBase::EndResize(int Width, int Height) { return false; }
//	bool CWispBase::BeginResize(int Width, int Height) { return false; }
//	bool CWispBase::MoveFrame(int PosX, int PosY) { return false; }

//	void CWispBase::BeginDrag() { }
//	void CWispBase::EndDrag() { }

	void CWispBase::RedrawNextTime()
	{
		if (!m_bNeedUpdate)
		{
			m_bNeedUpdate = true;
			if (m_bInCriticalSection)
			{
				m_bInCriticalSection = false;
				WakeUpMsgThread();
			}
		}
	}
//	bool CWispBase::WakeUpMsgThread() { return true; }
//	bool CWispBase::SleepMsgThread() { return true; }

//	void CWispBase::EnterMsgCriticalSection() { }
//	void CWispBase::LeaveMsgCriticalSection() { }

//	void CWispBase::BeginDraw(WISP_RECT *pRect) { }
//	void CWispBase::EndDraw(WISP_RECT *pRect) { }

	void CWispBase::SetCursor(unsigned int CursorType, WISP_POINT *pHotPT, WISP_SIZE *pSize, CWispDIB *pDIB)
	{
		switch (CursorType)
		{
		case WISP_CT_ARROW:
			m_pWispDrawObj->DrawCursorArrow(0, 0);
			break;
		case WISP_CT_RESIZE_VERT:
			m_pWispDrawObj->DrawCursorResizeVert(0, 0);
			break;
		case WISP_CT_RESIZE_HORZ:
			m_pWispDrawObj->DrawCursorResizeHorz(0, 0);
			break;
		case WISP_CT_DRAG:
			m_pWispDrawObj->DrawCursorDrag(0, 0);
			break;
		case WISP_CT_RESIZE_LEFT_LEAN:
			m_pWispDrawObj->DrawCursorResizeLeftLean(0, 0);
			break;
		case WISP_CT_RESIZE_RIGHT_LEAN:
			m_pWispDrawObj->DrawCursorResizeRightLean(0, 0);
			break;
		default:
			if (pDIB)
			{
				if (pHotPT)
				{
					pHotPT->x = pDIB->m_HotPT.x;
					pHotPT->y = pDIB->m_HotPT.y;
				}

				if (pSize)
				{
					pSize->cx = pDIB->m_PaintRect.cx;
					pSize->cy = pDIB->m_PaintRect.cy;
				}
			}
			break;
		}

	}
//	void CWispBase::ChangeCursor(LONG_PTR Style, unsiged int CursorType, WISP_POINT *pHotPT, WISP_SIZE *pSize) { }

	void CWispBase::ChangeCursor(unsigned int CursorType)
	{
		if (m_CursorType != CursorType)
		{
			m_CursorTypeBak = m_CursorType;
			m_pCursorDIBBak = m_pCursorDIB;
			m_CursorType = CursorType;
			m_pCursorDIB = 0;
			SetCursor(m_CursorType, &m_MouseCursorPos, &m_MouseCursorSize, m_pCursorDIB);
			if (!m_bHideMouse)
				RedrawNextTime();
		}
	}

	void CWispBase::ChangeCursor(CWispDIB *pCursorDIB)
	{
		if (m_pCursorDIB != pCursorDIB)
		{
			m_CursorTypeBak = m_CursorType;
			m_pCursorDIBBak = m_pCursorDIB;
			m_CursorType = WISP_CT_PENDING;
			m_pCursorDIB = pCursorDIB;
			SetCursor(m_CursorType, &m_MouseCursorPos, &m_MouseCursorSize, m_pCursorDIB);
			if (!m_bHideMouse)
				RedrawNextTime();
		}
	}

	void CWispBase::Update()
	{
		WISP_RECT DrawRect;
		WISP_RECT MouseRect;
		WISP_MSG Msg;

		if (m_pRootWnd)
		{
			Msg.hWnd = m_pRootWnd;

			if (m_pRootWnd->m_pUpdateRC)
			{
				DrawRect = *m_pRootWnd->m_pUpdateRC;
			} else
			if (m_bHideMouse)
			{
				return;
			}

			if (!m_bHideMouse)
			{
				MouseRect.y = m_MousePT.y - m_MouseCursorPos.y;
				MouseRect.x = m_MousePT.x - m_MouseCursorPos.x;
				MouseRect.cx = m_MouseCursorSize.cx;
				MouseRect.cy = m_MouseCursorSize.cy;

				RectToRect(&MouseRect, &m_MouseRectUpd); //Union |
				m_pRootWnd->Update(&m_MouseRectUpd, 0);

				if (!m_pRootWnd->m_pUpdateRC)
					return;

				DrawRect = *m_pRootWnd->m_pUpdateRC;

				m_MouseRectUpd = MouseRect;
			}

			BeginDraw(&DrawRect);
			Msg.Msg = WISP_WM_UPDATE;
			SendMessage(&Msg);
			UpdateCursor();
			EndDraw(&DrawRect);
		}
	}

	void CWispBase::UpdateCursor()
	{
		if (!m_bHideMouse)
		{
			m_pRootWnd->m_pUpdateRC = &m_pRootWnd->m_WindowRect;
			m_pWispDrawObj->DrawCursor(&m_MousePT, &m_pRootWnd->m_WindowDC,
						m_CursorType, m_pCursorDIB);
			m_pRootWnd->m_pUpdateRC = 0;
		}
	}

//	bool CWispBase::InsertTimer(const WISP_TIMER &) { return true; }
//	bool CWispBase::RemoveTimer(const WISP_TIMER &) { return true; }

	unsigned long CWispBase::GetPalColor(int Index)
	{
		return m_PalColors[Index];
	}
	bool CWispBase::SetPalColor(int Index, unsigned long Color)
	{
		m_PalColors[Index] = Color;
		return true;
	}
	void CWispBase::LoadPalette()
	{
		for (int i = 0; i < 256; ++i)
			SetPalColor(i, m_PalColors[i]);
	}

	void CWispBase::RemoveWnd(CWispBaseWnd *pWnd)
	{
		if (!m_pRootWnd)
			return;
		if (m_pRootWnd == pWnd)
		{
			m_pRootWnd = 0;
			m_bActive = 0;
			return;
		}
		
		if (pWnd->m_PrevWnd)
			pWnd->m_PrevWnd->m_NextWnd = pWnd->m_NextWnd;

		if (pWnd->m_NextWnd)
			pWnd->m_NextWnd->m_PrevWnd = pWnd->m_PrevWnd;

		if (pWnd->m_ParentWnd->m_ChildWnd == pWnd)
			pWnd->m_ParentWnd->m_ChildWnd = pWnd->m_PrevWnd ? pWnd->m_PrevWnd : pWnd->m_NextWnd;

		if (pWnd->m_ParentWnd->m_ChildTopWnd == pWnd)
			pWnd->m_ParentWnd->m_ChildTopWnd = pWnd->m_PrevWnd;

		if (pWnd->m_Style & 0x8000)
			--m_WndCount;
		else	--m_BaseWndCount;
	}

	void CWispBase::RemoveWndMsg(CWispBaseWnd *pWnd)
	{
		for (int i = 0; i < m_MsgQueue.Count; ++i)
		{
			if (m_MsgQueue[i].hWnd == pWnd)
				m_MsgQueue[i].hWnd = 0;
		}
	}
	void CWispBase::InsertWnd(CWispBaseWnd *pParentWnd, CWispBaseWnd *pNewWnd)
	{
		if (m_pRootWnd == pNewWnd)
			return;
		
		if (!pParentWnd)
			pParentWnd = m_pRootWnd;

		if (pNewWnd->m_Style & 0x8000)
			++m_WndCount;
		else	++m_BaseWndCount;

		if (pParentWnd->m_ChildWnd)
		{
			pNewWnd->m_NextWnd = 0;
			pParentWnd->m_ChildTopWnd->m_NextWnd = pNewWnd;
			pNewWnd->m_PrevWnd = pParentWnd->m_ChildTopWnd;
			pNewWnd->m_ParentWnd = pParentWnd;
			pParentWnd->m_ChildTopWnd = pNewWnd;

			if (pParentWnd == m_pRootWnd && pNewWnd != gpCurWisp->m_pTopMostRootWnd)
				gpCurWisp->m_pTopMostRootWnd->Top(false);
		} else
		{
			pParentWnd->m_ChildWnd = pNewWnd;
			pParentWnd->m_ChildTopWnd = pNewWnd;
			pNewWnd->m_PrevWnd = 0;
			pNewWnd->m_NextWnd = 0;
			pNewWnd->m_ParentWnd = pParentWnd;
		}
		
	}
	CWispBaseWnd *CWispBase::WindowFromPoint(WISP_POINT *pPoint, CWispBaseWnd *pParentWnd)
	{
		CWispBaseWnd *pWnd = pParentWnd ? pParentWnd : m_pRootWnd;

		if (!pWnd->IsRect(pPoint))
			return nullptr;

		for (CWispBaseWnd *pChildWnd = pWnd->m_ChildTopWnd; pChildWnd; pChildWnd = pChildWnd->m_PrevWnd)
		{
			//TODO assert infinet loop when CreateWnd twice
			if (pChildWnd->m_ShowMode != WISP_SH_HIDDEN &&
			    pChildWnd->m_CtrlType != WISP_CTRL_STATIC_GROUP)
			{
				if (pWnd->IsRect(pPoint))
				{
					if (pChildWnd->IsRect(pPoint))
					{
						CWispBaseWnd *res = WindowFromPoint(pPoint, pChildWnd);
						if (!(pChildWnd->m_Style & 0x100) || (res && res != pChildWnd))
							return res;
					}
				}
			}
		}
		return (pWnd->m_Style & 0x100) == 0 ? pWnd : nullptr;
	}

	bool CWispBase::MergeMessage(WISP_MSG *pNewMsg, WISP_MSG *pMergeMsg)
	{
		if (pNewMsg->Msg == pMergeMsg->Msg && pNewMsg->Msg == WISP_WM_MOUSE_MOVE)
		{
			pMergeMsg->MouseEvent.hWndMouseAt = pNewMsg->MouseEvent.hWndMouseAt;
			pMergeMsg->MouseEvent.DeltaX += pNewMsg->MouseEvent.DeltaX;
			pMergeMsg->MouseEvent.DeltaY += pNewMsg->MouseEvent.DeltaY;
			return true;
		}
		return false;
	}

	//GetMessage

	bool CWispBase::SendMessage(WISP_MSG *pMsg)
	{
		if (!pMsg->hWnd)
			return true;

		pMsg->bMsgLBTDown = m_KeyMap[VK_LBUTTON];
		pMsg->bMsgRBTDown = m_KeyMap[VK_RBUTTON];
		pMsg->MsgMouseScrPT = m_MousePT;
		pMsg->MsgMouseWndPT = m_MousePT;
		PointToRect(&pMsg->MsgMouseWndPT, &pMsg->hWnd->m_ScrWindowRect);

		pMsg->m_LogicMousePosWnd = pMsg->MsgMouseWndPT;
		if (pMsg->hWnd->m_Style & 0x8000) //WispWnd
			PointToRect(&pMsg->m_LogicMousePosWnd, &((CWispWnd*)pMsg->hWnd)->m_ClientRect);
			
		bool r = DispatchMessage(pMsg); //pMsg->hWnd->MsgProc(pMsg);// if (!DispatchMessage(pMsg)) return false;

		if (m_bInCriticalSection)
		{
			WakeUpMsgThread();
		}
		return r;
	}
	bool CWispBase::PostMessage(WISP_MSG *pMsg)
	{
		if (!pMsg->hWnd)
			return false;
		
		pMsg->bMsgLBTDown = m_KeyMap[VK_LBUTTON];
		pMsg->bMsgRBTDown = m_KeyMap[VK_RBUTTON];
		pMsg->MsgMouseScrPT = m_MousePT;
		pMsg->MsgMouseWndPT = m_MousePT;
		PointToRect(&pMsg->MsgMouseWndPT, &pMsg->hWnd->m_ScrWindowRect);

		if (m_MsgQueue.Count)
		{
			WISP_MSG *pLastMsg = &m_MsgQueue[m_MsgQueue.Count-1];
			if (pLastMsg->hWnd != pMsg->hWnd || !MergeMessage(pMsg, pLastMsg))
				m_MsgQueue.Append(pMsg);
		} else
		{
			m_MsgQueue.Append(pMsg);
		}

		if (m_bInCriticalSection)
		{
			m_bInCriticalSection = false;
			WakeUpMsgThread();
		}
		return true;
	}
#if 0
	const char *Msg2String(unsigned int Msg)
	{
		switch (Msg)
		{
		case WISP_WM_CREATING:
				return "WISP_WM_CREATING";
		case WISP_WM_CREATE:
				return "WISP_WM_CREATE";
		case WISP_WM_CREATE_FORM:
				return "WISP_WM_CREATE_FORM";
		case WISP_WM_DESTROY:
				return "WISP_WM_DESTROY";
		case WISP_WM_CLOSE:
				return "WISP_WM_CLOSE";

		case WISP_WM_KEY_EVENT:
				return "WISP_WM_KEY_EVENT";

		case WISP_WM_MOUSE_ENTER:
				return "WISP_WM_MOUSE_ENTER";
		case WISP_WM_MOUSE_MOVE:
				return "WISP_WM_MOUSE_MOVE";
		case WISP_WM_MOUSE_LEAVE:
				return "WISP_WM_MOUSE_LEAVE";
		case WISP_WM_MOUSE_WHEEL:
				return "WISP_WM_MOUSE_WHEEL";
		case WISP_WM_MOUSE_DBLCLICK:
				return "WISP_WM_MOUSE_DBLCLICK";

		case WISP_WM_COMMAND:
				return "WISP_WM_COMMAND";
		case WISP_WM_EVENT:
				return "WISP_WM_EVENT";

		case WISP_WM_UPDATE:
				return "WISP_WM_UPDATE";
		case WISP_WM_UPDATE_BORDER:
				return "WISP_WM_UPDATE_BORDER";
		case WISP_WM_UPDATE_CAPTION:
				return "WISP_WM_UPDATE_CAPTION";
		case WISP_WM_UPDATE_CLIENT:
				return "WISP_WM_UPDATE_CLIENT";
		case WISP_WM_UPDATE_CARET:
				return "WISP_WM_UPDATE_CARET";
		case WISP_WM_UPDATE_HORZ_SCROLL_BAR:
				return "WISP_WM_UPDATE_HORZ_SCROLL_BAR";
		case WISP_WM_UPDATE_VERT_SCROLL_BAR:
				return "WISP_WM_UPDATE_VERT_SCROLL_BAR";

		case WISP_WM_BEGIN_MOVE:
				return "WISP_WM_BEGIN_MOVE";
		case WISP_WM_END_MOVE:
				return "WISP_WM_END_MOVE";
		case WISP_WM_MOVE:
				return "WISP_WM_MOVE";
		case WISP_WM_MOVING:
				return "WISP_WM_MOVING";
		case WISP_WM_SIZE:
				return "WISP_WM_SIZE";
		case WISP_WM_SIZING:
				return "WISP_WM_SIZING";
		case WISP_WM_RECALC_LAYOUT:
				return "WISP_WM_RECALC_LAYOUT";
		case WISP_WM_RESIZE_CHILD:
				return "WISP_WM_RESIZE_CHILD";

		case WISP_WM_CHAR:
				return "WISP_WM_CHAR";

		case WISP_WM_SCROLL_EVENT:
				return "WISP_WM_SCROLL_EVENT";

		case WISP_WM_VERT_SCROLL_MOVE:
				return "WISP_WM_VERT_SCROLL_MOVE";
		case WISP_WM_HORZ_SCROLL_MOVE:
				return "WISP_WM_HORZ_SCROLL_MOVE";

		case WISP_WM_TIMER_EVENT:
				return "WISP_WM_TIMER_EVENT";

		case WISP_WM_GET_FOCUS:
				return "WISP_WM_GET_FOCUS";
		case WISP_WM_LOST_FOCUS:
				return "WISP_WM_LOST_FOCUS";

		case WISP_WM_HIT_TEST:
				return "WISP_WM_HIT_TEST";

		case WISP_WM_DRAG_BEGIN:
				return "WISP_WM_DRAG_BEGIN";
		case WISP_WM_DRAG_MOVE:
				return "WISP_WM_DRAG_MOVE";
		case WISP_WM_DRAG_END:
				return "WISP_WM_DRAG_END";
		}
		return "UNKNOWN";
	}
#endif
	//int Level = 0;
	//char Buffer[1024];

	bool CWispBase::DispatchMessage(WISP_MSG *pMsg)
	{
		if (pMsg->hWnd)
		{
			//++Level;
			//int i = 0;
			//for (i = 0; i < Level; i++) //TSPrintf(Buffer, " "); //DebugPrintf(" ");
			//	Buffer[i] = 0x20;
			//TSPrintf(Buffer, "> MSG %x\n", pMsg->Msg);
			//DebugPrintf("MSG %x %s\n", pMsg->Msg, Msg2String(pMsg->Msg));
			//DebugPrintf("%s\n", Buffer);
			return pMsg->hWnd->MsgProc(pMsg); //???
			//for (int i = 0; i < Level; i++) //DebugPrintf(" ");
			//	Buffer[i] = 0x20;
			//DebugPrintf(&Buffer[i], "\n");
			//DebugPrintf("<\n");
			//--Level;
		}

		return false;
	}

	void CWispBase::DispatchMsgQueue()
	{
		while (m_MsgQueue.Count)
		{
			WISP_MSG Msg;
			memcpy(&Msg, &m_MsgQueue[0], sizeof(WISP_MSG)); //Pop()
			m_MsgQueue.Remove();

			DispatchMessage(&Msg);
		}
	}
	void CWispBase::DispatchInputQueue()
	{
		while (m_InputQueue.Count)
		{
			WISP_INPUT *Input = &m_InputQueue[0]; //Pop()
			m_InputQueue.Remove();

			switch (Input->Type)
			{
			case WISP_INPUT_KEY:
				OnKeyEvent(Input->u.KeyEvent.KeyType,
					Input->u.KeyEvent.bKeyDown, Input->u.KeyEvent.ScanCode);
				break;

			case WISP_INPUT_POS:
				OnMousePosChg(Input->u.MousePos.PosX, Input->u.MousePos.PosY);
				break;

			case WISP_INPUT_MOVE:
				OnMouseMove(Input->u.MouseMove.DeltaX, Input->u.MouseMove.DeltaY);
				break;

			case WISP_INPUT_WHEEL:
				OnMouseWheel(Input->u.MouseWheel.Delta);
				break;

			case WISP_INPUT_DBLCLICK:
				OnMouseDblClick(Input->u.MouseDblClick.Button);
				break;

			case WISP_INPUT_TIMER:
				OnTimer(Input->u.Timer.MilliSec);
				break;

			default:
				break;
			}
		}
	}

	void CWispBase::LockUpdate()
	{
		++m_UpdateLockRef;
	}
	void CWispBase::UnlockUpdate()
	{
		if (m_UpdateLockRef > 0)
			--m_UpdateLockRef;
	}

	void CWispBase::Pump()
	{
		m_bActive = true;

		while (m_bActive)
		{
			if (!PumpCondition())
				break;

			EnterMsgCriticalSection();

			DispatchInputQueue();
			DispatchMsgQueue();

			if (m_bActive && m_bNeedUpdate && !m_UpdateLockRef)
			{
				Update();
				m_bNeedUpdate = 0;
			}

			LeaveMsgCriticalSection();

			m_bInCriticalSection = true;
			SleepMsgThread();
			m_bInCriticalSection = false;
		}

		EnterMsgCriticalSection();
		Update();
		LeaveMsgCriticalSection();

		m_bActive = false;
	}

	void CWispBase::PumpQueue()
	{
		if (!m_bActive) return;

		DispatchInputQueue();
		DispatchMsgQueue();

		if (m_bActive && m_bNeedUpdate && !m_UpdateLockRef)
		{
			Update();
			m_bNeedUpdate = 0;
		}

		LeaveMsgCriticalSection();
		m_bInCriticalSection = true;
		SleepMsgThread();
		m_bInCriticalSection = false;
		EnterMsgCriticalSection();
	}

	void CWispBase::BlockPump(CWispBaseWnd *pWnd)
	{
		++m_PumpLockRef;
		while (m_bActive)
		{
			if (!pWnd->IsWindow() || !pWnd->IsWindowShow())
				break;

			DispatchInputQueue();
			DispatchMsgQueue();

			if (m_bActive && m_bNeedUpdate && !m_UpdateLockRef)
			{
				Update();
				m_bNeedUpdate = 0;
			}

			LeaveMsgCriticalSection();
			m_bInCriticalSection = true;
			SleepMsgThread();
			m_bInCriticalSection = false;
			EnterMsgCriticalSection();
		}
		--m_PumpLockRef;
	}
	bool CWispBase::PumpCondition()
	{
		return !m_KeyMap[VK_F12] || !m_KeyMap[VK_CONTROL];
	}

	const WCHAR * CWispBase::GetClipboard()
	{
		return m_ClipString.operator const WCHAR*();
	}
	bool CWispBase::SetClipboard(const WCHAR *Text)
	{
		m_ClipString = Text;
		return true;
	}

	void CWispBase::GetFrameBuffer(WISP_FRAME_BUFFER_INFO *pFrameBuffer)
	{
		switch (pFrameBuffer->Bpp)
		{
		case 4:
			pFrameBuffer->pWispDrawHAL = &m_Draw4Bit;
			break;
		case 8:
			pFrameBuffer->pWispDrawHAL = &m_Draw8Bit;
			break;
		case 16:
			pFrameBuffer->pWispDrawHAL = &m_Draw16Bit;
			break;
		case 24:
			pFrameBuffer->pWispDrawHAL = &m_Draw24Bit;
			break;
		case 32:
			pFrameBuffer->pWispDrawHAL = &m_Draw32Bit;
			break;
		default:
			pFrameBuffer->pWispDrawHAL = &m_DrawHAL;
			break;
		}
	}

	void CWispBase::CaptureMouseEvent(CWispBaseWnd *pWnd)
	{
		m_pMouseEventWnd = pWnd;
	}

	void CWispBase::BeginMove(CWispBaseWnd *pWnd)
	{
		if (!pWnd)
			pWnd = m_pRootWnd;
		m_pMoveWnd = pWnd;
		WISP_MSG Msg;
		Msg.hWnd = pWnd;
		Msg.Msg = WISP_WM_BEGIN_MOVE;
		pWnd->m_State |= 1; //WISP_WSTATE_MOVE
		SendMessage(&Msg);
	}
	void CWispBase::EndMove()
	{
		if (m_pMoveWnd && m_pMoveWnd->IsWindow())
		{
			WISP_MSG Msg;
			Msg.hWnd = m_pMoveWnd;
			Msg.Msg = WISP_WM_END_MOVE;
			Msg.hWnd->m_State &= ~1; //~WISP_WSTATE_MOVE
			SendMessage(&Msg);
			m_pMoveWnd = 0;
		}
	}

	void CWispBase::ResetInput()
	{
		
		memset(m_KeyMap, 0, sizeof(m_KeyMap));
		m_LockMap[0] = 0;
		m_LockMap[1] = 0;
		m_LockMap[2] = 0;

		m_RepKeyIndex = 0;
		m_RepKeyElapse = 0;
		m_RepKeyPeriod = 0;
	}

	void CWispBase::StopMouseKeyRep()
	{
		m_RepKeyIndex = 0;
	}
	void CWispBase::StartMouseKeyRep(unsigned int RepKeyIndex)
	{
		if (m_RepKeyIndex != RepKeyIndex)
		{
			m_RepKeyIndex = RepKeyIndex;
			m_RepKeyElapse = 0;
			m_RepKeyPeriod = 500;
		}
	}

	bool CWispBase::KeySimulateMouse(unsigned int KeyType, bool bKeyDown)
	{
		switch (KeyType)
		{
		case VK_PRIOR:
		case VK_END:
			OnKeyEvent(VK_LBUTTON, bKeyDown, 0);
			break;

		case VK_NEXT:
			OnKeyEvent(VK_RBUTTON, bKeyDown, 0);
			break;

		case VK_LEFT:
		case VK_UP:
		case VK_RIGHT:
		case VK_DOWN:
		{
			int y = 0;
			int x = 0;

			if (m_KeyMap[VK_UP])
				y = -m_KeySimDelta;
			if (m_KeyMap[VK_DOWN])
				y = m_KeySimDelta;
			if (m_KeyMap[VK_LEFT])
				x = -m_KeySimDelta;
			if (m_KeyMap[VK_RIGHT])
				x += m_KeySimDelta;

			if (m_KeySimDelta < 20)
				++m_KeySimDelta;

			OnMousePosChg(x + m_PrevMousePT.x, y + m_PrevMousePT.y);
			break;
		}
		default:
			return false;
			break;
		}
		return true;
	}
	unsigned short CWispBase::IsCharKey(unsigned int KeyType)
	{
		bool bLowCase = m_KeyMap[VK_SHIFT] == false;
		if (m_LockMap[0])	// CAPS LOCK ?
			bLowCase = bLowCase == 0;
		return CWispBase::m_VKKeyChar[m_KeyLangMap][KeyType][bLowCase];
	}

	void CWispBase::OnMousePosChg(int PosX, int PosY)
	{
		if (m_MousePT.x == PosX && m_MousePT.y == PosY)
			return;

		m_MousePT.x = PosX;
		m_MousePT.y = PosY;

		MIN_LIMIT(m_MousePT.x, 0);
		MIN_LIMIT(m_MousePT.y, 0);

		MAX_LIMIT(m_MousePT.x, m_FrameBufferInfo.Width-1);
		MAX_LIMIT(m_MousePT.y, m_FrameBufferInfo.Height-1);

		int DeltaX = m_MousePT.x - m_PrevMousePT.x;
		int DeltaY = m_MousePT.y - m_PrevMousePT.y;

		m_PrevMousePT = m_MousePT;

		if (!m_bHideMouse)
			RedrawNextTime();

		if (m_pMoveWnd && m_pMoveWnd->m_State & 1) //WISP_WSTATE_MOVE
		{
			m_pMoveWnd->Move(DeltaX, DeltaY, true);
			return;
		}

		CWispWnd *pWispWnd = (CWispWnd *)WindowFromPoint(&m_MousePT, m_pRootWnd);
		if (!pWispWnd)
			return;

		//0x200
		if ((pWispWnd->m_Style >> 9) & 1)
			return;

		if (gpCurWisp->m_pDragWnd == m_pMouseEventWnd)
		{
			WISP_MSG MsgMove;
			MsgMove.hWnd = m_pMouseEventWnd;
			MsgMove.Msg = WISP_WM_DRAG_MOVE;
			MsgMove.DragEvent.BeginMouseWndPT = m_BeginPT;
			MsgMove.DragEvent.DeltaX = DeltaX;
			MsgMove.DragEvent.DeltaY = DeltaY;

			gpCurWisp->SendMessage(&MsgMove); //??? ->
			return;
		}


		if (pWispWnd->m_State & 2) //WISP_WSTATE_RESIZE
		{
			pWispWnd->Move(
				-(DeltaX * pWispWnd->m_SignResizeX),
				-(DeltaY * pWispWnd->m_SignResizeY),  true);

			if (!pWispWnd->Resize(
				pWispWnd->m_WindowRect.cx - DeltaX * pWispWnd->m_SignResizeDX,
				pWispWnd->m_WindowRect.cy - DeltaY * pWispWnd->m_SignResizeDY, true))
			{
				m_pMouseEventWnd->m_State &= ~2; //~WISP_WSTATE_RESIZE
				ChangeCursor(WISP_CT_ARROW);
			}
			return;
		}

		WISP_MSG Msg;

		//CWispWnd *pScrollWnd = (CWispWnd*)m_pMouseEventWnd;

		if (pWispWnd != m_pMouseEventWnd)
		{
			if (m_pMouseEventWnd->m_State & 1) //WISP_WSTATE_MOVE
			{
				m_pMouseEventWnd->Move(DeltaX, DeltaY, true);
				return;
			}

			if (m_pMouseEventWnd->m_State & 2) //WISP_WSTATE_RESIZE
			{
				CWispWnd *pScrollWnd = (CWispWnd*)m_pMouseEventWnd;

				m_pMouseEventWnd->Move(
					-(DeltaX * pScrollWnd->m_SignResizeX),
					-(DeltaY * pScrollWnd->m_SignResizeY),
					true);

				if (!m_pMouseEventWnd->Resize(
					m_pMouseEventWnd->m_WindowRect.cx - DeltaX * pScrollWnd->m_SignResizeDX,
					m_pMouseEventWnd->m_WindowRect.cy - DeltaY * pScrollWnd->m_SignResizeDY,
					true))
				{
					m_pMouseEventWnd->m_State &= ~2; //~WISP_WSTATE_RESIZE
					ChangeCursor(WISP_CT_ARROW);
				}
				return;
			}

			Msg.hWnd = pWispWnd;
			Msg.Msg = WISP_WM_HIT_TEST;
			Msg.HitTest.HitArea.Type = 0;
			Msg.HitTest.HitArea.State = 0;
			Msg.HitTest.bKeyDown = m_KeyMap[VK_LBUTTON];

			SendMessage(&Msg);

			WISP_HIT_AREA HitArea = Msg.HitTest.HitArea;

			if (m_pMouseEventWnd->m_Style & 0x8000)
			{
				CWispWnd *pScrollWnd = (CWispWnd*)m_pMouseEventWnd;
				if (pScrollWnd->m_bInResizeArea)
					ChangeCursor(WISP_CT_ARROW);
			}

			Msg.hWnd = m_pMouseEventWnd;
			Msg.Msg = WISP_WM_MOUSE_LEAVE;

			if (m_pMouseEventWnd->m_Style & 0x8000)
			{
				CWispWnd *pScrollWnd = (CWispWnd*)m_pMouseEventWnd;
				if (pScrollWnd->m_pScrollBar[0] &&
					pScrollWnd->m_pScrollBar[0]->State == 2)
					Msg.Msg = WISP_WM_VERT_SCROLL_MOVE;
				else
				if (pScrollWnd->m_pScrollBar[1] &&
					pScrollWnd->m_pScrollBar[1]->State == 2)
					Msg.Msg = WISP_WM_HORZ_SCROLL_MOVE;
			}

			Msg.MouseEvent.HitArea = HitArea;
			Msg.MouseEvent.hWndMouseAt = pWispWnd;
			Msg.MouseEvent.DeltaX = DeltaX;
			Msg.MouseEvent.DeltaY = DeltaY;
			Msg.MouseEvent.Wheel = 0;

			SendMessage(&Msg);

			if (m_pMouseEventWnd == pWispWnd)
			{
				Msg.hWnd = m_pMouseEventWnd;
				Msg.Msg = WISP_WM_MOUSE_ENTER;
				SendMessage(&Msg);
				return;
			}
			return;
		}

		if (m_pModalWnd	&& !pWispWnd->IsChildWndOf(m_pModalWnd)	&& pWispWnd != m_pModalWnd)
			return;

		Msg.hWnd = pWispWnd;
		Msg.Msg = WISP_WM_HIT_TEST;
		Msg.HitTest.HitArea.Type = 0;
		Msg.HitTest.HitArea.State = 0;
		Msg.HitTest.bKeyDown = false;
		SendMessage(&Msg);

		WISP_HIT_AREA HitArea = Msg.HitTest.HitArea;

		unsigned long Type = HitArea.Type & WISP_HT_MASK;

		if (Type == 0)
		{
			if (m_pMouseEventWnd->m_Style & 0x8000)
			{
				CWispWnd *pScrollWnd = (CWispWnd*)m_pMouseEventWnd;
				if (pScrollWnd->m_bInResizeArea)
				{
					ChangeCursor(WISP_CT_ARROW);
					pScrollWnd->m_bInResizeArea = 0;
				}
			}
		} else
		{
			unsigned int CursorType = WISP_CT_ARROW;

			switch (Type)
			{
			case WISP_HT_LEFT: //0x10000:
			case WISP_HT_RIGHT: //0x20000:
				CursorType = WISP_CT_RESIZE_HORZ;
				break;
			case WISP_HT_TOP: //0x40000:
			case WISP_HT_BOTTOM: //0x80000:
				CursorType = WISP_CT_RESIZE_VERT;
				break;
			case WISP_HT_TOPLEFT: //0x50000:
			case WISP_HT_BOTTOMRIGHT: //0xA0000:
				CursorType = WISP_CT_RESIZE_LEFT_LEAN;
				break;
			case WISP_HT_TOPRIGHT: //0x60000:
			case WISP_HT_BOTTOMLEFT: //0x90000:
				CursorType = WISP_CT_RESIZE_RIGHT_LEAN;
				break;

		//	case 0x80000:
		//		CursorType = 1;
		//		break;
		//	case 0x90000:
		//		CursorType = 5;
		//		break;
		//	case 0xA0000:
		//		CursorType = 4;
		//		break;
			}

			if (m_pMouseEventWnd->m_Style & 0x8000)
			{
				CWispWnd *pScrollWnd = (CWispWnd*)m_pMouseEventWnd;
				pScrollWnd->m_bInResizeArea = 1;
				ChangeCursor(CursorType);
			}
		}

		Msg.hWnd = pWispWnd;
		Msg.Msg = WISP_WM_MOUSE_MOVE;
		Msg.MouseEvent.HitArea = HitArea;
		Msg.MouseEvent.hWndMouseAt = pWispWnd;
		Msg.MouseEvent.DeltaX = DeltaX;
		Msg.MouseEvent.DeltaY = DeltaY;
		Msg.MouseEvent.Wheel = 0;

		if (m_MouseHookWndList.Size())
		{
			TListIter<CWispBaseWnd*> it = m_MouseHookWndList.Begin();
			for (; it != m_MouseHookWndList.End(); ++it)
			{
				if (Msg.hWnd != *it)
				{
					Msg.hWnd = *it;
					if (!SendMessage(&Msg))
						return;
				}
			}
		}

		Msg.hWnd = pWispWnd;
		if (pWispWnd->m_Style & 0x8000)
		{
			if (pWispWnd->m_pScrollBar[0] && pWispWnd->m_pScrollBar[0]->State == 2)
				Msg.Msg = WISP_WM_VERT_SCROLL_MOVE;
			else
			if (pWispWnd->m_pScrollBar[1] && pWispWnd->m_pScrollBar[1]->State == 2)
				Msg.Msg = WISP_WM_HORZ_SCROLL_MOVE;
		}

		SendMessage(&Msg);
		return;

	}
	void CWispBase::SendMousePosChg(int PosX, int PosY)
	{
		WISP_INPUT *p = m_InputQueue.Append(0);
		p->Type = WISP_INPUT_POS;
		p->u.MousePos.PosX = PosX;
		p->u.MousePos.PosY = PosY;
	}

	void CWispBase::OnMouseMove(int DeltaX, int DeltaY)
	{
		SendMousePosChg(DeltaX + m_MousePT.x, DeltaY + m_MousePT.y);
	}
	void CWispBase::SendMouseMove(int DeltaX, int DeltaY)
	{
		WISP_INPUT *p = m_InputQueue.Append(0);
		p->Type = WISP_INPUT_MOVE;
		p->u.MouseMove.DeltaX = DeltaX;
		p->u.MouseMove.DeltaY = DeltaY;
	}

	void CWispBase::OnMouseWheel(int Delta)
	{
		if (m_pFocusWnd)
		{
			WISP_MSG Msg;
			Msg.hWnd = m_pFocusWnd;
			Msg.Msg = WISP_WM_MOUSE_WHEEL;
			Msg.MouseEvent.HitArea.Type = 0;
			Msg.MouseEvent.HitArea.State = 0;
			Msg.MouseEvent.hWndMouseAt = Msg.hWnd;
			Msg.MouseEvent.DeltaX = 0;
			Msg.MouseEvent.DeltaY = 0;
			Msg.MouseEvent.Wheel = Delta;
			SendMessage(&Msg);
		}
	}
	void CWispBase::SendMouseWheel(int Delta)
	{
		WISP_INPUT *p = m_InputQueue.Append(0);
		p->Type = WISP_INPUT_WHEEL;
		p->u.MouseWheel.Delta = Delta;
	}

	void CWispBase::OnMouseDblClick(unsigned int Button) //L=1,R=2
	{
		if (m_pFocusWnd)
		{
			if (m_HitArea.Type == 1 ||
			    m_HitArea.Type == 3)
			{
				WISP_MSG Msg;
				Msg.hWnd = m_pFocusWnd;
				Msg.Msg = WISP_WM_MOUSE_DBLCLICK;
				Msg.KeyEvent.HitArea = m_HitArea;
				Msg.KeyEvent.KeyType = Button;
				Msg.KeyEvent.bKeyDown = true;
				Msg.KeyEvent.ScanCode = 0;
				SendMessage(&Msg);
			}
		}
	}
	void CWispBase::SendMouseDblClick(unsigned int Button) //L=1,R=2
	{
		WISP_INPUT *p = m_InputQueue.Append(0);
		p->Type = WISP_INPUT_DBLCLICK;
		p->u.MouseDblClick.Button = Button;
	}

	bool CWispBase::OnProcessKeyEvent(unsigned int KeyType, bool bKeyDown, int ScanCode)
	{
		if (!m_pFocusWnd)
			return false;

		CWispBaseWnd *pWispWnd = m_pFocusWnd;

		if (m_pModalWnd
			&& !pWispWnd->IsChildWndOf(m_pModalWnd)
			&& pWispWnd != m_pModalWnd)
		{
			pWispWnd = m_pModalWnd;
		}

		m_KeyMap[KeyType] = bKeyDown;

		if (KeyType == VK_LSHIFT || KeyType == VK_RSHIFT)
			m_KeyMap[VK_SHIFT] = m_KeyMap[VK_LSHIFT] | m_KeyMap[VK_RSHIFT];

		if (KeyType == VK_LMENU || KeyType == VK_RMENU)
			m_KeyMap[VK_MENU] = m_KeyMap[VK_LMENU] | m_KeyMap[VK_RMENU];

		if (KeyType == VK_LCONTROL || KeyType == VK_RCONTROL)
			m_KeyMap[VK_CONTROL] = m_KeyMap[VK_LCONTROL] | m_KeyMap[VK_RCONTROL];

		if (m_KeyMap[VK_SHIFT])
			m_SpecKey |= WISP_SK_SHIFT;
		else	m_SpecKey &= ~WISP_SK_SHIFT;

		if (m_KeyMap[VK_MENU])
			m_SpecKey |= WISP_SK_ALT;
		else	m_SpecKey &= ~WISP_SK_ALT;

		if (m_KeyMap[VK_CONTROL])
			m_SpecKey |= WISP_SK_CTRL;
		else	m_SpecKey &= ~WISP_SK_CTRL;


		if (m_KeySimulateMouse)
		{
			if (bKeyDown)
			{
				if (KeyType != VK_END &&
				    KeyType != VK_NEXT &&
				    KeyType != VK_PRIOR)
				{
					m_RepKeyIndex = KeyType;
					m_RepKeyElapse = 0;
					m_RepKeyPeriod = 600;
					m_KeySimDelta = 1;
				}
			} else
			if (m_RepKeyIndex == KeyType)
			{
				m_RepKeyIndex = 0;	//StopMouseKeyRep()
			}

			if (KeySimulateMouse(KeyType, bKeyDown))
				return true;
		}

		if (bKeyDown && m_KeyEventList.Size() != 0)
		{
			TListIter<WISP_KEY_EVENT> it = m_KeyEventList.Begin();
			for (; it != m_KeyEventList.End(); ++it)
			{
				if (it->KeyType == KeyType)
				{
					if (it->SpecKey == 0 || it->SpecKey == m_SpecKey)
					{
						WISP_MSG MsgEvent;
						MsgEvent.hWnd = (CWispWnd*)it->pWnd;
						MsgEvent.Msg = WISP_WM_EVENT;
						MsgEvent.Command.CmdMsg = 0x80002000; //WISP_ID_FORM_CLOSE_ID_START
						MsgEvent.Command.CmdID = it->CmdID;

						if ( (it->Disable & 1) == 0
							|| pWispWnd->IsChildWndOf((CWispWnd*)it->pWnd)
							|| pWispWnd == it->pWnd)
						{
							SendMessage(&MsgEvent);
						}
					}
				}
			}
		}

		WISP_MSG Msg;
		Msg.hWnd = pWispWnd;
		Msg.Msg = WISP_WM_KEY_EVENT;
		Msg.KeyEvent.KeyType = m_SpecKey | KeyType;
		Msg.KeyEvent.bKeyDown = bKeyDown;
		Msg.KeyEvent.ScanCode = ScanCode;

		if (m_KeyHookWndList.Size() != 0)
		{
			TListIter<CWispBaseWnd*> it = m_KeyHookWndList.Begin();
			for (; it != m_KeyHookWndList.End(); ++it)
			{
				if (Msg.hWnd != *it)
				{
					Msg.hWnd = *it;
					SendMessage(&Msg);
				}
			}
		}

		if (!((pWispWnd->m_Style>>9)&1)) //0x200
		{
			Msg.hWnd = pWispWnd;
			if (!SendMessage(&Msg))
				return true;
		}

		if (!bKeyDown)
			return true;
		
		if (m_KeyMap[VK_CONTROL] && m_KeyMap[VK_MENU])
		{
			if (m_KeyMap[VK_F1])
			{
				SelectDrawObject(&m_DefDrawObj);
				m_pRootWnd->Update((WISP_RECT*)0); //???
			} else
			if (m_KeyMap[VK_F2])
			{
				SelectDrawObject(&m_DIBDrawObj);
				m_pRootWnd->Update((WISP_RECT*)0); //???
			}
		}


		if (m_SpecKey == 0 || m_SpecKey == WISP_SK_SHIFT)
		{
			if (KeyType == VK_CAPITAL)
				m_LockMap[0] = m_LockMap[0] == 0;

			unsigned short Char = IsCharKey(KeyType);

			if (Char)
			{
				CWispBaseWnd *v21 = m_pFocusWnd;
				if (m_pModalWnd
					&& !v21->IsChildWndOf(m_pModalWnd)
					&& v21 != m_pModalWnd)
				{
					v21 = m_pModalWnd;
				}

				Msg.hWnd = v21;
				Msg.Msg = WISP_WM_CHAR;
				Msg.Char.nRepeat = 1;
				Msg.Char.Char = Char;

				PostMessage(&Msg);

				TListIter<CWispBaseWnd*> it = m_KeyHookWndList.Begin();
				for (; it != m_KeyHookWndList.End(); ++it)
				{
					if (Msg.hWnd != *it)
					{
						Msg.hWnd = *it;
						PostMessage(&Msg);
					}
				}
			}
		}
		return true;
	}

	bool CWispBase::OnProcessMouseKeyEvent(unsigned int KeyType, bool bKeyDown, int ScanCode)
	{
		//TODO???

//		CWispWnd *v4;
		CWispWnd *pWispWnd_v8;
//		int v8;
//		int v9;
//		int v10;
//		int v11;

		WISP_MSG Msg;

		m_KeyMap[KeyType] = bKeyDown;

		if (m_pMoveWnd && m_pMoveWnd->m_State & 1) //WISP_WSTATE_MOVE
		{
			if (KeyType == VK_LBUTTON)
			{
				if (!bKeyDown)
				{
					EndMove();
					return true;
				}
//				goto LABEL_8;
			}
		}
//		else
		if (KeyType == VK_LBUTTON && bKeyDown)
		{
//LABEL_8:
			pWispWnd_v8 = (CWispWnd*)WindowFromPoint(&m_MousePT, m_pRootWnd);
			if (m_pModalWnd
				&& !pWispWnd_v8->IsChildWndOf(m_pModalWnd)
				&& pWispWnd_v8 != m_pModalWnd)
			{
				pWispWnd_v8 = (CWispWnd*)m_pModalWnd;
			}

			if (!pWispWnd_v8)
				return false;

			//???
			if ( (pWispWnd_v8->m_Style >> 9) & 1 )
				return true;

			if (pWispWnd_v8 != m_pFocusWnd)
				pWispWnd_v8->Focus();
		} else
		{
			pWispWnd_v8 = (CWispWnd*)m_pMouseEventWnd;
			if (m_pModalWnd
				&& !pWispWnd_v8->IsChildWndOf(m_pModalWnd)
				&& pWispWnd_v8 != m_pModalWnd)
			{
				pWispWnd_v8 = (CWispWnd*)m_pModalWnd;
			}

			//???
			if ( (pWispWnd_v8->m_Style >> 9) & 1 )
				return true;
		}

		Msg.hWnd = pWispWnd_v8;

		if (!bKeyDown)
		{
			if (m_RepKeyIndex == KeyType)
				StopMouseKeyRep();

			Msg.Msg = WISP_WM_HIT_TEST;
			Msg.HitTest.HitArea.Type = 0;
			Msg.HitTest.HitArea.State = 0;
			Msg.HitTest.bKeyDown = false;
			SendMessage(&Msg);

			Msg.KeyEvent.HitArea = Msg.HitTest.HitArea;
			Msg.hWnd = pWispWnd_v8;
			Msg.Msg = WISP_WM_KEY_EVENT;
			Msg.KeyEvent.KeyType = KeyType;
			Msg.KeyEvent.bKeyDown = false;
			Msg.KeyEvent.ScanCode = ScanCode;
			SendMessage(&Msg);

			if (KeyType == VK_LBUTTON)
			{
				if (pWispWnd_v8->m_State & 2) //WISP_WSTATE_RESIZE
				{
					pWispWnd_v8->m_State &= ~2; //~WISP_WSTATE_RESIZE
					ChangeCursor(WISP_CT_ARROW);
				}
			}
			return true;
		}

		if (pWispWnd_v8->m_AdvStyle & 4) //WISP_ADV_CANMOVE
		{
			if (pWispWnd_v8->m_State & 5) //WISP_WSTATE_MAXIMIZE | WISP_WSTATE_MOVE
				return true;

			pWispWnd_v8->m_State |= 1;	//WISP_WSTATE_MOVE
			Msg.Msg = WISP_WM_BEGIN_MOVE;
			SendMessage(&Msg);
			return true;
		}

		Msg.Msg = WISP_WM_HIT_TEST;
		Msg.HitTest.HitArea.Type = 0;
		Msg.HitTest.HitArea.State = 0;
		Msg.HitTest.bKeyDown = bKeyDown;

		if ((pWispWnd_v8->m_Style & 0x8000) == 0)
		{
			SendMessage(&Msg);

			Msg.KeyEvent.HitArea = Msg.HitTest.HitArea;
			Msg.hWnd = pWispWnd_v8;
			Msg.Msg = WISP_WM_KEY_EVENT;
			Msg.KeyEvent.KeyType = KeyType;
			Msg.KeyEvent.bKeyDown = bKeyDown;
			Msg.KeyEvent.ScanCode = ScanCode;
			SendMessage(&Msg);
			return true;
		}

		SendMessage(&Msg);

		m_HitArea = Msg.HitTest.HitArea;

		//1-ON_SCRCLIENT,2-ON_CAP,3-ON_RCCLIENT,4-ON_CLOSE,5-ON_MAX,6-ON_MIN,
		switch (m_HitArea.Type)
		{
		case 2:
			if (KeyType == VK_LBUTTON && !(pWispWnd_v8->m_State & 5) ) //WISP_WSTATE_MAXIMIZE | WISP_WSTATE_MOVE
			{
				BeginMove(pWispWnd_v8);
				return true;
			}
			return true;
		case 1:
		case 3:
//LABEL_55:
			Msg.Msg = WISP_WM_KEY_EVENT;
			Msg.KeyEvent.KeyType = KeyType;
			Msg.KeyEvent.bKeyDown = bKeyDown;
			Msg.KeyEvent.ScanCode = ScanCode;
			SendMessage(&Msg);
			return true;
		}

		if (KeyType == VK_LBUTTON && (m_HitArea.Type & WISP_HT_MASK)) //0xF0000)) //MASK
		{
			pWispWnd_v8->m_SignResizeDY = 0;
			pWispWnd_v8->m_SignResizeY = 0;
			pWispWnd_v8->m_SignResizeDX = 0;
			pWispWnd_v8->m_SignResizeX = 0;

			if (m_HitArea.Type & WISP_HT_LEFT) //0x10000)	//HORZ	LEFT
			{
				pWispWnd_v8->m_SignResizeX = -1;
				pWispWnd_v8->m_SignResizeDX = 1;
			}

			if (m_HitArea.Type & WISP_HT_RIGHT) //0x20000)	//HORZ	RIGHT
			{
				pWispWnd_v8->m_SignResizeX = 0;
				pWispWnd_v8->m_SignResizeDX = -1;
			}

			if (m_HitArea.Type & WISP_HT_TOP) //0x40000)	//VERT	TOP
			{
				pWispWnd_v8->m_SignResizeY = -1;
				pWispWnd_v8->m_SignResizeDY = 1;
			}

			if (m_HitArea.Type & WISP_HT_BOTTOM) //0x80000)	//VERT BOTTOM
			{
				pWispWnd_v8->m_SignResizeY = 0;
				pWispWnd_v8->m_SignResizeDY = -1;
			}
			pWispWnd_v8->m_State |= 2; //WISP_WSTATE_RESIZE
		}
		return true;
	}

	void CWispBase::OnKeyEvent(unsigned int KeyType, bool bKeyDown, int ScanCode)
	{
		if (!m_bKeyMutex)
		{
			if (KeyType <= 7) //??? MOUSE VS KEY
				OnProcessMouseKeyEvent(KeyType, bKeyDown, ScanCode);
			else	OnProcessKeyEvent(KeyType, bKeyDown, ScanCode);
		}

	}
	void CWispBase::SendKeyEvent(unsigned int KeyType, bool bKeyDown, int ScanCode)
	{
		WISP_INPUT *p = m_InputQueue.Append(0);
		p->Type = WISP_INPUT_KEY;
		p->u.KeyEvent.KeyType = KeyType;
		p->u.KeyEvent.bKeyDown = bKeyDown;
		p->u.KeyEvent.ScanCode = ScanCode;
	}

	void CWispBase::LockTimer()
	{
		++m_TimerLockRef;
	}
	void CWispBase::UnlockTimer()
	{
		if (m_TimerLockRef > 0)
			--m_TimerLockRef;
	}

	void CWispBase::OnTimer(int MilliSec)
	{
		WISP_MSG MsgHit;
		WISP_MSG Msg;

		if (m_TimerLockRef > 0)
			return;
		
		if (m_RepKeyIndex)
		{
			m_RepKeyElapse += MilliSec;
			if (m_KeySimulateMouse)
				KeySimulateMouse(m_RepKeyIndex, 1);

			if (m_RepKeyElapse >= m_RepKeyPeriod)
			{
				m_RepKeyElapse -= m_RepKeyPeriod;
				if (m_RepKeyIndex < 7)	//??? MOUSE VS KEY
				{
					if (m_RepKeyPeriod == 500)
						m_RepKeyPeriod = 50;
				} else
				{
					if (m_RepKeyPeriod == 600)
						m_RepKeyPeriod = 15;
				}

				Msg.hWnd = m_pFocusWnd;
				Msg.Msg = WISP_WM_KEY_EVENT;

				if (m_RepKeyIndex == VK_LBUTTON)
				{
					MsgHit.hWnd = m_pFocusWnd;
					MsgHit.Msg = WISP_WM_HIT_TEST;
					MsgHit.HitTest.HitArea.Type = 0;
					MsgHit.HitTest.HitArea.State = 0;
					MsgHit.HitTest.bKeyDown = true;

					SendMessage(&MsgHit);

					Msg.KeyEvent.HitArea = MsgHit.KeyEvent.HitArea;
				}

				Msg.KeyEvent.KeyType = m_RepKeyIndex;
				Msg.KeyEvent.bKeyDown = true;
				SendMessage(&Msg);

				unsigned short Char = IsCharKey(m_RepKeyIndex);

				if (Char)
				{
					CWispWnd *hWnd = (CWispWnd *)m_pFocusWnd;
					if (m_pModalWnd
						&& !hWnd->IsChildWndOf(m_pModalWnd)
						&& hWnd != m_pModalWnd)
					{
						hWnd = (CWispWnd *)m_pModalWnd;
					}
					Msg.hWnd = hWnd;
					Msg.Msg = WISP_WM_CHAR;
					Msg.Char.nRepeat = 1;
					Msg.Char.Char = Char;

					SendMessage(&Msg);
				}
			}
		}

		map<WISP_TIMER_KEY, WISP_TIMER>::IT it = m_TimerList.begin();
		while (it != m_TimerList.end())
		{
			map<WISP_TIMER_KEY, WISP_TIMER>::IT cur = it++;
			if (MilliSec <= cur->second.Period)
			{
				cur->second.Elapse += MilliSec;
				if (cur->second.Elapse > cur->second.Period)
				{
					cur->second.Elapse -= cur->second.Period;
					Msg.hWnd = cur->first.pWnd;
					Msg.Msg = WISP_WM_TIMER_EVENT;
					Msg.Timer.ID = cur->first.ID;
					Msg.Timer.UserData = cur->second.UserData;
					Msg.Timer.UserPtr = cur->second.UserPtr;
					SendMessage(&Msg);
				}
			}
		}
	}

	void CWispBase::SendTimer(int MilliSec)
	{
		WISP_INPUT *p = m_InputQueue.Append(0);
		p->Type = WISP_INPUT_TIMER;
		p->u.Timer.MilliSec = MilliSec;
	}

	void CWispBase::AdjustColor()
	{
		for (int i = 0; i < lenof(m_pWispDrawObj->m_crSystem); ++i)
			m_pWispDrawObj->m_crSystem[i] = FindFitColor(m_pWispDrawObj->m_crSystem[i], m_PalColors);
	}

	void CWispBase::OnFrameBufferBppChg(int Bpp)
	{
		m_FrameBufferInfo.Bpp = Bpp;
		switch (Bpp)
		{
		case 4:
			m_FrameBufferInfo.pWispDrawHAL = &m_Draw4Bit;
			break;
		case 8:
			m_FrameBufferInfo.pWispDrawHAL = &m_Draw8Bit;
			break;
		case 16:
			m_FrameBufferInfo.pWispDrawHAL = &m_Draw16Bit;
			break;
		case 24:
			m_FrameBufferInfo.pWispDrawHAL = &m_Draw24Bit;
			break;
		case 32:
			m_FrameBufferInfo.pWispDrawHAL = &m_Draw32Bit;
			break;
		default:
			m_FrameBufferInfo.pWispDrawHAL = &m_DrawHAL;
			break;
		}

		if (Bpp == 8)
		{
			LoadPalette();
			AdjustColor();
		}
	}

	void CWispBase::OnCreateMousePos(int PosX, int PosY)
	{
		m_MousePT.x = PosX;
		m_MousePT.y = PosY;

		m_PrevMousePT.x = PosX;
		m_PrevMousePT.y = PosY;
	}

//	bool CWispBase::GetOpenFolderName(WCHAR *Path, const WCHAR *Title) { return false; }
//	bool CWispBase::GetOpenFileName(const WCHAR *InitialDir, const WCHAR *Filter, int, WCHAR *File, int MaxFile) { return false; }

//	void CWispBase::ReportMsg(const WCHAR *Format, ...) { }

	int CWispBase::GetMetrics(unsigned int Type)
	{
		return (Type < WISP_SM_COUNT) ? m_Metrics[Type] : 0;
	}

	bool CWispBase::SelectDrawObject(CWispDrawObj *pDrawObj)
	{
		if (m_pWispDrawObj == pDrawObj)
		{
			if (m_pWispDrawObj)
			{
				m_pWispDrawObj->Release();
				return m_pWispDrawObj->Init();
			}
			return false;
		}

		if (pDrawObj && !pDrawObj->Init())
			return false;

		if (m_pWispDrawObj)
			m_pWispDrawObj->Release();
		m_pWispDrawObj = pDrawObj;
		return true;
	}

	CWispDIB *CWispBase::GetDefDIB(unsigned int ID)
	{
		return (ID < WISP_DI_COUNT) ? &m_DefDIB[ID] : 0;
	}

	void *CWispBase::GetScreenBuffer(int x, int y)
	{
		return (char*)m_FrameBufferInfo.VideoBuffer
				+ y * m_FrameBufferInfo.LineDistance
				+ x * m_FrameBufferInfo.Bpp / 8;
	}

	bool CWispBase::CopyToScreen(WISP_FRAME_BUFFER_INFO *pRealScreen, WISP_POINT *pPT, WISP_RECT *pRect)
	{
		CWispDrawHAL *pDrawHAL;
		WISP_RECT rcClip;
		WISP_RECT rc;

		  if (!pRealScreen->VideoBuffer)
			return false;

		int xoff, yoff;

		if (pPT)
		{
			xoff = pPT->x;
			yoff = pPT->y;
		} else
		{
			xoff = (pRealScreen->Width - m_FrameBufferInfo.Width) / 2; //CENTER_ALIGN
			yoff = (pRealScreen->Height - m_FrameBufferInfo.Height) / 2;
			MIN_LIMIT(xoff, 0);
			MIN_LIMIT(yoff, 0);
		}

		if (pRect)
		{
			xoff += pRect->x;
			yoff += pRect->y;

			rc.x = xoff;
			rc.y = yoff;
			rc.cx = pRect->cx;
			rc.cy = pRect->cy;
		} else
		{
			rc.x = xoff;
			rc.y = yoff;
			rc.cx = m_FrameBufferInfo.Width;
			rc.cy = m_FrameBufferInfo.Height;
		}

		switch (pRealScreen->Bpp)
		{
		case 4:
			pDrawHAL = &m_Draw4Bit;
			break;
		case 8:
			pDrawHAL = &m_Draw8Bit;
			break;
		case 16:
			pDrawHAL = &m_Draw16Bit;
			break;
		case 24:
			pDrawHAL = &m_Draw24Bit;
			break;
		case 32:
			pDrawHAL = &m_Draw32Bit;
			break;
		default:
			pDrawHAL = &m_DrawHAL;
			break;
		}

		if (pRect)
		{
			xoff -= pRect->x;
			yoff -= pRect->y;
		}


		rcClip.x = 0;
		rcClip.y = 0;
		rcClip.cx = pRealScreen->Width;
		rcClip.cy = pRealScreen->Height;

		if (ClipRect(&rc, &rcClip))
		{
			yoff = -yoff;
			for (int y = 0; y < rc.cy; ++y)
			{
				pDrawHAL->CopyToPixel((char*)pRealScreen->VideoBuffer +
							pRealScreen->LineDistance * (rc.y + y) +
							rc.x * pRealScreen->Bpp / 8,

							(char*)m_FrameBufferInfo.VideoBuffer +
							m_FrameBufferInfo.LineDistance * (rc.y + yoff) +
							m_FrameBufferInfo.Bpp * (rc.x - xoff) / 8,

							rc.cx);
				++yoff;
			}
		}

		return true;
	}

	bool CWispBase::CopyScreenToFile(const char *FileName)
	{
		CWispDIB DIB;
		DIB.m_PixelBuf = m_FrameBufferInfo;
		bool ret = DIB.Write(FileName);
		memset(&DIB.m_PixelBuf, 0, sizeof(DIB.m_PixelBuf));
		return ret;
	}

	int CWispBase::MsgBox(const WCHAR *pText, const WCHAR *pCaption, unsigned int uType, CWispBaseWnd *pParentWnd)
	{
		return CWispMsgBox::StaticShowMsgBox(pText, pCaption, uType, pParentWnd);
	}

```

`source/Wisp/wispbase.hpp`:

```hpp

#ifndef _WISPBASE_HPP_
#define _WISPBASE_HPP_

#include "../Code/define.h"
//#include "../Code/osdefine.hpp"
#include "../Code/alt/altqueue.hpp"
#include "../Code/alt/altlist.hpp"
#include "../Code/alt/altmap.hpp"
#include "../Code/tstrmem.hpp"
#include "../Code/polyfs.hpp"
#include "utility.hpp"
#include "wispdraw.hpp"
#include "wispdib.hpp"
#include "wispfont.hpp"
#include "wispdrawobj.hpp"
#include "wispmsg.hpp"

	//forward decl

	struct CWispBaseWnd; //TODO
	struct CWispWnd; //???
	struct CWispTipWnd; //???

	//=====

	#define WISP_SK_SHIFT	0x10000000
	#define WISP_SK_ALT	0x20000000
	#define WISP_SK_CTRL	0x40000000


	struct WISP_INPUT
	{
		unsigned int Type;

		#define WISP_INPUT_KEY		0x70000001
		#define WISP_INPUT_POS		0x70000002
		#define WISP_INPUT_MOVE		0x70000003
		#define WISP_INPUT_WHEEL	0x70000004
		#define WISP_INPUT_DBLCLICK	0x70000005
		#define WISP_INPUT_TIMER	0x70000006

		union 
		{
			struct {
				unsigned int KeyType;
				unsigned char bKeyDown;
				unsigned char ScanCode;
			} KeyEvent;

			struct {
				unsigned int PosX;
				unsigned int PosY;
			} MousePos;

			struct {

				unsigned int DeltaX;
				unsigned int DeltaY;
			} MouseMove;

			struct {
				int Delta;
			} MouseWheel;

			struct {
				unsigned int Button;
			} MouseDblClick;

			struct {
				unsigned int MilliSec;
			} Timer;
		} u;
	};

	struct WISP_TIMER_KEY
	{
		CWispBaseWnd *pWnd;
		unsigned int ID;

		bool operator<(const WISP_TIMER_KEY & other) const
		{
			if (pWnd < other.pWnd) return true;
			if (pWnd > other.pWnd) return false;
			return ID < other.ID;
		}
	};

	struct WISP_TIMER
	{
		unsigned long Elapse; //int ???
		unsigned long Period; //int ???
		unsigned int UserData;
		void *UserPtr;
	};

	struct WISP_KEY_EVENT
	{
		unsigned long KeyType;
		unsigned long SpecKey;
		unsigned long CmdID;
		unsigned long Disable;
		CWispWnd *pWnd;
	};

	enum WISP_HT_TYPE
	{
		WISP_HT_LEFT	= 0x10000,	//1<<16
		WISP_HT_RIGHT	= 0x20000,	//1<<17
		WISP_HT_TOP	= 0x40000,	//1<<18
		WISP_HT_BOTTOM	= 0x80000,	//1<<19

		WISP_HT_TOPLEFT		= WISP_HT_TOP|WISP_HT_LEFT,	//0x50000,
		WISP_HT_TOPRIGHT	= WISP_HT_TOP|WISP_HT_RIGHT,	//0x60000,
		WISP_HT_BOTTOMLEFT	= WISP_HT_BOTTOM|WISP_HT_LEFT,	//0x90000,
		WISP_HT_BOTTOMRIGHT	= WISP_HT_BOTTOM|WISP_HT_RIGHT,	//0xA0000,

		WISP_HT_MASK = 0xF << 16,
	};

	//m_Metrics[]

	enum WISP_SM
	{
		WISP_SM_CAPTION_CY = 0,
		WISP_SM_BORDER_SIZE = 1,
		WISP_SM_TIP_BORDER_SIZE = 2,
		WISP_SM_SCREEN_CX = 3,
		WISP_SM_SCREEN_CY = 4,
		WISP_SM_CAPTION_BT_SIZE = 5,
		WISP_SM_SCROLL_BAR_SIZE = 6,
		WISP_SM_TOOLBAR_CY = 7,
		WISP_SM_RESIZE_SIZE = 8,
		WISP_SM_COUNT = 9,
	};

	enum WISP_DIB_TYPE
	{
		WISP_DI_CARET = 0,
		WISP_DI_CURSOR = 1,
		WISP_DI_RESIZE = 2,
		WISP_DI_COUNT = 3,
	};

	enum 
	{
		WISP_CT_ARROW = 0,
		WISP_CT_RESIZE_VERT = 1,
		WISP_CT_RESIZE_HORZ = 2,
		WISP_CT_DRAG = 3,
		WISP_CT_RESIZE_LEFT_LEAN = 4,
		WISP_CT_RESIZE_RIGHT_LEAN = 5,
		WISP_CT_PENDING = 6,
	};

	//============

	struct CWispBase
	{
		bool m_bActive;
		bool m_bInCriticalSection;

		CWispDrawObj *m_pWispDrawObj;
		CWispDrawObj m_DefDrawObj;
		CWispDIBDrawObj m_DIBDrawObj;

		CWispDrawHAL m_DrawHAL;
		CWispDraw32Bit m_Draw32Bit;
		CWispDraw24Bit m_Draw24Bit;
		CWispDraw16Bit m_Draw16Bit;
		CWispDraw8Bit m_Draw8Bit;
		CWispDraw4Bit m_Draw4Bit;

		TWideString m_ClipString;

		bool m_KeyMap[256];
		bool m_LockMap[3];	//0 CAPSLOCK,
		static unsigned short m_VKKeyChar[2][256][2];

		WISP_POINT m_MousePT;
		WISP_POINT m_PrevMousePT;
		WISP_POINT m_MouseCursorPos;
		WISP_SIZE m_MouseCursorSize;
		WISP_RECT m_MouseRectUpd;
		WISP_HIT_AREA m_HitArea;

		bool m_bUpdate;
		int m_UpdateLockRef;
		unsigned int m_CursorType;
		unsigned int m_CursorTypeBak;
		CWispDIB *m_pCursorDIB;
		CWispDIB *m_pCursorDIBBak;
		int m_PumpLockRef;

		CWispBaseWnd *m_pRootWnd;

		CWispWnd *m_pTopMostRootWnd;
		CWispTipWnd *m_pTipWnd;
		char m_szModuleName[MAX_PATH];
		const char *m_szWispResource;
		CWispBaseWnd *m_pMoveWnd;
		CWispBaseWnd *m_pDragWnd;
		WISP_POINT m_BeginPT;
		CPFSFileIO m_PFSFileIO;
		CWispFont m_FontList[WISP_FONT_COUNT];
		static WISP_PHYS_FONT_INFO m_PhysFontInfo[WISP_FONT_COUNT];

		CWispBaseWnd *m_pMouseEventWnd;
		CWispBaseWnd *m_pFocusWnd;
		CWispBaseWnd *m_pModalWnd;
		CWispDIB m_DefDIB[WISP_DI_COUNT];
		CWispDIBLib m_DIBLib;
		int m_Metrics[WISP_SM_COUNT];

		WISP_FRAME_BUFFER_INFO m_FrameBufferInfo;

		TQueue<WISP_INPUT,128> m_InputQueue; //TStack
		TQueue<WISP_MSG,128> m_MsgQueue; //TStack
		map<WISP_TIMER_KEY, WISP_TIMER> m_TimerList;
		TList<WISP_KEY_EVENT> m_KeyEventList;
		bool m_bNeedUpdate;

		unsigned long m_PalColors[256];
		static unsigned long m_DefColorPal[256];

		unsigned int m_RepKeyIndex;
		int m_RepKeyElapse;
		int m_RepKeyPeriod;
		unsigned int m_SpecKey;
		TList<CWispBaseWnd*> m_KeyHookWndList;
		TList<CWispBaseWnd*> m_MouseHookWndList;

		bool m_KeySimulateMouse;
		bool m_bHideMouse;
		int m_KeySimDelta;

		int m_BaseWndCount;
		int m_WndCount;
		int m_bKeyMutex;
		int m_TimerLockRef;
		int m_FontIndex;
		int m_KeyLangMap;

	public:
		CWispBase();
		virtual ~CWispBase();

		virtual bool Init();
		virtual void Release();

		virtual bool CreateFrame(const WCHAR *WndName, int Width, int Height, int Bpp) = 0;
		virtual void DestroyFrame() = 0;

		virtual bool EndResize(int Width, int Height) { return false; }
		virtual bool BeginResize(int Width, int Height) { return false; }
		virtual bool MovingFrame(int PosX, int PosY) { return false; }

		virtual void BeginDrag() { }
		virtual void EndDrag() { }

		void RedrawNextTime();
		virtual bool WakeUpMsgThread() { return true; }
		virtual bool SleepMsgThread() { return true; }

		virtual void EnterMsgCriticalSection() { }
		virtual void LeaveMsgCriticalSection() { }

		virtual void BeginDraw(WISP_RECT *pRect) { }
		virtual void EndDraw(WISP_RECT *pRect) { }

		virtual void SetCursor(unsigned int CursorType, WISP_POINT *pHotPT, WISP_SIZE *pSize, CWispDIB *pDIB);
		virtual void ChangeCursor(LONG_PTR Style, unsigned int CursorType, WISP_POINT *pHotPT, WISP_SIZE *pSize) { }
		void ChangeCursor(unsigned int CursorType);
		void ChangeCursor(CWispDIB *pCursorDIB);

		virtual void Update();
		virtual void UpdateCursor();

		virtual bool InsertTimer(const WISP_TIMER &) { return true; }
		virtual bool RemoveTimer(const WISP_TIMER &) { return true; }

		virtual unsigned long GetPalColor(int Index);
		virtual bool SetPalColor(int Index, unsigned long Color);
		virtual void LoadPalette();

		void RemoveWnd(CWispBaseWnd *pWnd);
		void RemoveWndMsg(CWispBaseWnd *pWnd);
		void InsertWnd(CWispBaseWnd *pParentWnd, CWispBaseWnd *pNewWnd);
		CWispBaseWnd *WindowFromPoint(WISP_POINT *pPoint, CWispBaseWnd *pParentWnd);

		bool MergeMessage(WISP_MSG *pNewMsg, WISP_MSG *pMergeMsg);
		//GetMessage
		bool SendMessage(WISP_MSG *pMsg);
		bool PostMessage(WISP_MSG *pMsg);
		bool DispatchMessage(WISP_MSG *pMsg);

		void DispatchMsgQueue();
		void DispatchInputQueue();

		void LockUpdate();
		void UnlockUpdate();

		virtual void Pump();
		void PumpQueue();
		virtual void BlockPump(CWispBaseWnd *pWnd);
		virtual bool PumpCondition();

		virtual const WCHAR *GetClipboard();
		virtual bool SetClipboard(const WCHAR *Text);

		virtual void GetFrameBuffer(WISP_FRAME_BUFFER_INFO *pFrameBuffer);

		void CaptureMouseEvent(CWispBaseWnd *pWnd);

		void BeginMove(CWispBaseWnd *pWnd);
		void EndMove();

		void ResetInput();
		void StopMouseKeyRep();
		void StartMouseKeyRep(unsigned int RepKeyIndex);

		bool KeySimulateMouse(unsigned int KeyType, bool bKeyDown);
		unsigned short IsCharKey(unsigned int KeyType);

		virtual void OnMousePosChg(int PosX, int PosY);
		virtual void SendMousePosChg(int PosX, int PosY);

		virtual void OnMouseMove(int DeltaX, int DeltaY);
		virtual void SendMouseMove(int DeltaX, int DeltaY);

		virtual void OnMouseWheel(int Delta);
		virtual void SendMouseWheel(int Delta);

		virtual void OnMouseDblClick(unsigned int Button);
		virtual void SendMouseDblClick(unsigned int Button);

		bool OnProcessKeyEvent(unsigned int KeyType, bool bKeyDown, int ScanCode);
		bool OnProcessMouseKeyEvent(unsigned int KeyType, bool bKeyDown, int ScanCode);

		virtual void OnKeyEvent(unsigned int KeyType, bool bKeyDown, int ScanCode);
		virtual void SendKeyEvent(unsigned int KeyType, bool bKeyDown, int ScanCode);

		void LockTimer();
		void UnlockTimer();

		virtual void OnTimer(int MilliSec);
		virtual void SendTimer(int MilliSec);

		void AdjustColor();
		virtual void OnFrameBufferBppChg(int Bpp);

		virtual void OnCreateMousePos(int PosX, int PosY);

		virtual bool GetOpenFolderName(WCHAR *Path, const WCHAR *Title) { return false; }
		virtual bool GetOpenFileName(const WCHAR *InitialDir, const WCHAR *Filter, int, WCHAR *File, int MaxFile) { return false; }

		virtual void ReportMsg(const WCHAR *Format, ...) { }

		virtual int GetMetrics(unsigned int Type);

		bool SelectDrawObject(CWispDrawObj *pDrawObj);
		CWispDIB *GetDefDIB(unsigned int ID);

		void *GetScreenBuffer(int x, int y);
		bool CopyToScreen(WISP_FRAME_BUFFER_INFO *pRealScreen, WISP_POINT *pPT, WISP_RECT *pRect);
		bool CopyScreenToFile(const char *FileName);

		int MsgBox(const WCHAR *pText, const WCHAR *pCaption, unsigned int uType, CWispBaseWnd *pParentWnd);
	};

	extern CWispBase *gpCurWisp;
#endif

```

`source/Wisp/wispbasewnd.cpp`:

```cpp

//#include "../Code/osdefine.hpp"
#include "../Code/define.h"
#include "../Code/sysdep.hpp"

#include "wispbase.hpp"
#include "wispbasewnd.hpp"
#include "wispwnd.hpp"
#include "wisptipwnd.hpp"
#include "wispmsgbox.hpp"

	CWispBaseWnd::CWispBaseWnd()
	{
		m_Style = 0;
		m_ShowMode = WISP_SH_NORMAL;
		m_State = WISP_WSTATE_INIT;
		m_ParentWnd = 0;
		m_CtrlType = WISP_CTRL_BASE_WND;
		m_pUpdateRC = 0;
		m_IsWindow = 0;
	}
	CWispBaseWnd::~CWispBaseWnd()
	{
		if (m_ShowMode == WISP_SH_MODAL_BLOCK)
			Destroy();
	}

	bool CWispBaseWnd::Create(const WCHAR *Name, int x, int y, int cx, int cy, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int Style, unsigned int ShowMode)
	{
		WISP_MSG Msg;

		m_pWispBase = gpCurWisp;

		if (!pParentWnd)
		{
			if (m_pWispBase->m_pRootWnd)
			{
				pParentWnd = m_pWispBase->m_pTopMostRootWnd;
			} else
			{
				m_pWispBase->m_pRootWnd = this;
				m_pWispBase->m_pMouseEventWnd = this;
				m_pWispBase->m_pFocusWnd = this;
				pParentWnd = m_pWispBase->m_pRootWnd;
				m_pWispBase->m_Metrics[WISP_SM_SCREEN_CX] = cx;
				m_pWispBase->m_Metrics[WISP_SM_SCREEN_CY] = cy;

				m_pWispBase->OnCreateMousePos(
					m_pWispBase->m_FrameBufferInfo.Width / 2,
					m_pWispBase->m_FrameBufferInfo.Height / 2);

				m_pWispBase->m_MouseRectUpd.x = 0;
				m_pWispBase->m_MouseRectUpd.y = 0;
				m_pWispBase->m_MouseRectUpd.cx = 0;
				m_pWispBase->m_MouseRectUpd.cy = 0;
				m_pWispBase->ChangeCursor(WISP_CT_ARROW);
				m_pWispBase->OnFrameBufferBppChg(m_pWispBase->m_FrameBufferInfo.Bpp);
			}
		}

		if (m_pWispBase->m_pRootWnd == this)
		{
			m_ScrWindowRect.x = x;
			m_ScrWindowRect.y = y;
		} else
		{
			m_ScrWindowRect.x = x + ((CWispWnd*)pParentWnd)->m_ScrClientRect.x; //???
			m_ScrWindowRect.y = y + ((CWispWnd*)pParentWnd)->m_ScrClientRect.y; //???
		}

		m_ScrWindowRect.cx = cx;
		m_WindowRect.cx = cx;

		m_ScrWindowRect.cy = cy;
		m_WindowRect.cy = cy;

		m_Style = Style;
		m_WindowRect.y = 0;
		m_WindowRect.x = 0;
		m_State = WISP_WSTATE_RESET;
		m_CmdID = CmdID;
		m_ParentWnd = 0;
		m_ChildTopWnd = 0;
		m_ChildWnd = 0;
		m_NextWnd = 0;
		m_PrevWnd = 0;
		m_PrevModalWnd = 0;

		m_pWispBase->InsertWnd(pParentWnd, this);
		m_OwnerWnd = m_ParentWnd;

		if (!m_WindowDC.Create(this, &m_ScrWindowRect))
			return false;

		if (Name)
			m_WndText = Name;

		if (m_Style & 0x8000)
		{
			m_IsWindow = 0x77777777;
			return true;
		}
		
		if (!InitWnd())
		{
			m_WndText.Empty();
			return false;
		}

		m_IsWindow = 0x77777777;
		Msg.hWnd = this;
		Msg.Msg = WISP_WM_CREATE;
		if (!m_pWispBase->SendMessage(&Msg))
		{
			Destroy();
			return false;
		}

		Show(ShowMode);
		return true;
	}
	bool CWispBaseWnd::Destroy()
	{
		if (m_IsWindow != 0x77777777)
			return false;

		WISP_MSG Msg;
		Msg.Msg = WISP_WM_DESTROY;
		Msg.hWnd = (CWispWnd *)this;
		if (!m_pWispBase->SendMessage(&Msg))
			return false;

		if ( (CWispBaseWnd *)m_pWispBase->m_pMouseEventWnd == this)
			m_pWispBase->m_pMouseEventWnd = (CWispWnd *)m_pWispBase->m_pRootWnd;

		CWispBaseWnd *pWnd = m_ChildWnd;
		while (pWnd)
		{
			CWispBaseWnd *old = pWnd;
			pWnd = pWnd->m_NextWnd;
			if (!old->Destroy())
				return false;
		}

		m_pWispBase->RemoveWndMsg(this);
		m_pWispBase->RemoveWnd(this);
		m_WindowDC.Destroy();

		if (m_pWispBase->m_pFocusWnd == this)
			m_pWispBase->m_pFocusWnd = m_pWispBase->m_pRootWnd != this ? m_pWispBase->m_pRootWnd : 0;

		if (m_pWispBase->m_pModalWnd == this)
		{
			m_pWispBase->m_pModalWnd = m_PrevModalWnd;
			m_PrevModalWnd = 0;
		}

		map<WISP_TIMER_KEY, WISP_TIMER>::IT it = m_pWispBase->m_TimerList.begin();
		for (; it != m_pWispBase->m_TimerList.end();)
		{
			if (it->first.pWnd == this)
			{
				m_pWispBase->m_TimerList.erase(it++);
			} else
			{
				++it;
			}
		}

		UnhookKeyEvent();
		UnhookMouseEvent();

		m_WndText.Empty();

		if (m_pWispBase->m_pTipWnd == this)
			m_pWispBase->m_pTipWnd = 0;

		if (m_pWispBase->m_pTipWnd &&
			m_pWispBase->m_pTipWnd->m_pTipOwnerWnd == this &&
			m_pWispBase->m_pTipWnd->m_ShowMode != WISP_SH_HIDDEN)
		{
			m_pWispBase->m_pTipWnd->Show(WISP_SH_HIDDEN);
			m_pWispBase->m_pTipWnd->m_pTipOwnerWnd = 0;
		}

		if (m_pWispBase->m_pRootWnd != this && m_pWispBase->m_pRootWnd && m_ShowMode != WISP_SH_HIDDEN)
		{
			m_pWispBase->m_pRootWnd->Update(&m_ScrWindowRect, this);
			m_pWispBase->RedrawNextTime();
		}

		m_State = WISP_WSTATE_INIT;
		m_IsWindow = 0;
		m_ShowMode = WISP_SH_NORMAL;
		if ((m_Style & 0x8000) == 0)
		{
			if (m_AdvStyle & 1) //WISP_ADV_AUTODEL
				delete this;
		}
		return true;
	}
	void CWispBaseWnd::RecalcLayout()
	{
		m_WindowRect.y = 0;
		m_WindowRect.x = 0;
		m_WindowRect.cx = m_ScrWindowRect.cx;
		m_WindowRect.cy = m_ScrWindowRect.cy;
	}
	bool CWispBaseWnd::InitWnd()
	{
		m_pTabWndItem = 0;
		m_ShowMode = WISP_SH_NORMAL;
		m_AdvStyle = 0;
		m_pUpdateRC = 0;
		m_LockUpdateRef = 0;
		return true;
	}
	void CWispBaseWnd::SetOwner(CWispBaseWnd *pOwnerWnd)
	{
		m_OwnerWnd = pOwnerWnd;
	}
	bool CWispBaseWnd::SetWindowText(const WCHAR *pString)
	{
		m_WndText = pString;
		Update((WISP_RECT*)0);
		return true;
	}
	TWideString & CWispBaseWnd::GetWindowText()
	{
		return m_WndText;
	}

	bool CWispBaseWnd::IsRect(WISP_POINT *pPT)
	{
		return PtInRect(&m_ScrWindowRect, pPT);
	}
	void CWispBaseWnd::Hide()
	{
		//EMPTY
	}
	void CWispBaseWnd::Show()
	{
		//EMPTY
	}

	WISP_MSG_MAP_BEGIN(CWispBaseWnd)
		WISP_MSG_MAP(WISP_WM_BEGIN_MOVE, OnBeginMove)
		WISP_MSG_MAP(WISP_WM_TIMER_EVENT, OnTimer)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
		WISP_MSG_MAP(WISP_WM_LOST_FOCUS, OnLostFocus)
		WISP_MSG_MAP(WISP_WM_MOUSE_ENTER, OnMouseEnter)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
	WISP_MSG_MAP_END_

	bool CWispBaseWnd::Create(const WCHAR *Name, const CWispRect & pRC, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int Style, unsigned int ShowMode)
	{
		return Create(Name, pRC.x, pRC.y, pRC.cx, pRC.cy, pParentWnd, CmdID, Style, ShowMode);
	}

	bool CWispBaseWnd::SendCommand(unsigned int CmdMsg, int nParam1, void* pParam2)
	{
		WISP_MSG Msg;

		Msg.hWnd = m_OwnerWnd;
		Msg.Msg = WISP_WM_COMMAND;
		Msg.hParentWnd = this;
		Msg.Command.CtrlType = m_CtrlType;
		Msg.Command.CmdMsg = CmdMsg;
		Msg.Command.CmdID = m_CmdID;
		Msg.Command.Param1 = nParam1;
		Msg.Command.Param2 = pParam2;
		return m_pWispBase->SendMessage(&Msg);
	}
	bool CWispBaseWnd::SendEvent(unsigned int CmdMsg, int nParam1, void* pParam2)
	{
		WISP_MSG Msg;

		Msg.hWnd = m_OwnerWnd;
		Msg.Msg = WISP_WM_EVENT;
		Msg.hParentWnd = this;
		Msg.Command.CtrlType = m_CtrlType;
		Msg.Command.CmdMsg = CmdMsg;
		Msg.Command.CmdID = m_CmdID;
		Msg.Command.Param1 = nParam1;
		Msg.Command.Param2 = pParam2;
		return m_pWispBase->PostMessage(&Msg);

	}
	void CWispBaseWnd::Close()
	{
		WISP_MSG Msg;

		Msg.hWnd = this;
		Msg.Msg = WISP_WM_CLOSE;
		m_pWispBase->PostMessage(&Msg);
	}
	void CWispBaseWnd::Top(bool bUpdate)
	{
		CWispBaseWnd *pParentWnd = m_ParentWnd;
		if (pParentWnd && this != pParentWnd)
		{
			m_pWispBase->RemoveWnd(this);
			m_pWispBase->InsertWnd(pParentWnd, this);
			pParentWnd->Top(bUpdate);

			if (m_pWispBase->m_pTopMostRootWnd &&
				pParentWnd == m_pWispBase->m_pRootWnd &&
				this != m_pWispBase->m_pTopMostRootWnd)
				m_pWispBase->m_pTopMostRootWnd->Top(bUpdate);

			if (bUpdate)
				Update((WISP_RECT*)0);
		}
	}
	void CWispBaseWnd::Update(WISP_RECT *pRect, CWispBaseWnd *pWnd)
	{
		if (pRect)
		{
			if (m_pUpdateRC)
			{
				WISP_RECT rc2_v13 = *pRect;
				WISP_RECT rc1_v12 = *m_pUpdateRC;

				m_pUpdateRC = &m_UpdateRC;
				RectToRect(&rc1_v12, &rc2_v13, &m_UpdateRC); //Union |
			} else
			{
				m_UpdateRC = *pRect; //???
				m_pUpdateRC = &m_UpdateRC;
			}

			if (!m_pUpdateRC)
				return;

			if (!ClipRect(m_pUpdateRC, &m_WindowRect))
			{
				m_pUpdateRC = 0;
				return;
			}
		} else
		{
			m_pUpdateRC = &m_WindowRect;
		}

		for (CWispBaseWnd *pChildWnd = m_ChildWnd;
			pChildWnd;
			pChildWnd = pChildWnd->m_NextWnd)
		{
			if (pChildWnd != pWnd)
			{
				if (m_pUpdateRC)
				{
					WISP_RECT rc1_v12 = *m_pUpdateRC;

					rc1_v12.x += m_ScrWindowRect.x - pChildWnd->m_ScrWindowRect.x;
					rc1_v12.y += m_ScrWindowRect.y - pChildWnd->m_ScrWindowRect.y;

					if (pChildWnd->m_pUpdateRC)
					{
						WISP_RECT rc2_v13;
						RectToRect(&rc1_v12, pChildWnd->m_pUpdateRC, &rc2_v13); //Union |

						pChildWnd->Update(&rc2_v13, pWnd);
					} else
					{
						pChildWnd->Update(&rc1_v12, pWnd);
					}
					
				}
			}
		}
	}
	void CWispBaseWnd::Update(WISP_RECT *pRect)
	{
		if (m_LockUpdateRef > 0)
			return;
		
		Update(pRect, 0);

		if (m_pWispBase->m_pRootWnd)
		{
			if (m_pWispBase->m_pRootWnd != this)
			{
				if (m_pUpdateRC)
				{
					WISP_RECT rc1_v15 = *m_pUpdateRC;

					rc1_v15.x += m_ScrWindowRect.x;
					rc1_v15.y += m_ScrWindowRect.y;

					if (m_pWispBase->m_pRootWnd->m_pUpdateRC)
					{
						WISP_RECT rc3_v16;
						RectToRect(&rc1_v15, m_pWispBase->m_pRootWnd->m_pUpdateRC, &rc3_v16); //Union |

						m_pWispBase->m_pRootWnd->Update(&rc3_v16, this);
					} else
					{
						m_pWispBase->m_pRootWnd->Update(&rc1_v15, this);
					}
					
				}
			}
		}
		m_pWispBase->RedrawNextTime();
	}
	void CWispBaseWnd::Move(int DeltaX, int DeltaY, bool bUpdate)
	{
		if (DeltaX || DeltaY)
		{
			WISP_MSG Msg;
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_MOVING;
			Msg.Move.DeltaX = DeltaX;
			Msg.Move.DeltaY = DeltaY;

			WISP_RECT rc1_v19;
			if (m_ParentWnd)
			{
				rc1_v19 = m_ScrWindowRect;
			}

			if (m_pWispBase->SendMessage(&Msg))
			{
				m_ScrWindowRect.x += DeltaX;
				m_ScrWindowRect.y += DeltaY;
				RecalcLayout();
				for (CWispBaseWnd *pWnd = m_ChildWnd;
					pWnd;
					pWnd = pWnd->m_NextWnd)
					pWnd->Move(DeltaX, DeltaY, 0);

				Msg.hWnd = this;
				Msg.Msg = WISP_WM_MOVE;
				Msg.Move.DeltaX = DeltaX;
				Msg.Move.DeltaY = DeltaY;
				m_pWispBase->SendMessage(&Msg);
				RecalcLayout();

				if (bUpdate)
				{
					if (m_ParentWnd)
					{
						WISP_RECT rc2_v17;
						rc2_v17 = m_ScrWindowRect;

						WISP_RECT rc3_v21;
						RectToRect(&rc1_v19, &rc2_v17, &rc3_v21); //Union |

						rc3_v21.x -= m_ParentWnd->m_ScrWindowRect.x;
						rc3_v21.y -= m_ParentWnd->m_ScrWindowRect.y;
						m_ParentWnd->Update(&rc3_v21);
					} else
					{
						Update((WISP_RECT*)0);
					}
				}
			}
		}
	}
	void CWispBaseWnd::MoveToWindow(int PosX, int PosY, bool bUpdate)
	{
		if (this != m_pWispBase->m_pRootWnd)
		{
			if (m_ParentWnd)
				Move(
					PosX + m_ParentWnd->m_ScrWindowRect.x - m_ScrWindowRect.x,
					PosY + m_ParentWnd->m_ScrWindowRect.y - m_ScrWindowRect.y,
					bUpdate);
			else
				Move(PosX - m_ScrWindowRect.x, PosY - m_ScrWindowRect.y, bUpdate);
		}

	}

	void CWispBaseWnd::MoveToClient(int PosX, int PosY, bool bUpdate)
	{
		if (this != m_pWispBase->m_pRootWnd)
		{
			if (m_ParentWnd)
				Move(
					PosX + ((CWispWnd*)m_ParentWnd)->m_ScrClientRect.x - m_ScrWindowRect.x,
					PosY + ((CWispWnd*)m_ParentWnd)->m_ScrClientRect.y - m_ScrWindowRect.y,
					bUpdate);
			else
				Move(PosX - m_ScrWindowRect.x, PosY - m_ScrWindowRect.y, bUpdate);
		}
	}
	void CWispBaseWnd::MoveToScreen(int PosX, int PosY, bool bUpdate)
	{
		if (this != m_pWispBase->m_pRootWnd)
			Move(PosX - m_ScrWindowRect.x, PosY - m_ScrWindowRect.y, bUpdate);
	}
	bool CWispBaseWnd::Resize(int cx, int cy, bool bUpdate)
	{
		if (cx == m_WindowRect.cx && cy == m_WindowRect.cy)
			return true;
		
		MIN_LIMIT(cx, 0);
		MIN_LIMIT(cy, 0);

		if (m_Style & 0x8000) //CWispWnd
		{
			if (((CWispWnd*)this)->m_MaxWndSize.cx && cx > ((CWispWnd*)this)->m_MaxWndSize.cx)
			{
				if (m_State & 2) //WISP_WSTATE_RESIZE
					return false;
				cx = ((CWispWnd*)this)->m_MaxWndSize.cx;
			}

			if (((CWispWnd*)this)->m_MaxWndSize.cy && cy > ((CWispWnd*)this)->m_MaxWndSize.cy)
			{
				if (m_State & 2) //WISP_WSTATE_RESIZE
					return false;
				cy = ((CWispWnd*)this)->m_MaxWndSize.cy;
			}
		}
		if (cx == -1) cx = m_WindowRect.cx;
		if (cy == -1) cy = m_WindowRect.cy;

		WISP_MSG Msg;
		Msg.hWnd = this;
		Msg.Msg = WISP_WM_SIZING; //???
		Msg.Sizing.Size.cx = cx;
		Msg.Sizing.Size.cy = cy;

		WISP_RECT rc1_v25;
		if (m_ParentWnd)
		{
			rc1_v25 = m_ScrWindowRect;
			rc1_v25.x -= m_ParentWnd->m_ScrWindowRect.x;
			rc1_v25.y -= m_ParentWnd->m_ScrWindowRect.y;
		}

		Msg.Sizing.ScrSize.cx = cx - m_ScrWindowRect.cx;
		Msg.Sizing.ScrSize.cy = cy - m_ScrWindowRect.cy;

		if (!m_pWispBase->SendMessage(&Msg))
			return false;

		m_ScrWindowRect.cx = cx;
		m_ScrWindowRect.cy = cy;
		RecalcLayout();

		Msg.hWnd = this;
		Msg.Msg = WISP_WM_SIZE;
		m_pWispBase->SendMessage(&Msg);
		RecalcLayout();
		for (CWispBaseWnd *pChildWnd = m_ChildWnd;
			pChildWnd;
			pChildWnd = pChildWnd->m_NextWnd)
		{
			Msg.hWnd = pChildWnd;
			Msg.Msg = WISP_WM_RESIZE_CHILD;
			m_pWispBase->SendMessage(&Msg);
		}

		if (bUpdate)
		{
			if (m_ParentWnd)
			{
				WISP_RECT rc2_v24 = m_ScrWindowRect;

				rc2_v24.x -= m_ParentWnd->m_ScrWindowRect.x;
				rc2_v24.y -= m_ParentWnd->m_ScrWindowRect.y;

				WISP_RECT rc3_v26;
				RectToRect(&rc1_v25, &rc2_v24, &rc3_v26); //Union |

				m_ParentWnd->Update(&rc3_v26);
			} else
			{
				Update((WISP_RECT*)0);
			}
		}

		return true;
	}
	void CWispBaseWnd::Center(CWispBaseWnd *pCenterWnd)
	{
		if (pCenterWnd)
		{
			MoveToWindow(
				pCenterWnd->m_ScrWindowRect.x + (pCenterWnd->m_WindowRect.cx - m_WindowRect.cx) / 2,
				pCenterWnd->m_ScrWindowRect.y + (pCenterWnd->m_WindowRect.cy - m_WindowRect.cy) / 2,
				true);
		} else
		{
			if (this != m_pWispBase->m_pRootWnd)
				Move(
				(m_pWispBase->m_pRootWnd->m_WindowRect.cx - m_WindowRect.cx) / 2 - m_ScrWindowRect.x,
				(m_pWispBase->m_pRootWnd->m_WindowRect.cy - m_WindowRect.cy) / 2 - m_ScrWindowRect.y,
				true);
		}
	}
	CWispBaseWnd *CWispBaseWnd::Focus()
	{
		WISP_MSG Msg;

		if (m_pWispBase->m_pFocusWnd == this)
			return m_pWispBase->m_pFocusWnd;

		Msg.hWnd = this;
		Msg.Msg = WISP_WM_GET_FOCUS;
		Msg.hOtherWnd = m_pWispBase->m_pFocusWnd;
		if (m_pWispBase->SendMessage(&Msg))
		{
			Msg.hWnd = (CWispBaseWnd*)Msg.hOtherWnd; //??????m_pWispBase->m_pFocusWnd; //??? Msg.u.field_0
			Msg.Msg = WISP_WM_LOST_FOCUS;
			Msg.hOtherWnd = this;
			if (m_pWispBase->SendMessage(&Msg))
				m_pWispBase->m_pFocusWnd = this;
		}
		Update((WISP_RECT*)0);
		m_pWispBase->CaptureMouseEvent(this);
		return m_pWispBase->m_pFocusWnd;
	}
	bool CWispBaseWnd::IsWindow()
	{
		return m_IsWindow == 0x77777777;
	}
	bool CWispBaseWnd::IsChildWndOf(CWispBaseWnd *pParentWnd)
	{
		for (CWispBaseWnd *pWnd = m_ParentWnd;
			pWnd;
			pWnd = pWnd->m_ParentWnd)
		{
			if (pWnd == pParentWnd)
				return true;
		}
		return false;
	}
	bool CWispBaseWnd::IsWindowShow()
	{
		if (!IsWindow())
			return false;
		if (m_ShowMode != WISP_SH_HIDDEN && (m_Style & 0x100) == 0 && m_WindowRect.cx && m_WindowRect.cy)
			return true;
		return false;
	}

	bool CWispBaseWnd::OnGetFocus(WISP_MSG *pMsg)
	{
		if (!SendCommand(WISP_ID_CHILD_GET_FOCUS, 0, 0))
			return false;
		Top(true);
		return true;
	}
	bool CWispBaseWnd::OnLostFocus(WISP_MSG *pMsg)
	{
		return SendCommand(WISP_ID_CHILD_LOST_FOCUS, 0, pMsg->hOtherWnd);
	}

	bool CWispBaseWnd::Show(unsigned int ShowMode)
	{
		if (m_ShowMode == ShowMode)
			return true;

		if (m_ShowMode == WISP_SH_HIDDEN && ShowMode != WISP_SH_HIDDEN)
			Show();

		m_ShowMode = ShowMode;

		if (ShowMode == WISP_SH_MODAL)
		{
			if (m_pWispBase->m_pModalWnd != this)
			{
				m_PrevModalWnd = m_pWispBase->m_pModalWnd;
				m_pWispBase->m_pModalWnd = this;
			}
			Top(true);
			Update((WISP_RECT*)0);
			return true;
		}

		if (ShowMode == WISP_SH_MODAL_BLOCK)
		{
			if (m_pWispBase->m_pModalWnd != this)
			{
				m_PrevModalWnd = m_pWispBase->m_pModalWnd;
				m_pWispBase->m_pModalWnd = this;
				Top(true);
				Update((WISP_RECT*)0);
				m_pWispBase->BlockPump(this);
				return true;
			}
		} else
		if (m_pWispBase->m_pModalWnd == this)
		{
			m_pWispBase->m_pModalWnd = m_PrevModalWnd;
			m_PrevModalWnd = 0;
		}

		if (m_ShowMode == WISP_SH_HIDDEN)
		{
			if (m_pWispBase->m_pMouseEventWnd == this)
			{
				WISP_MSG Msg;
				Msg.hWnd = this;
				Msg.Msg = WISP_WM_MOUSE_LEAVE;
				Msg.MouseEvent.HitArea.Type = 0;
				Msg.MouseEvent.HitArea.State = 0;
				Msg.MouseEvent.hWndMouseAt = this;
				Msg.MouseEvent.DeltaX = 0;
				Msg.MouseEvent.DeltaY = 0;
				m_pWispBase->SendMessage(&Msg);
			}
			Hide();
		}

		Update((WISP_RECT*)0);
		return true;
	}

	bool CWispBaseWnd::MoveWindowToWindow(const WISP_RECT & Rect, bool bUpdate)
	{
		MoveToWindow(Rect.x, Rect.y, bUpdate);
		return Resize(Rect.cx, Rect.cy, bUpdate);
	}
	bool CWispBaseWnd::MoveWindowToWindow(int x, int y, int cx, int cy, bool bUpdate)
	{
		MoveToWindow(x, y, bUpdate);
		return Resize(cx, cy, bUpdate);
	}
	bool CWispBaseWnd::MoveWindowToClient(const WISP_RECT & Rect, bool bUpdate)
	{
		MoveToClient(Rect.x, Rect.y, bUpdate);
		return Resize(Rect.cx, Rect.cy, bUpdate);
	}
	bool CWispBaseWnd::MoveWindowToClient(int x, int y, int cx, int cy, bool bUpdate)
	{
		MoveToClient(x, y, bUpdate);
		return Resize(cx, cy, bUpdate);
	}

	bool CWispBaseWnd::HookKeyEvent()
	{
		TListIter<CWispBaseWnd*> it = m_pWispBase->m_KeyHookWndList.Begin();
		for (;it != m_pWispBase->m_KeyHookWndList.End(); ++it)
		{
			if (*it == this)
				return false;
		}
		CWispBaseWnd *pWnd = this;
		m_pWispBase->m_KeyHookWndList.Append(&pWnd);
		return true;
	}

	bool CWispBaseWnd::UnhookKeyEvent()
	{
		TListIter<CWispBaseWnd*> it = m_pWispBase->m_KeyHookWndList.Begin();
		for (;it != m_pWispBase->m_KeyHookWndList.End(); ++it)
		{
			if (*it == this)
			{
				m_pWispBase->m_KeyHookWndList.Remove(it);
				return true;
			}
		}
		return false;
	}

	bool CWispBaseWnd::HookMouseEvent()
	{
		TListIter<CWispBaseWnd*> it = m_pWispBase->m_MouseHookWndList.Begin();
		for (;it != m_pWispBase->m_MouseHookWndList.End(); ++it)
		{
			if (*it == this)
				return false;
		}
		CWispBaseWnd *pWnd = this;
		m_pWispBase->m_MouseHookWndList.Append(&pWnd);
		return true;
	}

	bool CWispBaseWnd::UnhookMouseEvent()
	{
		TListIter<CWispBaseWnd*> it = m_pWispBase->m_MouseHookWndList.Begin();
		for (;it != m_pWispBase->m_MouseHookWndList.End(); ++it)
		{
			if (*it == this)
			{
				m_pWispBase->m_MouseHookWndList.Remove(it);
				return true;
			}
		}
		return false;
	}

	WISP_KEY_EVENT * CWispBaseWnd::RegisterKeyEvent(unsigned int CmdID, unsigned int KeyType, unsigned int SpecKey, int Disable)
	{
		TListIter<WISP_KEY_EVENT> p = m_pWispBase->m_KeyEventList.Append();
		p->CmdID = CmdID;
		p->KeyType = KeyType;
		p->SpecKey = SpecKey;
		p->pWnd = (CWispWnd*)this;
		p->Disable = Disable;
		return &*p;
	}

	bool CWispBaseWnd::UnregisterKeyEvent(unsigned int CmdID)
	{
		TListIter<WISP_KEY_EVENT> it = m_pWispBase->m_KeyEventList.Begin();
		for (;it != m_pWispBase->m_KeyEventList.End(); ++it)
		{
			if (it->CmdID == CmdID)
			{
				m_pWispBase->m_KeyEventList.Remove(it);
				return true;
			}
		}
		return false;
	}

	bool CWispBaseWnd::EnableHelpTip(const WCHAR *pString)
	{
		if (!pString) return false;

		m_HelpTipString = pString;
		m_AdvStyle |= 2;	//WISP_ADV_HINT
		return true;
	}

	bool CWispBaseWnd::DisableHelpTip()
	{
		m_HelpTipString.Empty();
		m_AdvStyle &= ~2;	//WISP_ADV_HINT
		return true;
	}

	void *CWispBaseWnd::GetTimer(unsigned int TimerID)
	{
		WISP_TIMER_KEY Key;
		Key.pWnd = this;
		Key.ID = TimerID;
		map<WISP_TIMER_KEY, WISP_TIMER>::IT it = m_pWispBase->m_TimerList.find(Key);
		if (it == m_pWispBase->m_TimerList.end())
			return nullptr;

		return &it->second;
	}

	WISP_TIMER *CWispBaseWnd::InsertTimer(unsigned int TimerID, int Period, unsigned int UserData, void *UserPtr)
	{
		if (GetTimer(TimerID))
			return nullptr;

		WISP_TIMER_KEY Key;
		Key.pWnd = this;
		Key.ID = TimerID;

		map<WISP_TIMER_KEY, WISP_TIMER>::IT it = m_pWispBase->m_TimerList.insert(
			_Tmap_pair<WISP_TIMER_KEY, WISP_TIMER>(Key,WISP_TIMER() ) );
		if (it == m_pWispBase->m_TimerList.end())
			return nullptr;

		it->second.Period = Period;
		it->second.UserData = UserData;
		it->second.UserPtr = UserPtr;
		it->second.Elapse = 0;

		if (!m_pWispBase->InsertTimer(it->second))
		{
			m_pWispBase->m_TimerList.erase(it);
			return nullptr;
		}
		return &it->second;
	}
	bool CWispBaseWnd::RemoveTimer(unsigned int TimerID)
	{
		WISP_TIMER_KEY Key;
		Key.pWnd = this;
		Key.ID = TimerID;

		map<WISP_TIMER_KEY, WISP_TIMER>::IT it = m_pWispBase->m_TimerList.find(Key);
		if (it == m_pWispBase->m_TimerList.end())
			return false;

		if (m_pWispBase->RemoveTimer(it->second))
			m_pWispBase->m_TimerList.erase(it);

		return false;
	}

	bool CWispBaseWnd::EnableWindow(bool bState)
	{
		bool Result = ~(m_Style >> 9) & 1;	//???

		if (bState)
		{
			m_Style &= ~0x200;
		} else
		{
			m_Style |= 0x200;

			//WISP_ADV_HINT
			if (m_AdvStyle & 2 && m_pWispBase->m_pTipWnd->m_pTipOwnerWnd == this)
			{
				RemoveTimer(WISP_ID_HELP_TIP);
				m_pWispBase->m_pTipWnd->Show(WISP_SH_HIDDEN);
				m_pWispBase->m_pTipWnd->m_pTipOwnerWnd = 0;
			}

		}
		RecalcLayout();
		if (Result != bState)
			Update((WISP_RECT*)0);
		return Result;
	}

	bool CWispBaseWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		//WISP_ADV_HINT
		if ((m_AdvStyle & 2) && pMsg->KeyEvent.KeyType == VK_LBUTTON && pMsg->KeyEvent.bKeyDown)
		{
			RemoveTimer(WISP_ID_HELP_TIP);
			m_pWispBase->m_pTipWnd->Show(WISP_SH_HIDDEN);
			m_pWispBase->m_pTipWnd->m_pTipOwnerWnd = 0;
		}

		if (m_OwnerWnd && m_OwnerWnd->m_CtrlType == WISP_CTRL_FORM)
			SendCommand(
				pMsg->KeyEvent.bKeyDown != 0 ? 0x80000119 : 0x80000120, //WISP_ID_FORM_KEYDOWN : WISP_ID_FORM_KEYUP
				pMsg->KeyEvent.KeyType,
				this);
		return true;

	}
	bool CWispBaseWnd::OnBeginMove(WISP_MSG *pMsg)
	{
		//WISP_ADV_HINT
		if ((m_AdvStyle & 2) && m_pWispBase->m_pTipWnd->IsWindow())
		{
			RemoveTimer(WISP_ID_HELP_TIP);
			CWispTipWnd *pWispTipWnd = m_pWispBase->m_pTipWnd;
			if (pWispTipWnd->m_ShowMode != WISP_SH_HIDDEN)
			{
				pWispTipWnd->m_ShowMode = WISP_SH_HIDDEN;
				if (pWispTipWnd->m_pWispBase->m_pModalWnd == pWispTipWnd)
				{
					pWispTipWnd->m_pWispBase->m_pModalWnd = pWispTipWnd->m_PrevModalWnd;
					pWispTipWnd->m_PrevModalWnd = 0;
				}
				if (pWispTipWnd->m_ShowMode == WISP_SH_HIDDEN)
				{
					if (pWispTipWnd->m_pWispBase->m_pMouseEventWnd == pWispTipWnd)
					{
						WISP_MSG Msg;
						Msg.hWnd = pWispTipWnd;
						Msg.Msg = WISP_WM_MOUSE_LEAVE;

						Msg.MouseEvent.HitArea.Type = 0;
						Msg.MouseEvent.HitArea.State = 0;
						Msg.MouseEvent.hWndMouseAt = pWispTipWnd;
						Msg.MouseEvent.DeltaX = 0;
						Msg.MouseEvent.DeltaY = 0;

						pWispTipWnd->m_pWispBase->SendMessage(&Msg);
					}
					pWispTipWnd->Hide();
				}
				pWispTipWnd->Update((WISP_RECT*)0);
			}
			m_pWispBase->m_pTipWnd->m_pTipOwnerWnd = 0;
		}

		return true;
	}
	bool CWispBaseWnd::OnTimer(WISP_MSG *pMsg)
	{
		//WISP_ADV_HINT
		if (m_AdvStyle & 2)
		{
			if (pMsg->Timer.ID == WISP_ID_HELP_TIP)
			{
				if (PtInRect(&m_ScrWindowRect, &m_pWispBase->m_MousePT))
				{
					RemoveTimer(WISP_ID_HELP_TIP);
					//???
					if ( !((m_Style >> 9) & 1) )
					{
						m_pWispBase->m_pTipWnd->SetWindowText(m_HelpTipString);
						m_pWispBase->m_pTipWnd->AutoAdjustPostion((CWispWnd*)this);
						m_pWispBase->m_pTipWnd->Show(WISP_SH_MINSIZE);
					}
				}
			}
		}

		return true;
	}
	bool CWispBaseWnd::OnMouseEnter(WISP_MSG *pMsg)
	{
		//WISP_ADV_HINT
		if (m_AdvStyle & 2)
			InsertTimer(WISP_ID_HELP_TIP, 500, 0, 0);

		return true;
	}
	bool CWispBaseWnd::OnMouseLeave(WISP_MSG *pMsg)
	{
		m_pWispBase->CaptureMouseEvent((CWispWnd*)pMsg->MouseEvent.hWndMouseAt);

		//WISP_ADV_HINT
		if (m_AdvStyle & 2)
		{
			RemoveTimer(WISP_ID_HELP_TIP);
			CWispTipWnd *pWispTipWnd = m_pWispBase->m_pTipWnd;
			if (pWispTipWnd->m_ShowMode != WISP_SH_HIDDEN)
			{
				pWispTipWnd->m_ShowMode = WISP_SH_HIDDEN;
				if (pWispTipWnd->m_pWispBase->m_pModalWnd == pWispTipWnd)
				{
					pWispTipWnd->m_pWispBase->m_pModalWnd = pWispTipWnd->m_PrevModalWnd;
					pWispTipWnd->m_PrevModalWnd = 0;
				}

				if (pWispTipWnd->m_ShowMode == WISP_SH_HIDDEN)
				{
					if (pWispTipWnd->m_pWispBase->m_pMouseEventWnd == pWispTipWnd)
					{
						WISP_MSG Msg;
						Msg.hWnd = pWispTipWnd;
						Msg.Msg = WISP_WM_MOUSE_LEAVE;
						Msg.MouseEvent.HitArea.Type = 0;
						Msg.MouseEvent.HitArea.State = 0;
						Msg.MouseEvent.hWndMouseAt = pWispTipWnd;
						Msg.MouseEvent.DeltaX = 0;
						Msg.MouseEvent.DeltaY = 0;

						pWispTipWnd->m_pWispBase->SendMessage(&Msg);
					}
					pWispTipWnd->Hide();
				}
				pWispTipWnd->Update((WISP_RECT*)0);
			}
			m_pWispBase->m_pTipWnd->m_pTipOwnerWnd = 0;
		}

		return true;

	}

	WISP_EVENT_MAP_BEGIN(CWispBaseWnd)
//		WISP_EVENT_MAP(..., ...)
	WISP_EVENT_MAP_END

	bool CWispBaseWnd::OnClose(WISP_MSG *pMsg)
	{
		return Destroy();
	}

	int CWispBaseWnd::MsgBox(WCHAR *pText, WCHAR *pCaption, unsigned int uType, CWispBaseWnd *pParentWnd)
	{
		return CWispMsgBox::StaticShowMsgBox(pText, pCaption, uType, pParentWnd);
	}

```

`source/Wisp/wispbasewnd.hpp`:

```hpp

#ifndef _WISPBASEWND_HPP_
#define _WISPBASEWND_HPP_

#include "../Code/define.h"
#include "../Code/tstrmem.hpp"

#include "utility.hpp"
#include "wispdc.hpp"
#include "wispmsg.hpp"

	//forward decl

	struct CWispBase; //???
	struct WISP_TAB_WND_ITEM; //???
	struct WISP_KEY_EVENT; //???
	struct WISP_TIMER; //???
	//==========

	//ShowMode

	enum WISP_SH
	{
		WISP_SH_NORMAL = 0,
		WISP_SH_MINSIZE = 1,
		WISP_SH_FULL_SCR = 2,
		WISP_SH_HIDDEN = 3,
		WISP_SH_MODAL = 4,
		WISP_SH_MODAL_BLOCK = 5,
	};

	//m_Style

	enum WISP_WSTYLE
	{
		WISP_WSTYLE_CAPTION = 1,	//1<<0
		WISP_WSTYLE_BORDER = 2,		//1<<1
		WISP_WSTYLE_TIP_BORDER = 4,	//1<<2 0x4 ???
		WISP_WSTYLE_BT_CLOSE = 8,	//1<<3
		WISP_WSTYLE_BT_MAX = 0x10,	//1<<4
		WISP_WSTYLE_BT_MIN = 0x20,	//1<<5
		WISP_WSTYLE_DISABLE_BK = 0x40,	//1<<6
		WISP_WSTYLE_RESIZE = 0x80,	//1<<7
		WISP_WSTYLE_CHILD = 0x100,	//1<<8
		WISP_WSTYLE_DISABLE = 0x200,	//1<<9
		//CHECKED			//1<<10 0x400
		WISP_WSTYLE_FOCUS = 0x800,	//1<<11 0x800
						//1<<12 0x1000
						//1<<13 0x2000
						//1<<14 0x4000
		WISP_WSTYLE_WND = 0x8000,	//1<<15 0x8000
		//1<<16 0x010000 WISP_WSTYLE_VERT
		//1<<17 0x020000 WISP_WSTYLE_HORZ LIST BOX EXPAND !
		//1<<18 0x040000 WISP_WSTYLE_STATIC LIST BOX CHILD RESIZE VERT DISABLED CONST
		//1<<19 0x080000
		//1<<20 0x100000 AUTO WIDTH		SCROLL H
		//1<<21 0x200000 FOCUSED / CLOSE BUTTON SCROLL V
		//1<<22 0x400000 LIST BOX CHECKED !
		//1<<23 0x800000 LIST BOX CTRL UNSELECT / FIXED

		//1<<24 0x1000000 LIST ICON
		//1<<25 0x2000000 LIST BOX DRAG
		//1<<26 0x4000000 LIST BOX PROLOG-EPILOG ADDING END
		//1<<27 0x8000000

		//1<<28 0x10000000 LIST BOX AUTO SELECT
		//1<<29 0x20000000 ADD END
		//1<<30 0x40000000 LIST BOX AUTO UNSELECT/SELECT FOCUS
		//1<<21 0x80000000 WISP_WSTYLE_MULTILINE
	};

	//m_AdvStyle

	enum WISP_ADV_STYLE
	{
		WISP_ADV_AUTODEL = 1,		//1<<0
		WISP_ADV_HINT	 = 2,		//1<<1
		WISP_ADV_CANMOVE = 4,		//1<<2
						//1<<3
	};

	//m_State

	enum WISP_WSTATE
	{
		WISP_WSTATE_RESET	= 0,
		WISP_WSTATE_MOVE	= 1,	//1<<0
		WISP_WSTATE_RESIZE	= 2,	//1<<1
		WISP_WSTATE_MAXIMIZE	= 4,	//1<<2
		WISP_WSTATE_MINIMIZE	= 8,	//1<<3
		WISP_WSTATE_INIT = 0xffffffff,
	};

	struct CWispBaseWnd
	{
		CWispBase *m_pWispBase;
		unsigned int m_CtrlType;
		unsigned int m_State;
		WISP_RECT m_ScrWindowRect;
		WISP_RECT m_WindowRect;
		unsigned int m_Style;
		unsigned int m_AdvStyle;
		unsigned int m_ShowMode;
		TWideString m_WndText;
		unsigned int m_CmdID;
		CWispDC m_WindowDC;
		CWispBaseWnd *m_PrevWnd;
		CWispBaseWnd *m_NextWnd;
		CWispBaseWnd *m_ChildWnd;
		CWispBaseWnd *m_ChildTopWnd;
		CWispBaseWnd *m_ParentWnd;
		CWispBaseWnd *m_PrevModalWnd;
		CWispBaseWnd *m_OwnerWnd;
		WISP_TAB_WND_ITEM *m_pTabWndItem;
		TWideString m_HelpTipString;
		WISP_RECT m_UpdateRC;
		WISP_RECT *m_pUpdateRC;
		int m_LockUpdateRef;
		unsigned int m_IsWindow;

	public:
		CWispBaseWnd();
		virtual ~CWispBaseWnd();

		virtual bool Create(const WCHAR *Name, int x, int y, int cx, int cy, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int Style, unsigned int ShowMode);
		virtual bool Destroy();
		virtual void RecalcLayout();
		virtual bool InitWnd();
		virtual void SetOwner(CWispBaseWnd *pOwnerWnd);
		virtual bool SetWindowText(const WCHAR *pString);
		virtual TWideString & GetWindowText();
		virtual void Update(WISP_RECT *pRect);
		virtual bool IsRect(WISP_POINT *pPT);
		virtual void Hide();
		virtual void Show();
		virtual bool MsgProc(WISP_MSG *pMsg);

		bool Create(const WCHAR *Name, const CWispRect & pRC, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int Style, unsigned int ShowMode);

		bool SendCommand(unsigned int CmdMsg, int nParam1, void* pParam2);
		bool SendEvent(unsigned int CmdMsg, int nParam1, void* pParam2);
		void Close();
		void Top(bool Update);
		void Update(WISP_RECT *pRect, CWispBaseWnd *pWnd);

		void Move(int DeltaX, int DeltaY, bool bUpdate);
		void MoveToWindow(int PosX, int PosY, bool bUpdate);
		void MoveToClient(int PosX, int PosY, bool bUpdate);
		void MoveToScreen(int PosX, int PosY, bool bUpdate);
		bool Resize(int cx, int cy, bool Update);
		void Center(CWispBaseWnd *pCenterWnd);
		CWispBaseWnd *Focus();
		bool IsWindow();
		bool IsChildWndOf(CWispBaseWnd *pParentWnd);
		bool IsWindowShow();

		bool OnGetFocus(WISP_MSG *pMsg);
		bool OnLostFocus(WISP_MSG *pMsg);

		bool Show(unsigned int ShowMode);

		bool MoveWindowToWindow(const WISP_RECT & Rect, bool bUpdate);
		bool MoveWindowToWindow(int x, int y, int cx, int cy, bool bUpdate);
		bool MoveWindowToClient(const WISP_RECT & Rect, bool bUpdate);
		bool MoveWindowToClient(int x, int y, int cx, int cy, bool bUpdate);

		bool HookKeyEvent();
		bool UnhookKeyEvent();

		bool HookMouseEvent();
		bool UnhookMouseEvent();

		WISP_KEY_EVENT * RegisterKeyEvent(unsigned int CmdID, unsigned int KeyType, unsigned int SpecKey, int Disable);
		bool UnregisterKeyEvent(unsigned int CmdID);

		bool EnableHelpTip(const WCHAR *pString);
		bool DisableHelpTip();

		void *GetTimer(unsigned int TimerID);
		WISP_TIMER *InsertTimer(unsigned int TimerID, int Period, unsigned int UserData, void *UserPtr);
		bool RemoveTimer(unsigned int TimerID);

		bool EnableWindow(bool bState);

		bool OnKeyEvent(WISP_MSG *pMsg);
		bool OnBeginMove(WISP_MSG *pMsg);
		bool OnTimer(WISP_MSG *pMsg);
		bool OnMouseEnter(WISP_MSG *pMsg);
		bool OnMouseLeave(WISP_MSG *pMsg);
		bool OnEvent(WISP_MSG *pMsg);
		bool OnClose(WISP_MSG *pMsg);

		int MsgBox(WCHAR *pText, WCHAR *pCaption, unsigned int uType, CWispBaseWnd* pParentWnd);
	};

#endif

```

`source/Wisp/wispbutton.cpp`:

```cpp

#include "wispbutton.hpp"
#include "wispbase.hpp"
#include "wispwnd.hpp"

	CWispButton::CWispButton()
	{
		m_CtrlType = WISP_CTRL_BUTTON;
		m_bTextRect = 0;
	}
	CWispButton::~CWispButton()
	{
		//NONE
	}

	WISP_MSG_MAP_BEGIN(CWispButton)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_MOVE, OnMove)
	WISP_MSG_MAP_END(CWispBaseWnd)

	bool CWispButton::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON || pMsg->KeyEvent.KeyType == VK_RETURN)
		{
			if (pMsg->KeyEvent.bKeyDown)
			{
				if (!m_bPressed)
				{
					m_bPressed = true;
					Update((WISP_RECT*)0);

					WISP_MSG Msg;
					Msg.hWnd = m_OwnerWnd;
					Msg.hParentWnd = (CWispWnd *)this;
					Msg.Msg = WISP_WM_COMMAND;
					Msg.Command.CtrlType = WISP_CTRL_BUTTON;
					Msg.Command.CmdMsg = 0x80000001; //WISP_ID_KEYDOWN
					Msg.Command.CmdID = m_CmdID;
					m_pWispBase->SendMessage(&Msg); //SendCommand(
				}
			} else
			if (m_bPressed)
			{
				m_bPressed = false;
				Update((WISP_RECT*)0);

				WISP_MSG Msg;
				Msg.hWnd = m_OwnerWnd;
				Msg.hParentWnd = (CWispWnd *)this;
				Msg.Msg = WISP_WM_COMMAND;
				Msg.Command.CtrlType = WISP_CTRL_BUTTON;
				Msg.Command.CmdMsg = 0x80000002; //WISP_ID_KEYUP
				Msg.Command.CmdID = m_CmdID;
				if (m_pWispBase->SendMessage(&Msg)) //SendCommand(
				{
					Msg.hWnd = m_OwnerWnd;
					Msg.Msg = WISP_WM_EVENT;
					m_pWispBase->PostMessage(&Msg);
				}
			}
		}
		return true;
	}
	void CWispButton::RecalcLayout()
	{
		CWispBaseWnd::RecalcLayout();
		//???
		if ((m_Style >> 9) & 1)
		{
			if (m_bMouseInBTRect)
				m_bMouseInBTRect = false;
		} else
		{
			if (PtInRect(&m_ScrWindowRect, &m_pWispBase->m_MousePT) != m_bMouseInBTRect)
			{
				m_bMouseInBTRect = m_bMouseInBTRect == false;
				Update((WISP_RECT*)0);
			}
		}
	}
	bool CWispButton::OnMouseMove(WISP_MSG *pMsg)
	{
		if (!m_bMouseInBTRect)
		{
			OnButtonEnter();
			SendCommand(WISP_ID_ENTER, 0, 0);
			m_bMouseInBTRect = true;
			Update((WISP_RECT*)0);
		}
		return true;
	}
	bool CWispButton::OnMouseLeave(WISP_MSG *pMsg)
	{
		m_bMouseInBTRect = false;
		m_bPressed = false;
		OnButtonLeave();
		SendCommand(WISP_ID_LEAVE, 0, 0);
		Update((WISP_RECT*)0);
		return true;
	}
	bool CWispButton::OnMove(WISP_MSG *pMsg)
	{
		if (m_bMouseInBTRect)
		{
			m_bMouseInBTRect = PtInRect(&m_ScrWindowRect, &m_pWispBase->m_MousePT);
			Update((WISP_RECT*)0);
		}
		return true;
	}
	bool CWispButton::OnUpdate(WISP_MSG *pMsg)
	{
		//unsigned int State;
		unsigned int uStyle;
		unsigned long OrgTextColor;
		//WISP_RECT rcBtn;
		int x, y;

		unsigned int State = 0; //WISP_BT_DIB_NORMAL
		if (m_bMouseInBTRect)
			State = 1; //WISP_BT_DIB_HOVER
		if (m_bPressed)
			State = 2; //WISP_BT_DIB_DOWN

		WISP_RECT rcBtn = m_WindowRect;

		if ( (m_Style & 0x40) == 0 )
			m_pWispBase->m_pWispDrawObj->DrawButtonClient(
				&m_WindowDC, &m_WindowRect, State);

		if (m_DIBList[0]) //!= WISP_BT_DIB_NORMAL
		{
			if ( (m_Style >> 9) & 1 )
			{
				if (!m_DIBList[3]) //WISP_BT_DIB_DISABLE
				{
					m_WindowDC.DrawDIBGray(
						(m_WindowRect.cx - m_DIBList[0]->m_PixelBuf.Width) / 2,
						(m_WindowRect.cy - m_DIBList[0]->m_PixelBuf.Height) / 2,
						m_DIBList[0]); //WISP_BT_DIB_NORMAL
				} else
				{
					m_WindowDC.DrawDIB(
						(m_WindowRect.cx - m_DIBList[3]->m_PixelBuf.Width) / 2,
						(m_WindowRect.cy - m_DIBList[3]->m_PixelBuf.Height) / 2,
						m_DIBList[3]); //WISP_BT_DIB_DISABLE
				}
			} else
			if (m_bPressed)
			{
				if (!m_DIBList[2]) //WISP_BT_DIB_DOWN
				{
					m_WindowDC.DrawDIB(
						(m_WindowRect.cx - m_DIBList[0]->m_PixelBuf.Width) / 2+1,
						(m_WindowRect.cy - m_DIBList[0]->m_PixelBuf.Height) / 2+1,
						m_DIBList[0]); //WISP_BT_DIB_NORMAL
				} else
				{
					m_WindowDC.DrawDIB(
						(m_WindowRect.cx - m_DIBList[2]->m_PixelBuf.Width) / 2,
						(m_WindowRect.cy - m_DIBList[2]->m_PixelBuf.Height) / 2,
						m_DIBList[2]); //WISP_BT_DIB_DOWN


				}
			} else
			{
				if (m_bMouseInBTRect && m_DIBList[1]) //WISP_BT_DIB_HOVER
				{
					m_WindowDC.DrawDIB(
						(m_WindowRect.cx - m_DIBList[1]->m_PixelBuf.Width) / 2,
						(m_WindowRect.cy - m_DIBList[1]->m_PixelBuf.Height) / 2,
						m_DIBList[1]); //WISP_BT_DIB_HOVER


				} else
				{
					m_WindowDC.DrawDIB(
						(m_WindowRect.cx - m_DIBList[0]->m_PixelBuf.Width) / 2,
						(m_WindowRect.cy - m_DIBList[0]->m_PixelBuf.Height) / 2,
						m_DIBList[0]); //WISP_BT_DIB_NORMAL
				}
			}
		}

		if (m_Style & 0x1000000)
		{
			if (State == 1) //WISP_BT_DIB_HOVER
			{
				m_WindowDC.DrawFrameRect(&m_WindowRect, 1, 1);
			} else
			if (State == 2) //WISP_BT_DIB_DOWN
			{
				m_WindowDC.DrawFrameRect(&m_WindowRect, 0, 1);
			}
		} else
		if ( !(m_Style & 0x800000) )
		{
			if (!m_DIBList[State])
				m_pWispBase->m_pWispDrawObj->DrawButtonFrameRect(
					&m_WindowDC, &rcBtn, State);
			if (State == 1) //WISP_BT_DIB_HOVER
			{
				rcBtn.x += 3;
				rcBtn.y += 3;
				rcBtn.cx -= 6;
				rcBtn.cy -= 6;
			} else
			{
				rcBtn.x += 1;
				rcBtn.y += 1;
				rcBtn.cx -= 2;
				rcBtn.cy -= 2;
			}
		}

		if (m_WndText.m_nLength)
		{
			if (m_bTextRect)
			{
				rcBtn = m_TextRect;
			}

			if (State != 1) //WISP_BT_DIB_HOVER
			{
				rcBtn.x += 2;
				rcBtn.y += 2;
				rcBtn.cx -= 4;
				rcBtn.cy -= 4;
			}

			uStyle = 0x24;
			if ( (m_Style & 0x30000) != 0x10000)
			{
				uStyle = 0x25;
				if ( (m_Style & 0x30000) == 0x20000)
					uStyle = 0x26;
			}

			if ( (m_Style >> 9) & 1 )
			{
				OrgTextColor = m_WindowDC.m_TextColor;
				m_WindowDC.m_OldTextColor = m_WindowDC.m_TextColor;
				m_WindowDC.m_TextColor = m_pWispBase->m_pWispDrawObj->m_crSystem[12];
			}

			if (State == 2) //WISP_BT_DIB_DOWN
			{
				++rcBtn.x;
				++rcBtn.y;
			}

			m_WindowDC.DrawString(m_WndText.operator const WCHAR*(), &rcBtn, uStyle, 0, -1);

			if ( (m_Style >> 9) & 1 )
			{
				m_WindowDC.m_OldTextColor = m_WindowDC.m_TextColor;
				m_WindowDC.m_TextColor = OrgTextColor;
			}
		}

		return false;
	}

	bool CWispButton::InitWnd()
	{
		if (!CWispBaseWnd::InitWnd())
			return false;

		m_bPressed = false;
		m_bMouseInBTRect = PtInRect(&m_ScrWindowRect, &m_pWispBase->m_MousePT);

		m_DIBList[0] = 0;	//SetDIBList(0);
		m_DIBList[1] = 0;
		m_DIBList[2] = 0;
		m_DIBList[3] = 0;

		return true;
	}

	void CWispButton::OnButtonEnter()
	{
		//NONE
	}
	void CWispButton::OnButtonLeave()
	{
		//NONE
	}

	bool CWispButton::CreateEx(CWispDIBList *pDIBList, int x, int y, CWispWnd *pParentWnd, unsigned int CmdID, unsigned int Style)
	{
		if (!Create(0, x,y,
			pDIBList->m_DIBList[0].m_PixelBuf.Width,
			pDIBList->m_DIBList[0].m_PixelBuf.Height,
			(CWispBaseWnd*)pParentWnd, CmdID, Style, WISP_SH_MINSIZE))
			return false;
		SetDIBList(pDIBList);
		return true;
	}
	bool CWispButton::CreateEx(CWispDIB *pDIB, int x, int y, CWispWnd *pParentWnd, unsigned int CmdID, unsigned int Style)
	{
		if (!Create(0, x,y,
			pDIB->m_PixelBuf.Width,
			pDIB->m_PixelBuf.Height,
			(CWispBaseWnd*)pParentWnd, CmdID, Style, WISP_SH_MINSIZE))
			return false;
		SetDIB(pDIB, WISP_BT_DIB_NORMAL); //m_DIBList[0] = pDIB;
		return true;
	}
	bool CWispButton::SetDIB(CWispDIB *pDIB, WISP_BT_DIB DIB)
	{
		//if (!(m_Style & 0x20)) return false; //BYTE2()
		m_DIBList[DIB] = pDIB;
		return true;
	}
	bool CWispButton::SetDIBList(CWispDIBList *pDIBList)
	{
		for (int n = 0; n < 4; ++n)
			m_DIBList[n] = pDIBList->GetDIB(n);
		return true;
	}

```

`source/Wisp/wispbutton.hpp`:

```hpp

#ifndef _WISPBUTTON_HPP_
#define _WISPBUTTON_HPP_

#include "../Code/define.h"
#include "wispbasewnd.hpp"
#include "wispdrawobj.hpp"

struct CWispWnd; //???

struct CWispButton : public CWispBaseWnd
{
	CWispButton();
	virtual ~CWispButton();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	virtual void RecalcLayout() override;

	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	bool OnMouseLeave(WISP_MSG *pMsg);
	bool OnMove(WISP_MSG *pMsg);
	bool OnUpdate(WISP_MSG *pMsg);

	virtual bool InitWnd() override;

	virtual void OnButtonEnter(); // {} Press
	virtual void OnButtonLeave(); // {} Release

	bool m_bTextRect;
	WISP_RECT m_TextRect;

	bool m_bPressed;
	bool m_bMouseInBTRect;

	CWispDIB *m_DIBList[WISP_BT_DIB_COUNT];

	bool CreateEx(CWispDIBList *pDIBList, int x, int y, CWispWnd *pParentWnd, unsigned int CmdID, unsigned int Style);
	bool CreateEx(CWispDIB *pDIB, int x, int y, CWispWnd *pParentWnd, unsigned int CmdID, unsigned int Style);
	bool SetDIB(CWispDIB *pDIB, WISP_BT_DIB DIB);
	bool SetDIBList(CWispDIBList *pDIBList);
};

#endif
```

`source/Wisp/wispcalcwnd.cpp`:

```cpp

#include "wispbase.hpp"
#include "wispcalcwnd.hpp"

enum
{
  BUTTON_CONFIG = 0,
  BUTTON_HELP = 1,
  EDIT_DISPLAY = 2,
  CHECKBOX_HEX = 3,
  CHECKBOX_DEC = 4,
  CHECKBOX_OCT = 5,
  CHECKBOX_BIN = 6,
  CHECKBOX_8BYTE = 7,
  CHECKBOX_4BYTE = 8,
  CHECKBOX_2BYTE = 9,
  CHECKBOX_1BYTE = 10,
  BUTTON_HYP = 11,
  BUTTON_INV = 12,
  BUTTON_A = 13,
  BUTTON_EE = 14,
  BUTTON_MR = 15,
  BUTTON_MOTHER = 16,
  BUTTON_MC = 17,
  BUTTON_AFUNCTION = 18,
  BUTTON_AC = 19,
  BUTTON_RSH = 20,
  BUTTON_PLUSMINUS = 21,
  BUTTON_B = 22,
  BUTTON_7 = 23,
  BUTTON_8 = 24,
  BUTTON_9 = 25,
  BUTTON_LBRACKET = 26,
  BUTTON_RBRACKET = 27,
  BUTTON_AND = 28,
  BUTTON_COS = 29,
  BUTTON_RECIPROCAL = 30,
  BUTTON_C = 31,
  BUTTON_4 = 32,
  BUTTON_5 = 33,
  BUTTON_6 = 34,
  BUTTON_MULTIPLYSIGN = 35,
  BUTTON_DIVESIONSIGN = 36,
  BUTTON_OR = 37,
  BUTTON_TAN = 38,
  BUTTON_FACTORIAL = 39,
  BUTTON_D = 40,
  BUTTON_1 = 41,
  BUTTON_2 = 42,
  BUTTON_3 = 43,
  BUTTON_ADDSIGN = 44,
  BUTTON_SUBSIGN = 45,
  BUTTON_LSH = 46,
  BUTTON_LOG = 47,
  BUTTON_SQUARE = 48,
  BUTTON_E = 49,
  BUTTON_DECIMAL = 50,
  BUTTON_0 = 51,
  BUTTON_EQUALSIGN = 52,
  BUTTON_PERCENTSIGN = 53,
  BUTTON_CMP = 54,
  BUTTON_MOD = 55,
  BUTTON_LN = 56,
  BUTTON_POWER = 57,
  BUTTON_F = 58,
  CONTROL_MAXNUM = 59,
};

	WISP_MSG_MAP_BEGIN(CWispCalcWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP_ON_COMMAND
	WISP_MSG_MAP_END(CWispWnd)

	CWispCalcWnd::CWispCalcWnd()
	{
		inverse = 0;
		refresh_display = 0;
		display_size = 20;
		m_NumberBitWdith = 0;
		input_limit = 0;
		input_count = 0;
		decimal_point = 0;
		precedence_base = 0;
		current_base = NB_DECIMAL;
		memory_num = 0;
		last_input = DIGIT;
		history_index = 0;
		key_pressed = 0;
		mInternalSpacing = 4;
	}

	CWispCalcWnd::~CWispCalcWnd()
	{
	}

	bool CWispCalcWnd::Create(int x, int y, CWispBaseWnd *parent, unsigned int CmdID)
	{
		return CreateWnd(WSTR("Calc"), x, y, 500, 204, parent, CmdID, 0xB, WISP_SH_MINSIZE);
	}

	bool CWispCalcWnd::OnCreate(WISP_MSG *pMsg)
	{
		WISP_RECT rc;
		rc.cy = 0;
		rc.cx = 0;
		rc.y = 0;
		rc.x = 0;

		bpA = new CWispButton;
		pbMR = new CWispButton;
		pbMRplusminus = new CWispButton;
		pbMC = new CWispButton;
		pbClear = new CWispButton;
		pbAC = new CWispButton;
		pbRsh = new CWispButton;
		pbplusmius = new CWispButton;
		bpB = new CWispButton;
		pb7 = new CWispButton;
		pb8 = new CWispButton;
		pb9 = new CWispButton;
		pbparenopen = new CWispButton;
		pbparenclose = new CWispButton;
		pband = new CWispButton;
		pbXor = new CWispButton;
		bpC = new CWispButton;
		pb4 = new CWispButton;
		pb5 = new CWispButton;
		pb6 = new CWispButton;
		pbX = new CWispButton;
		pbdivision = new CWispButton;
		pbor = new CWispButton;
		pbfactorial = new CWispButton;
		pbD = new CWispButton;
		pb1 = new CWispButton;
		pb2 = new CWispButton;
		pb3 = new CWispButton;
		pbplus = new CWispButton;
		pbminus = new CWispButton;
		pbshift = new CWispButton;
		pbsquare = new CWispButton;
		pbE = new CWispButton;
		pb0 = new CWispButton;
		pbequal = new CWispButton;
		pbnegate = new CWispButton;
		pbmod = new CWispButton;
		pbpower = new CWispButton;
		pbF = new CWispButton;

		anglebutton[0] = new CWispRadioBox;
		anglebutton[1] = new CWispRadioBox;
		anglebutton[2] = new CWispRadioBox;
		anglebutton[3] = new CWispRadioBox;

		basebutton[0] = new CWispRadioBox;
		basebutton[1] = new CWispRadioBox;
		basebutton[2] = new CWispRadioBox;
		basebutton[3] = new CWispRadioBox;

		//
		rc.x = 15;
		rc.y = 33;
		rc.cx = 40;
		rc.cy = 16;
		basebutton[0]->Create(WSTR("Hex"), rc, this, CHECKBOX_HEX, 0x20040, WISP_SH_MINSIZE);

		rc.y += 29;
		rc.x = 15;
		rc.cx = 40;
		rc.cy = 25;
		basebutton[1]->Create(WSTR("Dec"), rc, this, CHECKBOX_DEC, 0x20040, WISP_SH_MINSIZE);

		rc.y += 29;
		rc.x = 15;
		rc.cx = 40;
		rc.cy = 25;
		basebutton[2]->Create(WSTR("Oct"), rc, this, CHECKBOX_OCT, 0x20040, WISP_SH_MINSIZE);

		rc.y += 29;
		rc.x = 15;
		rc.cx = 40;
		rc.cy = 25;
		basebutton[3]->Create(WSTR("Bin"), rc, this, CHECKBOX_BIN, 0x20040, WISP_SH_MINSIZE);

		rc.x = 90;
		rc.y = 33;
		rc.cx = 58;
		rc.cy = 16;
		anglebutton[0]->Create(WSTR("64 Bit"), rc, this, CHECKBOX_8BYTE, 0x20040, WISP_SH_MINSIZE);

		rc.y += 29;
		rc.x = 90;
		rc.cx = 58;
		rc.cy = 25;
		anglebutton[1]->Create(WSTR("32 Bit"), rc, this, CHECKBOX_4BYTE, 0x20040, WISP_SH_MINSIZE);

		rc.y += 29;
		rc.x = 90;
		rc.cx = 58;
		rc.cy = 25;
		anglebutton[2]->Create(WSTR("16 Bit"), rc, this, CHECKBOX_2BYTE, 0x20040, WISP_SH_MINSIZE);

		rc.y += 29;
		rc.x = 90;
		rc.cx = 58;
		rc.cy = 25;
		anglebutton[3]->Create(WSTR(" 8 Bit"), rc, this, CHECKBOX_1BYTE, 0x20040, WISP_SH_MINSIZE);

		anglebutton[0]->Enable(0);
		anglebutton[1]->Enable(1);
		anglebutton[2]->Enable(0);
		anglebutton[3]->Enable(0);

		basebutton[0]->Enable(1);
		basebutton[1]->Enable(0);
		basebutton[2]->Enable(0);
		basebutton[3]->Enable(0);

		//
		WISP_RECT rc1;

		rc.y = 32;
		rc1.y = 32;
		rc.x = 268;
		rc1.x = 268;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbMR->Create(WSTR("MR"), rc1, this, BUTTON_MR, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc.y = 32;
		rc.cx = 40;
		rc.cy = 16;
		rc1.x = rc.x;
		rc1.y = 32;
		rc1.cx = 40;
		rc1.cy = 16;
		pbMRplusminus->Create(WSTR("M+-"), rc1, this, BUTTON_MOTHER, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc.y = 32;
		rc1.y = 32;
		rc1.x = rc.x;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbMC->Create(WSTR("MC"), rc1, this, BUTTON_MC, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc.y = 32;
		rc1.y = 32;
		rc1.x = rc.x;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbClear->Create(WSTR("C"), rc1, this, BUTTON_AFUNCTION, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc.y = 32;
		rc1.y = 32;
		rc1.x = rc.x;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbAC->Create(WSTR("AC"), rc1, this, BUTTON_AC, 0, WISP_SH_MINSIZE);

		rc.y += 20;
		rc.x = 180;
		rc1.x = 180;
		rc.cx = 40;
		rc.cy = 16;
		rc1.y = rc.y;
		rc1.cx = 40;
		rc1.cy = 16;
		pbplusmius->Create(WSTR("+/-"), rc1, this, BUTTON_PLUSMINUS, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pb7->Create(WSTR("7"), rc1, this, BUTTON_7, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pb8->Create(WSTR("8"), rc1, this, BUTTON_8, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pb9->Create(WSTR("9"), rc1, this, BUTTON_9, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbparenopen->Create(WSTR("("), rc1, this, BUTTON_LBRACKET, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbparenclose->Create(WSTR(")"), rc1, this, BUTTON_RBRACKET, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pband->Create(WSTR("And"), rc1, this, BUTTON_AND, 0, WISP_SH_MINSIZE);

		rc.y += 20;
		rc.x = 224;
		rc1.x = 224;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pb4->Create(WSTR("4"), rc1, this, BUTTON_4, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pb5->Create(WSTR("5"), rc1, this, BUTTON_5, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc.cx = 40;
		rc.cy = 16;
		rc1.y = rc.y;
		rc1.cx = 40;
		rc1.cy = 16;
		pb6->Create(WSTR("6"), rc1, this, BUTTON_6, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbX->Create(WSTR("X"), rc1, this, BUTTON_MULTIPLYSIGN, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbdivision->Create(WSTR("/"), rc1, this, BUTTON_DIVESIONSIGN, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbor->Create(WSTR("Or"), rc1, this, BUTTON_OR, 0, WISP_SH_MINSIZE);

		rc.y += 20;
		rc.x = 180;
		rc1.x = 180;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbfactorial->Create(WSTR("x!"), rc1, this, BUTTON_FACTORIAL, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pb1->Create(WSTR("1"), rc1, this, BUTTON_1, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pb2->Create(WSTR("2"), rc1, this, BUTTON_2, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pb3->Create(WSTR("3"), rc1, this, BUTTON_3, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbplus->Create(WSTR("+"), rc1, this, BUTTON_ADDSIGN, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc.cx = 40;
		rc.cy = 16;
		rc1.y = rc.y;
		rc1.cx = 40;
		rc1.cy = 16;
		pbminus->Create(WSTR("-"), rc1, this, BUTTON_SUBSIGN, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbshift->Create(WSTR("Lsh"), rc1, this, BUTTON_LSH, 0, WISP_SH_MINSIZE);

		rc.y += 20;
		rc.x = 180;
		rc1.x = 180;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbsquare->Create(WSTR("x^2"), rc1, this, BUTTON_SQUARE, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pb0->Create(WSTR("0"), rc1, this, BUTTON_0, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbequal->Create(WSTR("="), rc1, this, BUTTON_EQUALSIGN, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbnegate->Create(WSTR("Not"), rc1, this, BUTTON_CMP, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbmod->Create(WSTR("Mod"), rc1, this, BUTTON_MOD, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbRsh->Create(WSTR("Rsh"), rc1, this, BUTTON_RSH, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbXor->Create(WSTR("Cos"), rc1, this, BUTTON_COS, 0, WISP_SH_MINSIZE);

		rc.y += 20;
		rc.x = 180;
		rc1.x = 180;
		rc.cx = 40;
		rc.cy = 16;
		rc1.y = rc.y;
		rc1.cx = 40;
		rc1.cy = 16;
		pbpower->Create(WSTR("x^y"), rc1, this, BUTTON_POWER, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		bpA->Create(WSTR("A"), rc1, this, BUTTON_A, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		bpB->Create(WSTR("B"), rc1, this, BUTTON_B, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		bpC->Create(WSTR("C"), rc1, this, BUTTON_C, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbD->Create(WSTR("D"), rc1, this, BUTTON_D, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cx = 40;
		rc.cy = 16;
		rc1.cx = 40;
		rc1.cy = 16;
		pbE->Create(WSTR("E"), rc1, this, BUTTON_E, 0, WISP_SH_MINSIZE);

		rc.x += 44;
		rc.cx = 40;
		rc1.cx = 40;
		rc1.x = rc.x;
		rc1.y = rc.y;
		rc.cy = 16;
		rc1.cy = 16;
		pbF->Create(WSTR("F"), rc1, this, BUTTON_F, 0, WISP_SH_MINSIZE);

		//
		//set_precision();
		UpdateDisplay();
		//set_style();
		Base_Selected(0);
		//InitializeCalculator();
		LoadTitleDIB("\\WispApp\\Calc\\Calc.bmp", 0);
		m_pTitleDIB->SetType(2);
		m_pTitleDIB->SetColorKey(0);
		return true;
	}

	bool CWispCalcWnd::OnDestroy(WISP_MSG *pMsg)
	{
		bpA->Destroy();
		delete bpA;

		pbMR->Destroy();
		delete pbMR;

		pbMRplusminus->Destroy();
		delete pbMRplusminus;

		pbMC->Destroy();
		delete pbMC;

		pbClear->Destroy();
		delete pbClear;

		pbAC->Destroy();
		delete pbAC;

		pbRsh->Destroy();
		delete pbRsh;

		pbplusmius->Destroy();
		delete pbplusmius;

		bpB->Destroy();
		delete bpB;

		pb7->Destroy();
		delete pb7;

		pb8->Destroy();
		delete pb8;

		pb9->Destroy();
		delete pb9;

		pbparenopen->Destroy();
		delete pbparenopen;

		pbparenclose->Destroy();
		delete pbparenclose;

		pband->Destroy();
		delete pband;

		pbXor->Destroy();
		delete pbXor;

		bpC->Destroy();
		delete bpC;

		pb4->Destroy();
		delete pb4;

		pb5->Destroy();
		delete pb5;

		pb6->Destroy();
		delete pb6;

		pbX->Destroy();
		delete pbX;

		pbdivision->Destroy();
		delete pbdivision;

		pbor->Destroy();
		delete pbor;

		pbfactorial->Destroy();
		delete pbfactorial;

		pbD->Destroy();
		delete pbD;

		pb1->Destroy();
		delete pb1;

		pb2->Destroy();
		delete pb2;

		pb3->Destroy();
		delete pb3;

		pbplus->Destroy();
		delete pbplus;

		pbminus->Destroy();
		delete pbminus;

		pbshift->Destroy();
		delete pbshift;

		pbsquare->Destroy();
		delete pbsquare;

		pbE->Destroy();
		delete pbE;

		pb0->Destroy();
		delete pb0;

		pbequal->Destroy();
		delete pbequal;

		pbnegate->Destroy();
		delete pbnegate;

		pbmod->Destroy();
		delete pbmod;

		pbpower->Destroy();
		delete pbpower;

		pbF->Destroy();
		delete pbF;
		//
		anglebutton[3]->Destroy();
		delete anglebutton[3];

		anglebutton[2]->Destroy();
		delete anglebutton[2];

		anglebutton[1]->Destroy();
		delete anglebutton[1];

		anglebutton[0]->Destroy();
		delete anglebutton[0];
		//
		basebutton[3]->Destroy();
		delete basebutton[3];

		basebutton[2]->Destroy();
		delete basebutton[2];

		basebutton[1]->Destroy();
		delete basebutton[1];

		basebutton[0]->Destroy();
		delete basebutton[0];
		//
		return true;
	}

	bool CWispCalcWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.bKeyDown)
			OnKeyDown(pMsg);
		else	OnKeyUp(pMsg);
		Update((WISP_RECT*)0);
		return true;
	}

	bool CWispCalcWnd::OnKeyDown(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}

	bool CWispCalcWnd::OnKeyUp(WISP_MSG *pMsg)
	{
		//
		return true;
	}

	bool CWispCalcWnd::OnCommand(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CtrlType == WISP_CTRL_RADIO_BOX)
		{
			switch (pMsg->Command.CmdID)
			{
			case CHECKBOX_HEX:
				Hex_Selected(); break;
			case CHECKBOX_DEC:
				Dec_Selected(); break;
			case CHECKBOX_OCT:
				Oct_Selected(); break;
			case CHECKBOX_BIN:
				Bin_Selected(); break;
			case CHECKBOX_8BYTE:
				Qword_Selected(); break;
			case CHECKBOX_4BYTE:
				Dword_Selected(); break;
			case CHECKBOX_2BYTE:
				Word_Selected();  break;
			case CHECKBOX_1BYTE:
				Byte_Selected();  break;
			default: break;
			}
		}

		if (pMsg->Command.CtrlType == WISP_CTRL_BUTTON && pMsg->Command.CmdMsg == 0x80000002)
		{
			switch (pMsg->Command.CmdID)
			{
			
			}
		}
		return true;
	}

	bool CWispCalcWnd::OnUpdateClient(WISP_MSG *pMsg)
	{
		CWispWnd::OnUpdateClient(pMsg);

		WISP_RECT rc;
		WCHAR DisplayOut[100];

		rc.x = 5;
		rc.y = 31;
		rc.cx = 64;
		rc.cy = 117;
		m_ClientDC.DrawRect(&rc, m_pWispBase->m_pWispDrawObj->m_crSystem[2]);

		rc.x = 85;
		rc.y = 31;
		rc.cx = 66;
		rc.cy = 117;
		m_ClientDC.DrawRect(&rc, m_pWispBase->m_pWispDrawObj->m_crSystem[2]);

		rc.x = 5;
		rc.y = 156;
		rc.cx = 49;
		rc.cy = 17;
		m_ClientDC.DrawFrameRect(&rc, 0, 1);
		m_ClientDC.DrawString(WSTR("NORM"), &rc, 5, 0, -1);

		rc.x = 58;
		rc.y = 156;
		rc.cx = 49;
		rc.cy = 17;
		m_ClientDC.DrawFrameRect(&rc, 0, 1);
		m_ClientDC.DrawString(WSTR(""), &rc, 5, 0, -1);

		rc.x = 111;
		rc.y = 156;
		rc.cx = 374;
		rc.cy = 17;
		m_ClientDC.DrawFrameRect(&rc, 0, 1);

		rc.x = 5;
		rc.y = 4;
		rc.cx = 479;
		rc.cy = 22;
		m_ClientDC.DrawFullRect(&rc, m_pWispBase->m_pWispDrawObj->m_crSystem[1]);
		m_ClientDC.DrawRect(&rc, m_pWispBase->m_pWispDrawObj->m_crSystem[0]);
		rc.cx -= 4;
		TStrToStr(display_str, DisplayOut);
		m_ClientDC.DrawString(DisplayOut, &rc, 6, 0, -1);
		
		return false;
	}

	void CWispCalcWnd::Create()
	{
		if (IsWindow())
		{
			Show(WISP_SH_MINSIZE);
		} else
		{
			Create(0, 0, 0, 0);
			Center(nullptr);
		}
	}

	void CWispCalcWnd::UpdateDisplay()
	{
		//TODO
		Update((WISP_RECT*)0);
	}

	void CWispCalcWnd::angle_selected(int number)
	{
		if (number == 0)
		{
			m_NumberBitWdith = 0;
		} else
		if (number == 1)
		{
			m_NumberBitWdith = 1;
		} else
		if (number == 2)
		{
			m_NumberBitWdith = 2;
		} else
		if (number == 3)
		{
			m_NumberBitWdith = 1;
		} else
			m_NumberBitWdith = 1;
	}

	void CWispCalcWnd::Qword_Selected()
	{
		anglebutton[0]->Enable(1);
		anglebutton[1]->Enable(0);
		anglebutton[2]->Enable(0);
		anglebutton[3]->Enable(0);
		angle_selected(0);
	}

	void CWispCalcWnd::Dword_Selected()
	{
		anglebutton[0]->Enable(0);
		anglebutton[1]->Enable(1);
		anglebutton[2]->Enable(0);
		anglebutton[3]->Enable(0);
		angle_selected(1);
	}

	void CWispCalcWnd::Word_Selected()
	{
		anglebutton[0]->Enable(0);
		anglebutton[1]->Enable(0);
		anglebutton[2]->Enable(1);
		anglebutton[3]->Enable(0);
		angle_selected(2);
	}

	void CWispCalcWnd::Byte_Selected()
	{
		anglebutton[0]->Enable(0);
		anglebutton[1]->Enable(0);
		anglebutton[2]->Enable(0);
		anglebutton[3]->Enable(1);
		angle_selected(3);
	}

	void CWispCalcWnd::Hex_Selected()
	{
		basebutton[0]->Enable(1);
		basebutton[1]->Enable(0);
		basebutton[2]->Enable(0);
		basebutton[3]->Enable(0);
		Base_Selected(0);
	}

	void CWispCalcWnd::Dec_Selected()
	{
		basebutton[0]->Enable(0);
		basebutton[1]->Enable(1);
		basebutton[2]->Enable(0);
		basebutton[3]->Enable(0);
		Base_Selected(1);
	}

	void CWispCalcWnd::Oct_Selected()
	{
		basebutton[0]->Enable(0);
		basebutton[1]->Enable(0);
		basebutton[2]->Enable(1);
		basebutton[3]->Enable(0);
		Base_Selected(2);
	}

	void CWispCalcWnd::Bin_Selected()
	{
		basebutton[0]->Enable(0);
		basebutton[1]->Enable(0);
		basebutton[2]->Enable(0);
		basebutton[3]->Enable(1);
		Base_Selected(3);
	}

	void CWispCalcWnd::history_next()
	{
		//TODO
	}

	void CWispCalcWnd::history_prev()
	{
		//TODO
	}

	void CWispCalcWnd::Base_Selected(int number)
	{
		bpA->EnableWindow(number == 0);
		bpB->EnableWindow(number == 0);
		bpC->EnableWindow(number == 0);
		pbD->EnableWindow(number == 0);
		pbE->EnableWindow(number == 0);
		pbF->EnableWindow(number == 0);
		pb9->EnableWindow(number <= 1);
		pb8->EnableWindow(number <= 1);
		pb7->EnableWindow(number <= 2);
		pb6->EnableWindow(number <= 2);
		pb5->EnableWindow(number <= 2);
		pb4->EnableWindow(number <= 2);
		pb3->EnableWindow(number <= 2);
		pb2->EnableWindow(number <= 2);
		base_selected(number);
	}

	void CWispCalcWnd::base_selected(int number)
	{
		switch (number)
		{
		case 0:
			current_base = NB_HEX;
			display_size = 16;
			input_limit = 16;
			decimal_point = 0;
			UpdateDisplay();
			break;
		case 2:
			current_base = NB_OCTAL;
			display_size = 22;
			input_limit = 11;
			decimal_point = 0;
			UpdateDisplay();
			break;
		case 3:
			current_base = NB_BINARY;
			display_size = 64;
			input_limit = 32;
			decimal_point = 0;
			UpdateDisplay();
			break;
		default:
			current_base = NB_DECIMAL;
			display_size = 20;
			input_limit = 0;
			UpdateDisplay();
			break;
		}
	}
#if 0
bool CWispCalcWnd::OnKeyDown(WISP_MSG *pMsg)
{
	switch (pMsg->u.field_8)
	{
	case 0x8:
		key_pressed = 1;
		ClearAll();
		break;
	case 0xD:
		key_pressed = 1;
		EnterEqual();
		break;
	case 0x1B:
		key_pressed = 1;
		Clear();
		break;
	case 0x21:
		key_pressed = 1;
		Clear();
		break;
	case 0x22:
		key_pressed = 1;
		ClearAll();
		break;
	case 0x26:
		history_prev();
		break;
	case 0x28:
		history_next();
		break;
	case 0x2E:
		key_pressed = 1;
		ClearAll();
		break;
	case 0x30:
		key_pressed = 1;
		if (m_pWispBase->m_KeyMap[16])
			EnterCloseParen();
		else	EnterDigit(0);
		break;
	case 0x31:
		key_pressed = 1;
		if (m_pWispBase->m_KeyMap[16])
			EnterFactorial();
		else	EnterDigit(1);
		break;
	case 0x32:
		key_pressed = 1;
		button2();
		break;
	case 0x39:
		key_pressed = 1;
		if (m_pWispBase->m_KeyMap[16])
			EnterOpenParen();
		else	button9();
		break;

	case 0x41:
		key_pressed = 1;
		buttonA();
		break;
	case 0x42:
		key_pressed = 1;
		buttonB();
		break;
	case 0x43:
		key_pressed = 1;
		if (current_base == NB_HEX)
			buttonC();
		else	Xor();
	case 0x44:
		key_pressed = 1;
		buttonD();
		break;
	case 0x45:
		key_pressed = 1;
		if (current_base == NB_HEX && !display_error)
			buttonE();
		break;
	case 0x46:
		key_pressed = 1;
		buttonF();
		break;
	case 0x48:
		key_pressed = 1;
		break;
	case 0x49:
		key_pressed = 1;
		inverse = inverse == 0;
		break;

	//case 0x4A:
	//case 0x4B:

	case 0x4C:
		break;
	case 0x4D:
		key_pressed = 1;
		break;
	case 0x4E:
		key_pressed = 1;
		break;
	case 0x4F:
		key_pressed = 1;
		Or();
		break;
	case 0x52:
		key_pressed = 1;
		break;
	case 0x53:
		key_pressed = 1;
		Rshift();
		break;
	case 0x54:
		key_pressed = 1;
		break;
	case 0x58:
		key_pressed = 1;
		Multiply();
		break;
	case 0xBA:
		key_pressed = 1;
		if (m_pWispBase->m_KeyMap[16])
			Mod();
		break;
	case 0xBB:
		key_pressed = 1;
		if (m_pWispBase->m_KeyMap[16])
			Plus();
		else	EnterEqual();
		break;
	case 0xBD:
		key_pressed = 1;
		Minus();
		break;
	case 0xBE:
		key_pressed = 1;
		break;
	case 0xC0:
		key_pressed = 1;
		if (m_pWispBase->m_KeyMap[16])
			EnterNotCmp();
		break;
	case 0xDB:
		key_pressed = 1;
		EnterSquare();
		break;
	case 0xDC:
		key_pressed = 1;
		if (m_pWispBase->m_KeyMap[16])
			Or();
		else	EnterNegate();
		break;
	case 0x6F:
		key_pressed = 1;
		Divide();
		break;
	case 0x72:
		kcalcdefaults.style = kcalcdefaults.style == 0;
		set_style();
		break;
	
	}
}
#endif
```

`source/Wisp/wispcalcwnd.hpp`:

```hpp

#ifndef _WISPCALCWND_HPP_
#define _WISPCALCWND_HPP_

#include "../Code/define.h"
#include "../Code/tstrmem.hpp"
#include "../Code/alt/altlist.hpp"
#include "wispwnd.hpp"
#include "wispbutton.hpp"
#include "wispradiobox.hpp"

struct _DefStruct
{
	unsigned long forecolor;
	unsigned long backcolor;
	unsigned long numberButtonColor;
	unsigned long functionButtonColor;
	unsigned long hexButtonColor;
	unsigned long memoryButtonColor;
	unsigned long operationButtonColor;
	int precision;
	int fixedprecision;
	int style;
	char fixed;
	char beep;

	CWispFont font;
};

enum _last_input_type
{
  DIGIT = 1,
  OPERATION = 2,
  RECALL = 3,
  PASTE = 4,
};

enum _num_base
{
  NB_BINARY = 2,
  NB_OCTAL = 8,
  NB_DECIMAL = 10,
  NB_HEX = 16,
};

enum _angle_type
{
  ANG_DEGREE = 0,
  ANG_RADIAN = 1,
  ANG_GRADIENT = 2,
};

struct CWispCalcWnd: public CWispWnd
{
	CWispRadioBox *anglebutton[4];
	CWispRadioBox *basebutton[4];
	CWispButton *bpA;
	CWispButton *pbMR;
	CWispButton *pbMRplusminus;
	CWispButton *pbMC;
	CWispButton *pbClear;
	CWispButton *pbAC;
	CWispButton *pbRsh;
	CWispButton *pbplusmius;
	CWispButton *bpB;
	CWispButton *pb7;
	CWispButton *pb8;
	CWispButton *pb9;
	CWispButton *pbparenopen;
	CWispButton *pbparenclose;
	CWispButton *pband;
	CWispButton *pbXor;
	CWispButton *bpC;
	CWispButton *pb4;
	CWispButton *pb5;
	CWispButton *pb6;
	CWispButton *pbX;
	CWispButton *pbdivision;
	CWispButton *pbor;
	CWispButton *pbfactorial;
	CWispButton *pbD;
	CWispButton *pb1;
	CWispButton *pb2;
	CWispButton *pb3;
	CWispButton *pbplus;
	CWispButton *pbminus;
	CWispButton *pbshift;
	CWispButton *pbsquare;
	CWispButton *pbE;
	CWispButton *pb0;
	CWispButton *pbequal;
	CWispButton *pbnegate;
	CWispButton *pbmod;
	CWispButton *pbpower;
	CWispButton *pbF;

	_DefStruct kcalcdefaults;
	bool inverse;
	bool refresh_display;
	int display_size;
	int m_NumberBitWdith;
	int input_limit;
	int input_count;
	int decimal_point;
	int precedence_base;
	_num_base current_base;
	long long memory_num;
	_last_input_type last_input;
	char display_str[66];

	TList<long long> history_list;
	int history_index;
	bool key_pressed;
	int mInternalSpacing;

	CWispCalcWnd();
	virtual ~CWispCalcWnd();

	bool Create(int x, int y, CWispBaseWnd *parent, unsigned int CmdID);

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnKeyDown(WISP_MSG *pMsg);
	bool OnKeyUp(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);

	void Create();

	void UpdateDisplay();

	void angle_selected(int number);
	void Qword_Selected();
	void Dword_Selected();
	void Word_Selected();
	void Byte_Selected();

	void Hex_Selected();
	void Dec_Selected();
	void Oct_Selected();
	void Bin_Selected();

	void history_next();
	void history_prev();

	void Base_Selected(int number);
	void base_selected(int number);
};

#endif

```

`source/Wisp/wispcheckbox.cpp`:

```cpp

#include "wispcheckbox.hpp"
#include "wispbase.hpp"
#include "wispwnd.hpp"

	CWispCheckBox::CWispCheckBox()
	{
		m_TextRect.cy = 0;
		m_TextRect.cx = 0;
		m_TextRect.y = 0;
		m_TextRect.x = 0;

		m_CheckBoxRect.cy = 0;
		m_CheckBoxRect.cx = 0;
		m_CheckBoxRect.y = 0;
		m_CheckBoxRect.x = 0;

		m_bIsMultiLine = false;
		m_bMouseDown = false;
		m_bMouseIn = false;
		m_CtrlType = WISP_CTRL_CHECK_BOX;
	}
	CWispCheckBox::~CWispCheckBox()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispCheckBox)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
	WISP_MSG_MAP_END(CWispBaseWnd)

	bool CWispCheckBox::OnUpdate(WISP_MSG *pMsg)
	{
		if (!(m_Style & 0x40))
			m_pWispBase->m_pWispDrawObj->DrawCtrlClient(&m_WindowDC, &m_WindowRect);

		if (!(m_Style & 0x40000000))
		{
			if ((m_Style >> 10) & 1)
				m_WindowDC.DrawSystemStandardIcon(&m_CheckBoxRect, 0x0C, 0x21A221); //12 WISP_SSI_CHECKBOX_CHECKED
			else	m_WindowDC.DrawSystemStandardIcon(&m_CheckBoxRect, 0x0B, 0x21A221); //11 WISP_SSI_CHECKBOX_UNCHECKED
		}

		DrawCaption();

		if (m_Style & 0x40000000)
		{
			if (((m_Style >> 10) & 1) || (m_bMouseDown && m_bMouseIn))
				m_WindowDC.DrawFrameRect(&m_WindowRect, 0, 1);
			else	m_WindowDC.DrawFrameRect(&m_WindowRect, 1, 1);
		}
		return false;
	}
	bool CWispCheckBox::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			if (pMsg->KeyEvent.bKeyDown)
			{
				m_bMouseDown = true;
			} else
			if (OnMouseLUp(pMsg))
			{
				WISP_MSG Msg;
				Msg.Msg = WISP_WM_COMMAND;
				Msg.hWnd = (CWispWnd *)m_OwnerWnd;
				Msg.Command.CtrlType = m_CtrlType;
				Msg.Command.CmdMsg = 0x80000300; //WISP_ID_BOX_SELECT
				Msg.Command.CmdID = m_CmdID;
				Msg.Command.Param1 = (m_Style >> 10) & 1;
				m_pWispBase->SendMessage(&Msg);
			}
			Update((WISP_RECT*)0);
		}
		return true;
	}
	bool CWispCheckBox::OnMouseLDown(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.bKeyDown)
		{
			m_bMouseDown = true;
			return true;
		}
		return false;
	}
	bool CWispCheckBox::OnMouseLUp(WISP_MSG *pMsg)
	{
		if (!m_bMouseIn || !m_bMouseDown)
			return false;
		if (!((m_Style >> 10) & 1))
			Enable(1);
		else	Enable(0);
		m_bMouseDown = false;
                return true;
	}
//	bool CWispCheckBox::OnGetFocus(WISP_MSG *pMsg) { m_bFocus = 1; return true; }
//	bool CWispCheckBox::OnLostFocus(WISP_MSG *pMsg) { m_bFocus = 0; return true; }
	bool CWispCheckBox::OnMouseLeave(WISP_MSG *pMsg)
	{
		m_bMouseIn = false;
		if (m_bMouseDown == false)
			return true;
		if (!pMsg->bMsgLBTDown)
			m_bMouseDown = false;
		return false;
	}
	bool CWispCheckBox::OnMouseMove(WISP_MSG *pMsg)
	{
		m_bMouseIn = true;
		return true;
	}
	bool CWispCheckBox::InitWnd()
	{
		if (!CWispBaseWnd::InitWnd())
			return false;
		m_Style &= ~0xBB;
		if (m_Style & 0x40000000)
			m_Style |= 6;
		m_Style |= 0x40;
		if (m_Style & 0x80000000)
			m_bIsMultiLine = true;
		if (m_Style & 0x40000000)
		{
			m_TextRect = m_WindowRect;
			m_CheckBoxRect = m_WindowRect;
			return true;
		}
		if (m_Style & 0x2000000)
		{
			m_CheckBoxRect.x = m_WindowRect.cx + m_WindowRect.x - 13;
			m_CheckBoxRect.y = m_WindowRect.y + (m_WindowRect.cy - 9) / 2;
			m_CheckBoxRect.cx = 13;
			m_CheckBoxRect.cy = 13;
			if (m_Style & 0x40000)
				m_CheckBoxRect.y = m_WindowRect.y;
			else
			if (m_Style & 0x80000)
				m_CheckBoxRect.y = m_WindowRect.y + m_WindowRect.cy - 9;

			m_TextRect.x = m_WindowRect.x;
			m_TextRect.y = m_WindowRect.y + (m_WindowRect.cy - 9) / 2;
			if (m_Style & 0x40000)
				m_TextRect.y = m_WindowRect.y;
			else
			if (m_Style & 0x80000)
				m_TextRect.y = m_WindowRect.y + m_WindowRect.cy - m_WindowDC.m_pFont->m_Height;
			m_TextRect.cx = (m_WindowRect.cx + m_WindowRect.x - 13) - m_WindowRect.x - 6;
			//
			if (m_Style & 0x80000000)
			{
				m_TextRect.cy = m_WindowRect.cy;
			} else
			{
				m_TextRect.cy = m_WindowDC.m_pFont->m_Height;
				if (m_WindowDC.m_pFont->m_Height > 13)
					m_CheckBoxRect.y += (m_WindowDC.m_pFont->m_Height - 9) / 2;
			}
		} else
		{
			m_CheckBoxRect.x = m_WindowRect.x;
			m_CheckBoxRect.y = m_WindowRect.y + (m_WindowRect.cy - 9) / 2;
			m_CheckBoxRect.cx = 13;
			m_CheckBoxRect.cy = 13;
			if (m_Style & 0x40000)
				m_CheckBoxRect.y = m_WindowRect.y;
			else
			if (m_Style & 0x80000)
				m_CheckBoxRect.y = m_WindowRect.y + m_WindowRect.cy - 9;

			m_TextRect.x = m_WindowRect.x + 19;
			m_TextRect.y = m_WindowRect.y + (m_WindowRect.cy - 9) / 2;
			if (m_Style & 0x40000)
				m_TextRect.y = m_WindowRect.y;
			else
			if (m_Style & 0x80000)
				m_TextRect.y = m_WindowRect.y + m_WindowRect.cy - m_WindowDC.m_pFont->m_Height;
			//
			if (m_Style & 0x80000000)
			{
				m_TextRect.cy = m_WindowRect.cy;
			} else
			{
				m_TextRect.cy = m_WindowDC.m_pFont->m_Height;
				if (m_WindowDC.m_pFont->m_Height > 13)
					m_CheckBoxRect.y += (m_WindowDC.m_pFont->m_Height - 9) / 2;
			}
		}
		return true;
	}
//	void CWispCheckBox::DrawFocusRect(WISP_MSG *pMsg)
//	void CWispCheckBox::DrawBorder()
//	void CWispCheckBox::DrawCheckBox(WISP_MSG *pMsg)
	void CWispCheckBox::DrawCaption()
	{
		WISP_RECT Rect = m_TextRect;
		unsigned int uFormat = 4;
		if (m_Style & 0x40000000)
		{
			uFormat = 5;
			if (m_bMouseDown && m_bMouseIn)
				++Rect.x;
		}
		if (!m_bIsMultiLine)
			uFormat |= 0x20;
		if (m_Style & 0x80000)
			uFormat |= 8;
		if ((m_Style >> 9) & 1)                          // 0x200
			m_WindowDC.SetTextColor(m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
		m_WindowDC.DrawString(m_WndText.operator const WCHAR*(), &Rect, uFormat, 0, -1);
		if ((m_Style >> 9) & 1)
			m_WindowDC.SetTextColor();
	}
//	int CWispCheckBox::SetState(int newState)
//	int CWispCheckBox::GetState()
	void CWispCheckBox::Enable(bool bEnable)
	{
		if (bEnable)
			m_Style |= 0x400;
		else	m_Style &= ~0x400;
	}

```

`source/Wisp/wispcheckbox.hpp`:

```hpp

#ifndef _WISPCHECKBOX_HPP_
#define _WISPCHECKBOX_HPP_

#include "../Code/define.h"
#include "wispbasewnd.hpp"

struct CWispCheckBox : public CWispBaseWnd
{
	CWispRect m_TextRect;
	CWispRect m_CheckBoxRect;
//	bool m_bIsThreeState;
//	int m_CurrentState;
//	unsigned int m_uStyle;
	bool m_bIsMultiLine;//???
	bool m_bFocus;//???
	bool m_bMouseDown;
	bool m_bMouseIn;
//	bool m_EnableState;

	CWispCheckBox();
	virtual ~CWispCheckBox();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnMouseLDown(WISP_MSG *pMsg);
	bool OnMouseLUp(WISP_MSG *pMsg);
//	bool OnGetFocus(WISP_MSG *pMsg) { m_bFocus = 1; return true; }
//	bool OnLostFocus(WISP_MSG *pMsg) { m_bFocus = 0; return true; }
	bool OnMouseLeave(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	virtual bool InitWnd() override;
//	void DrawFocusRect(WISP_MSG *pMsg);
//	void DrawBorder();
//	void DrawCheckBox(WISP_MSG *pMsg);
	void DrawCaption();
//	int SetState(int newState);
//	int GetState();
	void Enable(bool bEnable);
};

#endif
```

`source/Wisp/wispcolorstrwnd.cpp`:

```cpp

#include "wispcolorstrwnd.hpp"
#include "wispbase.hpp"

	CWispColorStrWnd::CWispColorStrWnd()
	{
		m_MaxChars = 0;
		m_MaxLines = 0;
		m_Margin = 5;
	}
	CWispColorStrWnd::~CWispColorStrWnd()
	{
		//NONE
	}

	WISP_MSG_MAP_BEGIN(CWispColorStrWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_RECALC_LAYOUT, OnRecalcLayout)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_SCROLL_EVENT, OnScrollEvent)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispWnd)

	bool CWispColorStrWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_bSelect = false;
		return true;
	}
	bool CWispColorStrWnd::OnUpdateClient(WISP_MSG *pMsg)
	{
		CWispWnd::OnUpdateClient(pMsg);
		unsigned long CSBuffer[WISP_TERMINAL_LINE_SIZE+1];
		for (int line = 0; line < m_nLinesPerPage; ++line)
		{
			int PosY = line + m_ScrPos.y;
			CSBuffer[0] = 0;
			char BKClr = GetLineStr(PosY, CSBuffer);
			if (BKClr)
			{
				WISP_RECT Rect;
				Rect.x = 0;
				Rect.y = m_Margin + line * m_ClientDC.m_pFont->m_Height;
				Rect.cx = m_ClientRect.cx;
				Rect.cy = m_ClientDC.m_pFont->m_Height;
				m_ClientDC.DrawFullRect(&Rect, m_pWispBase->m_pWispDrawObj->m_crSystem[BKClr]);
			}

			int Length = TStrLen(CSBuffer);
			if (Length > 0)
			{
				if (m_Style & 0x20000 && m_bSelect &&
					PosY >= m_pSelStartPos->y && PosY <= m_pSelEndPos->y)
				{
					int PosX = m_Margin - m_ScrPos.x * m_ClientDC.m_pFont->m_Width;
					int n = 0;
					do {
						if (IsSelectChar(m_ScrPos.x + (PosX - m_Margin) / m_ClientDC.m_pFont->m_Width, PosY))
						{
							unsigned long Char = (CSBuffer[n + m_ScrPos.x] & 0xFFFF) + 0x19010000;
							PosX += m_ClientDC.DrawColorString(PosX, m_Margin + line * m_ClientDC.m_pFont->m_Height, &Char, 1, n + m_ScrPos.x);
						} else
						{
							unsigned long Char = (CSBuffer[n + m_ScrPos.x]);
							PosX += m_ClientDC.DrawColorString(PosX, m_Margin + line * m_ClientDC.m_pFont->m_Height, &Char, 1, n + m_ScrPos.x);
						}
						++n;
					} while (n < Length);
				} else
				{
					m_ClientDC.DrawColorString(
						m_Margin - m_ScrPos.x * m_ClientDC.m_pFont->m_Width,
						m_Margin + line * m_ClientDC.m_pFont->m_Height,
						CSBuffer, Length, 0);
				}
			}
		}
		return false;
	}
	bool CWispColorStrWnd::OnScrollEvent(WISP_MSG *pMsg)
	{
		CWispWnd::OnScrollEvent(pMsg);
		if (pMsg->ScrollEvent.Type == 1)
			m_ScrPos.x = m_pScrollBar[1]->CurPos;
		else	m_ScrPos.y = m_pScrollBar[0]->CurPos;
		UpdateCaretState();
		Update(&m_ClientRect);
		return false;
	}
	bool CWispColorStrWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (!pMsg->KeyEvent.bKeyDown)
			return true;

		WISP_MSG Msg;

		switch (pMsg->KeyEvent.KeyType)
		{
		case 2: //VK_RBUTTON
		case 0x4000002D: //WISP_SK_CTRL + VK_INSERT
		case 0x40000043: //WISP_SK_CTRL + C
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_EVENT;
			Msg.Command.CmdID = WISP_ID_COPY;
			m_pWispBase->PostMessage(&Msg);
			return false;
		case 0x1000002D: //WISP_SK_SHIFT + VK_INSERT
		case 0x40000056: //WISP_SK_CTRL + V
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_EVENT;
			Msg.Command.CmdID = WISP_ID_PASTE;
			m_pWispBase->PostMessage(&Msg);
			return false;
		}

		if (m_Style & 0x20000)
		{
			if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
			{
				m_bSelect = false;
				CalcPonitStrPos(&pMsg->MsgMouseWndPT, &m_RealSelStartPos);
				m_RealSelEndPos.x = -1;
				m_RealSelEndPos.y = -1;
				m_pSelStartPos = &m_RealSelStartPos;
				m_pSelEndPos = &m_RealSelEndPos;
				Update((WISP_RECT*)0);
			}
		}

		if (m_Style & 0x10000)
		{
			if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
			{
				ResetSelect();
				m_CaretPos.x = ROUNDPREV(pMsg->MsgMouseWndPT.x, m_ClientDC.m_pFont->m_Width);
				m_CaretPos.x /= m_ClientDC.m_pFont->m_Width;
				m_CaretPos.y = ROUNDPREV(pMsg->MsgMouseWndPT.y, m_ClientDC.m_pFont->m_Height);
				m_CaretPos.y /= m_ClientDC.m_pFont->m_Height;
				SetCaretPos(m_CaretPos.x * m_ClientDC.m_pFont->m_Width, m_CaretPos.y * m_ClientDC.m_pFont->m_Height);
				m_CaretPos.y += m_ScrPos.y;
				m_CaretPos.x += m_ScrPos.x;
				RecalcLayout();
				Update((WISP_RECT*)0);
			}

			switch (pMsg->KeyEvent.KeyType)
			{
			case VK_LEFT:
				ResetSelect();
				if (m_CaretPos.x <= 0)
					break;
				if (m_CaretPos.x <= m_ScrPos.x)
					SendScrollEvent(1, 1);// HorzScrollLineUp()
				--m_CaretPos.x;
				RecalcLayout();
				Update((WISP_RECT*)0);
				break;
			case VK_UP:
				ResetSelect();
				if (m_CaretPos.y <= 0)
					break;
				if (m_CaretPos.y <= m_ScrPos.y)
					SendScrollEvent(0, 1);// VertScrollLineUp()
				--m_CaretPos.y;
				RecalcLayout();
				Update((WISP_RECT*)0);
				break;
			case VK_RIGHT:
				ResetSelect();
				if (m_CaretPos.x + 1 >= m_MaxChars)
					break;
				if (m_CaretPos.x + 1 >= m_ScrPos.x + m_nCharsPerLine)
				SendScrollEvent(1, 0);// HorzScrollLineDown()
				++m_CaretPos.x;
				RecalcLayout();
				Update((WISP_RECT*)0);
				break;
			case VK_DOWN:
				ResetSelect();
				if (m_CaretPos.y + 1 >= m_MaxLines)
					break;
				if (m_CaretPos.y + 1 >= m_ScrPos.y + m_nLinesPerPage)
					SendScrollEvent(0, 0);// VertScrollLineDown()
				++m_CaretPos.y;
				RecalcLayout();
				Update((WISP_RECT*)0);
				break;
			default: ;
			}
		}
		return true;
	}
	bool CWispColorStrWnd::OnRecalcLayout(WISP_MSG *pMsg)
	{
		m_nCharsPerLine = (m_ClientRect.cx - 2 * m_Margin) / m_ClientDC.m_pFont->m_Width;
		MIN_LIMIT(m_nCharsPerLine, 0);

		m_nLinesPerPage = (m_ClientRect.cy - m_Margin) / m_ClientDC.m_pFont->m_Height;
		MIN_LIMIT(m_nLinesPerPage, 0);

		if (m_nLinesPerPage >= m_MaxLines && m_ScrPos.y)
			m_ScrPos.y = 0;

		CWispWnd::SetScrollBarInfo(0, m_ScrPos.y, m_MaxLines, m_nLinesPerPage, 0, 1);
		CWispWnd::SetScrollBarInfo(1, m_ScrPos.x, m_MaxChars, m_nCharsPerLine, 0, 1);
		UpdateCaretState();
		return true;
	}
	bool CWispColorStrWnd::OnMouseMove(WISP_MSG *pMsg)
	{
		if (!PtInRect(&m_ClientRect, &pMsg->MsgMouseWndPT))
			return true;
		
		if (!pMsg->bMsgLBTDown)
			return true;
		
		if ( !(m_Style & 0x20000))
			return true;
		
		if (m_RealSelStartPos.x < 0 || m_RealSelStartPos.y < 0)
			return true;
		
		CalcPonitStrPos(&pMsg->MsgMouseWndPT, &m_RealSelEndPos);

		if (m_RealSelEndPos.x < 0 || m_RealSelEndPos.y < 0)
			return true;
		
		if (m_RealSelStartPos.x < 0 || m_RealSelStartPos.y < 0) //??? DUP
			return true;
		
		m_bSelect = true;
		//UpdateSelect();
		if (m_RealSelStartPos.y <= m_RealSelEndPos.y &&
			(m_RealSelStartPos.y != m_RealSelEndPos.y ||
			m_RealSelStartPos.x <= m_RealSelEndPos.x))
		{
			m_pSelStartPos = &m_RealSelStartPos;
			m_pSelEndPos = &m_RealSelEndPos;
		} else
		{
			m_pSelStartPos = &m_RealSelEndPos;
			m_pSelEndPos = &m_RealSelStartPos;
		}
		Update((WISP_RECT*)0);
		return true;
	}

	WISP_EVENT_MAP_BEGIN(CWispColorStrWnd)
		WISP_EVENT_MAP(WISP_ID_COPY, OnEventCopy)
	WISP_EVENT_MAP_END

	bool CWispColorStrWnd::OnEventCopy(WISP_MSG *pMsg)
	{
		if (!m_bSelect)
			return false;
		unsigned long CSBuffer[WISP_TERMINAL_LINE_SIZE+1]; //257
		WCHAR szBuffer[WISP_TERMINAL_LINE_SIZE]; //258
		TWideString String;
		for (int ScrPosY = m_pSelStartPos->y; ScrPosY <= m_pSelEndPos->y; ++ScrPosY)
		{
			if (ScrPosY != m_pSelStartPos->y)
				String += WSTR("\r\n");
			CSBuffer[0] = 0;
			GetLineStr(ScrPosY, CSBuffer);
			TStrCpy(szBuffer, CSBuffer);

			if (m_pSelStartPos->y == m_pSelEndPos->y)
			{
				int Len = m_pSelEndPos->x - m_pSelStartPos->x + 1;
				if (Len > 0)
				{
					szBuffer[MIN(m_pSelStartPos->x + Len, WISP_TERMINAL_LINE_SIZE)] = 0; //???
					String += &szBuffer[m_pSelStartPos->x];
				}
			} else
			if (ScrPosY >= m_pSelEndPos->y)
			{
				if (ScrPosY == m_pSelEndPos->y)
				{
					szBuffer[MIN(m_pSelEndPos->x + 1, WISP_TERMINAL_LINE_SIZE)] = 0; //???
					String += szBuffer;
				}
			} else
			if (ScrPosY == m_pSelStartPos->y)
			{
				String += &szBuffer[m_pSelStartPos->x];
			} else
			{
				String += szBuffer;
			}
		}
		m_pWispBase->SetClipboard(String.operator const WCHAR*());
		m_bSelect = false;
		Update(&m_ClientRect);
		return true;
	}

	bool CWispColorStrWnd::InitWnd()
	{
		if (!CWispWnd::InitWnd())
			return false;
		m_ScrPos.y = 0;
		m_ScrPos.x = 0;
		m_CaretPos.y = 0;
		m_CaretPos.x = 0;
		return true;
	}

//	unsigned char CWispColorStrWnd::GetLineStr(int LineIndex, unsigned long *pColorStr) = 0;

	void CWispColorStrWnd::SetMaxLines(int nLine)
	{
		m_MaxLines = nLine;
	}
	void CWispColorStrWnd::SetMaxChars(int nChar)
	{
		m_MaxChars = nChar;
	}

	void CWispColorStrWnd::CalcPonitStrPos(WISP_POINT *pPoint, WISP_POINT *pStrPT)
	{
		pStrPT->x = ROUNDPREV((pPoint->x - m_Margin), m_ClientDC.m_pFont->m_Width);
		pStrPT->x /= m_ClientDC.m_pFont->m_Width;

		if ((pPoint->x - m_Margin) < m_ClientDC.m_pFont->m_Width/2 && pStrPT->x > 0)
			--pStrPT->x;

		pStrPT->y = ROUNDPREV((pPoint->y - m_Margin), m_ClientDC.m_pFont->m_Height);
		pStrPT->y /= m_ClientDC.m_pFont->m_Height;

		pStrPT->y += m_ScrPos.y;
		pStrPT->x += m_ScrPos.x;
	}

	void CWispColorStrWnd::UpdateCaretState()
	{
		if (m_CaretPos.x >= m_ScrPos.x &&  m_CaretPos.x < m_ScrPos.x + m_nCharsPerLine &&
		    m_CaretPos.y >= m_ScrPos.y &&  m_CaretPos.y < m_ScrPos.y + m_nLinesPerPage )
		{
			CWispWnd::SetCaretPos(
				m_Margin + m_ClientDC.m_pFont->m_Width * (m_CaretPos.x - m_ScrPos.x),
				m_Margin + m_ClientDC.m_pFont->m_Height * (m_CaretPos.y - m_ScrPos.y));
			CWispWnd::ShowCaret(true);
		} else
		{
			CWispWnd::ShowCaret(false);
		}
	}

	void CWispColorStrWnd::UpdateSelect()
	{
		if (m_RealSelStartPos.y <= m_RealSelEndPos.y &&
			(m_RealSelStartPos.y != m_RealSelEndPos.y || m_RealSelStartPos.x <= m_RealSelEndPos.x))
		{
			m_pSelStartPos = &m_RealSelStartPos;
			m_pSelEndPos = &m_RealSelEndPos;
		} else
		{
			m_pSelStartPos = &m_RealSelEndPos;
			m_pSelEndPos = &m_RealSelStartPos;
		}
		Update((WISP_RECT*)0);
	}

	void CWispColorStrWnd::ResetSelect()
	{
		if (m_bSelect)
		{
			m_bSelect = false;
			m_RealSelStartPos.y = -1;
			m_RealSelStartPos.x = -1;
			m_RealSelEndPos.y = -1;
			m_RealSelEndPos.x = -1;
		}
	}

	bool CWispColorStrWnd::IsSelectChar(int ScrX, int ScrY)
	{
		if (m_pSelEndPos->x == -1)
			return false;

		if (m_pSelEndPos->y == -1)
			return false;

		return ScrY >= m_pSelStartPos->y && ScrY <= m_pSelEndPos->y &&
			(ScrY != m_pSelStartPos->y || ScrX >= m_pSelStartPos->x) &&
			(ScrY != m_pSelEndPos->y || ScrX <= m_pSelEndPos->x);
	}


```

`source/Wisp/wispcolorstrwnd.hpp`:

```hpp

#ifndef _WISPCOLORSTRWND_HPP_
#define _WISPCOLORSTRWND_HPP_

#include "../Code/define.h"
#include "wispwnd.hpp"

#define WISP_TERMINAL_LINE_SIZE 256

struct CWispColorStrWnd : public CWispWnd
{
	CWispColorStrWnd();
	virtual ~CWispColorStrWnd();
	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnScrollEvent(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnRecalcLayout(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventCopy(WISP_MSG *pMsg);

	virtual bool InitWnd() override;
	virtual unsigned char GetLineStr(int LineIndex, unsigned long *pColorStr) = 0;
	virtual void SetMaxLines(int nLine);
	virtual void SetMaxChars(int nChar);
	void CalcPonitStrPos(WISP_POINT *pPoint, WISP_POINT *pStrPT);
	void UpdateCaretState();
	void UpdateSelect();
	void ResetSelect();

	WISP_POINT m_ScrPos;
	WISP_POINT m_CaretPos;
	WISP_POINT m_RealSelStartPos;
	WISP_POINT m_RealSelEndPos;
	WISP_POINT *m_pSelStartPos;
	WISP_POINT *m_pSelEndPos;
	bool m_bSelect;
	
	int m_Margin;
	int m_nCharsPerLine;
	int m_nLinesPerPage;
	int m_MaxChars;
	int m_MaxLines;

	bool IsSelectChar(int SrcX, int ScrY);
};


#endif
```

`source/Wisp/wispcombobox.cpp`:

```cpp

#include "wispcombobox.hpp"
#include "wispbase.hpp"

#define ID_BUTTON	0x40000000
#define ID_LIST		0x40000001

	CWispComboBox::CWispComboBox()
	{
		m_nCurSel = -1;
		m_CtrlType = WISP_CTRL_COMBO_BOX;
	}
	CWispComboBox::~CWispComboBox()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispComboBox)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP_ON_EVENT
		WISP_MSG_MAP_ON_COMMAND
	WISP_MSG_MAP_END(CWispEdit)

	bool CWispComboBox::OnCreate(WISP_MSG *pMsg)
	{
		CWispDIBList *pDIBList = gpCurWisp->m_DIBLib.GetDIBList("\\Skin\\Default\\VertInc.bmp", 16, 16, 0);
		m_Button.CreateEx(pDIBList, m_ClientRect.cx - pDIBList->m_DIBList->m_PaintRect.cx, 0, this, ID_BUTTON, 0x800000);
		m_ComboList.CreateWnd(0, 0,0,m_WindowRect.cx,pDIBList->m_DIBList->m_PaintRect.cy, 0, ID_LIST, 0x10000006, WISP_SH_HIDDEN);
		m_ComboList.SetOwner(this);
		m_ComboList.InsertColumn(0, -1, 0, 0, -1);
		return true;
	}
	bool CWispComboBox::OnDestroy(WISP_MSG *pMsg)
	{
		m_ComboList.Destroy();
		return true;
	}

	WISP_EVENT_MAP_BEGIN(CWispComboBox)
		WISP_EVENT_MAP(ID_BUTTON, OnEventButton)
		WISP_EVENT_MAP(ID_LIST, OnEventComboList)
	WISP_EVENT_MAP_END

	bool CWispComboBox::OnEventButton(WISP_MSG *pMsg)
	{
		if (m_ComboList.IsWindowShow())
		{
			m_ComboList.Show(WISP_SH_HIDDEN);
		} else
		{
			m_ComboList.MoveToScreen(m_ScrWindowRect.x, m_ScrWindowRect.y + m_ScrWindowRect.cy, false);
			int Count = m_ComboList.GetItemCount(0, true);
			m_ComboList.Resize(m_ComboList.m_WindowRect.cx, m_ComboList.m_nLineHeight * Count + m_BorderSize*2, false);
			m_ComboList.Show(WISP_SH_MINSIZE);
			m_ComboList.Top(true);
			m_ComboList.Focus();
		}
		return true;
	}
	bool CWispComboBox::OnEventComboList(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000203) //WISP_ID_LBUTTON
		{
			CListStringItem *pItem = (CListStringItem *)pMsg->Command.Param2;
			m_nCurSel = m_ComboList.GetPosition(pItem);
			SetWindowText(m_ComboList.GetItemContent(pItem, 0)->String.operator const WCHAR*());
			m_ComboList.Show(WISP_SH_HIDDEN);
			Focus();
			SendCommand(0x80000400, m_nCurSel, pItem); //WISP_ID_COMBO_SELECT
		}
		return true;
	}
	bool CWispComboBox::OnCmdComboList(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000202 && (CWispButton *)pMsg->Command.Param2 != &m_Button) //WISP_ID_CHILD_LOST_FOCUS
			m_ComboList.Show(WISP_SH_HIDDEN);
		return true;
	}

	WISP_CMD_MAP_BEGIN(CWispComboBox)
		WISP_CMD_MAP(ID_LIST, OnCmdComboList)
	WISP_CMD_MAP_END

	void CWispComboBox::SetCurSel(int nSelect)
	{
		CListStringItem *pItem = m_ComboList.GetItem(nSelect, 0);
		if (pItem)
		{
			SetWindowText(m_ComboList.GetItemContent(pItem, 0)->String.operator const WCHAR*());
			m_nCurSel = nSelect;
			Update((WISP_RECT*)0);
		}
	}
	int CWispComboBox::GetCurSel()
	{
		return m_nCurSel;
	}

```

`source/Wisp/wispcombobox.hpp`:

```hpp

#ifndef _WISPCOMBOBOX_HPP_
#define _WISPCOMBOBOX_HPP_

#include "../Code/define.h"
#include "wispedit.hpp"
#include "wisplist.hpp"
#include "wispbutton.hpp"

struct CWispComboBox : public CWispEdit
{
	unsigned int m_nCurSel;
	CWispList m_ComboList;
	CWispButton m_Button;

	CWispComboBox();
	virtual ~CWispComboBox();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventButton(WISP_MSG *pMsg);
	bool OnEventComboList(WISP_MSG *pMsg);
	bool OnCmdComboList(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);

	void SetCurSel(int nSelect);
	int GetCurSel();
};

#endif

```

`source/Wisp/wispconsolewnd.cpp`:

```cpp

#include "../Code/txtfile.hpp"
#include "wispconsolewnd.hpp"
#include "wispbase.hpp"

	CWispTerminalWnd::CWispTerminalWnd()
	{
		m_CtrlType = WISP_CTRL_TERMINAL_WND;
		m_pConsoleWnd = 0;
		m_Prefix = WSTR(">");
		m_MaxChars = m_Prefix.m_nLength;
		m_OutPutStr.Preallocate(2561, 0);
		m_pDelegate = 0;
		m_uFlags = 0;
	}
	CWispTerminalWnd::~CWispTerminalWnd()
	{
	}

	void CWispTerminalWnd::SetHistoryLines(int nLine)
	{
		if (nLine > 0 && nLine < 10000)
			m_LineList.Resize(nLine);
	}
	void CWispTerminalWnd::ClearScreen()
	{
		m_LineList.Clear();
		m_ScrPos.x = 0;
		m_ScrPos.y = 0;
		m_CaretPos.x = m_Prefix.m_nLength;
		m_CaretPos.y = 0;
		m_MaxChars = m_Prefix.m_nLength + 1;
		SetMaxLines(m_LineList.Count + 1);
		m_InputStr = m_Prefix;
		RecalcLayout();
		Update((WISP_RECT*)0);
	}
	
	void CWispTerminalWnd::OutPut(WCHAR ch)
	{
		if (ch)
		{
			m_OutPutStr += ch;
			if (m_OutPutStr.m_nLength < WISP_TERMINAL_LINE_SIZE) return;
		} else
		if (m_OutPutStr.m_nLength == 0)
		{
			if (m_OutPutStr.m_nLength < WISP_TERMINAL_LINE_SIZE) return;
		}
		OutPut(m_OutPutStr.operator const WCHAR*());
		m_OutPutStr.SetAt(0, 0);
	}
	void CWispTerminalWnd::OutPut(const WCHAR *szLine)
	{
		if (m_CtrlType == WISP_CTRL_CONSOLE_WND && static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd)
		{
			static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd->OutPut(szLine);
			return;
		}

		TColorString *pLine;
		int TotalLength;
		if (m_bNewLine)
		{
			TotalLength = WISP_TERMINAL_LINE_SIZE;
			pLine = m_LineList.Append(0);
			pLine->Empty();
			SetMaxLines(m_LineList.Count + 1);
			m_bNewLine = 0;
		} else
		{
			TotalLength = WISP_TERMINAL_LINE_SIZE - m_LineList[m_LineList.Count-1].m_nLength;
			pLine = &m_LineList[m_LineList.Count-1];
		}

		unsigned long szLineBuffer[WISP_TERMINAL_LINE_SIZE+1];
		const WCHAR *pNextLine;
		const WCHAR *pThisLine = szLine;
		while (pThisLine && pThisLine[0])
		{
			if (TotalLength==0)
			{
				TotalLength = WISP_TERMINAL_LINE_SIZE;
				pLine = m_LineList.Append(0);
				pLine->Empty();
				SetMaxLines(m_LineList.Count + 1);
			}

			WCHAR *pStr = TStrChr(pThisLine, 10);
			if (pStr)
			{
				int Length = pStr - pThisLine;
				MAX_LIMIT(Length, TotalLength);

				pNextLine = pStr + 1;
				TotalLength = 0;
				ColorStrNCpy(szLineBuffer, pThisLine, Length, m_TextColor, (char)0);
				if (!pNextLine[0])
				{
					m_bNewLine = 1;
					if (m_pDelegate)
					{
						if (m_uFlags & 1)
							szLineBuffer[Length++] = 13;
						szLineBuffer[Length++] = 10;
						szLineBuffer[Length] = 0;
					}
				}
				if (m_pDelegate)
					m_pDelegate->Write(szLineBuffer, 4 * Length);
				(*pLine) += szLineBuffer; //ADD
				MIN_LIMIT(m_MaxChars, pLine->m_nLength);
			} else
			{
				int Length = TStrLen(pThisLine);
				MAX_LIMIT(Length, TotalLength);

				pNextLine = &pThisLine[Length];
				ColorStrNCpy(szLineBuffer, pThisLine, Length, m_TextColor, (char)0);
				*pLine += szLineBuffer; //ADD
				if (m_pDelegate)
					m_pDelegate->Write(szLineBuffer, 4 * Length);
				MIN_LIMIT(m_MaxChars, pLine->m_nLength);
				TotalLength = WISP_TERMINAL_LINE_SIZE - pLine->m_nLength;
			}
			pThisLine = pNextLine;
		}

		m_CaretPos.y = m_LineList.Count;
		if (m_nLinesPerPage > 0)
			EnsureLineVisible();
		RecalcLayout();
	}

	void CWispTerminalWnd::OutPut(const unsigned long *szLine)
	{
		if (m_CtrlType == WISP_CTRL_CONSOLE_WND && static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd)
		{
			static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd->OutPut(szLine);
			return;
		}

		TColorString *pLine;
		int TotalLength;
		if (m_bNewLine)
		{
			TotalLength = WISP_TERMINAL_LINE_SIZE;
			pLine = m_LineList.Append(0);
			pLine->Empty();
			SetMaxLines(m_LineList.Count + 1);
			m_bNewLine = 0;
		} else
		{
			TotalLength = WISP_TERMINAL_LINE_SIZE - m_LineList[m_LineList.Count-1].m_nLength;
			pLine = &m_LineList[m_LineList.Count-1];
		}

		unsigned long szLineBuffer[WISP_TERMINAL_LINE_SIZE+1];
		const unsigned long *pNextLine;
		const unsigned long *pThisLine = szLine;
		while (pThisLine && pThisLine[0])
		{
			if (TotalLength==0)
			{
				TotalLength = WISP_TERMINAL_LINE_SIZE;
				pLine = m_LineList.Append(0);
				pLine->Empty();
				SetMaxLines(m_LineList.Count + 1);
			}

			const unsigned long *pStr = TStrChr(pThisLine, 10);
			if (pStr)
			{
				int Length = pStr - pThisLine;
				MAX_LIMIT(Length, TotalLength);

				pNextLine = pStr + 1;
				TotalLength = 0;
				TStrCpyLimit(szLineBuffer, pThisLine, Length);
				if (!pNextLine[0])
				{
					m_bNewLine = 1;
					if (m_pDelegate)
					{
						if (m_uFlags & 1)
							szLineBuffer[Length++] = 13;
						szLineBuffer[Length++] = 10;
						szLineBuffer[Length] = 0;
					}
				}
				if (m_pDelegate)
					m_pDelegate->Write(szLineBuffer, 4 * Length);
				(*pLine) += szLineBuffer; //ADD
				MIN_LIMIT(m_MaxChars, pLine->m_nLength);
			} else
			{
				int Length = TStrLen(pThisLine);
				MAX_LIMIT(Length, TotalLength);

				pNextLine = &pThisLine[Length];
				TStrCpyLimit(szLineBuffer, pThisLine, Length);
				*pLine += szLineBuffer; //ADD
				if (m_pDelegate)
					m_pDelegate->Write(szLineBuffer, 4 * Length);
				MIN_LIMIT(m_MaxChars, pLine->m_nLength);
				TotalLength = WISP_TERMINAL_LINE_SIZE - pLine->m_nLength;				
			}
			pThisLine = pNextLine;
		}
	}

	int CWispTerminalWnd::VPrintf(const WCHAR *format, va_list ParamList)
	{
		//EmitNumber
		//EmitString
		//Done

		const WCHAR *str;
		bool bIsShort;
		static const WCHAR *strSub = WSTR("-");//[2];
		static const WCHAR *strSpace = WSTR(" ");//[2];
		static const WCHAR *strZero = WSTR("0");//[2];
		int Precision;
		bool bLeftJustify;
		bool bIsLong;
		bool bMore;
		bool bPlusSign;
		WCHAR * savestr;
		WCHAR strbuf[36]; //??? increase
		bool bZeroPrefix;
		va_list Next;
		static const WCHAR *str0X = WSTR("0X");//[3];
		unsigned long val;
		static const WCHAR *strPlus = WSTR("+");//[2];
		int Flags;
		WCHAR cPad;
		static const WCHAR *strNULL = WSTR("");//[1];
		int len;
		__int64 val64;
		bool bBlankSign;
		bool bIsLonglong;
		int Length;
		int Width;
		int nPad;
		static const WCHAR *strError = WSTR("<Error>");//[8];
		int nLeadingZeros;
		const WCHAR * sPrefix;
		static const WCHAR *str0x = WSTR("0x"); //[3];

		Next = ParamList;

		SaveFontColor();

		Length = 0;
		while (*format)
		{
			if (*format != '%')
			{
				OutPut(*format);
				++Length;
				++format;
				continue;
			}

			Width = 0;
			Precision = -1;
			bLeftJustify = false;
			bPlusSign = false;
			bBlankSign = false;
			bZeroPrefix = false;
			bIsLonglong = false;
			Flags = 0;
			cPad = 0x20;
			sPrefix = strNULL;

			format++;

			bool bMore = true;
			while (bMore)
			{
				switch (*format)
				{
				case ' ': /*Width = 0;*/ bBlankSign = true; format++; Flags |= SPACE; break;
				case '#': bZeroPrefix = true; format++; Flags |= HEX_PREP; break;
				case '+': bPlusSign = true; format++; Flags |= PLUS; break;
				case '-': /*Width = 0;*/ bLeftJustify = true; format++; Flags |= LEFT; break;
				case '0': cPad = '0'; format++; Flags |= ZEROPAD; break;
				default: bMore = false; break;
				}
			}

			if (*format == '*')
			{
				Width = va_arg(Next, int);
				format++;
				if (Width < 0)
				{
					Width = 0;
					bLeftJustify = true;
					Flags |= LEFT;
				}
			} else
			if (IS_DIGIT(*format))
			{
				while (IS_DIGIT(*format))
					Width = 10 * Width + *format++ - '0';
			}

			//switch TODO
			if (*format == '.')
			{
				format++;
				Precision = 0;
				if (*format == '*')
				{
					Precision = va_arg(Next, int);
					format++;
				} else
				{
					while (IS_DIGIT(*format))
						Precision = 10 * Precision + *format++ - '0';
				}
				if (Precision < 0) Precision = 0;
			}

			if (format[0] == 'I')
			{
				if (format[1] == '6' && format[2] == '4')
				{
					format += 3;
					bIsLonglong = true;
					
				}
			} else
			if (*format == 'h') ++format;
			else
			if (*format == 'l') ++format;

			switch (*format++)
			{
			case '%':
				strbuf[0] = '%';
				str = strbuf;
				len = 1;
				goto EmitString;
		#ifdef HAS_FLOAT
			case 'E':
			case 'G':
			case 'e':
			case 'f':
			case 'g': {
				double valDouble = va_arg(Next, double);

//unsigned long NaN[2] = {0xffffffff, 0x7fffffff}
//A quiet NaN is represented by any bit pattern between X'7FF80000 00000000' and X'7FFFFFFF FFFFFFFF' 
//or between X'FFF80000 00000000' and X'FFFFFFFF FFFFFFFF'.
//https://stackoverflow.com/questions/2249110/how-do-i-make-a-portable-isnan-isinf-function/2249173

				if (_fpclass(valDouble) == _FPCLASS_QNAN || _fpclass(valDouble) == _FPCLASS_SNAN)
				{
					TStrCpy(strbuf, ("Nan"));
					str = strbuf;
					len = TStrLen(strbuf);
					goto EmitString;
				} else
				if (_fpclass(valDouble) == _FPCLASS_NINF)
				{
					TStrCpy(strbuf, ("-Inf"));
					str = strbuf;
					len = TStrLen(strbuf);
					goto EmitString;
				} else
				if (_fpclass(valDouble) == _FPCLASS_PINF)
				{
					TStrCpy(strbuf, ("+Inf"));
					str = strbuf;
					len = TStrLen(strbuf);
					goto EmitString;
				}
				//_FPCLASS_NN
				//_FPCLASS_ND
				//_FPCLASS_NZ
				//_FPCLASS_PZ
				//_FPCLASS_PD
				//_FPCLASS_PN
				else {

				WCHAR *fstr = flt(strbuf, valDouble, Width, Precision, *format, Flags | SIGN);
				*fstr = (WCHAR)0;
				str = strbuf;
				len = TStrLen(strbuf);
				goto EmitNumber; }}
		#endif
			case 'X':
				if (bZeroPrefix) sPrefix = str0x;
				if (bIsLonglong)
				{
					val64 = va_arg(Next, __int64);
					NumToStr(val64, strbuf, 16);
					if (!val64) sPrefix = strNULL;
				} else
				{
					val = va_arg(Next, unsigned long);
					NumToStr(val, strbuf, 16);
					if (!val) sPrefix = strNULL;
				}
				TStrUpr(strbuf);
				goto EmitNumber;
			case 'c':
				strbuf[0] = va_arg(Next, int); //WCHAR
				str = strbuf;
				len = 1;
				goto EmitString;
			case 'd':
			case 'i':
				Flags |= SIGN;
				if (bIsLonglong)
				{
					long long val64 = va_arg(Next, long long);
					NumToStr(val64, strbuf, 10);
				} else
				{
					long val = va_arg(Next, long);
					NumToStr(val, strbuf, 10);
				}
				if (strbuf[0] == '-') sPrefix = strSub;
				else
				if (bPlusSign) sPrefix = strPlus;
				else
				if (bBlankSign) sPrefix = strSpace;
				goto EmitNumber;
			case 'n':
				goto EmitNumber;
			case 'o':
				if (bIsLonglong)
				{
					//goto EmitLongLongNumber;
					unsigned long long val64 = va_arg(Next, unsigned long long);
					NumToStr(val64, strbuf, 10); //??? 8
				} else
				{
					if (bZeroPrefix) sPrefix = strZero;
					unsigned long val = va_arg(Next, unsigned long);
					NumToStr(val, strbuf, 8);
					if (!val) sPrefix = strNULL;
				}
				goto EmitNumber;
			case 'p':
			case 'x':
				if (bZeroPrefix) sPrefix = str0X;
				if (bIsLonglong)
				{
					unsigned long long val64 = va_arg(Next, unsigned long long);
					NumToStr(val64, strbuf, 16);
					if (!val64) sPrefix = strNULL;
				} else
				{
					unsigned long val = va_arg(Next, unsigned long);
					NumToStr(val, strbuf, 16);
					if (!val) sPrefix = strNULL;
				}
				TStrLwr(strbuf);
				goto EmitNumber;
			case 's':
				str = va_arg(Next, WCHAR*);
				len = TStrLen(str);
				if (Precision != -1 && Precision < len)
					len = Precision;
				goto EmitString;
			case 'u':
				if (bIsLonglong)
				{
//EmitLongLongNumber:
					unsigned long long val64 = va_arg(Next, unsigned long long);
					NumToStr(val64, strbuf, 10);
				} else
				{	
					unsigned long val = va_arg(Next, unsigned long);
					NumToStr(val, strbuf, 10);		
				}
EmitNumber:
				if (Precision == -1) Precision = 1;
				savestr = strbuf;
				if (strbuf[0] == '-')
					savestr = &strbuf[1];
				len = TStrLen(savestr);
				nLeadingZeros = Precision - len;
				if (nLeadingZeros < 0)
					nLeadingZeros = 0;
				nPad = Width - (TStrLen(sPrefix) + nLeadingZeros + len);
				if (nPad < 0) nPad = 0;
				if (cPad == '0')
				{
					while (*sPrefix)
					{
						OutPut((WCHAR)*sPrefix++);
						++Length;
					}
				}
				if (nPad && !bLeftJustify)
				{
					while (nPad--)
					{
						OutPut((WCHAR)cPad);
						++Length;
					}
					nPad = 0;
				}
				while (*sPrefix)
				{
					OutPut((WCHAR)*sPrefix++);
					++Length;
				}
				while (nLeadingZeros--)
				{
					OutPut((WCHAR)0x30);
					++Length;
				}
				while (len--)
				{
					OutPut(*savestr++);
					++Length;
				}
				if (nPad)
				{
					while (nPad--)
					{
						OutPut((WCHAR)0x20);
						++Length;
					}
				}
				break;
			case '<':{
				WCHAR *pStr = TStrChr(format, '>');
				if (pStr)
				{
					int Length = pStr-format;
					if (Length == 1 || Length == 2)
					{
						WCHAR ColorNum[4];
						unsigned char ColorIndex = 0;
						TStrCpyLimit(ColorNum, format, Length+1);
						format += Length+1;
						if (USHexStrToNum(ColorNum, &ColorIndex))
						{
							OutPut((WCHAR)0);
							SetFontColor(ColorIndex);
							strbuf[0] = 0;
							Precision = 0;
							goto EmitNumber;
						}
					}
				}}
			default:
				str = strError;
				len = TStrLen(str);
			EmitString:
				if (Width <= len)
					nPad = 0;
				else	nPad = Width - len; //abs()
				if (nPad && !bLeftJustify)
				{
					while (nPad--)
					{
						OutPut((WCHAR)cPad);
						++Length;
					}
				} 
				while (len--)
				{
					OutPut(*str++);
					++Length;
				}
				if (nPad && bLeftJustify)
				{
					while (nPad--)
					{
						OutPut((WCHAR)0x20);
						++Length;
					}
				}
				break;
			}
		}

		OutPut((WCHAR)0);
		RestoreFontColor();
		return Length;
	}

	void CWispTerminalWnd::Printf(const WCHAR *szLine, ...)
	{
		va_list va;
		va_start(va, szLine);
		int Len = VPrintf(szLine, va);
		va_end(va);

		CWispTerminalWnd *pTermWnd = this;
		if (m_CtrlType == WISP_CTRL_CONSOLE_WND && static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd)
			pTermWnd = static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd;

		pTermWnd->m_CaretPos.y = pTermWnd->m_LineList.Count;
		if (pTermWnd->m_nLinesPerPage > 0)
			pTermWnd->EnsureLineVisible();
		m_bSelect = false; //???
		pTermWnd->UpdateCaretState();
		pTermWnd->RecalcLayout();
		pTermWnd->Update((WISP_RECT*)0);
	}
	void CWispTerminalWnd::AttachConsole(CWispConsoleWnd *pConsoleWnd)
	{
		m_pConsoleWnd = pConsoleWnd;
	}
	void CWispTerminalWnd::SetFontColor(unsigned char ColorIndex)
	{
		if (m_CtrlType == WISP_CTRL_CONSOLE_WND && static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd)
			static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd->m_TextColor = ColorIndex;
		else	m_TextColor = ColorIndex;
	}
	void CWispTerminalWnd::SaveFontColor()
	{
		if (m_CtrlType == WISP_CTRL_CONSOLE_WND && static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd)
			static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd->m_OldTextColor = static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd->m_TextColor;
		else	m_OldTextColor = m_TextColor;
	}
	void CWispTerminalWnd::RestoreFontColor()
	{
		if (m_CtrlType == WISP_CTRL_CONSOLE_WND && static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd)
			static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd->m_TextColor = static_cast<CWispConsoleWnd*>(this)->m_pTerminalWnd->m_OldTextColor;
		else	m_TextColor = m_OldTextColor;
	}
	void CWispTerminalWnd::EnsureLineVisible()
	{
		m_ScrPos.y = m_LineList.Count - m_nLinesPerPage + 1;
		MIN_LIMIT(m_ScrPos.y, 0);
		SetScrollBarCurPos(0, m_ScrPos.y, 1);
	}
	void CWispTerminalWnd::EnsureInputVisible()
	{
		EnsureLineVisible();
		UpdateCaretState();
	}
	void CWispTerminalWnd::EnsureInputVisible2()
	{
		MAX_LIMIT(m_ScrPos.x, m_CaretPos.x);
		MIN_LIMIT(m_ScrPos.x, m_CaretPos.x - m_nCharsPerLine + 1); //???
		MIN_LIMIT(m_CaretPos.x, 0);

		UpdateCaretState();
		Update((WISP_RECT*)0);
	
	}

	WISP_MSG_MAP_BEGIN(CWispTerminalWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_CHAR, OnChar)
		WISP_MSG_MAP_ON_EVENT
		WISP_MSG_MAP_ON_COMMAND
	WISP_MSG_MAP_END(CWispColorStrWnd)

	bool CWispTerminalWnd::OnChar(WISP_MSG *pMsg)
	{
		if (m_CaretPos.x < WISP_TERMINAL_LINE_SIZE-1 ||
			pMsg->Char.Char == 8 ||
			pMsg->Char.Char == 10)
		{
			if (m_LineList.Count > m_nLinesPerPage &&
			    m_ScrPos.y < m_LineList.Count - m_nLinesPerPage + 1)
				EnsureInputVisible();

			if (pMsg->Char.Char == 8) //BACKSPACE
			{
				if (m_bSelect &&
					(m_pSelStartPos->y == m_LineList.Count) &&
					(m_pSelStartPos->x >= m_Prefix.m_nLength) &&
					(m_pSelEndPos->x > m_pSelStartPos->x) )
				{
					m_InputStr.Delete(m_pSelStartPos->x, m_pSelEndPos->x - m_pSelStartPos->x);
					m_bSelect = false;
					m_CaretPos.x = m_pSelStartPos->x;
					RecalcLayout();
					Update(&m_ClientRect);
				} else
				{
					if (m_CaretPos.x > m_Prefix.m_nLength)
					{
						m_CaretPos.x--;
						if (m_CaretPos.x < m_ScrPos.x)
						{
							m_ScrPos.x -= m_nCharsPerLine/2;
							MIN_LIMIT(m_ScrPos.x, 0);
						}

						if (m_CaretPos.x > m_InputStr.m_nLength)
						{
							m_InputStr.SetAt(m_CaretPos.x, 0);
						} else
						if (m_CaretPos.x >= m_Prefix.m_nLength)
						{
							m_InputStr.Delete(m_CaretPos.x, 1);
						}
						RecalcLayout();
						Update((WISP_RECT*)0);
					}
				}
				return true;
			}
			
			if (pMsg->Char.Char != 10) //\n
			{
				if (pMsg->Char.Char == 9) //TAB \v
				{
					for (map<TWideNoCaseString, COMMAND_ENTRY>::IT it = m_pConsoleWnd->CCmdParser::m_CmdMap.begin();
						it != m_pConsoleWnd->CCmdParser::m_CmdMap.end(); ++it)
					{
						if (!TStrNICmp(&m_InputStr.m_pData[m_Prefix.m_nLength],
								it->first.operator const WCHAR*(),
								m_InputStr.m_nLength - m_Prefix.m_nLength))
						{
							m_InputStr = m_Prefix + it->first;
							m_CaretPos.x = m_InputStr.m_nLength;
							break;
						}
					}
				} else
				{
					if (m_CaretPos.x >= m_InputStr.m_nLength)
						m_InputStr += pMsg->Char.Char;
					else	m_InputStr.Insert(m_CaretPos.x, pMsg->Char.Char);
	
					MIN_LIMIT(m_MaxChars, m_InputStr.m_nLength + 1);
					++m_CaretPos.x;
					if (m_CaretPos.x >= m_ScrPos.x + m_nCharsPerLine)
						++m_ScrPos.x;
				}
			}

			if (pMsg->Char.Char == 10) //\n
			{
				if (m_InputStr.m_nLength > m_Prefix.m_nLength)
				{
					m_CmdHistroy.Append(&m_InputStr);
					m_CurHisIndex = -1;
				}
				WISP_MSG Msg;
				Msg.hWnd = this;
				Msg.Msg = WISP_WM_COMMAND;

				Msg.Command.CmdMsg = 0x80000010; //WISP_ID_CMD
				Msg.Command.CmdID = -1;

				Msg.Command.Param2 = (void*)m_InputStr.operator const WCHAR*(); //???

				m_CommandStr = &m_InputStr.m_pData[m_Prefix.m_nLength];
				m_InputStr.SetAt(m_Prefix.m_nLength, 0);

				m_CaretPos.x = m_Prefix.m_nLength;
				m_pWispBase->SendMessage(&Msg);
				if (m_nLinesPerPage > 0)
					EnsureLineVisible();

				m_CaretPos.y = m_LineList.Count;
				m_ScrPos.x = 0;
			}
			RecalcLayout();
			Update((WISP_RECT*)0);
			
		}
		return true;
	}
	bool CWispTerminalWnd::OnCreate(WISP_MSG *pMsg)
	{
		EnableScrollBar(0, 1, 1);
		EnableScrollBar(1, 1, 1);
		m_InputStr.Empty();
		m_InputStr = m_Prefix;
		m_CurHisIndex = -1;
		m_CaretPos.x = m_ScrPos.x + m_InputStr.m_nLength;
		m_CaretPos.y = m_LineList.Count;
		RecalcLayout();
		UpdateCaretState();
		CreateCaret(WISP_DI_CARET);
		ShowCaret(true);
		BlinkCaret(300);
		m_Style |= 0x20000;
		SetBGColor(m_pWispBase->m_pWispDrawObj->m_crSystem[0]);
		m_TextColor = 1;
		m_bNewLine = true;
		return true;
	}
	bool CWispTerminalWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (!pMsg->KeyEvent.bKeyDown)
			return true;

		switch (pMsg->KeyEvent.KeyType)
		{
		case VK_END:
			m_CaretPos.x = m_InputStr.m_nLength;
			EnsureInputVisible2();
			RecalcLayout();
			Update(&m_ClientRect);
			break;
		case VK_HOME:
			m_CaretPos.x = m_Prefix.m_nLength;
			EnsureInputVisible2();
			RecalcLayout();
			Update(&m_ClientRect);
			break;
		case VK_LEFT:
			ResetSelect();
			if (m_CaretPos.x > m_Prefix.m_nLength)
			{
				m_CaretPos.x--;
				EnsureInputVisible2();
				RecalcLayout();
			}
			Update(&m_ClientRect);
			break;
		case VK_RIGHT:
			ResetSelect();
			if (m_CaretPos.x < m_InputStr.m_nLength)
			{
				m_CaretPos.x++;
				EnsureInputVisible2();
				RecalcLayout();
			}
			Update(&m_ClientRect);
			break;
		case VK_UP:
			if (m_CmdHistroy.Count && m_CurHisIndex < m_CmdHistroy.Count-1)
			{
				if (m_CurHisIndex >= 0)
					m_CurHisIndex++;
				else	m_CurHisIndex = 0;
				m_InputStr = m_CmdHistroy[m_CurHisIndex];
				m_CaretPos.x = m_InputStr.m_nLength;
				RecalcLayout();
				Update((WISP_RECT*)0);
			}
			break;
		case VK_DOWN:
			if (m_CmdHistroy.Count && m_CurHisIndex > 0)
			{
				m_CurHisIndex--;
				m_InputStr = m_CmdHistroy[m_CurHisIndex];
				m_CaretPos.x = m_InputStr.m_nLength;
				RecalcLayout();
				Update((WISP_RECT*)0);
			}
			break;
		case 0x40000058: //WISP_SK_CTRL + X
		case 0x2E: //??? .
			if (m_bSelect
				&& (m_pSelStartPos->y == m_LineList.Count)
				&& (m_pSelStartPos->x >= m_Prefix.m_nLength)
				&& (m_pSelEndPos->x >= m_pSelStartPos->x))
			{
				int selectlen = m_pSelEndPos->x - m_pSelStartPos->x + 1;
				if (pMsg->KeyEvent.KeyType == 0x40000058) //WISP_SK_CTRL + X
				{
					TWideString S; //Set ???
					S.Preallocate(selectlen + 1, 0);
					S.m_nLength = TStrCpyLimit(S.m_pData, &m_InputStr.m_pData[m_pSelStartPos->x], selectlen + 1);
					m_pWispBase->SetClipboard(S.operator const WCHAR*());
				}
				m_InputStr.Delete(m_pSelStartPos->x, selectlen);
				m_bSelect = false;
				m_CaretPos.x = m_pSelStartPos->x;
				RecalcLayout();
				Update(&m_ClientRect);
			} else
			{
				if (m_CaretPos.x < m_InputStr.m_nLength)
				{
					m_InputStr.Delete(m_CaretPos.x, 1);
					RecalcLayout();
					Update(&m_ClientRect);
				}
			}
			break;
		case 0x10000025: //WISP_SK_SHIFT + VK_LEFT
			if (m_bSelect)
			{
				if (m_CaretPos.x > m_Prefix.m_nLength && m_RealSelEndPos.y == m_LineList.Count)
				{
					m_RealSelEndPos.x = --m_CaretPos.x;
					UpdateCaretState();
					m_RealSelEndPos.y = m_RealSelStartPos.y;
				}
			} else
			if (m_CaretPos.x > m_Prefix.m_nLength)
			{
				m_RealSelStartPos.x = m_CaretPos.x;
				m_RealSelStartPos.y = m_CaretPos.y;

				m_RealSelEndPos.x = --m_RealSelStartPos.x;
				m_RealSelEndPos.y = m_RealSelStartPos.y;

				m_CaretPos.x = m_RealSelEndPos.x;
				m_bSelect = true;
				UpdateCaretState();
			}
			//UpdateSelect();
			if (m_RealSelEndPos.y >= m_RealSelStartPos.y &&
				(m_RealSelEndPos.y != m_RealSelStartPos.y ||
				m_RealSelEndPos.x >= m_RealSelStartPos.x))
			{
				m_pSelStartPos = &m_RealSelStartPos;
				m_pSelEndPos = &m_RealSelEndPos;
			} else
			{
				m_pSelStartPos = &m_RealSelEndPos;
				m_pSelEndPos = &m_RealSelStartPos;
			}
			Update((WISP_RECT*)0);
			break;
		case 0x10000027: //WISP_SK_SHIFT + VK_RIGHT
			if (m_bSelect)
			{
				if (m_CaretPos.x < m_InputStr.m_nLength && m_RealSelEndPos.y == m_LineList.Count)
				{
					m_RealSelEndPos.x = m_CaretPos.x++;
					UpdateCaretState();
					m_RealSelEndPos.y = m_RealSelStartPos.y;
				}
			} else
			if (m_CaretPos.x < m_InputStr.m_nLength)
			{
				m_RealSelStartPos.x = m_CaretPos.x;
				m_RealSelStartPos.y = m_CaretPos.y;

				m_RealSelEndPos.x = m_CaretPos.x++;
				m_RealSelEndPos.y = m_CaretPos.y;
				m_bSelect = true;
				UpdateCaretState();
			}
			//UpdateSelect();
			if (m_RealSelEndPos.y >= m_RealSelStartPos.y &&
				(m_RealSelEndPos.y != m_RealSelStartPos.y ||
				m_RealSelEndPos.x >= m_RealSelStartPos.x))
			{
				m_pSelStartPos = &m_RealSelStartPos;
				m_pSelEndPos = &m_RealSelEndPos;
			} else
			{
				m_pSelStartPos = &m_RealSelEndPos;
				m_pSelEndPos = &m_RealSelStartPos;
			}
			Update((WISP_RECT*)0);
			break;
		case VK_LBUTTON:
			if ((pMsg->m_LogicMousePosWnd.y - m_Margin)/m_ClientDC.m_pFont->m_Height == m_LineList.Count - m_ScrPos.y)
			{
				int PosX = m_ScrPos.x + (pMsg->m_LogicMousePosWnd.x - m_Margin)/m_ClientDC.m_pFont->m_Width;
				if (PosX >= m_Prefix.m_nLength && PosX <= m_InputStr.m_nLength)
				{
					m_CaretPos.x = PosX;
					RecalcLayout();
					Update(&m_ClientRect);
				}
			}
			break;
		}
		return true;
	}
	bool CWispTerminalWnd::OnDestroy(WISP_MSG *pMsg)
	{
		return true;//???
	}

	WISP_CMD_MAP_BEGIN(CWispTerminalWnd)
		WISP_CMD_MAP_DEFAULT(OnCmdGetCmd)
	WISP_CMD_MAP_END

	bool CWispTerminalWnd::OnCmdGetCmd(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000010) //WISP_ID_CMD
		{
			++m_LockUpdateRef;
			Printf(WSTR("%s%s\n"), m_InputStr.operator const WCHAR*(), m_CommandStr.operator const WCHAR*());
			if (!m_pConsoleWnd)
			{
				Printf(WSTR("Error : inside error!\n"));
				--m_LockUpdateRef;
				return false;
			}

			if (m_CommandStr.m_nLength)
			{
				if (m_CtrlType == WISP_CTRL_TERMINAL_WND)
					m_pConsoleWnd->m_pTerminalWnd = this;

				if (m_pConsoleWnd->OnAcceptingCmd(m_CommandStr.operator const WCHAR*()))
				{
					if (!m_pConsoleWnd->CCmdParser::ParseCmd(m_CommandStr.operator const WCHAR*(), 0))
						Printf(WSTR("Error : unknown command !\n"));
					OnAcceptCmd(m_CommandStr.operator const WCHAR*());
				}
				if (m_CtrlType == WISP_CTRL_TERMINAL_WND)
					m_pConsoleWnd->m_pTerminalWnd = 0;
			}
			--m_LockUpdateRef;
		}
		return true;
	}

	WISP_EVENT_MAP_BEGIN(CWispTerminalWnd)
		WISP_EVENT_MAP(WISP_ID_PASTE, OnEventPaste)
	WISP_EVENT_MAP_END

	bool CWispTerminalWnd::OnEventPaste(WISP_MSG *pMsg)
	{
		m_pWispBase->GetClipboard(); //TODO
		if (!m_pWispBase->m_ClipString.IsEmpty())
		{
			m_InputStr.Insert(m_CaretPos.x, m_pWispBase->m_ClipString.operator const WCHAR*());

			if (m_InputStr.m_nLength >= WISP_TERMINAL_LINE_SIZE)
				m_InputStr.SetAt(WISP_TERMINAL_LINE_SIZE, 0);

			m_CaretPos.x += m_pWispBase->m_ClipString.m_nLength;

			MAX_LIMIT(m_CaretPos.x, m_InputStr.m_nLength);

			UpdateCaretState();
			Update((WISP_RECT*)0);
		}
		return true;
	}
	unsigned char CWispTerminalWnd::GetLineStr(int LineIndex, unsigned long *pColorStr)
	{
		if (LineIndex <= m_LineList.Count) //??? < +1
		{
			if (LineIndex < m_LineList.Count)
				TStrCpy(pColorStr, m_LineList[LineIndex].operator const unsigned long*());
			else	ColorStrCpy(pColorStr, m_InputStr.operator const WCHAR*(), m_TextColor, (unsigned char)0);
		}
		return 0;
	}

#include "../Code/fileio.hpp"

	bool CWispTerminalWnd::SaveHistory(const char *FileName)
	{
		CImageFileStream File;
		gpFileIO->DeleteFile(FileName);

		if (!File.Create(FileName, 0))
			return false;

		for (int Line = 0; Line < m_LineList.Count; ++Line)
		{
			WCHAR UniString[258];
			TStrCpyLimit(UniString, m_LineList[Line].operator const unsigned long*(), 258);
			char AnsiString[260];
			int Len = UnicodeToAnsi(UniString, AnsiString, 258); //??? Rtl
			TStrCpy(&AnsiString[Len], "\r\n");
			File.Write(AnsiString, Len + 2);
		}
		File.Close();
		return true;
	}
///
	CWispConsoleWnd::CWispConsoleWnd()
	{
		m_pTerminalWnd = 0;
		m_CtrlType = WISP_CTRL_CONSOLE_WND;
		m_pConsoleWnd = this;
	}
	CWispConsoleWnd::~CWispConsoleWnd()
	{
	}

	void CWispConsoleWnd::OnBeginCmd(const WCHAR *szCmd)
	{
		//EMPTY
	}
	void CWispConsoleWnd::OnCmd(const WCHAR *szCmd)
	{
		//EMPTY
	}
	void CWispConsoleWnd::OnEndCmd(const WCHAR *szCmd)
	{
		//EMPTY
	}

	void CWispConsoleWnd::PrintString(const WCHAR *pString)
	{
		Printf(pString);
	}

	int CWispConsoleWnd::Cls(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		pTermWnd->ClearScreen();
		return 0;
	}
	int CWispConsoleWnd::WispVer(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		pTermWnd->Printf(WSTR("Wisp GUI System\n"));
		WCHAR szDate[64];
		WCHAR szTime[64];
		TStrCpy(szDate, "" __DATE__ "");
		TStrCpy(szTime, "" __TIME__ "");
		pTermWnd->Printf(WSTR("Build Time : %s  %s\n"), szDate, szTime);
		return 0;
	}
	int CWispConsoleWnd::HL(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		if (argc != 2)
		{
			pTermWnd->Printf(WSTR("Usage : hl <histroy lines count>\n"));
			pTermWnd->Printf(WSTR("Current count of histroy lines = %<E>%d (dec)\n"), pTermWnd->m_LineList.Size);
			return -1;
		}

		unsigned int line;
		if (!USDecStrToNum(argv[1], &line))
		{
			pTermWnd->Printf(WSTR("Error : %s is Invalid !\n"), argv[1]);
			return -1;
		}

		if (line < 1 || line > 10000)
		{
			pTermWnd->Printf(WSTR("Error : please input from 1 to 1000\n"));
			return -1;
		}
		pTermWnd->SetHistoryLines(line);
		return 0;
	}
	int CWispConsoleWnd::HCC(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		if (argc == 1)
		{
			pTermWnd->Printf(WSTR("command histroy count = %d\n"), pTermWnd->m_CmdHistroy.Count);
			return 0;
		}
		unsigned int count;
		if (argc > 2 || !USDecStrToNum(argv[1], &count))
		{
			pTermWnd->Printf(WSTR("Usage : hcc command_histroy_count\n"));
			return 1;		
		}
		pTermWnd->m_CmdHistroy.Resize(count);
		return 0;
	}
	int CWispConsoleWnd::HC(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		//???++
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		if (argc == 1)
		{
			pConWnd->Printf(WSTR("Usage : hc sz_command_line\n"));
			return 1;
		}
		const TWideString str = pConWnd->m_Prefix + &szCmd[argv[1] - argv[0]];
		pTermWnd->m_CmdHistroy.Append(&str);
		return 0;
	}
	int CWispConsoleWnd::Color(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		unsigned char Color;
		if (argc != 2 || !USHexStrToNum(argv[1], &Color))
		{
			pTermWnd->Printf(WSTR("Usage : Color Color_Index[0 - FF]\n"));
			pConWnd->DisplayColor(pTermWnd); //???
		} else
		{
			pTermWnd->SetFontColor(Color);
		}
		return 0;
	}
	int CWispConsoleWnd::BKColor(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		unsigned char Color;
		if (argc != 2 || !USHexStrToNum(argv[1], &Color))
		{
			pTermWnd->Printf(WSTR("Usage : BKColor Color_Index[0 - FF]\n"));
			pConWnd->DisplayColor(pTermWnd); //???
		} else
		{
			pTermWnd->SetBGColor(pTermWnd->m_pWispBase->m_pWispDrawObj->m_crSystem[Color]);
		}
		return 0;
	}
	int CWispConsoleWnd::Help(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		WCHAR szMaskCmd[128]; //???
		szMaskCmd[0] = 0;

		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		if (argc < 2)
		{
			TStrCpy(szMaskCmd, "*");
		} else
		{
			TStrCpy(szMaskCmd, argv[1]);
			TStrLwr(szMaskCmd);
			if (!TStrChr(szMaskCmd, '*') && !TStrChr(szMaskCmd, '?'))
			{
				map<TWideNoCaseString,COMMAND_ENTRY>::IT It = pConWnd->CCmdParser::m_CmdMap.find(szMaskCmd);
				//if (It == pConWnd->CCmdParser::m_CmdMap.end())
				if (!It)
				{
					pTermWnd->Printf(WSTR("Invalid Command\n"));
				} else
				{
					if (It->second.pUsage)
						pTermWnd->Printf(It->second.pUsage);
					else
					if (It->second.pComment)
						pTermWnd->Printf(WSTR("%s %s\n"), It->first.operator const WCHAR*(), It->second.pComment);
				}
				return 0;
			}
		}

		for (map<TWideNoCaseString,COMMAND_ENTRY>::IT it = pConWnd->CCmdParser::m_CmdMap.begin();
			it != pConWnd->CCmdParser::m_CmdMap.end(); ++it)
		{
			if (TIMultiMatchWithPattern(szMaskCmd, it->first.operator const WCHAR*()))
			{
				if (it->second.pComment)
					pTermWnd->Printf(WSTR("%<B>%-12s    %<F>%s\n"), it->first.operator const WCHAR*(), it->second.pComment);
			}
		}
		return 0;
	}
	int CWispConsoleWnd::Bat(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		CTXTFile BatFile;
		if (argc < 2)
		{
			pTermWnd->Printf(WSTR("Usage:%<B>bat [-s|b] %<1>bat_file_name \n"));
			pTermWnd->Printf(WSTR("s : silence mode\n"));
			pTermWnd->Printf(WSTR("b : break if command fail\n"));
			return 1;
		}
		char FileName[MAX_FN_LEN];
		bool silence = false;
		bool fail = false;
		if (argv[1][0] == (WCHAR)'-')
		{
			silence = TStrIChr(argv[1], (WCHAR)'s') != 0;
			fail = TStrIChr(argv[1], (WCHAR)'b') != 0;
			if (argc < 3)
			{
				pTermWnd->Printf(WSTR("Usage:%<B>bat [-s|b] %<1>bat_file_name \n"));
				pTermWnd->Printf(WSTR("s : silence mode\n"));
				pTermWnd->Printf(WSTR("b : break if command fail\n"));
				return 1;
			}
			UnicodeToAnsi(&szCmd[argv[2] - argv[0]], FileName, MAX_FN_LEN); //??? Rtl
		} else
		{
			UnicodeToAnsi(&szCmd[argv[1] - argv[0]], FileName, MAX_FN_LEN); //??? Rtl
		}

		if (!BatFile.Open(FileName, 0))
		{
			if (!silence)
				pTermWnd->Printf(WSTR("%<3>Error : %<B>Fail to open file %<F>%s %<1>!\n"), argv[1]);
			return 1;
		}
		WCHAR szCmds[258];
		pConWnd->OnBeginCmd(szCmd);
		unsigned long Result = 0;
		TListIter<char*> It = BatFile.m_StrList.Begin();
		while (It != BatFile.m_StrList.End())
		{
			AnsiToUnicode(*It, szCmds, 257); //MAX_SIZE //??? Rtl
			pConWnd->OnCmd(szCmds);
			if (!pConWnd->CCmdParser::ParseCmd(szCmds, &Result) && fail)
				break;
			if (fail && Result)
				break;
			++It;
		}
		BatFile.Close();
		pConWnd->OnEndCmd(szCmd);
		return Result;
	}

	void SetHelp(const WCHAR *Name, int Type, void *Value, CWispTerminalWnd *pTermWnd)
	{
		switch (Type)
		{
		case SETOPTION_INVALID: pTermWnd->Printf(WSTR("Error : Invalid value name !\n")); break;
		case SETOPTION_STR:  pTermWnd->Printf(WSTR("%<B>%-12s %<1>= %<F>\"%s\"%<1>\n"), Name, (WCHAR*)Value); break;
		case SETOPTION_INT:  pTermWnd->Printf(WSTR("%<B>%-12s %<1>= %<4>%d %<1>(dec)\n"), Name, *(int*)Value); break;
		case SETOPTION_UINT: pTermWnd->Printf(WSTR("%<B>%-12s %<1>= %<4>%u %<1>(dec)\n"), Name, *(unsigned int*)Value); break;
		default:;
		}
	}

	int CWispConsoleWnd::Set(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		if (argc == 1)
		{
			for (map<TWideNoCaseString, SETOPTION>::IT it = pConWnd->m_Options.begin();
				it != pConWnd->m_Options.end(); ++it)
			{
				SetHelp(it->first.operator const WCHAR*(), it->second.Type, (void*)it->second.Value, pTermWnd);
			}
			return 1;
		} else
		if (argc == 2)
		{
			void *Value;
			int Size;
			int Type = pConWnd->m_Options.Get(argv[1], &Value, &Size);
			SetHelp(argv[1], Type, Value, pTermWnd);
			return 1;
		}

		void *Value;
		int Size;
		int Type = pConWnd->m_Options.Get(argv[1], &Value, &Size);
		switch (Type)
		{
		case SETOPTION_INVALID: {
			pTermWnd->Printf(WSTR("Error : Invalid value name!\n"));
			return 1;
			} break;
		case SETOPTION_STR:
			TStrCpyLimit((WCHAR*)Value, argv[2], Size);
			break;
		case SETOPTION_INT:
			if (!USDecStrToNum(argv[2], (int*)Value))
			{
				pTermWnd->Printf(WSTR("Error : Invalid value!\n"));
				return 1;
			}
			break;
		case SETOPTION_UINT:
			if (!USDecStrToNum(argv[2], (unsigned int*)Value))
			{
				pTermWnd->Printf(WSTR("Error : Invalid value!\n"));
				return 1;
			}
			break;
		default:
			if (Value == 0)
			{
				pTermWnd->Printf(WSTR("Error : Invalid value!\n"));
				return 1;
			}
			break;
		}
		return 0;
	}
	int CWispConsoleWnd::Rem(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		return 0; //!
	}
	int CWispConsoleWnd::Echo(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		CWispTerminalWnd *pTermWnd = (CWispTerminalWnd *)pConWnd;
		if (pConWnd->m_pTerminalWnd)
			pTermWnd = (CWispTerminalWnd *)pConWnd->m_pTerminalWnd;

		pTermWnd->Printf(&szCmd[TStrLen(argv[0])+1]);
		pTermWnd->OutPut(WSTR("\n"));
		return 0;
	}

	int CWispConsoleWnd::HeapInfo(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd)
	{
		//TODO
		return 0;
	}

	void CWispConsoleWnd::DisplayColor(CWispTerminalWnd *pTermWnd)
	{
		pTermWnd->Printf(WSTR("%<0>0 ------- Black\n"));
		pTermWnd->Printf(WSTR("%<1>1 ------- White\n"));
		pTermWnd->Printf(WSTR("%<2>2 ------- Red\n"));
		pTermWnd->Printf(WSTR("%<3>3 ------- Light Red\n"));
		pTermWnd->Printf(WSTR("%<4>4 ------- Green\n"));
		pTermWnd->Printf(WSTR("%<5>5 ------- Light Green\n"));
		pTermWnd->Printf(WSTR("%<6>6 ------- Blue\n"));
		pTermWnd->Printf(WSTR("%<7>7 ------- Light Blue\n"));
		pTermWnd->Printf(WSTR("%<8>8 ------- Brown\n"));
		pTermWnd->Printf(WSTR("%<9>9 ------- Light Brown\n"));
		pTermWnd->Printf(WSTR("%<A>A ------- Cyan\n"));
		pTermWnd->Printf(WSTR("%<B>B ------- Light Cyan\n"));
		pTermWnd->Printf(WSTR("%<C>C ------- Gray\n"));
		pTermWnd->Printf(WSTR("%<D>D ------- Light Gray\n"));
		pTermWnd->Printf(WSTR("%<E>E ------- Yellow\n"));
		pTermWnd->Printf(WSTR("%<F>F ------- Light Yellow\n"));
	}

	WISP_MSG_MAP_BEGIN(CWispConsoleWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
	WISP_MSG_MAP_END(CWispTerminalWnd)

	bool CWispConsoleWnd::OnCreate(WISP_MSG *pMsg)
	{                                   
		CCmdParser::InsertCmd(WSTR("cls"), (CMDPROC)CWispConsoleWnd::Cls, this, WSTR("Clear screen"), 0);
		CCmdParser::InsertCmd(WSTR("wispver"), (CMDPROC)CWispConsoleWnd::WispVer, this, WSTR("Display WISP version"), 0);
		CCmdParser::InsertCmd(WSTR("hl"), (CMDPROC)CWispConsoleWnd::HL, this, WSTR("Set count of histroy lines"), 0);
		CCmdParser::InsertCmd(WSTR("hcc"), (CMDPROC)CWispConsoleWnd::HCC, this, WSTR("Set count of command histroy"), 0);
		CCmdParser::InsertCmd(WSTR("hc"), (CMDPROC)CWispConsoleWnd::HC, this, WSTR("add a command string into histroy"), 0);
		CCmdParser::InsertCmd(WSTR("Color"), (CMDPROC)CWispConsoleWnd::Color, this, WSTR("Set default font color"), 0);
		CCmdParser::InsertCmd(WSTR("BKColor"), (CMDPROC)CWispConsoleWnd::BKColor, this, WSTR("Set default font color"), 0);
		CCmdParser::InsertCmd(WSTR("help"), (CMDPROC)CWispConsoleWnd::Help, this, WSTR("Display this help information"), 0);
		CCmdParser::InsertCmd(WSTR("h"), (CMDPROC)CWispConsoleWnd::Help, this, WSTR("Display this help information"), 0);
		CCmdParser::InsertCmd(WSTR("bat"), (CMDPROC)CWispConsoleWnd::Bat, this, WSTR("Execute bat command file"), 0);
		CCmdParser::InsertCmd(WSTR("set"), (CMDPROC)CWispConsoleWnd::Set, this, WSTR("Set environment value"), 0);
		CCmdParser::InsertCmd(WSTR("#"), (CMDPROC)CWispConsoleWnd::Rem, this, WSTR("Do nothing"), 0);
		CCmdParser::InsertCmd(WSTR("@"), (CMDPROC)CWispConsoleWnd::Echo, this, WSTR("Print string"), 0);

		CCmdParser::InsertCmd(WSTR("wispheapinfo"), (CMDPROC)CWispConsoleWnd::HeapInfo, this, WSTR("Show heap debug information"), 0);
		return true;
	}
	bool CWispConsoleWnd::OnDestroy(WISP_MSG *pMsg)
	{
		CCmdParser::Reset();
		return true;
	}

```

`source/Wisp/wispconsolewnd.hpp`:

```hpp

#ifndef _WISPCONSOLEWND_HPP_
#define _WISPCONSOLEWND_HPP_

#include "../Code/define.h"
#include "../Code/alt/altqueue.hpp"
#include "../Code/alt/altstack.hpp"
#include "../Code/cmdparser.hpp"
#include "../Code/options.hpp"
#include "wispcolorstrwnd.hpp"

#define WISP_MAX_CMD_SIZE 257

struct CWispTermnialDelegate
{
	virtual void Write(void *Buffer, int Length) = 0;
};

struct CWispConsoleWnd;

struct CWispTerminalWnd : public CWispColorStrWnd
{
	CWispTerminalWnd();
	virtual ~CWispTerminalWnd();

	void SetHistoryLines(int nLine);
	void ClearScreen();
	void OutPut(WCHAR ch);
	void OutPut(const WCHAR *szLine);
	void OutPut(const unsigned long *szLine);
	int VPrintf(const WCHAR *format, va_list ParamList);
	void Printf(const WCHAR *szLine, ...);
	void AttachConsole(CWispConsoleWnd* pConsoleWnd);
	void SetFontColor(unsigned char ColorIndex);
	void SaveFontColor();
	void RestoreFontColor();
	void EnsureLineVisible();
	void EnsureInputVisible();
	void EnsureInputVisible2();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnChar(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdGetCmd(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventPaste(WISP_MSG *pMsg);
	virtual unsigned char GetLineStr(int LineIndex, unsigned long *pColorStr) override;

	bool SaveHistory(const char *FileName);

	virtual bool OnAcceptingCmd(const WCHAR *szCmd) { return true; }
	virtual void OnAcceptCmd(const WCHAR *szCmd) { }

	CWispConsoleWnd *m_pConsoleWnd;
	TQueue<TColorString,64> m_LineList;
	TStack<TWideString,64> m_CmdHistroy;
	TWideString m_CommandStr;
	TWideString m_InputStr;
	TWideString m_Prefix;
	TWideString m_OutPutStr;
	unsigned int m_uFlags;
	int m_CurHisIndex;
	unsigned char m_TextColor;
	unsigned char m_OldTextColor;
	bool m_bNewLine;
	CWispTermnialDelegate *m_pDelegate;
};

struct CWispConsoleWnd : public CWispTerminalWnd, public CCmdParser
{
	COptions m_Options;
	CWispTerminalWnd *m_pTerminalWnd;
	
	CWispConsoleWnd();
	virtual ~CWispConsoleWnd();

	virtual void OnBeginCmd(const WCHAR *szCmd);// {}
	virtual void OnCmd(const WCHAR *szCmd);// {}
	virtual void OnEndCmd(const WCHAR *szCmd);// {}

	virtual void PrintString(const WCHAR *pString) override;

	static int Cls(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int WispVer(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int HL(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int HCC(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int HC(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int Color(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int BKColor(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int Help(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int Bat(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int Set(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int Rem(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);
	static int Echo(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);

	static int HeapInfo(int argc, const WCHAR **argv, const WCHAR *szCmd, CWispConsoleWnd *pConWnd);

	void DisplayColor(CWispTerminalWnd *pTermWnd);

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
};

#endif

```

`source/Wisp/wispdc.cpp`:

```cpp

#include "wispdc.hpp"
#include "wispbase.hpp"
#include "wispbasewnd.hpp"
#include "wispwnd.hpp"

	CWispDC::CWispDC()
	{
		m_pWispWnd = 0;
		m_pRect = 0;
		m_pClipRect = 0;
		m_TabAlign = 4;
		m_pColor = 0;
	}

	CWispDC::~CWispDC()
	{
		Destroy();
	}

	void CWispDC::Destroy()
	{
		//
	}

	void CWispDC::SetFontAndColor()
	{
		m_pWispBase = gpCurWisp;
		m_TextStyle = 0;
		m_TextColor = m_pWispBase->m_pWispDrawObj->m_crSystem[0];
		m_TextShadowColor = m_pWispBase->m_pWispDrawObj->m_crSystem[31];
		m_TextBKColor = m_pWispBase->m_pWispDrawObj->m_crSystem[1];
		m_pFont = &m_pWispBase->m_FontList[m_pWispBase->m_FontIndex];

		if (m_pWispWnd && m_pWispWnd->m_ParentWnd &&
			m_pWispWnd->m_ParentWnd->m_CtrlType == WISP_CTRL_FORM)
			SetTextType(WISP_FONT_6X12);
	}

	bool CWispDC::Create(WISP_FRAME_BUFFER_INFO *pFrameBuffer, WISP_RECT *pRect)
	{
		m_pWispWnd = 0;
		m_pWispBase = gpCurWisp;
		m_pFrameBuffer = pFrameBuffer;
		m_pRect = pRect;
		SetFontAndColor();
		return true;
	}

	CWispDC *CWispDC::CreateNull(WISP_FRAME_BUFFER_INFO *pFrameBuffer, WISP_RECT *pRect)
	{
		Create(pFrameBuffer, pRect);
		m_pClipRect = 0;
		return this;
	}

	bool CWispDC::Create(CWispDIB *pDIB)
	{
		return Create(&pDIB->m_PixelBuf, &pDIB->m_PaintRect);
	}

	void CWispDC::SetTextType(unsigned int FontIndex)
	{
		m_pFont = &m_pWispBase->m_FontList[FontIndex];
	}

	bool CWispDC::Create(CWispBaseWnd *pWispWnd, WISP_RECT *pRect)
	{
		m_pWispBase = pWispWnd->m_pWispBase;
		m_pWispWnd = pWispWnd;
		m_pRect = pRect;
		m_pFrameBuffer = &m_pWispBase->m_FrameBufferInfo;
		SetFontAndColor();
		return true;
	}

	bool CWispDC::IsRectVisible(WISP_RECT *pRect)
	{
		return !IsInvalidRect(pRect);
	}

	bool CWispDC::ClipDCRect(WISP_RECT *pRect)
	{
		if (m_pClipRect && !ClipRect(pRect, m_pClipRect))
			return false;

		if (!m_pWispWnd)
			return ClipRect(pRect, m_pRect);

		if (!m_pWispWnd->m_pUpdateRC)
			return false;

		WISP_RECT rc = *m_pWispWnd->m_pUpdateRC;

		rc.x += m_pWispWnd->m_ScrWindowRect.x;
		rc.y += m_pWispWnd->m_ScrWindowRect.y;

		if (!ClipRect(pRect, &rc) ||
		    !ClipRect(pRect, m_pRect))
			return false;

		if (m_pWispWnd == m_pWispBase->m_pRootWnd)
			return true;

		CWispBaseWnd *pWnd = m_pWispWnd->m_ParentWnd;

		if (!pWnd)
		{
		//	CWispBaseWnd *
			pWnd = m_pWispBase->m_pRootWnd;
		//	if (!pWnd)
		//		return true;

		//	if (!ClipRect(pRect, pWnd->m_Style & 0x8000 ? 
		//			&((CWispWnd*)pWnd)->m_ScrClientRect :
		//			&pWnd->m_ScrWindowRect))
		//		return false;
		//	return true;
		}

		while (pWnd)
		{
			if (!ClipRect(pRect, pWnd->m_Style & 0x8000 ? 
				&((CWispWnd*)pWnd)->m_ScrClientRect :
				&pWnd->m_ScrWindowRect))
				return false;
			//if (!pWnd) break;
			pWnd = pWnd->m_ParentWnd;
		}
		return true;
	}

	bool CWispDC::ClipDCLine(int *pX1, int *pY1, int *pX2, int *pY2)
	{
		if (m_pClipRect && !ClipLine(pX1, pY1, pX2, pY2, m_pClipRect))
			return false;

		if (!m_pWispWnd)
			return ClipLine(pX1, pY1, pX2, pY2, m_pRect);

		if (!m_pWispWnd->m_pUpdateRC)
			return false;

		WISP_RECT rc = *m_pWispWnd->m_pUpdateRC;

		rc.x += m_pWispWnd->m_ScrWindowRect.x;
		rc.y += m_pWispWnd->m_ScrWindowRect.y;

		if (!ClipLine(pX1, pY1, pX2, pY2, &rc) ||
		    !ClipLine(pX1, pY1, pX2, pY2, m_pRect))
			return false;

		if (m_pWispWnd == m_pWispBase->m_pRootWnd)
			return true;

		CWispBaseWnd *pWnd = m_pWispWnd->m_ParentWnd;

		if (!pWnd)
		{
		//	CWispBaseWnd *
			pWnd = m_pWispBase->m_pRootWnd;
		//	if (!pWnd)
		//		return true;

		//	if (!ClipLine(pX1, pY1, pX2, pY2, pWnd->m_Style & 0x8000 ? 
		//			&((CWispWnd*)pWnd)->m_ScrClientRect :
		//			&pWnd->m_ScrWindowRect))
		//		return false;
		//	return true;
		}

		while (pWnd)
		{
			if (!ClipLine(pX1, pY1, pX2, pY2, pWnd->m_Style & 0x8000 ? 
				&((CWispWnd*)pWnd)->m_ScrClientRect :
				&pWnd->m_ScrWindowRect))
				return false;
			//if (!pWnd) break;
			pWnd = pWnd->m_ParentWnd;
		}
		return true;
	}

	bool CWispDC::ClipDCPoint(WISP_POINT *pPT)
	{
		if (m_pClipRect && !PtInRect(m_pClipRect, pPT))
			return false;

		if (!m_pWispWnd)
			return PtInRect(m_pRect, pPT);

		if (!m_pWispWnd->m_pUpdateRC)
			return false;

		WISP_RECT rc = *m_pWispWnd->m_pUpdateRC;

		rc.x += m_pWispWnd->m_ScrWindowRect.x;
		rc.y += m_pWispWnd->m_ScrWindowRect.y;

		if (!PtInRect(&rc, pPT) ||
		    !PtInRect(m_pRect, pPT))
			return false;

		if (m_pWispWnd == m_pWispBase->m_pRootWnd)
			return true;

		CWispBaseWnd *pWnd = m_pWispWnd->m_ParentWnd;

		if (!pWnd)
		{
		//	CWispBaseWnd *
			pWnd = m_pWispBase->m_pRootWnd;
		//	if (!pWnd)
		//		return true;

		//	if (!PtInRect(pWnd->m_Style & 0x8000 ? 
		//			&((CWispWnd*)pWnd)->m_ScrClientRect :
		//			&pWnd->m_ScrWindowRect, pPT))
		//		return false;
		//	return true;
		}

		while (pWnd)
		{
			if (!PtInRect(pWnd->m_Style & 0x8000 ? 
				&((CWispWnd*)pWnd)->m_ScrClientRect :
				&pWnd->m_ScrWindowRect, pPT))
				return false;
			//if (!pWnd) break;
			pWnd = pWnd->m_ParentWnd;
		}
		return true;
	}

	void CWispDC::DrawSystemStandardIcon(WISP_RECT *rcBoundary, unsigned int uStyle, unsigned long color)
	{
		m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(this, rcBoundary, uStyle, 0);
	}


	void CWispDC::CirclePlotPointsRightTop(int xCenter, int yCenter, int x, int y, unsigned long color, WISP_RECT *pRect)
	{
		if (PtInRect(pRect, xCenter+x, yCenter-y))
			m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, xCenter+x, yCenter-y, color);
		if (PtInRect(pRect, xCenter+y, yCenter-x))
			m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, xCenter+y, yCenter-x, color);
	}

	void CWispDC::CirclePlotPointsRightBottom(int xCenter, int yCenter, int x, int y, unsigned long color, WISP_RECT *pRect)
	{
		if (PtInRect(pRect, xCenter+y, yCenter+x))
			m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, xCenter+y, yCenter+x, color);
		if (PtInRect(pRect, xCenter+x, yCenter+y))
			m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, xCenter+x, yCenter+y, color);
	}

	void CWispDC::CirclePlotPointsLeftTop(int xCenter, int yCenter, int x, int y, unsigned long color, WISP_RECT *pRect)
	{
		if (PtInRect(pRect, xCenter-y, yCenter-x))
			m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, xCenter-y, yCenter-x, color);
		if (PtInRect(pRect, xCenter-x, yCenter-y))
			m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, xCenter-x, yCenter-y, color);
	}

	void CWispDC::CirclePlotPointsLeftBottom(int xCenter, int yCenter, int x, int y, unsigned long color, WISP_RECT *pRect)
	{
		if (PtInRect(pRect, xCenter-x, yCenter+y))
			m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, xCenter-x, yCenter+y, color);
		if (PtInRect(pRect, xCenter-y, yCenter+x))
			m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, xCenter-y, yCenter+x, color);
	}


	//...

	void CWispDC::DrawCircleRightTop(int x, int y, int radius, unsigned long color)
	{
		WISP_RECT rc = *m_pRect;

		int xCenter = m_pRect->x + x;
		int yCenter = m_pRect->y + y;
		ClipDCRect(&rc);

		int _x = 0;
		int _y = radius;
		int p = 1 - radius;
		while ( _x < _y )
		{
			++_x;
			if (p >= 0)
				p += 2 * (_x - --_y) +1;
			else	p += 2 * (_x) +1;
			CirclePlotPointsRightTop(xCenter, yCenter, _x, _y, color, &rc);
		}
	}

	void CWispDC::DrawCircleRightBottom(int x, int y, int radius, unsigned long color)
	{
		WISP_RECT rc = *m_pRect;

		int xCenter = m_pRect->x + x;
		int yCenter = m_pRect->y + y;
		ClipDCRect(&rc);

		int _x = 0;
		int _y = radius;
		int p = 1 - radius;
		while ( _x < _y )
		{
			++_x;
			if (p >= 0)
				p += 2 * (_x - --_y) +1;
			else	p += 2 * (_x) +1;
			CirclePlotPointsRightBottom(xCenter, yCenter, _x, _y, color, &rc);
		}
	}

	void CWispDC::DrawCircleLeftTop(int x, int y, int radius, unsigned long color)
	{
		WISP_RECT rc = *m_pRect;

		int xCenter = m_pRect->x + x;
		int yCenter = m_pRect->y + y;
		ClipDCRect(&rc);

		int _x = 0;
		int _y = radius;
		int p = 1 - radius;
		while ( _x < _y )
		{
			++_x;
			if (p >= 0)
				p += 2 * (_x - --_y) +1;
			else	p += 2 * (_x) +1;

			CirclePlotPointsLeftTop(xCenter, yCenter, _x, _y, color, &rc);
		}
	}
	void CWispDC::DrawCircleLeftBottom(int x, int y, int radius, unsigned long color)
	{
		WISP_RECT rc = *m_pRect;

		int xCenter = m_pRect->x + x;
		int yCenter = m_pRect->y + y;
		ClipDCRect(&rc);

		int _x = 0;
		int _y = radius;
		int p = 1 - radius;
		while ( _x < _y )
		{
			++_x;
			if (p >= 0)
				p += 2 * (_x - --_y) +1;
			else	p += 2 * (_x) +1;

			CirclePlotPointsLeftBottom(xCenter, yCenter, _x, _y, color, &rc);
		}
	}


	void CWispDC::DrawPixel(int x, int y, unsigned long color)
	{
		WISP_POINT PT;

		PT.x = x + m_pRect->x;
		PT.y = y + m_pRect->y;

		if (ClipDCPoint(&PT))
			m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, x, y, color);
	}

	void CWispDC::DrawLine(int x1, int y1, int x2, int y2, unsigned long color)
	{
		int Error;
		int XDelta;
		int YDelta;
		int step;

		x1 += m_pRect->x;
		x2 += m_pRect->x;

		y1 += m_pRect->y;
		y2 += m_pRect->y;

		Error = 0;

		if (ClipDCLine(&x1, &y1, &x2, &y2))
		{
			XDelta = ABS(x2-x1);
			YDelta = ABS(y2-y1);

			if (XDelta >= YDelta)
			{
				if (x1 > x2)
				{
					SWAP(x1, x2);
					SWAP(y1, y2);
				}
				step = (y1<y2)?1:-1;
				for (; x1 <= x2; ++x1)
				{
					if (Error >= XDelta)
					{
						Error -= XDelta;
						y1 += step;
					}
					Error += YDelta;
					m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, x1, y1, color);
				}
			} else
			{
				if (y1 > y2)
				{
					SWAP(x1, x2);
					SWAP(y1, y2);
				}
				step = (x1<x2)?1:-1;
				for (; y1 <= y2; ++y1)
				{
					if (Error >= YDelta)
					{
						Error -= YDelta;
						x1 += step;
					}
					Error += XDelta;
					m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, x1, y1, color);
				}
			}
		}
	}

	void CWispDC::DrawVLine(int x, int y1, int y2, unsigned long color)
	{
		x += m_pRect->x;
		y1 += m_pRect->y;
		y2 += m_pRect->y;

		if (ClipDCLine(&x, &y1, &x, &y2))
		{
			if (y1 > y2)
			{
				SWAP(y1,y2);
			}

			while (y1 <= y2)
			{
				m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer,
					x, y1++, color);
			}
		}
	}
	void CWispDC::DrawHLine(int x1, int x2, int y, unsigned long color)
	{
		x1 += m_pRect->x;
		x2 += m_pRect->x;
		y += m_pRect->y;

		if (ClipDCLine(&x1, &y, &x2, &y))
		{
			if (x2 < x1)
			{
				SWAP(x2,x1);
			}

			m_pFrameBuffer->pWispDrawHAL->SetHLinePixel(m_pFrameBuffer,
					x1, y, x2 - x1 + 1, color);
		}
	}

	void CWispDC::DrawVDashLine(int x, int y1, int y2, unsigned long color)
	{
		x += m_pRect->x;
		y1 += m_pRect->y;
		y2 += m_pRect->y;

		if (ClipDCLine(&x, &y1, &x, &y2))
		{
			for (int y = y1; y <= y2; y += 2)
				m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer,
						x, y, color);
		}
	}

	void CWispDC::DrawHDashLine(int x1, int x2, int y, unsigned long color)
	{
		x1 += m_pRect->x;
		x2 += m_pRect->x;
		y += m_pRect->y;

		if (ClipDCLine(&x1, &y, &x2, &y))
		{
			for (int x = x1; x <= x2; x += 2)
				m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer,
						x,y, color);
		}
	}


//	void CWispDC::DrawCircle(int, int, int, unsigned long);


	void CWispDC::DrawRect(WISP_RECT *pRc, unsigned long color)
	{
		DrawRect(pRc->x, pRc->y, pRc->cx, pRc->cy, color);
	}

	void CWispDC::DrawRect(int x, int y, int cx, int cy, unsigned long color)
	{
		DrawVLine(x, y, y+cy-1, color);
		DrawVLine(x+cx-1, y, y+cy-1, color);
		DrawHLine(x, x+cx-1, y, color);
		DrawHLine(x, x+cx-1, y+cy-1, color);
	}

	void CWispDC::DrawRoundRect(WISP_RECT *pRc, unsigned long color)
	{
		DrawVLine(pRc->x, pRc->y + 1, pRc->y2() - 2, color);
		DrawVLine(pRc->x2() - 1, pRc->y + 1, pRc->y2() - 2, color);
		DrawHLine(pRc->x + 1, pRc->x2() - 2, pRc->y, color);
		DrawHLine(pRc->x + 1, pRc->x2() - 2, pRc->y2() - 1, color);
	}

	void CWispDC::Draw3DRect(WISP_RECT *pRc, unsigned long crTopLeft, unsigned long crBottomRight)
	{
		DrawVLine(pRc->x, pRc->y, pRc->y2() - 1, crTopLeft);
		DrawVLine(pRc->x2() - 1, pRc->y, pRc->y2() - 1, crBottomRight);
		DrawHLine(pRc->x, pRc->x2() - 1, pRc->y, crTopLeft);
		DrawHLine(pRc->x, pRc->x2() - 1, pRc->y2() - 1, crBottomRight);
	}

	void CWispDC::DrawDashRect(WISP_RECT *pRc, unsigned long color)
	{
		DrawVDashLine(pRc->x, pRc->y, pRc->y2() - 1, color);
		DrawVDashLine(pRc->x2() - 1, pRc->y, pRc->y2() - 1, color);
		DrawHDashLine(pRc->x, pRc->x2() - 1, pRc->y, color);
		DrawHDashLine(pRc->x, pRc->x2() - 1, pRc->y2() - 1, color);
	}

	void CWispDC::DrawFullRect(WISP_RECT *pRc, unsigned long color)
	{
		DrawFullRect(pRc->x, pRc->y, pRc->cx, pRc->cy, color);
	}

	void CWispDC::DrawFullRect(int x, int y, int cx, int cy, unsigned long color)
	{
		WISP_RECT rc;

		rc.x = x + m_pRect->x;
		rc.y = y + m_pRect->y;
		rc.cy = cy;
		rc.cx = cx;
		if (ClipDCRect(&rc)) //&& IsRectVisible(&rc)
		{
			//gpWispBase->DrawFullRect(&rc, color);
			for (int v = rc.y; v < rc.y + rc.cy; ++v)
				m_pFrameBuffer->pWispDrawHAL->SetHLinePixel(m_pFrameBuffer,
					rc.x, v, rc.cx, color);
		}
	}

	inline COLOR GrayColor(COLOR color, char nChg, unsigned char start, unsigned char end)
	{
			unsigned char R = GetRColor(color);
			unsigned char G = GetGColor(color);
			unsigned char B = GetBColor(color);

			unsigned char Delta = (start - end);//*nChg;
			Delta *= nChg;
			R += Delta*3;
			G += Delta*5;
			B += Delta*1;

		return RGBColor(R,G,B);
	}

	unsigned long CWispDC::DrawXGrayChgFullRect(WISP_RECT *pRc, unsigned long color, int nChg)
	{
		WISP_RECT rc = *pRc;

		rc.x += m_pRect->x;
		rc.y += m_pRect->y;

		if (!ClipDCRect(&rc))
			return GrayColor(color,nChg,pRc->cx,0);

		int X = pRc->x + m_pRect->x;
		int CX = X + pRc->cx;

		for (int x = X; x < CX; ++x)
		{
			unsigned long Color = GrayColor(color,nChg,x,X);
			if (x >= rc.x && x < rc.x+rc.cx)
			{
				for (int Y = rc.y; Y < rc.y+rc.cy; ++Y)
				{
					m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer,	x, Y, Color);
				}
			}
		}
		return color;
	}
	void CWispDC::DrawXGrayColorFullRect(unsigned long color1, unsigned long color2, WISP_RECT *pRc)
	{
		WISP_RECT rc = *pRc;

		rc.x += m_pRect->x;
		rc.y += m_pRect->y;

		if (!ClipDCRect(&rc))
			return;

		unsigned long sC16 = ((unsigned long)((unsigned char)(color1>>16)))<<16;
		unsigned long sC08 = ((unsigned long)((unsigned char)(color1>> 8)))<<16;
		unsigned long sC00 = ((unsigned long)((unsigned char)(color1>> 0)))<<16;

		unsigned long dc16 = (((unsigned char)(color2>>16) - (unsigned char)(color1>>16))<<16)/pRc->cx;
		unsigned long dc08 = (((unsigned char)(color2>> 8) - (unsigned char)(color1>> 8))<<16)/pRc->cx;
		unsigned long dc00 = (((unsigned char)(color2>> 0) - (unsigned char)(color1>> 0))<<16)/pRc->cx;

		int X = pRc->x + m_pRect->x;
		int CX = X + pRc->cx;

		for (int x = X; x < CX; ++x)
		{
			if (x >= rc.x && X < rc.x+rc.cx)
			{
				sC16 += dc16;
				sC08 += dc08;
				sC00 += dc00;
				unsigned long color = (sC16>>16)<<16 | (sC08>>16)<<8 | (sC00>>16);

				for (int Y = rc.y; Y < rc.y+rc.cy; ++Y)
				{
					m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer,
						x, Y, color);
				}
			}
		}
	}

	unsigned long CWispDC::DrawYGrayChgFullRect(WISP_RECT *pRc, unsigned long color, int nChg)
	{
		WISP_RECT rc = *pRc;

		rc.x += m_pRect->x;
		rc.y += m_pRect->y;

		if (!ClipDCRect(&rc))
			return GrayColor(color,nChg,pRc->cy,0);

		int Y = pRc->y + m_pRect->y;
		int CY = Y + pRc->cy;

		for (int y = Y; y < CY; ++y)
		{
			unsigned long Color = GrayColor(color,nChg,y,Y);
			if (y >= rc.y && y < rc.y+rc.cy)
				m_pFrameBuffer->pWispDrawHAL->SetHLinePixel(m_pFrameBuffer, rc.x, y, rc.cx, Color);
		}
		return color;
	}
	void CWispDC::DrawYGrayColorFullRect(unsigned long color1, unsigned long color2, WISP_RECT *pRc)
	{
		WISP_RECT rc = *pRc;

		rc.x += m_pRect->x;
		rc.y += m_pRect->y;

		if (!ClipDCRect(&rc))
			return;

		unsigned long sC16 = ((unsigned long)((unsigned char)(color1>>16)))<<16;
		unsigned long sC08 = ((unsigned long)((unsigned char)(color1>> 8)))<<16;
		unsigned long sC00 = ((unsigned long)((unsigned char)(color1>> 0)))<<16;

		unsigned long dc16 = (((unsigned char)(color2>>16) - (unsigned char)(color1>>16))<<16)/pRc->cy;
		unsigned long dc08 = (((unsigned char)(color2>> 8) - (unsigned char)(color1>> 8))<<16)/pRc->cy;
		unsigned long dc00 = (((unsigned char)(color2>> 0) - (unsigned char)(color1>> 0))<<16)/pRc->cy;

		int Y = pRc->y + m_pRect->y;
		int CY = Y + pRc->cy;

		for (int y = Y; y < CY; ++y)
		{
			sC16 += dc16;
			sC08 += dc08;
			sC00 += dc00;
			unsigned long color = (sC16>>16)<<16 | (sC08>>16)<<8 | (sC00>>16);

			if (y >= rc.y && y < rc.y+rc.cy)
				m_pFrameBuffer->pWispDrawHAL->SetHLinePixel(m_pFrameBuffer,
					rc.x, y, rc.cx, color);
		}
	}


	void CWispDC::DrawXGrayColorFullRect2(unsigned long color1, unsigned long color2, WISP_RECT *pRc)
	{
		WISP_RECT rc = *pRc;

		rc.cx /= 2;
		DrawXGrayColorFullRect(color1, color2, &rc);

		rc.x += rc.cx;
		rc.cx = pRc->x + pRc->cx - rc.x;
		DrawXGrayColorFullRect(color2, color1, &rc);
	}
	void CWispDC::DrawYGrayColorFullRect2(unsigned long color1, unsigned long color2, WISP_RECT *pRc)
	{
		WISP_RECT rc = *pRc;

		rc.cy /= 2;
		DrawYGrayColorFullRect(color1, color2, &rc);

		rc.y += rc.cy;
		rc.cy = pRc->y + pRc->cy - rc.y;
		DrawYGrayColorFullRect(color2, color1, &rc);
	}

	void CWispDC::DrawFrameRect(WISP_RECT *pRc, bool bRaised, int Deep)
	{
		//if (IsRectVisible(pRc))
		DrawFrameRect(pRc->x, pRc->y, pRc->cx, pRc->cy, bRaised, Deep);
	}

	void CWispDC::DrawFrameRect(int x, int y, int cx, int cy, bool bRaised, int Deep)
	{
		unsigned long ColTop;
		unsigned long ColBottom;

		if (bRaised)
		{
			ColTop = m_pWispBase->m_pWispDrawObj->m_crSystem[29]; //swap
			ColBottom = m_pWispBase->m_pWispDrawObj->m_crSystem[30]; //swap
		} else
		{
			ColTop = m_pWispBase->m_pWispDrawObj->m_crSystem[30]; //swap
			ColBottom = m_pWispBase->m_pWispDrawObj->m_crSystem[29]; //swap
		}

		int Sign;

		if (Deep >= 0)
		{
			Sign = 1;
		} else
		{
			Deep = -Deep;
			Sign = -1;
		}

		if (Deep > 0)
		{
			int Inc = 0;
			do {

		//DrawHLine(x, x+cx-1, y, color);
		//DrawHLine(x, x+cx-1, y+cy-1, color);

		//DrawVLine(x, y, y+cy-1, color);
		//DrawVLine(x+cx-1, y, y+cy-1, color);

		DrawHLine(Inc + x, x - Inc + cx - 1, Inc + y, ColTop);
		DrawHLine(Inc + x, x - Inc + cx - 1, cy - Inc + y - 1, ColBottom);

		DrawVLine(Inc + x,          Inc + y, cy - Inc + y - 1, ColTop);
		DrawVLine(x - Inc + cx - 1, Inc + y, cy - Inc + y - 1, ColBottom);

				Inc += Sign;

			} while (--Deep);
		}
	}

	void CWispDC::DrawDIBTiled(CWispDIB *pDIB, WISP_RECT *pRect)
	{
		WISP_RECT DefRect;

		if (!pRect)
		{
			DefRect.y = 0;
			DefRect.x = 0;
			DefRect.cx = m_pRect->cx;
			DefRect.cy = m_pRect->cy;
			pRect = &DefRect;
		}

		for (int x = pRect->x; x < pRect->x + pRect->cx; x+=pDIB->m_PixelBuf.Width)
			for (int y = pRect->y; y < pRect->y + pRect->cy; y+=pDIB->m_PixelBuf.Height)
				DrawDIB(x, y, pDIB);
	}

	void CWispDC::DrawDIB(int x, int y, CWispDIB *pDIB)
	{
		if (pDIB->m_PixelBuf.VideoBuffer == 0)
			return;

		WISP_RECT rect;

		int xoff = x - pDIB->m_HotPT.x;
		int yoff = y - pDIB->m_HotPT.y;

		rect.x = xoff + m_pRect->x;
		rect.y = yoff + m_pRect->y;

		rect.cx = pDIB->m_PixelBuf.Width;
		rect.cy = pDIB->m_PixelBuf.Height;

		if (!ClipDCRect(&rect))
			return;

		unsigned long *pBuf = (unsigned long*)((unsigned char*)pDIB->m_PixelBuf.VideoBuffer+
				(rect.x-m_pRect->x-xoff)*(32/8) +
				(rect.y-m_pRect->y-yoff)*pDIB->m_PixelBuf.LineDistance);

		//if (rect.cy <= 0)
		//	return;

		for (int ny = 0; ny < rect.cy; ++ny)
		{
			if (pDIB->m_Type == 1) //BMP COLORREF_PF_PAL
			{
				m_pFrameBuffer->pWispDrawHAL->CopyToPixel(
						(char*)m_pFrameBuffer->VideoBuffer
						+ rect.x * (m_pFrameBuffer->Bpp/8)
						+ (rect.y + ny)* m_pFrameBuffer->LineDistance,
						pBuf,
						rect.cx);
				pBuf += pDIB->m_PixelBuf.LineDistance/4;
			} else
			if (pDIB->m_Type == 2) //ICO COLORREF_PF_555
			{
				for (int nx = 0; nx < rect.cx; ++nx, ++pBuf)
				{
					if (*pBuf != pDIB->m_ColorKey)
					{
						m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer,
							nx+rect.x, ny+rect.y, *pBuf);
					}
				}
				pBuf += pDIB->m_PixelBuf.LineDistance/4 - rect.cx;

			} else
			if (pDIB->m_Type == 3) //??? COLORREF_PF_565
			{
				for (int nx = 0; nx < rect.cx; ++nx, ++pBuf)
				{
					if (*pBuf != pDIB->m_ColorKey)
					{
						m_pFrameBuffer->pWispDrawHAL->DrawXorPixel(m_pFrameBuffer,
							nx+rect.x, ny+rect.y, *pBuf);
					}
				}
				pBuf += pDIB->m_PixelBuf.LineDistance/4 - rect.cx;
			}
		}
	}
	void CWispDC::DrawDIB(WISP_RECT *pRect, CWispDIB *pDIB)
	{
		DrawDIB(
			pRect->x + (pRect->cx - pDIB->m_PaintRect.cx) / 2,
			pRect->y + (pRect->cy - pDIB->m_PaintRect.cy) / 2,
			pDIB);
	}

	void CWispDC::DrawDIBGray(int x, int y, CWispDIB *pDIB)
	{
		if (pDIB->m_PixelBuf.VideoBuffer == 0)
			return;

		WISP_RECT rect;

		int xoff = x - pDIB->m_HotPT.x;
		int yoff = y - pDIB->m_HotPT.y;

		rect.x = xoff + m_pRect->x;
		rect.y = yoff + m_pRect->y;

		rect.cx = pDIB->m_PixelBuf.Width;
		rect.cy = pDIB->m_PixelBuf.Height;

		if (!ClipDCRect(&rect))
			return;

		unsigned long *pBuf = (unsigned long*)((unsigned char*)pDIB->m_PixelBuf.VideoBuffer+
				(rect.x - m_pRect->x - xoff)*(32/8) +
				(rect.y - m_pRect->y - yoff)*pDIB->m_PixelBuf.LineDistance);

		//if (rect.cy <= 0)
		//	return;

		for (int ny = 0; ny < rect.cy; ++ny)
		{
			if (pDIB->m_Type == 0 || //??? COLORREF_PF_DEFAULT
			    pDIB->m_Type == 1 || //BMP COLORREF_PF_PAL
			    pDIB->m_Type == 2) //ICO COLORREF_PF_555
			{
				for (int nx = 0; nx < rect.cx; ++nx, ++pBuf)
				{
					if (*pBuf != pDIB->m_ColorKey)
					{
						unsigned char TextClr = LOW_BYTE(pBuf[0]);
						unsigned char BKClr = HIGH_BYTE(pBuf[0]);
						unsigned long Clr = BKClr*5+TextClr*4;

						m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer,
							nx+rect.x, ny+rect.y, 
							Clr <= 0x480 ?
							m_pWispBase->m_pWispDrawObj->m_crSystem[20] :
							m_pWispBase->m_pWispDrawObj->m_crSystem[115]);
					}
				}
				pBuf += pDIB->m_PixelBuf.LineDistance/4 - rect.cx;

			} else
			if (pDIB->m_Type == 3) //??? COLORREF_PF_565
			{
				for (int nx = 0; nx < rect.cx; ++nx, ++pBuf)
				{
					if (*pBuf != pDIB->m_ColorKey)
					{
						m_pFrameBuffer->pWispDrawHAL->DrawXorPixel(m_pFrameBuffer,
							nx+rect.x, ny+rect.y, *pBuf);
					}
				}
				pBuf += pDIB->m_PixelBuf.LineDistance/4 - rect.cx;
			}
		}
	}
	void CWispDC::DrawDIBGray(WISP_RECT *pRect, CWispDIB *pDIB)
	{
		DrawDIBGray(
			pRect->x + (pRect->cx - pDIB->m_PaintRect.cx) / 2,
			pRect->y + (pRect->cy - pDIB->m_PaintRect.cy) / 2,
			pDIB);
	}

// text
	int CWispDC::GetTextHeight(WCHAR Char)
	{
		return m_pFont->m_Height;
	}

	int CWispDC::GetTextLen(const WCHAR *lpString, int nStrLen) //nCharsBits
	{
		int nRetLen = 0;
		if (lpString == 0)
			return 0;

		if (!IsColorString(lpString))
		{
			int nCount = 0;
			int Len = TStrLen(lpString);
			int nWidth = 0; //= nStrLen ??? TODO
			int nMaxLen = 0;
			for (int i = 0; i < Len; ++i)
			{
				const WCHAR Char = lpString[i];
				if (Char == 9)
				{
					int nTmp = ROUNDREVERSE(nCount, m_TabAlign);
					nWidth = nTmp * m_pFont->GetCharWidth(0x20);
					nMaxLen += nWidth;
					nCount += nTmp;
				} else
				if (Char != 10)
				{
					nWidth = m_pFont->GetCharWidth(Char);
					nMaxLen += nWidth;
					++nCount;
				}
				if (nStrLen >= nMaxLen - nWidth && nStrLen < nMaxLen)
					return i;
			}
			return -1;
		}

		//ColorStr
		const unsigned long *lpColorString = (const unsigned long *)lpString;
		++lpColorString; //skip Color

			int nCount = 0;
			int Len = TStrLen(lpColorString);
			int nWidth = 0; //= nStrLen ??? TODO
			int nMaxLen = 0;
			for (int i = 0; i < Len; ++i)
			{
				WCHAR Char = lpColorString[i];
				if (Char == 9)
				{
					int nTmp = ROUNDREVERSE(nCount, m_TabAlign);
					nWidth = nTmp * m_pFont->GetCharWidth(0x20);
					nMaxLen += nWidth;
					nCount += nTmp;
				} else
				if (Char != 10)
				{
					nWidth = m_pFont->GetCharWidth(Char);
					nMaxLen += nWidth;
					++nCount;
				}
				if (nStrLen >= nMaxLen - nWidth && nStrLen < nMaxLen)
					return i;
			}
			return -1;
	}

	int CWispDC::GetTextExtent(const WCHAR *lpString, int nStrLen, int nCount)
	{
		if (lpString == 0)
			return 0;

		if (!IsColorString(lpString))
		{
			if (nStrLen == -1)
				nStrLen = TStrLen(lpString);
			int nRetLen = 0;
			for (int i = 0; i < nStrLen; ++i)
			{
				WCHAR Char = lpString[i];
				if (Char == 9)
				{
					int nTmp = ROUNDREVERSE(nCount, m_TabAlign);
					nRetLen += nTmp * m_pFont->GetCharWidth(0x20);
					nCount += nTmp;
				} else
				if (Char != 10)
				{
					nRetLen += m_pFont->GetCharWidth(Char);
					++nCount;
				}
			}
			return nRetLen;
		}

		//ColorStr
		const unsigned long *lpColorString = (const unsigned long *)lpString;
		++lpColorString; //skip Color

			if (nStrLen == -1)
				nStrLen = TStrLen(lpColorString);
			int nRetLen = 0;
			for (int i = 0; i < nStrLen; ++i)
			{
				WCHAR Char = lpColorString[i];
				if (Char == 9)
				{
					int nTmp = ROUNDREVERSE(nCount, m_TabAlign);
					nRetLen += nTmp * m_pFont->GetCharWidth(0x20);
					nCount += nTmp;
				} else
				if (Char != 10)
				{
					nRetLen += m_pFont->GetCharWidth(Char);
					++nCount;
				}
			}
			return nRetLen;
	}

	int CWispDC::GetTextExtentTabExpend(const WCHAR *lpString, int nTabPixelWidth, int nCount)
	{
		int nRetLen = 0;
		if (nCount == -1)
			nCount = TStrLen(lpString);
		for (int i = 0; i < nCount; ++i)
		{
			if (lpString[i] < 256)
			{
				if (lpString[i] == 9)
					nRetLen += ROUNDREVERSE(nRetLen, nTabPixelWidth);
				else	nRetLen += m_pFont->m_CharLenAry[lpString[i]];
			} else
			{
				nRetLen += 16;
			}
		}
		return nRetLen;
	}

	int CWispDC::GetTextExtentLineTabExpend(const WCHAR *lpString, int nTabPixelWidth, int nCount)
	{
		int nRetLen = 0;
		if (nCount == -1)
			nCount = TStrLen(lpString);
		for (int i = 0; i < nCount; ++i)
		{
			if (lpString[i] == 10 || lpString[i] == 13)
				break;

			if (lpString[i] < 256)
			{
				if (lpString[i] == 9)
					nRetLen += ROUNDREVERSE(nRetLen, nTabPixelWidth);
				else	nRetLen += m_pFont->m_CharLenAry[lpString[i]];
			} else
			{
				nRetLen += 16;
			}
		}
		return nRetLen;
	}

	int CWispDC::CalcTextLineNum(const WCHAR *lpString, int nStrLen)
	{
		int nLineNum = 0;
		int j = 0;
		int i = 0;
		while (j++ < nStrLen && i < nStrLen)
		{
			int start = i;
			int len = 0;
			while (i < nStrLen &&
				(lpString[i] != 13 && lpString[i] != 10))
			{
				++i;
				++len;
			}
			if (len == 0 && i >= nStrLen) break;
			++nLineNum;

			if (++i >= nStrLen) break;

			if ((lpString[i] == 10 || lpString[i] == 13) && lpString[i-1] != lpString[i])
				++i;
		}
		return nLineNum;
	}

	int CWispDC::CalcDrawTextRect(const WCHAR *lpString, WISP_RECT *lpRect, int nStrLen, unsigned int uFormat, int nTabPixelWidth)
	{
		if (uFormat & 0x20)
		{
			if (uFormat & 0x40)
				lpRect->cx = GetTextExtentTabExpend(lpString, nTabPixelWidth, nStrLen);
			else	lpRect->cx = GetTextExtent(lpString, nStrLen, 0);
			lpRect->cy = m_pFont->m_Height;
			return lpRect->cy;
		}

		int nWidth = 0;
		int nLineNum = 0;
		int i = 0;
		while (i < nStrLen)
		{
			int start = i;
			int len = 0;
			while (i < nStrLen && 
				(lpString[i] != 13 && lpString[i] != 10))
			{
				++i;
				++len;
			}
			if (len == 0 && i >= nStrLen) break;
			++nLineNum;

			int nExten;
			if (uFormat & 0x40)
				nExten = GetTextExtentLineTabExpend(&lpString[start], nTabPixelWidth, len);
			else	nExten = GetTextExtent(&lpString[start], len, 0);
			if (uFormat & 0x00400000 && lpRect->cx < nExten)
			{
				while (len>0)
				{
					int n = GetMaxShowCharNum(&lpString[start], lpRect->cx, 0, len);
					++nLineNum;
					len -= n;
					start += n;
				}
				--nLineNum;
			}
			MIN_LIMIT(nWidth, nExten);

			if (++i >= nStrLen) break;
			if ((lpString[i] == 10 || lpString[i] == 13) && lpString[i-1] != lpString[i])
				++i;
		}
		lpRect->cx = nWidth;
		lpRect->cy = m_pFont->m_Height * nLineNum;
		return lpRect->cy;
	}

	int CWispDC::GetMaxShowCharNum(const WCHAR *lpString, int nMaxWidth, int nTabPixelWidth, int nCount)
	{
		int nRetLen = 0;
		int sum = 0;
		if (nCount == -1)
			nCount = TStrLen(lpString);
		if (nTabPixelWidth)
		{
			for (int i = 0; i < nCount; ++i)
			{	
				if (lpString[i] == 9)
					sum += ROUNDREVERSE(sum, nTabPixelWidth);
				else	sum += GetTextExtent(&lpString[i], 1, 0);
				if (sum >= nMaxWidth)
					break;
				++nRetLen;
				if (nRetLen >= nCount)
					return nRetLen;
			}
			if (lpString[nRetLen] == 9)
				++nRetLen;
		} else
		{
			for (int i = 0; i < nCount; ++i)
			{	
				sum += GetTextExtent(&lpString[i], 1, 0);
				if (sum >= nMaxWidth)
					break;
				++nRetLen;
			}
		}
		return nRetLen;
	}

	int CWispDC::DrawTabExpendString(int x, int y, const WCHAR *lpString, int nStringRealLen, WISP_RECT rc, int nTabPixelWidth)
	{
		WCHAR TabExpendString[9];
		TMemSet(TabExpendString, (WCHAR)0x20, 9);
		int TabExpendStringPixelWidth = GetTextExtent(TabExpendString, -1, 0);

		int i = 0;
		int nStartx = x;
		while (i < nStringRealLen)
		{
			int start = i;
			int nLen = 0;
			while (i < nStringRealLen &&
				(lpString[i] != 9))
			{
				++i;
				++nLen;
			}

			int nx = nStartx + GetTextExtent(&lpString[start], nLen, 0);
			if (nx < 0 || nStartx > m_pRect->cx)
				break;
			DrawString(nStartx, y, &lpString[start], nLen, 0, 0);

			int tab = ROUNDREVERSE((nx - x), nTabPixelWidth);
			int tabAlign = ALIGNUP(tab, TabExpendStringPixelWidth);
			nStartx = nx + tab;
			for (int k = 0; k < tabAlign; ++k)
			{
				int n = nx + TabExpendStringPixelWidth;
				if (n < 0) break;
				if (nx > m_pRect->cx) break;
				DrawString(nx, y, TabExpendString, -1, 0, 0);
				nx = n;
			}
			++i;
		}
		return 0;
	}

	void CWispDC::AdjustNoClipRect(WISP_RECT *lpRect, unsigned int uFormat)
	{
		if (uFormat & 2)
		{
			if (lpRect->x > 0)
			{
				lpRect->cx += lpRect->x;
				lpRect->x = 0;
			}
		} else
		if (uFormat & 1)
		{
			if (lpRect->x > 0)
			{
				lpRect->cx += lpRect->x;
				lpRect->x = 0;
			}

			if (lpRect->x + lpRect->cx < m_pRect->cx)
				lpRect->cx = m_pRect->cx - lpRect->x;
		} else
		{
			if (lpRect->x + lpRect->cx < m_pRect->cx)
				lpRect->cx = m_pRect->cx - lpRect->x;
		}
	}

//0x0000 0001	X
//0x0000 0002	X
//0x0000 0004	Y
//0x0000 0008	Y

//0x0000 0010
//0x0000 0020 STR
//0x0000 0040 TAB
//0x0000 0080

//0x0000 0100 CLIP
//0x0000 0200
//0x0000 0400 CALCRECT
//0x0000 0800

//0x0000 1000
//0x0000 2000
//0x0000 4000 FILE PATH
//0x0000 8000 DIR PATH

//0x0001 0000 PATH ELIPSIS
//0x0002 0000
//0x0004 0000 FS
//0x0008 0000

//0x0010 0000
//0x0020 0000
//0x0040 0000 MAX
//0x0080 0000

	int CWispDC::DrawString(const WCHAR *lpString, WISP_RECT *lpRect, unsigned int uFormat, unsigned int nShowLen, int nPreLineMaxCharNum)
	{
		struct stShowString
		{
			int coordinateX;
			const WCHAR *ShowString;
			int nShowLen;
			int nPixelWidth;
		} ShowString[3];

		if (lpString == 0) return 0;
		int nStringRealLen = TStrLen(lpString);
		if (nStringRealLen == 0) return 0;
		if (nShowLen && nShowLen < nStringRealLen)
			nStringRealLen = nShowLen;

		WISP_RECT rc = *lpRect;

		int nTabPixelWidth = 6;
		if (uFormat & 0x40)
		{
			int n8 = 8;
			if (uFormat & 0x80)
			{
				n8 = (uFormat >> 8) & 0xff; //???
				if (n8==0) n8 = 8;
				uFormat &= ~0x1F00;
			}
			nTabPixelWidth *= n8;
		}
		int nLineNum = CalcTextLineNum(lpString, nStringRealLen);

		if (uFormat & 0x400)
			return CalcDrawTextRect(lpString, lpRect, nStringRealLen, uFormat, nTabPixelWidth);

		int nCenterPos = rc.x + rc.cx/2;

		int nEllipsisStringPixelWidth; //??? = 0;
		if (uFormat & 0x4C000)
			nEllipsisStringPixelWidth = GetTextExtent(WSTR("..."), -1, 0);

		if (uFormat & 0x100)
			AdjustNoClipRect(&rc, uFormat);

		if ((uFormat & 0x20) == 0)
		{
			if (uFormat & 4)
			{
				if (rc.cy > nLineNum * m_pFont->m_Height)
					rc.y += (rc.cy - nLineNum * m_pFont->m_Height)/2;
				uFormat &= ~4;
			}
			uFormat = (uFormat & ~8) | 0x20;
			int nTotalLen = nStringRealLen;
			int nCurLine = 0;
			int n = 0;
			int i = 0;
			while (i < nStringRealLen && n++ < nLineNum)
			{
				int len = 0;
				int start = i;
				while (i < nStringRealLen &&
					(lpString[i] != 13 && lpString[i] != 10))
				{
					++i;
					++len;
				}
				if (len==0)
				{
					if (len>=nStringRealLen) break;
					goto skip;
				}

				if (nTotalLen <= 0) break;
				MAX_LIMIT(len, nTotalLen);
				nTotalLen -= len;
			//move under
				int nStringPixelWidth;
				if (uFormat & 0x40)
					nStringPixelWidth = GetTextExtentLineTabExpend(&lpString[start], nTabPixelWidth, len);
				else	nStringPixelWidth = GetTextExtent(&lpString[start], len, 0);

				if (uFormat & 0x400000)
				{
					if (nStringPixelWidth > lpRect->cx)
					{
						while (len>0)
						{
							int MaxShow = GetMaxShowCharNum(&lpString[start], lpRect->cx, uFormat&0x40?nTabPixelWidth:0, len);
							DrawString(&lpString[start], &rc, uFormat, MaxShow, -1);
							++nCurLine;
							len -= MaxShow;
							start += MaxShow;
							if (len)
							{
								rc.y += m_pFont->m_Height;
								rc.cy -= m_pFont->m_Height;
							}
							if (rc.cy <= 0)break;
						}
						--nCurLine;
					}
				} else
				if (uFormat & 0x800000)
				{
						while (len>=nPreLineMaxCharNum)
						{
							DrawString(&lpString[start], &rc, uFormat, nPreLineMaxCharNum, -1);
							++nCurLine;
							len -= nPreLineMaxCharNum;
							start += nPreLineMaxCharNum;
							if (len)
							{
								rc.y += m_pFont->m_Height;
								rc.cy -= m_pFont->m_Height;
							}
							if (rc.cy <= 0) break;
						}
						if (len==0)
							--nCurLine;
						else	DrawString(&lpString[start], &rc, uFormat, len, -1);

				} else
				if (len)
				{
					DrawString(&lpString[start], &rc, uFormat, len, -1);
				}
		skip:
				if (++i>=nStringRealLen) break;
				--nTotalLen;
				if ((lpString[i] == 10 || lpString[i] == 13) && lpString[i-1] != lpString[i])
				{
					++i;
					--nTotalLen;
				}
				rc.y += m_pFont->m_Height;
				rc.cy -= m_pFont->m_Height;
				if (rc.cy <= 0) break;
				++nCurLine;
			}
			return m_pFont->m_Height * nCurLine;
		}

		//0x20

		if (rc.x + rc.cx < 0 || rc.x > m_pRect->cx)
			return m_pFont->m_Height;

		int coordinateX = rc.x;
		int coordinateY = rc.y;

		int nStringPixelWidth;
		if (uFormat & 0x40)
			nStringPixelWidth = GetTextExtentTabExpend(lpString, nTabPixelWidth, nStringRealLen);
		else	nStringPixelWidth = GetTextExtent(lpString, nStringRealLen, 0);
		//
		if (uFormat & 1)	coordinateX = nCenterPos - nStringPixelWidth/2;
		else
		if (uFormat & 2)	coordinateX = rc.x + rc.cx - nStringPixelWidth;
		//
		if (uFormat & 4)	coordinateY = rc.y + (rc.cy - m_pFont->m_Height)/2;
		else
		if (uFormat & 8)	coordinateY = rc.y + (rc.cy - m_pFont->m_Height);

		ShowString[0].coordinateX = coordinateX;
		ShowString[0].ShowString = lpString;
		ShowString[0].nShowLen = nStringRealLen;
		ShowString[0].nPixelWidth = nStringPixelWidth;
		int nShowStringCounter = 1;

		if (nStringPixelWidth > rc.cx)
		{
			if (uFormat & 0x4000)
			{
				int nPathStrLen = nStringRealLen - 2;
				int nFileNameStrLen = 1;
				while (nPathStrLen>=0)
				{
					if (lpString[nPathStrLen] != '\\')
					{
						--nPathStrLen;
						++nFileNameStrLen;
						continue;
					}

					if (nPathStrLen >= 3)
					{
						const WCHAR *PathName = nPathStrLen != 0 ? lpString : 0;
						++nFileNameStrLen;
						if (&lpString[nPathStrLen] && nPathStrLen > 3)
						{
							int nEllipsesBegineOffset = 0; //???
							int nFileNamePixelWidth;
							if (uFormat & 0x40)
								nFileNamePixelWidth = GetTextExtentTabExpend(&lpString[nPathStrLen], nStringPixelWidth, nFileNameStrLen);
							else	nFileNamePixelWidth = GetTextExtent(&lpString[nPathStrLen], nFileNameStrLen, 0);

							if (nFileNamePixelWidth + nEllipsisStringPixelWidth >= rc.cx)
							{
								if (uFormat & 2) coordinateX = rc.x + rc.cx - nFileNamePixelWidth;
								else
								if (uFormat & 1) coordinateX = nCenterPos + nFileNamePixelWidth/2;

								nEllipsesBegineOffset = nStringPixelWidth;

								ShowString[0].coordinateX = coordinateX;
								ShowString[0].ShowString = WSTR("...");
								ShowString[0].nShowLen = 3;
								ShowString[0].nPixelWidth = nEllipsisStringPixelWidth;

								ShowString[1].coordinateX = ShowString[0].coordinateX + ShowString[0].nPixelWidth;
								ShowString[1].ShowString = &lpString[nPathStrLen];
								ShowString[1].nShowLen = nFileNameStrLen;
								ShowString[1].nPixelWidth = nFileNamePixelWidth;
								nShowStringCounter = 2;
							} else
							{
								int w = rc.cx - nFileNamePixelWidth - nEllipsisStringPixelWidth;
								int nPathShowStrLen;
								int nPathNamePixelWidth;
								if (uFormat & 0x40)
								{
									nPathShowStrLen = GetMaxShowCharNum(PathName, w, nTabPixelWidth, nPathStrLen);
									nPathNamePixelWidth = GetTextExtentTabExpend(PathName, nStringPixelWidth, nPathShowStrLen);
								} else
								{
									nPathShowStrLen = GetMaxShowCharNum(PathName, w, 0, nPathStrLen);
									nPathNamePixelWidth = GetTextExtent(PathName, nPathShowStrLen, 0);
								}
								int delta = w - nPathNamePixelWidth;

								nEllipsesBegineOffset = nPathShowStrLen;

								if (nPathStrLen - nPathShowStrLen < 3) break;

								if (uFormat & 2) coordinateX += delta;
								else
								if (uFormat & 1) coordinateX += delta/2;

								ShowString[0].coordinateX = coordinateX;
								ShowString[0].ShowString = PathName;
								ShowString[0].nShowLen = nPathShowStrLen;
								ShowString[0].nPixelWidth = nPathNamePixelWidth;

								ShowString[1].coordinateX = ShowString[0].coordinateX + ShowString[0].nPixelWidth;
								ShowString[1].ShowString = WSTR("...");
								ShowString[1].nShowLen = 3;
								ShowString[1].nPixelWidth = nEllipsisStringPixelWidth;

								ShowString[2].coordinateX = ShowString[1].coordinateX + ShowString[1].nPixelWidth;
								ShowString[2].ShowString = &lpString[nPathStrLen];
								ShowString[2].nShowLen = nFileNameStrLen;
								ShowString[2].nPixelWidth = nFileNamePixelWidth;
								nShowStringCounter = 3;
							}

							if (uFormat & 0x10000)
							{
						#if 0 //TODO ASSERT const*
								PathName[nEllipsesBegineOffset+0]='.';
								PathName[nEllipsesBegineOffset+1]='.';
								PathName[nEllipsesBegineOffset+2]='.';
								int i = 0;
								for (i = 0; i < nFileNameStrLen; ++i)
								{
									PathName[nEllipsesBegineOffset+3+i]=lpString[i];
								}
								lpString[i]=0;
						#endif
							}
						}
					}
					break;
				}
			} else
			if (uFormat & 0x8000)
			{
				int l;
				if (uFormat & 3)
					l = rc.cx - nEllipsisStringPixelWidth;
				else	l = rc.cx - nEllipsisStringPixelWidth/2 + 1;

				int Len = 0; //???
				int PixelWidth = 0; //???
				if (uFormat & 0x40)
				{
					Len = GetMaxShowCharNum(lpString, l, nStringRealLen, nTabPixelWidth);
					PixelWidth = GetTextExtentTabExpend(lpString, nStringPixelWidth, Len);
				} else
				{
					Len = GetMaxShowCharNum(lpString, l, nStringRealLen, -1);
					PixelWidth = GetTextExtent(lpString, Len, 0);
				}

				if (uFormat & 1) coordinateX += (l - PixelWidth)/2;
				else
				if (uFormat & 2) coordinateX += (l - PixelWidth);

				int v32 = PixelWidth + ShowString[0].coordinateX;

				ShowString[1].coordinateX = v32;
				ShowString[1].ShowString = WSTR("...");
				ShowString[1].nShowLen = 3;
				ShowString[1].nPixelWidth = nEllipsisStringPixelWidth;

				ShowString[0].coordinateX = coordinateX;

				ShowString[0].nShowLen = Len;
				
				nShowStringCounter = 2;

				if (uFormat & 0x10000)
				{
			#if 0 //TODO ASSERT const*
					for (int i = 0; i < 3; ++i)
					{
						if (Len+i>=nStringRealLen) break;
						lpString[Len+i] = '.';
					}
			#endif
				}
			}
		}

		if (uFormat & 0x40)
		{
			for (int i = 0; i < nShowStringCounter; ++i)
				DrawTabExpendString(ShowString[i].coordinateX, coordinateY,
					ShowString[i].ShowString, ShowString[i].nShowLen, rc, nTabPixelWidth);
		} else
		{
			for (int i = 0; i < nShowStringCounter; ++i)
				DrawString(ShowString[i].coordinateX, coordinateY,
					ShowString[i].ShowString, ShowString[i].nShowLen, 0, 0);
		}		
		return m_pFont->m_Height; //GetTextHeight
	}

	int CWispDC::DrawString(CWispFont *pLogFont, int x, int y, const WCHAR *pStr, unsigned long TextColor, WISP_RECT *pClipRect, unsigned long *pBKColor, int Len, int nTabPixelWidth, int bFlag)
	{
		WCHAR szBuffer[MAX_SHORT_NAME_LEN+1];
		//int BitOffset = 0;
		int nStartx = x;
		while (Len)
		{
			const WCHAR Char = pStr[0];
			if (Char == 0) break;
			if (bFlag)
			{
				szBuffer[0] = Char;
				szBuffer[1] = 0;
			} else
			if (Char == 9)
			{
				int n = ROUNDREVERSE(nTabPixelWidth, m_TabAlign); //??? 32
				MAX_LIMIT(n, MAX_SHORT_NAME_LEN);
				szBuffer[n] = 0;
				while (n-- > 0)
					szBuffer[n] = 0x20;
			} else
			if (Char != 10)
			{
				szBuffer[0] = Char;
				szBuffer[1] = 0;
			} else
				break;
			
			int i = 0;
			while (szBuffer[i] != 0)
			{
				unsigned char *pFont = pLogFont->GetCharPixelBuffer(szBuffer[i]);
				int Width = pLogFont->GetCharWidth(szBuffer[i]);
				int BitOffset = 0; //???
				for (int h = 0; h < pLogFont->m_Height; ++h) //??? =
				{
					int PosX = x;
					int PosY = y + h;
					for (int w = 0; w < Width; ++w) //??? =
					{
						if (PtInRect(pClipRect, PosX ,PosY))
						{
							if (GET_BIT(pFont, BitOffset))
							{
								m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, PosX, PosY, TextColor);
							} else
							if (pBKColor)
							{
								m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, PosX, PosY, *pBKColor);
							}
						}
						++BitOffset;
						++PosX;
					}
				}
				x += Width;
				++nTabPixelWidth;
				//BitOffset = 0;
				++i;
			}
			++pStr;
			--Len;
		}
		return x - nStartx;
	}
	int CWispDC::DrawString(int x, int y, const WCHAR *pStr, int Len, int nTabPixelWidth, int bFlag)
	{
		WISP_RECT rect;

		rect.x = x + m_pRect->x;
		rect.y = y + m_pRect->y;
		rect.cx = GetTextExtent(pStr, Len, 0);
		rect.cy = m_pFont->m_Height;

		if (!ClipDCRect(&rect))
			return 0;

		return DrawString(m_pFont, x + m_pRect->x, y + m_pRect->y, pStr, m_TextColor, &rect,
			(m_TextStyle & 1 ) ? &m_TextBKColor : 0, Len, nTabPixelWidth, bFlag);
	}
	int CWispDC::DrawString(WISP_RECT *pRect, const WCHAR *pStr, int Len, int nTabPixelWidth)
	{
		WISP_RECT rc = *pRect;

		rc.x += m_pRect->x;
		rc.y += m_pRect->y;

		if (!ClipDCRect(&rc))
			return 0;

		return DrawString(m_pFont,
				(pRect->x + m_pRect->x),
				(pRect->y + m_pRect->y) + (pRect->cy - m_pFont->m_Height) / 2,
				pStr,
				m_TextColor, &rc, 0, Len, nTabPixelWidth, 0);
	}
	void CWispDC::DrawShadowText(WISP_RECT *pRect, const WCHAR *pStr, int Offset, int Len, int nTabPixelWidth)
	{
		WISP_RECT rc = *pRect;

		rc.x += m_pRect->x;
		rc.y += m_pRect->y;

		if (ClipDCRect(&rc))
		{
			unsigned long shadowColor = m_TextShadowColor;

			unsigned long OrgTextColor = m_TextColor;
			m_TextColor = shadowColor;
			int y = (pRect->y + m_pRect->y) + (pRect->cy - m_pFont->m_Height) / 2;
			int x = (pRect->x + m_pRect->x);

			DrawString(m_pFont, x + Offset, y + Offset,
						pStr, m_TextColor, &rc, 0, Len, nTabPixelWidth, 0);

			m_TextColor = OrgTextColor;

			DrawString(m_pFont, x, y, pStr, m_TextColor, &rc, 0, Len, nTabPixelWidth, 0);
		}
	}

	int CWispDC::DrawColorString(CWispFont *pLogFont, int x, int y, const unsigned long *pStr, WISP_RECT *pClipRect, int Len, int nTabPixelWidth)
	{
		WCHAR szBuffer[MAX_SHORT_NAME_LEN+1]; //???
	//	int BitOffset = 0;
		int nStartx = x;

		if (m_pColor == 0)
			m_pColor = m_pWispBase->m_pWispDrawObj->m_crSystem;

		while (Len)
		{
			const WCHAR Char = LOW_WORD(pStr[0]);
			if (Char == 0) break;
			if (Char == 9)
			{
				int n = ROUNDREVERSE(nTabPixelWidth, m_TabAlign); //??? 32
				MAX_LIMIT(n, MAX_SHORT_NAME_LEN);
				szBuffer[n] = 0;
				while (n-- > 0)
					szBuffer[n] = 0x20;
			} else
			if (Char != 10)
			{
				szBuffer[0] = Char;
				szBuffer[1] = 0;
			} else
				break;

			unsigned short Color = HIGH_WORD(pStr[0]);
			unsigned char BKClr = HIGH_BYTE(Color);
			unsigned char TextClr = LOW_BYTE(Color);
			
			int i = 0;
			while (szBuffer[i] != 0)
			{
				unsigned char *pFont = pLogFont->GetCharPixelBuffer(szBuffer[i]);
				int Width = pLogFont->GetCharWidth(szBuffer[i]);

				if (x + Width >= pClipRect->x && x < pClipRect->x + pClipRect->cx)
				{
					int BitOffset = 0;
					for (int h = 0; h < pLogFont->m_Height; ++h) //??? =
					{
						int PosX = x;
						int PosY = y + h;
						for (int w = 0; w < Width; ++w)
						{
							if (PtInRect(pClipRect, PosX, PosY))
							{
								if (GET_BIT(pFont, BitOffset))
								{
									m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, PosX, PosY, m_pColor[TextClr]);
								} else
								if (BKClr)
								{
									m_pFrameBuffer->pWispDrawHAL->DrawPixel(m_pFrameBuffer, PosX, PosY, m_pColor[BKClr]);
								}
							}
							++PosX;
							++BitOffset;
						}
					}
				}
				x += Width;
				++nTabPixelWidth;				
				++i;
			}
			++pStr;
			--Len;
		}
		return x - nStartx;
	}
	int CWispDC::DrawColorString(int x, int y, const unsigned long *pStr, int Len, int nTabPixelWidth)
	{
		WISP_RECT rect;

		rect.x = x + m_pRect->x;
		rect.y = y + m_pRect->y;
		rect.cx = m_pRect->x + m_pRect->cx - x;
		rect.cy = m_pFont->m_Height;

		if (!ClipDCRect(&rect))
			return 0;

		return DrawColorString(m_pFont, x + m_pRect->x, y + m_pRect->y,
				pStr, &rect, Len, nTabPixelWidth);
	}
	int CWispDC::DrawColorString(WISP_RECT *pRect, const unsigned long *pStr, int Len, int nTabPixelWidth)
	{
		WISP_RECT rc = *pRect;

		rc.x += m_pRect->x;
		rc.y += m_pRect->y;

		if (!ClipDCRect(&rc))
			return 0;

		return DrawColorString(m_pFont,
				pRect->x + m_pRect->x,
				pRect->y + m_pRect->y + (pRect->cy - m_pFont->m_Height) / 2,
				pStr, &rc, Len, nTabPixelWidth);
	}

```

`source/Wisp/wispdc.hpp`:

```hpp

#ifndef _WISPDC_HPP_
#define _WISPDC_HPP_

#include "../Code/define.h"
#include "utility.hpp"
#include "wispfont.hpp"
#include "wispdib.hpp"
#include "wispdraw.hpp"

	//forward decl

	struct CWispBase; //???
	struct CWispBaseWnd; //???

struct CWispDC
{
	CWispBaseWnd *m_pWispWnd;
	CWispBase *m_pWispBase;
	WISP_FRAME_BUFFER_INFO *m_pFrameBuffer;
	WISP_RECT *m_pRect;
	unsigned long *m_pColor;
	CWispFont *m_pFont;
	unsigned long m_TextColor;
	unsigned long m_TextShadowColor;
	unsigned long m_TextBKColor;

	unsigned long m_OldTextColor;
	unsigned long m_OldTextShadowColor;
	unsigned long m_OldTextBKColor;

	unsigned int m_TextStyle;
	WISP_RECT *m_pClipRect;
	unsigned long m_TabAlign;

	unsigned long GetTextColor() { return m_TextColor; }
	void SetTextColor(unsigned long TextColor)
	{
		m_OldTextColor = m_TextColor;
		m_TextColor = TextColor;
	}
	void SetTextColor() { m_TextColor = m_OldTextColor; }


	unsigned long GetTextShadowColor() { return m_TextShadowColor; }
	void SetTextShadowColor(unsigned long TextShadowColor)
	{
		m_OldTextShadowColor = m_TextShadowColor;
		m_TextShadowColor = TextShadowColor;
	}
	void SetTextShadowColor() { m_TextShadowColor = m_OldTextShadowColor; }

	unsigned long GetTextBKColor() { return m_TextBKColor; }
	void SetTextBKColor(unsigned long TextBKColor)
	{
		m_OldTextBKColor = m_TextBKColor;
		m_TextBKColor = TextBKColor;
	}
	void SetTextBKColor() { m_TextBKColor = m_OldTextBKColor; }

	void SetTextStyle(unsigned int TextStyle);

	void SetTextType(unsigned int FontIndex);

	CWispDC();
	~CWispDC();

	bool Create(CWispBaseWnd *pWispWnd, WISP_RECT *pRect);
	void Destroy();

	void SetFontAndColor();

	bool Create(WISP_FRAME_BUFFER_INFO *pFrameBuffer, WISP_RECT *pRect);
	CWispDC *CreateNull(WISP_FRAME_BUFFER_INFO *pFrameBuffer, WISP_RECT *pRect);
	bool Create(CWispDIB *pDIB);

	bool IsRectVisible(WISP_RECT *pRect);
	bool ClipDCRect(WISP_RECT *pRect);
	bool ClipDCLine(int *pX1, int *pY1, int *pX2, int *pY2);
	bool ClipDCPoint(WISP_POINT *pPT);

	void DrawPixel(int x, int y, unsigned long color);
	void DrawVLine(int x, int y1, int y2, unsigned long color);
	void DrawHLine(int x1, int x2, int y, unsigned long color);
	void DrawVDashLine(int x, int y1, int y2, unsigned long color);
	void DrawHDashLine(int x1, int x2, int y, unsigned long color);
	void DrawLine(int x1, int y1, int x2, int y2, unsigned long color);
	void DrawCircle(int, int, int, unsigned long);

	void DrawCircleRightTop(int x, int y, int radius, unsigned long color);
	void DrawCircleRightBottom(int x, int y, int radius, unsigned long color);
	void DrawCircleLeftTop(int x, int y, int radius, unsigned long color);
	void DrawCircleLeftBottom(int x, int y, int radius, unsigned long color);
//!!
	void CirclePlotPointsRightTop(int xCenter, int yCenter, int x, int y, unsigned long color, WISP_RECT *pClipRect);
	void CirclePlotPointsRightBottom(int xCenter, int yCenter, int x, int y, unsigned long color, WISP_RECT *pClipRect);
	void CirclePlotPointsLeftTop(int xCenter, int yCenter, int x, int y, unsigned long color, WISP_RECT *pClipRect);
	void CirclePlotPointsLeftBottom(int xCenter, int yCenter, int x, int y, unsigned long color, WISP_RECT *pClipRect);

	void DrawRect(WISP_RECT *pRc, unsigned long color);
	void DrawRect(int x, int y, int cx, int cy, unsigned long color);

	void DrawRoundRect(WISP_RECT *pRc, unsigned long color);
	void Draw3DRect(WISP_RECT *pRc, unsigned long crTopLeft, unsigned long crBottomRight);
	void DrawDashRect(WISP_RECT *pRc, unsigned long color);

	void DrawFullRect(WISP_RECT *pRc, unsigned long color);
	void DrawFullRect(int x, int y, int cx, int cy, unsigned long color);

	unsigned long DrawXGrayChgFullRect(WISP_RECT *pRc, unsigned long color, int nChg);
	unsigned long DrawYGrayChgFullRect(WISP_RECT *pRc, unsigned long color, int nChg);

	void DrawXGrayColorFullRect(unsigned long color1, unsigned long color2, WISP_RECT *pRc);
	void DrawYGrayColorFullRect(unsigned long color1, unsigned long color2, WISP_RECT *pRc);

	void DrawXGrayColorFullRect2(unsigned long color1, unsigned long color2, WISP_RECT *pRc);
	void DrawYGrayColorFullRect2(unsigned long color1, unsigned long color2, WISP_RECT *pRc);

	void DrawFrameRect(WISP_RECT *pRc, bool bRaised, int Deep);
	void DrawFrameRect(int x, int y, int cx, int cy, bool bRaised, int Deep);

	void DrawDIBTiled(CWispDIB *pDIB, WISP_RECT *pRect);

	void DrawDIB(int x, int y, CWispDIB *pDIB);
	void DrawDIB(WISP_RECT *pRect, CWispDIB *pDIB);

	void DrawDIBGray(int x, int y, CWispDIB *pDIB);
	void DrawDIBGray(WISP_RECT *pRect, CWispDIB *pDIB);

	void DrawSystemStandardIcon(WISP_RECT *rcBoundary, unsigned int uStyle, unsigned long color);

	int GetTextHeight(const WCHAR Char);
	int GetTextLen(const WCHAR *lpString, int nStrLen);
	int GetTextExtent(const WCHAR *lpString, int nStrLen, int Count);
	int GetTextExtentTabExpend(const WCHAR *lpString, int nTabPixelWidth, int nCount);
	int GetTextExtentLineTabExpend(const WCHAR *lpString, int nTabPixelWidth, int nCount);


//	int DrawSingleLineText(WCHAR*, int, WISP_RECT*, unsigned int); //private


	int CalcTextLineNum(const WCHAR *lpString, int nCount);
	int CalcDrawTextRect(const WCHAR *lpString, WISP_RECT *lpRect, int nStrLen, unsigned int uFormat, int nTabPixelWidth);
	int GetMaxShowCharNum(const WCHAR *lpString, int nMaxWidth, int nTabPixelWidth, int nCount);
	int DrawTabExpendString(int x, int y, const WCHAR *lpString, int nStringRealLen, WISP_RECT rc, int nTabPixelWidth);

	void AdjustNoClipRect(WISP_RECT *lpRect, unsigned int uFormat);

	int DrawString(const WCHAR *lpString, WISP_RECT *lpRect, unsigned int uFormat, unsigned int nShowLen, int nPreLineMaxCharNum);
//??	void DrawString(int x, int y, const WCHAR *string, int Len, WISP_RECT *pClipRect);

//??	void DrawColorString(int x, int y, const unsigned long  *string, int Len, WISP_RECT *pClipRect);
//??	void DrawRightString(int, int, const WCHAR*, int, WISP_RECT*);
//??	void DrawShadowText(int, int, const WCHAR*, int, int);


	int DrawString(CWispFont *pLogFont, int x, int y, const WCHAR *pStr, unsigned long TextColor, WISP_RECT *pClipRect, unsigned long *pBKColor, int Len, int nTabPixelWidth, int bFlag);
	int DrawString(int x, int y, const WCHAR *pStr, int Len, int nTabPixelWidth, int bFlag);
	int DrawString(WISP_RECT *pRect, const WCHAR *pStr, int Len, int nTabPixelWidth);
	void DrawShadowText(WISP_RECT *pRect, const WCHAR *pStr, int Offset, int Len, int nTabPixelWidth);

	int DrawColorString(CWispFont *pLogFont, int x, int y, const unsigned long *pStr, WISP_RECT *pClipRect, int Len, int nTabPixelWidth);
	int DrawColorString(int x, int y, const unsigned long *pStr, int Len, int nTabPixelWidth);
	int DrawColorString(WISP_RECT *pRect, const unsigned long *pStr, int Len, int nTabPixelWidth);
};

#endif
```

`source/Wisp/wispdib.cpp`:

```cpp

#include "wispdib.hpp"
#include "wispbase.hpp"

	CWispDIB::CWispDIB()
		{
			m_PixelBuf.VideoBuffer = 0;
			m_Pal = 0;
			m_bAutoDelete = 0;
			m_RefCount = 0;
			m_PixelBuf.Height = 0;
			m_PixelBuf.Width = 0;
		}

	CWispDIB::~CWispDIB()
		{
			if (!m_bAutoDelete)
				Destroy();
		}

	void CWispDIB::CreatePaint()
		{
			m_PixelBuf.LineDistance = 4 * m_PixelBuf.Width;
			m_PixelBuf.VideoBufferSize = 4 * m_PixelBuf.Width * m_PixelBuf.Height;
			m_PixelBuf.VideoBuffer = new unsigned char[m_PixelBuf.VideoBufferSize];
			m_PaintRect.y = 0;
			m_PaintRect.x = 0;
			m_PixelBuf.Bpp = 32;
			m_PaintRect.cx = m_PixelBuf.Width;
			m_PaintRect.cy = m_PixelBuf.Height;
			m_PixelBuf.pWispDrawHAL = &gpCurWisp->m_Draw32Bit;
		}

	void CWispDIB::FillColor(unsigned long Color)
		{
			//TMemSet(&m_PixelBuf.VideoBuffer[1], Color, m_PixelBuf.VideoBufferSize / (m_PixelBuf.Bpp/8));

			int Len = m_PixelBuf.VideoBufferSize / (m_PixelBuf.Bpp/8);
			while (Len>0)
			{
				((DWORD*)m_PixelBuf.VideoBuffer)[Len] = Color;
				--Len;
			}
		}

	bool CWispDIB::Create(int Width, int Height, unsigned int Type, WISP_POINT *pHotPT, unsigned long ColorKey)
		{
			m_PixelBuf.Width = Width;
			m_PixelBuf.Height = Height;
			m_ColorKey = ColorKey;
			m_Type = Type;
			if (pHotPT)
			{
				m_HotPT.y = pHotPT->x;
				m_HotPT.x = pHotPT->y;

			} else
			{
				m_HotPT.y = 0;
				m_HotPT.x = 0;
			}

			CreatePaint();
			return true;
		}

	void CWispDIB::SetType(unsigned int Type)
		{
			m_Type = Type;
		}

	void CWispDIB::SetColorKey(unsigned long ColorKey)
		{
			if (m_Type != 2) //COLORREF_PF_555
				m_Type = 2; //COLORREF_PF_555
			m_ColorKey = ColorKey;
		}

	void CWispDIB::SetHotPoint(WISP_POINT *pHotPT)
		{
			m_HotPT.x = pHotPT->x;
			m_HotPT.y = pHotPT->y;
		}

	void CWispDIB::SetHotPoint(int x, int y)
		{
			m_HotPT.x = x;
			m_HotPT.y = y;
		}

	bool CWispDIB::GetPixel(int PosX, int PosY, unsigned long *pPixel)
		{
			if (PosX < 0 || PosY < 0)
				return false;

			if (PosX >= m_PixelBuf.Width || PosY >= m_PixelBuf.Height)
				return false;

			*pPixel = *(unsigned long*)((unsigned char*)m_PixelBuf.VideoBuffer+PosX*(32/8) + PosY*m_PixelBuf.LineDistance);
			return true;
		}

	void CWispDIB::Blt(const WISP_RECT & SrcRect, CWispDIB *pDesDIB, int x, int y)
		{
			if (!m_PixelBuf.VideoBuffer)
				return;
			
			WISP_RECT DrawRC;
			WISP_RECT ClipRC;

			ClipRC.x = 0;
			ClipRC.y = 0;
			ClipRC.cx = pDesDIB->m_PixelBuf.Width;
			ClipRC.cy = pDesDIB->m_PixelBuf.Height;

			DrawRC.x = x;
			DrawRC.y = y;
			DrawRC.cx = SrcRect.cx;
			DrawRC.cy = SrcRect.cy;

			if (!ClipRect(&DrawRC, &ClipRC))
				return;
			
			for (int dy = 0; dy < DrawRC.cy; ++dy)
			{
				for (int dx = 0; dx < DrawRC.cx; ++dx)
				{
	((DWORD*)pDesDIB->m_PixelBuf.VideoBuffer)[ x+dx + (y+dy)*pDesDIB->m_PixelBuf.Width ] =
	((DWORD*)m_PixelBuf.VideoBuffer)[ SrcRect.x+dx + (SrcRect.y+dy)*m_PixelBuf.Width ];
				}
			}
			
		}

#pragma pack(push,1)
struct BITMAP_FILE_HEADER
{
  /* 0x0000 */ unsigned short bfType;	//0x4D42
  /* 0x0002 */ unsigned short bfSizeLow;
  /* 0x0004 */ unsigned short bfSizeHigh;
  /* 0x0006 */ unsigned short bfReserved1;
  /* 0x0008 */ unsigned short bfReserved2;
  /* 0x000a */ unsigned short bfOffBitsLow;
  /* 0x000c */ unsigned short bfOffBitsHigh;
}; /* size: 0x000e */

struct BITMAP_INFO_HEADER
{
  /* 0x0000 */ unsigned long biSize;
  /* 0x0004 */ long biWidth;
  /* 0x0008 */ long biHeight;
  /* 0x000c */ unsigned short biPlanes;
  /* 0x000e */ unsigned short biBitCount;
  /* 0x0010 */ unsigned long biCompression;
  /* 0x0014 */ unsigned long biSizeImage;
  /* 0x0018 */ long biXPelsPerMeter;
  /* 0x001c */ long biYPelsPerMeter;
  /* 0x0020 */ unsigned long biClrUsed;
  /* 0x0024 */ unsigned long biClrImportant;
}; /* size: 0x0028 */
#pragma pack(pop)

	bool CWispDIB::Load(const char *FileName, int Index)
		{
			CImageFile BmpFile;

			BmpFile.ChangeFileIO(&gpCurWisp->m_PFSFileIO);

			if (gpCurWisp->m_PFSFileIO.GetFileAttr(FileName) & 0x20) //PFS_ARCHIVE
			{
				unsigned long Size = gpCurWisp->m_PFSFileIO.GetFileSize(FileName);
				if (Size == 0 || Size == -1)
					return false;

				if (!BmpFile.Create(Size, 0, 0))
					return false;

				gpCurWisp->m_PFSFileIO.ReadFromFile(FileName, BmpFile.m_Buffer, Size);
			} else
			if (!BmpFile.Open(FileName, 0))
				return false;

			m_Pal = 0;

			BITMAP_FILE_HEADER bmFileHead;
			BmpFile.ReadFile(0, &bmFileHead, sizeof(bmFileHead));
			if (bmFileHead.bfType != 0x4D42)
			{
				BmpFile.Close();
				return LoadIcon(FileName, Index);
			}

			int dwSize = MAKE_DWORD(bmFileHead.bfSizeHigh,bmFileHead.bfSizeLow) - sizeof(bmFileHead);
			BITMAP_INFO_HEADER *pbmInfo = (BITMAP_INFO_HEADER *)new unsigned char[dwSize+4];

			if (!BmpFile.ReadFile(pbmInfo, dwSize) ||
				pbmInfo->biCompression || 
				pbmInfo->biBitCount == 16 ||
				pbmInfo->biSize != sizeof(BITMAP_INFO_HEADER) )
			{
				BmpFile.Close();
				delete [](unsigned char*)pbmInfo;
				return false;
			}

			m_ColorKey = 0;
			m_HotPT.y = 0;
			m_HotPT.x = 0;
			m_PixelBuf.Width = pbmInfo->biWidth;
			m_PixelBuf.Height = ABS(pbmInfo->biHeight);
			m_Type = 1; //BMP COLORREF_PF_PAL

			int Bpp = ALIGNUP(pbmInfo->biBitCount, 8);
			int PicW = ALIGN_SIZE(Bpp * m_PixelBuf.Width, 4);
			int PicH = m_PixelBuf.Height;

			CreatePaint();

			if (pbmInfo->biBitCount == 8)
			{
				m_Pal = new unsigned long[256];
				for (int i = 0; i < 256; ++i)
					m_Pal[i] = _RT_PDWORD(RT_PDWORD(pbmInfo, sizeof(BITMAP_INFO_HEADER)))[i];

				unsigned char *pPixel = (unsigned char *)pbmInfo + MAKE_DWORD(bmFileHead.bfOffBitsHigh,bmFileHead.bfOffBitsLow) + PicW*PicH - sizeof(BITMAP_FILE_HEADER);

				if (gpCurWisp->m_FrameBufferInfo.Bpp == 8)
				{
					int Off = 0;
					for (int h = 0; h < m_PixelBuf.Height; ++h)
					{
						pPixel -= PicW;
						for (int w = 0; w < m_PixelBuf.Width; ++w)
							((DWORD*)m_PixelBuf.VideoBuffer)[Off++] = pPixel[w];
					}
				} else
				{
					int Off = 0;
					for (int h = 0; h < m_PixelBuf.Height; ++h)
					{
						pPixel -= PicW;
						for (int w = 0; w < m_PixelBuf.Width; ++w)
							((DWORD*)m_PixelBuf.VideoBuffer)[Off++] = m_Pal[pPixel[w]];
					}
				}	
			} else
			{
				unsigned char *pPixel = (unsigned char *)pbmInfo + sizeof(BITMAP_INFO_HEADER) + PicW*PicH;
				int Off = 0;
				for (int h = 0; h < m_PixelBuf.Height; ++h)
				{
					pPixel -= PicW;
					unsigned char *pOrgPixel = pPixel;
					for (int w = 0; w < m_PixelBuf.Width; ++w)
					{
						((DWORD*)m_PixelBuf.VideoBuffer)[Off++] = GET_DWORD(pPixel, 0) & 0xffffff;
						pPixel += Bpp;
					}
					pPixel = pOrgPixel;
				}
			}

			BmpFile.Close();
			delete [](unsigned char*)pbmInfo;
			return true;
		}

#pragma pack(push,1)
struct ICON_DIR
{
  /* 0x0000 */ unsigned short idReserved;
  /* 0x0002 */ unsigned short idType;
  /* 0x0004 */ unsigned short idCount;
}; /* size: 0x0006 */

struct ICON_DIR_ENTRY
{
  /* 0x0000 */ unsigned char bWidth;
  /* 0x0001 */ unsigned char bHeight;
  /* 0x0002 */ unsigned char bColorCount;
  /* 0x0003 */ unsigned char bReserved;
  /* 0x0004 */ unsigned short wPlanes;
  /* 0x0006 */ unsigned short wBitCount;
  /* 0x0008 */ unsigned long dwBytesInRes;
  /* 0x000c */ unsigned long dwImageOffset;
}; /* size: 0x0010 */
#pragma pack(pop)
#if 0
	void CWispDIB::LoadIcon(const ICON_DIR_ENTRY & IconDirEntry)
		{
			m_PixelBuf.Width = IconDirEntry.bWidth;
			m_PixelBuf.Height = IconDirEntry.bHeight;
			m_HotPT.y = 0;
			m_HotPT.x = 0;
			m_Type = 2; //ICO COLORREF_PF_555
			m_ColorKey = 0;
			int Bpp = ALIGNUP(IconDirEntry.wBitCount, 8);
			CreatePaint();

			BITMAP_INFO_HEADER *pIcon = (BITMAP_INFO_HEADER *)new unsigned char[IconDirEntry.dwBytesInRes];
			IconFile.ReadFile(IconDirEntry.dwImageOffset, pIcon, IconDirEntry.dwBytesInRes);
			if (Bpp == 0)
				Bpp = ALIGNUP(pIcon->biBitCount, 8);

			int PicW = ALIGN_SIZE(Bpp * m_PixelBuf.Width, 4);
			int PicH = m_PixelBuf.Height;

			if (IconDirEntry.wBitCount == 8)
			{
				m_Pal = new unsigned long[256];
				for (int i = 0; i < 256; ++i)
					m_Pal[i] = _RT_PDWORD(RT_PDWORD(pIcon, sizeof(BITMAP_INFO_HEADER)))[i];

				unsigned char *pPixel = (unsigned char *)pIcon + sizeof(BITMAP_INFO_HEADER) + 256*4 + PicW*PicH;

				if (gpCurWisp->m_FrameBufferInfo.Bpp == 8)
				{
					int Off = 0;
					for (int h = 0; h < m_PixelBuf.Height; ++h)
					{
						pPixel -= PicW;
						for (int w = 0; w < m_PixelBuf.Width; ++w)
							((DWORD*)m_PixelBuf.VideoBuffer)[Off++] = pPixel[w];
					}
				} else
				{
					int Off = 0;
					for (int h = 0; h < m_PixelBuf.Height; ++h)
					{
						pPixel -= PicW;
						for (int w = 0; w < m_PixelBuf.Width; ++w)
							((DWORD*)m_PixelBuf.VideoBuffer)[Off++] = m_Pal[pPixel[w]];
					}
				}	
			} else
			{
				unsigned char *pPixel = (unsigned char *)pIcon + sizeof(BITMAP_INFO_HEADER) + PicW*PicH;
				int Off = 0;
				for (int h = 0; h < m_PixelBuf.Height; ++h)
				{
					pPixel -= PicW;
					unsigned char *pOrgPixel = pPixel;
					for (int w = 0; w < m_PixelBuf.Width; ++w)
					{
						((DWORD*)m_PixelBuf.VideoBuffer)[Off++] = GET_DWORD(pPixel, 0) & 0xffffff;
						pPixel += Bpp;
					}
					pPixel = pOrgPixel;
				}
			}
			delete [](unsigned char*)pIcon;
		}
#endif
	bool CWispDIB::LoadIcon(const char *FileName, int Index)
		{
			CImageFile IconFile;

			IconFile.ChangeFileIO(&gpCurWisp->m_PFSFileIO);

			if (gpCurWisp->m_PFSFileIO.GetFileAttr(FileName) & 0x20) //???
			{
				unsigned long Size = gpCurWisp->m_PFSFileIO.GetFileSize(FileName);
				if (Size == 0 || Size == -1)
					return false;

				if (!IconFile.Create(Size, 0, 0))
					return false;

				gpCurWisp->m_PFSFileIO.ReadFromFile(FileName, IconFile.m_Buffer, Size);
			} else
			if (!IconFile.Open(FileName, 0))
				return false;

			ICON_DIR IconDir;
			IconFile.ReadFile(&IconDir, sizeof(IconDir));

			if (IconDir.idType != 1 || IconDir.idReserved)
			{
				IconFile.Close();
				return false;
			}

			int DirOffset = sizeof(IconDir);

			if (Index < 0)
				Index = IconDir.idCount-1;

			for (int i = 0; i < IconDir.idCount; ++i)
			{
				ICON_DIR_ENTRY IconDirEntry;
				IconFile.ReadFile(DirOffset, &IconDirEntry, sizeof(ICON_DIR_ENTRY));
				if (i == Index)
				{
					//LoadIcon(IconDirEntry);

					m_PixelBuf.Width = IconDirEntry.bWidth;
					m_PixelBuf.Height = IconDirEntry.bHeight;
					m_HotPT.y = 0;
					m_HotPT.x = 0;
					m_Type = 2; //ICO COLORREF_PF_555
					m_ColorKey = 0;
					int Bpp = ALIGNUP(IconDirEntry.wBitCount, 8);
					CreatePaint();

					BITMAP_INFO_HEADER *pIcon = (BITMAP_INFO_HEADER *)new unsigned char[IconDirEntry.dwBytesInRes];
					IconFile.ReadFile(IconDirEntry.dwImageOffset, pIcon, IconDirEntry.dwBytesInRes);
					if (Bpp == 0)
						Bpp = ALIGNUP(pIcon->biBitCount, 8);

					int PicW = ALIGN_SIZE(Bpp * m_PixelBuf.Width, 4);
					int PicH = m_PixelBuf.Height;

					if (IconDirEntry.wBitCount == 8)
					{
						m_Pal = new unsigned long[256];
						for (int i = 0; i < 256; ++i)
							m_Pal[i] = _RT_PDWORD(RT_PDWORD(pIcon, sizeof(BITMAP_INFO_HEADER)))[i];

						unsigned char *pPixel = (unsigned char *)pIcon + sizeof(BITMAP_INFO_HEADER) + 256*4 + PicW*PicH;

						if (gpCurWisp->m_FrameBufferInfo.Bpp == 8)
						{
							int Off = 0;
							for (int h = 0; h < m_PixelBuf.Height; ++h)
							{
								pPixel -= PicW;
								for (int w = 0; w < m_PixelBuf.Width; ++w)
									((DWORD*)m_PixelBuf.VideoBuffer)[Off++] = pPixel[w];
							}
						} else
						{
							int Off = 0;
							for (int h = 0; h < m_PixelBuf.Height; ++h)
							{
								pPixel -= PicW;
								for (int w = 0; w < m_PixelBuf.Width; ++w)
									((DWORD*)m_PixelBuf.VideoBuffer)[Off++] = m_Pal[pPixel[w]];
							}
						}	
					} else
					{
						unsigned char *pPixel = (unsigned char *)pIcon + sizeof(BITMAP_INFO_HEADER) + PicW*PicH;
						int Off = 0;
						for (int h = 0; h < m_PixelBuf.Height; ++h)
						{
							pPixel -= PicW;
							unsigned char *pOrgPixel = pPixel;
							for (int w = 0; w < m_PixelBuf.Width; ++w)
							{
								((DWORD*)m_PixelBuf.VideoBuffer)[Off++] = GET_DWORD(pPixel, 0) & 0xffffff;
								pPixel += Bpp;
							}
							pPixel = pOrgPixel;
						}
					}
					delete [](unsigned char*)pIcon;

					break;
				}
				DirOffset += sizeof(ICON_DIR_ENTRY);
			}

			IconFile.Close();
			return IconDir.idCount>0;
		}

	void CWispDIB::Destroy()
		{
			SafeDeleteAry(m_PixelBuf.VideoBuffer);
			SafeDeleteAry(m_Pal);

			if (m_bAutoDelete)
				delete this;
		}

	bool CWispDIB::Write(const char *FileName)
		{
			if (!m_PixelBuf.VideoBuffer)
				return false;

			BITMAP_INFO_HEADER bmpHeader;

			bmpHeader.biWidth = m_PixelBuf.Width;
			bmpHeader.biHeight = m_PixelBuf.Height;
			bmpHeader.biSize = sizeof(BITMAP_INFO_HEADER);
			bmpHeader.biPlanes = 1;
			bmpHeader.biBitCount = m_PixelBuf.Bpp;

			int dwDibSize = bmpHeader.biHeight * bmpHeader.biWidth * (bmpHeader.biBitCount / 8);

			BITMAP_FILE_HEADER bmpFileHeader;

			bmpFileHeader.bfType = 0x4D42;
			bmpFileHeader.bfOffBitsLow = sizeof(BITMAP_INFO_HEADER)+sizeof(BITMAP_FILE_HEADER); //0x36;
			bmpFileHeader.bfOffBitsHigh = 0;
			bmpFileHeader.bfSizeLow  = LOW_WORD(dwDibSize + bmpFileHeader.bfOffBitsLow);
			bmpFileHeader.bfSizeHigh = HIGH_WORD(dwDibSize + bmpFileHeader.bfOffBitsLow);
			bmpFileHeader.bfReserved2 = 0;
			bmpFileHeader.bfReserved1 = 0;

			bmpHeader.biCompression = 0;
			bmpHeader.biSizeImage = dwDibSize;
			bmpHeader.biXPelsPerMeter = 0;
			bmpHeader.biYPelsPerMeter = 0;
			bmpHeader.biClrUsed = 0;
			bmpHeader.biClrImportant = 0;

			unsigned long *pPic = new unsigned long[bmpHeader.biHeight * bmpHeader.biWidth];
			if (!pPic)
				return false;

			CImageFileStream BmpFile;

			if (!BmpFile.Create(FileName, 0))
			{
				delete []pPic;
				return false;
			}

			BmpFile.Write(&bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
			BmpFile.Write(&bmpHeader, sizeof(BITMAP_INFO_HEADER));

			int PicW = m_PixelBuf.Width;
			int PicH = m_PixelBuf.Height;

			int dbDibSize = dwDibSize/4;

			unsigned long *pPixel = pPic+(PicH*PicW);

			int Off = 0;
			for (int h = 0; h < m_PixelBuf.Height; ++h)
			{
				pPixel -= PicW;
				for (int w = 0; w < m_PixelBuf.Width; ++w)
					pPixel[w] = ((DWORD*)m_PixelBuf.VideoBuffer)[Off++];
			}

			BmpFile.Write(pPic, dbDibSize * 4);
			BmpFile.Close();
			delete []pPic;
			return true;
		}

	void CWispDIB::BltTiled(CWispDIB *pDIB) //???
		{
			//TODO
		}
//

	CWispDIBList::CWispDIBList()
		{
			m_DIBList = 0;
			m_RefCount = 0;
		}
	CWispDIBList::~CWispDIBList()
		{
			Destroy();
		}

	CWispDIB *CWispDIBList::GetDIB(int ID)
		{
			if (ID > m_Count) return nullptr; //ASSERT
			return &m_DIBList[ID]; //???
		}

	bool CWispDIBList::Load(const char *FileName, int TileWidth, int TileHeight, int Count)
		{
			CWispDIB WholeDIB;

			if (!WholeDIB.Load(FileName, -1))
				return false;

			if (!Count)
				Count = WholeDIB.m_PixelBuf.Width * WholeDIB.m_PixelBuf.Height / (TileHeight * TileWidth);

			m_DIBList = new CWispDIB[Count];

			if (WholeDIB.m_PixelBuf.Height > 0 && WholeDIB.m_PixelBuf.Width > 0) //???
			{
				int n = 0;
				for (int y = 0; y < WholeDIB.m_PixelBuf.Height; y += TileHeight)
					for (int x = 0; x < WholeDIB.m_PixelBuf.Width; x += TileWidth)
					{
						if (n >= Count) break;

						m_DIBList[n].Create(TileWidth, TileHeight, 1, 0, 0);
						WISP_RECT Rect;
						Rect.x = x;
						Rect.y = y;
						Rect.cx = TileWidth;
						Rect.cy = TileHeight;
						WholeDIB.Blt(Rect, &m_DIBList[n], 0, 0);
						n++;
					}
			}

			WholeDIB.Destroy();
			m_Count = Count;
		
			return true;
		}	

	bool CWispDIBList::LoadIcon(const char *FileName)
		{
			CImageFile IconFile;

			IconFile.ChangeFileIO(&gpCurWisp->m_PFSFileIO);
			if (!IconFile.Open(FileName, 0))
				return false;

			ICON_DIR IconDir;
			IconFile.ReadFile(&IconDir, sizeof(IconDir));

			if (IconDir.idType != 1 || IconDir.idReserved)
			{
				IconFile.Close();
				return false;
			}

			m_Count = IconDir.idCount;
			m_DIBList = new CWispDIB[m_Count];

			int DirOffset = sizeof(IconDir);

			for (int i = 0; i < m_Count; ++i)
			{
				ICON_DIR_ENTRY IconDirEntry;
				IconFile.ReadFile(DirOffset, &IconDirEntry, sizeof(ICON_DIR_ENTRY));
				//if (i == Index)
				//{

				m_DIBList[i].m_PixelBuf.Width = IconDirEntry.bWidth;
				m_DIBList[i].m_PixelBuf.Height = IconDirEntry.bHeight;
				m_DIBList[i].m_HotPT.y = 0;
				m_DIBList[i].m_HotPT.x = 0;
				m_DIBList[i].m_Type = 2; //ICO COLORREF_PF_555
				m_DIBList[i].m_ColorKey = 0;
				int Bpp = ALIGNUP(IconDirEntry.wBitCount, 8);
				m_DIBList[i].CreatePaint();

				BITMAP_INFO_HEADER *pIcon = (BITMAP_INFO_HEADER *)new unsigned char[IconDirEntry.dwBytesInRes];
				IconFile.ReadFile(IconDirEntry.dwImageOffset, pIcon, IconDirEntry.dwBytesInRes);
				if (Bpp == 0)
					Bpp = ALIGNUP(pIcon->biBitCount, 8);

				int PicW = ALIGN_SIZE(Bpp * m_DIBList[i].m_PixelBuf.Width, 4);
				int PicH = m_DIBList[i].m_PixelBuf.Height;

				if (IconDirEntry.wBitCount == 8)
				{
					m_DIBList[i].m_Pal = new unsigned long[256];
					for (int i = 0; i < 256; ++i)
						m_DIBList[i].m_Pal[i] = _RT_PDWORD(RT_PDWORD(pIcon, sizeof(BITMAP_INFO_HEADER)))[i];
	
					unsigned char *pPixel = (unsigned char *)pIcon + sizeof(BITMAP_INFO_HEADER) + 256*4 + PicW*PicH;

					if (gpCurWisp->m_FrameBufferInfo.Bpp == 8)
					{
						int Off = 0;
						for (int h = 0; h < m_DIBList[i].m_PixelBuf.Height; ++h)
						{
							pPixel -= PicW;
							for (int w = 0; w < m_DIBList[i].m_PixelBuf.Width; ++w)
								((DWORD*)m_DIBList[i].m_PixelBuf.VideoBuffer)[Off++] = pPixel[w];
						}
					} else
					{
						int Off = 0;
						for (int h = 0; h < m_DIBList[i].m_PixelBuf.Height; ++h)
						{
							pPixel -= PicW;
							for (int w = 0; w < m_DIBList[i].m_PixelBuf.Width; ++w)
								((DWORD*)m_DIBList[i].m_PixelBuf.VideoBuffer)[Off++] = m_DIBList[i].m_Pal[pPixel[w]];
						}
					}	
				} else
				{
					unsigned char *pPixel = (unsigned char *)pIcon + sizeof(BITMAP_INFO_HEADER) + PicW*PicH;
					int Off = 0;
					for (int h = 0; h < m_DIBList[i].m_PixelBuf.Height; ++h)
					{
						pPixel -= PicW;
						unsigned char *pOrgPixel = pPixel;
						for (int w = 0; w < m_DIBList[i].m_PixelBuf.Width; ++w)
						{
							((DWORD*)m_DIBList[i].m_PixelBuf.VideoBuffer)[Off++] = GET_DWORD(pPixel, 0) & 0xffffff;
							pPixel += Bpp;
						}
						pPixel = pOrgPixel;
					}
				}
	
				delete [](unsigned char*)pIcon;

				//	break;
				//}
				DirOffset += sizeof(ICON_DIR_ENTRY);
			}
			IconFile.Close();
			return m_Count > 0;
		}

	void CWispDIBList::Destroy()
		{
			SafeDeleteAry(m_DIBList);
		}

	void CWispDIBList::SetType(unsigned int Type)
		{
			for (int i = 0; i < m_Count; ++i)
			{
				m_DIBList[i].SetType(Type);
			}
		}

	void CWispDIBList::SetColorKey(unsigned long ColorKey)
		{
			for (int i = 0; i < m_Count; ++i)
			{
				m_DIBList[i].SetColorKey(ColorKey);
			}
		}

//
	void CWispDIBLib::ReleaseAll()
		{
			m_DIBMap.clear();
			m_DIBListMap.clear();
		}

	void CWispDIBLib::Remove(const char *FileName)
	{
		map<TAnsiString, CWispDIBList>::IT it = m_DIBListMap.find(FileName);
		if (it != m_DIBListMap.end())
		{
			it->second.m_RefCount--;
			if (it->second.m_RefCount < 1)
				m_DIBListMap.erase(it);
		}

	}

	CWispDIBList *CWispDIBLib::GetDIBList(const char *FileName, int TileWidth, int TileHeight, int Count)
		{
			map<TAnsiString, CWispDIBList>::IT it = m_DIBListMap.find(FileName);
			if (it != m_DIBListMap.end())
			{
				it->second.m_RefCount++;
				return &it->second;
			}
	{
			map<TAnsiString, CWispDIBList>::IT it = m_DIBListMap.insert(_Tmap_pair<TAnsiString, CWispDIBList>(FileName, CWispDIBList()));
		//	if (p.second == false) //??? TODO remove
		//	{
		//		p.first->second.m_RefCount++;
		//		return &p.first->second;
		//	}

			if (it->second.Load(FileName, TileWidth, TileHeight, Count))
			{
				it->second.m_RefCount++;
				return &it->second;
			}
			m_DIBListMap.erase(it);
	}
			return nullptr;
		}

	CWispDIBList *CWispDIBLib::LoadDIBList(const char *FileName, int TileWidth, int TileHeight, int Count, unsigned long ColorKey)
		{
			CWispDIBList *pDIBList = GetDIBList(FileName, TileWidth, TileHeight, Count);
			if (!pDIBList)
				return nullptr;
			pDIBList->SetColorKey(ColorKey);
			return pDIBList;
		}


	CWispDIB *CWispDIBLib::GetDIB(const char *FileName, int Index)
		{
			char szFilePath[MAX_FN_LEN];

			TStrCpy(szFilePath, FileName);

			char *pName = TStrRChr(szFilePath, '\\');
			if (!pName)
				pName = szFilePath;

			char *delim = TStrChr(pName, '#');
			if (delim)
			{
				int x, y;
				if (sscanf(delim, "#%d#%d:%d", &x, &y, &Index) != 3)
					return nullptr;
				*delim = 0;
				return LoadDIBList(szFilePath, x, y, 0, 0xFF00FF)->GetDIB(Index);
			}

			delim = TStrRChr(pName, ':');
			if (delim)
			{
				*delim = 0;
				if (!USDecStrToNum(delim+1, &Index))	//???
					return nullptr;
			}

			map<TAnsiString, CWispDIB>::IT it = m_DIBMap.find(FileName);
			if (it != m_DIBMap.end())
			{
				it->second.m_RefCount++;
				return &it->second;
			}
	{
			map<TAnsiString, CWispDIB>::IT it = m_DIBMap.insert(_Tmap_pair<TAnsiString, CWispDIB>(FileName, CWispDIB()));
		//	if (p.second == false) //??? TODO remove
		//	{
		//		p.first->second.m_RefCount++;
		//		return &p.first->second;
		//	}

			if (it->second.Load(szFilePath, Index))
			{
				it->second.m_RefCount++;
				return &it->second;
			}
			m_DIBMap.erase(it);
	}
			return nullptr;
		}

	CWispDIB *CWispDIBLib::LoadDIB(const char *FileName, int Index, unsigned long ColorKey)
		{
			CWispDIB *pDIB = GetDIB(FileName, Index);
			if (!pDIB)
				return nullptr;
			pDIB->SetColorKey(ColorKey);
			return pDIB;
		}


```

`source/Wisp/wispdib.hpp`:

```hpp

#ifndef _WISPDIB_HPP_
#define _WISPDIB_HPP_

#include "../Code/define.h"
#include "../Code/alt/altmap.hpp"
#include "../Code/tstrmem.hpp"
#include "utility.hpp"
#include "wispdraw.hpp"

enum PIXEL_FORMAT
{
  COLORREF_PF_DEFAULT = 0,
  COLORREF_PF_PAL = 1,
  COLORREF_PF_555 = 2, //15
  COLORREF_PF_565 = 3, //16
  COLORREF_PF_888 = 4, //24
  COLORREF_PF_COUNT = 5,
};

struct CWispDIB
{
	CWispDIB();
	~CWispDIB();

	WISP_FRAME_BUFFER_INFO m_PixelBuf;
	WISP_RECT m_PaintRect;
	unsigned int m_Type; //0=?,1=BMP,2=ICO,3=?
	unsigned long m_ColorKey;
	WISP_POINT m_HotPT;
	unsigned long *m_Pal;
	bool m_bAutoDelete;
	int m_RefCount;

	void CreatePaint();
	void FillColor(unsigned long Color);
	bool Create(int Width, int Height, unsigned int Type, WISP_POINT *pHotPT, unsigned long ColorKey);
	void SetType(unsigned int Type);
	void SetColorKey(unsigned long ColorKey);
	void SetHotPoint(WISP_POINT *pHotPT);
	void SetHotPoint(int x, int y);
	bool GetPixel(int PosX, int PosY, unsigned long *pPixel);
	void Blt(const WISP_RECT & SrcRect, CWispDIB *pDesDIB, int x, int y);
	bool Load(const char *FileName, int Index);
//	void LoadIcon(const ICON_DIR_ENTRY & IconDirEntry);
	bool LoadIcon(const char *FileName, int Index);
	void Destroy();
	bool Write(const char *FileName);
	void BltTiled(CWispDIB *pDIB); //???
};

enum WISP_DIBLIST_ID
{
  WISP_DIBLIST_MIN = 0,
  WISP_DIBLIST_MAX = 1,
  WISP_DIBLIST_NORMAL = 2,
  WISP_DIBLIST_CLOSE = 3,
  WISP_DIBLIST_HORZ_DEC = 4,
  WISP_DIBLIST_HORZ_INC = 5,
  WISP_DIBLIST_VERT_DEC = 6,
  WISP_DIBLIST_VERT_INC = 7,
  WISP_DIBLIST_COUNT = 8,
};

struct CWispDIBList
{
	CWispDIBList();
	~CWispDIBList();

	CWispDIB *m_DIBList;
	int m_RefCount;
	int m_Count;


	CWispDIB *GetDIB(int ID);

	bool Load(const char *FileName, int TileWidth, int TileHeight, int Count);
	bool LoadIcon(const char *FileName);
	void Destroy();
	void SetType(unsigned int Type);
	void SetColorKey(unsigned long ColorKey);
};

struct CWispDIBLib
{
	map<TAnsiString, CWispDIB> m_DIBMap;
	map<TAnsiString, CWispDIBList> m_DIBListMap;

	void ReleaseAll();

	void Remove(const char *FileName);

	CWispDIBList *GetDIBList(const char *FileName, int TileWidth, int TileHeight, int Count); //LoadDIBList
	//16,16,0,0xFF00FF
	CWispDIBList *LoadDIBList(const char *FileName, int TileWidth, int TileHeight, int Count, unsigned long ColorKey);

	CWispDIB *GetDIB(const char *FileName, int Index); //LoadDIB
	CWispDIB *LoadDIB(const char *FileName, int Index, unsigned long ColorKey);
};

#endif


```

`source/Wisp/wispdraw.cpp`:

```cpp

#include <string.h>
#include "../Code/define.h"
#include "wispdraw.hpp"

	void CWispDrawHAL::DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
		}
	void CWispDrawHAL::DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
		}
	void CWispDrawHAL::SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color)
		{
		}
	unsigned long CWispDrawHAL::GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y)
		{
			return 0; 
		}
	void CWispDrawHAL::CopyToPixel(void *pDes, void *pSrc, int Count)
		{
		}
	void CWispDrawHAL::CopyFromPixel(void *pDes, void *pSrc, int Count)
		{
		}
	//4

	void CWispDraw4Bit::DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(4/8)+y*pFrameBuffer->LineDistance;
			if (x%2)
				*buf |= (Color&0xf);
			else	*buf |= (Color&0xf)<<4;
		}
	void CWispDraw4Bit::DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(4/8)+y*pFrameBuffer->LineDistance;
			if (x%2)
				*buf ^= (Color&0xf);
			else	*buf ^= (Color&0xf)<<4;
		}
	void CWispDraw4Bit::SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(4/8)+y*pFrameBuffer->LineDistance;
			if (x%2)
			{
				*buf++ |= (Color&0xf);
				--Count;
			}

			while (Count--)
			{
				*buf++ |= (Color&0xf)<<4| (Color&0xf);
			}

		}
	unsigned long CWispDraw4Bit::GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(4/8)+y*pFrameBuffer->LineDistance;
			return x%2 ? (*buf&0xf) : (*buf&0xf)<<4; //???
		}
	void CWispDraw4Bit::CopyToPixel(void *pDes, void *pSrc, int Count)
		{
			BYTE *Des=(BYTE*)pDes;
			DWORD *Src=(DWORD*)pSrc;
			int Index = 0;
			while (Index < Count)
			{
				BYTE Color = (Src[Index] & 0xf)<<4;
				++Index;
				if (Index<Count)
					Color |= (Src[Index] & 0xf);
				++Index;
				*Des++=Color;
			}
		}
	void CWispDraw4Bit::CopyFromPixel(void *pDes, void *pSrc, int Count)
		{
			DWORD *Des=(DWORD*)pDes;
			BYTE *Src=(BYTE*)pSrc;
			int Index = 0;
			while (Index < Count)
			{
				Des[Index] = (*Src>>4)&0xf;
				++Index;
				if (Index<Count)
					Des[Index] |= (*Src & 0xf);
				++Index;
				++Src;
			}
		}

	//8

	void CWispDraw8Bit::DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
			{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(8/8)+y*pFrameBuffer->LineDistance;
			*buf++ = (Color>>0)&0xff; //???
		}
	void CWispDraw8Bit::DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(8/8)+y*pFrameBuffer->LineDistance;
			*buf++ ^= (Color>>0)&0xff;

		}
	void CWispDraw8Bit::SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(8/8)+y*pFrameBuffer->LineDistance;
			while (Count--)
			{
				*buf++= (Color>>0)&0xff;
			}
		}
	unsigned long CWispDraw8Bit::GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(8/8)+y*pFrameBuffer->LineDistance;
			return (unsigned long)buf[0];
		}
	void CWispDraw8Bit::CopyToPixel(void *pDes, void *pSrc, int Count)
		{
			BYTE *Des=(BYTE*)pDes;
			BYTE *Src=(BYTE*)pSrc;
			while (Count--)
			{
				*Des++ = *Src++;
				Src++;
				Src++;
				Src++;
			}
		}
	void CWispDraw8Bit::CopyFromPixel(void *pDes, void *pSrc, int Count)
		{
			BYTE *Des=(BYTE*)pDes;
			BYTE *Src=(BYTE*)pSrc;
			while (Count--)
			{
				*Des++ = *Src++;
				*Des++ = 0;
				*Des++ = 0;
				*Des++ = 0;
			}
		}

	//16

	void CWispDraw16Bit::DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(16/8)+y*pFrameBuffer->LineDistance;
			*(WORD*)buf = ((Color >> 3) & 0x1F) | ((Color >> 5) & 0x7E0) | ((Color >> 8) & 0xF800);
		}
	void CWispDraw16Bit::DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(16/8)+y*pFrameBuffer->LineDistance;
			*(WORD*)buf ^= Color & 0xffff;
		}
	void CWispDraw16Bit::SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(16/8)+y*pFrameBuffer->LineDistance;
			while (Count--)
			{
				*(WORD*)buf = ((Color >> 3) & 0x1f) | ((Color >> 5) & 0x7E0) | ((Color >> 8) & 0xF800);
				buf += 2;
			}
		}
//The RGB565 pixel data:
//    a red pixel   (1111 1000 0000 0000) F800  11
//    a green pixel (0000 0111 1110 0000) 7E0 5
//    a blue pixel  (0000 0000 0001 1111) 1F 0

	unsigned long CWispDraw16Bit::GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(16/8)+y*pFrameBuffer->LineDistance;
			WORD word = *(WORD*)buf;
			return ((word & 0xF8)<<12) | ((word & 0x7E)<<4) | ((word & 0x1F)<<0); //????
		}
	void CWispDraw16Bit::CopyToPixel(void *pDes, void *pSrc, int Count)
		{
			WORD *Des=(WORD*)pDes;
			DWORD *Src=(DWORD*)pSrc;
			while (Count--)
			{
				*Des=((*Src >> 3) & 0x1F) | ((*Src >> 5) & 0x7E0) | ((*Src >> 8) & 0xF800);
				++Des;
				++Src;
			}
		}
	void CWispDraw16Bit::CopyFromPixel(void *pDes, void *pSrc, int Count)
		{
			DWORD *Des=(DWORD*)pDes;
			WORD *Src=(WORD*)pSrc;
			while (Count--)
			{
				*Des=((*Src & 0x7C00) << 12) | ((*Src & 0x3E0) << 8) | ((*Src & 0x1F) << 4);
				++Des;
				++Src;
			}
		}

	//24

	void CWispDraw24Bit::DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(24/8)+y*pFrameBuffer->LineDistance;
			*buf++ = (Color>>0)&0xff;
			*buf++ = (Color>>8)&0xff;
			*buf++ = (Color>>16)&0xff;
		}
	void CWispDraw24Bit::DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(24/8)+y*pFrameBuffer->LineDistance;
			*buf++ ^= (Color>>0)&0xff;
			*buf++ ^= (Color>>8)&0xff;
			*buf++ ^= (Color>>16)&0xff;
		}
	void CWispDraw24Bit::SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(24/8)+y*pFrameBuffer->LineDistance;
			while (Count--)
			{
				*buf++= (Color>>0)&0xff;
				*buf++= (Color>>8)&0xff;
				*buf++= (Color>>16)&0xff;
			}
		}
	unsigned long CWispDraw24Bit::GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(24/8)+y*pFrameBuffer->LineDistance;
			return  ((unsigned long)buf[2]<<16) |
				((unsigned long)buf[1]<< 8) |
				((unsigned long)buf[0]<< 0);
		}
	void CWispDraw24Bit::CopyToPixel(void *pDes, void *pSrc, int Count)
		{
			BYTE *Des=(BYTE*)pDes;
			BYTE *Src=(BYTE*)pSrc;
			while (Count--)
			{
				*Des++ = *Src++;
				*Des++ = *Src++;
				*Des++ = *Src++;
					  Src++;
			}
		}                              	
	void CWispDraw24Bit::CopyFromPixel(void *pDes, void *pSrc, int Count)
		{
			BYTE *Des=(BYTE*)pDes;
			BYTE *Src=(BYTE*)pSrc;
			while (Count--)
			{
				*Des++ = *Src++;
				*Des++ = *Src++;
				*Des++ = *Src++;
				 Des++;
			}
		}

	//32

	void CWispDraw32Bit::DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(32/8)+y*pFrameBuffer->LineDistance;
			*buf++ = (Color>>0)&0xff;
			*buf++ = (Color>>8)&0xff;
			*buf++ = (Color>>16)&0xff;
			*buf++ = (Color>>24)&0xff;
		}
	void CWispDraw32Bit::DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(32/8)+y*pFrameBuffer->LineDistance;
			*buf++ ^= (Color>>0)&0xff;
			*buf++ ^= (Color>>8)&0xff;
			*buf++ ^= (Color>>16)&0xff;
			*buf++ ^= (Color>>24)&0xff;
		}
	void CWispDraw32Bit::SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(32/8)+y*pFrameBuffer->LineDistance;
			while (Count--)
			{
				*buf++= (Color>>0)&0xff;
				*buf++= (Color>>8)&0xff;
				*buf++= (Color>>16)&0xff;
				*buf++= (Color>>24)&0xff;
			}
		}
	unsigned long CWispDraw32Bit::GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y)
		{
			BYTE *buf = (BYTE*)pFrameBuffer->VideoBuffer+x*(32/8)+y*pFrameBuffer->LineDistance;
			return  ((unsigned long)buf[3]<<24) |
				((unsigned long)buf[2]<<16) |
				((unsigned long)buf[1]<< 8) |
				((unsigned long)buf[0]<< 0);
		}
	void CWispDraw32Bit::CopyToPixel(void *pDes, void *pSrc, int Count)
		{
			BYTE *Des=(BYTE*)pDes;
			BYTE *Src=(BYTE*)pSrc;
			while (Count--)
			{
				*Des++ = *Src++;
				*Des++ = *Src++;
				*Des++ = *Src++;
				*Des++ = *Src++;
			}
		}
	void CWispDraw32Bit::CopyFromPixel(void *pDes, void *pSrc, int Count)
		{
			BYTE *Des=(BYTE*)pDes;
			BYTE *Src=(BYTE*)pSrc;
			while (Count--)
			{
				*Des++ = *Src++;
				*Des++ = *Src++;
				*Des++ = *Src++;
				*Des++ = *Src++;
			}
		}


```

`source/Wisp/wispdraw.hpp`:

```hpp

#ifndef _WISPDRAW_HPP_
#define _WISPDRAW_HPP_

#include "../Code/define.h"

struct CWispDrawHAL;

struct WISP_FRAME_BUFFER_INFO
{
	int Width;
	int Height;
	int Bpp;		//Bpp/8
	int PixelFormat;
	unsigned int Flag;
	unsigned char *VideoBuffer; //void *
	unsigned int VideoBufferSize;
	int LineDistance;
	CWispDrawHAL *pWispDrawHAL;


	void *GetStart(int x, int y, int n)
	{ 
		return (void*)((unsigned char*)VideoBuffer+x*(32/n) + y*LineDistance);
	}
};

struct CWispDrawHAL
{
	virtual void DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color);
	virtual void DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color);
	virtual void SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color);
	virtual unsigned long GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y);
	virtual void CopyToPixel(void *pDes, void *pSrc, int Count);
	virtual void CopyFromPixel(void *pDes, void *pSrc, int Count);
};

struct CWispDraw4Bit : public CWispDrawHAL
{
	virtual void DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color) override;
	virtual unsigned long GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y) override;
	virtual void CopyToPixel(void *pDes, void *pSrc, int Count) override;
	virtual void CopyFromPixel(void *pDes, void *pSrc, int Count) override;
};

struct CWispDraw8Bit : public CWispDrawHAL
{
	virtual void DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color) override;
	virtual unsigned long GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y) override;
	virtual void CopyToPixel(void *pDes, void *pSrc, int Count) override;
	virtual void CopyFromPixel(void *pDes, void *pSrc, int Count) override;
};

struct CWispDraw16Bit : public CWispDrawHAL
{
	virtual void DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color) override;
	virtual unsigned long GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y) override;
	virtual void CopyToPixel(void *pDes, void *pSrc, int Count) override;
	virtual void CopyFromPixel(void *pDes, void *pSrc, int Count) override;
};

struct CWispDraw24Bit : public CWispDrawHAL
{
	virtual void DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color) override;
	virtual unsigned long GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y) override;
	virtual void CopyToPixel(void *pDes, void *pSrc, int Count) override;
	virtual void CopyFromPixel(void *pDes, void *pSrc, int Count) override;
};


struct CWispDraw32Bit : public CWispDrawHAL
{
	virtual void DrawPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void DrawXorPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, unsigned long Color) override;
	virtual void SetHLinePixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y, int Count, unsigned long Color) override;
	virtual unsigned long GetPixel(WISP_FRAME_BUFFER_INFO *pFrameBuffer, int x, int y) override;
	virtual void CopyToPixel(void *pDes, void *pSrc, int Count) override;
	virtual void CopyFromPixel(void *pDes, void *pSrc, int Count) override;
};


#endif


```

`source/Wisp/wispdrawobj.cpp`:

```cpp

#include "../Code/tstrmem.hpp"
#include "wispdrawobj.hpp"
#include "wispbase.hpp"
#include "wispbasewnd.hpp"

	CWispDrawObj::CWispDrawObj()
	{
		InitSystemColor();
	}

	CWispDrawObj::~CWispDrawObj()
	{
		//???
	}

	bool CWispDrawObj::Init()
	{
		gpCurWisp->m_MouseCursorSize.cy = 16;
		gpCurWisp->m_MouseCursorSize.cx = 16;
		return true;
	}

	void CWispDrawObj::Release()
	{
		//???
	}

	void CWispDrawObj::InitSystemColor()
	{
		m_crSystem[0] = 0;
		m_crSystem[1] = 0xFFFFFF;
		m_crSystem[2] = 0xC00000;
		m_crSystem[3] = 0xFF0000;
		m_crSystem[4] = 0xC000;
		m_crSystem[5] = 0xFF80;
		m_crSystem[6] = 0xC0;
		m_crSystem[7] = 0x80FF;
		m_crSystem[8] = 0x804040;
		m_crSystem[9] = 0xC86464;
		m_crSystem[10] = 0xC0C0;
		m_crSystem[11] = 0xFFFF;
		m_crSystem[12] = 0x808080;
		m_crSystem[13] = 0xC8C8C8;
		m_crSystem[14] = 0xC0C000;
		m_crSystem[15] = 0xFFFF00;
		m_crSystem[16] = 0x804000;
		m_crSystem[17] = 0xFF8000;

		m_crSystem[18] = 0;
		m_crSystem[19] = 0xC8C8C8;
		m_crSystem[20] = 0xECE9D8;
		m_crSystem[21] = 0;
		m_crSystem[22] = 0xFFFFFF;
		m_crSystem[23] = 0x2398C8;
		m_crSystem[24] = 0x50B0FF;
		m_crSystem[25] = 0x80FF;
		m_crSystem[26] = 0x64C8FA;
		m_crSystem[27] = 0x3C8CDC;
		m_crSystem[28] = 0x82E6;
		m_crSystem[29] = 0xDCDCDC;
		m_crSystem[30] = 0x555555;
		m_crSystem[31] = 0xAAAAAA;
		m_crSystem[32] = 0x50E6FF;
		m_crSystem[33] = 0x32B4E6;
		m_crSystem[34] = 0xFF;

		m_crSystem[35] = 0x7F9DB9;
		m_crSystem[36] = 0x7F9DB9;
		m_crSystem[37] = 0x1C5180;
		m_crSystem[38] = 0xFFFFFF;
		m_crSystem[39] = 0xF3F3EF;
		m_crSystem[40] = 0xE2E1DA;
		m_crSystem[41] = 0xA0A0A0;
		m_crSystem[42] = 0xC0C0C0;
		m_crSystem[43] = 0xF8B330;
		m_crSystem[44] = 0xFFD664;
		m_crSystem[45] = 0xFFFFFF;
		m_crSystem[46] = 0;
		m_crSystem[47] = 0x80;
		m_crSystem[48] = 0xFF;
		m_crSystem[49] = 0x316AC5;

		m_crSystem[50] = 0xB4C8E4;
		m_crSystem[51] = 0xD2E6FF;
		m_crSystem[52] = 0x8A867A;

		m_crSystem[53] = 0x50B0FF;
		m_crSystem[54] = 0xFFFF;
		m_crSystem[55] = 0xFFFFFF;
		m_crSystem[56] = 0x21A121;
		m_crSystem[57] = 0;

		m_crSystem[58] = 0x76B1E5;
		m_crSystem[59] = 0xB4D6F1;
		m_crSystem[60] = 0x6492B9;

		m_crSystem[61] = 0xEBEADB;
		m_crSystem[62] = 0xFFFFFF;
		m_crSystem[63] = 0xC7C5B2;
		m_crSystem[64] = 0xE2DECD;
		m_crSystem[65] = 0xD6D2C2;
		m_crSystem[66] = 0xCBC7B8;

		m_crSystem[67] = 0xF3F3F3;
		m_crSystem[68] = 0xF8A900;
		m_crSystem[69] = 0xF9C654;
		m_crSystem[70] = 0xF8B31F;

		m_crSystem[71] = 0xABEDAC;
		m_crSystem[72] = 0x95E996;
		m_crSystem[73] = 0x7CE47E;
		m_crSystem[74] = 0x66DF68;
		m_crSystem[75] = 0x4EDA50;
		m_crSystem[76] = 0x35D538;
		m_crSystem[77] = 0x28D22B;

		m_crSystem[78] = 0xC88200;
		m_crSystem[79] = 0xE59700;
		m_crSystem[80] = 0xF8B330;
		m_crSystem[81] = 0xFDD889;

		m_crSystem[82] = 0x3D95FF;
		m_crSystem[83] = 0x2B90FF;
		m_crSystem[84] = 0x55EA;
		m_crSystem[85] = 0x46E0;
		m_crSystem[86] = 0x143CF;
		m_crSystem[87] = 0x3DDC;
		m_crSystem[88] = 0x1DA0;
		m_crSystem[89] = 0x138C;

		m_crSystem[90] = 0x7B7B7B;
		m_crSystem[91] = 0xE0E8FE;
		m_crSystem[92] = 0xF1F1F1;
		m_crSystem[93] = 0xE7EBFF;
		m_crSystem[94] = 0x6B79BD;

		m_crSystem[95] = 0xACA899;
		m_crSystem[96] = 0xF1EFE2;
		m_crSystem[97] = 0x716F64;
		m_crSystem[98] = 0xDEDFD8;
		m_crSystem[99] = 0xA5A597;
		m_crSystem[100] = 0xC1C2B8;
		m_crSystem[101] = 0xD0D1C9;
		m_crSystem[102] = 0xB4FAD4;
		m_crSystem[103] = 0x64C8FF;
		m_crSystem[104] = 0xFFAAAA;
		m_crSystem[105] = 0x9BFF;
		m_crSystem[106] = 0xB42828;
		m_crSystem[107] = 0x70A2F3;
		m_crSystem[108] = 0xC5C2B8;
		m_crSystem[109] = 0xFF00;
		m_crSystem[110] = 0xFF00FF;
		m_crSystem[111] = 0xFAFACC;
		m_crSystem[112] = 0x21A221;
		m_crSystem[113] = 0x7BA2E7;
		m_crSystem[114] = 0x6375D6;
		m_crSystem[115] = 0xB4B1A3;
	}
	void CWispDrawObj::DrawBorder(CWispDC *pDC, WISP_RECT *pRect, int nSize)
	{
		WISP_RECT rc = *pRect;

		if (nSize >= 1)
		{
			pDC->DrawRoundRect(&rc, m_crSystem[28]);
			++rc.x;
			++rc.y;
			rc.cx -= 2;
			rc.cy -= 2;
		}

		if (nSize >= 2)
		{
			pDC->DrawRect(&rc, m_crSystem[28]);
			++rc.x;
			++rc.y;
			rc.cx -= 2;
			rc.cy -= 2;
		}

		if (nSize >= 3)
		{
			nSize -= 3;
			if (nSize > 0)
			{
				int n = nSize;
				while (n)
				{
					pDC->DrawRect(&rc, m_crSystem[28]);
					++rc.x;
					++rc.y;
					rc.cx -= 2;
					rc.cy -= 2;
					--n;
				}
			}
		}

		if (nSize >= 1)
			pDC->DrawRect(&rc, m_crSystem[28]);
	}
	void CWispDrawObj::DrawCaption(CWispDC *pDC, WISP_RECT *pRect)
	{
		WISP_RECT rc = *pRect;
		pDC->DrawFullRect(&rc, m_crSystem[23]);
	}
	void CWispDrawObj::DrawToolbarBK(CWispDC *pDC, WISP_RECT *pRect)
	{
		pDC->DrawFullRect(pRect, m_crSystem[24]);
	}
	void CWispDrawObj::DrawClient(CWispDC *pDC, WISP_RECT *pRect)
	{
		pDC->DrawFullRect(pRect, m_crSystem[20]);
	}
	void CWispDrawObj::DrawCtrlBorder(CWispDC *pDC, WISP_RECT *pRect, int nSize)
	{
		WISP_RECT rc = *pRect;
		while (nSize > 1)
		{
			pDC->Draw3DRect(&rc, m_crSystem[35], m_crSystem[36]);
			rc.cx -= 2;
			rc.cy -= 2;
			++rc.x;
			++rc.y;
			--nSize;
		}
		pDC->DrawRect(&rc, m_crSystem[38]);

	}
	void CWispDrawObj::DrawCtrlClient(CWispDC *pDC, WISP_RECT *pRect)
	{
		if (pDC->m_pWispWnd->m_Style & 0x200)	//???
			pDC->DrawFullRect(pRect, m_crSystem[19]);
		else	pDC->DrawFullRect(pRect, m_crSystem[38]);

	}
	void CWispDrawObj::DrawCtrlStaticEdge(CWispDC *pDC, WISP_RECT *pRect)
	{
		unsigned long rcBottomRight = m_crSystem[95];
		unsigned long rcTopLef = m_crSystem[1];
		pDC->DrawHLine(pRect->x, pRect->x2() - 2, pRect->y, rcBottomRight);
		pDC->DrawHLine(pRect->x, pRect->x2() - 1, pRect->y2() - 1, rcTopLef);
		pDC->DrawVLine(pRect->x, pRect->y, pRect->y2() - 2, rcBottomRight);
		pDC->DrawVLine(pRect->x2() - 1, pRect->y, pRect->y2() - 1, rcTopLef);
	}
	void CWispDrawObj::DrawCtrlClientEdge(CWispDC *pDC, WISP_RECT *pRect)
	{
		unsigned long rcTopLeft = m_crSystem[95];
		unsigned long rcBottomRight = m_crSystem[97];
		unsigned long rcBottomRight1 = m_crSystem[96];
		unsigned long rcTopLeft1 = m_crSystem[1];

		pDC->DrawHLine(pRect->x, pRect->x2() - 2, pRect->y, rcTopLeft);
		pDC->DrawHLine(pRect->x, pRect->x2() - 1, pRect->y2() - 1, rcTopLeft1);
		pDC->DrawVLine(pRect->x, pRect->y, pRect->y2() - 2, rcTopLeft);
		pDC->DrawVLine(pRect->x2() - 1, pRect->y, pRect->y2() - 1, rcTopLeft1);
		pDC->DrawHLine(pRect->x + 1, pRect->x2() - 3, pRect->y + 1, rcBottomRight);
		pDC->DrawHLine(pRect->x + 1, pRect->x2() - 2, pRect->y2() - 2, rcBottomRight1);
		pDC->DrawVLine(pRect->x + 1, pRect->y + 1, pRect->y2() - 3, rcBottomRight);
		pDC->DrawVLine(pRect->x2() - 2, pRect->y + 1, pRect->y2() - 2, rcBottomRight1);
	}
	void CWispDrawObj::DrawCtrlModalFrame(CWispDC *pDC, WISP_RECT *pRect)
	{
		unsigned long rcTopLeft2;
		unsigned long rcBottomRight2;
		unsigned long rcTopLeft;
		unsigned long rcBottomRight;
		unsigned long rcBottomRight1;
		unsigned long rcTopLeft1;

		unsigned long Color20;
		unsigned long Color96;
		unsigned long Color1;
		unsigned long Color95;
		unsigned long Color97;

		Color20 = m_crSystem[20];
		Color96 = m_crSystem[96];
		Color1 = m_crSystem[1];
		Color95 = m_crSystem[95];
		Color97 = m_crSystem[97];

		pDC->DrawHLine(pRect->x, pRect->x2() - 2, pRect->y, Color96);
		pDC->DrawHLine(pRect->x, pRect->x2() - 1, pRect->y2() - 1, Color97);
		pDC->DrawVLine(pRect->x, pRect->y, pRect->y2() - 2, Color96);
		pDC->DrawVLine(pRect->x2() - 1, pRect->y, pRect->y2() - 1, Color97);
		pDC->DrawHLine(pRect->x + 1, pRect->x2() - 3, pRect->y + 1, Color1);
		pDC->DrawHLine(pRect->x + 1, pRect->x2() - 2, pRect->y2() - 2, Color95);
		pDC->DrawVLine(pRect->x + 1, pRect->y + 1, pRect->y2() - 3, Color1);
		pDC->DrawVLine(pRect->x2() - 2, pRect->y + 1, pRect->y2() - 2, Color95);
		pDC->DrawHLine(pRect->x + 2, pRect->x2() - 4, pRect->y + 2, Color20);
		pDC->DrawHLine(pRect->x + 2, pRect->x2() - 3, pRect->y2() - 3, Color20);
		pDC->DrawVLine(pRect->x + 2, pRect->y + 2, pRect->y2() - 4, Color20);
		pDC->DrawVLine(pRect->x2() - 3, pRect->y + 2, pRect->y2() - 3, Color20);
	}
	void CWispDrawObj::DrawCtrlFocusRect(CWispDC *pDC, WISP_RECT *pRect)
	{
		pDC->DrawDashRect(pRect, m_crSystem[48]);
	}
	void CWispDrawObj::DrawVertScrollRect(CWispDC *pDC, WISP_RECT *pRect)
	{
		pDC->DrawFullRect(pRect, m_crSystem[39]);
	}
	void CWispDrawObj::DrawVertScrollSlideRect(CWispDC *pDC, WISP_RECT *pRect)
	{
		int i;
		WISP_RECT rc = *pRect;

		pDC->DrawRoundRect(&rc, m_crSystem[58]);

		++rc.x;
		++rc.y;
		rc.cx -= 2;
		rc.cy -= 2;
		pDC->DrawRect(&rc, m_crSystem[1]);

		++rc.x;
		++rc.y;
		rc.cx -= 2;
		rc.cy -= 2;
		pDC->DrawFullRect(&rc, m_crSystem[26]);
		if (rc.cy >= 10)
		{
			i = 0;
			do {
				pDC->DrawHLine(
					rc.x + 2,
					rc.cx + rc.x - 3,
					i + rc.y + (rc.cy - 8) / 2, m_crSystem[13]);
				pDC->DrawHLine(
					rc.x + 2,
					rc.cx + rc.x - 3,
					i + rc.y + (rc.cy - 8) / 2 + 1, m_crSystem[12]);
				i += 2;
			} while (i < 8);
		}
	}
	void CWispDrawObj::DrawHorzScrollRect(CWispDC *pDC, WISP_RECT *pRect)
	{
		pDC->DrawFullRect(pRect, m_crSystem[39]);
	}
	void CWispDrawObj::DrawHorzScrollSlideRect(CWispDC *pDC, WISP_RECT *pRect)
	{
		int i;
		WISP_RECT rc = *pRect;

		pDC->DrawRoundRect(&rc, m_crSystem[58]);

		++rc.x;
		++rc.y;
		rc.cx -= 2;
		rc.cy -= 2;
		pDC->DrawRect(&rc, m_crSystem[1]);

		++rc.x;
		++rc.y;
		rc.cx -= 2;
		rc.cy -= 2;
		pDC->DrawFullRect(&rc, m_crSystem[26]);
		if (rc.cx >= 10)
		{
			i = 0;
			do {
				pDC->DrawVLine(
					i + rc.x + (rc.cx - 8) / 2,
					rc.y + 2,
					rc.cy + rc.y - 3, m_crSystem[13]);
				pDC->DrawVLine(
					i + rc.x + (rc.cx - 8) / 2 + 1,
					rc.y + 2,
					rc.cy + rc.y - 3, m_crSystem[12]);
				i += 2;
			} while (i < 8);
		}
	}
	void CWispDrawObj::DrawSplitRect(CWispDC *pDC, WISP_RECT *pRect, bool bHorz)
	{
		pDC->DrawFullRect(pRect, m_crSystem[28]);
	}
	void CWispDrawObj::DrawButtonClient(CWispDC *pDC, WISP_RECT *pRect, unsigned int State)
	{
		if (State == 2) //WISP_BT_DIB_DOWN
			pDC->DrawFullRect(pRect, m_crSystem[40]);
		else	pDC->DrawFullRect(pRect, m_crSystem[39]);
	}
	void CWispDrawObj::DrawButtonFrameRect(CWispDC *pDC, WISP_RECT *pRect, unsigned int State)
	{
		if (State & 0x40)
		{
			if (State == 2) //WISP_BT_DIB_DOWN
			{
				pDC->DrawFrameRect(pRect, 0, 1);
			} else
			if (State == 1) //WISP_BT_DIB_HOVER
			{
				pDC->DrawFrameRect(pRect, 1, 1);
			}
		} else
		{
			if (State == 0) //WISP_BT_DIB_NORMAL
			{
				pDC->DrawRoundRect(pRect, m_crSystem[37]);
			} else
			if (State == 1) //WISP_BT_DIB_HOVER
			{
				WISP_RECT rc = *pRect;
				pDC->DrawRoundRect(&rc, m_crSystem[37]);

				++rc.x;
				++rc.y;
				rc.cx -= 2;
				rc.cy -= 2;
				pDC->DrawRect(&rc, m_crSystem[80]);

				++rc.x;
				++rc.y;
				rc.cx -= 2;
				rc.cy -= 2;
				pDC->DrawRect(&rc, m_crSystem[81]);
			} else
			if (State == 2) //WISP_BT_DIB_DOWN
			{
				WISP_RECT rc = *pRect;

				++rc.x;
				++rc.y;
				rc.cx -= 2;
				rc.cy -= 2;
				pDC->DrawRoundRect(&rc, m_crSystem[37]);
				pDC->DrawRect(&rc, m_crSystem[38]);
			}
		}
	}
	void CWispDrawObj::DrawTabBackground(CWispDC *pDC, WISP_RECT *pRect)
	{
		DrawToolbarBK(pDC, pRect);
	}
	void CWispDrawObj::DrawTabItem(CWispDC *pDC, WISP_RECT *pRect, unsigned int State)
	{
		if (State == 0) //WISP_BT_DIB_NORMAL
		{
			pDC->DrawRoundRect(pRect, m_crSystem[37]);
		} else
		if (State == 1) //WISP_BT_DIB_HOVER
		{
			WISP_RECT rc = *pRect;
			++rc.x;
			++rc.y;
			rc.cx -= 2;
			rc.cy -= 2;

			pDC->DrawRect(&rc, m_crSystem[80]);

			++rc.x;
			++rc.y;
			rc.cx -= 2;
			rc.cy -= 2;
			pDC->DrawRect(&rc, m_crSystem[81]);
			pDC->DrawRoundRect(pRect, m_crSystem[37]);
		}
		if (State == 2) //WISP_BT_DIB_DOWN
		{
			pDC->DrawRoundRect(pRect, m_crSystem[37]);
		}

	}
	void CWispDrawObj::DrawHeaderFrameRect(CWispDC *pDC, WISP_RECT *pRect, unsigned int State)
	{
		unsigned long Color61;
		unsigned long Color64;
		unsigned long Color65;
		unsigned long Color99;
		unsigned long Color98;
		unsigned long Color66;
		unsigned long Color62;
		unsigned long Color63;

		Color61 = m_crSystem[61];
		Color62 = m_crSystem[62];
		Color64 = m_crSystem[64];
		Color63 = m_crSystem[63];
		Color65 = m_crSystem[65];
		Color66 = m_crSystem[66];

		if (State == 1) //WISP_BT_DIB_HOVER
		{
			Color61 = m_crSystem[67];
			Color64 = m_crSystem[68];
			Color65 = m_crSystem[69];
			Color66 = m_crSystem[70];
		} else
		if (State == 2) //WISP_BT_DIB_DOWN
		{
			Color99 = m_crSystem[99];
			Color98 = m_crSystem[98];
			pDC->DrawHLine(pRect->x + 1, pRect->x2(), pRect->y2() - 1, Color99);
			pDC->DrawVLine(pRect->x + 1, pRect->y, pRect->y2() - 1, Color99);
			pDC->DrawFullRect(pRect, Color98);
			return;
		}
		pDC->DrawFullRect(pRect, Color61);
		pDC->DrawHLine(pRect->x, pRect->x2() - 1, pRect->y2() - 3, Color64);
		pDC->DrawHLine(pRect->x, pRect->x2() - 1, pRect->y2() - 2, Color65);
		pDC->DrawHLine(pRect->x, pRect->x2() - 1, pRect->y2() - 1, Color66);
		pDC->DrawLine(pRect->x, pRect->y + 2, pRect->x, pRect->y2() - 5, Color62);
		pDC->DrawLine(pRect->x2() - 1, pRect->y + 2, pRect->x2() - 1, pRect->y2() - 5, Color63);
	}
	void CWispDrawObj::DrawProgress(CWispDC *pDC, WISP_RECT *pRect, unsigned int uStyle, int nPersent)
	{
		pDC->Draw3DRect(pRect, m_crSystem[35], m_crSystem[36]);
		pRect->y += 2;
		pRect->x += 2;
		pRect->cx -= 4;
		pRect->cy -= 4;

		WISP_RECT rcLine;

		rcLine.y = pRect->y;
		rcLine.x = pRect->x;
		rcLine.cy = pRect->cy;
		rcLine.cx = nPersent * pRect->cx / 1000;

		if (rcLine.cx > 0)
		{
			int n = 0;
			while (rcLine.cy > 0) //&& n<6
			{
				pDC->DrawHLine(rcLine.x, rcLine.x2() - 1, rcLine.y, m_crSystem[71+n]);
				pDC->DrawHLine(rcLine.x, rcLine.x2() - 1, rcLine.y2() - 1, m_crSystem[71+n]);
				++rcLine.y;
				rcLine.cy -= 2;
				++n;
				if (n >= 6)
					break;
			}

			pDC->DrawFullRect(&rcLine, m_crSystem[77]);
			for (int i = 6; i < rcLine.cx; i += 7)
				pDC->DrawVLine(i+pRect->x, pRect->y, pRect->y2()-1, m_crSystem[38]);
		}

	}
	void CWispDrawObj::DrawSystemStandardIcon(CWispDC *pDC, WISP_RECT *pRect, unsigned int uStyle, unsigned int State)
	{
		WISP_RECT rect;
		unsigned long color; //???

		switch (uStyle)
		{
		case 0:	//WISP_SSI_VERT_INC_SPIN
		case 1: //WISP_SSI_VERT_DEC_SPIN
		case 2: //WISP_SSI_HORZ_INC_SPIN
		case 3:	//WISP_SSI_HORZ_DEC_SPIN

			if (State == 0) //WISP_BT_DIB_NORMAL
				color = m_crSystem[58];
			else
			if (State == 1) //WISP_BT_DIB_HOVER
				color = m_crSystem[59];
			else
			if (State == 2) //WISP_BT_DIB_DOWN
				color = m_crSystem[60];

			//???=
			rect = *pRect;

			pDC->DrawRect(&rect, color);

			++rect.x;
			++rect.y;
			rect.cx -= 2;
			rect.cy -= 2;
			pDC->DrawRect(&rect, m_crSystem[1]);

			rect.cx -= 2;
			rect.cy -= 2;
			++rect.x;
			++rect.y;
			pDC->DrawFullRect(&rect, color);

			rect.y += 2;
			rect.x += 1;
			rect.cx -= 2;
			rect.cy -= 4;

			switch (uStyle)
			{
			case 0: //WISP_SSI_VERT_INC_SPIN
			{
				int _ii_v43 = -1;
				do {
					pDC->DrawLine(rect.x + rect.cx/2 - rect.cy/2,
						_ii_v43 + rect.cy / 4 + rect.y,
						rect.cx/2 + rect.x, _ii_v43 + rect.cy/4 + rect.y + rect.cy/2, m_crSystem[6]);
	
					pDC->DrawLine(rect.x + rect.cy/2 + rect.cx/2,
						_ii_v43 + rect.cy / 4 + rect.y,
						rect.cx/2 + rect.x, _ii_v43 + rect.cy/4 + rect.y + rect.cy/2, m_crSystem[6]);
					++_ii_v43;
				} while ( _ii_v43 < 1);
				int _i_v44 = 2;
				do {
					pDC->DrawLine(rect.x + rect.cx/2 - rect.cy/2,
						_i_v44 + rect.cy / 4 + rect.y,
						rect.cx/2 + rect.x, _i_v44 + rect.cy/4 + rect.y + rect.cy/2, m_crSystem[6]);

					pDC->DrawLine(rect.x + rect.cy/2 + rect.cx/2,
						_i_v44 + rect.cy / 4 + rect.y,
						rect.cx/2 + rect.x, _i_v44 + rect.cy/4 + rect.y + rect.cy/2, m_crSystem[6]);
					++_i_v44;
				} while ( _i_v44 < 4);
			}
				break;
			case 1: //WISP_SSI_VERT_DEC_SPIN
			{
				int i_v40 = -1;
				do {
					pDC->DrawLine(rect.x + rect.cx/2 - rect.cy/2,
						rect.y - rect.cy/4 - i_v40 + rect.cy - 1,
						rect.cx/2 + rect.x,
						rect.y - rect.cy/4 - i_v40 - rect.cy/2 + rect.cy - 1, m_crSystem[6]);

					pDC->DrawLine(rect.x + rect.cy/2 + rect.cx/2,
						rect.y - rect.cy/4 - i_v40 + rect.cy - 1,
						rect.cx/2 + rect.x,
						rect.y - rect.cy/4 - i_v40 - rect.cy/2 + rect.cy - 1, m_crSystem[6]);
					++i_v40;
				} while (i_v40 < 1);
				int i_v41 = 2;
				do {
					pDC->DrawLine(rect.x + rect.cx/2 - rect.cy/2,
						rect.y - rect.cy/4 - i_v41 + rect.cy - 1,
						rect.cx/2 + rect.x,
						rect.y - rect.cy/4 - i_v41 - rect.cy/2 + rect.cy - 1, m_crSystem[6]);
					pDC->DrawLine(rect.x + rect.cy/2 + rect.cx/2,
						rect.y - rect.cy/4 - i_v41 + rect.cy - 1,
						rect.cx/2 + rect.x,
						rect.y - rect.cy/4 - i_v41 - rect.cy/2 + rect.cy - 1, m_crSystem[6]);
					++i_v41;
				} while (i_v41 < 4);
			}
				break;
			case 2: //WISP_SSI_HORZ_INC_SPIN
			{
				int i_v38 = -1;
				do {
					pDC->DrawLine(rect.x + rect.cx/4 + i_v38,
						rect.y + rect.cy/2 - rect.cy/2,
						rect.x + rect.cx/4 + i_v38 + rect.cy/2,
						rect.cy/2 + rect.y, m_crSystem[6]);

					pDC->DrawLine(rect.x + rect.cx/4 + i_v38,
						rect.y + rect.cy/2 + rect.cy/2,
						rect.x + rect.cx/4 + i_v38 + rect.cy/2,
						rect.cy/2 + rect.y, m_crSystem[6]);
					++i_v38;
				} while (i_v38 < 1);
				int i_v39 = 2;
				do {
					pDC->DrawLine(rect.x + rect.cx/4 + i_v39,
						rect.y + rect.cy/2 - rect.cy/2,
						rect.x + rect.cx/4 + i_v39 + rect.cy/2,
						rect.cy/2 + rect.y, m_crSystem[6]);

					pDC->DrawLine(rect.x + rect.cx/4 + i_v39,
						rect.y + rect.cy/2 + rect.cy/2,
						rect.x + rect.cx/4 + i_v39 + rect.cy/2,
						rect.cy/2 + rect.y, m_crSystem[6]);
					++i_v39;
				} while (i_v39 < 4);
			}
				break;
			case 3: //WISP_SSI_HORZ_DEC_SPIN
			{
				int i_v36 = -1;
				do {
					pDC->DrawLine(rect.cx - rect.cx/4 - i_v36 + rect.x - 1,
						rect.y + rect.cy/2 - rect.cy/2,
						rect.cx - rect.cx/4 - i_v36 - rect.cy/2 + rect.x-1,
						rect.cy/2 + rect.y, m_crSystem[6]);

					pDC->DrawLine(rect.cx - rect.cx/4 - i_v36 + rect.x - 1,
						rect.y + rect.cy/2 + rect.cy/2,
						rect.cx - rect.cx/4 - i_v36 - rect.cy/2 + rect.x-1,
						rect.cy/2 + rect.y, m_crSystem[6]);
					++i_v36;
				} while (i_v36 < 1);
				int _ixi_v37 = 2;
				do {
					pDC->DrawLine(rect.cx - rect.cx/4 - _ixi_v37 + rect.x - 1,
						rect.y + rect.cy/2 - rect.cy/2,
						rect.cx - rect.cx/4 - _ixi_v37 - rect.cy/2 + rect.x-1,
						rect.cy/2 + rect.y, m_crSystem[6]);

					pDC->DrawLine(rect.cx - rect.cx/4 - _ixi_v37 + rect.x - 1,
						rect.y + rect.cy/2 + rect.cy/2,
						rect.cx - rect.cx/4 - _ixi_v37 - rect.cy/2 + rect.x-1,
						rect.cy/2 + rect.y, m_crSystem[6]);
					++_ixi_v37;
				} while (_ixi_v37 < 4);
			}
				break;
			default:
				break;
			}
			break;

		case 4: //WISP_SSI_CLOSE
		case 5: //WISP_SSI_MINIMIZE
		case 6: //WISP_SSI_MAXIMIZE
		case 7: //WISP_SSI_RESTORE

			if (State == 0) //WISP_BT_DIB_NORMAL
				color = m_crSystem[55];
			else
			if (State == 1) //WISP_BT_DIB_HOVER
				color = m_crSystem[54];
			else
			if (State == 2) //WISP_BT_DIB_DOWN
				color = m_crSystem[53];

			//???=
			rect = *pRect;

			pDC->DrawRoundRect(&rect, color);

			rect.x += 4;
			rect.y += 4;
			rect.cx -= 8;
			rect.cy -= 8;

			if (uStyle == 4) //WISP_SSI_CLOSE
			{
				pDC->DrawLine(rect.x + 1, rect.y,               rect.cx + rect.x - 1, rect.cy + rect.y - 2, color);
				pDC->DrawLine(rect.x + 1, rect.y + 1,           rect.cx + rect.x - 2, rect.cy + rect.y - 2, color);
				pDC->DrawLine(rect.x,     rect.y + 1,           rect.cx + rect.x - 2, rect.cy + rect.y - 1, color);
				pDC->DrawLine(rect.x,     rect.cy + rect.y - 2, rect.cx + rect.x - 2, rect.y,               color);
				pDC->DrawLine(rect.x + 1, rect.cy + rect.y - 2, rect.cx + rect.x - 2, rect.y + 1,           color);
				pDC->DrawLine(rect.x + 1, rect.cy + rect.y - 1, rect.cx + rect.x - 1, rect.y + 1,           color);
			} else
			if (uStyle == 5) //WISP_SSI_MINIMIZE
			{
				pDC->DrawLine(rect.x, rect.cy+rect.y-3, rect.cx+rect.x-1, rect.cy+rect.y-3, color);
				pDC->DrawLine(rect.x, rect.cy+rect.y-2, rect.cx+rect.x-1, rect.cy+rect.y-2, color);
				pDC->DrawLine(rect.x, rect.cy+rect.y-1, rect.cx+rect.x-1, rect.cy+rect.y-1, color);
			} else
			if (uStyle == 6) //WISP_SSI_MAXIMIZE
			{
				pDC->DrawRect(&rect, color);
				pDC->DrawLine(rect.x + 1, rect.y + 1, rect.cx + rect.x - 2, rect.y + 1, color);
				pDC->DrawLine(rect.x + 1, rect.y + 2, rect.cx + rect.x - 2, rect.y + 2, color);
	       		} else
			if (uStyle == 7) //WISP_SSI_RESTORE
			{
				rect.x += 2;
				rect.cx -= 2;
				rect.cy -= 2;
				pDC->DrawRect(&rect, color);
				pDC->DrawLine(rect.x + 1, rect.y + 1, rect.cx + rect.x - 2, rect.y + 1, color);
				rect.x -= 3;
				rect.y += 4;
				rect.cy -= 1;
				pDC->DrawRect(&rect, color);
				pDC->DrawLine(rect.x + 1, rect.y + 1, rect.cx + rect.x - 2, rect.y + 1, color);
			}
			break;
		case 9: //WISP_SSI_EXPANDBUTTON_EXPAND
		case 10: //WISP_SSI_EXPANDBUTTON_COLLAPSE

			rect.x = pRect->x + (pRect->cx - 9) / 2;
			rect.y = pRect->y + (pRect->cy - 9) / 2;
			rect.cx = 9;
			rect.cy = 9;
			pDC->DrawRect(&rect, m_crSystem[53]);
			rect.x += 2;
			rect.y += 2;
			pDC->DrawHLine(rect.x, rect.x + 4, rect.y + 2, m_crSystem[53]);
	
			if (uStyle == 10) //WISP_SSI_EXPANDBUTTON_COLLAPSE
			{
				pDC->DrawVLine(rect.x + 2, rect.y, rect.y + 4, m_crSystem[53]);
			}
			break;

		case 11: //WISP_SSI_CHECKBOX_UNCHECKED
		case 12: //WISP_SSI_CHECKBOX_CHECKED
		case 13: //WISP_SSI_CHECKBOX_SEMICHECKED
		case 14: //WISP_SSI_CHECKBOX_CHECKMARK

			if (uStyle == 11 || uStyle == 12 || uStyle == 13)
			{
				rect.x = (pRect->cx - 11) / 2 + pRect->x;
				rect.y = (pRect->cy - 11) / 2 + pRect->y;
				rect.cx = 11;
				rect.cy = 11;
				pDC->DrawRect(&rect, m_crSystem[53]);

				if (uStyle == 13) //WISP_SSI_CHECKBOX_SEMICHECKED
				{
					rect.x += 3;
					rect.y += 3;
					rect.cx = 5;
					rect.cy = 5;
					pDC->DrawFullRect(&rect, m_crSystem[56]);
				}
			}

			if (uStyle == 12 || uStyle == 14) //WISP_SSI_CHECKBOX_CHECKED WISP_SSI_CHECKBOX_CHECKMARK
			{
				int v22_x = pRect->x + (pRect->cx - 7) / 2;
				int v21_y = pRect->y + (pRect->cy - 7) / 2;

				int v23 = 0;
				while (1)
				{
					pDC->DrawLine(v22_x,     v21_y + v23 + 2, v22_x + 2, v21_y + v23 + 4, m_crSystem[56]);
					pDC->DrawLine(v22_x + 2, v21_y + v23 + 4, v22_x + 6, v21_y + v23,     m_crSystem[56]);
	
					if (++v23 >= 3)
						break;
				}
			}
			break;

		case 15: //WISP_SSI_REDIOBOX_SELECTED
		case 16: //WISP_SSI_REDIOBOX_UNSELECTED
		case 17: //WISP_SSI_REDIOBOX_SELECTED_DRAK
		case 18: //WISP_SSI_REDIOBOX_UNSELECTED_DRAK

			pDC->DrawHLine(pRect->x + 4,  pRect->x + 7, pRect->y,      m_crSystem[0]);
			pDC->DrawHLine(pRect->x + 4,  pRect->x + 7, pRect->y + 11, m_crSystem[0]);
			pDC->DrawHLine(pRect->x + 2,  pRect->x + 9, pRect->y + 1,  m_crSystem[0]);
			pDC->DrawHLine(pRect->x + 2,  pRect->x + 9, pRect->y + 10, m_crSystem[0]);

			pDC->DrawVLine(pRect->x,      pRect->y + 4, pRect->y + 7,  m_crSystem[0]);
			pDC->DrawVLine(pRect->x + 11, pRect->y + 4, pRect->y + 7,  m_crSystem[0]);
			pDC->DrawVLine(pRect->x + 1,  pRect->y + 2, pRect->y + 9,  m_crSystem[0]);
			pDC->DrawVLine(pRect->x + 10, pRect->y + 2, pRect->y + 9,  m_crSystem[0]);

			pDC->DrawPixel(pRect->x + 3,  pRect->y + 2, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 8,  pRect->y + 2, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 3,  pRect->y + 9, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 8,  pRect->y + 9, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 2,  pRect->y + 3, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 2,  pRect->y + 8, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 9,  pRect->y + 3, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 9,  pRect->y + 8, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 2,  pRect->y + 2, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 9,  pRect->y + 2, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 2,  pRect->y + 9, m_crSystem[0]);
			pDC->DrawPixel(pRect->x + 9,  pRect->y + 9, m_crSystem[0]);

			if (uStyle == 15 || uStyle == 17) //WISP_SSI_REDIOBOX_SELECTED WISP_SSI_REDIOBOX_SELECTED_DRAK
			{
				pDC->DrawVLine(pRect->x + 5, pRect->y + 4, pRect->y + 7, m_crSystem[0]);
				pDC->DrawVLine(pRect->x + 6, pRect->y + 4, pRect->y + 7, m_crSystem[0]);
				pDC->DrawHLine(pRect->x + 4, pRect->x + 7, pRect->y + 5, m_crSystem[0]);
				pDC->DrawHLine(pRect->x + 4, pRect->x + 7, pRect->y + 6, m_crSystem[0]);
			}
			break;
		default:
			break;
		}
	}

	void CWispDrawObj::DrawCursorArrow(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{

		//	y1_v3 = pHotPT->y;
		//	color_v4 = &this->m_crSystem[77];
		//	x1_v5 = pHotPT->x;
		//	y2_v6 = y1_v3 + 15;
		//	C_v14 = &this->m_crSystem[77];
		//	vc = 3;
		//	do {
		//		pDC->DrawVLine(x1_v5++, y1_v3++, y2_v6--, *color_v4);
		//		color_v4 -= 2;
		//		--vc;
		//	} while (vc);

			pDC->DrawVLine(pHotPT->x+0, pHotPT->y+0, pHotPT->y+15-0, m_crSystem[77-0]);
			pDC->DrawVLine(pHotPT->x+1, pHotPT->y+1, pHotPT->y+15-1, m_crSystem[77-2]);
			pDC->DrawVLine(pHotPT->x+2, pHotPT->y+2, pHotPT->y+15-2, m_crSystem[77-4]);

		//	x1_L_v7 = pHotPT->x;
		//	y1_L_v8 = pHotPT->y;
		//	x2_L_v9 = pHotPT->x + 15;
		//	y2_L_v10 = y1_L_v8 + 15;
		//	color_v12 = C_v14;
		//	lc = 4;
		//	do {
		//		pDC->DrawLine(x1_L_v7, y1_L_v8, x2_L_v9, y2_L_v10, *color_v12);
		//		color_v12 -= 2;
		//		++x1_L_v7;
		//		y1_L_v8 += 2;
		//		x2_L_v9 -= 2;
		//		--y2_L_v10;
		//		--lc;
		//	} while (lc);

			pDC->DrawLine(pHotPT->x+0, pHotPT->y+0, pHotPT->x+15-0, pHotPT->y+15-0, m_crSystem[77-0]);
			pDC->DrawLine(pHotPT->x+1, pHotPT->y+2, pHotPT->x+15-2, pHotPT->y+15-1, m_crSystem[77-2]);
			pDC->DrawLine(pHotPT->x+2, pHotPT->y+4, pHotPT->x+15-4, pHotPT->y+15-2, m_crSystem[77-4]);
			pDC->DrawLine(pHotPT->x+3, pHotPT->y+6, pHotPT->x+15-6, pHotPT->y+15-3, m_crSystem[77-6]);

			pDC->DrawLine(pHotPT->x + 15, pHotPT->y + 15, pHotPT->x + 2, pHotPT->y + 11, m_crSystem[77]);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = 0;
			gpCurWisp->m_MouseCursorPos.y = 0;
			gpCurWisp->m_MouseCursorSize.cx = 16;
			gpCurWisp->m_MouseCursorSize.cy = 16;
		}
	}
	void CWispDrawObj::DrawCursorDrag(CWispDC *pClipDC, WISP_POINT *pHotPT)
	{
		//EMPTY
	}
	void CWispDrawObj::DrawCursorResizeVert(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawLine(pHotPT->x - 2, pHotPT->y - 4, pHotPT->x, pHotPT->y - 6, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 2, pHotPT->y - 5, pHotPT->x, pHotPT->y - 7, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 2, pHotPT->y - 4, pHotPT->x, pHotPT->y - 6, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 2, pHotPT->y - 5, pHotPT->x, pHotPT->y - 7, m_crSystem[75]);
			pDC->DrawVLine(pHotPT->x - 1, pHotPT->y - 6, pHotPT->y + 6, m_crSystem[75]);
			pDC->DrawVLine(pHotPT->x, pHotPT->y - 7, pHotPT->y + 7, m_crSystem[72]);
			pDC->DrawVLine(pHotPT->x + 1, pHotPT->y - 6, pHotPT->y + 6, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 2, pHotPT->y + 4, pHotPT->x, pHotPT->y + 6, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 2, pHotPT->y + 5, pHotPT->x, pHotPT->y + 7, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 2, pHotPT->y + 4, pHotPT->x, pHotPT->y + 6, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 2, pHotPT->y + 5, pHotPT->x, pHotPT->y + 7, m_crSystem[75]);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = 6;
			gpCurWisp->m_MouseCursorPos.y = 7;
			gpCurWisp->m_MouseCursorSize.cx = 13;
			gpCurWisp->m_MouseCursorSize.cy = 15;
		}
	}
	void CWispDrawObj::DrawCursorResizeHorz(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawLine(pHotPT->x - 4, pHotPT->y - 2, pHotPT->x - 6, pHotPT->y, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 5, pHotPT->y - 2, pHotPT->x - 7, pHotPT->y, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 4, pHotPT->y + 2, pHotPT->x - 6, pHotPT->y, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 5, pHotPT->y + 2, pHotPT->x - 7, pHotPT->y, m_crSystem[75]);
			pDC->DrawHLine(pHotPT->x - 6, pHotPT->x + 6, pHotPT->y - 1, m_crSystem[75]);
			pDC->DrawHLine(pHotPT->x - 7, pHotPT->x + 7, pHotPT->y, m_crSystem[72]);
			pDC->DrawHLine(pHotPT->x + 6, pHotPT->x - 6, pHotPT->y + 1, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 4, pHotPT->y - 2, pHotPT->x + 6, pHotPT->y, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 5, pHotPT->y - 2, pHotPT->x + 7, pHotPT->y, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 4, pHotPT->y + 2, pHotPT->x + 6, pHotPT->y, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 5, pHotPT->y + 2, pHotPT->x + 7, pHotPT->y, m_crSystem[75]);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = 7;
			gpCurWisp->m_MouseCursorPos.y = 6;
			gpCurWisp->m_MouseCursorSize.cx = 15;
			gpCurWisp->m_MouseCursorSize.cy = 13;
		}
	}
	void CWispDrawObj::DrawCursorResizeLeftLean(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawLine(pHotPT->x - 5, pHotPT->y - 5, pHotPT->x - 5, pHotPT->y, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 5, pHotPT->y - 5, pHotPT->x, pHotPT->y - 5, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 3, pHotPT->y - 4, pHotPT->x + 4, pHotPT->y + 3, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 4, pHotPT->y - 4, pHotPT->x + 4, pHotPT->y + 4, m_crSystem[72]);
			pDC->DrawLine(pHotPT->x - 4, pHotPT->y - 3, pHotPT->x + 3, pHotPT->y + 4, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x, pHotPT->y + 5, pHotPT->x + 5, pHotPT->y + 5, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 5, pHotPT->y, pHotPT->x + 5, pHotPT->y + 5, m_crSystem[75]);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = 6;
			gpCurWisp->m_MouseCursorPos.y = 6;
			gpCurWisp->m_MouseCursorSize.cx = 11;
			gpCurWisp->m_MouseCursorSize.cy = 11;
		}
	}
	void CWispDrawObj::DrawCursorResizeRightLean(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawLine(pHotPT->x, pHotPT->y - 5, pHotPT->x + 5, pHotPT->y - 5, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x + 5, pHotPT->y, pHotPT->x + 5, pHotPT->y - 5, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 3, pHotPT->y + 4, pHotPT->x + 4, pHotPT->y - 3, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 4, pHotPT->y + 4, pHotPT->x + 4, pHotPT->y - 4, m_crSystem[72]);
			pDC->DrawLine(pHotPT->x - 4, pHotPT->y + 3, pHotPT->x + 3, pHotPT->y - 4, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x - 5, pHotPT->y, pHotPT->x - 5, pHotPT->y + 5, m_crSystem[75]);
			pDC->DrawLine(pHotPT->x, pHotPT->y + 5, pHotPT->x - 5, pHotPT->y + 5, m_crSystem[75]);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = 6;
			gpCurWisp->m_MouseCursorPos.y = 6;
			gpCurWisp->m_MouseCursorSize.cx = 11;
			gpCurWisp->m_MouseCursorSize.cy = 11;
		}
	}

	void CWispDrawObj::DrawListBK(CWispDC *pDC, WISP_RECT *pRect)
	{
		DrawToolbarBK(pDC, pRect);
	}

	void CWispDrawObj::DrawListFocusRect(CWispDC *pDC, WISP_RECT *pRect)
	{
		pDC->DrawFullRect(pRect, m_crSystem[41]);
	}

	void CWispDrawObj::X88(CWispDC *pDC, WISP_RECT *pRect) //DrawPopupMenuBK
	{
		pDC->DrawFullRect(pRect, m_crSystem[50]);
	}

	void CWispDrawObj::DrawMenuItem(CWispDC *pDC, WISP_RECT *pRect, unsigned int State)
	{
		if (State == 1) //WISP_BT_DIB_HOVER
			pDC->DrawFullRect(pRect, m_crSystem[43]);
		else	pDC->DrawFullRect(pRect, m_crSystem[50]);
	}
	void CWispDrawObj::DrawMenuItemText(CWispDC *pDC, WISP_RECT *pRect, const WCHAR *Text, unsigned int Type)
	{
		pDC->DrawShadowText(pRect, Text, 1, -1, 0);
	}
	void CWispDrawObj::X94(CWispDC *pDC, WISP_RECT *pRect) //DrawPopupMenu
	{
		X88(pDC, pRect);
	}
	void CWispDrawObj::X98(CWispDC *pDC, WISP_RECT *pRect) //DrawPopupMenu
	{
		X88(pDC, pRect);
	}

	void CWispDrawObj::DrawCursor(WISP_POINT *pHotPT, CWispDC *pClipDC, unsigned int CursorType, CWispDIB *pDIB)
	{
		switch (CursorType)
		{
		case WISP_CT_ARROW:
			DrawCursorArrow(pClipDC, pHotPT);
			break;
		case WISP_CT_RESIZE_VERT:
			DrawCursorResizeVert(pClipDC, pHotPT);
			break;
		case WISP_CT_RESIZE_HORZ:
			DrawCursorResizeHorz(pClipDC, pHotPT);
			break;
		case WISP_CT_DRAG:
			DrawCursorDrag(pClipDC, pHotPT);
			break;
		case WISP_CT_RESIZE_LEFT_LEAN:
			DrawCursorResizeLeftLean(pClipDC, pHotPT);
			break;
		case WISP_CT_RESIZE_RIGHT_LEAN:
			DrawCursorResizeRightLean(pClipDC, pHotPT);
			break;
		default:
			if (pDIB)
				pClipDC->DrawDIB(pHotPT->x, pHotPT->y, pDIB);
			else	DrawCursorArrow(pClipDC, pHotPT);
			break;
		}
	}

	//


	CWispDIBDrawObj::CWispDIBDrawObj()
	{
		m_szSkin = "\\Skin\\Default";
	}

	CWispDIBDrawObj::~CWispDIBDrawObj()
	{
		//???
	}


	bool CWispDIBDrawObj::Init()
	{
		char szPicPath[MAX_PATH];


		TStrCpy(szPicPath, m_szSkin);
		TStrCat(szPicPath, "\\VertInc.bmp");
		m_DIBVertIncSpin.Load(szPicPath, 16, 16, 4);

		TStrCpy(szPicPath, m_szSkin);
		TStrCat(szPicPath, "\\VertDec.bmp");
		m_DIBVertDecSpin.Load(szPicPath, 16, 16, 4);

		TStrCpy(szPicPath, m_szSkin);
		TStrCat(szPicPath, "\\HorzInc.bmp");
		m_DIBHorzIncSpin.Load(szPicPath, 16, 16, 4);

		TStrCpy(szPicPath, m_szSkin);
		TStrCat(szPicPath, "\\HorzDec.bmp");
		m_DIBHorzDecSpin.Load(szPicPath, 16, 16, 4);

		TStrCpy(szPicPath, m_szSkin);
		TStrCat(szPicPath, "\\Min.bmp");
		m_DIBMin.Load(szPicPath, 16, 16, 4);

		TStrCpy(szPicPath, m_szSkin);
		TStrCat(szPicPath, "\\Max.bmp");
		m_DIBMax.Load(szPicPath, 16, 16, 4);

		TStrCpy(szPicPath, m_szSkin);
		TStrCat(szPicPath, "\\Normal.bmp");
		m_DIBRestore.Load(szPicPath, 16, 16, 4);

		TStrCpy(szPicPath, m_szSkin);
		TStrCat(szPicPath, "\\Close.bmp");
		m_DIBClose.Load(szPicPath, 16, 16, 4);

		TStrCpy(szPicPath, m_szSkin);
		TStrCat(szPicPath, "\\RedioBox.bmp");
		m_DIBRedioBoxIcon.Load(szPicPath, 13, 13, 6);
		m_DIBRedioBoxIcon.SetType(2);

		m_DIBArrow.Load("\\Cursor\\Arrow.bmp", -1);
		m_DIBArrow.SetType(2);

		m_DIBDrag.Load("\\Cursor\\Drag.bmp", -1);
		m_DIBDrag.SetType(2);
		m_DIBDrag.SetHotPoint(m_DIBDrag.m_PixelBuf.Width/2, m_DIBDrag.m_PixelBuf.Height/2);

		m_DIBHResize.Load("\\Cursor\\HResize.bmp", -1);
		m_DIBHResize.SetType(2);
		m_DIBHResize.SetHotPoint(m_DIBHResize.m_PixelBuf.Width/2, m_DIBHResize.m_PixelBuf.Height/2);

		m_DIBVResize.Load("\\Cursor\\VResize.bmp", -1);
		m_DIBVResize.SetType(2);
		m_DIBVResize.SetHotPoint(m_DIBVResize.m_PixelBuf.Width/2, m_DIBVResize.m_PixelBuf.Height/2);

		m_DIBLResize.Load("\\Cursor\\LResize.bmp", -1);
		m_DIBLResize.SetType(2);
		m_DIBLResize.SetHotPoint(m_DIBLResize.m_PixelBuf.Width/2, m_DIBLResize.m_PixelBuf.Height/2);

		m_DIBRResize.Load("\\Cursor\\RResize.bmp", -1);
		m_DIBRResize.SetType(2);
		m_DIBRResize.SetHotPoint(m_DIBRResize.m_PixelBuf.Width/2, m_DIBRResize.m_PixelBuf.Height/2);

		gpCurWisp->m_MouseCursorPos.x = m_DIBArrow.m_HotPT.x;
		gpCurWisp->m_MouseCursorPos.y = m_DIBArrow.m_HotPT.y;
		gpCurWisp->m_MouseCursorSize.cx = m_DIBArrow.m_PixelBuf.Width;
		gpCurWisp->m_MouseCursorSize.cy = m_DIBArrow.m_PixelBuf.Height;

		return true;
	}
	void CWispDIBDrawObj::Release()
	{
		m_DIBVertIncSpin.Destroy();
		m_DIBVertDecSpin.Destroy();
		m_DIBHorzIncSpin.Destroy();
		m_DIBHorzDecSpin.Destroy();
		m_DIBMin.Destroy();
		m_DIBMax.Destroy();
		m_DIBRestore.Destroy();
		m_DIBClose.Destroy();
		m_DIBArrow.Destroy();
		m_DIBRedioBoxIcon.Destroy();
		m_DIBHResize.Destroy();
		m_DIBVResize.Destroy();
		m_DIBLResize.Destroy();
		m_DIBRResize.Destroy();

	}
	void CWispDIBDrawObj::DrawBorder(CWispDC *pDC, WISP_RECT *pRect, int nSize)
	{
		for (int i = nSize-1; i >= 0; --i)
		{
			//unsigned long color = GrayColor(m_crSystem[28], 1, nSize, i);

			unsigned long color = m_crSystem[28];

			unsigned char v1 = 9+9*(nSize-i); //9*(1+nSize-i)
			unsigned char v2 = 15+15*(nSize-i);//15*(1+nSize-i)
			unsigned char v3 = 3+3*(nSize-i);//3*(1+nSize-i)
			
			unsigned long r16 = v1+(unsigned char)(color>>16);
			unsigned long r8 = v2+(unsigned char)(color>>8);
			unsigned long r0 = v3+(unsigned char)(color>>0);

			unsigned long color1 = ((unsigned long)r16<<16)|((unsigned long)r8<<8)|(r0<<0);

			pDC->DrawVLine(pRect->x + i, pRect->y + i, pRect->y2() - i - 1, color1);
			pDC->DrawVLine(pRect->x2() - i - 1, pRect->y + i, pRect->y2() - i - 1, color1);

			pDC->DrawHLine(pRect->x + i, pRect->x2() - i - 1, pRect->y + i, color1);
			pDC->DrawHLine(pRect->x + i, pRect->x2() - i - 1, pRect->y2() - i - 1, color1);
		}

	}
	void CWispDIBDrawObj::DrawCaption(CWispDC *pDC, WISP_RECT *pRect)
	{
		pDC->DrawYGrayColorFullRect2(m_crSystem[23], m_crSystem[24], pRect);
	}
	void CWispDIBDrawObj::DrawToolbarBK(CWispDC *pDC, WISP_RECT *pRect)
	{
		pDC->DrawYGrayColorFullRect2(0xACD6FF, 0x3E9EFF, pRect);
	}

	void CWispDIBDrawObj::DrawVertScrollSlideRect(CWispDC *pDC, WISP_RECT *pRect)
	{
		WISP_RECT rc = *pRect;

		pDC->DrawRoundRect(&rc, m_crSystem[58]);

		++rc.x;
		++rc.y;
		rc.cx -= 2;
		rc.cy -= 2;
		pDC->DrawRect(&rc, m_crSystem[1]);

		++rc.x;
		++rc.y;
		rc.cx -= 2;
		rc.cy -= 2;
		pDC->DrawXGrayColorFullRect2(m_crSystem[27], m_crSystem[26], &rc);
		if (rc.cy >= 10)
		{
			int i = 0;
			while (i < 8)
			{
				pDC->DrawHLine(rc.x + 2, rc.x2() - 3, rc.y + (rc.cy - 8) / 2 + i + 0, m_crSystem[13]);
				pDC->DrawHLine(rc.x + 2, rc.x2() - 3, rc.y + (rc.cy - 8) / 2 + i + 1, m_crSystem[12]);
				i += 2;
			}
		}
	}
	void CWispDIBDrawObj::DrawHorzScrollSlideRect(CWispDC *pDC, WISP_RECT *pRect)
	{
		WISP_RECT rc = *pRect;

		pDC->DrawRoundRect(&rc, m_crSystem[58]);

		++rc.x;
		++rc.y;
		rc.cx -= 2;
		rc.cy -= 2;
		pDC->DrawRect(&rc, m_crSystem[1]);

		++rc.x;
		++rc.y;
		rc.cx -= 2;
		rc.cy -= 2;
		pDC->DrawYGrayColorFullRect2(m_crSystem[27], m_crSystem[26], &rc);
		if (rc.cx >= 10)
		{
			int i = 0;
			while (i < 8)
			{
				pDC->DrawVLine(rc.x + (rc.cx - 8) / 2 + i + 0, rc.y + 2, rc.y2() - 3, m_crSystem[13]);
				pDC->DrawVLine(rc.x + (rc.cx - 8) / 2 + i + 1, rc.y + 2, rc.y2() - 3, m_crSystem[12]);
				i += 2;
			}
		}
	}

	void CWispDIBDrawObj::DrawSplitRect(CWispDC *pDC, WISP_RECT *pRect, bool bHorz)
	{
		if (bHorz)
			pDC->DrawXGrayChgFullRect(pRect, m_crSystem[28], 4);
		else	pDC->DrawYGrayChgFullRect(pRect, m_crSystem[28], 4);
	}

	void CWispDIBDrawObj::DrawSystemStandardIcon(CWispDC *pDC, WISP_RECT *pRect, unsigned int uStyle, unsigned int State)
	{
		switch (uStyle)
		{
		case WISP_SSI_VERT_INC_SPIN:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBVertIncSpin.m_DIBList[State]);
			break;
		case WISP_SSI_VERT_DEC_SPIN:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBVertDecSpin.m_DIBList[State]);
			break;
		case WISP_SSI_HORZ_INC_SPIN:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBHorzIncSpin.m_DIBList[State]);
			break;
		case WISP_SSI_HORZ_DEC_SPIN:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBHorzDecSpin.m_DIBList[State]);
			break;
		case WISP_SSI_CLOSE:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBClose.m_DIBList[State]);
			break;
		case WISP_SSI_MINIMIZE:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBMin.m_DIBList[State]);
			break;
		case WISP_SSI_MAXIMIZE:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBMax.m_DIBList[State]);
			break;
		case WISP_SSI_RESTORE:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBRestore.m_DIBList[State]);
			break;
		case WISP_SSI_REDIOBOX_SELECTED:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBRedioBoxIcon.m_DIBList[3]);
			break;
		case WISP_SSI_REDIOBOX_UNSELECTED:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBRedioBoxIcon.m_DIBList[0]);
			break;
		case WISP_SSI_REDIOBOX_SELECTED_DRAK:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBRedioBoxIcon.m_DIBList[5]);
			break;
		case WISP_SSI_REDIOBOX_UNSELECTED_DRAK:
			pDC->DrawDIB(pRect->x, pRect->y, &m_DIBRedioBoxIcon.m_DIBList[2]);
			break;
		default:
			CWispDrawObj::DrawSystemStandardIcon(pDC, pRect, uStyle, State);
			break;
		}
	}

	void CWispDIBDrawObj::DrawCursorArrow(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawDIB(pHotPT->x, pHotPT->y, &m_DIBArrow);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = m_DIBArrow.m_HotPT.x;
			gpCurWisp->m_MouseCursorPos.y = m_DIBArrow.m_HotPT.y;
			gpCurWisp->m_MouseCursorSize.cx = m_DIBArrow.m_PixelBuf.Width;
			gpCurWisp->m_MouseCursorSize.cy = m_DIBArrow.m_PixelBuf.Height;
		}
	}
	void CWispDIBDrawObj::DrawCursorDrag(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawDIB(pHotPT->x, pHotPT->y, &m_DIBDrag);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = m_DIBDrag.m_HotPT.x;
			gpCurWisp->m_MouseCursorPos.y = m_DIBDrag.m_HotPT.y;
			gpCurWisp->m_MouseCursorSize.cx = m_DIBDrag.m_PixelBuf.Width;
			gpCurWisp->m_MouseCursorSize.cy = m_DIBDrag.m_PixelBuf.Height;
		}

	}
	void CWispDIBDrawObj::DrawCursorResizeVert(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawDIB(pHotPT->x, pHotPT->y, &m_DIBVResize);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = m_DIBVResize.m_HotPT.x;
			gpCurWisp->m_MouseCursorPos.y = m_DIBVResize.m_HotPT.y;
			gpCurWisp->m_MouseCursorSize.cx = m_DIBVResize.m_PixelBuf.Width;
			gpCurWisp->m_MouseCursorSize.cy = m_DIBVResize.m_PixelBuf.Height;
		}

	}
	void CWispDIBDrawObj::DrawCursorResizeHorz(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawDIB(pHotPT->x, pHotPT->y, &m_DIBHResize);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = m_DIBHResize.m_HotPT.x;
			gpCurWisp->m_MouseCursorPos.y = m_DIBHResize.m_HotPT.y;
			gpCurWisp->m_MouseCursorSize.cx = m_DIBHResize.m_PixelBuf.Width;
			gpCurWisp->m_MouseCursorSize.cy = m_DIBHResize.m_PixelBuf.Height;
		}
	}

	void CWispDIBDrawObj::DrawCursorResizeLeftLean(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawDIB(pHotPT->x, pHotPT->y, &m_DIBLResize);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = m_DIBLResize.m_HotPT.x;
			gpCurWisp->m_MouseCursorPos.y = m_DIBLResize.m_HotPT.y;
			gpCurWisp->m_MouseCursorSize.cx = m_DIBLResize.m_PixelBuf.Width;
			gpCurWisp->m_MouseCursorSize.cy = m_DIBLResize.m_PixelBuf.Height;
		}

	}
	void CWispDIBDrawObj::DrawCursorResizeRightLean(CWispDC *pDC, WISP_POINT *pHotPT)
	{
		if (pDC)
		{
			pDC->DrawDIB(pHotPT->x, pHotPT->y, &m_DIBRResize);
		} else
		{
			gpCurWisp->m_MouseCursorPos.x = m_DIBRResize.m_HotPT.x;
			gpCurWisp->m_MouseCursorPos.y = m_DIBRResize.m_HotPT.y;
			gpCurWisp->m_MouseCursorSize.cx = m_DIBRResize.m_PixelBuf.Width;
			gpCurWisp->m_MouseCursorSize.cy = m_DIBRResize.m_PixelBuf.Height;
		}
	}

	void CWispDIBDrawObj::DrawListFocusRect(CWispDC *pDC, WISP_RECT *pRect)
	{
		pDC->DrawYGrayColorFullRect2(m_crSystem[41], m_crSystem[42], pRect);
	}

	void CWispDIBDrawObj::X88(CWispDC *pDC, WISP_RECT *pRect) //DrawPopupMenuBK
	{
		CWispDrawObj::X88(pDC, pRect);
	}

	void CWispDIBDrawObj::DrawMenuItem(CWispDC *pDC, WISP_RECT *pRect, unsigned int State)
	{
		if (State == 1) //WISP_BT_DIB_HOVER
			pDC->DrawYGrayColorFullRect2(m_crSystem[43], m_crSystem[44], pRect);
		else	pDC->DrawYGrayColorFullRect2(m_crSystem[50], m_crSystem[51], pRect);
	}
	void CWispDIBDrawObj::DrawMenuItemText(CWispDC *pDC, WISP_RECT *pRect, const WCHAR *Text, unsigned int Type)
	{
		if (Type == 0x40)
		{
			pDC->SetTextColor(m_crSystem[13]);
			pDC->SetTextShadowColor(m_crSystem[31]);
			pDC->DrawShadowText(pRect, Text, 1, -1, 0);
			pDC->SetTextColor();
			pDC->SetTextShadowColor();
		} else
		{
			pDC->DrawShadowText(pRect, Text, 1, -1, 0);
		}
	}

```

`source/Wisp/wispdrawobj.hpp`:

```hpp

#ifndef _WISPDRAWOBJ_HPP_
#define _WISPDRAWOBJ_HPP_

#include "../Code/define.h"
#include "utility.hpp"
#include "wispdc.hpp"
#include "wispdib.hpp"

enum WISP_SSI_ENUM
{
	WISP_SSI_VERT_INC_SPIN  = 0,
	WISP_SSI_VERT_DEC_SPIN  = 1,
	WISP_SSI_HORZ_INC_SPIN  = 2,
	WISP_SSI_HORZ_DEC_SPIN  = 3,
	WISP_SSI_CLOSE   = 4,
	WISP_SSI_MINIMIZE  = 5,
	WISP_SSI_MAXIMIZE  = 6,
	WISP_SSI_RESTORE  = 7,
	WISP_SSI_DISABLED  = 8,
	WISP_SSI_EXPANDBUTTON_EXPAND  = 9,
	WISP_SSI_EXPANDBUTTON_COLLAPSE  = 10,
	WISP_SSI_CHECKBOX_UNCHECKED  = 11,
	WISP_SSI_CHECKBOX_CHECKED  = 12,
	WISP_SSI_CHECKBOX_SEMICHECKED  = 13,
	WISP_SSI_CHECKBOX_CHECKMARK  = 14,
	WISP_SSI_REDIOBOX_SELECTED  = 15,
	WISP_SSI_REDIOBOX_UNSELECTED  = 16,
	WISP_SSI_REDIOBOX_SELECTED_DRAK  = 17,
	WISP_SSI_REDIOBOX_UNSELECTED_DRAK  = 18,
};

enum WISP_BT_DIB
{
	WISP_BT_DIB_NORMAL = 0,
	WISP_BT_DIB_HOVER = 1,
	WISP_BT_DIB_DOWN = 2,
	WISP_BT_DIB_DISABLE = 3,
	WISP_BT_DIB_COUNT = 4,
};

enum SYSTEM_COLOR
{
	SC_BLACK = 0,
	SC_WHITE = 1,
	SC_RED = 2,
	SC_LIGHT_RED = 3,
	SC_GREEN = 4,
	SC_LIGHT_GREEN = 5,
	SC_BLUE = 6,
	SC_LIGHT_BLUE = 7,
	SC_BROWN = 8,
	SC_LIGHT_BROWN = 9,
	SC_CYAN = 10,
	SC_LIGHT_CYAN = 11,
	SC_GRAY = 12,
	SC_LIGHT_GRAY = 13,
	SC_YELLOW = 14,
	SC_LIGHT_YELLOW = 15,
	SC_ORANGE_RED = 16,
	SC_LIGHT_ORANGE_RED = 17,

	SC_DESKTOP_BG = 18,
	SC_DISABLE_BG = 19,
	SC_CLIENT_BG = 20,
	SC_CLIENT_TEXT = 21,
	SC_CAPTION_TEXT = 22,
	SC_CAPTION_BG = 23,
	SC_CAPTION_LIGHT_BG = 24,
	SC_SELECT_BG = 25,
	SC_SCROLL_SLIDE_LIGHT_BG = 26,
	SC_SCROLL_SLIDE_BG = 27,
	SC_BORDER_BG = 28,
	SC_BRIGHT = 29,
	SC_SHADOW = 30,
	SC_SHADOW_TEXT = 31,
	SC_SCROLL_BG = 32,
	SC_SCROLL_BT_BG = 33,
	SC_CURSOR = 34,

	SC_CTRL_NORMAL_BORDER_TOPLEFT = 35,
	SC_CTRL_NORMAL_BORDER_BOTTOMRIGHT = 36,
	SC_CTRL_NORMAL_DARK_BORDER = 37,
	SC_CTRL_NORMAL_CLIENT_BG = 38,
	SC_CTRL_NORMAL_DARK_CLIENT_BG = 39,
	SC_CTRL_NORMAL_DARK_CLIENT_BG2 = 40,
	SC_CTRL_FOCUS_BG = 41,
	SC_CTRL_FOCUS_LIGHT_BG = 42,
	SC_CTRL_SELECTED_BG = 43,
	SC_CTRL_SELECTED_LIGHT_BG = 44,
	SC_CTRL_SELECTED_TEXT = 45,
	SC_CTRL_NORMAL_TEXT = 46,
	SC_CTRL_HOVER_TEXT = 47,
	SC_CTRL_NORMAL_FOCUS = 48,
	SC_CTRL_HOVER_FOCUS = 49,

	SC_MENU_BG = 50,
	SC_MENU_LIGHT_BG = 51,
	SC_MENU_BORDER = 52,

	SC_STDICON_NORMAL_BORDER = 53,
	SC_STDICON_HOVER_BORDER = 54,
	SC_STDICON_DOWN_BORDER = 55,
	SC_STDICON_NORMAL_CHECKMARK = 56,
	SC_STDICON_NORMAL_PLUS = 57,

	SC_SCROLL_NORMAL_BUTTON = 58,
	SC_SCROLL_HOVER_BUTTON = 59,
	SC_SCROLL_DOWN_BUTTON = 60,

	SC_FRAME_NORMAL_BG = 61,
	SC_FRAME_NORMAL_LEFT = 62,
	SC_FRAME_NORMAL_RIGHT = 63,
	SC_FRAME_NORMAL_BOTTOM1 = 64,
	SC_FRAME_NORMAL_BOTTOM2 = 65,
	SC_FRAME_NORMAL_BOTTOM3 = 66,

	SC_FRAME_HOVER_BG = 67,
	SC_FRAME_HOVER_BOTTOM1 = 68,
	SC_FRAME_HOVER_BOTTOM2 = 69,
	SC_FRAME_HOVER_BOTTOM3 = 70,

	SC_GRADIENT_GREEN_1 = 71,
	SC_GRADIENT_GREEN_2 = 72,
	SC_GRADIENT_GREEN_3 = 73,
	SC_GRADIENT_GREEN_4 = 74,
	SC_GRADIENT_GREEN_5 = 75,
	SC_GRADIENT_GREEN_6 = 76,
	SC_GRADIENT_GREEN_7 = 77,

	SC_GRADIENT_YELLOW_0 = 78,
	SC_GRADIENT_YELLOW_1 = 79,
	SC_GRADIENT_YELLOW_2 = 80,
	SC_GRADIENT_YELLOW_3 = 81,

	SC_GRADIENT_BULE_1 = 82,
	SC_GRADIENT_BULE_2 = 83,
	SC_GRADIENT_BULE_3 = 84,
	SC_GRADIENT_BULE_4 = 85,
	SC_GRADIENT_BULE_5 = 86,
	SC_GRADIENT_BULE_6 = 87,
	SC_GRADIENT_BULE_7 = 88,
	SC_GRADIENT_BULE_8 = 89,

	SC_RAV_1 = 90,
	SC_RAV_2 = 91,
	SC_RAV_3 = 92,
	SC_RAV_4 = 93,
	SC_RAV_5 = 94,

	CTRL_STATIC_EDGE__WISP_COLOR_95 = 95,
	CTRL_STATIC_EDGE__WISP_COLOR_96 = 96,
	CTRL_STATIC_EDGE__WISP_COLOR_97 = 97,
	SC_FRAME_DOWN_BG = 98,
	SC_FRAME_DOWN = 99,
	WISP_COLOR_100 = 100,
	WISP_COLOR_101 = 101,
	WISP_COLOR_102 = 102,
	WISP_COLOR_103 = 103,
	WISP_COLOR_104 = 104,
	WISP_COLOR_105 = 105,
	WISP_COLOR_106 = 106,
	WISP_COLOR_107 = 107,
	WISP_COLOR_108 = 108,
	WISP_COLOR_109 = 109,
	WISP_COLOR_110 = 110,
	TIP__WISP_COLOR_111 = 111,
	WISP_COLOR_112 = 112,
	WISP_COLOR_113 = 113,
	WISP_COLOR_114 = 114,
	WISP_COLOR_115 = 115,
	WISP_COLOR_116 = 116,
};

struct CWispDrawObj
{
	CWispDrawObj();

	virtual ~CWispDrawObj();

	unsigned long m_crSystem[116];

	virtual bool Init();
	virtual void Release();
	virtual void InitSystemColor();
	virtual void DrawBorder(CWispDC *pDC, WISP_RECT *pRect, int nSize);
	virtual void DrawCaption(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawToolbarBK(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawClient(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawCtrlBorder(CWispDC *pDC, WISP_RECT *pRect, int nSize);
	virtual void DrawCtrlClient(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawCtrlStaticEdge(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawCtrlClientEdge(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawCtrlModalFrame(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawCtrlFocusRect(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawVertScrollRect(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawVertScrollSlideRect(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawHorzScrollRect(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawHorzScrollSlideRect(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawSplitRect(CWispDC *pDC, WISP_RECT *pRect, bool bHorz);
	virtual void DrawButtonClient(CWispDC *pDC, WISP_RECT *pRect, unsigned int State);
	virtual void DrawButtonFrameRect(CWispDC *pDC, WISP_RECT *pRect, unsigned int State);
	virtual void DrawTabBackground(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawTabItem(CWispDC *pDC, WISP_RECT *pRect, unsigned int State);
	virtual void DrawHeaderFrameRect(CWispDC *pDC, WISP_RECT *pRect, unsigned int State);
	virtual void DrawProgress(CWispDC *pDC, WISP_RECT *pRect, unsigned int uStyle, int nPersent);
	virtual void DrawSystemStandardIcon(CWispDC *pDC, WISP_RECT *pRect, unsigned int uStyle, unsigned int State);

	virtual void DrawCursorArrow(CWispDC *pDC, WISP_POINT *pHotPT);
	virtual void DrawCursorDrag(CWispDC *pDC, WISP_POINT *pHotPT);
	virtual void DrawCursorResizeVert(CWispDC *pDC, WISP_POINT *pHotPT);
	virtual void DrawCursorResizeHorz(CWispDC *pDC, WISP_POINT *pHotPT);
	virtual void DrawCursorResizeLeftLean(CWispDC *pDC, WISP_POINT *pHotPT);
	virtual void DrawCursorResizeRightLean(CWispDC *pDC, WISP_POINT *pHotPT);

	virtual void DrawListBK(CWispDC *pDC, WISP_RECT *pRect);
	virtual void DrawListFocusRect(CWispDC *pDC, WISP_RECT *pRect);

	virtual void X88(CWispDC *pDC, WISP_RECT *pRect); //DrawPopupMenuBK

	virtual void DrawMenuItem(CWispDC *pDC, WISP_RECT *pRect, unsigned int State);
	virtual void DrawMenuItemText(CWispDC *pDC, WISP_RECT *pRect, const WCHAR *Text, unsigned int Type);

	virtual void X94(CWispDC *pDC, WISP_RECT *pRect); //DrawPopupMenu
	virtual void X98(CWispDC *pDC, WISP_RECT *pRect); //DrawPopupMenu

	void DrawCursor(WISP_POINT *pHotPT, CWispDC *pClipDC, unsigned int CursorType, CWispDIB *pDIB);
};


struct CWispDIBDrawObj : public CWispDrawObj
{
	CWispDIBDrawObj();

	virtual ~CWispDIBDrawObj();

	CWispDIBList m_DIBVertIncSpin;
	CWispDIBList m_DIBVertDecSpin;
	CWispDIBList m_DIBHorzIncSpin;
	CWispDIBList m_DIBHorzDecSpin;
	CWispDIBList m_DIBClose;
	CWispDIBList m_DIBMin;
	CWispDIBList m_DIBMax;
	CWispDIBList m_DIBRestore;
	CWispDIBList m_DIBRedioBoxIcon;
	CWispDIB m_DIBArrow;
	CWispDIB m_DIBHResize;
	CWispDIB m_DIBVResize;
	CWispDIB m_DIBLResize;
	CWispDIB m_DIBRResize;
	CWispDIB m_DIBDrag;
	const char *m_szSkin;

	virtual bool Init() override;
	virtual void Release() override;
	virtual void DrawBorder(CWispDC *pDC, WISP_RECT *pRect, int nSize) override;
	virtual void DrawCaption(CWispDC *pDC, WISP_RECT *pRect) override;
	virtual void DrawToolbarBK(CWispDC *pDC, WISP_RECT *pRect) override;

	virtual void DrawVertScrollSlideRect(CWispDC *pDC, WISP_RECT *pRect) override;
	virtual void DrawHorzScrollSlideRect(CWispDC *pDC, WISP_RECT *pRect) override;

	virtual void DrawSplitRect(CWispDC *pDC, WISP_RECT *pRect, bool bHorz) override;

	virtual void DrawSystemStandardIcon(CWispDC *pDC, WISP_RECT *pRect, unsigned int uStyle, unsigned int State) override; //WISP_SSI_ENUM uStyle

	virtual void DrawCursorArrow(CWispDC *pDC, WISP_POINT *pHotPT) override;
	virtual void DrawCursorDrag(CWispDC *pDC, WISP_POINT *pHotPT) override;
	virtual void DrawCursorResizeVert(CWispDC *pDC, WISP_POINT *pHotPT) override;
	virtual void DrawCursorResizeHorz(CWispDC *pDC, WISP_POINT *pHotPT) override;

	virtual void DrawCursorResizeLeftLean(CWispDC *pDC, WISP_POINT *pHotPT) override;
	virtual void DrawCursorResizeRightLean(CWispDC *pDC, WISP_POINT *pHotPT) override;

	virtual void DrawListFocusRect(CWispDC *pDC, WISP_RECT *pRect) override;

	virtual void X88(CWispDC *pDC, WISP_RECT *pRect) override; //DrawPopupMenuBK

	virtual void DrawMenuItem(CWispDC *pDC, WISP_RECT *pRect, unsigned int State) override;
	virtual void DrawMenuItemText(CWispDC *pDC, WISP_RECT *pRect, const WCHAR *Text, unsigned int Type) override;
};

#endif


```

`source/Wisp/wispedit.cpp`:

```cpp

#include "wispedit.hpp"
#include "wispbase.hpp"

	CWispEdit::CWispEdit()
	{
		m_CurrentCaretHot = 0;
		m_DebugValue = 0;
		m_CtrlType = WISP_CTRL_EDIT;
	}
	CWispEdit::~CWispEdit()
	{
	}
	
	bool CWispEdit::CreateWnd(const WCHAR *Name, int x, int y, int cx, int cy, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int uStyle, unsigned int ShowMode)
	{
		if ( !(uStyle & 0x20000000) )
		{
			uStyle &= ~0x2200000;
			if (uStyle & 0x4010000)
				;
			else	uStyle |= 0x8000000;
		} else
		if (uStyle & 0x4010000)
		{
			uStyle &= ~0x1100000;
			if (uStyle & 0x4010000)
				;
			else	uStyle |= 0x8000000;
		} else
		{
			uStyle |= 0x8000000;
		}
		if (!CWispWnd::CreateWnd(Name, x, y, cx, cy, pParentWnd, CmdID, uStyle & ~1, ShowMode))
			return false;

		m_StringMaxLen = (uStyle & 0x3200000) != 0 ? 30001 : 0;
		m_BorderSize = uStyle & 2;
		if (uStyle & 0x200000)
			EnableScrollBar(0, 1, 1);
		if (uStyle & 0x100000)
			EnableScrollBar(1, 1, 1);
		CreateCaret(WISP_DI_CARET);
		m_LineMaxLen = (uStyle & 0x20000000) != 0 ? 1024 : 0;

		if (uStyle & 0x10000)
		{
			m_Caret.x = m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
		} else
		if (uStyle & 0x4000000)
		{
			m_Caret.x = m_ClientRect.cx / 2;
		} else
		{
			m_Caret.x = 0;
		}

		if (uStyle & 0x20000000)
			m_Caret.y = 0;
		else	m_Caret.y = (m_ClientRect.cy - m_Caret.pDIB->m_PixelBuf.Height)/2;

		if ( !(m_Style & 0x40000))
			ShowCaret(true);
		m_bSelectFlag = 0;
		m_SelectBegin = 0;
		m_SelectEnd = 0;
		bMouseLeftButtonDown = 0;
		m_SelectColor = m_pWispBase->m_pWispDrawObj->m_crSystem[49];
		return true;
	}

	bool CWispEdit::Create(WISP_RECT& RectAtWnd, unsigned int uStyle, CWispWnd *pParentWnd, unsigned int CmdID)
	{
		return CreateWnd(0, RectAtWnd.x, RectAtWnd.y, RectAtWnd.cx, RectAtWnd.cy, pParentWnd, CmdID, uStyle, WISP_SH_MINSIZE);
	}

	WISP_MSG_MAP_BEGIN(CWispEdit)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
		WISP_MSG_MAP(WISP_WM_LOST_FOCUS, OnLostFocus)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
		WISP_MSG_MAP_ON_EVENT
		WISP_MSG_MAP(WISP_WM_CHAR, OnChar)
		WISP_MSG_MAP(WISP_WM_UPDATE_BORDER, OnUpdateBorder)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
	WISP_MSG_MAP_END(CWispWnd)

	bool CWispEdit::OnEventCopy(WISP_MSG *pMsg)
	{
		if (!m_bSelectFlag)
			return false;

		int Begin = MIN(m_SelectBegin, m_SelectEnd);
		int End = MAX(m_SelectBegin, m_SelectEnd);

		TWideString String;
		String.Empty();
		String += &m_WndText.operator const WCHAR*()[Begin];
		String.Delete(End - Begin, Begin + String.m_nLength - End);
		
		m_pWispBase->SetClipboard(String.operator const WCHAR*());
		return true;
	}
	bool CWispEdit::OnEventPaste(WISP_MSG *pMsg)
	{
		if (!(m_Style & 0x40000))
		{
			m_pWispBase->GetClipboard(); //TODO
			if (!m_pWispBase->m_ClipString.IsEmpty())
			{
				InsertChar(m_pWispBase->m_ClipString.operator const WCHAR*(), -1, m_pWispBase->m_ClipString.m_nLength);
				WISP_POINT CaretPos;
				GetCaretPos(&CaretPos);
				int TextExt = m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), m_pWispBase->m_ClipString.m_nLength, m_CurrentCaretHot);
				if (m_Style & 0x8000000)
				{
					if (TextExt + CaretPos.x <= m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width)
					{
						CaretPos.x += TextExt;
					} else
					{
						CaretPos.x = m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
						if ((m_Style & 0x1000000) && m_CurrentCaretHot != m_WndText.m_nLength)
							CaretPos.x = (CaretPos.x/4)*3;
					}
					m_CurrentCaretHot += m_pWispBase->m_ClipString.m_nLength;
					SetCaretPos(CaretPos.x, CaretPos.y);
				}
				Update((WISP_RECT*)0);
			}
		}
		return true;
	}

	WISP_EVENT_MAP_BEGIN(CWispEdit)
		WISP_EVENT_MAP(WISP_ID_COPY, OnEventCopy)
		WISP_EVENT_MAP(WISP_ID_PASTE, OnEventPaste)
	WISP_EVENT_MAP_END

	bool CWispEdit::OnGetFocus(WISP_MSG *pMsg)
	{
		SendCommand(0x80000702, 0, (void*)m_WndText.operator const WCHAR*());//WISP_ID_EDIT_GET_FOCUS
		return true;
	}
	bool CWispEdit::OnLostFocus(WISP_MSG *pMsg)
	{
		SendCommand(0x80000701, 0, (void*)m_WndText.operator const WCHAR*()); //WISP_ID_EDIT_LOST_FOCUS
		if (bMouseLeftButtonDown == true)
		{
			bMouseLeftButtonDown = false;
			m_bSelectFlag = false;
		}
		return true;
	}
	bool CWispEdit::OnChar(WISP_MSG *pMsg)
	{
		if (m_Style & 0x40000)
			return true;

		switch (pMsg->Char.Char)
		{
		case 8: //BackKey()
			Update((WISP_RECT*)0);
			break;
		case 10: //NewLine
			break;
		case 13: //EnterKey
			Update((WISP_RECT*)0);
			break;
		default:
			WCHAR Char = pMsg->Char.Char;
			m_ClientDC.GetTextExtent(&Char, 1, 0);
			if (!IsInsertChar(Char))
			{
				Update((WISP_RECT*)0);
				break;
			}
			InsertChar(&Char, -1, 1);
			int TextExt = m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), m_CurrentCaretHot + 1, 0);
			TextExt -= m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), m_CurrentCaretHot, 0);
			WISP_POINT CaretPos;
			GetCaretPos(&CaretPos);
			if (m_Style & 0x8000000)
			{
				int PosX = m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
				if (TextExt + CaretPos.x > PosX)
				{
					CaretPos.x = PosX;
					if (m_Style & 0x1000000 && m_CurrentCaretHot != m_WndText.m_nLength)
						CaretPos.x = (CaretPos.x/4)*3;
				} else
				{
					CaretPos.x += TextExt;
				}
			}
			++m_CurrentCaretHot;
			const WCHAR *pStr = &m_WndText.operator const WCHAR*()[m_CurrentCaretHot - GetCurrentLinePosition(-1)];
			TextExt = m_ClientDC.GetTextExtent(pStr, GetLineWidth(pStr), 0);
			int PosX = m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
			if (TextExt < PosX)
			{
				if (m_Style & 0x4000000)
					CaretPos.x = (PosX - TextExt)/2 + m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), m_CurrentCaretHot, 0);
				else
				if (m_Style & 0x10000)
					CaretPos.x = PosX;
			}
			SetCaretPos(CaretPos.x, CaretPos.y);
			Update(&m_ClientRect);
		}
		return false;
	}
	bool CWispEdit::OnUpdateClient(WISP_MSG *pMsg)
	{
		if ( !(m_Style & 0x40) && (m_ParentWnd->m_CtrlType != WISP_CTRL_FORM || !(m_Style & 0x40000)) )
			m_pWispBase->m_pWispDrawObj->DrawCtrlClient(&m_WindowDC, &m_ClientRect);

		if (!m_WndText.IsEmpty())
		{
			WISP_POINT CaretPos;
			GetCaretPos(&CaretPos);

			m_CurrentShowRect.x = CaretPos.x - m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), m_CurrentCaretHot, 0);
			m_CurrentShowRect.cx = (m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width) - m_CurrentShowRect.x;
			m_CurrentShowRect.y = (m_Style & 0x20000000) ? CaretPos.y : 0;
			m_CurrentShowRect.cy = m_ClientRect.cy;

			WISP_RECT Rect = m_CurrentShowRect;

			int TextExt = 0;
			int Begin = 0;
			int End = 0;
			if (m_bSelectFlag && m_SelectBegin != m_SelectEnd)
			{
				Begin = MIN(m_SelectBegin, m_SelectEnd);
				End = MAX(m_SelectBegin, m_SelectEnd);
				if (Begin)
				{
					m_ClientDC.m_TextStyle = 0;
					m_ClientDC.DrawString(m_WndText.operator const WCHAR*(), &m_CurrentShowRect, 0x24, Begin, -1);
					TextExt = m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), Begin, 0);
	                        }
			}

			if (End != Begin)
			{
				Rect.x += TextExt;
				Rect.cx -= TextExt;
				m_ClientDC.m_TextStyle = 1;
				m_ClientDC.SetTextBKColor(m_SelectColor);
				m_ClientDC.DrawString(&m_WndText.operator const WCHAR*()[Begin], &Rect, 0x24, End - Begin, -1);
				TextExt = m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[Begin], End - Begin, 0);
			}

			if (End != m_WndText.m_nLength)
			{
				Rect.x += TextExt;
				Rect.cx -= TextExt;
				m_ClientDC.m_TextStyle = 0;
				m_ClientDC.DrawString(&m_WndText.operator const WCHAR*()[End], &Rect, 0x24, 0, -1);
			}
		}
		return false;
	}
	bool CWispEdit::OnUpdateBorder(WISP_MSG *pMsg)
	{
		if (m_Style & 2)
			m_pWispBase->m_pWispDrawObj->DrawCtrlBorder(&m_WindowDC, &m_WindowRect, m_BorderSize);
		return false;
	}
	bool CWispEdit::OnCreate(WISP_MSG *pMsg)
	{
		m_CaretColor = m_pWispBase->m_pWispDrawObj->m_crSystem[0];
		return true;
	}
	bool CWispEdit::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (m_Style & 0x40000)
			return true;

		if (pMsg->KeyEvent.KeyType == VK_LBUTTON ||
		    pMsg->KeyEvent.KeyType == VK_RBUTTON)
			return OnMouseEvent(pMsg);

		if (!pMsg->KeyEvent.bKeyDown)
		{
			if (!SendCommand(0x80000704, pMsg->KeyEvent.KeyType, 0)) //WISP_ID_EDIT_KEYUP
				return false;

			if (pMsg->KeyEvent.KeyType == VK_SHIFT)
			{
				bMouseLeftButtonDown = 0;
				if (m_bSelectFlag)
					m_SelectEnd = m_CurrentCaretHot;
				Update((WISP_RECT*)0);
			}
			return true;
		}

		if (!SendCommand(0x80000703, pMsg->KeyEvent.KeyType, 0)) //WISP_ID_EDIT_KEYDOWN
			return false;

		WISP_MSG Msg;

		switch (pMsg->KeyEvent.KeyType)
		{
		case 0x10000010://WISP_SK_SHIFT VK_SHIFT
			if (bMouseLeftButtonDown != 1)
			{
				bMouseLeftButtonDown = 1;
				m_SelectBegin = m_CurrentCaretHot;
				m_SelectEnd = m_CurrentCaretHot;
			}
			Update((WISP_RECT*)0);
			return false;
		case VK_END://0x23
		case 0x10000023://WISP_SK_SHIFT VK_END
			OnEndKey(pMsg);
			Update((WISP_RECT*)0);
			return true;
		case VK_HOME:
		case 0x10000024://WISP_SK_SHIFT VK_HOME
			OnHomeKey(pMsg);
			Update((WISP_RECT*)0);
			return true;
		case VK_LEFT://0x25
		case 0x10000025://WISP_SK_SHIFT VK_LEFT
		case 0x40000025://WISP_SK_CTRL VK_LEFT
			if (!m_pWispBase->m_KeyMap[VK_CONTROL])
				OnLeftKey(pMsg);
			else	OnHomeKey(pMsg);
			Update((WISP_RECT*)0);
			return true;
		case VK_RIGHT: //0x27
		case 0x10000027://WISP_SK_SHIFT VK_RIGHT
		case 0x40000027://WISP_SK_CTRL VK_RIGHT
			if (!m_pWispBase->m_KeyMap[VK_CONTROL])
				OnRightKey(pMsg);
			else	OnEndKey(pMsg);
			Update((WISP_RECT*)0);
			return true;
		case 0x4000002D://WISP_SK_CTRL VK_INSERT
		case 0x40000043://WISP_SK_CTRL C
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_EVENT;
			Msg.Command.CmdID = WISP_ID_COPY;
			m_pWispBase->PostMessage(&Msg);
			return false;
		case 0x1000002D://WISP_SK_SHIFT VK_INSERT
		case 0x40000056://WISP_SK_CTRL V
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_EVENT;
			Msg.Command.CmdID = WISP_ID_PASTE;
			m_pWispBase->PostMessage(&Msg);
			return false;
		case VK_DELETE://0x2E
			OnDeleteKey(pMsg);
			Update((WISP_RECT*)0);
			return true;
		case VK_BACK://0x
			OnBackKey(pMsg);
			Update((WISP_RECT*)0);
			return true;
		case 0x40000041://WISP_SK_CTRL A
			if (m_WndText.m_nLength)
				Select(0, m_WndText.m_nLength);
			Update((WISP_RECT*)0);
			return false;
		default:
			Update((WISP_RECT*)0);
			return true;
		}
		return true;
#if 0
//////////////////////////////
        CHAR_v5 = pMsg->u.field_8;
        if ( CHAR_v5 > 0x10000023 )
        {
                if ( CHAR_v5 > 0x40000027 )
                {
                        switch ( CHAR_v5 )
                        {
                        case 0x4000002D:// VK_INSERT
                        case 0x40000056:// V
                                Msg.hWnd = this;
                                Msg.Msg = WISP_WM_EVENT;
                                Msg.u.field_8 = WISP_ID_PASTE;
                                m_pWispBase->PostMessage(&Msg);
                                result = 0;
                                break;
                        case 0x40000041:// A
                                if (m_WndText.m_nLength)
                                        Select(0, m_WndText.m_nLength);
				Update((WISP_RECT*)0);
			        return 0;
                        case 0x40000043:// C
				Msg.hWnd = this;
				Msg.Msg = WISP_WM_EVENT;
				Msg.u.field_8 = WISP_ID_COPY;
				m_pWispBase->PostMessage(&Msg);
				return 0;
                        default:
			        Update((WISP_RECT*)0);
			        return 1;

                        }
                        return result;
                }
                if ( CHAR_v5 == 0x40000027 )    // VK_RIGHT
		{
                        if (!m_pWispBase->m_KeyMap[VK_CONTROL])
                                OnRightKey(pMsg);
	                else	OnEndKey(pMsg);
	                Update((WISP_RECT*)0);
	                return 1;
		}

                if ( CHAR_v5 <= 0x10000027 )
                {
                        if (CHAR_v5 != 0x10000027)// VK_RIGHT
                        {
                                v7 = CHAR_v5 - 0x10000024;
                                v6 = v7 == 0;
                                goto LABEL_16;
                        }
//LABEL_36:
			//CHAR_v5 == 0x10000027
                        if (!m_pWispBase->m_KeyMap[VK_CONTROL])
                                OnRightKey(pMsg);
	                else	OnEndKey(pMsg);
	                Update((WISP_RECT*)0);
	                return 1;
                }

                if ( CHAR_v5 != 0x1000002D )    // VK_INSERT
                {
                        if (CHAR_v5 != 0x40000025)// VK_LEFT
			{
		                Update((WISP_RECT*)0);
	        	        return 1;
			}
			//CHAR_v5 == 0x40000025
                        //goto LABEL_34;
                        if (!m_pWispBase->m_KeyMap[VK_CONTROL])
                                OnLeftKey(pMsg);
                        else	OnHomeKey(pMsg);
	                Update((WISP_RECT*)0);
	                return 1;
                }
		//CHAR_v5 == 0x1000002D
                Msg.hWnd = this;
                Msg.Msg = WISP_WM_EVENT;
                Msg.u.field_8 = WISP_ID_COPY;
                m_pWispBase->PostMessage(&Msg);
                return 0;
        }

        if (CHAR_v5 == 0x10000023)            // VK_END
        {
//END_UP_R_1_LABEL_25:
                OnEndKey(pMsg);
                Update((WISP_RECT*)0);
                return 1;
        }

        if ( CHAR_v5 <= VK_END )
        {
                if ( CHAR_v5 != VK_END )
                {
                        if (CHAR_v5 == VK_BACK)
                            OnBackKey(pMsg);
	                Update((WISP_RECT*)0);
	                return 1;
                }
		//CHAR_v5 == VK_END
                OnEndKey(pMsg);
                Update((WISP_RECT*)0);
                return 1;
        }

        if ( CHAR_v5 <= VK_RIGHT )
        {
                if ( CHAR_v5 != VK_RIGHT )
                {
                        v7 = CHAR_v5 - VK_HOME;
                        v6 = v7 == 0;
LABEL_16:
			//CHAR_v5 == 0x10000024
                        if (v6)
                        {
//HOME_U_R_1_LABEL_31:
				//CHAR_v5 == VK_HOME
                                OnHomeKey(pMsg);
		                Update((WISP_RECT*)0);
		                return 1;

                        }
                        if (v7 != 1)
			{
		                Update((WISP_RECT*)0);
		                return 1;
			}

//LABEL_34:
			////CHAR_v5 == VK_LEFT
                        if (!m_pWispBase->m_KeyMap[VK_CONTROL])
                                OnLeftKey(pMsg);
                        else	OnHomeKey(pMsg);
	                Update((WISP_RECT*)0);
	                return 1;

                }

		//CHAR_v5 == VK_RIGHT
                //goto LABEL_36;
                if (!m_pWispBase->m_KeyMap[VK_CONTROL])
                        OnRightKey(pMsg);
	        else	OnEndKey(pMsg);
	        Update((WISP_RECT*)0);
	        return 1;

        }

		if (CHAR_v5 == VK_DELETE)
		{
			OnDeleteKey(pMsg);
			Update((WISP_RECT*)0);
			return 1;
		}
		if (CHAR_v5 == 0x10000010)            // VK_SHIFT
		{
			if (bMouseLeftButtonDown != 1)
			{
				bMouseLeftButtonDown = 1;
				m_SelectBegin = m_CurrentCaretHot;
				m_SelectEnd = m_CurrentCaretHot;
			}

			Update((WISP_RECT*)0);
			return 0;
		}
		Update((WISP_RECT*)0);
		return 1;
#endif
	}
	bool CWispEdit::OnMouseEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType == VK_RBUTTON)
			return true;
		if (pMsg->KeyEvent.bKeyDown)
			return OnMouseLeftButtonDown(pMsg);
		return OnMouseLeftButtonUp(pMsg);
	}
	bool CWispEdit::OnMouseLeave(WISP_MSG *pMsg)
	{
		if (bMouseLeftButtonDown == true)
		{
			if (pMsg->bMsgLBTDown) return false;
			bMouseLeftButtonDown = false;
			m_bSelectFlag = false;
		}
		return true;
	}
	bool CWispEdit::OnMouseLeftButtonUp(WISP_MSG *pMsg)
	{
		if (m_bSelectFlag)
		{
			WISP_POINT CaretPos;
			GetCaretPos(&CaretPos);
			WISP_POINT Point;
			int Index = GetCharIndexByPoint(pMsg->MsgMouseWndPT, Point);
			if (Index != m_CurrentCaretHot)
				SetCaretPos(Point.x, CaretPos.y);
			m_CurrentCaretHot = Index;
			m_SelectEnd = Index;
			Update((WISP_RECT*)0);
		}
		bMouseLeftButtonDown = false;
		return true;
	}
	bool CWispEdit::OnMouseLeftButtonDown(WISP_MSG *pMsg)
	{
		if (m_bSelectFlag)
			m_bSelectFlag = 0;

		WISP_POINT CaretPos;
		GetCaretPos(&CaretPos);
		WISP_POINT Point;
		int Index = GetCharIndexByPoint(pMsg->MsgMouseWndPT, Point);
		if (Index != m_CurrentCaretHot)
			SetCaretPos(Point.x, CaretPos.y);
		m_CurrentCaretHot = Index;
		m_SelectBegin = Index;
		m_SelectEnd = Index;
		bMouseLeftButtonDown = true;
		Update((WISP_RECT*)0);
		return true;
	}
	bool CWispEdit::OnMouseMove(WISP_MSG *pMsg)
	{
		if (pMsg->bMsgLBTDown)
		{
			WISP_POINT CaretPos;
			GetCaretPos(&CaretPos);
			WISP_POINT Point;
			int Index = GetCharIndexByPoint(pMsg->MsgMouseWndPT, Point);
			if (Point.x <= CaretPos.x)
			{
				m_SelectRect.x = Point.x;
				m_SelectRect.cx = CaretPos.x - Point.x;
			} else
			{
				m_SelectRect.x = CaretPos.x;
				m_SelectRect.cx = Point.x - CaretPos.x;
			}
			m_SelectRect.y = CaretPos.y;
			m_SelectRect.cy = 12;
			m_SelectEnd = Index;
			if (m_SelectBegin == m_SelectEnd)
				m_bSelectFlag = 0;
			else
			if ( !(m_Style & 0x40000) )
				m_bSelectFlag = 1;
			Update((WISP_RECT*)0);
		}
		return true;
	}
//	void OnKeyBack();
	void CWispEdit::OnLeftKey(WISP_MSG *pMsg)
	{
		WISP_POINT CaretPosPT;
		GetCaretPos(&CaretPosPT);
		if (m_CurrentCaretHot)
		{
			if (CaretPosPT.x - m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[m_CurrentCaretHot-1], 1, 0) >= 0)
			{
				CaretPosPT.x -= m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[m_CurrentCaretHot-1], 1, 0);
			} else
			{
				int X_v6 = m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), m_CurrentCaretHot-1, 0);
				if (X_v6 >= m_ClientRect.cx/4)
					X_v6 = m_ClientRect.cx/4;
				CaretPosPT.x = X_v6;
			}
			SetCaretPos(CaretPosPT.x, CaretPosPT.y);
			if (m_pWispBase->m_KeyMap[VK_SHIFT])
			{
				if (!m_bSelectFlag)
				{
					m_SelectBegin = m_CurrentCaretHot;
					m_SelectEnd = m_CurrentCaretHot-1;
					--m_CurrentCaretHot;
					m_bSelectFlag = 1;
				} else
				if (m_SelectBegin != m_CurrentCaretHot-1)
				{
					m_SelectEnd = m_CurrentCaretHot-1;
					--m_CurrentCaretHot;
					m_bSelectFlag = 1;
				} else
				{
					--m_CurrentCaretHot;
					m_bSelectFlag = 0;
				}
			} else
			{
				--m_CurrentCaretHot;
				m_bSelectFlag = 0;
			}
			return;
		}

		if (m_bSelectFlag)
		{
			if (!m_pWispBase->m_KeyMap[VK_SHIFT])
				m_bSelectFlag = 0;
		}
	}
	void CWispEdit::OnRightKey(WISP_MSG *pMsg)
	{
		if (m_CurrentCaretHot != m_WndText.m_nLength)
		{
			m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[m_CurrentCaretHot], 1, 0);

			WISP_POINT CaretPosPT;
			GetCaretPos(&CaretPosPT);

			if (m_CurrentCaretHot >= m_WndText.m_nLength)
				return;
			if (CaretPosPT.x + m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[m_CurrentCaretHot], 1, 0) <= m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width)
			{
				CaretPosPT.x += m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[m_CurrentCaretHot], 1, 0);
			} else
			{
				CaretPosPT.x = (m_ClientRect.cx/4)*3;
			}
			SetCaretPos(CaretPosPT.x, CaretPosPT.y);
			if (m_pWispBase->m_KeyMap[VK_SHIFT])
			{
				if (!m_bSelectFlag)
				{
					m_SelectBegin = m_CurrentCaretHot;
					m_SelectEnd = m_CurrentCaretHot+1;
					m_CurrentCaretHot = m_CurrentCaretHot+1;
					m_bSelectFlag = 1;
				} else
				if (m_SelectBegin != m_CurrentCaretHot+1)
				{
					m_SelectEnd = m_CurrentCaretHot+1;
					m_CurrentCaretHot = m_CurrentCaretHot+1;
					m_bSelectFlag = 1;
				} else
				{
					++m_CurrentCaretHot;
					m_bSelectFlag = 0;
				}
			} else
			{
				++m_CurrentCaretHot;
				m_bSelectFlag = 0;
			}
			return;
		}

		if (m_bSelectFlag)
		{
			if (!m_pWispBase->m_KeyMap[VK_SHIFT])
				m_bSelectFlag = 0;
		}
	}
//	void OnUpKey(WISP_MSG *pMsg);
//	void OnDownKey(WISP_MSG *pMsg);
//	void OnReturnKey(WISP_MSG *pMsg);
	void CWispEdit::OnBackKey(WISP_MSG *pMsg)
	{
		if (m_CurrentCaretHot && m_CurrentCaretHot <= m_WndText.m_nLength)
			DeleteChar(m_CurrentCaretHot, 1, pMsg);
	}
	void CWispEdit::OnHomeKey(WISP_MSG *pMsg)
	{
		if (m_CurrentCaretHot)
		{
			int TextExt = m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), -1, 0);
			WISP_POINT CaretPosPT;
			GetCaretPos(&CaretPosPT);

			CaretPosPT.x = 0;
			int v8 = m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
			if (TextExt < v8)
			{
				if (m_Style & 0x4000000)
					CaretPosPT.x = (v8 - TextExt)/2;
				else
				if (m_Style & 0x10000)
					CaretPosPT.x = (v8 - TextExt);
			}

			SetCaretPos(CaretPosPT.x, CaretPosPT.y);

			if (m_pWispBase->m_KeyMap[VK_SHIFT])
			{
				if (!m_bSelectFlag)
				{
					m_SelectBegin = m_CurrentCaretHot;
					m_SelectEnd = 0;
					m_CurrentCaretHot = 0;
					m_bSelectFlag = 1;
				} else
				if (m_SelectBegin)
				{
					m_SelectEnd = 0;
					m_CurrentCaretHot = 0;
					m_bSelectFlag = 1;
				} else
				{
					m_bSelectFlag = 0;
					m_CurrentCaretHot = 0;
				}
			} else
			{
				m_bSelectFlag = 0;
				m_CurrentCaretHot = 0;
			}
			return;
		}

		if (m_bSelectFlag)
		{
			if (!m_pWispBase->m_KeyMap[VK_SHIFT])
				m_bSelectFlag = 0;
		}
	}
	void CWispEdit::OnEndKey(WISP_MSG *pMsg)
	{
		WISP_POINT CaretPosPT;
		GetCaretPos(&CaretPosPT);
		int TextExt = m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), -1, 0);
		int v7 = m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
		if (TextExt <= v7)
		{
			if (m_Style & 0x4000000)
			{
				CaretPosPT.x = (v7 - TextExt)/2 + m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), -1, 0);
			} else
			{
                                CaretPosPT.x = TextExt;
	                        if (m_Style & 0x10000)
		                        CaretPosPT.x = v7;
			}
		} else
		{
			CaretPosPT.x = v7;
		}
		SetCaretPos(CaretPosPT.x, CaretPosPT.y);

		if (m_pWispBase->m_KeyMap[VK_SHIFT])
		{
			if (m_bSelectFlag)
			{
				if (m_SelectBegin == m_WndText.m_nLength)
				{
					m_CurrentCaretHot = m_WndText.m_nLength;
					m_bSelectFlag = 0;
					return;
				}
			} else
			{
				m_SelectBegin = m_CurrentCaretHot;
			}
			m_SelectEnd = m_WndText.m_nLength;
			m_bSelectFlag = 1;
			m_CurrentCaretHot = m_WndText.m_nLength;
		} else
		{
			m_CurrentCaretHot = m_WndText.m_nLength;
			m_bSelectFlag = 0;
		}
	}
	void CWispEdit::OnDeleteKey(WISP_MSG *pMsg)
	{
		if (m_bSelectFlag && m_SelectBegin != m_SelectEnd)
		{
			WISP_POINT CaretPos;
			GetCaretPos(&CaretPos);
			int Begin = MIN(m_SelectBegin, m_SelectEnd);
			int End = MAX(m_SelectBegin, m_SelectEnd);
			WISP_POINT Point;
			GetCurrentPosition(&Point, Begin);
			m_WndText.Delete(Begin, End - Begin);
			m_CurrentCaretHot = Begin;
			CaretPos.x = MAX(Point.x, 0);
			SetCaretPos(CaretPos.x, CaretPos.y);
			m_bSelectFlag = 0;
			m_SelectBegin = 0;
			m_SelectEnd = 0;
		} else
		if (m_CurrentCaretHot != m_WndText.m_nLength)
		{
			WISP_POINT CaretPos;
			GetCaretPos(&CaretPos);
			int TextExt = m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[m_CurrentCaretHot+1], -1, 0);
			int w = m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
			if (TextExt <= w - CaretPos.x &&
				CaretPos.x < m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), m_CurrentCaretHot, 0))
			{
				int w = m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[m_CurrentCaretHot+1], 1, 0);
				m_WndText.Delete(m_CurrentCaretHot, 1);
				CaretPos.x += w;
			} else
			{
				m_WndText.Delete(m_CurrentCaretHot, 1);
			}
			TextExt = m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), -1, 0);
			w = m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
			if (TextExt < w)
			{
				if (m_Style & 0x4000000)
					CaretPos.x = (w - TextExt)/2 + m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), m_CurrentCaretHot, 0);
				else
				if (m_Style & 0x10000)
					CaretPos.x = w;
			}
			SetCaretPos(CaretPos.x, CaretPos.y);
		}
	}
	//void OnPageUpKey(WISP_MSG *pMsg);
	//void OnPageDownKey(WISP_MSG *pMsg);
	//bool OnShiftKey(WISP_MSG *pMsg);
	//int GetMaxShowCharNum(WCHAR*, int, int*, char);
	bool CWispEdit::IsInsertChar(WCHAR wch)
	{
		int TextWidth = m_ClientDC.GetTextExtent(&wch, 1, 0);
		if (m_WndText.IsEmpty() || m_Style & 0x1100000)
			return true;

		int TextExt = 0;
		if (m_bSelectFlag && m_SelectBegin != m_SelectEnd)
		{
			int Begin = MIN(m_SelectBegin, m_SelectEnd);
			int End = MAX(m_SelectBegin, m_SelectEnd);
			TextExt = m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[Begin], End - Begin, 0);
		}
		return TextWidth + m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), -1, 0) - TextExt <=
						m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
	}
	int CWispEdit::InsertChar(const WCHAR *pChar, int nPosition, int nCount)
	{
		int Len = 0;
		if (!SendCommand(0x80000700, 0, 0)) //WISP_ID_EDIT_CHANGING
			return Len;

		if (m_bSelectFlag && m_SelectBegin != m_SelectEnd)
		{
			WISP_POINT CaretPos;
			GetCaretPos(&CaretPos);

			int Begin = MIN(m_SelectBegin, m_SelectEnd);
			int End = MAX(m_SelectBegin, m_SelectEnd);

			WISP_POINT Point;
			GetCurrentPosition(&Point, Begin);
			m_WndText.Delete(Begin, End - Begin);
			m_CurrentCaretHot = Begin;
			CaretPos.x = Point.x;
			SetCaretPos(CaretPos.x, CaretPos.y);
			m_bSelectFlag = 0;
			m_SelectBegin = 0;
			m_SelectEnd = 0;
		}

		if (nPosition == -1)
			nPosition = m_CurrentCaretHot;

		if (nCount == 1)
			Len = m_WndText.Insert(nPosition, *pChar);
		else	m_WndText.Insert(nPosition, pChar);
		SendCommand(0x80000705, 0, 0); //WISP_ID_EDIT_CHANGED
		return Len;		
	}
	int CWispEdit::DeleteChar(int nPosition, int nCount, WISP_MSG *pMsg)
	{
		if (nPosition == -1)
			nPosition = m_CurrentCaretHot;
		if (!SendCommand(0x80000700, 0, 0)) //WISP_ID_EDIT_CHANGING
			return 0;
		//??? fix if (nPosition == m_WndText.m_nLength)
			--nPosition;
		OnLeftKey(pMsg);
		m_WndText.Delete(nPosition, nCount);
		SendCommand(0x80000705, 0, 0); //WISP_ID_EDIT_CHANGED
		return nCount;
	}
	int CWispEdit::GetCurrentLinePosition(int nIndex)
	{
		if ( (m_Style & 0x20000000) == 0)
			return m_CurrentCaretHot;

		WISP_POINT CaretPos;
		GetCaretPos(&CaretPos);

		int Len = 0;
		for (int Hot = m_CurrentCaretHot - 1; Hot >= 0; --Hot)
		{
			if (m_WndText.operator const WCHAR*()[Hot] == 10) break;
			if (m_WndText.operator const WCHAR*()[Hot] == 13) break;
			++Len;
		}

		if (m_Style & 0x1100000)
		{
			int Pos = Len % 20;
			if (!Pos && Len)
				Pos = 20;
			return Pos;
		}

		int Pos = 0;
		int i = 0;
		for (int n = 0; n < Len; ++n)
		{
			int TextExt = m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[n + m_CurrentCaretHot - Len], 1, 0);
			if (TextExt + i >= m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width)
			{
				Pos = -1;
				i = TextExt;
			} else
			{
				i += TextExt;
			}
			++Pos;
		}
		return Pos;
	}
	//int GetPrevLineBeginPosition(int, int*);
	//int GetCaretLineCharWidth();
	int CWispEdit::GetLineWidth(const WCHAR *pSrc)
	{
		int Len = 0;
		while (pSrc[Len++]);
		return Len;
	}
	//int CalcLineNum(const WCHAR* pSrc, int nCount, int nPerLineMaxCharNum);
	//int CalcLineNumForWidth(const WCHAR* pSrc, int nCount, int nLineWidth);
	//int CaretLeftMove();
	//int CaretRightMove();
	void CWispEdit::GetCurrentPosition(WISP_POINT *pPoint, int Len)
	{
		pPoint->x = 0;
		pPoint->y = 0;
		if (Len <= m_WndText.m_nLength)
		{
			pPoint->x = m_CurrentShowRect.x + m_ClientDC.GetTextExtent(m_WndText.operator const WCHAR*(), Len,0);
			pPoint->y = m_CurrentShowRect.y;
		}
	}
	bool CWispEdit::SetWindowText(const WCHAR *pString)
	{
		if (!pString)
			return false;
		m_WndText = pString;
		int PosX = 0;
		int PosY = m_Style & 0x20000000 ? 0 : (m_ClientRect.cy - m_Caret.pDIB->m_PixelBuf.Height)/2;
		m_CurrentStringLen = TStrLen(pString);
		if (m_Style & 0x4000000)
		{
			m_CurrentLineCharIndex = m_CurrentStringLen/2;
			m_CurrentCaretHot = m_CurrentStringLen/2;
			PosX = m_ClientRect.cx - m_Caret.pDIB->m_PixelBuf.Width;
			if (m_CurrentStringLen % 2)
				PosX -= m_ClientDC.GetTextExtent(&pString[m_CurrentStringLen/2], 1, 0);
			PosX /= 2;
		} else
		{
			m_CurrentLineCharIndex = 0;
			m_CurrentCaretHot = 0;
		}
		SetCaretPos(PosX, PosY);
		Update(&m_ClientRect);
		return true;
	}

	int CWispEdit::GetCharIndexByPoint(WISP_POINT point, WISP_POINT& retpoint)
	{
		int PosX = m_CurrentShowRect.x;
		int Index = 0;
		int TextExt = 0;
		for (Index = 0; Index < m_WndText.m_nLength; ++Index)
		{
				TextExt = m_ClientDC.GetTextExtent(&m_WndText.operator const WCHAR*()[Index], 1, 0);
				PosX += TextExt;
				if (PosX > point.x) break;
		}
		if (PosX > point.x)
			PosX -= TextExt;
		retpoint.x = PosX;
		retpoint.y = point.y;
		return Index;		
	}

	int CWispEdit::Select(int Pos, int Len)
	{
		if (m_WndText.m_nLength < MAX(Pos, Len))
			return 0;

		m_SelectBegin = MIN(Pos, Len);
		m_SelectEnd = MAX(Pos, Len);
		m_CurrentCaretHot = Len;
		m_bSelectFlag = 1;
		Update((WISP_RECT*)0);
		return m_SelectEnd - m_SelectBegin + 1;
	}

```

`source/Wisp/wispedit.hpp`:

```hpp

#ifndef _WISPEDIT_HPP_
#define _WISPEDIT_HPP_

#include "../Code/define.h"
#include "wispwnd.hpp"

struct _SELECTPOS
{
	int begin;
	int end;
};

struct CWispEdit : public CWispWnd
{
	int m_CharLenArray[320];
	int m_CurrentCaretHot;
	int m_CurrentCaretLine;
	int m_CurrentStringLen;
	char m_bIsMultiLine;
	int m_StringMaxLen;
	int m_LineMaxLen;
	unsigned int m_TextRowNum;
	unsigned int m_TextColNum;
	int m_CurrentLineCharIndex;
	int m_CurrentLineNum;
	WISP_RECT m_CurrentShowRect;
	int m_DebugValue;
	char m_bSelectFlag;
	int m_SelectBegin;
	int m_SelectEnd;
	bool bMouseLeftButtonDown;
	WISP_RECT m_SelectRect;
	unsigned int m_SelectColor;

	CWispEdit();
	virtual ~CWispEdit();
	
	virtual bool CreateWnd(const WCHAR *Name, int x, int y, int cx, int cy, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int uStyle, unsigned int ShowMode) override;
	bool Create(WISP_RECT &RectAtWnd, unsigned int uStyle, CWispWnd *pParentWnd, unsigned int CmdID);

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnEventCopy(WISP_MSG *pMsg);
	bool OnEventPaste(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnGetFocus(WISP_MSG *pMsg);
	bool OnLostFocus(WISP_MSG *pMsg);
	bool OnChar(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnUpdateBorder(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnMouseEvent(WISP_MSG *pMsg);
	bool OnMouseLeave(WISP_MSG *pMsg);
	bool OnMouseLeftButtonUp(WISP_MSG *pMsg);
	bool OnMouseLeftButtonDown(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
//	void OnKeyBack();
	void OnLeftKey(WISP_MSG *pMsg);
	void OnRightKey(WISP_MSG *pMsg);
//	void OnUpKey(WISP_MSG *pMsg);
//	void OnDownKey(WISP_MSG *pMsg);
//	void OnReturnKey(WISP_MSG *pMsg);
	void OnBackKey(WISP_MSG *pMsg);
	void OnHomeKey(WISP_MSG *pMsg);
	void OnEndKey(WISP_MSG *pMsg);
	void OnDeleteKey(WISP_MSG *pMsg);
	//void OnPageUpKey(WISP_MSG *pMsg);
	//void OnPageDownKey(WISP_MSG *pMsg);
	//bool OnShiftKey(WISP_MSG *pMsg);
	//int GetMaxShowCharNum(WCHAR*, int, int*, char);
	bool IsInsertChar(WCHAR wch);
	int InsertChar(const WCHAR *pChar, int nPosition, int nCount);
	int DeleteChar(int nPosition, int nCount, WISP_MSG *pMsg);
	int GetCurrentLinePosition(int nIndex);
	//int GetPrevLineBeginPosition(int, int*);
	//int GetCaretLineCharWidth();
	int GetLineWidth(const WCHAR *pSrc);
	//int CalcLineNum(const WCHAR* pSrc, int nCount, int nPerLineMaxCharNum);
	//int CalcLineNumForWidth(const WCHAR* pSrc, int nCount, int nLineWidth);
	//int CaretLeftMove();
	//int CaretRightMove();
	void GetCurrentPosition(WISP_POINT *pPoint, int Len);
	virtual bool SetWindowText(const WCHAR *pString) override;
	int GetCharIndexByPoint(WISP_POINT point, WISP_POINT &retpoint);
	int Select(int Pos, int Len);
};

#endif

```

`source/Wisp/wispfont.cpp`:

```cpp

#include "wispfont.hpp"
#include "../Code/imagefile.hpp"
#include "../Code/txtfile.hpp"
#include "../Code/sysdep.hpp"
#include "wispbase.hpp"

	CWispFont::CWispFont()
	{
		m_WideHeight = 0;
		m_WideWidth = 0;
		m_WideBufSize = 0;
		m_WideBuffer = 0;

		m_Height = 0;
		m_Width = 0;
		m_BufSize = 0;
		m_Buffer = 0;
	}

	CWispFont::~CWispFont() { Destroy(); }

	void MirrorBitmap(unsigned char *Buffer, unsigned int width, unsigned int height)
	{
		unsigned long sizebuf = (width*height+7)/8;
		unsigned char *buffer = new unsigned char[sizebuf];

		memcpy(buffer, Buffer, sizebuf);

		unsigned int bitoffset = 0;
		for (int h = 0; h < height; ++h)
		{
			for (int w = 0; w < width; ++w)
			{
				if (GET_BIT(buffer, bitoffset+width-1-w))
					SET_BIT(Buffer, bitoffset+w);
				else	CLR_BIT(Buffer, bitoffset+w);
			}
			bitoffset += width;
		}

		delete []buffer;
	}

	bool CWispFont::LoadBDF(const char *FileName)
	{
		CTXTFile File;

		m_Buffer = 0;
		m_BufSize = 0;
		m_Width = 0;
		m_Height = 0;

		if (!File.Open(FileName, 0))
			return false;

		unsigned int codepoint = 0;
		unsigned int w = 0;
		unsigned int h = 0;
		unsigned int cx = 0;
		unsigned int cy = 0;

		unsigned int width = 0;
		unsigned int height = 0;
		unsigned int xoff = 0;
		unsigned int yoff = 0;

		int Start = 0;
		int Bitmap = 0;
		int off = 0;
		unsigned int bitoffset = 0;
		unsigned long long QWord = 0;

		TListIter<char*> It = File.m_StrList.Begin();
		while (It != File.m_StrList.End())
		{
			//STARTFONT version

			if (::sscanf(*It, "FONTBOUNDINGBOX %d %d %d %d", &w, &h, &cx, &cy) == 4)
			{
				m_Width = w;
				m_Height = h;
				m_BytesPerChar = (m_Width * m_Height + 7) / 8;
				m_BufSize = m_BytesPerChar * 256;
				if (!m_BufSize) break;
				m_Buffer = new unsigned char[m_BufSize];
				if (!m_Buffer) break;
				memset(m_Buffer, 0, m_BufSize);
			} else
			
			//FONT name
			//CHARS n

			//STARTCHAR name
			if (::sscanf(*It, "ENCODING %ud", &codepoint) == 1)
			{

			} else
			if (::sscanf(*It, "BBX %d %d %d %d", &width, &height, &xoff, &yoff) == 4)
			{
				if (width == m_Width && height == m_Height)
				{
					if (codepoint >= 0 && codepoint < 256)
						Start = 1;
				}
			} else
			if (!TStrNCmp(*It, "BITMAP", 6))
			{
				Bitmap = 1;
				off = 0;
			} else
			if (!TStrNCmp(*It, "ENDCHAR", 7))
			{
				if (Bitmap == 1 && Start == 1)
				{
					MirrorBitmap(&m_Buffer[m_BytesPerChar*codepoint], width, height);
				}
				Start = 0;
				Bitmap = 0;
				bitoffset = 0;
			} else
			if (Bitmap == 1 && Start == 1 && off>=0 && off<height && ::sscanf(*It, "%llx", &QWord) == 1)
			{
				QWord >>= TStrLen(*It)*4-width;

				unsigned char *buffer = &m_Buffer[m_BytesPerChar*codepoint];

				for (int w = 0; w < width; ++w)
				{
					if (QWord&1)
					{
						SET_BIT(buffer, w+bitoffset);
					} else
					{
						CLR_BIT(buffer, w+bitoffset);
					}
					QWord>>=1;
				}
				++off;
				bitoffset += width;
			}

			++It;
		}
		File.Close();

		if (!m_BufSize)
			return false;
		if (!m_Buffer)
			return false;

		TMemSet(m_CharLenAry, m_Width, 256); //???

		//m_BytesPerChar = (m_Width * m_Height + 7) / 8;
		m_CharLenAry[10] = 0;
		m_CharLenAry[13] = 0;
		m_CharLenAry[0] = 0;

		return true;
	}

	bool CWispFont::LoadChar(WISP_PHYS_FONT_INFO *pPhysFont)
	{
		CImageFile ImageFile;

		ImageFile.ChangeFileIO(&gpCurWisp->m_PFSFileIO);

		m_Buffer = 0;
		m_BufSize = 0;
		m_Width = 0;
		m_Height = 0;

	//	char szModuleName[MAX_FN_LEN];
	//	GetModulePath(szModuleName, true);
	//	TStrCat(szModuleName, pPhysFont->FontFN);
	//	if (!ImageFile.Open(szModuleName, 0))

		if (!ImageFile.Open(pPhysFont->FontFN, 0))
			return false;

		m_BufSize = ImageFile.GetFileLength();
		if (!m_BufSize)
		{
			ImageFile.Close();
			return false;
		}

		m_Buffer = new unsigned char[m_BufSize];
		if (!m_Buffer)
		{
			m_BufSize = 0;
			ImageFile.Close();
			return false;
		}

		if (!ImageFile.ReadFile(0, m_Buffer, m_BufSize))
		{
			m_BufSize = 0;
			SafeDeleteAry(m_Buffer);
			ImageFile.Close();
			return false;
		}

		m_Width = pPhysFont->Width;
		m_Height = pPhysFont->Height;
		ImageFile.Close();

		TMemSet(m_CharLenAry, 8, 256);

		m_BytesPerChar = (m_Width * m_Height + 7) / 8;
		m_CharLenAry[10] = 0;
		m_CharLenAry[13] = 0;
		m_CharLenAry[0] = 0;

		return true;		
	}

	bool CWispFont::LoadWideChar(WISP_PHYS_FONT_INFO *pPhysFont)
	{
		CImageFile ImageFile;

		ImageFile.ChangeFileIO(&gpCurWisp->m_PFSFileIO);

		m_WideBuffer = 0;
		m_WideBufSize = 0;
		m_WideWidth = 0;
		m_WideHeight = 0;

		if (!ImageFile.Open(pPhysFont->WideFontFN, 0))
			return false;

		m_WideBufSize = ImageFile.GetFileLength();
		if (!m_WideBufSize)
		{
			ImageFile.Close();
			return false;
		}

		m_WideBuffer = new unsigned char[m_WideBufSize]; //unsigned short ???
		if (!m_WideBuffer)
		{
			m_WideBufSize = 0;
			ImageFile.Close();
			return false;
		}

		if (!ImageFile.ReadFile(0, m_WideBuffer, m_WideBufSize))
		{
			m_WideBufSize = 0;
			SafeDeleteAry(m_WideBuffer);
			ImageFile.Close();
			return false;
		}

		m_WideWidth = pPhysFont->Width*2;
		m_WideHeight = pPhysFont->Height;
		ImageFile.Close();

		return true;		
	}

	void CWispFont::Destroy()
	{
		SafeDeleteAry(m_Buffer);
		SafeDeleteAry(m_WideBuffer);
	}

	unsigned char *CWispFont::GetCharPixelBuffer(WCHAR Char)
	{
		if (Char < 256) return m_Buffer + m_BytesPerChar * Char;

		int Offset = 2 * m_BytesPerChar * Char;
		if (m_WideBuffer && Offset < m_WideBufSize)
			return m_WideBuffer + Offset;
		return m_Buffer + m_BytesPerChar * 0x3F; //'?'
	}

	int CWispFont::GetCharWidth(WCHAR Char)
	{
		return (Char >= 256 && m_WideBuffer) ? m_WideWidth : m_Width;
	}

	int CWispFont::GetCharHeight(WCHAR Char)
	{
		return (Char >= 256 && m_WideBuffer) ? m_WideHeight : m_Height;
	}

```

`source/Wisp/wispfont.hpp`:

```hpp

#ifndef _WISPFONT_HPP_
#define _WISPFONT_HPP_

#include "../Code/define.h"
//#include "../Code/osdefine.hpp"

enum WISP_FONT_ID
{
	WISP_FONT_8X16 = 0,
	WISP_FONT_6X12,// = 1,
	WISP_FONT_ASCI_12X16,// = 2,
	WISP_FONT_EBCD_12X16,// = 3,
	WISP_FONT_ANSI_12X16,// = 4,
	WISP_FONT_BDF,
	WISP_FONT_COUNT,// = 5,
};

struct WISP_PHYS_FONT_INFO
{
	int Width;
	int Height;
	const char *FontFN;
	const char *WideFontFN;
};

struct CWispFont
{
	CWispFont();
	~CWispFont();

	bool LoadBDF(const char *FileName);
	bool LoadChar(WISP_PHYS_FONT_INFO *pPhysFont);
	bool LoadWideChar(WISP_PHYS_FONT_INFO *pPhysFont);

	void Destroy();

	int m_CharLenAry[256];

	int m_Height;
	int m_Width;
	unsigned char *m_Buffer;
	int m_BufSize;

	int m_WideHeight;
	int m_WideWidth;
	unsigned char *m_WideBuffer;
	int m_WideBufSize;

	int m_BytesPerChar;

	unsigned char *GetCharPixelBuffer(WCHAR Char);

	int GetCharWidth(WCHAR Char);
	int GetCharHeight(WCHAR Char);
};

#endif


```

`source/Wisp/wispform.cpp`:

```cpp

#include "wispform.hpp"
#include "wispbase.hpp"

#include "wispstatic.hpp"
#include "wispbutton.hpp"
#include "wispprogress.hpp"
#include "wisptabwnd.hpp"
#include "wispedit.hpp"
#include "wisplist.hpp"
#include "wispcombobox.hpp"
#include "wispradiobox.hpp"
#include "wispcheckbox.hpp"

	CWispForm::CWispForm()
	{
		m_Result = 0;
		m_Resource = 0;
		m_CtrlType = WISP_CTRL_FORM;
	}
	CWispForm::~CWispForm()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispForm)
		WISP_MSG_MAP_ON_EVENT
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
	WISP_MSG_MAP_END(CWispWnd)
#if 0
	WISP_EVENT_MAP_BEGIN(CWispForm)
	WISP_EVENT_MAP_END
#else
	bool CWispForm::OnEvent(WISP_MSG *pMsg)
	{
		return CWispBaseWnd::OnEvent(pMsg);
	}
#endif
	//
	WISP_CMD_MAP_BEGIN(CWispForm)
		WISP_CMD_MAP(WISP_ID_CLOSE, OnCmdClose)
		WISP_CMD_MAP(WISP_ID_OK, OnCmdOk)
		WISP_CMD_MAP(WISP_ID_CANCEL, OnCmdCancel)
		WISP_CMD_MAP_DEFAULT(OnCmdDefault)
	WISP_CMD_MAP_END

	bool CWispForm::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType == VK_ESCAPE &&
			pMsg->KeyEvent.bKeyDown &&
			(m_Style & 8))
			CWispBaseWnd::Close();
		return true;
	}
	bool CWispForm::OnCmdOk(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002) //WISP_ID_KEYUP
		{
			m_Result = WISP_ID_OK;
			CWispBaseWnd::Close();
		}
		return false; //???
	}
	bool CWispForm::OnCmdCancel(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002) //WISP_ID_KEYUP
		{
			m_Result = WISP_ID_CANCEL;
			CWispBaseWnd::Close();
		}
		return false; //???
	}

	bool CWispForm::OnCmdDefault(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002) //WISP_ID_KEYUP
		{
			if (pMsg->Command.CmdID > WISP_ID_FORM_CLOSE_ID_START &&
			    pMsg->Command.CmdID < WISP_ID_FORM_CLOSE_ID_END)
			{
				m_Result = pMsg->Command.CmdID;
				CWispBaseWnd::Close();
			}
		}
		return true;
	}

	bool CWispForm::LoadForm(WISP_FORM_RES_ITEM *ItemAry)
	{
		//CWispStaticDIB
		//CWispEdit
		//CWispButton
		//CWispStaticURL
		//CWispStaticGroup
		//CWispStaticStr
		//CWispList
		//CWispCheckBox
		//CWispTabWnd
		//CWispRadioBox
		//CWispProgress
		//CWispComboBox

		CWispBaseWnd *pWnd;

		while (ItemAry->Type)
		{
			switch (ItemAry->Type)
			{
			case WISP_CTRL_STATIC_STRING:
				pWnd = new CWispStaticStr;
				pWnd->Create(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1; //WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_STATIC_DIB:
				pWnd = new CWispStaticDIB;
				((CWispStaticDIB*)pWnd)->CreateEx(gpCurWisp->m_DIBLib.GetDIB((const char*)ItemAry->pData, 0),
						ItemAry->rc.x, ItemAry->rc.y, this, ItemAry->CmdID);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_STATIC_GROUP:
				pWnd = new CWispStaticGroup;
				pWnd->Create(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_STATIC_URL:
				pWnd = new CWispStaticURL;
				pWnd->Create(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_BUTTON:
				pWnd = new CWispButton;
				pWnd->Create(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_EDIT:
				pWnd = new CWispEdit;
				((CWispEdit*)pWnd)->Create(ItemAry->rc, ItemAry->Style, this, ItemAry->CmdID);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_LIST:
				pWnd = new CWispList;
				((CWispList*)pWnd)->CreateWnd(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_CHECK_BOX:
				pWnd = new CWispCheckBox;
				pWnd->Create(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_TAB:
				pWnd = new CWispTabWnd;
				((CWispTabWnd*)pWnd)->CreateWnd(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_RADIO_BOX:
				pWnd = new CWispRadioBox;
				pWnd->Create(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_PROGRESS:
				pWnd = new CWispProgress;
				pWnd->Create(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			case WISP_CTRL_FORM:

				if (!CreateWnd(ItemAry->pName, ItemAry->rc, m_ParentWnd, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE))
					return false;
				if (ItemAry->pData)
					LoadTitleDIB((const char*)ItemAry->pData, 0);

				if (ItemAry->pTipString)
					EnableHelpTip(ItemAry->pTipString);
				if (m_Style & 0x800)
					Focus();
				break;
			case WISP_CTRL_COMBO_BOX:
				pWnd = new CWispComboBox;
				((CWispTabWnd*)pWnd)->CreateWnd(ItemAry->pName, ItemAry->rc, this, ItemAry->CmdID, ItemAry->Style, WISP_SH_MINSIZE);
				pWnd->m_AdvStyle |= 1;	//WISP_ADV_AUTODEL
				if (ItemAry->CmdID)
					m_FormItemMap.insert(_Tmap_pair<unsigned int,CWispBaseWnd*>(ItemAry->CmdID, pWnd));
				if (ItemAry->pTipString)
					pWnd->EnableHelpTip(ItemAry->pTipString);
				if (pWnd->m_Style & 0x800)
					pWnd->Focus();
				break;
			default:
				; //???
			}
			++ItemAry;
		}

		return true;
	}
	bool CWispForm::Create(CWispWnd *pParentWnd, int ShowMode)
	{
		m_ParentWnd = pParentWnd;
		if (!LoadForm(m_Resource))
			return false;

		WISP_MSG Msg;
		m_Result = 0;
		Msg.hWnd = this;
		Msg.Msg = WISP_WM_CREATE_FORM;
		m_pWispBase->SendMessage(&Msg);
		Center(pParentWnd);
		Focus();
		Show(ShowMode);
		return true;
	}
	bool CWispForm::Destroy()
	{
		m_FormItemMap.clear();
		return CWispWnd::Destroy();
	}
	CWispBaseWnd *CWispForm::GetFormItem(unsigned int CmdID)
	{
		map<unsigned int, CWispBaseWnd*>::IT it = m_FormItemMap.find(CmdID);
		if (it == m_FormItemMap.end())
			return nullptr;
		return it->second;
	}

	unsigned int CWispForm::GetFormResult()
	{
		return m_Result;
	}

```

`source/Wisp/wispform.hpp`:

```hpp

#ifndef _WISPFORM_HPP_
#define _WISPFORM_HPP_

#include "../Code/define.h"
#include "../Code/alt/altmap.hpp"
#include "wispwnd.hpp"

struct WISP_FORM_RES_ITEM
{
	unsigned int Type;
	WISP_RECT rc;
	unsigned int CmdID;
	unsigned int Style;
	const WCHAR *pName;
	void *pData;
	const WCHAR *pTipString;
};

struct CWispForm : public CWispWnd
{
	CWispForm();
	virtual ~CWispForm();
	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnEvent(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnCmdOk(WISP_MSG *pMsg);
	bool OnCmdCancel(WISP_MSG *pMsg);
	bool OnCmdDefault(WISP_MSG *pMsg);

	bool LoadForm(WISP_FORM_RES_ITEM *ItemAry);
	bool Create(CWispWnd *pParentWnd, int ShowMode);
	virtual bool Destroy() override;
	CWispBaseWnd *GetFormItem(unsigned int CmdID);
	map<unsigned int, CWispBaseWnd *> m_FormItemMap;

	unsigned int GetFormResult();
	unsigned int m_Result;
	WISP_FORM_RES_ITEM *m_Resource;
};

#endif
```

`source/Wisp/wisphexwnd.cpp`:

```cpp

#include "wisphexwnd.hpp"
#include "wispbase.hpp"

	const WCHAR *CWispHexWnd::m_UnReadable = WSTR("????????????????");
	const WCHAR *CWispHexWnd::m_UnReadableASCII = WSTR("...................");
	const WCHAR *CWispHexWnd::m_Spaces = WSTR("                ");

	CWispHexWnd::CWispHexWnd()
	{
		m_ImageHighBase = -1;
		m_ImageSize = -1;
		m_nByte_Line = 16;
		m_ShowLength = 1;
		m_CtrlType = WISP_CTRL_HEX_WND;
		m_ImageBase = 0;
		m_AlignScroll = 4;
		m_bShowOffset = true;
		m_ShowOffset = 0;
		m_bFloatAddress = false;
		m_Offset2 = 0;
		m_Size2 = 0;
		m_Size1 = 0;
		m_Offset1 = 0;
		m_HistoryIter = m_History.Begin();
	}
	CWispHexWnd::~CWispHexWnd()
	{
		m_History.Clear();
	}

	WISP_MSG_MAP_BEGIN(CWispHexWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_RECALC_LAYOUT, OnRecalcLayout)
		WISP_MSG_MAP(WISP_WM_CHAR, OnChar)
		WISP_MSG_MAP(WISP_WM_SCROLL_EVENT, OnScrollEvent)
	WISP_MSG_MAP_END(CWispWnd)

	bool CWispHexWnd::OnChar(WISP_MSG *pMsg)
	{
		char Buffer[4];
		char NumBuffer[16+1];

		int nStartLine = GetStartLine();
		WCHAR nChar = pMsg->Char.Char;
		int HitPoint = CorrectHitPoint(&m_CaretPos);

		if (HitPoint == HEX_ASCII_INDEX)
		{
			ULONG_PTR Addr;
			if (CalcPointPos(&m_CaretPos, &Addr, 0) && m_CaretIndex > m_nByte_Line)
			{
				if (ReadMemory(Addr, Buffer, 1))
				{
					Buffer[0] = nChar;
					if (WriteMemory(Addr, Buffer, 1))
					{
						WISP_MSG Msg;
						Msg.KeyEvent.bKeyDown = true;
						Msg.KeyEvent.KeyType = VK_RIGHT;
						OnKeyEvent(&Msg);
					}
				}
			}
			return true;
		}

		if (IS_HEX_DIGIT(nChar))
		{
			if (HitPoint == HEX_POS_INDEX && m_CaretIndex < ADDR_SIZE)
			{
				ULONG_PTR HexAddr = m_CurAddr + m_nByte_Line * (m_CaretnLine - nStartLine);
				TSPrintf(NumBuffer, F0ADDR "X", HexAddr);
				NumBuffer[m_CaretIndex] = nChar;
				ULONG_PTR Addr;
				if (USHexStrToNum(NumBuffer, &Addr))
				{
					unsigned long CaretnLine = (Addr - m_ImageBase) / m_nByte_Line;
					if (CaretnLine >= m_CaretnLine)
					{
						unsigned long CaretnLineSize = CaretnLine - m_CaretnLine;
						if (CaretnLineSize <= m_ImageHighBase/m_nByte_Line - m_nLines_Page)
						{
							ViewAddressMsg(Addr + m_CurAddr - HexAddr, 0);
							m_CaretPos.x += m_CharWidth;
							SetCaretPos(m_CaretPos.x, m_CaretPos.y);
							Update((WISP_RECT*)0);
							return true;
						}
						if (CaretnLineSize >= m_ImageHighBase / m_nByte_Line)
							return true;
						m_CaretPos.x += m_CharWidth;
						m_CaretPos.y = m_LineHeight * ((Addr-m_CurAddr)/m_nByte_Line);
					} else
					{
						m_CaretPos.y = CaretnLine * m_LineHeight;
						ViewAddressMsg(m_ImageBase, 0);
						m_CaretPos.x += m_CharWidth;
					}
					SetCaretPos(m_CaretPos.x, m_CaretPos.y);
					Update((WISP_RECT*)0);
				}
				return true;
			} else
			if (HitPoint == HEX_HEX_INDEX && m_CaretIndex%(m_ShowLength*3) < m_ShowLength*2)
			{
				ULONG_PTR Addr;
				if (CalcPointPos(&m_CaretPos, &Addr, 0))
				{
					ULONG_PTR NewAddr = Addr + m_ShowLength - m_CaretIndex%(m_ShowLength*3)/2 - 1;
					if (ReadMemory(NewAddr, Buffer, 1))
					{
						unsigned char byte = nChar > 0x39 ? (nChar|0x20)-0x57 : nChar-0x30;
						Buffer[0] = m_CaretIndex%(m_ShowLength*3)%2 ? (byte|(Buffer[0] & 0xF0)) : (byte<<4)|(Buffer[0] & 0xF);
						if (WriteMemory(NewAddr, Buffer, 1))
						{
							WISP_MSG Msg;
							Msg.KeyEvent.bKeyDown = true;
							Msg.KeyEvent.KeyType = VK_RIGHT;
							OnKeyEvent(&Msg);
							OnDataUpdated();
						}
					}
				}
				return true;
			}
		}
		return true;
	}
	bool CWispHexWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_ItemColor[HEX_START_INDEX] = m_pWispBase->m_pWispDrawObj->m_crSystem[0];
		m_ItemColor[HEX_POS_INDEX] = m_pWispBase->m_pWispDrawObj->m_crSystem[11];
		m_ItemColor[HEX_HEX_INDEX] = m_pWispBase->m_pWispDrawObj->m_crSystem[5];
		m_ItemColor[HEX_ASCII_INDEX] = m_pWispBase->m_pWispDrawObj->m_crSystem[104];
		m_BSelColor = m_pWispBase->m_pWispDrawObj->m_crSystem[105];
		m_TSelColor = m_pWispBase->m_pWispDrawObj->m_crSystem[1];
		m_BBPXColor = m_pWispBase->m_pWispDrawObj->m_crSystem[106];
		EnableScrollBar(0, 1, 1);
		EnableScrollBar(1, 1, 1);
		CreateCaret(WISP_DI_CARET);
		ShowCaret(true);
		SetCaretPos(0, 0);
		m_SelEnd = -1;
		m_SelStart = -1;
		m_bSelText = false;
		m_bSelect = false;
		m_CurAddr = 0;
		m_CharXPos = 0;
		SetBGColor(m_pWispBase->m_pWispDrawObj->m_crSystem[0]);
		m_CaretPos.y = 0;
		m_CaretPos.x = 0;
		m_AddressMode = 0;
		m_AddressModeOffs = 0;
		memset(m_Array2, 0, sizeof(m_Array2));
		m_Offset2 = 0;
		m_Size2 = 0;
		m_Size1 = 0;
 		
		return true;
	}

	WISP_CMD_MAP_BEGIN(CWispHexWnd)
		WISP_CMD_MAP(WISP_ID_VSPIN_SCROLL, OnCmdVSpinScroll)
	WISP_CMD_MAP_END

	bool CWispHexWnd::OnCmdVSpinScroll(WISP_MSG *pMsg)
	{
		if (m_Style & 0x10000 && pMsg->Command.CmdMsg == 0x80000002) //WISP_ID_KEYUP
			SetScrollBarCurPos(0, m_AlignScroll * m_nLines_Page, 0);
		return true;
	}
	bool CWispHexWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
	        if (!pMsg->KeyEvent.bKeyDown)
			return true;
		
	        int LineHeight = m_bShowOffset ? m_LineHeight : 0;

	        switch (pMsg->KeyEvent.KeyType)
	        {
                case VK_LBUTTON: {
			WISP_POINT Point = pMsg->MsgMouseWndPT;
                        Point.y -= m_ClientRect.y;
                        ShowCaret(true);
                        m_CurArea = CorrectHitPoint(&Point);
                        m_CaretPos.x = ROUNDPREV(Point.x, m_CharWidth);
                        m_CaretPos.y = ROUNDPREV(Point.y, m_LineHeight);
                        if (m_bSelect)
                        {
                                m_bSelect = false;
                                m_SelEnd = -1;
                                m_SelStart = -1;
                        }
                        SetCaretPos(m_CaretPos.x, m_CaretPos.y);
                        Update(&m_ClientRect);
                        } break;
                case VK_TAB: {
                        m_ShowLength *= 2;
		#ifdef _X64_
                        if (m_ShowLength >= 16)
		#else
                        if (m_ShowLength >= 8)
		#endif
                                m_ShowLength = 1;
                        Update(&m_ClientRect);
                        } break;
                case VK_PRIOR: {
                        m_CurAddr -= m_nLines_Page * m_nByte_Line;
                        MIN_LIMIT(m_CurAddr, m_ImageBase);
                        Update(&m_ClientRect);
                        } break;
                case VK_NEXT: {
                        m_CurAddr += m_nLines_Page * m_nByte_Line;
                        MAX_LIMIT(m_CurAddr, m_ImageHighBase - m_nLines_Page * m_nByte_Line);
                        ViewAddressMsg(m_CurAddr, 0);
                        Update(&m_ClientRect);
                        } break;
                case VK_END: {
                        m_CurAddr = m_ImageHighBase - m_nLines_Page * m_nByte_Line;
                        ViewAddressMsg(m_CurAddr, 0);
                        Update(&m_ClientRect);
                        } break;
                case VK_HOME: {
                        m_CurAddr = m_ImageBase;
                        ViewAddressMsg(m_CurAddr, 0);
                        Update(&m_ClientRect);
                        } break;
                case VK_LEFT: {
                        if (m_CaretPos.x >= m_CharWidth)
                        {
                                m_CaretPos.x -= m_CharWidth;
                                if (CorrectHitPoint(&m_CaretPos) == HEX_HEX_INDEX &&
					m_CaretIndex%(m_ShowLength*3) >= 2 * m_ShowLength && 
					m_CaretPos.x >= m_CharWidth)
				{
					m_CaretPos.x -= m_CharWidth * m_ShowLength;
					m_CaretIndex -= m_ShowLength;
                                }
                                SetCaretPos(m_CaretPos.x, m_CaretPos.y);
                        } else
			if (m_CaretPos.x == 0 && m_CharXPos > 0)
			{
				--m_CharXPos;
				CorrectHitPoint(&m_CaretPos);
			}
			Update(&m_ClientRect);
			} break;
                case VK_RIGHT: {
                        if (m_CaretPos.x < m_CharWidth * m_nChars_Line)
                        {
                                m_CaretPos.x += m_CharWidth;
                                if (CorrectHitPoint(&m_CaretPos) == HEX_HEX_INDEX &&
					m_CaretIndex%(m_ShowLength*3) >= 2 * m_ShowLength &&
					m_CaretPos.x < m_CharWidth * m_nChars_Line)
				{
					m_CaretPos.x += m_CharWidth * m_ShowLength;
					m_CaretIndex += m_ShowLength;
                                }
                                SetCaretPos(m_CaretPos.x, m_CaretPos.y);
                        } else
                        if (m_CaretPos.x == m_CharWidth * m_nChars_Line && m_CharXPos < m_CharMax)
                        {
				++m_CharXPos;
				CorrectHitPoint(&m_CaretPos);
                        }
			Update(&m_ClientRect);
			} break;
		case VK_UP: {
			if (m_CaretPos.y >= m_LineHeight + LineHeight)
			{
				m_CaretPos.y -= m_LineHeight;
				CorrectHitPoint(&m_CaretPos);
				SetCaretPos(m_CaretPos.x, m_CaretPos.y);
			} else
			if (m_CaretPos.y == LineHeight && m_CurAddr > m_ImageBase)
			{
				m_CurAddr -= m_nByte_Line;
				if (m_CurAddr < m_ImageBase)
				{
					m_CurAddr = m_ImageBase;
					ViewAddressMsg(m_CurAddr, 0);
				}
				CorrectHitPoint(&m_CaretPos);
			}
			Update(&m_ClientRect);
			} break;
		case VK_DOWN: {
			if (m_CaretPos.y < m_LineHeight * (m_nLines_Page - 1))
			{
				m_CaretPos.y += m_LineHeight;
				CorrectHitPoint(&m_CaretPos);
				SetCaretPos(m_CaretPos.x, m_CaretPos.y);
			} else
			if (m_CaretPos.y == m_LineHeight * (m_nLines_Page - 1) &&
				m_CurAddr < m_ImageHighBase - m_nByte_Line * m_nLines_Page)
			{
				m_CurAddr += m_nByte_Line;
				ViewAddressMsg(m_CurAddr, 0);
				CorrectHitPoint(&m_CaretPos);
			}
			Update(&m_ClientRect);
			} break;
		default:
			break;
		}
		return true;
	}
	bool CWispHexWnd::OnMouseMove(WISP_MSG *pMsg)
	{
		WISP_POINT MousePT = pMsg->MsgMouseWndPT;
		PointToRect(&MousePT, &m_ClientRect);
		if (pMsg->bMsgLBTDown)
		{
			ULONG_PTR Pos;
			if (m_bSelect)
			{
				if (CalcPointPos(&MousePT, &Pos, 0))
				{
					m_SelEnd = m_bSelText ? Pos : m_ShowLength + Pos - 1;
					Update((WISP_RECT*)0);
				}
			} else
			if (CalcPointPos(&MousePT, &Pos, 0))
			{
				ShowCaret(false);
				m_SelStart = Pos;
				m_bSelect = true;
				m_bSelText = m_CurArea == HEX_ASCII_INDEX;
				Update((WISP_RECT*)0);
			}
		}
		return true;
	}
	bool CWispHexWnd::OnMouseDblClick(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			if (m_bShowOffset && pMsg->m_LogicMousePosWnd.y < m_LineHeight)
			{
				m_ShowOffset = 1 - m_ShowOffset;
				Update((WISP_RECT*)0);
			} else
			{
				int Width = 2 * m_ShowLength;
			#ifdef _X64_
				if (Width >= 16)
			#else
				if (Width >= 8)
			#endif
					Width = 1;
				if (m_CaretIndex >= 0 && m_CaretIndex < ADDR_SIZE && m_CurArea == HEX_POS_INDEX)
					SetDataWidth(Width);
			}
		}
		return true;
	}
	bool CWispHexWnd::OnUpdateClient(WISP_MSG *pMsg)
	{
		WCHAR Buffer[0x200];

		CWispWnd::OnUpdateClient(pMsg);

		int nStartLine = GetStartLine();
		m_Size1 = 0;

		if (m_bShowOffset != 0)
		{
			unsigned int v6 = m_nByte_Line/m_ShowLength;

			m_ClientDC.m_TextStyle = 0;
			int XStart = m_ItemSpace[HEX_START_INDEX] + m_ItemSpace[HEX_POS_INDEX];
			int GroupLen = m_ShowLength*3;

			m_ClientDC.SetTextColor(m_ItemColor[HEX_POS_INDEX]);
			if (m_ShowOffset)
			{
				//TODO
				m_ClientDC.SetTextColor(m_ItemColor[HEX_POS_INDEX]);
			}
			unsigned int HexLen = 0;
			int HexVal = 1;
			while (v6-- > 0)
			{
				if (m_ShowOffset)
				{
					for (int n = 0,i = 0; n < m_ShowLength; ++n,i+=2)
					{
						//TSPrintf(&Buffer[i], WSTR("+%X"), (HexVal*m_ShowLength-n-1));
						TSPrintf(&Buffer[i], WSTR("%2X"), (HexVal*m_ShowLength-n-1));
						//break; //FIX
					}
				} else
				{
					for (int n = 0,i = 0; n < m_ShowLength; ++n,i+=2)
						TSPrintf(&Buffer[i], WSTR("%X "), (HexVal*m_ShowLength-n-1+m_CurAddr) % m_nByte_Line);
				}
                                m_ClientDC.DrawString(m_CharWidth * (XStart + HexLen - m_CharXPos),
					(nStartLine-1)*m_LineHeight, Buffer, 2 * m_ShowLength, 0, 0);

				HexVal++;
				HexLen += GroupLen;
			}
		}

		if (m_bFloatAddress)
		{
			ULONG_PTR Addr = GetFloatAddress(m_FloatAddressStr);
			if (Addr != m_CurAddr)
				ViewAddressMsg(Addr, 0);
		}

		memset(m_LenArray, 0, sizeof(m_LenArray));

		unsigned char DataBuffer[32];
		memset(DataBuffer, 0, sizeof(DataBuffer));

		WCHAR szSpace[32+1];

		for (int nLine = 0; nLine < m_nLines_Page; ++nLine)
		{
			int XStart = m_ItemSpace[HEX_START_INDEX];
			int YLine = (nStartLine + nLine) * m_LineHeight;

			ULONG_PTR Address = m_CurAddr + nLine * m_nByte_Line;
			if (m_AddressMode == 0)
			{
				TSPrintf(Buffer, WSTR("" F0ADDR "X:"), Address);
			} else
			{
				LONG_PTR AddressOffset = Address - m_AddressModeOffs;
				if (AddressOffset > 0)
					TSPrintf(Buffer, WSTR("$+%X"), AddressOffset);
				else
				if (AddressOffset < 0)
					TSPrintf(Buffer, WSTR("$-%X"), -AddressOffset);
				else
					TStrCpy(Buffer, "$ ==>");
			}

			int Len = TStrLen(Buffer);

			m_LenArray[nLine][HEX_POS_INDEX] = Len;

			m_ClientDC.m_TextStyle = 0;
			m_ClientDC.SetTextColor(m_ItemColor[HEX_POS_INDEX]);

			m_ClientDC.DrawString( (XStart - m_CharXPos) * m_CharWidth,
							YLine, Buffer, Len, 0, 0);

			XStart += m_ItemSpace[HEX_POS_INDEX];

			unsigned long AsciiLen = m_ImageBase + m_ImageSize - (nLine * m_nByte_Line) - m_CurAddr;
			MAX_LIMIT(AsciiLen, m_nByte_Line);

			TStrCpy(szSpace, CWispHexWnd::m_Spaces);

			MAX_LIMIT(m_ShowLength, 32); //???
			szSpace[m_ShowLength] = 0;

			int HexLen = PAGE_COUNT(AsciiLen, m_ShowLength);

			int GroupLen = m_ShowLength*3;

			m_LenArray[nLine][HEX_HEX_INDEX] = HexLen * GroupLen;

			int GroupX = 0;
			
			for (int HexIt = 0; HexIt < HexLen; ++HexIt)
			{
				bool bSame = false;
				if (!ReadMemory(Address + HexIt * m_ShowLength, DataBuffer, m_ShowLength))
				{
					TStrCpy(Buffer, CWispHexWnd::m_UnReadable);
				} else
				{
					THexBytesToStr(DataBuffer, Buffer, AsciiLen, m_ShowLength, szSpace);
					
					for (unsigned int i = 0; i < m_ShowLength; ++i)
						m_Array1[i+ m_Size1] = DataBuffer[i];

					m_Size1 += m_ShowLength;
					bSame = DataWidthCompare(Address + HexIt * m_ShowLength, DataBuffer);
				}
				unsigned int HexAttr = GetHexByteAttribute(m_CurAddr + nLine * m_nByte_Line + HexIt * m_ShowLength);
				if (HexAttr == HEX_BYTE_NORMAL)
				{
					m_ClientDC.m_TextStyle = 0;
					if (!bSame)
						m_ClientDC.SetTextColor(m_ItemColor[HEX_HEX_INDEX]);
					else	m_ClientDC.SetTextColor(0xFFFF00);
				} else
				if (HexAttr == HEX_BYTE_SEL)
				{
					m_ClientDC.m_TextStyle = 1;
					m_ClientDC.SetTextBKColor(m_BSelColor);
					if (!bSame)
						m_ClientDC.SetTextColor(m_TSelColor);
					else	m_ClientDC.SetTextColor(0xFFFF00);
				} else
				if (HexAttr == HEX_BYTE_BPX)
				{
					m_ClientDC.m_TextStyle = 1;
					m_ClientDC.SetTextBKColor(m_BBPXColor);
					m_ClientDC.SetTextColor(m_ItemColor[HEX_HEX_INDEX]);
				}
				m_ClientDC.DrawString(m_CharWidth * (XStart + GroupX - m_CharXPos),
						YLine, Buffer, m_ShowLength*2, 0, 0);
				GroupX += GroupLen;
			}

			XStart += m_ItemSpace[HEX_HEX_INDEX];

			m_LenArray[nLine][HEX_ASCII_INDEX] = m_nByte_Line;

			for (int AsciiIt = 0; AsciiIt < AsciiLen; ++AsciiIt)
			{
				if (!ReadMemory(Address + AsciiIt, DataBuffer, 1))
					TStrCpy(Buffer, CWispHexWnd::m_UnReadableASCII);
				else	THexBytesToPrint(DataBuffer, Buffer, 1);

				unsigned int HexAttr = GetHexByteAttribute(AsciiIt + m_CurAddr + nLine * m_nByte_Line);
				if (HexAttr == HEX_BYTE_NORMAL)
				{
					m_ClientDC.m_TextStyle = 0;
					m_ClientDC.SetTextBKColor(m_pWispBase->m_pWispDrawObj->m_crSystem[20]);
					m_ClientDC.SetTextColor(m_ItemColor[HEX_ASCII_INDEX]);
				} else
				if (HexAttr == HEX_BYTE_SEL)
				{
					m_ClientDC.m_TextStyle = 1;
					m_ClientDC.SetTextBKColor(m_BSelColor);
					m_ClientDC.SetTextColor(m_TSelColor);
				}
				m_ClientDC.DrawString(m_CharWidth * (XStart + AsciiIt - m_CharXPos),
							YLine, Buffer, 1, 0, 0);
			}
		}

		m_Offset1 = m_CurAddr;
		if (!m_Size2)
			DataWidthUpdate();
		return false;
	}
	bool CWispHexWnd::OnRecalcLayout(WISP_MSG *pMsg)
	{
		m_nChars_Line = m_ClientRect.cx / m_ClientDC.m_pFont->m_Width;
		m_nLines_Page = m_ClientRect.cy / m_ClientDC.m_pFont->m_Height;

		m_CharWidth = m_ClientDC.m_pFont->m_Width;
		m_LineHeight = m_ClientDC.m_pFont->m_Height;

		if (m_nLines_Page % m_LineHeight > m_LineHeight/2)
			++m_nLines_Page;
		if (m_ClientRect.cx < 0)
			m_nChars_Line = 0;

		MIN_LIMIT(m_nLines_Page, 0);
		
		MAX_LIMIT(m_CurAddr, m_ImageHighBase - m_nLines_Page*m_nByte_Line);
		MIN_LIMIT(m_CurAddr, m_ImageBase);

		m_ItemSpace[HEX_START_INDEX] = 1;
		m_ItemSpace[HEX_ASCII_INDEX] = m_nByte_Line + 1; //used below
		m_ItemSpace[HEX_POS_INDEX] = ADDR_SIZE+2;
		m_ItemSpace[HEX_HEX_INDEX] = m_nByte_Line*3;

		if (m_nChars_Line > (int)(m_nByte_Line*4+ADDR_SIZE+3))
		{
			m_CharXPos = 0;
			int Width = (m_nChars_Line - m_nByte_Line*3 - m_ItemSpace[HEX_ASCII_INDEX] - (ADDR_SIZE+3))/2;
			m_ItemSpace[HEX_POS_INDEX] += Width;
			m_ItemSpace[HEX_HEX_INDEX] += Width;
		}

		MAX_LIMIT(m_nLines_Page, m_ImageSize/m_nByte_Line);

		m_CharMax = m_ItemSpace[HEX_POS_INDEX] +
			    m_ItemSpace[HEX_HEX_INDEX] +
			    m_ItemSpace[HEX_ASCII_INDEX] + 1;

		MIN_LIMIT(m_CharMax, m_nChars_Line-1);
		return true;
	}
	bool CWispHexWnd::OnScrollEvent(WISP_MSG *pMsg)
	{
		int nLines_Page = m_nLines_Page;
		CWispWnd::OnScrollEvent(pMsg);
		if (m_bShowOffset)
			--nLines_Page;
		if (pMsg->ScrollEvent.Type == 1) //HORZ ???
		{
			m_CharXPos = m_pScrollBar[1]->CurPos;
			return false;
		}
		
		if (m_Style & 0x10000)
		{
			switch (pMsg->ScrollEvent.Event)
			{
			case WISP_SB_INC:
				ViewAddressMsg(m_CurAddr + m_nByte_Line, 0);
				SetScrollBarCurPos(0, m_nLines_Page * m_AlignScroll, 0);
				break;
			case WISP_SB_DEC:
				ViewAddressMsg(m_CurAddr - m_nByte_Line, 0);
				SetScrollBarCurPos(0, m_nLines_Page * m_AlignScroll, 0);
				break;
			case WISP_SB_PAGE_UP:
				ViewAddressMsg(m_CurAddr - nLines_Page*m_nByte_Line, 0);
				SetScrollBarCurPos(0, m_nLines_Page * m_AlignScroll, 0);
				break;
			case WISP_SB_PAGE_DOWN:
				ViewAddressMsg(m_CurAddr + nLines_Page*m_nByte_Line, 0);
				SetScrollBarCurPos(0, m_nLines_Page * m_AlignScroll, 0);
				break;
			case WISP_SB_POS_CHANGE:
				ViewAddressMsg(m_CurAddr + pMsg->ScrollEvent.Delta * m_nByte_Line, 0);
				break;
			default:
				SetScrollBarCurPos(0, m_nLines_Page * m_AlignScroll, 0);
			}
			
			return false;
		} else
		{
			ULONG_PTR CurAddr = m_nByte_Line * m_pScrollBar[0]->CurPos;
			if (CurAddr >= m_ImageBase && CurAddr < m_ImageHighBase)
			{
				m_CurAddr = CurAddr;
				DataWidthUpdate();	
				OnChangeView();
			}
		}
		return true;
	}
	bool CWispHexWnd::OnSize(WISP_MSG *pMsg)
	{
		if (m_Style & 0x10000)
		{
			int nLines_Page = m_nLines_Page;
			if (m_bShowOffset)
				--nLines_Page;

			SetScrollBarInfo(0, m_nLines_Page * m_AlignScroll, m_nLines_Page * (2 * m_AlignScroll + 1), nLines_Page, 0, 0);
		} else
		{
			SetScrollBarRange(0, m_ImageHighBase / m_nByte_Line, m_ImageBase / m_nByte_Line);
		}
		SetScrollBarInfo(1, m_CharXPos, m_CharMax, m_nChars_Line, 0, 1);
		return true;
	}

	unsigned long CWispHexWnd::WriteMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		return 0;
	}
	unsigned long CWispHexWnd::ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		return 0;
	}

	unsigned int CWispHexWnd::GetHexByteAttribute(ULONG_PTR Address)
	{
		unsigned int HexByte = HEX_BYTE_NORMAL;
		if (m_bSelect)
		{
			ULONG_PTR Start = MIN(m_SelStart, m_SelEnd);
			ULONG_PTR End = MAX(m_SelStart, m_SelEnd);

			if (Start >= m_ImageBase && End < m_ImageBase + m_ImageSize &&
				Address >= Start && Address <= End)
				HexByte = HEX_BYTE_SEL;
		}
		return HexByte;
	}

	unsigned int CWispHexWnd::CorrectHitPoint(WISP_POINT *pPoint)
	{
		int x = pPoint->x + m_CharXPos * m_CharWidth;
		int nLine = pPoint->y/m_LineHeight;
		if (nLine >= m_nLines_Page)
		{
			nLine = m_nLines_Page - 1;
			pPoint->y = nLine * m_LineHeight;
		}
		int MaxX = 0;
		m_CaretnLine = pPoint->y/m_LineHeight;
		for (int SpaceIndex = 0; SpaceIndex < 4; ++SpaceIndex)
		{
			int MinX = MaxX;
			MaxX += m_CharWidth * m_ItemSpace[SpaceIndex];	
			if (x >= MinX && x < MaxX)
			{
				int WW = MinX + m_CharWidth * m_LenArray[nLine][SpaceIndex];
				if (x <= WW)
				{
					//WW = pPoint->x;
					m_CaretIndex = (pPoint->x - MinX) / m_CharWidth;
					return SpaceIndex;
				} else
				if (x - WW >= MaxX - x)
				{
					pPoint->x = MaxX - m_CharWidth * m_CharXPos;
					m_CaretIndex = 0;
					return SpaceIndex+1;
				} else
				{
					pPoint->x = WW - m_CharWidth * m_CharXPos;
					m_CaretIndex = (WW - MinX) / m_CharWidth;
					return SpaceIndex;
				}
				//return SpaceIndex;
			}
		}
		
		pPoint->x = MaxX;
		m_CaretIndex = m_ItemSpace[3]; //HEX_ASCII_INDEX
		return 3;
	}
	bool CWispHexWnd::CalcPointPos(WISP_POINT *pPoint, ULONG_PTR *pPos, unsigned long *pLength)
	{
		int Offset = GetStartLine();
		int x = pPoint->x + m_CharWidth * m_CharXPos;
		int MinX = m_CharWidth * (m_ItemSpace[HEX_START_INDEX] + m_ItemSpace[HEX_POS_INDEX]);
		int nLine = pPoint->y / m_LineHeight;
		if (nLine < Offset)
			return false;

		nLine -= Offset;
		if (x >= MinX && x < MinX + m_CharWidth*(m_nByte_Line*3 - m_ShowLength))
		{
			m_CurArea = HEX_HEX_INDEX;
			*pPos = m_CurAddr + (nLine*m_nByte_Line) + (((x - MinX)/m_CharWidth)/(m_ShowLength*3))*m_ShowLength;
			if (pLength)
				*pLength = (x - MinX)/m_CharWidth % (m_ShowLength*3);
			return true;
		}
		MinX += m_CharWidth * m_ItemSpace[HEX_HEX_INDEX];
		if (x >= MinX && x < MinX + m_CharWidth * m_nByte_Line)
		{
			m_CurArea = HEX_ASCII_INDEX;
			*pPos = m_CurAddr + (nLine*m_nByte_Line) + ((x-MinX)/m_CharWidth);
			return true;
		}
		return false;
	}
	bool CWispHexWnd::ViewAddress(ULONG_PTR Address, bool bHistory)
	{
		ULONG_PTR PrevAddr = m_CurAddr;
		if (Address < m_ImageBase || Address >= m_ImageHighBase)
				return false;
		if (m_Style & 0x10000)
			m_CurAddr = Address;
		else
		if (m_nLines_Page > 0)
			SetScrollBarCurPos(0, Address/m_nByte_Line, 0);
		if (bHistory && m_CurAddr)
			AddPos(m_CurAddr, PrevAddr);
		OnChangeView();
		DataWidthUpdate();
		Update((WISP_RECT*)0);
		return true;
			
	}
	bool CWispHexWnd::ViewAddressMsg(ULONG_PTR Address, bool bUpdate) //private
	{
		if (Address < m_ImageBase || Address >= m_ImageHighBase)
				return false;
		m_CurAddr = Address;
		DataWidthUpdate();
		OnChangeView();
		return true;
	}

	int CWispHexWnd::GetDataWidth()
	{
		return m_ShowLength;
	}

	bool CWispHexWnd::SetDataWidth(int width)
	{
		if (16 % width) return false;
		m_ShowLength = width;
		Update((WISP_RECT*)0);
		return true;
	}

	void CWispHexWnd::SetFloatAddress(const WCHAR *StringAddr)
	{
		m_FloatAddressStr = StringAddr;
	}

	ULONG_PTR CWispHexWnd::GetFloatAddress(const TWideString & FixedAddress)
	{
		return m_CurAddr;
	}

	void CWispHexWnd::OnChangeView()
	{
		//???
	}

	void CWispHexWnd::OnDataUpdated()
	{
		//???
	}

	int CWispHexWnd::GetStartLine()
	{
		int nStartLine = 0;
		if (m_bShowOffset)
			nStartLine += 1;
		return nStartLine;
	}

	bool CWispHexWnd::DataWidthCompare(ULONG_PTR Address, unsigned char *Buffer)
	{
		if (Address >= m_Offset2 && Address < m_Offset2+m_Size2)
		{
			unsigned long Start = Address - m_Offset2;
			for (int n = 0; n < m_ShowLength; ++n)
			{
				if (Buffer[n] != m_Array2[Start+n])
					return true;
			}
		}
		return false;
	}
	void CWispHexWnd::DataWidthUpdate()
	{
		if (m_Size1)
		{
			for (int n = 0; n < m_Size2; ++n)
			{
				if (m_Offset2+n >= m_Offset1 && m_Offset2+n < m_Offset1+m_Size1)
					m_Array1[m_Offset2+n - m_Offset1] = m_Array2[n];
			}
			memcpy(m_Array2, m_Array1, m_Size1);
			m_Size2 = m_Size1;
			m_Offset2 = m_Offset1;
		}
	}

	int CWispHexWnd::GetAddressMode()
	{
		return m_AddressMode;
	}

	void CWispHexWnd::SetAddressMode(int Mode, ULONG_PTR Addr)
	{
		if (Mode <= 0 || Mode >= 2) Mode = 0;
		m_AddressMode = Mode;
		m_AddressModeOffs = Addr;
		OnUpdateClient(0);
	}

	bool CWispHexWnd::GetFloatAddressMode()
	{
		return m_bFloatAddress;
	}

	bool CWispHexWnd::ToggleFloatAddressMode()
	{
		m_bFloatAddress = !m_bFloatAddress;
		Update((WISP_RECT*)0);
		return m_bFloatAddress==0;
	}

	void CWispHexWnd::ToggleHexOffset()
	{
		m_bShowOffset = !m_bShowOffset;
		Update((WISP_RECT*)0);
		//???
	}

	void CWispHexWnd::AddPos(ULONG_PTR Addr, ULONG_PTR PrevAddr)
	{
		if (m_History.Size()>100)
		{
			if (m_HistoryIter == m_History.Begin())
				m_HistoryIter++;
			m_History.Remove(m_History.Begin());
		}

		if (m_History.Size()==0 && Addr != PrevAddr)
			m_HistoryIter = m_History.Append(&Addr);

		if (Addr != *(m_History.End()-1)) //???
			m_HistoryIter = m_History.Append(&Addr);
	}

	void CWispHexWnd::ResetPos()
	{
	        m_History.Clear();
	        m_HistoryIter = m_History.Append(&m_CurAddr);
	}
	void CWispHexWnd::SavePos()
	{
		if (m_HistoryIter != m_History.End()-1)
		{
			m_HistoryIter++;
			m_History.Remove(m_HistoryIter, m_History.End());
			m_HistoryIter = m_History.End();
		}
		if (m_History.Size()>100)
		{
			if (m_HistoryIter == m_History.Begin())
				m_HistoryIter++;
			m_History.Remove(m_History.Begin());
		}
		if (!m_History.Size() || m_CurAddr != *(m_History.End()-1))
			m_HistoryIter = m_History.Append(&m_CurAddr);
	}

	void CWispHexWnd::PrevPos() //WISP_MSG*
	{
		if (m_HistoryIter == m_History.End() || *m_HistoryIter == m_CurAddr)
		{
			if (m_HistoryIter != m_History.Begin())
			{
				m_HistoryIter--;
				ViewAddress(*m_HistoryIter, 0);
			}
		} else
		{
			ViewAddress(*m_HistoryIter, 0);
		}
	}

	void CWispHexWnd::NextPos() //WISP_MSG*
	{
		if (m_HistoryIter == m_History.End() || *m_HistoryIter == m_CurAddr)
		{
			if (m_HistoryIter != m_History.End()-1)
			{
				m_HistoryIter++;
				ViewAddress(*m_HistoryIter, 0);
			}
		} else
		{
			ViewAddress(*m_HistoryIter, 0);
		}
	}


```

`source/Wisp/wisphexwnd.hpp`:

```hpp

#ifndef _WISPHEXWND_HPP_
#define _WISPHEXWND_HPP_

#include "../Code/define.h"
#include "../Code/alt/altlist.hpp"
#include "wispwnd.hpp"

enum 
{
	HEX_START_INDEX = 0,
	HEX_POS_INDEX = 1,
	HEX_HEX_INDEX = 2,
	HEX_ASCII_INDEX = 3,
	HEX_ITEM_COUNT = 4,
};

enum 
{
	HEX_BYTE_NORMAL = 0,
	HEX_BYTE_SEL = 1,
	HEX_BYTE_BPX = 2,
};

struct CWispHexWnd : public CWispWnd
{
	CWispHexWnd();
	virtual ~CWispHexWnd();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnChar(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdVSpinScroll(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	bool OnMouseDblClick(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnRecalcLayout(WISP_MSG *pMsg);
	bool OnScrollEvent(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);

	virtual unsigned long WriteMemory(ULONG_PTR Address, void *Buffer, unsigned long Size);
	virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size);

	virtual unsigned int GetHexByteAttribute(ULONG_PTR Address);

	unsigned int CorrectHitPoint(WISP_POINT *pPoint);
	bool CalcPointPos(WISP_POINT *pPoint, ULONG_PTR *pPos, unsigned long *pLength);
	bool ViewAddress(ULONG_PTR Address, bool bHistory);
	bool ViewAddressMsg(ULONG_PTR Address, bool bUpdate); //private

	int GetDataWidth();
	bool SetDataWidth(int width);

	void SetFloatAddress(const WCHAR *StringAddr);
	virtual ULONG_PTR GetFloatAddress(const TWideString & FloatAddress);

	virtual void OnChangeView();
	virtual void OnDataUpdated();
	virtual int GetStartLine();

	bool DataWidthCompare(ULONG_PTR Address, unsigned char *Buffer);
	void DataWidthUpdate();

	int GetAddressMode();
	void SetAddressMode(int Mode, ULONG_PTR Addr);

	bool GetFloatAddressMode();

	bool ToggleFloatAddressMode();
	void ToggleHexOffset();

	void AddPos(ULONG_PTR Addr, ULONG_PTR PrevAddr);
	void ResetPos();
	void SavePos();
	void PrevPos();
	void NextPos();

	unsigned long m_ShowOffset;
	bool m_bShowOffset;

	ULONG_PTR m_ImageBase;
	ULONG_PTR m_ImageSize;
	ULONG_PTR m_ImageHighBase;
	ULONG_PTR m_CurAddr;

	unsigned long m_BSelColor;
	unsigned long m_TextColor;
	unsigned long m_TSelColor;
	unsigned long m_BBPXColor;

	unsigned long m_AlignScroll;

	int m_ShowLength;
	int m_nLines_Page;
	int m_nChars_Line;
	int m_LineHeight;
	int m_CharWidth;
	int m_nByte_Line;
	int m_CharXPos;
	int m_CharMax;
	int m_CaretIndex;
	int m_CaretnLine;
	WISP_POINT m_CaretPos;
	ULONG_PTR m_SelStart;
	ULONG_PTR m_SelEnd;
	bool m_bSelect;
	bool m_bSelText;
	unsigned long m_CurArea;

	unsigned long m_SrhAddr;
	unsigned char m_SrhData[256];
	unsigned long m_SrhSize;
	unsigned long m_SrhLeftSize;
	char m_SrhbCase;

	int m_LenArray[256][HEX_ITEM_COUNT];
	unsigned long m_ItemColor[HEX_ITEM_COUNT];
	int m_ItemSpace[HEX_ITEM_COUNT];

	unsigned long m_AddressMode;//Address=1,Offset=0
	ULONG_PTR m_AddressModeOffs;
	TWideString m_FloatAddressStr;
	bool m_bFloatAddress;//Fixed=1,Float=0
	unsigned char m_Array2[4096];
	ULONG_PTR m_Offset2;
	ULONG_PTR m_Offset1;
	unsigned long m_Size2;

	unsigned char m_Array1[4096];
	unsigned long m_Size1;

	TList<ULONG_PTR> m_History;
	TListIter<ULONG_PTR> m_HistoryIter;

	static const WCHAR *m_UnReadable;      //L"????????????????"
	static const WCHAR *m_UnReadableASCII; //L"..................."
	static const WCHAR *m_Spaces;          //L"                "
};

#endif

```

`source/Wisp/wisplist.cpp`:

```cpp

#include "../Code/alt/altarray.hpp"
#include "wisplist.hpp"
#include "wispbase.hpp"

//
//
#define ID_EDIT		0x80000000
#define ID_TIP		0x80000001
#define ID_TIP_TIMER	0x80000002

	int CListStringItem::GetItemLevel()
	{
		int Level = 0;
		CListStringItem *Item = pParentItem;
		while (Item)
		{
			Item = Item->pParentItem;
			++Level;
		}
		return Level-1;
	}
	int CListStringItem::GetChildItemExpandCount()
	{
		int nCount = Size();
		TListIter<CListStringItem> It = Begin();
		while (It != End())
		{
			if (It->uStatus & 1) //LIST_EXPAND
				nCount += It->GetChildItemExpandCount();
			++It;
		}
		return nCount;
	}

	bool CListStringItem::ItemHasChildren(CListStringItem *Item)
	{
		do {
			if (!Item->pParentItem)
				return false;
			Item = Item->pParentItem;
		} while (Item != this);
		return true;
	}

//
	CWispList::CWispList()
	{
		m_RootItem.pParentItem = 0;
		m_RootItem.Checked = 0;

		m_nLayoutHeight = 0;
		m_nMaxLayoutHeight = 0;

		m_nSpaceWidth = 3;
		m_nCtrlBoxWidth = 12;
		m_nLineHeight = 16;

		m_RootItem.uStatus = 1; //LIST_EXPAND
		m_CtrlType = WISP_CTRL_LIST;
		m_nTipPeriod = 700;
	}

	CWispList::~CWispList()
	{
	}

	bool CWispList::Destroy()
	{
		m_TipWnd.Destroy();
		m_FocusedIter = m_RootItem.End();
		m_RootItem.Clear();
		m_RootItem.Checked = 0;
		m_RootItem.SemiChecked = 0;
		m_RootItem.uStatus = 1; //LIST_EXPAND
		m_Columns.Clear();
		return CWispWnd::Destroy();
	}

	bool CWispList::Recalc(bool bMin)
	{
		if (!(m_Style & 0x1'0000))
			return false;

		if (bMin)
		{
			if (m_nLayoutHeight <= 0)
			{
				m_nMaxLayoutHeight = m_nLayoutHeight;
				m_nLayoutHeight = 0;
				RecalcLayout();
			}
		} else
		{
			if (m_nLayoutHeight > 0)
			{
				m_nLayoutHeight = m_nMaxLayoutHeight;
				RecalcLayout();
			}
			
		}
		return true;
	}
	void CWispList::RecalcLayout()
	{
		CWispWnd::RecalcLayout();

		m_LayoutRect.x = 0;
		m_LayoutRect.y = 0;
		m_LayoutRect.cx = m_ClientRect.cx;
		if (m_Style & 0x1'0000)
			m_LayoutRect.cy = m_nLayoutHeight;
		else	m_LayoutRect.cy = 0;

		m_ColumnRect.x = 0;
		m_ColumnRect.y = m_LayoutRect.cy;
		
		m_ColumnRect.cy = m_ClientRect.cy - m_LayoutRect.cy;
		
		m_nVSBPage = m_ClientRect.cy;
		if (m_Style & 0x1'0000)
			m_nVSBPage = m_ColumnRect.cy; //m_ClientRect.cy - m_LayoutRect.cy;

		m_nVSBPage = (m_nVSBPage + m_nLineHeight/3)/m_nLineHeight;
		MIN_LIMIT(m_nVSBPage, 0);

		if (m_pScrollBar[0] && m_nVSBPage != m_pScrollBar[0]->Page)
			SetScrollBarPage(0, m_nVSBPage);

		m_nNonTextWidth = 0;
		if (m_Style & 0x2'0000)
			m_nNonTextWidth += m_nCtrlBoxWidth;
		if (m_Style & 0x40'0000)
			m_nNonTextWidth += m_nCtrlBoxWidth;

		if (m_pScrollBar[1] && m_ClientRect.cx > 0)
		{
			int nHSBPage = m_ClientRect.cx / m_CharMiddleWidth;
			if (m_pScrollBar[1]->Page != nHSBPage)
				SetScrollBarPage(1, nHSBPage);
		}
		
		m_nColumnWidth = 0;
		int PosX = 0;
		TListIter<stWispHeaderItem> It = m_Columns.Begin();
		while (It != m_Columns.End())
		{
			It->RCDIB.x = PosX;
			It->RCDIB.y = m_LayoutRect.y;
			if (It == m_Columns.End()-1)
			{
				MIN_LIMIT(It->nRealWidth, m_ClientRect.cx - m_nColumnWidth);
				m_nColumnWidth += It->nRealWidth;
				if (m_pScrollBar[1] &&
					m_nColumnWidth != m_CharMiddleWidth * m_pScrollBar[1]->MaxPos)
				{
					if (m_pScrollBar[1]->bHide)
					{
						if (It->nRealWidth >= It->nInitWidth + m_pWispBase->m_Metrics[WISP_SM_SCROLL_BAR_SIZE])
							m_nColumnWidth -= m_pWispBase->m_Metrics[WISP_SM_SCROLL_BAR_SIZE];
					}
					SetScrollBarRange(1, m_nColumnWidth/m_CharMiddleWidth, 0);
				}
			} else
			{
				m_nColumnWidth += It->nRealWidth;
			}
			It->RCDIB.cx = It->nRealWidth;
			It->RCDIB.cy = m_LayoutRect.cy;
			                              
			It->RCRECT.x = It->nRealWidth + PosX - 2;;
			It->RCRECT.y = m_LayoutRect.y + 2;
			It->RCRECT.cx = 2;
			It->RCRECT.cy = m_LayoutRect.cy - 4;

			It->RCDRAG.x = It->nRealWidth + PosX - 2;
			It->RCDRAG.y = m_LayoutRect.y;
			It->RCDRAG.cx = 6;
			It->RCDRAG.cy = m_LayoutRect.cy;
			PosX += It->nRealWidth;
			++It;
		}
		m_ColumnRect.cx = m_nColumnWidth;

		CWispList::ScrollPage(0);
	}
	bool CWispList::InitWnd()
	{
		m_pDragColumn = 0;
		m_nColumnWidth = 0;
		m_nVSBPage = 0;
		m_PrevMousePos.y = -1;
		m_PrevMousePos.x = -1;
		m_CharMiddleWidth = m_ClientDC.m_pFont->GetCharWidth(0x30)/2;
		m_RootIter = m_RootItem.End();
		m_bEnableEdit = true;
		m_bTipShow = false;
		m_FocusedIter = m_RootItem.End();
		m_bEditDateUpdate = false;
		m_nLineHeight = m_ClientDC.GetTextHeight(0) + 4;
		return CWispWnd::InitWnd();
	}
	void CWispList::Hide()
	{
		if (m_TipWnd.IsWindowShow())
			HideTip();
	}

	WISP_MSG_MAP_BEGIN(CWispList)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_SCROLL_EVENT, OnScrollEvent)
		WISP_MSG_MAP(WISP_WM_TIMER_EVENT, OnTimer)
		WISP_MSG_MAP(WISP_WM_LOST_FOCUS, OnLostFocus)
		WISP_MSG_MAP(WISP_WM_DRAG_BEGIN, OnDragBegin)
		WISP_MSG_MAP(WISP_WM_DRAG_MOVE, OnDragMove)
		WISP_MSG_MAP(WISP_WM_DRAG_END, OnDragEnd)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_CREATING, OnCreating)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
	WISP_MSG_MAP_END(CWispWnd)

	bool CWispList::OnUpdate(WISP_MSG *pMsg)
	{
//		UpdateItemColor(0);
		return true;
	}

	bool CWispList::OnSize(WISP_MSG *pMsg)
	{
		if (pMsg->Sizing.ScrSize.cx <= 0 && m_Columns.Size())
		{
			if ((m_Columns.End()-1)->nRealWidth > (m_Columns.End()-1)->nInitWidth)
			{
				(m_Columns.End()-1)->nRealWidth += pMsg->Sizing.ScrSize.cx;
				m_nColumnWidth += pMsg->Sizing.ScrSize.cx;
			}
		}
		return true;
	}
	bool CWispList::OnScrollEvent(WISP_MSG *pMsg)
	{
		if (CWispWnd::OnScrollEvent(pMsg) && pMsg->ScrollEvent.Type == 0) //WISP_SCROLL_BAR_VERT
		{
			ScrollPage(pMsg->ScrollEvent.Delta);

			if (pMsg->ScrollEvent.Event == 3 && m_FocusedIter != m_RootItem.End()) //WISP_SB_PAGE_DOWN
			{
				TListIter<CListStringItem> It = m_RootIter;
				if (pMsg->ScrollEvent.Delta == 0)
				{
					for (int i = 1; i < m_nVSBPage; ++i) //???
						if (!NextOpen(It)) break;
				}

				if (It != m_RootItem.End())
					Select(&*It);

			}

			if (pMsg->ScrollEvent.Event == 2 && m_FocusedIter != m_RootItem.End()) //WISP_SB_PAGE_UP
			{
				TListIter<CListStringItem> It = m_RootIter;
				if (pMsg->ScrollEvent.Delta < 0)
				{
					for (int i = 1; i < m_nVSBPage; ++i) //???
						if (!NextOpen(It)) break;
				}

				if (It != m_RootItem.End())
					Select(&*It);
			}
		}
		return false;
	}

	bool CWispList::OnTimer(WISP_MSG *pMsg)
	{
		if (pMsg->Timer.ID == ID_TIP_TIMER &&
			m_PrevMousePos.x == pMsg->m_LogicMousePosWnd.x &&
			m_PrevMousePos.y == pMsg->m_LogicMousePosWnd.y)
		{
			TListIter<CListStringItem> Iter;
			int nCol = Point2Iter(&m_PrevMousePos, Iter);
			if (nCol >= 0 && nCol < 0x1000)
			{
				CListStringItem::CONTENT *Content = GetItemContent(&*Iter, nCol);
				if (!ShowTip(&*Iter, nCol, Content->String.operator const WCHAR*()))
					HideTip();
			}
		}
		return true;
	}
	bool CWispList::OnLostFocus(WISP_MSG *pMsg)
	{
		HideTip();
		return true;
	}
	bool CWispList::OnDragBegin(WISP_MSG *pMsg)
	{
		m_pWispBase->ChangeCursor(WISP_CT_RESIZE_HORZ);
		return true;
	}
	bool CWispList::OnDragMove(WISP_MSG *pMsg)
	{
		int PosX = pMsg->m_LogicMousePosWnd.x + m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
		int DeltaX = pMsg->DragEvent.DeltaX;
		TListIter<stWispHeaderItem> It = m_pDragColumn; //???
		if (It != m_Columns.End()-1)
		{
			++It;
			int Middle = m_pDragColumn->RCRECT.x + m_pDragColumn->RCRECT.cx/2;
			if (DeltaX <= 0)
			{
				if (PosX >= Middle) return true;
				if (PosX < m_pDragColumn->RCDIB.x + m_pDragColumn->RCDRAG.cx)
				{
					if (m_pDragColumn->nRealWidth <= m_pDragColumn->RCDRAG.cx) return true;
					if (PosX <= 0) return true;
				}
			} else
			{
				if (PosX < Middle) return true;
				if (PosX >= It->nRealWidth + It->RCDIB.x - It->RCDRAG.cx)
				{
					if (It->nRealWidth <= It->RCDRAG.cx) return true;
					DeltaX = It->nRealWidth - It->RCDRAG.cx;
				}
			}
			m_pDragColumn->nRealWidth += DeltaX;
			It->nRealWidth -= DeltaX;
			RecalcLayout();
			Update((WISP_RECT*)0);
		} else
		{
			if (DeltaX < 0)
			{
				if (PosX < It->RCDIB.x + It->RCDRAG.cx)
				{
					if (It->nRealWidth <= It->RCDRAG.cx) return true;
					DeltaX = It->nRealWidth - It->RCDRAG.cx;
				}
			}

			It->nRealWidth += DeltaX;
			m_nColumnWidth += DeltaX;
			SetScrollBarRange(1, m_nColumnWidth / m_CharMiddleWidth, 0);// HORZ
			RecalcLayout();
			Update((WISP_RECT*)0);
		}
		return true;
	}
	bool CWispList::OnDragEnd(WISP_MSG *pMsg)
	{
		m_pWispBase->ChangeCursor(WISP_CT_ARROW);
		m_pDragColumn = 0;
		return true;
	}
	bool CWispList::OnUpdateClient(WISP_MSG *pMsg)
	{
		if ( !(m_Style & 0x40) )
		{
		        if (m_pBKDIB)
		                m_ClientDC.DrawDIBTiled(m_pBKDIB, 0);
		        else
		        if (m_bBGColor)
		                m_WindowDC.DrawFullRect(&m_ClientRect, m_crBGColor);
		        else
		                m_pWispBase->m_pWispDrawObj->DrawCtrlClient(&m_WindowDC, &m_ClientRect);
		}
		
		TListIter<CListStringItem> It = m_RootIter;
		if (It != m_RootItem.End())
		{
			int nLine = 0;
			while (nLine < m_nVSBPage)
			{
				DrawItem(nLine, It);
				if (!NextOpen(It))
				{
					if (m_Style & 0x400'0000)
						m_ClientDC.DrawHLine(0, m_ClientRect.cx - 1, m_ColumnRect.y + (nLine + 1) * m_nLineHeight, m_SpaceColor);
					break;
				}
				++nLine;
			}
		}

		if (m_Style & 0x1'0000)
		{
			m_ClientDC.SetTextColor(m_BKColor);
			m_pWispBase->m_pWispDrawObj->DrawListBK(&m_ClientDC, &m_LayoutRect);
			
			WISP_RECT LayoutRect = m_LayoutRect;
			LayoutRect.x = m_nSpaceWidth - m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
			TListIter<stWispHeaderItem> It = m_Columns.Begin();
			while (It != m_Columns.End())
			{
				WISP_RECT RCDIB = It->RCDIB;
				RCDIB.x -= m_CharMiddleWidth * m_pScrollBar[1]->CurPos;

				m_ClientDC.m_pClipRect = &RCDIB;
				RCDIB.x += m_ClientDC.m_pRect->x;
				RCDIB.y += m_ClientDC.m_pRect->y;
				LayoutRect.cx = It->nRealWidth - m_nSpaceWidth*2;

				if (It->pDIB)
				{
					m_ClientDC.DrawDIB(LayoutRect.x, LayoutRect.y + (LayoutRect.cy - It->pDIB->m_PaintRect.cy)/2, It->pDIB);
					LayoutRect.x += m_nSpaceWidth + It->pDIB->m_PaintRect.cx;
					LayoutRect.cx -= m_nSpaceWidth + It->pDIB->m_PaintRect.cx;
				}
				DrawHeader(&*It, &LayoutRect);

				LayoutRect.x += LayoutRect.cx + m_nSpaceWidth*2;

				WISP_RECT RCRECT = It->RCRECT;
				RCRECT.x -= m_CharMiddleWidth * m_pScrollBar[1]->CurPos;

				m_ClientDC.DrawFrameRect(&RCRECT, 0, 1);
				m_ClientDC.m_pClipRect = 0;

				if (m_Style & 0x200'0000)
				{
					RCRECT.y = m_ColumnRect.y + 2;
					RCRECT.cx = 2;
					RCRECT.cy = m_ColumnRect.cy - 4;
					m_ClientDC.DrawFrameRect(&RCRECT, 0, 1);
				}
				
				++It;
			}
		}
		return false;
	}
	bool CWispList::OnMouseLeave(WISP_MSG *pMsg)
	{
		if (m_pDragColumn)
		{
			if (m_pWispBase->m_CursorType != WISP_CT_ARROW)
			{
				m_pWispBase->ChangeCursor(WISP_CT_ARROW);
				m_pDragColumn = 0;
			}
		}
		if (pMsg->MouseEvent.hWndMouseAt == &m_TipWnd)
			HideTip();
		return true;
	}
	bool CWispList::OnCmdEdit(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000701) //WISP_ID_EDIT_LOST_FOCUS
		{
			if (!m_bEditDateUpdate)
				EditUpdate();
			return false;
		}

		if (pMsg->Command.CmdMsg == 0x80000703) //WISP_ID_EDIT_KEYDOWN
		{
			if (pMsg->Command.Param1 == VK_RETURN)
				EditChange(true);
			else
			if (pMsg->Command.Param1 == VK_ESCAPE)
				EditChange(false);
		}
		return true;
	}

	WISP_CMD_MAP_BEGIN(CWispList)
		WISP_CMD_MAP(ID_EDIT, OnCmdEdit)
	WISP_CMD_MAP_END

	bool CWispList::OnMouseMove(WISP_MSG *pMsg)
	{
		WISP_POINT point = pMsg->m_LogicMousePosWnd;
		if (m_pDragColumn == 0 || PtInRect(&m_ClientRect, &pMsg->MsgMouseWndPT))
		{
			point.x += m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
			if (m_Style & 0x1'0000)
			{
				m_pDragColumn = 0;
				if (m_Style & 0x200'0000)
				{
					TListIter<stWispHeaderItem> It = m_Columns.Begin();
					while (It != m_Columns.End())
					{
						WISP_RECT RECT;
						RECT.x = It->RCDRAG.x;
						RECT.y = 0;
						RECT.cx = It->RCDRAG.cx;
						RECT.cy = m_ClientRect.cy;

						if (point.x < RECT.x) break;
						if (PtInRect(&RECT, &point) && !(It->nFormat & 2)) //WHI_FIXED
						{
							m_pDragColumn = &*It;
							break;
						}
						++It;
					}
				} else
				if (point.y >= m_LayoutRect.y && point.y < m_LayoutRect.y + m_LayoutRect.cy)
				{
					TListIter<stWispHeaderItem> It = m_Columns.Begin();
					while (It != m_Columns.End())
					{
						if (point.x < It->RCDRAG.x) break;
						if (PtInRect(&It->RCDRAG, &point) && !(It->nFormat & 2)) //WHI_FIXED
						{
							m_pDragColumn = &*It;
							break;
						}
						++It;
					}
				}

				if (PtInRect(&m_ClientRect, &pMsg->MsgMouseWndPT))
				{
					if (m_pDragColumn)
					{
						if (m_pWispBase->m_CursorType != WISP_CT_RESIZE_HORZ)
							m_pWispBase->ChangeCursor(WISP_CT_RESIZE_HORZ);
					} else
					{
						if (m_pWispBase->m_CursorType != WISP_CT_ARROW)
							m_pWispBase->ChangeCursor(WISP_CT_ARROW);
					}
					m_PrevMousePos = pMsg->m_LogicMousePosWnd;

					if (m_TipWnd.IsWindowShow() &&
						!PtInRect(&m_TipWnd.m_ScrWindowRect, &pMsg->MsgMouseScrPT))
						HideTip();

					if (!m_bTipShow)
					{
						InsertTimer(ID_TIP_TIMER, m_nTipPeriod, 0, 0);
						m_bTipShow = true;
					}
				}
			}

			if (m_Style & 0x1000'0000)
			{
				CListStringItem *Item = Point2Index(&point, 0);
				if (Item)
					Select(Item);
			}
		} else
		{
			m_pWispBase->ChangeCursor(WISP_CT_ARROW);
			m_pDragColumn = 0;
		}
		return true;
	}
	bool CWispList::OnCreating(WISP_MSG *pMsg)
	{
		m_nCtrlCol = 0;
		m_ItemColor = gpCurWisp->m_pWispDrawObj->m_crSystem[0];
		_____________m_Color_field_CD4 = gpCurWisp->m_pWispDrawObj->m_crSystem[1];
		m_ColorFocus = m_pWispBase->m_pWispDrawObj->m_crSystem[107];
		m_ColorUnFocus = m_pWispBase->m_pWispDrawObj->m_crSystem[107];
		m_SpaceColor = gpCurWisp->m_pWispDrawObj->m_crSystem[0];
		_____________m_Color_field_CE0 = gpCurWisp->m_pWispDrawObj->m_crSystem[7];
		m_BKColor = gpCurWisp->m_pWispDrawObj->m_crSystem[1];
		m_nLayoutHeight = m_ClientDC.m_pFont->m_Height + 6;
		EnableScrollBar(0, 1, 1);
		EnableScrollBar(1, 1, 1);
		return true;
	}
	bool CWispList::OnCreate(WISP_MSG *pMsg)
	{
		if (!(m_Style & 0x1'0000))
		{
			m_LayoutRect.x = 0;
			m_LayoutRect.y = 0;
			m_LayoutRect.cx = 0;
			m_LayoutRect.cy = 0;
		}
		m_EditWnd.CreateWnd(0, 0,0,0,0, this, ID_EDIT, 0x9000002, WISP_SH_HIDDEN); //CMD
		m_TipWnd.CreateWnd(0, 0,0,0,0,     0, ID_TIP, 0, WISP_SH_HIDDEN); //CMD
		return true;
	}
	bool CWispList::OnKeyEvent(WISP_MSG *pMsg)
	{
		switch (pMsg->KeyEvent.KeyType)
		{
		case VK_LBUTTON:{
				if (pMsg->m_LogicMousePosWnd.x > m_ClientRect.cx ||
				    pMsg->m_LogicMousePosWnd.y > m_ClientRect.cy)
					return true;

				if ((m_Style & 0x1'0000) && m_pDragColumn)
				{
					if (pMsg->KeyEvent.bKeyDown)
						BeginDrag();
					else	EndDrag();
					return true;
				}

				if (pMsg->KeyEvent.bKeyDown)
				{
					TListIter<CListStringItem> It;
					int nCol = Point2Iter(&pMsg->m_LogicMousePosWnd, It);
					switch (nCol)
					{
					//case -1:
					//	if (m_FocusedIter != m_RootItem && !(m_Style & 0x4000'0000))
					//		Unselect(It);
					//	break;
					case COL_EXPAND: //0x1001:
						Toggle(&*It);
						break;
					case COL_CHECK: //0x1002:
						ToggleChecked(&*It, true);
						break;
					case COL_LAYOUT: { //0x1003: {
						WISP_POINT point = pMsg->m_LogicMousePosWnd;
						point.y = m_LayoutRect.y + m_LayoutRect.cy + 1;
						nCol = Point2Iter(&point, It);
						OnLButtonLayout(nCol);
						SendEvent(0x80000121, nCol, 0); //WISP_ID_LBUTTON_LAYOUT
						}
					case -1: {
						if (m_FocusedIter != m_RootItem.End() && !(m_Style & 0x4000'0000))
							Unselect(&*m_FocusedIter);
						} break;
					//case COL_EMPTY: //0x1004:
					//	break;
					default:
						{
							if (It->uStatus & 8) //LIST_SELECT
							{
								if (nCol >= 0 && nCol < m_Columns.Size() &&
									m_EditWnd.m_ShowMode == WISP_SH_HIDDEN)
								{
									if (m_Columns[nCol]->nFormat & 1) //WHI_EDIT
									{
										EditItem(&*It, nCol);
									} else
									{
										OnLButton(&*It, nCol);
										m_nLButtonCol = nCol;
										SendEvent(0x80000203, nCol, &*It); //WISP_ID_LBUTTON
									}
								}

								if ((m_Style & 0x80'0000) && m_pWispBase->m_KeyMap[VK_CONTROL])
								{
									Unselect(&*It);
								}
							} else
							{
								if (!(m_Style & 0x80'0000) || !m_pWispBase->m_KeyMap[VK_CONTROL])
								{
									if (m_FocusedIter != m_RootItem.End())
										Unselect(&*m_FocusedIter);
								}
								Select(&*It);
							}
						}
						break;
					}
				}
				Update((WISP_RECT*)0);
			//	HideTip();
				break;}
		case VK_RBUTTON:{
				if (pMsg->m_LogicMousePosWnd.x > m_ClientRect.cx ||
				    pMsg->m_LogicMousePosWnd.y > m_ClientRect.cy || pMsg->KeyEvent.bKeyDown)
					return true;

				TListIter<CListStringItem> It;
				int nCol = Point2Iter(&pMsg->m_LogicMousePosWnd, It);
				switch (nCol)
				{
				case -1:
					break;
				case COL_EXPAND: //0x1001:
					break;
				case COL_CHECK: //0x1002:
					break;
				case COL_LAYOUT: { //0x1003: {
					WISP_POINT point = pMsg->m_LogicMousePosWnd;
					point.y = m_LayoutRect.y + m_LayoutRect.cy + 1;
					nCol = Point2Iter(&point, It);
					OnRButtonLayout(nCol);
					SendEvent(0x80000122, nCol, 0); //WISP_ID_RBUTTON_LAYOUT
					} break;
				//case COL_EMPTY: //0x1004:
				//	break;
				default:
					if ((It->uStatus & 8) && //LIST_SELECT
						(nCol >= 0 && nCol < m_Columns.Size()) &&
						m_EditWnd.m_ShowMode == WISP_SH_HIDDEN)
					{
						OnRButton(&*It, nCol);
						SendEvent(0x80000204, nCol, &*It); //WISP_ID_RBUTTON
					}
					break;
				}
			//	HideTip();
				break;}
		case VK_RETURN:{
				if (pMsg->KeyEvent.bKeyDown && m_FocusedIter != m_RootItem.End())
					Toggle(&*m_FocusedIter);
			//	HideTip();
				break;}
		case VK_SPACE:{
				if ((m_Style & 0x40'0000) && pMsg->KeyEvent.bKeyDown)
				{
					if (m_FocusedIter != m_RootItem.End())
						ToggleChecked(&*m_FocusedIter, true);
				}
			//	HideTip();
				break;}
		case VK_LEFT:{
				if (pMsg->KeyEvent.bKeyDown && m_FocusedIter != m_RootItem.End() &&
					m_FocusedIter->GetItemLevel()>0)
				{
					Scroll(m_FocusedIter->pParentItem, -1);
					Select(m_FocusedIter->pParentItem);
				}
			//	HideTip();
				break;}
		case VK_UP:
		case VK_DOWN:{
				if (pMsg->KeyEvent.bKeyDown && !(m_Style & 0x80'0000))
				{
					if (m_FocusedIter != m_RootItem.End())
					{
						if (!CheckItemPage(&*m_FocusedIter))
						{
							Scroll(&*m_FocusedIter, -1);
						}

						TListIter<CListStringItem> It = m_FocusedIter;
						if (pMsg->KeyEvent.KeyType == VK_UP)
						{
							bool bSelect = PrevOpen(It);
							if (m_FocusedIter == m_RootIter)
								SendScrollEvent(0, 1); //VertScrollLineUp();
							if (bSelect)
							{
								Select(&*It);
								Update((WISP_RECT*)0);
							}
						} else
						if (pMsg->KeyEvent.KeyType == VK_DOWN)
						{
							bool bSelect = NextOpen(It);
							if (GetItemIndex(&*m_FocusedIter) == m_nVSBPage-1)
								SendScrollEvent(0, 0); //VertScrollLineDown();
							if (bSelect)
							{
								Select(&*It);
								Update((WISP_RECT*)0);
							}
						}
					} else
					if (m_RootItem.Size())
					{
						Select(&*m_RootItem.Begin());
						Scroll(&*m_FocusedIter, -1);
						Update((WISP_RECT*)0);
					}
				}
			//	HideTip();
				break;}
		case VK_RIGHT:{
				if (pMsg->KeyEvent.bKeyDown && m_FocusedIter != m_RootItem.End())
				{
					Expand(&*m_FocusedIter);
				}
			//	HideTip();
				break;}
		default:;
		}
		HideTip();
		return true;
	}

	//0x80000203
	void CWispList::OnLButton(CListStringItem *Item, int nCol) //0x38
	{
	}
	//0x80000204
	void CWispList::OnRButton(CListStringItem *Item, int nCol) //+3C
	{
	}

	//0x80000122
	void CWispList::OnRButtonLayout(int nCol) //+40
	{
	}
	//0x80000121
	void CWispList::OnLButtonLayout(int nCol) //+44
	{
	}

//DBLCLICK

	void CWispList::OnMouseDblClick(CListStringItem *Item, int nCol) //+48
	{
		//EMPTY
	}

	bool CWispList::OnMouseDblClick(WISP_MSG *pMsg)
	{
		if (m_FocusedIter != m_RootItem.End())
		{
			OnMouseDblClick(&*m_FocusedIter, m_nLButtonCol);

			if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
				SendCommand(0x80000118, m_nLButtonCol, &*m_FocusedIter); //WISP_ID_LBUTTON_DBLCLICK
			else
			if (pMsg->KeyEvent.KeyType == VK_RBUTTON)
				SendCommand(0x80000117, m_nLButtonCol, &*m_FocusedIter); //WISP_ID_RBUTTON_DBLCLICK
		}
		return true;
	}

//TIP
	bool CWispList::HideTip()
	{
		if (m_bTipShow)
		{
			RemoveTimer(ID_TIP_TIMER);
			m_bTipShow = false;
		}
		if (!m_TipWnd.IsWindowShow())
			return false;
		if (!OnHideTip(m_pTipItem, m_nTipCol, m_TipWnd.m_WndText.operator const WCHAR*()))
			return false;
		m_TipWnd.m_WndText.Empty();
		m_TipWnd.Show(WISP_SH_HIDDEN);
		m_pTipItem = 0;
		m_nTipCol = 0;
		Update((WISP_RECT*)0);
		return true;
	}
	bool CWispList::ShowTip(CListStringItem *Item, int nCol, const WCHAR *Text)
	{
		int nIndex = GetItemIndex(Item);
		if (nIndex < 0)
			return false;

		m_pTipItem = Item;
		m_nTipCol = nCol;
		int PosX = m_ScrWindowRect.x + m_Columns[nCol]->RCDIB.x - m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
		int PosY = m_ScrWindowRect.y + m_ColumnRect.y + nIndex * m_nLineHeight;
		unsigned long szText[256];
		if (IsColorString(Text))
			TStrCpy((DWORD*)szText, (const DWORD*)Text);
		else	TStrCpy((WCHAR*)szText, (const WCHAR*)Text);

		if (!GetTipText(Item, nCol, &PosX, &PosY, (WCHAR*)szText))
			return false;

		if (m_bTipShow)
		{
			RemoveTimer(ID_TIP_TIMER);
			m_bTipShow = false;
		}

		if (IsColorString((const WCHAR*)szText))
		{
			int Len = TStrLen((const DWORD*)&szText[1]);
			m_TipWnd.m_WndText.Preallocate(Len+1, 0);
			m_TipWnd.m_WndText.m_nLength = Len;
			//TStrCpy(m_TipWnd.m_WndText.operator const WCHAR*(), (const DWORD*)&szText[1]);
			TStrCpy(m_TipWnd.m_WndText.data(), (const DWORD*)&szText[1]);
		} else
		{
			m_TipWnd.SetWindowText((const WCHAR*)szText);
		}

		m_TipWnd.AutoAdjustPostion(this);

		MAX_LIMIT(PosX, m_pWispBase->m_pRootWnd->m_WindowRect.cx - m_TipWnd.m_WindowRect.cx);
		MIN_LIMIT(PosX, 0);

		MAX_LIMIT(PosY, m_pWispBase->m_pRootWnd->m_WindowRect.cy - m_TipWnd.m_WindowRect.cy);
		MIN_LIMIT(PosY, 0);

		m_TipWnd.MoveToScreen(PosX, PosY, true);
		m_TipWnd.Show(WISP_SH_MINSIZE);
		Update((WISP_RECT*)0);
		return true;
	}
	bool CWispList::CheckShowTip(CListStringItem *Item, int nCol)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		int TextExt = m_ClientDC.GetTextExtent(Content->String.operator const WCHAR*(), -1, 0) + m_nSpaceWidth*2;
		if (nCol == 0) //m_nCtrlCol ???
		{
			if (m_Style & 0x2'0000)
				TextExt += m_nCtrlBoxWidth;
			if (m_Style & 0x40'0000)
				TextExt += m_nCtrlBoxWidth;
		}
		if (Content->pDIB)
			TextExt += Content->pDIB->m_PaintRect.cx;
		return TextExt <= m_Columns[nCol]->RCDIB.cx;
	}
	bool CWispList::GetTipText(CListStringItem *Item, int nCol, int *pPosX, int *pPosY, WCHAR *pOutText) //+4C
	{
		if (CheckShowTip(Item, nCol))
			return false;
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		TStrCpy(pOutText, Content->String.operator const WCHAR*());
		return true;
	}
	bool CWispList::OnHideTip(CListStringItem *Item, int nCol, const WCHAR *Text) //+50
	{
		return true;
	}

//EDIT
	void CWispList::EditChange(bool bEnable)
	{
		if (m_pWispBase->m_pFocusWnd == &m_EditWnd)
		{
			m_bEnableEdit = bEnable;
			Focus();
			Update(&m_ClientRect);
		}
	}
	bool CWispList::Edit(CListStringItem *Item, int nCol, TWideString& String) //Content? 0x80000111 //+54
	{
		//EMPTY
		return true;
	}
	void CWispList::EditItem(CListStringItem *Item, int nCol)
	{
		if (nCol < m_Columns.Size())
		{
			int nIndex = GetItemIndex(Item);
			if (nIndex == -1)
				Scroll(Item, -1);
			WISP_RECT Rect = m_Columns[nCol]->RCDIB; //+28
			Rect.x -= m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
			Rect.y = m_ColumnRect.y + nIndex * m_nLineHeight;

			Rect.cy = m_nLineHeight;

			m_nEditCol = nCol;
			m_pEditItem = Item;

			CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
			m_EditWnd.m_WndText.Empty();
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x80000111; //WISP_ID_ITEM_EDITITING
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = m_nEditCol;
			Msg.Command.Param2 = m_pEditItem;
			if (m_pWispBase->SendMessage(&Msg) && Edit(m_pEditItem, m_nEditCol, Content->String))
			{
				if (nCol == m_nCtrlCol)
				{
					if (m_Style & 0x2'0000)
					{
						Rect.x += m_nCtrlBoxWidth;
						Rect.cx -= m_nCtrlBoxWidth;
					} else //???
					if (m_Style & 0x40'0000)
					{
						Rect.x += m_nCtrlBoxWidth;
						Rect.cx -= m_nCtrlBoxWidth;
					}
				}

				if (Content->pDIB)
				{
					Rect.x  += Content->pDIB->m_PaintRect.cx;
					Rect.cx -= Content->pDIB->m_PaintRect.cx;
				}
				m_EditWnd.MoveWindowToClient(Rect, true);
				if (m_EditWnd.m_WndText.m_nLength == 0)
					m_EditWnd.SetWindowText(Content->String.operator const WCHAR*());
				m_EditWnd.Show(WISP_SH_MINSIZE);
				m_EditWnd.Focus();
			}
		}
	}
	bool CWispList::OnEditing(CListStringItem *Item, int nCol, TWideString& String) //80000113,80000112 //+58
	{
		//EMPTY
		return true;
	}
	void CWispList::OnEdit(CListStringItem *Item, int nCol, TWideString& String) //0x8000010E //+5C
	{
		//EMPTY
	}
	void CWispList::EditUpdate()
	{
		m_bEditDateUpdate = true;
		m_EditWnd.Show(WISP_SH_HIDDEN);
		WISP_MSG Msg;
		Msg.hWnd = m_OwnerWnd;
		Msg.Msg = WISP_WM_COMMAND;
		Msg.Command.CmdMsg = (m_bEnableEdit != 0) ? 0x80000112 : 0x80000113; // WISP_ID_ITEM_EDIT_LBUTTON : WISP_ID_ITEM_EDIT_RBUTTON
		Msg.Command.CmdID = m_CmdID;
		Msg.Command.Param1 = m_nEditCol;
		Msg.Command.Param2 = m_pEditItem;
		if (m_pWispBase->SendMessage(&Msg) && OnEditing(m_pEditItem, m_nEditCol, m_EditWnd.m_WndText))
		{
			if (m_bEnableEdit)
			{
				CListStringItem::CONTENT *Content = GetItemContent(m_pEditItem, m_nEditCol);
				if (Content->String != m_EditWnd.m_WndText)
				{
					Content->String = m_EditWnd.m_WndText;
					Msg.Command.CmdMsg = 0x8000010E; //WISP_ID_ITEM_EDIT_UPDATE
					m_pWispBase->SendMessage(&Msg);
					OnEdit(m_pEditItem, m_nEditCol, Content->String);
				}
			}
		} else
		{
			m_EditWnd.m_WndText.Empty();
		}
		m_bEditDateUpdate = false;
		m_bEnableEdit = true;
	}


	bool CWispList::OnExpanding(CListStringItem *Item) //+60
	{
		//EMPTY
		return true;
	}
	void CWispList::OnExpand(CListStringItem *Item) //+64
	{
		//EMPTY
	}
	bool CWispList::Expand(CListStringItem *Item)
	{
		if (!(Item->uStatus & 1)) //LIST_EXPAND
		{
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x80000100; //WISP_ID_EXPANDING
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 0;
			Msg.Command.Param2 = Item;
			if (!m_pWispBase->SendMessage(&Msg) || !OnExpanding(Item))
				return false;

			Item->uStatus |= 1; //LIST_EXPAND
			int Count = Item->GetChildItemExpandCount();
			if (Count)
			{
				AdjustScrollBarMaxPos(0, Count);
				RecalcLayout();
				Msg.Command.CmdMsg = 0x80000101; //WISP_ID_EXPAND
				Msg.Command.Param1 = 1;
				m_pWispBase->SendMessage(&Msg);
				OnExpand(Item);
				Update((WISP_RECT*)0);
			}
		}
		return true;
	}

	bool CWispList::OnCollapsing(CListStringItem *Item) //+68
	{
		//EMPTY
		return true;
	}
	void CWispList::OnCollapse(CListStringItem *Item) //+6C
	{
		//EMPTY
	}
	bool CWispList::Collapse(CListStringItem *Item)
	{
		if (!Item)
			Item = &m_RootItem;
		if (Item->uStatus & 1) //LIST_EXPAND
		{
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x80000102; //WISP_ID_COLLAPSING
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 1;
			Msg.Command.Param2 = Item;
			if (!m_pWispBase->SendMessage(&Msg) || !OnCollapsing(Item))
				return false;

			Item->uStatus &= ~1; //LIST_EXPAND
			int Count = Item->GetChildItemExpandCount();
			if (Count)
			{
				if (m_FocusedIter != m_RootItem.End())
				{	
					if (Item->ItemHasChildren(&*m_FocusedIter))
						Select(Item);
				}
				AdjustScrollBarMaxPos(0, -Count);
				RecalcLayout();
				Msg.Command.CmdMsg = 0x80000103; //WISP_ID_COLLAPSE
				Msg.Command.Param1 = 0;
				m_pWispBase->SendMessage(&Msg);
				OnCollapse(Item);
				Update((WISP_RECT*)0);
			}
		}
		return true;
	}

	bool CWispList::Toggle(CListStringItem *Item)
	{
		if (Item->uStatus & 1) //LIST_EXPAND
		{
			Collapse(Item);
			return true;
		}
		Expand(Item);
		return false;
	}

	bool CWispList::OnSelecting(CListStringItem *Item) //+70
	{
		//EMPTY
		return true;
	}
	void CWispList::OnSelect(CListStringItem *Item) //+74
	{
		//EMPTY
	}
	bool CWispList::Select(CListStringItem *Item)
	{
		if (!(Item->uStatus & 8)) //LIST_SELECT
		{
			if (!(m_Style & 0x80'0000) || !m_pWispBase->m_KeyMap[VK_CONTROL])
			{
				if (m_FocusedIter != m_RootItem.End())
				{
					if (&*m_FocusedIter != Item)
						Unselect(&*m_FocusedIter);//Item);
				}
			}
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x80000104; //WISP_ID_SELECTING
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 0;
			Msg.Command.Param2 = Item;
			if (!m_pWispBase->SendMessage(&Msg) || !OnSelecting(Item))
				return false;
			Item->uStatus |= 8; //LIST_SELECT
			Msg.Command.CmdMsg = 0x80000105; //WISP_ID_SELECT
			Msg.Command.Param1 = 1;
			m_pWispBase->SendMessage(&Msg);
			m_FocusedIter = Item; //???
			OnSelect(Item);
			Update((WISP_RECT*)0);
		}
		return true;
	}

	bool CWispList::OnUnselecting(CListStringItem *Item) //+78
	{
		//EMPTY
		return true;
	}
	void CWispList::OnUnselect(CListStringItem *Item) //+7C
	{
		//EMPTY
	}
	bool CWispList::Unselect(CListStringItem *Item)
	{
		if (Item->uStatus & 8) //LIST_SELECT
		{
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x80000106; //WISP_ID_UNSELECTING
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 1;
			Msg.Command.Param2 = Item;
			if (!m_pWispBase->SendMessage(&Msg) || !OnUnselecting(Item))
				return false;
			Item->uStatus &= ~8; //LIST_SELECT
			Msg.Command.CmdMsg = 0x80000107; //WISP_ID_UNSELECT
			Msg.Command.Param1 = 0;
			m_pWispBase->SendMessage(&Msg);
			if (&*m_FocusedIter == Item)
				m_FocusedIter = m_RootItem.End();
			OnUnselect(Item);
			Update((WISP_RECT*)0);
		}
		return true;
	}


	bool CWispList::OnChecking(CListStringItem *Item) //0x80
	{
		//EMPTY
		return true;
	}
	void CWispList::OnChecked(CListStringItem *Item) //0x84
	{
		//EMPTY
	}
	bool CWispList::Checked(CListStringItem *Item, bool bWalk)
	{
		if (!(Item->uStatus & 2)) //LIST_CHECKED
		{
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x80000108; //WISP_ID_CHECKING
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 0;
			Msg.Command.Param2 = Item;
			if (!m_pWispBase->SendMessage(&Msg) || !OnChecking(Item))
				return false;

			if (Item->uStatus & 4) //LIST_SEMICHECKED
			{
				Item->uStatus &= ~4; //LIST_SEMICHECKED
				--Item->pParentItem->SemiChecked;
			}

			Item->uStatus |= 2; //LIST_CHECKED
			++Item->pParentItem->Checked;

			TListIter<CListStringItem> It = Item->Begin();
			while (It != Item->End())
			{
				Checked(&*It, 0);
				++It;
			}

			if (bWalk)
			{
				WalkChecked(Item);
			} else
			{
				Item->Checked = Item->Size();
				Item->SemiChecked = 0;
			}
			Msg.Command.CmdMsg = 0x80000109; //WISP_ID_CHECKED
			Msg.Command.Param1 = 1;
			m_pWispBase->SendMessage(&Msg);
			OnChecked(Item);
			Update((WISP_RECT*)0);
		}
		return true;
	}

	bool CWispList::OnUnchecking(CListStringItem *Item) //0x88
	{
		//EMPTY
		return true;
	}
	void CWispList::OnUnchecked(CListStringItem *Item) //0x8C
	{
		//EMPTY
	}
	bool CWispList::Unchecked(CListStringItem *Item, bool bWalk)
	{
		if (Item->uStatus & (2|4)) //LIST_CHECKED LIST_SEMICHECKED
		{
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x8000010A; //WISP_ID_UNCHECKING
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 1;
			Msg.Command.Param2 = Item;
			if (!m_pWispBase->SendMessage(&Msg) || !OnUnchecking(Item))
				return false;

			if (Item->uStatus & 2) //LIST_CHECKED
			{
				Item->uStatus &= ~2; //LIST_CHECKED
				--Item->pParentItem->Checked;
			} else
			if (Item->uStatus & 4) //LIST_SEMICHECKED
			{
				Item->uStatus &= ~4; //LIST_SEMICHECKED
				--Item->pParentItem->SemiChecked;
			}

			TListIter<CListStringItem> It = Item->Begin();
			while (It != Item->End())
			{
				Unchecked(&*It, 0);
				++It;
			}
			if (bWalk)
			{
				WalkChecked(Item);
			} else
			{
				Item->Checked = 0;
				Item->SemiChecked = 0;
			}
			Msg.Command.CmdMsg = 0x8000010B; //WISP_ID_UNCHECKED
			Msg.Command.Param1 = 0;
			m_pWispBase->SendMessage(&Msg);
			OnUnchecked(Item);
			Update((WISP_RECT*)0);
		}
		return true;
	}

	bool CWispList::ToggleChecked(CListStringItem *Item, char bWalk)
	{
		if (Item->uStatus & 2) //LIST_CHECKED
		{
			Unchecked(Item, bWalk);
			return true;
		}
		Checked(Item, bWalk);
		return false;
	}

	unsigned int CWispList::GetContent(CListStringItem *Item, int nCol, WCHAR *pOutStr, unsigned int OutLen, const WCHAR *pStr) //+90
	{
		TArray<const WCHAR*,0> Array;
		Array.Resize(GetParentLevel(Item)-1);
		unsigned int nRet = 0;
		if (pOutStr) pOutStr[0] = 0;
		while (Item != &m_RootItem)
		{
			CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
			Array.Append(Content->String.operator const WCHAR*());
			Item = Item->pParentItem;
		}
		for (int i = Array.Count - 1; i >= 0; --i)
		{
			if (nRet < OutLen)
			{
				if (pOutStr)
					nRet += TStrCpy(&pOutStr[nRet], Array[i]);
				else	nRet += TStrLen(Array[i]);
			}

			if (i > 0 && nRet < OutLen)
			{
				if (pOutStr)
					nRet += TStrCpy(&pOutStr[nRet], pStr);
				else	nRet += TStrLen(pStr);
			}
		}
		return nRet;
	}

	void CWispList::DrawContent(int nCol, CListStringItem::CONTENT *Content, WISP_RECT *pRect) //+94
	{
		if (IsColorString(Content->String.operator const WCHAR*()))
			m_ClientDC.DrawColorString(pRect, ((const unsigned long*)Content->String.operator const WCHAR*())+1, -1, 0);
		else	m_ClientDC.DrawString(pRect, Content->String.operator const WCHAR*(), -1, 0);
	}
	void CWispList::DrawHeader(stWispHeaderItem *Item, WISP_RECT *pRect) //+98
	{
		m_ClientDC.DrawShadowText(pRect, Item->strHeading.operator const WCHAR*(), 1, -1, 0);
	}

	void CWispList::DrawItem(int nCol, TListIter<CListStringItem> & It)
	{
		int Level = It->GetItemLevel();
		WISP_RECT LineRC;
		LineRC.cy = m_nLineHeight;
		LineRC.y = m_ColumnRect.y + nCol * m_nLineHeight;
		if ((m_Style & 0x6'0000) == 0x6'0000)
		{
			if (It->Size())
			{
				LineRC.cx = m_ColumnRect.cx;
				LineRC.x = m_ColumnRect.x + Level * m_nNonTextWidth - m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
				m_ClientDC.DrawFullRect(&LineRC, m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
			}

			for (int i = 0; i < Level; ++i)
			{
				if (!(i%2))
				{
					LineRC.cx = m_nCtrlBoxWidth;
					LineRC.x = m_ColumnRect.x + i * m_nCtrlBoxWidth - m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
					m_ClientDC.DrawFullRect(&LineRC, m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
				}
			}
		}

		int Line = 0;
		LineRC.x = m_ColumnRect.x + Level * m_nNonTextWidth - m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
		TListIter<CListStringItem::CONTENT> Icon = It->Contents.Begin();
		TListIter<stWispHeaderItem> Icol = m_Columns.Begin();
		while (Icon != It->Contents.End() && Icol != m_Columns.End())
		{
			WISP_RECT MainRC;
			MainRC.x = Icol->RCDIB.x - m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
			MainRC.y = LineRC.y;
			MainRC.cx = Icol->RCDIB.cx;
			MainRC.cy = m_nLineHeight;

			if (Line != 0)
			{
				MainRC.x += m_ClientDC.m_pRect->x;
				MainRC.y = LineRC.y + m_ClientDC.m_pRect->y;
				LineRC.x = Icol->RCDIB.x - m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
			} else
			{
				if (It->uStatus & 0x10) //LIST_COLOR
				{
					WISP_RECT ColorRC;
					ColorRC.x = 0;
					ColorRC.y = LineRC.y;
					ColorRC.cx = m_ClientRect.cx;
					ColorRC.cy = LineRC.cy;
					m_ClientDC.DrawFullRect(&ColorRC, It->Color);
				}

				if ((m_Style & 0x4000'0000 || m_pWispBase->m_pFocusWnd == this) &&
					It->uStatus & 8 && !(m_Style & 0x8000'0000))
				{
					//LIST_SELECT
					WISP_RECT RCx08;
					RCx08.x = 0;
					RCx08.y = LineRC.y;
					RCx08.cx = m_ClientRect.cx;
					RCx08.cy = LineRC.cy;
					if (m_Style & 0x100'0000)
					{
						m_ClientDC.DrawRect(&RCx08, m_pWispBase->m_pFocusWnd == this ? m_ColorFocus : m_ColorUnFocus);
					} else
					{
						m_pWispBase->m_pWispDrawObj->DrawListFocusRect(&m_ClientDC, &RCx08);
					}
					m_ClientDC.m_pClipRect = &MainRC;
					MainRC.x += m_ClientDC.m_pRect->x;
					MainRC.y += m_ClientDC.m_pRect->y;
				}
			}

			if (m_nCtrlCol == Line)
			{
				if (m_Style & 0x2'0000)
				{
					LineRC.cx = m_nCtrlBoxWidth;
					if (It->Size())
					{
						//LIST_EXPAND
						int State = (It->uStatus & 1) ? 9 : 10;
						//WISP_SSI_EXPANDBUTTON_EXPAND
						//WISP_SSI_EXPANDBUTTON_COLLAPSE
						m_ClientDC.DrawSystemStandardIcon(&LineRC, State, 0x21A221);
					}
					LineRC.x += m_nCtrlBoxWidth;
				}

				if (m_Style & 0x40'0000)
				{
					LineRC.cx = m_nCtrlBoxWidth;
					int State;
					//LIST_CHECKED
					if (It->uStatus & 2) State = 12; //WISP_SSI_CHECKBOX_CHECKED
					else
					//LIST_SEMICHECKED
					if (It->uStatus & 4) State = 13; //WISP_SSI_CHECKBOX_SEMICHECKED
					else State = 11; //WISP_SSI_CHECKBOX_UNCHECKED
					m_ClientDC.DrawSystemStandardIcon(&LineRC, State, 0x21A221);
					LineRC.x += m_nCtrlBoxWidth;
				}
			}

			if (Icon->pDIB)
			{
				m_ClientDC.DrawDIB(LineRC.x, LineRC.y, Icon->pDIB);
				LineRC.x += Icon->pDIB->m_PaintRect.cx;
			}

			m_ClientDC.m_pClipRect = 0;

			LineRC.x += m_nSpaceWidth;
			LineRC.cx = (Icol->RCDIB.x + Icol->RCDIB.cx) - m_CharMiddleWidth * m_pScrollBar[1]->CurPos - m_nSpaceWidth - LineRC.x;

			m_ClientDC.SetTextColor(Icon->Color);
			DrawContent(Line, &*Icon, &LineRC);

			++Icon;
			++Icol;
			++Line;
		}

		if ((m_Style & 0x400'0000) && nCol > 0)
		{
			int PosX = m_ColumnRect.x - m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
			if ((m_Style & 0x6'0000) == 0x6'0000)
				PosX += Level * m_nNonTextWidth;
			m_ClientDC.DrawHLine(PosX, m_ColumnRect.cx-1, m_ColumnRect.y + nCol * m_nLineHeight, m_SpaceColor);
		}
	}

	bool CWispList::PrevOpen(TListIter<CListStringItem> & It)
	{
		if (It->pParentItem == 0)
			return false;

		if (It == It->pParentItem->Begin())
		{
			if (It->pParentItem == &m_RootItem)
				return false;
			It = It->pParentItem; //???
			return true;
		}
		--It;
		while (It->uStatus & 1) //LIST_EXPAND
		{
			if (It->Size()==0) break;
			//--It;
			It = It->End()-1;
		}
		return true;
	}
	bool CWispList::NextOpen(TListIter<CListStringItem> & It)
	{
		if (m_RootItem.Size()==0)
			return false;
		if (It == m_RootItem.End())
			return false;
		if ((It->uStatus & 1) && It->Size()) //LIST_EXPAND
		{
			It = It->Begin();
			return true;
		}
		if (It->pParentItem == 0)
			return false;

		CListStringItem *Item = It->pParentItem;
		++It;
		if (It == Item->End())
		{
			do {
				if (Item == &m_RootItem) break;
				It = Item; //???
				++It;
				Item = Item->pParentItem;
			} while (It == Item->End());
		}
		return It != Item->End();
	}
	int CWispList::ScrollPage(int Delta)
	{
		if (m_RootIter == m_RootItem.End())
			return 0;
		int Index = 0;
		if (Delta > 0)
		{
			while (Delta > 0)
			{
				if (!NextOpen(m_RootIter)) break;
				--Delta;
				++Index;
			}
		} else
		if (Delta < 0)
		{
			while (Delta < 0)
			{
				if (!PrevOpen(m_RootIter)) break;
				++Delta;
				++Index;
			}
		}
		return Index;
	}

	int CWispList::Point2Iter(WISP_POINT *pPoint, TListIter<CListStringItem> & It)
	{
		if (pPoint->y >= m_LayoutRect.y &&
		    pPoint->y <  m_LayoutRect.y + m_LayoutRect.cy)
			return COL_LAYOUT; //0x1003;

		if (!PtInRect(&m_ColumnRect, pPoint))
			return -1;

		int nLine = (pPoint->y - m_ColumnRect.y) / m_nLineHeight;
		if (nLine > m_pScrollBar[0]->MaxPos || !m_RootItem.Size())
			return -1;

		It = m_RootIter;
		while (nLine > 0)
		{
			if (!NextOpen(It))
				return -1;
			--nLine;
		}

		int Pos = pPoint->x + m_CharMiddleWidth * m_pScrollBar[1]->CurPos;
		int MaxPos = m_ColumnRect.x + m_nNonTextWidth * It->GetItemLevel();
		if (Pos < MaxPos)
			return COL_EMPTY; //0x1004;

		int Index = 0;
		if (!m_Columns.Size())
			return -1;
		TListIter<stWispHeaderItem> Itc = m_Columns.Begin();
		while (Itc != m_Columns.End())
		{
			if (Index == m_nCtrlCol)
			{
				if (m_Style & 0x2'0000)
				{
					MaxPos += m_nCtrlBoxWidth;
					if (Pos < MaxPos)
						return It->Size() != 0 ? COL_EXPAND : COL_EMPTY; //0x1001 : 0x1004
				}
				if ((m_Style & 0x40'0000) && Pos < MaxPos + m_nCtrlBoxWidth)
					return COL_CHECK; //0x1002;
			}
			MaxPos = Itc->RCDIB.x + Itc->RCDIB.cx;
			if (Pos < MaxPos)
				return Index;
			++Index;
			++Itc;
		}
		return Index-1;
	}
	CListStringItem *CWispList::Point2Index(WISP_POINT *pPoint, int *pIndex)
	{
		TListIter<CListStringItem> Iter;
		int Index = Point2Iter(pPoint, Iter);
		if (Index < 0)
		{
			if (pIndex) *pIndex = -1;
			return nullptr;
		}
		if (pIndex) *pIndex = Index;
		return &*Iter;
	}

	CListStringItem *CWispList::FindItem(CListStringItem *Item, unsigned int uStatus)
	{
		if (!Item)
			Item = &m_RootItem;
		TListIter<CListStringItem> It = Item->Begin();
		while (It != Item->End())
		{
			if ((uStatus & It->uStatus) == uStatus)
				return &*It;
			++It;
		}
		return nullptr;
	}
	int CWispList::GetItemCount(CListStringItem *Item, bool Sub)
	{
		if (!Item)
			Item = &m_RootItem;
		int Size = Item->Size();
		if (Sub)
		{
			TListIter<CListStringItem> It = Item->Begin();
			while (It != Item->End())
			{
				Size += GetItemCount(&*It, true);
				++It;
			}
		}
		return Size;
	}
	CListStringItem *CWispList::GetItem(int Pos, CListStringItem *Item)
	{
		if (!Item)
			Item = &m_RootItem;
		if (Item->Size() == 0)
			return nullptr;
		if (Pos < 0 || Pos >= Item->Size())
			return &*(Item->End()-1);
		return &*Item->operator[](Pos);
	}
	CListStringItem *CWispList::GetRootItem()
	{
		return m_RootIter == m_RootItem.End() ? nullptr : &*m_RootIter;
	}
	bool CWispList::Next(TListIter<CListStringItem>& It)
	{
		if (It->pParentItem == 0)
			return false;
		return ++It != It->pParentItem->End();
	}
	bool CWispList::Prev(TListIter<CListStringItem>& It)
	{
		if (It->pParentItem == 0)
			return false;
		return --It != It->pParentItem->End();
	}
	bool CWispList::NextSibling(TListIter<CListStringItem>& It)
	{
		if (It->Size())
		{
			It = It->Begin();
			return true;
		}

		if (It->pParentItem == 0)
			return false;

		CListStringItem *Item = It->pParentItem;
		++It;
		if (It == Item->End())
		{
			do {
				if (Item == &m_RootItem) break;
				It = Item; //???
				++It;
				Item = Item->pParentItem;
			} while (It == Item->End());
		}
		return It != Item->End();
	}
	CListStringItem *CWispList::FullFindItem(CListStringItem *Item, unsigned int uStatus)
	{
		TListIter<CListStringItem> It = Item ? Item : m_RootItem.Begin();
		if (It == m_RootItem.End())
			return nullptr;
		if (Item == 0)
		{
			if ((uStatus & It->uStatus) == uStatus)
				return &*It;
		}
		while (NextSibling(It))
		{
			if ((uStatus & It->uStatus) == uStatus)
				return &*It;
		}
		return nullptr;
	}
	//GetNextSiblingItem
	CListStringItem *CWispList::GetNext(CListStringItem *Item, unsigned int uStatus)
	{
		if (!Item)
			return FindItem(0, uStatus);
		TListIter<CListStringItem> It = Item; //???
		while (Next(It))
		{
			if ((uStatus & It->uStatus) == uStatus)
				return &*It;
		}
		return nullptr;
	}
	//GetPrevSiblingItem
	CListStringItem *CWispList::GetPrev(CListStringItem *Item, unsigned int uStatus)
	{
		TListIter<CListStringItem> It = Item; //???
		while (Prev(It))
		{
			if ((uStatus & It->uStatus) == uStatus)
				return &*It;
		}
		return nullptr;
	}
	int CWispList::GetPosition(CListStringItem *Item)
	{
		if (Item->pParentItem == 0)
			return 0;
		int Index = 0;
		CListStringItem *Cur = FindItem(Item->pParentItem, 0);
		while (Cur)
		{
			if (Cur == Item)
				return Index;
			Cur = GetNext(Cur, 0);
			++Index;
		}
		return -1;
	}
	CListStringItem *CWispList::GetItemParent(CListStringItem *Item)
	{
		return Item->pParentItem;
	}
	int CWispList::GetItemLevel(CListStringItem *Item)
	{
		return Item->GetItemLevel();
	}
	int CWispList::GetParentLevel(CListStringItem *Item)
	{
		int Level = 0;
		while (Item)
		{
			Item = Item->pParentItem;
			++Level;
		}
		return Level;
	}

	CWispList::stWispHeaderItem *CWispList::InsertColumn(const WCHAR *lpszHeading, int nWidth, int nFormat, CWispDIB *pDIB, int nCol)
	{
		TListIter<stWispHeaderItem> It;
		if (nCol>=0)
		{
			It = m_Columns[nCol];
		} else
		{
			if (m_Columns.Size()>0)
				(m_Columns.End()-1)->nRealWidth = (m_Columns.End()-1)->nInitWidth;
			It = m_Columns.End();
		}
		TListIter<stWispHeaderItem> p = m_Columns.InsertBefore(It);
		p->strHeading = lpszHeading;
		p->nFormat = nFormat;
		p->pDIB = pDIB;
		if (nWidth < 0)
			nWidth = m_ClientDC.GetTextExtent(lpszHeading, -1, 0) + m_nSpaceWidth*2 + 2;
		p->nRealWidth = nWidth;
		p->nInitWidth = nWidth;
		RecalcLayout();
		return &*p;
	}
	CListStringItem::CONTENT *CWispList::GetItemContent(CListStringItem *Item, int nCol)
	{
		if (nCol >= m_Columns.Size()) //> Size-1
			return nullptr;
		
		if (Item->Contents.Size() <= nCol)
	{
		int i = nCol - Item->Contents.Size() + 1;
		//for (int i = nCol; i <= (Item->Contents.Size()+1); ++i)
		do {
			TListIter<CListStringItem::CONTENT> Itc = Item->Contents.Append();
			Itc->Number = 0;
			Itc->v1 = 0;
			Itc->v2 = 0;
			Itc->pDIB = 0;
			Itc->Color = m_ItemColor;
			--i;
		} while (i);
	}
		return &*Item->Contents[nCol];
	}
	
	void CWispList::WalkChecked(CListStringItem *Item)
	{
		while ((Item = Item->pParentItem) != &m_RootItem)
		{
			if (((Item->Checked <= 0) || (Item->Checked >= Item->Size())) && //WARN TODO
			     Item->SemiChecked <= 0 || (Item->uStatus & 4)) //LIST_SEMICHECKED
			{
				if (Item->Checked == Item->Size() && !(Item->uStatus & 2)) //LIST_CHECKED
				{
					if (Item->uStatus & 4) //LIST_SEMICHECKED
					{
						Item->uStatus &= ~4; //LIST_SEMICHECKED
						--Item->pParentItem->SemiChecked;
					}
					Item->uStatus |= 2; //LIST_CHECKED
					++Item->pParentItem->Checked;
				} else
				if (!Item->Checked && !Item->SemiChecked)
				{
					if (Item->uStatus & 2) //LIST_CHECKED
					{
						Item->uStatus &= ~2; //LIST_CHECKED
						--Item->pParentItem->Checked;
					} else
					if (Item->uStatus & 4) //LIST_SEMICHECKED
					{
						Item->uStatus &= ~4; //LIST_SEMICHECKED
						--Item->pParentItem->SemiChecked;
					}
				}
				
			} else
			{
				if (Item->uStatus & 2) //LIST_CHECKED
				{
					Item->uStatus &= ~2; //LIST_CHECKED
					--Item->pParentItem->Checked;
				}
				Item->uStatus |= 4; //LIST_SEMICHECKED
				++Item->pParentItem->SemiChecked;
			}			
		}
	}

	void CWispList::UpdateItemContentColor(CListStringItem *Item)
	{
		TListIter<CListStringItem::CONTENT> It = Item->Contents.Begin();
		while (It != Item->Contents.End())
		{
		//	It->String.Empty();
		//	It->Number = 0;
			It->Color = m_ItemColor;
			++It;
		}
	}

	void CWispList::ClearItemContent(CListStringItem *Item)
	{
		TListIter<CListStringItem::CONTENT> It = Item->Contents.Begin();
		while (It != Item->Contents.End())
		{
			It->String.Empty();
			It->Number = 0;
			It->v1 = 0;
			It->v2 = 0;
			It->Color = m_ItemColor;
			++It;
		}
	}
	int CWispList::UpdateItemColor(CListStringItem *Item)
	{
		if (!Item)
			Item = &m_RootItem;

		TListIter<CListStringItem> It = Item->Begin();
		while (It != Item->End())
		{
			UpdateItemColor(&*It);
			UpdateItemContentColor(&*It);
			++It;
		}
		return Item->Size();
	}
	int CWispList::ClearItem(CListStringItem *Item)
	{
		if (!Item)
			Item = &m_RootItem;

		TListIter<CListStringItem> It = Item->Begin();
		while (It != Item->End())
		{
			ClearItemContent(&*It);
			++It;
		}
		return Item->Size();
	}
	void CWispList::Scroll(CListStringItem *Item, int Count)
	{
		CListStringItem *Next = Item->pParentItem; //???
		while (Next != &m_RootItem)
		{
			if (!(Next->uStatus & 1)) //LIST_EXPAND
				Expand(Next);
			Next = Next->pParentItem;
		}
	{
		TListIter<CListStringItem> It = Item;
		if (Count<0) Count = m_nVSBPage/2;
		while (Count>0)
		{
			if (!PrevOpen(It))
				break;
			--Count;
			Item = &*It;
		}
	}
	{
		int Index = 0;
		TListIter<CListStringItem> It = m_RootItem.Begin();
		while (It != m_RootItem.End())
		{
			if (&*It == Item)
			{
				SetScrollBarCurPos(0, Index, 1);
				break;
			}
			if (!NextOpen(It))
				break;
			++Index;
		}
	}
	}
	bool CWispList::CheckItemPage(CListStringItem *Item)
	{
		int nLine = 0;
		TListIter<CListStringItem> Iter = m_RootIter;
		while (nLine < m_nVSBPage)
		{
			if (&*Iter == Item) return true;
			if (!NextOpen(Iter)) break;
			++nLine;
		}
		return false;
	}
	int CWispList::GetItemIndex(CListStringItem *Item)
	{
		int nIndex = 0;
		TListIter<CListStringItem> Iter = m_RootIter;
		while (nIndex < m_nVSBPage)
		{
			if (&*Iter == Item) return nIndex;
			if (!NextOpen(Iter)) break;
			++nIndex;
		}
		if (&*Iter == Item) return nIndex;
		return -1;
	}
	bool CWispList::GetItemRect(CListStringItem *Item, int nCol, WISP_RECT *pRect)
	{
		int nIndex = GetItemIndex(Item);
		if (nIndex < 0)
			return false;
		pRect->y = m_ColumnRect.y + nIndex * m_nLineHeight;
		pRect->cy = m_nLineHeight;
		pRect->x = 0;
		pRect->cx = 0;
		TListIter<stWispHeaderItem> Itc = m_Columns.Begin();
		while (Itc != m_Columns.End())
		{
			if (nCol == 0)
			{
				pRect->x = Itc->RCDIB.x;
				pRect->cx = Itc->RCDIB.cx;
				break;
			}
			--nCol;
			++Itc;
		}
		//+++
		//if (nCol == m_nCtrlCol) //TODO
		if (m_Style & 0x2'0000)
			pRect->x += m_nCtrlBoxWidth;
		if (m_Style & 0x40'0000)
			pRect->x += m_nCtrlBoxWidth;
		return true;
	}
	int CWispList::GetItemText(CListStringItem *Item, int nCol, WCHAR *Des, int Len)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		if (!Content)
			return 0;
		if (Content->String.m_nLength == 0)
		{
			Des[0] = 0;
			return 0;
		}
		if (IsColorString(Content->String.m_pData))
			return TStrCpyLimit(Des, ((const unsigned long*)Content->String.m_pData)+1, Len); //???
		return TStrCpyLimit(Des, Content->String.m_pData, Len);
	}
	unsigned long long CWispList::GetItemValue(CListStringItem *Item, int nCol)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		//if (!Content)
		//	return false;
		return Content->Number;
	}

	bool CWispList::SetItemText(CListStringItem *Item, int nCol, const WCHAR *lpszString)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		if (!Content)
			return false;
		Content->String = lpszString;
		return true;
	}
	bool CWispList::SetItemTextColor(CListStringItem *Item, int nCol, const unsigned long *lpColorString)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		if (!Content)
			return false;
		int Len = TStrLen((const unsigned long*)lpColorString)*2+2;
		Content->String.Preallocate(Len+2, 0);
	//	TMemCpy(Content->String.operator WCHAR*()+2, (const WCHAR*)lpColorString, Len);
		TMemCpy(Content->String.data()+2, (const WCHAR*)lpColorString, Len);
		Content->String.m_pData[0] = -1;
		Content->String.m_pData[1] = -1;
		Content->String.m_nLength = Len/2-1;
		return true;
	}
	bool CWispList::SetItemValue(CListStringItem *Item, int nCol, unsigned long long Value)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		if (!Content)
			return false;
		Content->Number = Value;
		return true;
	}
	bool CWispList::SetItemDIB(CListStringItem *Item, int nCol, CWispDIB *pDIB)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		if (!Content)
			return false;
		Content->pDIB = pDIB;
		return true;
	}
	bool CWispList::SetItemColor(CListStringItem *Item, int nCol, unsigned long Color)
	{
		if (nCol < 0)
		{
			TListIter<CListStringItem::CONTENT> Itc = Item->Contents.Begin();
			while (Itc != Item->Contents.End())
			{
				Itc->Color = Color;
				++Itc;
			}
		} else
		{
			CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
			if (!Content)
				return false;
			Content->Color = Color;
		}
		return true;
	}
	bool CWispList::SetItemText(CListStringItem *Item, int nCol, const char *Text)
	{
		WCHAR Buffer[512];
		TStrCpyLimit(Buffer, Text, lenof(Buffer));
		return SetItemText(Item, nCol, Buffer);
	}
	bool CWispList::SetItemFormat(CListStringItem *Item, int nCol, unsigned long long Value, const WCHAR *Format)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		if (!Content)
			return false;
		Content->String.Format(Format, Value);
		return true;
	}
	
	bool CWispList::DeleteItem(CListStringItem *Item)
	{
		if (Item->uStatus & 2) //LIST_CHECKED
			--Item->pParentItem->Checked;
		if (Item->uStatus & 4) //LIST_SEMICHECKED
			--Item->pParentItem->SemiChecked;
		WalkChecked(Item);
		TListIter<CListStringItem> SaveIter = m_RootIter;
		if ((&*m_RootIter == Item || Item->ItemHasChildren(&*m_RootIter)) && !Prev(m_RootIter))
		{
			m_RootIter = SaveIter; //???
			if (!Next(m_RootIter))
				m_RootIter = m_RootItem.End();
		}
		if (&*m_FocusedIter == m_pTipItem)
			HideTip();
		if (&*m_FocusedIter == Item || (m_FocusedIter != m_RootItem.End() && Item->ItemHasChildren(&*m_FocusedIter)))
			m_FocusedIter = m_RootItem.End();
		AdjustScrollBarMaxPos(0, -Item->GetChildItemExpandCount());
		CListStringItem *pParentItem = Item->pParentItem;
		TListIter<CListStringItem> It = Item;
		pParentItem->Remove(It);
		if (pParentItem != &m_RootItem && !pParentItem->End())
		{
			if (pParentItem->uStatus & 1) //LIST_EXPAND
				pParentItem->uStatus &= ~1; //LIST_EXPAND
		}
		return true;
	}
	bool CWispList::DeleteAllChildrenItems(CListStringItem *Item)
	{
		if (Item)
		{
			if (Item->uStatus & 1) //LIST_EXPAND
				AdjustScrollBarMaxPos(0, -Item->GetChildItemExpandCount());
			if (m_FocusedIter != m_RootItem.End() && Item->ItemHasChildren(&*m_FocusedIter))
				m_FocusedIter = m_RootItem.End();
			if (m_RootIter != m_RootItem.End() && Item->ItemHasChildren(&*m_RootIter))
				m_RootIter = Item; //???
			Item->Clear();
			Item->Checked = 0;
			Item->SemiChecked = 0;
			Item->uStatus &= ~1; //LIST_EXPAND
		} else
		{
			if (m_FocusedIter != m_RootItem.End() && m_RootItem.ItemHasChildren(&*m_FocusedIter))
				m_FocusedIter = m_RootItem.End();
			m_RootItem.Clear();
			m_RootIter = m_RootItem.End();
			m_RootItem.Checked = 0;
			m_RootItem.SemiChecked = 0;
			SetScrollBarInfo(0, 0, 0, m_pScrollBar[0]->Page, 0, 1);
		}
		return true;
	}

	CListStringItem *CWispList::InsertItem(const WCHAR *pString, CListStringItem *pParentItem, unsigned int uStatus, CWispDIB *pDIB, int Pos)
	{
		if (!pParentItem)
			pParentItem = &m_RootItem;
		if (pParentItem->uStatus & 2) //LIST_CHECKED
			uStatus |= 2; //LIST_CHECKED
		TListIter<CListStringItem> It = pParentItem->InsertBefore(pParentItem->operator[](Pos));
		
		TListIter<CListStringItem::CONTENT> Itc = It->Contents.Append();
		Itc->String = pString;
		Itc->pDIB = pDIB;
		Itc->Color = m_ItemColor;

		It->pParentItem = pParentItem;
		It->uStatus = uStatus & ~2; //LIST_CHECKED
		It->Checked = 0;
		It->SemiChecked = 0;
	//	It->STRING = pString; //DEBUG
		if (uStatus & 2) //LIST_CHECKED
			Checked(&*It, true);

		if (pParentItem->uStatus & 1) //LIST_EXPAND
			AdjustScrollBarMaxPos(0, 1);

		if (m_RootIter == m_RootItem.End())
			m_RootIter = It;
		return &*It;
	}

	CListStringItem *CWispList::InsertItemStr(const char *pString, CListStringItem *pParentItem, unsigned int uStatus, CWispDIB *pDIB, int Pos)
	{
		WCHAR Buffer[512];
		if (pString)
			TStrCpyLimit(Buffer, pString, lenof(Buffer));
		else	Buffer[0] = 0;
		return InsertItem(Buffer, pParentItem, uStatus, pDIB, Pos);
	}
	CListStringItem *CWispList::InsertItemStr(const WCHAR *pString, CListStringItem *pParentItem, unsigned int uStatus, CWispDIB *pDIB, int Pos)
	{
		WCHAR Buffer[512];
		TStrCpyLimit(Buffer, pString, lenof(Buffer));
		return InsertItem(Buffer, pParentItem, uStatus, pDIB, Pos);
	}
	CListStringItem *CWispList::InsertItemValue(unsigned long long Value, CListStringItem *pParentItem, const WCHAR *Format, unsigned int uStatus, CWispDIB *pDIB, int Pos)
	{
		CListStringItem *Item = InsertItem(nullptr, pParentItem, uStatus, pDIB, Pos);
		CListStringItem::CONTENT *Content = GetItemContent(Item, 0);
		Content->String.Format(Format, Value);
		return Item;
	}

	int CWispList::Adjust(CListStringItem *Item, int Pos)
	{
		if (Pos < 0) return 0;
		if (!Item)
			Item = &m_RootItem;
		int Size = Pos - GetItemCount(Item, 0);
		if (Size<0)
		{
			CListStringItem *PosItem = GetItem(Pos, Item);
			Size = -Size;
			for (int i = 0; i < Size; ++i)
			{
				CListStringItem *NextItem = GetNext(PosItem, 0);
				DeleteItem(PosItem);
				PosItem = NextItem;
			}
		} else
		if (Size>0)
		{
			for (int i = 0; i < Size; ++i)
			{
				InsertItem((WCHAR*)0, Item, 0, 0, -1);
			}
		}
		return 0;
	}

```

`source/Wisp/wisplist.hpp`:

```hpp

#ifndef _WISPLIST_HPP_
#define _WISPLIST_HPP_

#include "../Code/define.h"
#include "../Code/tstrmem.hpp"
#include "../Code/alt/altlist.hpp"
#include "wispwnd.hpp"
#include "wisptipwnd.hpp"
#include "wispedit.hpp"

//uStatus
#define LIST_EXPAND		0x01
#define LIST_CHECKED		0x02
#define LIST_SEMICHECKED	0x04
#define LIST_SELECT		0x08
#define LIST_COLOR		0x10

#define COL_EXPAND	0x1001
#define COL_CHECK	0x1002
#define COL_LAYOUT	0x1003
#define COL_EMPTY	0x1004

#define WHI_EDIT 1
#define WHI_FIXED 2

struct CListStringItem : public TList<CListStringItem>
{
	struct CONTENT
	{
		TWideString String;
		CWispDIB *pDIB; //???
		unsigned long long Number;
		ULONGLONG v1;
		ULONGLONG v2;
		unsigned long Color;
		CWispDIB *Icon; //???
	};

	TList<CONTENT> Contents;
	CListStringItem *pParentItem;
	unsigned int uStatus;
	unsigned long Color;
	int Checked;
	int SemiChecked;

	int GetItemLevel();
	int GetChildItemExpandCount();
	bool ItemHasChildren(CListStringItem *Item);
};

struct CWispList : public CWispWnd
{
	struct stWispHeaderItem
	{
		TWideString strHeading;
		CWispDIB *pDIB;
		int nRealWidth;
		int nInitWidth;
		unsigned int nFormat;
		WISP_RECT RCDIB;
		WISP_RECT RCRECT;
		WISP_RECT RCDRAG;
		//int;
		//int;
	};

	CWispTipWnd m_TipWnd;

	int m_nCtrlCol;
	int m_CharMiddleWidth;
	int m_nColumnWidth;
	int m_nMaxLayoutHeight;
	int m_nLayoutHeight;

	int m_nEditCol;
	CListStringItem *m_pEditItem;
	CWispEdit m_EditWnd;

	stWispHeaderItem *m_pDragColumn;
	TListIter<CListStringItem> m_RootIter;
	TListIter<CListStringItem> m_FocusedIter;
	int m_nLButtonCol;
	WISP_POINT m_PrevMousePos;

	CListStringItem *m_pTipItem;
	int m_nTipCol;

	int m_nSpaceWidth;
	int m_nCtrlBoxWidth;
	int m_nLineHeight;
	WISP_RECT m_LayoutRect;
	WISP_RECT m_ColumnRect;
	TList<stWispHeaderItem> m_Columns;
	CListStringItem m_RootItem;
	int m_nVSBPage; //m_nItemCount//m_nLinesPerPage
	int m_nNonTextWidth;

	unsigned long m_BKColor;
	unsigned long m_ItemColor;
	unsigned long _____________m_Color_field_CD4;
	unsigned long m_ColorFocus;
	unsigned long m_ColorUnFocus;
	unsigned long _____________m_Color_field_CE0;
	unsigned long m_SpaceColor;

	bool m_bEnableEdit;
	bool m_bEditDateUpdate;

	bool m_bTipShow;
	int m_nTipPeriod;

	CWispList();
	virtual ~CWispList();

	virtual bool Destroy() override;

	bool Recalc(bool bMin);
	virtual void RecalcLayout() override;
	virtual bool InitWnd() override;
	virtual void Hide() override;
	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnUpdate(WISP_MSG *pMsg);

	bool OnSize(WISP_MSG *pMsg);
	bool OnScrollEvent(WISP_MSG *pMsg);

	bool OnTimer(WISP_MSG *pMsg);
	bool OnLostFocus(WISP_MSG *pMsg);
	bool OnDragBegin(WISP_MSG *pMsg);
	bool OnDragMove(WISP_MSG *pMsg);
	bool OnDragEnd(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnMouseLeave(WISP_MSG *pMsg);
	bool OnCmdEdit(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	bool OnCreating(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);

	//0x80000203
	virtual void OnLButton(CListStringItem *Item, int nCol); //0x38
	//0x80000204
	virtual void OnRButton(CListStringItem *Item, int nCol); //+3C

	//0x80000122
	virtual void OnRButtonLayout(int nCol); //+40
	//0x80000121
	virtual void OnLButtonLayout(int nCol); //+44

//DBLCLICK

	virtual void OnMouseDblClick(CListStringItem *Item, int nCol); //+48
	bool OnMouseDblClick(WISP_MSG *pMsg);

//TIP
	bool HideTip();
	bool ShowTip(CListStringItem *Item, int nCol, const WCHAR *Text);
	bool CheckShowTip(CListStringItem *Item, int nCol);
	virtual bool GetTipText(CListStringItem *Item, int nCol, int *pPosX, int *pPosY, WCHAR *pOutText); //+4C
	virtual bool OnHideTip(CListStringItem *Item, int nCol, const WCHAR *Text); //+50

//EDIT
	void EditChange(bool bEnable);
	virtual bool Edit(CListStringItem *Item, int nCol, TWideString& String); //Content? 0x80000111 //+54
	void EditItem(CListStringItem *Item, int nCol);
	virtual bool OnEditing(CListStringItem *Item, int nCol, TWideString& String); //80000113,80000112 //+58
	virtual void OnEdit(CListStringItem *Item, int nCol, TWideString& String); //0x8000010E //+5C
	void EditUpdate();


	virtual bool OnExpanding(CListStringItem *Item); //+60
	virtual void OnExpand(CListStringItem *Item); //+64
	bool Expand(CListStringItem *Item);

	virtual bool OnCollapsing(CListStringItem *Item); //+68
	virtual void OnCollapse(CListStringItem *Item); //+6C
	bool Collapse(CListStringItem *Item);

	bool Toggle(CListStringItem *Item);

	virtual bool OnSelecting(CListStringItem *Item); //+70
	virtual void OnSelect(CListStringItem *Item); //+74
	bool Select(CListStringItem *Item);

	virtual bool OnUnselecting(CListStringItem *Item); //+78
	virtual void OnUnselect(CListStringItem *Item); //+7C
	bool Unselect(CListStringItem *Item);


	virtual bool OnChecking(CListStringItem *Item); //0x80
	virtual void OnChecked(CListStringItem *Item); //0x84
	bool Checked(CListStringItem *Item, bool bWalk);

	virtual bool OnUnchecking(CListStringItem *Item); //0x88
	virtual void OnUnchecked(CListStringItem *Item); //0x8C
	bool Unchecked(CListStringItem *Item, bool bWalk);

	bool ToggleChecked(CListStringItem *Item, char bWalk);

	virtual unsigned int GetContent(CListStringItem *Item, int nCol, WCHAR *pOutStr, unsigned int OutLen, const WCHAR *pStr); //+90

	virtual void DrawContent(int nCol, CListStringItem::CONTENT *Content, WISP_RECT *pRect); //+94
	virtual void DrawHeader(stWispHeaderItem *Item, WISP_RECT *pRect); //+98

	void DrawItem(int nCol, TListIter<CListStringItem> & It);

	bool PrevOpen(TListIter<CListStringItem> & It);
	bool NextOpen(TListIter<CListStringItem> & It);
	int ScrollPage(int Delta);

	int Point2Iter(WISP_POINT *pPoint, TListIter<CListStringItem> & It);
	CListStringItem *Point2Index(WISP_POINT *pPoint, int *pIndex);

	CListStringItem *FindItem(CListStringItem *Item, unsigned int uStatus);
	int GetItemCount(CListStringItem *Item, bool Sub);
	CListStringItem *GetItem(int Pos, CListStringItem *Item);
	CListStringItem *GetRootItem();
	bool Next(TListIter<CListStringItem>& It);
	bool Prev(TListIter<CListStringItem>& It);
	bool NextSibling(TListIter<CListStringItem>& It);
	CListStringItem *FullFindItem(CListStringItem *Item, unsigned int uStatus);
	//GetNextSiblingItem
	CListStringItem *GetNext(CListStringItem *Item, unsigned int uStatus);
	//GetPrevSiblingItem
	CListStringItem *GetPrev(CListStringItem *Item, unsigned int uStatus);
	int GetPosition(CListStringItem *Item);
	CListStringItem *GetItemParent(CListStringItem *Item);
	int GetItemLevel(CListStringItem *Item);
	int GetParentLevel(CListStringItem *Item);

	stWispHeaderItem *InsertColumn(const WCHAR *lpszHeading, int nWidth, int nFormat, CWispDIB *pDIB, int nCol);
	CListStringItem::CONTENT *GetItemContent(CListStringItem *Item, int nCol);
	
	void WalkChecked(CListStringItem *Item);

	void UpdateItemContentColor(CListStringItem *Item);
	void ClearItemContent(CListStringItem *Item);
	int UpdateItemColor(CListStringItem *Item);
	int ClearItem(CListStringItem *Item);
	void Scroll(CListStringItem *Item, int Count);
	bool CheckItemPage(CListStringItem *Item);
	int GetItemIndex(CListStringItem *Item);
	bool GetItemRect(CListStringItem *Item, int nCol, WISP_RECT *pRect);
	int GetItemText(CListStringItem *Item, int nCol, WCHAR *Des, int Len);
	unsigned long long GetItemValue(CListStringItem *Item, int nCol);

	bool SetItemText(CListStringItem *Item, int nCol, const WCHAR *lpszString);
	bool SetItemTextColor(CListStringItem *Item, int nCol, const unsigned long *lpColorString);
	bool SetItemValue(CListStringItem *Item, int nCol, unsigned long long Value);
	bool SetItemDIB(CListStringItem *Item, int nCol, CWispDIB *pDIB);
	bool SetItemColor(CListStringItem *Item, int nCol, unsigned long Color);
	bool SetItemText(CListStringItem *Item, int nCol, const char *Text);
	bool SetItemFormat(CListStringItem *Item, int nCol, unsigned long long Value, const WCHAR *Format);
	
	bool DeleteItem(CListStringItem *Item);
	bool DeleteAllChildrenItems(CListStringItem *Item);

	CListStringItem *InsertItem(const WCHAR *pString, CListStringItem *pParentItem, unsigned int uStatus, CWispDIB *pDIB, int Pos);

	CListStringItem *InsertItemStr(const char *pString, CListStringItem *pParentItem, unsigned int uStatus, CWispDIB *pDIB, int Pos);
	CListStringItem *InsertItemStr(const WCHAR *pString, CListStringItem *pParentItem, unsigned int uStatus, CWispDIB *pDIB, int Pos);
	CListStringItem *InsertItemValue(unsigned long long Value, CListStringItem *pParentItem, const WCHAR *Format, unsigned int uStatus, CWispDIB *pDIB, int Pos);

	int Adjust(CListStringItem *Item, int Pos);
};

#endif

```

`source/Wisp/wispmenu.cpp`:

```cpp

//#include "../Code/osdefine.hpp"
#include "../Code/define.h"

#include "wispmenu.hpp"
#include "wispbase.hpp"

#define SUBMENU(Item)	((CWispMenu*)(Item->dwData))

	WISP_MSG_MAP_BEGIN(CWispMenu)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_RECALC_LAYOUT, OnRecalcLayout)
		WISP_MSG_MAP(WISP_WM_RESIZE_CHILD, OnResizeChild)
		WISP_MSG_MAP(WISP_WM_LOST_FOCUS, OnLostFocus)
		WISP_MSG_MAP(WISP_WM_UPDATE_BORDER, OnUpdateBorder)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
	WISP_MSG_MAP_END(CWispWnd)

	bool CWispMenu::OnUpdateClient(WISP_MSG *pMsg)
	{
		if (m_Style & 0x10000) //POPUP MENU
			DrawPopupMenu();
		else	DrawMenu();
		return false;
	}
	bool CWispMenu::OnRecalcLayout(WISP_MSG *pMsg)
	{
		if (m_Style & 0x10000) //POPUP MENU
		{
			int y = m_SubMenuBorderSize;
			TListIter<MenuItem> It = m_MenuItemList.Begin();
			while (It != m_MenuItemList.End())
			{
				It->Rect.x = 0;
				It->Rect.y = y;
				It->Rect.cx = m_ClientRect.cx;
				if (It->nFlags & 4) //MENU_DELIM
					It->Rect.cy = 1;
				else	It->Rect.cy = m_SubMenuOpenHeight;
				y += It->Rect.cy;
				++It;
			}
		} else
		{
			int x = 0;
			TListIter<MenuItem> It = m_MenuItemList.Begin();
			while (It != m_MenuItemList.End())
			{
				It->Rect.x = x;
				It->Rect.y = (m_FullMenuHeight - m_OpenMenuHeight)/2;
				It->Rect.cy = m_OpenMenuHeight;
				if (It->nFlags & 4) //MENU_DELIM
				{
					It->Rect.cx = m_SubMenuBorderSize*2 + 1;
				} else
				{
					It->Rect.cx = m_ClientDC.GetTextExtent(It->string.operator const WCHAR*(), -1, 0) + m_SubMenuBorderSize*2;
					if (It->nFlags & 2) //MENU_CHECKBOX
						It->Rect.cx += m_SubMenuBorderSize + 11;
					else
					if (It->pDIB)
						It->Rect.cx += m_SubMenuBorderSize + It->pDIB->m_PaintRect.cx;
				}
				x += It->Rect.cx;
				++It;
			}
			m_FullMenuWidth = x;
		}
		return true;
	}
	bool CWispMenu::OnResizeChild(WISP_MSG *pMsg)
	{
		if (!(m_Style & 0x10000)) //POPUP MENU
			Resize(((CWispWnd*)m_ParentWnd)->m_ClientRect.cx, m_WindowRect.cy, true);
		return true;
	}
	bool CWispMenu::OnLostFocus(WISP_MSG *pMsg)
	{
		CWispMenu *pRootMenu = GetRootMenu();
		if (!pRootMenu->CheckExist((CWispMenu*)pMsg->hOtherWnd))
		{
			if (pRootMenu != pMsg->hOtherWnd)
				pRootMenu->HideMenu();
			m_CurMenuItemIter = m_MenuItemList.End();
		}
		return true;
	}
	bool CWispMenu::OnUpdateBorder(WISP_MSG *pMsg)
	{
		if (pParentMenu && !(pParentMenu->m_Style & 0x10000)) //POPUP MENU
		{
			m_WindowDC.DrawHLine(pParentMenu->m_CurMenuItemIter->Rect.cx - 1, m_WindowRect.cx - 1, 0, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
			m_WindowDC.DrawHLine(1, m_CurMenuItemIter->Rect.cx - 2, 0, m_pWispBase->m_pWispDrawObj->m_crSystem[50]);
			m_WindowDC.DrawHLine(0, m_WindowRect.cx - 1, m_WindowRect.cy - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
			m_WindowDC.DrawVLine(0, 0, m_WindowRect.cy - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
			m_WindowDC.DrawVLine(m_WindowRect.cx - 1, 0, m_WindowRect.cy - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
		} else
		{
			m_WindowDC.DrawRect(&m_WindowRect, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
		}
		return false;
	}
	bool CWispMenu::OnDestroy(WISP_MSG *pMsg)
	{
		TListIter<MenuItem> It = m_MenuItemList.Begin();
		while (It != m_MenuItemList.End())
		{
			if (It->nFlags & 1) //MENU_SUBMENU
				((CWispMenu*)It->dwData)->Destroy();
			++It;
		}
		m_MenuItemList.Clear();
		return true;
	}
	bool CWispMenu::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (!m_MenuItemList.Size() || !pMsg->KeyEvent.bKeyDown)
			return true;

		switch (pMsg->KeyEvent.KeyType)
		{
		case VK_LBUTTON:
			if (PtInRect(&m_WindowRect, &pMsg->m_LogicMousePosWnd))
			{
				if (m_bShowed && m_CurMenuItemIter == m_MenuItemList.End())
				{
					m_bShowed = 0;
					HideMenu();
				}
				if (m_CurMenuItemIter != m_MenuItemList.End())
				{
					if (!(m_CurMenuItemIter->nFlags & 0x100000) && //MENU_DISABLED
						!(m_CurMenuItemIter->nFlags & 4)) //MENU_DELIM
					{
						if (m_CurMenuItemIter->nFlags & 1) //MENU_SUBMENU
						{
							if (m_bShowed)
							{
								m_bShowed = 0;
								TListIter<MenuItem> It = m_CurMenuItemIter; //???
								HideMenu();
								m_CurMenuItemIter = It; //???
							} else
							{
								m_bShowed = 1;
								Open(&*m_CurMenuItemIter, 0);
								Update(&m_CurMenuItemIter->Rect);
							}
						} else
						{
							SwitchItem(&*m_CurMenuItemIter);
						}
					}
				}
			} else
			{
				m_bShowed = 0;
				HideMenu();
			}
			break;
		case VK_RETURN:
			if (m_CurMenuItemIter != m_MenuItemList.End())
			{
				if (!(m_CurMenuItemIter->nFlags & 1)) //MENU_SUBMENU
					SwitchItem(&*m_CurMenuItemIter);
				else	Open(&*m_CurMenuItemIter, 1);
			}
			break;			
		case VK_ESCAPE:
			if (pParentMenu)
			{
				HideMenu();
				pParentMenu->Focus();
			} else
			if (m_OwnerWnd != this)
				m_OwnerWnd->Focus();
			else	HideMenu();
			break;
		case VK_LEFT:
			if (!(m_Style & 0x10000)) //POPUP MENU
			{
				PrevItem();
			} else
			if (pParentMenu)
			{
				HideMenu();
				pParentMenu->Focus();
			}
			break;
		case VK_UP:
			if (m_Style & 0x10000) //POPUP MENU
			{
				PrevItem();
			} else
			if (pParentMenu)
			{
				HideMenu();
				pParentMenu->Focus();
			}
			break;
		case VK_RIGHT:
			if (!(m_Style & 0x10000)) //POPUP MENU
			{
				NextItem();
			} else
			if (m_CurMenuItemIter != m_MenuItemList.End() && (m_CurMenuItemIter->nFlags & 1)) //MENU_SUBMENU
				Open(&*m_CurMenuItemIter, 1);
			break;
		case VK_DOWN:
			if (m_Style & 0x10000) //POPUP MENU
			{
				NextItem();
			} else
			if (m_CurMenuItemIter != m_MenuItemList.End() && (m_CurMenuItemIter->nFlags & 1)) //MENU_SUBMENU
				Open(&*m_CurMenuItemIter, 1);
			break;
		default:;
		}
		return true;
	}
	bool CWispMenu::OnMouseMove(WISP_MSG *pMsg)
	{
		TListIter<MenuItem> It = m_MenuItemList.Begin();
		while (It != m_MenuItemList.End())
		{
			if (PtInRect(&It->Rect, &pMsg->m_LogicMousePosWnd))
			{
				if (m_CurMenuItemIter != It)
					UpdateIter(It);
				break;
			}
			++It;
		}
		if (It == m_MenuItemList.End() && !(m_Style & 0x10000) && m_CurMenuItemIter != It) //POPUP MENU
			UpdateIter(It);
		return true;
	}
	bool CWispMenu::OnMouseLeave(WISP_MSG *pMsg)
	{
		if (!(m_Style & 0x10000) && m_CurMenuItemIter != m_MenuItemList.End() && !m_bShowed) //POPUP MENU
			UpdateIter(m_MenuItemList.End());
		return true;
	}

	bool CWispMenu::CheckExist(CWispMenu *pMenu)
	{
		if (pMenu->m_CtrlType != WISP_CTRL_MENU)
			return false;
		while ((pMenu = pMenu->pParentMenu))
			if (pMenu == this) return true;
		return false;
	}
	CWispMenu *CWispMenu::GetRootMenu()
	{
		CWispMenu *parent = this;
		while (parent && parent->pParentMenu)
			parent = parent->pParentMenu;
		return parent;
	}

	bool CWispMenu::SetDIB(CWispMenu::MenuItem *Item, CWispDIB *pDIB)
	{
		Item->pDIB = pDIB;
		return true;
	}
	bool CWispMenu::SetData(CWispMenu::MenuItem *Item, unsigned long long dwData)
	{
		Item->dwData = dwData;
		return true;
	}

	bool CWispMenu::CheckedItem(CWispMenu::MenuItem *Item)
	{
		if (!(Item->nFlags & 0x80000)) //MENU_CHECKED
		{
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x80000108; //WISP_ID_CHECKING
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 0;
			Msg.Command.Param2 = Item;
			if (!m_pWispBase->SendMessage(&Msg))
				return false;
			Item->nFlags |= 0x80000; //MENU_CHECKED
			Msg.Command.CmdMsg = 0x80000109; //WISP_ID_CHECKED
			Msg.Command.Param1 = 1;
			m_pWispBase->SendMessage(&Msg);
			Update((WISP_RECT*)0);
		}
		return true;
	}
	bool CWispMenu::UnCheckedItem(CWispMenu::MenuItem *Item)
	{
		if ((Item->nFlags & 0x80000)) //MENU_CHECKED
		{
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x8000010A; //WISP_ID_UNCHECKING
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 1;
			Msg.Command.Param2 = Item;
			if (!m_pWispBase->SendMessage(&Msg))
				return false;
			Item->nFlags &= ~0x80000; //MENU_CHECKED
			Msg.Command.CmdMsg = 0x8000010B; //WISP_ID_UNCHECKED
			Msg.Command.Param1 = 0;
			m_pWispBase->SendMessage(&Msg);
			Update((WISP_RECT*)0);
		}
		return true;
	}

	bool CWispMenu::EnableItem(CWispMenu::MenuItem *Item)
	{
		if ((Item->nFlags & 0x100000)) //MENU_DISABLED
		{
			Item->nFlags &= ~0x100000; //MENU_DISABLED
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x8000010F; //WISP_ID_ENABLE
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 0;
			Msg.Command.Param2 = Item;
			m_pWispBase->SendMessage(&Msg);
			Update((WISP_RECT*)0);
		}
		return true;
	}
	bool CWispMenu::DisableItem(CWispMenu::MenuItem *Item)
	{
		if (!(Item->nFlags & 0x100000)) //MENU_DISABLED
		{
			Item->nFlags |= 0x100000; //MENU_DISABLED
			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CmdMsg = 0x80000110; //WISP_ID_DISABLE
			Msg.Command.CmdID = m_CmdID;
			Msg.Command.Param1 = 1;
			Msg.Command.Param2 = Item;
			m_pWispBase->SendMessage(&Msg);
			Update((WISP_RECT*)0);
		}
		return true;
	}

	bool CWispMenu::Enable(CWispMenu::MenuItem *Item, bool bEnable)
	{
		if (bEnable)
			return EnableItem(Item);
		return DisableItem(Item);
	}

	bool CWispMenu::Checked(CWispMenu::MenuItem *Item)
	{
		if (Item->nFlags & 0x80000) //MENU_CHECKED
		{
			UnCheckedItem(Item);
			return true;
		}
		CheckedItem(Item);
		return false;
	}

	bool CWispMenu::InitWnd()
	{
		if (!CWispWnd::InitWnd())
			return false;

		m_CurMenuItemIter = m_MenuItemList.End();
		pParentMenu = 0;
		m_bShowed = 0;
		m_FullMenuWidth = 0;
		m_BorderSize = 1;
		return true;
	}

	void CWispMenu::DrawMenu()
	{
		if (!(m_Style & 0x40))
			m_pWispBase->m_pWispDrawObj->DrawMenuItem(&m_ClientDC, &m_ClientRect, 0);

		TListIter<MenuItem> It = m_MenuItemList.Begin();
		while (It != m_MenuItemList.End())
		{
			if (It->nFlags & 4) //MENU_DELIM
			{
				m_ClientDC.DrawVLine(m_SubMenuBorderSize + It->Rect.x, It->Rect.y, It->Rect.y + It->Rect.cy - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
			} else
			{
				WISP_RECT Rect;
				Rect.x = It->Rect.x + m_pWispBase->m_Metrics[2]; //WISP_WSTYLE_BORDER
				Rect.y = It->Rect.y;
				Rect.cx = It->Rect.cx - m_SubMenuBorderSize * 2;
				Rect.cy = It->Rect.cy;

				int State = It == m_CurMenuItemIter;

				if (State)
				{
					if (m_bShowed && It->nFlags & 1) //MENU_SUBMENU
					{
						m_ClientDC.DrawHLine(It->Rect.x, It->Rect.x + It->Rect.cx - 1, It->Rect.y, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
						m_ClientDC.DrawVLine(It->Rect.x, It->Rect.y, It->Rect.y + It->Rect.cy - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
						m_ClientDC.DrawVLine(It->Rect.x + It->Rect.cx - 1, It->Rect.y, It->Rect.y + It->Rect.cy - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
						if (((CWispMenu*)It->dwData)->m_WindowRect.cx < It->Rect.cx)
							m_ClientDC.DrawHLine(It->Rect.x + It->Rect.cx - 1, It->Rect.x + ((CWispMenu*)It->dwData)->m_WindowRect.cx - 1, It->Rect.y + It->Rect.cy - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
					} else
					if (!(It->nFlags & 0x100000)) //MENU_DISABLED
					{
						m_ClientDC.DrawFullRect(&It->Rect, m_pWispBase->m_pWispDrawObj->m_crSystem[44]);
						m_ClientDC.DrawRect(&It->Rect, m_pWispBase->m_pWispDrawObj->m_crSystem[49]);
					}
					State = 1;
				}

				if (It->nFlags & 2) //MENU_CHECKBOX
				{
					WISP_RECT RC;
					RC.x = Rect.x;
					RC.y = Rect.y;
					RC.cx = 11;
					RC.cy = Rect.cy;
					m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(&m_ClientDC, &RC, ((It->nFlags & 0x80000) != 0) + 11, 0); //MENU_CHECKED WISP_SSI_CHECKBOX_UNCHECKED/WISP_SSI_CHECKBOX_CHECKED
					Rect.x += m_SubMenuBorderSize + 11;
					Rect.cx -= m_SubMenuBorderSize + 11;
				} else
				if (It->pDIB)
				{
					WISP_RECT RC;
					RC.x = Rect.x;
					RC.y = Rect.y;
					RC.cx = It->pDIB->m_PaintRect.cx;
					RC.cy = Rect.cy;
					if (It->nFlags & 0x100000) //MENU_DISABLED
						m_ClientDC.DrawDIBGray(&RC, It->pDIB);
					else	m_ClientDC.DrawDIB(&RC, It->pDIB);
					Rect.x += m_SubMenuBorderSize + It->pDIB->m_PaintRect.cx;
					Rect.cx -= m_SubMenuBorderSize + It->pDIB->m_PaintRect.cx;
				} else
				{
					Rect.x = m_SubMenuBorderSize/2 + Rect.x;
				}

				if (It->nFlags & 0x100000) //MENU_DISABLED
					State = 0x40;
				if (It->Color)
				{
					m_ClientDC.SetTextColor(It->Color);
					m_pWispBase->m_pWispDrawObj->DrawMenuItemText(&m_ClientDC, &Rect, It->string.operator const WCHAR*(), State);
					m_ClientDC.SetTextColor();
				} else
				{
					m_pWispBase->m_pWispDrawObj->DrawMenuItemText(&m_ClientDC, &Rect, It->string.operator const WCHAR*(), State);
				}
			}
			++It;
		}
		m_ClientDC.DrawHLine(0, m_ClientRect.cx - 1, m_ClientRect.cy - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[28]);
	}
	void CWispMenu::DrawPopupMenu()
	{
		WISP_RECT Rect;
		Rect.y = 0;
		Rect.x = 0;
		Rect.cx = m_MenuBorderSize;
		Rect.cy = m_ClientRect.cy;

		WISP_RECT RC;
		RC.x = m_MenuOffset;
		RC.y = m_MenuHeight;
		RC.cx = m_ClientRect.cx - m_MenuOffset;
		RC.cy = m_SubMenuOpenHeight;

		int DEEP = m_ClientRect.cx - m_SubMenuBorderSize*2 - m_MenuOffset - m_SubMenuOffset;

		m_pWispBase->m_pWispDrawObj->X88(&m_ClientDC, &Rect);

		TListIter<MenuItem> It = m_MenuItemList.Begin();
		while (It != m_MenuItemList.End())
		{
			RC.cy = It->Rect.cy;
			if (It->nFlags & 4) //MENU_DELIM
			{
				m_ClientDC.DrawHLine(m_MenuBorderSize, m_ClientRect.cx-1, RC.y, m_pWispBase->m_pWispDrawObj->m_crSystem[52]);
			} else
			{
				Rect.cy = It->Rect.cy;
				Rect.y = RC.y;
				int State = It == m_CurMenuItemIter;
				m_pWispBase->m_pWispDrawObj->DrawMenuItem(&m_ClientDC, &RC, State);
				Rect.x = m_MenuOffset + m_SubMenuBorderSize;
				Rect.cx = DEEP;
				if (It->nFlags & 0x100000) //MENU_DISABLED
					State = 0x40;
				if (It->Color)
				{
					m_ClientDC.SetTextColor(It->Color);
					m_pWispBase->m_pWispDrawObj->DrawMenuItemText(&m_ClientDC, &Rect, It->string.operator const WCHAR*(), State);
					m_ClientDC.SetTextColor();
				} else
				{
					m_pWispBase->m_pWispDrawObj->DrawMenuItemText(&m_ClientDC, &Rect, It->string.operator const WCHAR*(), State);
				}

				if (It->nFlags & 2) //MENU_CHECKBOX
				{
					Rect.x = 0;
					Rect.cx = m_MenuOffset;
					m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(&m_ClientDC, &Rect, ((It->nFlags & 0x80000) != 0) + 11, State); //MENU_CHECKED WISP_SSI_CHECKBOX_UNCHECKED/WISP_SSI_CHECKBOX_CHECKED
				} else
				if (It->pDIB)
				{
					Rect.x = 0;
					Rect.cx = m_MenuOffset;
					if (It->nFlags & 0x100000) //MENU_DISABLED
						m_ClientDC.DrawDIBGray(&Rect, It->pDIB);
					else	m_ClientDC.DrawDIB(&Rect, It->pDIB);
				}
				
				if (It->nFlags & 1) //MENU_SUBMENU
				{
					Rect.x = m_ClientRect.cx - m_SubMenuOffset;
					Rect.cx = m_SubMenuOffset;
					m_pWispBase->m_pWispDrawObj->DrawMenuItemText(&m_ClientDC, &Rect, WSTR(">>"), 0);
				}
			}
			RC.y += It->Rect.cy;
			++It;
		}

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = m_ClientRect.cx;
		Rect.cy = m_MenuHeight;
		m_pWispBase->m_pWispDrawObj->X94(&m_ClientDC, &Rect);

		Rect.x = 0;
		Rect.y = RC.y;
		Rect.cx = m_ClientRect.cx;
		Rect.cy = m_SubMenuHeight;
		m_pWispBase->m_pWispDrawObj->X98(&m_ClientDC, &Rect);
	}

	void CWispMenu::NextItem()
	{
		TListIter<MenuItem> It = m_CurMenuItemIter;
		if (It != m_MenuItemList.End() &&
			It+1 != m_MenuItemList.End())
		{
			++It;
		} else
		{
			It = m_MenuItemList.Begin();
			while (It != m_MenuItemList.End())
			{
				if (!(It->nFlags & 4)) //MENU_DELIM
					break;
				++It;
			}
		}
		m_CurMenuItemIter = It;
		Update((WISP_RECT*)0);
	}
	void CWispMenu::PrevItem()
	{
		TListIter<MenuItem> It = m_CurMenuItemIter;
		if (It != m_MenuItemList.End() &&
			It-1 != m_MenuItemList.End())
		{
			--It;
		} else
		{
			It = m_MenuItemList.End()-1;
			while (It != m_MenuItemList.End())
			{
				if (!(It->nFlags & 4)) //MENU_DELIM
					break;
				--It;
			}
		}
		m_CurMenuItemIter = It;
		Update((WISP_RECT*)0);
	}
	void CWispMenu::Adjust()
	{
		int PosX = 0;
		int PosY = 0;
		TListIter<MenuItem> It = m_MenuItemList.Begin();
		while (It != m_MenuItemList.End())
		{
			int TextExt = m_ClientDC.GetTextExtent(It->string.operator const WCHAR*(), -1, 0);
			MIN_LIMIT(PosX, TextExt);

			if (It->nFlags & 4) //MENU_DELIM
				++PosY;
			else	PosY += m_SubMenuOpenHeight;
			++It;
		}
		int Border = (m_BorderSize + m_SubMenuBorderSize)*2;
		Resize(PosX + Border + m_MenuOffset + m_SubMenuOffset, Border + PosY, true);
		RecalcLayout();
	}

	void CWispMenu::SetOwner(CWispBaseWnd *pWnd)
	{
		CWispBaseWnd::SetOwner(pWnd);
		TListIter<MenuItem> It = m_MenuItemList.Begin();
		while (It != m_MenuItemList.End())
		{
			if (It->nFlags & 1) //MENU_SUBMENU
				((CWispMenu*)It->dwData)->SetOwner(pWnd);
			++It;
		}
	}

	CWispMenu::MenuItem *CWispMenu::GetItemIndex(int Pos)
	{
		if (Pos < 0 || Pos >= m_MenuItemList.Size())
			return nullptr;
		return &*m_MenuItemList[Pos];
	}

	CWispMenu::MenuItem *CWispMenu::GetItem(const WCHAR *Text)
	{
		TListIter<MenuItem> It = m_MenuItemList.Begin();
		while (It != m_MenuItemList.End())
		{
			if (It->string.operator const WCHAR*())
			{
				if (!TStrCmp(Text, It->string.operator const WCHAR*()))
					return &*It;
			}

			if (It->nFlags & 1) //MENU_SUBMENU
			{
				CWispMenu::MenuItem *Item = ((CWispMenu*)It->dwData)->GetItem(Text);
				if (Item) return Item;
			}
			++It;
		}
		return nullptr;
	}
	CWispMenu::MenuItem *CWispMenu::GetItem(int nID)
	{
		TListIter<MenuItem> It = m_MenuItemList.Begin();
		while (It != m_MenuItemList.End())
		{
			if (It->nFlags & 1) //MENU_SUBMENU
			{
				CWispMenu::MenuItem *Item = ((CWispMenu*)It->dwData)->GetItem(nID);
				if (Item) return Item;
			} else
			if (It->nID == nID)
			{
				return &*It;
			}
			++It;
		}
		return nullptr;
	}

	bool CWispMenu::SetItemText(CWispMenu::MenuItem *Item, const WCHAR *Text)
	{
		int PosX = m_MenuOffset + m_SubMenuOffset + m_ClientDC.GetTextExtent(Text, -1, 0) + (m_BorderSize + m_SubMenuBorderSize)*2;
		if (PosX > m_WindowRect.cx)
			Resize(PosX, m_WindowRect.cy, true);
		Item->string = Text;
		return true;
	}

	bool CWispMenu::CheckedItem(int nID)
	{
		CWispMenu::MenuItem *Item = GetItem(nID);
		if (!Item) return false;
		CheckedItem(Item);
		return true;
	}
	bool CWispMenu::UnCheckedItem(int nID)
	{
		CWispMenu::MenuItem *Item = GetItem(nID);
		if (!Item) return false;
		UnCheckedItem(Item);
		return true;
	}
	bool CWispMenu::Checked(unsigned int nID, bool bChecked)
	{
		if (bChecked)
			return CheckedItem(nID);
		return UnCheckedItem(nID);
	}

	bool CWispMenu::EnableItem(int nID)
	{
		CWispMenu::MenuItem *Item = GetItem(nID);
		if (!Item) return false;
		EnableItem(Item);
		return true;
	}
	bool CWispMenu::DisableItem(int nID)
	{
		CWispMenu::MenuItem *Item = GetItem(nID);
		if (!Item) return false;
		DisableItem(Item);
		return true;
	}
	bool CWispMenu::Enable(unsigned int nID, bool bEnable)
	{
		if (bEnable)
			return EnableItem(nID);
		return DisableItem(nID);
	}

	bool CWispMenu::Point(WISP_POINT *pPoint, bool bCurent) //Open
	{
		if (!pPoint)
			pPoint = &m_pWispBase->m_MousePT;

		int PosX = pPoint->x;
		int PosY = pPoint->y;

		if (PosX > m_ParentWnd->m_WindowRect.cx - m_WindowRect.cx)
			PosX -= m_WindowRect.cx;

		if (PosY > m_ParentWnd->m_WindowRect.cy - m_WindowRect.cy)
			PosY -= m_WindowRect.cy;

		if (bCurent)
			m_CurMenuItemIter = m_MenuItemList.Begin();

		MoveToScreen(PosX, PosY, true);
		Show(WISP_SH_MINSIZE);
		Focus();
		Top(true);

		return true;
	}
	void CWispMenu::Open(CWispMenu::MenuItem *Item, bool bCurrent)
	{
		CWispMenu *SubMenu = ((CWispMenu*)Item->dwData);
		SubMenu->m_CurMenuItemIter = SubMenu->m_MenuItemList.End();
		int PosX,PosY;
		if (m_Style & 0x10000) //POPUP MENU
		{
			PosX = Item->Rect.x + Item->Rect.cx + m_ScrClientRect.x;
			PosY = Item->Rect.y + m_ScrClientRect.y;
		} else
		{
			PosY = Item->Rect.y + Item->Rect.cy + m_ScrClientRect.y;
			int PosXtmp = Item->Rect.x + m_ScrClientRect.x;
			int TextExt = m_ClientDC.GetTextExtent(Item->string.operator const WCHAR*(), -1, 0) + m_SubMenuBorderSize*2;
			if (Item->pDIB)
				TextExt += Item->pDIB->m_PaintRect.cx;
			if (TextExt > SubMenu->m_WindowRect.cx)
				SubMenu->Resize(TextExt, SubMenu->m_WindowRect.cy, true);
			PosX = PosXtmp;
		}

		if (PosX > m_ParentWnd->m_WindowRect.cx - SubMenu->m_WindowRect.cx)
			PosX -= m_WindowRect.cx + SubMenu->m_ClientRect.cx;

		if (PosY > m_ParentWnd->m_WindowRect.cy - SubMenu->m_WindowRect.cy)
			PosY += Item->Rect.cy - SubMenu->m_WindowRect.cy;

		if (bCurrent)
			SubMenu->m_CurMenuItemIter = SubMenu->m_MenuItemList.Begin();
		SubMenu->MoveToScreen(PosX, PosY, true);
		SubMenu->Show(WISP_SH_MINSIZE);
		SubMenu->Focus();
	}
	void CWispMenu::HideMenu()
	{
		CWispMenu *pMenu = this;
		while (!(pMenu->m_Style & 0x10000)) //POPUP MENU
		{
			pMenu->m_bShowed = 0;
			TListIter<MenuItem> It = pMenu->m_CurMenuItemIter;

			if (It == pMenu->m_MenuItemList.End())
				return;

			pMenu->m_CurMenuItemIter = pMenu->m_MenuItemList.End();
			if (!(It->nFlags & 1)) //MENU_SUBMENU
				return;
			pMenu = ((CWispMenu*)It->dwData);
		}

		pMenu->Show(WISP_SH_HIDDEN);

		CWispMenu *NextMenu = pMenu;
		while (1)
		{
			TListIter<MenuItem> It = NextMenu->m_CurMenuItemIter;

			if (It == NextMenu->m_MenuItemList.End())
				break;

			if (!(It->nFlags & 1)) //MENU_SUBMENU
				break;

			NextMenu->m_CurMenuItemIter = NextMenu->m_MenuItemList.End();

			NextMenu = ((CWispMenu*)It->dwData);

			((CWispMenu*)It->dwData)->Show(WISP_SH_HIDDEN);
			pMenu->m_pWispBase->m_pRootWnd->Update(&NextMenu->m_ScrWindowRect);
			if (NextMenu == 0) break; //???
		}

		pMenu->Update((WISP_RECT*)0);
	}

	bool CWispMenu::OnActiveMenu(CWispMenu::MenuItem *Item, int nID)
	{
		return true;
	}

	void CWispMenu::SwitchItem(CWispMenu::MenuItem *Item)
	{
		if (OnActiveMenu(Item, Item->nID))
		{
			if (Item->nFlags & 2) //MENU_CHECKBOX
				Checked(Item);

			WISP_MSG Msg;
			Msg.hWnd = m_OwnerWnd;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CtrlType = WISP_CTRL_MENU;
			Msg.Command.CmdMsg = 0x80000203; //WISP_ID_LBUTTON
			Msg.Command.CmdID = Item->nID;
			Msg.Command.Param1 = 0;
			Msg.Command.Param2 = Item;
			if (m_pWispBase->SendMessage(&Msg))
			{
				Msg.hWnd = m_OwnerWnd;
				Msg.Msg = WISP_WM_EVENT;
				m_pWispBase->PostMessage(&Msg);
				if (m_OwnerWnd == this)
				{
					GetRootMenu()->HideMenu();
				} else
				{
					m_OwnerWnd->Focus();
				}
			}
		}
	}
	void CWispMenu::UpdateIter(TListIter<MenuItem> It)
	{
		if (m_CurMenuItemIter != m_MenuItemList.End() && (m_CurMenuItemIter->nFlags & 1)) //MENU_SUBMENU
			((CWispMenu*)m_CurMenuItemIter->dwData)->HideMenu();
		m_CurMenuItemIter = It;
		if (m_CurMenuItemIter != m_MenuItemList.End() && (m_Style & 0x10000 || m_bShowed)) //POPUP MENU
		{
			if (m_CurMenuItemIter->nFlags & 1) //MENU_SUBMENU
				Open(&*m_CurMenuItemIter, false);
		}
		Update((WISP_RECT*)0);
	}
	bool CWispMenu::UpdateItem(CWispMenu::MenuItem *Item)
	{
		TListIter<CWispMenu::MenuItem> It = Item; //???
		if (m_CurMenuItemIter != It)
			UpdateIter(It);
		return true;
	}

	int CWispMenu::Clear()
	{
		int Count = m_MenuItemList.Size();
		m_MenuItemList.Clear();
		return Count;
	}

	CWispMenu::CWispMenu()
	{
		//m_CurMenuItemIter = 0;

		m_OpenMenuHeight = 20;

		m_MenuOffset = 20;
		m_MenuBorderSize = 20;

		m_SubMenuOffset = 20;
		m_SubMenuBorderSize = 5;

		m_MenuHeight = 5;
		m_SubMenuHeight = 5;

		m_CtrlType = WISP_CTRL_MENU;

		m_SubMenuOpenHeight = 18;
		m_FullMenuHeight = 22;
	}

	CWispMenu::~CWispMenu()
	{
	}
	
	bool CWispMenu::RemoveMenu(int nID)
	{
		TListIter<MenuItem> It = m_MenuItemList.Begin();
		while (It != m_MenuItemList.End())
		{
			if ((It->nFlags & 1) && It->nID == nID) //== 1 ???
			{
				m_MenuItemList.Remove(It);
				return true;
			}
			++It;
		}
		return false;
	}

	bool CWispMenu::RemoveMenu(CWispMenu::MenuItem *Item)
	{
		TListIter<MenuItem> It = Item;
		if (Item->nFlags & 1) return false; //== 1 ???
		m_MenuItemList.Remove(It);
		return true;
	}

	CWispMenu::MenuItem * CWispMenu::AppendMenu(int Pos, const WCHAR *Text, int nFlags, int nID, CWispDIB *pDIB, unsigned long long dwData)
	{
		TListIter<MenuItem> It;
		if (Pos >= 0)
		{
			if (Pos >= m_MenuItemList.Size())
				return nullptr;

			It = m_MenuItemList.InsertBefore(m_MenuItemList[Pos]);
		} else
			It = m_MenuItemList.Append();

		It->string = Text;
		It->pDIB = pDIB;
		It->nFlags = nFlags;
		It->nID = nID;
		It->Color = 0;
		It->dwData = dwData;
		//It->Rect ???;
		return &*It;
	}
/////////

	bool CWispMenu::LoadPopupMenuGroup(WISP_MENU_GROUP_ITEM *pMenuGroup, CWispBaseWnd *pParentWnd, CWispDIBList *pDIBList)
	{
		if (!CreateWnd(0, 0,0,0,0, 0, 0, 0x10006, WISP_SH_HIDDEN)) //??? 0x10000 POPUP MENU
			return false;
		
		if (pMenuGroup)
		{
			CWispMenu *pMenu = nullptr;
			SetOwner(pParentWnd);
			int PosX = 0;
			int PosY = 0;
			while (pMenuGroup->pszItemText || pMenuGroup->nItemID || pMenuGroup->nFlags)
			{
				if ((pMenuGroup->nFlags & 1) && pMenuGroup->pSubMenu) //MENU_SUBMENU
				{
					pMenu = new CWispMenu;
					pMenu->LoadPopupMenuGroup(pMenuGroup->pSubMenu, pParentWnd, pDIBList);
					pMenu->pParentMenu = this;
					pMenu->SetOwner(pParentWnd);
					pMenu->m_AdvStyle |= 1;
				}

				CWispDIB *pDIB = nullptr;
				if (pDIBList && pMenuGroup->nDIBIndex >= 0)
					pDIB = &pDIBList->m_DIBList[pMenuGroup->nDIBIndex]; //GetDIB
				//else	pDIB = 0;

				AppendMenu(-1, pMenuGroup->pszItemText, pMenuGroup->nFlags, pMenuGroup->nItemID, pDIB, (unsigned long long)pMenu); //???
				int TextExt = m_ClientDC.GetTextExtent(pMenuGroup->pszItemText, -1, 0);
				MIN_LIMIT(PosX, TextExt);

				if (pMenuGroup->nFlags & 4) //MENU_DELIM
					++PosY;
				else	PosY += m_SubMenuOpenHeight;
				++pMenuGroup;
				pMenu = nullptr;
			}
			int Border = (m_BorderSize + m_SubMenuBorderSize)*2;
			Resize(PosX + Border + m_MenuOffset + m_SubMenuOffset, Border + PosY, true);
		}
		return true;
	}
	bool CWispMenu::LoadMenuGroup(CWispWnd *pParentWnd, int CmdID, WISP_MENU_GROUP_ITEM *pMenuGroup, CWispDIBList *pDIBList)
	{
		if (!CreateWnd(0, 0,0,pParentWnd->m_ClientRect.cx,m_FullMenuHeight, pParentWnd, CmdID, 0, WISP_SH_MINSIZE))
			return false;
		
		if (pMenuGroup)
		{
			CWispMenu *pMenu = nullptr;
			while (pMenuGroup->pszItemText || pMenuGroup->nItemID || pMenuGroup->nFlags)
			{
				if ((pMenuGroup->nFlags & 1) && pMenuGroup->pSubMenu) //MENU_SUBMENU
				{
					pMenu = new CWispMenu;
					pMenu->LoadPopupMenuGroup(pMenuGroup->pSubMenu, m_OwnerWnd, pDIBList);
					pMenu->pParentMenu = this;
					pMenu->m_AdvStyle |= 1;
					pMenu->m_OwnerWnd = m_OwnerWnd;
				}

				CWispDIB *pDIB = nullptr;
				if (pDIBList && pMenuGroup->nDIBIndex >= 0)
					pDIB = &pDIBList->m_DIBList[pMenuGroup->nDIBIndex]; //GetDIB
				//else	pDIB = 0;
				AppendMenu(-1, pMenuGroup->pszItemText, pMenuGroup->nFlags, pMenuGroup->nItemID, pDIB, (unsigned long long)pMenu); //???
				++pMenuGroup;
				pMenu = nullptr;
			}
			RecalcLayout();
		}
		return true;
	}

```

`source/Wisp/wispmenu.hpp`:

```hpp

#ifndef _WISPMENU_HPP_
#define _WISPMENU_HPP_

#include "../Code/define.h"
#include "../Code/tstrmem.hpp"
#include "../Code/alt/altlist.hpp"
#include "wispwnd.hpp"

//enum
//{
	//1<<0   0x0001 MENU_SUBMENU
	//1<<1   0x0002 MENU_CHECKBOX
	//1<<2   0x0004 MENU_DELIM
	//1<<3   0x0008

	//1<<4   0x0010
	//1<<5   0x0020
	//1<<6   0x0040
	//1<<7   0x0080

	//1<<8   0x0100
	//1<<9   0x0200
	//1<<10  0x0400
	//1<<11  0x0800

	//1<<12  0x1000
	//1<<13  0x2000
	//1<<14  0x4000
	//1<<15  0x8000

	//1<<16  0x10000
	//1<<17  0x20000
	//1<<18  0x40000
	//1<<19  0x80000 MENU_CHECKED

	//1<<20 0x100000 MENU_DISABLED
	//1<<21 0x200000
	//1<<22 0x400000
	//1<<23 0x800000

//};

struct WISP_MENU_GROUP_ITEM
{
	const WCHAR *pszItemText;
	unsigned int nItemID;
	unsigned int nDIBIndex;
	unsigned int nFlags;
	WISP_MENU_GROUP_ITEM *pSubMenu;
};

struct CWispMenu : public CWispWnd
{
	struct MenuItem
	{
		TWideString string;
		CWispDIB *pDIB;
		unsigned int nID;
		unsigned int nFlags;
		WISP_RECT Rect;
		unsigned long Color;
		union
		{
			//CWispMenu* pSubMenu;
			unsigned long long dwData; //UNION
		};
	};

	TList<MenuItem> m_MenuItemList;
	int m_SubMenuOpenHeight;
	int m_OpenMenuHeight;
	TListIter<MenuItem> m_CurMenuItemIter;
	int m_MenuOffset;
	int m_MenuBorderSize;
	int m_SubMenuOffset;
	int m_SubMenuBorderSize;
	int m_MenuHeight;
	int m_SubMenuHeight;
	int m_FullMenuHeight;
	int m_FullMenuWidth;
	bool m_bShowed;
	CWispMenu *pParentMenu;

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnRecalcLayout(WISP_MSG *pMsg);
	bool OnResizeChild(WISP_MSG *pMsg);
	bool OnLostFocus(WISP_MSG *pMsg);
	bool OnUpdateBorder(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	bool OnMouseLeave(WISP_MSG *pMsg);

	bool CheckExist(CWispMenu *pMenu);
	CWispMenu *GetRootMenu();

	bool SetDIB(CWispMenu::MenuItem *Item, CWispDIB *pDIB);
	bool SetData(CWispMenu::MenuItem *Item, unsigned long long dwData);

	CWispMenu *GetMenu(CWispMenu::MenuItem *Item)
	{
		return (CWispMenu*)(Item->dwData);
	}

	bool CheckedItem(CWispMenu::MenuItem *Item);
	bool UnCheckedItem(CWispMenu::MenuItem *Item);

	bool EnableItem(CWispMenu::MenuItem *Item);
	bool DisableItem(CWispMenu::MenuItem *Item);

	bool Enable(CWispMenu::MenuItem *Item, bool bEnable);

	bool Checked(CWispMenu::MenuItem *Item);

	virtual bool InitWnd() override;

	void DrawMenu();
	void DrawPopupMenu();

	void NextItem();
	void PrevItem();
	void Adjust();

	virtual void SetOwner(CWispBaseWnd *pWnd) override;

	CWispMenu::MenuItem *GetItemIndex(int Pos);
	CWispMenu::MenuItem *GetItem(const WCHAR *Text);
	CWispMenu::MenuItem *GetItem(int nID);

	bool SetItemText(CWispMenu::MenuItem *Item, const WCHAR *Text);

	bool CheckedItem(int nID);
	bool UnCheckedItem(int nID);
	bool Checked(unsigned int nID, bool bChecked);
	bool EnableItem(int nID);
	bool DisableItem(int nID);
	bool Enable(unsigned int nID, bool bEnable);
	bool Point(WISP_POINT *pPoint, bool bCurent);
	void Open(CWispMenu::MenuItem *Item, bool bCurrent); //SetHoverItem/PopupMenu
	void HideMenu();

	virtual bool OnActiveMenu(CWispMenu::MenuItem *Item, int nID);

	void SwitchItem(CWispMenu::MenuItem *Item);
	void UpdateIter(TListIter<MenuItem> It);
	bool UpdateItem(CWispMenu::MenuItem *Item);
	int Clear();

	CWispMenu();
	virtual ~CWispMenu();
	
	bool RemoveMenu(int nID);
	bool RemoveMenu(CWispMenu::MenuItem *Item);
	CWispMenu::MenuItem * AppendMenu(int Pos, const WCHAR *Text, int nFlags, int nID, CWispDIB *pDIB, unsigned long long dwData);

	bool LoadPopupMenuGroup(WISP_MENU_GROUP_ITEM *pMenuGroup, CWispBaseWnd *pParentWnd, CWispDIBList *pDIBList);
	bool LoadMenuGroup(CWispWnd *pParentWnd, int CmdID, WISP_MENU_GROUP_ITEM *pMenuGroup, CWispDIBList *pDIBList);
};


#endif

```

`source/Wisp/wispmsg.hpp`:

```hpp

#ifndef _WISPMSG_HPP_
#define _WISPMSG_HPP_

#include "../Code/define.h"
#include "utility.hpp"

	enum WISP_CTRL_TYPE : unsigned int
	{
		WISP_CTRL_NULL   = 0,
		WISP_CTRL_SYS_TYPE  = 1,

		WISP_CTRL_BASE_WND_BEGIN  = 2,
		WISP_CTRL_STATIC_STRING  = 3,	//
		WISP_CTRL_STATIC_DIB  = 4,	//
		WISP_CTRL_STATIC_GROUP  = 5,	//
		WISP_CTRL_STATIC_URL  = 6,	//
		WISP_CTRL_BUTTON  = 7,		//
		WISP_CTRL_BASE_WND  = 8,	//

		WISP_CTRL_WND_BEGIN  = 9,
		WISP_CTRL_EDIT   = 10,		//
		WISP_CTRL_LIST   = 11,		//
		WISP_CTRL_CHECK_BOX  = 12,	//
		WISP_CTRL_TAB    = 13,		//???
		WISP_CTRL_MENU   = 14,		//
		WISP_CTRL_RADIO_BOX  = 15,	//
		WISP_CTRL_MSG_BOX  = 16,	//
		WISP_CTRL_PROGRESS  = 17,	//
		WISP_CTRL_SPLIT_WND  = 18,	//
		WISP_CTRL_TOOL_BAR  = 19,	//
		WISP_CTRL_FORM   = 20,		//
		WISP_CTRL_HEX_WND  = 21,	//
		WISP_CTRL_COMBO_BOX  = 22,	//
		WISP_CTRL_TERMINAL_WND = 23,	//++
		WISP_CTRL_CONSOLE_WND = 24,	//++
		WISP_CTRL_TIP_WND  = 25,

		WISP_CTRL_WND    = 27,
	};

	struct CWispBaseWnd;

	enum WISP_MOUSE_EVENT
	{
		WISP_MOUSE_LEAVE = 0,
		WISP_MOUSE_ENTER = 1,
		WISP_MOUSE_MOVE = 2,
		WISP_MOUSE_KEY = 3,
		WISP_MOUSE_EVENT_COUNT = 4,
	};

	enum 
	{
		WISP_SCROLL_BAR_VERT = 0,
		WISP_SCROLL_BAR_HORZ = 1,
		WISP_SCROLL_BAR_COUNT = 2,
	};

	enum WISP_SB_TYPE
	{
		WISP_SB_INC = 0, //DOWN
		WISP_SB_DEC = 1, //UP
		WISP_SB_PAGE_UP = 2,
		WISP_SB_PAGE_DOWN = 3,
		WISP_SB_POS_CHANGE = 4,
		WISP_SB_MIN = 5,
		WISP_SB_MAX = 6,
	};

 //WISP_HT_*	1-ON_SCRCLIENT,2-ON_CAP,3-ON_RCCLIENT,4-ON_CLOSE,5-ON_MAX,6-ON_MIN,

	struct WISP_HIT_AREA
	{
		unsigned int Type;
		unsigned int State;
	};

	struct WISP_MSG
	{
		CWispBaseWnd *hWnd;
		CWispBaseWnd *hParentWnd;
		unsigned int Msg;
		bool bMsgLBTDown;
		bool bMsgRBTDown;
		WISP_POINT MsgMouseScrPT;
		WISP_POINT MsgMouseWndPT;
		WISP_POINT m_LogicMousePosWnd;
		union
		{
			struct
			{
				unsigned int ID;
				unsigned int UserData;
				void* UserPtr;
			} Timer;

			//WISP_WM_DRAG_BEGIN ?
			//WISP_WM_DRAG_END ?

			//WISP_WM_DRAG_MOVE
			struct
			{
				WISP_POINT BeginMouseWndPT;
				unsigned int UserData;
				void* UserPtr;
				int DeltaX;
				int DeltaY;
			} DragEvent;

			//WISP_WM_KEY_EVENT
			//WISP_WM_MOUSE_DBLCLICK

			struct
			{
				WISP_HIT_AREA HitArea;
				unsigned int KeyType; //KeyCode
				bool bKeyDown;
				unsigned int ScanCode;
			} KeyEvent;

			//WISP_WM_MOUSE_WHEEL
			//WISP_WM_MOUSE_MOVE
			//WISP_WM_MOUSE_LEAVE
			//WISP_WM_VERT_SCROLL_MOVE
			//WISP_WM_HORZ_SCROLL_MOVE

			struct
			{
				WISP_HIT_AREA HitArea;
				void* hWndMouseAt;
				int DeltaX;
				int DeltaY;
				int Wheel;
			} MouseEvent;

			//WISP_WM_EVENT
			//WISP_WM_COMMAND
			struct
			{
				unsigned int CtrlType; //WISP_CTRL_TYPE
				unsigned int CmdMsg;
				unsigned int CmdID;
				int Param1;
				void* Param2;
			} Command;

			//WISP_WM_MOVING
			//WISP_WM_MOVE
			struct
			{
				int DeltaX;
				int DeltaY;
			} Move;

			//WISP_WM_CHAR
			struct
			{
				int nRepeat;
				unsigned short Char;
			} Char;

			//WISP_WM_SCROLL_EVENT
			struct
			{
				unsigned int Event; //WISP_SB_* INC,DEC,UP,DOWN
				unsigned int Type; //WISP_SCROLL_BAR_* 0,1,
				unsigned int CurPos;
				long Delta;
			} ScrollEvent;

			struct
			{
				WISP_RECT Rect;
			} Update;

			struct
			{
				WISP_HIT_AREA HitArea;
				bool bKeyDown;
			} HitTest;

			//WISP_WM_SIZING
			//WISP_WM_SIZE ???
			//WISP_WM_RESIZE_CHILD ???
			struct
			{
				WISP_SIZE Size;
				WISP_SIZE ScrSize;
			} Sizing;

			//WISP_SIZE Size;

			CWispBaseWnd *hOtherWnd;
			unsigned int EventCmdID;

			bool bExit;
			unsigned int Code;

			struct
			{
				unsigned int field_0;
				unsigned int field_4;
				unsigned int field_8;
				unsigned int field_C;
				unsigned int field_10;
				unsigned int field_14;
			};
		};// u;
	};

	enum : unsigned int
	{
		WISP_WM_CREATING  = 0x80000010,
		WISP_WM_CREATE   = 0x80000011,
		WISP_WM_CREATE_FORM  = 0x80000012,
		WISP_WM_DESTROY  = 0x80000013,
		WISP_WM_CLOSE    = 0x80000014,

		WISP_WM_KEY_EVENT  = 0x80000020,

		WISP_WM_MOUSE_ENTER  = 0x80000030,
		WISP_WM_MOUSE_MOVE  = 0x80000031,
		WISP_WM_MOUSE_LEAVE  = 0x80000032,
		WISP_WM_MOUSE_WHEEL  = 0x80000033,
		WISP_WM_MOUSE_DBLCLICK  = 0x80000034,

		WISP_WM_COMMAND  = 0x80000040,
		WISP_WM_EVENT    = 0x80000041,

		WISP_WM_UPDATE   = 0x80000100,
		WISP_WM_UPDATE_BORDER  = 0x80000101,
		WISP_WM_UPDATE_CAPTION  = 0x80000102,
		WISP_WM_UPDATE_CLIENT  = 0x80000103,
		WISP_WM_UPDATE_CARET  = 0x80000104,
		WISP_WM_UPDATE_HORZ_SCROLL_BAR  = 0x80000105,
		WISP_WM_UPDATE_VERT_SCROLL_BAR  = 0x80000106,

		WISP_WM_BEGIN_MOVE  = 0x80000120,
		WISP_WM_END_MOVE  = 0x80000121,
		WISP_WM_MOVE     = 0x80000122,
		WISP_WM_MOVING   = 0x80000123,
		WISP_WM_SIZE     = 0x80000124,
		WISP_WM_SIZING   = 0x80000125,
		WISP_WM_RECALC_LAYOUT  = 0x80000126,
		WISP_WM_RESIZE_CHILD  = 0x80000127,

		WISP_WM_CHAR     = 0x80000140,

		WISP_WM_SCROLL_EVENT  = 0x80000150,

		WISP_WM_VERT_SCROLL_MOVE  = 0x80000152,
		WISP_WM_HORZ_SCROLL_MOVE  = 0x80000153,

		WISP_WM_TIMER_EVENT  = 0x80000161,

		WISP_WM_GET_FOCUS  = 0x80000170,
		WISP_WM_LOST_FOCUS  = 0x80000171,

		WISP_WM_HIT_TEST  = 0x80000180,

		WISP_WM_DRAG_BEGIN  = 0x80000190,
		WISP_WM_DRAG_MOVE  = 0x80000191,
		WISP_WM_DRAG_END  = 0x80000192,

	//	
		WISP_ID_TOP_MOST_ROOT = 0x80000000,

	//	WISP_ID_STATIC_STR = 0x80000001,
		WISP_ID_STATIC_DIB = 0x80000002,
	//	WISP_ID_STATIC_GROUP = 0x80000003,
		WISP_ID_MAIN_FRAME = 0x80000004,
		WISP_ID_MAIN_MENU = 0x80000005,

		WISP_ID_MAIN_TOOLBAR = 0x80000007,
		WISP_ID_SOFT_KB = 0x80000008,
		WISP_ID_HELP_TIP = 0x80000009,
	//	WISP_ID_SUB_MENU = 0x8000000A,
		WISP_ID_CARET = 0x8000000B,


		WISP_ID_KEYDOWN		= 0x80000001,
		WISP_ID_KEYUP		= 0x80000002,

		WISP_ID_CMD		= 0x80000010,

		WISP_ID_EXPANDING	= 0x80000100,
		WISP_ID_EXPAND		= 0x80000101,

		WISP_ID_COLLAPSING	= 0x80000102,
		WISP_ID_COLLAPSE	= 0x80000103,

		WISP_ID_SELECTING	= 0x80000104,
		WISP_ID_SELECT		= 0x80000105,

		WISP_ID_UNSELECTING	= 0x80000106,
		WISP_ID_UNSELECT	= 0x80000107,

		WISP_ID_CHECKING	= 0x80000108,
		WISP_ID_CHECKED		= 0x80000109,

		WISP_ID_UNCHECKING	= 0x8000010A,
		WISP_ID_UNCHECKED	= 0x8000010B,

		//0x8000010C ?
		//0x8000010D ?

		WISP_ID_ITEM_EDIT_UPDATE	= 0x8000010E,

		WISP_ID_ENABLE		= 0x8000010F,
		WISP_ID_DISABLE		= 0x80000110,

		WISP_ID_ITEM_EDITITING	= 0x80000111,
		WISP_ID_ITEM_EDIT_LBUTTON	= 0x80000112,
		WISP_ID_ITEM_EDIT_RBUTTON	= 0x80000113,

		WISP_ID_ENTER		= 0x80000114,
		WISP_ID_LEAVE		= 0x80000115,

		//0x80000116 WISP_ID_?

		WISP_ID_RBUTTON_DBLCLICK	= 0x80000117,
		WISP_ID_LBUTTON_DBLCLICK	= 0x80000118,

		WISP_ID_FORM_KEYDOWN	= 0x80000119,
		WISP_ID_FORM_KEYUP	= 0x80000120,

		WISP_ID_LBUTTON_LAYOUT	= 0x80000121,
		WISP_ID_RBUTTON_LAYOUT	= 0x80000122,

		WISP_ID_CHILD_GET_FOCUS		= 0x80000201,
		WISP_ID_CHILD_LOST_FOCUS	= 0x80000202,
		WISP_ID_LBUTTON		= 0x80000203,
		WISP_ID_RBUTTON		= 0x80000204,

		WISP_ID_BOX_SELECT	= 0x80000300,
		WISP_ID_COMBO_SELECT	= 0x80000400,
		WISP_ID_OPEN_URL	= 0x80000500,

		WISP_ID_EDIT_CHANGING	= 0x80000700,
		WISP_ID_EDIT_LOST_FOCUS	= 0x80000701,
		WISP_ID_EDIT_GET_FOCUS	= 0x80000702,
		WISP_ID_EDIT_KEYDOWN	= 0x80000703,
		WISP_ID_EDIT_KEYUP	= 0x80000704,
		WISP_ID_EDIT_CHANGED	= 0x80000705,

		WISP_ID_TAB_SELECT	= 0x80000800,


		WISP_ID_CLOSE    = 0x80001000,
		WISP_ID_MAX      = 0x80001001,
		WISP_ID_MIN      = 0x80001002,

		WISP_ID_VPAGE_DEC  = 0x80001003,
		WISP_ID_VPAGE_INC  = 0x80001004,
		WISP_ID_VSPIN_SCROLL  = 0x80001005,
		WISP_ID_VSPIN_DEC  = 0x80001006,
		WISP_ID_VSPIN_INC  = 0x80001007,

		WISP_ID_HPAGE_DEC  = 0x80001008,
		WISP_ID_HPAGE_INC  = 0x80001009,
		WISP_ID_HSPIN_SCROLL  = 0x8000100A,
		WISP_ID_HSPIN_DEC  = 0x8000100B,
		WISP_ID_HSPIN_INC  = 0x8000100C,

		WISP_ID_FORM_CLOSE_ID_START = 0x80002000,
		WISP_ID_OK       = 0x80002001,
		WISP_ID_CANCEL   = 0x80002002,
		WISP_ID_YES      = 0x80002003,
		WISP_ID_NO       = 0x80002004,
		WISP_ID_RETRY    = 0x80002005,
		WISP_ID_CONTINUE = 0x80002006,
		WISP_ID_IGNORE   = 0x80002007,
		WISP_ID_ABORT    = 0x80002008,
		WISP_ID_TRY      = 0x80002009,
		WISP_ID_FORM_CLOSE_ID_END  = 0x8000200A,

		WISP_ID_COPY     = 0x8000200B,
		WISP_ID_CUT      = 0x8000200C,
		WISP_ID_PASTE    = 0x8000200D,
	};
#if 0
	WISP_MSG_MAP_BEGIN(CSystemExplorer)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispWnd)
	
	WISP_CMD_MAP_BEGIN(CSystemExplorer)
		WISP_CMD_MAP(
	WISP_CMD_MAP_END

	WISP_EVENT_MAP_BEGIN(CSystemExplorer)
		WISP_EVENT_MAP(
	WISP_EVENT_MAP_END
#endif

//MSG
#define WISP_MSG_MAP_BEGIN(x)	bool x::MsgProc(WISP_MSG *pMsg) \
				{ \
					switch (pMsg->Msg) \
					{ \
					case 0: \
				        	return false;

#define WISP_MSG_MAP(i,f)		case i: \
						if (!f(pMsg)) return false; \
						break;

#define WISP_MSG_MAP_ON_COMMAND	WISP_MSG_MAP(WISP_WM_COMMAND, OnCommand)
#define WISP_MSG_MAP_ON_EVENT	WISP_MSG_MAP(WISP_WM_EVENT, OnEvent)

#define WISP_MSG_MAP_END_	\
					} \
					return true; \
				}

#define WISP_MSG_MAP_END(x)	\
					} \
					return x::MsgProc(pMsg); \
				}
//CMD
#define WISP_CMD_MAP_BEGIN(x)	bool x::OnCommand(WISP_MSG *pMsg) \
				{ \
					switch (pMsg->Command.CmdID) \
					{ \
					case 0: \
				        	return true;

#define WISP_CMD_MAP(i,f)		case i: \
						if (!f(pMsg)) return false; \
						break;

#define WISP_CMD_MAP_DEFAULT(f)		default: \
						if (!f(pMsg)) return false; \
						break;

#define WISP_CMD_MAP_END	\
					} \
					return true; \
				}

//EVENT
#define WISP_EVENT_MAP_BEGIN(x)	bool x::OnEvent(WISP_MSG *pMsg) \
				{ \
					switch (pMsg->Command.CmdID) \
					{ \
					case 0: \
				        	return false;

#define WISP_EVENT_MAP(i,f)		case i: \
						if (!f(pMsg)) return false; \
						break;

#define WISP_EVENT_MAP_DEFAULT(f)	default: \
						if (!f(pMsg)) return false; \
						break;

#define WISP_EVENT_MAP_END	\
					} \
					return true; \
				}

#endif
```

`source/Wisp/wispmsgbox.cpp`:

```cpp

#include "wispmsgbox.hpp"
#include "wispbutton.hpp"
#include "wispbase.hpp"

	CWispMsgBox::CWispMsgBox()
	{
		m_nReturnStatus = 0;
		m_nBtnWidth = 50;
		m_CtrlType = WISP_CTRL_MSG_BOX;
	}
	CWispMsgBox::~CWispMsgBox()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispMsgBox)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP_ON_COMMAND
	WISP_MSG_MAP_END(CWispWnd)

	bool CWispMsgBox::OnUpdateClient(WISP_MSG *pMsg)
	{
		CWispWnd::OnUpdateClient(pMsg);
		WISP_RECT rcText;
		rcText.x = m_dibIcon.m_PixelBuf.VideoBuffer != 0 ? 50 : 20;
		rcText.y = 10;
		rcText.cx = m_ClientRect.cx - rcText.x;
		rcText.cy = m_ClientRect.cy;
		m_ClientDC.DrawString(m_strText.operator const WCHAR*(), &rcText, 0, 0, -1);
		if (m_dibIcon.m_PixelBuf.VideoBuffer)
			m_ClientDC.DrawDIB(10, 10, &m_dibIcon);
		return false;
	}
	bool CWispMsgBox::OnCommand(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CtrlType == WISP_CTRL_BUTTON && pMsg->Command.CmdMsg == 0x80000002) //WISP_ID_KEYUP
		{
			m_nReturnStatus = pMsg->Command.CmdID;
			Show(WISP_SH_HIDDEN);
		}
		return true;
	}
	bool CWispMsgBox::Create(CWispBaseWnd *pParentWnd)
	{
		return CreateWnd(0,0,0,0,0, pParentWnd, 0, 0xB, WISP_SH_MINSIZE);
	}
	int CWispMsgBox::StaticShowMsgBox(const WCHAR *pText, const WCHAR *pCaption, unsigned int uType, CWispBaseWnd *pParentWnd)
	{
		CWispMsgBox MsgBox;
		if (!MsgBox.Create(pParentWnd))
			return 0;
		return MsgBox.ShowMsgBox(pText,pCaption,uType);
	}
	int CWispMsgBox::ShowMsgBox(const WCHAR *pText, const WCHAR *pCaption, unsigned int uType)
	{
		m_strText = pText;
		m_WndText = pCaption;
		
		if ( !(uType & 0x1000) )
		{
			AddDefaultButton((uType & 0xFFF) ? (uType & 0xFFF) : 1);
		}

		if (uType & 0xF0000)
			AddDefaultIcon(uType);

		WISP_RECT rcText;
		rcText.x = 0;
		rcText.y = 0;
		rcText.cx = 0;
		rcText.cy = 0;
		
		m_ClientDC.DrawString(pText, &rcText, 0x400, 0, -1);
		int TextWidth = rcText.cx + (m_dibIcon.m_PixelBuf.VideoBuffer != 0 ? 20 : 0);
		int CapWidth = m_ClientDC.GetTextExtent(pCaption, -1, 0);

		if (MAX(TextWidth, CapWidth) < m_lButtons.Size() * (m_nBtnWidth + 4))
			TextWidth = m_lButtons.Size() * (m_nBtnWidth + 4);
		else
		if (TextWidth <= CapWidth)
			TextWidth = CapWidth;

		int cx = TextWidth + 60;
		if (cx < 150) cx = 150; //MIN_LIMIT

		int cy = rcText.cy + 50;
		if (cy <= 120) cy = 120; //MIN_LIMIT

		Resize(cx, cy, true);
		Center(0);

		__int64 NextA = (cx - m_lButtons.Size() * (m_nBtnWidth + 4));
		int Next = NextA-(unsigned long)NextA; //ALIGN
		Next /= 2;

		TListIter<BTNPAIR> It = m_lButtons.Begin();
		while (It != m_lButtons.End())
		{
			Next += 2;
			CWispButton *pButton = new CWispButton;
			pButton->Create(It->pBtnText, Next, cy-50, m_nBtnWidth, m_ClientDC.m_pFont->m_Height + 6, this, It->nID, 0, 1);
			if (It->nID == WISP_ID_OK || It->nID == WISP_ID_YES)
				pButton->Focus();
			pButton->m_AdvStyle |= 1;
			Next += m_nBtnWidth;
			++It;
		}
		Show(WISP_SH_MODAL_BLOCK);
		Destroy();
		m_lButtons.Clear();
		return m_nReturnStatus;
	}
	void CWispMsgBox::AddButton(const WCHAR *pText, int nID)
	{
		BTNPAIR stPair;
		stPair.pBtnText = pText;
		stPair.nID = nID;
		int nBtnWidth = m_ClientDC.GetTextExtent(pText, -1, 0) + 4;
		MIN_LIMIT(m_nBtnWidth, nBtnWidth);
		m_lButtons.Append(&stPair);
	}
	void CWispMsgBox::AddDefaultButton(unsigned int uType)
	{
		if (uType & 0x001)
			AddButton(WSTR("OK"), WISP_ID_OK);
		if (uType & 0x020)
			AddButton(WSTR("YES"), WISP_ID_YES);
		if (uType & 0x040)
			AddButton(WSTR("NO"), WISP_ID_NO);
		if (uType & 0x002)
			AddButton(WSTR("CANCEL"), WISP_ID_CANCEL);
		if (uType & 0x100)
			AddButton(WSTR("TRY"), WISP_ID_TRY);
		if (uType & 0x080)
			AddButton(WSTR("CONTINUE"), WISP_ID_CONTINUE);
		if (uType & 0x004)
			AddButton(WSTR("ABORT"), WISP_ID_ABORT);
		if (uType & 0x008)
			AddButton(WSTR("RETRY"), WISP_ID_RETRY);
		if (uType & 0x010)
			AddButton(WSTR("IGNORE"), WISP_ID_IGNORE);
	}
	void CWispMsgBox::AddDefaultIcon(unsigned int uType)
	{
		if (uType & 0x10000)
		{
			m_dibIcon.Load("\\WispApp\\MsgBox\\Information.bmp", -1);
		} else
		if (uType & 0x20000)
		{
			m_dibIcon.Load("\\WispApp\\MsgBox\\Question.bmp", -1);
		} else
		if (uType & 0x30000)
		{
			m_dibIcon.Load("\\WispApp\\MsgBox\\Alert.bmp", -1);
		} else
		if (uType & 0x40000)
		{
			m_dibIcon.Load("\\WispApp\\MsgBox\\Error.bmp", -1);
		}
		m_dibIcon.m_Type = 2; //
		m_dibIcon.m_ColorKey = m_pWispBase->m_pWispDrawObj->m_crSystem[109];
	}
	void CWispMsgBox::RemoveAllButtons()
	{
		m_lButtons.Clear();
	}

```

`source/Wisp/wispmsgbox.hpp`:

```hpp

#ifndef _WISPMSGBOX_HPP_
#define _WISPMSGBOX_HPP_

#include "../Code/define.h"
#include "../Code/alt/altlist.hpp"
#include "wispwnd.hpp"
#include "wispdib.hpp"

struct CWispMsgBox : public CWispWnd
{
	CWispMsgBox();
	virtual ~CWispMsgBox();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool Create(CWispBaseWnd *pParentWnd);
	static int StaticShowMsgBox(const WCHAR *pText, const WCHAR *pCaption, unsigned int uType, CWispBaseWnd *pParentWnd);
	int ShowMsgBox(const WCHAR *pText, const WCHAR *pCaption, unsigned int uType);
	void AddButton(const WCHAR *pText, int nID);
	void AddDefaultButton(unsigned int uType);
	void AddDefaultIcon(unsigned int uType);
	void RemoveAllButtons();

	struct BTNPAIR
	{
		TWideString pBtnText;
		int nID;
	};

	TList<BTNPAIR> m_lButtons;
	TWideString m_strText;
	int m_nBtnWidth;
	CWispDIB m_dibIcon;
	int m_nReturnStatus;
};

#endif

```

`source/Wisp/wispmultitabview.cpp`:

```cpp

#include "wispmultitabview.hpp"

#define ID_TOOLBAR	0x40000003

	CWispMultiTabView::CWispMultiTabView()
	{
		m_nWithToolbar = 0;
	}
	CWispMultiTabView::~CWispMultiTabView()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispMultiTabView)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
	WISP_MSG_MAP_END(CWispTabWnd)

	bool CWispMultiTabView::OnCreate(WISP_MSG *pMsg)
	{
		if (m_nWithToolbar)
			m_Toolbar.CreateEx(this, 0, 0, ID_TOOLBAR, 0x10000);
		return true;
	}
	bool CWispMultiTabView::OnSize(WISP_MSG *pMsg)
	{
		int y = (m_TabSpaceHeight - m_Toolbar.m_WindowRect.cy)/2;
		if (!(m_Style & 0x10000))
			y += m_ClientRect.cy - m_TabSpaceHeight;
		int x = m_ClientRect.cx - m_Toolbar.m_WindowRect.cx - 2;
		if (m_Toolbar.IsWindow())
			m_Toolbar.MoveToClient(x, y, true);
		return true;
	}
	bool CWispMultiTabView::OnDestroy(WISP_MSG *pMsg)
	{
		return true;
	}

```

`source/Wisp/wispmultitabview.hpp`:

```hpp

#ifndef _WISPMULTITABVIEW_HPP_
#define _WISPMULTITABVIEW_HPP_

#include "../Code/define.h"
#include "wisptabwnd.hpp"
#include "wisptoolbar.hpp"

//enum
//{
//  WISP_MULTI_TAB_CMD_FULL_SCREEN = 0x40000000,
//  WISP_MULTI_TAB_CMD_NEW_VIEW = 0x40000001,
//  WISP_MULTI_TAB_CMD_REMOVE_VIEW = 0x40000002,
//};

struct CWispMultiTabView : public CWispTabWnd
{
	CWispMultiTabView();
	virtual ~CWispMultiTabView();
	int m_nWithToolbar;
	CWispToolbar m_Toolbar;

//	CWispButton m_FullScrBT;
//	CWispButton m_NewViewBT;
//	CWispButton m_RemoveViewBT;
//	CWispDIBList m_FullScrDIB;
//	CWispDIBList m_NewViewDIB;
//	CWispDIBList m_RemoveViewDIB;
//	CWispDIBList m_NormalViewDIB;
//	WISP_SIZE m_ViewBTSize;

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);

	//bool OnCommand(WISP_MSG *pMsg);
	//bool OnCmdFullScr(WISP_MSG *pMsg);
	//bool OnCmdNewView(WISP_MSG *pMsg);
	//bool OnCmdRemoveView(WISP_MSG *pMsg);
};
#endif

```

`source/Wisp/wispoptionform.cpp`:

```cpp

#include "wispoptionform.hpp"
#include "wisprgbselect.hpp"
#include "wispmenu.hpp"
#include "wispbase.hpp"
#include "../Code/sysdep.hpp"

struct CWispSelectMenu : public CWispMenu
{
	int m_nID;

	CWispSelectMenu()
	{
		m_nID = -1;
	}

	virtual bool OnActiveMenu(CWispMenu::MenuItem *Item, int nID) override
	{
		m_nID = nID - 1;
		Close();
		return true;
	}

	bool LoadPopupMenuGroup(const WCHAR *Text[])
	{
		if (!CreateWnd(0, 0,0,0,0, 0, 0, 0x10006, WISP_SH_HIDDEN))
			return false;
		
		SetOwner(this);
		int PosX = 0;
		int PosY = 0;
		int Index = 0;
		while (Text[Index])
		{
			if (!TStrNCmp(Text[Index], WSTR("%d"), 2))// && Text[Index+1] = 'd')
				AppendMenu(-1, &Text[Index][2], 0x100000, Index+1, 0, 0);
			else	AppendMenu(-1, Text[Index+0],        0, Index+1, 0, 0);
				
			int TextExt = m_ClientDC.GetTextExtent(Text[Index], -1, 0);
			MIN_LIMIT(PosX, TextExt);
			PosY += m_SubMenuOpenHeight;
			++Index;
		}
		int Border = (m_BorderSize + m_SubMenuBorderSize)*2;
		Resize(PosX + Border + m_MenuOffset + m_SubMenuOffset, PosY + Border, true);
		return true;
	}

	static bool StaticCreate(int PosX, int PosY, const WCHAR *Text[], unsigned int *pnID, int Index)
	{
		CWispSelectMenu SelectMenu;
		SelectMenu.LoadPopupMenuGroup(Text);
		WISP_POINT Point;
		Point.x = PosX;
		Point.y = PosY;
		CWispBaseWnd *pWnd = SelectMenu.m_pWispBase->m_pFocusWnd;
		SelectMenu.Point(&Point, 0);
		if (Index >= 0)
		{
			CWispMenu::MenuItem *Item = SelectMenu.GetItemIndex(Index);
			if (Item)
				SelectMenu.UpdateItem(Item);
		}
		SelectMenu.Show(WISP_SH_MODAL_BLOCK);
		SelectMenu.Destroy();
		pWnd->Focus();
		if (SelectMenu.m_nID >= 0)
		{
			*pnID = SelectMenu.m_nID;
			return true;
		}
		return false;
	}
};


	void CWispOptionList::DrawContent(int nCol, CListStringItem::CONTENT *Content, WISP_RECT *pRect) //+94
	{
		OPTION_FORM *Option = (OPTION_FORM*)Content->Number;
		if (nCol == 1 && Option->Type == OPTION_COLOR)
		{
			m_ClientDC.DrawFullRect(pRect->x, pRect->y + 2, 20, pRect->cy - 4, *(unsigned long*)Option->NewValue);
			m_ClientDC.DrawRect(pRect->x, pRect->y + 2, 20, pRect->cy - 4, m_pWispBase->m_pWispDrawObj->m_crSystem[0]);
		}
		return CWispList::DrawContent(nCol, Content, pRect);
	}

#define ID_OPTLIST	0x40000000
#define ID_APPLY	0x40000001
#define ID_RESTORE	0x40000002
#define ID_DEFAULT	0x40000003

WISP_FORM_RES_ITEM WispOptionForm[] =
{
	{ WISP_CTRL_FORM, {0, 0, 540, 330}, 0, 0, 0, 0, 0},
	{ WISP_CTRL_BUTTON, {430, 300, 100, 20}, ID_APPLY, 0x200, WSTR("Apply"), 0, 0},
	{ WISP_CTRL_BUTTON, {10, 300, 100, 20}, ID_RESTORE, 0x200, WSTR("Restore"), 0, 0},
	{ WISP_CTRL_BUTTON, {120, 300, 100, 20}, ID_DEFAULT, 0, WSTR("Default"), 0, 0},
	{ 0 },
};

	CWispOptionForm::CWispOptionForm()
	{
		m_Resource = WispOptionForm;
	}

	CWispOptionForm::~CWispOptionForm()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispOptionForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

	bool CWispOptionForm::OnCreateForm(WISP_MSG *pMsg)
	{
		m_OptionList.CreateWnd(0, 10,10,520,280, this, ID_OPTLIST, 0x46070006, WISP_SH_MINSIZE);
		m_pApply = (CWispButton *)GetFormItem(ID_APPLY);
		m_pRestore = (CWispButton *)GetFormItem(ID_RESTORE);
		m_pDefault = (CWispButton *)GetFormItem(ID_DEFAULT);
		m_OptionList.InsertColumn(WSTR("Option Item"), m_OptionList.m_ClientRect.cx / 2, 0, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xF), -1);
		m_OptionList.InsertColumn(WSTR("Value"), m_OptionList.m_ClientRect.cx / 2, 1, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x1A), -1);
		LoadItems(m_OptionForm, 0);
		if (m_Style & 0x10000)
			m_pDefault->Show(WISP_SH_HIDDEN);
		return true;
	}

	void CWispOptionForm::SetText(OPTION_FORM *Option, CListStringItem *Item)
	{
		switch (Option->Type)
		{
		case OPTION_STRNUM:{
			m_OptionList.SetItemFormat(Item, 1, *(unsigned int*)Option->DefaultValue, WSTR("%d"));
			break;}
		case OPTION_INT:{
			int Pos = 0;
			if (!TStrNCmp(Option->SelectValue[*(unsigned int*)Option->DefaultValue], WSTR("%d"),2)) Pos=2;
			m_OptionList.SetItemText(Item, 1, &Option->SelectValue[*(unsigned int*)Option->DefaultValue][Pos]);
			break;}
		case OPTION_STR:{
		case OPTION_DIR:
			m_OptionList.SetItemText(Item, 1, (WCHAR*)Option->DefaultValue);
			break;}
		default:;
		}
	}

	void CWispOptionForm::LoadTexts(CListStringItem *ParentItem)
	{
		CListStringItem *It = m_OptionList.GetItem(0, ParentItem);
		while (It)
		{
			OPTION_FORM *Option = (OPTION_FORM *)m_OptionList.GetItemValue(It, 0);
			if (Option->Type == OPTION_SUB)
			{
				LoadTexts(It);
			} else
			{
				SetText(Option, It);
				memcpy(Option->NewValue, Option->DefaultValue, Option->Size);
			}
			It = m_OptionList.GetNext(It, 0);
		}
	}

	void CWispOptionForm::LoadItems(OPTION_FORM *Option, CListStringItem *ParentItem)
	{
		if (Option)
		while (Option->Name)
		{
			CListStringItem *Item = m_OptionList.InsertItemStr(Option->Name, ParentItem, 0, 0, -1);
			m_OptionList.SetItemValue(Item, 0, (unsigned long long)Option);
			m_OptionList.SetItemValue(Item, 1, (unsigned long long)Option);
			if (Option->Type == OPTION_SUB)
			{
				LoadItems((OPTION_FORM *)Option->DefaultValue, Item);
			} else
			{
				Option->NewValue = new unsigned char[Option->Size];
				memcpy(Option->NewValue, Option->DefaultValue, Option->Size);
			}
			++Option;
		}
	}

	bool CWispOptionForm::OnDestroy(WISP_MSG *pMsg)
	{
		Destroy(0);
		return true;
	}

	bool CWispOptionForm::OnSize(WISP_MSG *pMsg)
	{
		m_OptionList.Resize(m_ClientRect.cx - 20, m_ClientRect.cy - 50, true);
		m_pRestore->MoveToWindow(m_OptionList.m_ScrWindowRect.x - m_ScrWindowRect.x,
			m_OptionList.m_ScrWindowRect.y + m_OptionList.m_WindowRect.cy - m_ScrWindowRect.y + 10, true);
		if (m_pDefault->IsWindowShow())
			m_pDefault->MoveToWindow(m_pRestore->m_ScrWindowRect.x + m_pRestore->m_WindowRect.cx - m_ScrWindowRect.x + 10,
						m_pRestore->m_ScrWindowRect.y - m_ScrWindowRect.y, true);
		m_pApply->MoveToWindow(m_OptionList.m_ScrWindowRect.x + m_OptionList.m_ScrWindowRect.cx - m_pApply->m_WindowRect.cx - m_ScrWindowRect.x,
					m_pRestore->m_ScrWindowRect.y - m_ScrWindowRect.y, true);
		return true;
	}

	bool CWispOptionForm::OnCmdOptionList(WISP_MSG *pMsg)
	{
		switch (pMsg->Command.CmdMsg)
		{
		case 0x80000111:{ //WISP_ID_ITEM_EDITITING
			CListStringItem *Item = (CListStringItem *)pMsg->Command.Param2;
			OPTION_FORM *tmp = (OPTION_FORM *)m_OptionList.GetItemValue(Item, 0);
			if (!tmp) return false;
			WISP_RECT Rect;
			if (!m_OptionList.GetItemRect(Item, pMsg->Command.Param1, &Rect))
				return false;
			return GetFormInput(Rect.x + m_OptionList.m_ScrClientRect.x,
					Rect.y + Rect.cy + m_OptionList.m_ScrClientRect.y, Item, tmp);}
		case 0x80000112:{ //WISP_ID_ITEM_EDIT_LBUTTON
			CListStringItem *Item = (CListStringItem *)pMsg->Command.Param2;
			OPTION_FORM *tmp = (OPTION_FORM *)m_OptionList.GetItemValue(Item, 0);
			if (!tmp) return false;
			return Process(Item, tmp);}
		case 0x80000119:{ //WISP_ID_FORM_KEYDOWN
			if (pMsg->Command.Param1 == 0x71) //VK_F2
			{
				CListStringItem *Item = m_OptionList.FullFindItem(0, 8);
				if (Item && m_OptionList.GetItemValue(Item, 0))
					m_OptionList.EditItem(Item, 1);
			}}
		}
		return true;
	}

	WISP_CMD_MAP_BEGIN(CWispOptionForm)
		WISP_CMD_MAP(ID_OPTLIST, OnCmdOptionList)
	WISP_CMD_MAP_END

	WISP_EVENT_MAP_BEGIN(CWispOptionForm)
		WISP_EVENT_MAP(ID_APPLY, OnEventApply)
		WISP_EVENT_MAP(ID_RESTORE, OnEventRestore)
		WISP_EVENT_MAP(ID_DEFAULT, OnEventDefault)
	WISP_EVENT_MAP_END

	bool CWispOptionForm::Process(CListStringItem *Item, OPTION_FORM *Option)
	{
		if (Option->Type == OPTION_STR)
		{
			if (TStrCmp(m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), (WCHAR*)Option->DefaultValue))
			{
				memset(Option->NewValue, 0, Option->Size);
				TStrCpyLimit((WCHAR*)Option->NewValue, m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), Option->Size);
				OnNew(Item);
			} else
			if (TStrCmp(m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), (WCHAR*)Option->NewValue))
			{
				memset(Option->NewValue, 0, Option->Size);
				TStrCpyLimit((WCHAR*)Option->NewValue, m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), Option->Size);
				OnOld(Item);
			}			
		} else
		if (Option->Type == OPTION_STRNUM)
		{
			unsigned int Num;
			if (!USDecStrToNum(m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), &Num))
				return false;
			if (Option->CheckValue && !Option->CheckValue(&Num))
				return false;
			if (Num != *(unsigned int*)Option->DefaultValue)
			{
				*(unsigned int*)Option->NewValue = Num;
				OnNew(Item);
			} else
			if (Num != *(unsigned int*)Option->NewValue)
			{
				*(unsigned int*)Option->NewValue = Num;
				OnOld(Item);
			}
		} else
		if (Option->Type == OPTION_DIR)
		{
			if (TStrCmp(m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), (WCHAR*)Option->DefaultValue))
			{
				char szPath[MAX_FN_LEN];
				UnicodeToAnsi(m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), szPath, MAX_FN_LEN);
				if (!gpFileIO->IsDir(szPath))
					return false;
				
				memset(Option->NewValue, 0, Option->Size);
				TStrCpyLimit((WCHAR*)Option->NewValue, m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), Option->Size);
				OnNew(Item);
			} else
			if (TStrCmp(m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), (WCHAR*)Option->NewValue))
			{
				memset(Option->NewValue, 0, Option->Size);
				TStrCpyLimit((WCHAR*)Option->NewValue, m_OptionList.m_EditWnd.m_WndText.operator const WCHAR*(), Option->Size);
				OnOld(Item);
			}			
		}
		return true;
	}

	bool CWispOptionForm::OnEventApply(WISP_MSG *pMsg)
	{
		if (OnAppling())
		{
			EventApply(0);
			m_pApply->EnableWindow(false);
			m_pRestore->EnableWindow(false);
			m_nChanges = 0;
			SendCommand(0x40000000, 0, 0);
			OnApply();
			Update(&m_ClientRect);
		}
		return true;
	}

	bool CWispOptionForm::OnEventRestore(WISP_MSG *pMsg)
	{
		if (OnRestoring())
		{
			EventRestore(0);
			m_pApply->EnableWindow(false);
			m_pRestore->EnableWindow(false);
			m_nChanges = 0;
			OnRestore();
			Update(&m_ClientRect);
		}
		return true;
	}

	bool CWispOptionForm::OnEventDefault(WISP_MSG *pMsg)
	{
		if (OnDefaulting())
		{
			EventDefault(0);
			m_pApply->EnableWindow(false);
			m_pRestore->EnableWindow(false);
			m_pDefault->EnableWindow(false);
			m_nChanges = 0;
			OnDefault();
			Update(&m_ClientRect);
		}
		return true;
	}

	void CWispOptionForm::EventApply(CListStringItem *ParentItem)
	{
		CListStringItem *It = m_OptionList.GetItem(0, ParentItem);
		while (It)
		{
			OPTION_FORM *Option = (OPTION_FORM *)m_OptionList.GetItemValue(It, 0);
			if (Option->Type == OPTION_SUB)
			{
				EventApply(It);
			} else
			if (memcmp(Option->DefaultValue, Option->NewValue, Option->Size) != 0)
			{
				memcpy(Option->DefaultValue, Option->NewValue, Option->Size);
				if (Option->Update)
					++*Option->Update;
				SetText(Option, It);
				m_OptionList.SetItemColor(It, -1, m_OptionList.m_ItemColor);
			}
			It = m_OptionList.GetNext(It, 0);
		}
	}

	void CWispOptionForm::EventRestore(CListStringItem *ParentItem)
	{
		CListStringItem *It = m_OptionList.GetItem(0, ParentItem);
		while (It)
		{
			OPTION_FORM *Option = (OPTION_FORM *)m_OptionList.GetItemValue(It, 0);
			if (Option->Type == OPTION_SUB)
			{
				EventRestore(It);
			} else
			if (memcmp(Option->DefaultValue, Option->NewValue, Option->Size) != 0)
			{
				memcpy(Option->NewValue, Option->DefaultValue, Option->Size);
				SetText(Option, It);
				m_OptionList.SetItemColor(It, -1, m_OptionList.m_ItemColor);
			}
			It = m_OptionList.GetNext(It, 0);
		}
	}

	void CWispOptionForm::EventDefault(CListStringItem *ParentItem)
	{
		CListStringItem *It = m_OptionList.GetItem(0, ParentItem);
		while (It)
		{
			OPTION_FORM *Option = (OPTION_FORM *)m_OptionList.GetItemValue(It, 0);
			if (Option->Type == OPTION_SUB)
			{
				EventDefault(It);
			} else
			{
				memcpy(Option->NewValue, Option->DefaultValue, Option->Size);
				SetText(Option, It);
				m_OptionList.SetItemColor(It, -1, m_OptionList.m_ItemColor);
			}
			It = m_OptionList.GetNext(It, 0);
		}
	}

	void CWispOptionForm::Destroy(CListStringItem *ParentItem)
	{
		CListStringItem *It = m_OptionList.GetItem(0, ParentItem);
		while (It)
		{
			OPTION_FORM *Option = (OPTION_FORM *)m_OptionList.GetItemValue(It, 0);
			if (Option->Type == OPTION_SUB)
			{
				Destroy(It);
			} else
			{
				delete [](unsigned char*)Option->NewValue; //???
			}
			It = m_OptionList.GetNext(It, 0);
		}
	}

	bool CWispOptionForm::GetFormInput(int PosX, int PoxY, CListStringItem *Item, OPTION_FORM *pOptionGroup)
	{
		switch (pOptionGroup->Type)
		{
		case OPTION_SUB:
			return false;

		case OPTION_INT:{
			unsigned int nID;
			if (!CWispSelectMenu::StaticCreate(PosX, PoxY, pOptionGroup->SelectValue, &nID, *(unsigned int*)pOptionGroup->DefaultValue))
				return false;
			if (*(unsigned int*)pOptionGroup->DefaultValue == nID)
			{
				if (*(unsigned int*)pOptionGroup->NewValue != nID)
				{	
					*(unsigned int*)pOptionGroup->NewValue = nID;
					m_OptionList.SetItemText(Item, 1, pOptionGroup->SelectValue[nID]);
					OnOld(Item);
				}
			} else
			if (!pOptionGroup->CheckValue || !pOptionGroup->CheckValue(&nID))
			{
				*(unsigned int*)pOptionGroup->NewValue = nID;
				m_OptionList.SetItemText(Item, 1, pOptionGroup->SelectValue[nID]);
				OnNew(Item);
			}
			
			return false;
			}
		case OPTION_DIR:{
			unsigned int nID;
			if (!CWispSelectMenu::StaticCreate(PosX, PoxY, pOptionGroup->SelectValue, &nID, -1))
				return false;
			WCHAR FileName[MAX_FN_LEN];
			if (nID == 0)
			{
				if (!m_pWispBase->GetOpenFolderName(FileName, m_OptionList.GetItemContent(Item, 0)->String.operator const WCHAR*()))
					return false;

				if (TStrCmp(FileName, (WCHAR*)pOptionGroup->DefaultValue))
				{
					memset(pOptionGroup->NewValue, 0, pOptionGroup->Size);
					TStrCpyLimit((WCHAR*)pOptionGroup->NewValue, FileName, pOptionGroup->Size);
					OnNew(Item);
				} else
				if (TStrCmp(FileName, (WCHAR*)pOptionGroup->NewValue))
				{
					memset(pOptionGroup->NewValue, 0, pOptionGroup->Size);
					TStrCpyLimit((WCHAR*)pOptionGroup->NewValue, FileName, pOptionGroup->Size);
					OnOld(Item);
				}			
				return false;
			} else
			if (nID == 2)
			{
				char szPath[MAX_FN_LEN];
				GetModulePath(szPath, false);
				AnsiToUnicode(szPath, FileName, lenof(FileName));
				m_OptionList.m_EditWnd.m_WndText = FileName;
			}
			return true;
			}
		case OPTION_COLOR:{
			if (!CWispRGBSelect::StaticCreate((unsigned long*)pOptionGroup->NewValue, (unsigned long*)pOptionGroup->DefaultValue))
				return false;

			if (*(unsigned long*)pOptionGroup->NewValue != *(unsigned long*)pOptionGroup->DefaultValue)
			{
				OnNew(Item);
			}
			return false;
			}
		}
		return true;
	}

	bool CWispOptionForm::OnAppling() { return true; }
	void CWispOptionForm::OnApply() {}

	bool CWispOptionForm::OnRestoring() { return true; }
	void CWispOptionForm::OnRestore() {}

	bool CWispOptionForm::OnDefaulting() { return true; }
	void CWispOptionForm::OnDefault() {}


	void CWispOptionForm::OnNew(CListStringItem *Item)
	{
		m_OptionList.SetItemColor(Item, -1, m_pWispBase->m_pWispDrawObj->m_crSystem[2]);
		++m_nChanges;
		if ((m_pApply->m_Style >> 9) & 1)	m_pApply->EnableWindow(1);
		if ((m_pRestore->m_Style >> 9) & 1)	m_pRestore->EnableWindow(1);
		if ((m_pDefault->m_Style >> 9) & 1)	m_pDefault->EnableWindow(1);
	}
	void CWispOptionForm::OnOld(CListStringItem *Item)
	{
		m_OptionList.SetItemColor(Item, -1, m_OptionList.m_ItemColor);
		if (m_nChanges-- == 1)
		{
			if ((m_pApply->m_Style >> 9) & 1)	m_pApply->EnableWindow(0);
			if ((m_pRestore->m_Style >> 9) & 1)	m_pRestore->EnableWindow(0);
		}
	}

```

`source/Wisp/wispoptionform.hpp`:

```hpp

#ifndef _WISPOPTIONFORM_HPP_
#define _WISPOPTIONFORM_HPP_

#include "../Code/define.h"
#include "wispform.hpp"
#include "wisplist.hpp"
#include "wispbutton.hpp"

enum
{
	OPTION_SUB	= 0,
	OPTION_STRNUM	= 1,
	OPTION_INT	= 2,
	OPTION_STR	= 3,
	OPTION_DIR	= 4,
	OPTION_COLOR	= 5,
};

struct OPTION_FORM
{
	const WCHAR *Name;
	int Type;
	//union
	//{
		//unsigned char *DefaultValue;
		void *DefaultValue;
		//OPTION_FORM *Sub;//0
		//unsigned int *IntValue;//1,2
		//const WCHAR *StrValue;//3
		//const WCHAR *DirValue;//4
		//unsigned long *ColorValue; //5
	//};
	int Size;
	const WCHAR **SelectValue;
	bool (*CheckValue)(unsigned int *IntValue);
	unsigned int *Update;
	//unsigned char *NewValue;
	void *NewValue;
};

struct CWispOptionList : public CWispList
{
	virtual void DrawContent(int nCol, CListStringItem::CONTENT *Content, WISP_RECT *pRect) override; //+94
};

struct CWispOptionForm : public CWispForm
{
	OPTION_FORM *m_OptionForm;
	int m_nChanges;
	CWispOptionList m_OptionList;
	CWispButton *m_pApply;
	CWispButton *m_pRestore;
	CWispButton *m_pDefault;

	CWispOptionForm();
	virtual ~CWispOptionForm();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);

	void SetText(OPTION_FORM *Option, CListStringItem *Item);
	void LoadTexts(CListStringItem *ParentItem);
	void LoadItems(OPTION_FORM *Option, CListStringItem *ParentItem);

	bool OnDestroy(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);
	bool OnCmdOptionList(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool Process(CListStringItem *Item, OPTION_FORM *Option);

	bool OnEventApply(WISP_MSG *pMsg);
	bool OnEventRestore(WISP_MSG *pMsg);
	bool OnEventDefault(WISP_MSG *pMsg);

	void EventApply(CListStringItem *ParentItem);
	void EventRestore(CListStringItem *ParentItem);
	void EventDefault(CListStringItem *ParentItem);

	void Destroy(CListStringItem *Item);

	bool GetFormInput(int PosX, int PoxY, CListStringItem *Item, OPTION_FORM *pOptionGroup);

	virtual bool OnAppling(); //{ return true; }
	virtual void OnApply(); //{}

	virtual bool OnRestoring(); //{ return true; }
	virtual void OnRestore(); //{}

	virtual bool OnDefaulting(); //{ return true; }
	virtual void OnDefault(); //{}


	virtual void OnNew(CListStringItem *Item);
	virtual void OnOld(CListStringItem *Item);
};


#endif
```

`source/Wisp/wispprogress.cpp`:

```cpp

#include "wispprogress.hpp"
#include "wispbase.hpp"

	CWispProgress::CWispProgress()
	{
		m_nPos = 0;
		m_nLower = 0;
		m_nStep = 1;
		m_nUpper = 9;
		m_CtrlType = WISP_CTRL_PROGRESS;
	}

	CWispProgress::~CWispProgress()
	{
		//EMPTY
	}

	WISP_MSG_MAP_BEGIN(CWispProgress)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
	WISP_MSG_MAP_END(CWispBaseWnd)

	bool CWispProgress::OnUpdate(WISP_MSG *pMsg)
	{
		WISP_RECT rcItem;
		rcItem.y = 0;
		rcItem.x = 0;
		rcItem.cx = m_WindowRect.cx;
		rcItem.cy = m_WindowRect.cy;
		if ( (m_Style & 0x40) == 0 )
			m_pWispBase->m_pWispDrawObj->DrawCtrlClient(&m_WindowDC, &rcItem);

		int nPersent = 1000 * m_nPos / (m_nUpper - m_nLower);
		m_pWispBase->m_pWispDrawObj->DrawProgress(&m_WindowDC, &rcItem, m_Style, nPersent);
		return true;
	}

	bool CWispProgress::Create(unsigned int Style, const WISP_RECT & rect, CWispBaseWnd *pParentWnd, unsigned int nID)
	{
		return CWispBaseWnd::Create(0, rect, pParentWnd, nID, Style, 0);
	}
	
	int CWispProgress::GetPos()
	{
		return m_nPos;
	}
	void CWispProgress::SetPos(int nPos)
	{
		m_nPos = nPos;
		//Update((WISP_RECT*)0);
	}

	void CWispProgress::GetRange(int & nLower, int & nUpper)
	{
		nLower = m_nLower;
		nUpper = m_nUpper;
	}
	void CWispProgress::SetRange(int nLower, int nUpper)
	{
		m_nLower = nLower;
		m_nUpper = nUpper;
		Update((WISP_RECT*)0);
	}

	void CWispProgress::SetStep(int nStep)
	{
		m_nStep = nStep;
		//Update((WISP_RECT*)0);
	}

	void CWispProgress::StepIt()
	{
		m_nPos += m_nStep;
		//Update((WISP_RECT*)0);
	}

	void CWispProgress::OffsetPos(int nOffet)
	{
		m_nPos += nOffet;
		//Update((WISP_RECT*)0);
	}

```

`source/Wisp/wispprogress.hpp`:

```hpp

#ifndef _WISPPROGRESS_HPP_
#define _WISPPROGRESS_HPP_

#include "../Code/define.h"
#include "wispbasewnd.hpp"

struct CWispProgress : public CWispBaseWnd
{
	int m_nStep;
	int m_nPos;
	int m_nLower;
	int m_nUpper;

	CWispProgress();
	virtual ~CWispProgress();
	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnUpdate(WISP_MSG *pMsg);
	bool Create(unsigned int Style, const WISP_RECT & rect, CWispBaseWnd *pParentWnd, unsigned int nID);
	
	int GetPos();
	void SetPos(int nPos);
	void GetRange(int & nLower, int & nUpper);
	void SetRange(int nLower, int nUpper);
	void SetStep(int nStep);
	void StepIt();
	void OffsetPos(int nPos);
};

#endif
```

`source/Wisp/wispprogressform.cpp`:

```cpp

#include "wispprogressform.hpp"

WISP_FORM_RES_ITEM WispProgressForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 325, 60}, 0, 6, 0, 0, 0},
	{WISP_CTRL_STATIC_STRING, {10, 10, 300, 16}, 2, 0, 0, 0, 0},
	{WISP_CTRL_PROGRESS, {10, 30, 300, 16}, 1, 0, 0, 0, 0},
	{0},
};

	CWispProgressForm::CWispProgressForm()
	{
		m_pProgress = NULL;
		m_pStaticStr = NULL;
		m_Resource = WispProgressForm;
	}
	CWispProgressForm::~CWispProgressForm()
	{
	}

        WISP_MSG_MAP_BEGIN(CWispProgressForm)
                WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
        WISP_MSG_MAP_END(CWispForm)

	bool CWispProgressForm::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pProgress = (CWispProgress *)GetFormItem(1);
		m_pProgress->SetRange(0, 99);
		m_pProgress->m_nPos = 0;
		m_pStaticStr = (CWispStaticStr *)GetFormItem(2);
		return true;
	}

	void CWispProgressForm::SetText(const WCHAR *Text)
	{
		m_pStaticStr->SetWindowText(Text);
	}

```

`source/Wisp/wispprogressform.hpp`:

```hpp

#ifndef _WISPPROGRESSFORM_HPP_
#define _WISPPROGRESSFORM_HPP_

#include "../Code/define.h"
#include "wispform.hpp"
#include "wispprogress.hpp"
#include "wispstatic.hpp"

struct CWispProgressForm : public CWispForm
{
	CWispProgress *m_pProgress;
	CWispStaticStr *m_pStaticStr;

	CWispProgressForm();
	virtual ~CWispProgressForm();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);

	void SetText(const WCHAR *Text);
};

#endif
```

`source/Wisp/wispradiobox.cpp`:

```cpp

#include "wispradiobox.hpp"
#include "wispbase.hpp"
#include "wispform.hpp"

	CWispRadioBox::CWispRadioBox()
	{
		m_TextRect.cy = 0;
		m_TextRect.cx = 0;
		m_TextRect.y = 0;
		m_TextRect.x = 0;

		m_RadioBoxRect.cy = 0;
		m_RadioBoxRect.cx = 0;
		m_RadioBoxRect.y = 0;
		m_RadioBoxRect.x = 0;

		m_bIsMultiLine = false;
		m_bMouseDown = false;
		m_bMouseIn = false;
		m_CtrlType = WISP_CTRL_RADIO_BOX;
	}
	CWispRadioBox::~CWispRadioBox()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispRadioBox)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
	WISP_MSG_MAP_END(CWispBaseWnd)

	bool CWispRadioBox::OnUpdate(WISP_MSG *pMsg)
	{
		if (!(m_Style & 0x40))
			m_pWispBase->m_pWispDrawObj->DrawCtrlClient(&m_WindowDC, &m_WindowRect);

		if (!(m_Style & 0x40000000))
		{
			if (m_Style & 0x400) //(m_Style >> 10) & 1)
			{
				if (m_bMouseDown && m_bMouseIn)
					m_WindowDC.DrawSystemStandardIcon(&m_RadioBoxRect, 0x11, 0x21A221); //17 WISP_SSI_REDIOBOX_SELECTED_DRAK
				else	m_WindowDC.DrawSystemStandardIcon(&m_RadioBoxRect, 0x0F, 0x21A221); //15 WISP_SSI_REDIOBOX_SELECTED
			} else
			{
				if (m_bMouseDown && m_bMouseIn)
					m_WindowDC.DrawSystemStandardIcon(&m_RadioBoxRect, 0x12, 0x21A221); //18 WISP_SSI_REDIOBOX_UNSELECTED_DRAK
				else	m_WindowDC.DrawSystemStandardIcon(&m_RadioBoxRect, 0x10, 0x21A221); //16 WISP_SSI_REDIOBOX_UNSELECTED
			}
		}

		DrawCaption();
		return false;
	}
	bool CWispRadioBox::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			if (pMsg->KeyEvent.bKeyDown)
			{
				m_bMouseDown = true;
			} else
			if (OnMouseLUp(pMsg))
			{
				WISP_MSG Msg;
				Msg.Msg = WISP_WM_COMMAND;
				Msg.hWnd = (CWispWnd *)m_OwnerWnd;
				Msg.Command.CtrlType = m_CtrlType;
				Msg.Command.CmdMsg = 0x80000300; //WISP_ID_BOX_SELECT
				Msg.Command.CmdID = m_CmdID;
				Msg.Command.Param1 = !!(m_Style & 0x400); //(m_Style >> 10) & 1;
				if (m_pWispBase->SendMessage(&Msg))
				{
					Msg.hWnd = (CWispWnd *)m_OwnerWnd;
					Msg.Msg = WISP_WM_EVENT;
					m_pWispBase->PostMessage(&Msg);
				}
			}
			Update((WISP_RECT*)0);
		}
		return true;
	}
	bool CWispRadioBox::OnMouseLDown(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.bKeyDown)
		{
			m_bMouseDown = true;
			return true;
		}
		return false;
	}
	bool CWispRadioBox::OnMouseLUp(WISP_MSG *pMsg)
	{
		if (!m_bMouseIn || !m_bMouseDown)
			return false;
		if (!(m_Style & 0x400)) //!((m_Style >> 10) & 1))
		{
			Enable(1);
		}
		m_bMouseDown = false;
                return true;
	}
//	bool CWispRadioBox::OnGetFocus(WISP_MSG *pMsg) { m_bFocus = 1; return true; }
//	bool CWispRadioBox::OnLostFocus(WISP_MSG *pMsg) { m_bFocus = 0; return true; }
	bool CWispRadioBox::OnMouseLeave(WISP_MSG *pMsg)
	{
		m_bMouseIn = false;
		if (m_bMouseDown == false)
			return true;
		if (!pMsg->bMsgLBTDown)
			m_bMouseDown = false;
		return false;
	}
	bool CWispRadioBox::OnMouseMove(WISP_MSG *pMsg)
	{
		m_bMouseIn = true;
		return true;
	}
	bool CWispRadioBox::InitWnd()
	{
		if (!CWispBaseWnd::InitWnd())
			return false;
		m_Style &= ~0xBB;
		if (m_Style & 0x40000000)
			m_Style |= 6;
		m_Style |= 0x40;
		if (m_Style & 0x80000000)
			m_bIsMultiLine = true;
		if (m_Style & 0x40000000)
		{
			m_TextRect = m_WindowRect;
			m_RadioBoxRect = m_WindowRect;
			return true;
		}
		if (m_Style & 0x2000000)
		{
			m_RadioBoxRect.x = m_WindowRect.cx + m_WindowRect.x - 13;
			m_RadioBoxRect.y = m_WindowRect.y + (m_WindowRect.cy - 9) / 2;
			m_RadioBoxRect.cx = 13;
			m_RadioBoxRect.cy = 13;
			if (m_Style & 0x40000)
				m_RadioBoxRect.y = m_WindowRect.y;
			else
			if (m_Style & 0x80000)
				m_RadioBoxRect.y = m_WindowRect.y + m_WindowRect.cy - 9;

			m_TextRect.x = m_WindowRect.x;
			m_TextRect.y = m_WindowRect.y + (m_WindowRect.cy - 9) / 2;
			if (m_Style & 0x40000)
				m_TextRect.y = m_WindowRect.y;
			else
			if (m_Style & 0x80000)
				m_TextRect.y = m_WindowRect.y + m_WindowRect.cy - m_WindowDC.m_pFont->m_Height;
			m_TextRect.cx = (m_WindowRect.cx + m_WindowRect.x - 13) - m_WindowRect.x - 6;
		//
			if (m_Style & 0x80000000)
			{
				m_TextRect.cy = m_WindowRect.cy;
			} else
			{
				m_TextRect.cy = m_WindowDC.m_pFont->m_Height;
				if (m_WindowDC.m_pFont->m_Height > 13)
					m_RadioBoxRect.y += (m_WindowDC.m_pFont->m_Height - 9) / 2;
			}
		} else
		{
			m_RadioBoxRect.x = m_WindowRect.x;
			m_RadioBoxRect.y = m_WindowRect.y + (m_WindowRect.cy - 9) / 2;
			m_RadioBoxRect.cx = 13;
			m_RadioBoxRect.cy = 13;
			if (m_Style & 0x40000)
				m_RadioBoxRect.y = m_WindowRect.y;
			else
			if (m_Style & 0x80000)
				m_RadioBoxRect.y = m_WindowRect.y + m_WindowRect.cy - 9;

			m_TextRect.x = m_WindowRect.x + 19;
			m_TextRect.y = m_WindowRect.y + (m_WindowRect.cy - 9) / 2;
			if (m_Style & 0x40000)
				m_TextRect.y = m_WindowRect.y;
			else
			if (m_Style & 0x80000)
				m_TextRect.y = m_WindowRect.y + m_WindowRect.cy - m_WindowDC.m_pFont->m_Height;
		//
			if (m_Style & 0x80000000)
			{
				m_TextRect.cy = m_WindowRect.cy;
			} else
			{
				m_TextRect.cy = m_WindowDC.m_pFont->m_Height;
				if (m_WindowDC.m_pFont->m_Height > 13)
					m_RadioBoxRect.y += (m_WindowDC.m_pFont->m_Height - 9) / 2;
			}
		}
		return true;
	}
//	void CWispRadioBox::DrawFocusRect(WISP_MSG *pMsg)
//	void CWispRadioBox::DrawBorder()
//	void CWispRadioBox::DrawRadioBox(WISP_MSG *pMsg)
	void CWispRadioBox::DrawCaption()
	{
		WISP_RECT Rect = m_TextRect;
		unsigned int uFormat = 4;
		if (m_Style & 0x40000000)
		{
			uFormat = 5;
			if (m_bMouseDown && m_bMouseIn)
				++Rect.x;
		}
		if (!m_bIsMultiLine)
			uFormat |= 0x20;
		if (m_Style & 0x80000)
			uFormat |= 8;
		if ((m_Style >> 9) & 1)                          // 0x200
			m_WindowDC.SetTextColor(m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
		m_WindowDC.DrawString(m_WndText.operator const WCHAR*(), &Rect, uFormat, 0, -1);
		if ((m_Style >> 9) & 1)
			m_WindowDC.SetTextColor();
	}
//	int CWispRadioBox::SetState(int newState)
//	int CWispRadioBox::GetState()
	void CWispRadioBox::Enable(bool bEnable)
	{
		if (bEnable)
		{
			if (m_Style & 0x400)//(m_Style >> 10) & 1)
				return;
			m_Style |= 0x400;
			UpdateForm();
		} else
		{
			if (!(m_Style & 0x400))//!((m_Style >> 10) & 1))
				return;
			m_Style &= ~0x400;
		}
		Update((WISP_RECT*)0);
	}
	void CWispRadioBox::UpdateForm()
	{
		CWispForm *pWispForm = (CWispForm *)m_ParentWnd;
		if (pWispForm->m_CtrlType == WISP_CTRL_FORM)
		{
			unsigned int CmdID = m_CmdID;
			while (1)
			{
				//--CmdID;
				map<unsigned int, CWispBaseWnd*>::IT It = pWispForm->m_FormItemMap.find(CmdID-1);
				if (It == pWispForm->m_FormItemMap.end())
					break;
				if (It->second->m_CtrlType != WISP_CTRL_RADIO_BOX)
					break;
				if ((It->second->m_Style >> 10) & 1)
				{
					CWispRadioBox *pRadioBox = (CWispRadioBox *)It->second;
					pRadioBox->Enable(0);
				}
				CmdID = It->second->m_CmdID;
			}
			//unsigned int
			CmdID = m_CmdID;
			while (1)
			{
				//++CmdID;
				map<unsigned int, CWispBaseWnd*>::IT It = pWispForm->m_FormItemMap.find(CmdID+1);
				if (It == pWispForm->m_FormItemMap.end())
					break;
				if (It->second->m_CtrlType != WISP_CTRL_RADIO_BOX)
					break;
				if ((It->second->m_Style >> 10) & 1)
				{
					CWispRadioBox *pRadioBox = (CWispRadioBox *)It->second;
					pRadioBox->Enable(0);
				}
				CmdID = It->second->m_CmdID;
			}
		}
	}

```

`source/Wisp/wispradiobox.hpp`:

```hpp

#ifndef _WISPRADIOBOX_HPP_
#define _WISPRADIOBOX_HPP_

#include "../Code/define.h"
#include "wispbasewnd.hpp"

struct CWispRadioBox : public CWispBaseWnd
{
	CWispRect m_TextRect;
	CWispRect m_RadioBoxRect;
//	bool m_bIsThreeState;
//	int m_CurrentState;
//	unsigned int m_uStyle;
	bool m_bIsMultiLine;//???
	bool m_bFocus;//???
	bool m_bMouseDown;
	bool m_bMouseIn;
//	bool m_EnableState;

	CWispRadioBox();
	virtual ~CWispRadioBox();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnMouseLDown(WISP_MSG *pMsg);
	bool OnMouseLUp(WISP_MSG *pMsg);
//	bool OnGetFocus(WISP_MSG *pMsg) { m_bFocus = 1; return true; }
//	bool OnLostFocus(WISP_MSG *pMsg) { m_bFocus = 0; return true; }
	bool OnMouseLeave(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	virtual bool InitWnd() override;
//	void DrawFocusRect(WISP_MSG *pMsg);
//	void DrawBorder();
//	void DrawCheckBox(WISP_MSG *pMsg);
	void DrawCaption();
//	int SetState(int newState);
//	int GetState();
	void Enable(bool bEnable);
	void UpdateForm();
};

#endif

```

`source/Wisp/wisprgbselect.cpp`:

```cpp

#include "wisprgbselect.hpp"


#define ID_RGB 2
#define ID_RED 3
#define ID_GREEN 4
#define ID_BLUE 5

WISP_FORM_RES_ITEM WispRGBSelect[] =
{
	{ WISP_CTRL_FORM, {0, 0, 350, 210}, 0, 0x0B, WSTR("RGB"), 0, 0},
	{ WISP_CTRL_STATIC_GROUP, {5, 5, 250, 170}, ID_RGB, 0, WSTR("RGB"), 0, 0},
	{ WISP_CTRL_BUTTON, {270, 130, 60, 18}, WISP_ID_CANCEL, 0, WSTR("Cancel"), 0, 0},
	{ WISP_CTRL_BUTTON, {270, 155, 60, 18}, WISP_ID_OK, 0, WSTR("OK"), 0, 0},
	{ WISP_CTRL_STATIC_STRING, {270, 56, 30, 16}, 0, 0, WSTR("Red"), 0, 0},
	{ WISP_CTRL_EDIT, {305, 55, 25, 16}, ID_RED, 0x9000006, 0, 0, 0},
	{ WISP_CTRL_STATIC_STRING, {270, 76, 30, 16}, 0, 0, WSTR("Green"), 0, 0},
	{ WISP_CTRL_EDIT, {305, 75, 25, 16}, ID_GREEN, 0x9000006, 0, 0, 0},
	{ WISP_CTRL_STATIC_STRING, {270, 96, 30, 16}, 0, 0, WSTR("Blue"), 0, 0},
	{ WISP_CTRL_EDIT, {305, 95, 25, 16}, ID_BLUE, 0x9000006, 0, 0, 0},
	{ 0 },
};

	CWispRGBSelect::CWispRGBSelect()
	{
		m_Resource = WispRGBSelect;
		m_Color = 0;
	}

	CWispRGBSelect::~CWispRGBSelect()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispRGBSelect)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP_ON_COMMAND
	WISP_MSG_MAP_END(CWispForm)

	bool CWispRGBSelect::OnDestroy(WISP_MSG *pMsg)
	{
		m_GammaDIB.Destroy();
		m_ScaleDIB.Destroy();
		return true;
	}
	bool CWispRGBSelect::OnUpdateClient(WISP_MSG *pMsg)
	{
		if (!CWispWnd::OnUpdateClient(pMsg))
			return false;

		m_ClientDC.DrawDIB(&m_GammaRC, &m_GammaDIB);
		m_ClientDC.DrawFrameRect(&m_GammaFrameRC, 0, 1);
		
		m_ClientDC.DrawDIB(&m_ScaleRC, &m_ScaleDIB);
		m_ClientDC.DrawFrameRect(&m_ScaleFrameRC, 0, 1);

		m_ClientDC.DrawHLine(m_GammaPoint.x - 5, m_GammaPoint.x - 2, m_GammaPoint.y, 0);
		m_ClientDC.DrawHLine(m_GammaPoint.x + 2, m_GammaPoint.x + 5, m_GammaPoint.y, 0);
		m_ClientDC.DrawVLine(m_GammaPoint.x, m_GammaPoint.y - 5, m_GammaPoint.y - 2, 0);
		m_ClientDC.DrawVLine(m_GammaPoint.x, m_GammaPoint.y + 2, m_GammaPoint.y + 5, 0);

		m_ClientDC.DrawHLine(m_ScaleRC.x2(), m_ScaleRC.x2() + 5, m_nScale, 0);
		m_ClientDC.DrawLine(m_ScaleRC.x2(), m_nScale, m_ScaleRC.x2() + 3, m_nScale - 3, 0);
		m_ClientDC.DrawLine(m_ScaleRC.x2(), m_nScale, m_ScaleRC.x2() + 3, m_nScale + 3, 0);

		m_ClientDC.DrawFullRect(&m_ResultRC, m_Color);
		m_ClientDC.DrawFrameRect(&m_ResultRC, 1, 1);
		return false;
	}
	bool CWispRGBSelect::OnMouseMove(WISP_MSG *pMsg)
	{
		if (pMsg->bMsgLBTDown)
		{
			if (PtInRect(&m_GammaRC, &pMsg->m_LogicMousePosWnd))
			{
				m_GammaPoint = pMsg->m_LogicMousePosWnd;
				ReDrawGamma(true);
				Update(&m_ClientRect);
				return true;
			}

			if (PtInRect(&m_ScaleFullRC, &pMsg->m_LogicMousePosWnd))
			{
				m_nScale = pMsg->m_LogicMousePosWnd.y;
				MIN_LIMIT(m_nScale, m_ScaleRC.y);
				MAX_LIMIT(m_nScale, m_ScaleRC.y2() - 1);
				DrawScale();
				Update(&m_ClientRect);
				return true;
			}
		}
		return true;
	}
	bool CWispRGBSelect::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.bKeyDown && pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			if (PtInRect(&m_GammaRC, &pMsg->m_LogicMousePosWnd))
			{
				m_GammaPoint = pMsg->m_LogicMousePosWnd;
				ReDrawGamma(true);
				Update(&m_ClientRect);
				return true;
			}

			if (PtInRect(&m_ScaleFullRC, &pMsg->m_LogicMousePosWnd))
			{
				m_nScale = pMsg->m_LogicMousePosWnd.y;
				DrawScale();
				Update(&m_ClientRect);
				return true;
			}
		}
		return true;
	}
	bool CWispRGBSelect::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pStaticGroup = (CWispStaticGroup*)GetFormItem(ID_RGB);
		m_pRedEdit = (CWispEdit*)GetFormItem(ID_RED);
		m_pGreenEdit = (CWispEdit*)GetFormItem(ID_GREEN);
		m_pBlueEdit = (CWispEdit*)GetFormItem(ID_BLUE);

		m_GammaDIB.Create(m_pStaticGroup->m_WindowRect.cx - 55, m_pStaticGroup->m_WindowRect.cy - 25, 1, 0, 0);
		m_ScaleDIB.Create(20, m_GammaDIB.m_PaintRect.cy, 1, 0, 0);
		DrawGamma(&m_GammaDIB);

		int GammaCX = m_GammaDIB.m_PaintRect.cx;
		int GammaCY = m_GammaDIB.m_PaintRect.cy;

		int ScaleCY = m_ScaleDIB.m_PaintRect.cy;
		int ScaleCX = m_ScaleDIB.m_PaintRect.cx;

		m_GammaRC.x = m_pStaticGroup->m_WindowRect.x + 15;
		m_GammaRC.y = m_pStaticGroup->m_WindowRect.y + 20;

		m_GammaFrameRC.x = m_GammaRC.x - 1;
		m_GammaFrameRC.y = m_GammaRC.y - 1;
		m_GammaFrameRC.cx = GammaCX + 2;
		m_GammaFrameRC.cy = GammaCY + 2;

		m_ScaleRC.x = m_GammaRC.x + GammaCX + 10;
		m_ScaleRC.y = m_GammaRC.y;
		m_ScaleRC.cx = ScaleCX;
		m_ScaleRC.cy = ScaleCY;

		m_ScaleFullRC.x = m_ScaleRC.x;
		m_ScaleFullRC.y = m_GammaRC.y;
		m_ScaleFullRC.cx = m_ScaleRC.cx + 5;
		m_ScaleFullRC.cy = ScaleCY;

		m_GammaRC.cx = GammaCX;
		m_GammaRC.cy = GammaCY;

		m_ScaleFrameRC.x = m_GammaRC.x + GammaCX + 9;
		m_ScaleFrameRC.y = m_GammaRC.y - 1;
		m_ScaleFrameRC.cx = ScaleCX + 2;
		m_ScaleFrameRC.cy = ScaleCY + 2;

		m_GammaPoint.x = m_GammaRC.x + GammaCX/2;
		m_GammaPoint.y = m_GammaRC.y + GammaCY/2;

		m_ScaleFullRC.y -= 5;
		m_ScaleFullRC.cy += 10;

		m_ResultRC.x = 270;
		m_ResultRC.y = 10;
		m_ResultRC.cx = 60;
		m_ResultRC.cy = 40;

		m_nScale = m_GammaRC.y + ScaleCY/2;
		
		ReDrawGamma(false);
		ShowColorValue();
		return true;
	}
#if 0
	WISP_CMD_MAP_BEGIN(CWispRGBSelect)
		WISP_CMD_MAP(WISP_ID_..., OnCmd...)
	WISP_CMD_MAP_END
#else	
	bool CWispRGBSelect::OnCommand(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdID && pMsg->Command.CmdMsg == 0x80000704)
			ReadColorValue();
		return true;
	}
#endif
	void CWispRGBSelect::ReadColorValue()
	{
		COLOR R,G,B;
		if (!USDecStrToNum(m_pRedEdit->m_WndText.operator const WCHAR*(), &R) || R>255)
			return;
		if (!USDecStrToNum(m_pGreenEdit->m_WndText.operator const WCHAR*(), &G) || G>255)
			return;
		if (!USDecStrToNum(m_pBlueEdit->m_WndText.operator const WCHAR*(), &B) || B>255)
			return;
		m_Color = RGBColor(R,G,B);
		Update((WISP_RECT*)0);
	}

	void CWispRGBSelect::ShowColorValue()
	{
		TWideString String;

		String.Format(WSTR("%d"), GetRColor(m_Color));
		m_pRedEdit->SetWindowText(String.operator const WCHAR*());

		String.Format(WSTR("%d"), GetGColor(m_Color));
		m_pGreenEdit->SetWindowText(String.operator const WCHAR*());

		String.Format(WSTR("%d"), GetBColor(m_Color));
		m_pBlueEdit->SetWindowText(String.operator const WCHAR*());
	}

	void CWispRGBSelect::DrawScale()
	{
		m_ScaleDIB.GetPixel(0, m_nScale - m_ScaleRC.y, &m_Color);
		ShowColorValue();
	}

	void //CWispRGBSelect::
	RGB2HSL(unsigned long Color, double &H, double &S, double &L)
	{
		double R = (double)GetRColor(Color)/255.;
		double G = (double)GetGColor(Color)/255.;
		double B = (double)GetBColor(Color)/255.;

		double var_Min = MIN(MIN(R, G), B);
		double var_Max = MAX(MAX(R, G), B);
		double del_Max = var_Max - var_Min;

		L = (var_Max + var_Min)/2;

		if (del_Max == 0)
		{
			H = 0;
			S = 0;
		} else
		{
			if (L < 0.5) S = del_Max/(var_Max + var_Min);
			else         S = del_Max/(2 - var_Max - var_Min);

			double del_R = ((var_Max-R)/6 + del_Max/2)/del_Max;
			double del_G = ((var_Max-G)/6 + del_Max/2)/del_Max;
			double del_B = ((var_Max-B)/6 + del_Max/2)/del_Max;

			if      (R == var_Max) H = del_B - del_G;
			else if (G == var_Max) H = (1./3.) + del_R - del_B;
			else if (B == var_Max) H = (2./3.) + del_G - del_R;

			if (H < 0) H += 1;
			if (H > 1) H -= 1;
		}
	}

	long double //CWispRGBSelect::
	Hue2RGB(double v1, double v2, double vH)
	{
		if (vH < 0.) vH += 1.;
		if (vH > 1.) vH -= 1.;
		if (vH*6. < 1.) return v1+ (v2-v1)*6.*vH;
		if (vH*2. < 1.) return v2;
		if (vH*3. < 2.) return v1+ (v2-v1)*(2./3. - vH)*6.;
		return v1;	
	}

#ifdef _RING0_
#if 0
unsigned int DoubleToU32(double x)
{
    return (unsigned int)_mm_cvtsd_si32(_mm_set_sd(x));
}

//If you need to cover whole [0..2^32) range for unsigned int conversion, you can add a bit more code to get it to work. In pseudocode:
unsigned int DoubleToU32(double x)
{
    if (x >= double(2^31))
    {
        return 2^31 + _mm_cvtsd_si32(x - double(2^31));
    }
    return _mm_cvtsd_si32(x);
}
#endif
	unsigned long double2uint(double v)
	{
		//TODO
		return 0;
	}
#else
	//unsigned int _dtoui3(double x) { ... }

	unsigned long double2uint(double v)
	{
		return v;
	}
#endif

	unsigned long //CWispRGBSelect::
	HLS2RGB(double H, double L, double S)
	{
		double R,G,B;

		if (S == 0)
		{
			R = L;
			G = L;
			B = L;
		} else
		{
			double var2;
			if (L <= 0.5)
				var2 = (S+1.)*L;
			else	var2 = L+S-S*L;
			double var1 = L*2 - var2;
			R = Hue2RGB(var1, var2, H+1./3);
			G = Hue2RGB(var1, var2, H);
			B = Hue2RGB(var1, var2, H-1./3);
		}

		return RGBColor(double2uint(R*255),double2uint(G*255),double2uint(B*255));
	}

	void CWispRGBSelect::ReDrawGamma(bool bGetPixel)
	{
		CWispDC WispDC;
		if (bGetPixel)
			m_GammaDIB.GetPixel(m_GammaPoint.x - m_GammaRC.x, m_GammaPoint.y - m_GammaRC.y, &m_Color);

		double H,S,L;
		RGB2HSL(m_Color, H, S, L);
		WispDC.Create(&m_ScaleDIB);
		WispDC.DrawHLine(0, m_ScaleRC.cx - 1, 0, 0xFFFFFF);
		for (int y = 1; y < m_ScaleRC.cy - 1; ++y)
		{
			unsigned long Color = HLS2RGB(H, (double)(m_ScaleRC.cy-y)/(double)m_ScaleRC.cy, S);
			WispDC.DrawHLine(0, m_ScaleRC.cx - 1, y, Color);
		}
		WispDC.DrawHLine(0, m_ScaleRC.cx - 1, m_ScaleRC.cy - 1, 0);
		ShowColorValue();
	}

	void CWispRGBSelect::DrawGamma(CWispDIB *pDIB)
	{
		CWispDC DrawDC;
		DrawDC.Create(pDIB);
		for (int PosY = 0; PosY < pDIB->m_PaintRect.cy; ++PosY)
		{
			for (int PosX = 0; PosX < pDIB->m_PaintRect.cx; ++PosX)
			{
				unsigned long Color = HLS2RGB((double)PosX/(double)pDIB->m_PaintRect.cx, 1./2., (double)PosY/(double)pDIB->m_PaintRect.cy);
				DrawDC.DrawPixel(PosX, pDIB->m_PaintRect.cy-PosY-1, Color);
			}
		}
	}

	bool CWispRGBSelect::StaticCreate(unsigned long *pRetColor, unsigned long *pColor)
	{
		CWispRGBSelect RGBSelect;
		if (pColor)
			RGBSelect.m_Color = *pColor;
		RGBSelect.Create(0, WISP_SH_MODAL_BLOCK);
		if (RGBSelect.m_Result == WISP_ID_OK)
		{
			*pRetColor = RGBSelect.m_Color;
			return true;
		}
		return false;
	}
```

`source/Wisp/wisprgbselect.hpp`:

```hpp

#ifndef _WISPRGBSELECT_HPP_
#define _WISPRGBSELECT_HPP_

#include "../Code/define.h"
#include "wispform.hpp"
#include "wispdib.hpp"
#include "wispedit.hpp"
#include "wispstatic.hpp"

struct CWispRGBSelect : public CWispForm
{
	WISP_RECT m_GammaFrameRC;
	WISP_RECT m_GammaRC;
	WISP_RECT m_ScaleFrameRC;
	WISP_RECT m_ScaleRC;
	WISP_RECT m_ScaleFullRC;
	WISP_RECT m_ResultRC;
	WISP_POINT m_GammaPoint;
	int m_nScale;
	CWispDIB m_GammaDIB;
	CWispDIB m_ScaleDIB;
	CWispStaticGroup *m_pStaticGroup;
	CWispEdit *m_pRedEdit;
	CWispEdit *m_pGreenEdit;
	CWispEdit *m_pBlueEdit;
	unsigned long m_Color;

	CWispRGBSelect();
	virtual ~CWispRGBSelect();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnCreateForm(WISP_MSG *pMsg);

	bool OnCommand(WISP_MSG *pMsg);

	void ReadColorValue();
	void ShowColorValue();
	void DrawScale();

	//void RGB2HSL(unsigned long Color, double &H, double &S, double &L);
	//long double Hue2RGB(double v1, double v2, double vH);
	//unsigned long HLS2RGB(double H, double L, double S);

	void ReDrawGamma(bool bGetPixel);
	void DrawGamma(CWispDIB *pDIB);

	static bool StaticCreate(unsigned long *pRetColor, unsigned long *pColor);
};

#endif

```

`source/Wisp/wispsoftkeyboard.cpp`:

```cpp

#include "wispsoftkeyboard.hpp"
#include "wispbase.hpp"
#include "wispcheckbox.hpp"

	WISP_SKB_KEY CWispSoftKeyboard::m_SoftKeyTable[] = {
			{ WSTR("ESC"), 0x1B, {2, 2, 22, 20}},
			{ WSTR("F1"), 0x70, {46, 2, 22, 20}},
			{ WSTR("F2"), 0x71, {70, 2, 22, 20}},
			{ WSTR("F3"), 0x72, {94, 2, 22, 20}},
			{ WSTR("F4"), 0x73, {118, 2, 22, 20}},
			{ WSTR("F5"), 0x74, {158, 2, 22, 20}},
			{ WSTR("F6"), 0x75, {182, 2, 22, 20}},
			{ WSTR("F7"), 0x76, {206, 2, 22, 20}},
			{ WSTR("F8"), 0x77, {230, 2, 22, 20}},
			{ WSTR("F9"), 0x78, {266, 2, 22, 20}},
			{ WSTR("F10"), 0x79, {290, 2, 22, 20}},
			{ WSTR("F11"), 0x7A, {314, 2, 22, 20}},
			{ WSTR("F12"), 0x7B, {338, 2, 22, 20}},
			{ WSTR("`"), 0xC0, {2, 28, 22, 20}},
			{ WSTR("1"), 0x31, {26, 28, 22, 20}},
			{ WSTR("2"), 0x32, {50, 28, 22, 20}},
			{ WSTR("3"), 0x33, {74, 28, 22, 20}},
			{ WSTR("4"), 0x34, {98, 28, 22, 20}},
			{ WSTR("5"), 0x35, {122, 28, 22, 20}},
			{ WSTR("6"), 0x36, {146, 28, 22, 20}},
			{ WSTR("7"), 0x37, {170, 28, 22, 20}},
			{ WSTR("8"), 0x38, {194, 28, 22, 20}},
			{ WSTR("9"), 0x39, {218, 28, 22, 20}},
			{ WSTR("0"), 0x30, {242, 28, 22, 20}},
			{ WSTR("-"), 0x6D, {266, 28, 22, 20}},
			{ WSTR("="), 0xBB, {290, 28, 22, 20}},
			{ WSTR("\\"), 0x6C, {314, 28, 22, 20}},
			{ WSTR("<-"), 8, {338, 28, 22, 20}},
			{ WSTR("TAB"), 9, {2, 50, 32, 20}},
			{ WSTR("Q"), 0x51, {36, 50, 22, 20}},
			{ WSTR("W"), 0x57, {60, 50, 22, 20}},
			{ WSTR("E"), 0x45, {84, 50, 22, 20}},
			{ WSTR("R"), 0x52, {108, 50, 22, 20}},
			{ WSTR("T"), 0x54, {132, 50, 22, 20}},
			{ WSTR("Y"), 0x59, {156, 50, 22, 20}},
			{ WSTR("U"), 0x55, {180, 50, 22, 20}},
			{ WSTR("I"), 0x49, {204, 50, 22, 20}},
			{ WSTR("O"), 0x4F, {228, 50, 22, 20}},
			{ WSTR("P"), 0x50, {252, 50, 22, 20}},
			{ WSTR("["), 0xDB, {276, 50, 22, 20}},
			{ WSTR("]"), 0xDD, {300, 50, 22, 20}},
			{ WSTR("Caps"), 0, {2, 72, 40, 20}},
			{ WSTR("A"), 0x41, {44, 72, 22, 20}},
			{ WSTR("S"), 0x53, {68, 72, 22, 20}},
			{ WSTR("D"), 0x44, {92, 72, 22, 20}},
			{ WSTR("F"), 0x46, {116, 72, 22, 20}},
			{ WSTR("G"), 0x47, {140, 72, 22, 20}},
			{ WSTR("H"), 0x48, {164, 72, 22, 20}},
			{ WSTR("J"), 0x4A, {188, 72, 22, 20}},
			{ WSTR("K"), 0x4B, {212, 72, 22, 20}},
			{ WSTR("L"), 0x4C, {236, 72, 22, 20}},
			{ WSTR(";"), 0xBA, {260, 72, 22, 20}},
			{ WSTR("'"), 0xDE, {284, 72, 22, 20}},
			{ WSTR("Enter"), 0x0D, {308, 72, 52, 20}},
			{ WSTR("Shift"), 0xA0, {2, 94, 50, 20}},
			{ WSTR("Z"), 0x5A, {54, 94, 22, 20}},
			{ WSTR("X"), 0x58, {78, 94, 22, 20}},
			{ WSTR("C"), 0x43, {102, 94, 22, 20}},
			{ WSTR("V"), 0x56, {126, 94, 22, 20}},
			{ WSTR("B"), 0x42, {150, 94, 22, 20}},
			{ WSTR("N"), 0x4E, {174, 94, 22, 20}},
			{ WSTR("M"), 0x4D, {198, 94, 22, 20}},
			{ WSTR(","), 0xBC, {222, 94, 22, 20}},
			{ WSTR("."), 0xBE, {246, 94, 22, 20}},
			{ WSTR("/"), 0x6F, {270, 94, 22, 20}},
			{ WSTR("Shift"), 0xA1, {294, 94, 66, 20}},
			{ WSTR("Ctrl"), 0xA2, {2, 116, 32, 20}},
			{ WSTR("Win"), 0x5B, {36, 116, 32, 20}},
			{ WSTR("Alt"), 0xA4, {70, 116, 32, 20}},
			{ WSTR("Space"), 0x20, {104, 116, 120, 20}},
			{ WSTR("Alt"), 0xA5, {226, 116, 32, 20}},
			{ WSTR("Win"), 0x5C, {260, 116, 32, 20}},
			{ WSTR("Apps"), 0x5D, {294, 116, 32, 20}},
			{ WSTR("Ctrl"), 0xA3, {328, 116, 32, 20}},
			{ WSTR("Ins"), 0x2D, {366, 50, 24, 20}},
			{ WSTR("Hom"), 0x24, {392, 50, 24, 20}},
			{ WSTR("PUp"), 0x21, {418, 50, 24, 20}},
			{ WSTR("Del"), 0x2E, {366, 72, 24, 20}},
			{ WSTR("End"), 0x23, {392, 72, 24, 20}},
			{ WSTR("PDo"), 0x22, {418, 72, 24, 20}},
			{ WSTR("Up"), 0x25, {392, 94, 24, 20}},
			{ WSTR("Le"), 0x25, {366, 116, 24, 20}},
			{ WSTR("Do"), 0x28, {392, 116, 24, 20}},
			{ WSTR("Ri"), 0x27, {418, 116, 24, 20}},
		};

	CWispSoftKeyboard::CWispSoftKeyboard()
	{
	}
	CWispSoftKeyboard::~CWispSoftKeyboard()
	{
	}

	bool CWispSoftKeyboard::CreateEx(int x, int y, CWispWnd *pParentWnd, unsigned int Style, unsigned int ShowMode, unsigned int CmdID)
	{
		WISP_RECT rc;
		rc.x = x;
		rc.y = y;
		rc.cx = 453;
		rc.cy = 166;
		return CreateWnd(WSTR("Soft Keyboard"), rc, pParentWnd, CmdID, Style, ShowMode);
	}

	WISP_MSG_MAP_BEGIN(CWispSoftKeyboard)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
	WISP_MSG_MAP_END(CWispWnd)

	bool CWispSoftKeyboard::OnCreate(WISP_MSG *pMsg)
	{
		#define BTN_COUNT lenof(m_SoftKeyTable)

		LoadTitleDIB("\\WispApp\\SoftKeyboard\\SoftKeyboard.ico", 0);

		CWispDIB *pDIB = gpCurWisp->m_DIBLib.GetDIB("\\WispApp\\SoftKeyboard\\SoftKeyboard.ico", 0);
		m_StaticDIB.CreateEx(pDIB, 387, 8, this, WISP_ID_STATIC_DIB);
		m_BTAry = new CWispBaseWnd*[BTN_COUNT];
		
		for (int n = 0; n < BTN_COUNT; ++n)
		{
			if (m_SoftKeyTable[n].VKCmdID == 0xA1 || //Shift
			    m_SoftKeyTable[n].VKCmdID == 0xA0) //Shift
			{
				CWispCheckBox *pButton = new CWispCheckBox;
				pButton->Create(m_SoftKeyTable[n].szKeyName, m_SoftKeyTable[n].BTRect, this, m_SoftKeyTable[n].VKCmdID, 0x40000000, 1);
				m_BTAry[n] = (CWispBaseWnd*)pButton;
			} else

			{
				CWispButton *pButton = new CWispButton;
				pButton->Create(m_SoftKeyTable[n].szKeyName, m_SoftKeyTable[n].BTRect, this, m_SoftKeyTable[n].VKCmdID, 0, 1);
				m_BTAry[n] = (CWispBaseWnd*)pButton;
			}
		}
		return true;
	}
	bool CWispSoftKeyboard::OnDestroy(WISP_MSG *pMsg)
	{
		for (int n = 0; n < BTN_COUNT; ++n)
		{
			m_BTAry[n]->Destroy();
			delete m_BTAry[n];
		}
		delete []m_BTAry;
		return true;
	}
	bool CWispSoftKeyboard::OnKeyEvent(WISP_MSG *pMsg)
	{
		//
		return true;
	}
	bool CWispSoftKeyboard::OnGetFocus(WISP_MSG *pMsg)
	{
		Top(true);
		return false;
	}
	bool CWispSoftKeyboard::OnCommand(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000201) //WISP_ID_CHILD_GET_FOCUS
			return false;

		if (pMsg->Command.CmdID < 256)
			m_pWispBase->OnKeyEvent(pMsg->Command.CmdID, pMsg->Command.CmdMsg == 0x80000001, 0); //WISP_ID_KEYDOWN

		return true;
	}
	void CWispSoftKeyboard::Create()
	{
		if (IsWindow())
		{
			Show(WISP_SH_MINSIZE);
		} else
		{
			CreateEx(0,0, 0, 0x2B, WISP_SH_MINSIZE, WISP_ID_SOFT_KB); //0x3B
			Center(0);
		}
	}

```

`source/Wisp/wispsoftkeyboard.hpp`:

```hpp

#ifndef _WISPSOFTKEYBOARD_HPP_
#define _WISPSOFTKEYBOARD_HPP_

#include "../Code/define.h"
#include "wispwnd.hpp"
#include "wispbutton.hpp"
#include "wispstatic.hpp"

struct WISP_SKB_KEY
{
	const WCHAR *szKeyName;
	unsigned int VKCmdID;
	WISP_RECT BTRect;
};

struct CWispSoftKeyboard : public CWispWnd
{
	CWispSoftKeyboard();
	virtual ~CWispSoftKeyboard();

	static WISP_SKB_KEY m_SoftKeyTable[];
	CWispBaseWnd **m_BTAry;
	CWispStaticDIB m_StaticDIB;

	bool CreateEx(int x, int y, CWispWnd *pParentWnd, unsigned int Style, unsigned int ShowMode, unsigned int CmdID);
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnGetFocus(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	void Create();
};

#endif
```

`source/Wisp/wispsplitwnd.cpp`:

```cpp

#include "wispsplitwnd.hpp"
#include "wispbase.hpp"
#include "utility.hpp"

	CWispSplitWnd::CWispSplitWnd()
	{
		m_SplitBorderSize = 4;
		m_CtrlType = WISP_CTRL_SPLIT_WND;
	}
	CWispSplitWnd::~CWispSplitWnd()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispSplitWnd)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP(WISP_WM_RESIZE_CHILD, OnResizeChild)
	WISP_MSG_MAP_END(CWispWnd)

	bool CWispSplitWnd::OnDestroy(WISP_MSG *pMsg)
	{
		m_WndList.Clear();
		return true;
	}
	bool CWispSplitWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_Size.cx = m_ParentWnd->m_WindowRect.cx - m_WindowRect.cx;
		m_Size.cy = m_ParentWnd->m_WindowRect.cy - m_WindowRect.cy;
		return true;
	}
	bool CWispSplitWnd::OnUpdate(WISP_MSG *pMsg)
	{
		TListIter<WISP_SPLIT_WND> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			m_pWispBase->m_pWispDrawObj->DrawSplitRect(&m_WindowDC, &It->SplitRect, (m_Style & 0x20000)?1:0);
			++It;
		}
		return true;
	}
	bool CWispSplitWnd::OnUpdateClient(WISP_MSG *pMsg)
	{
		return false;
	}
	bool CWispSplitWnd::OnMouseMove(WISP_MSG *pMsg)
	{
		WISP_POINT MouseCltPT = pMsg->MsgMouseWndPT;
		PointToRect(&MouseCltPT, &m_ClientRect);
		int Delta = (m_Style & 0x20000) ? pMsg->MouseEvent.DeltaX : pMsg->MouseEvent.DeltaY;
		if (m_CurSplitWndIt)
		{
			bool bMove = false;
			if (m_Style & 0x20000)
			{
				int x = m_CurSplitWndIt->SplitRect.x + m_CurSplitWndIt->SplitRect.cx/2;
				if (Delta>=0)
					bMove = (pMsg->MsgMouseWndPT.x<x);
				else	bMove = (pMsg->MsgMouseWndPT.x>=x);
			} else
			{
				int y = m_CurSplitWndIt->SplitRect.y + m_CurSplitWndIt->SplitRect.cy/2;
				if (Delta>=0)
					bMove = (pMsg->MsgMouseWndPT.y<y);
				else	bMove = (pMsg->MsgMouseWndPT.y>=y);
			}
			if (bMove) return true;
			m_NextSplitWndIt = m_CurSplitWndIt+1;
			if (m_NextSplitWndIt != m_WndList.End() &&
				m_CurSplitWndIt->SizeXorY  + Delta > 0 &&
				m_NextSplitWndIt->SizeXorY - Delta > 0)
			{
				m_CurSplitWndIt->SizeXorY += Delta;
				if (m_NextSplitWndIt != m_WndList.End())
					m_NextSplitWndIt->SizeXorY -= Delta;
				AdjustWndPos();
			}
		} else
		{
			TListIter<WISP_SPLIT_WND> It = m_WndList.Begin();
			while (It != m_WndList.End())
			{
				if (PtInRect(&It->SplitRect, &pMsg->MsgMouseWndPT))
					m_pWispBase->ChangeCursor((m_Style & 0x20000) ? WISP_CT_RESIZE_HORZ:WISP_CT_RESIZE_VERT);
				++It;
			}			
		}
		return true;
	}
	bool CWispSplitWnd::OnMouseLeave(WISP_MSG *pMsg)
	{
		int Delta = (m_Style & 0x20000) ? pMsg->MouseEvent.DeltaX : pMsg->MouseEvent.DeltaY;
		if (m_CurSplitWndIt)
		{
			bool bMove = false;
			if (m_Style & 0x20000)
			{
				int x = m_CurSplitWndIt->SplitRect.x + m_CurSplitWndIt->SplitRect.cx;
				if (Delta>=0)
					bMove = (pMsg->MsgMouseWndPT.x<m_CurSplitWndIt->SplitRect.x);
				else	bMove = (pMsg->MsgMouseWndPT.x>=x);
			} else
			{
				int y = m_CurSplitWndIt->SplitRect.y + m_CurSplitWndIt->SplitRect.cy;
				if (Delta>=0)
					bMove = (pMsg->MsgMouseWndPT.y<m_CurSplitWndIt->SplitRect.y);
				else	bMove = (pMsg->MsgMouseWndPT.y>=y);
			}
			if (bMove) return false;
			m_NextSplitWndIt = m_CurSplitWndIt+1;
			if (m_NextSplitWndIt != m_WndList.End() &&
				m_CurSplitWndIt->SizeXorY  + Delta > 0 &&
				m_NextSplitWndIt->SizeXorY - Delta > 0)
			{
				m_CurSplitWndIt->SizeXorY += Delta;
				if (m_NextSplitWndIt != m_WndList.End())
					m_NextSplitWndIt->SizeXorY -= Delta;
				AdjustWndPos();
			}
			return false;
		}

		m_pWispBase->ChangeCursor(WISP_CT_ARROW);
		return true;
	}
	bool CWispSplitWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType != VK_LBUTTON)
			return true;

		if (!pMsg->KeyEvent.bKeyDown)
		{
			m_CurSplitWndIt.Reset();// = 0;
			return true;
		}

		WISP_POINT MouseCltPT = pMsg->MsgMouseWndPT;
		PointToRect(&MouseCltPT, &m_ClientRect);
		TListIter<WISP_SPLIT_WND> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			if (PtInRect(&It->SplitRect, &pMsg->MsgMouseWndPT))
			{
				m_CurSplitWndIt = It;
				break;
			}
			++It;
		}
		return true;
	}
	bool CWispSplitWnd::OnSize(WISP_MSG *pMsg)
	{
		if (m_Style & 0x40000)
		{
			m_Size.cx = m_ParentWnd->m_WindowRect.cx - m_WindowRect.cx;
			m_Size.cy = m_ParentWnd->m_WindowRect.cy - m_WindowRect.cy;
		}
		AdjustWndPos();
		return true;
	}
	bool CWispSplitWnd::OnMouseDblClick(WISP_MSG *pMsg)
	{
		WISP_POINT MouseCltPT = pMsg->MsgMouseWndPT;
		PointToRect(&MouseCltPT, &m_ClientRect);
		int Index = 0;
		TListIter<WISP_SPLIT_WND> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			if (PtInRect(&It->SplitRect, &pMsg->MsgMouseWndPT))
			{
				if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
					SendCommand(0x80000118, Index, &*It); //WISP_ID_LBUTTON_DBLCLICK
				else
				if (pMsg->KeyEvent.KeyType == VK_RBUTTON)
					SendCommand(0x80000117, Index, &*It); //WISP_ID_RBUTTON_DBLCLICK
				break;
			}
			++It;
			++Index;
		}
		return true;
	}
	bool CWispSplitWnd::OnResizeChild(WISP_MSG *pMsg)
	{
		if (m_Style & 0x40000)
			Resize(pMsg->Sizing.Size.cx - m_Size.cx, pMsg->Sizing.Size.cy - m_Size.cy, true);
		return true;
	}
	bool CWispSplitWnd::InsertWnd(CWispWnd *pWnd, unsigned int Style, int SizeXorY, int InsertPos)
	{	
		if (InsertPos > m_WndList.Size())
			return false;
		WISP_SPLIT_WND WSWnd;
		WSWnd.pWnd = pWnd;
		WSWnd.Style = Style;
		WSWnd.SizeXorY = SizeXorY;
		if (InsertPos >= 0)
		{
			TListIter<WISP_SPLIT_WND> It;
			if (m_WndList.Size() > 0)
				It = m_WndList[InsertPos];
			m_WndList.InsertBefore(It, &WSWnd);
		} else
		{
			m_WndList.Append(&WSWnd);
		}
		return true;
	}
	bool CWispSplitWnd::RemoveWnd(CWispWnd *pWnd)
	{
		TListIter<WISP_SPLIT_WND> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			if (It->pWnd == pWnd)
			{
				m_WndList.Remove(It);
				return true;
			}
			++It;
		}
		return false;
	}
	void CWispSplitWnd::AdjustWnd(int Pos)
	{
		int SizeXorY = (m_Style & 0x20000) ? m_ClientRect.cx : m_ClientRect.cy;
		int Index = 0;
		TListIter<WISP_SPLIT_WND> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			if (Index == Pos)
				It->SizeXorY = SizeXorY - (m_SplitBorderSize + 1) * (m_WndList.Size() - 1);
			else	It->SizeXorY = 1;
			++Index;
			++It;
		}
		AdjustWndPos();
	}
	void CWispSplitWnd::AdjustWndPos()
	{
		int SizeXorY = 0;
		int Index = 0;
		TListIter<WISP_SPLIT_WND> It = m_WndList.Begin();
		while (Index < m_WndList.Size() && It != m_WndList.End())
		{
			if (m_Style & 0x20000)
			{
				if (Index == m_WndList.Size()-1)
					It->SizeXorY = m_ClientRect.cx - SizeXorY;
				It->pWnd->MoveToClient(SizeXorY, 0, true);
				It->pWnd->Resize(It->SizeXorY, m_ClientRect.cy, true);
				It->SplitRect.y = m_ClientRect.y;
				It->SplitRect.cy = m_ClientRect.cy;
				It->SplitRect.x = SizeXorY + m_ClientRect.x + It->pWnd->m_WindowRect.cx;
				It->SplitRect.cx = m_SplitBorderSize;
			} else
			{
				if (Index == m_WndList.Size()-1)
					It->SizeXorY = m_ClientRect.cy - SizeXorY;
				It->pWnd->MoveToClient(0, SizeXorY, true);
				It->pWnd->Resize(m_ClientRect.cx, It->SizeXorY, true);
				It->SplitRect.x = m_ClientRect.x;
				It->SplitRect.cx = m_ClientRect.cx;
				It->SplitRect.y = SizeXorY + m_ClientRect.y + It->pWnd->m_WindowRect.cy;
				It->SplitRect.cy = m_SplitBorderSize;
			}
			SizeXorY += m_SplitBorderSize + It->SizeXorY;
			++Index;
			++It;
		}		
		Update((WISP_RECT*)0);
	}
	int CWispSplitWnd::SetSize(int Pos, int SizeXorY)
	{
		if (Pos >= m_WndList.Size())
			return 0;
		m_WndList[Pos]->SizeXorY = SizeXorY;
		return 1;
	}
	int CWispSplitWnd::GetSize(int Pos, int *pSizeXorY)
	{
		if (Pos >= m_WndList.Size())
			return 0;
		*pSizeXorY = m_WndList[Pos]->SizeXorY;
		return 1;
	}

```

`source/Wisp/wispsplitwnd.hpp`:

```hpp

#ifndef _WISPSPLITWND_HPP_
#define _WISPSPLITWND_HPP_

#include "../Code/define.h"
#include "../Code/alt/altlist.hpp"
#include "wispwnd.hpp"

struct WISP_SPLIT_WND
{
	CWispWnd *pWnd;
	int SizeXorY;
	unsigned int Style;
	WISP_RECT SplitRect;
};

struct CWispSplitWnd : public CWispWnd
{
	CWispSplitWnd();
	virtual ~CWispSplitWnd();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	bool OnMouseLeave(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);
	bool OnMouseDblClick(WISP_MSG *pMsg);
	bool OnResizeChild(WISP_MSG *pMsg);
	WISP_SIZE m_Size;
	int m_SplitBorderSize;
	TList<WISP_SPLIT_WND> m_WndList;
	TListIter<WISP_SPLIT_WND> m_CurSplitWndIt;
	TListIter<WISP_SPLIT_WND> m_NextSplitWndIt;
	bool InsertWnd(CWispWnd *pWnd, unsigned int Style, int SizeXorY, int InsertPos);
	bool RemoveWnd(CWispWnd *pWnd);
	void AdjustWnd(int Pos);
	void AdjustWndPos();
	int SetSize(int Pos, int SizeXorY);
	int GetSize(int Pos, int *pSizeXorY);
};

#endif

```

`source/Wisp/wispstatic.cpp`:

```cpp

#include "wispstatic.hpp"
#include "wispbase.hpp"

//CWispStaticStr
//CWispStaticDIB
//CWispStaticGroup
//CWispStaticURL

//
	CWispStaticStr::CWispStaticStr()
	{
		m_CtrlType = WISP_CTRL_STATIC_STRING;
	}
	CWispStaticStr::~CWispStaticStr()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispStaticStr)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
	WISP_MSG_MAP_END(CWispBaseWnd)

	bool CWispStaticStr::OnUpdate(WISP_MSG *pMsg)
	{
		unsigned long OrgTextColor;

		if (m_WndText.m_nLength)
		{
			//???
			if ( (m_Style >> 9) & 1 ) //0x200
			{
				OrgTextColor = m_WindowDC.m_TextColor;
				m_WindowDC.m_OldTextColor = m_WindowDC.m_TextColor;
				m_WindowDC.m_TextColor = m_pWispBase->m_pWispDrawObj->m_crSystem[12];
			}

			m_WindowDC.DrawString(m_WndText.operator const WCHAR*(),
								&m_WindowRect, 0, 0, -1);

			//???
			if ( (m_Style >> 9) & 1 ) //0x200
			{
				m_WindowDC.m_OldTextColor = m_WindowDC.m_TextColor;
				m_WindowDC.m_TextColor = OrgTextColor;
			}
		}
		return true;
	}
//
	CWispStaticDIB::CWispStaticDIB()
	{
		m_CtrlType = WISP_CTRL_STATIC_DIB;
	}

	CWispStaticDIB::~CWispStaticDIB()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispStaticDIB)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
	WISP_MSG_MAP_END(CWispBaseWnd)

	bool CWispStaticDIB::CreateEx(CWispDIB *pDIB, int x, int y, CWispBaseWnd *pParentWnd, unsigned int CmdID)
	{
		m_pDIB = pDIB;
		return Create(0, x,y,
			pDIB->m_PixelBuf.Width, pDIB->m_PixelBuf.Height, pParentWnd, CmdID, 0, WISP_SH_MINSIZE);

	}

	bool CWispStaticDIB::OnUpdate(WISP_MSG *pMsg)
	{
		m_WindowDC.DrawDIB(0, 0, m_pDIB);
		return true;
		
	}
//
	CWispStaticGroup::CWispStaticGroup()
	{
		m_CtrlType = WISP_CTRL_STATIC_GROUP;
	}
	CWispStaticGroup::~CWispStaticGroup()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispStaticGroup)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
	WISP_MSG_MAP_END(CWispBaseWnd)

	bool CWispStaticGroup::OnUpdate(WISP_MSG *pMsg)
	{
		int nTextLen = m_WindowDC.GetTextExtent(m_WndText.operator const WCHAR*(), -1, 0);

		unsigned long color = m_pWispBase->m_pWispDrawObj->m_crSystem[35];

		WISP_RECT rc = m_WindowRect;

		rc.y += m_WindowDC.m_pFont->m_Height/2;
		rc.cy += m_WindowDC.m_pFont->m_Height/-2;

		m_WindowDC.DrawCircleLeftTop(rc.x+5, rc.y+5, 5, color);
		m_WindowDC.DrawCircleLeftBottom(rc.x+5, rc.y2()-6, 5, color);
		m_WindowDC.DrawCircleRightTop(rc.x2()-6, rc.y+5, 5, color);
		m_WindowDC.DrawCircleRightBottom(rc.x2()-6, rc.y2()-6, 5, color);
		m_WindowDC.DrawVLine(rc.x, rc.y+5, rc.y2()-6, color);
		m_WindowDC.DrawVLine(rc.x2()-1, rc.y+5, rc.y2()-6, color);
		m_WindowDC.DrawHLine( (rc.x + nTextLen) ? nTextLen+15:nTextLen+5, rc.x2()-6, rc.y, color);
		m_WindowDC.DrawHLine(rc.x+5, rc.x2()-6, rc.y2()-1, color);

		rc.x += 10;
		rc.y -= m_WindowDC.m_pFont->m_Height/2;
		rc.cx = nTextLen;
		rc.cy = m_WindowDC.m_pFont->m_Height;
		if (m_WndText.m_nLength)
			m_WindowDC.DrawString(m_WndText.operator const WCHAR*(), &rc, 0x24, 0, -1);

		return false;
	}
	bool CWispStaticGroup::OnGetFocus(WISP_MSG *pMsg)
	{
		//???
		return false;
	}

//
	CWispStaticURL::CWispStaticURL()
	{
		m_CtrlType = WISP_CTRL_STATIC_URL;
		m_MouseEnter = 0;
	}
	CWispStaticURL::~CWispStaticURL()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispStaticURL)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_ENTER, OnMouseEnter)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
	WISP_MSG_MAP_END(CWispBaseWnd)

	bool CWispStaticURL::OnUpdate(WISP_MSG *pMsg)
	{
		if (!m_WndText.m_nLength)
			return true;

		//???
		if ( (m_Style >> 9) & 1 ) //0x200
		{
			m_WindowDC.SetTextColor(m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
			m_WindowDC.DrawString(m_WndText.operator const WCHAR*(), &m_WindowRect, 0, 0, -1);
			m_WindowDC.SetTextColor();
			return true;
		}

		if (m_MouseEnter)
		{
			m_WindowDC.SetTextColor(m_pWispBase->m_pWispDrawObj->m_crSystem[7]);
		}

		m_WindowDC.DrawString(m_WndText.operator const WCHAR*(), &m_WindowRect, 0, 0, -1);

		if (m_MouseEnter)
		{
			m_WindowDC.DrawHLine(0, 
				m_WindowDC.GetTextExtent(m_WndText.operator const WCHAR*(), -1, 0),
				m_WindowRect.y + m_WindowDC.GetTextHeight(0),
				m_pWispBase->m_pWispDrawObj->m_crSystem[7]);
			m_WindowDC.SetTextColor();
		}
		return true;
	}
	bool CWispStaticURL::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType != VK_LBUTTON || pMsg->KeyEvent.bKeyDown)
			return true;

		char UrlStr[MAX_PATH];
		UnicodeToAnsi(GetWindowText().operator const WCHAR*(), UrlStr, MAX_PATH);

		//ShellExecuteA(0, "open", UrlStr, 0, 0, 3); //TODO

		WISP_MSG Msg;
		Msg.hWnd = m_OwnerWnd;
		Msg.Msg = WISP_WM_COMMAND;
		Msg.Command.CmdMsg = 0x80000500; //WISP_ID_OPEN_URL
		Msg.Command.CmdID = m_CmdID;
		Msg.Command.Param1 = 0;
		Msg.Command.Param2 = 0;
		if(!m_pWispBase->SendMessage(&Msg)) //SendCommand(
			return false;
		return true;
	}
	bool CWispStaticURL::OnMouseEnter(WISP_MSG *pMsg)
	{
		m_MouseEnter = true;
		Update((WISP_RECT*)0);
		return true;
	}
	bool CWispStaticURL::OnMouseLeave(WISP_MSG *pMsg)
	{
		m_MouseEnter = false;
		Update((WISP_RECT*)0);
		return true;
	}

```

`source/Wisp/wispstatic.hpp`:

```hpp

#ifndef _WISPSTATIC_HPP_
#define _WISPSTATIC_HPP_

#include "../Code/define.h"
#include "wispbasewnd.hpp"
#include "wispdib.hpp"

struct CWispStaticStr : public CWispBaseWnd
{
	CWispStaticStr();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	virtual ~CWispStaticStr();
};

struct CWispStaticDIB : public CWispBaseWnd
{
	CWispDIB *m_pDIB;

	CWispStaticDIB();
	virtual ~CWispStaticDIB();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool CreateEx(CWispDIB *pDIB, int x, int y, CWispBaseWnd *pParentWnd, unsigned int CmdID);
	bool OnUpdate(WISP_MSG *pMsg);
};

struct CWispStaticGroup : public CWispBaseWnd
{
	CWispStaticGroup();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnGetFocus(WISP_MSG *pMsg);
	virtual ~CWispStaticGroup();
};

struct CWispStaticURL : public CWispBaseWnd
{
	bool m_MouseEnter;

	CWispStaticURL();
	virtual ~CWispStaticURL();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnMouseEnter(WISP_MSG *pMsg);
	bool OnMouseLeave(WISP_MSG *pMsg);
};


#endif


```

`source/Wisp/wisptabwnd.cpp`:

```cpp

#include "wispbase.hpp"
#include "wisptabwnd.hpp"
#include "wispbasewnd.hpp"
#include "wispbutton.hpp"

#define ID_BUTTON 0x80000000

	CWispTabWnd::CWispTabWnd()
	{
		m_ActiveWndIndex = -1;
		m_nHoverIndex = -1;
		m_TabHeight = 18;
		m_TabSpaceHeight = 20;
		m_pActiveWnd = 0;
	}
	CWispTabWnd::~CWispTabWnd()
	{
	}

	WISP_MSG_MAP_BEGIN(CWispTabWnd)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
		WISP_MSG_MAP_ON_EVENT
		WISP_MSG_MAP(WISP_WM_RECALC_LAYOUT, OnRecalcLayout)
	WISP_MSG_MAP_END(CWispWnd)

	WISP_EVENT_MAP_BEGIN(CWispTabWnd)
		WISP_EVENT_MAP(ID_BUTTON, OnEventButtonClose)
	WISP_EVENT_MAP_END

	bool CWispTabWnd::OnEventButtonClose(WISP_MSG *pMsg)
	{
		WISP_TAB_WND_ITEM *pTabItem = pMsg->hParentWnd->m_pTabWndItem;
		if (!pTabItem)
			return false;
		RemoveTab(pTabItem, pTabItem->pWnd->m_AdvStyle & 1);
		Update((WISP_RECT*)0);
		return true;
	}

	bool CWispTabWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (!pMsg->KeyEvent.bKeyDown)
			return true;

		if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			int Index = 0;
			TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
			while (It != m_WndList.End())
			{	
				if (PtInRect(&It->TabRC, &pMsg->m_LogicMousePosWnd))
				{
					if (Index != m_ActiveWndIndex)
					{
						SetActiveWnd(Index);
					}
					break;
				}
				++Index;
				++It;
			}
		} else
		if (pMsg->KeyEvent.KeyType == VK_TAB && m_WndList.Size() != 0)
		{
			if (m_pWispBase->m_KeyMap[VK_SHIFT])
				ActivePrevPage();
			else	ActiveNextPage();
		}
		Update((WISP_RECT*)0);
		return true;
	}
	bool CWispTabWnd::OnUpdateClient(WISP_MSG *pMsg)
	{
		if (!m_WndList.Size())
			CWispWnd::OnUpdateClient(pMsg);

		if ( !(m_Style & 0x800000) || m_WndList.Size() != 1)
		{
			switch (m_Style & 0xF0000)
			{
			case 0x10000:
				DrawTabTop();
				break;
			case 0x20000:
				DrawTabButtom();
				break;
			case 0x40000:
				DrawTabLeft();
				break;
			case 0x80000:
				DrawTabRight();
				break;
			}
		}
		return false;
	}
	bool CWispTabWnd::OnDestroy(WISP_MSG *pMsg)
	{
		m_WndList.Clear();
		m_pActiveWnd = 0;
		m_nHoverIndex = -1;
		m_ActiveWndIndex = -1;
		return true;
	}
	bool CWispTabWnd::OnSize(WISP_MSG *pMsg)
	{
		if (m_pActiveWnd)
		{
			switch (m_Style & 0xF0000)
			{
			case 0x10000:
			case 0x20000:
				m_pActiveWnd->Resize(m_ClientRect.cx, m_ClientRect.cy - m_TabSpaceHeight, true);
				break;
			case 0x40000:
			case 0x80000:
				m_pActiveWnd->Resize(m_ClientRect.cx - m_TabSpaceHeight, m_ClientRect.cy, true);
				break;
			}
		}
		return true;
	}
	bool CWispTabWnd::OnRecalcLayout(WISP_MSG *pMsg)
	{
		switch (m_Style & 0xF0000)
		{
		case 0x10000:
			ResizeTabTop();
			break;
		case 0x20000:
			ResizeTabButtom();
			break;
		case 0x40000:
			ResizeTabLeft();
			break;
		case 0x80000:
			ResizeTabRight();
			break;
		}
		return true;
	}
	bool CWispTabWnd::OnGetFocus(WISP_MSG *pMsg)
	{
		m_pWispBase->m_pFocusWnd = m_pActiveWnd;
		return true;
	}
	bool CWispTabWnd::OnMouseMove(WISP_MSG *pMsg)
	{
		int Index = 0;
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			if (PtInRect(&It->TabRC, &pMsg->m_LogicMousePosWnd))
			{
				Update(&m_Rect);
				m_nHoverIndex = Index;
				return false;
			}
			++Index;
			++It;
		}
		return OnMouseLeave(pMsg);
	}
	bool CWispTabWnd::OnMouseLeave(WISP_MSG *pMsg)
	{
		if (m_nHoverIndex != -1)
		{
			Update(&m_Rect);
			m_nHoverIndex = -1;
		}
		return true;
	}
	bool CWispTabWnd::InitWnd()
	{
		if (!CWispWnd::InitWnd())
			return false;
		if (!(m_Style & 0xF0000))
			m_Style |= 0x10000;
		m_FixedTabWidth = 0;
		m_TextSpaceWidth = 0;
		m_MiniCloseDIBList = gpCurWisp->m_DIBLib.LoadDIBList("\\Skin\\Default\\MiniClose.bmp", 10, 10, 0, 0xFF00FF);
		m_ButtonSize.cy = 10;
		m_ButtonSize.cx = 10;
		if ((m_Style & 0x200000))
			m_TextSpaceWidth += 10;
		m_FullWidth = 0;
		m_TextColor = m_pWispBase->m_pWispDrawObj->m_crSystem[79];
		return true;
	}
	void CWispTabWnd::DrawTabTop()
	{
		WISP_RECT Rect;
		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = m_ClientRect.cx;
		Rect.cy = m_TabSpaceHeight;
		m_pWispBase->m_pWispDrawObj->DrawTabBackground(&m_ClientDC, &Rect);
		m_ClientDC.DrawHLine(Rect.x, Rect.x2() - 1, Rect.cy + Rect.y - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[28]);
		int Index = 0;
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			WISP_RECT Rect = It->TabRC;
			m_ClientDC.SetTextColor(m_pWispBase->m_pWispDrawObj->m_crSystem[46]);
			int State = 0;
			if (Index == m_ActiveWndIndex)
				State = 2;
			else
			if (Index == m_nHoverIndex)
				State = 1;
			switch (State)
			{
			case 0: //NORMAL
				m_ClientDC.DrawVLine(Rect.x, Rect.y + 1, Rect.y2() - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawVLine(Rect.x2() - 1, Rect.y + 1, Rect.y2() - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				++Rect.x;
				++Rect.y;
				Rect.cx -= 2;
				Rect.cy -= 2;
				m_ClientDC.DrawFullRect(&Rect, m_pWispBase->m_pWispDrawObj->m_crSystem[39]);
				break;
			case 1: //HOVER
				m_ClientDC.DrawVLine(Rect.x, Rect.y + 3, Rect.y2() - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawVLine(Rect.x2() - 1, Rect.y + 3, Rect.y2() - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawHLine(Rect.x + 2, Rect.x2() - 3, Rect.y, m_pWispBase->m_pWispDrawObj->m_crSystem[79]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y + 1, m_pWispBase->m_pWispDrawObj->m_crSystem[80]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y + 2, m_pWispBase->m_pWispDrawObj->m_crSystem[81]);

				Rect.x += 1;
				Rect.cx -= 2;
				Rect.y += 3;
				Rect.cy -= 4;
				m_ClientDC.DrawFullRect(&Rect, m_pWispBase->m_pWispDrawObj->m_crSystem[39]);
				break;
			case 2: //ACTIVE
				m_ClientDC.DrawVLine(Rect.x, Rect.y + 3, Rect.y2() - 4, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawVLine(Rect.x2() - 1, Rect.y + 3, Rect.y2() - 4, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawHLine(Rect.x + 2, Rect.x2() - 3, Rect.y, m_pWispBase->m_pWispDrawObj->m_crSystem[79]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y + 1, m_pWispBase->m_pWispDrawObj->m_crSystem[80]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y + 2, m_pWispBase->m_pWispDrawObj->m_crSystem[81]);
				Rect.x += 1;
				Rect.cx -= 2;
				Rect.y += 3;
				Rect.cy -= 3;
				m_ClientDC.DrawFullRect(&Rect, m_pWispBase->m_pWispDrawObj->m_crSystem[38]);
				break;
			}
			if (It->pDIB)
			{
				m_ClientDC.DrawDIB(Rect.x + 2, Rect.y + (Rect.cy - It->pDIB->m_PixelBuf.Height) / 2, It->pDIB);
				Rect.x += It->pDIB->m_PixelBuf.Width;
				Rect.cx -= It->pDIB->m_PixelBuf.Width;
			}
			Rect.x += 4;
			Rect.cx += -4 - m_TextSpaceWidth;
			if (m_pWispBase->m_pFocusWnd &&
				(m_pWispBase->m_pFocusWnd == It->pWnd ||
				m_pWispBase->m_pFocusWnd->IsChildWndOf(It->pWnd)))
			{
				m_ClientDC.SetTextColor(m_TextColor);
				m_ClientDC.DrawShadowText(&Rect, It->Name, 1, -1, 0);
				m_ClientDC.SetTextColor();
			} else
			{
				m_ClientDC.DrawString(&Rect, It->Name, -1, 0);
			}
			++Index;
			++It;
		}
	}
	void CWispTabWnd::DrawTabButtom()
	{
		WISP_RECT Rect;
		Rect.x = 0;
		Rect.y = m_ClientRect.cy - m_TabSpaceHeight;
		Rect.cx = m_ClientRect.cx;
		Rect.cy = m_TabSpaceHeight;
		m_pWispBase->m_pWispDrawObj->DrawTabBackground(&m_ClientDC, &Rect);
		m_ClientDC.DrawHLine(Rect.x, Rect.x2() - 1, Rect.y, m_pWispBase->m_pWispDrawObj->m_crSystem[28]);
		int Index = 0;
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			WISP_RECT Rect = It->TabRC;
			m_ClientDC.SetTextColor(m_pWispBase->m_pWispDrawObj->m_crSystem[46]);
			int State = 0;
			if (Index == m_ActiveWndIndex)
				State = 2;
			else
			if (Index == m_nHoverIndex)
				State = 1;
			switch (State)
			{
			case 0: //NORMAL
				m_ClientDC.DrawVLine(Rect.x, Rect.y, Rect.y2() - 2, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawVLine(Rect.x2() - 1, Rect.y, Rect.y2() - 2, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y2() - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				++Rect.x;
				++Rect.y;
				Rect.cx -= 2;
				Rect.cy -= 2;
				m_ClientDC.DrawFullRect(&Rect, m_pWispBase->m_pWispDrawObj->m_crSystem[39]);
				break;
			case 1: //HOVER
				m_ClientDC.DrawVLine(Rect.x, Rect.y, Rect.y2() - 4, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawVLine(Rect.x2() - 1, Rect.y, Rect.y2() - 4, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawHLine(Rect.x + 2, Rect.x2() - 3, Rect.y2() - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[79]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y2() - 2, m_pWispBase->m_pWispDrawObj->m_crSystem[80]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y2() - 3, m_pWispBase->m_pWispDrawObj->m_crSystem[81]);
				++Rect.x;
				++Rect.y;
				Rect.cx -= 2;
				Rect.cy -= 4;
				m_ClientDC.DrawFullRect(&Rect, m_pWispBase->m_pWispDrawObj->m_crSystem[39]);
				break;
			case 2: //ACTIVE
				m_ClientDC.DrawVLine(Rect.x, Rect.y, Rect.y2() - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawVLine(Rect.x2() - 1, Rect.y, Rect.y2() - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[35]);
				m_ClientDC.DrawHLine(Rect.x + 2, Rect.x2() - 3, Rect.y2() - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[79]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y2() - 2, m_pWispBase->m_pWispDrawObj->m_crSystem[80]);
				m_ClientDC.DrawHLine(Rect.x + 1, Rect.x2() - 2, Rect.y2() - 3, m_pWispBase->m_pWispDrawObj->m_crSystem[81]);
				++Rect.x;
				Rect.cx -= 2;
				Rect.cy -= 3;
				m_ClientDC.DrawFullRect(&Rect, m_pWispBase->m_pWispDrawObj->m_crSystem[38]);
				break;
			}
			if (It->pDIB)
			{
				m_ClientDC.DrawDIB(Rect.x + 2, Rect.y + (Rect.cy - It->pDIB->m_PixelBuf.Height) / 2, It->pDIB);
				Rect.x += It->pDIB->m_PixelBuf.Width;
				Rect.cx -= It->pDIB->m_PixelBuf.Width;
			}
			Rect.x += 4;
			Rect.cx += -4 - m_TextSpaceWidth;
			if (m_pWispBase->m_pFocusWnd &&
				(m_pWispBase->m_pFocusWnd == It->pWnd ||
				m_pWispBase->m_pFocusWnd->IsChildWndOf(It->pWnd)))
			{
				m_ClientDC.SetTextColor(m_TextColor);
				m_ClientDC.DrawShadowText(&Rect, It->Name, 1, -1, 0);
				m_ClientDC.SetTextColor();
			} else
			{
				m_ClientDC.DrawString(&Rect, It->Name, -1, 0);
			}
			++Index;
			++It;
		}
	}
	void CWispTabWnd::DrawTabLeft()
	{	
		//
	}
	void CWispTabWnd::DrawTabRight()
	{
		//
	}

	void CWispTabWnd::ResizeTabTop()
	{
		int Start = 3;
		m_Rect.x = Start;
		m_Rect.y = m_TabSpaceHeight - m_pWispBase->m_Metrics[WISP_SM_TOOLBAR_CY];
		m_Rect.cx = m_ClientRect.cx;
		m_Rect.cy = m_pWispBase->m_Metrics[WISP_SM_TOOLBAR_CY];
		m_FixedTabWidth = 0;
		if (m_Style & 0x100000)
		{
			TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
			while (It != m_WndList.End())
			{	
				int w = m_ClientDC.GetTextExtent(It->Name, -1, 0) + 8;
				if (It->pDIB)
					w += It->pDIB->m_PixelBuf.Width + 4;
				MIN_LIMIT(m_FixedTabWidth, w);
				++It;
			}
		}

		int Index = 0;
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			int w = m_ClientDC.GetTextExtent(It->Name, -1, 0) + 8 + m_TextSpaceWidth;
			if (It->pDIB)
				w += It->pDIB->m_PixelBuf.Width + 4;
			MIN_LIMIT(w, m_FixedTabWidth);
			
			It->TabRC.x = Start;
			It->TabRC.y = m_Rect.y;
			It->TabRC.cx = w;
			It->TabRC.cy = m_TabHeight;
			if (Index == m_ActiveWndIndex)
			{
				It->TabRC.x -= 2;
				It->TabRC.y -= 2;
				It->TabRC.cx += 4;
				It->TabRC.cy += 2;
			}
			if (m_Style & 0x200000)
				It->pButton->MoveToClient(
					It->TabRC.cx - It->pButton->m_WindowRect.cx + It->TabRC.x - 2,
					It->TabRC.y + (m_Rect.cy - It->pButton->m_WindowRect.cy)/2, true);
			Start += w + 1;
			++Index;
			++It;
		}
		m_FullWidth = Start;
	}
	void CWispTabWnd::ResizeTabButtom()
	{
		int Start = 3;
		m_Rect.x = Start;
		m_Rect.y = m_ClientRect.cy - m_TabSpaceHeight;
		m_Rect.cx = m_ClientRect.cx;
		m_Rect.cy = m_pWispBase->m_Metrics[WISP_SM_TOOLBAR_CY];
		m_FixedTabWidth = 0;
		if (m_Style & 0x100000)
		{
			TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
			while (It != m_WndList.End())
			{	
				int w = m_ClientDC.GetTextExtent(It->Name, -1, 0) + 8;
				if (It->pDIB)
					w += It->pDIB->m_PixelBuf.Width + 4;
				MIN_LIMIT(m_FixedTabWidth, w);
				++It;
			}
		}

		int Index = 0;
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			int w = m_ClientDC.GetTextExtent(It->Name, -1, 0) + 8 + m_TextSpaceWidth;
			if (It->pDIB)
				w += It->pDIB->m_PixelBuf.Width + 4;
			MIN_LIMIT(w, m_FixedTabWidth);
			
			It->TabRC.x = Start;
			It->TabRC.y = m_Rect.y;
			It->TabRC.cx = w;
			It->TabRC.cy = m_TabHeight;
			if (Index == m_ActiveWndIndex)
			{
				It->TabRC.x -= 2;

				It->TabRC.cx += 4;
				It->TabRC.cy += 2;
			}
			if (m_Style & 0x200000)
				It->pButton->MoveToClient(
					It->TabRC.cx - It->pButton->m_WindowRect.cx + It->TabRC.x - 2,
					It->TabRC.y + 3, true);
			Start += w + 1;
			++Index;
			++It;
		}
		m_FullWidth = Start;
	}
	void CWispTabWnd::ResizeTabLeft()
	{
		//
	}
	void CWispTabWnd::ResizeTabRight()
	{
		//
	}

	unsigned int CWispTabWnd::InsertWnd(const WCHAR *Name, CWispWnd *pWnd, CWispDIB *pDIB)
	{
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Append();
		InsertTab(&*It, Name, pWnd, pDIB);
		return m_WndList.Size()-1;
	}
	unsigned int CWispTabWnd::InsertWndAfter(int Index, const WCHAR *Name, CWispWnd *pWnd, CWispDIB *pDIB)
	{
		if (Index >= m_WndList.Size())
			return InsertWnd(Name, pWnd, pDIB);
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.InsertAfter(m_WndList[Index]);
		InsertTab(&*It, Name, pWnd, pDIB);
		return m_WndList.Size()-1;
	}
	unsigned int CWispTabWnd::InsertWndBefore(int Index, const WCHAR *Name, CWispWnd *pWnd, CWispDIB *pDIB)
	{
		if (Index >= m_WndList.Size())
			return InsertWnd(Name, pWnd, pDIB);
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.InsertBefore(m_WndList[Index]);
		InsertTab(&*It, Name, pWnd, pDIB);
		return m_WndList.Size()-1;
	}
	unsigned int CWispTabWnd::RemoveWnd(CWispWnd *pWnd, bool bDestroy)
	{
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			if (It->pWnd == pWnd)
			{
				RemoveTab(&*It, bDestroy);
				break;
			}
			++It;
		}
		return m_WndList.Size();
	}
	unsigned int CWispTabWnd::RemoveWnd(int Index, bool bDestroy)
	{
		if (Index < m_WndList.Size())
			RemoveTab(&*m_WndList[Index], bDestroy);
		return m_WndList.Size();
	}
	CWispWnd *CWispTabWnd::GetActiveWnd()
	{
		return m_pActiveWnd;
	}
	unsigned int CWispTabWnd::GetActiveWndIndex()
	{
		return m_ActiveWndIndex;
	}
	CWispWnd *CWispTabWnd::SetActiveWnd(unsigned int Index)
	{
		if (m_ActiveWndIndex == Index)
		{
			m_pActiveWnd->Focus();
			return m_pActiveWnd;
		}
	
		if (Index >= m_WndList.Size())
			return nullptr;

		TListIter<WISP_TAB_WND_ITEM> It = m_WndList[Index];
		if (It == m_WndList.End())
			return nullptr;
		ChangeActiveWnd(It->pWnd);
		return m_pActiveWnd;
	}
	bool CWispTabWnd::SetTabText(unsigned int Index, const WCHAR *pStr)
	{
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList[Index];
		if (It == m_WndList.End())
			return false;
		TStrOmit(pStr, It->Name, 32);
		Update((WISP_RECT*)0);
		return true;
	}
	void CWispTabWnd::ChangeActiveWnd(CWispWnd *pActiveWindow)
	{
		int Index = 0;
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			if (It->pWnd == pActiveWindow)
				break;
			++Index;
			++It;
		}
		if (Index < m_WndList.Size())
		{
			OnActiveWnd(pActiveWindow);
			if (SendCommand(0x80000800, Index, pActiveWindow)) //WISP_ID_TAB_SELECT
			{
				if (m_pActiveWnd)
					m_pActiveWnd->Show(WISP_SH_HIDDEN);
				m_pActiveWnd = pActiveWindow;
				switch (m_Style & 0xF0000)
				{
				case 0x10000:
					pActiveWindow->MoveToClient(0,m_TabSpaceHeight, true);
					m_pActiveWnd->Resize(m_ClientRect.cx, m_ClientRect.cy - m_TabSpaceHeight, true);
					break;
				case 0x20000:
					pActiveWindow->MoveToClient(0,0,true);
					m_pActiveWnd->Resize(m_ClientRect.cx, m_ClientRect.cy - m_TabSpaceHeight, true);
					break;
				case 0x40000:
					pActiveWindow->MoveToClient(m_TabSpaceHeight,0,true);
					m_pActiveWnd->Resize(m_ClientRect.cx - m_TabSpaceHeight, m_ClientRect.cy, true);
					break;
				case 0x80000:
					pActiveWindow->MoveToClient(0,0,true);
					m_pActiveWnd->Resize(m_ClientRect.cx - m_TabSpaceHeight, m_ClientRect.cy, true);
					break;
				}
				m_pActiveWnd->Focus();
				m_pActiveWnd->Show(WISP_SH_MINSIZE);
				m_ActiveWndIndex = Index;
				RecalcLayout();
				Update((WISP_RECT*)0);
			}
		}
	}
	void CWispTabWnd::ActiveNextPage()
	{
		int Index = m_ActiveWndIndex + 1;
		if (Index >= m_WndList.Size())
			Index = 0;
		SetActiveWnd(Index);
	}
	void CWispTabWnd::ActivePrevPage()
	{
		int Index = m_ActiveWndIndex - 1;
		if (Index < 0)
			Index = m_WndList.Size() - 1;
		SetActiveWnd(Index);
	}
	unsigned int CWispTabWnd::GetWndCount()
	{
		return m_WndList.Size();
	}

	CWispWnd *CWispTabWnd::GetWnd(int Index)
	{
		if (Index < m_WndList.Size())
			return m_WndList[Index]->pWnd;
		return nullptr;
	}
	CWispButton *CWispTabWnd::GetButton(int Index)
	{
		if (Index < m_WndList.Size())
			return m_WndList[Index]->pButton;
		return nullptr;
	}

	//+0x38
	void CWispTabWnd::InsertTab(WISP_TAB_WND_ITEM *pTabItem, const WCHAR *pString, CWispWnd *pWnd, CWispDIB *pDIB)
	{
		if (m_Style & 0x800000 && m_WndList.Size() == 1)
			m_TabSpaceHeight = 0;
		else	m_TabSpaceHeight = m_TabHeight + 2;

		pTabItem->pDIB = pDIB;
		pTabItem->pWnd = pWnd;

		if (pString)
			TStrCpy(pTabItem->Name, pString);

		if (m_Style & 0x200000)
		{
			pTabItem->pButton = new CWispButton;
			pTabItem->pButton->CreateEx(m_MiniCloseDIBList, 0, 0, this, ID_BUTTON, 0x800000);
			pTabItem->pButton->m_AdvStyle |= 1;
			pTabItem->pButton->m_pTabWndItem = pTabItem;
		} else
		{
			pTabItem->pButton = 0;
		}

		RecalcLayout();
		if (m_WndList.Size() == 1)
			SetActiveWnd(0);
		else	pTabItem->pWnd->Show(WISP_SH_HIDDEN);

		if ((m_Style & 0x200000) && (m_Style & 0x400000))
		{
			if (m_WndList.Size() == 1)
				m_WndList[0]->pButton->EnableWindow(0);

			if (m_WndList.Size() == 2)
				m_WndList[0]->pButton->EnableWindow(1);
		}		
	}
	//+0x3C
	void CWispTabWnd::RemoveTab(WISP_TAB_WND_ITEM *pTabItem, bool bDestroy)
	{
		if (OnRemoveTab(pTabItem->pWnd))
		{
			if (pTabItem->pButton)
				pTabItem->pButton->Destroy();
			if (bDestroy)
				pTabItem->pWnd->Destroy();
			TListIter<WISP_TAB_WND_ITEM> It = pTabItem;
			if (pTabItem->pWnd == m_pActiveWnd)
			{
				m_WndList.Remove(It);
				m_ActiveWndIndex = -1;
				m_pActiveWnd = 0;
				OnRemoved();
				if (m_WndList.Size())
					SetActiveWnd(m_WndList.Size()-1);
			} else
			{
				m_WndList.Remove(It);
				OnRemoved();
			}

			if ((m_Style & 0x200000) && (m_Style & 0x400000) && m_WndList.Size() == 1)
			{
				GetButton(0)->EnableWindow(0);
			}

			if ((m_Style & 0x800000) && m_WndList.Size() == 1)
			{
				m_TabSpaceHeight = 0;
				m_ActiveWndIndex = -1;
				SetActiveWnd(0);
			}
			RecalcLayout();
			Update(&m_Rect);
		}
	}

	//+0x40
	//bool CWispTabWnd::OnRemoveTab(CWispWnd *pWnd) { return true; }
	//+0x44
	//void CWispTabWnd::OnRemoved() { }
	//+0x48
	//void CWispTabWnd::OnActiveWnd(CWispWnd *pWnd) { }
	
	void CWispTabWnd::RemoveAllTab(bool bDestroy)
	{
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			if (It->pButton)
				It->pButton->Destroy();
			if (bDestroy)
				It->pWnd->Destroy();
			++It;
		}
		m_WndList.Clear();
		m_pActiveWnd = 0;
		m_nHoverIndex = -1;
		m_ActiveWndIndex = -1;
	}

```

`source/Wisp/wisptabwnd.hpp`:

```hpp

#ifndef _WISPTABWND_HPP_
#define _WISPTABWND_HPP_

#include "../Code/define.h"
#include "../Code/alt/altlist.hpp"
#include "wispwnd.hpp"
#include "wispdib.hpp"

	struct CWispButton;

struct WISP_TAB_WND_ITEM
{
	CWispWnd *pWnd;
	WCHAR Name[32];
	WISP_RECT TabRC;
	CWispDIB *pDIB;
	CWispButton *pButton;
};

struct CWispTabWnd : public CWispWnd
{
	CWispTabWnd();
	virtual ~CWispTabWnd();

	TList<WISP_TAB_WND_ITEM> m_WndList;
	CWispWnd *m_pActiveWnd;
	int m_ActiveWndIndex;
	int m_nHoverIndex;
	int m_TabHeight;
	int m_TabSpaceHeight;
	int m_TextSpaceWidth;
	WISP_RECT m_Rect;
	int m_FixedTabWidth;
	int m_FullWidth;
	WISP_SIZE m_ButtonSize;
	CWispDIBList *m_MiniCloseDIBList;
	unsigned long m_TextColor;

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventButtonClose(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);
	bool OnRecalcLayout(WISP_MSG *pMsg);
	bool OnGetFocus(WISP_MSG *pMsg);
	bool OnMouseMove(WISP_MSG *pMsg);
	bool OnMouseLeave(WISP_MSG *pMsg);
	virtual bool InitWnd() override;
	void DrawTabTop();
	void DrawTabButtom();
	void DrawTabLeft();
	void DrawTabRight();

	void ResizeTabTop();
	void ResizeTabButtom();
	void ResizeTabLeft();
	void ResizeTabRight();

	unsigned int InsertWnd(const WCHAR *Name, CWispWnd *pWnd, CWispDIB *pDIB);
	unsigned int InsertWndAfter(int Index, const WCHAR *Name, CWispWnd *pWnd, CWispDIB *pDIB);
	unsigned int InsertWndBefore(int Index, const WCHAR *Name, CWispWnd *pWnd, CWispDIB *pDIB);
	unsigned int RemoveWnd(CWispWnd *pWnd, bool bDestroy);
	unsigned int RemoveWnd(int Index, bool bDestroy);
	CWispWnd *GetActiveWnd();
	unsigned int GetActiveWndIndex();
	CWispWnd *SetActiveWnd(unsigned int Index);
	bool SetTabText(unsigned int Index, const WCHAR *pStr);
	void ChangeActiveWnd(CWispWnd *pActiveWindow);
	void ActiveNextPage();
	void ActivePrevPage();
	unsigned int GetWndCount();

	CWispWnd *GetWnd(int Index);
	CWispButton *GetButton(int Index);

	//+0x38
	virtual void InsertTab(WISP_TAB_WND_ITEM *pTabItem, const WCHAR *pString, CWispWnd *pWnd, CWispDIB *pDIB);
	//+0x3C
	virtual void RemoveTab(WISP_TAB_WND_ITEM *pTabItem, bool bDestroy);

	//+0x40
	virtual bool OnRemoveTab(CWispWnd *pWnd) { return true; }
	//+0x44
	virtual void OnRemoved() { }
	//+0x48
	virtual void OnActiveWnd(CWispWnd *pWnd) { }
	
	void RemoveAllTab(bool bDestory);
};


#endif
```

`source/Wisp/wisptipwnd.cpp`:

```cpp

#include "wisptipwnd.hpp"
#include "wispbase.hpp"

	CWispTipWnd::CWispTipWnd()
	{
		m_CtrlType = WISP_CTRL_TIP_WND;
		m_pTipOwnerWnd = 0;
	}

	bool CWispTipWnd::OnUpdate(WISP_MSG *pMsg)
	{
		WISP_RECT rc = m_WindowRect;
		m_WindowDC.DrawFrameRect(&rc, 1, 1);

		rc.x += 1;
		rc.y += 1;
		rc.cx -= 2;
		rc.cy -= 2;
		m_WindowDC.DrawFullRect(&rc, m_pWispBase->m_pWispDrawObj->m_crSystem[111]);
		if (m_WndText.m_nLength)
		{
			rc.x += 2;
			rc.y += 1;
			rc.cx -= 4;
			rc.cy -= 2;
			m_WindowDC.DrawString(m_WndText.operator const WCHAR*(), &rc, 0, 0, -1);
		}
		return false;
	}

	void CWispTipWnd::AutoAdjustPostion(CWispWnd *pWnd)
	{
		WISP_RECT rc;
		m_WindowDC.DrawString(m_WndText.operator const WCHAR*(), &rc, 0x400, 0, -1);
		rc.cy += 5;
		rc.cx += 8;
		m_pTipOwnerWnd = pWnd;
		m_WindowDC.GetTextExtent(m_WndText.operator const WCHAR*(), -1, 0);


		rc.x = m_pWispBase->m_MousePT.x - rc.cx / 2;
		rc.y = m_pWispBase->m_MousePT.y + 20;
		if (rc.x <= 0)
			rc.x = 10;

		if (rc.y <= 10)
			rc.y = 10;

		if (rc.x2()-1 >= m_pWispBase->m_FrameBufferInfo.Width)
			rc.x = m_pWispBase->m_FrameBufferInfo.Width - rc.cx - 10;
		if (rc.y2()-1 >= m_pWispBase->m_FrameBufferInfo.Height)
			rc.y = m_pWispBase->m_MousePT.y-30;

		MoveToScreen(rc.x, rc.y, true);
		Resize(rc.cx, rc.cy, true);
		Top(true);
	}

	WISP_MSG_MAP_BEGIN(CWispTipWnd)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
	WISP_MSG_MAP_END(CWispBaseWnd)


```

`source/Wisp/wisptipwnd.hpp`:

```hpp

#ifndef _WISPTIPWND_HPP_
#define _WISPTIPWND_HPP_

#include "../Code/define.h"
#include "wispwnd.hpp"

	struct CWispTipWnd : public CWispWnd
	{
		CWispWnd *m_pTipOwnerWnd;

		CWispTipWnd();

		bool OnUpdate(WISP_MSG *pMsg);
		void AutoAdjustPostion(CWispWnd *pWnd);
		virtual bool MsgProc(WISP_MSG *pMsg) override;
	};
#endif
```

`source/Wisp/wisptoolbar.cpp`:

```cpp

#include "wisptoolbar.hpp"
#include "wispbase.hpp"
#include "wispstatic.hpp"
#include "wispbutton.hpp"
#include "wispedit.hpp"

	CWispToolbar::CWispToolbar()
	{
		m_CtrlType = WISP_CTRL_TOOL_BAR;
		m_pDIBList = 0;
		m_Margin = 3;
		m_SeparatorWidth = 2;
	}
	CWispToolbar::~CWispToolbar()
	{
		//EMPTY
	}

	void CWispToolbar::SetOwner(CWispBaseWnd *pOwnerWnd)
	{
		TListIter<WISP_TOOLBAR_ITEM> It = m_BTList.Begin();
		while (It != m_BTList.End())
		{
			if (It->pItem)
				It->pItem->SetOwner(pOwnerWnd);
			++It;
		}
		CWispBaseWnd::SetOwner(pOwnerWnd);
	}

	WISP_MSG_MAP_BEGIN(CWispToolbar)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_RECALC_LAYOUT, OnRecalcLayout)
		WISP_MSG_MAP(WISP_WM_RESIZE_CHILD, OnResizeChild)
	WISP_MSG_MAP_END(CWispWnd)

	bool CWispToolbar::OnDestroy(WISP_MSG *pMsg)
	{
		m_BTList.Clear();
		return true;
	}
	bool CWispToolbar::OnUpdateClient(WISP_MSG *pMsg)
	{
		if ( !(m_Style & 0x40))
			m_pWispBase->m_pWispDrawObj->DrawToolbarBK(&m_ClientDC, &m_ClientRect);

		int x = m_Margin;
		TListIter<WISP_TOOLBAR_ITEM> It = m_BTList.Begin();
		while (It != m_BTList.End())
		{
			if (It->pItem)
			{
				x += m_Margin + It->pItem->m_WindowRect.cx;
			} else
			{
				WISP_RECT rc;
				rc.x = x + m_SeparatorWidth / 2;
				rc.y = m_Margin;
				rc.cx = m_SeparatorWidth;
				rc.cy = m_ClientRect.cy - m_Margin*2;
				m_ClientDC.DrawFrameRect(&rc, 0, 1);
				x += m_Margin + m_SeparatorWidth;
			}
			++It;
		}
		m_ClientDC.DrawHLine(0, m_ClientRect.cx - 1, m_ClientRect.cy - 1, m_pWispBase->m_pWispDrawObj->m_crSystem[28]);
		return false;
	}
	bool CWispToolbar::OnRecalcLayout(WISP_MSG *pMsg)
	{
		int x = m_Margin;
		int y = m_ClientRect.cx - x;
		TListIter<WISP_TOOLBAR_ITEM> It = m_BTList.Begin();
		while (It != m_BTList.End())
		{
			if (It->pItem)
			{
				int cy = m_WindowRect.cy - It->pItem->m_WindowRect.cy;
				if (It->Type & 0x20000) //WISP_TOOLBAR_ALIGN
				{
					int cx = y - It->pItem->m_WindowRect.cx;
					It->pItem->MoveToClient(cx, cy / 2, false);
					//It->pItem->Show(2 * (cx < x) + 1); //???
					if (x > cx)
						It->pItem->Show(WISP_SH_HIDDEN);
					else	It->pItem->Show(WISP_SH_MINSIZE);
					y = cx - m_Margin;
				} else
				{
					It->pItem->MoveToClient(x, cy / 2, true);
					x += m_Margin + It->pItem->m_WindowRect.cx;
				}
			} else
			{
				x += m_Margin + m_SeparatorWidth;
			}
			MIN_LIMIT(y, x);
			++It;
		}
		return true;
	}
	bool CWispToolbar::OnResizeChild(WISP_MSG *pMsg)
	{
		if (!(m_Style & 0x10000))
			CWispBaseWnd::Resize(((CWispWnd*)m_ParentWnd)->m_ClientRect.cx, m_WindowRect.cy, true);
		return true;
	}
	bool CWispToolbar::CreateEx(CWispWnd *pParentWnd, int y, int cy, unsigned int CmdID, unsigned int Style)
	{
		m_pDIBList = 0;

		if (cy == -1) cy = gpCurWisp->m_Metrics[WISP_SM_TOOLBAR_CY]+m_Margin*2;
		return CreateWnd(0, 0,y, pParentWnd->m_ClientRect.cx, cy, pParentWnd, CmdID, Style, WISP_SH_MINSIZE);
	}
	CWispBaseWnd *CWispToolbar::GetItem(unsigned int CmdID)
	{
		TListIter<WISP_TOOLBAR_ITEM> It = m_BTList.Begin();
		while (It != m_BTList.End())
		{
			if (It->pItem &&
				It->pItem->m_CmdID == CmdID)
				return It->pItem;
			++It;
		}
		return nullptr;
	}
	bool CWispToolbar::LoadToolbar(CWispDIBList *pDIBList, WISP_TOOLBAR_RES_ITEM *pResItem)
	{
		m_pDIBList = pDIBList;

		while (pResItem->CmdID || pResItem->Type)
		{
			if (pResItem->Type & WISP_TOOLBAR_SEPARATOR)
				InsertSeparator(-1, pResItem->Type);
			else
			if (pResItem->Type & WISP_TOOLBAR_EDIT)
				InsertEdit(-1, pResItem->Type, pResItem->Width, pResItem->CmdID,
					pResItem->Style, pResItem->pString);
			else
			if (pResItem->Type & WISP_TOOLBAR_DIB)
				InsertStaticDIB(-1, pResItem->Type, pResItem->CmdID,
					pDIBList->GetDIB(pResItem->DIBIndex));
			else
			if (pResItem->Type & WISP_TOOLBAR_STR)
				InsertStaticStr(-1, pResItem->Type, pResItem->CmdID,
					pResItem->pString);
			else
				InsertButton(-1, pResItem->Type, pResItem->CmdID,
					pResItem->Style, pDIBList->GetDIB(pResItem->DIBIndex), pResItem->pString);
			++pResItem;
		}
		if (m_WindowRect.cy == 0)
			Resize(m_WindowRect.cx, pDIBList->m_DIBList->m_PaintRect.cy, true);
		RecalcLayout();
		return true;
	}
	bool CWispToolbar::InsertButton(int Pos, unsigned int Type, unsigned int CmdID, unsigned int Style, CWispDIB *pDIB, const WCHAR *HelpString)
	{
		CWispButton *pButton = new CWispButton;
		pButton->CreateEx(pDIB, 0, 0, this, CmdID, Style | 0x1000040);
		pButton->Resize(pDIB->m_PixelBuf.Width + 4, pDIB->m_PixelBuf.Height + 4, true);
		pButton->SetOwner(m_OwnerWnd);
		pButton->EnableHelpTip(HelpString);
		pButton->m_AdvStyle |= 1;

		TListIter<WISP_TOOLBAR_ITEM> It;
		if (Pos < 0)
			It = m_BTList.Append();
		else	It = m_BTList.InsertBefore(m_BTList[Pos]);
		It->Type = Type;
		It->pItem = pButton;
		It->pDIB = pDIB;
		RecalcLayout();
		return true;
	}
	bool CWispToolbar::InsertEdit(int Pos, unsigned int Type, int Width, unsigned int CmdID, unsigned int Style, const WCHAR *HelpString)
	{
		CWispEdit *pEdit = new CWispEdit;
		pEdit->CreateWnd(0, 0,0,Width,m_ClientDC.m_pFont->m_Height + 2 * m_Margin, this, CmdID, Style, WISP_SH_MINSIZE);
		pEdit->SetOwner(m_OwnerWnd);
		pEdit->EnableHelpTip(HelpString);
		pEdit->m_AdvStyle |= 1;

		TListIter<WISP_TOOLBAR_ITEM> It;
		if (Pos < 0)
			It = m_BTList.Append();
		else	It = m_BTList.InsertBefore(m_BTList[Pos]);
		It->Type = Type;
		It->pItem = pEdit;
		It->pDIB = 0;
		RecalcLayout();
		return true;
	}
	bool CWispToolbar::InsertStaticDIB(int Pos, unsigned int Type, unsigned int CmdID, CWispDIB *pDIB)
	{
		CWispStaticDIB *pStaticDIB = new CWispStaticDIB;
		pStaticDIB->CreateEx(pDIB, 0, 0, this, CmdID);
		pStaticDIB->m_AdvStyle |= 1;

		TListIter<WISP_TOOLBAR_ITEM> It;
		if (Pos < 0)
			It = m_BTList.Append();
		else	It = m_BTList.InsertBefore(m_BTList[Pos]);
		It->Type = Type;
		It->pItem = pStaticDIB;
		It->pDIB = pDIB;
		RecalcLayout();
		return true;
	}
	bool CWispToolbar::InsertStaticStr(int Pos, unsigned int Type, unsigned int CmdID, const WCHAR *HelpString)
	{
		CWispStaticStr *pStaticStr = new CWispStaticStr;
		pStaticStr->Create(HelpString, 0,0,0,0, this, CmdID, 0xBB, 1);
		pStaticStr->m_AdvStyle |= 1;

		TListIter<WISP_TOOLBAR_ITEM> It;
		if (Pos < 0)
			It = m_BTList.Append();
		else	It = m_BTList.InsertBefore(m_BTList[Pos]);
		It->Type = Type;
		It->pItem = pStaticStr;
		It->pDIB = 0;
		int y = pStaticStr->m_WindowDC.m_pFont->m_Height;
		int x = m_WindowDC.GetTextExtent(HelpString, -1, 0);
		pStaticStr->Resize(x, y, true);
		RecalcLayout();
		return true;
	}
	bool CWispToolbar::InsertSeparator(int Pos, unsigned int Type)
	{
		TListIter<WISP_TOOLBAR_ITEM> It;
		if (Pos < 0)
			It = m_BTList.Append();
		else	It = m_BTList.InsertBefore(m_BTList[Pos]);
		It->Type = Type;
		It->pItem = 0;
		It->pDIB = 0;
		RecalcLayout();
		Update((WISP_RECT*)0);
		return true;
	}
	bool CWispToolbar::RemoveItem(int Pos) //???
	{
		return false; //???
	}
	bool CWispToolbar::Enable(unsigned int nID, bool bEnable)
	{
		CWispBaseWnd *pWnd = GetItem(nID);
		if (!pWnd)
			return false;
		pWnd->EnableWindow(bEnable);
		return true;
	}

```

`source/Wisp/wisptoolbar.hpp`:

```hpp

#ifndef _WISPTOOLBAR_HPP_
#define _WISPTOOLBAR_HPP_

#include "../Code/define.h"
#include "../Code/alt/altlist.hpp"
#include "wispwnd.hpp"
#include "wispdib.hpp"

	struct CWispButton;
	struct CWispEdit;
	struct CWispStaticDIB;
	struct CWispStaticStr;

#define WISP_TOOLBAR_SEPARATOR 0x10000
#define WISP_TOOLBAR_ALIGN 0x20000
#define WISP_TOOLBAR_BTN 0
#define WISP_TOOLBAR_EDIT 1
#define WISP_TOOLBAR_DIB 2
#define WISP_TOOLBAR_STR 4


struct WISP_TOOLBAR_RES_ITEM
{
	unsigned int CmdID;
	unsigned int DIBIndex;
	unsigned int Type;
	const WCHAR *pString;
	unsigned int Width;
	unsigned int Style;
};

struct WISP_TOOLBAR_ITEM
{
	union {
		CWispBaseWnd *pItem;
		CWispButton *pButton;
		CWispEdit *pEdit;
		CWispStaticDIB *pStaticDIB;
		CWispStaticStr *pStaticStr;
	};
	CWispDIB *pDIB;
	unsigned int Type;
};

struct CWispToolbar : public CWispWnd
{
	CWispToolbar();
	virtual ~CWispToolbar();

	TList<WISP_TOOLBAR_ITEM> m_BTList;
	CWispDIBList *m_pDIBList;
	int m_Margin;
	int m_SeparatorWidth;

	virtual void SetOwner(CWispBaseWnd *pOwnerWnd) override;
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnRecalcLayout(WISP_MSG *pMsg);
	bool OnResizeChild(WISP_MSG *pMsg);
	bool CreateEx(CWispWnd *pParentWnd, int y, int cy, unsigned int CmdID, unsigned int Style);
	CWispBaseWnd *GetItem(unsigned int CmdID);
	bool LoadToolbar(CWispDIBList *pDIBList, WISP_TOOLBAR_RES_ITEM *pResItem);
	bool InsertButton(int Pos, unsigned int Type, unsigned int CmdID, unsigned int Style, CWispDIB *pDIB, const WCHAR *HelpString);
	bool InsertEdit(int Pos, unsigned int Type, int Width, unsigned int CmdID, unsigned int Style, const WCHAR *HelpString);
	bool InsertStaticDIB(int Pos, unsigned int Type, unsigned int CmdID, CWispDIB *pDIB);
	bool InsertStaticStr(int Pos, unsigned int Type, unsigned int CmdID, const WCHAR *HelpString);
	bool InsertSeparator(int Pos, unsigned int Type);
	bool RemoveItem(int Pos);
	bool Enable(unsigned int nID, bool bEnable);
};

#endif
```

`source/Wisp/wispwnd.cpp`:

```cpp

#include "../Code/define.h"
//#include "../Code/osdefine.hpp"
#include "wispwnd.hpp"
#include "wispbase.hpp"
#include "wisptipwnd.hpp"

	struct SCROLL_AREA
	{
		unsigned int PageDec;	//BTDec
		unsigned int PageInc;	//BTInc
		unsigned int Slide;	//Thumb
		unsigned int Track;
		unsigned int None;
	};

	SCROLL_AREA Scroll_NUM[WISP_SCROLL_BAR_COUNT] = {
			{   1,    2,    3,    4,    5},
			{0x11, 0x12, 0x13, 0x14, 0x15} }; //0x10 |

	struct SCROLL_WM
	{
		unsigned int PageDec;	//BTDec
		unsigned int PageInc;	//BTInc
		unsigned int SLIDE;
		unsigned int BTDec;
		unsigned int BTInc;
	};


	SCROLL_WM Scroll_WM[WISP_SCROLL_BAR_COUNT] = 

{ { WISP_ID_VPAGE_DEC, WISP_ID_VPAGE_INC, WISP_ID_VSPIN_SCROLL, WISP_ID_VSPIN_DEC, WISP_ID_VSPIN_INC },
  { WISP_ID_HPAGE_DEC, WISP_ID_HPAGE_INC, WISP_ID_HSPIN_SCROLL, WISP_ID_HSPIN_DEC, WISP_ID_HSPIN_INC } };

	bool CWispWnd::OnCmdClose(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002) //WISP_ID_KEYUP
		{
			WISP_MSG Msg;
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_CLOSE;
			return m_pWispBase->SendMessage(&Msg) == 0;
		}
		return true;
	}
	bool CWispWnd::OnCmdMax(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002) //WISP_ID_KEYUP
		{
			if (m_State & 8) //WISP_WSTATE_MINIMIZE
			{
				return true; //???
			}
			
			if (m_State & 4) //WISP_WSTATE_MAXIMIZE
			{
				MoveToScreen(m_NormalRect.x, m_NormalRect.y, true);
				Resize(m_NormalRect.cx, m_NormalRect.cy, true);
				m_State &= ~4; //~WISP_WSTATE_MAXIMIZE
				Update((WISP_RECT*)0);
				return true;
			}

			if (m_ParentWnd)
			{
				m_NormalRect = m_ScrWindowRect;
				MoveToWindow(0, 0, true);
				Resize(
					((CWispWnd*)m_ParentWnd)->m_ClientRect.cx,
					((CWispWnd*)m_ParentWnd)->m_ClientRect.cy, true);
				m_State |= 4; //WISP_WSTATE_MAXIMIZE
				Update((WISP_RECT*)0);
			}
			
		}
		return true;
	}
	bool CWispWnd::OnCmdMin(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002) //WISP_ID_KEYUP
		{
			if (m_State & 4) //WISP_WSTATE_MAXIMIZE
			{
				return true; //???
			}
			
			if (m_State & 8) //WISP_WSTATE_MINIMIZE
			{
				Resize(m_NormalRect.cx, m_NormalRect.cy, true);
				m_State &= ~8; //~WISP_WSTATE_MINIMIZE
				Update((WISP_RECT*)0);
				return true;
			}

			m_NormalRect = m_ScrWindowRect;
			Resize(m_MinWndSize.cx, m_MinWndSize.cy, true);
			m_State |= 8; //WISP_WSTATE_MINIMIZE
			Update((WISP_RECT*)0);
		}
		return true;
	}
	bool CWispWnd::OnCmdScrollBarDrag(WISP_MSG *pMsg)
	{
		int type = pMsg->Command.Param1;

		if (pMsg->Command.CmdMsg == 0x80000001) //WISP_ID_KEYDOWN
		{
			if (m_pScrollBar[type]->Style & 2)
				m_pScrollBar[type]->DragPos = m_pScrollBar[type]->CurPos;
			m_pScrollBar[type]->State = 2;
			m_pWispBase->BeginDrag();
		} else
		if (pMsg->Command.CmdMsg == 0x80000002) //WISP_ID_KEYUP
		{
			if (m_pScrollBar[type]->Style & 2)
			{
				WISP_MSG Msg;
				Msg.hWnd = this;
				Msg.Msg = WISP_WM_SCROLL_EVENT;
				Msg.ScrollEvent.Event = WISP_SB_POS_CHANGE;
				Msg.ScrollEvent.Type = type;
				Msg.ScrollEvent.CurPos = m_pScrollBar[type]->CurPos;
				Msg.ScrollEvent.Delta = m_pScrollBar[type]->CurPos - m_pScrollBar[type]->DragPos;
				m_pWispBase->SendMessage(&Msg);
			}
			m_pScrollBar[type]->State = 0;
			m_pWispBase->EndDrag();
		}
		return true;
	}

	CWispWnd::CWispWnd()
	{
		ClearBGColor();
		
		m_pBKDIB = 0;
		m_CtrlType = WISP_CTRL_WND;
	}

	CWispWnd::~CWispWnd()
	{
	}

	unsigned int CWispWnd::IsPointInCaptionBT(WISP_POINT & ScrMousePT)
	{
		if (!PtInRect(&m_ScrCaptionRect, ScrMousePT))
			return 0;

		WISP_POINT pt = ScrMousePT;

		//CAPTION
		if (m_Style & 1)
		{
			PointToRect(&pt, &m_ScrCaptionRect);
			if (m_Style & 0x08 && PtInRect(&m_CloseBTRect, &pt))
				return WISP_ID_CLOSE;
			if (m_Style & 0x10 && PtInRect(&m_MaxBTRect, &pt))
				return WISP_ID_MAX;
			if (m_Style & 0x20 && PtInRect(&m_MinBTRect, &pt))
				return WISP_ID_MIN;
		}
		return 0;
	}
	bool CWispWnd::OnHitTest(WISP_MSG *pMsg)
	{
		if ((m_Style & 0x80) && m_State == WISP_WSTATE_RESET) //???
		{
			WISP_POINT WndPT = pMsg->MsgMouseScrPT;
			PointToRect(&WndPT, &m_ScrWindowRect);

			int v3 = m_BorderSize + m_pWispBase->m_Metrics[WISP_SM_RESIZE_SIZE];
			if (WndPT.x < v3 && WndPT.y < v3)
			{
				pMsg->HitTest.HitArea.Type = WISP_HT_TOPLEFT; //0x50000;
				return true;
			}
			if (WndPT.x > m_WindowRect.cx - v3 && WndPT.y < v3)
			{
				pMsg->HitTest.HitArea.Type = WISP_HT_TOPRIGHT; //0x60000;
				return true;
			}
			if (WndPT.x < v3 && WndPT.y > m_WindowRect.cy - v3)
			{
				pMsg->HitTest.HitArea.Type = WISP_HT_BOTTOMLEFT; //0x90000;
				return true;
			}
			if (WndPT.x > m_WindowRect.cx - v3 && WndPT.y > m_WindowRect.cy - v3)
			{
				pMsg->HitTest.HitArea.Type = WISP_HT_BOTTOMRIGHT; //0xA0000;
				return true;
			}
			if (WndPT.x < m_BorderSize)
				pMsg->HitTest.HitArea.Type |= WISP_HT_LEFT; //0x10000;
			if (WndPT.y < m_BorderSize)
				pMsg->HitTest.HitArea.Type |= WISP_HT_TOP; //0x40000;
			if (WndPT.x > m_WindowRect.cx - m_BorderSize)
				pMsg->HitTest.HitArea.Type |= WISP_HT_RIGHT; //0x20000;
			if (WndPT.y > m_WindowRect.cy - m_BorderSize)
				pMsg->HitTest.HitArea.Type |= WISP_HT_BOTTOM; //0x80000;

			if (pMsg->HitTest.HitArea.Type)
				return true;
		}

		if ( !(m_Style & 1) || !PtInRect(&m_ScrCaptionRect, &pMsg->MsgMouseScrPT))
		{
			int n = 0;
			int result;
			while (n < 2)
			{
				if (m_pScrollBar[n] && !m_pScrollBar[n]->bHide &&
					PtInRect(&m_pScrollBar[n]->BarRect, &pMsg->MsgMouseWndPT))
				{
					pMsg->HitTest.HitArea.Type = 3;
					if (PtInRect(&m_pScrollBar[n]->SlideRect, &pMsg->MsgMouseWndPT))
					{
						pMsg->HitTest.HitArea.State = Scroll_NUM[n].Slide;
						result = 1;
					} else
					if (PtInRect(&m_pScrollBar[n]->TrackRect, &pMsg->MsgMouseWndPT))
					{
						pMsg->HitTest.HitArea.State = Scroll_NUM[n].Track;
						result = 1;
					} else
					if (PtInRect(&m_pScrollBar[n]->PageIncRect, &pMsg->MsgMouseWndPT))
					{
						pMsg->HitTest.HitArea.State = Scroll_NUM[n].PageInc;
						result = 1;
					} else
					if (PtInRect(&m_pScrollBar[n]->PageDecRect, &pMsg->MsgMouseWndPT))
					{
						pMsg->HitTest.HitArea.State = Scroll_NUM[n].PageDec;
						result = 1;
					} else
					{
						pMsg->HitTest.HitArea.State = Scroll_NUM[n].None;
						result = 1;
					}
					return result;
				}
				++n;
			};

			if (PtInRect(&m_ScrClientRect, &pMsg->MsgMouseScrPT))
			{
				pMsg->HitTest.HitArea.Type = 1;
				return true;
			}

			if ( pMsg->MsgMouseScrPT.x > m_ClientRect.x2() ||
			     pMsg->MsgMouseScrPT.y > m_ClientRect.y2() )
			{
				pMsg->HitTest.HitArea.Type = 3;
			}
			return true;
		}

		//CAPTION

		if (!pMsg->HitTest.bKeyDown)
		{
			pMsg->HitTest.HitArea.Type = 2;
			return true;
		}

		unsigned int CapBTID = IsPointInCaptionBT(pMsg->MsgMouseScrPT);
		if (CapBTID == WISP_ID_CLOSE)
		{
			pMsg->HitTest.HitArea.Type = 4;
			m_CloseBTState = 2;
		} else
		if (CapBTID == WISP_ID_MAX)
		{
			pMsg->HitTest.HitArea.Type = 5;
			m_MaxBTState = 2;
		} else
		if (CapBTID == WISP_ID_MIN)
		{
			pMsg->HitTest.HitArea.Type = 6;
			m_MinBTState = 2;
		} else
		{
			pMsg->HitTest.HitArea.Type = 2;
			return true;
		}

		Update(&m_CaptionRect);

		WISP_MSG Msg;
		Msg.hWnd = this;
		Msg.Msg = WISP_WM_COMMAND;
		Msg.Command.CtrlType = 1;
		Msg.Command.CmdMsg = 0x80000001; //WISP_ID_KEYDOWN
		Msg.Command.CmdID = CapBTID;
		m_pWispBase->SendMessage(&Msg);
		return true;
	}

	bool CWispWnd::OnSizing(WISP_MSG *pMsg)		//?????
	{
		if (m_pWispBase->m_pRootWnd == this)
		{
			m_pWispBase->m_Metrics[WISP_SM_SCREEN_CX] = pMsg->Sizing.Size.cx;
			m_pWispBase->m_Metrics[WISP_SM_SCREEN_CY] = pMsg->Sizing.Size.cy;

			if (!m_pWispBase->BeginResize(pMsg->Sizing.Size.cx, pMsg->Sizing.Size.cy))
				return false;
		}

		return pMsg->Sizing.Size.cx >= m_MinWndSize.cx && pMsg->Sizing.Size.cy >= m_MinWndSize.cy;
	}
	bool CWispWnd::OnMoving(WISP_MSG *pMsg)
	{
		if (m_pWispBase->m_pRootWnd == this)
		{
			m_pWispBase->m_MousePT.x -= pMsg->Move.DeltaX;
			m_pWispBase->m_MousePT.y -= pMsg->Move.DeltaY;
			m_pWispBase->m_PrevMousePT.x -= pMsg->Move.DeltaX;
			m_pWispBase->m_PrevMousePT.y -= pMsg->Move.DeltaY;
			m_pWispBase->MovingFrame(pMsg->Move.DeltaX, pMsg->Move.DeltaY);
			return false;
		}
		return true;
	}
	void CWispWnd::CalcVertScrollSlideWithPos()
	{
		if (m_pScrollBar[0])
		{
			m_pScrollBar[0]->PageDecRect.cy = m_pScrollBar[0]->BarSize;
			m_pScrollBar[0]->PageDecRect.cx = m_pScrollBar[0]->PageDecRect.cy;
			m_pScrollBar[0]->PageIncRect.cy = m_pScrollBar[0]->PageDecRect.cx;
			m_pScrollBar[0]->PageIncRect.cx = m_pScrollBar[0]->PageIncRect.cy;
			m_pScrollBar[0]->BarRect.x = m_ClientRect.cx + m_ClientRect.x;
			m_pScrollBar[0]->PageIncRect.x = m_pScrollBar[0]->BarRect.x;
			m_pScrollBar[0]->PageDecRect.x = m_pScrollBar[0]->PageIncRect.x;
			m_pScrollBar[0]->BarRect.y = m_ClientRect.y;
			m_pScrollBar[0]->PageIncRect.y = m_pScrollBar[0]->BarRect.y;
			m_pScrollBar[0]->BarRect.cx = m_pScrollBar[0]->BarSize;
			m_pScrollBar[0]->BarRect.cy = m_ClientRect.cy;
			m_pScrollBar[0]->PageDecRect.y = m_pScrollBar[0]->BarRect.y
                                         + m_pScrollBar[0]->BarRect.cy
                                         - m_pScrollBar[0]->PageDecRect.cy;

			m_pScrollBar[0]->TrackRect.x = m_ClientRect.cx + m_ClientRect.x;
			m_pScrollBar[0]->TrackRect.y = m_ClientRect.y + m_pScrollBar[0]->BarSize;
			m_pScrollBar[0]->TrackRect.cx = m_pScrollBar[0]->BarSize;
			m_pScrollBar[0]->TrackRect.cy = m_ClientRect.cy - 2 * m_pScrollBar[0]->BarSize;

			m_pScrollBar[0]->SlideRect.x = m_pScrollBar[0]->TrackRect.x + 1;
			m_pScrollBar[0]->SlideRect.cx = m_pScrollBar[0]->TrackRect.cx - 2;
			m_pScrollBar[0]->SlideRect.y = m_pScrollBar[0]->TrackRect.y;
			m_pScrollBar[0]->SlideRect.cy = m_pScrollBar[0]->TrackRect.cy;

			if (m_pScrollBar[0]->MaxPos == m_pScrollBar[0]->MinPos)
			{
				m_pScrollBar[0]->SlideRect.cx = 0;
				m_pScrollBar[0]->SlideRect.cy = 0;
			} else
			{
				m_pScrollBar[0]->SlideRect.cy = m_pScrollBar[0]->SlideRect.cy * m_pScrollBar[0]->AdjustPage
						/ (m_pScrollBar[0]->MaxPos - m_pScrollBar[0]->MinPos);

				MIN_LIMIT(m_pScrollBar[0]->SlideRect.cy, 8);
				MAX_LIMIT(m_pScrollBar[0]->SlideRect.cy, m_pScrollBar[0]->TrackRect.cy);

				if (m_pScrollBar[0]->CurPos == m_pScrollBar[0]->MaxPos - m_pScrollBar[0]->AdjustPage)
					m_pScrollBar[0]->SlideRect.y += m_pScrollBar[0]->TrackRect.cy - m_pScrollBar[0]->SlideRect.cy;
				else
					m_pScrollBar[0]->SlideRect.y += m_pScrollBar[0]->CurPos * m_pScrollBar[0]->TrackRect.cy
					/ (m_pScrollBar[0]->MaxPos - m_pScrollBar[0]->MinPos);

				if (m_pScrollBar[0]->SlideRect.y + m_pScrollBar[0]->SlideRect.cy > m_pScrollBar[0]->TrackRect.y + m_pScrollBar[0]->TrackRect.cy)
					m_pScrollBar[0]->SlideRect.y = m_pScrollBar[0]->TrackRect.y + m_pScrollBar[0]->TrackRect.cy - m_pScrollBar[0]->SlideRect.cy;
			}
		}

	}
	void CWispWnd::CalcHorzScrollSlideWithPos()
	{
		if (m_pScrollBar[1])
		{
			m_pScrollBar[1]->PageIncRect.cy = m_pScrollBar[1]->BarSize;
			m_pScrollBar[1]->PageIncRect.cx = m_pScrollBar[1]->PageIncRect.cy;
			m_pScrollBar[1]->PageDecRect.cy = m_pScrollBar[1]->PageIncRect.cx;
			m_pScrollBar[1]->PageDecRect.cx = m_pScrollBar[1]->PageDecRect.cy;
			m_pScrollBar[1]->BarRect.x = m_ClientRect.x;
			m_pScrollBar[1]->PageIncRect.x = m_pScrollBar[1]->BarRect.x;
			m_pScrollBar[1]->PageDecRect.x = m_pScrollBar[1]->BarRect.x
                                         + m_pScrollBar[1]->BarRect.cx
                                         - m_pScrollBar[1]->PageDecRect.cx;
			m_pScrollBar[1]->BarRect.y = m_ClientRect.cy + m_ClientRect.y;
			m_pScrollBar[1]->PageIncRect.y = m_pScrollBar[1]->BarRect.y;
			m_pScrollBar[1]->PageDecRect.y = m_pScrollBar[1]->PageIncRect.y;
			m_pScrollBar[1]->BarRect.cx = m_ClientRect.cx;
			m_pScrollBar[1]->BarRect.cy = m_pScrollBar[1]->BarSize;

			m_pScrollBar[1]->TrackRect.x = m_ClientRect.x + m_pScrollBar[1]->BarSize;
			m_pScrollBar[1]->TrackRect.y = m_ClientRect.cy + m_ClientRect.y;
			m_pScrollBar[1]->TrackRect.cx = m_ClientRect.cx - 2 * m_pScrollBar[1]->BarSize;
			m_pScrollBar[1]->TrackRect.cy = m_pScrollBar[1]->BarSize;

			m_pScrollBar[1]->SlideRect.x = m_pScrollBar[1]->TrackRect.x;
			m_pScrollBar[1]->SlideRect.cx = m_pScrollBar[1]->TrackRect.cx;
			m_pScrollBar[1]->SlideRect.y = m_pScrollBar[1]->TrackRect.y + 1;
			m_pScrollBar[1]->SlideRect.cy = m_pScrollBar[1]->TrackRect.cy - 2;

			if (m_pScrollBar[1]->MaxPos == m_pScrollBar[1]->MinPos)
			{
				m_pScrollBar[1]->SlideRect.cx = 0;
				m_pScrollBar[1]->SlideRect.cy = 0;
			} else
			{
				m_pScrollBar[1]->SlideRect.cx = m_pScrollBar[1]->SlideRect.cx * m_pScrollBar[1]->AdjustPage
					/ (m_pScrollBar[1]->MaxPos - m_pScrollBar[1]->MinPos);

				MIN_LIMIT(m_pScrollBar[1]->SlideRect.cx, 8);
				MAX_LIMIT(m_pScrollBar[1]->SlideRect.cx, m_pScrollBar[1]->TrackRect.cx);

				if (m_pScrollBar[1]->CurPos == m_pScrollBar[1]->MaxPos - m_pScrollBar[1]->AdjustPage)
					m_pScrollBar[1]->SlideRect.x += m_pScrollBar[1]->TrackRect.cx - m_pScrollBar[1]->SlideRect.cx;
				else
					m_pScrollBar[1]->SlideRect.x += m_pScrollBar[1]->CurPos * m_pScrollBar[1]->TrackRect.cx
                                            / (m_pScrollBar[1]->MaxPos - m_pScrollBar[1]->MinPos);

				if (m_pScrollBar[1]->SlideRect.x + m_pScrollBar[1]->SlideRect.cx > m_pScrollBar[1]->TrackRect.x + m_pScrollBar[1]->TrackRect.cx)
					m_pScrollBar[1]->SlideRect.x = m_pScrollBar[1]->TrackRect.x + m_pScrollBar[1]->TrackRect.cx - m_pScrollBar[1]->SlideRect.cx;
			}
		}
	}
	void CWispWnd::ProcessScrollBTSpinKey(int Type, WISP_MSG *pMsg)
	{

		if (pMsg->MouseEvent.HitArea.State == Scroll_NUM[Type].PageInc)
		{
			if (!m_pScrollBar[Type]->BTSpinDecState)
				m_pScrollBar[Type]->BTSpinDecState = 1;
		} else
		{
			if (m_pScrollBar[Type]->BTSpinDecState)
			{
				m_pScrollBar[Type]->BTSpinDecState = 0;
				if (m_pWispBase->m_RepKeyIndex == 1)	//VK_LBUTTON
					m_pWispBase->StopMouseKeyRep();
			}
		}
		Update(&m_pScrollBar[Type]->BarRect);

		if (pMsg->MouseEvent.HitArea.State == Scroll_NUM[Type].PageDec)
		{
			if (!m_pScrollBar[Type]->BTSpinIncState)
				m_pScrollBar[Type]->BTSpinIncState = 1;

		} else
		{
			if (m_pScrollBar[Type]->BTSpinIncState)
			{
				m_pScrollBar[Type]->BTSpinIncState = 0;
				if (m_pWispBase->m_RepKeyIndex == 1)	//VK_LBUTTON
					m_pWispBase->StopMouseKeyRep();
			}
		}
		Update(&m_pScrollBar[Type]->BarRect);

		if (!pMsg->bMsgLBTDown)
		{
			if (m_pWispBase->m_RepKeyIndex == 1)	//VK_LBUTTON
				m_pWispBase->StopMouseKeyRep();
		}
	}
	void CWispWnd::ProcessHorzScrollMouseMove(WISP_MSG *pMsg)
	{
		int v3;
		int v6;
		int v7;

		//??? check field_10

		v6 = pMsg->MouseEvent.DeltaX;
		v3 = pMsg->MsgMouseWndPT.x;
		if ( (v3 >= m_pScrollBar[1]->SlideRect.x + m_pScrollBar[1]->HotPos || v6 <= 0) &&
		     (v3 <= m_pScrollBar[1]->SlideRect.x + m_pScrollBar[1]->HotPos || v6 >= 0) )
		{
			WISP_MSG Msg;
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_SCROLL_EVENT;
			Msg.ScrollEvent.Event = WISP_SB_POS_CHANGE;
			Msg.ScrollEvent.Type = 1;	//HORZ
			m_pScrollBar[1]->SlideRect.x += v6;

			if (m_pScrollBar[1]->SlideRect.x2() < m_pScrollBar[1]->TrackRect.x2())
			{
				if (m_pScrollBar[1]->SlideRect.x >= m_pScrollBar[1]->TrackRect.x)
				{
					v7 = (m_pScrollBar[1]->MaxPos - m_pScrollBar[1]->MinPos)
						* (m_pScrollBar[1]->SlideRect.x - m_pScrollBar[1]->TrackRect.x)
						/ m_pScrollBar[1]->TrackRect.cx;
				} else
				{
					m_pScrollBar[1]->SlideRect.x = m_pScrollBar[1]->TrackRect.x;
					v7 = m_pScrollBar[1]->MinPos;
				}
			} else
			{
				m_pScrollBar[1]->SlideRect.x = m_pScrollBar[1]->TrackRect.x + m_pScrollBar[1]->TrackRect.cx - m_pScrollBar[1]->SlideRect.cx;
				v7 = m_pScrollBar[1]->MaxPos - m_pScrollBar[1]->AdjustPage;
			}

			if (m_pScrollBar[1]->Style & 2)
			{
				m_pScrollBar[1]->CurPos = v7;
				Update(&m_pScrollBar[1]->BarRect);
			} else
			{
				Msg.ScrollEvent.Delta = v7 - m_pScrollBar[1]->CurPos;
				m_pScrollBar[1]->CurPos = v7;
				Msg.ScrollEvent.CurPos = v7;
				m_pWispBase->SendMessage(&Msg);
				Update((WISP_RECT*)0);
			}
		}
	}
	void CWispWnd::ProcessVertScrollMouseMove(WISP_MSG *pMsg)
	{
		int v2;
		int v5;
		int v7;

		v2 = pMsg->MouseEvent.DeltaY;
		if (!v2)
			return;
		
		v5 = pMsg->MsgMouseWndPT.y;
		if ( (v5 >= m_pScrollBar[0]->SlideRect.y + m_pScrollBar[0]->HotPos || v2 <= 0) &&
		     (v5 <= m_pScrollBar[0]->SlideRect.y + m_pScrollBar[0]->HotPos || v2 >= 0) )
		{
			WISP_MSG Msg;
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_SCROLL_EVENT;
			Msg.ScrollEvent.Event = WISP_SB_POS_CHANGE;
			Msg.ScrollEvent.Type = 0;	//VERT
			m_pScrollBar[0]->SlideRect.y += v2;

			if (m_pScrollBar[0]->SlideRect.y2() < m_pScrollBar[0]->TrackRect.y2())
			{
				if (m_pScrollBar[0]->SlideRect.y >= m_pScrollBar[0]->TrackRect.y)
				{
					v7 = (m_pScrollBar[0]->MaxPos - m_pScrollBar[0]->MinPos)
						* (m_pScrollBar[0]->SlideRect.y - m_pScrollBar[0]->TrackRect.y)
						/ m_pScrollBar[0]->TrackRect.cy;
				} else
				{
					m_pScrollBar[0]->SlideRect.y = m_pScrollBar[0]->TrackRect.y;
					v7 = m_pScrollBar[0]->MinPos;
				}
			} else
			{
				m_pScrollBar[0]->SlideRect.y = m_pScrollBar[0]->TrackRect.y + m_pScrollBar[0]->TrackRect.cy - m_pScrollBar[0]->SlideRect.cy;
				v7 = m_pScrollBar[0]->MaxPos - m_pScrollBar[0]->AdjustPage;
			}

			if (m_pScrollBar[0]->Style & 2)
			{
				m_pScrollBar[0]->CurPos = v7;
				Update(&m_pScrollBar[0]->BarRect);
			} else
			{
				Msg.ScrollEvent.Delta = v7 - m_pScrollBar[0]->CurPos;
				m_pScrollBar[0]->CurPos = v7;
				Msg.ScrollEvent.CurPos = v7;
				m_pWispBase->SendMessage(&Msg);
				Update((WISP_RECT*)0);
			}
		}
		
	}
	void CWispWnd::ProcessCaptionBTMouseMove(WISP_POINT & pPT)
	{
		WISP_POINT pt = pPT;

		PointToRect(&pt, &m_ScrCaptionRect);

		if (m_Style & 8)
		{
			if (PtInRect(&m_CloseBTRect, &pt))
			{
				if (!m_CloseBTState)
				{
					m_CloseBTState = 1;
					Update(&m_CaptionRect);
				}
			} else
			{
				if (m_CloseBTState)
				{
					m_CloseBTState = 0;
					Update(&m_CaptionRect);
				}
			}
		}

		if (m_Style & 0x10)
		{
			if (PtInRect(&m_MaxBTRect, &pt))
			{
				if (!m_MaxBTState)
				{
					m_MaxBTState = 1;
					Update(&m_CaptionRect);
				}
			} else
			{
				if (m_MaxBTState)
				{
					m_MaxBTState = 0;
					Update(&m_CaptionRect);
				}
			}
		}

		if (m_Style & 0x20)
		{
			if (PtInRect(&m_MinBTRect, &pt))
			{
				if (!m_MinBTState)
				{
					m_MinBTState = 1;
					Update(&m_CaptionRect);
				}
			} else
			{
				if (m_MinBTState)
				{
					m_MinBTState = 0;
					Update(&m_CaptionRect);
				}
			}
		}
	}
	bool CWispWnd::OnMouseMove(WISP_MSG *pMsg)
	{
		if (m_Style & 1)
			ProcessCaptionBTMouseMove(pMsg->MsgMouseScrPT);

		if (m_pScrollBar[0] && !m_pScrollBar[0]->bHide)
			ProcessScrollBTSpinKey(0, pMsg);

		if (m_pScrollBar[1] && !m_pScrollBar[1]->bHide)
			ProcessScrollBTSpinKey(1, pMsg);

		return true;
	}
	bool CWispWnd::OnMouseLeave(WISP_MSG *pMsg)
	{
		bool ret = true;

		if (m_Style & 1)
			ProcessCaptionBTMouseMove(pMsg->MsgMouseScrPT);

		if (m_pScrollBar[0] && !m_pScrollBar[0]->bHide)
		{
			ProcessScrollBTSpinKey(0, pMsg);
			if (m_pScrollBar[0]->State == 2)
				ret = 0;
		}
		if (m_pScrollBar[1] && !m_pScrollBar[1]->bHide)
		{
			ProcessScrollBTSpinKey(1, pMsg);
			if (m_pScrollBar[1]->State == 2)
				ret = 0;
		}
		return ret;
	}
	void CWispWnd::ProcessScrollMouseKey(int Type, WISP_MSG *Msg)
	{
		if (Msg->KeyEvent.bKeyDown)
		{
			WISP_MSG Msg1;

			if (Msg->KeyEvent.HitArea.State == Scroll_NUM[Type].PageInc)
			{
				Msg1.hWnd = this;
				Msg1.Msg = WISP_WM_COMMAND;
				Msg1.Command.CtrlType = 1;
				Msg1.Command.CmdMsg = 0x80000001; //WISP_ID_KEYDOWN
				Msg1.Command.CmdID = Scroll_WM[Type].BTDec;
				Msg1.Command.Param1 = Type;
				m_pWispBase->SendMessage(&Msg1);
			}

			if (Msg->KeyEvent.HitArea.State == Scroll_NUM[Type].PageDec)
			{
				Msg1.hWnd = this;
				Msg1.Msg = WISP_WM_COMMAND;
				Msg1.Command.CtrlType = 1;
				Msg1.Command.CmdMsg = 0x80000001; //WISP_ID_KEYDOWN
				Msg1.Command.CmdID = Scroll_WM[Type].BTInc;
				Msg1.Command.Param1 = Type;
				m_pWispBase->SendMessage(&Msg1);
			}

			if (m_pScrollBar[Type] && Msg->KeyEvent.HitArea.State == Scroll_NUM[Type].Track)
			{
				Msg1.hWnd = this;
				Msg1.Msg = WISP_WM_COMMAND;
				Msg1.Command.CtrlType = 1;

				if (Type == 0)
				{
					if (Msg->MsgMouseWndPT.y < m_pScrollBar[0]->SlideRect.y)
					{
						Msg1.Command.CmdMsg = 0x80000001; //WISP_ID_KEYDOWN
						Msg1.Command.CmdID = Scroll_WM[Type].PageDec;
						Msg1.Command.Param1 = Type;
						m_pWispBase->SendMessage(&Msg1);
					} else
					{
						Msg1.Command.CmdMsg = 0x80000001; //WISP_ID_KEYDOWN
						Msg1.Command.CmdID = Scroll_WM[Type].PageInc;
						Msg1.Command.Param1 = Type;
						m_pWispBase->SendMessage(&Msg1);
					}
				} else
				if (Type == 1)
				{
					if (Msg->MsgMouseWndPT.x < m_pScrollBar[1]->SlideRect.x)
					{
						Msg1.Command.CmdMsg = 0x80000001; //WISP_ID_KEYDOWN
						Msg1.Command.CmdID = Scroll_WM[Type].PageDec;
						Msg1.Command.Param1 = Type;
						m_pWispBase->SendMessage(&Msg1);
					} else
					{
						Msg1.Command.CmdMsg = 0x80000001; //WISP_ID_KEYDOWN
						Msg1.Command.CmdID = Scroll_WM[Type].PageInc;
						Msg1.Command.Param1 = Type;
						m_pWispBase->SendMessage(&Msg1);
					}
				} else	//WTF ???
				{

				}
			}

			if (m_pScrollBar[Type]->State != 2 && Msg->KeyEvent.HitArea.State == Scroll_NUM[Type].Slide)
			{
				if (Type == 0)
					m_pScrollBar[0]->HotPos = Msg->MsgMouseWndPT.y - m_pScrollBar[0]->SlideRect.y;
				if (Type == 1)
					m_pScrollBar[1]->HotPos = Msg->MsgMouseWndPT.x - m_pScrollBar[1]->SlideRect.x;

				Msg1.hWnd = this;
				Msg1.Msg = WISP_WM_COMMAND;
				Msg1.Command.CtrlType = 1;
				Msg1.Command.CmdMsg = 0x80000001; //WISP_ID_KEYDOWN
				Msg1.Command.CmdID = Scroll_WM[Type].SLIDE;
				Msg1.Command.Param1 = Type;
				m_pWispBase->SendMessage(&Msg1);
			}
			return;
		}

		if (Msg->KeyEvent.HitArea.State == Scroll_NUM[Type].PageInc)
		{
			m_pScrollBar[Type]->BTSpinDecState = 1;
			Update(&m_pScrollBar[Type]->BarRect);
		}

		if (Msg->KeyEvent.HitArea.State == Scroll_NUM[Type].PageDec)
		{
			m_pScrollBar[Type]->BTSpinIncState = 1;
			Update(&m_pScrollBar[Type]->BarRect);
		}

		if (m_pScrollBar[Type]->State == 2)
		{
			WISP_MSG Msg2;
			Msg2.hWnd = this;
			Msg2.Msg = WISP_WM_COMMAND;
			Msg2.Command.CtrlType = 1;
			Msg2.Command.CmdMsg = 0x80000002; //WISP_ID_KEYUP
			Msg2.Command.CmdID = Scroll_WM[Type].SLIDE;
			Msg2.Command.Param1 = Type;
			m_pWispBase->SendMessage(&Msg2);
		}
	}
	void CWispWnd::ProcessCaptionBTMouseKeyUp(WISP_POINT & ScrMousePT)
	{
		bool bSendCmd = false;
		unsigned int CapBTID = IsPointInCaptionBT(ScrMousePT);
		if (CapBTID == WISP_ID_CLOSE)
		{
			bSendCmd = m_CloseBTState == 2;
			m_CloseBTState = 1;
		} else
		if (CapBTID == WISP_ID_MAX)
		{
			bSendCmd = m_MaxBTState == 2;
			m_MaxBTState = 1;
		} else
		if (CapBTID == WISP_ID_MIN)
		{
			bSendCmd = m_MinBTState == 2;
			m_MinBTState = 1;
		} else
			return;

		Update(&m_CaptionRect);
		if (bSendCmd)
		{
			WISP_MSG Msg;
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_COMMAND;
			Msg.Command.CtrlType = 1;
			Msg.Command.CmdMsg = 0x80000002; //WISP_ID_KEYUP
			Msg.Command.CmdID = CapBTID;
			if (m_pWispBase->SendMessage(&Msg))
			{
				Msg.hWnd = this;
				Msg.Msg = WISP_WM_EVENT;
				m_pWispBase->SendMessage(&Msg);
			}
		}
	}
	bool CWispWnd::OnUpdate(WISP_MSG *pMsg)
	{
		if (!m_pUpdateRC)
			return true;

		WISP_MSG Msg;
		Msg.hWnd = this;

		//???
		if ( (m_Style & 0x100) == 0)
		{
			if (HasClipRect(m_pUpdateRC, &m_ClientRect))
			{
				Msg.Msg = WISP_WM_UPDATE_CLIENT;
				m_pWispBase->SendMessage(&Msg);
				if (m_Caret.bEnable)
				{
					Msg.Msg = WISP_WM_UPDATE_CARET;
					m_pWispBase->SendMessage(&Msg);
				}
			}

			if ((m_Style & 2) && m_BorderSize && HasClipRect(m_pUpdateRC, &m_WindowRect))
			{
				Msg.Msg = WISP_WM_UPDATE_BORDER;
				m_pWispBase->SendMessage(&Msg);
			}

			if (m_pScrollBar[1] && !m_pScrollBar[1]->bHide && HasClipRect(m_pUpdateRC, &m_pScrollBar[1]->BarRect))
			{
				Msg.Msg = WISP_WM_UPDATE_HORZ_SCROLL_BAR;
				m_pWispBase->SendMessage(&Msg);
			}

			if (m_pScrollBar[0] && !m_pScrollBar[0]->bHide && HasClipRect(m_pUpdateRC, &m_pScrollBar[0]->BarRect))
			{
				Msg.Msg = WISP_WM_UPDATE_VERT_SCROLL_BAR;
				m_pWispBase->SendMessage(&Msg);
			}

			if (m_pScrollBar[1] && m_pScrollBar[0])
			{
				WISP_RECT rc_v26;
				rc_v26.x = m_ClientRect.x2();
				rc_v26.y = m_ClientRect.y2();
				rc_v26.cx = m_WindowRect.cx - m_BorderSize - m_ClientRect.x2();
				rc_v26.cy = m_WindowRect.cy - m_BorderSize - m_ClientRect.y2();
				m_WindowDC.DrawFullRect(&rc_v26, m_pWispBase->m_pWispDrawObj->m_crSystem[28]);
			}

			if ((m_Style & 1) && HasClipRect(m_pUpdateRC, &m_CaptionRect))
			{
				Msg.Msg = WISP_WM_UPDATE_CAPTION;
				m_pWispBase->SendMessage(&Msg);
			}
		}

		for (CWispBaseWnd *pChildWnd = m_ChildWnd;
			pChildWnd;
			pChildWnd = pChildWnd->m_NextWnd)
		{
			if (pChildWnd->m_ShowMode != WISP_SH_HIDDEN)
			{
				if (pChildWnd->m_pUpdateRC &&
					HasClipRect(pChildWnd->m_pUpdateRC, &pChildWnd->m_WindowRect))
				{
					Msg.hWnd = pChildWnd;
					Msg.Msg = WISP_WM_UPDATE;
					m_pWispBase->SendMessage(&Msg);
					pChildWnd->m_pUpdateRC = 0;
				}
			}
		}
		m_pUpdateRC = 0;
		
		return true;
	}

	bool CWispWnd::OnUpdateClient(WISP_MSG *pMsg)
	{
		//???
		if ( !(m_Style & 0x40) )
		{
			if (m_pBKDIB)
				m_ClientDC.DrawDIBTiled(m_pBKDIB, 0);
			else
			if (m_bBGColor)
				m_WindowDC.DrawFullRect(&m_ClientRect, m_crBGColor);
			else
				m_pWispBase->m_pWispDrawObj->DrawClient(&m_WindowDC, &m_ClientRect);
		}
		return true;
	}
	bool CWispWnd::OnUpdateBorder(WISP_MSG *pMsg)
	{
		if (m_Style & 2)
		{
			m_pWispBase->m_pWispDrawObj->DrawBorder(&m_WindowDC, &m_WindowRect, m_BorderSize);
			return true;
		}
		return false;
	}
	bool CWispWnd::IsBlinkSlowTime(unsigned long BlinkTime)
	{
		//TODO
		return true;
	}
	bool CWispWnd::OnUpdateCaret(WISP_MSG *pMsg)
	{
		if (m_Caret.pDIB && IsBlinkSlowTime(m_Caret.BlinkTime) && m_pWispBase->m_pFocusWnd == this)
		{
			//m_ClientDC.DrawDIB(m_Caret.x, m_Caret.y, m_Caret.pDIB);
			m_ClientDC.DrawVLine(m_Caret.x + 0, m_Caret.y + 1,
					m_ClientDC.m_pFont->m_Height + m_Caret.y - 2, m_CaretColor);

			m_ClientDC.DrawVLine(m_Caret.x + 1, m_Caret.y + 1,
					m_ClientDC.m_pFont->m_Height + m_Caret.y - 2, m_CaretColor);
			return true;
		}
		return false;
	}
	bool CWispWnd::OnUpdateHorzScrollBar(WISP_MSG *pMsg)
	{
		m_pWispBase->m_pWispDrawObj->DrawHorzScrollRect(&m_WindowDC, &m_pScrollBar[1]->TrackRect);
		m_pWispBase->m_pWispDrawObj->DrawHorzScrollSlideRect(&m_WindowDC, &m_pScrollBar[1]->SlideRect);
		WISP_RECT rc;
		rc.x = m_ClientRect.x;
		rc.y = m_ClientRect.y + m_ClientRect.cy;
		rc.cx = m_pScrollBar[1]->BarSize;
		rc.cy = m_pScrollBar[1]->BarSize;
		m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(&m_WindowDC, &rc, WISP_SSI_HORZ_DEC_SPIN, m_pScrollBar[1]->BTSpinDecState);
		rc.x = m_ClientRect.x + m_ClientRect.cx - m_pScrollBar[1]->BarSize;
		m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(&m_WindowDC, &rc, WISP_SSI_HORZ_INC_SPIN, m_pScrollBar[1]->BTSpinIncState);
		return true;
	}
	bool CWispWnd::OnUpdateVertScrollBar(WISP_MSG *pMsg)
	{
		m_pWispBase->m_pWispDrawObj->DrawVertScrollRect(&m_WindowDC, &m_pScrollBar[0]->TrackRect);
		m_pWispBase->m_pWispDrawObj->DrawVertScrollSlideRect(&m_WindowDC, &m_pScrollBar[0]->SlideRect);
		WISP_RECT rc;
		rc.x = m_ClientRect.x + m_ClientRect.cx;
		rc.y = m_ClientRect.y;
		rc.cx = m_pScrollBar[0]->BarSize;
		rc.cy = m_pScrollBar[0]->BarSize;
		m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(&m_WindowDC, &rc, WISP_SSI_VERT_DEC_SPIN, m_pScrollBar[0]->BTSpinDecState);
		rc.y = m_ClientRect.y + m_ClientRect.cy - m_pScrollBar[0]->BarSize;
		m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(&m_WindowDC, &rc, WISP_SSI_VERT_INC_SPIN, m_pScrollBar[0]->BTSpinIncState);
		return true;
	}

	bool CWispWnd::CreateWnd(const WCHAR *Name, const CWispRect & pRC, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int Style, unsigned int ShowMode)
	{
		return CreateWnd(Name, pRC.x, pRC.y, pRC.cx, pRC.cy, pParentWnd, CmdID, Style, ShowMode);
	}

	bool CWispWnd::CreateWnd(const WCHAR *Name, int x, int y, int cx, int cy, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int Style, unsigned int ShowMode)
	{
		if (!CWispBaseWnd::Create(Name, x,y,cx,cy, pParentWnd, CmdID, Style | 0x8000, ShowMode))
			return false;

		if (!m_ClientDC.Create(this, &m_ScrClientRect))
			return false;

		if (!m_CaptionDC.Create(this, &m_ScrCaptionRect))
			return false;

		m_CaptionDC.SetTextColor(m_pWispBase->m_pWispDrawObj->m_crSystem[1]);

		if (!InitWnd())
			return false;

		RecalcLayout();
		m_State = WISP_WSTATE_RESET;

		WISP_MSG Msg;
		Msg.hWnd = this;
		Msg.Msg = WISP_WM_CREATING;
		if (!m_pWispBase->SendMessage(&Msg))
		{
			Destroy();
			return false;
		}

		Msg.Msg = WISP_WM_CREATE;
		if (!m_pWispBase->SendMessage(&Msg))
		{
			Destroy();
			return false;
		}
		Show(ShowMode);
		return true;
	}

	bool CWispWnd::Destroy()
	{
		if (!CWispBaseWnd::Destroy())
			return false;

		m_ClientDC.Destroy();
		m_CaptionDC.Destroy();

		SafeDelete(m_pScrollBar[0]);
		SafeDelete(m_pScrollBar[1]);

		if (m_AdvStyle & 1)	//WISP_ADV_AUTODEL
			delete this;

		return true;
	}

	bool CWispWnd::AttachBKDIB(CWispDIB *pDIB)
	{
		m_pBKDIB = pDIB;
		return true;
	}

	void CWispWnd::DetachBKDIB()
	{
		m_pBKDIB = 0;
	}

	bool CWispWnd::LoadBKDIB(const char *FileName)
	{
		m_pBKDIB = gpCurWisp->m_DIBLib.GetDIB(FileName, -1);
		return true;
	}

	bool CWispWnd::AttachTitleDIB(CWispDIB *pDIB)
	{
		m_pTitleDIB = pDIB;
		return true;
	}
	void CWispWnd::DetachTitleDIB()
	{
		m_pTitleDIB = 0;
	}
	bool CWispWnd::LoadTitleDIB(const char *FileName, int Index)
	{
		m_pTitleDIB = gpCurWisp->m_DIBLib.GetDIB(FileName, Index);
		return true;
	}
	bool CWispWnd::InitWnd()
	{
		if (!CWispBaseWnd::InitWnd())
			return false;

		m_MaxWndSize.cy = 0;
		m_MaxWndSize.cx = 0;
		m_bInResizeArea = 0;
		m_pScrollBar[1] = 0;
		m_pScrollBar[0] = 0;
		m_pBKDIB = 0;
		m_pTitleDIB = 0;
		m_Caret.y = 0;
		m_Caret.x = 0;
		m_Caret.bEnable = false;
		m_Caret.BlinkTime = 300;

		//4+2 TIP HELP
		if ( (m_Style & 6) == 6 )
			m_BorderSize = m_pWispBase->m_Metrics[WISP_SM_TIP_BORDER_SIZE];
		else
		if (m_Style & 2)
			m_BorderSize = m_pWispBase->m_Metrics[WISP_SM_BORDER_SIZE];
		else	m_BorderSize = 0;


		m_MinBTState = 0;
		m_MaxBTState = 0;
		m_CloseBTState = 0;
		m_CaretColor = m_pWispBase->m_pWispDrawObj->m_crSystem[1];

		return true;
	}
	bool CWispWnd::CreateCaret(unsigned int ID)
	{
		m_Caret.pDIB = m_pWispBase->GetDefDIB(ID);
		m_Caret.bEnable = false;
		return true;
	}
	bool CWispWnd::SetCaretPos(int PosX, int PosY)
	{
		m_Caret.x = PosX;
		m_Caret.y = PosY;
		return true;
	}
	bool CWispWnd::GetCaretPos(WISP_POINT *pPT)
	{
		pPT->x = m_Caret.x;
		pPT->y = m_Caret.y;
		return true;
	}
	void CWispWnd::ShowCaret(bool bShow)
	{
		if (m_Caret.bEnable != bShow)
			m_Caret.bEnable = bShow;
	}
	void CWispWnd::BlinkCaret(unsigned long BlinkTime)
	{
		m_Caret.BlinkTime = BlinkTime;
	}
	void CWispWnd::DestroyCaret() //???
	{
		m_Caret.pDIB = 0;
		m_Caret.bEnable = false;
	}
	void CWispWnd::UpdateScrollBarState(int Type)
	{
		if (m_pScrollBar[Type] && m_pScrollBar[Type]->Style & 1)
		{
			if (m_pScrollBar[Type]->MaxPos - m_pScrollBar[Type]->MinPos > m_pScrollBar[Type]->Page)
			{
				if (m_pScrollBar[Type]->bHide)
				{
					m_pScrollBar[Type]->bHide = 0;
					RecalcLayout();
				}
			} else
			if (!m_pScrollBar[Type]->bHide)
			{
				m_pScrollBar[Type]->bHide = 1;
				RecalcLayout();
			}
		}
	}
	bool CWispWnd::EnableScrollBar(int Type, bool bEnable, int Style)
	{
		if (bEnable)
		{
			if (m_pScrollBar[Type])
				return false;

			m_pScrollBar[Type] = new WISP_SCROLL_BAR;
			memset(m_pScrollBar[Type], 0, sizeof(WISP_SCROLL_BAR));
			m_pScrollBar[Type]->BarSize = m_pWispBase->GetMetrics(WISP_SM_SCROLL_BAR_SIZE);
			m_pScrollBar[Type]->bHide = 0;
			m_pScrollBar[Type]->State = 0;
			m_pScrollBar[Type]->BTSpinDecState = 0;
			m_pScrollBar[Type]->BTSpinIncState = 0;
			m_pScrollBar[Type]->Style = Style;
			m_pScrollBar[Type]->CurPos = 0;
			m_pScrollBar[Type]->MinPos = 0;
			m_pScrollBar[Type]->MaxPos = 0;
			m_pScrollBar[Type]->Page = 0;

			if (m_pWispBase->m_RepKeyIndex == 1)	//VK_LBUTTON
				m_pWispBase->StopMouseKeyRep();
		} else
		{
			if (!m_pScrollBar[Type])
				return false;
			SafeDelete(m_pScrollBar[Type]);
		}
		RecalcLayout();
		return true;
	}
	void CWispWnd::LimitScrollInfo(int Type, bool bSendEvent)
	{
		int v4 = m_pScrollBar[Type]->CurPos;

		MIN_LIMIT(m_pScrollBar[Type]->MaxPos, m_pScrollBar[Type]->MinPos);

		m_pScrollBar[Type]->AdjustPage = MIN(m_pScrollBar[Type]->MaxPos - m_pScrollBar[Type]->MinPos, m_pScrollBar[Type]->Page);

		MIN_LIMIT(m_pScrollBar[Type]->AdjustPage, 0);
		MAX_LIMIT(m_pScrollBar[Type]->CurPos, m_pScrollBar[Type]->MaxPos);
		MIN_LIMIT(m_pScrollBar[Type]->CurPos, m_pScrollBar[Type]->MinPos);
		MAX_LIMIT(m_pScrollBar[Type]->CurPos, m_pScrollBar[Type]->MaxPos - m_pScrollBar[Type]->AdjustPage);

		if (bSendEvent)
		{
			if (v4 != m_pScrollBar[Type]->CurPos)
			{
				WISP_MSG Msg;
				Msg.hWnd = this;
				Msg.Msg = WISP_WM_SCROLL_EVENT;
				Msg.ScrollEvent.Event = WISP_SB_POS_CHANGE;
				Msg.ScrollEvent.Type = Type;
				Msg.ScrollEvent.CurPos = m_pScrollBar[Type]->CurPos;
				Msg.ScrollEvent.Delta = m_pScrollBar[Type]->CurPos - v4;
				m_pWispBase->SendMessage(&Msg);
			}
		}
	}
	bool CWispWnd::BeginDrag()
	{
		if (m_pWispBase->m_pDragWnd == this)
			return false;
		m_pWispBase->m_pDragWnd = this;
		m_pWispBase->m_BeginPT = m_pWispBase->m_MousePT;
		PointToRect(&m_pWispBase->m_BeginPT, &m_ScrWindowRect);
		WISP_MSG Msg;
		Msg.hWnd = this;
		Msg.Msg = WISP_WM_DRAG_BEGIN;
		Msg.DragEvent.BeginMouseWndPT = m_pWispBase->m_BeginPT;
		m_pWispBase->SendMessage(&Msg);
		m_pWispBase->BeginDrag();
		return true;
	}
	void CWispWnd::EndDrag()
	{
		if (m_pWispBase->m_pDragWnd)
		{
			WISP_MSG Msg;
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_DRAG_END;
			Msg.DragEvent.BeginMouseWndPT = m_pWispBase->m_BeginPT;
			PointToRect(&Msg.DragEvent.BeginMouseWndPT, &m_WindowRect);
			m_pWispBase->SendMessage(&Msg);
			m_pWispBase->EndDrag();
			m_pWispBase->m_pDragWnd = 0;
		}
	}
	void CWispWnd::SendScrollEvent(int Type, int Event)
	{
		if (m_pScrollBar[Type])
		{
			WISP_MSG Msg;
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_SCROLL_EVENT;
			Msg.ScrollEvent.Event = Event;
			Msg.ScrollEvent.Type = Type;
			Msg.ScrollEvent.CurPos = m_pScrollBar[Type]->CurPos;
			Msg.ScrollEvent.Delta = 0;
			m_pWispBase->SendMessage(&Msg);
			Update((WISP_RECT*)0);
		}
	}
	bool CWispWnd::OnCreating(WISP_MSG *pMsg)
	{
		if (m_pWispBase->m_pRootWnd != this)
			return true;

		m_pWispBase->m_pTopMostRootWnd = new CWispWnd;
		m_pWispBase->m_pTopMostRootWnd->CreateWnd(0, m_WindowRect, this, WISP_ID_TOP_MOST_ROOT, 0x100, WISP_SH_MINSIZE);
		m_pWispBase->m_pTopMostRootWnd->m_AdvStyle |= 1; //WISP_ADV_AUTODEL

		m_pWispBase->m_pTipWnd = new CWispTipWnd;
		m_pWispBase->m_pTipWnd->CreateWnd(0, 0,0,0,0, 0, WISP_ID_HELP_TIP, 6, WISP_SH_HIDDEN);
		m_pWispBase->m_pTipWnd->m_AdvStyle |= 1; //WISP_ADV_AUTODEL
		return true;
	}
	bool CWispWnd::OnTimer(WISP_MSG *pMsg)
	{
		if (pMsg->Timer.ID == WISP_ID_CARET)
		{
			WISP_RECT Rect;
			Rect.x = m_Caret.x;
			Rect.y = m_Caret.y;
			WISP_RECT *OrgRc = m_pUpdateRC;
			Rect.cx = m_Caret.pDIB->m_PaintRect.cx;
			Rect.cy = m_Caret.pDIB->m_PaintRect.cy;
			m_pUpdateRC = &Rect;
			OnUpdateCaret(pMsg);
			Rect.y += m_ScrWindowRect.y;
			Rect.x += m_ScrWindowRect.x;
			m_pWispBase->EndDraw(&Rect);
			m_pUpdateRC = OrgRc;
		}
		return true;
	}
	bool CWispWnd::OnMouseWheel(WISP_MSG *pMsg)
	{
		if (pMsg->MouseEvent.Wheel >= 0)
			SendScrollEvent(0, WISP_SB_DEC);	//VertScrollLineUp()
		else	SendScrollEvent(0, WISP_SB_INC);	//VertScrollLineDown()

		return true;
	}
	bool CWispWnd::OnCmdPageDec(WISP_MSG *pMsg)
	{
		if (m_pScrollBar[pMsg->Command.Param1] && pMsg->Command.CmdMsg == 0x80000001) //WISP_ID_KEYDOWN
			SendScrollEvent(pMsg->Command.Param1, WISP_SB_PAGE_UP);	//PAGE UP
		return true;
	}
	bool CWispWnd::OnCmdPageInc(WISP_MSG *pMsg)
	{
		if (m_pScrollBar[pMsg->Command.Param1] && pMsg->Command.CmdMsg == 0x80000001) //WISP_ID_KEYDOWN
			SendScrollEvent(pMsg->Command.Param1, WISP_SB_PAGE_DOWN); //PAGE DOWN
		return true;
	}
	bool CWispWnd::OnCmdSpinInc(WISP_MSG *pMsg)
	{
		int type = pMsg->Command.Param1;

		if (!m_pScrollBar[type])
			return true;
		if (pMsg->Command.CmdMsg != 0x80000001) //WISP_ID_KEYDOWN
		{
			m_pScrollBar[type]->BTSpinIncState = 0;
			return true;
		}
		if (m_pScrollBar[type]->BTSpinIncState != 2)
		{
			m_pScrollBar[type]->BTSpinIncState = 2;
			m_pWispBase->StartMouseKeyRep(VK_LBUTTON);
		}
		SendScrollEvent(type, WISP_SB_INC);
		return true;
	}
	bool CWispWnd::OnCmdSpinDec(WISP_MSG *pMsg)
	{
		int type = pMsg->Command.Param1;

		if (!m_pScrollBar[type])
			return true;
		if (pMsg->Command.CmdMsg != 0x80000001) //WISP_ID_KEYDOWN
		{
			m_pScrollBar[type]->BTSpinDecState = 0;
			return true;
		}
		if (m_pScrollBar[type]->BTSpinDecState != 2)
		{
			m_pScrollBar[type]->BTSpinDecState = 2;
			m_pWispBase->StartMouseKeyRep(VK_LBUTTON);
		}
		SendScrollEvent(type, WISP_SB_DEC);
		return true;
	}
	bool CWispWnd::OnMove(WISP_MSG *pMsg)
	{
		if (m_Style & 1)
			ProcessCaptionBTMouseMove(pMsg->MsgMouseScrPT);
		return true;
	}
	bool CWispWnd::OnSize(WISP_MSG *pMsg)
	{
		if (m_pWispBase->m_pRootWnd == this)
		{
			//WISP_WSTATE_RESIZE
			if (m_State != 2 && !m_pWispBase->EndResize(m_ClientRect.cx, m_ClientRect.cy))
				return false;

			if (!m_pWispBase->m_pTopMostRootWnd->Resize(m_ClientRect.cx, m_ClientRect.cy, true))
				return false;
		}

		if (m_Style & 1)
			ProcessCaptionBTMouseMove(pMsg->MsgMouseScrPT);
		return true;

	}
	bool CWispWnd::OnHorzScrollMove(WISP_MSG *pMsg)
	{
		if (m_pScrollBar[1])
		{
			if (!m_pScrollBar[1]->bHide)
				ProcessScrollBTSpinKey(1, pMsg);
			ProcessHorzScrollMouseMove(pMsg);
		}
		return false;
	}
	bool CWispWnd::OnVertScrollMove(WISP_MSG *pMsg)
	{
		if (m_pScrollBar[0])
		{
			ProcessVertScrollMouseMove(pMsg);
		}
		return false;
	}

	void CWispWnd::CalcScrollSlideWithPos(int Type)
	{
		if (Type == 0)
			CalcVertScrollSlideWithPos();
		if (Type == 1)
			CalcHorzScrollSlideWithPos();
	}

	bool CWispWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		switch (pMsg->KeyEvent.KeyType)
		{
		case 0x40000025:	//WISP_SK_CTRL+VK_LEFT
				if (pMsg->KeyEvent.bKeyDown && m_pScrollBar[1] && !m_pScrollBar[1]->bHide)
				{
					SendScrollEvent(1, WISP_SB_DEC);	//HorzScrollLineUp()
					return false;
				}
				break;
		case 0x40000026:	//WISP_SK_CTRL+VK_UP
				if (pMsg->KeyEvent.bKeyDown && m_pScrollBar[0] && !m_pScrollBar[0]->bHide)
				{
					SendScrollEvent(0, WISP_SB_DEC);	//VertScrollLineUp()
					return false;
				}
				break;
		case 0x40000027:	//WISP_SK_CTRL+VK_RIGHT
				if (pMsg->KeyEvent.bKeyDown && m_pScrollBar[1] && !m_pScrollBar[1]->bHide)
				{
					SendScrollEvent(1, WISP_SB_INC);	//HorzScrollLineDown()
					return false;
				}
				break;
		case 0x40000028:   	//WISP_SK_CTRL+VK_DOWN
				if (pMsg->KeyEvent.bKeyDown && m_pScrollBar[0] && !m_pScrollBar[0]->bHide)
				{
					SendScrollEvent(0, WISP_SB_INC);	//VertScrollLineDown()
					return false;
				}
				break;

		case VK_LBUTTON:
			if (m_pScrollBar[0] && !m_pScrollBar[0]->bHide)
				ProcessScrollMouseKey(0, pMsg);
			if (m_pScrollBar[1] && !m_pScrollBar[1]->bHide)
				ProcessScrollMouseKey(1, pMsg);

			if (!pMsg->KeyEvent.bKeyDown)
			{
				ProcessCaptionBTMouseKeyUp(pMsg->MsgMouseScrPT);

				if (m_pScrollBar[0] && m_pScrollBar[0]->State == 2)
					m_pScrollBar[0]->State = 0;

				if (m_pScrollBar[1] && m_pScrollBar[1]->State == 2)
					m_pScrollBar[1]->State = 0;
			}
			break;
		case VK_PRIOR:
			if (pMsg->KeyEvent.bKeyDown)
				SendScrollEvent(0, WISP_SB_PAGE_UP);
			break;
		case VK_NEXT:
			if (pMsg->KeyEvent.bKeyDown)
				SendScrollEvent(0, WISP_SB_PAGE_DOWN);
			break;
		default:
			break;
		}
		return true;
	}
	bool CWispWnd::OnUpdateCaption(WISP_MSG *pMsg)
	{
		m_pWispBase->m_pWispDrawObj->DrawCaption(&m_WindowDC, &m_CaptionRect);
		int x = 2;
		if (m_pTitleDIB)
		{
			m_CaptionDC.DrawDIB(2, (m_CaptionRect.cy - m_pTitleDIB->m_PixelBuf.Height) / 2, m_pTitleDIB);
			x = m_pTitleDIB->m_PixelBuf.Width + 2;
		}

		if (m_WndText.m_nLength)
		{
			WISP_RECT Rect;
			Rect.x = x + m_CaptionDC.m_pFont->m_Width;
			Rect.y = (m_CaptionRect.cy - m_CaptionDC.m_pFont->m_Height) / 2;
			Rect.cx = m_CaptionRect.cx - 60;
			Rect.cy = 14;
			m_CaptionDC.DrawString(m_WndText.operator const WCHAR*(), &Rect, 0x8020, 0, -1);
		}

		if (m_Style & 8)
			m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(&m_CaptionDC, &m_CloseBTRect, 4, m_CloseBTState);

		if (m_Style & 0x10)
			m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(&m_CaptionDC, &m_MaxBTRect,
				((m_State & 4) | 0x18) >> 2, (m_State & 8) ? 3:m_MaxBTState); //WISP_WSTATE_MAXIMIZE WISP_WSTATE_MINIMIZE

		if (m_Style & 0x20)
			m_pWispBase->m_pWispDrawObj->DrawSystemStandardIcon(&m_CaptionDC, &m_MinBTRect,
				((m_State & 8) | 0x14) >> 2, (m_State & 4) ? 3:m_MinBTState);

		return true;
	}
	void CWispWnd::RecalcMinWndSize()
	{
		m_MinWndSize.cy = 0;
		m_MinWndSize.cx = 0;

		//CAPTION TEXT

		if (m_Style & 1)
		{
			m_MinWndSize.cy = m_pWispBase->m_Metrics[WISP_SM_CAPTION_CY];
			if (m_pTitleDIB)
				m_MinWndSize.cx = m_pTitleDIB->m_PaintRect.cx + m_CaptionDC.m_pFont->m_Width;

			if (m_WndText.m_nLength)
			{
				int len = m_CaptionDC.GetTextExtent(m_WndText.operator const WCHAR*(), -1, 0) + 20;
				MAX_LIMIT(len, 120);
				m_MinWndSize.cx += len + m_CaptionDC.m_pFont->m_Width;
			}
		}

		//BORDER

		if (m_Style & 2)
		{
			m_MinWndSize.cy += 2 * m_pWispBase->m_Metrics[WISP_SM_BORDER_SIZE];
			m_MinWndSize.cx += 2 * m_pWispBase->m_Metrics[WISP_SM_BORDER_SIZE];
		}

		//CAPTION BT

		if (m_Style & 8)	
			m_MinWndSize.cx += m_pWispBase->m_Metrics[WISP_SM_CAPTION_BT_SIZE];
		if (m_Style & 0x10)
			m_MinWndSize.cx += m_pWispBase->m_Metrics[WISP_SM_CAPTION_BT_SIZE];
		if (m_Style & 0x20)
			m_MinWndSize.cx += m_pWispBase->m_Metrics[WISP_SM_CAPTION_BT_SIZE];
	}
	void CWispWnd::RecalcLayout()
	{
		CWispBaseWnd::RecalcLayout();
		RecalcMinWndSize();

		m_ClientRect.y = 0;
		m_ClientRect.x = 0;
		m_ClientRect.cx = m_ScrWindowRect.cx;
		m_ClientRect.cy = m_ScrWindowRect.cy;

		//BORDER
		if (m_Style & 2)
		{
			m_ClientRect.x = m_BorderSize;
			m_ClientRect.y = m_BorderSize;
			m_ClientRect.cx = m_ScrWindowRect.cx - 2 * m_BorderSize;
			m_ClientRect.cy = m_ScrWindowRect.cy - 2 * m_BorderSize;
		}

		m_CaptionRect.x = m_ClientRect.x;
		m_CaptionRect.y = m_ClientRect.y;
		m_CaptionRect.cx = m_ClientRect.cx;
		m_CaptionRect.cy = 0;

		//CAPTION
		if (m_Style & 1)
		{
			m_ClientRect.y += m_pWispBase->m_Metrics[WISP_SM_CAPTION_CY];
			m_ClientRect.cy -= m_pWispBase->m_Metrics[WISP_SM_CAPTION_CY];

			m_CaptionRect.cy = m_pWispBase->m_Metrics[WISP_SM_CAPTION_CY];

			if (m_Style & 8) //BT_CLOSE
			{
				m_CloseBTRect.x = m_CaptionRect.cx - 17;
				m_CloseBTRect.y = (m_CaptionRect.cy - 16) / 2;
				m_CloseBTRect.cx = 16;
				m_CloseBTRect.cy = 16;
			}

			if (m_Style & 0x10) //BT_MAX
			{
				m_MaxBTRect.x = m_CaptionRect.cx - 17*2;
				m_MaxBTRect.y = (m_CaptionRect.cy - 16) / 2;
				m_MaxBTRect.cx = 16;
				m_MaxBTRect.cy = 16;
			}

			if (m_Style & 0x20) //BT_MIN
			{
				m_MinBTRect.x = m_CaptionRect.cx - 17*3;
				m_MinBTRect.y = (m_CaptionRect.cy - 16) / 2;
				m_MinBTRect.cx = 16;
				m_MinBTRect.cy = 16;
			}
		}

		if (m_pScrollBar[0] && !m_pScrollBar[0]->bHide)
			m_ClientRect.cx -= m_pScrollBar[0]->BarSize;

		if (m_pScrollBar[1] && !m_pScrollBar[1]->bHide)
			m_ClientRect.cy -= m_pScrollBar[1]->BarSize;

		if (m_pScrollBar[0])
			UpdateScrollBarState(0);
		if (m_pScrollBar[1])
			UpdateScrollBarState(1);

		CalcVertScrollSlideWithPos();
		CalcHorzScrollSlideWithPos();

		m_ScrClientRect.x = m_ClientRect.x;
		m_ScrClientRect.y = m_ClientRect.y;
		m_ScrClientRect.cx = m_ClientRect.cx;

		m_ScrCaptionRect.x = m_CaptionRect.x;
		m_ScrCaptionRect.y = m_CaptionRect.y;
		m_ScrCaptionRect.cx = m_CaptionRect.cx;

		m_ScrClientRect.cy = m_ClientRect.cy;
		m_ScrClientRect.x += m_ScrWindowRect.x;
		m_ScrClientRect.y += m_ScrWindowRect.y;

		m_ScrCaptionRect.cy = m_CaptionRect.cy;
		m_ScrCaptionRect.x += m_ScrWindowRect.x;
		m_ScrCaptionRect.y += m_ScrWindowRect.y;

		if (m_State != WISP_WSTATE_INIT)
		{
			WISP_MSG Msg;
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_RECALC_LAYOUT;
			m_pWispBase->SendMessage(&Msg);
		}
	}
	bool CWispWnd::SetWindowText(const WCHAR *Text)
	{
		if (m_Style & 0x20)
		{
			if (!CWispBaseWnd::SetWindowText(Text))
				return false;

			RecalcMinWndSize();
			return true;
		}
		return CWispBaseWnd::SetWindowText(Text);
	}
	void CWispWnd::SetScrollBarCurPos(int Type, int CurPos, bool bSendEvent)
	{
		if (m_pScrollBar[Type])
		{
			WISP_MSG Msg;
			Msg.hWnd = this;
			Msg.Msg = WISP_WM_SCROLL_EVENT;
			Msg.ScrollEvent.Event = WISP_SB_POS_CHANGE;
			Msg.ScrollEvent.Type = Type;
			int v6 = m_pScrollBar[Type]->CurPos;
			m_pScrollBar[Type]->CurPos = CurPos;
			LimitScrollInfo(Type, false);
			int Delta = m_pScrollBar[Type]->CurPos - v6;
			Msg.ScrollEvent.Delta = Delta;
			if (bSendEvent && Delta)
			{
				Msg.ScrollEvent.CurPos = m_pScrollBar[Type]->CurPos;
				m_pWispBase->SendMessage(&Msg);
			}
			CalcScrollSlideWithPos(Type);
			UpdateScrollBarState(Type);
			Update(&m_pScrollBar[Type]->BarRect);
		}

	}
	void CWispWnd::SetScrollBarRange(int Type, int MaxPos, int MinPos)
	{
		if (m_pScrollBar[Type])
		{
			m_pScrollBar[Type]->MaxPos = MaxPos;
			m_pScrollBar[Type]->MinPos = MinPos;
			LimitScrollInfo(Type, true);
			CalcScrollSlideWithPos(Type);
			UpdateScrollBarState(Type);
		}

	}
	void CWispWnd::SetScrollBarPage(int Type, int Page)
	{
		if (m_pScrollBar[Type])
		{
			m_pScrollBar[Type]->Page = Page;
			LimitScrollInfo(Type, true);
			CalcScrollSlideWithPos(Type);
			UpdateScrollBarState(Type);
		}
	}
	void CWispWnd::AdjustScrollBarMaxPos(int Type, int MaxPos)
	{
		if (m_pScrollBar[Type])
		{
			m_pScrollBar[Type]->MaxPos += MaxPos;
			LimitScrollInfo(Type, true);
			CalcScrollSlideWithPos(Type);
			UpdateScrollBarState(Type);
		}
	}

	WISP_CMD_MAP_BEGIN(CWispWnd)
		WISP_CMD_MAP(WISP_ID_VPAGE_DEC, OnCmdPageDec)
		WISP_CMD_MAP(WISP_ID_HPAGE_DEC, OnCmdPageDec)
		WISP_CMD_MAP(WISP_ID_VPAGE_INC, OnCmdPageInc)
		WISP_CMD_MAP(WISP_ID_HPAGE_INC, OnCmdPageInc)
		WISP_CMD_MAP(WISP_ID_VSPIN_SCROLL, OnCmdScrollBarDrag)
		WISP_CMD_MAP(WISP_ID_HSPIN_SCROLL, OnCmdScrollBarDrag)
		WISP_CMD_MAP(WISP_ID_VSPIN_DEC, OnCmdSpinDec)
		WISP_CMD_MAP(WISP_ID_HSPIN_DEC, OnCmdSpinDec)
		WISP_CMD_MAP(WISP_ID_VSPIN_INC, OnCmdSpinInc)
		WISP_CMD_MAP(WISP_ID_HSPIN_INC, OnCmdSpinInc)
		WISP_CMD_MAP(WISP_ID_CLOSE, OnCmdClose)
		WISP_CMD_MAP(WISP_ID_MAX, OnCmdMax)
		WISP_CMD_MAP(WISP_ID_MIN, OnCmdMin)
	WISP_CMD_MAP_END

	bool CWispWnd::OnScrollEvent(WISP_MSG *pMsg)
	{
		int type = pMsg->ScrollEvent.Type;

		int OldCurPos = m_pScrollBar[type]->CurPos;

		switch (pMsg->ScrollEvent.Event)
		{
		case WISP_SB_INC:
			++m_pScrollBar[type]->CurPos;
			LimitScrollInfo(type, false);
			pMsg->ScrollEvent.Delta = m_pScrollBar[type]->CurPos - OldCurPos;
			CalcScrollSlideWithPos(type);
			break;

		case WISP_SB_DEC:
			--m_pScrollBar[type]->CurPos;
			LimitScrollInfo(type, false);
			pMsg->ScrollEvent.Delta = m_pScrollBar[type]->CurPos - OldCurPos;
			CalcScrollSlideWithPos(type);
			break;

		case WISP_SB_PAGE_UP:
			m_pScrollBar[type]->CurPos -= m_pScrollBar[type]->AdjustPage;
			LimitScrollInfo(type, false);
			pMsg->ScrollEvent.Delta = m_pScrollBar[type]->CurPos - OldCurPos;
			CalcScrollSlideWithPos(type);
			break;

		case WISP_SB_PAGE_DOWN:
			m_pScrollBar[type]->CurPos += m_pScrollBar[type]->AdjustPage;
			LimitScrollInfo(type, false);
			pMsg->ScrollEvent.Delta = m_pScrollBar[type]->CurPos - OldCurPos;
			CalcScrollSlideWithPos(type);
			break;

		default: ;

		}
		Update((WISP_RECT*)0);
		return true;
	}
	void CWispWnd::SetScrollBarInfo(int Type, int CurPos, int Max, int Page, int Min, bool bSendEvent)
	{
		if (m_pScrollBar[Type])
		{
			m_pScrollBar[Type]->MaxPos = Max;
			m_pScrollBar[Type]->MinPos = Min;
			m_pScrollBar[Type]->Page = Page;
			SetScrollBarCurPos(Type, CurPos, bSendEvent);
		}
	}

	WISP_EVENT_MAP_BEGIN(CWispWnd)
	WISP_EVENT_MAP_END

	WISP_MSG_MAP_BEGIN(CWispWnd)
		WISP_MSG_MAP(WISP_WM_UPDATE_VERT_SCROLL_BAR, OnUpdateVertScrollBar)
		WISP_MSG_MAP(WISP_WM_UPDATE_HORZ_SCROLL_BAR, OnUpdateHorzScrollBar)
		WISP_MSG_MAP(WISP_WM_MOVE, OnMove)
		WISP_MSG_MAP(WISP_WM_MOVING, OnMoving)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_SIZING, OnSizing)
		WISP_MSG_MAP(WISP_WM_SCROLL_EVENT, OnScrollEvent)
		WISP_MSG_MAP(WISP_WM_VERT_SCROLL_MOVE, OnVertScrollMove)
		WISP_MSG_MAP(WISP_WM_HORZ_SCROLL_MOVE, OnHorzScrollMove)
		WISP_MSG_MAP(WISP_WM_TIMER_EVENT, OnTimer)
		WISP_MSG_MAP(WISP_WM_HIT_TEST, OnHitTest)
		WISP_MSG_MAP_ON_EVENT
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_UPDATE_BORDER, OnUpdateBorder)
		WISP_MSG_MAP(WISP_WM_UPDATE_CAPTION, OnUpdateCaption)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_UPDATE_CARET, OnUpdateCaret)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP(WISP_WM_MOUSE_MOVE, OnMouseMove)
		WISP_MSG_MAP(WISP_WM_CREATING, OnCreating)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_LEAVE, OnMouseLeave)
		WISP_MSG_MAP(WISP_WM_MOUSE_WHEEL, OnMouseWheel)
	WISP_MSG_MAP_END(CWispBaseWnd)


```

`source/Wisp/wispwnd.hpp`:

```hpp

#ifndef _WISPWND_HPP_
#define _WISPWND_HPP_

#include "../Code/define.h"
//#include "../Code/osdefine.hpp"
#include "utility.hpp"
#include "wispbasewnd.hpp"

	struct WISP_SCROLL_BAR
	{
		int MinPos;
		int MaxPos;
		int CurPos;
		int Page;
		int AdjustPage;
		int DragPos;

		unsigned int State;
		unsigned int Style;
		unsigned int BTSpinIncState;
		unsigned int BTSpinDecState;
		WISP_RECT BarRect;
		WISP_RECT TrackRect;
		WISP_RECT SlideRect;
		WISP_RECT PageIncRect;
		WISP_RECT PageDecRect;
		int BarSize;
		int HotPos;
		bool bHide;
	};

	struct WISP_WND_CARET
	{
		int x;
		int y;
		unsigned long BlinkTime;
		CWispDIB *pDIB;
		bool bEnable;
	};


	//METRIC
	//	0 caption cy
	//	1 border size
	//	2 tip border size
	//	3 resize width
	//	4 resize height
	//	5 min-max-close-button size

	struct CWispWnd : public CWispBaseWnd
	{
		WISP_RECT m_NormalRect;
		WISP_RECT m_ScrCaptionRect;
		WISP_RECT m_ScrClientRect;
		WISP_RECT m_CaptionRect;
		WISP_RECT m_ClientRect;
		WISP_RECT *m_pBarRect;
		int m_BarCount;
		WISP_SIZE m_MinWndSize;
		WISP_SIZE m_MaxWndSize;
		bool m_bInResizeArea;
		int m_BorderSize;
		WISP_WND_CARET m_Caret;
		CWispDC m_ClientDC;
		CWispDC m_CaptionDC;
		CWispDIB *m_pTitleDIB;
		CWispDIB *m_pBKDIB;
		unsigned long m_crBGColor;
		unsigned long m_CaretColor;
		bool m_bBGColor;
		int m_SignResizeX;
		int m_SignResizeY;
		int m_SignResizeDX;
		int m_SignResizeDY;
		int m_CloseBTState;
		int m_MaxBTState;
		int m_MinBTState;
		WISP_RECT m_CloseBTRect;
		WISP_RECT m_MaxBTRect;
		WISP_RECT m_MinBTRect;
		WISP_SCROLL_BAR *m_pScrollBar[2];

	public:
		CWispWnd();
		virtual ~CWispWnd();

		//	virtual bool Create(const WCHAR *Name, int x, int y, int cx, int cy, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int Style, unsigned int ShowMode);

	//	virtual bool Destroy();
	//	virtual void RecalcLayout();
	//	virtual bool InitWnd();

		//	virtual void SetOwner(CWispBaseWnd *pOwnerWnd);

	//	virtual void SetWindowText(const WCHAR *pString);

		//	virtual TWideString & GetWindowText();
		//	virtual void Update(const WISP_RECT *pRect);
		//	virtual bool IsRect(WISP_POINT *pPT);
		//	virtual void Hide();
		//	virtual void Show();

		virtual bool MsgProc(WISP_MSG *pMsg) override;

		bool OnMouseMove(WISP_MSG *pMsg);
		bool OnMouseLeave(WISP_MSG *pMsg);
		bool OnKeyEvent(WISP_MSG *pMsg);
		bool OnUpdate(WISP_MSG *pMsg);
		bool OnUpdateClient(WISP_MSG *pMsg);
		bool OnUpdateCaption(WISP_MSG *pMsg);
		bool OnUpdateBorder(WISP_MSG *pMsg);
		bool IsBlinkSlowTime(unsigned long BlinkTime);
		bool OnUpdateCaret(WISP_MSG *pMsg);
		bool OnUpdateHorzScrollBar(WISP_MSG *pMsg);
		bool OnUpdateVertScrollBar(WISP_MSG *pMsg);
		bool OnScrollEvent(WISP_MSG *pMsg);
		bool OnHorzScrollMove(WISP_MSG *pMsg);
		bool OnVertScrollMove(WISP_MSG *pMsg);
		bool OnSize(WISP_MSG *pMsg);
		bool OnSizing(WISP_MSG *pMsg);
		bool OnMove(WISP_MSG *pMsg);
		bool OnMoving(WISP_MSG *pMsg);
		bool OnHitTest(WISP_MSG *pMsg);
		bool OnEvent(WISP_MSG *pMsg); //++

		bool OnCreating(WISP_MSG *pMsg);
		bool OnTimer(WISP_MSG *pMsg);
		bool OnMouseWheel(WISP_MSG *pMsg);

		bool OnCommand(WISP_MSG *pMsg);
		bool OnCmdClose(WISP_MSG *pMsg);
		bool OnCmdMax(WISP_MSG *pMsg);
		bool OnCmdMin(WISP_MSG *pMsg);

//	PG_INC     PG_DEC     SCROLL     BT_INC     BT_DEC
//V 0	80001003h, 80001004h, 80001005h, 80001006h, 80001007h	 1,   2,   3,   4,   5
//H 1	80001008h, 80001009h, 8000100Ah, 8000100Bh, 8000100Ch	11h, 12h, 13h, 14h, 15h


		//0x80001003 VP UP
		//0x80001008
		bool OnCmdPageDec(WISP_MSG *pMsg);	//P UP		DEC	2

		//0x80001004 VP DOWN
		//0x80001009 HP RIGHT
		bool OnCmdPageInc(WISP_MSG *pMsg);	//P DOWN	INC	3

		//0x80001005 VS
		//0x8000100A HS
		bool OnCmdScrollBarDrag(WISP_MSG *pMsg);

		//0x80001006 VB UP
		//0x8000100B
		bool OnCmdSpinDec(WISP_MSG *pMsg);	//V UP		DEC	1

		//0x80001007 VB DOWN
		//0x8000100C HB RIGHT
		bool OnCmdSpinInc(WISP_MSG *pMsg);	//V DOWN	INC	0


		bool CreateWnd(const WCHAR *Name, const CWispRect & pRC, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int Style, unsigned int ShowMode);
		virtual bool CreateWnd(const WCHAR *Name, int x, int y, int cx, int cy, CWispBaseWnd *pParentWnd, unsigned int CmdID, unsigned int Style, unsigned int ShowMode);

		virtual bool Destroy() override;
		virtual void RecalcLayout() override;
		virtual bool InitWnd() override;
		virtual bool SetWindowText(const WCHAR *Text) override;

		//+++
		void ChangeColor(unsigned int, unsigned long crBGColor);
		void SetBGColor(unsigned long crBGColor)
		{
			m_crBGColor = crBGColor;
			m_bBGColor = true;
		}
		void ClearBGColor()
		{
			m_crBGColor = 0;
			m_bBGColor = false;
		}

		void RecalcMinWndSize();

		//+++
		void ScreenToClient(WISP_POINT *pPT);
		void ClientToScreen(WISP_POINT *pPT);
		void ScreenToWindow(WISP_POINT *pPT);
		void WindowToScreen(WISP_POINT *pPT);

		//+++
		bool AttachBKDIB(CWispDIB *pDIB);
		void DetachBKDIB();
		bool LoadBKDIB(const char *FileName);

		bool AttachTitleDIB(CWispDIB *pDIB);
		void DetachTitleDIB();
		bool LoadTitleDIB(const char *FileName, int Index);

		bool CreateCaret(unsigned int ID);
		bool SetCaretPos(int PosX, int PosY);
		bool GetCaretPos(WISP_POINT *pPT);
		void ShowCaret(bool bShow);
		void BlinkCaret(unsigned long BlinkTime);
		void DestroyCaret(); //???

		void LimitScrollInfo(int Type, bool bSendEvent);
		void UpdateScrollBarState(int Type);
		void CalcScrollSlideWithPos(int Type);

		bool EnableScrollBar(int Type, bool bEnable, int Style);

		void SetScrollBarInfo(int Type, int CurPos, int Max, int Page, int Min, bool bSendEvent);
		void SetScrollBarCurPos(int Type, int CurPos, bool bSendEvent);
		void SetScrollBarRange(int Type, int MaxPos, int MinPos);
		void SetScrollBarPage(int Type, int Page);
		void AdjustScrollBarMaxPos(int Type, int MaxPos);

		void ProcessCaptionBTMouseMove(WISP_POINT & pPT);
		void ProcessCaptionBTMouseKeyUp(WISP_POINT & pPoint);
		unsigned int IsPointInCaptionBT(WISP_POINT & ScrMousePT);

		void ProcessScrollBTSpinKey(int Type, WISP_MSG *pMsg);
		void ProcessScrollMouseKey(int Type, WISP_MSG *Msg);
		void ProcessVertScrollMouseMove(WISP_MSG *pMsg);
		void ProcessHorzScrollMouseMove(WISP_MSG *pMsg);

		bool BeginDrag();
		void EndDrag();
		void CalcVertScrollSlideWithPos();
		void CalcHorzScrollSlideWithPos();

		void HorzScrollLineUp() { SendScrollEvent(1,1); } //WISP_SB_DEC
		void VertScrollLineUp() { SendScrollEvent(0,1); } //WISP_SB_DEC
		void HorzScrollLineDown() { SendScrollEvent(1,0); } //WISP_SB_INC
		void VertScrollLineDown() { SendScrollEvent(0,0); } //WISP_SB_INC

		void SendScrollEvent(int Type, int Event);
	};

#endif

```

`source/WispSyser/SyserRing3.cpp`:

```cpp

#include <stdio.h>
#include "SyserRing3.hpp"
#include "../Code/sysdep.hpp"
#include "../Code/txtfile.hpp"
#include "syserconfig.hpp"
#include "keymappingpage.hpp"

	CSyserPluginUI *gpSyserPluginUI = NULL;

	CSyser *gpSyser = NULL;

	CSyser Syser;

	int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
	{
		gpSyser = &Syser;
		return Syser.WinMainStart(hInstance, lpCmdLine, nShowCmd);
	}

	static void CreateProgress(unsigned long MaxPos)
	{
		gpSyser->m_MainFrame.CreateProgress(WSTR("Loading PDB"), MaxPos);
	}

	static void UpdateProgress(unsigned long Pos)
	{
		gpSyser->m_MainFrame.UpdateProgress(Pos);
	}

	static void UpdateCaption(const WCHAR *Text)
	{
		gpSyser->m_MainFrame.UpdateCaption(Text);
	}

	static void DestroyProgress()
	{
		gpSyser->m_MainFrame.DestroyProgress();
	}

	CSyser::CSyser()
	{
		m_hDebuggerModule = NULL;
		m_pDebugger = NULL;
		gpSyserPluginUI = &m_SyserUI;
		m_bInitializeOK = true;

		TIME_ZONE_INFORMATION tz;
		GetTimeZoneInformation(&tz);
		m_TimeOffset = tz.Bias * 60;

		m_SourceDebug.m_CreateProgress = CreateProgress;
		m_SourceDebug.m_UpdateProgress = UpdateProgress;
		m_SourceDebug.m_UpdateCaption = UpdateCaption;
		m_SourceDebug.m_DestroyProgress = DestroyProgress;
	}

	CSyser::~CSyser()
	{
	}

	void CSyser::LoadConfig()
	{
		char szConfig[MAX_FN_LEN];
		GetModulePath(szConfig, true);
		TStrCat(szConfig, "Syser.cfg");

		if (!ReadConfig(szConfig, &gSyserConfig, sizeof(gSyserConfig)) )
		{
			WriteConfig(szConfig, &gSyserDefConfig, sizeof(gSyserConfig));
			memcpy(&gSyserConfig, &gSyserDefConfig, sizeof(gSyserConfig));
		}

		char szColorConfig[MAX_FN_LEN];
		GetModulePath(szColorConfig, true);
		TStrCat(szColorConfig, "SyserColor.cfg");

		if (!ReadConfig(szColorConfig, &gSyserColors, sizeof(gSyserColors)) )
		{
			WriteConfig(szColorConfig, &gSyserDefColors, sizeof(gSyserColors));
			memcpy(&gSyserColors, &gSyserDefColors, sizeof(gSyserColors));
		}
	}

	bool CSyser::Start()
	{
		LoadConfig();

		m_szWispResource = "Wisp.dat;Syser.dat";
		m_FontIndex = gSyserConfig.iBigFont ? WISP_FONT_8X16 : WISP_FONT_6X12;

		if (!CWinWisp::Start())
			return false;

		if (TStrLen(gSyserConfig.szFontFileName))
		{
			char szFontFileName[MAX_FN_LEN];
			TStrCpy(szFontFileName, gSyserConfig.szFontFileName);
			if (m_FontList[WISP_FONT_BDF].LoadBDF(szFontFileName))
				m_FontIndex = WISP_FONT_BDF;
		}

		m_dwExStyle |= WS_EX_ACCEPTFILES;

		m_bHideMouse = true;

		m_hWindowClassIcon = LoadIconA(m_hInstance, (LPCSTR)101); //???
		m_hCursorCurCIP = LoadCursorA(m_hInstance, (LPCSTR)103); //???
		int Height = MAX( 5*GetSystemMetrics(SM_CYFULLSCREEN)/6, 190);
		int Width = MAX( 5*GetSystemMetrics(SM_CXFULLSCREEN)/6, 720);

		CreateFrame(WSTR("Syser Debugger"), Width, Height, 0);
		LoadHotKey();
		m_MainFrame.CreateWnd(0, 0,0, 
			m_FrameBufferInfo.Width, m_FrameBufferInfo.Height,
			0, WISP_ID_MAIN_FRAME, 0x40, WISP_SH_MINSIZE);
		m_MainFrame.m_AdvStyle |= 4; //WISP_ADV_CANMOVE
		m_MainFrame.m_pWispBase->m_KeyLangMap = 0;
		LoadPlugins();
		if (!gpSyser->LoadDebugger(gSyserConfig.szDebuggerFileName))
		{
			m_MainFrame.m_SystemExplorer.UpdateMenu();
			m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();
		}
	//	if (!m_pDebugger)
	//		m_MainFrame.m_DebuggerSelectForm.CWispForm::Create(0, WISP_SH_MODAL_BLOCK);
		m_SyserUI.LoadAPIDef();
		LoadHistory();
		m_MainFrame.m_ConsoleWnd.Run("Syser.cmd", 0, 0); //"-s"

		if (m_lpCmdLine && TStrLen(m_lpCmdLine))
		{
			WCHAR szCmdLine[MAX_FN_LEN];
			AnsiToUnicode(m_lpCmdLine, szCmdLine, lenof(szCmdLine));
			WCHAR szCmdBuffer[MAX_FN_LEN];
			TSPrintf(szCmdBuffer, WSTR("open %s"), szCmdLine);
			gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(szCmdBuffer, 0);
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("open %s"), szCmdLine);
		}
		return true;
	}

	bool CSyser::Stop()
	{
		UnloadDebugger();
		UnloadPlugins();

		m_MainFrame.Destroy();

		DestroyFrame();

		DestroyIcon(m_hWindowClassIcon);
		DestroyIcon(m_hCursorCurCIP);
		return CWinWisp::Stop();
	}

	bool CSyser::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		if (uMsg == WM_DROPFILES)
		{
			char szFileName[MAX_FN_LEN];
			DragQueryFileA((HDROP)wParam, 0, szFileName, MAX_FN_LEN);
			if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
				gpSyser->m_SyserUI.m_SyserCodeDoc.Close();
			if (!gpSyser->m_SyserUI.m_SyserCodeDoc.Open(szFileName))
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Fail to open dropped file !\n"));
			return false;
		}

		return CWinWisp::WindowProc(hWnd, uMsg, wParam, lParam);
	}

	HOT_KEY_CFG *CSyser::GetHotKeyMap()
	{
		HOT_KEY_CFG *pHotKey = new HOT_KEY_CFG; //4096
		if (!pHotKey) return nullptr;
		
		char HotKeyFileName[MAX_FN_LEN];
		GetModulePath(HotKeyFileName, true);
		TStrCat(HotKeyFileName, "SyserHotKey.cfg");
	#if 0
		unsigned long Size;
		if (ReadConfigSize(HotKeyFileName, pHotKey, sizeof(HOT_KEY_CFG), &Size)) //4096
		{
			DbgPrint("Syser : Load HotKey configure ok!\n");
			return pHotKey;
		}
	#endif
		int i = 0;
		while(i < 127 && gGlobalKeyMap[i].Name)
		{
			pHotKey->Keys[i].CmdID = gGlobalKeyMap[i].CmdID;
			pHotKey->Keys[i].Repeat = 1;
			pHotKey->Keys[i].FirstKey = gGlobalKeyMap[i].FirstKey;
			pHotKey->Keys[i].NextKey = gGlobalKeyMap[i].NextKey;
			++i;
		}
		pHotKey->KeyCount = i;
		pHotKey->Keys[i].CmdID = 0;
		pHotKey->Keys[i].Repeat = 0;
		pHotKey->Keys[i].FirstKey = 0;
		pHotKey->Keys[i].NextKey = 0;
		
		return pHotKey;
	}

	void CSyser::LoadHotKey()
	{
		HOT_KEY_CFG *pHotKey = GetHotKeyMap();
		if (pHotKey)
		{
			TList<HOT_KEY> HK;
			for (int i = 0; i < pHotKey->KeyCount; ++i)
			{
				map<unsigned int, TList<HOT_KEY> >::IT it = m_HotKeyMap.insert(_Tmap_pair<unsigned int, TList<HOT_KEY> >(pHotKey->Keys[i].CmdID, HK));
				if (it == m_HotKeyMap.end()) break;

				for (int x = 0; x < pHotKey->Keys[i].Repeat; ++x)
				{
					HOT_KEY ev;
					ev.FirstKey = pHotKey->Keys[i].FirstKey;
					ev.NextKey = pHotKey->Keys[i].NextKey;
					it->second.Append(&ev);
				}
			}
			delete pHotKey;
		}
	}

	int CSyser::GetHotKey(unsigned int CmdID, map<unsigned int, unsigned int> & HotKeyMap)
	{
		if (CmdID == 0) return 0;
		map<unsigned int, TList<HOT_KEY> >::IT It = m_HotKeyMap.find(CmdID);
		if (It == m_HotKeyMap.end()) return 0;
		TListIter<HOT_KEY> Itc = It->second.Begin();
		while (Itc != It->second.End())
		{
			HotKeyMap.insert(_Tmap_pair<unsigned int, unsigned int>((Itc->FirstKey | Itc->NextKey), CmdID));
			++Itc;
		}
		return It->second.Size();
	}

	void CSyser::RegisterHotKeyEvent(unsigned int CmdID, CWispBaseWnd *pWnd)
	{
		if (CmdID != 0)
		{
			map<unsigned int, TList<HOT_KEY> >::IT It = m_HotKeyMap.find(CmdID);
			if (It == m_HotKeyMap.end()) return;

			TListIter<HOT_KEY> Itc = It->second.Begin();
			while (Itc != It->second.End())
			{
				if (Itc->NextKey)
					pWnd->RegisterKeyEvent(CmdID, Itc->NextKey, Itc->FirstKey, 1);
				else	pWnd->RegisterKeyEvent(CmdID, Itc->FirstKey, 0, 1);
				++Itc;
			}
		}
	}

	void CSyser::UnloadPlugins()
	{
		TListIter<HMODULE> It = m_PluginHandles.Begin();
		while (It != m_PluginHandles.End())
		{
			FreeLibrary(*It);
			++It;
		}
		m_PluginMap.clear();
	}
	int CSyser::LoadPlugin(CFileIO *This, const char *FullFileName, int FileLength, void *pData)
	{
		if (!TIMultiMatchWithPattern("*.dll", FullFileName))
			return 2; //???
		CSyser *pSyser = (CSyser*)pData;
		HMODULE hPlugin = LoadLibraryA(FullFileName);
		pSyser->m_PluginHandles.Append(&hPlugin);
		return 0;
	}
	void CSyser::LoadPlugins()
	{
		char szModulePath[MAX_FN_LEN];
		TStrCat(szModulePath, "Plugin\\*.dll");
		gpFileIO->XFind(szModulePath, CSyser::LoadPlugin, this, 0, 0);
	}

	void CSyser::UnloadDebugger()
	{
		if (m_pDebugger && m_hDebuggerModule)
		{
			if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
				gpSyser->m_SyserUI.m_SyserCodeDoc.Close();
			m_pDebugger->Release();
			m_pDebugger = nullptr;
			FreeLibrary(m_hDebuggerModule);
			gpSyser->m_szDbgFileNameFilter.Empty();
			m_MainFrame.m_SystemExplorer.ResetView();
			UnloadPlugins();
			m_MainFrame.m_SystemExplorer.UpdateMenu();
			m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();
		}
	}
	bool CSyser::LoadDebugger(const WCHAR *szModuleName)
	{
		typedef void *(*FPCreateDebugger)(CSyserUI *pSyserUI);
		typedef void (*FPGetFileFilter)(WCHAR *Filter);
		typedef void (*FPGetInfo)(char *pInfo);
		
		UnloadDebugger();
		char szFullName[MAX_FN_LEN];
		GetModulePath(szFullName, true);
		int Length = TStrLen(szFullName);
		if (Length>=MAX_FN_LEN) return false;
		UnicodeToAnsi(szModuleName, &szFullName[Length], MAX_FN_LEN - Length);
		m_hDebuggerModule = LoadLibraryA(szFullName);
		if (!m_hDebuggerModule) return false;
		FPCreateDebugger fCreateDebugger;
		(FARPROC&)fCreateDebugger = GetProcAddress(m_hDebuggerModule, "CreateDebugger");
		if (!fCreateDebugger) return false;
		FPGetFileFilter fGetFileFilter;
		(FARPROC&)fGetFileFilter = GetProcAddress(m_hDebuggerModule, "GetFileFilter");
		FPGetInfo fGetInfo;
		(FARPROC&)fGetInfo = GetProcAddress(m_hDebuggerModule, "GetInfo");

		if (fGetFileFilter)
		{
			WCHAR szDbgFileNameFilter[MAX_FN_LEN];
			fGetFileFilter(szDbgFileNameFilter);
			gpSyser->m_szDbgFileNameFilter = szDbgFileNameFilter;
		}

		if (fGetInfo)
		{
			char szTitle[256];
			TStrCpy(szTitle, "Syser Debugger - ");
			fGetInfo(&szTitle[TStrLen(szTitle)]);
			SetWindowTextA(m_hWnd, szTitle);
		}

		m_pDebugger = (CX86Debugger *)fCreateDebugger(&m_SyserUI);
		if (!m_pDebugger)
		{
			FreeLibrary(m_hDebuggerModule);
			m_hDebuggerModule = nullptr;
			return false;
		}
		m_pSysDebugger = m_pDebugger;
		m_pSysDebugger->Init(&gpSyser->m_SyserUI.m_DebugInterface);
		//m_pDebugger->???();

		m_MainFrame.m_SystemExplorer.UpdateMenu();
		m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();

		return true;
	}

	void CSyser::AddHistory(const char *FileName, unsigned long uFlag)
	{
		RECENT_HISTORY_ITEM FileHistory;

		//TODO get full path from loaded module !!!
		//TODO full path name
		//char szPath[MAX_FN_LEN];
		//const char *pPath = TStrChr(FileName, '\\');
		//if (!pPath)
		//{
		//	char *pStr += GetModulePath(szPath, true);
		//	TStrCpy(pStr, FileName);
		//	FileName = szPath;
		//}

		FileHistory.FileName = FileName;
		FileHistory.uFlag = uFlag;

		TListIter<RECENT_HISTORY_ITEM> It = m_HistoryList.Find(FileHistory);
		if (It != m_HistoryList.End())
		{
			if (It->uFlag == uFlag) return;
			m_HistoryList.Remove(It);
		}

		if (m_HistoryList.Size() > 9)
		{
			m_HistoryList.InsertBefore(m_HistoryList.Begin(), &FileHistory);
			m_HistoryList.Remove(m_HistoryList.End()-1);
		} else
		if (m_HistoryList.Size() > 0)
		{
			m_HistoryList.InsertBefore(m_HistoryList.Begin(), &FileHistory);
		} else
		{
			m_HistoryList.Append(&FileHistory);
		}
		m_bHistoryModified = true;
		SaveHistory();
		LoadHistory();
	}

	void CSyser::SaveHistory()
	{
		CImageFileStream File;
		char szFile[MAX_FN_LEN];
		GetModulePath(szFile, true);
		TStrCat(szFile, "History.lst");
		if (File.Create(szFile, 0))
		{
			TListIter<RECENT_HISTORY_ITEM> It = m_HistoryList.Begin();
			while (It != m_HistoryList.End())
			{
				File.Write(It->FileName.m_pData, It->FileName.m_nLength);
				char szFlag[256];
				int len = TSPrintf(szFlag, "|%X\r\n", It->uFlag);
				File.Write(szFlag, len);
				++It;
			}
			File.Close();
		}
	}

	void CSyser::LoadHistory()
	{
		CTXTFile TXTFile;
		char szFile[MAX_FN_LEN];
		GetModulePath(szFile, true);
		TStrCat(szFile, "History.lst");
		if (!TXTFile.Open(szFile, 0))
			return;

		m_HistoryList.Clear();

		TListIter<char *> It = TXTFile.m_StrList.Begin();
		while (It != TXTFile.m_StrList.End())
		{
			unsigned long uFlag = 0;
			char *pStr = TStrRChr(*It, '|');
			if (pStr)
			{
				*pStr++ = 0;
				if (!USHexStrToNum(pStr, &uFlag))
					uFlag = 0;
			}
			RECENT_HISTORY_ITEM FileHistory;
			FileHistory.FileName = *It;
			FileHistory.uFlag = uFlag;

			if (gpFileIO->IsFileExist(FileHistory.FileName.operator const char*()))
				m_HistoryList.Append(&FileHistory);
			++It;
		}
		TXTFile.Close();

		m_bHistoryModified = false;

		CWispMenu::MenuItem *Item = m_MainFrame.m_SystemExplorer.m_MainMenu.GetItem(WSTR("Recent Files"));
		if (Item && m_HistoryList.Size())
		{
			CWispMenu *RecentMenu = m_MainFrame.m_SystemExplorer.m_MainMenu.GetMenu(Item);
			RecentMenu->Clear();
			TListIter<RECENT_HISTORY_ITEM> It = m_HistoryList.Begin();
			int nID = 0x72;
			while (It != m_HistoryList.End() && nID <= 0x79)
			{
				WCHAR uFile[MAX_FN_LEN];
				AnsiToUnicode(It->FileName.operator const char*(), uFile, lenof(uFile));
				char *pExt = TGetFileExt(It->FileName.operator const char*());
				CWispDIB *pDIB;
				if (pExt && !TStrICmp(pExt, "exe"))
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x16);
				else	pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xF);
				RecentMenu->AppendMenu(-1, uFile, 0, nID, pDIB, 0);
				++nID;
				++It;
			}
			RecentMenu->Adjust();
		}
	}

	WCHAR g_OpenExeArgs[520] = {};
	LPCWSTR g_UiProcessStartDir = NULL;
	const WCHAR *g_CreateProcessStartDir = NULL;

	UINT_PTR CALLBACK /*__stdcall*/ OpenExeWithArgsHookProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
	#if 1
		if (uMsg == WM_INITDIALOG) //0x110 272
		{
			::SendDlgItemMessageW(hDlg, 2251, 0xC5, 0x206, 0);
			if (g_OpenExeArgs[0])
				::SetDlgItemTextW(hDlg, 2251, &g_OpenExeArgs[1]);
			if (g_UiProcessStartDir)
				::SetDlgItemTextW(hDlg, 2253, g_UiProcessStartDir);
			::CheckDlgButton(hDlg, 2252, 0);
			return 1;
		}
	#endif
	#if 0
		if (uMsg == WM_NOTIFY) //0x4E 78
		{
			::GetDlgItemTextW(hDlg, 2253, g_OpenExeArgs, 520);
			DupAllocString(&g_UiProcessStartDir, g_OpenExeArgs);
			g_CreateProcessStartDir = g_UiProcessStartDir;

			g_OpenExeArgs[0] = ' ';
			if (!::GetDlgItemTextW(hDlg, 2251, &g_OpenExeArgs[1], 519))
				g_OpenExeArgs[0] = 0;

			if (::IsDlgButtonChecked(hDlg, 2252) == 1)
				g_DebugCreateOptions.CreateFlags &= ~2 | 1;// DEBUG_PROCESS
			else	g_DebugCreateOptions.CreateFlags &= ~1 | 2;// DEBUG_ONLY_THIS_PROCESS
			return 0;
		}
	#endif
		return 0;
	}

	bool CSyser::OpenFileDialog(char *szFileName, bool arguments)
	{
		//bool arguments = true;
		if (m_szDbgFileNameFilter.m_nLength)
		{
			OPENFILENAMEA ofn;
			memset(&ofn, 0, sizeof(ofn));
			ofn.lStructSize = sizeof(ofn);
			ofn.hInstance = m_hInstance;
			ofn.hwndOwner = m_hWnd;

			ofn.Flags = OFN_EXPLORER | OFN_NOCHANGEDIR;

			if (arguments)
			{
				ofn.Flags |= OFN_ENABLETEMPLATE;
				ofn.lpTemplateName = (LPCSTR)2250;
			} else
			{
				ofn.Flags |= OFN_EXPLORER;
			}

			if (arguments)
			{
				ofn.Flags |= OFN_ENABLEHOOK;
				ofn.lpfnHook = OpenExeWithArgsHookProc;
			}

			char szFilter[MAX_FN_LEN];
			UnicodeToAnsi(m_szDbgFileNameFilter.operator const WCHAR*(), szFilter, MAX_FN_LEN);

			int Len = TStrLen(szFilter); //TStrLen(szFilter, MAX_FN_LEN);
			MAX_LIMIT(Len, MAX_FN_LEN-1);

			for (int i = Len; i >= 0; --i) //TStrReplace(szFilter, Len, '|', '\0');
			{
				if (szFilter[i] == '|')
					szFilter[i] = 0;
			}

			ofn.lpstrFilter = szFilter;
			ofn.lpstrFile = szFileName;
			ofn.nMaxFile = MAX_FN_LEN;
			szFileName[0] = 0;
			gpSyser->LockTimer();
			if (!::GetOpenFileNameA(&ofn))
			{
				UnlockTimer();
				return false;
			}
			UnlockTimer();

			TStrCpy(szFileName, ofn.lpstrFile);
		} else
		{
			szFileName[0] = 0;
		}
		return true;
	}

```

`source/WispSyser/SyserRing3.hpp`:

```hpp

#ifndef _SYSER_HPP_
#define _SYSER_HPP_

#include "../Code/alt/altlist.hpp"
#include "../Code/alt/altmap.hpp"
#include "winwisp.hpp"
#include "mainframe.hpp"
#include "plugin.hpp"
#include "syserui.hpp"
#include "../EXEAnalyzer/x86debugger.hpp"
#include "currentfunction.hpp"
#include "../EXEAnalyzer/sourcedebug.hpp"

	struct RECENT_HISTORY_ITEM
	{
		TAnsiString FileName;
		unsigned long uFlag;
		bool operator!=(const RECENT_HISTORY_ITEM&other) const { return FileName != other.FileName; }
	};

	struct HOT_KEY
	{
		unsigned int FirstKey;
		unsigned int NextKey;
	};

	struct HOT_KEY_CFG
	{
		unsigned int ID;

		unsigned int KeyCount;
		struct KEY
		{
			unsigned int CmdID;
			unsigned int Repeat;

			unsigned int FirstKey;
			unsigned int NextKey;
		} Keys[255];
	};

	struct CSyser : public CWinWisp
	{
		map<TWideString, SYSER_PLUGIN_MODULE> m_PluginMap;
		TList<HMODULE> m_PluginHandles;

		HMODULE m_hDebuggerModule;
		CX86Debugger *m_pDebugger;
		CX86Debugger *m_pSysDebugger;
		HCURSOR m_hCursorCurCIP;
		TWideString m_szDbgFileNameFilter;
		CMainFrame m_MainFrame;
		CSyserUI m_SyserUI;
		CSourceDebug m_SourceDebug;
		CCurrentFunction m_CurrentFunctionContext;
		unsigned int m_TimeOffset;
		unsigned long m_TID;
		unsigned long m_PID;

		bool m_bInitializeOK;

		TList<RECENT_HISTORY_ITEM> m_HistoryList;
		bool m_bHistoryModified;
		
		map<unsigned int, TList<HOT_KEY> > m_HotKeyMap;

		struct BPR
		{
			unsigned long Address;
			unsigned long Size;
			unsigned long State;
			unsigned long Type;
			unsigned long PageAddr;
			unsigned long PageAlign;
			unsigned long PageSize;
			TAnsiString Condition;
			TAnsiString Command;
		};

		map<unsigned long, TList<BPR>> m_ProcsBPR;
	public:
		CSyser();
		virtual ~CSyser();

		void LoadConfig();

		virtual bool Start() override;
		virtual bool Stop() override;
		virtual bool WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) override;

		HOT_KEY_CFG *GetHotKeyMap();
		void LoadHotKey();

		int GetHotKey(unsigned int CmdID, map<unsigned int, unsigned int> & HotKeyMap);
		void RegisterHotKeyEvent(unsigned int CmdID, CWispBaseWnd *pWnd);

		void UnloadPlugins();
		static int LoadPlugin(CFileIO *This, const char *FullFileName, int FileLength, void *pData);
		void LoadPlugins();

		void UnloadDebugger();
		bool LoadDebugger(const WCHAR *szModuleName);

		void AddHistory(const char *FileName, unsigned long uFlag);
		void SaveHistory();
		void LoadHistory();
		bool OpenFileDialog(char *szFileName, bool arguments = true);
	};

	extern CSyser *gpSyser;
#endif
```

`source/WispSyser/aboutform.cpp`:

```cpp

#include "aboutform.hpp"
#include "../wisp/wispstatic.hpp"

WISP_FORM_RES_ITEM AboutForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 300, 250}, 0, 0xB, WSTR("About Syser"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {10, 10, 32, 32}, 0, 0, 0, (void*)("\\SyserIcon\\Syser.ico:2"), 0},
	{WISP_CTRL_STATIC_DIB, {85, 20, 16, 16}, 0, 0, 0, (void*)("\\SyserIcon\\Explorer.ico:1"), 0},
	{WISP_CTRL_STATIC_URL, {110, 20, 180, 20}, 0, 0, WSTR("https://github.com/marakew/"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {85, 50, 16, 16}, 0, 0, 0, (void*)("\\SyserIcon\\Email.ico:1"), 0},
	{WISP_CTRL_STATIC_URL, {110, 50, 180, 20}, 0, 0, WSTR("mailto:newsyser@gmail.com"), 0, 0},
	{WISP_CTRL_STATIC_GROUP, {10, 80, 270, 110}, 0, 0, WSTR("Version Info"), 0, 0},
	{WISP_CTRL_STATIC_STRING, {20, 100, 250, 90}, 1, 0, 0, 0, WSTR("Syser Version")},
	{WISP_CTRL_BUTTON, {120, 200, 50, 18}, WISP_ID_OK, 0, WSTR("OK"), 0, 0},
	{0},
};

	CAboutForm::CAboutForm()
	{
		m_Resource = AboutForm;
	}
	CAboutForm::~CAboutForm()
	{
	}

	WISP_MSG_MAP_BEGIN(CAboutForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
	WISP_MSG_MAP_END(CWispForm)
	
	bool CAboutForm::OnCreateForm(WISP_MSG *pMsg)
	{
		CWispStaticStr *pStringItem = (CWispStaticStr *)GetFormItem(1);
		if (pStringItem)
		{
			//WCHAR szDate[64];
			//WCHAR szTime[64];
			//TStrCpy(szDate, "" __DATE__ "");
			//TStrCpy(szTime, "" __TIME__ "");

			WCHAR Ver[32];
			WCHAR Date[64];
			TStrCpy(Ver, "Develop"); //1.99.1900.1120");
			TStrCpy(Date, "" __DATE__ " " __TIME__ "");
			WCHAR Build[512];
			TSPrintf(Build, WSTR("Version : %s \n"
					"Build Date    : %s \n\n"
					"Development Team\n\n"
					"reversecode"),
					Ver, Date);
			pStringItem->SetWindowText(Build);
		}
		return true;
	}

```

`source/WispSyser/aboutform.hpp`:

```hpp

#ifndef _ABOUTFORM_HPP_
#define _ABOUTFORM_HPP_

#include "../Wisp/wispform.hpp"

struct CAboutForm : public CWispForm
{
	CAboutForm();
	virtual ~CAboutForm();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreateForm(WISP_MSG *pMsg);
};

#endif
```

`source/WispSyser/breakpointform.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "breakpointform.hpp"
#include "codebpedit.hpp"
#include "databpedit.hpp"

#define ID_EDIT 1
#define ID_NEW 2
#define ID_REMOVE 3
#define ID_REMOVE_ALL 4
#define ID_ENABLE_ALL 5
#define ID_DISABLE_ALL 6
#define ID_TAB 7
#define ID_CODE_BP 8
#define ID_DATA_BP 9

enum
{
  BPF_NAME = 0,
  BPF_OWNER = 1,
  BPF_CONDITION = 2,
};

WISP_FORM_RES_ITEM BreakPointForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 450, 300}, 0, 0xB, WSTR("Breakpoint"), (void*)"\\SyserIcon\\Syser.ico", 0},
	{WISP_CTRL_TAB, {5, 5, 350, 260}, ID_TAB, 6, 0, 0, 0},
	{WISP_CTRL_STATIC_DIB, {380, 30, 70, 20}, 0, 0, 0, (void*)"\\SyserIcon\\Syser.ico:1", 0},
	{WISP_CTRL_BUTTON, {362, 90, 70, 20}, ID_EDIT, 0, WSTR("Edit"), 0, WSTR("Edit break point")},
	{WISP_CTRL_BUTTON, {362, 120, 70, 20}, ID_NEW, 0, WSTR("New"), 0, WSTR("Insert New break point")},
	{WISP_CTRL_BUTTON, {362, 150, 70, 20}, ID_REMOVE, 0, WSTR("Remove"), 0, WSTR("Remove break point")},
	{WISP_CTRL_BUTTON, {362, 180, 70, 20}, ID_REMOVE_ALL, 0, WSTR("RemoveAll"), 0, WSTR("Remove All break point")},
	{WISP_CTRL_BUTTON, {362, 210, 70, 20}, ID_ENABLE_ALL, 0, WSTR("EnableAll"), 0, WSTR("Enable all break point")},
	{WISP_CTRL_BUTTON, {362, 240, 70, 20}, ID_DISABLE_ALL, 0, WSTR("DisableAll"), 0, WSTR("Disable all break point")},
	{0},
};

	WISP_MSG_MAP_BEGIN(CBreakPointForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
//TODO BP	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

	WISP_CMD_MAP_BEGIN(CBreakPointForm)
		WISP_CMD_MAP(ID_TAB, OnCmdTabSelect)
		WISP_CMD_MAP(ID_CODE_BP, OnCmdListSelect)
		WISP_CMD_MAP(ID_DATA_BP, OnCmdListSelect)
	WISP_CMD_MAP_END

	WISP_EVENT_MAP_BEGIN(CBreakPointForm)
		WISP_EVENT_MAP(ID_EDIT, OnEventEdit)
		WISP_EVENT_MAP(ID_NEW, OnEventNew)
		WISP_EVENT_MAP(ID_REMOVE, OnEventRemove)
		WISP_EVENT_MAP(ID_REMOVE_ALL, OnEventRemoveAll)
		WISP_EVENT_MAP(ID_ENABLE_ALL, OnEventEnableAll)
		WISP_EVENT_MAP(ID_DISABLE_ALL, OnEventDisableAll)
	WISP_EVENT_MAP_END

	CBreakPointForm::CBreakPointForm()
	{
		m_Resource = BreakPointForm;
	}
	CBreakPointForm::~CBreakPointForm()
	{
	}
	
	bool CBreakPointForm::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pTabWnd = (CWispTabWnd *)GetFormItem(ID_TAB);

		m_pEdit = (CWispButton *)GetFormItem(ID_EDIT);

		m_pRemove = (CWispButton *)GetFormItem(ID_REMOVE);
		m_pRemoveAll = (CWispButton *)GetFormItem(ID_REMOVE_ALL);
		m_pEnableAll = (CWispButton *)GetFormItem(ID_ENABLE_ALL);
		m_pDisableAll = (CWispButton *)GetFormItem(ID_DISABLE_ALL);

		m_pCodeBP = new CWispList;

		m_pCodeBP->CreateWnd(0, 0,0,0,0, m_pTabWnd, ID_CODE_BP, 0x40010000, WISP_SH_MINSIZE);
		m_pCodeBP->SetOwner(this);
		m_pTabWnd->InsertWnd(WSTR("Code Breakpoint"), m_pCodeBP, 0);
		InitContext(m_pCodeBP);

		m_pCurList = m_pCodeBP;

		m_pDataBP = new CWispList;
		m_pDataBP->CreateWnd(0, 0,0,0,0, m_pTabWnd, ID_DATA_BP, 0x40010000, WISP_SH_MINSIZE);
		m_pDataBP->SetOwner(this);
		m_pTabWnd->InsertWnd(WSTR("Data Breakpoint"), m_pDataBP, 0);
		InitContext(m_pDataBP);

		ShowCode();
		ShowData();
 		
		return true;
	}

	bool CBreakPointForm::OnCmdTabSelect(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000800) //WISP_ID_TAB_SELECT
		{
			m_pCurList = (CWispList *)pMsg->Command.Param2;
			UpdateButton();
		}
		return true;
	}
	bool CBreakPointForm::OnCmdListSelect(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000105) //WISP_ID_SELECT
		{
			if ((m_pRemove->m_Style >> 9) & 1)
			{
				m_pEdit->EnableWindow(true);
				m_pRemove->EnableWindow(true);
			}
		}
		return true;
	}

	bool CBreakPointForm::OnEventEdit(WISP_MSG *pMsg)
	{
		CListStringItem *Item = m_pCurList->GetNext(0, 8);
		if (Item)
		{
			if (m_pCurList == m_pCodeBP)
			{
				CCodeBPEdit CodeEdit;
				if (m_pCurList->GetItemValue(Item, BPF_OWNER))
					CodeEdit.m_pModuleBP = (BREAK_POINT::MODULE *)m_pCurList->GetItemValue(Item, BPF_NAME);
				else	CodeEdit.m_pBP = (BREAK_POINT *)m_pCurList->GetItemValue(Item, BPF_NAME);
				CodeEdit.Create(0, WISP_SH_MODAL_BLOCK);
				if (CodeEdit.m_Result == WISP_ID_OK)
					ShowCode();
			} else
			{
				CDataBPEdit DataEdit;
				DataEdit.m_pBP = (BREAK_POINT *)m_pCurList->GetItemValue(Item, BPF_NAME);
				DataEdit.Create(0, WISP_SH_MODAL_BLOCK);
				if (DataEdit.m_Result == WISP_ID_OK)
					ShowData();
			}
		}
		return true;
	}
	bool CBreakPointForm::OnEventNew(WISP_MSG *pMsg)
	{
		if (m_pCurList == m_pCodeBP)
		{
			CCodeBPEdit CodeEdit;
			CodeEdit.Create(0, WISP_SH_MODAL_BLOCK);
			if (CodeEdit.m_Result == WISP_ID_OK)
				ShowCode();
		} else
		{
			CDataBPEdit DataEdit;
			DataEdit.Create(0, WISP_SH_MODAL_BLOCK);
			if (DataEdit.m_Result == WISP_ID_OK)
				ShowData();
		}
		return true;
	}
	bool CBreakPointForm::OnEventRemove(WISP_MSG *pMsg)
	{
		CListStringItem *Item = m_pCurList->GetNext(0, 8);
		if (Item)
		{
			if (m_pCurList == m_pCodeBP)
			{
				if (m_pCurList->GetItemValue(Item, BPF_OWNER))
				{
					BREAK_POINT::MODULE *BreakPoint = (BREAK_POINT::MODULE *)m_pCurList->GetItemValue(Item, BPF_NAME);
	typedef _Tmap_pair<ULONG_PTR, BREAK_POINT::MODULE> PBP;
	PBP *p = CONTAINING_RECORD_MY1(BreakPoint, PBP, second);
					//unsigned long Address = p->first; //BP-4 TODO
					gpSyser->m_SyserUI.RemoveBP(p->first);//Address);
				} else
				{
					BREAK_POINT *BreakPoint = (BREAK_POINT *)m_pCurList->GetItemValue(Item, BPF_NAME);
					gpSyser->m_pDebugger->DelCodeBP(*BreakPoint);
				}
				ShowCode();
			} else
			{
				BREAK_POINT *BreakPoint = (BREAK_POINT *)m_pCurList->GetItemValue(Item, BPF_NAME);
				gpSyser->m_pDebugger->DelDataBP(*BreakPoint);
				ShowData();
			}
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
			gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		}
		return true;
	}
	bool CBreakPointForm::OnEventRemoveAll(WISP_MSG *pMsg)
	{
		if (m_pCurList == m_pCodeBP)
		{
			gpSyser->m_pDebugger->DelAllCodeBP(0, 0x300);
			gpSyser->m_SyserUI.m_ModuleBPMap.clear();
			ShowCode();
		} else
		{
			gpSyser->m_pDebugger->DelAllDataBP(0, 0x300);
			ShowData();
		}
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		return true;
	}
	bool CBreakPointForm::OnEventEnableAll(WISP_MSG *pMsg)
	{
		if (m_pCurList == m_pCodeBP)
		{
			gpSyser->m_pDebugger->EnableAllCodeBP(0, 0x300);
			gpSyser->m_SyserUI.EnableAllModuleBP(true);
			ShowCode();
		} else
		{
			gpSyser->m_pDebugger->EnableAllDataBP(0, 0x300);
			ShowData();
		}
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		return true;
	}
	bool CBreakPointForm::OnEventDisableAll(WISP_MSG *pMsg)
	{
		if (m_pCurList == m_pCodeBP)
		{
			gpSyser->m_pDebugger->DisableAllCodeBP(0, 0x300);
			gpSyser->m_SyserUI.EnableAllModuleBP(false);
			ShowCode();
		} else
		{
			gpSyser->m_pDebugger->DisableAllDataBP(0, 0x300);
			ShowData();
		}
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		return true;
	}

	void CBreakPointForm::CreateShow()
	{
		if (IsWindowShow())
		{
			ShowCode();
			ShowData();
		}
	}
	int CBreakPointForm::FillCode()
	{
		WCHAR szName[256];
		int Count = 0;
		for (map<unsigned long long, BREAK_POINT>::IT it = gpSyser->m_pDebugger->m_pCodeBPMap->begin();
			it != gpSyser->m_pDebugger->m_pCodeBPMap->end(); ++it)
		{
			if (!(it->second.Type & 0x300) && !it->second.pModule)
			{
				if (it->second.Name.m_nLength)
				{
					AnsiToUnicode(it->second.Name.operator const char*(), szName, lenof(szName));
				} else
				{
					uNumToStr(it->second.Address, szName, 16);
				}
				CListStringItem *Item = m_pCodeBP->InsertItem(szName, 0, 0, 0, -1);
				DrawBP(m_pCodeBP, Item, &it->second);
				++Count;
			}
		}
		{
		map<ULONG_PTR, BREAK_POINT::MODULE>::IT it = gpSyser->m_SyserUI.m_ModuleBPMap.begin();
		while (it != gpSyser->m_SyserUI.m_ModuleBPMap.end())
		//wile (it)
		{
			AnsiToUnicode(it->second.Name.operator const char*(), szName, lenof(szName));
			CListStringItem *Item = m_pCodeBP->InsertItem(szName, 0, 0, 0, -1);
			DrawModuleBP(m_pCodeBP, Item, &it->second);
			++it;
		}
		}
		return Count;
	}
	int CBreakPointForm::ShowCode()
	{
		int Count = 0;
		if (m_pCodeBP)
			m_pCodeBP->DeleteAllChildrenItems(0);
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
			Count = FillCode();
		UpdateButton();
		Update(&m_ClientRect);
		return Count;
	}
	int CBreakPointForm::FillData()
	{
		WCHAR szName[256];
		int Count = 0;
		TListIter<BREAK_POINT> It = gpSyser->m_pDebugger->m_pDataBPList->Begin();
		while (It != gpSyser->m_pDebugger->m_pDataBPList->End())
		{
			if (!(It->Type & 0x300))
			{
				if (It->Name.m_nLength)
				{
					AnsiToUnicode(It->Name.operator const char*(), szName, lenof(szName));
				} else
				{
					uNumToStr(It->Address, szName, 16);
				}
				CListStringItem *Item = m_pDataBP->InsertItem(szName, 0, 0, 0, -1);
				DrawBP(m_pDataBP, Item, &*It);
				++Count;
			}
			++It;
		}
		return Count;
	}
	int CBreakPointForm::ShowData()
	{
		int Count = 0;
		if (m_pDataBP)
			m_pDataBP->DeleteAllChildrenItems(0);
		//if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		if (gpSyser->m_pDebugger)
			Count = FillData();
		UpdateButton();
		Update(&m_ClientRect);
		return Count;
	}
	void CBreakPointForm::UpdateButton()
	{
		bool bBP = m_pCurList->GetItemCount(0, true) > 0;
		m_pRemoveAll->EnableWindow(bBP);
		m_pEnableAll->EnableWindow(bBP);
		m_pDisableAll->EnableWindow(bBP);

		bool bPresent = m_pCurList->GetNext(0, 8) != 0;
		m_pRemove->EnableWindow(bPresent);
		m_pEdit->EnableWindow(bPresent);

		Update((WISP_RECT*)0);
	}

	void CBreakPointForm::InitContext(CWispList *pList)
	{
		pList->m_AdvStyle |= 1;
		pList->InsertColumn(WSTR("Name"), 100, 0, 0, -1);
		pList->InsertColumn(WSTR("Owner Process"), 120, 0, 0, -1);
		pList->InsertColumn(WSTR("Condition"), 120, 0, 0, -1);
	}

	void CBreakPointForm::DrawBP(CWispList *pList, CListStringItem *Item, BREAK_POINT *BreakPoint)
	{
		WCHAR Buffer[256];
		pList->SetItemValue(Item, BPF_NAME, (unsigned long long)BreakPoint);
		pList->SetItemValue(Item, BPF_OWNER, 0);
		AnsiToUnicode(BreakPoint->Owner.operator const char*(), Buffer, lenof(Buffer));
		pList->SetItemText(Item, BPF_OWNER, Buffer);
		AnsiToUnicode(BreakPoint->Condition.operator const char*(), Buffer, lenof(Buffer));
		pList->SetItemText(Item, BPF_CONDITION, Buffer);
		if (BreakPoint->State == BP_STATE_DISABLE)
		{
			pList->SetItemColor(Item, BPF_NAME, m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
			pList->SetItemColor(Item, BPF_OWNER, m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
			pList->SetItemColor(Item, BPF_CONDITION, m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
		}
	}

	void CBreakPointForm::DrawModuleBP(CWispList *pList, CListStringItem *Item, BREAK_POINT::MODULE *BreakPoint)
	{
		WCHAR Buffer[256];
		pList->SetItemValue(Item, BPF_NAME, (unsigned long long)BreakPoint);
		pList->SetItemValue(Item, BPF_OWNER, 1);
		pList->SetItemText(Item, BPF_OWNER, WSTR("<All Process>"));
		AnsiToUnicode(BreakPoint->Condition.operator const char*(), Buffer, lenof(Buffer));
		pList->SetItemText(Item, BPF_CONDITION, Buffer);
		if (BreakPoint->State == BP_STATE_DISABLE)
		{
			pList->SetItemColor(Item, BPF_NAME, m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
			pList->SetItemColor(Item, BPF_OWNER, m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
			pList->SetItemColor(Item, BPF_CONDITION, m_pWispBase->m_pWispDrawObj->m_crSystem[12]);
		}
	}

	void CBreakPointForm::Create()
	{
		if (IsWindow())
		{
			CreateShow();
			Show(WISP_SH_MINSIZE);
		} else
		{
			CWispForm::Create(0, WISP_SH_MINSIZE);
		}
	}

```

`source/WispSyser/breakpointform.hpp`:

```hpp

#ifndef _BREAKPOINTFORM_HPP_
#define _BREAKPOINTFORM_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispedit.hpp"
#include "../Wisp/wispbutton.hpp"
#include "../Wisp/wisptabwnd.hpp"
#include "../EXEAnalyzer/debugger.hpp"

struct CBreakPointForm : public CWispForm
{
	CWispList *m_pCodeBP;
	CWispList *m_pDataBP;
	CWispList *m_pCurList;
	CWispTabWnd *m_pTabWnd;
	CWispButton *m_pEdit;
	CWispButton *m_pRemove;
	CWispButton *m_pRemoveAll;
	CWispButton *m_pEnableAll;
	CWispButton *m_pDisableAll;

	CBreakPointForm();
	virtual ~CBreakPointForm();
	
	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);

	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdTabSelect(WISP_MSG *pMsg);
	bool OnCmdListSelect(WISP_MSG *pMsg);

	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventEdit(WISP_MSG *pMsg);
	bool OnEventNew(WISP_MSG *pMsg);
	bool OnEventRemove(WISP_MSG *pMsg);
	bool OnEventRemoveAll(WISP_MSG *pMsg);
	bool OnEventEnableAll(WISP_MSG *pMsg);
	bool OnEventDisableAll(WISP_MSG *pMsg);


	void CreateShow();
	int FillCode();
	int ShowCode();
	int FillData();
	int ShowData();
	void UpdateButton();

	void InitContext(CWispList *pList);
	void DrawBP(CWispList *pList, CListStringItem *Item, BREAK_POINT *BreakPoint);
	void DrawModuleBP(CWispList *pList, CListStringItem *Item, BREAK_POINT::MODULE *BreakPoint);
	void Create();
};

#endif

```

`source/WispSyser/bugcheckcode.cpp`:

```cpp

#include "othercmd.hpp"

BUGCHECKCODE_ENTRY stBugCheckCodeList[] =
	{
      {0x1, "APC_INDEX_MISMATCH", 0 },
      {0x2, "DEVICE_QUEUE_NOT_BUSY", 0 },
      {0x3, "INVALID_AFFINITY_SET", 0 },
      {0x4, "INVALID_DATA_ACCESS_TRAP", 0 },
      {0x5, "INVALID_PROCESS_ATTACH_ATTEMPT", 0 },
      {0x6, "INVALID_PROCESS_DETACH_ATTEMPT", 0 },
      {0x7, "INVALID_SOFTWARE_INTERRUPT", 0 },
      {0x8, "IRQL_NOT_DISPATCH_LEVEL", 0 },
      {0x9, "IRQL_NOT_GREATER_OR_EQUAL", 0 },
      {0xA, "IRQL_NOT_LESS_OR_EQUAL", 0 },
      {0xB, "NO_EXCEPTION_HANDLING_SUPPORT", 0 },
      {0xC, "MAXIMUM_WAIT_OBJECTS_EXCEEDED", 0 },
      {0xD, "MUTEX_LEVEL_NUMBER_VIOLATION", 0 },
      {0xE, "NO_USER_MODE_CONTEXT", 0 },
      {0xF, "SPIN_LOCK_ALREADY_OWNED", 0 },
      {0x10, "SPIN_LOCK_NOT_OWNED", 0 },
      {0x11, "THREAD_NOT_MUTEX_OWNER", 0 },
      {0x12, "TRAP_CAUSE_UNKNOWN", 0 },
      {0x13, "EMPTY_THREAD_REAPER_LIST", 0 },
      {0x14, "CREATE_DELETE_LOCK_NOT_LOCKED", 0 },
      {0x15, "LAST_CHANCE_CALLED_FROM_KMODE", 0 },
      {0x16, "CID_HANDLE_CREATION", 0 },
      {0x17, "CID_HANDLE_DELETION", 0 },
      {0x18, "REFERENCE_BY_POINTER", 0 },
      {0x19, "BAD_POOL_HEADER", 0 },
      {0x1A, "MEMORY_MANAGEMENT", 0 },
      {0x1B, "PFN_SHARE_COUNT", 0 },
      {0x1C, "PFN_REFERENCE_COUNT", 0 },
      {0x1D, "NO_SPIN_LOCK_AVAILABLE", 0 },
      {0x1E, "KMODE_EXCEPTION_NOT_HANDLED", 0 },
      {0x1F, "SHARED_RESOURCE_CONV_ERROR", 0 },
      {0x20, "KERNEL_APC_PENDING_DURING_EXIT", 0 },
      {0x21, "QUOTA_UNDERFLOW", 0 },
      {0x22, "FILE_SYSTEM", 0 },
      {0x23, "FAT_FILE_SYSTEM", 0 },
      {0x24, "NTFS_FILE_SYSTEM", 0 },
      {0x25, "NPFS_FILE_SYSTEM", 0 },
      {0x26, "CDFS_FILE_SYSTEM", 0 },
      {0x27, "RDR_FILE_SYSTEM", 0 },
      {0x28, "CORRUPT_ACCESS_TOKEN", 0 },
      {0x29, "SECURITY_SYSTEM", 0 },
      {0x2A, "INCONSISTENT_IRP", 0 },
      {0x2B, "PANIC_STACK_SWITCH", 0 },
      {0x2C, "PORT_DRIVER_INTERNAL", 0 },
      {0x2D, "SCSI_DISK_DRIVER_INTERNAL", 0 },
      {0x2E, "DATA_BUS_ERROR", 0 },
      {0x2F, "INSTRUCTION_BUS_ERROR", 0 },
      {0x30, "SET_OF_INVALID_CONTEXT", 0 },
      {0x31, "PHASE0_INITIALIZATION_FAILED", 0 },
      {0x32, "PHASE1_INITIALIZATION_FAILED", 0 },
      {0x33, "UNEXPECTED_INITIALIZATION_CALL", 0 },
      {0x34, "CACHE_MANAGER", 0 },
      {0x35, "NO_MORE_IRP_STACK_LOCATIONS", 0 },
      {0x36, "DEVICE_REFERENCE_COUNT_NOT_ZERO", 0 },
      {0x37, "FLOPPY_INTERNAL_ERROR", 0 },
      {0x38, "SERIAL_DRIVER_INTERNAL", 0 },
      {0x39, "SYSTEM_EXIT_OWNED_MUTEX", 0 },
      {0x3A, "SYSTEM_UNWIND_PREVIOUS_USER", 0 },
      {0x3B, "SYSTEM_SERVICE_EXCEPTION", 0 },
      {0x3C, "INTERRUPT_UNWIND_ATTEMPTED", 0 },
      {0x3D, "INTERRUPT_EXCEPTION_NOT_HANDLED", 0 },
      {0x3E, "MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED", 0 },
      {0x3F, "NO_MORE_SYSTEM_PTES", 0 },
      {0x40, "TARGET_MDL_TOO_SMALL", 0 },
      {0x41, "MUST_SUCCEED_POOL_EMPTY", 0 },
      {0x42, "ATDISK_DRIVER_INTERNAL", 0 },
      {0x43, "NO_SUCH_PARTITION", 0 },
      {0x44, "MULTIPLE_IRP_COMPLETE_REQUESTS", 0 },
      {0x45, "INSUFFICIENT_SYSTEM_MAP_REGS", 0 },
      {0x46, "DEREF_UNKNOWN_LOGON_SESSION", 0 },
      {0x47, "REF_UNKNOWN_LOGON_SESSION", 0 },
      {0x48, "CANCEL_STATE_IN_COMPLETED_IRP", 0 },
      {0x49, "PAGE_FAULT_WITH_INTERRUPTS_OFF", 0 },
      {0x4A, "IRQL_GT_ZERO_AT_SYSTEM_SERVICE", 0 },
      {0x4B, "STREAMS_INTERNAL_ERROR", 0 },
      {0x4C, "FATAL_UNHANDLED_HARD_ERROR", 0 },
      {0x4D, "NO_PAGES_AVAILABLE", 0 },
      {0x4E, "PFN_LIST_CORRUPT", 0 },
      {0x4F, "NDIS_INTERNAL_ERROR", 0 },
      {0x50, "PAGE_FAULT_IN_NONPAGED_AREA", 0 },
      {0x51, "REGISTRY_ERROR", 0 },
      {0x52, "MAILSLOT_FILE_SYSTEM", 0 },
      {0x53, "NO_BOOT_DEVICE", 0 },
      {0x54, "LM_SERVER_INTERNAL_ERROR", 0 },
      {0x55, "DATA_COHERENCY_EXCEPTION", 0 },
      {0x56, "INSTRUCTION_COHERENCY_EXCEPTION", 0 },
      {0x57, "XNS_INTERNAL_ERROR", 0 },
      {0x58, "FTDISK_INTERNAL_ERROR", 0 },
      {0x59, "PINBALL_FILE_SYSTEM", 0 },
      {0x5A, "CRITICAL_SERVICE_FAILED", 0 },
      {0x5B, "SET_ENV_VAR_FAILED", 0 },
      {0x5C, "HAL_INITIALIZATION_FAILED", 0 },
      {0x5D, "UNSUPPORTED_PROCESSOR", 0 },
      {0x5E, "OBJECT_INITIALIZATION_FAILED", 0 },
      {0x5F, "SECURITY_INITIALIZATION_FAILED", 0 },
      {0x60, "PROCESS_INITIALIZATION_FAILED", 0 },
      {0x61, "HAL1_INITIALIZATION_FAILED", 0 },
      {0x62, "OBJECT1_INITIALIZATION_FAILED", 0 },
      {0x63, "SECURITY1_INITIALIZATION_FAILED", 0 },
      {0x64, "SYMBOLIC_INITIALIZATION_FAILED", 0 },
      {0x65, "MEMORY1_INITIALIZATION_FAILED", 0 },
      {0x66, "CACHE_INITIALIZATION_FAILED", 0 },
      {0x67, "CONFIG_INITIALIZATION_FAILED", 0 },
      {0x68, "FILE_INITIALIZATION_FAILED", 0 },
      {0x69, "IO1_INITIALIZATION_FAILED", 0 },
      {0x6A, "LPC_INITIALIZATION_FAILED", 0 },
      {0x6B, "PROCESS1_INITIALIZATION_FAILED", 0 },
      {0x6C, "REFMON_INITIALIZATION_FAILED", 0 },
      {0x6D, "SESSION1_INITIALIZATION_FAILED", 0 },
      {0x6E, "SESSION2_INITIALIZATION_FAILED", 0 },
      {0x6F, "SESSION3_INITIALIZATION_FAILED", 0 },
      {0x70, "SESSION4_INITIALIZATION_FAILED", 0 },
      {0x71, "SESSION5_INITIALIZATION_FAILED", 0 },
      {0x72, "ASSIGN_DRIVE_LETTERS_FAILED", 0 },
      {0x73, "CONFIG_LIST_FAILED", 0 },
      {0x74, "BAD_SYSTEM_CONFIG_INFO", 0 },
      {0x75, "CANNOT_WRITE_CONFIGURATION", 0 },
      {0x76, "PROCESS_HAS_LOCKED_PAGES", 0 },
      {0x77, "KERNEL_STACK_INPAGE_ERROR", 0 },
      {0x78, "PHASE0_EXCEPTION", 0 },
      {0x79, "MISMATCHED_HAL", 0 },
      {0x7A, "KERNEL_DATA_INPAGE_ERROR", 0 },
      {0x7B, "INACCESSIBLE_BOOT_DEVICE", 0 },
      {0x7C, "BUGCODE_NDIS_DRIVER", 0 },
      {0x7D, "INSTALL_MORE_MEMORY", 0 },
      {0x7E, "SYSTEM_THREAD_EXCEPTION_NOT_HANDLED", 0 },
      {0x7F, "UNEXPECTED_KERNEL_MODE_TRAP", 0 },
      {0x80, "NMI_HARDWARE_FAILURE", 0 },
      {0x81, "SPIN_LOCK_INIT_FAILURE", 0 },
      {0x82, "DFS_FILE_SYSTEM", 0 },
      {0x85, "SETUP_FAILURE", 0 },
      {0x8B, "MBR_CHECKSUM_MISMATCH", 0 },
      {0x8E, "KERNEL_MODE_EXCEPTION_NOT_HANDLED", 0 },
      {0x8F, "PP0_INITIALIZATION_FAILED", 0 },
      {0x90, "PP1_INITIALIZATION_FAILED", 0 },
      {0x92, "UP_DRIVER_ON_MP_SYSTEM", 0 },
      {0x93, "INVALID_KERNEL_HANDLE", 0 },
      {0x94, "KERNEL_STACK_LOCKED_AT_EXIT", 0 },
      {0x96, "INVALID_WORK_QUEUE_ITEM", 0 },
      {0x97, "BOUND_IMAGE_UNSUPPORTED", 0 },
      {0x98, "END_OF_NT_EVALUATION_PERIOD", 0 },
      {0x99, "INVALID_REGION_OR_SEGMENT", 0 },
      {0x9A, "SYSTEM_LICENSE_VIOLATION", 0 },
      {0x9B, "UDFS_FILE_SYSTEM", 0 },
      {0x9C, "MACHINE_CHECK_EXCEPTION", 0 },
      {0x9E, "USER_MODE_HEALTH_MONITOR", 0 },
      {0x9F, "DRIVER_POWER_STATE_FAILURE", 0 },
      {0xA0, "INTERNAL_POWER_ERROR", 0 },
      {0xA1, "PCI_BUS_DRIVER_INTERNAL", 0 },
      {0xA2, "MEMORY_IMAGE_CORRUPT", 0 },
      {0xA3, "ACPI_DRIVER_INTERNAL", 0 },
      {0xA4, "CNSS_FILE_SYSTEM_FILTER", 0 },
      {0xA5, "ACPI_BIOS_ERROR", 0 },
      {0xA7, "BAD_EXHANDLE", 0 },
      {0xAB, "SESSION_HAS_VALID_POOL_ON_EXIT", 0 },
      {0xAC, "HAL_MEMORY_ALLOCATION", 0 },
      {0xAD, "VIDEO_DRIVER_DEBUG_REPORT_REQUEST", 0 },
      {0xB4, "VIDEO_DRIVER_INIT_FAILURE", 0 },
      {0xB8, "ATTEMPTED_SWITCH_FROM_DPC", 0 },
      {0xB9, "CHIPSET_DETECTED_ERROR", 0 },
      {0xBA, "SESSION_HAS_VALID_VIEWS_ON_EXIT", 0 },
      {0xBA, "SESSION_HAS_VALID_VIEWS_ON_EXIT", 0 },
      {0xBC, "NETWORK_BOOT_DUPLICATE_ADDRESS", 0 },
      {0xBE, "ATTEMPTED_WRITE_TO_READONLY_MEMORY", 0 },
      {0xBF, "MUTEX_ALREADY_OWNED", 0 },
      {0xC1, "SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION", 0 },
      {0xC2, "BAD_POOL_CALLER", 0 },
      {0xC4, "DRIVER_VERIFIER_DETECTED_VIOLATION", 0 },
      {0xC5, "DRIVER_CORRUPTED_EXPOOL", 0 },
      {0xC6, "DRIVER_CAUGHT_MODIFYING_FREED_POOL", 0 },
      {0xC7, "TIMER_OR_DPC_INVALID", 0 },
      {0xC8, "IRQL_UNEXPECTED_VALUE", 0 },
      {0xC9, "DRIVER_VERIFIER_IOMANAGER_VIOLATION ", 0 },
      {0xCA, "PNP_DETECTED_FATAL_ERROR", 0 },
      {0xCB, "DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS", 0 },
      {0xCC, "PAGE_FAULT_IN_FREED_SPECIAL_POOL", 0 },
      {0xCD, "PAGE_FAULT_BEYOND_END_OF_ALLOCATION", 0 },
      {0xCE, "DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS", 0 },
      {0xCF, "TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE", 0 },
      {0xD0, "DRIVER_CORRUPTED_MMPOOL", 0 },
      {0xD1, "DRIVER_IRQL_NOT_LESS_OR_EQUAL", 0 },
      {0xD2, "BUGCODE_ID_DRIVER", 0 },
      {0xD3, "DRIVER_PORTION_MUST_BE_NONPAGED", 0 },
      {0xD4, "SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER", 0 },
      {0xD5, "DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL", 0 },
      {0xD6, "DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION", 0 },
      {0xD7, "DRIVER_UNMAPPING_INVALID_VIEW", 0 },
      {0xD8, "DRIVER_USED_EXCESSIVE_PTES", 0 },
      {0xD9, "LOCKED_PAGES_TRACKER_CORRUPTION", 0 },
      {0xDA, "SYSTEM_PTE_MISUSE", 0 },
      {0xDB, "DRIVER_CORRUPTED_SYSPTES", 0 },
      {0xDC, "DRIVER_INVALID_STACK_ACCESS", 0 },
      {0xDE, "POOL_CORRUPTION_IN_FILE_AREA", 0 },
      {0xDF, "IMPERSONATING_WORKER_THREAD", 0 },
      {0xE0, "ACPI_BIOS_FATAL_ERROR", 0 },
      {0xE1, "WORKER_THREAD_RETURNED_AT_BAD_IRQL", 0 },
      {0xE2, "MANUALLY_INITIATED_CRASH", 0 },
      {0xE3, "RESOURCE_NOT_OWNED", 0 },
      {0xE4, "WORKER_INVALID", 0 },
      {0xE6, "DRIVER_VERIFIER_DMA_VIOLATION", 0 },
      {0xE7, "INVALID_FLOATING_POINT_STATE", 0 },
      {0xE8, "INVALID_CANCEL_OF_FILE_OPEN", 0 },
      {0xE9, "ACTIVE_EX_WORKER_THREAD_TERMINATION", 0 },
      {0xEA, "THREAD_STUCK_IN_DEVICE_DRIVER", 0 },
      {0xEB, "DIRTY_MAPPED_PAGES_CONGESTION", 0 },
      {0xEC, "SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT", 0 },
      {0xED, "UNMOUNTABLE_BOOT_VOLUME", 0 },
      {0xEF, "CRITICAL_PROCESS_DIED", 0 },
      {0xF1, "SCSI_VERIFIER_DETECTED_VIOLATION", 0 },
      {0xF3, "DISORDERLY_SHUTDOWN", 0 },
      {0xF4, "CRITICAL_OBJECT_TERMINATION", 0 },
      {0xF5, "FLTMGR_FILE_SYSTEM", 0 },
      {0xF6, "PCI_VERIFIER_DETECTED_VIOLATION", 0 },
      {0xF7, "DRIVER_OVERRAN_STACK_BUFFER", 0 },
      {0xF8, "RAMDISK_BOOT_INITIALIZATION_FAILED", 0 },
      {0xF9, "DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN", 0 },
      {0xFA, "HTTP_DRIVER_CORRUPTED", 0 },
      {0xFC, "ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY", 0 },
      {0xFD, "DIRTY_NOWRITE_PAGES_CONGESTION", 0 },
      {0xFE, "BUGCODE_USB_DRIVER", 0 },
      {0xFF, "RESERVE_QUEUE_OVERFLOW", 0 },
      {0x100, "LOADER_BLOCK_MISMATCH", 0 },
      {0x101, "CLOCK_WATCHDOG_TIMEOUT", 0 },
      {0x104, "AGP_INVALID_ACCESS", 0 },
      {0x105, "AGP_GART_CORRUPTION", 0 },
      {0x106, "AGP_ILLEGALLY_REPROGRAMMED", 0 },
      {0x108, "THIRD_PARTY_FILE_SYSTEM_FAILURE", 0 },
      {0x109, "CRITICAL_STRUCTURE_CORRUPTION", 0 },
      {0x10A, "APP_TAGGING_INITIALIZATION_FAILED", 0 },
      {0x10C, "FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION", 0 },
      {0x10D, "WDF_VIOLATION", 0 },
      {0x10E, "VIDEO_MEMORY_MANAGEMENT_INTERNAL", 0 },
      {0x10F, "RESOURCE_MANAGER_EXCEPTION_NOT_HANDLED", 0 },
      {0x112, "MSRPC_STATE_VIOLATION", 0 },
      {0x113, "VIDEO_DXGKRNL_FATAL_ERROR", 0 },
      {0x114, "VIDEO_SHADOW_DRIVER_FATAL_ERROR", 0 },
      {0x115, "AGP_INTERNAL", 0 },
      {0x116, "VIDEO_TDR_ERROR", 0 },
      {0x117, "VIDEO_TDR_TIMEOUT_DETECTED", 0 },
      {0x119, "VIDEO_SCHEDULER_INTERNAL_ERROR", 0 },
      {0x11A, "EM_INITIALIZATION_FAILURE", 0 },
      {0x1000007E, "SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M", 0 },
      {0x1000007F, "UNEXPECTED_KERNEL_MODE_TRAP_M", 0 },
      {0x1000008E, "KERNEL_MODE_EXCEPTION_NOT_HANDLED_M", 0 },
      {0x100000EA, "THREAD_STUCK_IN_DEVICE_DRIVER_M", 0 },
      {0xC0000218, "STATUS_CANNOT_LOAD_REGISTRY_FILE", 0 },
      {0xC000021A, "STATUS_SYSTEM_PROCESS_TERMINATED", 0 },
      {0xC0000221, "STATUS_IMAGE_CHECKSUM_MISMATCH", 0 },
      {0xDEADDEAD, "MANUALLY_INITIATED_CRASH1", 0 },
	{0, NULL, NULL},
	};

```

`source/WispSyser/callstackwnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "callstackwnd.hpp"
#include "syserconfig.hpp"

	CCallStackWnd::CCallStackWnd()
	{
	}
	CCallStackWnd::~CCallStackWnd()
	{
	}

	WISP_MSG_MAP_BEGIN(CCallStackWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)


	WISP_EVENT_MAP_BEGIN(CCallStackWnd)
//		WISP_EVENT_MAP(..., OnEvent...)
	WISP_EVENT_MAP_END


	bool CCallStackWnd::OnCreate(WISP_MSG *pMsg)
	{
		AttachTitleDIB(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x12));
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		m_ColorFocus = gSyserColors.Color[2];
		InsertColumn(WSTR("Call Return"), 100, 0, 0, -1);
		InsertColumn(WSTR("Function"), 200, 0, 0, -1);
		m_Style |= 0x3000000;
		return true;
	}
	bool CCallStackWnd::OnClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}

	void CCallStackWnd::Create()
	{
		if (IsWindow())
		{
			Destroy();
		} else
		{
			CreateWnd(WSTR("Call Stack"), 0,0,400,200, 0, 0xC, 0x100BB, WISP_SH_MINSIZE);
			Center(0);
			UpdateContext();
		}
	}

	void CCallStackWnd::OnMouseDblClick(CListStringItem *Item, int nCol)
	{
		SetLineItem(Item);
		CCallStack::Frame *pFrame = (CCallStack::Frame *)GetItemValue(m_pItem, 0);
		ULONG_PTR Addr = pFrame->Return;

		CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(Addr);
		if (pSDSMod)	
		{
			TList<FilesLN*> ListFilesLN;
			gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.ExpandSDSModule(pSDSMod);
			if (pSDSMod->GetFilesLN(Addr - pSDSMod->m_pDbgModule->m_ImageBase, &ListFilesLN))
			{
				gpSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(SRC_TAB); //SRC_TAB(2)
				FilesLN *fln = *ListFilesLN[0];
				if (gpSyser->m_MainFrame.m_SourceDebugFrameWnd.OpenSrcView(pSDSMod,
					fln->FileID,
					fln->lineNumber))
				{
					return;
				}
			}
		}
		gpSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(CV_TAB); //CV_TAB(0)
		gpSyser->m_MainFrame.m_SystemExplorer.SelectCodeAddress(Addr);
	}

	void CCallStackWnd::SetLineItem(CListStringItem *Item)
	{
		if (m_pItem != Item)
		{
			WCHAR Text[128];

			if (m_pItem != 0)
			{
				SetItemColor(m_pItem, -1, gSyserColors.Color[1]);
				CCallStack::Frame *pFrame = (CCallStack::Frame *)GetItemValue(m_pItem, 0);
				TSPrintf(Text, WSTR("  " F0ADDR "X"), pFrame->Return);
				SetItemText(m_pItem, 0, Text);
			}
			m_pItem = Item;
			SetItemColor(Item, -1, gSyserColors.Color[5]);
			CCallStack::Frame *pFrame = (CCallStack::Frame *)GetItemValue(m_pItem, 0);
			TSPrintf(Text, WSTR("->" F0ADDR "X"), pFrame->Return);
			SetItemText(Item, 0, Text);
		}
	}

	void CCallStackWnd::UpdateContext()
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && IsWindowShow())
		{
			m_pItem = 0;
			DeleteAllChildrenItems(0);
			TListIter<CCallStack::Frame> It = gpSyser->m_SyserUI.m_CallStack.m_Frames.Begin();
			while (It != gpSyser->m_SyserUI.m_CallStack.m_Frames.End())
			{
				WCHAR szReturn[128];
				TSPrintf(szReturn, WSTR("  " F0ADDR "X"), It->Return);
				CListStringItem *Item = InsertItem(szReturn, 0, 0, 0, -1);
				SetItemText(Item, 1, It->FuncName.operator const char*());
				SetItemValue(Item, 0, (unsigned long long)&*It);

				if (gpSyser->m_SyserUI.m_CallStack.m_HeadIt == It)
					SetLineItem(Item);
				++It;
			}
		}
	}

```

`source/WispSyser/callstackwnd.hpp`:

```hpp

#ifndef _CALLSTACKWND_HPP_
#define _CALLSTACKWND_HPP_

#include "../Wisp/wisplist.hpp"

struct CCallStackWnd : public CWispList
{
	CListStringItem *m_pItem;

	CCallStackWnd();
	virtual ~CCallStackWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnClose(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	virtual void OnMouseDblClick(CListStringItem *Item, int nCol) override;

	void SetLineItem(CListStringItem *Item);
	void UpdateContext();

	void Create();
};

#endif
```

`source/WispSyser/codebpedit.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "codebpedit.hpp"

WISP_FORM_RES_ITEM CodeBPEditForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 385, 280}, 0, 0xB, WSTR("Code break point"), 0, 0},
	{WISP_CTRL_STATIC_GROUP, {10, 10, 325, 40}, 0, 0, WSTR("Address"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {20, 25, 16, 16}, 0, 0, 0, (void*)"\\Toolbar.bmp#16#16:243", 0},
	{WISP_CTRL_EDIT, {40, 25, 285, 16}, 1, 0x1000006, 0, 0, WSTR("Address of break point")},
	{WISP_CTRL_STATIC_GROUP, {10, 60, 325, 40}, 0, 0, WSTR("Name"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {20, 75, 16, 16}, 0, 0, 0, (void*)"\\Toolbar.bmp#16#16:10", 0},
	{WISP_CTRL_EDIT, {40, 75, 285, 16}, 2, 0x1000006, 0, 0, WSTR("Name of break point (if needed)")},
	{WISP_CTRL_STATIC_GROUP, {10, 110, 325, 40}, 0, 0, WSTR("Condition"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {20, 125, 16, 16}, 0, 0, 0, (void*)"\\Toolbar.bmp#16#16:29", 0},
	{WISP_CTRL_EDIT, {40, 125, 285, 16}, 4, 0x1000006, 0, 0, WSTR("break condition when break point touched")},
	{WISP_CTRL_STATIC_GROUP, {10, 160, 325, 40}, 0, 0, WSTR("Do Command (Use ; to delimit command lines)"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {20, 175, 16, 16}, 0, 0, 0, (void*)"\\Toolbar.bmp#16#16:63", 0},
	{WISP_CTRL_EDIT, {40, 175, 285, 16}, 5, 0x1000006, 0, 0, WSTR("Do command when break point touched")},
	{WISP_CTRL_CHECK_BOX, {20, 210, 60, 20}, 3, 0x20000000, WSTR("Enabled"), 0, WSTR("Is break point enabled")},
	{WISP_CTRL_BUTTON, {275, 210, 55, 20}, WISP_ID_OK, 0, WSTR("OK"), 0, WSTR("Save modify setting")},
	{0},
};

	WISP_MSG_MAP_BEGIN(CCodeBPEdit)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP_ON_COMMAND
	WISP_MSG_MAP_END(CWispForm)

	WISP_CMD_MAP_BEGIN(CCodeBPEdit)
		WISP_CMD_MAP(1, OnCmdEdit)
		WISP_CMD_MAP(WISP_ID_OK, OnCmdOK)
	WISP_CMD_MAP_END

	CCodeBPEdit::CCodeBPEdit()
	{
		m_pModuleBP = 0;
		m_pBP = 0;
		m_Resource = CodeBPEditForm;
	}

	CCodeBPEdit::~CCodeBPEdit()
	{
	}

	bool CCodeBPEdit::OnCreateForm(WISP_MSG *pMsg)
	{
		WCHAR Buffer[256];

		m_pName = (CWispEdit *)GetFormItem(2);
		m_pAddress = (CWispEdit *)GetFormItem(1);
		m_pCondition = (CWispEdit *)GetFormItem(4);
		m_pCommand = (CWispEdit *)GetFormItem(5);
		m_pEnable = (CWispCheckBox *)GetFormItem(3);

		m_bEnableBP = true;
		if (m_pBP)
		{
			uNumToStr(m_pBP->Address, Buffer, 16);
			m_pAddress->SetWindowText(Buffer);
			AnsiToUnicode(m_pBP->Name.operator const char*(), Buffer, lenof(Buffer));
			m_pName->SetWindowText(Buffer);
			AnsiToUnicode(m_pBP->Condition.operator const char*(), Buffer, lenof(Buffer));
			m_pCondition->SetWindowText(Buffer);
			AnsiToUnicode(m_pBP->Command.operator const char*(), Buffer, lenof(Buffer));
			m_pCommand->SetWindowText(Buffer);
			m_bEnableBP = m_pBP->State != BP_STATE_DISABLE;
		} else
		if (m_pModuleBP)
		{
			typedef _Tmap_pair<ULONG_PTR, BREAK_POINT::MODULE> PBP;
			PBP *p = CONTAINING_RECORD_MY1(m_pModuleBP, PBP, second);
			ULONG_PTR Address = p->first; //-4 m_pModuleBP-4 TODO
			uNumToStr(Address, Buffer, 16);
			m_pAddress->SetWindowText(Buffer);
			AnsiToUnicode(m_pModuleBP->Name.operator const char*(), Buffer, lenof(Buffer));
			m_pName->SetWindowText(Buffer);
			AnsiToUnicode(m_pModuleBP->Condition.operator const char*(), Buffer, lenof(Buffer));
			m_pCondition->SetWindowText(Buffer);
			AnsiToUnicode(m_pModuleBP->Command.operator const char*(), Buffer, lenof(Buffer));
			m_pCommand->SetWindowText(Buffer);
			m_bEnableBP = m_pModuleBP->State != BP_STATE_DISABLE;
		}
		m_pEnable->Enable(m_bEnableBP);
		return true;
	}

	bool CCodeBPEdit::OnCmdEdit(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000705) //WISP_ID_EDIT_CHANGED
		{
			m_pName->SetWindowText(m_pAddress->m_WndText.operator const WCHAR*());
		}
		return true;
	}

	bool CCodeBPEdit::OnCmdOK(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg != 0x80000002)
			return true;

		BREAK_POINT BreakPoint;
		if (!m_pAddress->m_WndText.m_nLength)
		{
			gpCurWisp->MsgBox(WSTR("Invalid Address !"), WSTR("Error"), 0x40001, 0);
			return false;
		}

		if (!gpSyser->m_SyserUI.CalcExp(m_pAddress->m_WndText.operator const WCHAR*(), &BreakPoint.Address))
		{
			gpCurWisp->MsgBox(WSTR("Invalid Address !"), WSTR("Error"), 0x40001, 0);
			return false;
		}

		char Buffer[256];

		UnicodeToAnsi(m_pName->m_WndText.operator const WCHAR*(), Buffer, lenof(Buffer));
		BreakPoint.Name = Buffer;
		if (BreakPoint.Name.IsEmpty())
			BreakPoint.Name.Format("" F0ADDR "X", BreakPoint.Address);

		ULONG_PTR Result;
		if (!gpSyser->m_SyserUI.CalcExp(m_pCondition->m_WndText.operator const WCHAR*(), &Result))
		{
			gpCurWisp->MsgBox(WSTR("Invalid Address !"), WSTR("Error"), 0x40001, 0);
			return false;
		}

		UnicodeToAnsi(m_pCondition->m_WndText.operator const WCHAR*(), Buffer, lenof(Buffer));
		BreakPoint.Condition = Buffer;

		UnicodeToAnsi(m_pCommand->m_WndText.operator const WCHAR*(), Buffer, lenof(Buffer));
		BreakPoint.Command = Buffer;
		
		m_bEnableBP = (m_pEnable->m_Style >> 10) & 1;

		BreakPoint.Type = 1;
		BreakPoint.State = m_bEnableBP ? BP_STATE_ENABLE : BP_STATE_DISABLE;

		if (m_pBP)
		{
			if (BreakPoint.Address == m_pBP->Address &&
			    BreakPoint.State == m_pBP->State)
			{
				m_pBP->Name = BreakPoint.Name;
				m_pBP->Condition = BreakPoint.Condition;
				m_pBP->Command = BreakPoint.Command;
				return true;
			}
			if (!gpSyser->m_SyserUI.RemoveBP(m_pBP->Address))
			{
				gpCurWisp->MsgBox(WSTR("Fail to remove breakpoint !"), WSTR("Error"), 0x40001, 0);
				return false;
			}
		} else
		if (m_pModuleBP)
		{
			typedef _Tmap_pair<ULONG_PTR, BREAK_POINT::MODULE> PBP;
			PBP *p = CONTAINING_RECORD_MY1(m_pModuleBP, PBP, second);
			ULONG_PTR Address = p->first; //-4 m_pModuleBP-4 TODO
			if (BreakPoint.Address == Address &&
			    BreakPoint.State == m_pModuleBP->State)
			{
				m_pModuleBP->Name = BreakPoint.Name;
				m_pModuleBP->Condition = BreakPoint.Condition;
				m_pModuleBP->Command = BreakPoint.Command;
				return true;
			}
			if (!gpSyser->m_SyserUI.RemoveBP(Address))
			{
				gpCurWisp->MsgBox(WSTR("Fail to remove breakpoint !"), WSTR("Error"), 0x40001, 0);
				return false;
			}
		}


		if (!gpSyser->m_SyserUI.InsertBP(BreakPoint.Address,
				BreakPoint.Name.operator const char*(),
				BreakPoint.Condition.operator const char*(),
				BreakPoint.Command.operator const char*()))
		{
			gpCurWisp->MsgBox(WSTR("Fail to insert breakpoint !"), WSTR("Error"), 0x40001, 0);
			return false;
		}

		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		return true;
	}

```

`source/WispSyser/codebpedit.hpp`:

```hpp

#ifndef _CODEBPEDIT_HPP_
#define _CODEBPEDIT_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wispedit.hpp"
#include "../Wisp/wispcheckbox.hpp"
#include "../EXEAnalyzer/debugger.hpp"

struct CCodeBPEdit : public CWispForm
{
	BREAK_POINT *m_pBP;
	BREAK_POINT::MODULE *m_pModuleBP;
	CWispEdit *m_pName;
	CWispEdit *m_pAddress;
	CWispEdit *m_pCondition;
	CWispEdit *m_pCommand;
	CWispCheckBox *m_pEnable;
	bool m_bEnableBP;

	CCodeBPEdit();
	virtual ~CCodeBPEdit();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);

	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdEdit(WISP_MSG *pMsg);
	bool OnCmdOK(WISP_MSG *pMsg);
};

#endif

```

`source/WispSyser/codeview.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "codeview.hpp"
#include "syserconfig.hpp"
#include "resource.hpp"

	WISP_MSG_MAP_BEGIN(CCodeView)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_CREATING, CWispList::OnCreating)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP(WISP_WM_CHAR, OnChar)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
		WISP_MSG_MAP(WISP_WM_SCROLL_EVENT, OnScrollEvent)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	WISP_EVENT_MAP_BEGIN(CCodeView)
		WISP_EVENT_MAP(EVENT_ID_NEXTPOS, OnEventNextPos)
		WISP_EVENT_MAP(EVENT_ID_PREVPOS, OnEventPrevPos)
		WISP_EVENT_MAP(EVENT_ID_SAVEPOS, OnEventSavePos)
		WISP_EVENT_MAP(EVENT_ID_CLRPOS, OnEventResetPos)
		WISP_EVENT_MAP(EVENT_ID_SEARCH_TRANSFER_REF, OnEventSearchTrRef)
		WISP_EVENT_MAP(EVENT_ID_SEARCH_OPERAND_REF, OnEventSearchOpRef)

		WISP_EVENT_MAP(EVENT_ID_TOGGLE_BM, OnEventToggleBM)

		WISP_EVENT_MAP(EVENT_ID_FOLLOW_CIP_AUTO, OnEventFollowAuto)
		WISP_EVENT_MAP(EVENT_ID_FOLLOW_CIP_SYSEXPLORER, OnEventFollowCodeView)
		WISP_EVENT_MAP(EVENT_ID_FOLLOW_CIP_SRCEXPLORER, OnEventFollowSourceView)

		WISP_EVENT_MAP(EVENT_ID_IDENTIFY_FUNCTION, OnEventAnalyze)

		WISP_EVENT_MAP(EVENT_ID_CV_ADDR_MODE, OnEventModeAddr)
		WISP_EVENT_MAP(EVENT_ID_CV_OFFSET_MODE, OnEventModeOffs)
		WISP_EVENT_MAP(EVENT_ID_CV_SWITCH_SYM, OnEventSymSwitch)
		WISP_EVENT_MAP(EVENT_ID_CV_FULL_SYM, OnEventFullSym)

		WISP_EVENT_MAP(EVENT_ID_REL_CIP, OnEventModeRelCIP)
		WISP_EVENT_MAP(EVENT_ID_EDIT_CODE, OnEventEditCode)
		WISP_EVENT_MAP(EVENT_ID_EDIT_CMT, OnEventEditComment)
		WISP_EVENT_MAP(EVENT_ID_STRREF, OnEventStrRef)
//		WISP_EVENT_MAP(EVENT_ID_STRFIND, OnEventStrFind)
		WISP_EVENT_MAP(EVENT_ID_CV_NEXT_CIP, OnEventNextCIPTrace)
		WISP_EVENT_MAP(EVENT_ID_CV_PREV_CIP, OnEventPrevCIPTrace)
		WISP_EVENT_MAP(EVENT_ID_CV_SHOW_AT, OnEventShowAt)
		WISP_EVENT_MAP(EVENT_ID_CV_NEXT, OnEventNextAddr)
		WISP_EVENT_MAP(EVENT_ID_CV_PREV, OnEventPrevAddr)

		WISP_EVENT_MAP(EVENT_ID_CV0, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_CV1, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_CV2, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_CV3, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_CV4, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_CV5, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_CV6, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_CV7, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_CV8, OnEventNewView)

		WISP_EVENT_MAP(EVENT_ID_GOTO_HERE, OnEventGotoHere)

		WISP_EVENT_MAP(EVENT_ID_INSREMBP, OnEventToggleAddBP)
		WISP_EVENT_MAP(EVENT_ID_ENDISMBP, OnEventToggleEnableBP)
		WISP_EVENT_MAP(WISP_ID_COPY, OnEventCopy)
	WISP_EVENT_MAP_END

	WISP_CMD_MAP_BEGIN(CCodeView)
		WISP_CMD_MAP(EVENT_ID_STRFIND, OnCmdFindString)
		WISP_CMD_MAP(WISP_ID_VSPIN_SCROLL, OnCmdVSpinScroll)
	WISP_CMD_MAP_END


	CCodeView::CCodeView()
	{
		m_CurAddr = 0;
		m_szKeyword[0] = 0;
		m_HistoryIter = m_History.End(); //???
		m_nScrollLine = 2;
	}

	CCodeView::~CCodeView()
	{
	}

WISP_MENU_GROUP_ITEM CodeViewPopupMenuCVMode[] =
{
	{WSTR("Symbol Switch        Tab"), EVENT_ID_CV_SWITCH_SYM, 0, 2, 0},
	{WSTR("Full Symbol          Ctrl+Tab"), EVENT_ID_CV_FULL_SYM, 0, 2, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Address Mode"), EVENT_ID_CV_ADDR_MODE, 0, 2, 0},
	{WSTR("Offset  Mode"), EVENT_ID_CV_OFFSET_MODE, 0, 2, 0},
	{WSTR("Relative to " CIPSTR ""), EVENT_ID_REL_CIP, 0, 2, 0},
	{0},
};

WISP_MENU_GROUP_ITEM CodeViewPopupMenuFolowMode[] =
{
	{WSTR("Automatic"), EVENT_ID_FOLLOW_CIP_AUTO, 0, 2, 0},
	{WSTR("System Explorer"), EVENT_ID_FOLLOW_CIP_SYSEXPLORER, 0, 2, 0},
	{WSTR("Source Code Explorer"), EVENT_ID_FOLLOW_CIP_SRCEXPLORER, 0, 2, 0},
	{0},
};

WISP_MENU_GROUP_ITEM CodeViewPopupMenu[] =
{
	{WSTR("Insert/Remove  Breakpoint      F9"), EVENT_ID_INSREMBP, 0xF3, 0, 0},
	{WSTR("Enable/Disable Breakpoint"), EVENT_ID_ENDISMBP, 0xF4, 0, 0},
	{WSTR("Toggle BookMark                Ctrl+K"), EVENT_ID_TOGGLE_BM, 0xD0, 0, 0},
	{WSTR("Save Position                  Shift+Enter"), EVENT_ID_SAVEPOS, 0x18, 0, 0},
	{WSTR("Identify standard C(++) Library Function"), EVENT_ID_IDENTIFY_FUNCTION, 0x6F, 0, 0},
	{WSTR("Go To Here                     F7"), EVENT_ID_GOTO_HERE, 0x10D, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Search Transfer Reference"), EVENT_ID_SEARCH_TRANSFER_REF, 0x118, 0, 0},
	{WSTR("Search Operand Reference"), EVENT_ID_SEARCH_OPERAND_REF, 0x119, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Code View Mode"), 0, 0x3D, 1, CodeViewPopupMenuCVMode},
	{WSTR("" CIPSTR " Follow Mode"), 0, 0x10, 1, CodeViewPopupMenuFolowMode},
	{WSTR("Copy"), WISP_ID_COPY, 0x23, 0, 0},
	{WSTR("Edit Code"), EVENT_ID_EDIT_CODE, 0x7E, 0, 0},
	{WSTR("Edit Comment"), EVENT_ID_EDIT_CMT, 0x93, 0, 0},
	{WSTR("String Reference"), EVENT_ID_STRREF, 0x93, 0, 0},
	{0},
};

	bool CCodeView::OnUpdate(WISP_MSG *pMsg)
	{
		m_Color[1] = gSyserColors.Color[6];

		m_Color[2] = gSyserColors.Color[9];
		m_Color[3] = gSyserColors.Color[10];
		m_Color[4] = gSyserColors.Color[11];
		m_Color[5] = gSyserColors.Color[12];
		m_Color[6] = gSyserColors.Color[13];
		m_Color[7] = gSyserColors.Color[14];
		m_Color[8] = gSyserColors.Color[15];
		m_Color[9] = gSyserColors.Color[16];
		m_Color[10] = gSyserColors.Color[17];
		m_Color[11] = gSyserColors.Color[18];
		m_Color[12] = gSyserColors.Color[19];
		m_Color[13] = gSyserColors.Color[20];
		m_Color[14] = gSyserColors.Color[21];
		m_Color[15] = gSyserColors.Color[22];
		m_Color[16] = gSyserColors.Color[23];
		m_Color[17] = gSyserColors.Color[24];
		m_Color[18] = gSyserColors.Color[25];
		m_Color[19] = gSyserColors.Color[26];
		m_Color[20] = gSyserColors.Color[27];
		m_Color[21] = gSyserColors.Color[28];
		m_Color[22] = gSyserColors.Color[29];
		m_Color[23] = gSyserColors.Color[30];
		m_Color[24] = gSyserColors.Color[31];
		m_Color[25] = gSyserColors.Color[32];
		m_Color[26] = gSyserColors.Color[33];

		m_ColorFocus = gSyserColors.Color[7];
		m_ColorUnFocus = gSyserColors.Color[8];

		m_ClientDC.m_pColor = m_Color;

		SetBGColor(m_Color[COLOR_BG]);

		UpdateDasm();
		return true;//CWispWnd::OnUpdate(pMsg);
	}

	bool CCodeView::OnCreate(WISP_MSG *pMsg)
	{
		m_Color[1] = gSyserColors.Color[6];

		m_Color[2] = gSyserColors.Color[9];
		m_Color[3] = gSyserColors.Color[10];
		m_Color[4] = gSyserColors.Color[11];
		m_Color[5] = gSyserColors.Color[12];
		m_Color[6] = gSyserColors.Color[13];
		m_Color[7] = gSyserColors.Color[14];
		m_Color[8] = gSyserColors.Color[15];
		m_Color[9] = gSyserColors.Color[16];
		m_Color[10] = gSyserColors.Color[17];
		m_Color[11] = gSyserColors.Color[18];
		m_Color[12] = gSyserColors.Color[19];
		m_Color[13] = gSyserColors.Color[20];
		m_Color[14] = gSyserColors.Color[21];
		m_Color[15] = gSyserColors.Color[22];
		m_Color[16] = gSyserColors.Color[23];
		m_Color[17] = gSyserColors.Color[24];
		m_Color[18] = gSyserColors.Color[25];
		m_Color[19] = gSyserColors.Color[26];
		m_Color[20] = gSyserColors.Color[27];
		m_Color[21] = gSyserColors.Color[28];
		m_Color[22] = gSyserColors.Color[29];
		m_Color[23] = gSyserColors.Color[30];
		m_Color[24] = gSyserColors.Color[31];
		m_Color[25] = gSyserColors.Color[32];
		m_Color[26] = gSyserColors.Color[33];

		m_ColorFocus = gSyserColors.Color[7];
		m_ColorUnFocus = gSyserColors.Color[8];

		m_ClientDC.m_pColor = m_Color;

		m_PopupMenu.LoadPopupMenuGroup(CodeViewPopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		m_DIBList.Load("\\SyserIcon\\CodeView.bmp", 16, 16, 4);
		m_DIBList.SetType(2);
		m_DIBList.SetColorKey(0xFFFF);

		int Ext = m_ClientDC.GetTextExtent(WSTR("X"), -1, 0);
		InsertColumn(WSTR("Pic"), 20, 2, 0, -1);// CV_START = 0
		InsertColumn(WSTR("Address"), (1+ADDR_SIZE) * Ext + 3, 0, 0, -1);// CV_ADDR = 1
		InsertColumn(WSTR("Bin"), (7+ADDR_SIZE) * Ext, 0, 0, -1);// CV_CODE = 2
		InsertColumn(WSTR("Code"), (27+ADDR_SIZE) * Ext, 0, 0, -1);// CV_INST = 3
		InsertColumn(WSTR("Comment"), 200, 1, 0, -1);// CV_CMT = 4
		Recalc(0);
		m_Style |= 0x3000000;
		SetBGColor(m_Color[COLOR_BG]);
		m_pScrollBar[0]->Style = 0;
		m_pScrollBar[0]->bHide = 0;
		m_Mode = 0;
		m_LineJmpWidth = 13;
		m_pLineMarkDIBList = gpCurWisp->m_DIBLib.LoadDIBList("\\SyserApp\\LineMark.bmp", 16, 16, 0, 0xFF00FF);
		m_pLineMarkDIBList->SetColorKey(0);
		LoadKeyMap();
		return true;
	}
	bool CCodeView::OnDestroy(WISP_MSG *pMsg)
	{
		m_DIBList.Destroy();
		m_PopupMenu.Destroy();
		return true;
	}

	void CCodeView::OnKeyLButton(WISP_MSG *pMsg)
	{
		TListIter<CListStringItem> Iter;
		int Len = TStrLen(m_szKeyword);
		int nCol = Point2Iter(&pMsg->m_LogicMousePosWnd, Iter);
		//if (nCol >= 1 && nCol <= 4096)
		if (nCol == CV_INST)
		{
			CListStringItem *Item = &*Iter;
			if (Item)
			{
				CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
				const WCHAR *pStr = Content->String.operator const WCHAR*();
				if (pStr)
				{
					WCHAR Buffer[512];
					if (IsColorString(pStr))
					{
						TStrCpyLimit(Buffer, ((unsigned long*)pStr)+1, 512);
						pStr = Buffer;
					}

					int l = TStrLen(pStr);
					WISP_RECT Rect;
					GetItemRect(Item, nCol, &Rect);
		#define IS_KEYWORD(c) (IS_DIGIT(c) || IS_LETTER(c) || (c)=='_')
					int Ext = m_ClientDC.GetTextLen(pStr, m_pWispBase->m_MousePT.x - m_ScrClientRect.x - Rect.x);

					if (Ext != -1 && IS_KEYWORD(pStr[Ext]))
					{
						int found = 0;
						int i = 0;
						for (i = 0; i < l; ++i)
						{
							if (!IS_KEYWORD(pStr[i]))
							{
								if (i>Ext) break;
								found = i+1;
							}
						}
						int klen = i - found;
						TStrNCpy(m_szKeyword, &Buffer[found], klen);
						m_szKeyword[klen]=0;
						UpdateDasm();
						return; //???
					}
				}
			}
		}

		if (Len)
		{
			m_szKeyword[0] = 0;
			UpdateDasm();
		}
	}

	void CCodeView::OnKeyRButton(WISP_MSG *pMsg)
	{
		if (Point2Index(&pMsg->m_LogicMousePosWnd, &m_nRButtonCol))
		{
			if (m_nRButtonCol >= 1 && m_nRButtonCol <= 4096)
			{
				m_pRButtonItem = FindItem(0, 8);
				if (m_pRButtonItem)
				{
					ULONG_PTR Addr = GetItemValue(m_pRButtonItem, CV_ADDR);

					bool bEnableEdit = GetItemContent(m_pRButtonItem, CV_CODE)->String.m_nLength != 0;
					m_PopupMenu.Enable(EVENT_ID_EDIT_CODE, bEnableEdit);
					m_PopupMenu.Enable(EVENT_ID_EDIT_CMT, bEnableEdit);

					m_PopupMenu.Enable(EVENT_ID_PREVPOS, m_HistoryIter != m_History.Begin());
					m_PopupMenu.Enable(EVENT_ID_NEXTPOS, m_HistoryIter != m_History.End()-1);
					m_PopupMenu.Enable(EVENT_ID_CLRPOS, m_History.Size() > 1);

					m_PopupMenu.Checked(EVENT_ID_CV_SWITCH_SYM, m_pSyserCodeDoc->m_Style & 1);

					m_PopupMenu.Checked(EVENT_ID_CV_FULL_SYM, gSyserConfig.iShowFullSym != 0);

					m_PopupMenu.Checked(EVENT_ID_CV_ADDR_MODE, m_Mode == 0);
					m_PopupMenu.Checked(EVENT_ID_CV_OFFSET_MODE, m_Mode == 1);
					m_PopupMenu.Checked(EVENT_ID_REL_CIP, m_Mode == 2);

					m_PopupMenu.Checked(EVENT_ID_FOLLOW_CIP_AUTO, gSyserConfig.iFollowMode == 0);
					m_PopupMenu.Checked(EVENT_ID_FOLLOW_CIP_SYSEXPLORER, gSyserConfig.iFollowMode == 1);
					m_PopupMenu.Checked(EVENT_ID_FOLLOW_CIP_SRCEXPLORER, gSyserConfig.iFollowMode == 2);

					m_PopupMenu.Point(0, 1);
				}
			}
		}
	}

	bool CCodeView::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (!pMsg->KeyEvent.bKeyDown) return true;

		map<unsigned int, unsigned int>::IT it = m_KeyMap.find(pMsg->KeyEvent.KeyType);
		if (it != m_KeyMap.end())
		{
			WISP_MSG Msg;
			Msg.Command.CmdID = it->second;
			return OnEvent(&Msg);
		}
		int Size;
		switch (pMsg->KeyEvent.KeyType)
		{
		case VK_LBUTTON:
			OnKeyLButton(pMsg); //Keyword
			break;
		case VK_RBUTTON:
			OnKeyRButton(pMsg); //Menu
			break;
		case 0x53: //S
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.GetSize(1, &Size);
			Size += 10;
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.SetSize(1, Size);
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.AdjustWndPos();
			return false;
			break;
		case 0x57: //W
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.GetSize(1, &Size);
			if (Size <= 10)
				Size = 0;
			else	Size -= 10;
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.SetSize(1, Size);
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.AdjustWndPos();
			return false;
			break;
		}
		return true;
	}

	bool CCodeView::OnEventShowAt(WISP_MSG *pMsg)
	{
		if (m_pSyserCodeDoc && m_pSyserCodeDoc->m_bOpen)
		{
			CListStringItem *Item = GetNext(0, 8);
			if (Item)
			{
				ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
				ULONG_PTR NewAddr;
				ULONG_PTR NewImm;
				ULONG_PTR Mem;
				if (m_pSyserCodeDoc->GetAddr(Addr, &NewAddr))
				{
					if (m_HistoryIter != m_History.End()-1)
					{
						m_HistoryIter++;
						m_History.Remove(m_HistoryIter, m_History.End());
						m_HistoryIter = m_History.End();
					}
					GotoAddr(NewAddr, true);
				} else
				if (m_pSyserCodeDoc->GetAddrImm(Addr, &NewAddr, &NewImm))
				{
					if (NewImm != -1)
					{
						CDataView *pWnd = (CDataView*)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd();
						pWnd->ViewAddress(NewImm, true);
					} else
					if (NewAddr != -1 && m_pSyserCodeDoc->ReadMemory(NewAddr, &Mem, sizeof(Mem)) == sizeof(Mem))
					{
						CDataView *pWnd = (CDataView*)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd();
						pWnd->ViewAddress(NewAddr, true);
					}
				}
			}
		}
		return true;
	}

	bool CCodeView::OnMouseDblClick(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			CListStringItem *Item = GetItem(0, 0);
			WISP_RECT Rect;
			GetItemRect(Item, CV_INST, &Rect);
			if (pMsg->MsgMouseWndPT.x >= Rect.x && pMsg->MsgMouseWndPT.x <= Rect.x + Rect.cx)
			{
                        	OnEventShowAt(pMsg);
			}
		}
		return true;
	}
	bool CCodeView::OnSize(WISP_MSG *pMsg)
	{
		SetScrollBarInfo(0, m_nVSBPage * m_nScrollLine, m_nVSBPage * (2 * m_nScrollLine + 1), m_nVSBPage, 0, 0);
		UpdateDasm();
		return true;
	}
	bool CCodeView::OnUpdateClient(WISP_MSG *pMsg)
	{
		CWispList::OnUpdateClient(pMsg);
		
		WISP_RECT Rect;
		Rect.cx = 16;
		Rect.cy = 16;
		Rect.x = 2;
		Rect.y = m_nLayoutHeight;

		CListStringItem *Item = GetRootItem();
		while (Item)
		{
			unsigned char pic = GetItemValue(Item, CV_START);
			if (pic & 8)
				m_ClientDC.DrawDIB(&Rect, m_pLineMarkDIBList->GetDIB(1));
			//??? else
			if (pic & 1)
				m_ClientDC.DrawDIB(&Rect, m_pLineMarkDIBList->GetDIB(0));
			//??? else
			if (pic & 2)
				m_ClientDC.DrawDIB(&Rect, m_pLineMarkDIBList->GetDIB(2));
			else
			if (pic & 4)
				m_ClientDC.DrawDIB(&Rect, m_pLineMarkDIBList->GetDIB(4));
			Rect.y += m_nLineHeight;
			Item = GetNext(Item, 0);
		}

		ULONG_PTR Addr;
		Item = FindItem(0, 8);
		if (Item) Addr = GetItemValue(Item, CV_ADDR);
		else Addr = 0;

		int LineJmp = -1;
		int CurLineJmp = -1;

		for (int i = 0; i < m_LineJmpCount; ++i)
		{
			if (i != m_CurLineJmp)
			{	
				if (Addr && Addr == m_LineDIB[i].eip)
					CurLineJmp = i;
				else	DrawLineJmp(&m_LineDIB[i], i, m_Color[COLOR_JMP_LINE]);
				LineJmp = CurLineJmp;
			}
		}
		if (LineJmp >= 0)
			DrawLineJmp(&m_LineDIB[LineJmp], LineJmp, gSyserColors.Color[7]); //FOCUS

		if (m_CurLineJmp >= 0 && m_CurLineJmp < m_LineJmpCount)
			DrawLineJmp(&m_LineDIB[m_CurLineJmp], m_CurLineJmp, m_Color[COLOR_ACTIVE_JMP_LINE]);
		return false;
	}
	bool CCodeView::OnChar(WISP_MSG *pMsg)
	{
		if (!IS_LOWER(pMsg->Char.Char))
			return true;

		gpSyser->m_MainFrame.m_SystemExplorer.m_TerminalWnd.Focus();
		WISP_MSG Msg;
		memcpy(&Msg, pMsg, sizeof(Msg));
		Msg.hWnd = &gpSyser->m_MainFrame.m_SystemExplorer.m_TerminalWnd;
		m_pWispBase->SendMessage(&Msg);
		return false;
	}
	bool CCodeView::OnGetFocus(WISP_MSG *pMsg)
	{
		if (!FindItem(0, 8))
		{
			CListStringItem *Item = FindItem(0, 0);
			if (Item)
				Select(Item);
		}
		return true;
	}
	bool CCodeView::OnScrollEvent(WISP_MSG *pMsg)
	{
		if (pMsg->ScrollEvent.Type == WISP_SCROLL_BAR_VERT)
		{
			ULONG_PTR Addr;
			switch (pMsg->ScrollEvent.Event)
			{
			case WISP_SB_INC:
				Addr = m_pSyserCodeDoc->GetInstrAddress(m_CurAddr, 1);
			#if 0
				GotoAddr(Addr, false);
			#else
				if (m_CurAddr < Addr && Addr < (m_pSyserCodeDoc->m_EndAddr-m_nVSBPage+1))
					GotoAddr(Addr, false);
				else	GotoAddr(m_pSyserCodeDoc->m_EndAddr-m_nVSBPage+1, false);
			#endif
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			case WISP_SB_DEC:
				Addr = m_pSyserCodeDoc->GetInstrAddress(m_CurAddr, -1);
			#if 0
				GotoAddr(Addr, false);
			#else
				if (m_CurAddr > Addr && Addr > m_pSyserCodeDoc->m_BeginAddr)
					GotoAddr(Addr, false);
				else	GotoAddr(m_pSyserCodeDoc->m_BeginAddr, false);
			#endif
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			case WISP_SB_PAGE_UP:
				Addr = m_pSyserCodeDoc->GetInstrAddress(m_CurAddr, 1 - m_nVSBPage);
			#if 0
				GotoAddr(Addr, false);
			#else
				if (m_CurAddr > Addr && Addr > m_pSyserCodeDoc->m_BeginAddr)
					GotoAddr(Addr, false);
				else	GotoAddr(m_pSyserCodeDoc->m_BeginAddr, false);
			#endif
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			case WISP_SB_PAGE_DOWN:
				Addr = m_pSyserCodeDoc->GetInstrAddress(m_CurAddr, m_nVSBPage - 1);
			#if 0
				GotoAddr(Addr, false);
			#else
				if (m_CurAddr < Addr && Addr < (m_pSyserCodeDoc->m_EndAddr-m_nVSBPage+1))
					GotoAddr(Addr, false);
				else	GotoAddr(m_pSyserCodeDoc->m_EndAddr-m_nVSBPage+1, false);
			#endif
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			case WISP_SB_POS_CHANGE:
				Addr = m_pSyserCodeDoc->GetInstrAddress(m_CurAddr, pMsg->ScrollEvent.Delta);
				if (pMsg->ScrollEvent.Delta < 0)
				{
				#if 0
					GotoAddr(Addr, false);
				#else
					if (m_CurAddr > Addr && Addr > m_pSyserCodeDoc->m_BeginAddr)
						GotoAddr(Addr, false);
					else	GotoAddr(m_pSyserCodeDoc->m_BeginAddr, false);
				#endif
				} else
				if (pMsg->ScrollEvent.Delta > 0)
				{
				#if 0
					GotoAddr(Addr, false);
				#else
					if (m_CurAddr < Addr && Addr < (m_pSyserCodeDoc->m_EndAddr-m_nVSBPage+1))
						GotoAddr(Addr, false);
					else	GotoAddr(m_pSyserCodeDoc->m_EndAddr-m_nVSBPage+1, false);
				#endif
				}
				//GotoAddr(Addr, false);
				break;
			default:
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			}
		}
		return false;
	}

	bool CCodeView::OnCmdFindString(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}
	bool CCodeView::OnCmdVSpinScroll(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002)
			SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 0); //m_nItemCount
		return true;
	}

	bool CCodeView::OnEventResetPos(WISP_MSG *pMsg)
	{
		ResetPos();
		return true;
	}
	bool CCodeView::OnEventSavePos(WISP_MSG *pMsg)
	{
		SavePos();
		return true;
	}
	bool CCodeView::OnEventNextPos(WISP_MSG *pMsg)
	{
		NextPos();
		return true;
	}
	bool CCodeView::OnEventPrevPos(WISP_MSG *pMsg)
	{
		PrevPos();
		return true;
	}

	bool CCodeView::OnEventSearchOpRef(WISP_MSG *pMsg)
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		{
			CListStringItem *Item = FindItem(0, 8);
			if (Item)
			{
				ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
				OpenOpRefList(Addr);
			}
		}
		return true;
	}
	bool CCodeView::OnEventSearchTrRef(WISP_MSG *pMsg)
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		{
			CListStringItem *Item = FindItem(0, 8);
			if (Item)
			{
				ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
				OpenTRefList(Addr);
			}
		}
		return true;
	}

	bool CCodeView::GetOpRefList(ULONG_PTR Address, TList<ULONG_PTR> & Addrs, ULONG_PTR & Return)
	{
		if (!m_pSyserCodeDoc)
			return false;

		if (!m_pSyserCodeDoc->m_bOpen)
			return false;

		ULONG_PTR Ret;
		if (!m_pSyserCodeDoc->GetAddrValue(Address, &Ret))
			return false;

		Return = Ret;
		CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Address);
		if (!pDbgMod)
		{
	#ifdef _RING0_
			pDbgMod = gpSyser->m_pSysDebugger->GetModule(Address);
			if (!pDbgMod)
	#endif
				return false;
		}

		if (Ret < pDbgMod->m_ImageBase)
			return false;

		if (Ret >= pDbgMod->m_ImageBase + pDbgMod->m_ImageSize)
			return false;

	gpSyser->m_MainFrame.CreateProgress(WSTR(""), pDbgMod->m_ImageSize-3);
	unsigned long Progress = (pDbgMod->m_ImageSize-3)/100;

		for (unsigned long i = 0; i < pDbgMod->m_ImageSize-3; ++i)
		{
			ULONG_PTR Op;
			ULONG_PTR Offset = pDbgMod->m_ImageBase+i;

			if (m_pSyserCodeDoc->ReadMemory(Offset, &Op, sizeof(Op)) == sizeof(Op) && Op == Ret)
			{
				Addrs.Append(&Offset);
			}

	if (Progress && !(i%Progress))
	gpSyser->m_MainFrame.UpdateProgress(i);

		}
	gpSyser->m_MainFrame.DestroyProgress();
		return Addrs.Size();
	}

	bool CCodeView::OpenOpRefList(ULONG_PTR Address)
	{
		TList<ULONG_PTR> Addrs;
		if (GetOpRefList(Address, Addrs, Address))
		{
			if (gpSyser->m_MainFrame.m_CrossReferenceForm.IsWindow())
				gpSyser->m_MainFrame.m_CrossReferenceForm.Show(WISP_SH_MINSIZE);
			else	gpSyser->m_MainFrame.m_CrossReferenceForm.Create(0, WISP_SH_MINSIZE);
			gpSyser->m_MainFrame.m_CrossReferenceForm.OpenOpRefList(Addrs, Address);
		} else
		{
			gpSyser->m_MainFrame.m_SystemExplorer.m_TerminalWnd.Printf(WSTR("Can't find Operand Reference\n"));
		}
		return true;
	}

	unsigned long CCodeView::GetTRefList(ULONG_PTR Address, TList<ULONG_PTR> & Addrs)
	{
		CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Address);
		if (!pDbgMod)
		{
			if (gpSyser->m_pSysDebugger != gpSyser->m_pDebugger)
				pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(Address);
		}

		if (!pDbgMod) return 0;
		
		unsigned long CodeBufSize = 4096;
		unsigned char *pCodeBuf = new unsigned char[CodeBufSize+16];
		if (!pCodeBuf) return 0;

		//far jump
		ULONG_PTR CurAddr = pDbgMod->m_ImageBase;
		unsigned long n = 0;
		while (n < pDbgMod->m_ImageSize)
		{
			unsigned long remain = pDbgMod->m_ImageSize - n;
			MAX_LIMIT(CodeBufSize, remain);
			unsigned long result = gpSyser->m_pDebugger->ReadMemory(CurAddr, pCodeBuf, CodeBufSize);
			if (result == CodeBufSize)
			{
				unsigned long Size = CurAddr - (ULONG_PTR)pCodeBuf;
				unsigned long i = 0;
				while (i < (result-5))
				{
					//CInstrSym::GetJump
					if ((pCodeBuf[i] == 0xE9 || pCodeBuf[i] == 0xE8) &&
						Address == (i + *(unsigned long*)&pCodeBuf[i+1] + CurAddr + 5)) //??? long
					{
						ULONG_PTR p = (ULONG_PTR)pCodeBuf+n+Size;
						Addrs.Append(&p);
					} else
					if (pCodeBuf[i] == 0xF && (pCodeBuf[i+1] >= 0x80 && pCodeBuf[i+1] <= 0x8F) &&
						Address == (i + *(unsigned long*)&pCodeBuf[i+2] + CurAddr + 6)) //??? long
					{
						ULONG_PTR p = (ULONG_PTR)pCodeBuf+n+Size;
						Addrs.Append(&p);
					}
					++i;
				}

				unsigned long subi = i;
				while (subi < result)
				{
					if (pCodeBuf[subi] == 0xE9) break;
					if (pCodeBuf[subi] == 0xF) break;
					++subi;
				}

				if (subi != result)
				{
					*(unsigned long*)&pCodeBuf[CodeBufSize] = 0;
					unsigned long RSize = remain - CodeBufSize;
					MAX_LIMIT(RSize, 5);
					unsigned long newresult = gpSyser->m_pDebugger->ReadMemory(CurAddr + CodeBufSize, &pCodeBuf[CodeBufSize], RSize);
					if (newresult == RSize)
					{
						while (i < result)
						{
							//CInstrSym::GetJump
							if ((pCodeBuf[i] == 0xE9 || pCodeBuf[i] == 0xE8) &&
								Address == (i + *(unsigned long*)&pCodeBuf[i+1] + CurAddr + 5)) //??? long
							{
								ULONG_PTR p = (ULONG_PTR)pCodeBuf+n+Size;
								Addrs.Append(&p);
							} else
							if (pCodeBuf[i] == 0xF && (pCodeBuf[i+1] >= 0x80 && pCodeBuf[i+1] <= 0x8F) &&
								Address == (i + *(unsigned long*)&pCodeBuf[i+2] + CurAddr + 6)) //??? long
							{
								ULONG_PTR p = (ULONG_PTR)pCodeBuf+n+Size;
								Addrs.Append(&p);
							}
							++i;
						}
					}
				}
			}
			CurAddr += CodeBufSize;
			n += CodeBufSize;
		}

		//near jump
		CurAddr = Address - 0x80;
		if (gpSyser->m_pDebugger->ReadMemory(CurAddr, pCodeBuf, 256) == 256)
		{
			unsigned long Size = CurAddr - (ULONG_PTR)pCodeBuf;
			for (unsigned long n = 0; n < 255; ++n)
			{
				//CInstrSym::GetJump
				if ((pCodeBuf[n] == 0xEB || (pCodeBuf[n] >= 0x70 && pCodeBuf[n] <= 0x7F)) &&
				    (Address == n + (char)pCodeBuf[n+1] + CurAddr + 2))
				{
					ULONG_PTR p = (ULONG_PTR)pCodeBuf+n+Size;
					Addrs.Append(&p);
				}
			}
		}
		delete []pCodeBuf;
		
		return Addrs.Size();
	}

	bool CCodeView::OpenTRefList(ULONG_PTR Address)
	{
		TList<ULONG_PTR> Addrs;
		if (GetTRefList(Address, Addrs))
		{
			if (gpSyser->m_MainFrame.m_CrossReferenceForm.IsWindow())
				gpSyser->m_MainFrame.m_CrossReferenceForm.Show(WISP_SH_MINSIZE);
			else	gpSyser->m_MainFrame.m_CrossReferenceForm.Create(0, WISP_SH_MINSIZE);
			gpSyser->m_MainFrame.m_CrossReferenceForm.OpenTRefList(Addrs, Address);
		} else
		{
			gpSyser->m_MainFrame.m_SystemExplorer.m_TerminalWnd.Printf(WSTR("Can't find Transfer Reference\n"));
		}
		return true;
	}

	bool CCodeView::OnEventToggleBM(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.ToggleBM();
		return false;
	}

	bool CCodeView::OnEventFollowAuto(WISP_MSG *pMsg)
	{
		gSyserConfig.iFollowMode = 0;
		return true;
	}
	bool CCodeView::OnEventFollowCodeView(WISP_MSG *pMsg)
	{
		gSyserConfig.iFollowMode = 1;
		return true;
	}
	bool CCodeView::OnEventFollowSourceView(WISP_MSG *pMsg)
	{
		gSyserConfig.iFollowMode = 2;
		return true;
	}

	bool CCodeView::OnEventAnalyze(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
			CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Addr);
			if (pDbgMod)
			{
				//TODO gpSyser->m_SyserUI.m_SymAnalyzer.???(pDbgMod, Addr); //pDbgMod->+30); //pDbgMod->m_ImageBase
				//TODO gpSyser->m_MainFrame.m_SystemExplorer.m_SymAnalyzer.???(pDbgMod, Addr); //pDbgMod->+30);
				UpdateDasm();
			}
		}
		return true;
	}

	bool CCodeView::OnEventModeAddr(WISP_MSG *pMsg)
	{
		m_Mode = 0;
		UpdateDasm();
		return true;
	}

	bool CCodeView::OnEventModeOffs(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item)
		{
			m_RelAddr = GetItemValue(Item, CV_ADDR);
			m_Mode = 1;
			UpdateDasm();
		}
		return true;
	}

	bool CCodeView::OnEventSymSwitch(WISP_MSG *pMsg)
	{
		if (m_pSyserCodeDoc->m_Style & 1)
			m_pSyserCodeDoc->m_Style &= ~1;
		else	m_pSyserCodeDoc->m_Style |= 1;
		UpdateDasm();
		return true;
	}
	bool CCodeView::OnEventFullSym(WISP_MSG *pMsg)
	{
		gSyserConfig.iShowFullSym = gSyserConfig.iShowFullSym == 0;
		UpdateDasm();
		return true;
	}

	bool CCodeView::OnEventModeRelCIP(WISP_MSG *pMsg)
	{
		m_Mode = 2;
		UpdateDasm();
		return true;
	}

	bool CCodeView::OnEventEditCode(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item) EditItem(Item, CV_INST);
		return true;
	}
	bool CCodeView::OnEventEditComment(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item) EditItem(Item, CV_CMT);
		return true;
	}

	bool CCodeView::OnEventStrRef(WISP_MSG *pMsg)
	{
		if (gpSyser->m_MainFrame.m_FindListWnd.IsWindow())
			gpSyser->m_MainFrame.m_FindListWnd.Destroy();
		gpSyser->m_MainFrame.m_FindListWnd.CreateWnd(WSTR("String Reference"), 0,0,564,344, 0, EVENT_ID_STRFIND, 0x300BB, WISP_SH_MINSIZE);
		return true;
	}

	bool CCodeView::OnEventStrFind(WISP_MSG *pMsg)
	{
		//???
		return true;
	}

	bool CCodeView::OnEventNextCIPTrace(WISP_MSG *pMsg)
	{
		CTracePoint *pTrace = gpSyser->m_MainFrame.m_SystemExplorer.NextCIP();
		if (!pTrace) return false;
		GotoAddr(pTrace->Address, false);
		SelectAddr(pTrace->Address + pTrace->Offset);
		return true;
	}
	bool CCodeView::OnEventPrevCIPTrace(WISP_MSG *pMsg)
	{
		CTracePoint *pTrace = gpSyser->m_MainFrame.m_SystemExplorer.PrevCIP();
		if (!pTrace) return false;
		GotoAddr(pTrace->Address, false);
		SelectAddr(pTrace->Address + pTrace->Offset);
		return true;
	}

	bool CCodeView::OnEventNextAddr(WISP_MSG *pMsg)
	{
		GotoAddr(m_CurAddr + 1, false);
		return false;
	}

	bool CCodeView::OnEventPrevAddr(WISP_MSG *pMsg)
	{
		GotoAddr(m_CurAddr - 1, false);
		return false;
	}

	bool CCodeView::OnEventNewView(WISP_MSG *pMsg)
	{
		CWispWnd *pWnd = (CWispWnd *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetWnd(pMsg->Command.CmdID - EVENT_ID_CV0);
		if (pWnd)
		{
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.ChangeActiveWnd(pWnd);
			return true;
		}

		if (!gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.InsertView(
				(CCodeView*)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd()))
			return false;
		return true;
	}

	bool CCodeView::OnEventGotoHere(WISP_MSG *pMsg)
	{
		if (gpSyser->m_pDebugger && gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		{
			CListStringItem *Item = FindItem(0, 8);
			if (Item)
			{
				ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
				gpSyser->m_pDebugger->SetCodeBP(Addr, 0x200, BP_STATE_ENABLE);
				gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("x"), 0);
			}
		}
		return true;
	}

	bool CCodeView::OnEventToggleAddBP(WISP_MSG *pMsg)
	{
		if (!gpSyser->m_pDebugger || !gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
			return true;

		CListStringItem *Item = FindItem(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
			gpSyser->m_SyserUI.ToggleInsertBP(Addr);
		//???
			gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
		}
		return false;

	}
	bool CCodeView::OnEventToggleEnableBP(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
			gpSyser->m_SyserUI.ToggleEnableBP(Addr);
		//???
			UpdateDasm();
			gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
		}
		return false;
	}
	bool CCodeView::OnEventCopy(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item == m_pRButtonItem && Item && m_nRButtonCol >= CV_ADDR && m_nRButtonCol <= CV_CMT)
		{
			CListStringItem::CONTENT *Content = GetItemContent(m_pRButtonItem, m_nRButtonCol);
			if (IsColorString(Content->String.m_pData))
			{
				WCHAR Buffer[256];
				TStrCpyLimit(Buffer, ((unsigned long*)Content->String.m_pData)+1, 256); //???
				m_pWispBase->SetClipboard(Buffer);
			} else
			if (Content->String.m_nLength)
			{
				m_pWispBase->SetClipboard(Content->String.m_pData);
			}
		}
		return true;
	}

	void CCodeView::OnLButton(CListStringItem *Item, int nCol)
	{
		if (nCol == CV_START)
		{
			OnEventToggleAddBP(0);
		} else
		if (nCol == CV_ADDR)
		{
			if (m_Mode == 0)
			{
				OnEventModeOffs(0);
			} else
			if (m_Mode == 1)
			{
				OnEventModeRelCIP(0);
			} else
			if (m_Mode == 2)
			{
				OnEventModeAddr(0);
			}
			UpdateDasm();
		}
	}
	void CCodeView::OnRButton(CListStringItem *Item, int nCol)
	{
		if (nCol == CV_START)
		{
			OnEventToggleBM(0);
		}
	}
	bool CCodeView::Edit(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (m_pSyserCodeDoc && m_pSyserCodeDoc->m_bOpen)
		{
			if (nCol == CV_INST)
			{
				m_EditWnd.SetWindowText(WSTR(" "));
			} else
			if (nCol == CV_CMT)
			{
				if (IsColorString(String.operator const WCHAR*()))
					return false;
			}
			return true;
		}
		return false;
	}

	bool CCodeView::OnEditing(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (nCol == CV_ADDR)
		{
			ULONG_PTR Result;
			CListStringItem::CONTENT *Content = GetItemContent(Item, CV_ADDR);
			if (Content->String != String &&
				gpSyser->m_SyserUI.CalcExp(String.operator const WCHAR*(), &Result))
				GotoAddr(Result, true);
			
			return false;
		} else
		if (nCol == CV_INST)
		{
			return EditAsm(Item, String);
		} else
		if (nCol == CV_CMT)
		{
			ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
			m_pSyserCodeDoc->SetComment(Addr, String.operator const WCHAR*());
			UpdateDasm();
		}
		return true;
	}

	bool CCodeView::EditAsm(CListStringItem *Item, TWideString& String)
	{
		ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
		char szInput[256];
		TStrCpyLimit(szInput, String.operator const WCHAR*(), 256);
		unsigned char CodeBuff[128];
	#ifdef _X64_
		unsigned long Size = CIntelDisassembler::Assembler(szInput, CodeBuff, Addr, CODE_MODE_64);
	#else
		unsigned long Size = CIntelDisassembler::Assembler(szInput, CodeBuff, Addr, CODE_MODE_32);
	#endif
		if (Size)
		{
			gpSyser->m_pDebugger->WriteMemory(Addr, CodeBuff, Size);
			UpdateDasm();
		}
		return false;
	}

	unsigned long *CCodeView::OptItemToCS(_OPERAND_ITEM *OpArray, int nOp, unsigned long *pColorString, _INSTRUCTION_INFORMATION *pDasmInstr)
	{
		WCHAR szBuffer[32];

		for (int n = 0; n < nOp; ++n)
		{
			_OPERAND_ITEM *pOp = &OpArray[n];
			if (pOp->mode == OP_Invalid) break;
			if (n > 0)
				pColorString += ColorStrCpy(pColorString, ",", COLOR_OPTR, 0);
			if (pOp->mode == OP_Address)
			{
				if (pOp->opersize != -1)
				{
					pColorString += ColorStrCpy(pColorString, CInstrSym::m_SizeSym[pOp->opersize], COLOR_KEYWORD, 0);
					pColorString += ColorStrCpy(pColorString, " PTR ", COLOR_KEYWORD, 0);
				}

				if (pDasmInstr->SegmentPrefix != -1)
				{
					pColorString += ColorStrCpy(pColorString, CInstrSym::m_SegStr[pDasmInstr->SegmentPrefix], COLOR_SEG_REG, 0);
					pColorString += ColorStrCpy(pColorString, ":", COLOR_OPTR, 0);
				}

				pColorString += ColorStrCpy(pColorString, "[", COLOR_OPTR, 0);
				if (pOp->addr.base != -1)
					pColorString += ColorStrCpy(pColorString, CInstrSym::m_RegStr[pOp->addr.address_size][pOp->addr.base], COLOR_REGISTER, 0);

				if (pOp->addr.index != -1)
				{
					if (pOp->addr.base != -1)
						pColorString += ColorStrCpy(pColorString, "+", COLOR_OPTR, 0);
					pColorString += ColorStrCpy(pColorString, CInstrSym::m_RegStr[pOp->addr.address_size][pOp->addr.index], COLOR_REGISTER, 0);
					if (pOp->addr.scale >= 1)
					{
						pColorString += ColorStrCpy(pColorString, "*", COLOR_OPTR, 0);
						pColorString += ColorStrCpy(pColorString, CInstrSym::m_ScaleStr[pOp->addr.scale], COLOR_OPTR, 0);
					}
				}

				if (pOp->addr.displacement || (pOp->addr.base == -1 && pOp->addr.index == -1))
				{
					if (pOp->addr.index != -1 || pOp->addr.base != -1)
					{
						if (GetSign(&pOp->addr))
						{
							pColorString += ColorStrCpy(pColorString, "+", COLOR_OPTR, 0);
							TSPrintf(szBuffer, CInstrSym::m_SizePtr[GetSize(pOp->addr.displacement)], pOp->addr.displacement);
						} else
						{
							pColorString += ColorStrCpy(pColorString, "-", COLOR_OPTR, 0);
							TSPrintf(szBuffer, CInstrSym::m_SizePtr[GetSize(pOp->addr.displacement)], -pOp->addr.displacement);
						}
					} else
					{
						TSPrintf(szBuffer, CInstrSym::m_SizePtr[GetSize(pOp->addr.displacement)], pOp->addr.displacement);
					}
					pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
				}
				pColorString += ColorStrCpy(pColorString, "]", COLOR_OPTR, 0);
			} else
			{
				switch (pOp->mode)
				{
				case OP_Register:
					pColorString += ColorStrCpy(pColorString, pOp->string, COLOR_REGISTER, 0);
					break;
				case OP_Segment:
					pColorString += ColorStrCpy(pColorString, pOp->string, COLOR_SEG_REG, 0);
					break;
				case OP_Immed:
				case OP_Near:
					pColorString += ColorStrCpy(pColorString, pOp->string, COLOR_IMMED, 0);
					break;
				case OP_Far:
					TSPrintf(szBuffer, WSTR("%04X"), pOp->farptr.segment);
					pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
					pColorString += ColorStrCpy(pColorString, WSTR(":"), COLOR_OPTR, 0);
					TSPrintf(szBuffer, CInstrSym::m_ScaleStr[pOp->opersize+2], pOp->farptr.offset); //???
					pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
					break;
				case OP_Datadup:
					if (n == 0)
					for (n = 0; n < pOp->datadup.count; ++n)
					{
						if (n > 0)
							pColorString += ColorStrCpy(pColorString, ",", COLOR_OPTR, 0);
						TSPrintf(szBuffer, WSTR("%02X"), pOp->datadup.buffer[n]);
						pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
					}
					break;
				case OP_Symbol:
					if (pOp->symbol.boffset)
						pColorString += ColorStrCpy(pColorString, "OFFSET ", COLOR_KEYWORD, 0);
					pColorString += ColorStrCpy(pColorString, pOp->symbol.string, COLOR_SYMBOL, 0);
					break;
				case OP_Align:
					if (n == 0)
					{
						TSPrintf(szBuffer, WSTR("%X"), pOp->align.nBytes);
						pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
					}
					break;
				default: break;
				}
			}
		}
		return pColorString;
	}

	unsigned long *CCodeView::InstrToCS(_INSTRUCTION_INFORMATION *pDasmInstr, unsigned long *pColorString)
	{
		bool bFirstLine = true;
		if (pDasmInstr->Lock != -1)
		{
			ColorStrCpy(pColorString, pDasmInstr->LockName, COLOR_PREFIX, 0);
			ColorStrCat(pColorString, " ", 0, 0);
			pColorString += TStrFillTail(pColorString, m_pSyserCodeDoc->m_UxAlign, (unsigned long)32);
			bFirstLine = false;
		}
		if (pDasmInstr->Repeat != -1)
		{
			ColorStrCpy(pColorString, pDasmInstr->RepeatName, COLOR_PREFIX, 0);
			ColorStrCat(pColorString, " ", 0, 0);
			if (bFirstLine)
			{
				pColorString += TStrFillTail(pColorString, m_pSyserCodeDoc->m_UxAlign, (unsigned long)32);
				pColorString += TStrLen(pColorString);
				bFirstLine = false;
			} else
			{
				pColorString += TStrLen(pColorString);
				pColorString += TStrLen(pColorString);
			}

		}
		ColorStrCpy(pColorString, pDasmInstr->Name, COLOR_OPCODE, 0);
		ColorStrCat(pColorString, " ", 0, 0);
		if (pDasmInstr->Name[0] && bFirstLine)
			pColorString += TStrFillTail(pColorString, m_pSyserCodeDoc->m_UxAlign, (unsigned long)32);
		else	pColorString += TStrLen(pColorString);
		return OptItemToCS(pDasmInstr->op, 3, pColorString, pDasmInstr);
	}

	unsigned long CCodeView::ColorDasm(ULONG_PTR Address, unsigned long MaxSize, unsigned long *pColorString, unsigned long nCodeAlign, _INSTRUCTION_INFORMATION *pInstInfo, unsigned char *pCodeBuff)
	{
		unsigned char CodeBuff[64];
		if (!pCodeBuff)
			pCodeBuff = CodeBuff;

		_INSTRUCTION_INFORMATION InstInfo;
		InstInfo.CodeBuff = pCodeBuff;
		InstInfo.eip = Address;
		InstInfo.pasm = nullptr;
		unsigned long CodeLen = m_pSyserCodeDoc->Dasm(&InstInfo, 0, MaxSize);
		if (nCodeAlign)
		{
			if (InstInfo.OpCode == -1)
			{
				ColorStrCpy(pColorString, WSTR("??"), COLOR_IMMED, 0);
			} else
			{
				WCHAR Buffer[64];
				THexBytesToStr(InstInfo.CodeBuff, Buffer, CodeLen, 1, (WCHAR*)0);
				ColorStrCpy(pColorString, Buffer, COLOR_IMMED, 0);
			}
			pColorString += TStrFillTail(pColorString, nCodeAlign, (unsigned long)32);
		}
		InstrToCS(&InstInfo, pColorString);
		if (pInstInfo)
		{
			memcpy(pInstInfo, &InstInfo, sizeof(_INSTRUCTION_INFORMATION));
			if (!pCodeBuff)
				pInstInfo->CodeBuff = 0;
		}
		return CodeLen;
	}

	void CCodeView::GetAddress(ULONG_PTR Address, WCHAR *szAddress)
	{
		if (m_Mode == 0)
		{
			TSPrintf(szAddress, WSTR("" F0ADDR "X"), Address);
		} else
		{
			WCHAR Buffer[32];
			LONG_PTR Offs;
			if (m_Mode == 1)
			{
				Offs = Address - m_RelAddr;
				TStrCpy(Buffer, "$");
			} else
			if (m_Mode == 2)
			{
				Offs = Address - (gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP?*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP:0);
				TStrCpy(Buffer, CIPSTR);
			}

			if (Offs > 0) TSPrintf(szAddress, WSTR("%s+%X"), Buffer, Offs);
			else
			if (Offs < 0) TSPrintf(szAddress, WSTR("%s-%X"), Buffer, -Offs);
			else
			{
				TStrCpy(szAddress, Buffer);
				TStrCat(szAddress, "==>");
			}
		}
	}

	int TStrCount(const char *Str, char Char)
	{
		int Count = 0;
		if (Str) while (*Str) { if (*Str == Char) ++Count; ++Str; }
		return Count;
	}

	void CCodeView::ShowAPICall(ULONG_PTR Address, const char *string, CListStringItem *Item, unsigned int nLine)
	{
		map<TAnsiNoCaseString, APIFunction>::IT it = gpSyser->m_SyserUI.m_APIDef.find(string);
		if (it == gpSyser->m_SyserUI.m_APIDef.end())
			return;

		int Len = 0;
		WCHAR szString[256];
		unsigned long ColorString[1024];

		Len += ColorStrCpy(ColorString, it->second.Return.operator const char*(), COLOR_PARAM_TYPE, COLOR_BG);
		Len += ColorStrCpy(&ColorString[Len], " ", COLOR_BG, COLOR_BG);

		Len += ColorStrCpy(&ColorString[Len], it->first.operator const char*(), COLOR_API_NAME, COLOR_BG);
		Len += ColorStrCpy(&ColorString[Len], "(", COLOR_OPTR, COLOR_BG);
	{
		TListIter<TAnsiString> It = it->second.Arguments.Begin();
		while (It != it->second.Arguments.End())
		{
			const char *pStrOptional = 0;
			const char *pStrParam = TStrRChr(It->operator const char*(), ' ');
			if (pStrParam)
			{
				if (!TStrCmp(pStrParam+1, "OPTIONAL"))
				{
					pStrOptional = pStrParam;
					pStrParam = TStrRChr(It->operator const char*(), pStrParam-1, ' ');
					if (!pStrParam)
						pStrParam = It->operator const char*();
				}

				int Pos = TStrCount(It->operator const char*(), ' ');
				if (Pos == 1)
				{
					if (!TStrNCmp(It->operator const char*(), "IN ", 3))
						pStrParam = 0;
					else
					if (!TStrNCmp(It->operator const char*(), "OUT ", 4))
						pStrParam = 0;
					
				} else
				if (Pos == 2)
				{
					if (!TStrNCmp(It->operator const char*(), "IN OUT ", 7))
						pStrParam = 0;
				}

				if (pStrParam)	
				{
					int l = pStrParam - It->operator const char*()+1;
					TStrCpyLimit(szString, It->operator const char*(), l);
					Len += ColorStrCpy(ColorString, szString, COLOR_PARAM_TYPE, COLOR_BG);
					if (pStrOptional)
						TStrCpyLimit(szString, pStrParam, pStrOptional - pStrParam+1);
					else	TStrCpy(szString, pStrParam);
					Len += ColorStrCpy(&ColorString[Len], szString, COLOR_PARAM_NAME, COLOR_BG);
					if (pStrOptional)
					{
						TStrCpy(szString, pStrOptional);
						Len += ColorStrCpy(&ColorString[Len], szString, COLOR_PARAM_TYPE, COLOR_BG);
					}
				}
			}

			if (!pStrParam)
			{
				Len += ColorStrCpy(ColorString, It->operator const char*(), COLOR_PARAM_TYPE, COLOR_BG);
			}


			if (It != it->second.Arguments.End()-1)
				Len += ColorStrCpy(&ColorString[Len], ",", COLOR_OPTR, COLOR_BG);
			++It;
		}
	}
		ColorStrCpy(&ColorString[Len], ")", COLOR_OPTR, COLOR_BG);
		SetItemTextColor(Item, CV_CMT, ColorString);

		if (it->second.Declaration!=0) return;
		
		TListIter<TAnsiString> It = it->second.Arguments.Begin();
		while (It != it->second.Arguments.End() && nLine>0)
		{
			--nLine;
			Item = GetPrev(Item, 0);
			if (!Item) return;

			CListStringItem::CONTENT *Content = GetItemContent(Item, CV_CMT);
			if (!IsColorString(Content->String.m_pData))
			{
				Content = GetItemContent(Item, CV_INST);
				if (Content->String.m_nLength > 0)
				{
					unsigned long long CodeBuf = GetItemValue(Item, CV_CODE);
					if (CInstrSym::GetJump((unsigned char*)&CodeBuf, 0, nullptr)) return;

					if (!TStrNICmp((WCHAR*)Content->String.m_pData+2, "PUSH", 4))
					{
						ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
						const char *pStrOptional = 0;
						const char *pStrParam = TStrRChr(It->operator const char*(), ' ');
						if (pStrParam)
						{
							if (!TStrCmp(pStrParam+1, "OPTIONAL"))
							{
								pStrOptional = pStrParam;
								pStrParam = TStrRChr(It->operator const char*(), pStrParam-1, ' ');
								if (!pStrParam)
									pStrParam = It->operator const char*();
							}

							int Pos = TStrCount(It->operator const char*(), ' ');
							if (Pos == 1)
							{
								if (!TStrNCmp(It->operator const char*(), "IN ", 3))
									pStrParam = 0;
								else
								if (!TStrNCmp(It->operator const char*(), "OUT ", 4))
									pStrParam = 0;
								
							} else
							if (Pos == 2)
							{
								if (!TStrNCmp(It->operator const char*(), "IN OUT ", 7))
									pStrParam = 0;
							}

							if (pStrParam)	
							{
								int l = pStrParam - It->operator const char*()+1;
								TStrCpyLimit(szString, It->operator const char*(), l);
								Len = ColorStrCpy(ColorString, szString, COLOR_PARAM_TYPE, COLOR_BG);
								if (pStrOptional)
									TStrCpyLimit(szString, pStrParam, pStrOptional - pStrParam+1);
								else	TStrCpy(szString, pStrParam);
								Len += ColorStrCpy(&ColorString[Len], szString, COLOR_PARAM_NAME, COLOR_BG);
								if (pStrOptional)
								{
									TStrCpy(szString, pStrOptional);
									ColorStrCpy(&ColorString[Len], szString, COLOR_PARAM_TYPE, COLOR_BG);
								}
							}
						}

						if (!pStrParam)
						{
							ColorStrCpy(ColorString, It->operator const char*(), COLOR_PARAM_TYPE, COLOR_BG);
						}
						SetItemTextColor(Item, CV_CMT, ColorString);
						++It;
					}
				}
			}
		}
		
	}

	bool CCodeView::UpdateDasm()
	{
		bool bContext = false;
		Adjust(0, m_nVSBPage); //_m_nItemCount);

		ULONG_PTR CurAddr = m_CurAddr;
		CListStringItem *Item = GetNext(0, 0);

		_INSTRUCTION_INFORMATION InstInfo;
		memset(&InstInfo, 0, sizeof(InstInfo));

		unsigned char CodeBuff[MAX_INSTR_LEN];
		memset(CodeBuff, 0xFF, sizeof(CodeBuff));

		unsigned long InstrColorString[256];

		int KeywordLen = TStrLen(m_szKeyword);

		unsigned int nLine = 0;
		while (nLine < m_nVSBPage && Item)
		{
			InstInfo.CodeBuff = CodeBuff;
			InstrColorString[0] = 0;
			unsigned long CodeLen = ColorDasm(CurAddr, sizeof(CodeBuff), InstrColorString, 0, &InstInfo, CodeBuff);
			ULONG_PTR JmpAddr = 0;
			if (CodeLen >= 2)
				CInstrSym::GetJump(CodeBuff, CurAddr, &JmpAddr);

			WCHAR szString[256];
			TStrCpy(szString, InstrColorString);

			if (KeywordLen>0)
			{
				WCHAR *pStr = szString;
			//	while ((pStr = TStrIStr(pStr, m_szKeyword)))
				while ((pStr = TStrIStrX(pStr, WSTR("[],+- "), m_szKeyword))) //:
				{
					int start = pStr - szString;
					for (int i = 0; i < KeywordLen; ++i)
					{
						InstrColorString[start+i] = (InstrColorString[start+i] & 0xFFFFFF) + 0xA000000;
					}
					pStr += KeywordLen;
				}
				
			}

			SetItemValue(Item, CV_ADDR, CurAddr);
			if (!bContext && m_pSyserCodeDoc->GetFunction(CurAddr, szString, 256))
			{
				SetItemValue(Item, CV_START, 0);
	                        SetItemValue(Item, CV_INST, 0);
	                        SetItemText(Item, CV_START, WSTR(""));
	                        SetItemText(Item, CV_ADDR, WSTR(""));
	                        SetItemText(Item, CV_CODE, WSTR(""));
	                        SetItemColor(Item, CV_INST, m_Color[COLOR_SYMBOL]);
	                        SetItemText(Item, CV_INST, szString);
	                        SetItemText(Item, CV_CMT, WSTR(""));
	                        bContext = true;
			} else
			{
				SetItemValue(Item, CV_START, m_pSyserCodeDoc->GetPic(CurAddr));

				SetItemColor(Item, CV_ADDR, m_Color[COLOR_ADDRESS]);
				GetAddress(CurAddr, szString);
				SetItemText(Item, CV_ADDR, szString);

				unsigned long ColorCode[120];

				if (CodeLen < 1 || InstInfo.OpCode == -1)
				{
					THexBytesToStr(CodeBuff, szString, 1, 1, (WCHAR*)0);
					ColorStrCpy(ColorCode, szString, COLOR_PARAM_TYPE, COLOR_BG);
				} else
				{
					int l = 0;
					bool bUnknown = false;
					for (int i = 0; i < CodeLen; ++i)
					{
						THexBytesToStr(&CodeBuff[i], szString, 1, 1, (WCHAR*)0);

						if (i < InstInfo.Prefixes)
						{
							l += ColorStrCpy(&ColorCode[l], szString, COLOR_PREFIX_BYTE, COLOR_BG);
						} else
						if (i < InstInfo.Prefixes + InstInfo.OpCount)
						{
							if (i == InstInfo.Prefixes && i)
								l += ColorStrCpy(&ColorCode[l], ":", COLOR_OPCODE_BYTE, COLOR_BG);
							l += ColorStrCpy(&ColorCode[l], szString, COLOR_OPCODE_BYTE, COLOR_BG);
						} else
						if (InstInfo.RegRM != -1 &&
							InstInfo.Prefixes + InstInfo.OpCount == i)
						{
							l += ColorStrCpy(&ColorCode[l], " ", COLOR_REGRM_BYTE, COLOR_BG);
							l += ColorStrCpy(&ColorCode[l], szString, COLOR_REGRM_BYTE, COLOR_BG);
						} else
						if (InstInfo.Sib1 != -1 &&
							InstInfo.Prefixes + InstInfo.OpCount+1 == i)
						{
							l += ColorStrCpy(&ColorCode[l], " ", COLOR_SIB_BYTE, COLOR_BG);
							l += ColorStrCpy(&ColorCode[l], szString, COLOR_SIB_BYTE, COLOR_BG);
						} else
						if (InstInfo.AMD3DNow != -1 && i == CodeLen - 1)
						{
							l += ColorStrCpy(&ColorCode[l], " ", COLOR_AMD3DNOW_BYTE, COLOR_BG);
							l += ColorStrCpy(&ColorCode[l], szString, COLOR_AMD3DNOW_BYTE, COLOR_BG);
						} else
						{
							if (!bUnknown)
							{
								l += ColorStrCpy(&ColorCode[l], " ", COLOR_OTHER_OPCODE_BYTE, COLOR_BG);
								bUnknown = true;
							}
							l += ColorStrCpy(&ColorCode[l], szString, COLOR_OTHER_OPCODE_BYTE, COLOR_BG);
						}
						
					}
				}

				SetItemTextColor(Item, CV_CODE, ColorCode);
				SetItemValue(Item, CV_CODE, *(unsigned long long*)CodeBuff);

				SetItemTextColor(Item, CV_INST, InstrColorString);
				SetItemValue(Item, CV_INST, JmpAddr);

				szString[0] = 0;

				SetItemColor(Item, CV_CMT, m_Color[COLOR_COMMENT]);
				SetItemText(Item, CV_CMT, szString);

				ULONG_PTR ADDR1,ADDR2;
				char Encode;

				if (m_pSyserCodeDoc->GetComment(CurAddr, szString, 256))
				{
					SetItemText(Item, CV_CMT, szString);
				} else
				if (!m_pSyserCodeDoc->GetAddrImm(CurAddr, &ADDR1, &ADDR2))
				{
					InstrColorString[0] = 0;
					if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen &&
						CurAddr == *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP)
					{
						m_pSyserCodeDoc->ContextCS(InstrColorString, 256);
						SetItemTextColor(Item, CV_CMT, InstrColorString);
					}
				} else
				if ((ADDR2 != -1 && gpSyser->m_SyserUI.ReadString(ADDR2, szString, 256, &Encode)) ||
				    (ADDR1 != -1 && gpSyser->m_SyserUI.ReadString(ADDR1, szString, 256, &Encode)) )
				{
					SetItemText(Item, CV_CMT, szString);
				}

				bContext = false;

				if (!TStrNICmp(InstrColorString, "CALL", 4) && InstInfo.op[0].mode == OP_Symbol)
					ShowAPICall(CurAddr, InstInfo.op[0].symbol.string, Item, nLine);

				m_EndAddr = CurAddr;
				CurAddr = m_pSyserCodeDoc->GetInstrAddress(CurAddr, 1);
			}
                        Item = GetNext(Item, 0);
			++nLine;
		}

		AddLineJmp();
		Update((WISP_RECT*)0);
		return true;
	}

	void CCodeView::UpdateStaticText()
	{
		WCHAR Buffer[512];
		if (gpSyser->m_pDebugger == 0)
		{
		//	TSPrintf(Buffer, WSTR("Debugger: %s not found"), gSyserConfig.szDebuggerFileName);
		//	gpSyser->m_MainFrame.m_StaticText.SetWindowText(Buffer);
			return;
		}
	#ifdef _RING0_
		int Len = TStrCpy(Buffer, gpSyser->m_pDebugger->m_ProcessName.operator const WCHAR*());
	#else
		int Len = AnsiToUnicode(TGetFileName(gpSyser->m_SyserUI.m_SyserCodeDoc.m_ExeFilePath.operator const char*()), Buffer, lenof(Buffer));
		if (Len==0) Buffer[0] = 0;
	#endif
		CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(m_CurAddr);
		if (!pDbgMod)
		{
			if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger)
				pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(m_CurAddr);
		}
		if (pDbgMod)
		{
			Len += TStrCpy(&Buffer[Len], WSTR(" : "));
			Len += AnsiToUnicode(pDbgMod->m_FileTitle.operator const char*(), &Buffer[Len], lenof(Buffer) - Len);
			char szSym[256];
			if (gpSyser->m_SyserUI.GetSymbolOffset(m_CurAddr, szSym))
			{
				Len += TStrCpy(&Buffer[Len], WSTR("!"));
				Len += TStrCpy(&Buffer[Len], szSym);
			} else
			{
				TSPrintf(&Buffer[Len], WSTR("+%X"), m_CurAddr - pDbgMod->m_ImageBase);
			}
		}
		gpSyser->m_MainFrame.m_StaticText.SetWindowText(Buffer);
	}

	void CCodeView::GotoAddr(ULONG_PTR Address, bool bHistory)
	{
		ULONG_PTR PrevAddr = m_CurAddr;
		if (m_CurAddr != Address)
		{
			m_CurAddr = Address;
			unsigned int Index = 0;
			TListIter<WISP_TAB_WND_ITEM> It = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.m_WndList.Begin();
			while (It != gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.m_WndList.End())
			{
				if (It->pWnd == this)
				{
					WCHAR Buffer[64];
					TSPrintf(Buffer, WSTR("" F0ADDR "X"), m_CurAddr);
					gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.SetTabText(Index, Buffer);
				}
				++It;
				++Index;
			}
			if (gpSyser->m_MainFrame.m_SystemExplorer.m_pCodeView == this)
			{
				UpdateStaticText();
			}
			if (m_CurAddr && bHistory)
			{
				AddPos(m_CurAddr, PrevAddr);
			}
			UpdateDasm();
			Update((WISP_RECT*)0);
		}
	}

	void CCodeView::SelectAddress(ULONG_PTR Address)
	{
		ULONG_PTR Addr = m_pSyserCodeDoc->GetInstrAddress(Address, m_nVSBPage/-2); //m_nItemCount
		GotoAddr(Addr, false);
		SelectAddr(Address);
	}

	void CCodeView::SelectAddr(ULONG_PTR Address)
	{
		CListStringItem *Item = GetRootItem();
		while (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
			if (Addr == Address)
			{
				Select(Item);
				return;
			}
			Item = GetNext(Item, 0);
		}
	}

	void CCodeView::LoadKeyMap()
	{
		if (!gpSyser->GetHotKey(EVENT_ID_CV0, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000031, EVENT_ID_CV0)); //WISP_SK_ALT 0
		if (!gpSyser->GetHotKey(EVENT_ID_CV1, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000032, EVENT_ID_CV1)); //WISP_SK_ALT 1
		if (!gpSyser->GetHotKey(EVENT_ID_CV2, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000033, EVENT_ID_CV2)); //WISP_SK_ALT 2
		if (!gpSyser->GetHotKey(EVENT_ID_CV3, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000034, EVENT_ID_CV3)); //WISP_SK_ALT 3
		if (!gpSyser->GetHotKey(EVENT_ID_CV4, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000035, EVENT_ID_CV4)); //WISP_SK_ALT 4
		if (!gpSyser->GetHotKey(EVENT_ID_CV5, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000036, EVENT_ID_CV5)); //WISP_SK_ALT 5
		if (!gpSyser->GetHotKey(EVENT_ID_CV6, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000037, EVENT_ID_CV6)); //WISP_SK_ALT 6
		if (!gpSyser->GetHotKey(EVENT_ID_CV7, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000038, EVENT_ID_CV7)); //WISP_SK_ALT 7
		if (!gpSyser->GetHotKey(EVENT_ID_CV8, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000039, EVENT_ID_CV8)); //WISP_SK_ALT 8

		if (!gpSyser->GetHotKey(EVENT_ID_CV_SWITCH_SYM, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x9,        EVENT_ID_CV_SWITCH_SYM)); //VK_TAB
		if (!gpSyser->GetHotKey(EVENT_ID_CV_FULL_SYM, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x40000009, EVENT_ID_CV_FULL_SYM)); //WISP_SK_CTRL VK_TAB

		if (!gpSyser->GetHotKey(EVENT_ID_CV_NEXT_CIP, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0xBB,       EVENT_ID_CV_NEXT_CIP)); //VK_OEM_PLUS
		if (!gpSyser->GetHotKey(EVENT_ID_CV_PREV_CIP, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0xBD,       EVENT_ID_CV_PREV_CIP)); //VK_OEM_MINUS

		if (!gpSyser->GetHotKey(EVENT_ID_PREVPOS, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x8,        EVENT_ID_PREVPOS)); //VK_BACK
		if (!gpSyser->GetHotKey(EVENT_ID_NEXTPOS, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x4000000D, EVENT_ID_NEXTPOS)); //WISP_SK_CTRL VK_RETURN

		if (!gpSyser->GetHotKey(EVENT_ID_CV_SHOW_AT, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0xD,        EVENT_ID_CV_SHOW_AT)); //VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_SAVEPOS, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x1000000D, EVENT_ID_SAVEPOS)); //WISP_SK_SHIFT VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_CV_PREV, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x40000026, EVENT_ID_CV_PREV)); //WISP_SK_CTRL VK_UP
		if (!gpSyser->GetHotKey(EVENT_ID_CV_NEXT, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x40000028, EVENT_ID_CV_NEXT)); //WISP_SK_CTRL VK_DOWN
		if (!gpSyser->GetHotKey(EVENT_ID_INSREMBP, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x78,      EVENT_ID_INSREMBP)); //VK_F9
		if (!gpSyser->GetHotKey(EVENT_ID_GOTO_HERE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x76,       EVENT_ID_GOTO_HERE)); //VK_F7
	}

	void CCodeView::GetCodeRange(ULONG_PTR *pStart, ULONG_PTR *pEnd)
	{
		*pStart = m_CurAddr;
		*pEnd = m_pSyserCodeDoc->GetInstrAddress(m_CurAddr, m_nVSBPage - 1); //m_nItemCount
	}

	bool CCodeView::GetJumpPos(ULONG_PTR Address, unsigned long *pJmpPos)
	{
		if (Address < m_CurAddr || Address > m_EndAddr)
			return false;
		unsigned long Pos = 0;
		CListStringItem *Item = GetRootItem();
		while (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, CV_ADDR);
			if (Address == Addr)
			{
				if (pJmpPos) *pJmpPos = Pos;
				return true;
			}
			Item = GetNext(Item, 0);
			++Pos;
		}
		return false;
	}

	void CCodeView::AddLineJmp()
	{
		m_LineJmpCount = 0;
		m_CurLineJmp = -1;
		int Index = 0;
		CListStringItem *Item = GetRootItem();
		while (Item && m_LineJmpCount < MAX_LINEDIB)
		{
			ULONG_PTR Inst = GetItemValue(Item, CV_INST);
			unsigned long JmpPos;
			if (Inst && GetJumpPos(Inst, &JmpPos))
			{
				m_LineDIB[m_LineJmpCount].eip = GetItemValue(Item, CV_ADDR);
				m_LineDIB[m_LineJmpCount].index = Index;
				m_LineDIB[m_LineJmpCount].inst = Inst;
				m_LineDIB[m_LineJmpCount].offs = JmpPos;
				if (m_LineDIB[m_LineJmpCount].eip == *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP)
				{
					unsigned long long Code = GetItemValue(Item, CV_CODE);
					if (CInstrSym::CheckJump((unsigned char*)&Code, *(unsigned long*)gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pEFL)) //??? TODO
						m_CurLineJmp = m_LineJmpCount;
				}
				++m_LineJmpCount;
			}
			Item = GetNext(Item, 0);
			++Index;
		}
	}

	void CCodeView::DrawLineJmp(LINEDIB *LineDIB, int Pos, unsigned long Color)
	{
		int X1 = Pos * (m_LineJmpWidth / m_LineJmpCount);
		int X2 = m_LineJmpWidth;

		int Y1 = m_nLineHeight/2 + m_nLineHeight * LineDIB->index;
		int Y2 = m_nLineHeight/2 + m_nLineHeight * LineDIB->offs;

		m_ClientDC.DrawHLine(X1, X2, Y1, Color);
		m_ClientDC.DrawVLine(X2, Y1 - 3, Y1 + 3, Color);
		m_ClientDC.DrawHLine(X1, X2, Y2, Color);
		m_ClientDC.DrawLine(X2 - 2, Y2 - 2, X2, Y2, Color);
		m_ClientDC.DrawLine(X2 - 2, Y2 + 2, X2, Y2, Color);
		m_ClientDC.DrawVLine(X1, Y1, Y2, Color);
	}

	void CCodeView::AddPos(ULONG_PTR Addr, ULONG_PTR PrevAddr)
	{
		if (m_History.Size()>100)
		{
			if (m_HistoryIter == m_History.Begin())
				m_HistoryIter++;
			m_History.Remove(m_History.Begin());
		}

		if (m_History.Size()==0 && Addr != PrevAddr)
			m_HistoryIter = m_History.Append(&PrevAddr);

		if (Addr != *(m_History.End()-1)) //???
			m_HistoryIter = m_History.Append(&Addr);

		gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();
	}

	void CCodeView::ResetPos()
	{
		m_History.Clear();
		m_HistoryIter = m_History.Append(&m_CurAddr);
		gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();
	}
	void CCodeView::SavePos()
	{
		if (m_HistoryIter != m_History.End()-1)
		{
			m_HistoryIter++;
			m_History.Remove(m_HistoryIter, m_History.End());
			m_HistoryIter = m_History.End();
		}
		if (m_History.Size()>100)
		{
			if (m_HistoryIter == m_History.Begin())
				m_HistoryIter++;
			m_History.Remove(m_History.Begin());
		}
		if (!m_History.Size() || m_CurAddr != *(m_History.End()-1))
			m_HistoryIter = m_History.Append(&m_CurAddr);

		gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();
	}
	void CCodeView::NextPos()
	{
		if (m_pSyserCodeDoc && m_pSyserCodeDoc->m_bOpen)
		{
			if (m_HistoryIter == m_History.End() || *m_HistoryIter == m_CurAddr)
			{
				if (m_HistoryIter != m_History.End()-1)
				{
					m_HistoryIter++;
					GotoAddr(*m_HistoryIter, false);
				}
			} else
			{
				GotoAddr(*m_HistoryIter, false);
			}
			gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();			
		}
	}
	void CCodeView::PrevPos()
	{
		if (m_pSyserCodeDoc && m_pSyserCodeDoc->m_bOpen)
		{
			if (m_HistoryIter == m_History.End() || *m_HistoryIter == m_CurAddr)
			{
				if (m_HistoryIter != m_History.Begin())
				{
					m_HistoryIter--;
					GotoAddr(*m_HistoryIter, false);
				}
			} else
			{
				GotoAddr(*m_HistoryIter, false);
			}

			gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();			
		}
	}

```

`source/WispSyser/codeview.hpp`:

```hpp

#ifndef _CODEVIEW_HPP_
#define _CODEVIEW_HPP_

#include "../Code/alt/altlist.hpp"
#include "../Code/alt/altmap.hpp"
#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispmenu.hpp"
#include "../Wisp/wispdib.hpp"
#include "syserui.hpp"
#include "syserconfig.hpp"

enum
{
  CV_START = 0,
  CV_ADDR = 1,
  CV_CODE = 2,
  CV_INST = 3,
  CV_CMT = 4,
  CV_MAX = 5,
};

struct LINEDIB
{
	ULONG_PTR eip;
	ULONG_PTR inst;
	unsigned long index;
	unsigned long offs;
};

#define MAX_LINEDIB 5

struct CCodeView : public CWispList
{
	CWispDIBList *m_pLineMarkDIBList;
	TWideString Str;
	unsigned long m_nScrollLine;
	unsigned long m_Mode;
	ULONG_PTR m_RelAddr;
	ULONG_PTR m_CurAddr;
	ULONG_PTR m_EndAddr;
	unsigned long m_Color[COLOR_MAX];
	CSyserCodeDoc *m_pSyserCodeDoc;
	CWispDIBList m_DIBList;
	TList<ULONG_PTR> m_History;
	TListIter<ULONG_PTR> m_HistoryIter;
	CListStringItem *m_pRButtonItem;
	int m_nRButtonCol;
//	XXXXXXXXXXXXXXXXXXXXfield_DB0;
	CWispMenu m_PopupMenu;
//	XXXXXXXXXXXXXXXXXXXXfield_1034;
	LINEDIB m_LineDIB[MAX_LINEDIB];
	unsigned long m_LineJmpCount;
	int m_CurLineJmp;
	unsigned long m_LineJmpWidth;
	WCHAR m_szKeyword[256];
//	XXXXXXXXXXXXXXXXXXXXfield_1294;
	map<unsigned int, unsigned int> m_KeyMap;

	CCodeView();
	virtual ~CCodeView();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);

	void OnKeyLButton(WISP_MSG *pMsg);
	void OnKeyRButton(WISP_MSG *pMsg);

	bool OnKeyEvent(WISP_MSG *pMsg);

	bool OnEventShowAt(WISP_MSG *pMsg);

	bool OnMouseDblClick(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
	bool OnChar(WISP_MSG *pMsg);
	bool OnGetFocus(WISP_MSG *pMsg);
	bool OnScrollEvent(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdFindString(WISP_MSG *pMsg);
	bool OnCmdVSpinScroll(WISP_MSG *pMsg);

	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventResetPos(WISP_MSG *pMsg);
	bool OnEventSavePos(WISP_MSG *pMsg);
	bool OnEventNextPos(WISP_MSG *pMsg);
	bool OnEventPrevPos(WISP_MSG *pMsg);

	bool OnEventSearchOpRef(WISP_MSG *pMsg);
	bool OnEventSearchTrRef(WISP_MSG *pMsg);

	bool GetOpRefList(ULONG_PTR Address, TList<ULONG_PTR> & Addrs, ULONG_PTR & Return);
	bool OpenOpRefList(ULONG_PTR Address);
	unsigned long GetTRefList(ULONG_PTR Address, TList<ULONG_PTR> & Addrs);
	bool OpenTRefList(ULONG_PTR Address);

	bool OnEventToggleBM(WISP_MSG *pMsg);

	bool OnEventFollowAuto(WISP_MSG *pMsg);
	bool OnEventFollowCodeView(WISP_MSG *pMsg);
	bool OnEventFollowSourceView(WISP_MSG *pMsg);

	bool OnEventAnalyze(WISP_MSG *pMsg);

	bool OnEventModeAddr(WISP_MSG *pMsg);
	bool OnEventModeOffs(WISP_MSG *pMsg);

	bool OnEventSymSwitch(WISP_MSG *pMsg);
	bool OnEventFullSym(WISP_MSG *pMsg);

	bool OnEventModeRelCIP(WISP_MSG *pMsg);

	bool OnEventEditCode(WISP_MSG *pMsg);
	bool OnEventEditComment(WISP_MSG *pMsg);

	bool OnEventStrRef(WISP_MSG *pMsg);
	bool OnEventStrFind(WISP_MSG *pMsg);

	bool OnEventNextCIPTrace(WISP_MSG *pMsg);
	bool OnEventPrevCIPTrace(WISP_MSG *pMsg);

	bool OnEventNextAddr(WISP_MSG *pMsg);
	bool OnEventPrevAddr(WISP_MSG *pMsg);

	bool OnEventNewView(WISP_MSG *pMsg);
	bool OnEventGotoHere(WISP_MSG *pMsg);

	bool OnEventToggleAddBP(WISP_MSG *pMsg);
	bool OnEventToggleEnableBP(WISP_MSG *pMsg);
	bool OnEventCopy(WISP_MSG *pMsg);

	virtual void OnLButton(CListStringItem *Item, int nCol) override;
	virtual void OnRButton(CListStringItem *Item, int nCol) override;

	virtual bool Edit(CListStringItem *Item, int nCol, TWideString& String) override;
	virtual bool OnEditing(CListStringItem *Item, int nCol, TWideString& String) override;

	bool EditAsm(CListStringItem *Item, TWideString& String);

	unsigned long *OptItemToCS(_OPERAND_ITEM *OpArray, int nOp, unsigned long *pColorString, _INSTRUCTION_INFORMATION *pDasmInstr);
	unsigned long *InstrToCS(_INSTRUCTION_INFORMATION *pDasmInstr, unsigned long *pColorString);
	unsigned long ColorDasm(ULONG_PTR Address, unsigned long MaxSize, unsigned long *ColorString, unsigned long nCodeAlign, _INSTRUCTION_INFORMATION *pInstInfo, unsigned char *pCodeBuff);
	void GetAddress(ULONG_PTR Address, WCHAR *szAddress);
	void ShowAPICall(ULONG_PTR Address, const char *string, CListStringItem *Item, unsigned int nLine);
	bool UpdateDasm();
	void UpdateStaticText();
	void GotoAddr(ULONG_PTR Address, bool bHistory);
	void SelectAddress(ULONG_PTR Address);
	void SelectAddr(ULONG_PTR Address);
	void LoadKeyMap();
	void GetCodeRange(ULONG_PTR *pStart, ULONG_PTR *pEnd);
	bool GetJumpPos(ULONG_PTR Address, unsigned long *pJmpPos);
	void AddLineJmp();
	void DrawLineJmp(LINEDIB *LineDIB, int Pos, unsigned long Color);

	void AddPos(ULONG_PTR Addr, ULONG_PTR PrevAddr);
	void ResetPos();
	void SavePos();
	void NextPos();
	void PrevPos();
};

#endif
```

`source/WispSyser/commentlist.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "commentlist.hpp"
#include "syserconfig.hpp"

	WISP_MSG_MAP_BEGIN(CCommentList)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	WISP_EVENT_MAP_BEGIN(CCommentList)
		WISP_EVENT_MAP(0xF2, OnEventGoto)
		WISP_EVENT_MAP(0xF4, OnEventRemove)
	WISP_EVENT_MAP_END

WISP_MENU_GROUP_ITEM CommentListPopupMenu[] =
{
	{WSTR("Goto"), 0xF2, 0x80, 0, 0},
	{WSTR("Remove"), 0xF4, 0xCA, 0, 0},
	{0},
};

	CCommentList::CCommentList()
	{
	}
	CCommentList::~CCommentList()
	{
	}
#if 0
	bool CCommentList::OnUpdate(WISP_MSG *pMsg)
	{
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		UpdateItemColor(0);
		return true;
	}
#endif
	bool CCommentList::OnCreate(WISP_MSG *pMsg)
	{
		m_pItem = 0;
		AttachTitleDIB(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x93));
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		m_PopupMenu.LoadPopupMenuGroup(CommentListPopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		m_pGotoItem = m_PopupMenu.GetItem(0xF2);
		InsertColumn(WSTR("Module/Offset"), 120, 0, 0, -1);
		InsertColumn(WSTR("TimeStamp/Comment"), 150, 1, 0, -1);
		
		UpdateContext();
		return true;
	}

	bool CCommentList::OnDestroy(WISP_MSG *pMsg)
	{
		m_PopupMenu.Destroy();
		return true;
	}

	bool CCommentList::OnClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}

	bool CCommentList::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		if (!pMsg->KeyEvent.bKeyDown && pMsg->KeyEvent.KeyType == VK_RBUTTON)
		{
			m_pItem = FullFindItem(0, 8);
			m_PopupMenu.Enable(0xF2, m_pItem && (GetItemLevel(m_pItem)==1));
			if (m_pItem)
				m_PopupMenu.Point(0, 1);
		}
		return true;
	}

	bool CCommentList::OnMouseDblClick(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType != VK_LBUTTON) return true;

		{
			m_pItem = FullFindItem(0, 8);
			if (m_pItem && GetItemLevel(m_pItem) == 1)
			{
				unsigned long long Addr = GetItemValue(m_pItem, 1);
				CCommentModule *pCommentModule = (CCommentModule*)GetItemValue(GetItemParent(m_pItem), 0);
				CDbgModule *DbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(pCommentModule->m_ModuleName.operator const char*());
				if (!DbgMod)
					DbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(pCommentModule->m_ModuleName.operator const char*());
				if (DbgMod)
					gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(Addr + DbgMod->m_ImageBase, false);
			}
		}
		return true;
	}

	bool CCommentList::OnEventGoto(WISP_MSG *pMsg)
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		{
			unsigned long long Addr = GetItemValue(m_pItem, 1);
			CCommentModule *pCommentModule = (CCommentModule*)GetItemValue(GetItemParent(m_pItem), 0);
			CDbgModule *DbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(pCommentModule->m_ModuleName.operator const char*());
			if (!DbgMod)
				DbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(pCommentModule->m_ModuleName.operator const char*());
			if (DbgMod)
				gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(Addr + DbgMod->m_ImageBase, true);
		}
		return true;
	}

	bool CCommentList::OnEventRemove(WISP_MSG *pMsg)
	{
		if (GetItemLevel(m_pItem))
		{
			TAnsiString *pString = (TAnsiString*)GetItemValue(m_pItem, 0);

			//typedef _Tmap_pair<const ULONG_PTR, TAnsiString> PCM;
			//PCM *p = CONTAINING_RECORD_MY1(pString, PCM, second);
			map<ULONG_PTR, TAnsiString>::IT It = pString;//p;//pString-0x18;
			CCommentModule *pCommentModule = (CCommentModule*)GetItemValue(GetItemParent(m_pItem), 0);
			pCommentModule->m_CommentMap.erase(It);
			DeleteItem(m_pItem);
		} else
		{
			CCommentModule *pCommentModule = (CCommentModule *)GetItemValue(m_pItem, 0);
			if (pCommentModule)
			{
				gpSyser->m_SyserUI.RemoveCommentModule(pCommentModule);
				DeleteItem(m_pItem);
			}
		}
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		return true;
	}

	bool CCommentList::Edit(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (nCol != 1) return false;
		if (GetItemLevel(Item) != 1) return false;
		return true;
	}

	bool CCommentList::OnEditing(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (nCol != 1) return false;
		if (GetItemLevel(Item) != 1) return false;
		TAnsiString *pString = (TAnsiString*)GetItemValue(Item, 0);
		char Buffer[256];
		UnicodeToAnsi(String.operator const WCHAR*(), Buffer, lenof(Buffer));
		*pString = Buffer;
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		return true;
	}

	void CCommentList::Create()
	{
		if (IsWindow())
		{
			Destroy();
		} else
		{
			CreateWnd(WSTR("Comment List"), 0,0,400,380, 0, 0xD, 0x300BB, WISP_SH_MINSIZE);
			Center(0);
		}
	}

	void CCommentList::UpdateContext()
	{
		if (IsWindow())
		{
			DeleteAllChildrenItems(0);

			for (map<unsigned long long, CCommentModule>::IT it = gpSyser->m_SyserUI.m_CommentContainer.m_CommentModulesMap.begin();
				it != gpSyser->m_SyserUI.m_CommentContainer.m_CommentModulesMap.end(); ++it)
			{
				CListStringItem *Item = InsertItemStr(TGetFileName(it->second.m_ModuleName.operator const char*()), 0, 0, 0, -1);
				SetItemFormat(Item, 1, it->second.m_TimeStamp, WSTR("%08X"));
				SetItemValue(Item, 0, (unsigned long long)&it->second);
				for (map<ULONG_PTR, TAnsiString>::IT it2 = it->second.m_CommentMap.begin();
					it2 != it->second.m_CommentMap.end(); ++it2)
				{
					CListStringItem *ItemNext = InsertItemValue(it2->first, Item, WSTR("" F0ADDR "X"), 0, nullptr, -1);
					SetItemText(ItemNext, 1, it2->second.operator const char*());
					SetItemValue(ItemNext, 0, (unsigned long long)&it2->second);
					SetItemValue(ItemNext, 1, it2->first);
				}
			}
		}
	}


```

`source/WispSyser/commentlist.hpp`:

```hpp

#ifndef _COMMENTLIST_HPP_
#define _COMMENTLIST_HPP_

#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispmenu.hpp"

struct CCommentList : public CWispList
{
	CWispMenu m_PopupMenu;
	CListStringItem *m_pItem;
	CWispMenu::MenuItem *m_pGotoItem;

	CCommentList();
	virtual ~CCommentList();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnClose(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnMouseDblClick(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool OnEventGoto(WISP_MSG *pMsg);
	bool OnEventRemove(WISP_MSG *pMsg);

	virtual bool Edit(CListStringItem *Item, int nCol, TWideString& String) override; //Content? 0x80000111 //+54
	virtual bool OnEditing(CListStringItem *Item, int nCol, TWideString& String) override; //80000113,80000112 //+58

	void Create();
	void UpdateContext();
};

#endif
```

`source/WispSyser/consolewnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "consolewnd.hpp"
#include "../Code/sysdep.hpp"
#include "syserconfig.hpp"
#include "syserdefine.hpp"

	CConsoleWnd::CConsoleWnd()
	{
		m_StartCmd = 0;
	}
	CConsoleWnd::~CConsoleWnd()
	{
	}

	WISP_MSG_MAP_BEGIN(CConsoleWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
	WISP_MSG_MAP_END(CWispConsoleWnd)

SETOPTION SetEnv[] =
{
	{WSTR("iFollowMode"), 2, &gSyserConfig.iFollowMode, 0},
	{WSTR("iShowStartSplash"), 2, &gSyserConfig.iShowStartSplash, 0},
	{WSTR("iShowFullSym"), 2, &gSyserConfig.iShowFullSym, 0},
	{WSTR("iShowCCByte"), 2, &gSyserConfig.iShowCCByte, 0},
	{WSTR("iMouseSensitivity"), 2, &gSyserConfig.iMouseSensitivity, 0},
	{WSTR("iSourceCodeShowTips"), 2, &gSyserConfig.iSourceCodeShowTips, 0},
	{WSTR("iSourceCodeSyntaxColors"), 2, &gSyserConfig.iSourceCodeSyntaxColors, 0},
	{WSTR("iSourceCodeShowLineNumbers"), 2, &gSyserConfig.iSourceCodeShowLineNumbers, 0},
	{WSTR("iConnectType"), 2, &gSyserConfig.iConnectType, 0},
	{WSTR("iComPort"), 2, &gSyserConfig.iComPort, 0},
	{WSTR("iHardTimerEnable"), 2, &gSyserConfig.iHardTimerEnable, 0},
	{WSTR("szDebuggerFileName"), 1, gSyserConfig.szDebuggerFileName, MAX_FN_LEN},
	{0}
};

	bool CConsoleWnd::OnCreate(WISP_MSG *pMsg)
	{
		for (int i = 0; SysCmdTable[i].CmdStr; ++i)
		{
			CCmdParser::InsertCmd(SysCmdTable[i].CmdStr,
				(CMDPROC)SysCmdTable[i].CmdProc, gpSyser,
				SysCmdTable[i].CmdCmt,
				SysCmdTable[i].CmdUsage);
		}

		for (int i = 0; ShareCmdTable[i].CmdStr; ++i)
		{
			CCmdParser::InsertCmd(ShareCmdTable[i].CmdStr,
				(CMDPROC)ShareCmdTable[i].CmdProc, gpSyser,
				ShareCmdTable[i].CmdCmt,
				ShareCmdTable[i].CmdUsage);
		}

		for (int i = 0; OtherCmdTable[i].CmdStr; ++i)
		{
			CCmdParser::InsertCmd(OtherCmdTable[i].CmdStr,
				(CMDPROC)OtherCmdTable[i].CmdProc, gpSyser,
				OtherCmdTable[i].CmdCmt,
				OtherCmdTable[i].CmdUsage);
		}

		m_Options.Parse(SetEnv);
		SetHistoryLines(gSyserConfig.iHistoryLines);
		return true;
	}

	bool CConsoleWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType == VK_TAB && pMsg->KeyEvent.bKeyDown)
		{
			const WCHAR *pStr = TStrRChr(m_InputStr.operator const WCHAR*(), 0x20);
			if (pStr && TStrLen(pStr)>2)
			{
				char szStr[64];
				int Len = TStrCpy(szStr, pStr+1);
				if (gpSyser->m_SyserUI.GetModuleName(szStr) > Len)
				{
					m_InputStr.SetAt(PTR_DELTA(pStr,m_InputStr.m_pData)/2+1, 0);
					WCHAR szuStr[64];
					AnsiToUnicode(szStr, szuStr, lenof(szuStr));
					m_InputStr += szuStr;
					m_CaretPos.x = m_InputStr.m_nLength;
				}
			}
		}
		return true;
	}

	void CConsoleWnd::OnBeginCmd(const WCHAR *szCmd)
	{
		m_StartCmd = 1;
	}

	//virtual void OnCmd(const WCHAR *szCmd)

	void CConsoleWnd::OnEndCmd(const WCHAR *szCmd)
	{
		m_StartCmd = 0;
	}

	bool CConsoleWnd::Run(const char *szFile, const char *szParam, unsigned long *pResult)
	{
		WCHAR uCmd[MAX_FN_LEN];
		char szCmd[MAX_FN_LEN];

		int Lenght = TStrCpy(szCmd, "bat ");
		char *pStr = &szCmd[Lenght];
		if (szParam)
		{
			pStr += TStrCpy(&szCmd[Lenght], szParam);
			pStr += TStrCpy(pStr, " ");
		}
		pStr += GetModulePath(pStr, true);
		TStrCpy(pStr, szFile);

		AnsiToUnicode(szCmd, uCmd, lenof(uCmd)); //??? Rtl
		return m_pConsoleWnd->CCmdParser::ParseCmd(uCmd, pResult);
	}

```

`source/WispSyser/consolewnd.hpp`:

```hpp

#ifndef _CONSOLEWND_HPP_
#define _CONSOLEWND_HPP_

#include "../Wisp/wispconsolewnd.hpp"

struct CConsoleWnd : public CWispConsoleWnd
{
	unsigned long m_StartCmd;

	CConsoleWnd();
	virtual ~CConsoleWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);

	virtual void OnBeginCmd(const WCHAR *szCmd) override;// {}
	//virtual void OnCmd(const WCHAR *szCmd) override;// {}
	virtual void OnEndCmd(const WCHAR *szCmd) override;// {}

	bool Run(const char *szFile, const char *szParam, unsigned long *pResult);
};

#endif
```

`source/WispSyser/crossreferenceform.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "crossreferenceform.hpp"
#include "syserconfig.hpp"

WISP_FORM_RES_ITEM CrossReferenceForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 400, 240}, 0, 0xB, WSTR("xrefs to ..."), (void*)"\\SyserIcon\\Syser.ico", 0},
	{WISP_CTRL_LIST, {5, 5, 380, 160}, 1, 0x40010006, 0, 0, 0},
	{WISP_CTRL_BUTTON, {80, 180, 70, 20}, 2, 0, WSTR("OK"), 0, 0},
	{WISP_CTRL_BUTTON, {250, 180, 70, 20}, WISP_ID_CANCEL, 0, WSTR("Cancel"), 0, 0},
	{0},
};

	WISP_MSG_MAP_BEGIN(CCrossReferenceForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

        WISP_CMD_MAP_BEGIN(CCrossReferenceForm)
		WISP_CMD_MAP(1, OnCmdSelect)
        WISP_CMD_MAP_END

        WISP_EVENT_MAP_BEGIN(CCrossReferenceForm)
		WISP_EVENT_MAP(2, OnEventGoto)
        WISP_EVENT_MAP_END

	CCrossReferenceForm::CCrossReferenceForm()
	{
		m_Resource = CrossReferenceForm;
	}
	CCrossReferenceForm::~CCrossReferenceForm()
	{
	}

	bool CCrossReferenceForm::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pListWnd = (CWispList *)GetFormItem(1);
		m_pListWnd->InsertColumn(WSTR("Direction"), 40, 0, 0, -1);
		m_pListWnd->InsertColumn(WSTR("Type"), 35, 0, 0, -1);
		m_pListWnd->InsertColumn(WSTR("Address"), 100, 0, 0, -1);
		m_pListWnd->InsertColumn(WSTR("Instruction"), 200, 0, 0, -1);
		m_pListWnd->m_ItemColor = gSyserColors.Color[1];
		m_pListWnd->SetBGColor(gSyserColors.Color[0]);
		return true;
	}

	bool CCrossReferenceForm::OnCmdSelect(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000118)
			OnEventGoto(0);
		return true;
	}

	bool CCrossReferenceForm::OnEventGoto(WISP_MSG *pMsg)
	{
		CListStringItem *Item = m_pListWnd->FullFindItem(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = m_pListWnd->GetItemValue(Item, 0);
			CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
			if (pWnd)
				pWnd->GotoAddr(Addr, true);
		}
		if (pMsg)
			Destroy();
		return true;
	}

	bool CCrossReferenceForm::OpenTRefList(TList<ULONG_PTR> & Addrs, ULONG_PTR Address)
	{
		bool bSelect = true;
		m_pListWnd->DeleteAllChildrenItems(0);
		CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
		if (!pWnd) return false;

		TListIter<ULONG_PTR> It = Addrs.Begin();
		while (It != Addrs.End())
		{
			CListStringItem *Item;
			ULONG_PTR Addr = *It;
			if (Addr < Address)
				Item = m_pListWnd->InsertItemStr(WSTR("UP"), 0, 0, 0, -1);
			else	Item = m_pListWnd->InsertItemStr(WSTR("DOWN"), 0, 0, 0, -1);
			m_pListWnd->SetItemValue(Item, 0, Addr);
			m_pListWnd->SetItemColor(Item, 0, gpCurWisp->m_pWispDrawObj->m_crSystem[1]);
			m_pListWnd->SetItemColor(Item, 1, gpCurWisp->m_pWispDrawObj->m_crSystem[1]);
			m_pListWnd->SetItemColor(Item, 2, gpCurWisp->m_pWispDrawObj->m_crSystem[1]);
			m_pListWnd->SetItemFormat(Item, 2, Addr, WSTR("%X"));
			unsigned long ColorString[256];
			pWnd->ColorDasm(Addr, 16, ColorString, 0, 0, 0);
			m_pListWnd->SetItemTextColor(Item, 3, ColorString);
			if (bSelect)
				m_pListWnd->Select(Item);
			++It;
		}
		return true;
	}

	bool CCrossReferenceForm::OpenOpRefList(TList<ULONG_PTR> & Addrs, ULONG_PTR Address)
	{
		bool bSelect = true;
		m_pListWnd->DeleteAllChildrenItems(0);
		CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
		if (!pWnd) return false;

		TListIter<ULONG_PTR> It = Addrs.Begin();
		while (It != Addrs.End())
		{
			CListStringItem *Item;
			ULONG_PTR Addr = *It;
			ULONG_PTR Return;
			if ((pWnd->m_pSyserCodeDoc->GetReturn(--Addr, &Return) && Return == Address) ||
			    (pWnd->m_pSyserCodeDoc->GetReturn(--Addr, &Return) && Return == Address))
			{
				if (Addr < Address)
					Item = m_pListWnd->InsertItemStr(WSTR("UP"), 0, 0, 0, -1);
				else	Item = m_pListWnd->InsertItemStr(WSTR("DOWN"), 0, 0, 0, -1);
				m_pListWnd->SetItemValue(Item, 0, Addr);
				m_pListWnd->SetItemColor(Item, 0, gpCurWisp->m_pWispDrawObj->m_crSystem[1]);
				m_pListWnd->SetItemColor(Item, 1, gpCurWisp->m_pWispDrawObj->m_crSystem[1]);
				m_pListWnd->SetItemColor(Item, 2, gpCurWisp->m_pWispDrawObj->m_crSystem[1]);
				m_pListWnd->SetItemFormat(Item, 2, Addr, WSTR("%X"));
				unsigned long ColorString[256];
				pWnd->ColorDasm(Addr, 16, ColorString, 0, 0, 0);
				m_pListWnd->SetItemTextColor(Item, 3, ColorString);
				if (bSelect)
					m_pListWnd->Select(Item);
				bSelect = false;
			}
			++It;
		}
		return true;
	}

```

`source/WispSyser/crossreferenceform.hpp`:

```hpp

#ifndef _CROSSREFERENCEFORM_HPP_
#define _CROSSREFERENCEFORM_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wisplist.hpp"

struct CCrossReferenceForm : public CWispForm
{
	CWispList *m_pListWnd;

	CCrossReferenceForm();
	virtual ~CCrossReferenceForm();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdSelect(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventGoto(WISP_MSG *pMsg);
	bool OpenTRefList(TList<ULONG_PTR> & Addrs, ULONG_PTR Address);
	bool OpenOpRefList(TList<ULONG_PTR> & Addrs, ULONG_PTR Address);
};

#endif
```

`source/WispSyser/currentfunction.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"

#include "currentfunction.hpp"

	CCurrentFunction::CCurrentFunction()
	{
		m_ImageBaseTRUE = 0;
		m_ImageBase = 0;
		m_ImageHighBase = 0;
		m_Length = 0;
		m_pFunc = nullptr;
		m_Class = nullptr;
		m_pSDSMod = nullptr;
	}

	CCurrentFunction::~CCurrentFunction()
	{
	}

	DATATYPE *CCurrentFunction::GetLocal(char *pStr, bool bNoCase)
	{
		TListIter<DATATYPE*> It = m_Vars.Begin();
		while (It != m_Vars.End())
		{
			DATATYPE *data = *It;
			if (bNoCase && !TStrCmp(pStr, data->name))
				return data;
			else
			if (!TStrICmp(pStr, data->name))
				return data;
			++It;
		}
		if (m_pFunc && m_pFunc->ClassID) //+++
		{
			BASICTYPE *Type = m_pSDSMod->GetGlobal(m_pFunc->ClassID);
			if (Type) //+++
			{
				DATATYPE *data = m_pSDSMod->GetClassMember(pStr, (UDTYPE*)Type, nullptr);
				if (data) return data;
			}
		}
		return m_pSDSMod->GetLocal(pStr, DataIsGlobal);
	}

	FUNCTION *CCurrentFunction::GetFunction(const char *FuncName, bool X)
	{
		if (m_pFunc && m_pFunc->ClassID) //+++
		{
			FUNCTION *Func = m_pSDSMod->GetFunction(FuncName, (UDTYPE*)m_Class, false);
			if (Func) return Func;
		}
		return m_pSDSMod->GetFunction(FuncName, true);
	}

	const char *CCurrentFunction::GetSymbol(unsigned long displacement, unsigned int base, DATATYPE **Type) const
	{
	#ifdef _X64_
		static const int Reg2Index[] = {
					CV_AMD64_RAX,
					CV_AMD64_RCX,
					CV_AMD64_RDX,
					CV_AMD64_RBX,
					CV_AMD64_RSP,
					CV_AMD64_RBP,
					CV_AMD64_RSI,
					CV_AMD64_RDI};
	#else
		static const int Reg2Index[] = {
					CV_REG_EAX,
					CV_REG_ECX,
					CV_REG_EDX,
					CV_REG_EBX,
					CV_REG_ESP,
					CV_REG_EBP,
					CV_REG_ESI,
					CV_REG_EDI};
	#endif
		int registerId = 0;
		if (base != -1)
		{
			if (base > 7) return 0;
	//		if (base > 32) return 0; //???
			registerId = Reg2Index[base];
		}

		if (Type) *Type = 0;

		TListIter<DATATYPE*> It = m_Vars.Begin();
		while (It != m_Vars.End())
		{
			DATATYPE *data = *It;
			if (base != -1 && data->locationType == LocIsRegRel && //??? >> 8
			    data->RegRel.offset == displacement &&
			    data->RegRel.registerId == registerId)
			{
				if (Type) *Type = *It;
				return data->name;
			} else
			if (data->locationType == LocIsStatic &&
			    (m_ImageBaseTRUE + data->Static.rva) == displacement)
			{
				if (Type) *Type = *It;
				return data->name;
			}
			++It;
		}
		return nullptr;
	}

	void CCurrentFunction::AddClassFunctions(BASICTYPE *Type)
	{
		if (Type && (Type->Elem.Type == ELEM_STRUCT ||
			      Type->Elem.Type == ELEM_CLASS ||
			      Type->Elem.Type == ELEM_UNION))
		{
			UDTYPE *udt = (UDTYPE*)Type;
			for (int n = 0; n < udt->FunctionLen; ++n)
			{
				FUNCTION *func = m_pSDSMod->GetFunctionByID(udt->Function[n]);
				if (func)
					m_ClassFunctions.Append(&func);
			}
		}
	}

	void CCurrentFunction::Update()
	{
		m_Vars.Clear();
		for (int n = 0; n < m_pFunc->nstack; ++n)
		{
			DATATYPE *data = m_pSDSMod->GetLocal(m_pFunc->stack[n]);
			if (data)
				m_Vars.Append(&data);
		}

		for (int n = 0; n < m_pFunc->nblocks; ++n)
		{
			BLOCKTYPE *block = (BLOCKTYPE *)m_pSDSMod->GetGlobal(m_pFunc->blocks[n]);
			if (block->Elem.Type == ELEM_BLOCK) //+++ ???
			for (int i = 0; i < block->count; ++i)
			{
				DATATYPE *data = m_pSDSMod->GetLocal(block->IDs[i]);
				if (data)
					m_Vars.Append(&data);
			}
		}
		BASICTYPE *Class = m_pSDSMod->GetGlobal(m_pFunc->ClassID);
		if (Class && m_Class != Class)
		{
			m_ClassFunctions.Clear();
			AddClassFunctions(Class);
			m_Class = Class;
		}
	}

	void CCurrentFunction::Init(CSDSModule *pSDSMod, FUNCTION *pFunc)
	{
		if (pFunc)
		{
			m_pSDSMod = pSDSMod;
			CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(pSDSMod->m_ExeFileName.operator const char*());
			if (pDbgMod)
				m_ImageBaseTRUE = pDbgMod->m_ImageBase;
			else	m_ImageBaseTRUE = 0;
			m_ImageBase = m_ImageBaseTRUE + pFunc->rva; //TODO DONE
			m_ImageHighBase = m_ImageBase + pFunc->length;
			m_Length = pFunc->length;
			m_pFunc = pFunc;
			Update();
		} else
		{
			m_ImageBaseTRUE = 0;
			m_ImageBase = 0;
			m_ImageHighBase = 0;
			m_Length = 0;
			m_pFunc = 0;
			m_Class = 0;
			m_Vars.Clear();	
			m_ClassFunctions.Clear();
			m_pSDSMod = pSDSMod;
		}
	}	

```

`source/WispSyser/currentfunction.hpp`:

```hpp
#ifndef _CURRENTFUNCTION_HPP_
#define _CURRENTFUNCTION_HPP_

#include "../Code/alt/altlist.hpp"
#include "../EXEAnalyzer/sdsmodule.hpp"

struct CCurrentFunction
{
	ULONG_PTR m_ImageBaseTRUE;
	ULONG_PTR m_ImageBase;
	ULONG_PTR m_ImageHighBase;
	unsigned long m_Length;
	CSDSModule *m_pSDSMod;
	FUNCTION *m_pFunc;
	TList<DATATYPE*> m_Vars;
	TList<FUNCTION*> m_ClassFunctions;
	BASICTYPE *m_Class;

	CCurrentFunction();
	virtual ~CCurrentFunction();

	DATATYPE *GetLocal(char *pStr, bool bNoCase);
	FUNCTION *GetFunction(const char *FuncName, bool X);
	const char *GetSymbol(unsigned long displacement, unsigned int base, DATATYPE **Type) const;
	void AddClassFunctions(BASICTYPE *Type);
	void Update();
	void Init(CSDSModule *pSDSMod, FUNCTION *pFunc);
};

#endif

```

`source/WispSyser/databpedit.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "databpedit.hpp"

WISP_FORM_RES_ITEM DataBPEditForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 355, 290}, 0, 0xB, WSTR("Data break point"), 0, 0},
	{WISP_CTRL_STATIC_GROUP, {10, 5, 80, 40}, 0, 0, WSTR("Address"), 0, 0},
	{WISP_CTRL_EDIT, {20, 20, 60, 16}, 1, 0x1000006, 0, 0, WSTR("Address of break point")},
	{WISP_CTRL_STATIC_GROUP, {100, 5, 100, 40}, 0, 0, WSTR("Name"), 0, 0},
	{WISP_CTRL_EDIT, {110, 20, 80, 16}, 2, 0x1000006, 0, 0, WSTR("Name of break point (if needed)")},
	{WISP_CTRL_CHECK_BOX, {210, 17, 60, 20}, 3, 0x20000000, WSTR("Enabled"), 0, WSTR("Is break point enabled")},
	{WISP_CTRL_BUTTON, {280, 20, 55, 20}, WISP_ID_OK, 0, WSTR("OK"), 0, WSTR("Save modify setting")}, 
	{WISP_CTRL_STATIC_GROUP, {10, 50, 325, 40}, 0, 0, WSTR("Type"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {20, 65, 75, 20}, 5, 0x20000000, WSTR("ReadWrite"), 0, WSTR("break on access memory")},
	{WISP_CTRL_RADIO_BOX, {100, 65, 75, 20}, 4, 0x20000000, WSTR("WriteOnly"), 0, WSTR("break on write memory")},
	{WISP_CTRL_RADIO_BOX, {180, 65, 75, 20}, 6, 0x20000000, WSTR("Execute"), 0, WSTR("break on execute")},
	{WISP_CTRL_RADIO_BOX, {260, 65, 75, 20}, 7, 0x20000000, WSTR("I/O"), 0, WSTR("break on IO access,address is IO Num")},
	{WISP_CTRL_STATIC_GROUP, {10, 95, 325, 45}, 0, 0, WSTR("Length"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {20, 110, 75, 20}, 0xD, 0x20000000, WSTR("ALL"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {100, 110, 75, 20}, 0xA, 0x20000000, WSTR("BYTE"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {180, 110, 75, 20}, 0xB, 0x20000000, WSTR("WORD"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {260, 110, 75, 20}, 0xC, 0x20000000, WSTR("DWORD"), 0, 0},
	{WISP_CTRL_STATIC_GROUP, {10, 150, 325, 50}, 0, 0, WSTR("Condition"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {20, 170, 16, 16}, 0, 0, 0, (void*)"\\Toolbar.bmp#16#16:29", 0},
	{WISP_CTRL_EDIT, {40, 170, 285, 16}, 8, 0x1000006, 0, 0, WSTR("break condition when break point touche")},
	{WISP_CTRL_STATIC_GROUP, {10, 210, 325, 40}, 0, 0, WSTR("Do Command  (Use ; to delimit command lines)"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {20, 225, 16, 16}, 0, 0, 0, (void*)"\\Toolbar.bmp#16#16:63", 0},
	{WISP_CTRL_EDIT, {40, 225, 285, 16}, 9, 0x1000006, 0, 0, WSTR("Do command when break point touched")},
	{0},
};

	WISP_MSG_MAP_BEGIN(CDataBPEdit)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP_ON_COMMAND
	WISP_MSG_MAP_END(CWispForm)

	WISP_CMD_MAP_BEGIN(CDataBPEdit)
		WISP_CMD_MAP(1, OnCmdEdit)
		WISP_CMD_MAP(WISP_ID_OK, OnCmdOK)
	WISP_CMD_MAP_END

	CDataBPEdit::CDataBPEdit()
	{
		m_pBP = 0;
		m_Resource = DataBPEditForm;
	}

	CDataBPEdit::~CDataBPEdit()
	{
	}

	bool CDataBPEdit::OnCreateForm(WISP_MSG *pMsg)
	{
		WCHAR Buffer[256];

		m_pName = (CWispEdit *)GetFormItem(2);
		m_pAddress = (CWispEdit *)GetFormItem(1);
		m_pCondition = (CWispEdit *)GetFormItem(8);
		m_pCommand = (CWispEdit *)GetFormItem(9);

		m_pEnable = (CWispCheckBox *)GetFormItem(3);

		m_pWriteOnly = (CWispRadioBox *)GetFormItem(4);
		m_pReadWrite = (CWispRadioBox *)GetFormItem(5);
		m_pExecute = (CWispRadioBox *)GetFormItem(6);
		m_pIO = (CWispRadioBox *)GetFormItem(7);
		m_pLenAll = (CWispRadioBox *)GetFormItem(0xD);
		m_pLenByte = (CWispRadioBox *)GetFormItem(0xA);
		m_pLenWord = (CWispRadioBox *)GetFormItem(0xB);
		m_pLenDWord = (CWispRadioBox *)GetFormItem(0xC);

		m_bEnableBP = true;
		if (m_pBP)
		{
			uNumToStr(m_pBP->Address, Buffer, 16);
			m_pAddress->SetWindowText(Buffer);

			AnsiToUnicode(m_pBP->Name.operator const char*(), Buffer, lenof(Buffer));
			m_pName->SetWindowText(Buffer);

			AnsiToUnicode(m_pBP->Condition.operator const char*(), Buffer, lenof(Buffer));
			m_pCondition->SetWindowText(Buffer);

			AnsiToUnicode(m_pBP->Command.operator const char*(), Buffer, lenof(Buffer));
			m_pCommand->SetWindowText(Buffer);

			m_bEnableBP = m_pBP->State != BP_STATE_DISABLE;

			if ((m_pBP->Type & 0xC) == 0xC)
				m_pReadWrite->Enable(1);
			else
			if (m_pBP->Type & 4)
				m_pWriteOnly->Enable(1);
			else
			if (m_pBP->Type & 2)
				m_pExecute->Enable(1);
			else
			if (m_pBP->Type & 0x30)
				m_pIO->Enable(1);

			switch (m_pBP->Size)
			{
			case 1:	m_pLenByte->Enable(1); break;
			case 2:	m_pLenWord->Enable(1); break;
			case 4: m_pLenDWord->Enable(1); break;
			default:m_pLenAll->Enable(1); break;
			}
		} else
		{
			m_pLenAll->Enable(1);
			m_pReadWrite->Enable(1);
		}
		m_pEnable->Enable(m_bEnableBP);
		return true;
	}

	bool CDataBPEdit::OnCmdEdit(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000705) //WISP_ID_EDIT_CHANGED
		{
			m_pName->SetWindowText(m_pAddress->m_WndText.operator const WCHAR*());
		}
		return true;
	}
	bool CDataBPEdit::OnCmdOK(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg != 0x80000002)
			return true;

		BREAK_POINT BreakPoint;
		if (!m_pAddress->m_WndText.m_nLength)
		{
			gpCurWisp->MsgBox(WSTR("Invalid Address !"), WSTR("Error"), 0x40001, 0);
			return false;
		}

		if (!gpSyser->m_SyserUI.CalcExp(m_pAddress->m_WndText.operator const WCHAR*(), &BreakPoint.Address))
		{
			gpCurWisp->MsgBox(WSTR("Invalid Address !"), WSTR("Error"), 0x40001, 0);
			return false;
		}

		char Buffer[256];

		UnicodeToAnsi(m_pName->m_WndText.operator const WCHAR*(), Buffer, lenof(Buffer));
		BreakPoint.Name = Buffer;
		if (BreakPoint.Name.IsEmpty())
			BreakPoint.Name.Format("" F0ADDR "X", BreakPoint.Address);

		ULONG_PTR Result;
		if (!gpSyser->m_SyserUI.CalcExp(m_pCondition->m_WndText.operator const WCHAR*(), &Result))
		{
			gpCurWisp->MsgBox(WSTR("Invalid Address !"), WSTR("Error"), 0x40001, 0);
			return false;
		}

		UnicodeToAnsi(m_pCondition->m_WndText.operator const WCHAR*(), Buffer, lenof(Buffer));
		BreakPoint.Condition = Buffer;

		UnicodeToAnsi(m_pCommand->m_WndText.operator const WCHAR*(), Buffer, lenof(Buffer));
		BreakPoint.Command = Buffer;
		
		m_bEnableBP = (m_pEnable->m_Style >> 10) & 1;

		BreakPoint.Type = 1;
		BreakPoint.State = m_bEnableBP ? BP_STATE_ENABLE : BP_STATE_DISABLE;

		if ((m_pReadWrite->m_Style >> 10) & 1)
			BreakPoint.Type = 0xD; //8|4|1
		else
		if ((m_pWriteOnly->m_Style >> 10) & 1)
			BreakPoint.Type = 5;
		else
		if ((m_pExecute->m_Style >> 10) & 1)
			BreakPoint.Type = 3;
		else
		if ((m_pIO->m_Style >> 10) & 1)
			BreakPoint.Type = 0x31;

		if ((m_pLenByte->m_Style >> 10) & 1)
			BreakPoint.Size = 1;
		else
		if ((m_pLenWord->m_Style >> 10) & 1)
			BreakPoint.Size = 2;
		else
		if ((m_pLenDWord->m_Style >> 10) & 1)
			BreakPoint.Size = 4;
		else	BreakPoint.Size = 0;

		if (m_pBP)
		{
			if (BreakPoint.Address == m_pBP->Address &&
			    BreakPoint.Type == m_pBP->Type &&
			    BreakPoint.State == m_pBP->State &&
			    BreakPoint.Size == m_pBP->Size)
			{
				m_pBP->Name = BreakPoint.Name;
				m_pBP->Condition = BreakPoint.Condition;
				m_pBP->Command = BreakPoint.Command;
				return true;
			}
			gpSyser->m_pSysDebugger->DelDataBP(*m_pBP); //???
		}

		m_pBP = gpSyser->m_pSysDebugger->SetDataBP(BreakPoint.Address,
						BreakPoint.Type,
						BreakPoint.State,
						BreakPoint.Size);
		if (!m_pBP)
		{
			gpCurWisp->MsgBox(WSTR("Fail to insert breakpoint !"), WSTR("Error"), 0x40001, 0);
			return false;
		}
		m_pBP->Name = BreakPoint.Name;
		m_pBP->Condition = BreakPoint.Condition;
		m_pBP->Command = BreakPoint.Command;
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		return true;
	}

```

`source/WispSyser/databpedit.hpp`:

```hpp

#ifndef _DATABPEDIT_HPP_
#define _DATABPEDIT_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wispedit.hpp"
#include "../Wisp/wispcheckbox.hpp"
#include "../Wisp/wispradiobox.hpp"
#include "../EXEAnalyzer/debugger.hpp"

struct CDataBPEdit : public CWispForm
{
	BREAK_POINT *m_pBP;
	CWispEdit *m_pName;
	CWispEdit *m_pAddress;
	CWispEdit *m_pCondition;
	CWispEdit *m_pCommand;
	CWispCheckBox *m_pEnable;
	CWispRadioBox *m_pWriteOnly;
	CWispRadioBox *m_pReadWrite;
	CWispRadioBox *m_pExecute;
	CWispRadioBox *m_pIO;
	CWispRadioBox *m_pLenAll;
	CWispRadioBox *m_pLenByte;
	CWispRadioBox *m_pLenWord;
	CWispRadioBox *m_pLenDWord;
	bool m_bEnableBP;

	CDataBPEdit();
	virtual ~CDataBPEdit();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);

	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdEdit(WISP_MSG *pMsg);
	bool OnCmdOK(WISP_MSG *pMsg);
};

#endif
```

`source/WispSyser/dataoperatordlg.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "dataoperatordlg.hpp"
#include "resource.hpp"

	//TODO Value Hex/Dec update input

WISP_FORM_RES_ITEM DataOperatorDlg[] =
{
	{WISP_CTRL_FORM, {0, 0, 340, 240}, 0, 0xB, WSTR("Data Operation"), (void*)"\\SyserIcon\\Plugin.ico", 0},
	{WISP_CTRL_STATIC_GROUP, {11, 6, 313, 53}, 0, 0, WSTR("Description"), 0, 0},
	{WISP_CTRL_STATIC_GROUP, {11, 64, 313, 80}, 0, 0, WSTR("Data Width"), 0, 0},
	{WISP_CTRL_STATIC_GROUP, {11, 151, 234, 55}, 0, 0, WSTR("Length"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {25, 76, 96, 16}, 3, 0x1000006, WSTR("BYTE (Bit 8)"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {180, 76, 110, 16}, 4, 0x1000006, WSTR("WORD (Bit 16)"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {25, 96, 110, 16}, 5, 0x1000006, WSTR("DWORD (Bit 32)"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {180, 96, 110, 16}, 6, 0x1000006, WSTR("QWORD (Bit 64)"), 0, 0},
	{WISP_CTRL_STATIC_STRING, {14, 20, 310, 50}, 7, 0, WSTR(""), 0, 0},
	{WISP_CTRL_STATIC_STRING, {25, 120, 40, 16}, 0xA, 0, WSTR("Value:"), 0, 0},
	{WISP_CTRL_EDIT, {65, 120, 105, 16}, 0xE, 0x1000006, 0, 0, 0},
	{WISP_CTRL_RADIO_BOX, {180, 119, 65, 16}, 9, 0x1000006, WSTR("Decimal"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {250, 119, 110, 16}, 8, 0x1000006, WSTR("Hex"), 0, 0},
	{WISP_CTRL_STATIC_STRING, {16, 167, 90, 16}, 0xB, 0, WSTR("Begin Address:"), 0, 0},
	{WISP_CTRL_EDIT, {105, 166, 80, 16}, 0xC, 0x1000006, 0, 0, 0},
	{WISP_CTRL_STATIC_STRING, {16, 185, 90, 16}, 0xB, 0, WSTR("  End Address:"), 0, 0},
	{WISP_CTRL_EDIT, {105, 185, 80, 16}, 0xD, 0x1000006, 0, 0, 0},
	{WISP_CTRL_CHECK_BOX, {190, 184, 60, 16}, 0xF, 0x20000000, WSTR("Count"), 0, 0},
	{WISP_CTRL_BUTTON, {255, 155, 68, 20}, 1, 0, WSTR("OK"), 0, 0},
	{WISP_CTRL_BUTTON, {255, 185, 68, 20}, 2, 0, WSTR("Cancel"), 0, 0},
	{0},
};

	WISP_MSG_MAP_BEGIN(CDataOperatorDlg)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

	WISP_EVENT_MAP_BEGIN(CDataOperatorDlg)
		WISP_EVENT_MAP(0x1, OnEventExecOp)
		WISP_EVENT_MAP(0x2, OnEventClose)
	WISP_EVENT_MAP_END

	WISP_CMD_MAP_BEGIN(CDataOperatorDlg)
		WISP_CMD_MAP(0xE, OnCmd)
	WISP_CMD_MAP_END

	CDataOperatorDlg::CDataOperatorDlg()
	{
		m_Resource = DataOperatorDlg;
	}
	CDataOperatorDlg::~CDataOperatorDlg()
	{
	}

	const WCHAR *DescOp[] =
		{
			WSTR("Fips the byte order of you data. For example, the \nword 0xABCD would become 0xCDAB."),
			WSTR("Inverts the bits of your data. For example, the \nvalue 0x35 (00110101 in binary) would become 0xCA\n(11001010 in binary)."),
			WSTR("Shift the bits of your data to the left. For \nexample,the value 0x08 (00001000 in binary) would \nbecome 0x10 (00010000 in binary)."),
			WSTR("Shift the bits of your data to the right. For \nexample,the value 0x08(00001000 in binary) would \nbecome 0x04 (00000100 in binary)."),
			WSTR("Rotates the bits of your data to the left. For\nexample,the value 0x98 (10011000 in binary) would \nbecome 0x31 (00110001 in binary)."),
			WSTR("Rotates the bits of your data to the right. For\nexampel,the value 0x61 (01100001 in binary) would \nbecome 0xB0 (10110000 in binary)."),
			WSTR("Shift the bits of your data to the left across byte\nboundaries. For example,the value 0x08(00001000 in\nbinary) would become 0x10 (00010000 in binary)."),
			WSTR("Shift the bits of your data to the right across byte\nboundaries. For example,the value 0x08 (00001000 in\nbinary) would become 0x04 (00000100 in binary)."),
			WSTR("Performs a XOR operation. For example,the value\n0xFO (11110000 in binary) XOR 0xAA (10101010 in \nbinary) is 0x5A (01011010 in binary)."),
			WSTR("Performs an OR operation. For example,the value\n0xF0 (11110000 in binary) OR 0xAA (10101010 in \nbinary) is 0xFA (11111010 in binary)."),
			WSTR("Performs an AND operation. For example,the value\n0xF0 (11110000 in binary) AND 0xAA (10101010 in \nbinary) is 0xA0 (10100000 in binary)."),
			WSTR("Change the sign of your data. For example,a value of\n5 would become -5 or a value of -5 would become 5."),
			WSTR("Replaces your data with your data plus another value\n(data = data + value)."),
			WSTR("Replaces your data with your data minus another\nvalue (data = data - value)."),
			WSTR("Replaces your data with your data multiplied by \nanother value (data = data * value)."),
			WSTR("Replaces your data with your data divided by another\nvalue (data = data / value)."),
			WSTR("Replaces your data with your data mod another value\n(data = data % value)."),
			WSTR("Replaces your character data with all upper case\ncharacters. For example,the text \"Test String\"\nwould become \"TEST STRING\"."),
			WSTR("Replaces your character data with all lower case\ncharacters. For example,the text \"Test String\"\nwould become \"test string\"."),
			WSTR("Replaces your character data with the inverse \ncharacter case. For example, the next \"Test String\" would\nbecome \"tEST sTRING\"."),
		};

	const WCHAR *NameOp[] =
		{
			WSTR("ByteFlip Operation"),
			WSTR("Inverse Bits Operation"),
			WSTR("Shift Left Operation"),
			WSTR("Shift Right Operation"),
			WSTR("Rotate Left Operation"),
			WSTR("Rotate Right Operation"),
			WSTR("Block Shift Left Operation"),
			WSTR("Block Shift Right Operation"),
			WSTR("XOR Operation"),
			WSTR("OR Operation"),
			WSTR("AND Operation"),
			WSTR("Change Sign Operation"),
			WSTR("Add Operation"),
			WSTR("Subtract Operation"),
			WSTR("Multiply Operation"),
			WSTR("Divide Operation"),
			WSTR("Mod Operation"),
			WSTR("Upper Case Operation"),
			WSTR("Lower Case Operation"),
			WSTR("Inverse Case Operation"),
		};

	void ByteFlipOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length && Size != 1)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char ReadBuffer[8];
				unsigned char WriteBuffer[8];

				if (gpSyser->m_pDebugger->ReadMemory(Address, ReadBuffer, Size) != Size) break;

				for (unsigned long n = 0; n <= Size-1; ++n)
				{
					WriteBuffer[n] = ReadBuffer[Size-1-n];
				}

				if (gpSyser->m_pDebugger->WriteMemory(Address, WriteBuffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void InverseOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1);
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, 1) != 1) break;

				Buffer[0] = ~Buffer[0];

				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, 1) != 1) break;
				++Address;
			}
		}
	}

	void SHLOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) <<= Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) <<= Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) <<= Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) <<= Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void SHROp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) >>= Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) >>= Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) >>= Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) >>= Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

#define ROL(x,n,r) (((x) >> (unsigned char)(((n)<<3)-(r))) | ((x) << (unsigned char)(r)))

#define ROR(x,n,r) (((x) << (unsigned char)(((n)<<3)-(r))) | ((x) >> (unsigned char)(r)))

	void ROLOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			unsigned long r = Value % (8 * Size);
			if (r)
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) = ROL(*(unsigned char*)&(Buffer[0]), 1, r);
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) = ROL(*(unsigned short*)&(Buffer[0]), 2, r);
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) = ROL(*(unsigned long*)&(Buffer[0]), 4, r);
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) = ROL(*(unsigned long long*)&(Buffer[0]), 8, r);
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void ROROp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			unsigned long r = Value % (8 * Size);
			if (r)
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) = ROR(*(unsigned char*)&(Buffer[0]), 1, r);
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) = ROR(*(unsigned short*)&(Buffer[0]), 2, r);
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) = ROR(*(unsigned long*)&(Buffer[0]), 4, r);
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) = ROR(*(unsigned long long*)&(Buffer[0]), 8, r);
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void BlockSHLOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1);
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, 1) != 1) break;

				*(unsigned char*)&(Buffer[0]) <<= Value;

				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, 1) != 1) break;
				++Address;
			}
		}
	}

	void BlockSHROp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1);
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, 1) != 1) break;

				*(unsigned char*)&(Buffer[0]) >>= Value;

				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, 1) != 1) break;
				++Address;
			}
		}
	}

	void XOROp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) ^= Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) ^= Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) ^= Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) ^= Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void OROp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) |= Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) |= Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) |= Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) |= Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void ANDOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) &= Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) &= Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) &= Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) &= Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void ChangeSignOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) = - *(unsigned char*)&(Buffer[0]);
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) = - *(unsigned short*)&(Buffer[0]);
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) = - *(unsigned long*)&(Buffer[0]);
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) = -*(unsigned long long*)&(Buffer[0]);
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void AddOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) += Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) += Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) += Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) += Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void SubtractOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) -= Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) -= Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) -= Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) -= Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void MultiplyOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) *= Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) *= Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) *= Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) *= Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void DivideOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length && Value)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) /= Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) /= Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) /= Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) /= Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void ModOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1) / Size;
		if (Length && Value)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size) != Size) break;
				switch (Size)
				{
				case 1:
					*(unsigned char*)&(Buffer[0]) %= Value;
					break;
				case 2:
					*(unsigned short*)&(Buffer[0]) %= Value;
					break;
				case 4:
					*(unsigned long*)&(Buffer[0]) %= Value;
					break;
				case 8:
					*(unsigned long long*)&(Buffer[0]) %= Value;
					break;
				}
				if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size) != Size) break;
				Address += Size;
			}
		}
	}

	void UpperCaseOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1);
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, 1) != 1) break;

				//if (Buffer[0] >= 'a' && Buffer[0] <= 'z')
				if (IS_LOWER(Buffer[0]))
				{
					Buffer[0] -= ' ';
					if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, 1) != 1) break;
				}
				++Address;
			}
		}
	}

	void LowerCaseOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1);
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, 1) != 1) break;

				//if (Buffer[0] >= 'A' && Buffer[0] <= 'Z')
				if (IS_UPPER(Buffer[0]))
				{
					Buffer[0] += ' ';
					if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, 1) != 1) break;
				}
				++Address;
			}
		}
	}

	void InverseCaseOp(ULONG_PTR Begin,ULONG_PTR End,int Size,long long Value)
	{
		ULONG_PTR Address = Begin;
		unsigned long Length = (End - Begin + 1);
		if (Length)
		{
			for (unsigned long i = 0; i < Length; ++i)
			{
				unsigned char Buffer[8];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Buffer, 1) != 1) break;

				//if ((Buffer[0] >= 'A' && Buffer[0] <= 'Z') || (Buffer[0] >= 'a' && Buffer[0] <= 'z'))
				if (IS_UPPER(Buffer[0]) || IS_LOWER(Buffer[0]))
				{
					Buffer[0] ^= 0x20;
					if (gpSyser->m_pDebugger->WriteMemory(Address, Buffer, 1) != 1) break;
				}
				++Address;
			}
		}
	}

	void (*FuncsOp[])(ULONG_PTR,ULONG_PTR,int,long long) =
		{
			ByteFlipOp,
			InverseOp,
			SHLOp,
			SHROp,
			ROLOp,
			ROROp,
			BlockSHLOp,
			BlockSHROp,
			XOROp,
			OROp,
			ANDOp,
			ChangeSignOp,
			AddOp,
			SubtractOp,
			MultiplyOp,
			DivideOp,
			ModOp,
			UpperCaseOp,
			LowerCaseOp,
			InverseCaseOp,
		};

	bool CDataOperatorDlg::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pOK = (CWispButton *)GetFormItem(1);
		m_pCancel = (CWispButton *)GetFormItem(2);

		m_pWidth8 = (CWispRadioBox *)GetFormItem(3);
		m_pWidth16 = (CWispRadioBox *)GetFormItem(4);
		m_pWidth32 = (CWispRadioBox *)GetFormItem(5);
		m_pWidth64 = (CWispRadioBox *)GetFormItem(6);

		m_pNameDesc = (CWispStaticStr *)GetFormItem(7);
		m_pDec = (CWispRadioBox *)GetFormItem(9);
		m_pHex = (CWispRadioBox *)GetFormItem(8);
		m_pCount = (CWispCheckBox *)GetFormItem(0xF);
		m_pValueName = (CWispStaticStr *)GetFormItem(0xA);
		m_pBegin = (CWispEdit *)GetFormItem(0xC);
		m_pEnd = (CWispEdit *)GetFormItem(0xD);
		m_pValue = (CWispEdit *)GetFormItem(0xE);

		WCHAR DisplayOut[20];

		TSPrintf(DisplayOut, WSTR("%x"), m_Begin);
		m_pBegin->SetWindowText(DisplayOut);

		TSPrintf(DisplayOut, WSTR("%x"), m_End);
		m_pEnd->SetWindowText(DisplayOut);

		if (m_Len == 1)
			m_pWidth8->Enable(1);
		if (m_Len == 2)
			m_pWidth16->Enable(1);
		if (m_Len == 4)
			m_pWidth32->Enable(1);

		m_pNameDesc->SetWindowText(DescOp[m_Op]);
		SetWindowText(NameOp[m_Op]);

		m_pHex->Enable(1);
		unsigned int Op = m_Op + EVENT_ID_OP_BFLIP; //0xA9;
		if (Op == EVENT_ID_OP_BFLIP || //0xA9
		    Op == EVENT_ID_OP_BINV || //0xAA
		    Op == EVENT_ID_OP_SIG || //0xB4
		    Op == EVENT_ID_OP_UPR || //0xBA
		    Op == EVENT_ID_OP_LWR || //0xBB
		    Op == EVENT_ID_OP_INV) //0xBC
		{
			m_pValue->EnableWindow(0);
			m_pDec->EnableWindow(0);
			m_pHex->EnableWindow(0);
		} else
		{
			m_pOK->EnableWindow(0);
		}
		return true;
	}
	bool CDataOperatorDlg::OnDestroy(WISP_MSG *pMsg)
	{
		return true;
	}

	bool CDataOperatorDlg::Create(CWispWnd *pParentWnd, int ShowMode, ULONG_PTR Start, ULONG_PTR End, unsigned long Length, unsigned int CmdID)
	{
		m_Begin = Start;
		m_End = End;
		m_Len = Length;
		m_Op = CmdID - EVENT_ID_OP_BFLIP;
		return CWispForm::Create(pParentWnd, ShowMode);
	}

	int CDataOperatorDlg::GetWidth()
	{
		if (m_pWidth16->m_Style & 0x400) return 2;
		if (m_pWidth32->m_Style & 0x400) return 4;
		if (m_pWidth64->m_Style & 0x400) return 8;
		return 1;
	}

	bool CDataOperatorDlg::OnCmd(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000703) //WISP_ID_EDIT_KEYDOWN
		{
			return (pMsg->Command.Param1 < 'g' || pMsg->Command.Param1 > 'z') &&
			       (pMsg->Command.Param1 < 'G' || pMsg->Command.Param1 > 'Z') &&
			       ((m_pHex->m_Style & 0x400) ||
			        ((pMsg->Command.Param1 < 'a' || pMsg->Command.Param1 > 'f') &&
                                 (pMsg->Command.Param1 < 'A' || pMsg->Command.Param1 > 'F')));
		} else
		if (pMsg->Command.CmdMsg == 0x80000705) //WISP_ID_EDIT_CHANGED
		{
			ULONG_PTR Num;
			if (m_pHex->m_Style & 0x400)
				m_pOK->EnableWindow(USHexStrToNum(m_pValue->GetWindowText().operator const WCHAR*(), &Num));
			else	m_pOK->EnableWindow(USDecStrToNum(m_pValue->GetWindowText().operator const WCHAR*(), &Num));
		}
		return true;
	}

	bool CDataOperatorDlg::OnEventExecOp(WISP_MSG *pMsg)
	{
		long long Value = 0;

		ULONG_PTR Begin;
		if (!USHexStrToNum(m_pBegin->GetWindowText().operator const WCHAR*(), &Begin))
			Begin = m_Begin;

		ULONG_PTR End;
		if (!USHexStrToNum(m_pEnd->GetWindowText().operator const WCHAR*(), &End))
			End = m_End;

		int Size = GetWidth();

		if (!m_pValue->GetWindowText().IsEmpty())
		{
			if (m_pHex->m_Style & 0x400)
			{
				if (!USHexStrToNum(m_pValue->GetWindowText().operator const WCHAR*(), &Value)) Value = 0;
			} else
			{
				if (!USDecStrToNum(m_pValue->GetWindowText().operator const WCHAR*(), &Value)) Value = 0;
			}
		}
		FuncsOp[m_Op](Begin, End, Size, Value);
		gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
		CWispBaseWnd::Close();
		return true;
	}

	bool CDataOperatorDlg::OnEventClose(WISP_MSG *pMsg)
	{
		CWispBaseWnd::Close();
		return true;
	}

```

`source/WispSyser/dataoperatordlg.hpp`:

```hpp

#ifndef _DATAOPERATORDLG_HPP_
#define _DATAOPERATORDLG_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wispstatic.hpp"
#include "../Wisp/wispbutton.hpp"
#include "../Wisp/wispradiobox.hpp"
#include "../Wisp/wispcheckbox.hpp"
#include "../Wisp/wispedit.hpp"

struct CDataOperatorDlg : CWispForm
{
	CWispStaticStr *m_pNameDesc;
	CWispButton *m_pOK;
	CWispButton *m_pCancel;
	CWispRadioBox *m_pWidth8;
	CWispRadioBox *m_pWidth16;
	CWispRadioBox *m_pWidth32;
	CWispRadioBox *m_pWidth64;
	CWispRadioBox *m_pDec;
	CWispRadioBox *m_pHex;
	CWispCheckBox *m_pCount;
	CWispStaticStr *m_pValueName;
	CWispEdit *m_pBegin;
	CWispEdit *m_pEnd;
	CWispEdit *m_pValue;

	ULONG_PTR m_Begin;
	ULONG_PTR m_End;
	unsigned long m_Len;
	unsigned int m_Op;

	CDataOperatorDlg();
	virtual ~CDataOperatorDlg();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreateForm(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool Create(CWispWnd *pParentWnd, int ShowMode, ULONG_PTR Start, ULONG_PTR End, unsigned long Length, unsigned int CmdID);
	int GetWidth();
	bool OnCmd(WISP_MSG *pMsg);
	bool OnEventExecOp(WISP_MSG *pMsg);
	bool OnEventClose(WISP_MSG *pMsg);
};

#endif
```

`source/WispSyser/dataview.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "dataview.hpp"
#include "resource.hpp"

	WISP_MSG_MAP_BEGIN(CDataView)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispHexWnd)


	WISP_EVENT_MAP_BEGIN(CDataView)
		WISP_EVENT_MAP(EVENT_ID_SHOW_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_NEW_DATA, OnEventNewData)
		WISP_EVENT_MAP(EVENT_ID_DISASM, OnEventGotoDasm)
		WISP_EVENT_MAP(EVENT_ID_NEW_CODE, OnEventNewDasm)
	#ifdef _RING0_
		WISP_EVENT_MAP(EVENT_ID_DASM_PHYS_ADDR, OnEventShowPhysAddr)
		WISP_EVENT_MAP(EVENT_ID_SHOW_PHYS_ADDR, OnEventDasmPhysAddr)
	#endif
		WISP_EVENT_MAP(EVENT_ID_SHOW_OP, OnEventToggleToolbar)

		WISP_EVENT_MAP(EVENT_ID_ATTACH_TYPE, OnEventAttachType)
		WISP_EVENT_MAP(EVENT_ID_FIND_FORM, OnEventFindForm)

		WISP_EVENT_MAP(EVENT_ID_SHOW_OFFSET, OnEventToggleOffsetMode)

		WISP_EVENT_MAP(EVENT_ID_DV_ADDR_MODE, OnEventToggleAddressMode)

		WISP_EVENT_MAP(EVENT_ID_DATA_WIDTH, OnEventDataWidth);

		WISP_EVENT_MAP(EVENT_ID_DV0, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_DV1, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_DV2, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_DV3, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_DV4, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_DV5, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_DV6, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_DV7, OnEventNewView)
		WISP_EVENT_MAP(EVENT_ID_DV8, OnEventNewView)

		WISP_EVENT_MAP(EVENT_ID_OP_BFLIP, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_BINV, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_SHL, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_SHR, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_ROL, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_ROR, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_BSHL, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_BSHR, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_XOR, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_OR, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_AND, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_SIG, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_ADD, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_SUB, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_MUL, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_DIV, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_MOD, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_UPR, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_LWR, OnEventOp)
		WISP_EVENT_MAP(EVENT_ID_OP_INV, OnEventOp)

		WISP_EVENT_MAP(EVENT_ID_DV_SHOW_DATA_AT, OnEventShowDataAt)
		WISP_EVENT_MAP(EVENT_ID_CV_OPEN, OnEventShowDasm)
		WISP_EVENT_MAP(EVENT_ID_DV_SHOW_DATA_AT_REL, OnEventShowDataAt)
		WISP_EVENT_MAP(EVENT_ID_COPYVAL, OnEventCopyVal)
		WISP_EVENT_MAP(EVENT_ID_COPYADDR, OnEventCopyAddr)

		WISP_EVENT_MAP(EVENT_ID_COPYSEL, OnEventCopySelect)
		WISP_EVENT_MAP(EVENT_ID_COPYSEL_CLANG, OnEventCopySelect)
		WISP_EVENT_MAP(EVENT_ID_COPYSEL_SPACE, OnEventCopySelect)

		WISP_EVENT_MAP(EVENT_ID_FLOAT_MODE, OnEventToggleFloatAddressMode)

		WISP_EVENT_MAP(EVENT_ID_HISTORY_NEXT, OnEventNextHistory)
		WISP_EVENT_MAP(EVENT_ID_HISTORY_PREV, OnEventPrevHistory)
	WISP_EVENT_MAP_END

WISP_MENU_GROUP_ITEM DataViewPopupMenu[] = 
{
	{WSTR("Open new data view at "), EVENT_ID_NEW_DATA, 0xE0, 0, 0},
	{WSTR("Show Data                  Enter"), EVENT_ID_SHOW_DATA, 0xE0, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Open new code view at "), EVENT_ID_NEW_CODE, 0xDF, 0, 0},
	{WSTR("Disassemble code at " F0ADDR "X   Shift+Enter"), EVENT_ID_DISASM, 0xDF, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Data Operator Toolbar          Ctrl+T"), EVENT_ID_SHOW_OP, 0x76, 0, 0},
	{WSTR("Attach type to Addr                  "), EVENT_ID_ATTACH_TYPE, 0xE2, 0, 0}, //??? ICON ID
	{WSTR("Find                                 "), EVENT_ID_FIND_FORM, 0xC, 0, 0}, //??? ICON ID
	{0, 0, 0, 4, 0},
	{WSTR("Show offset                    Ctrl+S"), EVENT_ID_SHOW_OFFSET, 0xE2, 0, 0},
	{WSTR("Width                                "), EVENT_ID_DATA_WIDTH, 0xE2, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Address Mode                   Ctrl+O"), EVENT_ID_DV_ADDR_MODE, 0xE2, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Float mode                     Ctrl+M"), EVENT_ID_FLOAT_MODE, 0xE2, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Copy selected data (WO space)  Shift+X"), EVENT_ID_COPYSEL, 0x23, 0, 0},
	{WSTR("Copy selected data             Ctrl+X"), EVENT_ID_COPYSEL_SPACE, 0x82, 0, 0},
	{WSTR("Copy data as C source          Ctrl+Z"), EVENT_ID_COPYSEL_CLANG, 0x82, 0, 0},
	{WSTR("Copy value                     Ctrl+Enter"), EVENT_ID_COPYVAL, 0x100, 0, 0},
	{0},
};

WISP_TOOLBAR_RES_ITEM DataViewToolbar[] =
{
	{EVENT_ID_OP_BFLIP, 0, 0, WSTR("ByteFlip"), 0, 0},
	{EVENT_ID_OP_BINV, 1, 0, WSTR("Inverse Bits"), 0, 0},
	{EVENT_ID_OP_SHL, 2, 0, WSTR("Shift Left"), 0, 0},
	{EVENT_ID_OP_SHR, 3, 0, WSTR("Shift Right"), 0, 0},
	{EVENT_ID_OP_ROL, 4, 0, WSTR("Rotate Left"), 0, 0},
	{EVENT_ID_OP_ROR, 5, 0, WSTR("Rotate Right"), 0, 0},
	{EVENT_ID_OP_BSHL, 6, 0, WSTR("Block Shift Left"), 0, 0},
	{EVENT_ID_OP_BSHR, 7, 0, WSTR("Block Shift Right"), 0, 0},
	{EVENT_ID_OP_XOR, 8, 0, WSTR("XOR"), 0, 0},
	{EVENT_ID_OP_OR, 9, 0, WSTR("OR"), 0, 0},
	{EVENT_ID_OP_AND, 0xA, 0, WSTR("AND"), 0, 0},
	{EVENT_ID_OP_SIG, 0xB, 0, WSTR("Change Sign"), 0, 0},
	{EVENT_ID_OP_ADD, 0xC, 0, WSTR("Add"), 0, 0},
	{EVENT_ID_OP_SUB, 0xD, 0, WSTR("Subtract"), 0, 0},
	{EVENT_ID_OP_MUL, 0xE, 0, WSTR("Multiply"), 0, 0},
	{EVENT_ID_OP_DIV, 0xF, 0, WSTR("Divide"), 0, 0},
	{EVENT_ID_OP_MOD, 0x10, 0, WSTR("Mod"), 0, 0},
	{EVENT_ID_OP_UPR, 0x11, 0, WSTR("Upper Case"), 0, 0},
	{EVENT_ID_OP_LWR, 0x12, 0, WSTR("Lower Case"), 0, 0},
	{EVENT_ID_OP_INV, 0x13, 0, WSTR("Inverse Case"), 0, 0},
	{0},
};

	CDataView::CDataView()
	{
	}
	CDataView::~CDataView()
	{
	}

	bool CDataView::OnCreate(WISP_MSG *pMsg)
	{
		m_RButtonAddress = -1;
		m_LButtonAddress = -1;
		m_PopupMenu.LoadPopupMenuGroup(DataViewPopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		m_Style |= 0x10000;
		m_Toolbar.CreateEx(this, 0, -1, EVENT_ID_SHOW_OP, 0);
		m_Toolbar.LoadToolbar(gpCurWisp->m_DIBLib.LoadDIBList("\\SyserApp\\Operation.bmp", 16, 16, 0, 0xFF00FF), DataViewToolbar);
		m_Toolbar.Show(WISP_SH_HIDDEN);
		LoadKeyMap();
		return true;
	}
	bool CDataView::OnDestroy(WISP_MSG *pMsg)
	{
		m_PopupMenu.Destroy();
		return true;
	}

	void CDataView::OnKeyLButton(WISP_MSG *pMsg)
	{
		if (!CalcPointPos(&pMsg->MsgMouseWndPT, &m_LButtonAddress, 0))
			m_LButtonAddress = m_CurAddr;
	}

	void CDataView::OnKeyRButton(WISP_MSG *pMsg)
	{
		WCHAR szHotKey[50];
		WCHAR szMenu[256];

		m_RButtonAddress = -1;
		bool bValue = false;
		bool bAddr = false;
		LONG_PTR Offset = 0;
		if (CalcPointPos(&pMsg->MsgMouseWndPT, &m_RButtonAddress, 0))
		{
			if (gpSyser->m_KeyMap[VK_SHIFT])
				Offset = m_RButtonAddress - m_CurAddr;
			bValue = ReadMemory(m_RButtonAddress, &m_RButtonAddress, sizeof(m_RButtonAddress)) == sizeof(m_RButtonAddress);
			if (bValue)
			{
				ULONG_PTR Val;
				bAddr = ReadMemory(m_RButtonAddress, &Val, sizeof(Val)) == sizeof(Val);
				if (bAddr)
				{
					m_RButtonAddress -= Offset;

					TSPrintf(szMenu, WSTR("Open new data view at " F0ADDR "X"), m_RButtonAddress);
					m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_NEW_DATA), szMenu);

					gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_DV_SHOW_DATA_AT), szHotKey);
					TSPrintf(szMenu, WSTR("Display data at " F0ADDR "X           %s"), m_RButtonAddress, szHotKey);
					m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_SHOW_DATA), szMenu);

					TSPrintf(szMenu, WSTR("Open new code view at " F0ADDR "X"), m_RButtonAddress);
					m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_NEW_CODE), szMenu);

					gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_CV_OPEN), szHotKey);
					TSPrintf(szMenu, WSTR("Disassemble code at " F0ADDR "X       %s"), m_RButtonAddress, szHotKey);
					m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_DISASM), szMenu);
				}
			}
		}
		
		gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_DV_ADDR_MODE), szHotKey);
		if (GetAddressMode())
			TSPrintf(szMenu, WSTR("Address Mode                   %s"), szHotKey);
		else	TSPrintf(szMenu, WSTR("Offset Mode                    %s"), szHotKey);
		m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_DV_ADDR_MODE), szMenu);

		gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_COPYSEL), szHotKey);
		TSPrintf(szMenu, WSTR("Copy selected data (WO space)  %s"), szHotKey);
		m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_COPYSEL), szMenu);

		gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_COPYSEL_SPACE), szHotKey);
		TSPrintf(szMenu, WSTR("Copy selected data             %s"), szHotKey);
		m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_COPYSEL_SPACE), szMenu);

		gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_COPYSEL_CLANG), szHotKey);
		TSPrintf(szMenu, WSTR("Copy data as C source          %s"), szHotKey);
		m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_COPYSEL_CLANG), szMenu);

		gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_COPYVAL), szHotKey);
		TSPrintf(szMenu, WSTR("Copy value                     %s"), szHotKey);
		m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_COPYVAL), szMenu);

		gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_SHOW_OP), szHotKey);
		TSPrintf(szMenu, WSTR("Data Operator Toolbar          %s"), szHotKey);
		m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_SHOW_OP), szMenu);

		gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_SHOW_OFFSET), szHotKey);
		TSPrintf(szMenu, WSTR("Show offset                    %s"), szHotKey);
		m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_SHOW_OFFSET), szMenu);

		gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_FLOAT_MODE), szHotKey);
		if (GetFloatAddressMode())
			TSPrintf(szMenu, WSTR("Fixed mode                     %s"), szHotKey);
		else	TSPrintf(szMenu, WSTR("Float mode                     %s"), szHotKey);
		m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_FLOAT_MODE), szMenu);

		gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_DATA_WIDTH), szHotKey);
		if (m_nByte_Line == 16)
			TSPrintf(szMenu, WSTR("Width 32                       %s"), szHotKey);
		else
		if (m_nByte_Line == 32)
			TSPrintf(szMenu, WSTR("Width 16                       %s"), szHotKey);
		m_PopupMenu.SetItemText(m_PopupMenu.GetItem(EVENT_ID_DATA_WIDTH), szMenu);

		m_PopupMenu.Enable(EVENT_ID_FLOAT_MODE, !m_FloatAddressStr.IsEmpty());
		m_PopupMenu.Enable(EVENT_ID_NEW_DATA, bAddr);
		m_PopupMenu.Enable(EVENT_ID_SHOW_DATA, bAddr);
		m_PopupMenu.Enable(EVENT_ID_NEW_CODE, bAddr);
		m_PopupMenu.Enable(EVENT_ID_DISASM, bAddr);
		m_PopupMenu.Enable(EVENT_ID_COPYSEL, m_bSelect);
		m_PopupMenu.Enable(EVENT_ID_COPYSEL_SPACE, m_bSelect);
		m_PopupMenu.Enable(EVENT_ID_COPYSEL_CLANG, m_bSelect);
		m_PopupMenu.Enable(EVENT_ID_COPYVAL, bValue);

		m_PopupMenu.Point(0, 1);
	}

	unsigned int CDataView::GetKeyMap(unsigned int CmdID)
	{
		for (map<unsigned int, unsigned int>::IT it = m_KeyMap.begin();
			it != m_KeyMap.end(); ++it)
		{
			if (it->second == CmdID)
				return it->first;
		}
		return 0;
	}

	bool CDataView::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (!pMsg->KeyEvent.bKeyDown) return true;

		map<unsigned int, unsigned int>::IT it = m_KeyMap.find(pMsg->KeyEvent.KeyType);
		if (it != m_KeyMap.end())
		{
			WISP_MSG Msg;
			Msg.Command.CmdID = it->second;
			return OnEvent(&Msg);
		}
		int Size;
		switch (pMsg->KeyEvent.KeyType)
		{
		case VK_LBUTTON:
			OnKeyLButton(pMsg); //Data Range
			break;
		case VK_RBUTTON:
			OnKeyRButton(pMsg); //Menu
			return false;
			break;
		case 0x53: //S
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.GetSize(0, &Size);
			Size += 10;
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.SetSize(0, Size);
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.AdjustWndPos();
			return false;
			break;
		case 0x57: //W
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.GetSize(0, &Size);
			if (Size <= 10)
				Size = 0;
			else	Size -= 10;
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.SetSize(0, Size);
			gpSyser->m_MainFrame.m_SystemExplorer.m_ViewSplitWnd.AdjustWndPos();
			return false;
			break;
		}
		return true;
	}

	bool CDataView::OnEventGotoData(WISP_MSG *pMsg)
	{
		ULONG_PTR Val;
		if (m_RButtonAddress != -1 && gpSyser->m_pDebugger->ReadMemory(m_RButtonAddress, &Val, sizeof(Val)) == sizeof(Val))
			ViewAddress(m_RButtonAddress, true);
		return true;
	}
	bool CDataView::OnEventNewData(WISP_MSG *pMsg)
	{
		static_cast<CMultiDataView*>(m_ParentWnd)->InsertView(this);
		static_cast<CMultiDataView*>(m_ParentWnd)->SetActiveAddress(m_RButtonAddress, 0);
		return true;
	}
	bool CDataView::OnEventGotoDasm(WISP_MSG *pMsg)
	{
		if (m_RButtonAddress != -1)
		{
			CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
			if (pWnd) pWnd->GotoAddr(m_RButtonAddress, true);
		}
		return true;
	}
	bool CDataView::OnEventNewDasm(WISP_MSG *pMsg)
	{
		if (m_RButtonAddress != -1)
		{
			CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.InsertView(0);
			if (pWnd) pWnd->GotoAddr(m_RButtonAddress, true);
		}
		return true;
	}
	bool CDataView::OnEventShowPhysAddr(WISP_MSG *pMsg)
	{
		return true;
	}
	bool CDataView::OnEventDasmPhysAddr(WISP_MSG *pMsg)
	{
		return true;
	}
	bool CDataView::OnEventToggleToolbar(WISP_MSG *pMsg)
	{
		if (m_Toolbar.IsWindowShow())
			m_Toolbar.Show(WISP_SH_HIDDEN);
		else	m_Toolbar.Show(WISP_SH_MINSIZE);
		return true;
	}

	bool CDataView::OnEventAttachType(WISP_MSG *pMsg)
	{
		ULONG_PTR Addr = m_LButtonAddress;
		if (Addr == -1)
			Addr = m_CurAddr;
		m_StructViewerForm.Create(nullptr, 5, Addr); //SHOW_SH_???
		return true;
	}
	bool CDataView::OnEventFindForm(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}

	bool CDataView::OnEventToggleOffsetMode(WISP_MSG *pMsg)
	{
		ToggleHexOffset();
		return true;
	}
	bool CDataView::OnEventToggleAddressMode(WISP_MSG *pMsg)
	{
		SetAddressMode(1-GetAddressMode(), m_CurAddr);
		Update((WISP_RECT*)0);
		return true;
	}

	bool CDataView::OnEventDataWidth(WISP_MSG *pMsg)
	{
		if (m_nByte_Line == 16)
			m_nByte_Line = 32;
		else
		if (m_nByte_Line == 32)
			m_nByte_Line = 16;
		RecalcLayout();
		Update((WISP_RECT*)0);
		return true;
	}

	bool CDataView::OnEventNewView(WISP_MSG *pMsg)
	{
		CWispWnd *pWnd = (CWispWnd *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetWnd(pMsg->Command.CmdID - EVENT_ID_DV0);
		if (pWnd)
		{
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.ChangeActiveWnd(pWnd);
			return true;
		}

		if (!gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.InsertView(
				(CDataView*)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd()))
			return false;
		return true;
	}

	bool CDataView::OnEventOp(WISP_MSG *pMsg)
	{
		ULONG_PTR Start;
		ULONG_PTR End;
		unsigned long Len;
		GetDataRange(&Start, &End, &Len);
		m_OperatorDlg.Create(0, WISP_SH_MODAL_BLOCK, Start, End, Len, pMsg->Command.CmdID);
		return true;
	}

	bool CDataView::OnEventShowDataAt(WISP_MSG *pMsg)
	{
		LONG_PTR Offset = 0;
		ULONG_PTR TargetAddr;
		ULONG_PTR Addr;
		if (CalcPointPos(&m_CaretPos, &Addr, 0))
		{
			if (pMsg && pMsg->Command.CmdID == EVENT_ID_DV_SHOW_DATA_AT_REL)
				 Offset = Addr - m_CurAddr;

			Addr += m_ShowLength - m_CaretIndex % (3 * m_ShowLength)/2 - 1;
			if (ReadMemory(Addr, &TargetAddr, sizeof(TargetAddr)))
			{
				ULONG_PTR Val;
				if (TargetAddr != -1)
				{
					TargetAddr -= Offset;
					if (gpSyser->m_pDebugger->ReadMemory(TargetAddr, &Val, sizeof(Val)) == sizeof(Val))
						ViewAddress(TargetAddr, true);
				}
			}
		}
		return true;
	}

	bool CDataView::OnEventShowDasm(WISP_MSG *pMsg)
	{
		ULONG_PTR TargetAddr;
		ULONG_PTR Addr;
		if (CalcPointPos(&m_CaretPos, &Addr, 0))
		{
			Addr += m_ShowLength - m_CaretIndex % (3 * m_ShowLength)/2 - 1;
			if (ReadMemory(Addr, &TargetAddr, sizeof(TargetAddr)))
			{
				ULONG_PTR Val;
				if (TargetAddr != -1 && gpSyser->m_pDebugger->ReadMemory(TargetAddr, &Val, sizeof(Val)) == sizeof(Val))
				{
					CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
					if (pWnd) pWnd->GotoAddr(TargetAddr, true);
				}
			}
		}
		return true;
	}

	bool CDataView::OnEventCopyVal(WISP_MSG *pMsg)
	{
		TWideString String;
		ULONG_PTR Addr;
		if (CalcPointPos(&m_CaretPos, &Addr, 0))
		{
			Addr += m_ShowLength - m_CaretIndex % (3 * m_ShowLength)/2 - 1;
			ULONG_PTR Value;
			if (ReadMemory(Addr, &Value, sizeof(Value)) && Value != -1)
			{
				WCHAR Buffer[10];
				TSPrintf(Buffer, WSTR("" F0ADDR "X"), Value); //??? LOWER CASE
				String = Buffer;
				m_pWispBase->SetClipboard(String.operator const WCHAR*());
			}
		}
		return true;
	}
	bool CDataView::OnEventCopyAddr(WISP_MSG *pMsg)
	{
		TWideString String;
		ULONG_PTR Addr;
		if (CalcPointPos(&m_CaretPos, &Addr, 0))
		{
			WCHAR Buffer[10];
			TSPrintf(Buffer, WSTR("" F0ADDR "X"), Addr); //??? LOWER CASE
			String = Buffer;
			m_pWispBase->SetClipboard(String.operator const WCHAR*());
		}
		return true;
	}

	bool CDataView::OnEventCopySelect(WISP_MSG *pMsg)
	{
		WCHAR Buffer[256];
		TWideString String;
		bool bSpace = true;

		if (m_bSelect)
		{
			if (pMsg->Command.CmdID == EVENT_ID_COPYSEL_SPACE)
				bSpace = false;

			int Len = m_SelEnd - m_SelStart + 1;

			if (pMsg->Command.CmdID == EVENT_ID_COPYSEL_CLANG)
			{
				//String += WSTR("// Generated by Syser software's Syser Debugger v");
				//TStrCpy(Buffer, "1.99.1900.1220");
				//String += Buffer;
				//String += WSTR("\r\n//   http://www.sysersoft.com\r\n");

				String += WSTR("// Generated by Syser Debugger");
				String += WSTR("\r\n//   http://exelab.ru/f/\r\n");

				TSPrintf(Buffer, WSTR("unsigned char rawData[%d] =\r\n{"), Len);
				String += Buffer;
				for (int i = 0; i < Len; ++i)
				{
					if (!(i&0xf)) //%
						String += WSTR("\r\n\t");
					unsigned char Byte;
					if (gpSyser->m_pDebugger->ReadMemory(m_SelStart+i, &Byte, 1) != 1)
						break;
					if (i == Len-1)
						TSPrintf(Buffer, WSTR("0x%02X"), Byte);
					else	TSPrintf(Buffer, WSTR("0x%02X, "), Byte);
					String += Buffer;
				}
				String += WSTR("\r\n};\n");
				
			} else
			{
				for (int i = 0; i < Len/m_ShowLength; ++i)
				{
					ULONG_PTR Data;
					if (gpSyser->m_pDebugger->ReadMemory(m_SelStart + i * m_ShowLength, &Data, m_ShowLength) != m_ShowLength)
						break;
					switch (m_ShowLength)
					{
					case 1: TSPrintf(Buffer, WSTR("%02x"), Data&0xFF); break;
					case 2: TSPrintf(Buffer, WSTR("%04x"), Data&0xFFFF); break;
					case 4: TSPrintf(Buffer, WSTR("%08x"), Data&0xFFFFFFFF); break;
				#ifdef _X64_
					case 8: TSPrintf(Buffer, WSTR("%016I64x"), Data&0xFFFFFFFFFFFFFFFF); break;
				#endif
					}
					String += Buffer;
					if (bSpace && i != Len-1)
						String += WSTR(" ");
				}
			}
			m_pWispBase->SetClipboard(String.operator const WCHAR*());
		}

		return true;
	}

	bool CDataView::OnEventToggleFloatAddressMode(WISP_MSG *pMsg)
	{
		ToggleFloatAddressMode();
		return true;
	}

	bool CDataView::OnEventNextHistory(WISP_MSG *pMsg)
	{
		NextPos(); //???
		return true;
	}
	bool CDataView::OnEventPrevHistory(WISP_MSG *pMsg)
	{
		PrevPos(); //???
		return true;
	}

	unsigned long CDataView::WriteMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
			return gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size);
		return 0;
	}

	unsigned long CDataView::ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
			return gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size);
		return 0;
	}

	unsigned int CDataView::GetHexByteAttribute(ULONG_PTR Address)
	{
		unsigned int HexByte = CWispHexWnd::GetHexByteAttribute(Address);
		if (gpSyser->m_pDebugger)
		{
			if (gpSyser->m_pDebugger->GetCodeBP(Address, 0, 0)) return HEX_BYTE_BPX;
			if (gpSyser->m_pDebugger->GetDataBP1(Address, 0, 0)) return HEX_BYTE_BPX;
		}
		return HexByte;
	}

	ULONG_PTR CDataView::GetFloatAddress(const TWideString & FloatAddress)
	{
		ULONG_PTR Result;
		if (!FloatAddress.IsEmpty() &&
			gpSyser->m_SyserUI.CalcExp(FloatAddress.operator const WCHAR*(), &Result))
			return Result;
		return m_CurAddr;
	}


	void CDataView::OnChangeView()
	{
		int Index = 0;
		TListIter<WISP_TAB_WND_ITEM> It = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.m_WndList.Begin();
		while (It != gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.m_WndList.End())
		{
			if (It->pWnd == this)
			{
				WCHAR Buffer[64];
				TSPrintf(Buffer, WSTR("" F0ADDR "X"), m_CurAddr);
				gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetTabText(Index, Buffer);
			}
			++It;
			++Index;
		}
	}
	void CDataView::OnDataUpdated()
	{
		gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
	}
	int CDataView::GetStartLine()
	{
		int nStartLine = 0;
		if (m_Toolbar.IsWindowShow())
			nStartLine += 2;
		if (m_bShowOffset)
			nStartLine += 1;
		return nStartLine;
	}

	void CDataView::LoadKeyMap()
	{
		if (!gpSyser->GetHotKey(EVENT_ID_DV0, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000031, EVENT_ID_DV0)); //WISP_SK_ALT 1
		if (!gpSyser->GetHotKey(EVENT_ID_DV1, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000032, EVENT_ID_DV1)); //WISP_SK_ALT 2
		if (!gpSyser->GetHotKey(EVENT_ID_DV2, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000033, EVENT_ID_DV2)); //WISP_SK_ALT 3
		if (!gpSyser->GetHotKey(EVENT_ID_DV3, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000034, EVENT_ID_DV3)); //WISP_SK_ALT 4
		if (!gpSyser->GetHotKey(EVENT_ID_DV4, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000035, EVENT_ID_DV4)); //WISP_SK_ALT 5
		if (!gpSyser->GetHotKey(EVENT_ID_DV5, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000036, EVENT_ID_DV5)); //WISP_SK_ALT 6
		if (!gpSyser->GetHotKey(EVENT_ID_DV6, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000037, EVENT_ID_DV6)); //WISP_SK_ALT 7
		if (!gpSyser->GetHotKey(EVENT_ID_DV7, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000038, EVENT_ID_DV7)); //WISP_SK_ALT 8
		if (!gpSyser->GetHotKey(EVENT_ID_DV8, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000039, EVENT_ID_DV8)); //WISP_SK_ALT 9

		if (!gpSyser->GetHotKey(EVENT_ID_DV_SHOW_DATA_AT, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0xD       , EVENT_ID_DV_SHOW_DATA_AT)); //VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_DV_SHOW_DATA_AT_REL, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x6000000D, EVENT_ID_DV_SHOW_DATA_AT_REL)); //WISP_SK_CTRL WISP_SK_ALT VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_CV_OPEN, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x1000000D, EVENT_ID_CV_OPEN)); //WISP_SK_SHIFT VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_COPYVAL, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x4000000D, EVENT_ID_COPYVAL)); //WISP_SK_CTRL VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_COPYADDR, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x2000000D, EVENT_ID_COPYADDR)); //WISP_SK_ALT VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_COPYSEL, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x40000058, EVENT_ID_COPYSEL)); //WISP_SK_CTRL X
		if (!gpSyser->GetHotKey(EVENT_ID_COPYSEL_SPACE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000058, EVENT_ID_COPYSEL_SPACE)); //WISP_SK_SHIFT X
		if (!gpSyser->GetHotKey(EVENT_ID_DV_ADDR_MODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x4000004F, EVENT_ID_DV_ADDR_MODE)); //WISP_SK_CTRL O
		if (!gpSyser->GetHotKey(EVENT_ID_COPYSEL_CLANG, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x4000005A, EVENT_ID_COPYSEL_CLANG)); //WISP_SK_CTRL Z
		if (!gpSyser->GetHotKey(EVENT_ID_HISTORY_NEXT, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0xBB      , EVENT_ID_HISTORY_NEXT)); //VK_OEM_PLUS
		if (!gpSyser->GetHotKey(EVENT_ID_HISTORY_PREV, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0xBD      , EVENT_ID_HISTORY_PREV)); //VK_OEM_MINUS
		if (!gpSyser->GetHotKey(EVENT_ID_FLOAT_MODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x4000004D, EVENT_ID_FLOAT_MODE)); //WISP_SK_CTRL M
		if (!gpSyser->GetHotKey(EVENT_ID_SHOW_OFFSET, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x40000053, EVENT_ID_SHOW_OFFSET)); //WISP_SK_CTRL S
		if (!gpSyser->GetHotKey(EVENT_ID_SHOW_OP, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x40000054, EVENT_ID_SHOW_OP)); //WISP_SK_CTRL T
	}

	bool CDataView::GetDataRange(ULONG_PTR *Start, ULONG_PTR *End, unsigned long *Len)
	{
		if (m_bSelect)
		{
			*Start = m_SelStart;
			*End = m_SelEnd;
			if (m_SelStart == m_SelEnd)
			{
				++*End;
				*Len = m_ShowLength;
			}
		} else
		{
			*Start = m_LButtonAddress;
			if (*Start == -1)
				*Start = m_CurAddr;
			*End = *Start + m_ShowLength;
		}
		*Len = m_ShowLength;
		return true;
	}

```

`source/WispSyser/dataview.hpp`:

```hpp

#ifndef _DATAVIEW_HPP_
#define _DATAVIEW_HPP_

#include "../Wisp/wisphexwnd.hpp"
#include "../Wisp/wispmenu.hpp"
#include "../Wisp/wisptoolbar.hpp"
#include "dataoperatordlg.hpp"
#include "typeviewerform.hpp"

struct CDataView : public CWispHexWnd
{
	ULONG_PTR m_RButtonAddress;
	ULONG_PTR m_LButtonAddress;
	unsigned long XXX;
	CWispMenu m_PopupMenu;
	CWispToolbar m_Toolbar;
	CDataOperatorDlg m_OperatorDlg;
	CStructViewerForm m_StructViewerForm;
	//CFindStringForm m_FindStringForm;
	map<unsigned int, unsigned int> m_KeyMap;

	CDataView();
	virtual ~CDataView();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	void OnKeyLButton(WISP_MSG *pMsg);
	void OnKeyRButton(WISP_MSG *pMsg);
	unsigned int GetKeyMap(unsigned int CmdID);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool OnEventGotoData(WISP_MSG *pMsg);
	bool OnEventNewData(WISP_MSG *pMsg);
	bool OnEventGotoDasm(WISP_MSG *pMsg);
	bool OnEventNewDasm(WISP_MSG *pMsg);
	bool OnEventDasmPhysAddr(WISP_MSG *pMsg);
	bool OnEventShowPhysAddr(WISP_MSG *pMsg);
	bool OnEventToggleToolbar(WISP_MSG *pMsg);
	bool OnEventAttachType(WISP_MSG *pMsg);
	bool OnEventFindForm(WISP_MSG *pMsg);
	bool OnEventToggleOffsetMode(WISP_MSG *pMsg);
	bool OnEventToggleAddressMode(WISP_MSG *pMsg);
	bool OnEventDataWidth(WISP_MSG *pMsg);

	bool OnEventNewView(WISP_MSG *pMsg);

	bool OnEventOp(WISP_MSG *pMsg);

	bool OnEventShowDataAt(WISP_MSG *pMsg);

	bool OnEventShowDasm(WISP_MSG *pMsg);

	bool OnEventCopyVal(WISP_MSG *pMsg);
	bool OnEventCopyAddr(WISP_MSG *pMsg);

	bool OnEventCopySelect(WISP_MSG *pMsg);

	bool OnEventToggleFloatAddressMode(WISP_MSG *pMsg);

	bool OnEventNextHistory(WISP_MSG *pMsg);
	bool OnEventPrevHistory(WISP_MSG *pMsg);

	virtual unsigned long WriteMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) override;
	virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) override;

	virtual unsigned int GetHexByteAttribute(ULONG_PTR Address) override;

	virtual ULONG_PTR GetFloatAddress(const TWideString & FloatAddress) override;

	virtual void OnChangeView() override;
	virtual void OnDataUpdated() override;
	virtual int GetStartLine() override;

	bool GetDataRange(ULONG_PTR *Start, ULONG_PTR *End, unsigned long *Len);
	void LoadKeyMap();
};

#endif
```

`source/WispSyser/dataviewform.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "dataviewform.hpp"

WISP_FORM_RES_ITEM DataViewForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 500, 300}, 0, 0xAB, WSTR("Data View"), 0, 0},
	{WISP_CTRL_STATIC_GROUP, {10, 10, 470, 40}, 2, 0, WSTR("Address"), 0, 0},
	{WISP_CTRL_EDIT, {20, 25, 400, 16}, 1, 0x1000006, 0, 0, 0},
	{WISP_CTRL_BUTTON, {430, 25, 40, 16}, 4, 0, WSTR("Goto"), 0, 0},
	{0},
};

	WISP_MSG_MAP_BEGIN(CDataViewForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

        WISP_CMD_MAP_BEGIN(CDataViewForm)
		WISP_CMD_MAP(1, OnCmdEdit)
        WISP_CMD_MAP_END

        WISP_EVENT_MAP_BEGIN(CDataViewForm)
		WISP_EVENT_MAP(4, OnEventGoto)
        WISP_EVENT_MAP_END

	CDataViewForm::CDataViewForm()
	{
		m_Resource = DataViewForm;
	}

	CDataViewForm::~CDataViewForm()
	{
	}

	bool CDataViewForm::OnCreateForm(WISP_MSG *pMsg)
	{
		if (m_Style & 1)
		{
			AttachTitleDIB(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x59));
		}
		m_pAddressName = (CWispEdit *)GetFormItem(1);
		m_pAddress = (CWispStaticGroup *)GetFormItem(2);
		m_pGoto = (CWispButton *)GetFormItem(4);
		m_DataView.CreateWnd(0,10,
				m_pAddressName->m_ScrWindowRect.x - m_ScrWindowRect.x + 30,
				m_pAddress->m_WindowRect.cx,
				m_ClientRect.cy - (m_pAddressName->m_ScrWindowRect.x - m_ScrWindowRect.x + 30) - 10, this, 3, 0, WISP_SH_MINSIZE);
		OnSize(0);
		return true;
	}
	bool CDataViewForm::OnClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}
	bool CDataViewForm::OnSize(WISP_MSG *pMsg)
	{
		m_pAddress->Resize(m_ClientRect.cx - 20, m_pAddress->m_WindowRect.cy, 1);
		m_pAddressName->Resize(m_pAddress->m_WindowRect.cx - m_pGoto->m_WindowRect.cx - 30,
					m_pAddressName->m_WindowRect.cy, 1);
		m_pGoto->MoveToWindow(m_pAddress->m_ScrWindowRect.x + m_pAddress->m_WindowRect.cx - m_ScrWindowRect.x - 50,
					m_pGoto->m_ScrWindowRect.y - m_ScrWindowRect.y, 1);
		m_DataView.Resize(m_pAddress->m_WindowRect.cx,
					m_ClientRect.cy - m_pAddressName->m_ScrWindowRect.x + m_ScrWindowRect.x - 40, 1);
		return true;
	}

	bool CDataViewForm::OnCmdEdit(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000703 && //WISP_ID_EDIT_KEYDOWN
		    pMsg->Command.Param1 == 13)
			UpdateContext();
		return true;
	}

	bool CDataViewForm::OnEventGoto(WISP_MSG *pMsg)
	{
		UpdateContext();
		return false;
	}
	void CDataViewForm::UpdateContext()
	{
		if (IsWindowShow())
		{
			ULONG_PTR Result;
			if (gpSyser->m_SyserUI.CalcExp(m_pAddressName->GetWindowText().operator const WCHAR*(), &Result))
			{
				SetWindowText(m_pAddressName->GetWindowText().operator const WCHAR*());
				m_DataView.ViewAddress(Result, true);
			}
		}
	}
	void CDataViewForm::Create()
	{
		if (IsWindow())
		{
			Destroy();
		} else
		{
			CWispForm::Create(0, WISP_SH_MINSIZE);
			Center(0);
		}
	}

```

`source/WispSyser/dataviewform.hpp`:

```hpp

#ifndef _DATAVIEWFORM_HPP_
#define _DATAVIEWFORM_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wispedit.hpp"
#include "../Wisp/wispstatic.hpp"
#include "../Wisp/wispbutton.hpp"
#include "dataview.hpp"

struct CDataViewForm : public CWispForm
{
	CDataView m_DataView;
	CWispEdit *m_pAddressName;
	CWispButton *m_pGoto;
	CWispStaticGroup *m_pAddress;

	CDataViewForm();
	virtual ~CDataViewForm();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);
	bool OnClose(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdEdit(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventGoto(WISP_MSG *pMsg);
	void UpdateContext();
	void Create();
};

#endif
```

`source/WispSyser/debuggerselectform.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "../Code/sysdep.hpp"
#include "debuggerselectform.hpp"

WISP_FORM_RES_ITEM DebuggerSelectForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 400, 200}, 0, 0xB, WSTR("Debugger Select ..."), (void*)("\\SyserIcon\\Syser.ico"), WSTR("Select Debugger Plugin Module!")},
	{WISP_CTRL_LIST, {5, 5, 300, 160}, 1, 0x40010006, 0, 0, 0},
	{WISP_CTRL_STATIC_DIB, {315, 20, 64, 64}, 0, 0, 0, (void*)("\\SyserIcon\\Syser.ico"), 0},
	{WISP_CTRL_BUTTON, {312, 100, 70, 20}, 2, 0, WSTR("Plugin"), 0, WSTR("Plug Debugger into Syser")},
	{WISP_CTRL_BUTTON, {312, 140, 70, 20}, 3, 0, WSTR("Refresh"), 0, WSTR("Refresh Debugger Module list")},
	{0},
};

	CDebuggerSelectForm::CDebuggerSelectForm()
	{
		m_Resource = DebuggerSelectForm;
	}
	CDebuggerSelectForm::~CDebuggerSelectForm()
	{
	}

	WISP_MSG_MAP_BEGIN(CDebuggerSelectForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

	bool CDebuggerSelectForm::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pList = (CWispList *)GetFormItem(1);
		m_pList->InsertColumn(WSTR("Module Name"), 95, 0, 0, -1);
		m_pList->InsertColumn(WSTR("Information"), 200, 0, 0, -1);
		OnEventModuleList(0);
		return true;
	}

	WISP_EVENT_MAP_BEGIN(CDebuggerSelectForm)
		WISP_EVENT_MAP(0x2, OnEventPlug)
		WISP_EVENT_MAP(0x3, OnEventModuleList)
	WISP_EVENT_MAP_END

	bool CDebuggerSelectForm::OnEventPlug(WISP_MSG *pMsg)
	{
		CListStringItem *pItem = m_pList->GetNext(0, 8);
		if (pItem)
		{
			if (!gpSyser->LoadDebugger(m_pList->GetItemContent(pItem, 0)->String.operator const WCHAR*()))
			{
				gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();
			}
			Destroy();
		}
		return true;
	}

	bool CDebuggerSelectForm::OnEventModuleList(WISP_MSG *pMsg)
	{
		typedef void *(*FPCreateDebugger)(CSyserUI *pSyserUI);
		typedef void (*FPGetFileFilter)(WCHAR *Filter);
		typedef void (*FPGetInfo)(char *pInfo);

		m_pList->DeleteAllChildrenItems(0);

		char szModule[MAX_FN_LEN];
		char szModulePath[MAX_FN_LEN];
		GetModulePath(szModulePath, true);
		TStrCpy(szModule, szModulePath);
		TStrCat(szModule, "*.dll");
		FILE_FIND_DATA FindData;
		if (gpFileIO->FindFirstFile(szModule, &FindData))
		{
			do {
				TStrCpy(szModule, szModulePath);
				TStrCat(szModule, FindData.FileName);
				HMODULE hLib = LoadLibraryA(szModule);
				if (hLib)
				{
					FPCreateDebugger fCreateDebugger;
					FPGetFileFilter fGetFileFilter;
					FPGetInfo fGetInfo;

					(FARPROC&)fGetInfo = GetProcAddress(hLib, "GetInfo");
					(FARPROC&)fCreateDebugger = GetProcAddress(hLib, "CreateDebugger");
					if (fGetInfo && fCreateDebugger)
					{
						WCHAR szFileName[64];
						AnsiToUnicode(FindData.FileName, szFileName, lenof(szFileName));
						CListStringItem *pItem = m_pList->InsertItem(szFileName, 0, 0, 0, -1);
						char szInfo[128];
						WCHAR uInfo[128];
						fGetInfo(szInfo);
						AnsiToUnicode(szInfo, uInfo, lenof(uInfo));
						m_pList->SetItemText(pItem, 1, uInfo);
						if (gpSyser->m_hDebuggerModule == hLib)
							m_pList->SetItemColor(pItem, -1, m_pWispBase->m_pWispDrawObj->m_crSystem[3]);
					}
					FreeLibrary(hLib);
				}
			} while (gpFileIO->FindNextFile(&FindData));
		}
		gpFileIO->FindClose(&FindData);
		return true;
	}

	void CDebuggerSelectForm::Create()
	{
		if (IsWindow())
			Show(WISP_SH_MINSIZE);
		else	CWispForm::Create(0, WISP_SH_MINSIZE);
	}

```

`source/WispSyser/debuggerselectform.hpp`:

```hpp

#ifndef _DEBUGGERSELECTFORM_HPP_
#define _DEBUGGERSELECTFORM_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wisplist.hpp"

struct CDebuggerSelectForm : public CWispForm
{
	CWispList *m_pList;

	CDebuggerSelectForm();
	virtual ~CDebuggerSelectForm();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreateForm(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool OnEventPlug(WISP_MSG *pMsg);
	bool OnEventModuleList(WISP_MSG *pMsg);
	void Create();
};

#endif
```

`source/WispSyser/findlistwnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "findlistwnd.hpp"
#include "syserconfig.hpp"
#include "resource.hpp"

	WISP_MSG_MAP_BEGIN(CStatusWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
	WISP_MSG_MAP_END(CWispWnd)

	CStatusWnd::CStatusWnd()
	{
	}
	CStatusWnd::~CStatusWnd()
	{
	}

	bool CStatusWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_BorderSize = 2;
		m_StatusStr.Empty();
		return true;
	}
	bool CStatusWnd::OnUpdateClient(WISP_MSG *pMsg)
	{
		CWispWnd::OnUpdateClient(pMsg);
		m_ClientDC.DrawString(4, 2, m_StatusStr.operator const WCHAR*(), -1, 0, 0);
		return false;
	}


	WISP_MSG_MAP_BEGIN(CFindListWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP_ON_COMMAND
	WISP_MSG_MAP_END(CWispWnd)

	WISP_CMD_MAP_BEGIN(CFindListWnd)
		WISP_CMD_MAP(EVENT_ID_STRFIND, OnCmdStrFind)
	WISP_CMD_MAP_END

	CFindListWnd::CFindListWnd()
	{
	}
	CFindListWnd::~CFindListWnd()
	{
	}

	bool CFindListWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_ShowFormat = 1; //???
		m_StringReferenceList.CreateWnd(WSTR("String Reference"), 0,0,556,300, this, EVENT_ID_STRFIND, 0x40030000, WISP_SH_MINSIZE);
		m_StringReferenceList.m_ShowFormat = m_ShowFormat;

		gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.clear();

		int Ext = m_ClientDC.GetTextExtent(WSTR("X"), -1, 0);
		if (m_ShowFormat)
		{
			m_StringReferenceList.InsertColumn(WSTR("Address"), (3+ADDR_SIZE)*Ext+3, 0, 0, -1); //60
			m_StringReferenceList.InsertColumn(WSTR("Type"), 32, 0, 0, -1);
			m_StringReferenceList.InsertColumn(WSTR("Disassembly"), 200, 0, 0, -1);
			m_StringReferenceList.InsertColumn(WSTR("Text String"), 280, 0, 0, -1);
		} else
		{
			m_StringReferenceList.InsertColumn(WSTR("Address"), (3+ADDR_SIZE)*Ext+3, 0, 0, -1); //80
			m_StringReferenceList.InsertColumn(WSTR("Text String/Disassembly"), 200, 0, 0, -1);
		}

		m_StringReferenceList.m_ColorFocus = gSyserColors.Color[2];
		m_StringReferenceList.m_ItemColor = gSyserColors.Color[1];
		m_StringReferenceList.SetBGColor(gSyserColors.Color[0]);

		m_StatusWnd.CreateWnd(0, 0,300,564,20, this, 0, 6, WISP_SH_MINSIZE);
		m_StatusWnd.SetBGColor(gSyserColors.Color[0]);
		m_StatusWnd.m_ClientDC.SetTextColor(gSyserColors.Color[1]);

		m_StringReferenceList.InitContext(0, 0);
		return true;
	}
	bool CFindListWnd::OnCmdStrFind(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0)
		{
			m_StatusWnd.m_StatusStr = m_StringReferenceList.m_SearchString;
			if (pMsg->Command.Param1 == 0 && m_StatusWnd.m_StatusStr.m_nLength)
				m_StatusWnd.m_StatusStr += WSTR(": not found");
			m_StatusWnd.Update((WISP_RECT*)0);
		}
		return true;
	}
	bool CFindListWnd::OnSize(WISP_MSG *pMsg)
	{
		m_StringReferenceList.Resize(m_ClientRect.cx, m_ClientRect.cy - 20, 1);
		m_StatusWnd.Resize(m_ClientRect.cx, 20, 1);

		m_StringReferenceList.MoveToWindow(m_ClientRect.x, m_ClientRect.y, 1);
		m_StatusWnd.MoveToWindow(m_ClientRect.x, m_ClientRect.y + m_ClientRect.cy - 20, 1);
		return true;
	}

```

`source/WispSyser/findlistwnd.hpp`:

```hpp

#ifndef _FINDLISTWND_HPP_
#define _FINDLISTWND_HPP_

#include "../Wisp/wispwnd.hpp"
#include "findstringform.hpp"

struct CStatusWnd : public CWispWnd
{
	TWideString m_StatusStr;

	CStatusWnd();
	virtual ~CStatusWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);
};

struct CFindListWnd : public CWispWnd
{
	CStatusWnd m_StatusWnd;
	CStringReferenceList m_StringReferenceList;
	unsigned long m_ShowFormat;

	CFindListWnd();
	virtual ~CFindListWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdStrFind(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);
};

#endif
```

`source/WispSyser/findstringform.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "findstringform.hpp"
#include "syserconfig.hpp"
#include "resource.hpp"

WISP_FORM_RES_ITEM FindStringForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 320, 120}, 0, 0xB, WSTR("Find"), (void*)"\\SyserIcon\\Plugin.ico", WSTR("Find")},
	{WISP_CTRL_STATIC_STRING, {10, 18, 70, 20}, 0, 0, WSTR("Find what:  "), 0, 0},
	{WISP_CTRL_EDIT, {80, 15, 220, 20}, 3, 0x1000006, 0, 0, 0},
	{WISP_CTRL_BUTTON, {54, 50, 78, 21}, 1, 0x200, WSTR("Find Next"), 0, 0},
	{WISP_CTRL_BUTTON, {186, 50, 78, 21}, 0x80002002, 0, WSTR("Close"), 0, 0},
	{0},
};

	WISP_MSG_MAP_BEGIN(CFindStringForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

	WISP_CMD_MAP_BEGIN(CFindStringForm)
		WISP_CMD_MAP(3, OnCmdFindWhat)
	WISP_CMD_MAP_END

	WISP_EVENT_MAP_BEGIN(CFindStringForm)
		WISP_EVENT_MAP(1, OnEvent1)
	WISP_EVENT_MAP_END

	CFindStringForm::CFindStringForm()
	{
		m_Resource = FindStringForm;
	}
	CFindStringForm::~CFindStringForm()
	{
	}
	
	bool CFindStringForm::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pFindNext = (CWispButton *)GetFormItem(1);
		m_pClose = (CWispButton *)GetFormItem(2);
		m_pFindWhat = (CWispEdit *)GetFormItem(3); 		
		return true;
	}

	bool CFindStringForm::OnCmdFindWhat(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000703) //WISP_ID_EDIT_KEYDOWN
		{
			if (pMsg->Command.Param1 != 13) return true;
			m_pFindNext->Focus();
			return OnEvent1(0);
		}

		if (pMsg->Command.CmdMsg == 0x80000704) //WISP_ID_EDIT_KEYUP
		{
			if (pMsg->Command.Param1 != 13) return true;
			return false;
		}

		if (pMsg->Command.CmdMsg == 0x80000705) //WISP_ID_EDIT_CHANGED
		{
			m_pFindNext->EnableWindow(m_pFindWhat->GetWindowText().IsEmpty()==0);
			m_pFindNext->Update((WISP_RECT*)0);
		}

		return true;
	}

	bool CFindStringForm::OnEvent1(WISP_MSG *pMsg)
	{
		const TWideString &String = m_pFindWhat->GetWindowText();

		if (m_pStringReferenceList)
		{
			if (m_pStringReferenceList->m_SearchString == String)
			{
				m_pStringReferenceList->OnEventSearchAgain(0);
			} else
			{
				m_pStringReferenceList->Search(String.operator const WCHAR*());
			}
		}
		return true;
	}


	WISP_MSG_MAP_BEGIN(CStringReferenceList)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_CHAR, OnChar)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	WISP_CMD_MAP_BEGIN(CStringReferenceList)
	WISP_CMD_MAP_END

	WISP_EVENT_MAP_BEGIN(CStringReferenceList)
		WISP_EVENT_MAP(EVENT_ID_SEARCH, OnEventSearch)
		WISP_EVENT_MAP(EVENT_ID_SEARCH_AGAIN, OnEventSearchAgain)
	WISP_EVENT_MAP_END

	CStringReferenceList::CStringReferenceList()
	{
		m_nSearchLen = 0;
	}
	CStringReferenceList::~CStringReferenceList()
	{
	}

	void CStringReferenceList::LoadKeyMap()
	{
		if (!gpSyser->GetHotKey(EVENT_ID_SEARCH_AGAIN, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x2000004E, EVENT_ID_SEARCH_AGAIN));
		if (!gpSyser->GetHotKey(EVENT_ID_SEARCH, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x4000004E, EVENT_ID_SEARCH));
	}

WISP_MENU_GROUP_ITEM StringReferenceListPopupMenu[] =
	{
		{WSTR("Search          Ctrl+N"), EVENT_ID_SEARCH, 0x77, 0, 0},
		{WSTR("Search again    Alt+N"), EVENT_ID_SEARCH_AGAIN, 0x77, 0, 0},
		{0},
	};

	bool CStringReferenceList::OnCreate(WISP_MSG *pMsg)
	{
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		m_SearchString.Empty();
		LoadKeyMap();
		CWispDIBList *pDIBList = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF);
		m_PopupMenu.LoadPopupMenuGroup(StringReferenceListPopupMenu, this, pDIBList);

		m_SearchAgainMenuItem = m_PopupMenu.GetItem(EVENT_ID_SEARCH_AGAIN);
		return true;
	}
	bool CStringReferenceList::OnDestroy(WISP_MSG *pMsg)
	{
		m_PopupMenu.Destroy();
		return true;
	}

	bool CStringReferenceList::OnMouseDblClick(WISP_MSG *pMsg)
	{
		CListStringItem *pItem = GetNext(0, 8);
		WISP_RECT Rect;
		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		int nCol = (m_ShowFormat != 0)*2 + 1;
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON && pItem)
		{
			GetItemRect(pItem, nCol, &Rect);
			int X = pMsg->MsgMouseWndPT.x;
			if (X >= Rect.x && X <= Rect.x + Rect.cx)
			{
				ULONG_PTR Addr = GetItemValue(pItem, 1);
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
			} else
			{
				ULONG_PTR Addr = GetItemValue(pItem, 0);
				gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(Addr, true);
			}
		}
		return true;
	}

	void CStringReferenceList::PopupMenu()
	{
		CListStringItem *pRootItem = GetNext(0, 8);
		m_PopupMenu.Enable(m_SearchAgainMenuItem, !m_SearchString.IsEmpty());
		m_PopupMenu.Point(nullptr, true);
	}

	bool CStringReferenceList::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (!pMsg->KeyEvent.bKeyDown) return true;

		map<unsigned int, unsigned int>::IT it = m_KeyMap.find(pMsg->KeyEvent.KeyType);
		if (it != m_KeyMap.end())
		{
		        WISP_MSG Msg;
		        Msg.Command.CmdID = it->second;
		        return OnEvent(&Msg);
		}

		if (pMsg->KeyEvent.KeyType == VK_RBUTTON)
			PopupMenu();

		return true;
	}
	bool CStringReferenceList::OnChar(WISP_MSG *pMsg)
	{
		int Len = m_SearchString.m_nLength;
		if (pMsg->Char.Char == 8 || Len > m_nSearchLen)
		{
			if (Len)
				m_SearchString.Delete(Len - 1, 1);
			if (pMsg->Char.Char != 8)
				m_SearchString += pMsg->Char.Char;
		} else
		{
			m_SearchString += pMsg->Char.Char;
		}
		if (pMsg->Char.Char == 8)
			SendCommand(0, 1, 0);
		else	Search(nullptr);
		return true;
	}

	bool CStringReferenceList::OnEventSearch(WISP_MSG *pMsg)
	{
		m_FindStringForm.Create(0, 1);
		m_FindStringForm.m_pStringReferenceList = this;
		return true;
	}
	bool CStringReferenceList::OnEventSearchAgain(WISP_MSG *pMsg)
	{
		CListStringItem *pRootItem = GetNext(0, 8);
		if (m_SearchString.m_nLength)
		{
			if (!pRootItem)
				pRootItem = FullFindItem(0, 0);
			int Len = m_SearchString.m_nLength + 5;
			if (Len > 255) Len = 255;
			int nCol = (m_ShowFormat != 0)*2 + 1;
			if (pRootItem)
			{
				CListStringItem *pItem = FullFindItem(pRootItem, 0);
				if (pItem)
				{
					WCHAR Text[256];
					do {
						GetItemText(pItem, nCol, Text, Len);
						
						if (!TStrNICmp((Text[0]!='L')?&Text[1]:((Text[1]!='"')?&Text[1]:&Text[2]), m_SearchString.operator const WCHAR*(), m_SearchString.m_nLength)) break;
						pItem = FullFindItem(pItem, 0);
					} while (pItem);

					if (pItem)
					{
						Select(pItem);
						Scroll(pItem, -1);
					}
				}
			}
		}
		return true;
	}

	struct FindStringSection
	{
		bool FindSection(ULONG_PTR VirtualAddress, unsigned long VirtualSize, ULONG_PTR Address, unsigned long Size)
		{
			char Buffer[256];
			char ABuffer[512];
			WCHAR szAsm[256];
			CInstrSym InstrSym;
			unsigned char CodeBuff[16];
			CodeBuff[0] = 0;
			_INSTRUCTION_INFORMATION InstrInfo;
			char pasm[256];
			InstrInfo.CodeBuff = CodeBuff;
		#ifdef _X64_
			InstrInfo.CodeMode = CODE_MODE_64;
		#else
			InstrInfo.CodeMode = CODE_MODE_32;
		#endif
			InstrInfo.pasm = pasm;

		gpSyser->m_MainFrame.CreateProgress(WSTR(""), VirtualSize);
		unsigned long Progress = VirtualSize/100;

			unsigned long Result;
			for (unsigned long pos = 0; pos < VirtualSize; pos += Result)
			{
				ULONG_PTR EIP = VirtualAddress + pos;
				Result = gpSyser->m_pDebugger->ReadMemory(EIP, CodeBuff, 16);
				if (Result == 0)
				{
					VirtualAddress = (EIP & ~(((ULONG_PTR)4096)-1)) + 4096;
					Result = 4096 - (VirtualAddress + pos) % (4096-1);
					continue;
				}

				InstrInfo.eip = EIP;
				unsigned long CodeLen = InstrSym.Disassembler(&InstrInfo, NULL);
				if (CodeLen == 0)
				{
					++Result;
					continue;
				}
				Result = CodeLen;

				unsigned long RLen;
				if (!TStrICmp(InstrInfo.Name, "mov"))
				{
					if (InstrInfo.op[1].mode == OP_Address &&
					    InstrInfo.op[1].opersize == sizeof(ULONG_PTR) && //???
					    InstrInfo.op[1].addr.displacement > Address &&
					    InstrInfo.op[1].addr.displacement < (Address + Size) &&
					    gpSyser->m_pDebugger->ReadMemory(InstrInfo.op[1].addr.displacement, Buffer, 256) == 256 &&
					    ANormalize(Buffer, 256, ABuffer, 256*2, &RLen))
					{
						if (RLen == 2)
						{
							if (UNormalize(Buffer, 256, ABuffer, 256*2, &RLen))
							{
								TStrCpy(szAsm, InstrInfo.pasm);
								gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[1].addr.displacement, 0x80000000|RLen/2)));
								TStrCpy(szAsm, ABuffer);
								AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
							}
						} else
						{
							TStrCpy(szAsm, InstrInfo.pasm);
							gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[1].addr.displacement, RLen)));
							TStrCpy(szAsm, ABuffer);
							AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
						}

					} else
					if (InstrInfo.op[1].mode == OP_Immed &&
					    InstrInfo.op[1].opersize == sizeof(ULONG_PTR) && //???
					    InstrInfo.op[1].immed.immed_value > Address &&
					    InstrInfo.op[1].immed.immed_value < (Address + Size) &&
					    gpSyser->m_pDebugger->ReadMemory(InstrInfo.op[1].immed.immed_value, Buffer, 256) == 256 &&
					    ANormalize(Buffer, 256, ABuffer, 256*2, &RLen))
					{
						if (RLen == 2)
						{
							if (UNormalize(Buffer, 256, ABuffer, 256*2, &RLen))
							{
								TStrCpy(szAsm, InstrInfo.pasm);
								gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[1].immed.immed_value, 0x80000000|RLen/2)));
								TStrCpy(szAsm, ABuffer);
								AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
							}
						} else
						{
							TStrCpy(szAsm, InstrInfo.pasm);
							gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[1].immed.immed_value, RLen)));
							TStrCpy(szAsm, ABuffer);
							AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
						}
					}
				} else
				if (!TStrICmp(InstrInfo.Name, "lea"))
				{
					//first X64 only
					if (InstrInfo.op[1].mode == OP_Address &&
					    InstrInfo.SegmentPrefix == -1 &&
					    InstrInfo.op[1].addr.base == -1 &&
					    InstrInfo.op[1].addr.index == -1 &&
					    InstrInfo.op[1].addr.displacement_size == sizeof(ULONG_PTR) &&
					    InstrInfo.op[1].addr.displacement > Address &&
					    InstrInfo.op[1].addr.displacement < (Address + Size) &&
					    gpSyser->m_pDebugger->ReadMemory(InstrInfo.op[1].addr.displacement, Buffer, 256) == 256 &&
					    ANormalize(Buffer, 256, ABuffer, 256*2, &RLen))
					{
						if (RLen == 2)
						{
							if (UNormalize(Buffer, 256, ABuffer, 256*2, &RLen))
							{
								TStrCpy(szAsm, InstrInfo.pasm);
								gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[1].addr.displacement, 0x80000000|RLen/2)));
								TStrCpy(szAsm, ABuffer);
								AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
							}
						} else
						{
							TStrCpy(szAsm, InstrInfo.pasm);
							gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[1].addr.displacement, RLen)));
							TStrCpy(szAsm, ABuffer);
							AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
						}
					} else
					if (InstrInfo.op[1].mode == OP_Immed && //???
					    InstrInfo.op[1].opersize == sizeof(ULONG_PTR) && //???
					    InstrInfo.op[1].immed.immed_value > Address &&
					    InstrInfo.op[1].immed.immed_value < (Address + Size) &&
					    gpSyser->m_pDebugger->ReadMemory(InstrInfo.op[1].immed.immed_value, Buffer, 256) == 256 &&
					    ANormalize(Buffer, 256, ABuffer, 256*2, &RLen))
					{
						if (RLen == 2)
						{
							if (UNormalize(Buffer, 256, ABuffer, 256*2, &RLen))
							{
								TStrCpy(szAsm, InstrInfo.pasm);
								gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[1].immed.immed_value, 0x80000000|RLen/2)));
								TStrCpy(szAsm, ABuffer);
								AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
							}
						} else
						{
							TStrCpy(szAsm, InstrInfo.pasm);
							gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[1].immed.immed_value, RLen)));
							TStrCpy(szAsm, ABuffer);
							AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
						}
					}
				} else
				if (!TStrICmp(InstrInfo.Name, "push"))
				{
					//if (InstrInfo.op[1].mode == OP_Address)
					//{
					//	//???
					//} else
					//if (InstrInfo.op[1].mode == OP_Immed && //???
					if (InstrInfo.op[0].opersize == sizeof(ULONG_PTR) && //???
					    InstrInfo.op[0].immed.immed_value > Address &&
					    InstrInfo.op[0].immed.immed_value < (Address + Size) &&
					    gpSyser->m_pDebugger->ReadMemory(InstrInfo.op[0].immed.immed_value, Buffer, 256) == 256 &&
					    ANormalize(Buffer, 256, ABuffer, 256*2, &RLen))
					{
						if (RLen == 2)
						{
							if (UNormalize(Buffer, 256, ABuffer, 256*2, &RLen))
							{
								TStrCpy(szAsm, InstrInfo.pasm);
								gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[0].immed.immed_value, 0x80000000|RLen/2)));
								TStrCpy(szAsm, ABuffer);
								AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
							}
						} else
						{
							TStrCpy(szAsm, InstrInfo.pasm);
							gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.insert(_Tmap_pair<ULONG_PTR,StringRef>(EIP, StringRef(InstrInfo.op[0].immed.immed_value, RLen)));
							TStrCpy(szAsm, ABuffer);
							AnsiToUnicode(ABuffer, szAsm, lenof(szAsm));
						}
					}
				}

		if (Progress && !(pos%Progress))
		gpSyser->m_MainFrame.UpdateProgress(pos);

			}

		gpSyser->m_MainFrame.DestroyProgress();
			return true;
		}

		bool Find(ULONG_PTR Address)
		{
			//CMemPEFile PEFile;
			CPEFile PEFile;
			CDbgModule *pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(Address);
			if (!pDbgMod)
				pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Address);
			if (pDbgMod)
			{
				ULONG_PTR ImageBase = pDbgMod->m_ImageBase;
				if (ImageBase == 0)
					ImageBase = 0x400000;

				if (PEFile.Open(ImageBase, 0x30, CDebugger::Read, gpSyser->m_pDebugger))
				{
					for (int nsec = 0; nsec < PEFile.m_SectCount; ++nsec)
					{
						if (PEFile.m_Section[nsec].Characteristics & 0x20000000)
						{
							FindSection(ImageBase +
									PEFile.m_Section[nsec].VirtualAddress,
									PEFile.m_Section[nsec].VirtualSize,
									PEFile.m_ImageBase,
									PEFile.m_ImageSize);
						}
					}
					PEFile.Close();
					return true;
				}
			}
			return false;
		}
	};

	void CStringReferenceList::InitContext(int,int)
	{
		char Buffer[256];
		char UBuffer[256*2];
		char ABuffer[512];
		unsigned long RLen;

		unsigned long ColorString[256];
		WCHAR wString[256];
		char aString[256];
		FindStringSection findStringSection;

		CCodeView *pCodeView = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
		if (!pCodeView) return;
	
		gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.clear();
		CListStringItem *pRootItem = pCodeView->FindItem(0, 8);
		ULONG_PTR CIP = pRootItem ? GetItemValue(pRootItem, 1) : (gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP ? *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP : 0);
		if (m_ShowFormat)
		{
			findStringSection.Find(CIP);
			for (map<ULONG_PTR,StringRef>::IT it = gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.begin();
				it != gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.end(); ++it)
			{
				bool bUnicode = false;
				pCodeView->ColorDasm(it->first, 16, ColorString, 0, 0, 0);
				CListStringItem *pItem = InsertItemValue(it->first, nullptr, WSTR("" F0ADDR "X"), 0, nullptr, -1); //TODO
				SetItemTextColor(pItem, 2, ColorString);
				SetItemValue(pItem, 1, (unsigned long long)(/*((unsigned long long)it->second.Len<<32)|*/it->second.Address)); //???
				SetItemValue(pItem, 0, (unsigned long long)it->first);
				unsigned long Len = it->second.Len;
				if (Len & 0x80000000)
				{
					bUnicode = true;
					Len &= ~0x80000000;
				}

				if (Len >= 255) Len = 255;

				if (bUnicode)
				{
					//wString[0] = 'L';
					//wString[1] = '"';
					//gpSyser->m_pDebugger->ReadMemory(it->second.Address, &wString[2], Len * 2);
					//wString[Len + 1] = '"';
					//wString[Len + 2] = 0;
					//wString[255] = 0;

					//gpSyser->m_SyserUI.ReadUString(it->second.Address, wString, Len);

					unsigned long result = gpSyser->m_pDebugger->ReadMemory(it->second.Address, Buffer, Len*2);
					UNormalize(Buffer, 256, UBuffer, 256*2, &RLen);
					int PrefixLen = TStrCpy(wString, "L\"");
					TStrCpyLimit(&wString[PrefixLen], (WCHAR*)UBuffer, 256 - PrefixLen - 1);
					TStrCat(wString, "\"");

					SetItemText(pItem, 1, WSTR("U"));
				} else
				{
					//aString[0] = 0;
					//gpSyser->m_pDebugger->ReadMemory(it->second.Address, aString, Len);
					//TStrCpyLimit(&wString[1], aString, Len);
					//wString[0] = '"';
					//TStrCat(wString, "\"");

					//gpSyser->m_SyserUI.ReadAString(it->second.Address, aString, Len);
					//TStrCpyLimit(wString, aString, Len);

					unsigned long result = gpSyser->m_pDebugger->ReadMemory(it->second.Address, Buffer, Len);
					ANormalize(Buffer, 256, ABuffer, 256, &RLen);
					int PrefixLen = TStrCpy(wString, "\"");
					TStrCpyLimit(&wString[PrefixLen], ABuffer, 256 - PrefixLen - 1);
					TStrCat(wString, "\"");

					SetItemText(pItem, 1, WSTR("C"));
				}
				SetItemText(pItem, 3, wString);
			}
		} else
		{
			map<ULONG_PTR,CListStringItem *> Lists;

			findStringSection.Find(gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP?*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP:0);
			for (map<ULONG_PTR,StringRef>::IT it = gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.begin();
				it != gpSyser->m_MainFrame.m_SystemExplorer.m_FoundStringRefMap.end(); ++it)
			{
				bool bUnicode = false;
				pCodeView->ColorDasm(it->first, 16, ColorString, 0, 0, 0);

				CListStringItem *pItem = NULL;
				map<ULONG_PTR,CListStringItem *>::IT fit = Lists.find(it->second.Address);
				if (fit == Lists.end())
				{
					pItem = InsertItemValue(it->first, nullptr, WSTR("" F0ADDR "X"), 0, nullptr, -1); //TODO
					Lists.insert(_Tmap_pair<ULONG_PTR,CListStringItem *>(it->first, pItem));
					SetItemValue(pItem, 1, (unsigned long long)(/*((unsigned long long)it->second.Len<<32)|*/it->second.Address)); //???
					SetItemValue(pItem, 0, (unsigned long long)(/*((unsigned long long)0x80000000<<32)|*/it->first));
					unsigned long Len = it->second.Len;
					if (Len & 0x80000000)
					{
						bUnicode = true;
						Len &= ~0x80000000;
					}

					if (Len >= 255) Len = 255;

					if (bUnicode)
					{
						//wString[0] = 'L';
						//wString[1] = '"';
						//gpSyser->m_pDebugger->ReadMemory(it->second.Address, &wString[2], Len * 2);
						//wString[Len + 1] = '"';
						//wString[Len + 2] = 0;
						//wString[255] = 0;

						unsigned long result = gpSyser->m_pDebugger->ReadMemory(it->second.Address, Buffer, Len*2);
						UNormalize(Buffer, 256, UBuffer, 256*2, &RLen);
						int PrefixLen = TStrCpy(wString, "L\"");
						TStrCpyLimit(&wString[PrefixLen], (WCHAR*)UBuffer, 256 - PrefixLen - 1);
						TStrCat(wString, "\"");
					} else
					{
						//aString[0] = 0;
						//gpSyser->m_pDebugger->ReadMemory(it->second.Address, aString, Len);
						//TStrCpyLimit(&wString[1], aString, Len);
						//wString[0] = '"';
						//TStrCat(wString, "\"");

						unsigned long result = gpSyser->m_pDebugger->ReadMemory(it->second.Address, Buffer, Len);
						ANormalize(Buffer, 256, ABuffer, 256, &RLen);
						int PrefixLen = TStrCpy(wString, "\"");
						TStrCpyLimit(&wString[PrefixLen], ABuffer, 256 - PrefixLen - 1);
						TStrCat(wString, "\"");
					}
					SetItemText(pItem, 1, wString);
				} else
				{
					pItem = fit->second;
				}
				pItem = InsertItemValue(it->first, pItem, WSTR("" F0ADDR "X"), 0, nullptr, -1);
				SetItemTextColor(pItem, 1, ColorString);
				SetItemValue(pItem, 0, (unsigned long long)it->first);
				//SetItemValue(pItem, 1, *(unsigned long long*)&it->second);
				SetItemValue(pItem, 1, (unsigned long long)it->second.Address);
			}
		}
	}

	bool CStringReferenceList::Search(const WCHAR *pString)
	{
		int nCol = (m_ShowFormat != 0)*2 + 1;
		if (pString)
			m_SearchString = pString;
		WCHAR Text[255];
		CListStringItem *pItem = GetNext(0, 0);
		while (pItem)
		{
			GetItemText(pItem, nCol, Text, 511);
			if (TStrIStr((Text[0]!='L')?&Text[1]:((Text[1]!='"')?&Text[1]:&Text[2]), m_SearchString.operator const WCHAR*())) break;
			pItem = GetNext(pItem, 0);
		}

		if (pItem)
		{
			m_nSearchLen = m_SearchString.m_nLength;
			Select(pItem);
			Scroll(pItem, -1);
			SendCommand(0, 1, 0);
		} else
		{
			SendCommand(0, 0, 0);
		}
		return true;
	}

```

`source/WispSyser/findstringform.hpp`:

```hpp

#ifndef _FINDSTRINGFORM_HPP_
#define _FINDSTRINGFORM_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wispedit.hpp"
#include "../Wisp/wispbutton.hpp"

#include "../Code/alt/altmap.hpp"
#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispmenu.hpp"

struct CStringReferenceList;

struct CFindStringForm : public CWispForm
{
	CWispButton *m_pFindNext;
	CWispButton *m_pClose;
	CWispEdit *m_pFindWhat;
	CStringReferenceList *m_pStringReferenceList;

	CFindStringForm();
	virtual ~CFindStringForm();
	
	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);

	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdFindWhat(WISP_MSG *pMsg);

	bool OnEvent(WISP_MSG *pMsg);
	bool OnEvent1(WISP_MSG *pMsg);
};

struct CStringReferenceList : public CWispList
{
	unsigned long m_ShowFormat;
	int m_nSearchLen;
	CWispMenu m_PopupMenu;
	TWideString m_SearchString;
	map<unsigned int, unsigned int> m_KeyMap;
	CFindStringForm m_FindStringForm;
	CWispMenu::MenuItem *m_SearchAgainMenuItem;

	CStringReferenceList();
	virtual ~CStringReferenceList();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	void LoadKeyMap();

	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);

	bool OnCommand(WISP_MSG *pMsg);

	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventSearch(WISP_MSG *pMsg);
	bool OnEventSearchAgain(WISP_MSG *pMsg);

	bool OnChar(WISP_MSG *pMsg);
	void PopupMenu();
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnMouseDblClick(WISP_MSG *pMsg);

	void InitContext(int,int);
	bool Search(const WCHAR *pString);
};

#endif

```

`source/WispSyser/fpuregisterlist.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "fpuregisterlist.hpp"
#include "syserconfig.hpp"

//#define FPUFMT "%+1.17e"
#define FPUFMT "%1.17e"
extern "C" void _cdecl REAL10toDOUBLE(unsigned long long *pFpuReg, double *Value);

	WISP_MSG_MAP_BEGIN(CFpuRegisterList)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
	WISP_MSG_MAP_END(CWispList)

	CFpuRegisterList::CFpuRegisterList()
	{
	}
	CFpuRegisterList::~CFpuRegisterList()
	{
	}

	bool CFpuRegisterList::OnUpdate(WISP_MSG *pMsg)
	{
		m_ColorChanges = gSyserColors.Color[4];
		m_ColorSame = gSyserColors.Color[1];
		m_ColorFocus = gSyserColors.Color[2];
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		UpdateItemColor(0);
		return true;
	}

	bool CFpuRegisterList::OnCreate(WISP_MSG *pMsg)
	{
		m_ColorChanges = gSyserColors.Color[4];
		m_ColorSame = gSyserColors.Color[1];
		m_ColorFocus = gSyserColors.Color[2];
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		InsertColumn(WSTR("Register"), 90, 0, 0, -1);
		InsertColumn(WSTR("Value"), 180, 1, 0, -1);

		m_hFpuRegItem[FPU_REG_ST_0] = InsertItem(WSTR("ST(0)"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_ST_1] = InsertItem(WSTR("ST(1)"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_ST_2] = InsertItem(WSTR("ST(2)"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_ST_3] = InsertItem(WSTR("ST(3)"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_ST_4] = InsertItem(WSTR("ST(4)"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_ST_5] = InsertItem(WSTR("ST(5)"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_ST_6] = InsertItem(WSTR("ST(6)"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_ST_7] = InsertItem(WSTR("ST(7)"), 0, 0, 0, -1);

		m_hFpuRegItem[FPU_REG_STATE] = InsertItem(WSTR("FPU Status Word"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_B] = InsertItem(WSTR("FPU Busy"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_C3] = InsertItem(WSTR("Condition Code 3"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_TOP] = InsertItem(WSTR("Top of Stack Pointer"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_C2] = InsertItem(WSTR("Condition Code 2"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_C1] = InsertItem(WSTR("Condition Code 1"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_C0] = InsertItem(WSTR("Condition Code 0"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_ES] = InsertItem(WSTR("Error Summary Status"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_SF] = InsertItem(WSTR("Stack Fault"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_PE] = InsertItem(WSTR("Precision Exception"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_UE] = InsertItem(WSTR("Underflow Exception"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_OE] = InsertItem(WSTR("Overflow Exception"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_ZE] = InsertItem(WSTR("Zero Divide Exception"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_DE] = InsertItem(WSTR("Denormalized Exception"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_STATUS_IE] = InsertItem(WSTR("Invalid Operation Exception"), m_hFpuRegItem[FPU_REG_STATE], 0, 0, -1);

		m_hFpuRegItem[FPU_REG_CONTROL] = InsertItem(WSTR("FPU Control Word"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_CONTROL_X] = InsertItem(WSTR("Infinity Control"), m_hFpuRegItem[FPU_REG_CONTROL], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_CONTROL_RC] = InsertItem(WSTR("Rounding Control"), m_hFpuRegItem[FPU_REG_CONTROL], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_CONTROL_PC] = InsertItem(WSTR("Precision Control"), m_hFpuRegItem[FPU_REG_CONTROL], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_CONTROL_PM] = InsertItem(WSTR("Precision Mask"), m_hFpuRegItem[FPU_REG_CONTROL], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_CONTROL_UM] = InsertItem(WSTR("Underflow Mask"), m_hFpuRegItem[FPU_REG_CONTROL], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_CONTROL_OM] = InsertItem(WSTR("Overflow Mask"), m_hFpuRegItem[FPU_REG_CONTROL], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_CONTROL_ZM] = InsertItem(WSTR("Zero Divide Mask"), m_hFpuRegItem[FPU_REG_CONTROL], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_CONTROL_DM] = InsertItem(WSTR("Denormal Mask"), m_hFpuRegItem[FPU_REG_CONTROL], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_CONTROL_IM] = InsertItem(WSTR("Invalid Mask"), m_hFpuRegItem[FPU_REG_CONTROL], 0, 0, -1);

		m_hFpuRegItem[FPU_REG_TAG] = InsertItem(WSTR("FPU Tag word"), 0, 0, 0, -1);
		m_hFpuRegItem[FPU_REG_TAG_0] = InsertItem(WSTR("TAG(0)"), m_hFpuRegItem[FPU_REG_TAG], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_TAG_1] = InsertItem(WSTR("TAG(1)"), m_hFpuRegItem[FPU_REG_TAG], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_TAG_2] = InsertItem(WSTR("TAG(2)"), m_hFpuRegItem[FPU_REG_TAG], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_TAG_3] = InsertItem(WSTR("TAG(3)"), m_hFpuRegItem[FPU_REG_TAG], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_TAG_4] = InsertItem(WSTR("TAG(4)"), m_hFpuRegItem[FPU_REG_TAG], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_TAG_5] = InsertItem(WSTR("TAG(5)"), m_hFpuRegItem[FPU_REG_TAG], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_TAG_6] = InsertItem(WSTR("TAG(6)"), m_hFpuRegItem[FPU_REG_TAG], 0, 0, -1);
		m_hFpuRegItem[FPU_REG_TAG_7] = InsertItem(WSTR("TAG(7)"), m_hFpuRegItem[FPU_REG_TAG], 0, 0, -1);
		ResetContext();
		return true;
	}
	bool CFpuRegisterList::OnGetFocus(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 0);
		if (Item) Select(Item);
		return true;
	}
	void CFpuRegisterList::ResetContext()
	{
		Select(m_hFpuRegItem[FPU_REG_ST_0]);
		SetItemText(m_hFpuRegItem[FPU_REG_ST_0], 1, WSTR("?? ?? ?? ?? ?? ?? ?? ?? ?? ??"));
		SetItemText(m_hFpuRegItem[FPU_REG_ST_1], 1, WSTR("?? ?? ?? ?? ?? ?? ?? ?? ?? ??"));
		SetItemText(m_hFpuRegItem[FPU_REG_ST_2], 1, WSTR("?? ?? ?? ?? ?? ?? ?? ?? ?? ??"));
		SetItemText(m_hFpuRegItem[FPU_REG_ST_3], 1, WSTR("?? ?? ?? ?? ?? ?? ?? ?? ?? ??"));
		SetItemText(m_hFpuRegItem[FPU_REG_ST_4], 1, WSTR("?? ?? ?? ?? ?? ?? ?? ?? ?? ??"));
		SetItemText(m_hFpuRegItem[FPU_REG_ST_5], 1, WSTR("?? ?? ?? ?? ?? ?? ?? ?? ?? ??"));
		SetItemText(m_hFpuRegItem[FPU_REG_ST_6], 1, WSTR("?? ?? ?? ?? ?? ?? ?? ?? ?? ??"));
		SetItemText(m_hFpuRegItem[FPU_REG_ST_7], 1, WSTR("?? ?? ?? ?? ?? ?? ?? ?? ?? ??"));

		SetItemText(m_hFpuRegItem[FPU_REG_STATE], 1, WSTR("????"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_B], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_C3], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_TOP], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_C2], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_C1], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_C0], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_ES], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_SF], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_PE], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_UE], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_OE], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_ZE], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_DE], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_STATUS_IE], 1, WSTR("?"));

		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL], 1, WSTR("????"));
		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_X], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_RC], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_PC], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_PM], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_UM], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_OM], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_ZM], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_DM], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_IM], 1, WSTR("?"));

		SetItemText(m_hFpuRegItem[FPU_REG_TAG], 1, WSTR("????"));
		SetItemText(m_hFpuRegItem[FPU_REG_TAG_0], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_TAG_1], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_TAG_2], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_TAG_3], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_TAG_4], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_TAG_5], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_TAG_6], 1, WSTR("?"));
		SetItemText(m_hFpuRegItem[FPU_REG_TAG_7], 1, WSTR("?"));
		memset(&m_FPUREG, 0, sizeof(m_FPUREG));
	}
	void CFpuRegisterList::UpdateContext()
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && IsWindow())
		{
			if (GetActiveCPU() == m_nCPU)
				memcpy(&m_CPUREGPTR, &gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR, sizeof(m_CPUREGPTR));
			else	gpSyser->m_pDebugger->GetX86RegPtr(&m_CPUREGPTR, m_nCPU);

			//memcpy(&m_FPUREG, &FpuRegisterImage[CurrentFpuImageIndex ^ 1], sizeof(m_FPUREG));

			WCHAR Buffer[5000];

			for (int n = 0; n < 8; ++n)
			{
				unsigned char *pFPU = m_CPUREGPTR.GetFPU(n);

			//	TSPrintf(Buffer, WSTR("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x"),
			//		pFPU[0], pFPU[1], pFPU[2], pFPU[3], pFPU[4],
			//		pFPU[5], pFPU[6], pFPU[7], pFPU[8], pFPU[9]);
				double FPUValue = 0.0;
				REAL10toDOUBLE((unsigned long long *)pFPU, &FPUValue); //0xFFF80000
			#if 0
//unsigned long NaN[2] = {0xffffffff, 0x7fffffff}
//A quiet NaN is represented by any bit pattern between X'7FF80000 00000000' and X'7FFFFFFF FFFFFFFF' 
//or between X'FFF80000 00000000' and X'FFFFFFFF FFFFFFFF'.
//https://stackoverflow.com/questions/2249110/how-do-i-make-a-portable-isnan-isinf-function/2249173

				if (_fpclass(FPUValue) == _FPCLASS_QNAN || _fpclass(FPUValue) == _FPCLASS_SNAN)
					TSPrintf(Buffer, WSTR("Nan"));
				else
				if (_fpclass(FPUValue) == _FPCLASS_NINF)
					TSPrintf(Buffer, WSTR("-Inf"));
				else
				if (_fpclass(FPUValue) == _FPCLASS_PINF)
					TSPrintf(Buffer, WSTR("+Inf"));
				//_FPCLASS_NN
				//_FPCLASS_ND
				//_FPCLASS_NZ
				//_FPCLASS_PZ
				//_FPCLASS_PD
				//_FPCLASS_PN
				else
			#endif
					TSPrintf(Buffer, WSTR("" FPUFMT ""), FPUValue);

				SetItemText(m_hFpuRegItem[n], 1, Buffer);
				bool Same = !memcmp(pFPU, &m_FPUREG.RegisterArea[n*10], 10);
				SetItemColor(m_hFpuRegItem[n], 1, Same ? m_ColorSame:m_ColorChanges);
			}
		//STATUS
			TSPrintf(Buffer, WSTR("%04x"), *(unsigned short*)m_CPUREGPTR.FP_StatusWord);
			SetItemText(m_hFpuRegItem[FPU_REG_STATE], 1, Buffer);
			SetItemColor(m_hFpuRegItem[FPU_REG_STATE], 1, (*(unsigned short*)m_CPUREGPTR.FP_StatusWord==*(unsigned short*)&m_FPUREG.StatusWord)?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_IE], 1, m_CPUREGPTR.FP_StatusWord->IE?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_IE], 1, m_CPUREGPTR.FP_StatusWord->IE==m_FPUREG.StatusWord.IE?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_DE], 1, m_CPUREGPTR.FP_StatusWord->DE?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_DE], 1, m_CPUREGPTR.FP_StatusWord->DE==m_FPUREG.StatusWord.DE?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_ZE], 1, m_CPUREGPTR.FP_StatusWord->ZE?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_ZE], 1, m_CPUREGPTR.FP_StatusWord->ZE==m_FPUREG.StatusWord.ZE?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_OE], 1, m_CPUREGPTR.FP_StatusWord->OE?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_OE], 1, m_CPUREGPTR.FP_StatusWord->OE==m_FPUREG.StatusWord.OE?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_UE], 1, m_CPUREGPTR.FP_StatusWord->UE?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_UE], 1, m_CPUREGPTR.FP_StatusWord->UE==m_FPUREG.StatusWord.UE?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_PE], 1, m_CPUREGPTR.FP_StatusWord->PE?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_PE], 1, m_CPUREGPTR.FP_StatusWord->PE==m_FPUREG.StatusWord.PE?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_SF], 1, m_CPUREGPTR.FP_StatusWord->SF?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_SF], 1, m_CPUREGPTR.FP_StatusWord->SF==m_FPUREG.StatusWord.SF?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_ES], 1, m_CPUREGPTR.FP_StatusWord->ES?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_ES], 1, m_CPUREGPTR.FP_StatusWord->ES==m_FPUREG.StatusWord.ES?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_C0], 1, m_CPUREGPTR.FP_StatusWord->C0?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_C0], 1, m_CPUREGPTR.FP_StatusWord->C0==m_FPUREG.StatusWord.C0?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_C1], 1, m_CPUREGPTR.FP_StatusWord->C1?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_C1], 1, m_CPUREGPTR.FP_StatusWord->C1==m_FPUREG.StatusWord.C1?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_C2], 1, m_CPUREGPTR.FP_StatusWord->C2?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_C2], 1, m_CPUREGPTR.FP_StatusWord->C2==m_FPUREG.StatusWord.C2?m_ColorSame:m_ColorChanges);

			TSPrintf(Buffer, WSTR("%x"), m_CPUREGPTR.FP_StatusWord->TOP);
			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_TOP], 1, Buffer);
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_TOP], 1, m_CPUREGPTR.FP_StatusWord->TOP==m_FPUREG.StatusWord.TOP?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_C3], 1, m_CPUREGPTR.FP_StatusWord->C3?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_C3], 1, m_CPUREGPTR.FP_StatusWord->C3==m_FPUREG.StatusWord.C3?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_STATUS_B], 1, m_CPUREGPTR.FP_StatusWord->B?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_STATUS_B], 1, m_CPUREGPTR.FP_StatusWord->B==m_FPUREG.StatusWord.B?m_ColorSame:m_ColorChanges);
		//CONTROL
			TSPrintf(Buffer, WSTR("%04x"), *(unsigned short*)m_CPUREGPTR.FP_ControlWord);
			SetItemText(m_hFpuRegItem[FPU_REG_CONTROL], 1, Buffer);
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL], 1, (*(unsigned short*)m_CPUREGPTR.FP_ControlWord==*(unsigned short*)&m_FPUREG.ControlWord)?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_X], 1, m_CPUREGPTR.FP_ControlWord->X?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL_X], 1, m_CPUREGPTR.FP_ControlWord->X==m_FPUREG.ControlWord.X?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hFpuRegItem[FPU_REG_CONTROL_RC], 1, m_CPUREGPTR.FP_ControlWord->RC, WSTR("%X"));
			//TODO compare changes
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL_RC], 1, m_ColorSame);

			SetItemFormat(m_hFpuRegItem[FPU_REG_CONTROL_PC], 1, m_CPUREGPTR.FP_ControlWord->PC, WSTR("%X"));
			//TODO compare changes
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL_PC], 1, m_ColorSame);

			SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_PM], 1, m_CPUREGPTR.FP_ControlWord->PM?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL_PM], 1, m_CPUREGPTR.FP_ControlWord->PM==m_FPUREG.ControlWord.PM?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_UM], 1, m_CPUREGPTR.FP_ControlWord->UM?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL_UM], 1, m_CPUREGPTR.FP_ControlWord->UM==m_FPUREG.ControlWord.UM?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_OM], 1, m_CPUREGPTR.FP_ControlWord->OM?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL_OM], 1, m_CPUREGPTR.FP_ControlWord->OM==m_FPUREG.ControlWord.OM?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_ZM], 1, m_CPUREGPTR.FP_ControlWord->ZM?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL_ZM], 1, m_CPUREGPTR.FP_ControlWord->ZM==m_FPUREG.ControlWord.ZM?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_DM], 1, m_CPUREGPTR.FP_ControlWord->DM?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL_DM], 1, m_CPUREGPTR.FP_ControlWord->DM==m_FPUREG.ControlWord.DM?m_ColorSame:m_ColorChanges);

			SetItemText(m_hFpuRegItem[FPU_REG_CONTROL_IM], 1, m_CPUREGPTR.FP_ControlWord->IM?WSTR("1"):WSTR("0"));
			SetItemColor(m_hFpuRegItem[FPU_REG_CONTROL_IM], 1, m_CPUREGPTR.FP_ControlWord->IM==m_FPUREG.ControlWord.IM?m_ColorSame:m_ColorChanges);

		//TAG
			TSPrintf(Buffer, WSTR("%04x"), *(unsigned short*)m_CPUREGPTR.FP_TagWord);
			SetItemText(m_hFpuRegItem[FPU_REG_TAG], 1, Buffer);
			SetItemColor(m_hFpuRegItem[FPU_REG_TAG], 1, (*(unsigned short*)m_CPUREGPTR.FP_TagWord==*(unsigned short*)&m_FPUREG.TagWord)?m_ColorSame:m_ColorChanges);
			//3 ?
			SetItemFormat(m_hFpuRegItem[FPU_REG_TAG_0], 1, m_CPUREGPTR.FP_TagWord->TAG0,WSTR("%X"));
			SetItemColor(m_hFpuRegItem[FPU_REG_TAG_0], 1, m_CPUREGPTR.FP_TagWord->TAG0==m_FPUREG.TagWord.TAG0?m_ColorSame:m_ColorChanges);
			//0xC
			SetItemFormat(m_hFpuRegItem[FPU_REG_TAG_1], 1, m_CPUREGPTR.FP_TagWord->TAG1,WSTR("%X"));
			SetItemColor(m_hFpuRegItem[FPU_REG_TAG_1], 1, m_CPUREGPTR.FP_TagWord->TAG1==m_FPUREG.TagWord.TAG1?m_ColorSame:m_ColorChanges);
			//0x30
			SetItemFormat(m_hFpuRegItem[FPU_REG_TAG_2], 1, m_CPUREGPTR.FP_TagWord->TAG2,WSTR("%X"));
			SetItemColor(m_hFpuRegItem[FPU_REG_TAG_2], 1, m_CPUREGPTR.FP_TagWord->TAG2==m_FPUREG.TagWord.TAG2?m_ColorSame:m_ColorChanges);
			//0xC0
			SetItemFormat(m_hFpuRegItem[FPU_REG_TAG_3], 1, m_CPUREGPTR.FP_TagWord->TAG3,WSTR("%X"));
			SetItemColor(m_hFpuRegItem[FPU_REG_TAG_3], 1, m_CPUREGPTR.FP_TagWord->TAG3==m_FPUREG.TagWord.TAG3?m_ColorSame:m_ColorChanges);
			//3 ?
			SetItemFormat(m_hFpuRegItem[FPU_REG_TAG_4], 1, m_CPUREGPTR.FP_TagWord->TAG4,WSTR("%X"));
			SetItemColor(m_hFpuRegItem[FPU_REG_TAG_4], 1, m_CPUREGPTR.FP_TagWord->TAG4==m_FPUREG.TagWord.TAG4?m_ColorSame:m_ColorChanges);
			//0xC00
			SetItemFormat(m_hFpuRegItem[FPU_REG_TAG_5], 1, m_CPUREGPTR.FP_TagWord->TAG5,WSTR("%X"));
			SetItemColor(m_hFpuRegItem[FPU_REG_TAG_5], 1, m_CPUREGPTR.FP_TagWord->TAG5==m_FPUREG.TagWord.TAG5?m_ColorSame:m_ColorChanges);
			//0x3000
			SetItemFormat(m_hFpuRegItem[FPU_REG_TAG_6], 1, m_CPUREGPTR.FP_TagWord->TAG6,WSTR("%X"));
			SetItemColor(m_hFpuRegItem[FPU_REG_TAG_6], 1, m_CPUREGPTR.FP_TagWord->TAG6==m_FPUREG.TagWord.TAG6?m_ColorSame:m_ColorChanges);
			//0xC000
			SetItemFormat(m_hFpuRegItem[FPU_REG_TAG_7], 1, m_CPUREGPTR.FP_TagWord->TAG7,WSTR("%X"));
			SetItemColor(m_hFpuRegItem[FPU_REG_TAG_7], 1, m_CPUREGPTR.FP_TagWord->TAG7==m_FPUREG.TagWord.TAG7?m_ColorSame:m_ColorChanges);

			for (int n = 0; n < 8; ++n)
			{
				memcpy(&m_FPUREG.RegisterArea[n*10], m_CPUREGPTR.GetFPU(n), 10);
			}

			memcpy(&m_FPUREG.StatusWord, m_CPUREGPTR.FP_StatusWord, sizeof(m_FPUREG.StatusWord));
			memcpy(&m_FPUREG.ControlWord, m_CPUREGPTR.FP_ControlWord, sizeof(m_FPUREG.ControlWord));
			memcpy(&m_FPUREG.TagWord, m_CPUREGPTR.FP_TagWord, sizeof(m_FPUREG.TagWord));

			Update(&m_ClientRect);
		}
	}

```

`source/WispSyser/fpuregisterlist.hpp`:

```hpp

#ifndef _FPUREGISTERLIST_HPP_
#define _FPUREGISTERLIST_HPP_

#include "../Wisp/wisplist.hpp"
#include "../EXEAnalyzer/x86debugger.hpp"

enum FPU_REG_INDEX
{
  FPU_REG_ST_0 = 0,
  FPU_REG_ST_1 = 1,
  FPU_REG_ST_2 = 2,
  FPU_REG_ST_3 = 3,
  FPU_REG_ST_4 = 4,
  FPU_REG_ST_5 = 5,
  FPU_REG_ST_6 = 6,
  FPU_REG_ST_7 = 7,

  FPU_REG_STATE = 8,
  FPU_REG_STATUS_IE = 9,
  FPU_REG_STATUS_DE = 10,
  FPU_REG_STATUS_ZE = 11,
  FPU_REG_STATUS_OE = 12,
  FPU_REG_STATUS_UE = 13,
  FPU_REG_STATUS_PE = 14,
  FPU_REG_STATUS_SF = 15,
  FPU_REG_STATUS_ES = 16,
  FPU_REG_STATUS_C0 = 17,
  FPU_REG_STATUS_C1 = 18,
  FPU_REG_STATUS_C2 = 19,
  FPU_REG_STATUS_TOP = 20,
  FPU_REG_STATUS_C3 = 21,
  FPU_REG_STATUS_B = 22,

  FPU_REG_CONTROL = 23,
  FPU_REG_CONTROL_IM = 24,
  FPU_REG_CONTROL_DM = 25,
  FPU_REG_CONTROL_ZM = 26,
  FPU_REG_CONTROL_OM = 27,
  FPU_REG_CONTROL_UM = 28,
  FPU_REG_CONTROL_PM = 29,
  FPU_REG_CONTROL_PC = 30,
  FPU_REG_CONTROL_RC = 31,
  FPU_REG_CONTROL_X = 32,

  FPU_REG_TAG = 33,
  FPU_REG_TAG_0 = 34,
  FPU_REG_TAG_1 = 35,
  FPU_REG_TAG_2 = 36,
  FPU_REG_TAG_3 = 37,
  FPU_REG_TAG_4 = 38,
  FPU_REG_TAG_5 = 39,
  FPU_REG_TAG_6 = 40,
  FPU_REG_TAG_7 = 41,

  FPU_REG_COUNT = 42,
};

struct FPU_REG
{
	unsigned char RegisterArea[80]; //SIZE_OF_80387_REGISTERS
	stFPU_STATUS_REG StatusWord;
	stFPU_CONTROL_REG ControlWord;
	stFPU_TAG_REG TagWord;
};

struct CFpuRegisterList : public CWispList
{
	CListStringItem *m_hFpuRegItem[FPU_REG_COUNT];
	unsigned long m_ColorChanges;
	unsigned long m_ColorSame;
	int m_nCPU;
	X86_CPU_REG_PTR m_CPUREGPTR;
	FPU_REG m_FPUREG;

	CFpuRegisterList();
	virtual ~CFpuRegisterList();

	bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnGetFocus(WISP_MSG *pMsg);
	void ResetContext();
	void UpdateContext();
};

#endif
```

`source/WispSyser/functionlistwnd.cpp`:

```cpp

#include "functionlistwnd.hpp"

```

`source/WispSyser/functionlistwnd.hpp`:

```hpp

#ifndef _FUNCTIONLISTWND_HPP_
#define _FUNCTIONLISTWND_HPP_
#endif

```

`source/WispSyser/gdtwnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "gdtwnd.hpp"
#include "syserconfig.hpp"

	static const WCHAR *DescType[] =
	        {
	                WSTR("Reserved"),//0
	                WSTR("TSS16   "),//1
	                WSTR("LDT     "),//2
	                WSTR("TSS32   "),//3
	                WSTR("CallG16 "),//4
	                WSTR("TaskG   "),//5
	                WSTR("IntG16  "),//6
	                WSTR("TrapG16 "),//7
	                WSTR("Reserved"),//8
	                WSTR("TSS32   "),//9
	                WSTR("Reserved"),//A
	                WSTR("TSS32   "),//B
	                WSTR("CallG32 "),//C
	                WSTR("Reserved"),//D
	                WSTR("IntG32  "),//E-
	                WSTR("TrapG32 "),//F
	        };

struct _X86_SEGMENT_DESCRIPTOR
{
	unsigned long limit_L0 :8;
	unsigned long limit_L1 :8;
	unsigned long base_L0 :8;
	unsigned long base_L1 :8;

	unsigned long base_H0 :8;	/* 0 */

	unsigned long TYPE :4;		/* 8 */
	unsigned long DT :1;		/* 12 */
	unsigned long DPL :2;		/* 13 */
	unsigned long P :1;		/* 15 */

	unsigned long limit_H :4;	/* 16 */
	unsigned long AVL :1;		/* 20 */
	unsigned long reseved :1;	/* 21 */
	unsigned long D :1;		/* 22 */
	unsigned long G :1;		/* 23 */

	unsigned long base_H1 :8;	/* 24 */

};

	_X86_SEGMENT_DESCRIPTOR gdtdata[] =
		{
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xff,0xff,0x00,0x00,0x00,  0x0b,0x01,0x00,0x01,  0x0f,0x00,0x00,0x01,0x01,  0x00},
      {0xff,0xff,0x00,0x00,0x00,  0x03,0x01,0x00,0x01,  0x0f,0x00,0x00,0x01,0x01,  0x00},
      {0xff,0xff,0x00,0x00,0x00,  0x0b,0x01,0x03,0x01,  0x0f,0x00,0x00,0x01,0x01,  0x00},
      {0xff,0xff,0x00,0x00,0x00,  0x03,0x01,0x03,0x01,  0x0f,0x00,0x00,0x01,0x01,  0x00},
      {0xab,0x20,0x00,0x20,0x04,  0x0b,0x00,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x80},
      {0x01,0x00,0x00,0xf0,0xdf,  0x03,0x01,0x00,0x01,  0x00,0x00,0x00,0x01,0x01,  0xff},
      {0xff,0x0f,0x00,0x00,0x00,  0x03,0x01,0x03,0x01,  0x00,0x00,0x00,0x01,0x00,  0x00},
      {0xff,0xff,0x00,0x04,0x00,  0x02,0x01,0x03,0x01,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x68,0x00,0x00,0x32,0x54,  0x09,0x00,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x80},
      {0x68,0x00,0x68,0x32,0x54,  0x09,0x00,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x80},
      {0xff,0xff,0x20,0x2f,0x02,  0x03,0x01,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xff,0x3f,0x00,0x80,0x0b,  0x02,0x01,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xff,0x03,0x00,0x70,0xff,  0x02,0x01,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0xff},
      {0xff,0xff,0x00,0x00,0x40,  0x0a,0x01,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x80},
      {0xff,0xff,0x00,0x00,0x40,  0x02,0x01,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x80},
      {0x00,0x00,0x00,0x00,0x00,  0x02,0x01,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x68,0x00,0xb8,0xeb,0xbd,  0x09,0x00,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x81},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xff,0xff,0x00,0x20,0xa9,  0x0f,0x01,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0xf9},
      {0xff,0xff,0x00,0x00,0x00,  0x02,0x01,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xce,0x25,0xd0,0x31,0x50,  0x08,0x01,0x00,0x01,  0x0f,0x00,0x00,0x00,0x00,  0x80},
      {0xff,0xff,0x00,0x00,0x00,  0x02,0x01,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xff,0xff,0x00,0x20,0xaa,  0x03,0x01,0x00,0x01,  0x00,0x00,0x00,0x01,0x00,  0xf9},
      {0xff,0xff,0x00,0x20,0xaa,  0x03,0x01,0x00,0x01,  0x00,0x00,0x00,0x01,0x00,  0xf9},
      {0xff,0xff,0x00,0x20,0xaa,  0x03,0x01,0x00,0x01,  0x00,0x00,0x00,0x01,0x00,  0xf9},
      {0x20,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x28,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x30,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x38,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x40,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x48,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x50,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x58,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x60,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x68,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x70,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x78,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x80,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x88,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x90,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x98,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xa0,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xa8,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xb0,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xb8,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xc0,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xc8,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xd0,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xd8,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xe0,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xe8,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xf0,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xf8,0xf1,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x08,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x10,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x18,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x20,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x28,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x30,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x38,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x40,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x48,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x50,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x58,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x60,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x68,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x70,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x78,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x80,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x88,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x90,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x98,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xa0,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xa8,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xb0,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xb8,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xc0,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xc8,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xd0,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xd8,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xe0,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xe8,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xf0,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xf8,0xf2,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x08,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x10,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x18,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x20,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x28,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x30,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x38,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x40,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x48,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x50,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x58,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x60,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x68,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x70,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x78,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x80,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x88,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x90,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x98,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xa0,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xa8,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xb0,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xb8,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xc0,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xc8,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xd0,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xd8,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xe0,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xe8,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xf0,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xf8,0xf3,0x03,0x80,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x22,0xbc,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x69,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x03,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x78,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x87,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x03,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0xe5,0xc1,0x08,0x00,0x00,  0x0e,0x00,0x03,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x26,0xc3,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x96,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x57,0xca,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x78,0x11,0x50,0x00,0x00,  0x05,0x00,0x00,0x01,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x71,0xce,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x74,0xcf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xa5,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0xb4,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0xc3,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0xd2,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4f,0xe0,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x6a,0xe1,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0xa0,0x00,0x00,  0x05,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xb6,0xe2,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0x00,0x00,0x08,0x00,0x00,  0x00,0x00,0x00,0x00,  0x00,0x00,0x00,0x00,0x00,  0x00},
      {0xf6,0xb4,0x08,0x00,0x00,  0x0e,0x00,0x03,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xe1,0xb5,0x08,0x00,0x00,  0x0e,0x00,0x03,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x44,0xb7,0x08,0x00,0x00,  0x0e,0x00,0x03,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xf0,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x03,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0xff,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x03,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x4c,0xdf,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xc0,0xe4,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0c,0x00,0x01,0x01,0x00,  0x80},
      {0x0e,0xb0,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x84,0xa7,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x1d,0xb0,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x2c,0xb0,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x9c,0x15,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x02,0x00,0x01,0x00,0x01,  0x81},
      {0xac,0xa7,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4a,0xb0,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x80,0x8e,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0c,0x00,0x01,0x01,0x00,  0x80},
      {0x6c,0x52,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0c,0x01,0x01,0x00,0x01,  0x81},
      {0xd4,0xed,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x00,0x00,0x01,  0x81},
      {0xf4,0xf2,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0e,0x01,0x00,0x00,0x01,  0x81},
      {0x3b,0xb0,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0xf2,0xa7,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xe4,0x66,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0b,0x01,0x01,0x00,0x01,  0x81},
      {0x2c,0x1b,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x07,0x01,0x01,0x00,0x01,  0x81},
      {0x10,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xe1,0xaf,0x08,0x00,0x00,  0x0e,0x00,0x03,0x01,  0x00,0x01,0x01,0x01,0x01,  0xf1},
      {0x24,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x2e,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x38,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x42,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4c,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x56,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x60,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x6a,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x74,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x7e,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x88,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x92,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x9c,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xa6,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xb0,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xba,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xc4,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xce,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xd8,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xe2,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xec,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xf6,0xa8,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x00,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x0a,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x14,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x1e,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x28,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x32,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x3c,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x46,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x50,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x5a,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x64,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x6e,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x78,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x82,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x8c,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x96,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xa0,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xaa,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xb4,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xbe,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xc8,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xd2,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xdc,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xe6,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xf0,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0xfa,0xa9,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x04,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x0e,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x18,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x22,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x2c,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x36,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x40,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x4a,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x54,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x5e,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x68,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x72,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x7c,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
      {0x86,0xaa,0x08,0x00,0x00,  0x0e,0x00,0x00,0x01,  0x0d,0x00,0x00,0x01,0x00,  0x80},
		};

        WISP_MSG_MAP_BEGIN(CGDTWnd)
                WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
                WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
        WISP_MSG_MAP_END(CWispList)

	CGDTWnd::CGDTWnd()
	{
		m_dwBeginIndex = 0;
	#if 0
		//m_pGDTAddress = GetGDTBase(&m_dwGDTSize);
	#else
		m_pGDTAddress = gdtdata;
		m_dwGDTSize = sizeof(gdtdata)-1;//2047; //256		
	#endif
	}
	CGDTWnd::~CGDTWnd()
	{
	}

        bool CGDTWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_ItemColor = gSyserColors.Color[1];
		m_crBGColor = gSyserColors.Color[0];
		m_bBGColor = 1;

		InsertColumn(WSTR("Selector"), 40, 0, 0, -1);
		InsertColumn(WSTR("Type"), 80, 0, 0, -1);
		InsertColumn(WSTR("Base"), 90, 0, 0, -1);
		InsertColumn(WSTR("Limit"), 100, 0, 0, -1);
		InsertColumn(WSTR("DPL"), 90, 0, 0, -1);
		InsertColumn(WSTR("Attributes"), 90, 0, 0, -1);

		SetWindowText(WSTR("GDT TABLE"));
		InitContext();
		return true;
	}
        bool CGDTWnd::OnClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}

	bool CGDTWnd::InsertGDT()
	{
		void *dwGDTBase = m_pGDTAddress;
		unsigned long dwGDTSize = (m_dwGDTSize+1)/8;

		WCHAR display[64];

		_X86_SEGMENT_DESCRIPTOR *pSegDesc = (_X86_SEGMENT_DESCRIPTOR *)dwGDTBase;
		unsigned long dwShowSelector = (unsigned long)pSegDesc;

		for (unsigned long i = 0; i < dwGDTSize; ++i)
		{
			unsigned long dwSegmentBase = (pSegDesc->base_H1<<24) | (pSegDesc->base_H0<<16) | (pSegDesc->base_L1<<8) | (pSegDesc->base_L0);
			unsigned long dwSegmentLimit = (pSegDesc->limit_H<<16) | (pSegDesc->limit_L1<<8) | (pSegDesc->limit_L0);

			unsigned long dwSelector = (unsigned long)pSegDesc;
			dwSelector = (dwSelector-dwShowSelector) | pSegDesc->DPL;

			if (pSegDesc->P)
			{
				if (pSegDesc->DT)
				{
					if (pSegDesc->G)
						dwSegmentLimit = (dwSegmentLimit<<12) | 0xFFFF;


					TSPrintf(display, WSTR("%04X"), dwSelector);

					CListStringItem *pItem = InsertItem(display, 0, 0, 0, -1);
					unsigned long CD = pSegDesc->TYPE;
					if (CD&0x8)
						SetItemText(pItem, 1, pSegDesc->D?WSTR("Code32  "):WSTR("Code16  "));
					else	SetItemText(pItem, 1, pSegDesc->D?WSTR("Data32  "):WSTR("Data16  "));

					TSPrintf(display, WSTR("%08X"), dwSegmentBase);
					SetItemText(pItem, 2, display);

					TSPrintf(display, WSTR("%08X"), dwSegmentLimit);
					SetItemText(pItem, 3, display);

					TSPrintf(display, WSTR("%d"), pSegDesc->DPL);
					SetItemText(pItem, 4, display);

					unsigned long TYPE = pSegDesc->TYPE;
					if (TYPE&0x8)
						TSPrintf(display, WSTR("P  %s %s"), (TYPE&2)?WSTR("RE"):WSTR("EO"), (TYPE&4)?WSTR("C "):WSTR(" "));
					else	TSPrintf(display, WSTR("P  %s %s"), (TYPE&2)?WSTR("RW"):WSTR("RO"), (TYPE&4)?WSTR("ED"):WSTR(" "));
					SetItemText(pItem, 5, display);
				}
			} else
			{
				TSPrintf(display, WSTR("%04X"), dwSelector);
				CListStringItem *pItem = InsertItem(display, 0, 0, 0, -1);
				SetItemText(pItem, 1, DescType[pSegDesc->TYPE]);
				TSPrintf(display, WSTR("%08X"), dwSegmentBase);
				SetItemText(pItem, 2, display);
				TSPrintf(display, WSTR("%08X"), dwSegmentLimit);
				SetItemText(pItem, 3, display);
				TSPrintf(display, WSTR("%d"), pSegDesc->DPL);
				SetItemText(pItem, 4, display);
				SetItemText(pItem, 5, WSTR("NP      "));
			}
			++pSegDesc;
		}

		return true;
	}

	void CGDTWnd::InitContext()
	{
		DeleteAllChildrenItems(0);
		InsertGDT();
	}

	void CGDTWnd::Create()
	{
		if (IsWindow())
		{
			Destroy();
		} else
		{
			WISP_RECT Rect;
			Rect.x = 0;
			Rect.y = 0;
			Rect.cx = 540;
			Rect.cy = 350;
			CreateWnd(WSTR("GDT"), Rect, 0, 0, 0x100BB, WISP_SH_MINSIZE);
			Center(0);
		}
	}

```

`source/WispSyser/gdtwnd.hpp`:

```hpp

#ifndef _GDTWND_HPP_
#define _GDTWND_HPP_

#include "../Wisp/wisplist.hpp"

struct CGDTWnd : public CWispList
{
	void *m_pGDTAddress;
	unsigned long m_dwGDTSize;
	unsigned long m_dwBeginIndex;

	CGDTWnd();
	virtual ~CGDTWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
        bool OnCreate(WISP_MSG *pMsg);
        bool OnClose(WISP_MSG *pMsg);

	bool InsertGDT();
	void InitContext();
	void Create();
};

#endif

```

`source/WispSyser/genereglist.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "genereglist.hpp"
#include "syserconfig.hpp"
#include "resource.hpp"

enum
{
  GL_REG = 0,
  GL_VALUE = 1,
  GL_CONTEXT = 2,
};

WISP_MENU_GROUP_ITEM GeneRegListPopupMenu[] =
{
	{WSTR("Show Code "), EVENT_ID_SHOW_CODE, 0xE0, 0, 0},
	{WSTR("Show Data "), EVENT_ID_SHOW_DATA, 0xDF, 0, 0},
	{0},
};

	WISP_MSG_MAP_BEGIN(CGeneRegList)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
//		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	WISP_EVENT_MAP_BEGIN(CGeneRegList)
		WISP_EVENT_MAP(EVENT_ID_CAX_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_CBX_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_CCX_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_CDX_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_CSP_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_CBP_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_CSI_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_CDI_DATA, OnEventGotoData)
	#ifdef _X64_
		WISP_EVENT_MAP(EVENT_ID_R8_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_R9_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_R10_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_R11_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_R12_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_R13_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_R14_DATA, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_R15_DATA, OnEventGotoData)
	#endif
		WISP_EVENT_MAP(EVENT_ID_CIP_DATA, OnEventGotoData)

		WISP_EVENT_MAP(EVENT_ID_CAX_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_CBX_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_CCX_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_CDX_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_CSP_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_CBP_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_CSI_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_CDI_CODE, OnEventGotoCode)
	#ifdef _X64_
		WISP_EVENT_MAP(EVENT_ID_R8_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_R9_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_R10_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_R11_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_R12_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_R13_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_R14_CODE, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_R15_CODE, OnEventGotoCode)
	#endif
		WISP_EVENT_MAP(EVENT_ID_CIP_CODE, OnEventGotoCode)

		WISP_EVENT_MAP(EVENT_ID_SHOW_CODE, OnEventCode)

		WISP_EVENT_MAP(EVENT_ID_SHOW_DATA, OnEventData)
	WISP_EVENT_MAP_END


	CGeneRegList::CGeneRegList()
	{
	}
	CGeneRegList::~CGeneRegList()
	{
	}

	bool CGeneRegList::OnUpdate(WISP_MSG *pMsg)
	{
		m_ColorChanges = gSyserColors.Color[4];
		m_ColorSame = gSyserColors.Color[1];
		m_ColorFocus = gSyserColors.Color[2];

		if (m_Style & 1)
		{
			AttachTitleDIB(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x34));
		}
		m_ItemColor = m_ColorSame;
		SetBGColor(gSyserColors.Color[0]);
		UpdateItemColor(0);
	//	for (int i = 0; i < REG_GENE_REGCOUNT; ++i)
	//	{
	//		SetItemColor(m_hGeneRegItem[i], GL_REG, m_ItemColor);
	//	}
		return true;//CWispWnd::OnUpdate(pMsg);
	}

	bool CGeneRegList::OnCreate(WISP_MSG *pMsg)
	{
		m_ColorChanges = gSyserColors.Color[4];
		m_ColorSame = gSyserColors.Color[1];
		m_ColorFocus = gSyserColors.Color[2];

		memcpy(&m_CPUREGPTR, &gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR, sizeof(m_CPUREGPTR));

		if (m_Style & 1)
		{
			AttachTitleDIB(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x34));
		}
		m_ItemColor = m_ColorSame;
		SetBGColor(gSyserColors.Color[0]);
		m_PopupMenu.LoadPopupMenuGroup(GeneRegListPopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		m_MenuItemShowCode = m_PopupMenu.GetItem(EVENT_ID_SHOW_CODE);
		m_MenuItemShowData = m_PopupMenu.GetItem(EVENT_ID_SHOW_DATA);

		int Ext = m_ClientDC.GetTextExtent(WSTR("X"), -1, 0);

		InsertColumn(WSTR("Register"), 9 * Ext, 0, 0, -1);
		InsertColumn(WSTR("Value[F2]"), (2+ADDR_SIZE) * Ext, 1, 0, -1);
		InsertColumn(WSTR("Context"), 100, 0, 0, -1);
	#ifdef _X64_
		m_hGeneRegItem[REG_GENE_CAX] = InsertItem(WSTR("RAX"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CBX] = InsertItem(WSTR("RBX"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CCX] = InsertItem(WSTR("RCX"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CDX] = InsertItem(WSTR("RDX"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CSI] = InsertItem(WSTR("RSI"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CDI] = InsertItem(WSTR("RDI"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CBP] = InsertItem(WSTR("RBP"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CSP] = InsertItem(WSTR("RSP"), 0, 0, 0, -1);

		m_hGeneRegItem[REG_GENE_R8] = InsertItem(WSTR("R8"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_R9] = InsertItem(WSTR("R9"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_R10] = InsertItem(WSTR("R10"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_R11] = InsertItem(WSTR("R11"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_R12] = InsertItem(WSTR("R12"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_R13] = InsertItem(WSTR("R13"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_R14] = InsertItem(WSTR("R14"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_R15] = InsertItem(WSTR("R15"), 0, 0, 0, -1);

		m_hGeneRegItem[REG_GENE_CIP] = InsertItem(WSTR("RIP"), 0, 0, 0, -1);
	#else
		m_hGeneRegItem[REG_GENE_CAX] = InsertItem(WSTR("EAX"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CBX] = InsertItem(WSTR("EBX"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CCX] = InsertItem(WSTR("ECX"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CDX] = InsertItem(WSTR("EDX"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CSI] = InsertItem(WSTR("ESI"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CDI] = InsertItem(WSTR("EDI"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CBP] = InsertItem(WSTR("EBP"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CSP] = InsertItem(WSTR("ESP"), 0, 0, 0, -1);

		m_hGeneRegItem[REG_GENE_CIP] = InsertItem(WSTR("EIP"), 0, 0, 0, -1);
	#endif
		m_hGeneRegItem[REG_GENE_EFLAG] = InsertItem(WSTR("EFLAG"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_AF] = InsertItem(WSTR("AF"), m_hGeneRegItem[REG_GENE_EFLAG], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_CF] = InsertItem(WSTR("CF"), m_hGeneRegItem[REG_GENE_EFLAG], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_DF] = InsertItem(WSTR("DF"), m_hGeneRegItem[REG_GENE_EFLAG], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_IF] = InsertItem(WSTR("IF"), m_hGeneRegItem[REG_GENE_EFLAG], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_OF] = InsertItem(WSTR("OF"), m_hGeneRegItem[REG_GENE_EFLAG], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_PF] = InsertItem(WSTR("PF"), m_hGeneRegItem[REG_GENE_EFLAG], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_SF] = InsertItem(WSTR("SF"), m_hGeneRegItem[REG_GENE_EFLAG], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_ZF] = InsertItem(WSTR("ZF"), m_hGeneRegItem[REG_GENE_EFLAG], 0, 0, -1);

		m_hGeneRegItem[REG_GENE_CS] = InsertItem(WSTR("CS"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_DS] = InsertItem(WSTR("DS"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_ES] = InsertItem(WSTR("ES"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_FS] = InsertItem(WSTR("FS"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_GS] = InsertItem(WSTR("GS"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_SS] = InsertItem(WSTR("SS"), 0, 0, 0, -1);

		m_hGeneRegItem[REG_GENE_BASE_CS] = InsertItem(WSTR("Base"), m_hGeneRegItem[REG_GENE_CS], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_BASE_DS] = InsertItem(WSTR("Base"), m_hGeneRegItem[REG_GENE_DS], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_BASE_ES] = InsertItem(WSTR("Base"), m_hGeneRegItem[REG_GENE_ES], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_BASE_FS] = InsertItem(WSTR("Base"), m_hGeneRegItem[REG_GENE_FS], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_BASE_GS] = InsertItem(WSTR("Base"), m_hGeneRegItem[REG_GENE_GS], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_BASE_SS] = InsertItem(WSTR("Base"), m_hGeneRegItem[REG_GENE_SS], 0, 0, -1);
	#ifdef _RING0_
		m_hGeneRegItem[REG_GENE_GDTR] = InsertItem(WSTR("GDTR"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_IDTR] = InsertItem(WSTR("IDTR"), 0, 0, 0, -1);

		m_hGeneRegItem[REG_GENE_LDTR] = InsertItem(WSTR("LDTR"), 0, 0, 0, -1);
		m_hGeneRegItem[REG_GENE_TR] = InsertItem(WSTR("TR"), 0, 0, 0, -1);

		m_hGeneRegItem[REG_GENE_BASE_GDTR] = InsertItem(WSTR("Base"), m_hGeneRegItem[REG_GENE_GDTR], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_LIMIT_GDTR] = InsertItem(WSTR("Limit"), m_hGeneRegItem[REG_GENE_GDTR], 0, 0, -1);

		m_hGeneRegItem[REG_GENE_BASE_IDTR] = InsertItem(WSTR("Base"), m_hGeneRegItem[REG_GENE_IDTR], 0, 0, -1);
		m_hGeneRegItem[REG_GENE_LIMIT_IDTR] = InsertItem(WSTR("Limit"), m_hGeneRegItem[REG_GENE_IDTR], 0, 0, -1);
	#endif
		m_pEditItem = m_hGeneRegItem[REG_GENE_CAX];

		for (int i = 0; i < REG_GENE_REGCOUNT; ++i)
		{
			SetItemValue(m_hGeneRegItem[i], 0, i);
		}
		ResetContext();
		LoadKeyMap();
		return true;
	}
	bool CGeneRegList::OnClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}
	bool CGeneRegList::OnDestroy(WISP_MSG *pMsg)
	{
		m_PopupMenu.Destroy();
		return true;
	}

//	bool CGeneRegList::OnGetFocus(WISP_MSG *pMsg)
//	{
//		CListStringItem *Item = GetNext(0, 0);
//		if (Item)
//		{
//			Select(Item);
//		}
//		return true;
//	}

	bool CGeneRegList::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen) return true;
		if (pMsg->KeyEvent.bKeyDown) return true;

		map<unsigned int, unsigned int>::IT it = m_KeyMap.find(pMsg->KeyEvent.KeyType);
		if (it != m_KeyMap.end())
		{
			WISP_MSG Msg;
			Msg.Command.CmdID = it->second;
			return OnEvent(&Msg);
		}
		int Size;
		switch (pMsg->KeyEvent.KeyType)
		{
		case VK_RBUTTON:{
			CListStringItem *Item = FullFindItem(0, 8);
			bool bRead = false;
			if (Item)
			{
				ULONG_PTR Addr = GetItemValue(Item, GL_VALUE);
				unsigned char Byte;
				if (gpSyser->m_pDebugger->ReadMemory(Addr, &Byte, 1) == 1)
					bRead = true;
				CListStringItem::CONTENT *Content = GetItemContent(Item, GL_VALUE);
				WCHAR Buffer[128];
				TStrCpy(Buffer, WSTR("Show Code "));
				TStrCat(Buffer, Content->String.operator const WCHAR*());
				m_PopupMenu.SetItemText(m_MenuItemShowCode, Buffer);
				TStrCpy(Buffer, WSTR("Show Data "));
				TStrCat(Buffer, Content->String.operator const WCHAR*());
				m_PopupMenu.SetItemText(m_MenuItemShowData, Buffer);
			}
			m_PopupMenu.Enable(m_MenuItemShowCode, bRead);
			m_PopupMenu.Enable(m_MenuItemShowData, Item && bRead);
			m_PopupMenu.Point(0, 1);
			}break;
		case 0x41: //'A'
			gpSyser->m_MainFrame.m_SystemExplorer.m_MainSplitWnd.GetSize(0, &Size);
			if (Size <= 10)
				Size = 0;
			else	Size -= 10;
			gpSyser->m_MainFrame.m_SystemExplorer.m_MainSplitWnd.SetSize(0, Size);
			gpSyser->m_MainFrame.m_SystemExplorer.m_MainSplitWnd.AdjustWndPos();
			return false;
			break;
		case 0x44: //'D'
			gpSyser->m_MainFrame.m_SystemExplorer.m_MainSplitWnd.GetSize(0, &Size);
			Size += 10;
			gpSyser->m_MainFrame.m_SystemExplorer.m_MainSplitWnd.SetSize(0, Size);
			gpSyser->m_MainFrame.m_SystemExplorer.m_MainSplitWnd.AdjustWndPos();
			return false;
			break;
		case 0x53: //'S'
			gpSyser->m_MainFrame.m_SystemExplorer.m_MoniteSplitWnd.GetSize(0, &Size);
			Size += 10;
			gpSyser->m_MainFrame.m_SystemExplorer.m_MoniteSplitWnd.SetSize(0, Size);
			gpSyser->m_MainFrame.m_SystemExplorer.m_MoniteSplitWnd.AdjustWndPos();
			return false;
			break;
		case 0x57: //'W'
			gpSyser->m_MainFrame.m_SystemExplorer.m_MoniteSplitWnd.GetSize(0, &Size);
			if (Size <= 10)
				Size = 0;
			else	Size -= 10;
			gpSyser->m_MainFrame.m_SystemExplorer.m_MoniteSplitWnd.SetSize(0, Size);
			gpSyser->m_MainFrame.m_SystemExplorer.m_MoniteSplitWnd.AdjustWndPos();
			return false;
			break;
		case VK_F2: {
			CListStringItem *Item = FullFindItem(0, 8);
			if (Item)
			{
				Scroll(Item, -1);
				EditItem(Item, GL_VALUE);
			}
			return false;
			} break;
		}
		return true;
	}

	bool CGeneRegList::OnEventGotoData(WISP_MSG *pMsg)
	{
		switch (pMsg->Command.CmdID)
		{
		case EVENT_ID_CAX_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pCAX, 0); break;
		case EVENT_ID_CBX_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pCBX, 0); break;
		case EVENT_ID_CCX_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pCCX, 0); break;
		case EVENT_ID_CDX_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pCDX, 0); break;
		case EVENT_ID_CSP_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pCSP, 0); break;
		case EVENT_ID_CBP_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pCBP, 0); break;
		case EVENT_ID_CSI_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pCSI, 0); break;
		case EVENT_ID_CDI_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pCDI, 0); break;
	#ifdef _X64_
		case EVENT_ID_R8_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pR8, 0); break;
		case EVENT_ID_R9_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pR9, 0); break;
		case EVENT_ID_R10_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pR10, 0); break;
		case EVENT_ID_R11_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pR11, 0); break;
		case EVENT_ID_R12_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pR12, 0); break;
		case EVENT_ID_R13_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pR13, 0); break;
		case EVENT_ID_R14_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pR14, 0); break;
		case EVENT_ID_R15_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pR15, 0); break;
	#endif
		case EVENT_ID_CIP_DATA: gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(*m_CPUREGPTR.pCIP, 0); break;
		}
		return true;
	}

	bool CGeneRegList::OnEventGotoCode(WISP_MSG *pMsg)
	{
		switch (pMsg->Command.CmdID)
		{
		case EVENT_ID_CAX_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pCAX, true); break;
		case EVENT_ID_CBX_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pCBX, true); break;
		case EVENT_ID_CCX_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pCCX, true); break;
		case EVENT_ID_CDX_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pCDX, true); break;
		case EVENT_ID_CSP_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pCSP, true); break;
		case EVENT_ID_CBP_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pCBP, true); break;
		case EVENT_ID_CSI_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pCSI, true); break;
		case EVENT_ID_CDI_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pCDI, true); break;
	#ifdef _X64_
		case EVENT_ID_R8_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pR8, true); break;
		case EVENT_ID_R9_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pR9, true); break;
		case EVENT_ID_R10_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pR10, true); break;
		case EVENT_ID_R11_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pR11, true); break;
		case EVENT_ID_R12_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pR12, true); break;
		case EVENT_ID_R13_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pR13, true); break;
		case EVENT_ID_R14_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pR14, true); break;
		case EVENT_ID_R15_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pR15, true); break;
	#endif
		case EVENT_ID_CIP_CODE: gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(*m_CPUREGPTR.pCIP, true); break;
		}
		return true;
	}

	bool CGeneRegList::OnEventCode(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FullFindItem(0, 8);
		if (Item)
		{
			CListStringItem::CONTENT *Content = GetItemContent(Item, GL_VALUE);
			ULONG_PTR Addr;
			if (USHexStrToNum(Content->String.operator const WCHAR*(), &Addr))
			{
				gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(Addr, true);
			}
		}
		return true;
	}

	bool CGeneRegList::OnEventData(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FullFindItem(0, 8);
		if (Item)
		{
			CListStringItem::CONTENT *Content = GetItemContent(Item, GL_VALUE);
			ULONG_PTR Addr;
			if (USHexStrToNum(Content->String.operator const WCHAR*(), &Addr))
			{
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
			}
		}
		return true;
	}

	void CGeneRegList::OnLButton(CListStringItem *Item, int nCol)
	{
		if (nCol == GL_REG)
		{
			CListStringItem::CONTENT *Content = GetItemContent(Item, GL_VALUE);
			ULONG_PTR Addr;
			if (USHexStrToNum(Content->String.operator const WCHAR*(), &Addr))
			{
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
			}
		}
	}

	bool CGeneRegList::Edit(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen || GetActiveCPU() != m_nCPU)
			return false;

		int Index = GetItemValue(Item, GL_REG);
		if (Index < REG_GENE_AF || Index > REG_GENE_ZF)
			return true;

		bool bValue = false;
		bool bEqual = false;
		switch (Index)
		{
		case REG_GENE_AF:
			m_CPUREGPTR.pEFL->AF = !m_CPUREGPTR.pEFL->AF;
			bValue = m_CPUREGPTR.pEFL->AF;
			bEqual = m_CPUREGPTR.pEFL->AF == m_CPUREG.EFL.AF;
			break;
		case REG_GENE_CF:
			m_CPUREGPTR.pEFL->CF = !m_CPUREGPTR.pEFL->CF;
			bValue = m_CPUREGPTR.pEFL->CF;
			bEqual = m_CPUREGPTR.pEFL->CF == m_CPUREG.EFL.CF;
			break;
		case REG_GENE_DF:
			m_CPUREGPTR.pEFL->DF = !m_CPUREGPTR.pEFL->DF;
			bValue = m_CPUREGPTR.pEFL->DF;
			bEqual = m_CPUREGPTR.pEFL->DF == m_CPUREG.EFL.DF;
			break;
		case REG_GENE_IF:
			//IF flag can't modify from EFLAGS
			return false;
			m_CPUREGPTR.pEFL->IF = !m_CPUREGPTR.pEFL->IF;
			bValue = m_CPUREGPTR.pEFL->IF;
			bEqual = m_CPUREGPTR.pEFL->IF == m_CPUREG.EFL.IF;
			break;
		case REG_GENE_OF:
			m_CPUREGPTR.pEFL->OF = !m_CPUREGPTR.pEFL->OF;
			bValue = m_CPUREGPTR.pEFL->OF;
			bEqual = m_CPUREGPTR.pEFL->OF == m_CPUREG.EFL.OF;
			break;
		case REG_GENE_PF:
			m_CPUREGPTR.pEFL->PF = !m_CPUREGPTR.pEFL->PF;
			bValue = m_CPUREGPTR.pEFL->PF;
			bEqual = m_CPUREGPTR.pEFL->PF == m_CPUREG.EFL.PF;
			break;
		case REG_GENE_SF:
			m_CPUREGPTR.pEFL->SF = !m_CPUREGPTR.pEFL->SF;
			bValue = m_CPUREGPTR.pEFL->SF;
			bEqual = m_CPUREGPTR.pEFL->SF == m_CPUREG.EFL.SF;
			break;
		case REG_GENE_ZF:
			m_CPUREGPTR.pEFL->ZF = !m_CPUREGPTR.pEFL->ZF;
			bValue = m_CPUREGPTR.pEFL->ZF;
			bEqual = m_CPUREGPTR.pEFL->ZF == m_CPUREG.EFL.ZF;
			break;
		}

		SetItemFormat(m_hGeneRegItem[REG_GENE_EFLAG], GL_VALUE, *(unsigned long*)m_CPUREGPTR.pEFL, WSTR("%08X"));
		SetItemColor(m_hGeneRegItem[REG_GENE_EFLAG], GL_VALUE, (*(unsigned long*)m_CPUREGPTR.pEFL == *(unsigned long*)&m_CPUREG.EFL)?m_ColorSame:m_ColorChanges);

		SetItemText(m_hGeneRegItem[Index], GL_VALUE, bValue ? WSTR("1"):WSTR("0"));
		SetItemColor(m_hGeneRegItem[Index], GL_VALUE, bEqual ? m_ColorSame:m_ColorChanges);

		Update(&m_ClientRect);
		gpSyser->m_pDebugger->UpdateRegisters();
		gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
		return false;
	}

	bool CGeneRegList::OnEditing(CListStringItem *Item, int nCol, TWideString& String)
	{
		ULONG_PTR Result;
		if (!gpSyser->m_SyserUI.CalcExp(String.operator const WCHAR*(), &Result))
			return false;

		int Index = GetItemValue(Item, GL_REG);
		if (Index < REG_GENE_CAX || Index >= REG_GENE_REGCOUNT)
			return false;

		ULONG_PTR *pReg = 0;
		switch (Index)
		{
		case REG_GENE_CAX: pReg = m_CPUREGPTR.pCAX; break;
		case REG_GENE_CBX: pReg = m_CPUREGPTR.pCBX; break;
		case REG_GENE_CCX: pReg = m_CPUREGPTR.pCCX; break;
		case REG_GENE_CDX: pReg = m_CPUREGPTR.pCDX; break;
		case REG_GENE_CSI: pReg = m_CPUREGPTR.pCSI; break;
		case REG_GENE_CDI: pReg = m_CPUREGPTR.pCDI; break;
		case REG_GENE_CBP: pReg = m_CPUREGPTR.pCBP; break;
		case REG_GENE_CSP: pReg = m_CPUREGPTR.pCSP; break;
	#ifdef _X64_
		case REG_GENE_R8: pReg = m_CPUREGPTR.pR8; break;
		case REG_GENE_R9: pReg = m_CPUREGPTR.pR9; break;
		case REG_GENE_R10: pReg = m_CPUREGPTR.pR10; break;
		case REG_GENE_R11: pReg = m_CPUREGPTR.pR11; break;
		case REG_GENE_R12: pReg = m_CPUREGPTR.pR12; break;
		case REG_GENE_R13: pReg = m_CPUREGPTR.pR13; break;
		case REG_GENE_R14: pReg = m_CPUREGPTR.pR14; break;
		case REG_GENE_R15: pReg = m_CPUREGPTR.pR15; break;
	#endif
		case REG_GENE_CIP: pReg = m_CPUREGPTR.pCIP; break;
		case REG_GENE_EFLAG: pReg = (ULONG_PTR*)m_CPUREGPTR.pEFL; break;
		default:
			return false;
		}

		//copy IF flag
		if (Index == REG_GENE_EFLAG)
		{
			if (*pReg & 0x200)
				Result |= 0x200;
			else	Result &= ~0x200;
		}

		if (*pReg == Result)
			return false;

		*pReg = Result;

		SetItemColor(m_hGeneRegItem[Index], GL_VALUE, m_ColorChanges);
		if (Index == REG_GENE_EFLAG)
			String.Format(WSTR("%08X"), (unsigned long)*pReg);
		else	String.Format(WSTR("" F0ADDR "X"), *pReg);
		gpSyser->m_pDebugger->UpdateRegisters();
		if (Index == REG_GENE_EFLAG)
		{
			UpdateFlags();
		} else
		if (Index == REG_GENE_CIP)
		{
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		}
		m_pEditItem = m_hGeneRegItem[Index];
		gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
		return true;
	}

	void CGeneRegList::ResetContext()
	{
		if (IsWindow())
		{
			for (int i = 0; i < REG_GENE_REGCOUNT; ++i)
			{
				switch (i)
				{
				case REG_GENE_CAX:
				case REG_GENE_CBX:
				case REG_GENE_CCX:
				case REG_GENE_CDX:
				case REG_GENE_CSI:
				case REG_GENE_CDI:
				case REG_GENE_CBP:
				case REG_GENE_CSP:
			#ifdef _X64_
				case REG_GENE_R8:
				case REG_GENE_R9:
				case REG_GENE_R10:
				case REG_GENE_R11:
				case REG_GENE_R12:
				case REG_GENE_R13:
				case REG_GENE_R14:
				case REG_GENE_R15:
			#endif
				case REG_GENE_CIP:
					SetItemText(m_hGeneRegItem[i], GL_VALUE, WSTR("" UNREADSTR ""));
					break;
				case REG_GENE_CS:
				case REG_GENE_DS:
				case REG_GENE_ES:
				case REG_GENE_FS:
				case REG_GENE_GS:
				case REG_GENE_SS:
					SetItemText(m_hGeneRegItem[i], GL_VALUE, WSTR("????"));
					break;
				case REG_GENE_AF:
				case REG_GENE_CF:
				case REG_GENE_DF:
				case REG_GENE_IF:
				case REG_GENE_OF:
				case REG_GENE_PF:
				case REG_GENE_SF:
				case REG_GENE_ZF:
					SetItemText(m_hGeneRegItem[i], GL_VALUE, WSTR("?"));
					break;
				case REG_GENE_EFLAG:
				case REG_GENE_BASE_CS:
				case REG_GENE_BASE_DS:
				case REG_GENE_BASE_ES:
				case REG_GENE_BASE_FS:
				case REG_GENE_BASE_GS:
				case REG_GENE_BASE_SS:
					SetItemText(m_hGeneRegItem[i], GL_VALUE, WSTR("????????"));
					break;
				}
				SetItemText(m_hGeneRegItem[i], GL_CONTEXT, (WCHAR*)0);
				SetItemColor(m_hGeneRegItem[i], GL_VALUE, m_ColorSame);

			}
			Select(m_hGeneRegItem[REG_GENE_CAX]);
			memset(&m_CPUREG, 0, sizeof(m_CPUREG));
		}
	}

	void CGeneRegList::UpdateFlags()
	{
		SetItemText(m_hGeneRegItem[REG_GENE_AF], GL_VALUE, m_CPUREGPTR.pEFL->AF ? WSTR("1"):WSTR("0"));
		SetItemColor(m_hGeneRegItem[REG_GENE_AF], GL_VALUE, (m_CPUREG.EFL.AF ^ m_CPUREGPTR.pEFL->AF) ? m_ColorChanges:m_ColorSame);

		SetItemText(m_hGeneRegItem[REG_GENE_CF], GL_VALUE, m_CPUREGPTR.pEFL->CF ? WSTR("1"):WSTR("0"));
		SetItemColor(m_hGeneRegItem[REG_GENE_CF], GL_VALUE, (m_CPUREG.EFL.CF ^ m_CPUREGPTR.pEFL->CF) ? m_ColorChanges:m_ColorSame);

		SetItemText(m_hGeneRegItem[REG_GENE_DF], GL_VALUE, m_CPUREGPTR.pEFL->DF ? WSTR("1"):WSTR("0"));
		SetItemColor(m_hGeneRegItem[REG_GENE_DF], GL_VALUE, (m_CPUREG.EFL.DF ^ m_CPUREGPTR.pEFL->DF) ? m_ColorChanges:m_ColorSame);

		SetItemText(m_hGeneRegItem[REG_GENE_IF], GL_VALUE, m_CPUREGPTR.pEFL->IF ? WSTR("1"):WSTR("0"));
		SetItemColor(m_hGeneRegItem[REG_GENE_IF], GL_VALUE, (m_CPUREG.EFL.IF ^ m_CPUREGPTR.pEFL->IF) ? m_ColorChanges:m_ColorSame);

		SetItemText(m_hGeneRegItem[REG_GENE_OF], GL_VALUE, m_CPUREGPTR.pEFL->OF ? WSTR("1"):WSTR("0"));
		SetItemColor(m_hGeneRegItem[REG_GENE_OF], GL_VALUE, (m_CPUREG.EFL.OF ^ m_CPUREGPTR.pEFL->OF) ? m_ColorChanges:m_ColorSame);

		SetItemText(m_hGeneRegItem[REG_GENE_PF], GL_VALUE, m_CPUREGPTR.pEFL->PF ? WSTR("1"):WSTR("0"));
		SetItemColor(m_hGeneRegItem[REG_GENE_PF], GL_VALUE, (m_CPUREG.EFL.PF ^ m_CPUREGPTR.pEFL->PF) ? m_ColorChanges:m_ColorSame);

		SetItemText(m_hGeneRegItem[REG_GENE_SF], GL_VALUE, m_CPUREGPTR.pEFL->SF ? WSTR("1"):WSTR("0"));
		SetItemColor(m_hGeneRegItem[REG_GENE_SF], GL_VALUE, (m_CPUREG.EFL.SF ^ m_CPUREGPTR.pEFL->SF) ? m_ColorChanges:m_ColorSame);

		SetItemText(m_hGeneRegItem[REG_GENE_ZF], GL_VALUE, m_CPUREGPTR.pEFL->ZF ? WSTR("1"):WSTR("0"));
		SetItemColor(m_hGeneRegItem[REG_GENE_ZF], GL_VALUE, (m_CPUREG.EFL.ZF ^ m_CPUREGPTR.pEFL->ZF) ? m_ColorChanges:m_ColorSame);
	}

	void CGeneRegList::ReadString(X86_CPU_REG_PTR *pCPURegPtr)
	{
		WCHAR Buffer[256];
		char szSym[256];
		char Encode;

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pCAX, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pCAX, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pCAX, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CAX], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pCBX, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pCBX, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pCBX, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CBX], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pCCX, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pCCX, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pCCX, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CCX], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pCDX, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pCDX, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pCDX, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CDX], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pCSI, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pCSI, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pCSI, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CSI], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pCDI, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pCDI, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pCDI, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CDI], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pCBP, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pCBP, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pCBP, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CBP], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		//if (*m_CPUREGPTR.pESP == 0x7FFB8)
                //	Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pCSP, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pCSP, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pCSP, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CSP], GL_CONTEXT, Buffer);
	#ifdef _X64_
		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pR8, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pR8, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pR8, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R8], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pR9, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pR9, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pR9, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R9], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pR10, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pR10, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pR10, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R10], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pR11, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pR11, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pR11, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R11], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pR12, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pR12, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pR12, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R12], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pR13, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pR13, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pR13, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R13], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pR14, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pR14, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pR14, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R14], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(*pCPURegPtr->pR15, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(*pCPURegPtr->pR15, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pR15, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R15], GL_CONTEXT, Buffer);
	#endif
		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbolOffset(*pCPURegPtr->pCIP, szSym))
			TStrCpy(Buffer, szSym);
		SetItemText(m_hGeneRegItem[REG_GENE_CIP], GL_CONTEXT, Buffer);
	}

	void CGeneRegList::UpdateContext()
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && IsWindow())
		{
			if (GetActiveCPU() == m_nCPU)
				memcpy(&m_CPUREGPTR, &gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR, sizeof(m_CPUREGPTR));
			else	gpSyser->m_pDebugger->GetX86RegPtr(&m_CPUREGPTR, m_nCPU);

			SetItemFormat(m_hGeneRegItem[REG_GENE_CAX], GL_VALUE, *m_CPUREGPTR.pCAX, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_CAX], GL_VALUE, *m_CPUREGPTR.pCAX);
			SetItemColor(m_hGeneRegItem[REG_GENE_CAX], GL_VALUE, (*m_CPUREGPTR.pCAX == m_CPUREG.CAX)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_CBX], GL_VALUE, *m_CPUREGPTR.pCBX, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_CBX], GL_VALUE, *m_CPUREGPTR.pCBX);
			SetItemColor(m_hGeneRegItem[REG_GENE_CBX], GL_VALUE, (*m_CPUREGPTR.pCBX == m_CPUREG.CBX)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_CCX], GL_VALUE, *m_CPUREGPTR.pCCX, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_CCX], GL_VALUE, *m_CPUREGPTR.pCCX);
			SetItemColor(m_hGeneRegItem[REG_GENE_CCX], GL_VALUE, (*m_CPUREGPTR.pCCX == m_CPUREG.CCX)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_CDX], GL_VALUE, *m_CPUREGPTR.pCDX, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_CDX], GL_VALUE, *m_CPUREGPTR.pCDX);
			SetItemColor(m_hGeneRegItem[REG_GENE_CDX], GL_VALUE, (*m_CPUREGPTR.pCDX == m_CPUREG.CDX)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_CSI], GL_VALUE, *m_CPUREGPTR.pCSI, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_CSI], GL_VALUE, *m_CPUREGPTR.pCSI);
			SetItemColor(m_hGeneRegItem[REG_GENE_CSI], GL_VALUE, (*m_CPUREGPTR.pCSI == m_CPUREG.CSI)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_CDI], GL_VALUE, *m_CPUREGPTR.pCDI, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_CDI], GL_VALUE, *m_CPUREGPTR.pCDI);
			SetItemColor(m_hGeneRegItem[REG_GENE_CDI], GL_VALUE, (*m_CPUREGPTR.pCDI == m_CPUREG.CDI)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_CBP], GL_VALUE, *m_CPUREGPTR.pCBP, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_CBP], GL_VALUE, *m_CPUREGPTR.pCBP);
			SetItemColor(m_hGeneRegItem[REG_GENE_CBP], GL_VALUE, (*m_CPUREGPTR.pCBP == m_CPUREG.CBP)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_CSP], GL_VALUE, *m_CPUREGPTR.pCSP, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_CSP], GL_VALUE, *m_CPUREGPTR.pCSP);
			SetItemColor(m_hGeneRegItem[REG_GENE_CSP], GL_VALUE, (*m_CPUREGPTR.pCSP == m_CPUREG.CSP)?m_ColorSame:m_ColorChanges);
		#ifdef _X64_
			SetItemFormat(m_hGeneRegItem[REG_GENE_R8], GL_VALUE, *m_CPUREGPTR.pR8, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_R8], GL_VALUE, *m_CPUREGPTR.pR8);
			SetItemColor(m_hGeneRegItem[REG_GENE_R8], GL_VALUE, (*m_CPUREGPTR.pR8 == m_CPUREG.R8)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_R9], GL_VALUE, *m_CPUREGPTR.pR9, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_R9], GL_VALUE, *m_CPUREGPTR.pR9);
			SetItemColor(m_hGeneRegItem[REG_GENE_R9], GL_VALUE, (*m_CPUREGPTR.pR9 == m_CPUREG.R9)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_R10], GL_VALUE, *m_CPUREGPTR.pR10, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_R10], GL_VALUE, *m_CPUREGPTR.pR10);
			SetItemColor(m_hGeneRegItem[REG_GENE_R10], GL_VALUE, (*m_CPUREGPTR.pR10 == m_CPUREG.R10)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_R11], GL_VALUE, *m_CPUREGPTR.pR11, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_R11], GL_VALUE, *m_CPUREGPTR.pR11);
			SetItemColor(m_hGeneRegItem[REG_GENE_R11], GL_VALUE, (*m_CPUREGPTR.pR11 == m_CPUREG.R11)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_R12], GL_VALUE, *m_CPUREGPTR.pR12, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_R12], GL_VALUE, *m_CPUREGPTR.pR12);
			SetItemColor(m_hGeneRegItem[REG_GENE_R12], GL_VALUE, (*m_CPUREGPTR.pR12 == m_CPUREG.R12)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_R13], GL_VALUE, *m_CPUREGPTR.pR13, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_R13], GL_VALUE, *m_CPUREGPTR.pR13);
			SetItemColor(m_hGeneRegItem[REG_GENE_R13], GL_VALUE, (*m_CPUREGPTR.pR13 == m_CPUREG.R13)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_R14], GL_VALUE, *m_CPUREGPTR.pR14, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_R14], GL_VALUE, *m_CPUREGPTR.pR14);
			SetItemColor(m_hGeneRegItem[REG_GENE_R14], GL_VALUE, (*m_CPUREGPTR.pR14 == m_CPUREG.R14)?m_ColorSame:m_ColorChanges);

			SetItemFormat(m_hGeneRegItem[REG_GENE_R15], GL_VALUE, *m_CPUREGPTR.pR15, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_R15], GL_VALUE, *m_CPUREGPTR.pR15);
			SetItemColor(m_hGeneRegItem[REG_GENE_R15], GL_VALUE, (*m_CPUREGPTR.pR15 == m_CPUREG.R15)?m_ColorSame:m_ColorChanges);
		#endif
			SetItemFormat(m_hGeneRegItem[REG_GENE_CIP], GL_VALUE, *m_CPUREGPTR.pCIP, WSTR("" F0ADDR "X"));
			SetItemValue(m_hGeneRegItem[REG_GENE_CIP], GL_VALUE, *m_CPUREGPTR.pCIP);
			SetItemColor(m_hGeneRegItem[REG_GENE_CIP], GL_VALUE, (*m_CPUREGPTR.pCIP == m_CPUREG.CIP)?m_ColorSame:m_ColorChanges);

			ReadString(&m_CPUREGPTR);

			SetItemFormat(m_hGeneRegItem[REG_GENE_EFLAG], GL_VALUE, *(unsigned long*)m_CPUREGPTR.pEFL, WSTR("%08X"));
			if (*(unsigned long*)m_CPUREGPTR.pEFL == *(unsigned long*)&m_CPUREG.EFL)
				SetItemColor(m_hGeneRegItem[REG_GENE_EFLAG], GL_VALUE, m_ColorSame);
			else	SetItemColor(m_hGeneRegItem[REG_GENE_EFLAG], GL_VALUE, m_ColorChanges);

			ULONG_PTR Seg;

			SetItemFormat(m_hGeneRegItem[REG_GENE_CS], GL_VALUE, *m_CPUREGPTR.pCS, WSTR("%04X"));
			if (*m_CPUREGPTR.pCS == m_CPUREG.CS)
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_CS], GL_VALUE, m_ColorSame);
			} else
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_CS], GL_VALUE, m_ColorChanges);
				if (gpSyser->m_pDebugger->GetSegRegBase(*m_CPUREGPTR.pCS, &Seg, 0))
					SetItemFormat(m_hGeneRegItem[REG_GENE_BASE_CS], GL_VALUE, Seg, WSTR("%08X"));
				else	SetItemText(m_hGeneRegItem[REG_GENE_BASE_CS], GL_VALUE, WSTR("????????"));
			}

			SetItemFormat(m_hGeneRegItem[REG_GENE_DS], GL_VALUE, *m_CPUREGPTR.pDS, WSTR("%04X"));
			if (*m_CPUREGPTR.pDS == m_CPUREG.DS)
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_DS], GL_VALUE, m_ColorSame);
			} else
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_DS], GL_VALUE, m_ColorChanges);
				if (gpSyser->m_pDebugger->GetSegRegBase(*m_CPUREGPTR.pDS, &Seg, 0))
					SetItemFormat(m_hGeneRegItem[REG_GENE_BASE_DS], GL_VALUE, Seg, WSTR("%08X"));
				else	SetItemText(m_hGeneRegItem[REG_GENE_BASE_DS], GL_VALUE, WSTR("????????"));
			}

			SetItemFormat(m_hGeneRegItem[REG_GENE_ES], GL_VALUE, *m_CPUREGPTR.pES, WSTR("%04X"));
			if (*m_CPUREGPTR.pES == m_CPUREG.ES)
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_ES], GL_VALUE, m_ColorSame);
			} else
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_ES], GL_VALUE, m_ColorChanges);
				if (gpSyser->m_pDebugger->GetSegRegBase(*m_CPUREGPTR.pES, &Seg, 0))
				{
					SetItemFormat(m_hGeneRegItem[REG_GENE_BASE_ES], GL_VALUE, Seg, WSTR("%08X"));
					SetItemValue(m_hGeneRegItem[REG_GENE_BASE_ES], GL_VALUE, Seg);
				} else
				{
					SetItemText(m_hGeneRegItem[REG_GENE_BASE_ES], GL_VALUE, WSTR("????????"));
				}
			}

			SetItemFormat(m_hGeneRegItem[REG_GENE_FS], GL_VALUE, *m_CPUREGPTR.pFS, WSTR("%04X"));
			if (*m_CPUREGPTR.pFS == m_CPUREG.FS)
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_FS], GL_VALUE, m_ColorSame);
			} else
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_FS], GL_VALUE, m_ColorChanges);
				if (gpSyser->m_pDebugger->GetSegRegBase(*m_CPUREGPTR.pFS, &Seg, 0))
				{
					SetItemValue(m_hGeneRegItem[REG_GENE_BASE_FS], GL_VALUE, Seg);
					SetItemFormat(m_hGeneRegItem[REG_GENE_BASE_FS], GL_VALUE, Seg, WSTR("%08X"));
				} else
				{
					SetItemText(m_hGeneRegItem[REG_GENE_BASE_FS], GL_VALUE, WSTR("????????"));
				}
			}

			SetItemFormat(m_hGeneRegItem[REG_GENE_GS], GL_VALUE, *m_CPUREGPTR.pGS, WSTR("%04X"));
			if (*m_CPUREGPTR.pGS == m_CPUREG.GS)
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_GS], GL_VALUE, m_ColorSame);
			} else
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_GS], GL_VALUE, m_ColorChanges);
				if (gpSyser->m_pDebugger->GetSegRegBase(*m_CPUREGPTR.pGS, &Seg, 0))
				{
					SetItemFormat(m_hGeneRegItem[REG_GENE_BASE_GS], GL_VALUE, Seg, WSTR("%08X"));
					SetItemValue(m_hGeneRegItem[REG_GENE_BASE_GS], GL_VALUE, Seg);
				} else
				{
					SetItemText(m_hGeneRegItem[REG_GENE_BASE_GS], GL_VALUE, WSTR("????????"));
				}
			}

			SetItemFormat(m_hGeneRegItem[REG_GENE_SS], GL_VALUE, *m_CPUREGPTR.pSS, WSTR("%04X"));
			if (*m_CPUREGPTR.pSS == m_CPUREG.SS)
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_SS], GL_VALUE, m_ColorSame);
			} else
			{
				SetItemColor(m_hGeneRegItem[REG_GENE_SS], GL_VALUE, m_ColorChanges);
				if (gpSyser->m_pDebugger->GetSegRegBase(*m_CPUREGPTR.pSS, &Seg, 0))
				{
					SetItemFormat(m_hGeneRegItem[REG_GENE_BASE_SS], GL_VALUE, Seg, WSTR("%08X"));
					SetItemValue(m_hGeneRegItem[REG_GENE_BASE_SS], GL_VALUE, Seg);
				} else
				{
					SetItemText(m_hGeneRegItem[REG_GENE_BASE_SS], GL_VALUE, WSTR("????????"));
				}
			}

		#ifdef _RING0_
			SetItemFormat(m_hGeneRegItem[REG_GENE_GDTR], GL_VALUE, *m_CPUREGPTR.pGDT, WSTR("%08X"));
			SetItemFormat(m_hGeneRegItem[REG_GENE_BASE_GDTR], GL_VALUE, *m_CPUREGPTR.pGDT, WSTR("%08X"));
			SetItemFormat(m_hGeneRegItem[REG_GENE_LIMIT_GDTR], GL_VALUE, *m_CPUREGPTR.pGDTLimit, WSTR("%04X"));

			SetItemFormat(m_hGeneRegItem[REG_GENE_IDTR], GL_VALUE, *m_CPUREGPTR.pIDT, WSTR("%08X"));
			SetItemFormat(m_hGeneRegItem[REG_GENE_BASE_IDTR], GL_VALUE, *m_CPUREGPTR.pIDT, WSTR("%08X"));
			SetItemFormat(m_hGeneRegItem[REG_GENE_LIMIT_IDTR], GL_VALUE, *m_CPUREGPTR.pIDTLimit, WSTR("%04X"));

			SetItemFormat(m_hGeneRegItem[REG_GENE_LDTR], GL_VALUE, *m_CPUREGPTR.pLDT, WSTR("%04X"));
			SetItemFormat(m_hGeneRegItem[REG_GENE_TR], GL_VALUE, *m_CPUREGPTR.pTSS, WSTR("%04X"));
		#endif
			UpdateFlags();

			m_CPUREG.CAX = *m_CPUREGPTR.pCAX;
			m_CPUREG.CBX = *m_CPUREGPTR.pCBX;
			m_CPUREG.CCX = *m_CPUREGPTR.pCCX;
			m_CPUREG.CDX = *m_CPUREGPTR.pCDX;
			m_CPUREG.CDI = *m_CPUREGPTR.pCDI;
			m_CPUREG.CSI = *m_CPUREGPTR.pCSI;
			m_CPUREG.CBP = *m_CPUREGPTR.pCBP;
			m_CPUREG.CSP = *m_CPUREGPTR.pCSP;
		#ifdef _X64_
			m_CPUREG.R8 = *m_CPUREGPTR.pR8;
			m_CPUREG.R9 = *m_CPUREGPTR.pR9;
			m_CPUREG.R10 = *m_CPUREGPTR.pR10;
			m_CPUREG.R11 = *m_CPUREGPTR.pR11;
			m_CPUREG.R12 = *m_CPUREGPTR.pR12;
			m_CPUREG.R13 = *m_CPUREGPTR.pR13;
			m_CPUREG.R14 = *m_CPUREGPTR.pR14;
			m_CPUREG.R15 = *m_CPUREGPTR.pR15;
		#endif
			m_CPUREG.CIP = *m_CPUREGPTR.pCIP;

			*(unsigned long*)&m_CPUREG.EFL = *(unsigned long*)m_CPUREGPTR.pEFL;

			m_CPUREG.CS = *m_CPUREGPTR.pCS;
			m_CPUREG.DS = *m_CPUREGPTR.pDS;
			m_CPUREG.ES = *m_CPUREGPTR.pES;
			m_CPUREG.FS = *m_CPUREGPTR.pFS;
			m_CPUREG.GS = *m_CPUREGPTR.pGS;
			m_CPUREG.SS = *m_CPUREGPTR.pSS;

			Update(&m_ClientRect);
		}
	}
	void CGeneRegList::LoadKeyMap()
	{
		if (!gpSyser->GetHotKey(EVENT_ID_CAX_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000031, EVENT_ID_CAX_DATA)); //WISP_SK_SHIFT 1
		if (!gpSyser->GetHotKey(EVENT_ID_CBX_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000032, EVENT_ID_CBX_DATA)); //WISP_SK_SHIFT 2
		if (!gpSyser->GetHotKey(EVENT_ID_CCX_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000033, EVENT_ID_CCX_DATA)); //WISP_SK_SHIFT 3
		if (!gpSyser->GetHotKey(EVENT_ID_CDX_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000034, EVENT_ID_CDX_DATA)); //WISP_SK_SHIFT 4
		if (!gpSyser->GetHotKey(EVENT_ID_CSP_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000035, EVENT_ID_CSP_DATA)); //WISP_SK_SHIFT 5
		if (!gpSyser->GetHotKey(EVENT_ID_CBP_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000036, EVENT_ID_CBP_DATA)); //WISP_SK_SHIFT 6
		if (!gpSyser->GetHotKey(EVENT_ID_CSI_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000037, EVENT_ID_CSI_DATA)); //WISP_SK_SHIFT 7
		if (!gpSyser->GetHotKey(EVENT_ID_CDI_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000038, EVENT_ID_CDI_DATA)); //WISP_SK_SHIFT 8
		if (!gpSyser->GetHotKey(EVENT_ID_CIP_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x10000039, EVENT_ID_CIP_DATA)); //WISP_SK_SHIFT 9
	#ifdef _X64_
	#endif
		if (!gpSyser->GetHotKey(EVENT_ID_CAX_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000031, EVENT_ID_CAX_CODE)); //WISP_SK_ALT 1
		if (!gpSyser->GetHotKey(EVENT_ID_CBX_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000032, EVENT_ID_CBX_CODE)); //WISP_SK_ALT 2
		if (!gpSyser->GetHotKey(EVENT_ID_CCX_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000033, EVENT_ID_CCX_CODE)); //WISP_SK_ALT 3
		if (!gpSyser->GetHotKey(EVENT_ID_CDX_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000034, EVENT_ID_CDX_CODE)); //WISP_SK_ALT 4
		if (!gpSyser->GetHotKey(EVENT_ID_CSP_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000035, EVENT_ID_CSP_CODE)); //WISP_SK_ALT 5
		if (!gpSyser->GetHotKey(EVENT_ID_CBP_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000036, EVENT_ID_CBP_CODE)); //WISP_SK_ALT 6
		if (!gpSyser->GetHotKey(EVENT_ID_CSI_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000037, EVENT_ID_CSI_CODE)); //WISP_SK_ALT 7
		if (!gpSyser->GetHotKey(EVENT_ID_CDI_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000038, EVENT_ID_CDI_CODE)); //WISP_SK_ALT 8
		if (!gpSyser->GetHotKey(EVENT_ID_CIP_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x20000039, EVENT_ID_CIP_CODE)); //WISP_SK_ALT 9
	#ifdef _X64_
	#endif
	}

	void CGeneRegList::ReadStringTrace(X86_CPU_REG *pCPUReg)
	{
		WCHAR Buffer[256];
		char szSym[256];
		char Encode;

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->CAX, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->CAX, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->CAX, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CAX], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->CCX, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->CCX, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->CCX, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CCX], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->CDX, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->CDX, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->CDX, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CDX], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->CBX, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->CBX, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->CBX, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CBX], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->CSP, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->CSP, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->CSP, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CSP], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->CBP, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->CBP, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->CBP, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CBP], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->CSI, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->CSI, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->CSI, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CSI], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->CDI, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->CDI, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->CDI, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_CDI], GL_CONTEXT, Buffer);
	#ifdef _X64_
		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->R8, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->R8, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->R8, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R8], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->R9, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->R9, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->R9, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R9], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->R10, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->R10, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->R10, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R10], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->R11, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->R11, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->R11, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R11], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->R12, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->R12, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->R12, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R12], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->R13, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->R13, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->R13, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R13], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->R14, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->R14, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->R14, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R14], GL_CONTEXT, Buffer);

		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbol(pCPUReg->R15, szSym, lenof(szSym)) ||
			(!gpSyser->m_SyserUI.ReadString(pCPUReg->R15, Buffer, 256, &Encode) &&
			gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->R15, szSym)))
		{
			TStrCpy(Buffer, szSym);
		}
		SetItemText(m_hGeneRegItem[REG_GENE_R15], GL_CONTEXT, Buffer);
	#endif
		Buffer[0] = 0;
		if (gpSyser->m_SyserUI.GetSymbolOffset(pCPUReg->CIP, szSym))
			TStrCpy(Buffer, szSym);
		SetItemText(m_hGeneRegItem[REG_GENE_CIP], GL_CONTEXT, Buffer);
	}

	void CGeneRegList::UpdateContextTrace(unsigned long CPUType, X86_CPU_REG *pCPUReg, ULONG_PTR CIP)
	{
		SetItemFormat(m_hGeneRegItem[REG_GENE_CIP], GL_VALUE, CIP, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_CIP], GL_VALUE, CIP);
		SetItemColor(m_hGeneRegItem[REG_GENE_CIP], GL_VALUE, (CPUType & 0x20000)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_CAX], GL_VALUE, pCPUReg->CAX, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_CAX], GL_VALUE, pCPUReg->CAX);
		SetItemColor(m_hGeneRegItem[REG_GENE_CAX], GL_VALUE, (CPUType & 1)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_CBX], GL_VALUE, pCPUReg->CBX, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_CBX], GL_VALUE, pCPUReg->CBX);
		SetItemColor(m_hGeneRegItem[REG_GENE_CBX], GL_VALUE, (CPUType & 2)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_CCX], GL_VALUE, pCPUReg->CCX, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_CCX], GL_VALUE, pCPUReg->CCX);
		SetItemColor(m_hGeneRegItem[REG_GENE_CCX], GL_VALUE, (CPUType & 4)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_CDX], GL_VALUE, pCPUReg->CDX, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_CDX], GL_VALUE, pCPUReg->CDX);
		SetItemColor(m_hGeneRegItem[REG_GENE_CDX], GL_VALUE, (CPUType & 8)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_CSP], GL_VALUE, pCPUReg->CSP, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_CSP], GL_VALUE, pCPUReg->CSP);
		SetItemColor(m_hGeneRegItem[REG_GENE_CSP], GL_VALUE, (CPUType & 0x10)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_CBP], GL_VALUE, pCPUReg->CBP, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_CBP], GL_VALUE, pCPUReg->CBP);
		SetItemColor(m_hGeneRegItem[REG_GENE_CBP], GL_VALUE, (CPUType & 0x20)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_CSI], GL_VALUE, pCPUReg->CSI, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_CSI], GL_VALUE, pCPUReg->CSI);
		SetItemColor(m_hGeneRegItem[REG_GENE_CSI], GL_VALUE, (CPUType & 0x40)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_CDI], GL_VALUE, pCPUReg->CDI, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_CDI], GL_VALUE, pCPUReg->CDI);
		SetItemColor(m_hGeneRegItem[REG_GENE_CDI], GL_VALUE, (CPUType & 0x80)?m_ColorChanges:m_ColorSame);
	#ifdef _X64_
		SetItemFormat(m_hGeneRegItem[REG_GENE_R8], GL_VALUE, pCPUReg->R8, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_R8], GL_VALUE, pCPUReg->R8);
		SetItemColor(m_hGeneRegItem[REG_GENE_R8], GL_VALUE, (CPUType & 0x100)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_R9], GL_VALUE, pCPUReg->R9, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_R9], GL_VALUE, pCPUReg->R9);
		SetItemColor(m_hGeneRegItem[REG_GENE_R9], GL_VALUE, (CPUType & 0x200)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_R10], GL_VALUE, pCPUReg->R10, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_R10], GL_VALUE, pCPUReg->R10);
		SetItemColor(m_hGeneRegItem[REG_GENE_R10], GL_VALUE, (CPUType & 0x400)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_R11], GL_VALUE, pCPUReg->R11, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_R11], GL_VALUE, pCPUReg->R11);
		SetItemColor(m_hGeneRegItem[REG_GENE_R11], GL_VALUE, (CPUType & 0x800)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_R12], GL_VALUE, pCPUReg->R12, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_R12], GL_VALUE, pCPUReg->R12);
		SetItemColor(m_hGeneRegItem[REG_GENE_R12], GL_VALUE, (CPUType & 0x1000)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_R13], GL_VALUE, pCPUReg->R13, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_R13], GL_VALUE, pCPUReg->R13);
		SetItemColor(m_hGeneRegItem[REG_GENE_R13], GL_VALUE, (CPUType & 0x2000)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_R14], GL_VALUE, pCPUReg->R14, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_R14], GL_VALUE, pCPUReg->R14);
		SetItemColor(m_hGeneRegItem[REG_GENE_R14], GL_VALUE, (CPUType & 0x4000)?m_ColorChanges:m_ColorSame);

		SetItemFormat(m_hGeneRegItem[REG_GENE_R15], GL_VALUE, pCPUReg->R15, WSTR("" F0ADDR "X"));
		SetItemValue(m_hGeneRegItem[REG_GENE_R15], GL_VALUE, pCPUReg->R15);
		SetItemColor(m_hGeneRegItem[REG_GENE_R15], GL_VALUE, (CPUType & 0x8000)?m_ColorChanges:m_ColorSame);
	#endif
		ReadStringTrace(pCPUReg);
	}

```

`source/WispSyser/genereglist.hpp`:

```hpp

#ifndef _GENEREGLIST_HPP_
#define _GENEREGLIST_HPP_

#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispmenu.hpp"
#include "../EXEAnalyzer/x86debugger.hpp"

enum REG_GENE_INDEX
{
  REG_GENE_CAX = 0,
  REG_GENE_CBX,
  REG_GENE_CCX,
  REG_GENE_CDX,
  REG_GENE_CSI,
  REG_GENE_CDI,
  REG_GENE_CBP,
  REG_GENE_CSP,
#ifdef _X64_
  REG_GENE_R8,
  REG_GENE_R9,
  REG_GENE_R10,
  REG_GENE_R11,
  REG_GENE_R12,
  REG_GENE_R13,
  REG_GENE_R14,
  REG_GENE_R15,
#endif
  REG_GENE_CIP,

  REG_GENE_EFLAG,

  REG_GENE_CS,
  REG_GENE_DS,
  REG_GENE_ES,
  REG_GENE_FS,
  REG_GENE_GS,
  REG_GENE_SS,

  REG_GENE_AF,
  REG_GENE_CF,
  REG_GENE_DF,
  REG_GENE_IF,
  REG_GENE_OF,
  REG_GENE_PF,
  REG_GENE_SF,
  REG_GENE_ZF,

  REG_GENE_BASE_CS,
  REG_GENE_BASE_DS,
  REG_GENE_BASE_ES,
  REG_GENE_BASE_FS,
  REG_GENE_BASE_GS,
  REG_GENE_BASE_SS,
#ifdef _RING0_
  REG_GENE_GDTR,
  REG_GENE_IDTR,
  REG_GENE_LDTR,
  REG_GENE_TR,

  REG_GENE_BASE_GDTR,
  REG_GENE_LIMIT_GDTR,

  REG_GENE_BASE_IDTR,
  REG_GENE_LIMIT_IDTR,
#endif
  REG_GENE_REGCOUNT,
};

struct CPUREG
{
	ULONG_PTR CAX;
	ULONG_PTR CBX;
	ULONG_PTR CCX;
	ULONG_PTR CDX;
	ULONG_PTR CDI;
	ULONG_PTR CSI;
	ULONG_PTR CBP;
	ULONG_PTR CSP;
#ifdef _X64_
	ULONG_PTR R8;
	ULONG_PTR R9;
	ULONG_PTR R10;
	ULONG_PTR R11;
	ULONG_PTR R12;
	ULONG_PTR R13;
	ULONG_PTR R14;
	ULONG_PTR R15;
#endif
	ULONG_PTR CIP;
//	unsigned long EFL;
	EFL_REG EFL;
	unsigned short CS;
	unsigned short DS;
	unsigned short ES;
	unsigned short FS;
	unsigned short GS;
	unsigned short SS;

	ULONG_PTR DR[8];
};

struct CGeneRegList : public CWispList
{
	CListStringItem *m_hGeneRegItem[REG_GENE_REGCOUNT];
	CPUREG m_CPUREG;
	unsigned long m_ColorChanges;
	unsigned long m_ColorSame;
	CListStringItem *m_pEditItem;
	CWispMenu m_PopupMenu;
	CWispMenu::MenuItem *m_MenuItemShowCode;
	CWispMenu::MenuItem *m_MenuItemShowData;
	int m_nCPU;
	X86_CPU_REG_PTR m_CPUREGPTR;
	map<unsigned int, unsigned int> m_KeyMap;

	CGeneRegList();
	virtual ~CGeneRegList();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnClose(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
//	bool OnGetFocus(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	
	bool OnEventGotoData(WISP_MSG *pMsg);
	bool OnEventGotoCode(WISP_MSG *pMsg);
	bool OnEventCode(WISP_MSG *pMsg);
	bool OnEventData(WISP_MSG *pMsg);

	virtual void OnLButton(CListStringItem *Item, int nCol) override;

	virtual bool Edit(CListStringItem *Item, int nCol, TWideString& String) override;
	virtual bool OnEditing(CListStringItem *Item, int nCol, TWideString& String) override;

	void ResetContext();
	void UpdateFlags();
	void ReadString(X86_CPU_REG_PTR *pCPURegPtr);
	void UpdateContext();
	void LoadKeyMap();
	void ReadStringTrace(X86_CPU_REG *pCPUReg);
	void UpdateContextTrace(unsigned long CPUType, X86_CPU_REG *pCPUReg, ULONG_PTR CIP);
};

#endif
```

`source/WispSyser/idtwnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "idtwnd.hpp"
#include "syserconfig.hpp"

	static const WCHAR *DescType[] = 
		{
			WSTR("Reserved"),//0
			WSTR("TSS16   "),//1
			WSTR("LDT     "),//2
			WSTR("TSS32   "),//3
			WSTR("CallG16 "),//4
			WSTR("TaskG   "),//5
			WSTR("IntG16  "),//6
			WSTR("TrapG16 "),//7
			WSTR("Reserved"),//8
			WSTR("TSS32   "),//9
			WSTR("Reserved"),//A
			WSTR("TSS32   "),//B
			WSTR("CallG32 "),//C
			WSTR("Reserved"),//D
			WSTR("IntG32  "),//E-
			WSTR("TrapG32 "),//F
		};

struct _X86_GATE_DECR
{
	unsigned short OffsetLow;
	unsigned short Selector;

	unsigned char DCount :5;
	unsigned char Reserved :3;

	unsigned char Type :4;	//0x8E 1.00.0.1110(0xE,0,0,1), 0xEE 1.11.0.1110(0xE,0,3,1) 0x85 1.00.0.0101(0x5,0,0,1)
	unsigned char DT :1;
	unsigned char DPL :2;
	unsigned char P :1;

	unsigned short OffsetHigh;
};
	_X86_GATE_DECR idtdata[] =
		{
			{0xBC22, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0x3F69, 0x08, 0,0, 0xE,0,3,1, 0xF194},
			{0x3F78, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0x3F87, 0x08, 0,0, 0xE,0,3,1, 0xF194},
			{0xC1E5, 0x08, 0,0, 0xE,0,3,1, 0x804D},
			{0xC326, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0x3F96, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0xCA57, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0x1178, 0x50, 0,0, 0x5,0,0,1, 0},
			{0xCE71, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xCF74, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0x3FA5, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0x3FB4, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0x3FC3, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0x3FD2, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xE04F, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xE16A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0xA0, 0,0, 0x5,0,0,1, 0x804D},
			{0xE2B6, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{     0, 0x08, 0,0,   0,0,0,0, 0},
			{0xB4F6, 0x08, 0,0, 0xE,0,3,1, 0x804D},
			{0xB5E1, 0x08, 0,0, 0xE,0,3,1, 0x804D},
			{0xB744, 0x08, 0,0, 0xE,0,3,1, 0x804D},
			{0x3FF0, 0x08, 0,0, 0xE,0,3,1, 0xF194},
			{0x3FFF, 0x08, 0,0, 0xE,0,3,1, 0xF194},
			{0xDF4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xE4C0, 0x08, 0,0, 0xE,0,0,1, 0x806C},
			{0x400E, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0xA784, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0x401D, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0x402C, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0xF0FC, 0x08, 0,0, 0xE,0,0,1, 0x818E},
			{0xA7AC, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0x404A, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0x8E80, 0x08, 0,0, 0xE,0,0,1, 0x806C},
			{0xC4C4, 0x08, 0,0, 0xE,0,0,1, 0x81B7},
			{0x54CC, 0x08, 0,0, 0xE,0,0,1, 0x81A1},
			{0xE604, 0x08, 0,0, 0xE,0,0,1, 0x818F},
			{0x403B, 0x08, 0,0, 0xE,0,0,1, 0xF194},
			{0xA7F2, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xF6E4, 0x08, 0,0, 0xE,0,0,1, 0x81BC},
			{0xBAA4, 0x08, 0,0, 0xE,0,0,1, 0x81B5},
			{0xA810, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0x3FE1, 0x08, 0,0, 0xE,0,3,1, 0xF194},
			{0xA824, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA82E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA838, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA842, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA84C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA856, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA860, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA86A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA874, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA87E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA888, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA892, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA89C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA8A6, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA8B0, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA8BA, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA8C4, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA8CE, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA8D8, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA8E2, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA8EC, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA8F6, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA900, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA90A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA914, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA91E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA928, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA932, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA93C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA946, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA950, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA95A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA964, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA96E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA978, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA982, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA98C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA996, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9A0, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9AA, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9B4, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9BE, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9C8, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9D2, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9DC, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9E6, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9F0, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xA9FA, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA04, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA0E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA18, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA22, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA2C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA36, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA40, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA4A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA54, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA5E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA68, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA72, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA7C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA86, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA90, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAA9A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAAA4, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAAAE, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAAB8, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAAC2, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAACC, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAAD6, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAAE0, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAAEA, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAAF4, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAAFE, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB08, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB12, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB1C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB26, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB30, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB3A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB44, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB4E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB58, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB62, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB6C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB76, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB80, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB8A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB94, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAB9E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xABA8, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xABB2, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xABBC, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xABC6, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xABD0, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xABDA, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xABE4, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xABEE, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xABF8, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC02, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC0C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC16, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC20, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC2A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC34, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC3E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC48, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC52, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC5C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC66, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC70, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC7A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC84, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC8E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAC98, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACA2, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACAC, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACB6, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACC0, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACCA, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACD4, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACDE, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACE8, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACF2, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xACFC, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD06, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD10, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD1A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD24, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD2E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD38, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD42, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD4C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD56, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD60, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD6A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD74, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD7E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD88, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD92, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAD9C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xADA6, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xADB0, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xADBA, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xADC4, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xADCE, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xADD8, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xADE2, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xADEC, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xADF6, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE00, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE0A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE14, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE1E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE28, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE32, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE3C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE46, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE50, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE5A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE64, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE6E, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE78, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE82, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE8C, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAE96, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEA0, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEAA, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEB4, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEBE, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEC8, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAED2, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAED9, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEE0, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEE7, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEEE, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEF5, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAEFC, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF03, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF0A, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF11, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF18, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF1F, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF26, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF2D, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF34, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF3B, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF42, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF49, 0x08, 0,0, 0xE,0,0,1, 0x804D},
			{0xAF50, 0x08, 0,0, 0xE,0,0,1, 0x804D},
		};

        WISP_MSG_MAP_BEGIN(CIDTWnd)
                WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
                WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
        WISP_MSG_MAP_END(CWispList)

	CIDTWnd::CIDTWnd()
	{
		m_dwBeginIndex = 0;
	#if 0
		//m_pIDTAddress = GetIDTBase(&m_dwIDTSize);
	#else
		m_pIDTAddress = idtdata;
		m_dwIDTSize = sizeof(idtdata)-1;//2047; //256
	#endif
	}
	CIDTWnd::~CIDTWnd()
	{
	}

        bool CIDTWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_ItemColor = gSyserColors.Color[1];
		m_crBGColor = gSyserColors.Color[0];
		m_bBGColor = 1;

		InsertColumn(WSTR("Int"), 40, 0, 0, -1);
		InsertColumn(WSTR("Type"), 80, 0, 0, -1);
		InsertColumn(WSTR("Sel:Offset"), 90, 0, 0, -1);
		InsertColumn(WSTR("Attributes"), 100, 0, 0, -1);
		InsertColumn(WSTR("Symbol/Owner"), 90, 0, 0, -1);

		SetWindowText(WSTR("IDT TABLE"));
		InitContext();
		return true;
	}
        bool CIDTWnd::OnClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}

	bool CIDTWnd::InsertIDT()
	{
		void *dwIDTBase = m_pIDTAddress;
		unsigned long dwIDTSize = (m_dwIDTSize+1)/8;

		WCHAR display[64];

		_X86_GATE_DECR *pGateDesc = (_X86_GATE_DECR *)dwIDTBase;

		for (unsigned long i = 0; i < dwIDTSize; ++i)
		{
			unsigned long dwSelector = pGateDesc->Selector;
			TSPrintf(display, WSTR("%02X"), i);
			CListStringItem *pItem = InsertItem(display, 0, 0, 0, -1);
			SetItemText(pItem, 1, DescType[pGateDesc->Type]);
			unsigned long dwOffset = (pGateDesc->OffsetHigh << 16) | pGateDesc->OffsetLow;

		#ifdef _RING_0_
			if (gOldInterruptProcAddress[i])
			{
				if (dwOffset > gpSyser->m_pDriverObject->DriverStart &&
				    dwOffset < gpSyser->m_pDriverObject->DriverStart+gpSyser->m_pDriverObject->DriverSize)
					dwOffset = gOldInterruptProcAddress[i];
			}
		#endif

			SetItemText(pItem, 2, DescType[pGateDesc->Type]);
			TSPrintf(display, WSTR("%04X:%08X"), dwSelector, dwOffset);
			SetItemText(pItem, 2, display);

			TSPrintf(display, WSTR("DPL=%d %s"), pGateDesc->DPL, pGateDesc->P ? WSTR("P"):WSTR("NP"));
			SetItemText(pItem, 3, display);
			++pGateDesc;
		}

		return true;
	}

	void CIDTWnd::InitContext()
	{
		DeleteAllChildrenItems(0);
		InsertIDT();
	}

	void CIDTWnd::Create()
	{
		if (IsWindow())
		{
			Destroy();
		} else
		{
			WISP_RECT Rect;
			Rect.x = 0;
			Rect.y = 0;
			Rect.cx = 540;
			Rect.cy = 350;
			CreateWnd(WSTR("IDT"), Rect, 0, 0, 0x100BB, WISP_SH_MINSIZE);
			Center(0);
		}
	}

```

`source/WispSyser/idtwnd.hpp`:

```hpp

#ifndef _IDTWND_HPP_
#define _IDTWND_HPP_

#include "../Wisp/wisplist.hpp"

struct CIDTWnd : public CWispList
{
	void *m_pIDTAddress;
	unsigned long m_dwIDTSize;
	unsigned long m_dwBeginIndex;

	CIDTWnd();
	virtual ~CIDTWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
        bool OnCreate(WISP_MSG *pMsg);
        bool OnClose(WISP_MSG *pMsg);

	bool InsertIDT();
	void InitContext();
	void Create();
};

#endif

```

`source/WispSyser/ioctl.cpp`:

```cpp

#include "othercmd.hpp"

IOCTL_ENTRY stIoctlList[] =
        {
      {"IOCTL_BEEP_SET", 0x00010000 },
      {"IOCTL_CDROM_DISK_TYPE", 0x00020040 },
      {"IOCTL_CDROM_READ_TOC", 0x00024000 },
      {"IOCTL_CDROM_SEEK_AUDIO_MSF", 0x00024004 },
      {"IOCTL_CDROM_STOP_AUDIO", 0x00024008 },
      {"IOCTL_CDROM_PAUSE_AUDIO", 0x0002400C },
      {"IOCTL_CDROM_RESUME_AUDIO", 0x00024010 },
      {"IOCTL_CDROM_GET_VOLUME", 0x00024014 },
      {"IOCTL_CDROM_PLAY_AUDIO_MSF", 0x00024018 },
      {"IOCTL_CDROM_SET_VOLUME", 0x00024028 },
      {"IOCTL_CDROM_READ_Q_CHANNEL", 0x0002402C },
      {"IOCTL_CDROM_GET_LAST_SESSION", 0x00024038 },
      {"IOCTL_CDROM_RAW_READ", 0x0002403E },
      {"IOCTL_CDROM_GET_DRIVE_GEOMETRY", 0x0002404C },
      {"IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX", 0x00024050 },
      {"IOCTL_CDROM_READ_TOC_EX", 0x00024054 },
      {"IOCTL_CDROM_GET_CONFIGURATION", 0x00024058 },
      {"IOCTL_CDROM_CHECK_VERIFY", 0x00024800 },
      {"IOCTL_CDROM_MEDIA_REMOVAL", 0x00024804 },
      {"IOCTL_CDROM_EJECT_MEDIA", 0x00024808 },
      {"IOCTL_CDROM_LOAD_MEDIA", 0x0002480C },
      {"IOCTL_CDROM_RESERVE", 0x00024810 },
      {"IOCTL_CDROM_RELEASE", 0x00024814 },
      {"IOCTL_CDROM_FIND_NEW_DEVICES", 0x00024818 },
      {"IOCTL_CDROM_UNLOAD_DRIVER", 0x00025008 },
      {"IOCTL_SCSI_GET_INQUIRY_DATA", 0x0004100C },
      {"IOCTL_SCSI_GET_CAPABILITIES", 0x00041010 },
      {"IOCTL_SCSI_GET_ADDRESS", 0x00041018 },
      {"IOCTL_SCSI_RESCAN_BUS", 0x0004101C },
      {"IOCTL_SCSI_GET_DUMP_POINTERS", 0x00041020 },
      {"IOCTL_SCSI_FREE_DUMP_POINTERS", 0x00041024 },
      {"IOCTL_SCSI_PASS_THROUGH", 0x0004D004 },
      {"IOCTL_SCSI_MINIPORT", 0x0004D008 },
      {"IOCTL_SCSI_PASS_THROUGH_DIRECT", 0x0004D014 },
      {"IOCTL_IDE_PASS_THROUGH", 0x0004D028 },
      {"IOCTL_ATA_PASS_THROUGH", 0x0004D02C },
      {"IOCTL_ATA_PASS_THROUGH_DIRECT", 0x0004D030 },
      {"IOCTL_DISK_GET_DRIVE_GEOMETRY", 0x00070000 },
      {"IOCTL_DISK_VERIFY", 0x00070014 },
      {"IOCTL_DISK_PERFORMANCE", 0x00070020 },
      {"IOCTL_DISK_IS_WRITABLE", 0x00070024 },
      {"IOCTL_DISK_LOGGING", 0x00070028 },
      {"IOCTL_DISK_HISTOGRAM_STRUCTURE", 0x00070030 },
      {"IOCTL_DISK_HISTOGRAM_DATA", 0x00070034 },
      {"IOCTL_DISK_HISTOGRAM_RESET", 0x00070038 },
      {"IOCTL_DISK_REQUEST_STRUCTURE", 0x0007003C },
      {"IOCTL_DISK_REQUEST_DATA", 0x00070040 },
      {"IOCTL_DISK_CONTROLLER_NUMBER", 0x00070044 },
      {"IOCTL_DISK_GET_PARTITION_INFO_EX", 0x00070048 },
      {"IOCTL_DISK_GET_DRIVE_LAYOUT_EX", 0x00070050 },
      {"IOCTL_DISK_PERFORMANCE_OFF", 0x00070060 },
      {"IOCTL_DISK_GET_DRIVE_GEOMETRY_EX", 0x000700A0 },
      {"IOCTL_DISK_UPDATE_PROPERTIES", 0x00070140 },
      {"IOCTL_DISK_SENSE_DEVICE", 0x000703E0 },
      {"IOCTL_DISK_INTERNAL_SET_VERIFY", 0x00070403 },
      {"IOCTL_DISK_INTERNAL_CLEAR_VERIFY", 0x00070407 },
      {"IOCTL_DISK_INTERNAL_SET_NOTIFY", 0x00070408 },
      {"IOCTL_DISK_GET_MEDIA_TYPES", 0x00070C00 },
      {"IOCTL_DISK_GET_PARTITION_INFO", 0x00074004 },
      {"IOCTL_DISK_GET_DRIVE_LAYOUT", 0x0007400C },
      {"IOCTL_DISK_GET_LENGTH_INFO", 0x0007405C },
      {"SMART_GET_VERSION", 0x00074080 },
      {"IOCTL_DISK_GET_CACHE_INFORMATION", 0x000740D4 },
      {"IOCTL_DISK_GET_CACHE_SETTING", 0x000740E0 },
      {"IOCTL_DISK_CHECK_VERIFY", 0x00074800 },
      {"IOCTL_DISK_MEDIA_REMOVAL", 0x00074804 },
      {"IOCTL_DISK_EJECT_MEDIA", 0x00074808 },
      {"IOCTL_DISK_LOAD_MEDIA", 0x0007480C },
      {"IOCTL_DISK_RESERVE", 0x00074810 },
      {"IOCTL_DISK_RELEASE", 0x00074814 },
      {"IOCTL_DISK_FIND_NEW_DEVICES", 0x00074818 },
      {"IOCTL_DISK_SET_PARTITION_INFO", 0x0007C008 },
      {"IOCTL_DISK_SET_DRIVE_LAYOUT", 0x0007C010 },
      {"IOCTL_DISK_FORMAT_TRACKS", 0x0007C018 },
      {"IOCTL_DISK_REASSIGN_BLOCKS", 0x0007C01C },
      {"IOCTL_DISK_FORMAT_TRACKS_EX", 0x0007C02C },
      {"IOCTL_DISK_SET_PARTITION_INFO_EX", 0x0007C04C },
      {"IOCTL_DISK_SET_DRIVE_LAYOUT_EX", 0x0007C054 },
      {"IOCTL_DISK_CREATE_DISK", 0x0007C058 },
      {"SMART_SEND_DRIVE_COMMAND", 0x0007C084 },
      {"SMART_RCV_DRIVE_DATA", 0x0007C088 },
      {"IOCTL_DISK_UPDATE_DRIVE_SIZE", 0x0007C0C8 },
      {"IOCTL_DISK_GROW_PARTITION", 0x0007C0D0 },
      {"IOCTL_DISK_SET_CACHE_INFORMATION", 0x0007C0D8 },
      {"IOCTL_DISK_SET_CACHE_SETTING", 0x0007C0E4 },
      {"IOCTL_DISK_DELETE_DRIVE_LAYOUT", 0x0007C100 },
      {"IOCTL_DISK_FORMAT_DRIVE", 0x0007C3CC },
      {"IOCTL_DISK_SIMBAD", 0x0007D000 },
      {"FSCTL_REQUEST_OPLOCK_LEVEL_1", 0x00090000 },
      {"FSCTL_REQUEST_OPLOCK_LEVEL_2", 0x00090004 },
      {"FSCTL_REQUEST_BATCH_OPLOCK", 0x00090008 },
      {"FSCTL_OPLOCK_BREAK_ACKNOWLEDGE", 0x0009000C },
      {"FSCTL_OPBATCH_ACK_CLOSE_PENDING", 0x00090010 },
      {"FSCTL_OPLOCK_BREAK_NOTIFY", 0x00090014 },
      {"FSCTL_LOCK_VOLUME", 0x00090018 },
      {"FSCTL_UNLOCK_VOLUME", 0x0009001C },
      {"FSCTL_DISMOUNT_VOLUME", 0x00090020 },
      {"FSCTL_IS_VOLUME_MOUNTED", 0x00090028 },
      {"FSCTL_IS_PATHNAME_VALID", 0x0009002C },
      {"FSCTL_MARK_VOLUME_DIRTY", 0x00090030 },
      {"FSCTL_QUERY_RETRIEVAL_POINTERS", 0x0009003B },
      {"FSCTL_GET_COMPRESSION", 0x0009003C },
      {"FSCTL_MARK_AS_SYSTEM_HIVE", 0x0009004F },
      {"FSCTL_OPLOCK_BREAK_ACK_NO_2", 0x00090050 },
      {"FSCTL_INVALIDATE_VOLUMES", 0x00090054 },
      {"FSCTL_QUERY_FAT_BPB", 0x00090058 },
      {"FSCTL_REQUEST_FILTER_OPLOCK", 0x0009005C },
      {"FSCTL_FILESYSTEM_GET_STATISTICS", 0x00090060 },
      {"FSCTL_GET_NTFS_VOLUME_DATA", 0x00090064 },
      {"FSCTL_GET_NTFS_FILE_RECORD", 0x00090068 },
      {"FSCTL_GET_VOLUME_BITMAP", 0x0009006F },
      {"FSCTL_GET_RETRIEVAL_POINTERS", 0x00090073 },
      {"FSCTL_MOVE_FILE", 0x00090074 },
      {"FSCTL_IS_VOLUME_DIRTY", 0x00090078 },
      {"FSCTL_ALLOW_EXTENDED_DASD_IO", 0x00090083 },
      {"FSCTL_FIND_FILES_BY_SID", 0x0009008F },
      {"FSCTL_SET_OBJECT_ID", 0x00090098 },
      {"FSCTL_GET_OBJECT_ID", 0x0009009C },
      {"FSCTL_DELETE_OBJECT_ID", 0x000900A0 },
      {"FSCTL_SET_REPARSE_POINT", 0x000900A4 },
      {"FSCTL_GET_REPARSE_POINT", 0x000900A8 },
      {"FSCTL_DELETE_REPARSE_POINT", 0x000900AC },
      {"FSCTL_ENUM_USN_DATA", 0x000900B3 },
      {"FSCTL_READ_USN_JOURNAL", 0x000900BB },
      {"FSCTL_SET_OBJECT_ID_EXTENDED", 0x000900BC },
      {"FSCTL_CREATE_OR_GET_OBJECT_ID", 0x000900C0 },
      {"FSCTL_SET_SPARSE", 0x000900C4 },
      {"FSCTL_SET_ENCRYPTION", 0x000900D7 },
      {"FSCTL_ENCRYPTION_FSCTL_IO", 0x000900DB },
      {"FSCTL_WRITE_RAW_ENCRYPTED", 0x000900DF },
      {"FSCTL_READ_RAW_ENCRYPTED", 0x000900E3 },
      {"FSCTL_CREATE_USN_JOURNAL", 0x000900E7 },
      {"FSCTL_READ_FILE_USN_DATA", 0x000900EB },
      {"FSCTL_WRITE_USN_CLOSE_RECORD", 0x000900EF },
      {"FSCTL_EXTEND_VOLUME", 0x000900F0 },
      {"FSCTL_QUERY_USN_JOURNAL", 0x000900F4 },
      {"FSCTL_DELETE_USN_JOURNAL", 0x000900F8 },
      {"FSCTL_MARK_HANDLE", 0x000900FC },
      {"FSCTL_SIS_COPYFILE", 0x00090100 },
      {"FSCTL_RECALL_FILE", 0x00090117 },
      {"FSCTL_FILE_PREFETCH", 0x00090120 },
      {"FSCTL_SECURITY_ID_CHECK", 0x000940B7 },
      {"FSCTL_QUERY_ALLOCATED_RANGES", 0x000940CF },
      {"FSCTL_READ_FROM_PLEX", 0x0009411E },
      {"FSCTL_SET_ZERO_DATA", 0x000980C8 },
      {"FSCTL_SET_COMPRESSION", 0x0009C040 },
      {"FSCTL_SIS_LINK_FILES", 0x0009C104 },
      {"FSCTL_HSM_MSG", 0x0009C108 },
      {"FSCTL_HSM_DATA", 0x0009C113 },
      {"IOCTL_KEYBOARD_QUERY_ATTRIBUTES", 0x000B0000 },
      {"IOCTL_HID_GET_DEVICE_DESCRIPTOR", 0x000B0003 },
      {"IOCTL_KEYBOARD_SET_TYPEMATIC", 0x000B0004 },
      {"IOCTL_HID_GET_REPORT_DESCRIPTOR", 0x000B0007 },
      {"IOCTL_KEYBOARD_SET_INDICATORS", 0x000B0008 },
      {"IOCTL_HID_READ_REPORT", 0x000B000B },
      {"IOCTL_HID_WRITE_REPORT", 0x000B000F },
      {"IOCTL_HID_GET_STRING", 0x000B0013 },
      {"IOCTL_HID_ACTIVATE_DEVICE", 0x000B001F },
      {"IOCTL_KEYBOARD_QUERY_TYPEMATIC", 0x000B0020 },
      {"IOCTL_HID_DEACTIVATE_DEVICE", 0x000B0023 },
      {"IOCTL_HID_GET_DEVICE_ATTRIBUTES", 0x000B0027 },
      {"IOCTL_KEYBOARD_QUERY_INDICATORS", 0x000B0040 },
      {"IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION", 0x000B0080 },
      {"IOCTL_KEYBOARD_INSERT_DATA", 0x000B0100 },
      {"IOCTL_HID_SET_FEATURE", 0x000B0191 },
      {"IOCTL_HID_GET_FEATURE", 0x000B0192 },
      {"IOCTL_HID_GET_COLLECTION_DESCRIPTOR", 0x000B0193 },
      {"IOCTL_HID_SET_OUTPUT_REPORT", 0x000B0195 },
      {"IOCTL_HID_FLUSH_QUEUE", 0x000B0197 },
      {"IOCTL_HID_GET_POLL_FREQUENCY_MSEC", 0x000B0198 },
      {"IOCTL_GET_PHYSICAL_DESCRIPTOR", 0x000B019A },
      {"IOCTL_HID_SET_POLL_FREQUENCY_MSEC", 0x000B019C },
      {"IOCTL_HID_GET_HARDWARE_ID", 0x000B019E },
      {"IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS", 0x000B01A0 },
      {"IOCTL_HID_GET_INPUT_REPORT", 0x000B01A2 },
      {"IOCTL_HID_GET_COLLECTION_INFORMATION", 0x000B01A8 },
      {"IOCTL_HID_GET_MANUFACTURER_STRING", 0x000B01BA },
      {"IOCTL_HID_GET_PRODUCT_STRING", 0x000B01BE },
      {"IOCTL_HID_GET_SERIALNUMBER_STRING", 0x000B01C2 },
      {"IOCTL_HID_GET_INDEXED_STRING", 0x000B01E2 },
      {"IOCTL_INTERNAL_KEYBOARD_CONNECT", 0x000B0203 },
      {"IOCTL_HID_ENABLE_SECURE_READ", 0x000B020B },
      {"IOCTL_HID_DISABLE_SECURE_READ", 0x000B020F },
      {"IOCTL_INTERNAL_KEYBOARD_DISCONNECT", 0x000B0403 },
      {"IOCTL_KEYBOARD_QUERY_IME_STATUS", 0x000B1000 },
      {"IOCTL_KEYBOARD_SET_IME_STATUS", 0x000B1004 },
      {"IOCTL_INTERNAL_I8042_HOOK_KEYBOARD", 0x000B3FC3 },
      {"IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER", 0x000B3FC7 },
      {"IOCTL_INTERNAL_I8042_CONTROLLER_WRITE_BUFFER", 0x000B3FCB },
      {"IOCTL_INTERNAL_I8042_KEYBOARD_START_INFORMATION", 0x000B3FCF },
      {"IOCTL_INTERNAL_MOUSE_CONNECT", 0x000F0203 },
      {"IOCTL_INTERNAL_MOUSE_DISCONNECT", 0x000F0403 },
      {"IOCTL_INTERNAL_I8042_HOOK_MOUSE", 0x000F3FC3 },
      {"IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER", 0x000F3FC7 },
      {"IOCTL_INTERNAL_I8042_MOUSE_START_INFORMATION", 0x000F3FCF },
      {"IOCTL_PF_SET_EXTENSION_POINTER", 0x00128058 },
      {"IOCTL_PAR_QUERY_INFORMATION", 0x00160004 },
      {"IOCTL_PAR_SET_INFORMATION", 0x00160008 },
      {"IOCTL_PAR_QUERY_DEVICE_ID", 0x0016000C },
      {"IOCTL_PAR_QUERY_DEVICE_ID_SIZE", 0x00160010 },
      {"IOCTL_IEEE1284_GET_MODE", 0x00160014 },
      {"IOCTL_IEEE1284_NEGOTIATE", 0x00160018 },
      {"IOCTL_PAR_SET_WRITE_ADDRESS", 0x0016001C },
      {"IOCTL_PAR_SET_READ_ADDRESS", 0x00160020 },
      {"IOCTL_PAR_GET_DEVICE_CAPS", 0x00160024 },
      {"IOCTL_PAR_GET_DEFAULT_MODES", 0x00160028 },
      {"IOCTL_PAR_PING", 0x0016002C },
      {"IOCTL_PAR_QUERY_RAW_DEVICE_ID", 0x00160030 },
      {"IOCTL_PAR_ECP_HOST_RECOVERY", 0x00160034 },
      {"IOCTL_PAR_GET_READ_ADDRESS", 0x00160038 },
      {"IOCTL_PAR_GET_WRITE_ADDRESS", 0x0016003C },
      {"IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO", 0x00160044 },
      {"IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE", 0x0016004C },
      {"IOCTL_PAR_TEST", 0x00160050 },
      {"IOCTL_PAR_IS_PORT_FREE", 0x00160054 },
      {"IOCTL_PAR_QUERY_LOCATION", 0x00160058 },
      {"IOCTL_INTERNAL_SELECT_DEVICE", 0x0016005C },
      {"IOCTL_INTERNAL_DESELECT_DEVICE", 0x00160060 },
      {"IOCTL_INTERNAL_PARCLASS_CONNECT", 0x00160078 },
      {"IOCTL_INTERNAL_PARCLASS_DISCONNECT", 0x0016007C },
      {"IOCTL_INTERNAL_DISCONNECT_IDLE", 0x00160080 },
      {"IOCTL_INTERNAL_LOCK_PORT", 0x00160094 },
      {"IOCTL_INTERNAL_UNLOCK_PORT", 0x00160098 },
      {"IOCTL_INTERNAL_PARALLEL_PORT_FREE", 0x001600A0 },
      {"IOCTL_INTERNAL_LOCK_PORT_NO_SELECT", 0x001600D0 },
      {"IOCTL_INTERNAL_UNLOCK_PORT_NO_DESELECT", 0x001600D4 },
      {"IOCTL_NDIS_QUERY_GLOBAL_STATS", 0x00170002 },
      {"IOCTL_NDIS_QUERY_ALL_STATS", 0x00170006 },
      {"IOCTL_NDIS_DO_PNP_OPERATION", 0x00170008 },
      {"IOCTL_NDIS_QUERY_SELECTED_STATS", 0x0017000E },
      {"IOCTL_NDIS_ENUMERATE_INTERFACES", 0x00170010 },
      {"IOCTL_NDIS_ADD_TDI_DEVICE", 0x00170014 },
      {"IOCTL_NDIS_GET_LOG_DATA", 0x0017001E },
      {"IOCTL_NDIS_GET_VERSION", 0x00170020 },
      {"IOCTL_SCSISCAN_CMD", 0x00190012 },
      {"IOCTL_SCSISCAN_LOCKDEVICE", 0x00190016 },
      {"IOCTL_SCSISCAN_UNLOCKDEVICE", 0x0019001A },
      {"IOCTL_SCSISCAN_SET_TIMEOUT", 0x0019001C },
      {"IOCTL_SCSISCAN_GET_INFO", 0x00190022 },
      {"IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE", 0x001B0004 },
      {"IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE", 0x001B0008 },
      {"IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS", 0x001B000C },
      {"IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS", 0x001B0010 },
      {"IOCTL_SERIAL_SET_BREAK_OFF", 0x001B0014 },
      {"IOCTL_SERIAL_IMMEDIATE_CHAR", 0x001B0018 },
      {"IOCTL_SERIAL_SET_TIMEOUTS", 0x001B001C },
      {"IOCTL_SERIAL_GET_TIMEOUTS", 0x001B0020 },
      {"IOCTL_SERIAL_SET_DTR", 0x001B0024 },
      {"IOCTL_SERIAL_CLR_DTR", 0x001B0028 },
      {"IOCTL_SERIAL_RESET_DEVICE", 0x001B002C },
      {"IOCTL_SERIAL_SET_RTS", 0x001B0030 },
      {"IOCTL_SERIAL_CLR_RTS", 0x001B0034 },
      {"IOCTL_SERIAL_SET_XOFF", 0x001B0038 },
      {"IOCTL_SERIAL_SET_XON", 0x001B003C },
      {"IOCTL_SERIAL_GET_WAIT_MASK", 0x001B0040 },
      {"IOCTL_SERIAL_SET_WAIT_MASK", 0x001B0044 },
      {"IOCTL_SERIAL_WAIT_ON_MASK", 0x001B0048 },
      {"IOCTL_SERIAL_PURGE", 0x001B004C },
      {"IOCTL_SERIAL_GET_BAUD_RATE", 0x001B0050 },
      {"IOCTL_SERIAL_GET_LINE_CONTROL", 0x001B0054 },
      {"IOCTL_SERIAL_GET_CHARS", 0x001B0058 },
      {"IOCTL_SERIAL_SET_CHARS", 0x001B005C },
      {"IOCTL_SERIAL_GET_HANDFLOW", 0x001B0060 },
      {"IOCTL_SERIAL_SET_HANDFLOW", 0x001B0064 },
      {"IOCTL_SERIAL_GET_MODEMSTATUS", 0x001B0068 },
      {"IOCTL_SERIAL_GET_COMMSTATUS", 0x001B006C },
      {"IOCTL_SERIAL_XOFF_COUNTER", 0x001B0070 },
      {"IOCTL_SERIAL_GET_PROPERTIES", 0x001B0074 },
      {"IOCTL_SERIAL_GET_DTRRTS", 0x001B0078 },
      {"IOCTL_SERIAL_LSRMST_INSERT", 0x001B007C },
      {"IOCTL_SERIAL_CONFIG_SIZE", 0x001B0080 },
      {"IOCTL_SERIAL_GET_COMMCONFIG", 0x001B0084 },
      {"IOCTL_SERIAL_SET_COMMCONFIG", 0x001B0088 },
      {"IOCTL_SERIAL_GET_STATS", 0x001B008C },
      {"IOCTL_SERIAL_CLEAR_STATS", 0x001B0090 },
      {"IOCTL_SERIAL_GET_MODEM_CONTROL", 0x001B0094 },
      {"IOCTL_SERIAL_SET_MODEM_CONTROL", 0x001B0098 },
      {"IOCTL_SERIAL_SET_FIFO_CONTROL", 0x001B009C },
      {"IOCTL_TAPE_PREPARE", 0x001F4004 },
      {"IOCTL_TAPE_GET_POSITION", 0x001F400C },
      {"IOCTL_TAPE_SET_POSITION", 0x001F4010 },
      {"IOCTL_TAPE_GET_DRIVE_PARAMS", 0x001F4014 },
      {"IOCTL_TAPE_GET_MEDIA_PARAMS", 0x001F401C },
      {"IOCTL_TAPE_SET_MEDIA_PARAMS", 0x001F4020 },
      {"IOCTL_TAPE_GET_STATUS", 0x001F4024 },
      {"IOCTL_TAPE_MEDIA_REMOVAL", 0x001F4804 },
      {"IOCTL_TAPE_EJECT_MEDIA", 0x001F4808 },
      {"IOCTL_TAPE_LOAD_MEDIA", 0x001F480C },
      {"IOCTL_TAPE_RESERVE", 0x001F4810 },
      {"IOCTL_TAPE_RELEASE", 0x001F4814 },
      {"IOCTL_TAPE_ERASE", 0x001FC000 },
      {"IOCTL_TAPE_WRITE_MARKS", 0x001FC008 },
      {"IOCTL_TAPE_SET_DRIVE_PARAMS", 0x001FC018 },
      {"IOCTL_TAPE_CREATE_PARTITION", 0x001FC028 },
      {"IOCTL_TDI_ACCEPT", 0x00210000 },
      {"IOCTL_TDI_CONNECT", 0x00210004 },
      {"IOCTL_TDI_DISCONNECT", 0x00210008 },
      {"IOCTL_TDI_LISTEN", 0x0021000C },
      {"IOCTL_TDI_QUERY_INFORMATION", 0x00210012 },
      {"IOCTL_TDI_RECEIVE", 0x00210016 },
      {"IOCTL_TDI_RECEIVE_DATAGRAM", 0x0021001A },
      {"IOCTL_TDI_SEND", 0x0021001D },
      {"IOCTL_TDI_SEND_DATAGRAM", 0x00210021 },
      {"IOCTL_TDI_SET_EVENT_HANDLER", 0x00210024 },
      {"IOCTL_TDI_SET_INFORMATION", 0x00210029 },
      {"IOCTL_TDI_ASSOCIATE_ADDRESS", 0x0021002C },
      {"IOCTL_TDI_DISASSOCIATE_ADDRESS", 0x00210030 },
      {"IOCTL_TDI_ACTION", 0x00210036 },
      {"IOCTL_INTERNAL_USB_SUBMIT_URB", 0x00220003 },
      {"IOCTL_INTERNAL_USB_RESET_PORT", 0x00220007 },
      {"IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO", 0x0022000F },
      {"IOCTL_INTERNAL_USB_GET_PORT_STATUS", 0x00220013 },
      {"IOCTL_INTERNAL_USB_ENABLE_PORT", 0x00220017 },
      {"IOCTL_INTERNAL_USB_GET_HUB_COUNT", 0x0022001B },
      {"IOCTL_INTERNAL_USB_CYCLE_PORT", 0x0022001F },
      {"IOCTL_INTERNAL_USB_GET_HUB_NAME", 0x00220020 },
      {"IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION", 0x00220027 },
      {"IOCTL_USBPRINT_VENDOR_SET_COMMAND", 0x00220038 },
      {"IOCTL_USBPRINT_VENDOR_GET_COMMAND", 0x0022003C },
      {"IOCTL_1394_CLASS", 0x0022021D },
      {"IOCTL_USB_HCD_GET_STATS_1", 0x002203FC },
      {"IOCTL_IEEE1394_API_REQUEST", 0x00220400 },
      {"IOCTL_USB_DIAGNOSTIC_MODE_OFF", 0x00220404 },
      {"IOCTL_USB_GET_NODE_INFORMATION", 0x00220408 },
      {"IOCTL_USB_GET_NODE_CONNECTION_INFORMATION", 0x0022040C },
      {"IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION", 0x00220410 },
      {"IOCTL_USB_GET_NODE_CONNECTION_NAME", 0x00220414 },
      {"IOCTL_USB_DIAG_IGNORE_HUBS_ON", 0x00220418 },
      {"IOCTL_USB_DIAG_IGNORE_HUBS_OFF", 0x0022041C },
      {"IOCTL_INTERNAL_USB_GET_BUS_INFO", 0x00220420 },
      {"IOCTL_GET_HCD_DRIVERKEY_NAME", 0x00220424 },
      {"IOCTL_INTERNAL_USB_GET_BUSGUID_INFO", 0x00220428 },
      {"IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO", 0x0022042C },
      {"IOCTL_USB_HCD_DISABLE_PORT", 0x00220430 },
      {"IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE", 0x00220433 },
      {"IOCTL_USB_HCD_ENABLE_PORT", 0x00220434 },
      {"IOCTL_USB_GET_HUB_CAPABILITIES", 0x0022043C },
      {"IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES", 0x00220440 },
      {"IOCTL_USB_HUB_CYCLE_PORT", 0x00220444 },
      {"IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX", 0x00220448 },
      {"IOCTL_VIDEO_ENABLE_VDM", 0x00230000 },
      {"IOCTL_VIDEO_DISABLE_VDM", 0x00230004 },
      {"IOCTL_VIDEO_REGISTER_VDM", 0x00230008 },
      {"IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE", 0x0023000C },
      {"IOCTL_VIDEO_GET_OUTPUT_DEVICE_POWER_STATE", 0x00230010 },
      {"IOCTL_VIDEO_MONITOR_DEVICE", 0x00230014 },
      {"IOCTL_VIDEO_ENUM_MONITOR_PDO", 0x00230018 },
      {"IOCTL_VIDEO_INIT_WIN32K_CALLBACKS", 0x0023001C },
      {"IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS", 0x00230020 },
      {"IOCTL_VIDEO_IS_VGA_DEVICE", 0x00230024 },
      {"IOCTL_VIDEO_USE_DEVICE_IN_SESSION", 0x00230028 },
      {"IOCTL_VIDEO_PREPARE_FOR_EARECOVERY", 0x0023002C },
      {"IOCTL_VIDEO_SAVE_HARDWARE_STATE", 0x00230200 },
      {"IOCTL_VIDEO_RESTORE_HARDWARE_STATE", 0x00230204 },
      {"IOCTL_VIDEO_QUERY_AVAIL_MODES", 0x00230400 },
      {"IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES", 0x00230404 },
      {"IOCTL_VIDEO_QUERY_CURRENT_MODE", 0x00230408 },
      {"IOCTL_VIDEO_SET_CURRENT_MODE", 0x0023040C },
      {"IOCTL_VIDEO_RESET_DEVICE", 0x00230410 },
      {"IOCTL_VIDEO_LOAD_AND_SET_FONT", 0x00230414 },
      {"IOCTL_VIDEO_SET_PALETTE_REGISTERS", 0x00230418 },
      {"IOCTL_VIDEO_SET_COLOR_REGISTERS", 0x0023041C },
      {"IOCTL_VIDEO_ENABLE_CURSOR", 0x00230420 },
      {"IOCTL_VIDEO_DISABLE_CURSOR", 0x00230424 },
      {"IOCTL_VIDEO_SET_CURSOR_ATTR", 0x00230428 },
      {"IOCTL_VIDEO_QUERY_CURSOR_ATTR", 0x0023042C },
      {"IOCTL_VIDEO_SET_CURSOR_POSITION", 0x00230430 },
      {"IOCTL_VIDEO_QUERY_CURSOR_POSITION", 0x00230434 },
      {"IOCTL_VIDEO_ENABLE_POINTER", 0x00230438 },
      {"IOCTL_VIDEO_DISABLE_POINTER", 0x0023043C },
      {"IOCTL_VIDEO_SET_POINTER_ATTR", 0x00230440 },
      {"IOCTL_VIDEO_QUERY_POINTER_ATTR", 0x00230444 },
      {"IOCTL_VIDEO_SET_POINTER_POSITION", 0x00230448 },
      {"IOCTL_VIDEO_QUERY_POINTER_POSITION", 0x0023044C },
      {"IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES", 0x00230450 },
      {"IOCTL_VIDEO_GET_BANK_SELECT_CODE", 0x00230454 },
      {"IOCTL_VIDEO_MAP_VIDEO_MEMORY", 0x00230458 },
      {"IOCTL_VIDEO_UNMAP_VIDEO_MEMORY", 0x0023045C },
      {"IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES", 0x00230460 },
      {"IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES", 0x00230464 },
      {"IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES", 0x00230468 },
      {"IOCTL_VIDEO_SET_POWER_MANAGEMENT", 0x0023046C },
      {"IOCTL_VIDEO_GET_POWER_MANAGEMENT", 0x00230470 },
      {"IOCTL_VIDEO_SHARE_VIDEO_MEMORY", 0x00230474 },
      {"IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY", 0x00230478 },
      {"IOCTL_VIDEO_SET_COLOR_LUT_DATA", 0x0023047C },
      {"IOCTL_VIDEO_GET_CHILD_STATE", 0x00230480 },
      {"IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION", 0x00230484 },
      {"IOCTL_VIDEO_SET_CHILD_STATE_CONFIGURATION", 0x00230488 },
      {"IOCTL_VIDEO_SWITCH_DUALVIEW", 0x0023048C },
      {"IOCTL_VIDEO_SET_BANK_POSITION", 0x00230490 },
      {"IOCTL_BATTERY_QUERY_TAG", 0x00294040 },
      {"IOCTL_BATTERY_QUERY_INFORMATION", 0x00294044 },
      {"IOCTL_BATTERY_QUERY_STATUS", 0x0029404C },
      {"IOCTL_BATTERY_SET_INFORMATION", 0x00298048 },
      {"IOCTL_GAMEENUM_EXPOSE_HARDWARE", 0x002A0000 },
      {"IOCTL_GAMEENUM_REMOVE_HARDWARE", 0x002A0004 },
      {"IOCTL_GAMEENUM_PORT_DESC", 0x002A0008 },
      {"IOCTL_GAMEENUM_PORT_PARAMETERS", 0x002A0403 },
      {"IOCTL_GAMEENUM_EXPOSE_SIBLING", 0x002A0407 },
      {"IOCTL_GAMEENUM_REMOVE_SELF", 0x002A040B },
      {"IOCTL_GAMEENUM_ACQUIRE_ACCESSORS", 0x002A040F },
      {"IOCTL_STORAGE_CHECK_VERIFY2", 0x002D0800 },
      {"IOCTL_STORAGE_LOAD_MEDIA2", 0x002D080C },
      {"IOCTL_STORAGE_EJECTION_CONTROL", 0x002D0940 },
      {"IOCTL_STORAGE_MCN_CONTROL", 0x002D0944 },
      {"IOCTL_STORAGE_GET_MEDIA_TYPES", 0x002D0C00 },
      {"IOCTL_STORAGE_GET_MEDIA_TYPES_EX", 0x002D0C04 },
      {"IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER", 0x002D0C10 },
      {"IOCTL_STORAGE_GET_HOTPLUG_INFO", 0x002D0C14 },
      {"IOCTL_STORAGE_GET_DEVICE_NUMBER", 0x002D1080 },
      {"IOCTL_STORAGE_PREDICT_FAILURE", 0x002D1100 },
      {"IOCTL_STORAGE_QUERY_PROPERTY", 0x002D1400 },
      {"IOCTL_STORAGE_SET_READ_AHEAD", 0x002D4400 },
      {"IOCTL_STORAGE_CHECK_VERIFY", 0x002D4800 },
      {"IOCTL_STORAGE_MEDIA_REMOVAL", 0x002D4804 },
      {"IOCTL_STORAGE_EJECT_MEDIA", 0x002D4808 },
      {"IOCTL_STORAGE_LOAD_MEDIA", 0x002D480C },
      {"IOCTL_STORAGE_RESERVE", 0x002D4810 },
      {"IOCTL_STORAGE_RELEASE", 0x002D4814 },
      {"IOCTL_STORAGE_FIND_NEW_DEVICES", 0x002D4818 },
      {"IOCTL_STORAGE_RESET_BUS", 0x002D5000 },
      {"IOCTL_STORAGE_RESET_DEVICE", 0x002D5004 },
      {"IOCTL_STORAGE_BREAK_RESERVATION", 0x002D5014 },
      {"IOCTL_STORAGE_SET_HOTPLUG_INFO", 0x002DCC18 },
      {"OBSOLETE_DISK_GET_WRITE_CACHE_STATE", 0x00475356 },
      {"OBSOLETE_IOCTL_CDROM_GET_CONTROL", 0x00147508 },
      {"OBSOLETE_IOCTL_STORAGE_RESET_BUS", 0x002DD000 },
      {"OBSOLETE_IOCTL_STORAGE_RESET_DEVICE", 0x002DD004 },
      {"IOCTL_KS_PROPERTY", 0x002F0003 },
      {"IOCTL_KS_ENABLE_EVENT", 0x002F0007 },
      {"IOCTL_KS_DISABLE_EVENT", 0x002F000B },
      {"IOCTL_KS_METHOD", 0x002F000F },
      {"IOCTL_KS_RESET_STATE", 0x002F001B },
      {"IOCTL_KS_HANDSHAKE", 0x002F001F },
      {"IOCTL_KS_READ_STREAM", 0x002F4017 },
      {"IOCTL_KS_WRITE_STREAM", 0x002F8013 },
      {"IOCTL_CHANGER_GET_PARAMETERS", 0x00304000 },
      {"IOCTL_CHANGER_GET_STATUS", 0x00304004 },
      {"IOCTL_CHANGER_GET_PRODUCT_DATA", 0x00304008 },
      {"IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS", 0x00304018 },
      {"IOCTL_CHANGER_SET_POSITION", 0x0030401C },
      {"IOCTL_CHANGER_EXCHANGE_MEDIUM", 0x00304020 },
      {"IOCTL_CHANGER_MOVE_MEDIUM", 0x00304024 },
      {"IOCTL_CHANGER_REINITIALIZE_TRANSPORT", 0x00304028 },
      {"IOCTL_CHANGER_SET_ACCESS", 0x0030C010 },
      {"IOCTL_CHANGER_GET_ELEMENT_STATUS", 0x0030C014 },
      {"IOCTL_CHANGER_QUERY_VOLUME_TAGS", 0x0030C02C },
      {"IOCTL_SMARTCARD_POWER", 0x00310004 },
      {"IOCTL_SMARTCARD_GET_ATTRIBUTE", 0x00310008 },
      {"IOCTL_SMARTCARD_SET_ATTRIBUTE", 0x0031000C },
      {"IOCTL_SMARTCARD_CONFISCATE", 0x00310010 },
      {"IOCTL_SMARTCARD_TRANSMIT", 0x00310014 },
      {"IOCTL_SMARTCARD_EJECT", 0x00310018 },
      {"IOCTL_SMARTCARD_SWALLOW", 0x0031001C },
      {"IOCTL_SMARTCARD_IS_PRESENT", 0x00310028 },
      {"IOCTL_SMARTCARD_IS_ABSENT", 0x0031002C },
      {"IOCTL_SMARTCARD_SET_PROTOCOL", 0x00310030 },
      {"IOCTL_SMARTCARD_GET_STATE", 0x00310038 },
      {"IOCTL_SMARTCARD_GET_LAST_ERROR", 0x0031003C },
      {"IOCTL_SMARTCARD_GET_PERF_CNTR", 0x00310040 },
      {"IOCTL_DVD_START_SESSION", 0x00335000 },
      {"IOCTL_DVD_READ_KEY", 0x00335004 },
      {"IOCTL_DVD_SEND_KEY", 0x00335008 },
      {"IOCTL_DVD_END_SESSION", 0x0033500C },
      {"IOCTL_DVD_SET_READ_AHEAD", 0x00335010 },
      {"IOCTL_DVD_GET_REGION", 0x00335014 },
      {"IOCTL_DVD_READ_STRUCTURE", 0x00335140 },
      {"IOCTL_DVD_SEND_KEY2", 0x0033D018 },
      {"IOCTL_FSVIDEO_COPY_FRAME_BUFFER", 0x00340800 },
      {"IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER", 0x00340804 },
      {"IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER", 0x00340808 },
      {"IOCTL_FSVIDEO_SET_CURRENT_MODE", 0x0034080C },
      {"IOCTL_FSVIDEO_SET_SCREEN_INFORMATION", 0x00340810 },
      {"IOCTL_FSVIDEO_SET_CURSOR_POSITION", 0x00340814 },
      {"IOCTL_SERENUM_EXPOSE_HARDWARE", 0x00370200 },
      {"IOCTL_SERENUM_REMOVE_HARDWARE", 0x00370204 },
      {"IOCTL_INTERNAL_SERENUM_REMOVE_SELF", 0x00370207 },
      {"IOCTL_SERENUM_PORT_DESC", 0x00370208 },
      {"IOCTL_SERENUM_GET_PORT_NAME", 0x0037020C },
      {"IOCTL_DOT4_OPEN_CHANNEL", 0x003A2006 },
      {"IOCTL_DOT4_CLOSE_CHANNEL", 0x003A2008 },
      {"IOCTL_DOT4_READ", 0x003A200E },
      {"IOCTL_DOT4_WRITE", 0x003A2011 },
      {"IOCTL_DOT4_ADD_ACTIVITY_BROADCAST", 0x003A2014 },
      {"IOCTL_DOT4_REMOVE_ACTIVITY_BROADCAST", 0x003A2018 },
      {"IOCTL_DOT4_WAIT_ACTIVITY_BROADCAST", 0x003A201E },
      {"IOCTL_DOT4_CREATE_SOCKET", 0x003A2022 },
      {"IOCTL_DOT4_WAIT_FOR_CHANNEL", 0x003A2026 },
      {"IOCTL_DOT4_DESTROY_SOCKET", 0x003A202A },
      {"IOCTL_SA_GET_VERSION", 0x00412002 },
      {"IOCTL_SA_GET_CAPABILITIES", 0x00412006 },
      {"IOCTL_NVRAM_WRITE_BOOT_COUNTER", 0x00412026 },
      {"IOCTL_NVRAM_READ_BOOT_COUNTER", 0x0041202A },
      {"IOCTL_SADISPLAY_LOCK", 0x00412032 },
      {"IOCTL_SADISPLAY_UNLOCK", 0x00412036 },
      {"IOCTL_SADISPLAY_BUSY_MESSAGE", 0x0041203A },
      {"IOCTL_SADISPLAY_SHUTDOWN_MESSAGE", 0x0041203E },
      {"IOCTL_SADISPLAY_CHANGE_LANGUAGE", 0x00412042 },
      {"IOCTL_FUNC_DISPLAY_STORE_BITMAP", 0x00412046 },
      {"IOCTL_MOUNTDEV_QUERY_UNIQUE_ID", 0x004D0000 },
      {"IOCTL_MOUNTDEV_QUERY_DEVICE_NAME", 0x004D0008 },
      {"IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME", 0x004D000C },
      {"IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY", 0x004DC004 },
      {"IOCTL_MOUNTDEV_LINK_CREATED", 0x004DC010 },
      {"IOCTL_MOUNTDEV_LINK_DELETED", 0x004DC014 },
      {"IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS", 0x00560000 },
      {"IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE", 0x00560004 },
      {"IOCTL_VOLUME_IS_OFFLINE", 0x00560010 },
      {"IOCTL_VOLUME_IS_IO_CAPABLE", 0x00560014 },
      {"IOCTL_VOLUME_QUERY_FAILOVER_SET", 0x00560018 },
      {"IOCTL_VOLUME_QUERY_VOLUME_NUMBER", 0x0056001C },
      {"IOCTL_VOLUME_LOGICAL_TO_PHYSICAL", 0x00560020 },
      {"IOCTL_VOLUME_PHYSICAL_TO_LOGICAL", 0x00560024 },
      {"IOCTL_VOLUME_IS_PARTITION", 0x00560028 },
      {"IOCTL_VOLUME_IS_CLUSTERED", 0x00560030 },
      {"IOCTL_VOLUME_SET_GPT_ATTRIBUTES", 0x00560034 },
      {"IOCTL_VOLUME_GET_GPT_ATTRIBUTES", 0x00560038 },
      {"IOCTL_VOLUME_READ_PLEX", 0x0056402E },
      {"IOCTL_VOLUME_ONLINE", 0x0056C008 },
      {"IOCTL_VOLUME_OFFLINE", 0x0056C00C },
      {"FT_INITIALIZE_SET", 0x00660000 },
      {"FT_REGENERATE", 0x00660004 },
      {"FT_CONFIGURE", 0x0066000B },
      {"FT_VERIFY", 0x0066000C },
      {"FT_BALANCED_READ_MODE", 0x0066001B },
      {"FT_SYNC_REDUNDANT_COPY", 0x0066001C },
      {"FT_SEQUENTIAL_WRITE_MODE", 0x00660023 },
      {"FT_PARALLEL_WRITE_MODE", 0x00660027 },
      {"FT_QUERY_SET_STATE", 0x00660028 },
      {"FT_CLUSTER_SET_MEMBER_STATE", 0x0066002C },
      {"FT_CLUSTER_GET_MEMBER_STATE", 0x00660030 },
      {"FT_SECONDARY_READ", 0x00664012 },
      {"FT_PRIMARY_READ", 0x00664016 },
      {"FT_ENUMERATE_LOGICAL_DISKS", 0x00674008 },
      {"FT_QUERY_LOGICAL_DISK_INFORMATION", 0x0067400C },
      {"FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK", 0x00674018 },
      {"FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK", 0x00674020 },
      {"FT_CHECK_IO", 0x00674024 },
      {"FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION", 0x00674030 },
      {"FT_CHANGE_NOTIFY", 0x00674034 },
      {"FT_QUERY_LOGICAL_DISK_ID", 0x00674190 },
      {"FT_CREATE_LOGICAL_DISK", 0x0067C000 },
      {"FT_BREAK_LOGICAL_DISK", 0x0067C004 },
      {"FT_ORPHAN_LOGICAL_DISK_MEMBER", 0x0067C010 },
      {"FT_REPLACE_LOGICAL_DISK_MEMBER", 0x0067C014 },
      {"FT_INITIALIZE_LOGICAL_DISK", 0x0067C01C },
      {"FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK", 0x0067C028 },
      {"FT_STOP_SYNC_OPERATIONS", 0x0067C038 },
      {"FT_CREATE_PARTITION_LOGICAL_DISK", 0x0067C194 },
      {"IOCTL_MOUNTMGR_QUERY_POINTS", 0x006D0008 },
      {"IOCTL_MOUNTMGR_CHANGE_NOTIFY", 0x006D4020 },
      {"IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES", 0x006D4028 },
      {"IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION", 0x006D402C },
      {"IOCTL_MOUNTMGR_CREATE_POINT", 0x006DC000 },
      {"IOCTL_MOUNTMGR_DELETE_POINTS", 0x006DC004 },
      {"IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY", 0x006DC00C },
      {"IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER", 0x006DC010 },
      {"IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS", 0x006DC014 },
      {"IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED", 0x006DC018 },
      {"IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED", 0x006DC01C },
      {"IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE", 0x006DC024 },
      {"IOCTL_GET_VERSION", 0x80002000 },
      {"IOCTL_CANCEL_IO", 0x80002004 },
      {"IOCTL_WAIT_ON_DEVICE_EVENT", 0x80002008 },
      {"IOCTL_READ_REGISTERS", 0x8000200C },
      {"IOCTL_WRITE_REGISTERS", 0x80002010 },
      {"IOCTL_GET_CHANNEL_ALIGN_RQST", 0x80002014 },
      {"IOCTL_GET_DEVICE_DESCRIPTOR", 0x80002018 },
      {"IOCTL_RESET_PIPE", 0x8000201C },
      {"IOCTL_GET_USB_DESCRIPTOR", 0x80002020 },
      {"IOCTL_GET_PIPE_CONFIGURATION", 0x80002028 },
		{NULL, 0},
	};
```

`source/WispSyser/keymappingpage.cpp`:

```cpp

#include "keymappingpage.hpp"
#include "resource.hpp"
#include "../wisp/wispbase.hpp"

struct KEYS
{
	const char *Name;
	unsigned char ScanCode;
} keys [] =
{
{ "", 255 },
{ "Esc", 27 },
{ "1", 49 },
{ "2", 50 },
{ "3", 51 },
{ "4", 52 },
{ "5", 53 },
{ "6", 54 },
{ "7", 55 },
{ "8", 56 },
{ "9", 57 },
{ "0", 48 },
{ "-", 189 },
{ "+", 187 },
{ "Backspace", 8 },
{ "Tab", 9 },
{ "Q", 81 },
{ "W", 87 },
{ "E", 69 },
{ "R", 82 },
{ "T", 84 },
{ "Y", 89 },
{ "U", 85 },
{ "I", 73 },
{ "O", 79 },
{ "P", 80 },
{ "[", 219 },
{ "]", 221 },
{ "Enter", 13 },
{ "Ctrl", 17 },
{ "A", 65 },
{ "S", 83 },
{ "D", 68 },
{ "F", 70 },
{ "G", 71 },
{ "H", 72 },
{ "J", 74 },
{ "K", 75 },
{ "L", 76 },
{ ";", 186 },
{ "'", 222 },
{ "", 255 },
{ "Shift", 16 },
{ "\\", 220 },
{ "Z", 90 },
{ "X", 88 },
{ "C", 67 },
{ "V", 86 },
{ "B", 66 },
{ "N", 78 },
{ "M", 77 },
{ ",", 188 },
{ ".", 190 },
{ "/", 191 },
{ "Shift", 16 },
{ "*", 106 },
{ "Alt", 18 },
{ "Space", 32 },
{ "Caps Lock", 20 },
{ "F1", 112 },
{ "F2", 113 },
{ "F3", 114 },
{ "F4", 115 },
{ "F5", 116 },
{ "F6", 117 },
{ "F7", 118 },
{ "F8", 119 },
{ "F9", 120 },
{ "F10", 121 },
{ "Num Lock", 144 },
{ "", 145 },
{ "Numeric pad 7", 103 },
{ "Numeric pad 8", 104 },
{ "Numeric pad 9", 105 },
{ "", 109 },
{ "Numeric pad 4", 100 },
{ "Numeric pad 5", 101 },
{ "Numeric pad 6", 102 },
{ "", 107 },
{ "Numeric pad 1", 97 },
{ "Numeric pad 2", 98 },
{ "Numeric pad 3", 99 },
{ "Numeric pad 0", 96 },
{ "Decimal", 110 },
{ "", 255 },
{ "", 255 },
{ "", 255 },
{ "F11", 122 },
{ "F12", 123 },
{ "", 255 },
{ "", 255 },
{ "", 255 },
{ "", 255 },
{ "", 255 },
{ "", 255 },
{ "", 255 },
{ "", 255 },
{ "", 19 },
{ "", 255 },
{ "", 255 },
{ "Up", 38 },
{ "Down", 40 },
};
	WCHAR *CKeyMappingPage::GetHotKey(unsigned int KeyType, WCHAR *szKeys)
	{
		if (!szKeys) return 0;
		*szKeys = 0;

		if (KeyType & 0xFFFFFF)
		{
			if (KeyType & WISP_SK_CTRL) TStrCpy(szKeys, "Ctrl+"); //??? TStrCat
			if (KeyType & WISP_SK_ALT) TStrCat(szKeys, "Alt+");
			if (KeyType & WISP_SK_SHIFT) TStrCat(szKeys, "Shift+");

			for (int i = 0; i < lenof(keys); ++i)
			{
				if ((KeyType & 0xFFFFFF) == keys[i].ScanCode)
				{
					TStrCat(szKeys, keys[i].Name);
					return szKeys;
				}
			}

			
		} else
		{
			for (int i = 0; i < lenof(keys); ++i)
			{
				if ((KeyType & 0xFF000000) == keys[i].ScanCode)
				{
					TStrCpy(szKeys, keys[i].Name);
					return szKeys;
				}
			}
		}
		return szKeys;
	}

KEYMAP gGlobalKeyMap[] =
{
	{"ActiveHotKey", WISP_SK_CTRL, 0x7B, 0, 0, 0},
	{"Debug:Continue", 0x74, 0, EVENT_ID_GO, 0, 0},
	{"Debug:Return", 0x75, 0, EVENT_ID_DBG_RETURN, 0, 0},
	{"Debug:Step", 0x77, 0, EVENT_ID_DBG_STEP, 0, 0},
	{"Debug:Proceed", 0x79, 0, EVENT_ID_DBG_PROCEED, 0, 0},
	{"Debug:Step Branch", 0x7A, 0, EVENT_ID_DBG_STEPB, 0, 0},
	{"Debug:Break Point", WISP_SK_CTRL, 0x78, EVENT_ID_BREAK_POINT, 0, 0},
	{"Monitor:Register View", WISP_SK_ALT, 0x47, EVENT_ID_REGVIEW, 0, 0},
	{"Monitor:Data View", WISP_SK_ALT, 0x44, EVENT_ID_DATAVIEW, 0, 0},
	{"Monitor:Call Stack", WISP_SK_ALT, 0x43, EVENT_ID_CALLSTACK, 0, 0},
	{"View:Toggle BookMark", WISP_SK_CTRL, 0x4B, EVENT_ID_TOGGLE_BM, 0, 0},
	{"View:Previous BookMark", WISP_SK_CTRL, 0x50, EVENT_ID_PREV_BM, 0, 0},
	{"View:Next BookMark", WISP_SK_CTRL, 0x4E, EVENT_ID_NEXT_BM, 0, 0},
	{"View:Clear BookMark", WISP_SK_CTRL, 0x4C, EVENT_ID_CLEAR_BM, 0, 0},
	{0},
};

```

`source/WispSyser/keymappingpage.hpp`:

```hpp

#ifndef _KEYMAPPINGPAGE_HPP_
#define _KEYMAPPINGPAGE_HPP_

#include "../Wisp/wispform.hpp"

struct KEYMAP
{
	const char *Name;
	unsigned int FirstKey;
	unsigned int NextKey;
	unsigned int CmdID;
	unsigned int r;
	unsigned int s;
};

extern KEYMAP gGlobalKeyMap[];

struct CKeyMappingPage : public CWispForm
{
	WCHAR *GetHotKey(unsigned int KeyType, WCHAR *szKeys);
};

#endif
```

`source/WispSyser/lex.cpp`:

```cpp

#include "../Code/define.h"
#include "../Code/tstrmem.hpp"
#include "../Code/alt/altmap.hpp"

//
#if 0
	char *yytext = NULL;
	int yyleng = 0;

	void yyrestart(FILE*)
	{
		//???
	}

	int yylex()
	{
		//???
		return 0;
	}
#endif
//
	//static 
	const char *teststr = NULL;

	static const char *strsol = "int main(int argc, char* argv[]);";
	static const char *streol = NULL;

	void yy_set_input(const char *str)
	{
		strsol = str;
		streol = &str[TStrLen(str)];
	}

	int yy_input(char *data, int max_size)
	{
		int size = streol - strsol;
		if (size > max_size)
			size = max_size;
		if (size > 0)
		{
			memcpy(data, strsol, size);
			strsol += size;
		}
		return size;
	}

#undef YY_INPUT
#define YY_INPUT(data, res, max_size) res = yy_input(data, max_size)

#define yyalloc Syser_malloc

	static map<void*, unsigned int> *gpMemMap = nullptr;

	void *Syser_malloc(unsigned int size)
	{
		unsigned char *ptr = new unsigned char[size];
		if (!ptr) return nullptr;
		if (!gpMemMap)
			gpMemMap = new map<void*, unsigned int>;
		gpMemMap->insert(_Tmap_pair<void*, unsigned int>(ptr, size));
		return ptr;		
	}

#define yyfree Syser_free

	void Syser_free(void *ptr)
	{
		map<void*, unsigned int>::IT it = gpMemMap->find(ptr);
		if (it != gpMemMap->end())
		{
			gpMemMap->erase(it);
			delete []ptr;
			if (gpMemMap->size() == 0)
			{
				delete gpMemMap;
				gpMemMap = nullptr;
			}
		}
	}

#define yyrealloc Syser_realloc

	void *Syser_realloc(void *ptr, unsigned int size)
	{
		map<void*, unsigned int>::IT it = gpMemMap->find(ptr);
		if (it != gpMemMap->end())
		{
			if (it->second >= size)
				return ptr;
			void *p = Syser_malloc(size);
			memcpy(p, ptr, it->second);
			Syser_free(ptr);
			return p;
		}
		return nullptr;
	}
//

#include <stdlib.h>
//#include <unistd.h>
#include <stdio.h>

#define yyconst const

typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
	};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart(FILE *input_file);

void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
void yy_load_buffer_state();
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size);
void yy_delete_buffer(YY_BUFFER_STATE b);
void yy_init_buffer(YY_BUFFER_STATE b, FILE *file);
void yy_flush_buffer(YY_BUFFER_STATE b);
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

//YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
//YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
//YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc(yy_size_t);
static void *yy_flex_realloc(void *, yy_size_t);
static void yy_flex_free(void *);
/*
#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
*/
//typedef unsigned char YY_CHAR;
typedef unsigned long YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state();
static yy_state_type yy_try_NUL_trans(yy_state_type current_state);
static int yy_get_next_buffer();

#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define YY_END_OF_BUFFER 201
static yyconst flex_int16_t yy_accept[812] = 
	{
   0,    0,    0,    0,    0,  201,  199,    1,    3,    2, 
 160,  199,  148,  162,  155,  199,  145,  146,  156,  157, 
 147,  158,  154,  161,  140,  139,  168,  169,  163,  170, 
 164,  167,  138,  138,  152,  153,  165,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  150,  166,  151,  159, 
 200,  200,    1,    3,    0,    2,  182,    0,  144,    0, 
 149,    0,    0,    0,    0,    0,    0,  187,  183,  192, 
   0,    0,  185,  175,  188,  176,  189,  173,  171,    0, 
 142,  196,    0,  186,  142,  140,    0,    0,  140,  140, 
   0,  139,  139,  139,  172,  177,  179,  181,  180,  178, 
 138,    0,    0,  193,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,   65,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,   77,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 194,  184,  197,    0,    0,    0,    0,    0,    0,  129, 
   0,    0,    0,    0,    0,    0,  143,    0,    0,  174, 
 195,    0,  142,    0,  198,    0,  142,  140,  141,  139, 
 190,  191,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
  74,  138,  138,  138,   79,  138,  138,  138,  138,   84, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  110,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
   0,  142,  141,  141,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,   17,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
  51,  138,   53,  138,   55,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,   68,   69,  138,  138,  138, 
 138,  138,   76,  138,   80,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  106,  138, 
 138,  109,  138,  138,  138,  138,  117,  138,  119,  138, 
 138,  138,    0,    0,    0,  128,  132,    0,    0,    0, 
   0,    0,    0,  134,    0,    0,    0,    0,    0,  141, 
 138,  138,    6,  138,  138,    9,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,   29,  138,  138,  138,   36,  138,  138,  138,  138, 
 138,  138,   44,  138,  138,  138,  138,   50,  138,   52, 
  54,   56,   57,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,   72,   73,  138,  138,  138,   82,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,   98,  138,  138,  138,  138,  138,  138, 
 138,  108,  138,  138,  138,  114,  138,  116,  138,  138, 
 138,  123,    0,  135,  125,  133,    0,    0,    0,    0, 
 127,  131,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,   18,  138,  138,  138,  138,  138, 
 138,  138,   23,  138,  138,   30,  138,   34,   35,  138, 
 138,  138,  138,  138,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,   61,  138,  138,  138,   66,  138, 
 138,   71,   75,   78,  138,  138,  138,  138,  138,  138, 
 138,  138,  138,  138,   93,  138,  138,   96,  138,   99, 
 100,  101,  103,  104,  138,  107,  138,  112,  138,  138, 
 138,  138,  138,  124,  136,  126,    0,  137,  138,  138, 
 138,    8,   10,  138,  138,   13,  138,  138,  138,  138, 
 138,  138,  138,  138,   24,   25,   26,  138,   28,   31, 
  32,  138,  138,   38,  138,  138,  138,   42,  138,  138, 
 138,   48,  138,  138,  138,  138,   60,  138,  138,  138, 
 138,  138,   81,  138,  138,  138,   87,  138,  138,   90, 
 138,  138,  138,  138,  138,  138,  138,  111,  138,  138, 
 118,  138,  122,  130,  138,  138,    7,  138,  138,   14, 
 138,  138,  138,  138,  138,  138,   22,  138,  138,  138, 
  39,  138,  138,  138,   46,   47,  138,  138,  138,   59, 
 138,  138,  138,  138,   70,  138,   85,   86,   88,   89, 
  91,  138,   94,  138,  138,  138,  105,  113,  115,  120, 
 138,    5,  138,  138,  138,   45,  138,  138,  138,  138, 
 138,  138,  138,  138,   41,  138,  138,  121,  138,  138, 
  63,   64,  138,   83,   92,  138,   97,  138,    4,   11, 
  12,   15,  138,  138,  138,  138,  138,  138,   37,  138, 
  43,  138,   58,   62,  138,  138,  138,  138,  138,   20, 
 138,   27,  138,  138,  138,  138,  138,  102,  138,   19, 
 138,  138,  138,  138,   67,  138,   16,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,  138,   21,  138,  138, 
 138,  138,  138,  138,  138,   95,  138,  138,  138,  138, 
 138,  138,  138,  138,  138,  138,   40,  138,  138,   49, 
  33,    0, 
	};

static yyconst YY_CHAR yy_ec[256] =
	{
   0,    1,    1,    1,    1,    1,    1,    1,    1,    2, 
   3,    4,    5,    6,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    7,    8,    9,   10,    1,   11,   12,   13, 
  14,   15,   16,   17,   18,   19,   20,   21,   22,   23, 
  24,   25,   26,   27,   28,   27,   29,   30,   31,   32, 
  33,   34,   35,   36,    1,   37,   37,   37,   37,   38, 
  39,   40,   40,   40,   40,   40,   41,   40,   40,   40, 
  40,   40,   40,   40,   40,   42,   40,   40,   43,   40, 
  40,   44,   45,   46,   47,   48,    1,   49,   50,   51, 
  52,   53,   54,   55,   56,   57,   40,   58,   59,   60, 
  61,   62,   63,   40,   64,   65,   66,   67,   68,   69, 
  70,   71,   72,   73,   74,   75,   76,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1, 
	};

static yyconst YY_CHAR yy_meta[78] =
	{
   0,    1,    1,    2,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    3,    1,    1,    1,    1,    1,    1, 
   4,    1,    5,    5,    5,    5,    5,    5,    5,    5, 
   5,    1,    1,    1,    1,    1,    1,    6,    7,    8, 
   9,   10,    9,    9,    1,    1,    1,    1,    9,    6, 
   6,    6,    6,    7,    8,    9,    9,    9,    9,   10, 
   9,    9,    9,    9,    9,    9,    9,    9,    9,    9, 
   9,    9,    9,    1,    1,    1,    1,    0,
 	};

static yyconst flex_uint16_t yy_base[824] =
	{
   0,    0,    0, 1116, 1115, 1130, 1133,   75, 1133,   81, 
1095,   80,   80, 1094,   79, 1082, 1133, 1133, 1092,   75, 
1133,   76,   77,   96,  128,  179, 1094, 1133,   81, 1090, 
  84, 1133,    0,   85, 1133, 1133, 1089, 1074,   58,   67, 
 106,   75,   82, 1059,   67, 1058, 1052,  111, 1055,   60, 
1064,  119,  126,  113,   78,  111, 1133,  115, 1133, 1133, 
1133, 1095,  208, 1133,  220,  237, 1133,  174, 1133,  238, 
1133, 1062,  132,  174, 1057, 1049,   77, 1133, 1133, 1133, 
 171,  300, 1133, 1133, 1133, 1133, 1133, 1096, 1133, 1091, 
 214, 1133, 1107, 1133,  218,  175,  216,  350,  119,  189, 
   0,    0,  191,  190, 1133, 1075, 1133, 1133, 1133, 1074, 
   0,  241, 1062, 1133,  332, 1044, 1052,  210, 1055, 1054, 
1041,  226, 1042, 1033, 1038, 1033, 1030,  215, 1037, 1033, 
1030, 1036, 1026,    0,  225, 1030, 1024,  134, 1020,  237, 
1035,  233, 1037,  241, 1027, 1023,  238,  233, 1027, 1023, 
 254,  245, 1019,  172, 1024, 1023, 1015,  258, 1022, 1020, 
1133, 1133, 1133,  381,    0, 1022,  264, 1023, 1010,  218, 
1010, 1021, 1010, 1021, 1017, 1011, 1133,  389,    0, 1133, 
1133,  413, 1133, 1064, 1133,  422,  292, 1133,  293, 1133, 
1133, 1133,  282,  281, 1014, 1012,  269,  291, 1013, 1001, 
 304, 1009,  395,  999,  298, 1011,  400,  995,  253,  314, 
 291,  999, 1008, 1003, 1004,  990,  988,  354, 1003,  998, 
 986,  368,  999,  999,  994,  986,  986,  991,  978,  993, 
   0,  988,  978,  982,    0,  983,  988,  983,  982,    0, 
 973,  980,  976,  965,  966,  961,  361,  969,  970,  965, 
 958,  971,  959,  961,  968,  954,  952,  952,  954,  951, 
 369,  962,    0,  961,  951,  955,  950,  958,  943,  956, 
 958,  957,  946,  446,  483,  947,  949,  949,  944,  938, 
 946,  946,  935,  937,  942,  939,  940,  931,  471,  525, 
 453,  485,  387,  369,  926,  933,  396,  924,  918,  934, 
 464,  933,  934,  919,  922,  918,    0,  919,  927,  931, 
 399,  929,  953,  950,  916,  463,  913,  911,  915,  922, 
 909,  917,  905,  896,  910,  908,  905,  899,  936,  905, 
   0,  902,    0,  903,    0,  893,  891,  899,  888,  888, 
 900,  882,  891,  891,  889,    0,    0,  891,  883,  893, 
 879,  883,    0,  882,    0,  892,  889,  875,  880,  872, 
 873,  887,  886,  885,  880,  879,  874,  865,  863,  864, 
 876,  860,  872,  862,  866,  871,  870,  861,    0,  870, 
 849,    0,  504,  856,  861,  860,    0,  847,    0,  847, 
 848,  858,  455,    0,  849, 1133, 1133,  855,  844,  853, 
 853,  841,  837, 1133,  843,  848,  846,  472,    0, 1133, 
 834,  844,    0,  831,  844,    0,  845,  836,  841,  832, 
 839,  825,  841,  838,  830,  826,  466,  829,  543,  817, 
 855,    0,  817,  831,  818,    0,  817,  814,  819,  822, 
 825,  822,  826,  811,  820,  804,  804,    0,  820,    0, 
   0,    0,  820,  806,  807,  812,  813,  800,  799,  808, 
 803,  808,  797,    0,    0,  805,  803,  796,    0,  791, 
 796,  785,  789,  800,  783,  782,  783,  795,  794,  778, 
 790,  781,  775,    0,  788,  785,  787,  771,  780,  786, 
 782,    0,  780,  780,  782,    0,  769,    0,  780,  771, 
 779,    0,  773, 1133, 1133, 1133,  771,  758,  771,  773, 
1133, 1133,  757,  759,  759,  766,  758,  751,  760,  748, 
 750,  761,  752,  757,    0,  743,  738,  745,  745,  777, 
 780,  777,    0,  738,  748,  488,  743,    0,    0,  746, 
 745,  744,  737,  746,  730,  742,  730,  729,  737,  722, 
 724,  736,  719,  719,    0,  735,  721,  720,    0,  730, 
 723,    0,    0,    0,  726,  729,  716,  712,  706,  715, 
 711,  719,  705,  704,    0,  716,  704,    0,  718,    0, 
   0,  718,    0,    0,  699,    0,  710,    0,  703,  709, 
 702,  701,  693, 1133, 1133, 1133,  705, 1133,  708,  694, 
 702,    0,    0,  691,  704,    0,  686,  702,  691,  692, 
 691,  690,  680,  692,    0,    0,    0,  690,    0,    0, 
   0,  680,  678,    0,  689,  687,  680,    0,  689,  679, 
 682,    0,  686,  686,  684,  679,    0,  665,  666,  665, 
 680,  661,    0,  675,  672,  663,    0,  670,  658,    0, 
 650,  667,  655,  655,  656,  665,  662,    0,  661,  661, 
   0,  659,    0, 1133,  660,  656,    0,  656,  642,    0, 
 648,  635,  644,  650,  638,  654,    0,  652,  641,  633, 
   0,  650,  638,  631,    0,    0,  636,  628,  628,    0, 
 639,  625,  624,  638,    0,  635,    0,    0,    0,    0, 
   0,  635,    0,  622,  614,  635,    0,    0,    0,    0, 
 617,    0,  631,  628,  621,    0,  620,  621,  611,  622, 
 622,  619,  598,  610,    0,  600,  603,    0,  571,  582, 
   0,    0,  570,    0,    0,  565,    0,  543,    0,    0, 
   0,    0,  538,  541,  528,  522,  538,  542,    0,  528, 
   0,  531,    0,    0,  522,  520,  519,  523,  519,    0, 
 525,    0,  524,  524,  512,  503,  519,    0,  507,    0, 
 494,  497,  504,  490,    0,  492,    0,  476,  485,  467, 
 477,  480,  449,   43,   51,   99,  135,    0,  236,  272, 
 287,  291,  302,  345,  367,    0,  393,  399,  414,  437, 
 436,  427,  428,  437,  450,  451,    0,  450,  451,    0, 
   0, 1133,  596,  606,  616,  622,  628,  638,  645,  648, 
 652,  656,  660,  666, 
	};

static yyconst flex_int16_t yy_def[824] =
	{
   0,  811,    1,  812,  812,  811,  811,  811,  811,  811, 
 811,  813,  811,  811,  811,  814,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  815,  815,  811,  811,  811,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  813,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 814,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 816,  811,  817,  811,  816,   24,  818,  811,  811,  811, 
 819,   25,  811,  811,  811,  811,  811,  811,  811,  811, 
 815,  813,  814,  811,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 811,  811,  811,  813,  820,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  814,  821,  811, 
 811,  811,  811,  817,  811,  811,  822,  811,  819,  811, 
 811,  811,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  813,  813,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  814,  814, 
 811,  823,  811,  811,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  813,  274,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  814,  289,  811, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  811,  811,  811,  811,  811,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  811,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,  815,  815,  815,  815,  815,  815,  815,  815,  815, 
 815,    0,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811, 
	};

static yyconst flex_uint16_t yy_nxt[1212] =
	{
   0,    6,    7,    8,    9,    9,    9,    7,   10,   11, 
  12,   13,   14,   15,   16,   17,   18,   19,   20,   21, 
  22,   23,   24,   25,   25,   25,   25,   25,   25,   25, 
  25,   26,   27,   28,   29,   30,   31,   32,   32,   32, 
  32,   33,   32,   32,   34,    6,   35,   36,   37,   32, 
  38,   39,   40,   41,   42,   43,   32,   44,   32,   45, 
  46,   47,   48,   49,   50,   51,   52,   53,   54,   55, 
  32,   32,   32,   56,   57,   58,   59,   62,   63,   64, 
  64,   64,   62,   64,   63,   65,   65,   65,   64,   68, 
  70,   78,   83,   88,  111,   85,  788,   89,  112,   90, 
  90,   90,   90,   90,   90,   90,   90,   90,  789,   84, 
  86,   87,   91,   79,  105,  106,  117,   92,  108,  109, 
 115,  133,  116,  118,  141,   69,  119,  142,  134,  120, 
  93,  128,   71,   72,  125,  156,  126,   73,  174,   74, 
 157,  129,  175,   75,  130,  127,  131,   76,   94,  160, 
  95,   95,   95,   95,   95,   95,   95,   96,   96,  121, 
 137,  187,  158,  790,  138,  122,   97,  159,  123,   98, 
  99,  100,  144,  139,  153,  145,  146,  124,  154,  149, 
 155,   97,  150,   68,  176,  147,  187,   98,  148,  161, 
 151,  166,  237,  167,  238,   99,  168,  152,  100,   94, 
 791,  101,  101,  101,  101,  101,  101,  101,  101,  101, 
  62,   63,   64,   64,   64,   62,   81,   97,  811,   69, 
 102,  103,   64,   63,   64,   64,   64,   64,  169,  264, 
 187,  189,   97,  189,  170,  171,   94,  265,  102,   64, 
  63,   65,   65,   65,   64,  811,  103,   67,  187,  189, 
  68,   67,  181,  182,   97,  182,  181,  182,  189,  182, 
 163,  163,  163,  163,  163,  163,  163,  181,  182,   97, 
 280,  181,  182,  182,   67,  213,  214,  182,  226,  281, 
 218,  227,  255,   67,  233,  219,   69,   67,   67,  220, 
 245,  234,   67,  253,  240,  246,  248,  256,  249,   67, 
 792,  241,   67,  242,   67,  243,   67,  250,  164,   80, 
 254,  259,  261,   80,  324,  269,  262,  270,  260,  328, 
 325,  276,  177,  177,  177,  177,  177,  177,  177,  277, 
 297,  182,  294,  182,  292,  293,   80,  301,  793,  302, 
 303,  295,  329,  298,  794,   80,  182,  296,  304,   80, 
  80,  182,  292,  305,   80,  316,  308,  795,  309,  796, 
 293,   80,  317,  326,   80,  310,   80,  185,   80,  185, 
 178,  327,  186,  186,  186,  186,  186,  186,  186,  186, 
 186,  192,  193,  194,  195,  196,  197,  198,  199,  200, 
  68,  201,  202,  203,  797,  204,  205,  206,  207,  208, 
 209,  210,  176,  273,  273,  273,  273,  273,  273,  273, 
 409,  288,  288,  288,  288,  288,  288,  288,  312,  336, 
 337,  341,  379,  313,  364,  342,   69,  365,  409,  409, 
 290,  380,  290,  798,   81,  291,  291,  291,  291,  291, 
 291,  291,  291,  291,  186,  186,  186,  186,  186,  186, 
 186,  186,  186,  319,  409,   68,  412,  320,  427,  799, 
 800,  413,  314,  801,   68,  428,  321,  322,  392,  392, 
 392,  392,  392,  392,  392,  291,  291,  291,  291,  291, 
 291,  291,  291,  291,  176,  176,  802,  803,  804,  805, 
 806,   69,   68,  407,  407,  407,  407,  407,  407,  407, 
  69,  807,  808,  809,  810,  393,  393,  393,  393,  393, 
 393,  393,  393,  393,  787,  417,   81,   81,  433,  526, 
 393,  393,  393,  418,  182,  434,  182,  527,   69,  786, 
 785,  784,  393,  393,  393,  393,  393,  393,  176,  182, 
 619,  783,  782,  781,  182,  620,  780,  408,  408,  408, 
 408,  408,  408,  408,  408,  408,  492,  779,  778,  777, 
 776,  493,  408,  408,  408,  494,  529,  775,  530,  774, 
  81,  531,  532,  773,  408,  408,  408,  408,  408,  408, 
 772,  771,  770,  769,  768,  767,  766,  765,  764,  763, 
 762,  761,  760,  759,  758,  757,  533,   60,   60,   60, 
  60,   60,   60,   60,   60,   60,   60,   67,  756,   67, 
  67,   67,   67,   67,   67,   67,   67,   80,  755,  754, 
  80,   80,   80,   80,   80,   80,   80,  110,  110,  110, 
 110,  110,  110,   90,  753,   90,   90,  752,   90,  183, 
 183,  183,  183,  183,  183,  183,  183,  183,  183,   96, 
  96,  751,   96,  188,  188,  188,  188,  274,  274,  274, 
 274,  289,  289,  289,  289,  186,  750,  749,  186,  748, 
 186,  291,  747,  746,  291,  745,  291,  744,  743,  742, 
 741,  740,  739,  738,  737,  736,  735,  734,  733,  732, 
 731,  730,  729,  728,  727,  726,  725,  724,  723,  722, 
 721,  720,  719,  718,  717,  716,  715,  714,  713,  712, 
 711,  710,  709,  708,  707,  706,  705,  704,  703,  702, 
 701,  700,  699,  698,  697,  696,  695,  694,  693,  692, 
 691,  690,  689,  688,  687,  686,  685,  684,  683,  682, 
 681,  680,  679,  678,  677,  676,  675,  674,  673,  672, 
 671,  670,  669,  668,  667,  666,  665,  664,  663,  662, 
 661,  660,  659,  658,  657,  656,  655,  654,  653,  652, 
 651,  650,  649,  648,  647,  646,  645,  644,  643,  642, 
 641,  640,  639,  638,  637,  636,  635,  634,  633,  632, 
 631,  630,  629,  628,  627,  626,  625,  624,  623,  622, 
 621,  618,  617,  616,  615,  614,  613,  612,  611,  610, 
 609,  608,  607,  606,  605,  604,  603,  602,  601,  600, 
 599,  598,  597,  596,  595,  594,  593,  592,  591,  590, 
 589,  588,  587,  586,  585,  584,  583,  582,  581,  580, 
 579,  578,  577,  576,  575,  574,  573,  572,  571,  570, 
 569,  568,  567,  566,  565,  564,  563,  562,  561,  560, 
 559,  558,  557,  556,  555,  554,  553,  552,  551,  550, 
 549,  548,  547,  546,  545,  544,  543,  542,  541,  540, 
 539,  538,  537,  536,  535,  534,  528,  525,  524,  523, 
 522,  521,  520,  519,  518,  517,  516,  515,  514,  513, 
 512,  511,  510,  509,  508,  507,  506,  505,  504,  503, 
 502,  501,  500,  499,  498,  497,  496,  495,  491,  490, 
 489,  488,  487,  486,  485,  484,  483,  482,  481,  480, 
 479,  478,  477,  476,  475,  474,  473,  472,  471,  470, 
 469,  468,  467,  466,  465,  464,  463,  462,  461,  460, 
 459,  458,  457,  456,  455,  454,  453,  452,  451,  450, 
 449,  448,  447,  446,  445,  444,  443,  442,  441,  440, 
 439,  438,  437,  436,  435,  432,  431,  430,  429,  426, 
 425,  424,  423,  422,  421,  420,  419,  416,  415,  414, 
 411,  410,  406,  405,  404,  403,  402,  401,  400,  399, 
 398,  397,  396,  395,  394,  391,  390,  389,  388,  387, 
 386,  385,  384,  383,  382,  381,  378,  377,  376,  375, 
 374,  373,  372,  371,  370,  369,  368,  367,  366,  363, 
 362,  361,  360,  359,  358,  357,  356,  355,  354,  353, 
 352,  351,  350,  349,  348,  347,  346,  345,  344,  343, 
 340,  339,  338,  335,  334,  333,  332,  331,  330,  323, 
 318,  315,  311,  307,  306,  300,  299,  184,  287,  286, 
 285,  284,  283,  282,  279,  278,  275,  272,  271,  268, 
 267,  266,  263,  258,  257,  252,  251,  247,  244,  239, 
 236,  235,  232,  231,  230,  229,  228,  225,  224,  223, 
 222,  221,  217,  216,  215,  212,  211,   81,  191,  190, 
 184,  180,  179,  173,  172,  165,  162,  143,  140,  136, 
 135,  132,  114,  113,  107,  104,   82,   81,   77,   66, 
 811,   61,   61,    5,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
   0,    0, 
	};

static yyconst flex_int16_t yy_chk[1210] =
	{
   0,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
   1,    1,    1,    1,    1,    1,    1,    7,    7,    7, 
   7,    7,    7,    9,    9,    9,    9,    9,    9,   11, 
  12,   14,   19,   22,   33,   21,  783,   22,   33,   22, 
  22,   22,   22,   22,   22,   22,   22,   22,  784,   19, 
  21,   21,   23,   14,   28,   28,   39,   23,   30,   30, 
  38,   44,   38,   39,   49,   11,   39,   49,   44,   39, 
  23,   42,   12,   12,   41,   54,   41,   12,   76,   12, 
  54,   42,   76,   12,   42,   41,   42,   12,   24,   57, 
  24,   24,   24,   24,   24,   24,   24,   24,   24,   40, 
  47,   98,   55,  785,   47,   40,   24,   55,   40,   24, 
  24,   24,   51,   47,   53,   51,   51,   40,   53,   52, 
  53,   24,   52,   67,   80,   51,   98,   24,   51,   57, 
  52,   72,  137,   72,  137,   24,   72,   52,   24,   25, 
 786,   25,   25,   25,   25,   25,   25,   25,   25,   25, 
  62,   62,   62,   62,   62,   62,   80,   25,   95,   67, 
  25,   25,   64,   64,   64,   64,   64,   64,   73,  153, 
  99,  103,   25,  102,   73,   73,   96,  153,   25,   65, 
  65,   65,   65,   65,   65,   95,   25,   69,   99,  103, 
 111,   69,   90,   90,   96,   90,   94,   94,  102,   94, 
  69,   69,   69,   69,   69,   69,   69,   90,   90,   96, 
 169,   94,   94,   90,   69,  117,  117,   94,  127,  169, 
 121,  127,  147,   69,  134,  121,  111,   69,   69,  121, 
 141,  134,   69,  146,  139,  141,  143,  147,  143,   69, 
 788,  139,   69,  139,   69,  139,   69,  143,   69,   81, 
 146,  150,  151,   81,  208,  157,  151,  157,  150,  210, 
 208,  166,   81,   81,   81,   81,   81,   81,   81,  166, 
 193,  186,  192,  186,  188,  188,   81,  196,  789,  196, 
 197,  192,  210,  193,  790,   81,  186,  192,  197,   81, 
  81,  186,  188,  197,   81,  204,  200,  791,  200,  792, 
 188,   81,  204,  209,   81,  200,   81,   97,   81,   97, 
  81,  209,   97,   97,   97,   97,   97,   97,   97,   97, 
  97,  114,  114,  114,  114,  114,  114,  114,  114,  114, 
 163,  114,  114,  114,  793,  114,  114,  114,  114,  114, 
 114,  114,  177,  163,  163,  163,  163,  163,  163,  163, 
 293,  177,  177,  177,  177,  177,  177,  177,  202,  217, 
 217,  221,  260,  202,  246,  221,  163,  246,  293,  292, 
 181,  260,  181,  794,  177,  181,  181,  181,  181,  181, 
 181,  181,  181,  181,  185,  185,  185,  185,  185,  185, 
 185,  185,  185,  206,  292,  273,  296,  206,  310,  796, 
 797,  296,  202,  798,  392,  310,  206,  206,  273,  273, 
 273,  273,  273,  273,  273,  290,  290,  290,  290,  290, 
 290,  290,  290,  290,  288,  407,  799,  800,  801,  802, 
 803,  273,  274,  288,  288,  288,  288,  288,  288,  288, 
 392,  804,  805,  807,  808,  274,  274,  274,  274,  274, 
 274,  274,  274,  274,  782,  300,  288,  407,  315,  426, 
 274,  274,  274,  300,  291,  315,  291,  426,  274,  781, 
 780,  779,  274,  274,  274,  274,  274,  274,  289,  291, 
 535,  778,  777,  775,  291,  535,  773,  289,  289,  289, 
 289,  289,  289,  289,  289,  289,  382,  772,  771,  770, 
 768,  382,  289,  289,  289,  382,  428,  766,  428,  765, 
 289,  428,  428,  764,  289,  289,  289,  289,  289,  289, 
 763,  762,  760,  758,  757,  756,  755,  754,  751,  749, 
 747,  746,  745,  744,  743,  742,  428,  812,  812,  812, 
 812,  812,  812,  812,  812,  812,  812,  813,  737,  813, 
 813,  813,  813,  813,  813,  813,  813,  814,  735,  732, 
 814,  814,  814,  814,  814,  814,  814,  815,  815,  815, 
 815,  815,  815,  816,  729,  816,  816,  728,  816,  817, 
 817,  817,  817,  817,  817,  817,  817,  817,  817,  818, 
 818,  726,  818,  819,  819,  819,  819,  820,  820,  820, 
 820,  821,  821,  821,  821,  822,  725,  723,  822,  722, 
 822,  823,  721,  720,  823,  719,  823,  718,  717,  716, 
 714,  713,  712,  710,  705,  704,  703,  701,  695,  693, 
 692,  691,  690,  688,  687,  686,  683,  682,  681,  679, 
 678,  677,  675,  674,  673,  672,  671,  670,  668,  667, 
 665,  664,  661,  659,  658,  656,  655,  654,  653,  652, 
 651,  650,  648,  647,  645,  644,  643,  641,  640,  639, 
 638,  637,  635,  634,  633,  632,  630,  629,  628,  626, 
 625,  624,  622,  621,  617,  613,  612,  611,  610,  609, 
 608,  607,  606,  604,  603,  600,  599,  598,  596,  592, 
 591,  590,  589,  588,  586,  584,  581,  578,  576,  575, 
 573,  572,  571,  570,  569,  568,  567,  566,  565,  564, 
 560,  559,  557,  556,  555,  553,  552,  551,  550,  549, 
 548,  547,  546,  545,  544,  543,  542,  541,  540,  539, 
 536,  534,  533,  531,  530,  529,  528,  527,  526,  525, 
 523,  522,  521,  520,  519,  518,  517,  516,  515,  514, 
 513,  512,  509,  508,  507,  506,  502,  500,  499,  498, 
 496,  494,  493,  492,  490,  489,  488,  487,  486,  485, 
 484,  482,  481,  480,  479,  478,  477,  476,  475,  474, 
 473,  472,  471,  470,  469,  467,  466,  465,  462,  461, 
 460,  459,  458,  457,  456,  455,  454,  453,  452,  448, 
 446,  445,  444,  443,  442,  441,  440,  439,  438,  437, 
 436,  434,  433,  432,  430,  429,  427,  425,  424,  423, 
 422,  421,  420,  419,  418,  417,  416,  414,  413,  411, 
 410,  406,  405,  404,  402,  401,  400,  399,  398,  397, 
 394,  391,  390,  389,  387,  385,  384,  383,  380,  379, 
 377,  376,  375,  374,  373,  372,  371,  370,  369,  368, 
 367,  366,  365,  364,  363,  362,  361,  360,  359,  358, 
 357,  356,  355,  353,  351,  350,  349,  348,  347,  344, 
 343,  342,  341,  340,  339,  338,  337,  336,  335,  333, 
 331,  329,  328,  327,  326,  325,  324,  323,  322,  321, 
 320,  319,  318,  317,  316,  314,  313,  312,  311,  309, 
 308,  307,  305,  304,  303,  302,  301,  299,  298,  297, 
 295,  294,  287,  286,  285,  284,  283,  282,  281,  280, 
 279,  278,  277,  276,  275,  272,  271,  270,  269,  268, 
 267,  266,  265,  264,  263,  261,  259,  258,  257,  256, 
 255,  254,  253,  252,  251,  250,  249,  248,  247,  245, 
 244,  243,  242,  241,  240,  238,  237,  236,  235,  233, 
 232,  231,  229,  228,  227,  226,  225,  224,  223,  222, 
 220,  219,  218,  216,  215,  214,  213,  212,  211,  207, 
 205,  203,  201,  199,  198,  195,  194,  183,  175,  174, 
 173,  172,  171,  170,  168,  167,  165,  159,  158,  156, 
 155,  154,  152,  149,  148,  145,  144,  142,  140,  138, 
 136,  135,  132,  131,  130,  129,  128,  126,  125,  124, 
 123,  122,  120,  119,  118,  116,  115,  112,  109,  105, 
  92,   89,   87,   75,   74,   71,   61,   50,   48,   46, 
  45,   43,   37,   36,   29,   26,   18,   15,   13,   10, 
   5,    4,    3,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
 811,  811,  811,  811,  811,  811,  811,  811,  811,  811, 
	};

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

#define YY_MORE_ADJ 0
char *yytext;

#define INITIAL 0
#define COMMENT 1

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

int yylex()
{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;

	if ( yy_init )
		{
		yy_init = 0;

		if ( ! yy_start )
			yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, YY_BUF_SIZE );

		yy_load_buffer_state();
		}


	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 812 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 1133 );
		//???
yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;


do_action:	/* This label is used only to access EOF actions. */


		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

			case 1:		// \r\n
                                        //teststr = yytext; return 706+1000;
			case 2:		// \r
                                        //teststr = yytext; return 706+1001;
			case 3:		// \n
                                        teststr = yytext; return 706; //L_NEWLINE	//NEWLINE
			case 4:		// __abstract/deprecated
                                        teststr = yytext; return 512;			//KEYWORD
			case 5:		// e __alignof
                                        teststr = yytext; return 513;
			case 6:		// e __asm
                                        teststr = yytext; return 514; //L_ASM
			case 7:		// e __assume
                                        teststr = yytext; return 515; //L_ASSUME
			case 8:		// e __based
                                        teststr = yytext; return 516; //L_BASED
			case 9:		// __box/deprecated
                                        teststr = yytext; return 517;
			case 10:	// e __cdecl
                                        teststr = yytext; return 518; //L_C
			case 11:	// e __declspec
                                        teststr = yytext; return 519; //L_DECLSPEC
			case 12:	// __delegate/deprecated
                                        teststr = yytext; return 520;
			case 13:	// e __event
                                        teststr = yytext; return 521; //L_EVENT
			case 14:	// e __except
                                        teststr = yytext; return 522; //L_EXCEPT
			case 15:	// e __fastcall
                                        teststr = yytext; return 523; //L_FASTCALL
			case 16:	// e __forceinline
                                        teststr = yytext; return 524; //L_FORCEINLINE
			case 17:	// __gc/deprecated
                                        teststr = yytext; return 525;
			case 18:	// e __hook
                                        teststr = yytext; return 526; //L_HOOK
			case 19:	// __identifier
                                        teststr = yytext; return 527; //L_IDENTIFIER
			case 20:	// e __if_exists
                                        teststr = yytext; return 528; //L_IF_EXISTS
			case 21:	// e __if_not_exists
                                        teststr = yytext; return 529; //L_IF_NOT_EXISTS
			case 22:	// e __inline
                                        teststr = yytext; return 530;
			case 23:	// e __int8
                                        teststr = yytext; return 531; //L_INT8
			case 24:	// e __int16
                                        teststr = yytext; return 532; //L_INT16
			case 25:	// e __int32
                                        teststr = yytext; return 533; //L_INT32
			case 26:	// e __int64
                                        teststr = yytext; return 534; //L_INT64
			case 27:	// e __interface
                                        teststr = yytext; return 535; //L_INTERFACE
			case 28:	// e __leave
                                        teststr = yytext; return 536; //L_LEAVE
			case 29:	// e __m64
                                        teststr = yytext; return 537;
			case 30:	// e __m128
                                        teststr = yytext; return 538;
			case 31:	// e __m128d
                                        teststr = yytext; return 539;
			case 32:	// e __m128i
                                        teststr = yytext; return 540;
			case 33:	// e __multiple_inheritance
                                        teststr = yytext; return 541; //L_MI
			case 34:	// __nogc/deprecated
                                        teststr = yytext; return 542;
			case 35:	// __noop
                                        teststr = yytext; return 543;
			case 36:	// __pin/deprecated!
                                        teststr = yytext; return 544; //L_PIN
			case 37:	// __propertly/deprecated!
                                        teststr = yytext; return 545;
			case 38:	// e __raise
                                        teststr = yytext; return 546; //L_RAISE
			case 39:	// __sealed/deprecated!
                                        teststr = yytext; return 547;
			case 40:	// e __single_inheritance
                                        teststr = yytext; return 548; //L_SI
			case 41:	// e __stdcall
                                        teststr = yytext; return 549; //L_STDCALL
			case 42:	// e __super
                                        teststr = yytext; return 550; //L_SUPER
			case 43:	// __try_cast/deprecated
                                        teststr = yytext; return 551;
			case 44:	// e __try
                                        teststr = yytext; return 552; //L_SEHTRY
			case 45:	// e __finally
                                        teststr = yytext; return 553; //L_FINALLY
			case 46:	// e __unhook
                                        teststr = yytext; return 554; //L_UNHOOK
			case 47:	// e __uuidof
                                        teststr = yytext; return 555; //L_UUIDOF
			case 48:	// __value/deprecated
                                        teststr = yytext; return 556;
			case 49:	// e __virtual_inheritance
                                        teststr = yytext; return 557; //L_VI
			case 50:	// e __w64
                                        teststr = yytext; return 558; //L_W64
			case 51:	// bool
                                        teststr = yytext; return 559; //L_BOOL
			case 52:	// break
                                        teststr = yytext; return 560; //L_BREAK
			case 53:	// case
                                        teststr = yytext; return 561; //L_CASE
			case 54:	// catch
                                        teststr = yytext; return 562; //L_CATCH
			case 55:	// char
                                        teststr = yytext; return 563; //L_CHAR
			case 56:	// class
                                        teststr = yytext; return 564; //L_CLASS
			case 57:	// const
                                        teststr = yytext; return 565; //L_CONST
			case 58:	// const_cast
                                        teststr = yytext; return 566; //L_CONSTCAST
			case 59:	// continue
                                        teststr = yytext; return 567; //L_CONTINUE
			case 60:	// default
                                        teststr = yytext; return 568; //L_DEFAULT
			case 61:	// delete
                                        teststr = yytext; return 569; //L_DELETE
			case 62:	// deprecated/__declspec
                                        teststr = yytext; return 570;
			case 63:	// dllexport/__declspec
                                        teststr = yytext; return 571;
			case 64:	// dllimport/__declspec
                                        teststr = yytext; return 572;
			case 65:	// do
                                        teststr = yytext; return 573; //L_DO
			case 66:	// double
                                        teststr = yytext; return 574; //L_DOUBLE
			case 67:	// dynamic_cast
                                        teststr = yytext; return 575; //L_DYNCAST
			case 68:	// else
                                        teststr = yytext; return 576; //L_ELSE
			case 69:	// enum
                                        teststr = yytext; return 577; //L_ENUM
			case 70:	// explicit
                                        teststr = yytext; return 578; //L_EXPLICIT
			case 71:	// extern
                                        teststr = yytext; return 579; //L_EXTERN
			case 72:	// false
                                        teststr = yytext; return 580; //L_FALSE
			case 73:	// float
                                        teststr = yytext; return 581; //L_FLOAT
			case 74:	// for
                                        teststr = yytext; return 582; //L_FOR
			case 75:	// friend
                                        teststr = yytext; return 583; //L_FRIEND
			case 76:	// goto
                                        teststr = yytext; return 584; //L_GOTO
			case 77:	// if
                                        teststr = yytext; return 585; //L_IF
			case 78:	// inline
                                        teststr = yytext; return 586; //L_INLINE
			case 79:	// int
                                        teststr = yytext; return 587; //L_INT
			case 80:	// long
                                        teststr = yytext; return 588; //L_LONG
			case 81:	// mutable
                                        teststr = yytext; return 589; //L_MUTABLE
			case 82:	// naked/__declspec
                                        teststr = yytext; return 590;
			case 83:	// namespace
                                        teststr = yytext; return 591; //L_NAMESPACE
			case 84:	// new
                                        teststr = yytext; return 592; //L_NEW
			case 85:	// noinline/__declspec
                                        teststr = yytext; return 593;
			case 86:	// noreturn/__declspec
                                        teststr = yytext; return 594;
			case 87:	// nothrow/__declspec
                                        teststr = yytext; return 595; //L_NOTHROW
			case 88:	// novtable/__declspec
                                        teststr = yytext; return 596;
			case 89:	// operator
                                        teststr = yytext; return 597; //L_OPERATOR
			case 90:	// private
                                        teststr = yytext; return 598; //L_PRIVATE
			case 91:	// propetry/__declspec
                                        teststr = yytext; return 599;
			case 92:	// protected
                                        teststr = yytext; return 600; //L_PROTECTED
			case 93:	// public
                                        teststr = yytext; return 601; //L_PUBLIC
			case 94:	// register
                                        teststr = yytext; return 602; //L_REGISTER
			case 95:	// reinterpret_cast
                                        teststr = yytext; return 603; //L_REINCAST
			case 96:	// return
                                        teststr = yytext; return 604; //L_RETURN
			case 97:	// selectany/__declspec
                                        teststr = yytext; return 605;
			case 98:	// short
                                        teststr = yytext; return 606; //L_SHORT
			case 99:	// signed
                                        teststr = yytext; return 607; //L_SIGNED
			case 100:	// sizeof
                                        teststr = yytext; return 608; //L_SIZEOF
			case 101:	// static
                                        teststr = yytext; return 609; //L_STATIC
			case 102:	// static_cast
                                        teststr = yytext; return 610; //L_STATCAST
			case 103:	// struct
                                        teststr = yytext; return 611; //L_STRUCT
			case 104:	// switch
                                        teststr = yytext; return 612; //L_SWITCH
			case 105:	// template
                                        teststr = yytext; return 613; //L_TEMPLATE
			case 106:	// this
                                        teststr = yytext; return 614; //L_THIS
			case 107:	// thread/__declspec
                                        teststr = yytext; return 615;
			case 108:	// throw
                                        teststr = yytext; return 616; //L_THROW
			case 109:	// true
                                        teststr = yytext; return 617; //L_TRUE
			case 110:	// try
                                        teststr = yytext; return 618; //L_CXXTRY
			case 111:	// typedef
                                        teststr = yytext; return 619; //L_TYPEDEF
			case 112:	// typeid
                                        teststr = yytext; return 620; //L_TYPEID
			case 113:	// typename
                                        teststr = yytext; return 621; //L_TYPENAME_KW
			case 114:	// union
                                        teststr = yytext; return 622; //L_UNION
			case 115:	// unsigned
                                        teststr = yytext; return 623; //L_UNSIGNED
			case 116:	// using
                                        teststr = yytext; return 624; //L_USING
			case 117:	// uuid/__declspec
                                        teststr = yytext; return 625;
			case 118:	// virtual
                                        teststr = yytext; return 626; //L_VIRTUAL
			case 119:	// void
                                        teststr = yytext; return 627; //L_VOID
			case 120:	// volatile
                                        teststr = yytext; return 628; //L_VOLATILE
			case 121:	// e __wchar_t
                                        teststr = yytext; return 629; //L_WCHAR_T
			case 122:	// wchar_t
                                        teststr = yytext; return 630;
			case 123:	// while
                                        teststr = yytext; return 631; //L_WHILE		//KEYWORD
			case 124:	// #define
                                        teststr = yytext; return 632; //L_M_DEFINE	//MACRO
			case 125:	// #error
                                        teststr = yytext; return 633; //L_M_ERROR
			case 126:	// #import
                                        teststr = yytext; return 634; //L_M_IMPORT
			case 127:	// #undef
                                        teststr = yytext; return 635; //L_M_UNDEF
			case 128:	// #elif
                                        teststr = yytext; return 636; //L_M_ELIF
			case 129:	// #if
                                        teststr = yytext; return 637; //L_M_IF
			case 130:	// #include
                                        teststr = yytext; return 638; //L_M_INCLUDE
			case 131:	// #using
                                        teststr = yytext; return 639; //L_M_USING
			case 132:	// #else
                                        teststr = yytext; return 640; //L_M_ELSE
			case 133:	// #ifdef
                                        teststr = yytext; return 641; //L_M_IFDEF
			case 134:	// #line
                                        teststr = yytext; return 642; //L_M_LINE
			case 135:	// #endif
                                        teststr = yytext; return 643; //L_M_ENDIF
			case 136:	// #ifndef
                                        teststr = yytext; return 644; //L_M_IFNDEF
			case 137:	// #pragma
                                        teststr = yytext; return 645; //L_M_PRAGMA	//MACRO
			case 138:	// string
                                        teststr = yytext; return 705; //L_STRWORD	//OPERATION
			case 139:	// numbers??? dec include LL
                                        teststr = yytext; return 646; //L_DEC
			case 140:	// numbers??? oct
                                        teststr = yytext; return 647; //L_OCT
			case 141:	// hex??? 0xff
                                        teststr = yytext; return 648; //L_HEX
			case 142:	// float/double ??? 0.0
                                        teststr = yytext; return 649; //L_DBL
			case 143:	// 'string' ??? numbers '113'
                                        teststr = yytext; return 650; //L_SSTR
			case 144:	// "string" L"string"
                                        teststr = yytext; return 651; //L_DSTR
			case 145:	// (
                                        teststr = yytext; return 652; //L_LPAREN
			case 146:	// )
                                        teststr = yytext; return 653; //L_RPAREN
			case 147:	// ,
                                        teststr = yytext; return 654; //L_COMMA
			case 148:	// #
                                        teststr = yytext; return 35; //L_POUND
			case 149:	// ##
                                        teststr = yytext; return 655; //L_POUNDPOUND
			case 150:	// {
                                        teststr = yytext; return 656; //L_LCURLY
			case 151:	// }
                                        teststr = yytext; return 657; //L_RCURLY
			case 152:	// [
                                        teststr = yytext; return 658; //L_LBRACK
			case 153:	// ]
                                        teststr = yytext; return 659; //L_RBRACK
			case 154:	// .
                                        teststr = yytext; return 660; //L_PERIOD
			case 155:	// &
                                        teststr = yytext; return 661; //L_AND
			case 156:	// *
                                        teststr = yytext; return 662; //L_MULT
			case 157:	// +
                                        teststr = yytext; return 663; //L_PLUS
			case 158:	// -
                                        teststr = yytext; return 664; //L_MINUS
			case 159:	// ~
                                        teststr = yytext; return 665; //L_TILDE
			case 160:	// !
                                        teststr = yytext; return 666; //L_EXCLAIM
			case 161:	// /
                                        teststr = yytext; return 667; //L_DIV
			case 162:	// %
                                        teststr = yytext; return 668; //L_MOD
			case 163:	// <
                                        teststr = yytext; return 669; //L_LT
			case 164:	// >
                                        teststr = yytext; return 670; //L_GT
			case 165:	// ^
                                        teststr = yytext; return 671; //L_XOR
			case 166:	// |
                                        teststr = yytext; return 672; //L_OR
			case 167:	// ?
                                        teststr = yytext; return 673; //L_QUEST
			case 168:	// :
                                        teststr = yytext; return 674; //L_COLON
			case 169:	// ;
                                        teststr = yytext; return 675; //L_SEMI
			case 170:	// =
                                        teststr = yytext; return 676; //L_ASSIGN
			case 171:	// .*
                                        teststr = yytext; return 677; //L_MBRDOT
			case 172:	// ::
                                        teststr = yytext; return 678; //L_DBLCOLON
			case 173:	// -> 
                                        teststr = yytext; return 679; //L_POINTSTO
			case 174:	// ->*
                                        teststr = yytext; return 680; //L_MBRPTR
			case 175:	// ++
                                        teststr = yytext; return 681; //L_INCR
			case 176:	// --
                                        teststr = yytext; return 682; //L_DECR
			case 177:	// <<
                                        teststr = yytext; return 683; //L_LSHIFT
			case 178:	// >>
                                        teststr = yytext; return 684; //L_RSHIFT
			case 179:	// <=
                                        teststr = yytext; return 685; //L_LTEQ
			case 180:	// >=
                                        teststr = yytext; return 686; //L_GTEQ
			case 181:	// ==
                                        teststr = yytext; return 687; //L_EQUALS
			case 182:	// !=
                                        teststr = yytext; return 688; //L_NOTEQ
			case 183:	// &&
                                        teststr = yytext; return 689; //L_ANDAND
			case 184:	// ||
                                        teststr = yytext; return 690; //L_OROR
			case 185:	// *=
                                        teststr = yytext; return 691; //L_MULTEQ
			case 186:	// /=
                                        teststr = yytext; return 692; //L_DIVEQ
			case 187:	// %=
                                        teststr = yytext; return 693; //L_MODEQ
			case 188:	// +=
                                        teststr = yytext; return 694; //L_PLUSEQ
			case 189:	// -=
                                        teststr = yytext; return 695; //L_MINUSEQ
			case 190:	// <<=
                                        teststr = yytext; return 696; //L_LSHFTEQ
			case 191:	// >>=
                                        teststr = yytext; return 697; //L_RSHFTEQ
			case 192:	// &=
                                        teststr = yytext; return 698; //L_ANDEQ
			case 193:	// ^=
                                        teststr = yytext; return 699; //L_XOREQ
			case 194:	// |=
                                        teststr = yytext; return 700; //L_OREQ		//OPERATION
			case 195:	// ...
                                        teststr = yytext; return 701; //L_ELLIPSIS
			case 196:	// /*
                                        yy_start = 3;
                                        teststr = yytext; return 702; //L_BEGIN_COMMENT
			case 197:	// */
                                        yy_start = 1;
                                        teststr = yytext; return 703; //L_END_COMMENT
			case 198:	// //
                                        teststr = yytext; return 704; //L_LINE_COMMENT
									//705 ^
			case 199:	// \		???
                                        teststr = yytext; return 707;


			case YY_STATE_EOF(INITIAL): //0 201+0+1 //202
			case YY_STATE_EOF(COMMENT): //1 201+1+1 //203
					return 0;

	case YY_END_OF_BUFFER: //??? 201
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;
		//???

		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between yy_current_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p; //???
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE: //1
				{
				yy_did_buffer_switch_on_eof = 0;

				//if ( yywrap() )
				if (1)
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		;//YY_FATAL_ERROR("fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext_ptr;
	register int number_to_move, i;
	int ret_val;

	//if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
	//	YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a singled characater, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING ) //2
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yy_current_buffer->yy_n_chars = (yy_n_chars) = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */
//#ifdef YY_USES_REJECT
//			YY_FATAL_ERROR("input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
//#else

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			//if ( ! b->yy_ch_buf )
			//	YY_FATAL_ERROR("fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
//#endif
			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
			yy_n_chars, num_to_read );

		yy_current_buffer->yy_n_chars = (yy_n_chars); //+++
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ ) //?
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH; //2
			yy_current_buffer->yy_buffer_status =
				YY_BUFFER_EOF_PENDING; //2
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN; //0

	//???

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}


static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 812 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}

static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 812 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 811);

	return yy_is_jam ? 0 : yy_current_state;
	}


void yyrestart( FILE *input_file )
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}

//yy_switch_to_buffer

void yy_load_buffer_state()
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}

YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	//if ( ! b )
	//	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	//if ( ! b->yy_ch_buf )
	//	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}

//yy_delete_buffer

void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

	b->yy_is_interactive = file ? 1 : 0;
	}

void yy_flush_buffer( YY_BUFFER_STATE b )
	{
	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR; //0
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR; //0

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}

//yy_scan_buffer
//yy_scan_string
//yy_scan_bytes
//yy_push_state
//yy_pop_state
//yy_top_state
//yy_fatal_error
//yyless
//yy_flex_strncpy

static void *yy_flex_alloc( yy_size_t size )
	{
	return (void *) Syser_malloc( size );
	}

static void *yy_flex_realloc( void *ptr, yy_size_t size )
	{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) Syser_realloc( (char *) ptr, size );
	}

static void yy_flex_free( void *ptr )
	{
	Syser_free( ptr );
	}

```

`source/WispSyser/mainframe.cpp`:

```cpp

#include "mainframe.hpp"
#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "resource.hpp"

	CMainFrame::CMainFrame()
	{
		m_pGeneRegList = 0;
	}
	CMainFrame::~CMainFrame()
	{
	}

	WISP_MSG_MAP_BEGIN(CMainFrame)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_BEGIN_MOVE, OnBeginMove)
		WISP_MSG_MAP(WISP_WM_END_MOVE, OnEndMove)
		WISP_MSG_MAP(WISP_WM_EVENT, OnEvent)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(30, OnDebuggerPlunge)
		WISP_MSG_MAP(31, OnDebuggerClose)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
	WISP_MSG_MAP_END(CWispWnd)

	bool CMainFrame::OnCreate(WISP_MSG *pMsg)
	{
		AttachTitleDIB(gpCurWisp->m_DIBLib.LoadDIB("\\SyserIcon\\Syser.ico", 0, 0xFF00FF));

		WISP_RECT Rect;

		Rect.cx = m_ClientRect.cx;
		Rect.cy = m_ClientRect.cy;
		Rect.x = 0;
		Rect.y = 0;

		if (!m_MainTabWnd.CreateWnd(0, Rect, this, 0, 0x20000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_SystemExplorer.CreateWnd(0, Rect, &m_MainTabWnd, CMD_ID_SYSEXPLORER, 0x100, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_ConsoleWnd.CreateWnd(0, Rect, &m_MainTabWnd, CMD_ID_CONSOLE, 0, WISP_SH_MINSIZE))
			return false;

		Rect = m_MainTabWnd.m_ClientRect;
		if (!m_SourceDebugFrameWnd.CreateWnd(0, Rect, &m_MainTabWnd, 0, 0x20100, WISP_SH_MINSIZE))
			return false;

		m_ConsoleWnd.Printf(WSTR("Wisp Syser Console\n"));


		m_MainTabWnd.InsertWnd(WSTR("System Explorer Ctrl+1"), &m_SystemExplorer, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x3E));
		m_MainTabWnd.InsertWnd(WSTR("Command Console Ctrl+2"), &m_ConsoleWnd, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x3F));
		m_MainTabWnd.InsertWnd(WSTR("Source Explorer Ctrl+3"), &m_SourceDebugFrameWnd, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xF6));

		m_StaticText.Create(0, m_ClientRect.cx - 400, m_ClientRect.cy - 16, 400, 16, &m_MainTabWnd, 0, 0, 1);

		HookKeyEvent();

		gpSyser->RegisterHotKeyEvent(EVENT_ID_REGVIEW, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_DATAVIEW, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_CALLSTACK, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_BREAK_POINT, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_GO, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_DBG_RETURN, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_DBG_STEP, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_DBG_PROCEED, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_DBG_STEPB, this);
		return true;
	}
	bool CMainFrame::OnDestroy(WISP_MSG *pMsg)
	{
		DetachTitleDIB();
		return true;
	}
	bool CMainFrame::OnUpdate(WISP_MSG *pMsg)
	{
#if 0
#if 0
		//for test only
		WISP_RECT rc;

		rc.x = 0;
		rc.y = 0;
		rc.cx = m_WindowRect.cx;//120;
		rc.cy = m_WindowRect.cy; //200;
		//m_WindowDC.DrawFullRect(&rc, 0x64A0BA);
		m_WindowDC.DrawVLine(10,10,100, 0x64A0BA);
#endif
		WISP_RECT rc;
#if 0
#if 1
//		m_WindowDC.DrawRect(10, 10, 100, 100, 0x324510);
//		m_WindowDC.DrawLine(100,100, 400,400, 0x63FFA0);
//		m_WindowDC.DrawLine(400,100, 100,400, 0x63FFA0);

//		m_WindowDC.DrawVLine(400, 100,400, 0xFFA063);
//		m_WindowDC.DrawHLine(400, 100,400, 0x63FFA0);

		rc.x = 40;
		rc.y = 100;
		rc.cx = 300;
		rc.cy = 400;
		//m_WindowDC.DrawDashRect(&rc, 0x64A0BA);
//		m_pWispBase->m_pWispDrawObj->DrawButtonClient(&m_WindowDC, &rc, 0);

#if 1

		rc.x = 40;
		rc.y = 100;
		rc.cx = 300;
		rc.cy = 400;
//		m_WindowDC.DrawRoundRect(&rc,  0x64A0BA);

	#if 1
		rc.x = 40;
		rc.y = 100;
		rc.cx = 300;
		rc.cy = 400;
		//m_WindowDC.DrawDashRect(&rc, 0x64A0BA);
		m_pWispBase->m_pWispDrawObj->DrawButtonClient(&m_WindowDC, &rc, 1);
//		m_pWispBase->m_pWispDrawObj->DrawVertScrollSlideRect(&m_WindowDC, &rc);
//		m_pWispBase->m_pWispDrawObj->DrawCtrlModalFrame(&m_WindowDC, &rc);

		WISP_POINT pt;
		pt.x = 30;
		pt.y = 29;
//		m_pWispBase->m_pWispDrawObj->DrawCursorArrow(&m_WindowDC, &pt);
//		m_DefDrawObj.
//		m_DIBDrawObj.
//		m_pWispBase->m_pWispDrawObj->DrawCursorResizeVert(&m_WindowDC, &pt);
//		m_pWispBase->m_DefDrawObj.DrawCursorResizeVert(&m_WindowDC, &pt);
//		m_pWispBase->m_DefDrawObj.DrawCursorArrow(&m_WindowDC, &pt);
		m_pWispBase->m_DIBDrawObj.DrawCursorResizeVert(&m_WindowDC, &pt);

	#endif
	#if 1
		rc.x = 500;
		rc.y = 300;
		rc.cx = 120;
		rc.cy = 200;
		m_WindowDC.DrawFullRect(&rc, 0x64A0BA);
	#endif
	#if 1
		rc.x = 400;
		rc.y = 300;
		rc.cx = 100;
		rc.cy = 150;
		m_WindowDC.DrawXGrayChgFullRect(&rc, 0x64A0BA, 30);
	#endif

		rc.x = 600;
		rc.y = 150;
		rc.cx = 200;
		rc.cy = 150;
		m_WindowDC.DrawXGrayColorFullRect2(0x64A0BA, 0xA0FFED, &rc);
#endif
#endif
//		CWispDIB *pDIB = gpCurWisp->m_DIBLib.GetDIB("\\WispApp\\SoftKeyboard\\SoftKeyboard.ico", 0);
//		CWispDIB *pDIB = gpCurWisp->m_DIBLib.GetDIB("\\WispApp\\Calc\\Calc.bmp", 0);
//		pDIB->Write("D:\\Calc.bmp");
		CWispDIB DIB;
		DIB.Load("\\WispApp\\SoftKeyboard\\SoftKeyboard.ico", 0); //\\WispApp\\Calc\\Calc.bmp", 0);
//		DIB.Write("D:\\Calc.bmp");
		m_WindowDC.DrawDIB(10, 50, &DIB); //pDIB);
//#endif
//		m_WindowDC.DrawDIB(300, 50, &m_pWispBase->m_DefDIB[0]); //pDIB);
#endif
		m_WindowDC.SetTextColor(0x64A0BA);
		m_WindowDC.DrawString(0,0,WSTR("____TEST STRING___"), -1, 0, 0);
#endif
		return true;
	}
	bool CMainFrame::OnClose(WISP_MSG *pMsg)
	{
		return true;
	}
	bool CMainFrame::OnSize(WISP_MSG *pMsg)
	{
		int SizeX = m_ClientRect.cx - m_MainTabWnd.m_FullWidth;
		MAX_LIMIT(SizeX, 400);
		MIN_LIMIT(SizeX, 0);
		m_StaticText.MoveToClient(m_ClientRect.cx - SizeX, m_ClientRect.cy - 16, true);
		m_StaticText.Resize(SizeX, m_StaticText.m_WindowRect.cy, true);
		m_MainTabWnd.Resize(m_ClientRect.cx, m_ClientRect.cy, true);
		return true;
	}
	bool CMainFrame::OnBeginMove(WISP_MSG *pMsg)
	{
		return true;
	}
	bool CMainFrame::OnEndMove(WISP_MSG *pMsg)
	{
		return true;
	}

	WISP_EVENT_MAP_BEGIN(CMainFrame)
		WISP_EVENT_MAP(EVENT_ID_DBG_STEP, OnEventDbgStep)
		WISP_EVENT_MAP(EVENT_ID_DBG_PROCEED, OnEventDbgProceed)
		WISP_EVENT_MAP(EVENT_ID_DBG_STEPB, OnEventStepBranch)
		WISP_EVENT_MAP(EVENT_ID_DBG_RETURN, OnEventDbgReturn)
		WISP_EVENT_MAP(EVENT_ID_GO, OnEventDbgContinue)
		WISP_EVENT_MAP(EVENT_ID_BREAK_POINT, OnEventBreakPointForm)
		WISP_EVENT_MAP(EVENT_ID_CALLSTACK, OnEventCallStack)
		WISP_EVENT_MAP(EVENT_ID_REGVIEW, OnEventRegView)
		WISP_EVENT_MAP(EVENT_ID_DATAVIEW, OnEventDataViewForm)
	WISP_EVENT_MAP_END

	bool CMainFrame::OnEventDbgStep(WISP_MSG *pMsg)
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0:
		case 1:
			m_SystemExplorer.OnEventDbgStep(pMsg);
			break;
		case 2:
			m_SourceDebugFrameWnd.OnEventDbgStep(pMsg);
			break;
		}
		return true;
	}

	bool CMainFrame::OnEventDbgProceed(WISP_MSG *pMsg)
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0:
		case 1:
			m_SystemExplorer.OnEventDbgProceed(pMsg);
			break;
		case 2:
			m_SourceDebugFrameWnd.OnEventDbgProceed(pMsg);
			break;
		}
		return true;
	}

	bool CMainFrame::OnEventStepBranch(WISP_MSG *pMsg)
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0:
		case 1:
			m_SystemExplorer.OnEventStepBranch(pMsg);
			break;
		case 2:
			//m_SourceDebugFrameWnd.OnEventStepBranch(pMsg);
			break;
		}
		return true;
	}

	bool CMainFrame::OnEventDbgReturn(WISP_MSG *pMsg)
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0:
		case 1:
			m_SystemExplorer.OnEventDbgReturn(pMsg);
			break;
		case 2:
			m_SourceDebugFrameWnd.OnEventDbgReturn(pMsg);
			break;
		}
		return true;
	}

	bool CMainFrame::OnEventDbgContinue(WISP_MSG *pMsg)
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0:
		case 1:
			m_SystemExplorer.OnEventDbgContinue(pMsg);
			break;
		case 2:
			m_SourceDebugFrameWnd.OnEventDbgContinue(pMsg);
			break;
		}
		return true;
	}

	bool CMainFrame::OnEventBreakPointForm(WISP_MSG *pMsg)
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0:
		case 1:
			m_SystemExplorer.OnEventBreakPointForm(pMsg);
			break;
		case 2:
			m_SourceDebugFrameWnd.OnEventBreakPointForm(pMsg);
			break;
		}
		return true;
	}

	bool CMainFrame::OnEventCallStack(WISP_MSG *pMsg)
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0:
		case 1:
			m_SystemExplorer.OnEventCallStack(pMsg);
			break;
		case 2:
			m_SourceDebugFrameWnd.OnEventCallStack(pMsg);
			break;
		}
		return true;
	}

	bool CMainFrame::OnEventRegView(WISP_MSG *pMsg)
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0:
		case 1:
			m_SystemExplorer.OnEventRegView(pMsg);
			break;
		case 2:
			m_SourceDebugFrameWnd.OnEventRegView(pMsg);
			break;
		}
		return true;
	}

	bool CMainFrame::OnEventDataViewForm(WISP_MSG *pMsg)
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0:
		case 1:
			m_SystemExplorer.OnEventDataViewForm(pMsg);
			break;
		case 2:
			m_SourceDebugFrameWnd.OnEventDataViewForm(pMsg);
			break;
		}
		return true;
	}

	bool CMainFrame::Move()
	{
		int DeltaX = 0;
		int DeltaY = 0;
		if (gpCurWisp->m_KeyMap[VK_LEFT])
			DeltaX = -20;
		if (gpCurWisp->m_KeyMap[VK_RIGHT])
			DeltaX += 20;

		if (gpCurWisp->m_KeyMap[VK_UP])
			DeltaY = -20;
		if (gpCurWisp->m_KeyMap[VK_DOWN])
			DeltaY += 20;
		return gpSyser->MovingFrame(DeltaX, DeltaY);
	}

	bool CMainFrame::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (m_pWispBase->m_pModalWnd)
			return true;

		if (!pMsg->KeyEvent.bKeyDown)
			return true;

		switch (pMsg->KeyEvent.KeyType)
		{
		case 0x6000002E: //WISP_SK_CTRL|WISP_SK_ALT VK_DELETE
			gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("hboot"), 0);
			return false;
		case VK_ESCAPE:
			if (m_pWispBase->m_pFocusWnd && m_pWispBase->m_pFocusWnd->m_CtrlType != WISP_CTRL_EDIT)
				FocusActive();
			break;
		case 0x40000031: //WISP_SK_CTRL
		case 0x40000032: //WISP_SK_CTRL
		case 0x40000033: //WISP_SK_CTRL
		case 0x40000034: //WISP_SK_CTRL
		case 0x40000035: //WISP_SK_CTRL
		case 0x40000036: //WISP_SK_CTRL
		case 0x40000037: //WISP_SK_CTRL
		case 0x40000038: //WISP_SK_CTRL
		case 0x40000039: //WISP_SK_CTRL
			m_MainTabWnd.SetActiveWnd((pMsg->KeyEvent.KeyType&0xffff)-0x31);
			return false;
		default:;
		}
		return true;
	}

	bool CMainFrame::OnDebuggerPlunge(WISP_MSG *pMsg) //30
	{
		gpSyser->m_SyserUI.m_DebugInterface.Plunge(pMsg->Code);
		return true;
	}	
	bool CMainFrame::OnDebuggerClose(WISP_MSG *pMsg) //31
	{
		gpSyser->m_SyserUI.m_DebugInterface.Close(pMsg->bExit != 0);
		return true;
	}

	void CMainFrame::FocusActive()
	{
		switch (m_MainTabWnd.GetActiveWndIndex())
		{
		case 0: m_SystemExplorer.m_TerminalWnd.Focus(); break;
		case 1: m_ConsoleWnd.Focus(); break;
		case 2: {
			CWispBaseWnd *pWnd = m_SourceDebugFrameWnd.m_MultiSourceCodeView.GetActiveWnd();
			if (pWnd) pWnd->Focus();
			else	m_SourceDebugFrameWnd.Focus();
			} break;
		}
	}

	void CMainFrame::CreateProgress(const WCHAR *Text, unsigned long MaxPos)
	{
		m_ProgressForm.Create(nullptr, 1);
		m_ProgressForm.SetText(Text);
		m_ProgressForm.m_pProgress->SetRange(1, MaxPos);
		m_ProgressForm.m_pProgress->SetPos(1);
		m_ProgressForm.Update((WISP_RECT*)0);
		m_ProgressForm.Show(WISP_SH_MODAL); //WISP_SH_MODAL_BLOCK 5
	}

	void CMainFrame::UpdateProgress(unsigned long Pos)
	{
		m_ProgressForm.m_pProgress->SetPos(Pos);
		m_ProgressForm.Update((WISP_RECT*)0);
		m_pWispBase->PumpQueue();
	}

	void CMainFrame::UpdateCaption(const WCHAR *Text)
	{
		m_ProgressForm.SetText(Text);
		m_ProgressForm.Update((WISP_RECT*)0);
	}

	void CMainFrame::DestroyProgress()
	{
		m_ProgressForm.Destroy();
	}

```

`source/WispSyser/mainframe.hpp`:

```hpp

#ifndef _MAINFRAME_HPP_
#define _MAINFRAME_HPP_

#include "../Code/define.h"
#include "../Wisp/wispwnd.hpp"
#include "../Wisp/wispstatic.hpp"
#include "../Wisp/wisptabwnd.hpp"
#include "../Wisp/wispsoftkeyboard.hpp"
#include "../Wisp/wispcalcwnd.hpp"
#include "../Wisp/wispprogressform.hpp"

#include "systemexplorer.hpp"
#include "consolewnd.hpp"
#include "genereglist.hpp"
#include "dataviewform.hpp"
#include "debuggerselectform.hpp"
#include "pluginlistform.hpp"
#include "breakpointform.hpp"
#include "processlist.hpp"
#include "peexplorerform.hpp"
#include "sourcedebugframewnd.hpp"
#include "runtracewnd.hpp"
#include "callstackwnd.hpp"
#include "dataoperatordlg.hpp"
#include "keymappingpage.hpp"
#include "modulelist.hpp"
#include "crossreferenceform.hpp"
#include "commentlist.hpp"
#include "pagemapwnd.hpp"
#include "reghelpwnd.hpp"
#include "idtwnd.hpp"
#include "gdtwnd.hpp"
#include "findstringform.hpp"
#include "findlistwnd.hpp"

#define CV_TAB 0
#define TERM_TAB 1
#define SRC_TAB 2

struct CMainFrame : public CWispWnd
{
	//Register View
	CWispTabWnd m_CPUTabWnd;
	CGeneRegList *m_pGeneRegList;
	CDataViewForm m_DataViewForm;
	CSystemExplorer m_SystemExplorer;
	CConsoleWnd m_ConsoleWnd;
	CSourceDebugFrameWnd m_SourceDebugFrameWnd;
	CWispTabWnd m_MainTabWnd; //TAB
	CWispProgressForm m_ProgressForm;
	CDebuggerSelectForm m_DebuggerSelectForm;
	CPluginListForm m_PluginListForm;
	CKeyMappingPage m_KeyMappingPage;
	CWispSoftKeyboard m_SoftKeyboard;
	CBreakPointForm m_BreakPointForm;
	CPageMapWnd m_PageMapWnd;
	CX86RegHelpTabWnd m_X86RegHelpTabWnd;
	CWispCalcWnd m_CalcWnd;
	//CObjectDirectoryWnd m_ObjectDirectoryWnd;
	CDataOperatorDlg m_DataOperatorDlg;
	CCrossReferenceForm m_CrossReferenceForm;
	CCommentList m_CommentList;
	CCallStackWnd m_CallStackWnd;
	CRunTraceWnd m_RunTraceWnd;
	CModuleListWnd m_ModuleListWnd;
	//CHwndListWnd m_HwndListWnd;
	//CHwndPropertyForm m_HwndPropertyForm;
	CProcessList m_ProcessList;
	CIDTWnd m_IDTWnd;
	CGDTWnd m_GDTWnd;
	CWispStaticStr m_StaticText;
	CStringReferenceList m_StringReferenceList;
	CFindListWnd m_FindListWnd;
	CPEExplorerForm m_PEExplorerForm;
	//CIBMAsciiWnd m_IBMAsciiWnd;
	//CIBMAsciiWnd m_EBCDICWnd;
	//CIBMAsciiWnd m_ANSIAsciiWnd;

	CMainFrame();
	virtual ~CMainFrame();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnClose(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);
	bool OnBeginMove(WISP_MSG *pMsg);
	bool OnEndMove(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool Move();
	bool OnKeyEvent(WISP_MSG *pMsg);

	bool OnDebuggerPlunge(WISP_MSG *pMsg); //30
	bool OnDebuggerClose(WISP_MSG *pMsg); //31
	void FocusActive();

	bool OnEventDbgStep(WISP_MSG *pMsg);
	bool OnEventDbgProceed(WISP_MSG *pMsg);
	bool OnEventStepBranch(WISP_MSG *pMsg);
	bool OnEventDbgReturn(WISP_MSG *pMsg);
	bool OnEventDbgContinue(WISP_MSG *pMsg);
	bool OnEventBreakPointForm(WISP_MSG *pMsg);
	bool OnEventCallStack(WISP_MSG *pMsg);
	bool OnEventRegView(WISP_MSG *pMsg);
	bool OnEventDataViewForm(WISP_MSG *pMsg);

	void CreateProgress(const WCHAR *Text, unsigned long MaxPos);
	void UpdateProgress(unsigned long Pos);
	void UpdateCaption(const WCHAR *Text);
	void DestroyProgress();
};

#endif
```

`source/WispSyser/modulelist.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "modulelist.hpp"
#include "syserconfig.hpp"

enum
{
  ML_NAME = 0,
  ML_BASE = 1,
  ML_SIZE = 2,
  ML_SYM = 3,
  ML_PATH = 4,
};

	WISP_MSG_MAP_BEGIN(CModuleListWnd)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	WISP_EVENT_MAP_BEGIN(CModuleListWnd)
		WISP_EVENT_MAP(0x56, OnEventOpenPEExplorer)
		WISP_EVENT_MAP(0xF2, OnEventGotoBase) //EVENT_ID_GOTO_MODULE_BASE
		WISP_EVENT_MAP(0xF3, OnEventAnalyze) //EVENT_ID_ANALYZE_FUNCTION
	WISP_EVENT_MAP_END

WISP_MENU_GROUP_ITEM ModuleListPopupMenu[] =
{
	{WSTR("Goto Module Base"), 0xF2, 8, 0, 0}, //
	{WSTR("Analyze Module"), 0xF3, 8, 0, 0}, //
	{WSTR("PE Explorer "), 0x56, 0xE, 0, 0},
	{0},
};

	CModuleListWnd::CModuleListWnd()
	{
		m_pDbgMod = 0;
		m_bClose = false;
	}
	CModuleListWnd::~CModuleListWnd()
	{
	}

	bool CModuleListWnd::OnUpdate(WISP_MSG *pMsg)
	{
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		UpdateItemColor(0);
		return true;
	}

	bool CModuleListWnd::OnCreate(WISP_MSG *pMsg)
	{
		AttachTitleDIB(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xDC));
		m_ItemColor = gSyserColors.Color[1];
		m_Style |= 0x1000000;
		SetBGColor(gSyserColors.Color[0]);
		m_PopupMenu.LoadPopupMenuGroup(ModuleListPopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));

		int Ext = m_ClientDC.GetTextExtent(WSTR("X"), -1, 0);

		InsertColumn(WSTR("Name"), 100, 0, 0, -1);
		//76 +16
		InsertColumn(WSTR("Base"), (3+ADDR_SIZE)*Ext+3, 0, 0, -1); //60
		InsertColumn(WSTR("Size"), 68, 0, 0, -1);
		InsertColumn(WSTR("Symbols"), 50, 0, 0, -1);
		InsertColumn(WSTR("Path"), 150, 0, 0, -1);
		
		UpdateContext();
		return true;
	}
	bool CModuleListWnd::OnDestroy(WISP_MSG *pMsg)
	{
		m_PopupMenu.Destroy();
		return true;
	}
	bool CModuleListWnd::OnClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}
	bool CModuleListWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.bKeyDown && pMsg->KeyEvent.KeyType == VK_RBUTTON)
		{
			if (FindItem(0, 8))
				m_PopupMenu.Point(0, 1);
		}
		return true;
	}

	bool CModuleListWnd::OnEventOpenPEExplorer(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, ML_BASE);
			gpSyser->m_MainFrame.m_PEExplorerForm.Create();
			gpSyser->m_MainFrame.m_PEExplorerForm.Open(Addr);
		}
		return true;
	}
	bool CModuleListWnd::OnEventGotoBase(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, ML_BASE);
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveAddress(Addr, 0);
		}
		return true;
	}
	bool CModuleListWnd::OnEventAnalyze(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, ML_BASE);
			CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Addr);
			if (pDbgMod)
			{
				//TODO gpSyser->m_SyserUI.m_SymAnalyzer.???(pDbgMod, pDbgMod->+30); //pDbgMod->m_ImageBase
				//TODO gpSyser->m_MainFrame.m_SystemExplorer.m_SymAnalyzer.???(pDbgMod, pDbgMod->+30);
				gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
			}
		}
		return true;
	}

	void CModuleListWnd::OnLButton(CListStringItem *Item, int nCol)
	{
		if (m_bClose)
		{
			m_pDbgMod = (CDbgModule*)GetItemValue(Item, ML_NAME);
			Destroy();
		}
	}

	void CModuleListWnd::Create(bool bClose)
	{
		if (bClose)
		{
			m_bClose = true;
			CreateWnd(WSTR("Modules"), 0,0,500,350, 0, 0xE, 0x400100BB, WISP_SH_MINSIZE);
			SetOwner(&gpSyser->m_MainFrame.m_SystemExplorer);
			Center(0);
			Show(WISP_SH_MODAL_BLOCK);
		} else
		if (IsWindow())
		{
			Destroy();
		} else
		{
			CreateWnd(WSTR("Modules"), 0,0,500,350, 0, 0xE, 0x400100BB, WISP_SH_MINSIZE);
			SetOwner(&gpSyser->m_MainFrame.m_SystemExplorer);
			Center(0);
		}
	}
	void CModuleListWnd::UpdateContext()
	{
		if (gpSyser->m_pDebugger)
		{
			DeleteAllChildrenItems(0);

			map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
			//while (it != gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.end())
			while (it)
			{
				CListStringItem *Item = InsertItemStr(it->second.m_FileTitle.operator const char*(), 0, 0, 0, -1);
				WCHAR Buffer[MAX_FN_LEN];
				uNumToStr(it->second.m_ImageBase, Buffer, 16);
				SetItemText(Item, ML_BASE, Buffer);

				SetItemFormat(Item, ML_SIZE, it->second.m_ImageSize, WSTR("%08X"));

				SetItemFormat(Item, ML_SYM, (it->second.m_pSymbolModule?it->second.m_pSymbolModule->m_SymbolMap.size():0), WSTR("%d"));
				SetItemText(Item, ML_PATH, it->second.m_FullFileName.operator const char*());
				SetItemValue(Item, ML_NAME, (unsigned long long)&it->second);

				SetItemValue(Item, ML_BASE, it->second.m_ImageBase);
				++it;
			}

			if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger)
			{
				map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
				//while (it != gpSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.end())
				while (it)
				{
					CListStringItem *Item = InsertItemStr(it->second.m_FileTitle.operator const char*(), 0, 0, 0, -1);
					WCHAR Buffer[MAX_FN_LEN];
					uNumToStr(it->second.m_ImageBase, Buffer, 16);
					SetItemText(Item, ML_BASE, Buffer);

					SetItemFormat(Item, ML_SIZE, it->second.m_ImageSize, WSTR("%08X"));

					SetItemFormat(Item, ML_SYM, (it->second.m_pSymbolModule?it->second.m_pSymbolModule->m_SymbolMap.size():0), WSTR("%d"));
					SetItemText(Item, ML_PATH, it->second.m_FullFileName.operator const char*());
					SetItemValue(Item, ML_NAME, (unsigned long long)&it->second);

					SetItemValue(Item, ML_BASE, it->second.m_ImageBase);
					++it;
				}
			}
		}
	}


```

`source/WispSyser/modulelist.hpp`:

```hpp

#ifndef _MODULELIST_HPP_
#define _MODULELIST_HPP_

#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispmenu.hpp"

struct CDbgModule;
struct CModuleListWnd : public CWispList
{
	bool m_bClose;
	CWispMenu m_PopupMenu;
	CDbgModule *m_pDbgMod;

	CModuleListWnd();
	virtual ~CModuleListWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnClose(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool OnEventOpenPEExplorer(WISP_MSG *pMsg);
	bool OnEventGotoBase(WISP_MSG *pMsg);
	bool OnEventAnalyze(WISP_MSG *pMsg);

	virtual void OnLButton(CListStringItem *Item, int nCol) override;

	void Create(bool bClose);
	void UpdateContext();
};

#endif
```

`source/WispSyser/multicodeview.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "multicodeview.hpp"
#include "resource.hpp"

	WISP_MSG_MAP_BEGIN(CMultiCodeView)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
	WISP_MSG_MAP_END(CWispMultiTabView)

	CMultiCodeView::CMultiCodeView()
	{
	}
	CMultiCodeView::~CMultiCodeView()
	{
	}

	bool CMultiCodeView::OnCreate(WISP_MSG *pMsg)
	{
		InsertView(0);
		SetOwner(this);
		return true;
	}

	void CMultiCodeView::OnActiveWnd(CWispWnd *pWnd)
	{
		gpSyser->m_MainFrame.m_SystemExplorer.m_pCodeView = (CCodeView*)pWnd;
		gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();
	}

	CCodeView *CMultiCodeView::InsertView(CCodeView *pSrcView)
	{
		if (m_WndList.Size() >= 9) return nullptr;
		CCodeView *pNewView = new CCodeView;
		pNewView->CreateWnd(0, 0, 0, 0, 0, this, m_WndList.Size() + CMD_ID_CV0, 0x41010000, WISP_SH_MINSIZE);
		pNewView->m_AdvStyle |= 1;
		pNewView->m_pSyserCodeDoc = &gpSyser->m_SyserUI.m_SyserCodeDoc;
		InsertWnd(WSTR("" UNREADSTR ""), pNewView, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x7E));
		SetActiveWnd(m_WndList.Size() - 1);
		if (pSrcView)
			pNewView->GotoAddr(pSrcView->m_CurAddr, 0);
		return pNewView;
	}

	void CMultiCodeView::UpdateContext()
	{
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
		        static_cast<CCodeView*>(It->pWnd)->UpdateDasm();
		        ++It;
		}
	}
	void CMultiCodeView::ResetContext()
	{
		RemoveAllTab(true);
		InsertView(0);
	}

	ULONG_PTR CMultiCodeView::GetActiveAddress()
	{
		CCodeView *pWnd = (CCodeView *)GetActiveWnd();
		if (pWnd) return pWnd->m_CurAddr;
		return 0;
	}

	void CMultiCodeView::SetActiveAddress(ULONG_PTR Address, bool bHistory)
	{
		CCodeView *pWnd = (CCodeView *)GetActiveWnd();
		if (pWnd) pWnd->GotoAddr(Address, bHistory);
	}

	void CMultiCodeView::ClearBM()
	{
		m_Bookmark.clear();
		UpdateContext();
		gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();
	}
	bool CMultiCodeView::IsBM(ULONG_PTR Address)
	{
		return m_Bookmark.find(Address) != m_Bookmark.end();
	}
	void CMultiCodeView::ToggleBM(ULONG_PTR Address)
	{
		map<ULONG_PTR,ULONG_PTR>::IT it = m_Bookmark.find(Address);
		if (it == m_Bookmark.end())
			m_Bookmark.insert(_Tmap_pair<ULONG_PTR, ULONG_PTR>(Address, (ULONG_PTR*)0));
		else	m_Bookmark.erase(it);
		UpdateContext();
	}
	void CMultiCodeView::ToggleBM()
	{
		CCodeView *pWnd = (CCodeView *)GetActiveWnd();
		if (pWnd)
		{
			CListStringItem *Item = pWnd->FindItem(0, 8);
			if (Item)
			{
				ULONG_PTR Address = pWnd->GetItemValue(Item, CV_ADDR);
				ToggleBM(Address);
				gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();
			}
		}
	}
	void CMultiCodeView::NextBM()
	{
		CCodeView *pWnd = (CCodeView *)GetActiveWnd();
		if (pWnd)
		{
			map<ULONG_PTR,ULONG_PTR>::IT it = m_Bookmark.find_near(pWnd->m_CurAddr);
			if (it) it++;
			if (!it) it = m_Bookmark.begin();
			if (it)
			gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(it->first, false);
			
		}
	}
	void CMultiCodeView::PrevBM()
	{
		CCodeView *pWnd = (CCodeView *)GetActiveWnd();
		if (pWnd)
		{
			map<ULONG_PTR,ULONG_PTR>::IT it = m_Bookmark.find_near(pWnd->m_CurAddr);
			if (it && it->first == pWnd->m_CurAddr)
				--it;
			if (!it) it = m_Bookmark.rbegin();
			if (it)
			gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(it->first, false);
		}
	}

```

`source/WispSyser/multicodeview.hpp`:

```hpp

#ifndef _MULTICODEVIEW_HPP_
#define _MULTICODEVIEW_HPP_

#include "../Code/alt/altmap.hpp"
#include "../Wisp/wispmultitabview.hpp"
#include "codeview.hpp"

struct CMultiCodeView : public CWispMultiTabView
{
	map<ULONG_PTR, ULONG_PTR> m_Bookmark;

	CMultiCodeView();
	virtual ~CMultiCodeView();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);

	virtual void OnActiveWnd(CWispWnd *pWnd) override;

	CCodeView *InsertView(CCodeView *pSrcView);

	void UpdateContext();
	void ResetContext();

	ULONG_PTR GetActiveAddress();
	void SetActiveAddress(ULONG_PTR Address, bool bHistory);

	void ClearBM();
	bool IsBM(ULONG_PTR Address);
	void ToggleBM(ULONG_PTR Address);
	void ToggleBM();
	void NextBM();
	void PrevBM();
};

#endif
```

`source/WispSyser/multidataview.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "multidataview.hpp"
#include "../Wisp/wispsplitwnd.hpp"
#include "resource.hpp"

	WISP_MSG_MAP_BEGIN(CMultiDataView)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_COMMAND, CWispWnd::OnCommand)
//		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispMultiTabView)


	WISP_EVENT_MAP_BEGIN(CMultiDataView)
		WISP_EVENT_MAP(0x40000000, OnEventFullScr)
		WISP_EVENT_MAP(0x40000001, OnEventNewView)
//		WISP_EVENT_MAP(0x40000002, OnEventRemoveView)
	WISP_EVENT_MAP_END

//	WISP_COMMAND_MAP_BEGIN(CMultiDataView)
//		case default: return CWispWnd::OnCommand(pMsg);
//	WISP_COMMAND_MAP_END

	CMultiDataView::CMultiDataView()
	{
	}

	CMultiDataView::~CMultiDataView()
	{
	}

	bool CMultiDataView::OnCreate(WISP_MSG *pMsg)
	{
		InsertView(0);
		return true;
	}

	bool CMultiDataView::OnEventFullScr(WISP_MSG *pMsg)
	{
		if (m_WindowRect.cy <= static_cast<CWispSplitWnd*>(m_ParentWnd)->m_WindowRect.cy - 20)
			static_cast<CWispSplitWnd*>(m_ParentWnd)->AdjustWnd(0);
		else
			gpSyser->m_MainFrame.m_SystemExplorer.AdjustSplit();
		return true;
	}

	bool CMultiDataView::OnEventNewView(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002)
		{
			InsertView((CDataView *)GetActiveWnd());
		}
		return true;
	}

	CDataView *CMultiDataView::InsertView(CDataView *pSrcView)
	{
		if (m_WndList.Size() >= 9) return nullptr;
		CDataView *pNewView = new CDataView;
		WISP_RECT Rect;
		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		pNewView->CreateWnd(0, Rect, this, m_WndList.Size() + CMD_ID_DV0, 0, WISP_SH_MINSIZE);
		pNewView->m_AdvStyle |= 1;
		InsertWnd(WSTR("" UNREADSTR ""), pNewView, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x7F));
		SetActiveWnd(m_WndList.Size() - 1);
		SetActiveAddress(pSrcView ? pSrcView->m_CurAddr:0, 0);
		if (pSrcView)
			pNewView->m_ShowLength = pSrcView->m_ShowLength;
		return pNewView;
	}

	void CMultiDataView::UpdateContext()
	{
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			It->pWnd->Update((WISP_RECT*)0);
			++It;
		}
	}

	void CMultiDataView::DataWidthUpdate()
	{
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			static_cast<CDataView*>(It->pWnd)->DataWidthUpdate();
			++It;
		}
	}

	void CMultiDataView::ResetContext()
	{
		RemoveAllTab(true);
		InsertView(0);
	}

	int CMultiDataView::GetActiveDataWidth()
	{
		CDataView *pWnd = (CDataView *)GetActiveWnd();
		if (pWnd) return pWnd->GetDataWidth();
		return 1;
	}

	void CMultiDataView::SetActiveDataWidth(int Width)
	{
		CDataView *pWnd = (CDataView *)GetActiveWnd();
		if (pWnd) pWnd->SetDataWidth(Width);
	}

	ULONG_PTR CMultiDataView::GetActiveAddress()
	{
		CDataView *pWnd = (CDataView *)GetActiveWnd();
		if (pWnd) return pWnd->m_CurAddr;
		return 0;
	}
	void CMultiDataView::SetActiveAddress(ULONG_PTR Address, const WCHAR *pStrAddress)
	{
		CDataView *pWnd = (CDataView *)GetActiveWnd();
		if (pWnd)
		{
			pWnd->ViewAddress(Address, true);
			if (pStrAddress)
				pWnd->SetFloatAddress(pStrAddress);
		}
	}

```

`source/WispSyser/multidataview.hpp`:

```hpp

#ifndef _MULTIDATAVIEW_HPP_
#define _MULTIDATAVIEW_HPP_

#include "../Wisp/wispmultitabview.hpp"
#include "dataview.hpp"

struct CMultiDataView : public CWispMultiTabView
{

	CMultiDataView();
	virtual ~CMultiDataView();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventFullScr(WISP_MSG *pMsg);
	bool OnEventNewView(WISP_MSG *pMsg);

	CDataView *InsertView(CDataView *pSrcView);

	void UpdateContext();

	void DataWidthUpdate();

	void ResetContext();

	int GetActiveDataWidth();
	void SetActiveDataWidth(int Width);
	ULONG_PTR GetActiveAddress();
	void SetActiveAddress(ULONG_PTR Address, const WCHAR *pStrAddress);
};

#endif
```

`source/WispSyser/multisourcecodeview.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "multisourcecodeview.hpp"
#include "syserconfig.hpp"

	WISP_MSG_MAP_BEGIN(CMultiSourceCodeView)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispMultiTabView)

	WISP_CMD_MAP_BEGIN(CMultiSourceCodeView)
	WISP_CMD_MAP_END

	WISP_EVENT_MAP_BEGIN(CMultiSourceCodeView)
	WISP_EVENT_MAP_END

	bool CMultiSourceCodeView::OnCreate(WISP_MSG *pMsg)
	{
		SetBGColor(gSyserColors.Color[0]);
		return true;
	}

	bool CMultiSourceCodeView::OnRemoveTab(CWispWnd *pWnd)
	{
		CSourceCodeWnd *pSrcWnd = (CSourceCodeWnd *)pWnd;
		SCWKEY Key;
		Key.FileID = pSrcWnd->m_CurrentFileID;
		Key.pSDSMod = pSrcWnd->m_pSDSMod;
		map<SCWKEY, CSourceCodeWnd*>::IT it = m_SourceCodeWndMap.find(Key);
		if (it != m_SourceCodeWndMap.end())
			m_SourceCodeWndMap.erase(Key);
		CListStringItem *Item = gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.FullFindItem(0, 8);
		if (Item && gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.GetItemLevel(Item) == 1 &&
			it->first.pSDSMod == (CSDSModule *)gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.GetItemValue(Item, 0))
		{
			gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.Unselect(Item);
		}
		return true;
	}
	void CMultiSourceCodeView::OnRemoved()
	{
		if (!m_WndList.Size())
			gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();
	}

	void CMultiSourceCodeView::OnActiveWnd(CWispWnd *pWnd)
	{
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();
	}

	void CMultiSourceCodeView::UpdateContext()
	{
		TListIter<WISP_TAB_WND_ITEM> It = m_WndList.Begin();
		while (It != m_WndList.End())
		{
			static_cast<CSourceCodeWnd*>(It->pWnd)->UpdateContextSrc();
			static_cast<CSourceCodeWnd*>(It->pWnd)->UpdateContextPics();
			++It;
		}
	}

```

`source/WispSyser/multisourcecodeview.hpp`:

```hpp

#ifndef _MULTISOURCECODEVIEW_HPP_
#define _MULTISOURCECODEVIEW_HPP_

#include "../Code/alt/altmap.hpp"
#include "../Wisp/wispmultitabview.hpp"
#include "../EXEAnalyzer/sdsmodule.hpp"
#include "sourcecodewnd.hpp"

struct SCWKEY
{
	unsigned long FileID;
	CSDSModule *pSDSMod;
	//CSourceCodeWnd *pSrcWnd;
	
//	SCWKEY(unsigned long FileID, CSDSModule *pSDSMod):FileID(FileID), pSDSMod(pSDSMod) {}
	bool operator==(const SCWKEY & other) const
	{
		return FileID == other.FileID && pSDSMod == other.pSDSMod;
	}
	bool operator<(const SCWKEY & other) const
	{
	        if (FileID < other.FileID) return true;
	        if (FileID > other.FileID) return false;
	        if (pSDSMod < other.pSDSMod) return true;
	        return false;
	}
};

struct CMultiSourceCodeView : public CWispMultiTabView
{
	map<SCWKEY, CSourceCodeWnd*> m_SourceCodeWndMap;

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	virtual bool OnRemoveTab(CWispWnd *pWnd) override;
	virtual void OnRemoved() override;
	virtual void OnActiveWnd(CWispWnd *pWnd) override;

	void UpdateContext();
};

#endif
```

`source/WispSyser/ntstatus.cpp`:

```cpp

#include "othercmd.hpp"

NTSTATUS_ENTRY stNtStatusList[] =
	{
      {"STATUS_WAIT_0", "STATUS_WAIT_0", 0 },
      {"STATUS_WAIT_1", "STATUS_WAIT_1", 0x00000001 },
      {"STATUS_WAIT_2", "STATUS_WAIT_2", 0x00000002 },
      {"STATUS_WAIT_3", "STATUS_WAIT_3", 0x00000003 },
      {"STATUS_WAIT_63", "STATUS_WAIT_63", 0x0000003F },
      {"The success status codes 128 - 191 are reserved for wait completionstatus with an abandoned mutant object.", "STATUS_ABANDONED", 0x00000080 },
      {"STATUS_ABANDONED_WAIT_0", "STATUS_ABANDONED_WAIT_0", 0x00000080 },
      {"STATUS_ABANDONED_WAIT_63", "STATUS_ABANDONED_WAIT_63", 0x000000BF },
      {"STATUS_USER_APC", "STATUS_USER_APC", 0x000000C0 },
      {"STATUS_KERNEL_APC", "STATUS_KERNEL_APC", 0x00000100 },
      {"STATUS_ALERTED", "STATUS_ALERTED", 0x00000101 },
      {"STATUS_TIMEOUT", "STATUS_TIMEOUT", 0x00000102 },
      {"The operation that was requested is pending completion.", "STATUS_PENDING", 0x00000103 },
      {"A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.", "STATUS_REPARSE", 0x00000104 },
      {"Returned by enumeration APIs to indicate more information is available to successive calls.", "STATUS_MORE_ENTRIES", 0x00000105 },
      {"Indicates not all privileges referenced are assigned to the caller.This allows, for example, all privileges to be disabled without having to know exactly which privileges are assigned.", "STATUS_NOT_ALL_ASSIGNED", 0x00000106 },
      {"Some of the information to be translated has not been translated.", "STATUS_SOME_NOT_MAPPED", 0x00000107 },
      {"An open/create operation completed while an oplock break is underway.", "STATUS_OPLOCK_BREAK_IN_PROGRESS", 0x00000108 },
      {"A new volume has been mounted by a file system.", "STATUS_VOLUME_MOUNTED", 0x00000109 },
      {"This success level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.The commit has now been completed.", "STATUS_RXACT_COMMITTED", 0x0000010A },
      {"This indicates that a notify change request has been completed due to closing the handle which made the notify change request.", "STATUS_NOTIFY_CLEANUP", 0x0000010B },
      {"This indicates that a notify change request is being completed and that the information is not being returned in the caller's buffer.The caller now needs to enumerate the files to find the changes.", "STATUS_NOTIFY_ENUM_DIR", 0x0000010C },
      {"{No Quotas}No system quota limits are specifically set for this account.", "STATUS_NO_QUOTAS_FOR_ACCOUNT", 0x0000010D },
      {"{Connect Failure on Primary Transport}An attempt was made to connect to the remote server %hs on the primary transport, but the connection failed.The computer WAS able to connect on a secondary transport.", "STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED", 0x0000010E },
      {"Page fault was a transition fault.", "STATUS_PAGE_FAULT_TRANSITION", 0x00000110 },
      {"Page fault was a demand zero fault.", "STATUS_PAGE_FAULT_DEMAND_ZERO", 0x00000111 },
      {"Page fault was a demand zero fault.", "STATUS_PAGE_FAULT_COPY_ON_WRITE", 0x00000112 },
      {"Page fault was a demand zero fault.", "STATUS_PAGE_FAULT_GUARD_PAGE", 0x00000113 },
      {"Page fault was satisfied by reading from a secondary storage device.", "STATUS_PAGE_FAULT_PAGING_FILE", 0x00000114 },
      {"Cached page was locked during operation.", "STATUS_CACHE_PAGE_LOCKED", 0x00000115 },
      {"Crash dump exists in paging file.", "STATUS_CRASH_DUMP", 0x00000116 },
      {"Specified buffer contains all zeros.", "STATUS_BUFFER_ALL_ZEROS", 0x00000117 },
      {"A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.", "STATUS_REPARSE_OBJECT", 0x00000118 },
      {"The device has succeeded a query-stop and its resource requirements have changed.", "STATUS_RESOURCE_REQUIREMENTS_CHANGED", 0x00000119 },
      {"The translator has translated these resources into the global space and no further translations should be performed.", "STATUS_TRANSLATION_COMPLETE", 0x00000120 },
      {"The directory service evaluated group memberships locally, as it was unable to contact a global catalog server.", "STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY", 0x00000121 },
      {"A process being terminated has no threads to terminate.", "STATUS_NOTHING_TO_TERMINATE", 0x00000122 },
      {"The specified process is not part of a job.", "STATUS_PROCESS_NOT_IN_JOB", 0x00000123 },
      {"The specified process is part of a job.", "STATUS_PROCESS_IN_JOB", 0x00000124 },
      {"{Volume Shadow Copy Service}The system is now ready for hibernation.", "STATUS_VOLSNAP_HIBERNATE_READY", 0x00000125 },
      {"A file system or file system filter driver has successfully completed an FsFilter operation.", "STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY", 0x00000126 },
      {"Debugger handled exception", "DBG_EXCEPTION_HANDLED", 0x00010001 },
      {"Debugger continued", "DBG_CONTINUE", 0x00010002 },
      {"{Object Exists}An attempt was made to create an object and the object name already existed.", "STATUS_OBJECT_NAME_EXISTS", 0x40000000 },
      {"{Thread Suspended}A thread termination occurred while the thread was suspended. The thread was resumed, and termination proceeded.", "STATUS_THREAD_WAS_SUSPENDED", 0x40000001 },
      {"{Working Set Range Error}An attempt was made to set the working set minimum or maximum to values which are outside of the allowable range.", "STATUS_WORKING_SET_LIMIT_RANGE", 0x40000002 },
      {"{Image Relocated}An image file could not be mapped at the address specified in the image file. Local fixups must be performed on this image.", "STATUS_IMAGE_NOT_AT_BASE", 0x40000003 },
      {"This informational level status indicates that a specified registry sub-tree transaction state did not yet exist and had to be created.", "STATUS_RXACT_STATE_CREATED", 0x40000004 },
      {"{Segment Load}A virtual DOS machine (VDM) is loading, unloading, or moving an MS-DOS or Win16 program segment image.An exception is raised so a debugger can load, unload or track symbols and breakpoints within these 16-bit segments.", "STATUS_SEGMENT_NOTIFICATION", 0x40000005 },
      {"{Local Session Key}A user session key was requested for a local RPC connection. The session key returned is a constant value and not unique to this connection.", "STATUS_LOCAL_USER_SESSION_KEY", 0x40000006 },
      {"{Invalid Current Directory}The process cannot switch to the startup current directory %hs.Select OK to set current directory to %hs, or select CANCEL to exit.", "STATUS_BAD_CURRENT_DIRECTORY", 0x40000007 },
      {"{Serial IOCTL Complete}A serial I/O operation was completed by another write to a serial port.(The IOCTL_SERIAL_XOFF_COUNTER reached zero.)", "STATUS_SERIAL_MORE_WRITES", 0x40000008 },
      {"{Registry Recovery}One of the files containing the system's Registry data had to be recovered by use of a log or alternate copy.The recovery was successful.", "STATUS_REGISTRY_RECOVERED", 0x40000009 },
      {"{Redundant Read}To satisfy a read request, the NT fault-tolerant file system successfully read the requested data from a redundant copy.This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was unable to reassign the failing area of the device.", "STATUS_FT_READ_RECOVERY_FROM_BACKUP", 0x4000000A },
      {"{Redundant Write}To satisfy a write request, the NT fault-tolerant file system successfully wrote a redundant copy of the information.This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was not able to reassign the failing area of the device.", "STATUS_FT_WRITE_RECOVERY", 0x4000000B },
      {"{Serial IOCTL Timeout}A serial I/O operation completed because the time-out period expired.(The IOCTL_SERIAL_XOFF_COUNTER had not reached zero.)", "STATUS_SERIAL_COUNTER_TIMEOUT", 0x4000000C },
      {"{Password Too Complex}The Windows password is too complex to be converted to a LAN Manager password.The LAN Manager password returned is a NULL string.", "STATUS_NULL_LM_PASSWORD", 0x4000000D },
      {"{Machine Type Mismatch}The image file %hs is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.", "STATUS_IMAGE_MACHINE_TYPE_MISMATCH", 0x4000000E },
      {"{Partial Data Received}The network transport returned partial data to its client. The remaining data will be sent later.", "STATUS_RECEIVE_PARTIAL", 0x4000000F },
      {"{Expedited Data Received}The network transport returned data to its client that was marked as expedited by the remote system.", "STATUS_RECEIVE_EXPEDITED", 0x40000010 },
      {"{Partial Expedited Data Received}The network transport returned partial data to its client and this data was marked as expedited by the remote system. The remaining data will be sent later.", "STATUS_RECEIVE_PARTIAL_EXPEDITED", 0x40000011 },
      {"{TDI Event Done}The TDI indication has completed successfully.", "STATUS_EVENT_DONE", 0x40000012 },
      {"{TDI Event Pending}The TDI indication has entered the pending state.", "STATUS_EVENT_PENDING", 0x40000013 },
      {"Checking file system on %wZ", "STATUS_CHECKING_FILE_SYSTEM", 0x40000014 },
      {"{Fatal Application Exit}%hs", "STATUS_FATAL_APP_EXIT", 0x40000015 },
      {"The specified registry key is referenced by a predefined handle.", "STATUS_PREDEFINED_HANDLE", 0x40000016 },
      {"{Page Unlocked}The page protection of a locked page was changed to 'No Access' and the page was unlocked from memory and from the process.", "STATUS_WAS_UNLOCKED", 0x40000017 },
      {"%hs", "STATUS_SERVICE_NOTIFICATION", 0x40000018 },
      {"{Page Locked}One of the pages to lock was already locked.", "STATUS_WAS_LOCKED", 0x40000019 },
      {"Application popup: %1 : %2", "STATUS_LOG_HARD_ERROR", 0x4000001A },
      {"STATUS_ALREADY_WIN32", "STATUS_ALREADY_WIN32", 0x4000001B },
      {"Exception status code used by Win32 x86 emulation subsystem.", "STATUS_WX86_UNSIMULATE", 0x4000001C },
      {"Exception status code used by Win32 x86 emulation subsystem.", "STATUS_WX86_CONTINUE", 0x4000001D },
      {"Exception status code used by Win32 x86 emulation subsystem.", "STATUS_WX86_SINGLE_STEP", 0x4000001E },
      {"Exception status code used by Win32 x86 emulation subsystem.", "STATUS_WX86_BREAKPOINT", 0x4000001F },
      {"Exception status code used by Win32 x86 emulation subsystem.", "STATUS_WX86_EXCEPTION_CONTINUE", 0x40000020 },
      {"Exception status code used by Win32 x86 emulation subsystem.", "STATUS_WX86_EXCEPTION_LASTCHANCE", 0x40000021 },
      {"Exception status code used by Win32 x86 emulation subsystem.", "STATUS_WX86_EXCEPTION_CHAIN", 0x40000022 },
      {"{Machine Type Mismatch}The image file %hs is valid, but is for a machine type other than the current machine.", "STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE", 0x40000023 },
      {"A yield execution was performed and no thread was available to run.", "STATUS_NO_YIELD_PERFORMED", 0x40000024 },
      {"The resumable flag to a timer API was ignored.", "STATUS_TIMER_RESUME_IGNORED", 0x40000025 },
      {"The arbiter has deferred arbitration of these resources to its parent", "STATUS_ARBITRATION_UNHANDLED", 0x40000026 },
      {"The device \"%hs\" has detected a CardBus card in its slot, but the firmware on this system is not configured to allow the CardBus controller to be run in CardBus mode.The operating system will currently accept only 16-bit (R2) pc-cards on this controller.", "STATUS_CARDBUS_NOT_SUPPORTED", 0x40000027 },
      {"Exception status code used by Win32 x86 emulation subsystem.", "STATUS_WX86_CREATEWX86TIB", 0x40000028 },
      {"The CPUs in this multiprocessor system are not all the same revision level.  To use all processors the operating system restricts itself to the features of the least capable processor in the system.  Should problems occur with this system, contactthe CPU manufacturer to see if this mix of processors is supported.", "STATUS_MP_PROCESSOR_MISMATCH", 0x40000029 },
      {"The system was put into hibernation.", "STATUS_HIBERNATED", 0x4000002A },
      {"The system was resumed from hibernation.", "STATUS_RESUME_HIBERNATION", 0x4000002B },
      {"Windows has detected that the system firmware (BIOS) was updated [previous firmware date = %2, current firmware date %3].", "STATUS_FIRMWARE_UPDATED", 0x4000002C },
      {"A device driver is leaking locked I/O pages causing system degradation.  The system has automatically enabled tracking code in order to try and catch the culprit.", "STATUS_DRIVERS_LEAKING_LOCKED_PAGES", 0x4000002D },
      {"Debugger will reply later.", "DBG_REPLY_LATER", 0x40010001 },
      {"Debugger can not provide handle.", "DBG_UNABLE_TO_PROVIDE_HANDLE", 0x40010002 },
      {"Debugger terminated thread.", "DBG_TERMINATE_THREAD", 0x40010003 },
      {"Debugger terminated process.", "DBG_TERMINATE_PROCESS", 0x40010004 },
      {"Debugger got control C.", "DBG_CONTROL_C", 0x40010005 },
      {"Debugger printed exception on control C.", "DBG_PRINTEXCEPTION_C", 0x40010006 },
      {"Debugger received RIP exception.", "DBG_RIPEXCEPTION", 0x40010007 },
      {"Debugger received control break.", "DBG_CONTROL_BREAK", 0x40010008 },
      {"Debugger command communication exception.", "DBG_COMMAND_EXCEPTION", 0x40010009 },
      {"{EXCEPTION}Guard Page ExceptionA page of memory that marks the end of a data structure, such as a stack or an array, has been accessed.", "STATUS_GUARD_PAGE_VIOLATION", 0x80000001 },
      {"{EXCEPTION}Alignment FaultA datatype misalignment was detected in a load or store instruction.", "STATUS_DATATYPE_MISALIGNMENT", 0x80000002 },
      {"{EXCEPTION}BreakpointA breakpoint has been reached.", "STATUS_BREAKPOINT", 0x80000003 },
      {"{EXCEPTION}Single StepA single step or trace operation has just been completed.", "STATUS_SINGLE_STEP", 0x80000004 },
      {"{Buffer Overflow}The data was too large to fit into the specified buffer.", "STATUS_BUFFER_OVERFLOW", 0x80000005 },
      {"{No More Files}No more files were found which match the file specification.", "STATUS_NO_MORE_FILES", 0x80000006 },
      {"{Kernel Debugger Awakened}the system debugger was awakened by an interrupt.", "STATUS_WAKE_SYSTEM_DEBUGGER", 0x80000007 },
      {"{Handles Closed}Handles to objects have been automatically closed as a result of the requested operation.", "STATUS_HANDLES_CLOSED", 0x8000000A },
      {"{Non-Inheritable ACL}An access control list (ACL},", "STATUS_NO_INHERITANCE", 0x8000000B },
      {"{GUID Substitution}During the translation of a global identifier (GUID) to a Windows security ID (SID), no administratively-defined GUID prefix was found.A substitute prefix was used, which will not compromise system security.However, this may provide a more restrictive access than intended.", "STATUS_GUID_SUBSTITUTION_MADE", 0x8000000C },
      {"{Partial Copy}Due to protection conflicts not all the requested bytes could be copied.", "STATUS_PARTIAL_COPY", 0x8000000D },
      {"{Out of Paper}The printer is out of paper.", "STATUS_DEVICE_PAPER_EMPTY", 0x8000000E },
      {"{Device Power Is Off}The printer power has been turned off.", "STATUS_DEVICE_POWERED_OFF", 0x8000000F },
      {"{Device Offline}The printer has been taken offline.", "STATUS_DEVICE_OFF_LINE", 0x80000010 },
      {"{Device Busy}The device is currently busy.", "STATUS_DEVICE_BUSY", 0x80000011 },
      {"{No More EAs}No more extended attributes (EAs) were found for the file.", "STATUS_NO_MORE_EAS", 0x80000012 },
      {"{Illegal EA}The specified extended attribute (EA) name contains at least one illegal character.", "STATUS_INVALID_EA_NAME", 0x80000013 },
      {"{Inconsistent EA List}The extended attribute (EA) list is inconsistent.", "STATUS_EA_LIST_INCONSISTENT", 0x80000014 },
      {"{Invalid EA Flag}An invalid extended attribute (EA) flag was set.", "STATUS_INVALID_EA_FLAG", 0x80000015 },
      {"{Verifying Disk}The media has changed and a verify operation is in progress so no reads or writes may be performed to the device, except those used in the verify operation.", "STATUS_VERIFY_REQUIRED", 0x80000016 },
      {"{Too Much Information}The specified access control list (ACL},", "STATUS_EXTRANEOUS_INFORMATION", 0x80000017 },
      {"This warning level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.The commit has NOT been completed, but has not been rolled back either (so it may still be committed if desired).", "STATUS_RXACT_COMMIT_NECESSARY", 0x80000018 },
      {"{No More Entries}No more entries are available from an enumeration operation.", "STATUS_NO_MORE_ENTRIES", 0x8000001A },
      {"{Filemark Found}A filemark was detected.", "STATUS_FILEMARK_DETECTED", 0x8000001B },
      {"{Media Changed}The media may have changed.", "STATUS_MEDIA_CHANGED", 0x8000001C },
      {"{I/O Bus Reset}An I/O bus reset was detected.", "STATUS_BUS_RESET", 0x8000001D },
      {"{End of Media}The end of the media was encountered.", "STATUS_END_OF_MEDIA", 0x8000001E },
      {"Beginning of tape or partition has been detected.", "STATUS_BEGINNING_OF_MEDIA", 0x8000001F },
      {"{Media Changed}The media may have changed.", "STATUS_MEDIA_CHECK", 0x80000020 },
      {"A tape access reached a setmark.", "STATUS_SETMARK_DETECTED", 0x80000021 },
      {"During a tape access, the end of the data written is reached.", "STATUS_NO_DATA_DETECTED", 0x80000022 },
      {"The redirector is in use and cannot be unloaded.", "STATUS_REDIRECTOR_HAS_OPEN_HANDLES", 0x80000023 },
      {"The server is in use and cannot be unloaded.", "STATUS_SERVER_HAS_OPEN_HANDLES", 0x80000024 },
      {"The specified connection has already been disconnected.", "STATUS_ALREADY_DISCONNECTED", 0x80000025 },
      {"A long jump has been executed.", "STATUS_LONGJUMP", 0x80000026 },
      {"A cleaner cartridge is present in the tape library.", "STATUS_CLEANER_CARTRIDGE_INSTALLED", 0x80000027 },
      {"The Plug and Play query operation was not successful.", "STATUS_PLUGPLAY_QUERY_VETOED", 0x80000028 },
      {"A frame consolidation has been executed.", "STATUS_UNWIND_CONSOLIDATE", 0x80000029 },
      {"{Registry Hive Recovered}Registry hive (file):%hswas corrupted and it has been recovered. Some data might have been lost.", "STATUS_REGISTRY_HIVE_RECOVERED", 0x8000002A },
      {"The application is attempting to run executable code from the module %hs.  This may be insecure.  An alternative, %hs, is available.  Should the application use the secure module %hs?", "STATUS_DLL_MIGHT_BE_INSECURE", 0x8000002B },
      {"The application is loading executable code from the module %hs.  This is secure, but may be incompatible with previous releases of the operating system.  An alternative, %hs, is available.  Should the application use the secure module %hs?", "STATUS_DLL_MIGHT_BE_INCOMPATIBLE", 0x8000002C },
      {"Debugger did not handle the exception.", "DBG_EXCEPTION_NOT_HANDLED", 0x80010001 },
      {"The cluster node is already up.", "STATUS_CLUSTER_NODE_ALREADY_UP", 0x80130001 },
      {"The cluster node is already down.", "STATUS_CLUSTER_NODE_ALREADY_DOWN", 0x80130002 },
      {"The cluster network is already online.", "STATUS_CLUSTER_NETWORK_ALREADY_ONLINE", 0x80130003 },
      {"The cluster network is already offline.", "STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE", 0x80130004 },
      {"The cluster node is already a member of the cluster.", "STATUS_CLUSTER_NODE_ALREADY_MEMBER", 0x80130005 },
      {"{Operation Failed}The requested operation was unsuccessful.", "STATUS_UNSUCCESSFUL", 0xC0000001 },
      {"{Not Implemented}The requested operation is not implemented.", "STATUS_NOT_IMPLEMENTED", 0xC0000002 },
      {"{Invalid Parameter}The specified information class is not a valid information class for the specified object.", "STATUS_INVALID_INFO_CLASS", 0xC0000003 },
      {"The specified information record length does not match the length required for the specified information class.", "STATUS_INFO_LENGTH_MISMATCH", 0xC0000004 },
      {"The instruction at \"0x%08lx\" referenced memory at \"0x%08lx\". The memory could not be \"%s\".", "STATUS_ACCESS_VIOLATION", 0xC0000005 },
      {"The instruction at \"0x%08lx\" referenced memory at \"0x%08lx\". The required data was not placed into memory because of an I/O error status of \"0x%08lx\".", "STATUS_IN_PAGE_ERROR", 0xC0000006 },
      {"The pagefile quota for the process has been exhausted.", "STATUS_PAGEFILE_QUOTA", 0xC0000007 },
      {"An invalid HANDLE was specified.", "STATUS_INVALID_HANDLE", 0xC0000008 },
      {"An invalid initial stack was specified in a call to NtCreateThread.", "STATUS_BAD_INITIAL_STACK", 0xC0000009 },
      {"An invalid initial start address was specified in a call to NtCreateThread.", "STATUS_BAD_INITIAL_PC", 0xC000000A },
      {"An invalid Client ID was specified.", "STATUS_INVALID_CID", 0xC000000B },
      {"An attempt was made to cancel or set a timer that has an associated APC and the subject thread is not the thread that originally set the timer with an associated APC routine.", "STATUS_TIMER_NOT_CANCELED", 0xC000000C },
      {"An invalid parameter was passed to a service or function.", "STATUS_INVALID_PARAMETER", 0xC000000D },
      {"A device which does not exist was specified.", "STATUS_NO_SUCH_DEVICE", 0xC000000E },
      {"{File Not Found}The file %hs does not exist.", "STATUS_NO_SUCH_FILE", 0xC000000F },
      {"The specified request is not a valid operation for the target device.", "STATUS_INVALID_DEVICE_REQUEST", 0xC0000010 },
      {"The end-of-file marker has been reached. There is no valid data in the file beyond this marker.", "STATUS_END_OF_FILE", 0xC0000011 },
      {"{Wrong Volume}The wrong volume is in the drive.Please insert volume %hs into drive %hs.", "STATUS_WRONG_VOLUME", 0xC0000012 },
      {"{No Disk}There is no disk in the drive.Please insert a disk into drive %hs.", "STATUS_NO_MEDIA_IN_DEVICE", 0xC0000013 },
      {"{Unknown Disk Format}The disk in drive %hs is not formatted properly.Please check the disk, and reformat if necessary.", "STATUS_UNRECOGNIZED_MEDIA", 0xC0000014 },
      {"{Sector Not Found}The specified sector does not exist.", "STATUS_NONEXISTENT_SECTOR", 0xC0000015 },
      {"{Still Busy}The specified I/O request packet (IRP) cannot be disposed of because the I/O operation is not complete.", "STATUS_MORE_PROCESSING_REQUIRED", 0xC0000016 },
      {"{Not Enough Quota}Not enough virtual memory or paging file quota is available to complete the specified operation.", "STATUS_NO_MEMORY", 0xC0000017 },
      {"{Conflicting Address Range}The specified address range conflicts with the address space.", "STATUS_CONFLICTING_ADDRESSES", 0xC0000018 },
      {"Address range to unmap is not a mapped view.", "STATUS_NOT_MAPPED_VIEW", 0xC0000019 },
      {"Virtual memory cannot be freed.", "STATUS_UNABLE_TO_FREE_VM", 0xC000001A },
      {"Specified section cannot be deleted.", "STATUS_UNABLE_TO_DELETE_SECTION", 0xC000001B },
      {"An invalid system service was specified in a system service call.", "STATUS_INVALID_SYSTEM_SERVICE", 0xC000001C },
      {"{EXCEPTION}Illegal InstructionAn attempt was made to execute an illegal instruction.", "STATUS_ILLEGAL_INSTRUCTION", 0xC000001D },
      {"{Invalid Lock Sequence}An attempt was made to execute an invalid lock sequence.", "STATUS_INVALID_LOCK_SEQUENCE", 0xC000001E },
      {"{Invalid Mapping}An attempt was made to create a view for a section which is bigger than the section.", "STATUS_INVALID_VIEW_SIZE", 0xC000001F },
      {"{Bad File}The attributes of the specified mapping file for a section of memory cannot be read.", "STATUS_INVALID_FILE_FOR_SECTION", 0xC0000020 },
      {"{Already Committed}The specified address range is already committed.", "STATUS_ALREADY_COMMITTED", 0xC0000021 },
      {"{Access Denied}A process has requested access to an object, but has not been granted those access rights.", "STATUS_ACCESS_DENIED", 0xC0000022 },
      {"{Buffer Too Small}The buffer is too small to contain the entry. No information has been written to the buffer.", "STATUS_BUFFER_TOO_SMALL", 0xC0000023 },
      {"{Wrong Type}There is a mismatch between the type of object required by the requested operation and the type of object that is specified in the request.", "STATUS_OBJECT_TYPE_MISMATCH", 0xC0000024 },
      {"{EXCEPTION}Cannot ContinueWindows cannot continue from this exception.", "STATUS_NONCONTINUABLE_EXCEPTION", 0xC0000025 },
      {"An invalid exception disposition was returned by an exception handler.", "STATUS_INVALID_DISPOSITION", 0xC0000026 },
      {"Unwind exception code.", "STATUS_UNWIND", 0xC0000027 },
      {"An invalid or unaligned stack was encountered during an unwind operation.", "STATUS_BAD_STACK", 0xC0000028 },
      {"An invalid unwind target was encountered during an unwind operation.", "STATUS_INVALID_UNWIND_TARGET", 0xC0000029 },
      {"An attempt was made to unlock a page of memory which was not locked.", "STATUS_NOT_LOCKED", 0xC000002A },
      {"Device parity error on I/O operation.", "STATUS_PARITY_ERROR", 0xC000002B },
      {"An attempt was made to decommit uncommitted virtual memory.", "STATUS_UNABLE_TO_DECOMMIT_VM", 0xC000002C },
      {"An attempt was made to change the attributes on memory that has not been committed.", "STATUS_NOT_COMMITTED", 0xC000002D },
      {"Invalid Object Attributes specified to NtCreatePort or invalid Port Attributes specified to NtConnectPort", "STATUS_INVALID_PORT_ATTRIBUTES", 0xC000002E },
      {"Length of message passed to NtRequestPort or NtRequestWaitReplyPort was longer than the maximum message allowed by the port.", "STATUS_PORT_MESSAGE_TOO_LONG", 0xC000002F },
      {"An invalid combination of parameters was specified.", "STATUS_INVALID_PARAMETER_MIX", 0xC0000030 },
      {"An attempt was made to lower a quota limit below the current usage.", "STATUS_INVALID_QUOTA_LOWER", 0xC0000031 },
      {"{Corrupt Disk}The file system structure on the disk is corrupt and unusable.Please run the Chkdsk utility on the volume %hs.", "STATUS_DISK_CORRUPT_ERROR", 0xC0000032 },
      {"Object Name invalid.", "STATUS_OBJECT_NAME_INVALID", 0xC0000033 },
      {"Object Name not found.", "STATUS_OBJECT_NAME_NOT_FOUND", 0xC0000034 },
      {"Object Name already exists.", "STATUS_OBJECT_NAME_COLLISION", 0xC0000035 },
      {"Attempt to send a message to a disconnected communication port.", "STATUS_PORT_DISCONNECTED", 0xC0000037 },
      {"An attempt was made to attach to a device that was already attached to another device.", "STATUS_DEVICE_ALREADY_ATTACHED", 0xC0000038 },
      {"Object Path Component was not a directory object.", "STATUS_OBJECT_PATH_INVALID", 0xC0000039 },
      {"{Path Not Found}The path %hs does not exist.", "STATUS_OBJECT_PATH_NOT_FOUND", 0xC000003A },
      {"Object Path Component was not a directory object.", "STATUS_OBJECT_PATH_SYNTAX_BAD", 0xC000003B },
      {"{Data Overrun}A data overrun error occurred.", "STATUS_DATA_OVERRUN", 0xC000003C },
      {"{Data Late}A data late error occurred.", "STATUS_DATA_LATE_ERROR", 0xC000003D },
      {"{Data Error}An error in reading or writing data occurred.", "STATUS_DATA_ERROR", 0xC000003E },
      {"{Bad CRC}A cyclic redundancy check (CRC) checksum error occurred.", "STATUS_CRC_ERROR", 0xC000003F },
      {"{Section Too Large}The specified section is too big to map the file.", "STATUS_SECTION_TOO_BIG", 0xC0000040 },
      {"The NtConnectPort request is refused.", "STATUS_PORT_CONNECTION_REFUSED", 0xC0000041 },
      {"The type of port handle is invalid for the operation requested.", "STATUS_INVALID_PORT_HANDLE", 0xC0000042 },
      {"A file cannot be opened because the share access flags are incompatible.", "STATUS_SHARING_VIOLATION", 0xC0000043 },
      {"Insufficient quota exists to complete the operation", "STATUS_QUOTA_EXCEEDED", 0xC0000044 },
      {"The specified page protection was not valid.", "STATUS_INVALID_PAGE_PROTECTION", 0xC0000045 },
      {"An attempt to release a mutant object was made by a thread that was not the owner of the mutant object.", "STATUS_MUTANT_NOT_OWNED", 0xC0000046 },
      {"An attempt was made to release a semaphore such that its maximum count would have been exceeded.", "STATUS_SEMAPHORE_LIMIT_EXCEEDED", 0xC0000047 },
      {"An attempt to set a processes DebugPort or ExceptionPort was made, but a port already exists in the process oran attempt to set a file's CompletionPort made, but a port was already set in the file.", "STATUS_PORT_ALREADY_SET", 0xC0000048 },
      {"An attempt was made to query image information on a section which does not map an image.", "STATUS_SECTION_NOT_IMAGE", 0xC0000049 },
      {"An attempt was made to suspend a thread whose suspend count was at its maximum.", "STATUS_SUSPEND_COUNT_EXCEEDED", 0xC000004A },
      {"An attempt was made to suspend a thread that has begun termination.", "STATUS_THREAD_IS_TERMINATING", 0xC000004B },
      {"An attempt was made to set the working set limit to an invalid value (minimum greater than maximum, etc).", "STATUS_BAD_WORKING_SET_LIMIT", 0xC000004C },
      {"A section was created to map a file which is not compatible to an already existing section which maps the same file.", "STATUS_INCOMPATIBLE_FILE_MAP", 0xC000004D },
      {"A view to a section specifies a protection which is incompatible with the initial view's protection.", "STATUS_SECTION_PROTECTION", 0xC000004E },
      {"An operation involving EAs failed because the file system does not support EAs.", "STATUS_EAS_NOT_SUPPORTED", 0xC000004F },
      {"An EA operation failed because EA set is too large.", "STATUS_EA_TOO_LARGE", 0xC0000050 },
      {"An EA operation failed because the name or EA index is invalid.", "STATUS_NONEXISTENT_EA_ENTRY", 0xC0000051 },
      {"The file for which EAs were requested has no EAs.", "STATUS_NO_EAS_ON_FILE", 0xC0000052 },
      {"The EA is corrupt and non-readable.", "STATUS_EA_CORRUPT_ERROR", 0xC0000053 },
      {"A requested read/write cannot be granted due to a conflicting file lock.", "STATUS_FILE_LOCK_CONFLICT", 0xC0000054 },
      {"A requested file lock cannot be granted due to other existing locks.", "STATUS_LOCK_NOT_GRANTED", 0xC0000055 },
      {"A non close operation has been requested of a file object with a delete pending.", "STATUS_DELETE_PENDING", 0xC0000056 },
      {"An attempt was made to set the control attribute on a file. This attribute is not supported in the target file system.", "STATUS_CTL_FILE_NOT_SUPPORTED", 0xC0000057 },
      {"Indicates a revision number encountered or specified is not one known by the service. It may be a more recent revision than the service is aware of.", "STATUS_UNKNOWN_REVISION", 0xC0000058 },
      {"Indicates two revision levels are incompatible.", "STATUS_REVISION_MISMATCH", 0xC0000059 },
      {"Indicates a particular Security ID may not be assigned as the owner of an object.", "STATUS_INVALID_OWNER", 0xC000005A },
      {"Indicates a particular Security ID may not be assigned as the primary group of an object.", "STATUS_INVALID_PRIMARY_GROUP", 0xC000005B },
      {"An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.", "STATUS_NO_IMPERSONATION_TOKEN", 0xC000005C },
      {"A mandatory group may not be disabled.", "STATUS_CANT_DISABLE_MANDATORY", 0xC000005D },
      {"There are currently no logon servers available to service the logon request.", "STATUS_NO_LOGON_SERVERS", 0xC000005E },
      {"A specified logon session does not exist. It may already have been terminated.", "STATUS_NO_SUCH_LOGON_SESSION", 0xC000005F },
      {"A specified privilege does not exist.", "STATUS_NO_SUCH_PRIVILEGE", 0xC0000060 },
      {"A required privilege is not held by the client.", "STATUS_PRIVILEGE_NOT_HELD", 0xC0000061 },
      {"The name provided is not a properly formed account name.", "STATUS_INVALID_ACCOUNT_NAME", 0xC0000062 },
      {"The specified user already exists.", "STATUS_USER_EXISTS", 0xC0000063 },
      {"The specified user does not exist.", "STATUS_NO_SUCH_USER", 0xC0000064 },
      {"The specified group already exists.", "STATUS_GROUP_EXISTS", 0xC0000065 },
      {"The specified group does not exist.", "STATUS_NO_SUCH_GROUP", 0xC0000066 },
      {"The specified user account is already in the specified group account.Also used to indicate a group cannot be deleted because it contains a member.", "STATUS_MEMBER_IN_GROUP", 0xC0000067 },
      {"The specified user account is not a member of the specified group account.", "STATUS_MEMBER_NOT_IN_GROUP", 0xC0000068 },
      {"Indicates the requested operation would disable or delete the last remaining administration account.This is not allowed to prevent creating a situation in which the system cannot be administrated.", "STATUS_LAST_ADMIN", 0xC0000069 },
      {"When trying to update a password, this return status indicates that the value provided as the current password is not correct.", "STATUS_WRONG_PASSWORD", 0xC000006A },
      {"When trying to update a password, this return status indicates that the value provided for the new password contains values that are not allowed in passwords.", "STATUS_ILL_FORMED_PASSWORD", 0xC000006B },
      {"When trying to update a password, this status indicates that some password update rule has been violated. For example, the password may not meet length criteria.", "STATUS_PASSWORD_RESTRICTION", 0xC000006C },
      {"The attempted logon is invalid. This is either due to a bad username or authentication information.", "STATUS_LOGON_FAILURE", 0xC000006D },
      {"Indicates a referenced user name and authentication information are valid, but some user account restriction has prevented successful authentication (such as time-of-day restrictions).", "STATUS_ACCOUNT_RESTRICTION", 0xC000006E },
      {"The user account has time restrictions and may not be logged onto at this time.", "STATUS_INVALID_LOGON_HOURS", 0xC000006F },
      {"The user account is restricted such that it may not be used to log on from the source workstation.", "STATUS_INVALID_WORKSTATION", 0xC0000070 },
      {"The user account's password has expired.", "STATUS_PASSWORD_EXPIRED", 0xC0000071 },
      {"The referenced account is currently disabled and may not be logged on to.", "STATUS_ACCOUNT_DISABLED", 0xC0000072 },
      {"None of the information to be translated has been translated.", "STATUS_NONE_MAPPED", 0xC0000073 },
      {"The number of LUIDs requested may not be allocated with a single allocation.", "STATUS_TOO_MANY_LUIDS_REQUESTED", 0xC0000074 },
      {"Indicates there are no more LUIDs to allocate.", "STATUS_LUIDS_EXHAUSTED", 0xC0000075 },
      {"Indicates the sub-authority value is invalid for the particular use.", "STATUS_INVALID_SUB_AUTHORITY", 0xC0000076 },
      {"Indicates the ACL structure is not valid.", "STATUS_INVALID_ACL", 0xC0000077 },
      {"Indicates the SID structure is not valid.", "STATUS_INVALID_SID", 0xC0000078 },
      {"Indicates the SECURITY_DESCRIPTOR structure is not valid.", "STATUS_INVALID_SECURITY_DESCR", 0xC0000079 },
      {"Indicates the specified procedure address cannot be found in the DLL.", "STATUS_PROCEDURE_NOT_FOUND", 0xC000007A },
      {"{Bad Image}The application or DLL %hs is not a valid Windows image. Please check this against your installation diskette.", "STATUS_INVALID_IMAGE_FORMAT", 0xC000007B },
      {"An attempt was made to reference a token that doesn't exist.This is typically done by referencing the token associated with a thread when the thread is not impersonating a client.", "STATUS_NO_TOKEN", 0xC000007C },
      {"Indicates that an attempt to build either an inherited ACL or ACE was not successful.This can be caused by a number of things. One of the more probable causes is the replacement of a CreatorId with an SID that didn't fit into the ACE or ACL.", "STATUS_BAD_INHERITANCE_ACL", 0xC000007D },
      {"The range specified in NtUnlockFile was not locked.", "STATUS_RANGE_NOT_LOCKED", 0xC000007E },
      {"An operation failed because the disk was full.", "STATUS_DISK_FULL", 0xC000007F },
      {"The GUID allocation server is [already] disabled at the moment.", "STATUS_SERVER_DISABLED", 0xC0000080 },
      {"The GUID allocation server is [already] enabled at the moment.", "STATUS_SERVER_NOT_DISABLED", 0xC0000081 },
      {"Too many GUIDs were requested from the allocation server at once.", "STATUS_TOO_MANY_GUIDS_REQUESTED", 0xC0000082 },
      {"The GUIDs could not be allocated because the Authority Agent was exhausted.", "STATUS_GUIDS_EXHAUSTED", 0xC0000083 },
      {"The value provided was an invalid value for an identifier authority.", "STATUS_INVALID_ID_AUTHORITY", 0xC0000084 },
      {"There are no more authority agent values available for the given identifier authority value.", "STATUS_AGENTS_EXHAUSTED", 0xC0000085 },
      {"An invalid volume label has been specified.", "STATUS_INVALID_VOLUME_LABEL", 0xC0000086 },
      {"A mapped section could not be extended.", "STATUS_SECTION_NOT_EXTENDED", 0xC0000087 },
      {"Specified section to flush does not map a data file.", "STATUS_NOT_MAPPED_DATA", 0xC0000088 },
      {"Indicates the specified image file did not contain a resource section.", "STATUS_RESOURCE_DATA_NOT_FOUND", 0xC0000089 },
      {"Indicates the specified resource type cannot be found in the image file.", "STATUS_RESOURCE_TYPE_NOT_FOUND", 0xC000008A },
      {"Indicates the specified resource name cannot be found in the image file.", "STATUS_RESOURCE_NAME_NOT_FOUND", 0xC000008B },
      {"{EXCEPTION}Array bounds exceeded.", "STATUS_ARRAY_BOUNDS_EXCEEDED", 0xC000008C },
      {"{EXCEPTION}Floating-point denormal operand.", "STATUS_FLOAT_DENORMAL_OPERAND", 0xC000008D },
      {"{EXCEPTION}Floating-point division by zero.", "STATUS_FLOAT_DIVIDE_BY_ZERO", 0xC000008E },
      {"{EXCEPTION}Floating-point inexact result.", "STATUS_FLOAT_INEXACT_RESULT", 0xC000008F },
      {"{EXCEPTION}Floating-point invalid operation.", "STATUS_FLOAT_INVALID_OPERATION", 0xC0000090 },
      {"{EXCEPTION}Floating-point overflow.", "STATUS_FLOAT_OVERFLOW", 0xC0000091 },
      {"{EXCEPTION}Floating-point stack check.", "STATUS_FLOAT_STACK_CHECK", 0xC0000092 },
      {"{EXCEPTION}Floating-point underflow.", "STATUS_FLOAT_UNDERFLOW", 0xC0000093 },
      {"{EXCEPTION}Integer division by zero.", "STATUS_INTEGER_DIVIDE_BY_ZERO", 0xC0000094 },
      {"{EXCEPTION}Integer overflow.", "STATUS_INTEGER_OVERFLOW", 0xC0000095 },
      {"{EXCEPTION}Privileged instruction.", "STATUS_PRIVILEGED_INSTRUCTION", 0xC0000096 },
      {"An attempt was made to install more paging files than the system supports.", "STATUS_TOO_MANY_PAGING_FILES", 0xC0000097 },
      {"The volume for a file has been externally altered such that the opened file is no longer valid.", "STATUS_FILE_INVALID", 0xC0000098 },
      {"When a block of memory is allotted for future updates, such as the memory allocated to hold discretionary access control and primary group information, successive updates may exceed the amount of memory originally allotted.Since quota may already have been charged to several processes which have handles to the object, it is not reasonable to alter the size of the allocated memory.Instead, a request that requires more memory than has been allotted must fail and the STATUS_ALLOTED_SPACE_EXCEEDED error returned.", "STATUS_ALLOTTED_SPACE_EXCEEDED", 0xC0000099 },
      {"Insufficient system resources exist to complete the API.", "STATUS_INSUFFICIENT_RESOURCES", 0xC000009A },
      {"An attempt has been made to open a DFS exit path control file.", "STATUS_DFS_EXIT_PATH_FOUND", 0xC000009B },
      {"STATUS_DEVICE_DATA_ERROR", "STATUS_DEVICE_DATA_ERROR", 0xC000009C },
      {"STATUS_DEVICE_NOT_CONNECTED", "STATUS_DEVICE_NOT_CONNECTED", 0xC000009D },
      {"STATUS_DEVICE_POWER_FAILURE", "STATUS_DEVICE_POWER_FAILURE", 0xC000009E },
      {"Virtual memory cannot be freed as base address is not the base of the region and a region size of zero was specified.", "STATUS_FREE_VM_NOT_AT_BASE", 0xC000009F },
      {"An attempt was made to free virtual memory which is not allocated.", "STATUS_MEMORY_NOT_ALLOCATED", 0xC00000A0 },
      {"The working set is not big enough to allow the requested pages to be locked.", "STATUS_WORKING_SET_QUOTA", 0xC00000A1 },
      {"{Write Protect Error}The disk cannot be written to because it is write protected.Please remove the write protection from the volume %hs in drive %hs.", "STATUS_MEDIA_WRITE_PROTECTED", 0xC00000A2 },
      {"{Drive Not Ready}The drive is not ready for use; its door may be open.Please check drive %hs and make sure that a disk is inserted and that the drive door is closed.", "STATUS_DEVICE_NOT_READY", 0xC00000A3 },
      {"The specified attributes are invalid, or incompatible with the attributes for the group as a whole.", "STATUS_INVALID_GROUP_ATTRIBUTES", 0xC00000A4 },
      {"A specified impersonation level is invalid.Also used to indicate a required impersonation level was not provided.", "STATUS_BAD_IMPERSONATION_LEVEL", 0xC00000A5 },
      {"An attempt was made to open an Anonymous level token.Anonymous tokens may not be opened.", "STATUS_CANT_OPEN_ANONYMOUS", 0xC00000A6 },
      {"The validation information class requested was invalid.", "STATUS_BAD_VALIDATION_CLASS", 0xC00000A7 },
      {"The type of a token object is inappropriate for its attempted use.", "STATUS_BAD_TOKEN_TYPE", 0xC00000A8 },
      {"The type of a token object is inappropriate for its attempted use.", "STATUS_BAD_MASTER_BOOT_RECORD", 0xC00000A9 },
      {"An attempt was made to execute an instruction at an unaligned address and the host system does not support unaligned instruction references.", "STATUS_INSTRUCTION_MISALIGNMENT", 0xC00000AA },
      {"The maximum named pipe instance count has been reached.", "STATUS_INSTANCE_NOT_AVAILABLE", 0xC00000AB },
      {"An instance of a named pipe cannot be found in the listening state.", "STATUS_PIPE_NOT_AVAILABLE", 0xC00000AC },
      {"The named pipe is not in the connected or closing state.", "STATUS_INVALID_PIPE_STATE", 0xC00000AD },
      {"The specified pipe is set to complete operations and there are current I/O operations queued so it cannot be changed to queue operations.", "STATUS_PIPE_BUSY", 0xC00000AE },
      {"The specified handle is not open to the server end of the named pipe.", "STATUS_ILLEGAL_FUNCTION", 0xC00000AF },
      {"The specified named pipe is in the disconnected state.", "STATUS_PIPE_DISCONNECTED", 0xC00000B0 },
      {"The specified named pipe is in the closing state.", "STATUS_PIPE_CLOSING", 0xC00000B1 },
      {"The specified named pipe is in the connected state.", "STATUS_PIPE_CONNECTED", 0xC00000B2 },
      {"The specified named pipe is in the listening state.", "STATUS_PIPE_LISTENING", 0xC00000B3 },
      {"The specified named pipe is not in message mode.", "STATUS_INVALID_READ_MODE", 0xC00000B4 },
      {"{Device Timeout}The specified I/O operation on %hs was not completed before the time-out period expired.", "STATUS_IO_TIMEOUT", 0xC00000B5 },
      {"The specified file has been closed by another process.", "STATUS_FILE_FORCED_CLOSED", 0xC00000B6 },
      {"Profiling not started.", "STATUS_PROFILING_NOT_STARTED", 0xC00000B7 },
      {"Profiling not stopped.", "STATUS_PROFILING_NOT_STOPPED", 0xC00000B8 },
      {"The passed ACL did not contain the minimum required information.", "STATUS_COULD_NOT_INTERPRET", 0xC00000B9 },
      {"The file that was specified as a target is a directory and the caller specified that it could be anything but a directory.", "STATUS_FILE_IS_A_DIRECTORY", 0xC00000BA },
      {"The request is not supported.", "STATUS_NOT_SUPPORTED", 0xC00000BB },
      {"This remote computer is not listening.", "STATUS_REMOTE_NOT_LISTENING", 0xC00000BC },
      {"A duplicate name exists on the network.", "STATUS_DUPLICATE_NAME", 0xC00000BD },
      {"The network path cannot be located.", "STATUS_BAD_NETWORK_PATH", 0xC00000BE },
      {"The network is busy.", "STATUS_NETWORK_BUSY", 0xC00000BF },
      {"This device does not exist.", "STATUS_DEVICE_DOES_NOT_EXIST", 0xC00000C0 },
      {"The network BIOS command limit has been reached.", "STATUS_TOO_MANY_COMMANDS", 0xC00000C1 },
      {"An I/O adapter hardware error has occurred.", "STATUS_ADAPTER_HARDWARE_ERROR", 0xC00000C2 },
      {"The network responded incorrectly.", "STATUS_INVALID_NETWORK_RESPONSE", 0xC00000C3 },
      {"An unexpected network error occurred.", "STATUS_UNEXPECTED_NETWORK_ERROR", 0xC00000C4 },
      {"The remote adapter is not compatible.", "STATUS_BAD_REMOTE_ADAPTER", 0xC00000C5 },
      {"The printer queue is full.", "STATUS_PRINT_QUEUE_FULL", 0xC00000C6 },
      {"Space to store the file waiting to be printed is not available on the server.", "STATUS_NO_SPOOL_SPACE", 0xC00000C7 },
      {"The requested print file has been canceled.", "STATUS_PRINT_CANCELLED", 0xC00000C8 },
      {"The network name was deleted.", "STATUS_NETWORK_NAME_DELETED", 0xC00000C9 },
      {"Network access is denied.", "STATUS_NETWORK_ACCESS_DENIED", 0xC00000CA },
      {"{Incorrect Network Resource Type}The specified device type (LPT, for example) conflicts with the actual device type on the remote resource.", "STATUS_BAD_DEVICE_TYPE", 0xC00000CB },
      {"{Network Name Not Found}The specified share name cannot be found on the remote server.", "STATUS_BAD_NETWORK_NAME", 0xC00000CC },
      {"The name limit for the local computer network adapter card was exceeded.", "STATUS_TOO_MANY_NAMES", 0xC00000CD },
      {"The network BIOS session limit was exceeded.", "STATUS_TOO_MANY_SESSIONS", 0xC00000CE },
      {"File sharing has been temporarily paused.", "STATUS_SHARING_PAUSED", 0xC00000CF },
      {"No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.", "STATUS_REQUEST_NOT_ACCEPTED", 0xC00000D0 },
      {"Print or disk redirection is temporarily paused.", "STATUS_REDIRECTOR_PAUSED", 0xC00000D1 },
      {"A network data fault occurred.", "STATUS_NET_WRITE_FAULT", 0xC00000D2 },
      {"The number of active profiling objects is at the maximum and no more may be started.", "STATUS_PROFILING_AT_LIMIT", 0xC00000D3 },
      {"{Incorrect Volume}The target file of a rename request is located on a different device than the source of the rename request.", "STATUS_NOT_SAME_DEVICE", 0xC00000D4 },
      {"The file specified has been renamed and thus cannot be modified.", "STATUS_FILE_RENAMED", 0xC00000D5 },
      {"{Network Request Timeout}The session with a remote server has been disconnected because the time-out interval for a request has expired.", "STATUS_VIRTUAL_CIRCUIT_CLOSED", 0xC00000D6 },
      {"Indicates an attempt was made to operate on the security of an object that does not have security associated with it.", "STATUS_NO_SECURITY_ON_OBJECT", 0xC00000D7 },
      {"Used to indicate that an operation cannot continue without blocking for I/O.", "STATUS_CANT_WAIT", 0xC00000D8 },
      {"Used to indicate that a read operation was done on an empty pipe.", "STATUS_PIPE_EMPTY", 0xC00000D9 },
      {"Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.", "STATUS_CANT_ACCESS_DOMAIN_INFO", 0xC00000DA },
      {"Indicates that a thread attempted to terminate itself by default (called NtTerminateThread with NULL},", "STATUS_CANT_TERMINATE_SELF", 0xC00000DB },
      {"Indicates the Sam Server was in the wrong state to perform the desired operation.", "STATUS_INVALID_SERVER_STATE", 0xC00000DC },
      {"Indicates the Domain was in the wrong state to perform the desired operation.", "STATUS_INVALID_DOMAIN_STATE", 0xC00000DD },
      {"This operation is only allowed for the Primary Domain Controller of the domain.", "STATUS_INVALID_DOMAIN_ROLE", 0xC00000DE },
      {"The specified Domain did not exist.", "STATUS_NO_SUCH_DOMAIN", 0xC00000DF },
      {"The specified Domain already exists.", "STATUS_DOMAIN_EXISTS", 0xC00000E0 },
      {"An attempt was made to exceed the limit on the number of domains per server for this release.", "STATUS_DOMAIN_LIMIT_EXCEEDED", 0xC00000E1 },
      {"Error status returned when oplock request is denied.", "STATUS_OPLOCK_NOT_GRANTED", 0xC00000E2 },
      {"Error status returned when an invalid oplock acknowledgment is received by a file system.", "STATUS_INVALID_OPLOCK_PROTOCOL", 0xC00000E3 },
      {"This error indicates that the requested operation cannot be completed due to a catastrophic media failure or on-disk data structure corruption.", "STATUS_INTERNAL_DB_CORRUPTION", 0xC00000E4 },
      {"An internal error occurred.", "STATUS_INTERNAL_ERROR", 0xC00000E5 },
      {"Indicates generic access types were contained in an access mask which should already be mapped to non-generic access types.", "STATUS_GENERIC_NOT_MAPPED", 0xC00000E6 },
      {"Indicates a security descriptor is not in the necessary format (absolute or self-relative).", "STATUS_BAD_DESCRIPTOR_FORMAT", 0xC00000E7 },
      {"An access to a user buffer failed at an \"expected\" point in time.This code is defined since the caller does not want to accept STATUS_ACCESS_VIOLATION in its filter.", "STATUS_INVALID_USER_BUFFER", 0xC00000E8 },
      {"If an I/O error is returned which is not defined in the standard FsRtl filter, it is converted to the following error which is guaranteed to be in the filter.In this case information is lost, however, the filter correctly handles the exception.", "STATUS_UNEXPECTED_IO_ERROR", 0xC00000E9 },
      {"If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.In this case information is lost, however, the filter correctly handles the exception.", "STATUS_UNEXPECTED_MM_CREATE_ERR", 0xC00000EA },
      {"If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.In this case information is lost, however, the filter correctly handles the exception.", "STATUS_UNEXPECTED_MM_MAP_ERROR", 0xC00000EB },
      {"If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.In this case information is lost, however, the filter correctly handles the exception.", "STATUS_UNEXPECTED_MM_EXTEND_ERR", 0xC00000EC },
      {"The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.", "STATUS_NOT_LOGON_PROCESS", 0xC00000ED },
      {"An attempt has been made to start a new session manager or LSA logon session with an ID that is already in use.", "STATUS_LOGON_SESSION_EXISTS", 0xC00000EE },
      {"An invalid parameter was passed to a service or function as the first argument.", "STATUS_INVALID_PARAMETER_1", 0xC00000EF },
      {"An invalid parameter was passed to a service or function as the second argument.", "STATUS_INVALID_PARAMETER_2", 0xC00000F0 },
      {"An invalid parameter was passed to a service or function as the third argument.", "STATUS_INVALID_PARAMETER_3", 0xC00000F1 },
      {"An invalid parameter was passed to a service or function as the fourth argument.", "STATUS_INVALID_PARAMETER_4", 0xC00000F2 },
      {"An invalid parameter was passed to a service or function as the fifth argument.", "STATUS_INVALID_PARAMETER_5", 0xC00000F3 },
      {"An invalid parameter was passed to a service or function as the sixth argument.", "STATUS_INVALID_PARAMETER_6", 0xC00000F4 },
      {"An invalid parameter was passed to a service or function as the seventh argument.", "STATUS_INVALID_PARAMETER_7", 0xC00000F5 },
      {"An invalid parameter was passed to a service or function as the eighth argument.", "STATUS_INVALID_PARAMETER_8", 0xC00000F6 },
      {"An invalid parameter was passed to a service or function as the ninth argument.", "STATUS_INVALID_PARAMETER_9", 0xC00000F7 },
      {"An invalid parameter was passed to a service or function as the tenth argument.", "STATUS_INVALID_PARAMETER_10", 0xC00000F8 },
      {"An invalid parameter was passed to a service or function as the eleventh argument.", "STATUS_INVALID_PARAMETER_11", 0xC00000F9 },
      {"An invalid parameter was passed to a service or function as the twelfth argument.", "STATUS_INVALID_PARAMETER_12", 0xC00000FA },
      {"An attempt was made to access a network file, but the network software was not yet started.", "STATUS_REDIRECTOR_NOT_STARTED", 0xC00000FB },
      {"An attempt was made to start the redirector, but the redirector has already been started.", "STATUS_REDIRECTOR_STARTED", 0xC00000FC },
      {"A new guard page for the stack cannot be created.", "STATUS_STACK_OVERFLOW", 0xC00000FD },
      {"A specified authentication package is unknown.", "STATUS_NO_SUCH_PACKAGE", 0xC00000FE },
      {"A malformed function table was encountered during an unwind operation.", "STATUS_BAD_FUNCTION_TABLE", 0xC00000FF },
      {"Indicates the specified environment variable name was not found in the specified environment block.", "STATUS_VARIABLE_NOT_FOUND", 0xC0000100 },
      {"Indicates that the directory trying to be deleted is not empty.", "STATUS_DIRECTORY_NOT_EMPTY", 0xC0000101 },
      {"{Corrupt File}The file or directory %hs is corrupt and unreadable.Please run the Chkdsk utility.", "STATUS_FILE_CORRUPT_ERROR", 0xC0000102 },
      {"A requested opened file is not a directory.", "STATUS_NOT_A_DIRECTORY", 0xC0000103 },
      {"The logon session is not in a state that is consistent with the requested operation.", "STATUS_BAD_LOGON_SESSION_STATE", 0xC0000104 },
      {"An internal LSA error has occurred. An authentication package has requested the creation of a Logon Session but the ID of an already existing Logon Session has been specified.", "STATUS_LOGON_SESSION_COLLISION", 0xC0000105 },
      {"A specified name string is too long for its intended use.", "STATUS_NAME_TOO_LONG", 0xC0000106 },
      {"The user attempted to force close the files on a redirected drive, but there were opened files on the drive, and the user did not specify a sufficient level of force.", "STATUS_FILES_OPEN", 0xC0000107 },
      {"The user attempted to force close the files on a redirected drive, but there were opened directories on the drive, and the user did not specify a sufficient level of force.", "STATUS_CONNECTION_IN_USE", 0xC0000108 },
      {"RtlFindMessage could not locate the requested message ID in the message table resource.", "STATUS_MESSAGE_NOT_FOUND", 0xC0000109 },
      {"An attempt was made to duplicate an object handle into or out of an exiting process.", "STATUS_PROCESS_IS_TERMINATING", 0xC000010A },
      {"Indicates an invalid value has been provided for the LogonType requested.", "STATUS_INVALID_LOGON_TYPE", 0xC000010B },
      {"Indicates that an attempt was made to assign protection to a file system file or directory and one of the SIDs in the security descriptor could not be translated into a GUID that could be stored by the file system.This causes the protection attempt to fail, which may cause a file creation attempt to fail.", "STATUS_NO_GUID_TRANSLATION", 0xC000010C },
      {"Indicates that an attempt has been made to impersonate via a named pipe that has not yet been read from.", "STATUS_CANNOT_IMPERSONATE", 0xC000010D },
      {"Indicates that the specified image is already loaded.", "STATUS_IMAGE_ALREADY_LOADED", 0xC000010E },
      {"STATUS_ABIOS_NOT_PRESENT", "STATUS_ABIOS_NOT_PRESENT", 0xC000010F },
      {"STATUS_ABIOS_LID_NOT_EXIST", "STATUS_ABIOS_LID_NOT_EXIST", 0xC0000110 },
      {"STATUS_ABIOS_LID_ALREADY_OWNED", "STATUS_ABIOS_LID_ALREADY_OWNED", 0xC0000111 },
      {"STATUS_ABIOS_NOT_LID_OWNER", "STATUS_ABIOS_NOT_LID_OWNER", 0xC0000112 },
      {"STATUS_ABIOS_INVALID_COMMAND", "STATUS_ABIOS_INVALID_COMMAND", 0xC0000113 },
      {"STATUS_ABIOS_INVALID_LID", "STATUS_ABIOS_INVALID_LID", 0xC0000114 },
      {"STATUS_ABIOS_SELECTOR_NOT_AVAILABLE", "STATUS_ABIOS_SELECTOR_NOT_AVAILABLE", 0xC0000115 },
      {"STATUS_ABIOS_INVALID_SELECTOR", "STATUS_ABIOS_INVALID_SELECTOR", 0xC0000116 },
      {"Indicates that an attempt was made to change the size of the LDT for a process that has no LDT.", "STATUS_NO_LDT", 0xC0000117 },
      {"Indicates that an attempt was made to grow an LDT by setting its size, or that the size was not an even number of selectors.", "STATUS_INVALID_LDT_SIZE", 0xC0000118 },
      {"Indicates that the starting value for the LDT information was not an integral multiple of the selector size.", "STATUS_INVALID_LDT_OFFSET", 0xC0000119 },
      {"Indicates that the user supplied an invalid descriptor when trying to set up Ldt descriptors.", "STATUS_INVALID_LDT_DESCRIPTOR", 0xC000011A },
      {"The specified image file did not have the correct format. It appears to be NE format.", "STATUS_INVALID_IMAGE_NE_FORMAT", 0xC000011B },
      {"Indicates that the transaction state of a registry sub-tree is incompatible with the requested operation.For example, a request has been made to start a new transaction with one already in progress,or a request has been made to apply a transaction when one is not currently in progress.", "STATUS_RXACT_INVALID_STATE", 0xC000011C },
      {"Indicates an error has occurred during a registry transaction commit.The database has been left in an unknown, but probably inconsistent, state.The state of the registry transaction is left as COMMITTING.", "STATUS_RXACT_COMMIT_FAILURE", 0xC000011D },
      {"An attempt was made to map a file of size zero with the maximum size specified as zero.", "STATUS_MAPPED_FILE_SIZE_ZERO", 0xC000011E },
      {"Too many files are opened on a remote server.This error should only be returned by the Windows redirector on a remote drive.", "STATUS_TOO_MANY_OPENED_FILES", 0xC000011F },
      {"The I/O request was canceled.", "STATUS_CANCELLED", 0xC0000120 },
      {"An attempt has been made to remove a file or directory that cannot be deleted.", "STATUS_CANNOT_DELETE", 0xC0000121 },
      {"Indicates a name specified as a remote computer name is syntactically invalid.", "STATUS_INVALID_COMPUTER_NAME", 0xC0000122 },
      {"An I/O request other than close was performed on a file after it has been deleted,which can only happen to a request which did not complete before the last handle was closed via NtClose.", "STATUS_FILE_DELETED", 0xC0000123 },
      {"Indicates an operation has been attempted on a built-in (speciaL},For example, built-in accounts cannot be deleted.", "STATUS_SPECIAL_ACCOUNT", 0xC0000124 },
      {"The operation requested may not be performed on the specified group because it is a built-in special group.", "STATUS_SPECIAL_GROUP", 0xC0000125 },
      {"The operation requested may not be performed on the specified user because it is a built-in special user.", "STATUS_SPECIAL_USER", 0xC0000126 },
      {"Indicates a member cannot be removed from a group because the group is currently the member's primary group.", "STATUS_MEMBERS_PRIMARY_GROUP", 0xC0000127 },
      {"An I/O request other than close and several other special case operations was attempted using a file object that had already been closed.", "STATUS_FILE_CLOSED", 0xC0000128 },
      {"Indicates a process has too many threads to perform the requested action. For example, assignment of a primary token may only be performed when a process has zero or one threads.", "STATUS_TOO_MANY_THREADS", 0xC0000129 },
      {"An attempt was made to operate on a thread within a specific process, but the thread specified is not in the process specified.", "STATUS_THREAD_NOT_IN_PROCESS", 0xC000012A },
      {"An attempt was made to establish a token for use as a primary token but the token is already in use. A token can only be the primary token of one process at a time.", "STATUS_TOKEN_ALREADY_IN_USE", 0xC000012B },
      {"Page file quota was exceeded.", "STATUS_PAGEFILE_QUOTA_EXCEEDED", 0xC000012C },
      {"{Out of Virtual Memory}Your system is low on virtual memory. To ensure that Windows runs properly, increase the size of your virtual memory paging file. For more information, see Help.", "STATUS_COMMITMENT_LIMIT", 0xC000012D },
      {"The specified image file did not have the correct format, it appears to be LE format.", "STATUS_INVALID_IMAGE_LE_FORMAT", 0xC000012E },
      {"The specified image file did not have the correct format, it did not have an initial MZ.", "STATUS_INVALID_IMAGE_NOT_MZ", 0xC000012F },
      {"The specified image file did not have the correct format, it did not have a proper e_lfarlc in the MZ header.", "STATUS_INVALID_IMAGE_PROTECT", 0xC0000130 },
      {"The specified image file did not have the correct format, it appears to be a 16-bit Windows image.", "STATUS_INVALID_IMAGE_WIN_16", 0xC0000131 },
      {"The Netlogon service cannot start because another Netlogon service running in the domain conflicts with the specified role.", "STATUS_LOGON_SERVER_CONFLICT", 0xC0000132 },
      {"The time at the Primary Domain Controller is different than the time at the Backup Domain Controller or member server by too large an amount.", "STATUS_TIME_DIFFERENCE_AT_DC", 0xC0000133 },
      {"The SAM database on a Windows Server is significantly out of synchronization with the copy on the Domain Controller. A complete synchronization is required.", "STATUS_SYNCHRONIZATION_REQUIRED", 0xC0000134 },
      {"{Unable To Locate Component}This application has failed to start because %hs was not found. Re-installing the application may fix this problem.", "STATUS_DLL_NOT_FOUND", 0xC0000135 },
      {"The NtCreateFile API failed. This error should never be returned to an application, it is a place holder for the Windows Lan Manager Redirector to use in its internal error mapping routines.", "STATUS_OPEN_FAILED", 0xC0000136 },
      {"{Privilege Failed}The I/O permissions for the process could not be changed.", "STATUS_IO_PRIVILEGE_FAILED", 0xC0000137 },
      {"{Ordinal Not Found}The ordinal %ld could not be located in the dynamic link library %hs.", "STATUS_ORDINAL_NOT_FOUND", 0xC0000138 },
      {"{Entry Point Not Found}The procedure entry point %hs could not be located in the dynamic link library %hs.", "STATUS_ENTRYPOINT_NOT_FOUND", 0xC0000139 },
      {"{Application Exit by CTRL+C}The application terminated as a result of a CTRL+C.", "STATUS_CONTROL_C_EXIT", 0xC000013A },
      {"{Virtual Circuit Closed}The network transport on your computer has closed a network connection. There may or may not be I/O requests outstanding.", "STATUS_LOCAL_DISCONNECT", 0xC000013B },
      {"{Virtual Circuit Closed}The network transport on a remote computer has closed a network connection. There may or may not be I/O requests outstanding.", "STATUS_REMOTE_DISCONNECT", 0xC000013C },
      {"{Insufficient Resources on Remote Computer}The remote computer has insufficient resources to complete the network request. For instance, there may not be enough memory available on the remote computer to carry out the request at this time.", "STATUS_REMOTE_RESOURCES", 0xC000013D },
      {"{Virtual Circuit Closed}An existing connection (virtual circuit) has been broken at the remote computer. There is probably something wrong with the network software protocol or the network hardware on the remote computer.", "STATUS_LINK_FAILED", 0xC000013E },
      {"{Virtual Circuit Closed}The network transport on your computer has closed a network connection because it had to wait too long for a response from the remote computer.", "STATUS_LINK_TIMEOUT", 0xC000013F },
      {"The connection handle given to the transport was invalid.", "STATUS_INVALID_CONNECTION", 0xC0000140 },
      {"The address handle given to the transport was invalid.", "STATUS_INVALID_ADDRESS", 0xC0000141 },
      {"{DLL Initialization Failed}Initialization of the dynamic link library %hs failed. The process is terminating abnormally.", "STATUS_DLL_INIT_FAILED", 0xC0000142 },
      {"{Missing System File}The required system file %hs is bad or missing.", "STATUS_MISSING_SYSTEMFILE", 0xC0000143 },
      {"{Application Error}The exception %s (0x%08lx) occurred in the application at location 0x%08lx.", "STATUS_UNHANDLED_EXCEPTION", 0xC0000144 },
      {"{Application Error}The application failed to initialize properly (0x%lx). Click on OK to terminate the application.", "STATUS_APP_INIT_FAILURE", 0xC0000145 },
      {"{Unable to Create Paging File}The creation of the paging file %hs failed (%lx). The requested size was %ld.", "STATUS_PAGEFILE_CREATE_FAILED", 0xC0000146 },
      {"{No Paging File Specified}No paging file was specified in the system configuration.", "STATUS_NO_PAGEFILE", 0xC0000147 },
      {"{Incorrect System Call Level}An invalid level was passed into the specified system call.", "STATUS_INVALID_LEVEL", 0xC0000148 },
      {"{Incorrect Password to LAN Manager Server}You specified an incorrect password to a LAN Manager 2.x or MS-NET server.", "STATUS_WRONG_PASSWORD_CORE", 0xC0000149 },
      {"{EXCEPTION}A real-mode application issued a floating-point instruction and floating-point hardware is not present.", "STATUS_ILLEGAL_FLOAT_CONTEXT", 0xC000014A },
      {"The pipe operation has failed because the other end of the pipe has been closed.", "STATUS_PIPE_BROKEN", 0xC000014B },
      {"{The Registry Is Corrupt}The structure of one of the files that contains Registry data is corrupt, or the image of the file in memory is corrupt, or the file could not be recovered because the alternate copy or log was absent or corrupt.", "STATUS_REGISTRY_CORRUPT", 0xC000014C },
      {"An I/O operation initiated by the Registry failed unrecoverably.The Registry could not read in, or write out, or flush, one of the files that contain the system's image of the Registry.", "STATUS_REGISTRY_IO_FAILED", 0xC000014D },
      {"An event pair synchronization operation was performed using the thread specific client/server event pair object, but no event pair object was associated with the thread.", "STATUS_NO_EVENT_PAIR", 0xC000014E },
      {"The volume does not contain a recognized file system.Please make sure that all required file system drivers are loaded and that the volume is not corrupt.", "STATUS_UNRECOGNIZED_VOLUME", 0xC000014F },
      {"No serial device was successfully initialized. The serial driver will unload.", "STATUS_SERIAL_NO_DEVICE_INITED", 0xC0000150 },
      {"The specified local group does not exist.", "STATUS_NO_SUCH_ALIAS", 0xC0000151 },
      {"The specified account name is not a member of the local group.", "STATUS_MEMBER_NOT_IN_ALIAS", 0xC0000152 },
      {"The specified account name is already a member of the local group.", "STATUS_MEMBER_IN_ALIAS", 0xC0000153 },
      {"The specified local group already exists.", "STATUS_ALIAS_EXISTS", 0xC0000154 },
      {"A requested type of logon (e.g., Interactive, Network, Service) is not granted by the target system's local security policy.Please ask the system administrator to grant the necessary form of logon.", "STATUS_LOGON_NOT_GRANTED", 0xC0000155 },
      {"The maximum number of secrets that may be stored in a single system has been exceeded. The length and number of secrets is limited to satisfy United States State Department export restrictions.", "STATUS_TOO_MANY_SECRETS", 0xC0000156 },
      {"The length of a secret exceeds the maximum length allowed. The length and number of secrets is limited to satisfy United States State Department export restrictions.", "STATUS_SECRET_TOO_LONG", 0xC0000157 },
      {"The Local Security Authority (LSA) database contains an internal inconsistency.", "STATUS_INTERNAL_DB_ERROR", 0xC0000158 },
      {"The requested operation cannot be performed in fullscreen mode.", "STATUS_FULLSCREEN_MODE", 0xC0000159 },
      {"During a logon attempt, the user's security context accumulated too many security IDs. This is a very unusual situation.Remove the user from some global or local groups to reduce the number of security ids to incorporate into the security context.", "STATUS_TOO_MANY_CONTEXT_IDS", 0xC000015A },
      {"A user has requested a type of logon (e.g., interactive or network) that has not been granted. An administrator has control over who may logon interactively and through the network.", "STATUS_LOGON_TYPE_NOT_GRANTED", 0xC000015B },
      {"The system has attempted to load or restore a file into the registry, and the specified file is not in the format of a registry file.", "STATUS_NOT_REGISTRY_FILE", 0xC000015C },
      {"An attempt was made to change a user password in the security account manager without providing the necessary Windows cross-encrypted password.", "STATUS_NT_CROSS_ENCRYPTION_REQUIRED", 0xC000015D },
      {"A Windows Server has an incorrect configuration.", "STATUS_DOMAIN_CTRLR_CONFIG_ERROR", 0xC000015E },
      {"An attempt was made to explicitly access the secondary copy of information via a device control to the Fault Tolerance driver and the secondary copy is not present in the system.", "STATUS_FT_MISSING_MEMBER", 0xC000015F },
      {"A configuration registry node representing a driver service entry was ill-formed and did not contain required value entries.", "STATUS_ILL_FORMED_SERVICE_ENTRY", 0xC0000160 },
      {"An illegal character was encountered. For a multi-byte character set this includes a lead byte without a succeeding trail byte. For the Unicode character set this includes the characters 0xFFFF and 0xFFFE.", "STATUS_ILLEGAL_CHARACTER", 0xC0000161 },
      {"No mapping for the Unicode character exists in the target multi-byte code page.", "STATUS_UNMAPPABLE_CHARACTER", 0xC0000162 },
      {"The Unicode character is not defined in the Unicode character set installed on the system.", "STATUS_UNDEFINED_CHARACTER", 0xC0000163 },
      {"The paging file cannot be created on a floppy diskette.", "STATUS_FLOPPY_VOLUME", 0xC0000164 },
      {"{Floppy Disk Error}While accessing a floppy disk, an ID address mark was not found.", "STATUS_FLOPPY_ID_MARK_NOT_FOUND", 0xC0000165 },
      {"{Floppy Disk Error}While accessing a floppy disk, the track address from the sector ID field was found to be different than the track address maintained by the controller.", "STATUS_FLOPPY_WRONG_CYLINDER", 0xC0000166 },
      {"{Floppy Disk Error}The floppy disk controller reported an error that is not recognized by the floppy disk driver.", "STATUS_FLOPPY_UNKNOWN_ERROR", 0xC0000167 },
      {"{Floppy Disk Error}While accessing a floppy-disk, the controller returned inconsistent results via its registers.", "STATUS_FLOPPY_BAD_REGISTERS", 0xC0000168 },
      {"{Hard Disk Error}While accessing the hard disk, a recalibrate operation failed, even after retries.", "STATUS_DISK_RECALIBRATE_FAILED", 0xC0000169 },
      {"{Hard Disk Error}While accessing the hard disk, a disk operation failed even after retries.", "STATUS_DISK_OPERATION_FAILED", 0xC000016A },
      {"{Hard Disk Error}While accessing the hard disk, a disk controller reset was needed, but even that failed.", "STATUS_DISK_RESET_FAILED", 0xC000016B },
      {"An attempt was made to open a device that was sharing an IRQ with other devices.At least one other device that uses that IRQ was already opened.Two concurrent opens of devices that share an IRQ and only work via interrupts is not supported for the particular bus type that the devices use.", "STATUS_SHARED_IRQ_BUSY", 0xC000016C },
      {"{FT Orphaning}A disk that is part of a fault-tolerant volume can no longer be accessed.", "STATUS_FT_ORPHANING", 0xC000016D },
      {"The system bios failed to connect a system interrupt to the device or bus forwhich the device is connected.", "STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT", 0xC000016E },
      {"Tape could not be partitioned.", "STATUS_PARTITION_FAILURE", 0xC0000172 },
      {"When accessing a new tape of a multivolume partition, the current blocksize is incorrect.", "STATUS_INVALID_BLOCK_LENGTH", 0xC0000173 },
      {"Tape partition information could not be found when loading a tape.", "STATUS_DEVICE_NOT_PARTITIONED", 0xC0000174 },
      {"Attempt to lock the eject media mechanism fails.", "STATUS_UNABLE_TO_LOCK_MEDIA", 0xC0000175 },
      {"Unload media fails.", "STATUS_UNABLE_TO_UNLOAD_MEDIA", 0xC0000176 },
      {"Physical end of tape was detected.", "STATUS_EOM_OVERFLOW", 0xC0000177 },
      {"{No Media}There is no media in the drive.Please insert media into drive %hs.", "STATUS_NO_MEDIA", 0xC0000178 },
      {"A member could not be added to or removed from the local group because the member does not exist.", "STATUS_NO_SUCH_MEMBER", 0xC000017A },
      {"A new member could not be added to a local group because the member has the wrong account type.", "STATUS_INVALID_MEMBER", 0xC000017B },
      {"Illegal operation attempted on a registry key which has been marked for deletion.", "STATUS_KEY_DELETED", 0xC000017C },
      {"System could not allocate required space in a registry log.", "STATUS_NO_LOG_SPACE", 0xC000017D },
      {"Too many Sids have been specified.", "STATUS_TOO_MANY_SIDS", 0xC000017E },
      {"An attempt was made to change a user password in the security account manager without providing the necessary LM cross-encrypted password.", "STATUS_LM_CROSS_ENCRYPTION_REQUIRED", 0xC000017F },
      {"An attempt was made to create a symbolic link in a registry key that already has subkeys or values.", "STATUS_KEY_HAS_CHILDREN", 0xC0000180 },
      {"An attempt was made to create a Stable subkey under a Volatile parent key.", "STATUS_CHILD_MUST_BE_VOLATILE", 0xC0000181 },
      {"The I/O device is configured incorrectly or the configuration parameters to the driver are incorrect.", "STATUS_DEVICE_CONFIGURATION_ERROR", 0xC0000182 },
      {"An error was detected between two drivers or within an I/O driver.", "STATUS_DRIVER_INTERNAL_ERROR", 0xC0000183 },
      {"The device is not in a valid state to perform this request.", "STATUS_INVALID_DEVICE_STATE", 0xC0000184 },
      {"The I/O device reported an I/O error.", "STATUS_IO_DEVICE_ERROR", 0xC0000185 },
      {"A protocol error was detected between the driver and the device.", "STATUS_DEVICE_PROTOCOL_ERROR", 0xC0000186 },
      {"This operation is only allowed for the Primary Domain Controller of the domain.", "STATUS_BACKUP_CONTROLLER", 0xC0000187 },
      {"Log file space is insufficient to support this operation.", "STATUS_LOG_FILE_FULL", 0xC0000188 },
      {"A write operation was attempted to a volume after it was dismounted.", "STATUS_TOO_LATE", 0xC0000189 },
      {"The workstation does not have a trust secret for the primary domain in the local LSA database.", "STATUS_NO_TRUST_LSA_SECRET", 0xC000018A },
      {"The SAM database on the Windows Server does not have a computer account for this workstation trust relationship.", "STATUS_NO_TRUST_SAM_ACCOUNT", 0xC000018B },
      {"The logon request failed because the trust relationship between the primary domain and the trusted domain failed.", "STATUS_TRUSTED_DOMAIN_FAILURE", 0xC000018C },
      {"The logon request failed because the trust relationship between this workstation and the primary domain failed.", "STATUS_TRUSTED_RELATIONSHIP_FAILURE", 0xC000018D },
      {"The Eventlog log file is corrupt.", "STATUS_EVENTLOG_FILE_CORRUPT", 0xC000018E },
      {"No Eventlog log file could be opened. The Eventlog service did not start.", "STATUS_EVENTLOG_CANT_START", 0xC000018F },
      {"The network logon failed. This may be because the validation authority can't be reached.", "STATUS_TRUST_FAILURE", 0xC0000190 },
      {"An attempt was made to acquire a mutant such that its maximum count would have been exceeded.", "STATUS_MUTANT_LIMIT_EXCEEDED", 0xC0000191 },
      {"An attempt was made to logon, but the netlogon service was not started.", "STATUS_NETLOGON_NOT_STARTED", 0xC0000192 },
      {"The user's account has expired.", "STATUS_ACCOUNT_EXPIRED", 0xC0000193 },
      {"{EXCEPTION}Possible deadlock condition.", "STATUS_POSSIBLE_DEADLOCK", 0xC0000194 },
      {"Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or shared resource and try again.", "STATUS_NETWORK_CREDENTIAL_CONFLICT", 0xC0000195 },
      {"An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.", "STATUS_REMOTE_SESSION_LIMIT", 0xC0000196 },
      {"The log file has changed between reads.", "STATUS_EVENTLOG_FILE_CHANGED", 0xC0000197 },
      {"The account used is an Interdomain Trust account. Use your global user account or local user account to access this server.", "STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT", 0xC0000198 },
      {"The account used is a Computer Account. Use your global user account or local user account to access this server.", "STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT", 0xC0000199 },
      {"The account used is an Server Trust account. Use your global user account or local user account to access this server.", "STATUS_NOLOGON_SERVER_TRUST_ACCOUNT", 0xC000019A },
      {"The name or SID of the domain specified is inconsistent with the trust information for that domain.", "STATUS_DOMAIN_TRUST_INCONSISTENT", 0xC000019B },
      {"A volume has been accessed for which a file system driver is required that has not yet been loaded.", "STATUS_FS_DRIVER_REQUIRED", 0xC000019C },
      {"There is no user session key for the specified logon session.", "STATUS_NO_USER_SESSION_KEY", 0xC0000202 },
      {"The remote user session has been deleted.", "STATUS_USER_SESSION_DELETED", 0xC0000203 },
      {"Indicates the specified resource language ID cannot be found in theimage file.", "STATUS_RESOURCE_LANG_NOT_FOUND", 0xC0000204 },
      {"Insufficient server resources exist to complete the request.", "STATUS_INSUFF_SERVER_RESOURCES", 0xC0000205 },
      {"The size of the buffer is invalid for the specified operation.", "STATUS_INVALID_BUFFER_SIZE", 0xC0000206 },
      {"The transport rejected the network address specified as invalid.", "STATUS_INVALID_ADDRESS_COMPONENT", 0xC0000207 },
      {"The transport rejected the network address specified due to an invalid use of a wildcard.", "STATUS_INVALID_ADDRESS_WILDCARD", 0xC0000208 },
      {"The transport address could not be opened because all the available addresses are in use.", "STATUS_TOO_MANY_ADDRESSES", 0xC0000209 },
      {"The transport address could not be opened because it already exists.", "STATUS_ADDRESS_ALREADY_EXISTS", 0xC000020A },
      {"The transport address is now closed.", "STATUS_ADDRESS_CLOSED", 0xC000020B },
      {"The transport connection is now disconnected.", "STATUS_CONNECTION_DISCONNECTED", 0xC000020C },
      {"The transport connection has been reset.", "STATUS_CONNECTION_RESET", 0xC000020D },
      {"The transport cannot dynamically acquire any more nodes.", "STATUS_TOO_MANY_NODES", 0xC000020E },
      {"The transport aborted a pending transaction.", "STATUS_TRANSACTION_ABORTED", 0xC000020F },
      {"The transport timed out a request waiting for a response.", "STATUS_TRANSACTION_TIMED_OUT", 0xC0000210 },
      {"The transport did not receive a release for a pending response.", "STATUS_TRANSACTION_NO_RELEASE", 0xC0000211 },
      {"The transport did not find a transaction matching the specifictoken.", "STATUS_TRANSACTION_NO_MATCH", 0xC0000212 },
      {"The transport had previously responded to a transaction request.", "STATUS_TRANSACTION_RESPONDED", 0xC0000213 },
      {"The transport does not recognized the transaction request identifier specified.", "STATUS_TRANSACTION_INVALID_ID", 0xC0000214 },
      {"The transport does not recognize the transaction request type specified.", "STATUS_TRANSACTION_INVALID_TYPE", 0xC0000215 },
      {"The transport can only process the specified request on the server side of a session.", "STATUS_NOT_SERVER_SESSION", 0xC0000216 },
      {"The transport can only process the specified request on the client side of a session.", "STATUS_NOT_CLIENT_SESSION", 0xC0000217 },
      {"{Registry File Failure}The registry cannot load the hive (file):%hsor its log or alternate.It is corrupt, absent, or not writable.", "STATUS_CANNOT_LOAD_REGISTRY_FILE", 0xC0000218 },
      {"{Unexpected Failure in DebugActiveProcess}An unexpected failure occurred while processing a DebugActiveProcess API request. You may choose OK to terminate the process, or Cancel to ignore the error.", "STATUS_DEBUG_ATTACH_FAILED", 0xC0000219 },
      {"{Fatal System Error}The %hs system process terminated unexpectedly with a status of 0x%08x (0x%08x 0x%08x).The system has been shut down.", "STATUS_SYSTEM_PROCESS_TERMINATED", 0xC000021A },
      {"{Data Not Accepted}The TDI client could not handle the data received during an indication.", "STATUS_DATA_NOT_ACCEPTED", 0xC000021B },
      {"{Unable to Retrieve Browser Server List}The list of servers for this workgroup is not currently available.", "STATUS_NO_BROWSER_SERVERS_FOUND", 0xC000021C },
      {"NTVDM encountered a hard error.", "STATUS_VDM_HARD_ERROR", 0xC000021D },
      {"{Cancel Timeout}The driver %hs failed to complete a cancelled I/O request in the allotted time.", "STATUS_DRIVER_CANCEL_TIMEOUT", 0xC000021E },
      {"{Reply Message Mismatch}An attempt was made to reply to an LPC message, but the thread specified by the client ID in the message was not waiting on that message.", "STATUS_REPLY_MESSAGE_MISMATCH", 0xC000021F },
      {"{Mapped View Alignment Incorrect}An attempt was made to map a view of a file, but either the specified base address or the offset into the file were not aligned on the proper allocation granularity.", "STATUS_MAPPED_ALIGNMENT", 0xC0000220 },
      {"{Bad Image Checksum}The image %hs is possibly corrupt. The header checksum does not match the computed checksum.", "STATUS_IMAGE_CHECKSUM_MISMATCH", 0xC0000221 },
      {"{Delayed Write Failed}Windows was unable to save all the data for the file %hs. The data has been lost.This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.", "STATUS_LOST_WRITEBEHIND_DATA", 0xC0000222 },
      {"The parameter(s) passed to the server in the client/server shared memory window were invalid. Too much data may have been put in the shared memory window.", "STATUS_CLIENT_SERVER_PARAMETERS_INVALID", 0xC0000223 },
      {"The user's password must be changed before logging on the first time.", "STATUS_PASSWORD_MUST_CHANGE", 0xC0000224 },
      {"The object was not found.", "STATUS_NOT_FOUND", 0xC0000225 },
      {"The stream is not a tiny stream.", "STATUS_NOT_TINY_STREAM", 0xC0000226 },
      {"A transaction recover failed.", "STATUS_RECOVERY_FAILURE", 0xC0000227 },
      {"The request must be handled by the stack overflow code.", "STATUS_STACK_OVERFLOW_READ", 0xC0000228 },
      {"A consistency check failed.", "STATUS_FAIL_CHECK", 0xC0000229 },
      {"The attempt to insert the ID in the index failed because the ID is already in the index.", "STATUS_DUPLICATE_OBJECTID", 0xC000022A },
      {"The attempt to set the object's ID failed because the object already has an ID.", "STATUS_OBJECTID_EXISTS", 0xC000022B },
      {"Internal OFS status codes indicating how an allocation operation is handled. Either it is retried after the containing onode is moved or the extent stream is converted to a large stream.", "STATUS_CONVERT_TO_LARGE", 0xC000022C },
      {"The request needs to be retried.", "STATUS_RETRY", 0xC000022D },
      {"The attempt to find the object found an object matching by ID on the volume but it is out of the scope of the handle used for the operation.", "STATUS_FOUND_OUT_OF_SCOPE", 0xC000022E },
      {"The bucket array must be grown. Retry transaction after doing so.", "STATUS_ALLOCATE_BUCKET", 0xC000022F },
      {"The property set specified does not exist on the object.", "STATUS_PROPSET_NOT_FOUND", 0xC0000230 },
      {"The user/kernel marshalling buffer has overflowed.", "STATUS_MARSHALL_OVERFLOW", 0xC0000231 },
      {"The supplied variant structure contains invalid data.", "STATUS_INVALID_VARIANT", 0xC0000232 },
      {"Could not find a domain controller for this domain.", "STATUS_DOMAIN_CONTROLLER_NOT_FOUND", 0xC0000233 },
      {"The user account has been automatically locked because too many invalid logon attempts or password change attempts have been requested.", "STATUS_ACCOUNT_LOCKED_OUT", 0xC0000234 },
      {"NtClose was called on a handle that was protected from close via NtSetInformationObject.", "STATUS_HANDLE_NOT_CLOSABLE", 0xC0000235 },
      {"The transport connection attempt was refused by the remote system.", "STATUS_CONNECTION_REFUSED", 0xC0000236 },
      {"The transport connection was gracefully closed.", "STATUS_GRACEFUL_DISCONNECT", 0xC0000237 },
      {"The transport endpoint already has an address associated with it.", "STATUS_ADDRESS_ALREADY_ASSOCIATED", 0xC0000238 },
      {"An address has not yet been associated with the transport endpoint.", "STATUS_ADDRESS_NOT_ASSOCIATED", 0xC0000239 },
      {"An operation was attempted on a nonexistent transport connection.", "STATUS_CONNECTION_INVALID", 0xC000023A },
      {"An invalid operation was attempted on an active transport connection.", "STATUS_CONNECTION_ACTIVE", 0xC000023B },
      {"The remote network is not reachable by the transport.", "STATUS_NETWORK_UNREACHABLE", 0xC000023C },
      {"The remote system is not reachable by the transport.", "STATUS_HOST_UNREACHABLE", 0xC000023D },
      {"The remote system does not support the transport protocol.", "STATUS_PROTOCOL_UNREACHABLE", 0xC000023E },
      {"No service is operating at the destination port of the transport on the remote system.", "STATUS_PORT_UNREACHABLE", 0xC000023F },
      {"The request was aborted.", "STATUS_REQUEST_ABORTED", 0xC0000240 },
      {"The transport connection was aborted by the local system.", "STATUS_CONNECTION_ABORTED", 0xC0000241 },
      {"The specified buffer contains ill-formed data.", "STATUS_BAD_COMPRESSION_BUFFER", 0xC0000242 },
      {"The requested operation cannot be performed on a file with a user mapped section open.", "STATUS_USER_MAPPED_FILE", 0xC0000243 },
      {"{Audit Failed}An attempt to generate a security audit failed.", "STATUS_AUDIT_FAILED", 0xC0000244 },
      {"The timer resolution was not previously set by the current process.", "STATUS_TIMER_RESOLUTION_NOT_SET", 0xC0000245 },
      {"A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.", "STATUS_CONNECTION_COUNT_LIMIT", 0xC0000246 },
      {"Attempting to login during an unauthorized time of day for this account.", "STATUS_LOGIN_TIME_RESTRICTION", 0xC0000247 },
      {"The account is not authorized to login from this station.", "STATUS_LOGIN_WKSTA_RESTRICTION", 0xC0000248 },
      {"{UP/MP Image Mismatch}The image %hs has been modified for use on a uniprocessor system, but you are running it on a multiprocessor machine.Please reinstall the image file.", "STATUS_IMAGE_MP_UP_MISMATCH", 0xC0000249 },
      {"There is insufficient account information to log you on.", "STATUS_INSUFFICIENT_LOGON_INFO", 0xC0000250 },
      {"{Invalid DLL Entrypoint}The dynamic link library %hs is not written correctly. The stack pointer has been left in an inconsistent state.The entrypoint should be declared as WINAPI or STDCALL. Select YES to fail the DLL load. Select NO to continue execution. Selecting NO may cause the application to operate incorrectly.", "STATUS_BAD_DLL_ENTRYPOINT", 0xC0000251 },
      {"{Invalid Service Callback Entrypoint}The %hs service is not written correctly. The stack pointer has been left in an inconsistent state.The callback entrypoint should be declared as WINAPI or STDCALL. Selecting OK will cause the service to continue operation. However, the service process may operate incorrectly.", "STATUS_BAD_SERVICE_ENTRYPOINT", 0xC0000252 },
      {"The server received the messages but did not send a reply.", "STATUS_LPC_REPLY_LOST", 0xC0000253 },
      {"There is an IP address conflict with another system on the network", "STATUS_IP_ADDRESS_CONFLICT1", 0xC0000254 },
      {"There is an IP address conflict with another system on the network", "STATUS_IP_ADDRESS_CONFLICT2", 0xC0000255 },
      {"{Low On Registry Space}The system has reached the maximum size allowed for the system part of the registry.  Additional storage requests will be ignored.", "STATUS_REGISTRY_QUOTA_LIMIT", 0xC0000256 },
      {"The contacted server does not support the indicated part of the DFS namespace.", "STATUS_PATH_NOT_COVERED", 0xC0000257 },
      {"A callback return system service cannot be executed when no callback is active.", "STATUS_NO_CALLBACK_ACTIVE", 0xC0000258 },
      {"The service being accessed is licensed for a particular number of connections.No more connections can be made to the service at this time because there are already as many connections as the service can accept.", "STATUS_LICENSE_QUOTA_EXCEEDED", 0xC0000259 },
      {"The password provided is too short to meet the policy of your user account.Please choose a longer password.", "STATUS_PWD_TOO_SHORT", 0xC000025A },
      {"The policy of your user account does not allow you to change passwords too frequently.This is done to prevent users from changing back to a familiar, but potentially discovered, password.If you feel your password has been compromised then please contact your administrator immediately to have a new one assigned.", "STATUS_PWD_TOO_RECENT", 0xC000025B },
      {"You have attempted to change your password to one that you have used in the past.The policy of your user account does not allow this. Please select a password that you have not previously used.", "STATUS_PWD_HISTORY_CONFLICT", 0xC000025C },
      {"You have attempted to load a legacy device driver while its device instance had been disabled.", "STATUS_PLUGPLAY_NO_DEVICE", 0xC000025E },
      {"The specified compression format is unsupported.", "STATUS_UNSUPPORTED_COMPRESSION", 0xC000025F },
      {"The specified hardware profile configuration is invalid.", "STATUS_INVALID_HW_PROFILE", 0xC0000260 },
      {"The specified Plug and Play registry device path is invalid.", "STATUS_INVALID_PLUGPLAY_DEVICE_PATH", 0xC0000261 },
      {"{Driver Entry Point Not Found}The %hs device driver could not locate the ordinal %ld in driver %hs.", "STATUS_DRIVER_ORDINAL_NOT_FOUND", 0xC0000262 },
      {"{Driver Entry Point Not Found}The %hs device driver could not locate the entry point %hs in driver %hs.", "STATUS_DRIVER_ENTRYPOINT_NOT_FOUND", 0xC0000263 },
      {"{Application Error}The application attempted to release a resource it did not own. Click on OK to terminate the application.", "STATUS_RESOURCE_NOT_OWNED", 0xC0000264 },
      {"An attempt was made to create more links on a file than the file system supports.", "STATUS_TOO_MANY_LINKS", 0xC0000265 },
      {"The specified quota list is internally inconsistent with its descriptor.", "STATUS_QUOTA_LIST_INCONSISTENT", 0xC0000266 },
      {"The specified file has been relocated to offline storage.", "STATUS_FILE_IS_OFFLINE", 0xC0000267 },
      {"{Windows Evaluation Notification}The evaluation period for this installation of Windows has expired. This system will shutdown in 1 hour. To restore access to this installation of Windows, please upgrade this installation using a licensed distribution of this product.", "STATUS_EVALUATION_EXPIRATION", 0xC0000268 },
      {"{Illegal System DLL Relocation}The system DLL %hs was relocated in memory. The application will not run properly.The relocation occurred because the DLL %hs occupied an address range reserved for Windows system DLLs. The vendor supplying the DLL should be contacted for a new DLL.", "STATUS_ILLEGAL_DLL_RELOCATION", 0xC0000269 },
      {"{License Violation}The system has detected tampering with your registered product type. This is a violation of your software license. Tampering with product type is not permitted.", "STATUS_LICENSE_VIOLATION", 0xC000026A },
      {"{DLL Initialization Failed}The application failed to initialize because the window station is shutting down.", "STATUS_DLL_INIT_FAILED_LOGOFF", 0xC000026B },
      {"{Unable to Load Device Driver}%hs device driver could not be loaded.Error Status was 0x%x", "STATUS_DRIVER_UNABLE_TO_LOAD", 0xC000026C },
      {"DFS is unavailable on the contacted server.", "STATUS_DFS_UNAVAILABLE", 0xC000026D },
      {"An operation was attempted to a volume after it was dismounted.", "STATUS_VOLUME_DISMOUNTED", 0xC000026E },
      {"An internal error occurred in the Win32 x86 emulation subsystem.", "STATUS_WX86_INTERNAL_ERROR", 0xC000026F },
      {"Win32 x86 emulation subsystem Floating-point stack check.", "STATUS_WX86_FLOAT_STACK_CHECK", 0xC0000270 },
      {"The validation process needs to continue on to the next step.", "STATUS_VALIDATE_CONTINUE", 0xC0000271 },
      {"There was no match for the specified key in the index.", "STATUS_NO_MATCH", 0xC0000272 },
      {"There are no more matches for the current index enumeration.", "STATUS_NO_MORE_MATCHES", 0xC0000273 },
      {"The NTFS file or directory is not a reparse point.", "STATUS_NOT_A_REPARSE_POINT", 0xC0000275 },
      {"The Windows I/O reparse tag passed for the NTFS reparse point is invalid.", "STATUS_IO_REPARSE_TAG_INVALID", 0xC0000276 },
      {"The Windows I/O reparse tag does not match the one present in the NTFS reparse point.", "STATUS_IO_REPARSE_TAG_MISMATCH", 0xC0000277 },
      {"The user data passed for the NTFS reparse point is invalid.", "STATUS_IO_REPARSE_DATA_INVALID", 0xC0000278 },
      {"The layered file system driver for this IO tag did not handle it when needed.", "STATUS_IO_REPARSE_TAG_NOT_HANDLED", 0xC0000279 },
      {"The NTFS symbolic link could not be resolved even though the initial file name is valid.", "STATUS_REPARSE_POINT_NOT_RESOLVED", 0xC0000280 },
      {"The NTFS directory is a reparse point.", "STATUS_DIRECTORY_IS_A_REPARSE_POINT", 0xC0000281 },
      {"The range could not be added to the range list because of a conflict.", "STATUS_RANGE_LIST_CONFLICT", 0xC0000282 },
      {"The specified medium changer source element contains no media.", "STATUS_SOURCE_ELEMENT_EMPTY", 0xC0000283 },
      {"The specified medium changer destination element already contains media.", "STATUS_DESTINATION_ELEMENT_FULL", 0xC0000284 },
      {"The specified medium changer element does not exist.", "STATUS_ILLEGAL_ELEMENT_ADDRESS", 0xC0000285 },
      {"The specified element is contained within a magazine that is no longer present.", "STATUS_MAGAZINE_NOT_PRESENT", 0xC0000286 },
      {"The device requires reinitialization due to hardware errors.", "STATUS_REINITIALIZATION_NEEDED", 0xC0000287 },
      {"The device has indicated that cleaning is necessary.", "STATUS_DEVICE_REQUIRES_CLEANING", 0x80000288 },
      {"The device has indicated that it's door is open. Further operations require it closed and secured.", "STATUS_DEVICE_DOOR_OPEN", 0x80000289 },
      {"The file encryption attempt failed.", "STATUS_ENCRYPTION_FAILED", 0xC000028A },
      {"The file decryption attempt failed.", "STATUS_DECRYPTION_FAILED", 0xC000028B },
      {"The specified range could not be found in the range list.", "STATUS_RANGE_NOT_FOUND", 0xC000028C },
      {"There is no encryption recovery policy configured for this system.", "STATUS_NO_RECOVERY_POLICY", 0xC000028D },
      {"The required encryption driver is not loaded for this system.", "STATUS_NO_EFS", 0xC000028E },
      {"The file was encrypted with a different encryption driver than is currently loaded.", "STATUS_WRONG_EFS", 0xC000028F },
      {"There are no EFS keys defined for the user.", "STATUS_NO_USER_KEYS", 0xC0000290 },
      {"The specified file is not encrypted.", "STATUS_FILE_NOT_ENCRYPTED", 0xC0000291 },
      {"The specified file is not in the defined EFS export format.", "STATUS_NOT_EXPORT_FORMAT", 0xC0000292 },
      {"The specified file is encrypted and the user does not have the ability to decrypt it.", "STATUS_FILE_ENCRYPTED", 0xC0000293 },
      {"The system has awoken", "STATUS_WAKE_SYSTEM", 0x40000294 },
      {"The guid passed was not recognized as valid by a WMI data provider.", "STATUS_WMI_GUID_NOT_FOUND", 0xC0000295 },
      {"The instance name passed was not recognized as valid by a WMI data provider.", "STATUS_WMI_INSTANCE_NOT_FOUND", 0xC0000296 },
      {"The data item id passed was not recognized as valid by a WMI data provider.", "STATUS_WMI_ITEMID_NOT_FOUND", 0xC0000297 },
      {"The WMI request could not be completed and should be retried.", "STATUS_WMI_TRY_AGAIN", 0xC0000298 },
      {"The policy object is shared and can only be modified at the root", "STATUS_SHARED_POLICY", 0xC0000299 },
      {"The policy object does not exist when it should", "STATUS_POLICY_OBJECT_NOT_FOUND", 0xC000029A },
      {"The requested policy information only lives in the Ds", "STATUS_POLICY_ONLY_IN_DS", 0xC000029B },
      {"The volume must be upgraded to enable this feature", "STATUS_VOLUME_NOT_UPGRADED", 0xC000029C },
      {"The remote storage service is not operational at this time.", "STATUS_REMOTE_STORAGE_NOT_ACTIVE", 0xC000029D },
      {"The remote storage service encountered a media error.", "STATUS_REMOTE_STORAGE_MEDIA_ERROR", 0xC000029E },
      {"The tracking (workstation) service is not running.", "STATUS_NO_TRACKING_SERVICE", 0xC000029F },
      {"The server process is running under a SID different than that required by client.", "STATUS_SERVER_SID_MISMATCH", 0xC00002A0 },
      {"The specified directory service attribute or value does not exist.", "STATUS_DS_NO_ATTRIBUTE_OR_VALUE", 0xC00002A1 },
      {"The attribute syntax specified to the directory service is invalid.", "STATUS_DS_INVALID_ATTRIBUTE_SYNTAX", 0xC00002A2 },
      {"The attribute type specified to the directory service is not defined.", "STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED", 0xC00002A3 },
      {"The specified directory service attribute or value already exists.", "STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS", 0xC00002A4 },
      {"The directory service is busy.", "STATUS_DS_BUSY", 0xC00002A5 },
      {"The directory service is not available.", "STATUS_DS_UNAVAILABLE", 0xC00002A6 },
      {"The directory service was unable to allocate a relative identifier.", "STATUS_DS_NO_RIDS_ALLOCATED", 0xC00002A7 },
      {"The directory service has exhausted the pool of relative identifiers.", "STATUS_DS_NO_MORE_RIDS", 0xC00002A8 },
      {"The requested operation could not be performed because the directory service is not the master for that type of operation.", "STATUS_DS_INCORRECT_ROLE_OWNER", 0xC00002A9 },
      {"The directory service was unable to initialize the subsystem that allocates relative identifiers.", "STATUS_DS_RIDMGR_INIT_ERROR", 0xC00002AA },
      {"The requested operation did not satisfy one or more constraints associated with the class of the object.", "STATUS_DS_OBJ_CLASS_VIOLATION", 0xC00002AB },
      {"The directory service can perform the requested operation only on a leaf object.", "STATUS_DS_CANT_ON_NON_LEAF", 0xC00002AC },
      {"The directory service cannot perform the requested operation on the Relatively Defined Name (RDN) attribute of an object.", "STATUS_DS_CANT_ON_RDN", 0xC00002AD },
      {"The directory service detected an attempt to modify the object class of an object.", "STATUS_DS_CANT_MOD_OBJ_CLASS", 0xC00002AE },
      {"An error occurred while performing a cross domain move operation.", "STATUS_DS_CROSS_DOM_MOVE_FAILED", 0xC00002AF },
      {"Unable to Contact the Global Catalog Server.", "STATUS_DS_GC_NOT_AVAILABLE", 0xC00002B0 },
      {"The requested operation requires a directory service, and none was available.", "STATUS_DIRECTORY_SERVICE_REQUIRED", 0xC00002B1 },
      {"The reparse attribute cannot be set as it is incompatible with an existing attribute.", "STATUS_REPARSE_ATTRIBUTE_CONFLICT", 0xC00002B2 },
      {"A group marked use for deny only  can not be enabled.", "STATUS_CANT_ENABLE_DENY_ONLY", 0xC00002B3 },
      {"{EXCEPTION}Multiple floating point faults.", "STATUS_FLOAT_MULTIPLE_FAULTS", 0xC00002B4 },
      {"{EXCEPTION}Multiple floating point traps.", "STATUS_FLOAT_MULTIPLE_TRAPS", 0xC00002B5 },
      {"The device has been removed.", "STATUS_DEVICE_REMOVED", 0xC00002B6 },
      {"The volume change journal is being deleted.", "STATUS_JOURNAL_DELETE_IN_PROGRESS", 0xC00002B7 },
      {"The volume change journal is not active.", "STATUS_JOURNAL_NOT_ACTIVE", 0xC00002B8 },
      {"The requested interface is not supported.", "STATUS_NOINTERFACE", 0xC00002B9 },
      {"A directory service resource limit has been exceeded.", "STATUS_DS_ADMIN_LIMIT_EXCEEDED", 0xC00002C1 },
      {"{System Standby Failed}The driver %hs does not support standby mode. Updating this driver may allow the system to go to standby mode.", "STATUS_DRIVER_FAILED_SLEEP", 0xC00002C2 },
      {"Mutual Authentication failed. The server's password is out of date at the domain controller.", "STATUS_MUTUAL_AUTHENTICATION_FAILED", 0xC00002C3 },
      {"The system file %1 has become corrupt and has been replaced.", "STATUS_CORRUPT_SYSTEM_FILE", 0xC00002C4 },
      {"{EXCEPTION}Alignment ErrorA datatype misalignment error was detected in a load or store instruction.", "STATUS_DATATYPE_MISALIGNMENT_ERROR", 0xC00002C5 },
      {"The WMI data item or data block is read only.", "STATUS_WMI_READ_ONLY", 0xC00002C6 },
      {"The WMI data item or data block could not be changed.", "STATUS_WMI_SET_FAILURE", 0xC00002C7 },
      {"{Virtual Memory Minimum Too Low}Your system is low on virtual memory. Windows is increasing the size of your virtual memory paging file.During this process, memory requests for some applications may be denied. For more information, see Help.", "STATUS_COMMITMENT_MINIMUM", 0xC00002C8 },
      {"{EXCEPTION}Register NaT consumption faults.A NaT value is consumed on a non speculative instruction.", "STATUS_REG_NAT_CONSUMPTION", 0xC00002C9 },
      {"The medium changer's transport element contains media, which is causing the operation to fail.", "STATUS_TRANSPORT_FULL", 0xC00002CA },
      {"Security Accounts Manager initialization failed because of the following error:%hsError Status: 0x%x.Please click OK to shutdown this system and reboot into Directory Services Restore Mode, check the event log for more detailed information.", "STATUS_DS_SAM_INIT_FAILURE", 0xC00002CB },
      {"This operation is supported only when you are connected to the server.", "STATUS_ONLY_IF_CONNECTED", 0xC00002CC },
      {"Only an administrator can modify the membership list of an administrative group.", "STATUS_DS_SENSITIVE_GROUP_VIOLATION", 0xC00002CD },
      {"A device was removed so enumeration must be restarted.", "STATUS_PNP_RESTART_ENUMERATION", 0xC00002CE },
      {"The journal entry has been deleted from the journal.", "STATUS_JOURNAL_ENTRY_DELETED", 0xC00002CF },
      {"Cannot change the primary group ID of a domain controller account.", "STATUS_DS_CANT_MOD_PRIMARYGROUPID", 0xC00002D0 },
      {"{Fatal System Error}The system image %s is not properly signed.The file has been replaced with the signed file.The system has been shut down.", "STATUS_SYSTEM_IMAGE_BAD_SIGNATURE", 0xC00002D1 },
      {"Device will not start without a reboot.", "STATUS_PNP_REBOOT_REQUIRED", 0xC00002D2 },
      {"Current device power state cannot support this request.", "STATUS_POWER_STATE_INVALID", 0xC00002D3 },
      {"The specified group type is invalid.", "STATUS_DS_INVALID_GROUP_TYPE", 0xC00002D4 },
      {"In mixed domain no nesting of global group if group is security enabled.", "STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN", 0xC00002D5 },
      {"In mixed domain, cannot nest local groups with other local groups, if the group is security enabled.", "STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN", 0xC00002D6 },
      {"A global group cannot have a local group as a member.", "STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER", 0xC00002D7 },
      {"A global group cannot have a universal group as a member.", "STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER", 0xC00002D8 },
      {"A universal group cannot have a local group as a member.", "STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER", 0xC00002D9 },
      {"A global group cannot have a cross domain member.", "STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER", 0xC00002DA },
      {"A local group cannot have another cross domain local group as a member.", "STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER", 0xC00002DB },
      {"Can not change to security disabled group because of having primary members in this group.", "STATUS_DS_HAVE_PRIMARY_MEMBERS", 0xC00002DC },
      {"The WMI operation is not supported by the data block or method.", "STATUS_WMI_NOT_SUPPORTED", 0xC00002DD },
      {"There is not enough power to complete the requested operation.", "STATUS_INSUFFICIENT_POWER", 0xC00002DE },
      {"Security Account Manager needs to get the boot password.", "STATUS_SAM_NEED_BOOTKEY_PASSWORD", 0xC00002DF },
      {"Security Account Manager needs to get the boot key from floppy disk.", "STATUS_SAM_NEED_BOOTKEY_FLOPPY", 0xC00002E0 },
      {"Directory Service can not start.", "STATUS_DS_CANT_START", 0xC00002E1 },
      {"Directory Services could not start because of the following error:%hsError Status: 0x%x.Please click OK to shutdown this system and reboot into Directory Services Restore Mode, check the event log for more detailed information.", "STATUS_DS_INIT_FAILURE", 0xC00002E2 },
      {"Security Accounts Manager initialization failed because of the following error:%hsError Status: 0x%x.Please click OK to shutdown this system and reboot into Safe Mode, check the event log for more detailed information.", "STATUS_SAM_INIT_FAILURE", 0xC00002E3 },
      {"The requested operation can be performed only on a global catalog server.", "STATUS_DS_GC_REQUIRED", 0xC00002E4 },
      {"A local group can only be a member of other local groups in the same domain.", "STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY", 0xC00002E5 },
      {"Foreign security principals cannot be members of universal groups.", "STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS", 0xC00002E6 },
      {"Your computer could not be joined to the domain. You have exceeded the maximum number of computer accounts you are allowed to create in this domain. Contact your system administrator to have this limit reset or increased.", "STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED", 0xC00002E7 },
      {"STATUS_MULTIPLE_FAULT_VIOLATION", "STATUS_MULTIPLE_FAULT_VIOLATION", 0xC00002E8 },
      {"This operation can not be performed on the current domain.", "STATUS_CURRENT_DOMAIN_NOT_ALLOWED", 0xC00002E9 },
      {"The directory or file cannot be created.", "STATUS_CANNOT_MAKE", 0xC00002EA },
      {"The system is in the process of shutting down.", "STATUS_SYSTEM_SHUTDOWN", 0xC00002EB },
      {"Directory Services could not start because of the following error:%hsError Status: 0x%x.Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.", "STATUS_DS_INIT_FAILURE_CONSOLE", 0xC00002EC },
      {"Security Accounts Manager initialization failed because of the following error:%hsError Status: 0x%x.Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.", "STATUS_DS_SAM_INIT_FAILURE_CONSOLE", 0xC00002ED },
      {"A security context was deleted before the context was completed.  This is considered a logon failure.", "STATUS_UNFINISHED_CONTEXT_DELETED", 0xC00002EE },
      {"The client is trying to negotiate a context and the server requires user-to-user but didn't send a TGT reply.", "STATUS_NO_TGT_REPLY", 0xC00002EF },
      {"An object ID was not found in the file.", "STATUS_OBJECTID_NOT_FOUND", 0xC00002F0 },
      {"Unable to accomplish the requested task because the local machine does not have any IP addresses.", "STATUS_NO_IP_ADDRESSES", 0xC00002F1 },
      {"The supplied credential handle does not match the credential associated with the security context.", "STATUS_WRONG_CREDENTIAL_HANDLE", 0xC00002F2 },
      {"The crypto system or checksum function is invalid because a required function is unavailable.", "STATUS_CRYPTO_SYSTEM_INVALID", 0xC00002F3 },
      {"The number of maximum ticket referrals has been exceeded.", "STATUS_MAX_REFERRALS_EXCEEDED", 0xC00002F4 },
      {"The local machine must be a Kerberos KDC (domain controller) and it is not.", "STATUS_MUST_BE_KDC", 0xC00002F5 },
      {"The other end of the security negotiation is requires strong crypto but it is not supported on the local machine.", "STATUS_STRONG_CRYPTO_NOT_SUPPORTED", 0xC00002F6 },
      {"The KDC reply contained more than one principal name.", "STATUS_TOO_MANY_PRINCIPALS", 0xC00002F7 },
      {"Expected to find PA data for a hint of what etype to use, but it was not found.", "STATUS_NO_PA_DATA", 0xC00002F8 },
      {"The client certificate does not contain a valid UPN, or does not match the client name in the logon request.  Please contact your administrator.", "STATUS_PKINIT_NAME_MISMATCH", 0xC00002F9 },
      {"Smartcard logon is required and was not used.", "STATUS_SMARTCARD_LOGON_REQUIRED", 0xC00002FA },
      {"An invalid request was sent to the KDC.", "STATUS_KDC_INVALID_REQUEST", 0xC00002FB },
      {"The KDC was unable to generate a referral for the service requested.", "STATUS_KDC_UNABLE_TO_REFER", 0xC00002FC },
      {"The encryption type requested is not supported by the KDC.", "STATUS_KDC_UNKNOWN_ETYPE", 0xC00002FD },
      {"A system shutdown is in progress.", "STATUS_SHUTDOWN_IN_PROGRESS", 0xC00002FE },
      {"The server machine is shutting down.", "STATUS_SERVER_SHUTDOWN_IN_PROGRESS", 0xC00002FF },
      {"This operation is not supported on a computer running Windows Server 2003 for Small Business Server", "STATUS_NOT_SUPPORTED_ON_SBS", 0xC0000300 },
      {"The WMI GUID is no longer available", "STATUS_WMI_GUID_DISCONNECTED", 0xC0000301 },
      {"Collection or events for the WMI GUID is already disabled.", "STATUS_WMI_ALREADY_DISABLED", 0xC0000302 },
      {"Collection or events for the WMI GUID is already enabled.", "STATUS_WMI_ALREADY_ENABLED", 0xC0000303 },
      {"The Master File Table on the volume is too fragmented to complete this operation.", "STATUS_MFT_TOO_FRAGMENTED", 0xC0000304 },
      {"Copy protection failure.", "STATUS_COPY_PROTECTION_FAILURE", 0xC0000305 },
      {"Copy protection error - DVD CSS Authentication failed.", "STATUS_CSS_AUTHENTICATION_FAILURE", 0xC0000306 },
      {"Copy protection error - The given sector does not contain a valid key.", "STATUS_CSS_KEY_NOT_PRESENT", 0xC0000307 },
      {"Copy protection error - DVD session key not established.", "STATUS_CSS_KEY_NOT_ESTABLISHED", 0xC0000308 },
      {"Copy protection error - The read failed because the sector is encrypted.", "STATUS_CSS_SCRAMBLED_SECTOR", 0xC0000309 },
      {"Copy protection error - The given DVD's region does not correspond to theregion setting of the drive.", "STATUS_CSS_REGION_MISMATCH", 0xC000030A },
      {"Copy protection error - The drive's region setting may be permanent.", "STATUS_CSS_RESETS_EXHAUSTED", 0xC000030B },
      {"The kerberos protocol encountered an error while validating the KDC certificate during smartcard Logon.  Thereis more information in the system event log.", "STATUS_PKINIT_FAILURE", 0xC0000320 },
      {"The kerberos protocol encountered an error while attempting to utilize the smartcard subsystem.", "STATUS_SMARTCARD_SUBSYSTEM_FAILURE", 0xC0000321 },
      {"The target server does not have acceptable kerberos credentials.", "STATUS_NO_KERB_KEY", 0xC0000322 },
      {"The transport determined that the remote system is down.", "STATUS_HOST_DOWN", 0xC0000350 },
      {"An unsupported preauthentication mechanism was presented to the kerberos package.", "STATUS_UNSUPPORTED_PREAUTH", 0xC0000351 },
      {"The encryption algorithm used on the source file needs a bigger key buffer than the one used on the destination file.", "STATUS_EFS_ALG_BLOB_TOO_BIG", 0xC0000352 },
      {"An attempt to remove a processes DebugPort was made, but a port was not already associated with the process.", "STATUS_PORT_NOT_SET", 0xC0000353 },
      {"An attempt to do an operation on a debug port failed because the port is in the process of being deleted.", "STATUS_DEBUGGER_INACTIVE", 0xC0000354 },
      {"This version of Windows is not compatible with the behavior version of directory forest, domain or domain controller.", "STATUS_DS_VERSION_CHECK_FAILURE", 0xC0000355 },
      {"The specified event is currently not being audited.", "STATUS_AUDITING_DISABLED", 0xC0000356 },
      {"The machine account was created pre-NT4.  The account needs to be recreated.", "STATUS_PRENT4_MACHINE_ACCOUNT", 0xC0000357 },
      {"A account group can not have a universal group as a member.", "STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER", 0xC0000358 },
      {"The specified image file did not have the correct format, it appears to be a 32-bit Windows image.", "STATUS_INVALID_IMAGE_WIN_32", 0xC0000359 },
      {"The specified image file did not have the correct format, it appears to be a 64-bit Windows image.", "STATUS_INVALID_IMAGE_WIN_64", 0xC000035A },
      {"Client's supplied SSPI channel bindings were incorrect.", "STATUS_BAD_BINDINGS", 0xC000035B },
      {"The client's session has expired, so the client must reauthenticate to continue accessing the remote resources.", "STATUS_NETWORK_SESSION_EXPIRED", 0xC000035C },
      {"AppHelp dialog canceled thus preventing the application from starting.", "STATUS_APPHELP_BLOCK", 0xC000035D },
      {"The SID filtering operation removed all SIDs.", "STATUS_ALL_SIDS_FILTERED", 0xC000035E },
      {"The driver was not loaded because the system is booting into safe mode.", "STATUS_NOT_SAFE_MODE_DRIVER", 0xC000035F },
      {"Access to %1 has been restricted by your Administrator by the default software restriction policy level.", "STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT", 0xC0000361 },
      {"Access to %1 has been restricted by your Administrator by location with policy rule %2 placed on path %3", "STATUS_ACCESS_DISABLED_BY_POLICY_PATH", 0xC0000362 },
      {"Access to %1 has been restricted by your Administrator by software publisher policy.", "STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER", 0xC0000363 },
      {"Access to %1 has been restricted by your Administrator by policy rule %2.", "STATUS_ACCESS_DISABLED_BY_POLICY_OTHER", 0xC0000364 },
      {"The driver was not loaded because it failed it's initialization call.", "STATUS_FAILED_DRIVER_ENTRY", 0xC0000365 },
      {"The \"%hs\" encountered an error while applying power or reading the device configuration.This may be caused by a failure of your hardware or by a poor connection.", "STATUS_DEVICE_ENUMERATION_ERROR", 0xC0000366 },
      {"An operation is blocked waiting for an oplock.", "STATUS_WAIT_FOR_OPLOCK", 0x00000367 },
      {"The create operation failed because the name contained at least one mount point which resolves to a volume to which the specified device object is not attached.", "STATUS_MOUNT_POINT_NOT_RESOLVED", 0xC0000368 },
      {"The device object parameter is either not a valid device object or is not attached to the volume specified by the file name.", "STATUS_INVALID_DEVICE_OBJECT_PARAMETER", 0xC0000369 },
      {"A Machine Check Error has occurred. Please check the system eventlog for additional information.", "STATUS_MCA_OCCURED", 0xC000036A },
      {"Driver %2 has been blocked from loading.", "STATUS_DRIVER_BLOCKED_CRITICAL", 0xC000036B },
      {"Driver %2 has been blocked from loading.", "STATUS_DRIVER_BLOCKED", 0xC000036C },
      {"There was error [%2] processing the driver database.", "STATUS_DRIVER_DATABASE_ERROR", 0xC000036D },
      {"System hive size has exceeded its limit.", "STATUS_SYSTEM_HIVE_TOO_LARGE", 0xC000036E },
      {"A dynamic link library (DLL},", "STATUS_INVALID_IMPORT_OF_NON_DLL", 0xC000036F },
      {"The Directory Service is shuting down.", "STATUS_DS_SHUTTING_DOWN", 0x40000370 },
      {"An incorrect PIN was presented to the smart card", "STATUS_SMARTCARD_WRONG_PIN", 0xC0000380 },
      {"The smart card is blocked", "STATUS_SMARTCARD_CARD_BLOCKED", 0xC0000381 },
      {"No PIN was presented to the smart card", "STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED", 0xC0000382 },
      {"No smart card available", "STATUS_SMARTCARD_NO_CARD", 0xC0000383 },
      {"The requested key container does not exist on the smart card", "STATUS_SMARTCARD_NO_KEY_CONTAINER", 0xC0000384 },
      {"The requested certificate does not exist on the smart card", "STATUS_SMARTCARD_NO_CERTIFICATE", 0xC0000385 },
      {"The requested keyset does not exist", "STATUS_SMARTCARD_NO_KEYSET", 0xC0000386 },
      {"A communication error with the smart card has been detected.", "STATUS_SMARTCARD_IO_ERROR", 0xC0000387 },
      {"The system detected a possible attempt to compromise security. Please ensure that you can contact the server that authenticated you.", "STATUS_DOWNGRADE_DETECTED", 0xC0000388 },
      {"The smartcard certificate used for authentication has been revoked.Please contact your system administrator.  There may be additional information in theevent log.", "STATUS_SMARTCARD_CERT_REVOKED", 0xC0000389 },
      {"An untrusted certificate authority was detected While processing thesmartcard certificate used for authentication.  Please contact your systemadministrator.", "STATUS_ISSUING_CA_UNTRUSTED", 0xC000038A },
      {"The revocation status of the smartcard certificate used forauthentication could not be determined. Please contact your system administrator.", "STATUS_REVOCATION_OFFLINE_C", 0xC000038B },
      {"The smartcard certificate used for authentication was not trusted.  Pleasecontact your system administrator.", "STATUS_PKINIT_CLIENT_FAILURE", 0xC000038C },
      {"The smartcard certificate used for authentication has expired.  Pleasecontact your system administrator.", "STATUS_SMARTCARD_CERT_EXPIRED", 0xC000038D },
      {"The driver could not be loaded because a previous version of the driver is still in memory.", "STATUS_DRIVER_FAILED_PRIOR_UNLOAD", 0xC000038E },
      {"The smartcard provider could not perform the action since the context was acquired as silent.", "STATUS_SMARTCARD_SILENT_CONTEXT", 0xC000038F },
      {"The current user's delegated trust creation quota has been exceeded.", "STATUS_PER_USER_TRUST_QUOTA_EXCEEDED", 0xC0000401 },
      {"The total delegated trust creation quota has been exceeded.", "STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED", 0xC0000402 },
      {"The current user's delegated trust deletion quota has been exceeded.", "STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED", 0xC0000403 },
      {"The requested name already exists as a unique identifier.", "STATUS_DS_NAME_NOT_UNIQUE", 0xC0000404 },
      {"The requested object has a non-unique identifier and cannot be retrieved.", "STATUS_DS_DUPLICATE_ID_FOUND", 0xC0000405 },
      {"The group cannot be converted due to attribute restrictions on the requested group type.", "STATUS_DS_GROUP_CONVERSION_ERROR", 0xC0000406 },
      {"{Volume Shadow Copy Service}Please wait while the Volume Shadow Copy Service prepares volume %hs for hibernation.", "STATUS_VOLSNAP_PREPARE_HIBERNATE", 0xC0000407 },
      {"Kerberos sub-protocol User2User is required.", "STATUS_USER2USER_REQUIRED", 0xC0000408 },
      {"The system detected an overrun of a stack-based buffer in this application.  Thisoverrun could potentially allow a malicious user to gain control of this application.", "STATUS_STACK_BUFFER_OVERRUN", 0xC0000409 },
      {"The Kerberos subsystem encountered an error.  A service for user protocol request was made against a domain controller which does not support service for user.", "STATUS_NO_S4U_PROT_SUPPORT", 0xC000040A },
      {"An attempt was made by this server to make a Kerberos constrained delegation request for a targetoutside of the server's realm.  This is not supported, and indicates a misconfiguration on thisserver's allowed to delegate to list.  Please contact your administrator.", "STATUS_CROSSREALM_DELEGATION_FAILURE", 0xC000040B },
      {"The revocation status of the domain controller certificate used for smartcardauthentication could not be determined.  There is additional information in the system eventlog. Please contact your system administrator.", "STATUS_REVOCATION_OFFLINE_KDC", 0xC000040C },
      {"An untrusted certificate authority was detected while processing thedomain controller certificate used for authentication.  There is additional information inthe system event log.  Please contact your system administrator.", "STATUS_ISSUING_CA_UNTRUSTED_KDC", 0xC000040D },
      {"The domain controller certificate used for smartcard logon has expired.Please contact your system administrator with the contents of your system event log.", "STATUS_KDC_CERT_EXPIRED", 0xC000040E },
      {"The domain controller certificate used for smartcard logon has been revoked.Please contact your system administrator with the contents of your system event log.", "STATUS_KDC_CERT_REVOKED", 0xC000040F },
      {"Data present in one of the parameters is more than the function can operate on.", "STATUS_PARAMETER_QUOTA_EXCEEDED", 0xC0000410 },
      {"The system has failed to hibernate (The error code is %hs).  Hibernation will be disabled until the system is restarted.", "STATUS_HIBERNATION_FAILURE", 0xC0000411 },
      {"An attempt to delay-load a .dll or get a function address in a delay-loaded .dll failed.", "STATUS_DELAY_LOAD_FAILED", 0xC0000412 },
      {"Logon Failure: The machine you are logging onto is protected by an authentication firewall.  The specified account is not allowed to authenticate to the machine.", "STATUS_AUTHENTICATION_FIREWALL_FAILED", 0xC0000413 },
      {"%hs is a 16-bit application. You do not have permissions to execute 16-bit applications. Check your permissions with your system administrator.", "STATUS_VDM_DISALLOWED", 0xC0000414 },
      {"{Display Driver Stopped Responding}The %hs display driver has stopped working normally.  Save your work and reboot the system to restore full display functionality.The next time you reboot the machine a dialog will be displayed giving you a chance to report this failure to Microsoft.", "STATUS_HUNG_DISPLAY_DRIVER_THREAD", 0xC0000415 },
      {"An assertion failure has occurred.", "STATUS_ASSERTION_FAILURE", 0xC0000420 },
      {"An exception has occurred in a user mode callback and the kernel callback frame should be removed.", "STATUS_CALLBACK_POP_STACK", 0xC0000423 },
      {"The attempted write operation encountered a write already in progress for some portion of the range.", "STATUS_ENCOUNTERED_WRITE_IN_PROGRESS", 0xC0000433 },
      {"WOW Assertion Error.", "STATUS_WOW_ASSERTION", 0xC0009898 },
      {"Debugger did not perform a state change.", "DBG_NO_STATE_CHANGE", 0xC0010001 },
      {"Debugger has found the application is not idle.", "DBG_APP_NOT_IDLE", 0xC0010002 },
      {"The string binding is invalid.", "RPC_NT_INVALID_STRING_BINDING", 0xC0020001 },
      {"The binding handle is not the correct type.", "RPC_NT_WRONG_KIND_OF_BINDING", 0xC0020002 },
      {"The binding handle is invalid.", "RPC_NT_INVALID_BINDING", 0xC0020003 },
      {"The RPC protocol sequence is not supported.", "RPC_NT_PROTSEQ_NOT_SUPPORTED", 0xC0020004 },
      {"The RPC protocol sequence is invalid.", "RPC_NT_INVALID_RPC_PROTSEQ", 0xC0020005 },
      {"The string UUID is invalid.", "RPC_NT_INVALID_STRING_UUID", 0xC0020006 },
      {"The endpoint format is invalid.", "RPC_NT_INVALID_ENDPOINT_FORMAT", 0xC0020007 },
      {"The network address is invalid.", "RPC_NT_INVALID_NET_ADDR", 0xC0020008 },
      {"No endpoint was found.", "RPC_NT_NO_ENDPOINT_FOUND", 0xC0020009 },
      {"The timeout value is invalid.", "RPC_NT_INVALID_TIMEOUT", 0xC002000A },
      {"The object UUID was not found.", "RPC_NT_OBJECT_NOT_FOUND", 0xC002000B },
      {"The object UUID has already been registered.", "RPC_NT_ALREADY_REGISTERED", 0xC002000C },
      {"The type UUID has already been registered.", "RPC_NT_TYPE_ALREADY_REGISTERED", 0xC002000D },
      {"The RPC server is already listening.", "RPC_NT_ALREADY_LISTENING", 0xC002000E },
      {"No protocol sequences have been registered.", "RPC_NT_NO_PROTSEQS_REGISTERED", 0xC002000F },
      {"The RPC server is not listening.", "RPC_NT_NOT_LISTENING", 0xC0020010 },
      {"The manager type is unknown.", "RPC_NT_UNKNOWN_MGR_TYPE", 0xC0020011 },
      {"The interface is unknown.", "RPC_NT_UNKNOWN_IF", 0xC0020012 },
      {"There are no bindings.", "RPC_NT_NO_BINDINGS", 0xC0020013 },
      {"There are no protocol sequences.", "RPC_NT_NO_PROTSEQS", 0xC0020014 },
      {"The endpoint cannot be created.", "RPC_NT_CANT_CREATE_ENDPOINT", 0xC0020015 },
      {"Not enough resources are available to complete this operation.", "RPC_NT_OUT_OF_RESOURCES", 0xC0020016 },
      {"The RPC server is unavailable.", "RPC_NT_SERVER_UNAVAILABLE", 0xC0020017 },
      {"The RPC server is too busy to complete this operation.", "RPC_NT_SERVER_TOO_BUSY", 0xC0020018 },
      {"The network options are invalid.", "RPC_NT_INVALID_NETWORK_OPTIONS", 0xC0020019 },
      {"There are no remote procedure calls active on this thread.", "RPC_NT_NO_CALL_ACTIVE", 0xC002001A },
      {"The remote procedure call failed.", "RPC_NT_CALL_FAILED", 0xC002001B },
      {"The remote procedure call failed and did not execute.", "RPC_NT_CALL_FAILED_DNE", 0xC002001C },
      {"An RPC protocol error occurred.", "RPC_NT_PROTOCOL_ERROR", 0xC002001D },
      {"The transfer syntax is not supported by the RPC server.", "RPC_NT_UNSUPPORTED_TRANS_SYN", 0xC002001F },
      {"The type UUID is not supported.", "RPC_NT_UNSUPPORTED_TYPE", 0xC0020021 },
      {"The tag is invalid.", "RPC_NT_INVALID_TAG", 0xC0020022 },
      {"The array bounds are invalid.", "RPC_NT_INVALID_BOUND", 0xC0020023 },
      {"The binding does not contain an entry name.", "RPC_NT_NO_ENTRY_NAME", 0xC0020024 },
      {"The name syntax is invalid.", "RPC_NT_INVALID_NAME_SYNTAX", 0xC0020025 },
      {"The name syntax is not supported.", "RPC_NT_UNSUPPORTED_NAME_SYNTAX", 0xC0020026 },
      {"No network address is available to use to construct a UUID.", "RPC_NT_UUID_NO_ADDRESS", 0xC0020028 },
      {"The endpoint is a duplicate.", "RPC_NT_DUPLICATE_ENDPOINT", 0xC0020029 },
      {"The authentication type is unknown.", "RPC_NT_UNKNOWN_AUTHN_TYPE", 0xC002002A },
      {"The maximum number of calls is too small.", "RPC_NT_MAX_CALLS_TOO_SMALL", 0xC002002B },
      {"The string is too long.", "RPC_NT_STRING_TOO_LONG", 0xC002002C },
      {"The RPC protocol sequence was not found.", "RPC_NT_PROTSEQ_NOT_FOUND", 0xC002002D },
      {"The procedure number is out of range.", "RPC_NT_PROCNUM_OUT_OF_RANGE", 0xC002002E },
      {"The binding does not contain any authentication information.", "RPC_NT_BINDING_HAS_NO_AUTH", 0xC002002F },
      {"The authentication service is unknown.", "RPC_NT_UNKNOWN_AUTHN_SERVICE", 0xC0020030 },
      {"The authentication level is unknown.", "RPC_NT_UNKNOWN_AUTHN_LEVEL", 0xC0020031 },
      {"The security context is invalid.", "RPC_NT_INVALID_AUTH_IDENTITY", 0xC0020032 },
      {"The authorization service is unknown.", "RPC_NT_UNKNOWN_AUTHZ_SERVICE", 0xC0020033 },
      {"The entry is invalid.", "EPT_NT_INVALID_ENTRY", 0xC0020034 },
      {"The operation cannot be performed.", "EPT_NT_CANT_PERFORM_OP", 0xC0020035 },
      {"There are no more endpoints available from the endpoint mapper.", "EPT_NT_NOT_REGISTERED", 0xC0020036 },
      {"No interfaces have been exported.", "RPC_NT_NOTHING_TO_EXPORT", 0xC0020037 },
      {"The entry name is incomplete.", "RPC_NT_INCOMPLETE_NAME", 0xC0020038 },
      {"The version option is invalid.", "RPC_NT_INVALID_VERS_OPTION", 0xC0020039 },
      {"There are no more members.", "RPC_NT_NO_MORE_MEMBERS", 0xC002003A },
      {"There is nothing to unexport.", "RPC_NT_NOT_ALL_OBJS_UNEXPORTED", 0xC002003B },
      {"The interface was not found.", "RPC_NT_INTERFACE_NOT_FOUND", 0xC002003C },
      {"The entry already exists.", "RPC_NT_ENTRY_ALREADY_EXISTS", 0xC002003D },
      {"The entry is not found.", "RPC_NT_ENTRY_NOT_FOUND", 0xC002003E },
      {"The name service is unavailable.", "RPC_NT_NAME_SERVICE_UNAVAILABLE", 0xC002003F },
      {"The network address family is invalid.", "RPC_NT_INVALID_NAF_ID", 0xC0020040 },
      {"The requested operation is not supported.", "RPC_NT_CANNOT_SUPPORT", 0xC0020041 },
      {"No security context is available to allow impersonation.", "RPC_NT_NO_CONTEXT_AVAILABLE", 0xC0020042 },
      {"An internal error occurred in RPC.", "RPC_NT_INTERNAL_ERROR", 0xC0020043 },
      {"The RPC server attempted an integer divide by zero.", "RPC_NT_ZERO_DIVIDE", 0xC0020044 },
      {"An addressing error occurred in the RPC server.", "RPC_NT_ADDRESS_ERROR", 0xC0020045 },
      {"A floating point operation at the RPC server caused a divide by zero.", "RPC_NT_FP_DIV_ZERO", 0xC0020046 },
      {"A floating point underflow occurred at the RPC server.", "RPC_NT_FP_UNDERFLOW", 0xC0020047 },
      {"A floating point overflow occurred at the RPC server.", "RPC_NT_FP_OVERFLOW", 0xC0020048 },
      {"The list of RPC servers available for auto-handle binding has been exhausted.", "RPC_NT_NO_MORE_ENTRIES", 0xC0030001 },
      {"The file designated by DCERPCCHARTRANS cannot be opened.", "RPC_NT_SS_CHAR_TRANS_OPEN_FAIL", 0xC0030002 },
      {"The file containing the character translation table has fewer than 512 bytes.", "RPC_NT_SS_CHAR_TRANS_SHORT_FILE", 0xC0030003 },
      {"A null context handle is passed as an [in] parameter.", "RPC_NT_SS_IN_NULL_CONTEXT", 0xC0030004 },
      {"The context handle does not match any known context handles.", "RPC_NT_SS_CONTEXT_MISMATCH", 0xC0030005 },
      {"The context handle changed during a call.", "RPC_NT_SS_CONTEXT_DAMAGED", 0xC0030006 },
      {"The binding handles passed to a remote procedure call do not match.", "RPC_NT_SS_HANDLES_MISMATCH", 0xC0030007 },
      {"The stub is unable to get the call handle.", "RPC_NT_SS_CANNOT_GET_CALL_HANDLE", 0xC0030008 },
      {"A null reference pointer was passed to the stub.", "RPC_NT_NULL_REF_POINTER", 0xC0030009 },
      {"The enumeration value is out of range.", "RPC_NT_ENUM_VALUE_OUT_OF_RANGE", 0xC003000A },
      {"The byte count is too small.", "RPC_NT_BYTE_COUNT_TOO_SMALL", 0xC003000B },
      {"The stub received bad data.", "RPC_NT_BAD_STUB_DATA", 0xC003000C },
      {"A remote procedure call is already in progress for this thread.", "RPC_NT_CALL_IN_PROGRESS", 0xC0020049 },
      {"There are no more bindings.", "RPC_NT_NO_MORE_BINDINGS", 0xC002004A },
      {"The group member was not found.", "RPC_NT_GROUP_MEMBER_NOT_FOUND", 0xC002004B },
      {"The endpoint mapper database entry could not be created.", "EPT_NT_CANT_CREATE", 0xC002004C },
      {"The object UUID is the nil UUID.", "RPC_NT_INVALID_OBJECT", 0xC002004D },
      {"No interfaces have been registered.", "RPC_NT_NO_INTERFACES", 0xC002004F },
      {"The remote procedure call was cancelled.", "RPC_NT_CALL_CANCELLED", 0xC0020050 },
      {"The binding handle does not contain all required information.", "RPC_NT_BINDING_INCOMPLETE", 0xC0020051 },
      {"A communications failure occurred during a remote procedure call.", "RPC_NT_COMM_FAILURE", 0xC0020052 },
      {"The requested authentication level is not supported.", "RPC_NT_UNSUPPORTED_AUTHN_LEVEL", 0xC0020053 },
      {"No principal name registered.", "RPC_NT_NO_PRINC_NAME", 0xC0020054 },
      {"The error specified is not a valid Windows RPC error code.", "RPC_NT_NOT_RPC_ERROR", 0xC0020055 },
      {"A UUID that is valid only on this computer has been allocated.", "RPC_NT_UUID_LOCAL_ONLY", 0x40020056 },
      {"A security package specific error occurred.", "RPC_NT_SEC_PKG_ERROR", 0xC0020057 },
      {"Thread is not cancelled.", "RPC_NT_NOT_CANCELLED", 0xC0020058 },
      {"Invalid operation on the encoding/decoding handle.", "RPC_NT_INVALID_ES_ACTION", 0xC0030059 },
      {"Incompatible version of the serializing package.", "RPC_NT_WRONG_ES_VERSION", 0xC003005A },
      {"Incompatible version of the RPC stub.", "RPC_NT_WRONG_STUB_VERSION", 0xC003005B },
      {"The RPC pipe object is invalid or corrupted.", "RPC_NT_INVALID_PIPE_OBJECT", 0xC003005C },
      {"An invalid operation was attempted on an RPC pipe object.", "RPC_NT_INVALID_PIPE_OPERATION", 0xC003005D },
      {"Unsupported RPC pipe version.", "RPC_NT_WRONG_PIPE_VERSION", 0xC003005E },
      {"The RPC pipe object has already been closed.", "RPC_NT_PIPE_CLOSED", 0xC003005F },
      {"The RPC call completed before all pipes were processed.", "RPC_NT_PIPE_DISCIPLINE_ERROR", 0xC0030060 },
      {"No more data is available from the RPC pipe.", "RPC_NT_PIPE_EMPTY", 0xC0030061 },
      {"Invalid asynchronous remote procedure call handle.", "RPC_NT_INVALID_ASYNC_HANDLE", 0xC0020062 },
      {"Invalid asynchronous RPC call handle for this operation.", "RPC_NT_INVALID_ASYNC_CALL", 0xC0020063 },
      {"Some data remains to be sent in the request buffer.", "RPC_NT_SEND_INCOMPLETE", 0x400200AF },
      {"An attempt was made to run an invalid AML opcode", "STATUS_ACPI_INVALID_OPCODE", 0xC0140001 },
      {"The AML Interpreter Stack has overflowed", "STATUS_ACPI_STACK_OVERFLOW", 0xC0140002 },
      {"An inconsistent state has occurred", "STATUS_ACPI_ASSERT_FAILED", 0xC0140003 },
      {"An attempt was made to access an array outside of its bounds", "STATUS_ACPI_INVALID_INDEX", 0xC0140004 },
      {"A required argument was not specified", "STATUS_ACPI_INVALID_ARGUMENT", 0xC0140005 },
      {"A fatal error has occurred", "STATUS_ACPI_FATAL", 0xC0140006 },
      {"An invalid SuperName was specified", "STATUS_ACPI_INVALID_SUPERNAME", 0xC0140007 },
      {"An argument with an incorrect type was specified", "STATUS_ACPI_INVALID_ARGTYPE", 0xC0140008 },
      {"An object with an incorrect type was specified", "STATUS_ACPI_INVALID_OBJTYPE", 0xC0140009 },
      {"A target with an incorrect type was specified", "STATUS_ACPI_INVALID_TARGETTYPE", 0xC014000A },
      {"An incorrect number of arguments were specified", "STATUS_ACPI_INCORRECT_ARGUMENT_COUNT", 0xC014000B },
      {"An address failed to translate", "STATUS_ACPI_ADDRESS_NOT_MAPPED", 0xC014000C },
      {"An incorrect event type was specified", "STATUS_ACPI_INVALID_EVENTTYPE", 0xC014000D },
      {"A handler for the target already exists", "STATUS_ACPI_HANDLER_COLLISION", 0xC014000E },
      {"Invalid data for the target was specified", "STATUS_ACPI_INVALID_DATA", 0xC014000F },
      {"An invalid region for the target was specified", "STATUS_ACPI_INVALID_REGION", 0xC0140010 },
      {"An attempt was made to access a field outside of the defined range", "STATUS_ACPI_INVALID_ACCESS_SIZE", 0xC0140011 },
      {"The Global system lock could not be acquired", "STATUS_ACPI_ACQUIRE_GLOBAL_LOCK", 0xC0140012 },
      {"An attempt was made to reinitialize the ACPI subsystem", "STATUS_ACPI_ALREADY_INITIALIZED", 0xC0140013 },
      {"The ACPI subsystem has not been initialized", "STATUS_ACPI_NOT_INITIALIZED", 0xC0140014 },
      {"An incorrect mutex was specified", "STATUS_ACPI_INVALID_MUTEX_LEVEL", 0xC0140015 },
      {"The mutex is not currently owned", "STATUS_ACPI_MUTEX_NOT_OWNED", 0xC0140016 },
      {"An attempt was made to access the mutex by a process that was not the owner", "STATUS_ACPI_MUTEX_NOT_OWNER", 0xC0140017 },
      {"An error occurred during an access to Region Space", "STATUS_ACPI_RS_ACCESS", 0xC0140018 },
      {"An attempt was made to use an incorrect table", "STATUS_ACPI_INVALID_TABLE", 0xC0140019 },
      {"The registration of an ACPI event failed", "STATUS_ACPI_REG_HANDLER_FAILED", 0xC0140020 },
      {"An ACPI Power Object failed to transition state", "STATUS_ACPI_POWER_REQUEST_FAILED", 0xC0140021 },
      {"Session name %1 is invalid.", "STATUS_CTX_WINSTATION_NAME_INVALID", 0xC00A0001 },
      {"The protocol driver %1 is invalid.", "STATUS_CTX_INVALID_PD", 0xC00A0002 },
      {"The protocol driver %1 was not found in the system path.", "STATUS_CTX_PD_NOT_FOUND", 0xC00A0003 },
      {"The Client Drive Mapping Service Has Connected on Terminal Connection.", "STATUS_CTX_CDM_CONNECT", 0x400A0004 },
      {"The Client Drive Mapping Service Has Disconnected on Terminal Connection.", "STATUS_CTX_CDM_DISCONNECT", 0x400A0005 },
      {"A close operation is pending on the Terminal Connection.", "STATUS_CTX_CLOSE_PENDING", 0xC00A0006 },
      {"There are no free output buffers available.", "STATUS_CTX_NO_OUTBUF", 0xC00A0007 },
      {"The MODEM.INF file was not found.", "STATUS_CTX_MODEM_INF_NOT_FOUND", 0xC00A0008 },
      {"The modem (%1) was not found in MODEM.INF.", "STATUS_CTX_INVALID_MODEMNAME", 0xC00A0009 },
      {"The modem did not accept the command sent to it.Verify the configured modem name matches the attached modem.", "STATUS_CTX_RESPONSE_ERROR", 0xC00A000A },
      {"The modem did not respond to the command sent to it.Verify the modem is properly cabled and powered on.", "STATUS_CTX_MODEM_RESPONSE_TIMEOUT", 0xC00A000B },
      {"Carrier detect has failed or carrier has been dropped due to disconnect.", "STATUS_CTX_MODEM_RESPONSE_NO_CARRIER", 0xC00A000C },
      {"Dial tone not detected within required time.Verify phone cable is properly attached and functional.", "STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE", 0xC00A000D },
      {"Busy signal detected at remote site on callback.", "STATUS_CTX_MODEM_RESPONSE_BUSY", 0xC00A000E },
      {"Voice detected at remote site on callback.", "STATUS_CTX_MODEM_RESPONSE_VOICE", 0xC00A000F },
      {"Transport driver error", "STATUS_CTX_TD_ERROR", 0xC00A0010 },
      {"The client you are using is not licensed to use this system. Your logon request is denied.", "STATUS_CTX_LICENSE_CLIENT_INVALID", 0xC00A0012 },
      {"The system has reached its licensed logon limit.Please try again later.", "STATUS_CTX_LICENSE_NOT_AVAILABLE", 0xC00A0013 },
      {"The system license has expired. Your logon request is denied.", "STATUS_CTX_LICENSE_EXPIRED", 0xC00A0014 },
      {"The specified session cannot be found.", "STATUS_CTX_WINSTATION_NOT_FOUND", 0xC00A0015 },
      {"The specified session name is already in use.", "STATUS_CTX_WINSTATION_NAME_COLLISION", 0xC00A0016 },
      {"The requested operation cannot be completed because the Terminal Connection is currently busy processing a connect, disconnect, reset, or delete operation.", "STATUS_CTX_WINSTATION_BUSY", 0xC00A0017 },
      {"An attempt has been made to connect to a session whose video mode is not supported by the current client.", "STATUS_CTX_BAD_VIDEO_MODE", 0xC00A0018 },
      {"The application attempted to enable DOS graphics mode.DOS graphics mode is not supported.", "STATUS_CTX_GRAPHICS_INVALID", 0xC00A0022 },
      {"The requested operation can be performed only on the system console.This is most often the result of a driver or system DLL requiring direct console access.", "STATUS_CTX_NOT_CONSOLE", 0xC00A0024 },
      {"The client failed to respond to the server connect message.", "STATUS_CTX_CLIENT_QUERY_TIMEOUT", 0xC00A0026 },
      {"Disconnecting the console session is not supported.", "STATUS_CTX_CONSOLE_DISCONNECT", 0xC00A0027 },
      {"Reconnecting a disconnected session to the console is not supported.", "STATUS_CTX_CONSOLE_CONNECT", 0xC00A0028 },
      {"The request to control another session remotely was denied.", "STATUS_CTX_SHADOW_DENIED", 0xC00A002A },
      {"A process has requested access to a session, but has not been granted those access rights.", "STATUS_CTX_WINSTATION_ACCESS_DENIED", 0xC00A002B },
      {"The Terminal Connection driver %1 is invalid.", "STATUS_CTX_INVALID_WD", 0xC00A002E },
      {"The Terminal Connection driver %1 was not found in the system path.", "STATUS_CTX_WD_NOT_FOUND", 0xC00A002F },
      {"The requested session cannot be controlled remotely.You cannot control your own session, a session that is trying to control your session,a session that has no user logged on, nor control other sessions from the console.", "STATUS_CTX_SHADOW_INVALID", 0xC00A0030 },
      {"The requested session is not configured to allow remote control.", "STATUS_CTX_SHADOW_DISABLED", 0xC00A0031 },
      {"The RDP protocol component %2 detected an error in the protocol stream and has disconnected the client.", "STATUS_RDP_PROTOCOL_ERROR", 0xC00A0032 },
      {"Your request to connect to this Terminal server has been rejected.Your Terminal Server Client license number has not been entered for this copy of the Terminal Client.Please call your system administrator for help in entering a valid, unique license number for this Terminal Server Client.Click OK to continue.", "STATUS_CTX_CLIENT_LICENSE_NOT_SET", 0xC00A0033 },
      {"Your request to connect to this Terminal server has been rejected.Your Terminal Server Client license number is currently being used by another user.Please call your system administrator to obtain a new copy of the Terminal Server Client with a valid, unique license number.Click OK to continue.", "STATUS_CTX_CLIENT_LICENSE_IN_USE", 0xC00A0034 },
      {"The remote control of the console was terminated because the display mode was changed. Changing the display mode in a remote control session is not supported.", "STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE", 0xC00A0035 },
      {"Remote control could not be terminated because the specified session is not currently being remotely controlled.", "STATUS_CTX_SHADOW_NOT_RUNNING", 0xC00A0036 },
      {"A device is missing in the system BIOS MPS table. This device will not be used.Please contact your system vendor for system BIOS update.", "STATUS_PNP_BAD_MPS_TABLE", 0xC0040035 },
      {"A translator failed to translate resources.", "STATUS_PNP_TRANSLATION_FAILED", 0xC0040036 },
      {"A IRQ translator failed to translate resources.", "STATUS_PNP_IRQ_TRANSLATION_FAILED", 0xC0040037 },
      {"Driver %2 returned invalid ID for a child device (%3).", "STATUS_PNP_INVALID_ID", 0xC0040038 },
      {"The requested section is not present in the activation context.", "STATUS_SXS_SECTION_NOT_FOUND", 0xC0150001 },
      {"Windows was not able to process the application binding information.Please refer to your System Event Log for further information.", "STATUS_SXS_CANT_GEN_ACTCTX", 0xC0150002 },
      {"The application binding data format is invalid.", "STATUS_SXS_INVALID_ACTCTXDATA_FORMAT", 0xC0150003 },
      {"The referenced assembly is not installed on your system.", "STATUS_SXS_ASSEMBLY_NOT_FOUND", 0xC0150004 },
      {"The manifest file does not begin with the required tag and format information.", "STATUS_SXS_MANIFEST_FORMAT_ERROR", 0xC0150005 },
      {"The manifest file contains one or more syntax errors.", "STATUS_SXS_MANIFEST_PARSE_ERROR", 0xC0150006 },
      {"The application attempted to activate a disabled activation context.", "STATUS_SXS_ACTIVATION_CONTEXT_DISABLED", 0xC0150007 },
      {"The requested lookup key was not found in any active activation context.", "STATUS_SXS_KEY_NOT_FOUND", 0xC0150008 },
      {"A component version required by the application conflicts with another component version already active.", "STATUS_SXS_VERSION_CONFLICT", 0xC0150009 },
      {"The type requested activation context section does not match the query API used.", "STATUS_SXS_WRONG_SECTION_TYPE", 0xC015000A },
      {"Lack of system resources has required isolated activation to be disabled for the current thread of execution.", "STATUS_SXS_THREAD_QUERIES_DISABLED", 0xC015000B },
      {"The referenced assembly could not be found.", "STATUS_SXS_ASSEMBLY_MISSING", 0xC015000C },
      {"A kernel mode component is releasing a reference on an activation context.", "STATUS_SXS_RELEASE_ACTIVATION_CONTEXT", 0x4015000D },
      {"An attempt to set the process default activation context failed because the process default activation context was already set.", "STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET", 0xC015000E },
      {"The activation context being deactivated is not the most recently activated one.", "STATUS_SXS_EARLY_DEACTIVATION", 0xC015000F },
      {"The activation context being deactivated is not active for the current thread of execution.", "STATUS_SXS_INVALID_DEACTIVATION", 0xC0150010 },
      {"The activation context being deactivated has already been deactivated.", "STATUS_SXS_MULTIPLE_DEACTIVATION", 0xC0150011 },
      {"The activation context of system default assembly could not be generated.", "STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY", 0xC0150012 },
      {"A component used by the isolation facility has requested to terminate the process.", "STATUS_SXS_PROCESS_TERMINATION_REQUESTED", 0xC0150013 },
      {"The activation context activation stack for the running thread of execution is corrupt.", "STATUS_SXS_CORRUPT_ACTIVATION_STACK", 0xC0150014 },
      {"The application isolation metadata for this process or thread has become corrupt.", "STATUS_SXS_CORRUPTION", 0xC0150015 },
      {"The cluster node is not valid.", "STATUS_CLUSTER_INVALID_NODE", 0xC0130001 },
      {"The cluster node already exists.", "STATUS_CLUSTER_NODE_EXISTS", 0xC0130002 },
      {"A node is in the process of joining the cluster.", "STATUS_CLUSTER_JOIN_IN_PROGRESS", 0xC0130003 },
      {"The cluster node was not found.", "STATUS_CLUSTER_NODE_NOT_FOUND", 0xC0130004 },
      {"The cluster local node information was not found.", "STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND", 0xC0130005 },
      {"The cluster network already exists.", "STATUS_CLUSTER_NETWORK_EXISTS", 0xC0130006 },
      {"The cluster network was not found.", "STATUS_CLUSTER_NETWORK_NOT_FOUND", 0xC0130007 },
      {"The cluster network interface already exists.", "STATUS_CLUSTER_NETINTERFACE_EXISTS", 0xC0130008 },
      {"The cluster network interface was not found.", "STATUS_CLUSTER_NETINTERFACE_NOT_FOUND", 0xC0130009 },
      {"The cluster request is not valid for this object.", "STATUS_CLUSTER_INVALID_REQUEST", 0xC013000A },
      {"The cluster network provider is not valid.", "STATUS_CLUSTER_INVALID_NETWORK_PROVIDER", 0xC013000B },
      {"The cluster node is down.", "STATUS_CLUSTER_NODE_DOWN", 0xC013000C },
      {"The cluster node is not reachable.", "STATUS_CLUSTER_NODE_UNREACHABLE", 0xC013000D },
      {"The cluster node is not a member of the cluster.", "STATUS_CLUSTER_NODE_NOT_MEMBER", 0xC013000E },
      {"A cluster join operation is not in progress.", "STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS", 0xC013000F },
      {"The cluster network is not valid.", "STATUS_CLUSTER_INVALID_NETWORK", 0xC0130010 },
      {"No network adapters are available.", "STATUS_CLUSTER_NO_NET_ADAPTERS", 0xC0130011 },
      {"The cluster node is up.", "STATUS_CLUSTER_NODE_UP", 0xC0130012 },
      {"The cluster node is paused.", "STATUS_CLUSTER_NODE_PAUSED", 0xC0130013 },
      {"The cluster node is not paused.", "STATUS_CLUSTER_NODE_NOT_PAUSED", 0xC0130014 },
      {"No cluster security context is available.", "STATUS_CLUSTER_NO_SECURITY_CONTEXT", 0xC0130015 },
      {"The cluster network is not configured for internal cluster communication.", "STATUS_CLUSTER_NETWORK_NOT_INTERNAL", 0xC0130016 },
      {"The cluster node has been poisoned.", "STATUS_CLUSTER_POISONED", 0xC0130017 },
      {"Log service found an invalid log sector.", "STATUS_LOG_SECTOR_INVALID", 0xC01A0001 },
      {"Log service encountered a log sector with invalid block parity.", "STATUS_LOG_SECTOR_PARITY_INVALID", 0xC01A0002 },
      {"Log service encountered a remapped log sector.", "STATUS_LOG_SECTOR_REMAPPED", 0xC01A0003 },
      {"Log service encountered a partial or incomplete log block.", "STATUS_LOG_BLOCK_INCOMPLETE", 0xC01A0004 },
      {"Log service encountered an attempt access data outside the active log range.", "STATUS_LOG_INVALID_RANGE", 0xC01A0005 },
      {"Log service user log marshalling buffers are exhausted.", "STATUS_LOG_BLOCKS_EXHAUSTED", 0xC01A0006 },
      {"Log service encountered an attempt read from a marshalling area with an invalid read context.", "STATUS_LOG_READ_CONTEXT_INVALID", 0xC01A0007 },
      {"Log service encountered an invalid log restart area.", "STATUS_LOG_RESTART_INVALID", 0xC01A0008 },
      {"Log service encountered an invalid log block version.", "STATUS_LOG_BLOCK_VERSION", 0xC01A0009 },
      {"Log service encountered an invalid log block.", "STATUS_LOG_BLOCK_INVALID", 0xC01A000A },
      {"Log service encountered an attempt to read the log with an invalid read mode.", "STATUS_LOG_READ_MODE_INVALID", 0xC01A000B },
      {"Log service encountered a log stream with no restart area.", "STATUS_LOG_NO_RESTART", 0x401A000C },
      {"Log service encountered a corrupted metadata file.", "STATUS_LOG_METADATA_CORRUPT", 0xC01A000D },
      {"Log service encountered a metadata file that could not be created by the log file system.", "STATUS_LOG_METADATA_INVALID", 0xC01A000E },
      {"Log service encountered a metadata file with inconsistent data.", "STATUS_LOG_METADATA_INCONSISTENT", 0xC01A000F },
      {"Log service encountered an attempt to erroneously allocate or dispose reservation space.", "STATUS_LOG_RESERVATION_INVALID", 0xC01A0010 },
      {"Log service cannot delete log file or file system container.", "STATUS_LOG_CANT_DELETE", 0xC01A0011 },
      {"Log service has reached the maximum allowable containers allocated to a log file.", "STATUS_LOG_CONTAINER_LIMIT_EXCEEDED", 0xC01A0012 },
      {"Log service has attempted to read or write backwards past the start of the log.", "STATUS_LOG_START_OF_LOG", 0xC01A0013 },
      {"Log policy could not be installed because a policy of the same type is already present.", "STATUS_LOG_POLICY_ALREADY_INSTALLED", 0xC01A0014 },
      {"Log policy in question was not installed at the time of the request.", "STATUS_LOG_POLICY_NOT_INSTALLED", 0xC01A0015 },
      {"The installed set of policies on the log is invalid.", "STATUS_LOG_POLICY_INVALID", 0xC01A0016 },
      {"A policy on the log in question prevented the operation from completing.", "STATUS_LOG_POLICY_CONFLICT", 0xC01A0017 },
      {"Log space cannot be reclaimed because the log is pinned by the archive tail.", "STATUS_LOG_PINNED_ARCHIVE_TAIL", 0xC01A0018 },
      {"Log record is not a record in the log file.", "STATUS_LOG_RECORD_NONEXISTENT", 0xC01A0019 },
      {"Number of reserved log records or the adjustment of the number of reserved log records is invalid.", "STATUS_LOG_RECORDS_RESERVED_INVALID", 0xC01A001A },
      {"Reserved log space or the adjustment of the log space is invalid.", "STATUS_LOG_SPACE_RESERVED_INVALID", 0xC01A001B },
      {"A new or existing archive tail or base of the active log is invalid.", "STATUS_LOG_TAIL_INVALID", 0xC01A001C },
      {"Log space is exhausted.", "STATUS_LOG_FULL", 0xC01A001D },
      {"The log could not be set to the requested size.", "STATUS_COULD_NOT_RESIZE_LOG", 0x80190009 },
	{NULL, NULL, 0},
	};

```

`source/WispSyser/othercmd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "syserdefine.hpp"
#include "othercmd.hpp"

int resize_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	int width;
	int height;
	if (argc == 1)
	{
		width = gpSyser->DesktopSize.cx;
		height = gpSyser->DesktopSize.cy;
	} else
	if (argc != 3 || !USDecStrToNum(argv[1], &width) || !USDecStrToNum(argv[1], &height))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : ws width height\n"));
		return 1;
	}

	if (width > 2048 || height > 1536)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : window is too larger !\n"));
		return 1;
	}

	if (width < 320 || height < 200)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : window is too smaller !\n"));
		return 1;
	}
	gpSyser->m_MainFrame.Resize(width, height, 1);
	return 0;
}

int lines_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc == 1)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : lines number\n"));
		return 0;
	}

	unsigned int lines;
	if (argc == 2 && USDecStrToNum(argv[1], &lines))
	{
		lines *= gpSyser->m_FontList[1].m_Height;
		if (lines >= gpSyser->DesktopSize.cy) //MAX_LIMIT
			lines = gpSyser->DesktopSize.cy;
		gpSyser->m_MainFrame.Resize(gpSyser->m_MainFrame.m_WindowRect.cx, lines, 1);
	} else
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : lines number\n"));
	}
	return 0;
}

int width_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc == 1)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : width number\n"));
		return 0;
	}

	unsigned int width;
	if (argc == 2 && USDecStrToNum(argv[1], &width))
	{
		width *= gpSyser->m_FontList[1].m_Width;
		if (width >= gpSyser->DesktopSize.cx) //MAX_LIMIT
			width = gpSyser->DesktopSize.cx;
		gpSyser->m_MainFrame.Resize(width, gpSyser->m_MainFrame.m_WindowRect.cy, 1);
	} else
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : width number\n"));
	}
	return 0;
}

int ioctl_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	WCHAR DeviceType[50];

	if (argc == 1)
	{
		for (unsigned long n = 0; stIoctlList[n].Name; ++n)
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%08X "), stIoctlList[n].ControlCode);
			TStrCpy(DeviceType, stIoctlList[n].Name);
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("FILE_DEVICE_"));
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%s"), DeviceType);
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
		}
	} else
	{
		const char *szFileDevices[0x5C+1];
		szFileDevices[0] = NULL;
		szFileDevices[1] = "BEEP";
		szFileDevices[2] = "CD_ROM";
		szFileDevices[3] = "CD_ROM_FILE_SYSTEM";
		szFileDevices[4] = "CONTROLLER";
		szFileDevices[5] = "DATALINK";
		szFileDevices[6] = "DFS";
		szFileDevices[7] = "DISK";
		szFileDevices[8] = "DISK_FILE_SYSTEM";
		szFileDevices[9] = "FILE_SYSTEM";
		szFileDevices[0xA] = "INPORT_PORT";
		szFileDevices[0xB] = "KEYBOARD";
		szFileDevices[0xC] = "MAILSLOT";
		szFileDevices[0xD] = "MIDI_IN";
		szFileDevices[0xE] = "MIDI_OUT";
		szFileDevices[0xF] = "MOUSE";
		szFileDevices[0x10] = "MULTI_UNC_PROVIDER";
		szFileDevices[0x11] = "NAMED_PIPE";
		szFileDevices[0x12] = "NETWORK";
		szFileDevices[0x13] = "NETWORK_BROWSER";
		szFileDevices[0x14] = "NETWORK_FILE_SYSTEM";
		szFileDevices[0x15] = "NULL";
		szFileDevices[0x16] = "PARALLEL_PORT";
		szFileDevices[0x17] = "PHYSICAL_NETCARD";
		szFileDevices[0x18] = "PRINTER";
		szFileDevices[0x19] = "SCANNER";
		szFileDevices[0x1A] = "SERIAL_MOUSE_PORT";
		szFileDevices[0x1B] = "SERIAL_PORT";
		szFileDevices[0x1C] = "SCREEN";
		szFileDevices[0x1D] = "SOUND";
		szFileDevices[0x1E] = "STREAMS";
		szFileDevices[0x1F] = "TAPE";
		szFileDevices[0x20] = "TAPE_FILE_SYSTEM";
		szFileDevices[0x21] = "TRANSPORT";
		szFileDevices[0x22] = "UNKNOWN";
		szFileDevices[0x23] = "VIDEO";
		szFileDevices[0x24] = "VIRTUAL_DISK";
		szFileDevices[0x25] = "WAVE_IN";
		szFileDevices[0x26] = "WAVE_OUT";
		szFileDevices[0x27] = "8042_PORT";
		szFileDevices[0x28] = "NETWORK_REDIRECTOR";
		szFileDevices[0x29] = "BATTERY";
		szFileDevices[0x2A] = "BUS_EXTENDER";
		szFileDevices[0x2B] = "MODEM";
		szFileDevices[0x2C] = "VDM";
		szFileDevices[0x2D] = "MASS_STORAGE";
		szFileDevices[0x2E] = "SMB";
		szFileDevices[0x2F] = "KS";
		szFileDevices[0x30] = "CHANGER";
		szFileDevices[0x31] = "SMARTCARD";
		szFileDevices[0x32] = "ACPI";
		szFileDevices[0x33] = "DVD";
		szFileDevices[0x34] = "FULLSCREEN_VIDEO";
		szFileDevices[0x35] = "DFS_FILE_SYSTEM";
		szFileDevices[0x36] = "DFS_VOLUME";
		szFileDevices[0x37] = "SERENUM";
		szFileDevices[0x38] = "TERMSRV";
		szFileDevices[0x39] = "KSEC";
		szFileDevices[0x3A] = "FIPS";
		szFileDevices[0x3B] = "INFINIBAND";

		szFileDevices[0x3C] = NULL;
		szFileDevices[0x3D] = NULL;
		szFileDevices[0x3E] = "VMBUS";
		szFileDevices[0x3F] = "CRYPT_PROVIDER";
		szFileDevices[0x40] = "WPD";
		szFileDevices[0x41] = "BLUETOOTH";
		szFileDevices[0x42] = "MT_COMPOSITE";
		szFileDevices[0x43] = "MT_TRANSPORT";
		szFileDevices[0x44] = "BIOMETRIC";
		szFileDevices[0x45] = "PMI";
		szFileDevices[0x46] = "EHSTOR";
		szFileDevices[0x47] = "DEVAPI";
		szFileDevices[0x48] = "GPIO";
		szFileDevices[0x49] = "USBEX";
		szFileDevices[0x4A] = NULL;
		szFileDevices[0x4B] = NULL;
		szFileDevices[0x4C] = NULL;
		szFileDevices[0x4D] = NULL;
		szFileDevices[0x4E] = NULL;
		szFileDevices[0x4F] = NULL;
		szFileDevices[0x50] = "CONSOLE";
		szFileDevices[0x51] = "NFP";
		szFileDevices[0x52] = "SYSENV";
		szFileDevices[0x53] = "VIRTUAL_BLOCK";
		szFileDevices[0x54] = "POINT_OF_SERVICE";
		szFileDevices[0x55] = "STORAGE_REPLICATION";
		szFileDevices[0x56] = "TRUST_ENV";
		szFileDevices[0x57] = "UCM";
		szFileDevices[0x58] = "UCMTCPCI";
		szFileDevices[0x59] = "PERSISTENT_MEMORY";
		szFileDevices[0x5A] = "NVDIMM";
		szFileDevices[0x5B] = "HOLOGRAPHIC";
		szFileDevices[0x5C] = "SDFXHCI";

		for (unsigned long i = 1; i < argc; ++i)
		{
			ULONG_PTR ControlCode = 0;
			if (!gpSyser->m_SyserUI.CalcExp(argv[i], &ControlCode))
			{
				char szFileDevice[125];
				memset(szFileDevice, 0, sizeof(szFileDevice));
				TStrCpy(szFileDevice, "FILE_DEVICE_");
				unsigned long n = 0;
				for ( ; stIoctlList[n].Name; ++n)
				{
					TStrCpy(&szFileDevice[sizeof("FILE_DEVICE_")-1], stIoctlList[n].Name);
					if (TStrIStr(szFileDevice, argv[i])) break;
				}
				if (!stIoctlList[n].Name) continue;
				ControlCode = stIoctlList[n].ControlCode;
			}

			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("    Control Code:  %08x "), ControlCode);
			for (unsigned long n = 0; stIoctlList[n].Name; ++n)
			{
				if (stIoctlList[n].ControlCode == ControlCode)
				{
					TStrCpy(DeviceType, stIoctlList[n].Name);
					gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%s"), DeviceType);
					break;
				}
			}

			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
			if (ControlCode & 0x80000000)
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("    Device Type:   %x(vendor-assigned) "), (ControlCode | 0x8000FFFF) >> 16);
			} else
			{
				unsigned long d = (ControlCode >> 16) & 0x7FFF;
				if (d && d < (0x3B+1))//lenof(szFileDevices)) //<= 59 //TODO
				{
					TStrCpy(DeviceType, "FILE_DEVICE_");
					TStrCat(DeviceType, szFileDevices[d]);
					gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("    Device Type:   %s"), DeviceType);
				} else
				{
					gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("    Device Type:   %x(Microsoft reserved)"), d);
				}
			}
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n    Function:      "));
			if (ControlCode & 0x2000)
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("0x%x (%d) "), (ControlCode & 0x1FFC | 0x2000) >> 2, (ControlCode & 0x1FFC | 0x2000) >> 2);
			else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("0x%x (%d)(Microsoft Reserved) "), (ControlCode >> 2) & 0x7FF, (ControlCode >> 2) & 0x7FF);
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n    Method:        "));
			switch (ControlCode & 3)
			{
			case 0:
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("METHOD_BUFFERED "));
				break;
			case 1:
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("METHOD_IN_DIRECT "));
				break;
			case 2:
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("METHOD_OUT_DIRECT "));
				break;
			case 3:
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("METHOD_NEITHER "));
				break;
			}
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n    Access:        "));
			switch ( (unsigned short)(ControlCode >> 14))
			{
			case 0:
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("FILE_ANY_ACCESS "));
				break;
			case 1:
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("FILE_READ_ACCESS "));
				break;
			case 2:
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("FILE_WRITE_ACCESS "));
				break;
			case 3:
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("FILE_READ_ACCESS|FILE_WRITE_ACCESS "));
				break;
			}
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
		}
	}
	return 1;
}

int ntstatus_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	unsigned long Count = 0;
	if (argc == 1)
	{
		for (unsigned long n = 0; stNtStatusList[n].MsgName; ++n)
		{
			WCHAR MsgName[256];
			TStrCpy(MsgName, stNtStatusList[n].MsgName);
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("0X%08x  %s\n"), stNtStatusList[n].MsgNumber, MsgName);
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("totals (%<e>%d%<1>)\n"), Count);
	} else
	if (argc > 1)
	{
		--argc;
		++argv;
		while (argc>0)
		{
			ULONG_PTR Result;
			if (gpSyser->m_SyserUI.CalcExp(argv[0], &Result))
			{
		for (unsigned long n = 0; stNtStatusList[n].MsgName; ++n)
		{
			if (stNtStatusList[n].MsgNumber == Result)
			{
				WCHAR MsgName[256];
				TStrCpy(MsgName, stNtStatusList[n].MsgName);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("0X%08x  %<b>%s "), stNtStatusList[n].MsgNumber, MsgName);
				TStrCpy(MsgName, stNtStatusList[n].MsgDesc);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
				++Count;
			}
		}
			} else
			{
		for (unsigned long n = 0; stNtStatusList[n].MsgName; ++n)
		{
			if (!TStrNICmp(argv[0], stNtStatusList[n].MsgName, TStrLen(argv[0])))
			{
				WCHAR MsgName[256];
				TStrCpy(MsgName, stNtStatusList[n].MsgName);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<b>0X%08x  %<1>%s "), stNtStatusList[n].MsgNumber, MsgName);
				TStrCpy(MsgName, stNtStatusList[n].MsgDesc);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
			}
		}
			}
			++argv;
			--argc;
		}
		if (Count)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("totals (%<e>%d%<1>)\n"), Count);
	}
	return 0;
}

int winerror_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	unsigned long Count = 0;
	if (argc == 1)
	{
		for (unsigned long n = 0; stWinErrorList[n].MsgName; ++n)
		{
			WCHAR MsgName[256];
			TStrCpy(MsgName, stWinErrorList[n].MsgName);
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("0X%08x  %s\n"), stWinErrorList[n].MsgNumber, MsgName);
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("totals (%<e>%d%<1>)\n"), Count);
	} else
	if (argc > 1)
	{
		--argc;
		++argv;
		while (argc>0)
		{
			ULONG_PTR Result;
			if (gpSyser->m_SyserUI.CalcExp(argv[0], &Result))
			{
		for (unsigned long n = 0; stWinErrorList[n].MsgName; ++n)
		{
			if (stWinErrorList[n].MsgNumber == Result)
			{
				WCHAR MsgName[256];
				TStrCpy(MsgName, stWinErrorList[n].MsgName);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("0X%08x  %<b>%s "), stWinErrorList[n].MsgNumber, MsgName);
				TStrCpy(MsgName, stWinErrorList[n].MsgDesc);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
				++Count;
			}
		}
			} else
			{
		for (unsigned long n = 0; stWinErrorList[n].MsgName; ++n)
		{
			if (!TStrNICmp(argv[0], stWinErrorList[n].MsgName, TStrLen(argv[0])))
			{
				WCHAR MsgName[256];
				TStrCpy(MsgName, stWinErrorList[n].MsgName);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<b>0X%08x  %<1>%s "), stWinErrorList[n].MsgNumber, MsgName);
				TStrCpy(MsgName, stWinErrorList[n].MsgDesc);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
			}
		}
			}
			++argv;
			--argc;
		}
		if (Count)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("totals (%<e>%d%<1>)\n"), Count);
	}
	return 0;
}

int bugcheckcode_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	unsigned long Count = 0;
	if (argc == 1)
	{
		for (unsigned long n = 0; stBugCheckCodeList[n].MsgName; ++n)
		{
			WCHAR MsgName[256];
			TStrCpy(MsgName, stBugCheckCodeList[n].MsgName);
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("0X%08x  %s\n"), stBugCheckCodeList[n].MsgNumber, MsgName);
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("totals (%<e>%d%<1>)\n"), Count);
	} else
	if (argc > 1)
	{
		--argc;
		++argv;
		while (argc>0)
		{
			ULONG_PTR Result;
			if (gpSyser->m_SyserUI.CalcExp(argv[0], &Result))
			{
		for (unsigned long n = 0; stBugCheckCodeList[n].MsgName; ++n)
		{
			if (stBugCheckCodeList[n].MsgNumber == Result)
			{
				WCHAR MsgName[256];
				TStrCpy(MsgName, stBugCheckCodeList[n].MsgName);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("0X%08x  %<b>%s "), stBugCheckCodeList[n].MsgNumber, MsgName);
				TStrCpy(MsgName, stBugCheckCodeList[n].MsgDesc);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
				++Count;
			}
		}
			} else
			{
		for (unsigned long n = 0; stBugCheckCodeList[n].MsgName; ++n)
		{
			if (!TStrNICmp(argv[0], stBugCheckCodeList[n].MsgName, TStrLen(argv[0])))
			{
				WCHAR MsgName[256];
				TStrCpy(MsgName, stBugCheckCodeList[n].MsgName);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<b>0X%08x  %<1>%s "), stBugCheckCodeList[n].MsgNumber, MsgName);
				TStrCpy(MsgName, stBugCheckCodeList[n].MsgDesc);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
			}
		}
			}
			++argv;
			--argc;
		}
		if (Count)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("totals (%<e>%d%<1>)\n"), Count);
	}
	return 0;
}

int wmsg_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	unsigned long Count = 0;
	if (argc == 1)
	{
		for (unsigned long n = 0; stMsgList[n].MsgName; ++n)
		{
			WCHAR MsgName[256];
			TStrCpy(MsgName, stMsgList[n].MsgName);
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%04x  %s\n"), stMsgList[n].MsgNumber, MsgName);
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("totals (%<e>%d%<1>)\n"), Count);
	} else
	if (argc > 1)
	{
		--argc;
		++argv;
		while (argc>0)
		{
			ULONG_PTR Result;
			if (gpSyser->m_SyserUI.CalcExp(argv[0], &Result))
			{
		for (unsigned long n = 0; stMsgList[n].MsgName; ++n)
		{
			if (stMsgList[n].MsgNumber == Result)
			{
				WCHAR MsgName[256];
				TStrCpy(MsgName, stMsgList[n].MsgName);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%04x  %<b>%s\n"), stMsgList[n].MsgNumber, MsgName);
				++Count;
			}
		}
			} else
			{
		for (unsigned long n = 0; stMsgList[n].MsgName; ++n)
		{
			if (!TStrNICmp(argv[0], stMsgList[n].MsgName, TStrLen(argv[0])))
			{
				WCHAR MsgName[256];
				TStrCpy(MsgName, stMsgList[n].MsgName);
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<b>%04x  %<1>%s\n"), stMsgList[n].MsgNumber, MsgName);
			}
		}
			}
			++argv;
			--argc;
		}
		if (Count)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("totals (%<e>%d%<1>)\n"), Count);
	}
	return 0;
}

int zap_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc != 1)
		return -1;

	X86_CPU_REG_PTR X86_REG;
	pSyser->m_pDebugger->GetX86RegPtr(&X86_REG);
	unsigned short word;
	pSyser->m_pDebugger->ReadMemory(*X86_REG.pCIP - 2, &word, 2);

	if (word == 0x1CD || word == 0x3CD)
	{
		word = 0x9090;
		pSyser->m_pDebugger->WriteMemory(*X86_REG.pCIP - 2, &word, 2);
	} else
	if (((word & 0xFF00) == 0xCC00) || ((word & 0xFF00) == 0xF100))
	{
		word = 0x9090;
		pSyser->m_pDebugger->WriteMemory(*X86_REG.pCIP - 1, &word, 1);
	} else
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("NO embedded INT 1 or INT 3\n"));
	}
	gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
	return 0;
}

int file_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	CSDSModule *pSDSMod = gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.m_pSDSMod;
	if (!pSDSMod)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : not found symbol module.\n"));
		return 1;
	}
	if (argc == 1)
	{
		unsigned long Len = 0;
		SrcFileNameID *SrcFileName = pSDSMod->GetSrcFiles(&Len);
		if (!SrcFileName)
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : not found source file.\n"));
			return 1;
		}
		for (unsigned long n = 0; n < Len; ++n)
		{
			if (SrcFileName[n].FileSize)
			{
				char *pFileName = TStrRChr(SrcFileName[n].FileName, '\\');
				if (pFileName)
				{
					WCHAR FileName[512];
					TStrCpy(FileName, pFileName + 1);
					gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%s\n"), FileName);
				}
			}
		}
	} else
	if (argc > 1)
	{
		char Buffer[512];
		int index = 1;
		while (index < argc)
		{
			TStrCpy(Buffer, argv[index]);
			SrcFileNameID *SrcFile = pSDSMod->GetSrcFileName(Buffer);
			if (SrcFile)
			{
				gpSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(SRC_TAB); //SRC_TAB(2)
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.OpenSrcView(pSDSMod, SrcFile->FileID, 0);
				gpSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(SRC_TAB); //SRC_TAB(2)
			}
			++index;
		}
	}
	return 0;
}

int watch_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc < 2)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : watch variablename [variablename2 ..].\n"));
		return 1;
	}

	if (!gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.m_pSDSMod)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : not found symbol module.\n"));
		return 1;
	}

	int index = 1;
	while (index < argc)
	{
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_TypeViewerWnd.AddWatch(argv[index], 0);
		gpSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(SRC_TAB); //SRC_TAB(2)
		++index;
	}
	return 0;
}

int table_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (gpSyser->m_SyserUI.m_SDSModulesMap.size() == 0 || argc > 2)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : not found symbol module.\n"));
		return 1;
	}
	WCHAR szModuleName[MAX_FN_LEN]; //512
	if (argc == 1)
	{
		for (map<FILESIG, CSDSModule>::IT it = gpSyser->m_SyserUI.m_SDSModulesMap.begin();
			it != gpSyser->m_SyserUI.m_SDSModulesMap.end(); ++it)
		{
			TStrCpy(szModuleName, it->second.GetModuleName());
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%s\n"), szModuleName);
		}
	} else
	{
		for (map<FILESIG, CSDSModule>::IT it = gpSyser->m_SyserUI.m_SDSModulesMap.begin();
			it != gpSyser->m_SyserUI.m_SDSModulesMap.end(); ++it)
		{
			TStrCpy(szModuleName, it->second.GetModuleName());
			if (!TStrICmp(szModuleName, argv[1]))
			{
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.ExpandSDSModule(&it->second);
				gpSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(SRC_TAB); //SRC_TAB(2)
				break;
			}
		}
	}
	return 0;
}

const unsigned int gCRC32[256] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
	0xe963a535, 0x9e6495a3,	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
	0xf3b97148, 0x84be41de,	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,	0x14015c4f, 0x63066cd9,
	0xfa0f3d63, 0x8d080df5,	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,	0x35b5a8fa, 0x42b2986c,
	0xdbbbc9d6, 0xacbcf940,	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,	0x76dc4190, 0x01db7106,
	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

const unsigned int gCRC16[256] = {
	0x0000,	0xc0c1,	0xc181,	0x0140,	0xc301,	0x03c0,	0x0280,	0xc241,
	0xc601,	0x06c0,	0x0780,	0xc741,	0x0500,	0xc5c1,	0xc481,	0x0440,
	0xcc01,	0x0cc0,	0x0d80,	0xcd41,	0x0f00,	0xcfc1,	0xce81,	0x0e40,
	0x0a00,	0xcac1,	0xcb81,	0x0b40,	0xc901,	0x09c0,	0x0880,	0xc841,
	0xd801,	0x18c0,	0x1980,	0xd941,	0x1b00,	0xdbc1,	0xda81,	0x1a40,
	0x1e00,	0xdec1,	0xdf81,	0x1f40,	0xdd01,	0x1dc0,	0x1c80,	0xdc41,
	0x1400,	0xd4c1,	0xd581,	0x1540,	0xd701,	0x17c0,	0x1680,	0xd641,
	0xd201,	0x12c0,	0x1380,	0xd341,	0x1100,	0xd1c1,	0xd081,	0x1040,
	0xf001,	0x30c0,	0x3180,	0xf141,	0x3300,	0xf3c1,	0xf281,	0x3240,
	0x3600,	0xf6c1,	0xf781,	0x3740,	0xf501,	0x35c0,	0x3480,	0xf441,
	0x3c00,	0xfcc1,	0xfd81,	0x3d40,	0xff01,	0x3fc0,	0x3e80,	0xfe41,
	0xfa01,	0x3ac0,	0x3b80,	0xfb41,	0x3900,	0xf9c1,	0xf881,	0x3840,
	0x2800,	0xe8c1,	0xe981,	0x2940,	0xeb01,	0x2bc0,	0x2a80,	0xea41,
	0xee01,	0x2ec0,	0x2f80,	0xef41,	0x2d00,	0xedc1,	0xec81,	0x2c40,
	0xe401,	0x24c0,	0x2580,	0xe541,	0x2700,	0xe7c1,	0xe681,	0x2640,
	0x2200,	0xe2c1,	0xe381,	0x2340,	0xe101,	0x21c0,	0x2080,	0xe041,
	0xa001,	0x60c0,	0x6180,	0xa141,	0x6300,	0xa3c1,	0xa281,	0x6240,
	0x6600,	0xa6c1,	0xa781,	0x6740,	0xa501,	0x65c0,	0x6480,	0xa441,
	0x6c00,	0xacc1,	0xad81,	0x6d40,	0xaf01,	0x6fc0,	0x6e80,	0xae41,
	0xaa01,	0x6ac0,	0x6b80,	0xab41,	0x6900,	0xa9c1,	0xa881,	0x6840,
	0x7800,	0xb8c1,	0xb981,	0x7940,	0xbb01,	0x7bc0,	0x7a80,	0xba41,
	0xbe01,	0x7ec0,	0x7f80,	0xbf41,	0x7d00,	0xbdc1,	0xbc81,	0x7c40,
	0xb401,	0x74c0,	0x7580,	0xb541,	0x7700,	0xb7c1,	0xb681,	0x7640,
	0x7200,	0xb2c1,	0xb381,	0x7340,	0xb101,	0x71c0,	0x7080,	0xb041,
	0x5000,	0x90c1,	0x9181,	0x5140,	0x9301,	0x53c0,	0x5280,	0x9241,
	0x9601,	0x56c0,	0x5780,	0x9741,	0x5500,	0x95c1,	0x9481,	0x5440,
	0x9c01,	0x5cc0,	0x5d80,	0x9d41,	0x5f00,	0x9fc1,	0x9e81,	0x5e40,
	0x5a00,	0x9ac1,	0x9b81,	0x5b40,	0x9901,	0x59c0,	0x5880,	0x9841,
	0x8801,	0x48c0,	0x4980,	0x8941,	0x4b00,	0x8bc1,	0x8a81,	0x4a40,
	0x4e00,	0x8ec1,	0x8f81,	0x4f40,	0x8d01,	0x4dc0,	0x4c80,	0x8c41,
	0x4400,	0x84c1,	0x8581,	0x4540,	0x8701,	0x47c0,	0x4680,	0x8641,
	0x8201,	0x42c0,	0x4380,	0x8341,	0x4100,	0x81c1,	0x8081,	0x4040
};

const unsigned short gCRC16CCITT[256] = {
    0x0000,  0x1021,  0x2042,  0x3063,  0x4084,  0x50a5,  0x60c6,  0x70e7,
    0x8108,  0x9129,  0xa14a,  0xb16b,  0xc18c,  0xd1ad,  0xe1ce,  0xf1ef,
    0x1231,  0x0210,  0x3273,  0x2252,  0x52b5,  0x4294,  0x72f7,  0x62d6,
    0x9339,  0x8318,  0xb37b,  0xa35a,  0xd3bd,  0xc39c,  0xf3ff,  0xe3de,
    0x2462,  0x3443,  0x0420,  0x1401,  0x64e6,  0x74c7,  0x44a4,  0x5485,
    0xa56a,  0xb54b,  0x8528,  0x9509,  0xe5ee,  0xf5cf,  0xc5ac,  0xd58d,
    0x3653,  0x2672,  0x1611,  0x0630,  0x76d7,  0x66f6,  0x5695,  0x46b4,
    0xb75b,  0xa77a,  0x9719,  0x8738,  0xf7df,  0xe7fe,  0xd79d,  0xc7bc,
    0x48c4,  0x58e5,  0x6886,  0x78a7,  0x0840,  0x1861,  0x2802,  0x3823,
    0xc9cc,  0xd9ed,  0xe98e,  0xf9af,  0x8948,  0x9969,  0xa90a,  0xb92b,
    0x5af5,  0x4ad4,  0x7ab7,  0x6a96,  0x1a71,  0x0a50,  0x3a33,  0x2a12,
    0xdbfd,  0xcbdc,  0xfbbf,  0xeb9e,  0x9b79,  0x8b58,  0xbb3b,  0xab1a,
    0x6ca6,  0x7c87,  0x4ce4,  0x5cc5,  0x2c22,  0x3c03,  0x0c60,  0x1c41,
    0xedae,  0xfd8f,  0xcdec,  0xddcd,  0xad2a,  0xbd0b,  0x8d68,  0x9d49,
    0x7e97,  0x6eb6,  0x5ed5,  0x4ef4,  0x3e13,  0x2e32,  0x1e51,  0x0e70,
    0xff9f,  0xefbe,  0xdfdd,  0xcffc,  0xbf1b,  0xaf3a,  0x9f59,  0x8f78,
    0x9188,  0x81a9,  0xb1ca,  0xa1eb,  0xd10c,  0xc12d,  0xf14e,  0xe16f,
    0x1080,  0x00a1,  0x30c2,  0x20e3,  0x5004,  0x4025,  0x7046,  0x6067,
    0x83b9,  0x9398,  0xa3fb,  0xb3da,  0xc33d,  0xd31c,  0xe37f,  0xf35e,
    0x02b1,  0x1290,  0x22f3,  0x32d2,  0x4235,  0x5214,  0x6277,  0x7256,
    0xb5ea,  0xa5cb,  0x95a8,  0x8589,  0xf56e,  0xe54f,  0xd52c,  0xc50d,
    0x34e2,  0x24c3,  0x14a0,  0x0481,  0x7466,  0x6447,  0x5424,  0x4405,
    0xa7db,  0xb7fa,  0x8799,  0x97b8,  0xe75f,  0xf77e,  0xc71d,  0xd73c,
    0x26d3,  0x36f2,  0x0691,  0x16b0,  0x6657,  0x7676,  0x4615,  0x5634,
    0xd94c,  0xc96d,  0xf90e,  0xe92f,  0x99c8,  0x89e9,  0xb98a,  0xa9ab,
    0x5844,  0x4865,  0x7806,  0x6827,  0x18c0,  0x08e1,  0x3882,  0x28a3,
    0xcb7d,  0xdb5c,  0xeb3f,  0xfb1e,  0x8bf9,  0x9bd8,  0xabbb,  0xbb9a,
    0x4a75,  0x5a54,  0x6a37,  0x7a16,  0x0af1,  0x1ad0,  0x2ab3,  0x3a92,
    0xfd2e,  0xed0f,  0xdd6c,  0xcd4d,  0xbdaa,  0xad8b,  0x9de8,  0x8dc9,
    0x7c26,  0x6c07,  0x5c64,  0x4c45,  0x3ca2,  0x2c83,  0x1ce0,  0x0cc1,
    0xef1f,  0xff3e,  0xcf5d,  0xdf7c,  0xaf9b,  0xbfba,  0x8fd9,  0x9ff8,
    0x6e17,  0x7e36,  0x4e55,  0x5e74,  0x2e93,  0x3eb2,  0x0ed1,  0x1ef0
};

int crc_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc != 3)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : %s address size\n"), argv[0]);
		return 1;
	}

	ULONG_PTR Address = 0;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : %s address size\n"), argv[0]);
		return 1;
	}

	ULONG_PTR Size = 0;
	if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Size))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : %s address size\n"), argv[0]);
		return 1;
	}

	if (!TStrICmp(argv[0], "crc16-ccitt"))
	{
		unsigned short crc16ccitt = -1;
		while (Size>0)
		{
			unsigned char byte = 0;
			if (!pSyser->m_pDebugger->ReadMemory(Address, &byte, 1))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Syser : read memory failed, Address is " F0ADDR "X!\n"), Address);
				break;
			}
			++Address;
			--Size;
			crc16ccitt = gCRC16CCITT[(unsigned char)(argc ^ (crc16ccitt>>8))] ^ (crc16ccitt << 8);
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("CRC16/ccitt %04X\n"), crc16ccitt);
	} else
	if (!TStrICmp(argv[0], "crc16"))
	{
		unsigned short crc16 = 0;
		while (Size>0)
		{
			unsigned char byte = 0;
			if (!pSyser->m_pDebugger->ReadMemory(Address, &byte, 1))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Syser : read memory failed, Address is " F0ADDR "X!\n"), Address);
				break;
			}
			++Address;
			--Size;
			crc16 = gCRC16[(unsigned char)(crc16 ^ byte)] ^ (crc16 >> 8);
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("CRC16 %04X\n"), crc16);
	} else
	if (!TStrICmp(argv[0], "crc32"))
	{
		unsigned int crc32 = -1;
		while (Size>0)
		{
			unsigned char byte = 0;
			if (!pSyser->m_pDebugger->ReadMemory(Address, &byte, 1))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Syser : read memory failed, Address is " F0ADDR "X!\n"), Address);
				break;
			}
			++Address;
			--Size;
			crc32 = gCRC32[(unsigned char)byte ^ (unsigned char)crc32] ^ (crc32 >> 8);
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("CRC32 %08X\n"), ~crc32);
	}
	return 0;
}


SYSER_CMD_ENTRY OtherCmdTable[] =
{
	{ WSTR("resize"), WSTR("resize syser windows"), resize_command,
	0},
	{ WSTR("lines"), WSTR("Change the number of lines for the syser display."), lines_command,
	0},
	{ WSTR("width"), WSTR("Set the number of display columns in the syser window."), width_command,
	0},
	{ WSTR("ioctl"), WSTR("Decodes the IOCTL and FSCTL codes into readable English."), ioctl_command,
	0},
	{ WSTR("ntstatus"), WSTR("Display header-defined mnemonics for NTSTATUS error codes."), ntstatus_command,
	0},
	{ WSTR("winerror"), WSTR("Display header-defined mnemonics for Win32 error codes."), winerror_command,
	0},
	{ WSTR("bugcheckcode"), WSTR("Display Bug Check Code mnemonics for windows."), bugcheckcode_command,
	0},
	{ WSTR("wmsg"), WSTR("Display the names and message numbers of Windows messages."), wmsg_command,
	0},
	{ WSTR("zap"), WSTR("Replace an embedded INT 1 or INT 3 with a NOP instruction."), zap_command, 
	0},
	{ WSTR("file"), WSTR("List source code file"), file_command,
	0},
	{ WSTR("watch"), WSTR("Add source code variable watch"), watch_command,
	0},
	{ WSTR("table"), WSTR("List source code module"), table_command,
	0},
	{ WSTR("crc16"), WSTR("Calculate crc16 value with memory region."), crc_command,
	0},
	{ WSTR("crc32"), WSTR("Calculate crc32 value with memory region."), crc_command,
	0},
	{ WSTR("crc16-ccitt"), WSTR("Calculate crc-ccitt value with memory region."), crc_command,
	0},
	{0},
};

```

`source/WispSyser/othercmd.hpp`:

```hpp

#ifndef _OTHERCMD_HPP_
#define _OTHERCMD_HPP_

#include "../Code/define.h"

struct IOCTL_ENTRY
{
	const char *Name;
	unsigned long ControlCode;
};

extern IOCTL_ENTRY stIoctlList[];

struct NTSTATUS_ENTRY
{
	const char *MsgDesc;
	const char *MsgName;
	unsigned long MsgNumber;
};

extern NTSTATUS_ENTRY stNtStatusList[];

struct WINERROR_ENTRY
{
	unsigned long MsgNumber;
	const char *MsgDesc;
	const char *MsgName;
};

extern WINERROR_ENTRY stWinErrorList[];

struct BUGCHECKCODE_ENTRY
{
	unsigned long MsgNumber;
	const char *MsgName;
	const char *MsgDesc;
};

extern BUGCHECKCODE_ENTRY stBugCheckCodeList[];

struct WINDOWS_MSG_ENTRY
{
	unsigned long MsgNumber;
	const char *MsgName;
};

extern WINDOWS_MSG_ENTRY stMsgList[];

#endif
```

`source/WispSyser/pagemapwnd.cpp`:

```cpp

#include "../Code/fileiont.hpp"
#include "pagemapwnd.hpp"

        WISP_MSG_MAP_BEGIN(CPageMapWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
		WISP_MSG_MAP_ON_COMMAND
        WISP_MSG_MAP_END(CWispSplitWnd)


//      WISP_COMMAND_MAP_BEGIN(CPageMapWnd)
//              case default: return CWispWnd::OnCommand(pMsg);
//      WISP_COMMAND_MAP_END

	CPageMapWnd::CPageMapWnd()
	{
		_field_260 = 0;
	#if 0
		m_PageTableBaseAddress = 0xC0000000;// PAGE_TABLE
		if (GETX86CR4(-1) & 0x20)
			m_PageDirectBaseAddress = 0xC0600000;// PAGE_DIR_PAE
		else	m_PageDirectBaseAddress = 0xC0300000;// PAGE_DIR
	#else
		m_PageTableBaseAddress = 0;
		m_PageDirectBaseAddress = 0;
	#endif
	}
	CPageMapWnd::~CPageMapWnd()
	{
	}

	bool CPageMapWnd::OnCreate(WISP_MSG *pMsg)
	{
		WISP_RECT Rect;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = m_ClientRect.cx / 2;
		Rect.cy = m_ClientRect.cy;

		m_PageDirectList.CreateWnd(0, Rect, this, 1, 0x10000, WISP_SH_MINSIZE);
		m_PageDirectList.InsertColumn(WSTR("Page Table Physical Address"), 68, 0, 0, -1);
		m_PageDirectList.InsertColumn(WSTR("Lines Address"), 120, 0, 0, -1);
		m_PageDirectList.InsertColumn(WSTR("Attribute"), 120, 0, 0, -1);
		m_PageDirectList.InsertColumn(WSTR(""), 80, 0, 0, -1);

		Rect.x = m_ClientRect.cx / 2;
		Rect.y = 0;
		Rect.cx = Rect.x;
		Rect.cy = m_ClientRect.cy;

		m_PageTableList.CreateWnd(0, Rect, this, 2, 0x10000, WISP_SH_MINSIZE);
		m_PageTableList.InsertColumn(WSTR("Lines Address"), 120, 0, 0, -1);
		m_PageTableList.InsertColumn(WSTR("Physical"), 80, 0, 0, -1);
		m_PageTableList.InsertColumn(WSTR("Attribute"), 120, 0, 0, -1);
		m_PageTableList.InsertColumn(WSTR(""), 80, 0, 0, -1);

		InsertWnd(&m_PageDirectList, 0, 100, -1);
		InsertWnd(&m_PageTableList, 0, 100, -1);

		AdjustWndPos();

	#ifndef _RING0_
		CLocalFileIO File;
		HANDLE Handle;
		if (!File.OpenFile("PageTable.bin", &Handle, 0x10000))
		{
			m_PageTableBaseAddress = 0;
			m_PageDirectBaseAddress = 0;
			return true;
		}
		unsigned long len = File.GetFileLength(Handle);
		char *ptr = new char[len];
		m_PageTableBaseAddress = (unsigned long*)ptr;
		File.ReadFile(Handle, ptr, len);
		m_PageDirectBaseAddress = (unsigned long*)(ptr + 0x300000);
		File.CloseHandle(Handle);
	#endif

		InitContext();
		return true;
	}

	bool CPageMapWnd::OnDestroy(WISP_MSG *pMsg)
	{
	#ifndef _RING0_
		delete []m_PageTableBaseAddress;
	#endif
		return true;
	}

	bool CPageMapWnd::OnCommand(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CtrlType == 11 && //WISP_CTRL_LIST
		    pMsg->Command.CmdMsg == 0x80000105 && //WISP_WM_UPDATE_HORZ_SCROLL_BAR
		    pMsg->Command.CmdID == 1)
		{
			m_PageTableList.DeleteAllChildrenItems(nullptr);
			if (m_PageTableBaseAddress)
				InsertPageTableList(pMsg);
		}
		return true;
	}

	bool CPageMapWnd::InsertPageTableList(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}

	void CPageMapWnd::Create()
	{
		if (IsWindow())
		{
			Destroy();
		} else
		{
			WISP_RECT Rect;
			Rect.x = 0;
			Rect.y = 0;
			Rect.cx = 400;
			Rect.cy = 300;
			CreateWnd(WSTR("Page Map"), Rect, 0, 0, 0x200BB, WISP_SH_MINSIZE);
			Center(nullptr);
		}
	}

	void CPageMapWnd::InitContext()
	{
		//TODO
	}

```

`source/WispSyser/pagemapwnd.hpp`:

```hpp

#ifndef _PAGEMAPWND_HPP_
#define _PAGEMAPWND_HPP_

#include "../Wisp/wispsplitwnd.hpp"
#include "../Wisp/wisplist.hpp"

struct CPageMapWnd: public CWispSplitWnd
{
	bool _field_260;

	CWispList m_PageDirectList;
	CWispList m_PageTableList;
	unsigned long *m_PageDirectBaseAddress;
	unsigned long *m_PageTableBaseAddress;

	CPageMapWnd();
	virtual ~CPageMapWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);

	bool InsertPageTableList(WISP_MSG *pMsg);

	void Create();
	void InitContext();
};

#endif

```

`source/WispSyser/peexplorerform.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "peexplorerform.hpp"
#include "../Code/time.hpp"

	WISP_MSG_MAP_BEGIN(CPEHeaderWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispWnd)

        WISP_EVENT_MAP_BEGIN(CPEHeaderWnd)
//		WISP_EVENT_MAP(, OnEvent)
        WISP_EVENT_MAP_END

	bool CPEHeaderWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_COFF.CreateWnd(0, 5,5,372,294, this, 0x101, 0x46010006, WISP_SH_MINSIZE);
		m_WIN.CreateWnd(0, 385,5,372,294, this, 0x102, 0x46010006, WISP_SH_MINSIZE);
		InitContext();
		return true;
	}

	bool CPEHeaderWnd::InitContext()
	{
		m_COFF.InsertColumn(WSTR("Field Name"), 165, 0, 0, -1);
		m_COFF.InsertColumn(WSTR("Date Value"), 80, 0, 0, -1);
		m_COFF.InsertColumn(WSTR("Description"), 120, 0, 0, -1);
		m_pItems[0] = m_COFF.InsertItem(WSTR("Machine"), 0, 0, 0, -1);
		m_pItems[1] = m_COFF.InsertItem(WSTR("Number of Sections"), 0, 0, 0, -1);
		m_pItems[2] = m_COFF.InsertItem(WSTR("Time Date Stamp"), 0, 0, 0, -1);
		m_pItems[3] = m_COFF.InsertItem(WSTR("Pointer to Symbol Table"), 0, 0, 0, -1);
		m_pItems[4] = m_COFF.InsertItem(WSTR("Number of Symbols"), 0, 0, 0, -1);
		m_pItems[5] = m_COFF.InsertItem(WSTR("Size of Optional Header"), 0, 0, 0, -1);
		m_pItems[6] = m_COFF.InsertItem(WSTR("Characteristics"), 0, 0, 0, -1);
		m_pItems[7] = m_COFF.InsertItem(WSTR("Magic"), 0, 0, 0, -1);
		m_pItems[8] = m_COFF.InsertItem(WSTR("Linker Version"), 0, 0, 0, -1);
		m_pItems[9] = m_COFF.InsertItem(WSTR("Size of code"), 0, 0, 0, -1);
		m_pItems[10] = m_COFF.InsertItem(WSTR("Size of Initialized Data"), 0, 0, 0, -1);
		m_pItems[11] = m_COFF.InsertItem(WSTR("Size of Uninitialized Data"), 0, 0, 0, -1);
		m_pItems[12] = m_COFF.InsertItem(WSTR("Address of entry Point"), 0, 0, 0, -1);
		m_pItems[13] = m_COFF.InsertItem(WSTR("Base of code"), 0, 0, 0, -1);
	#ifndef _X64_
		m_pItems[14] = m_COFF.InsertItem(WSTR("Base of data"), 0, 0, 0, -1);
	#endif
		m_pItems[15] = m_COFF.InsertItem(WSTR("Image Base"), 0, 0, 0, -1);

		m_WIN.InsertColumn(WSTR("Field Name"), 165, 0, 0, -1);
		m_WIN.InsertColumn(WSTR("Date Value"), 90, 0, 0, -1);
		m_WIN.InsertColumn(WSTR("Description"), 110, 0, 0, -1);
		m_pItems[16] = m_WIN.InsertItem(WSTR("Section Alignment"), 0, 0, 0, -1);
		m_pItems[17] = m_WIN.InsertItem(WSTR("File Alignment"), 0, 0, 0, -1);
		m_pItems[18] = m_WIN.InsertItem(WSTR("Operating System Version"), 0, 0, 0, -1);
		m_pItems[19] = m_WIN.InsertItem(WSTR("Image Version"), 0, 0, 0, -1);
		m_pItems[20] = m_WIN.InsertItem(WSTR("Subsystem Version"), 0, 0, 0, -1);
		m_pItems[21] = m_WIN.InsertItem(WSTR("Win32 Version Value"), 0, 0, 0, -1);
		m_pItems[22] = m_WIN.InsertItem(WSTR("Size of Image"), 0, 0, 0, -1);
		m_pItems[23] = m_WIN.InsertItem(WSTR("Size of Headers"), 0, 0, 0, -1);
		m_pItems[24] = m_WIN.InsertItem(WSTR("Checksum"), 0, 0, 0, -1);
		m_pItems[25] = m_WIN.InsertItem(WSTR("Subsystem"), 0, 0, 0, -1);
		m_pItems[26] = m_WIN.InsertItem(WSTR("Dll Characteristics"), 0, 0, 0, -1);
		m_pItems[27] = m_WIN.InsertItem(WSTR("Size of Stack Reserve"), 0, 0, 0, -1);
		m_pItems[28] = m_WIN.InsertItem(WSTR("Size of Stack Commit"), 0, 0, 0, -1);
		m_pItems[29] = m_WIN.InsertItem(WSTR("Size of Heap Reserve"), 0, 0, 0, -1);
		m_pItems[30] = m_WIN.InsertItem(WSTR("Size of Heap Commit"), 0, 0, 0, -1);
		m_pItems[31] = m_WIN.InsertItem(WSTR("Loader Flags"), 0, 0, 0, -1);
		m_pItems[32] = m_WIN.InsertItem(WSTR("Number of Data Directories"), 0, 0, 0, -1);
 		
		return true;
	}

	bool CPEHeaderWnd::Open(CPEFile *pPEFile)
	{
		char Buffer[52];

		Time2Str(pPEFile->m_PEHead.TimeDateStamp - gpSyser->m_TimeOffset, Buffer);

		m_COFF.SetItemFormat(m_pItems[0], 1, pPEFile->m_PEHead.Machine, WSTR("0x%04x"));
		m_COFF.SetItemFormat(m_pItems[1], 1, pPEFile->m_PEHead.NumberOfSections, WSTR("0x%04x"));
		m_COFF.SetItemFormat(m_pItems[2], 1, pPEFile->m_PEHead.TimeDateStamp, WSTR("0x%08x"));
		m_COFF.SetItemText(m_pItems[2], 2, Buffer);
		m_COFF.SetItemFormat(m_pItems[3], 1, pPEFile->m_PEHead.PointerToSymbolTable, WSTR("0x%08x"));
		m_COFF.SetItemFormat(m_pItems[4], 1, pPEFile->m_PEHead.NumberOfSymbols, WSTR("0x%08x"));
		m_COFF.SetItemFormat(m_pItems[5], 1, pPEFile->m_PEHead.SizeOfOptionalHeader, WSTR("0x%04x"));
		m_COFF.SetItemFormat(m_pItems[6], 1, pPEFile->m_PEHead.Characteristics, WSTR("0x%08x"));
		m_COFF.SetItemFormat(m_pItems[7], 1, pPEFile->m_PEHead.Magic, WSTR("0x%08x"));
		m_COFF.SetItemFormat(m_pItems[8], 1, MAKE_WORD(pPEFile->m_PEHead.MinorLinkerVersion, pPEFile->m_PEHead.MajorLinkerVersion), WSTR("0x%04x"));
		TSPrintf(Buffer, "%d.%d", pPEFile->m_PEHead.MajorLinkerVersion, pPEFile->m_PEHead.MinorLinkerVersion);
		m_COFF.SetItemText(m_pItems[8], 2, Buffer);
		m_COFF.SetItemFormat(m_pItems[9], 1, pPEFile->m_PEHead.SizeOfCode, WSTR("0x%08x"));
		m_COFF.SetItemFormat(m_pItems[10], 1, pPEFile->m_PEHead.SizeOfInitializedData, WSTR("0x%08x"));
		m_COFF.SetItemFormat(m_pItems[11], 1, pPEFile->m_PEHead.SizeOfUninitializedData, WSTR("0x%08x"));
		m_COFF.SetItemFormat(m_pItems[12], 1, pPEFile->m_PEHead.AddressOfEntryPoint, WSTR("0x%08x"));
		m_COFF.SetItemFormat(m_pItems[13], 1, pPEFile->m_PEHead.BaseOfCode, WSTR("0x%08x"));
	#ifndef _X64_
		m_COFF.SetItemFormat(m_pItems[14], 1, pPEFile->m_PEHead.BaseOfData, WSTR("0x%08x"));
	#endif
		m_COFF.SetItemFormat(m_pItems[15], 1, pPEFile->m_PEHead.ImageBase, WSTR("0x" F0ADDR "X")); //"0x%016I64X"

		m_WIN.SetItemFormat(m_pItems[16], 1, pPEFile->m_PEHead.SectionAlignment, WSTR("0x%08x"));
		m_WIN.SetItemFormat(m_pItems[17], 1, pPEFile->m_PEHead.FileAlignment, WSTR("0x%08x"));
		m_WIN.SetItemFormat(m_pItems[18], 1, MAKE_DWORD(pPEFile->m_PEHead.MinorOperatingSystemVersion, pPEFile->m_PEHead.MajorOperatingSystemVersion), WSTR("0x%08x"));
		TSPrintf(Buffer, "%d.%d", pPEFile->m_PEHead.MajorOperatingSystemVersion, pPEFile->m_PEHead.MinorOperatingSystemVersion);
		m_COFF.SetItemText(m_pItems[18], 2, Buffer);
		m_WIN.SetItemFormat(m_pItems[19], 1, MAKE_DWORD(pPEFile->m_PEHead.MinorImageVersion, pPEFile->m_PEHead.MajorImageVersion), WSTR("0x%08x"));
		TSPrintf(Buffer, "%d.%d", pPEFile->m_PEHead.MajorImageVersion, pPEFile->m_PEHead.MinorImageVersion);
		m_COFF.SetItemText(m_pItems[19], 2, Buffer);
		m_WIN.SetItemFormat(m_pItems[20], 1, MAKE_DWORD(pPEFile->m_PEHead.MinorSubsystemVersion, pPEFile->m_PEHead.MajorSubsystemVersion), WSTR("0x%08x"));
		TSPrintf(Buffer, "%d.%d", pPEFile->m_PEHead.MajorSubsystemVersion, pPEFile->m_PEHead.MinorSubsystemVersion);
		m_COFF.SetItemText(m_pItems[20], 2, Buffer);
		m_WIN.SetItemFormat(m_pItems[21], 1, pPEFile->m_PEHead.Win32VersionValue, WSTR("0x%08x"));
		m_WIN.SetItemFormat(m_pItems[22], 1, pPEFile->m_PEHead.SizeOfImage, WSTR("0x%08x"));
		TSPrintf(Buffer, "%d bytes", pPEFile->m_PEHead.SizeOfImage);
		m_WIN.SetItemText(m_pItems[22], 2, Buffer);
		m_WIN.SetItemFormat(m_pItems[23], 1, pPEFile->m_PEHead.SizeOfHeaders, WSTR("0x%08x"));
		m_WIN.SetItemFormat(m_pItems[24], 1, pPEFile->m_PEHead.CheckSum, WSTR("0x%08x"));
		m_WIN.SetItemFormat(m_pItems[25], 1, pPEFile->m_PEHead.Subsystem, WSTR("0x%08x"));
		m_WIN.SetItemFormat(m_pItems[26], 1, pPEFile->m_PEHead.DllCharacteristics, WSTR("0x%08x"));
		m_WIN.SetItemFormat(m_pItems[27], 1, pPEFile->m_PEHead.SizeOfStackReserve, WSTR("0x" F0ADDR "X")); //"0x%016I64X"
		m_WIN.SetItemFormat(m_pItems[28], 1, pPEFile->m_PEHead.SizeOfStackCommit, WSTR("0x" F0ADDR "X")); //"0x%016I64X"
		m_WIN.SetItemFormat(m_pItems[29], 1, pPEFile->m_PEHead.SizeOfHeapReserve, WSTR("0x" F0ADDR "X")); //"0x%016I64X"
		m_WIN.SetItemFormat(m_pItems[30], 1, pPEFile->m_PEHead.SizeOfHeapCommit, WSTR("0x" F0ADDR "X")); //"0x%016I64X"
		m_WIN.SetItemFormat(m_pItems[31], 1, pPEFile->m_PEHead.LoaderFlags, WSTR("0x%08x"));
		m_WIN.SetItemFormat(m_pItems[32], 1, pPEFile->m_PEHead.NumberOfRvaAndSizes, WSTR("0x%08x"));
 
		return true;
	}
//
	WISP_MSG_MAP_BEGIN(CPERelcationWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispWnd)

        WISP_EVENT_MAP_BEGIN(CPERelcationWnd)
//		WISP_EVENT_MAP(, OnEvent)
        WISP_EVENT_MAP_END

	bool CPERelcationWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_ModuleList.CreateWnd(0, 5,5,372,294, this, 0x101, 0x46010006, WISP_SH_MINSIZE);
		m_EntryList.CreateWnd(0, 385,5,372,294, this, 0x102, 0x46010006, WISP_SH_MINSIZE);
		InitContext();
		return true;
	}

	bool CPERelcationWnd::InitContext()
	{
		m_ModuleList.InsertColumn(WSTR("RVA"), 165, 0, 0, -1);
		m_ModuleList.InsertColumn(WSTR("Items"), 90, 0, 0, -1);
		m_ModuleList.InsertColumn(WSTR("Owner"), 110, 0, 0, -1);

		m_EntryList.InsertColumn(WSTR("Offset"), 165, 0, 0, -1);
		m_EntryList.InsertColumn(WSTR("Types"), 90, 0, 0, -1);
		return true;
	}
//
	WISP_MSG_MAP_BEGIN(CPEImportModuleList)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	bool CPEImportModuleList::OnMouseDblClick(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			WISP_RECT Rect;
			GetItemRect(Item, 0, &Rect);
			if (pMsg->MsgMouseWndPT.x >= Rect.x && pMsg->MsgMouseWndPT.x <= Rect.x+Rect.cx)
			{
				ULONG_PTR Addr = GetItemValue(Item, 2);
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
			} else
			{
				ULONG_PTR Addr = GetItemValue(Item, 1);
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
			}
		}
		return true;
	}

	WISP_MSG_MAP_BEGIN(CPEImportEntryList)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	bool CPEImportEntryList::OnMouseDblClick(WISP_MSG *pMsg)	
	{
		CListStringItem *Item = GetNext(0, 8);
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			WISP_RECT Rect;
			GetItemRect(Item, 0, &Rect);
			if (pMsg->MsgMouseWndPT.x >= Rect.x && pMsg->MsgMouseWndPT.x <= Rect.x+Rect.cx)
			{
				ULONG_PTR Addr = GetItemValue(Item, 0);
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
			} else
			{
				ULONG_PTR Addr = GetItemValue(Item, 2);
				gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(Addr, true);
			}
		}
		return true;
	}

	WISP_MSG_MAP_BEGIN(CPEImportWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispWnd)

        WISP_CMD_MAP_BEGIN(CPEImportWnd)
		WISP_CMD_MAP(0x103, OnCmdSelectEntry)
        WISP_CMD_MAP_END

        WISP_EVENT_MAP_BEGIN(CPEImportWnd)
//		WISP_EVENT_MAP(, OnEvent)
        WISP_EVENT_MAP_END

	bool CPEImportWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_ModuleList.CreateWnd(0, 5,5,225,294, this, 0x103, 0x46010006, WISP_SH_MINSIZE);
		m_EntryList.CreateWnd(0, 240,5,510,294, this, 0x104, 0x46010006, WISP_SH_MINSIZE);
		InitContext();
		return true;
	}

	bool CPEImportWnd::OnCmdSelectEntry(WISP_MSG *pMsg)
	{
		CPEFile PEFile; //CMemPEFile
		if (pMsg->Command.CmdMsg == 0x80000105 && gpSyser->m_pDebugger)
		{
			bool bOpenOK = false;
			m_EntryList.DeleteAllChildrenItems(0);
			CListStringItem *Item = m_ModuleList.GetNext(0, 8);
			int Count = m_ModuleList.GetItemValue(Item, 0);
			if (Count < m_pPEFile->m_ImportModuleCount)
			{
				ULONG_PTR ImageBase = GetImageBase(m_pPEFile->m_ImportModule[Count].FileName);
				if (ImageBase)
					bOpenOK = PEFile.Open(ImageBase, 0x17, &CDebugger::Read, gpSyser->m_pDebugger);
				
				for (int i = 0; i < m_pPEFile->m_ImportModule[Count].FuncCount; ++i)
				{
					CListStringItem *Item = m_EntryList.InsertItemValue(m_pPEFile->m_ImportModule[Count].FuncList[i].ThunkAddr, 0, WSTR("0x" F0ADDR "X"), 0, nullptr, -1);
					m_EntryList.SetItemValue(Item, 0, m_pPEFile->m_ImportModule[Count].FuncList[i].ThunkAddr);
					if (bOpenOK)
					{
						unsigned long Index;
						ULONG_PTR Func = PEFile.GetExportFunc(m_pPEFile->m_ImportModule[Count].FuncList[i].FuncName, &Index);
						m_EntryList.SetItemFormat(Item, 1, Index, WSTR("0x%04X"));
						m_EntryList.SetItemFormat(Item, 2, Func, WSTR("0x" F0ADDR "X"));
						m_EntryList.SetItemValue(Item, 2, Func);
					}
					m_EntryList.SetItemText(Item, 3, m_pPEFile->m_ImportModule[Count].FuncList[i].FuncName);
				}
				if (bOpenOK)
					PEFile.Close();
			}
		}	
		return true;
	}

	bool CPEImportWnd::InitContext()
	{
		m_ModuleList.InsertColumn(WSTR("RVA"), 70, 0, 0, -1); //TODO
		m_ModuleList.InsertColumn(WSTR("Name"), 100, 0, 0, -1);
		m_ModuleList.InsertColumn(WSTR("Count"), 40, 0, 0, -1);

		m_EntryList.InsertColumn(WSTR("RVA"), 70, 0, 0, -1); //TODO
		m_EntryList.InsertColumn(WSTR("Hint"), 50, 0, 0, -1);
		m_EntryList.InsertColumn(WSTR("Entry Point"), 70, 0, 0, -1); //TODO
		m_EntryList.InsertColumn(WSTR("Name"), 270, 0, 0, -1);
		return true;
	}

	bool CPEImportWnd::Open(CPEFile *pPEFile)
	{
		m_pPEFile = pPEFile;
		m_ModuleList.DeleteAllChildrenItems(0);
		for (int i = 0; i < pPEFile->m_ImportModuleCount; ++i)
		{
			CListStringItem *Item = m_ModuleList.InsertItemValue(pPEFile->m_ImportModule[i].RVA, nullptr, WSTR("0x" F0ADDR "X"), 0, nullptr, -1);
			m_ModuleList.SetItemValue(Item, 2, pPEFile->m_ImportModule[i].RVA);
			m_ModuleList.SetItemText(Item, 1, pPEFile->m_ImportModule[i].FileName);
			m_ModuleList.SetItemValue(Item, 0, i);

			ULONG_PTR ImageBase = GetImageBase(pPEFile->m_ImportModule[i].FileName);
			m_ModuleList.SetItemValue(Item, 1, ImageBase);
			m_ModuleList.SetItemFormat(Item, 2, pPEFile->m_ImportModule[i].FuncCount, WSTR("%d"));
		}
		return true;
	}

	ULONG_PTR CPEImportWnd::GetImageBase(const char *szModuleName)
	{
		map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
		//while (it != gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.end())
		while (it)
		{
			if (!TStrICmp(it->second.m_pName, szModuleName))
				return it->second.m_ImageBase;
			++it;
		}
		return 0;
	}
//
	WISP_MSG_MAP_BEGIN(CPEExportList)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	bool CPEExportList::OnMouseDblClick(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			WISP_RECT Rect;
			GetItemRect(Item, 2, &Rect);
			if (pMsg->MsgMouseWndPT.x >= Rect.x && pMsg->MsgMouseWndPT.x <= Rect.x+Rect.cx)
			{
				ULONG_PTR Addr = GetItemValue(Item, 2);
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
			} else
			{
				ULONG_PTR Addr = GetItemValue(Item, 0);
				gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(Addr, true);
			}
		}
		return true;
	}

	WISP_MSG_MAP_BEGIN(CPEExportWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispWnd)

        WISP_EVENT_MAP_BEGIN(CPEExportWnd)
//		WISP_EVENT_MAP(, OnEvent)
        WISP_EVENT_MAP_END

	bool CPEExportWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_ExportList.CreateWnd(0, 5,5,736,294, this, 0x101, 0x46010006, WISP_SH_MINSIZE);
		InitContext();
		return true;
	}

	bool CPEExportWnd::InitContext()
	{
		m_ExportList.InsertColumn(WSTR("Entry Point"), 80, 0, 0, -1); //TODO
		m_ExportList.InsertColumn(WSTR("Ord"), 50, 0, 0, -1);
		m_ExportList.InsertColumn(WSTR("Thunk"), 80, 0, 0, -1); //TODO
		m_ExportList.InsertColumn(WSTR("Name"), 490, 0, 0, -1);
		return true;
	}

	bool CPEExportWnd::Open(CPEFile *pPEFile)
	{
		m_ExportList.DeleteAllChildrenItems(0);
		for (int i = 0; i < pPEFile->m_ExportFuncCount; ++i)
		{
			CListStringItem *Item = m_ExportList.InsertItemValue(pPEFile->m_ExportFunc[i].Address, nullptr, WSTR("0x" F0ADDR "X"), 0, nullptr, -1);
			m_ExportList.SetItemValue(Item, 0, pPEFile->m_ExportFunc[i].Address);
			m_ExportList.SetItemFormat(Item, 1, pPEFile->m_ExportFunc[i].FuncOrd, WSTR("%d"));
			m_ExportList.SetItemFormat(Item, 2, pPEFile->m_ExportFunc[i].Thunk, WSTR("0x" F0ADDR "X"));
			m_ExportList.SetItemValue(Item, 2, pPEFile->m_ExportFunc[i].Thunk);
			m_ExportList.SetItemText(Item, 3, pPEFile->m_ExportFunc[i].FuncName);
		}
		return true;
	}
//
	WISP_MSG_MAP_BEGIN(CPEDataDirectoryList)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	bool CPEDataDirectoryList::OnMouseDblClick(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (pMsg->KeyEvent.KeyType == VK_LBUTTON)
		{
			ULONG_PTR Addr = GetItemValue(Item, 1);
			gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
		}
		return true;
	}

	WISP_MSG_MAP_BEGIN(CPEDataDirectoryWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispWnd)

        WISP_EVENT_MAP_BEGIN(CPEDataDirectoryWnd)
//		WISP_EVENT_MAP(, OnEvent)
        WISP_EVENT_MAP_END

	bool CPEDataDirectoryWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_DirectoryList.CreateWnd(0, 5,5,450,278, this, 0x105, 0x46010006, WISP_SH_MINSIZE);
		InitContext();
		return true;
	}

	bool CPEDataDirectoryWnd::InitContext()
	{
		m_DirectoryList.InsertColumn(WSTR("Directory Name"), 205, 0, 0, -1);
		m_DirectoryList.InsertColumn(WSTR("Virtual Address"), 90, 0, 0, -1); //TODO
		m_DirectoryList.InsertColumn(WSTR("Size"), 90, 0, 0, -1);

		m_pItems[0] = m_DirectoryList.InsertItem(WSTR("Export Table"), 0, 0, 0, -1);
		m_pItems[1] = m_DirectoryList.InsertItem(WSTR("Import Table"), 0, 0, 0, -1);
		m_pItems[2] = m_DirectoryList.InsertItem(WSTR("Resource Table"), 0, 0, 0, -1);
		m_pItems[3] = m_DirectoryList.InsertItem(WSTR("Exception Table"), 0, 0, 0, -1);
		m_pItems[4] = m_DirectoryList.InsertItem(WSTR("Certificate Table"), 0, 0, 0, -1);
		m_pItems[5] = m_DirectoryList.InsertItem(WSTR("Relocation Table"), 0, 0, 0, -1);
		m_pItems[6] = m_DirectoryList.InsertItem(WSTR("Debug Data"), 0, 0, 0, -1);
		m_pItems[7] = m_DirectoryList.InsertItem(WSTR("Architecture-specific data"), 0, 0, 0, -1);
		m_pItems[8] = m_DirectoryList.InsertItem(WSTR("Machine Value (MIPS GP)"), 0, 0, 0, -1);
		m_pItems[9] = m_DirectoryList.InsertItem(WSTR("TLS Table"), 0, 0, 0, -1);
		m_pItems[10] = m_DirectoryList.InsertItem(WSTR("Load Configuration Table"), 0, 0, 0, -1);
		m_pItems[11] = m_DirectoryList.InsertItem(WSTR("Bound Import Table"), 0, 0, 0, -1);
		m_pItems[12] = m_DirectoryList.InsertItem(WSTR("Import Address Table"), 0, 0, 0, -1);
		m_pItems[13] = m_DirectoryList.InsertItem(WSTR("Delay Import Descriptor"), 0, 0, 0, -1);
		m_pItems[14] = m_DirectoryList.InsertItem(WSTR("COM+ Runtime Header"), 0, 0, 0, -1);
		m_pItems[15] = m_DirectoryList.InsertItem(WSTR("(15) Reserved"), 0, 0, 0, -1);
		return true;
	}

	bool CPEDataDirectoryWnd::Open(CPEFile *pPEFile)
	{
		for (int i = 0; i < pPEFile->m_PEHead.NumberOfRvaAndSizes; ++i)
		{
			ULONG_PTR Addr = pPEFile->m_PEHead.DataDirectory[i].VirtualAddress;
			if (Addr) Addr += pPEFile->m_ImageBase;
			m_DirectoryList.SetItemFormat(m_pItems[i], 1, Addr, WSTR("0x" F0ADDR "X"));
			m_DirectoryList.SetItemValue(m_pItems[i], 1, Addr);
			m_DirectoryList.SetItemFormat(m_pItems[i], 2, pPEFile->m_PEHead.DataDirectory[i].Size, WSTR("0x%08X"));
		}
		return true;
	}

WISP_FORM_RES_ITEM PEExplorerForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 780, 390}, 0, 0xB, WSTR("PE Explorer"), (void*)"\\SyserIcon\\Syser.ico", 0},
	{WISP_CTRL_COMBO_BOX, {5, 5, 135, 20}, 3, 0x9040006, 0, 0, 0},
	{WISP_CTRL_TAB, {5, 30, 765, 330}, 2, 6, 0, 0, 0},
	{0},
};

	WISP_MSG_MAP_BEGIN(CPEExplorerForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

        WISP_CMD_MAP_BEGIN(CPEExplorerForm)
		WISP_CMD_MAP(3, OnCmdModuleSelect)
        WISP_CMD_MAP_END

        WISP_EVENT_MAP_BEGIN(CPEExplorerForm)
//		WISP_EVENT_MAP(, OnEvent)
        WISP_EVENT_MAP_END

	CPEExplorerForm::CPEExplorerForm()
	{
		m_Resource = PEExplorerForm;
		m_pTabWnd = 0;
		m_pPEHeaderWnd = 0;
		m_pPERelcationWnd = 0;
		m_pPEImportWnd = 0;
		m_pPEExportWnd = 0;
	}
	CPEExplorerForm::~CPEExplorerForm()
	{
	}

	bool CPEExplorerForm::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pTabWnd = (CWispTabWnd *)GetFormItem(2);

		m_pPEHeaderWnd = new CPEHeaderWnd;
		m_pPEHeaderWnd->CreateWnd(0, 0,0,0,0, m_pTabWnd, 4, 0, WISP_SH_MINSIZE);
		m_pPEHeaderWnd->SetOwner(this);
		m_pTabWnd->InsertWnd(WSTR("PE Header"), m_pPEHeaderWnd, 0);
		m_pPEHeaderWnd->m_AdvStyle |= 1;

		m_pModuleList = (CWispComboBox *)GetFormItem(3);

		if (gpSyser->m_pDebugger)
		{
		map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
		//while (it != gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.end())
		while (it)
		{
			CListStringItem *Item = m_pModuleList->m_ComboList.InsertItemStr(it->second.m_pName, 0, 0, 0, -1);
			m_pModuleList->m_ComboList.SetItemValue(Item, 0, it->second.m_ImageBase);
			++it;
		}
		}
		m_pModuleList->SetCurSel(0);

		m_pPEDataDirectoryWnd = new CPEDataDirectoryWnd;
		m_pPEDataDirectoryWnd->CreateWnd(0, 0,0,0,0, m_pTabWnd, 0x105, 0, WISP_SH_MINSIZE);
		m_pPEDataDirectoryWnd->SetOwner(this);
		m_pTabWnd->InsertWnd(WSTR("Data Directories"), m_pPEDataDirectoryWnd, 0);
		m_pPEDataDirectoryWnd->m_AdvStyle |= 1;

		m_pPERelcationWnd = new CPERelcationWnd;
		m_pPERelcationWnd->CreateWnd(0, 0,0,0,0, m_pTabWnd, 5, 0, WISP_SH_MINSIZE);
		m_pPERelcationWnd->SetOwner(this);
		m_pTabWnd->InsertWnd(WSTR("Relocations"), m_pPERelcationWnd, 0);
		m_pPERelcationWnd->m_AdvStyle |= 1;

		m_pPEImportWnd = new CPEImportWnd;
		m_pPEImportWnd->CreateWnd(0, 0,0,0,0, m_pTabWnd, 6, 0, WISP_SH_MINSIZE);
		m_pPEImportWnd->SetOwner(this);
		m_pTabWnd->InsertWnd(WSTR("Imports"), m_pPEImportWnd, 0);
		m_pPEImportWnd->m_AdvStyle |= 1;

		m_pPEExportWnd = new CPEExportWnd;
		m_pPEExportWnd->CreateWnd(0, 0,0,0,0, m_pTabWnd, 7, 0, WISP_SH_MINSIZE);
		m_pPEExportWnd->SetOwner(this);
		m_pTabWnd->InsertWnd(WSTR("Exports"), m_pPEExportWnd, 0);
		m_pPEExportWnd->m_AdvStyle |= 1;

		return true;
	}

	bool CPEExplorerForm::OnCmdModuleSelect(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000400)
		{
			ULONG_PTR Addr = m_pModuleList->m_ComboList.GetItemValue((CListStringItem *)pMsg->Command.Param2, 0);
			Open(Addr);
		}
		return true;
	}
	bool CPEExplorerForm::SelectModule(ULONG_PTR Address)
	{
		unsigned int Index = 0;
		unsigned int Count = m_pModuleList->m_ComboList.GetItemCount(0, 1);
		for (Index = 0; Index < Count; ++Index)
		{
			CListStringItem *Item = m_pModuleList->m_ComboList.GetItem(Index, 0);
			if (!Item) break;
			if (Address == m_pModuleList->m_ComboList.GetItemValue(Item, 0))
			{
				m_pModuleList->SetCurSel(Index);
				break;
			}
		}
		return true;
	}

	bool CPEExplorerForm::OpenModule(ULONG_PTR Address)
	{
		if (m_MemPEFile.m_hHandle || m_MemPEFile.m_Buffer)
			m_MemPEFile.Close();
			//PE_OPEN_SYS | PE_OPEN_DLL | 1
		return m_MemPEFile.Open(Address, 7, &CDebugger::Read, gpSyser->m_pDebugger);
	}

	void CPEExplorerForm::Open(ULONG_PTR Address)
	{
		if (IsWindow() && OpenModule(Address))
		{
			SelectModule(Address);
			m_pPEHeaderWnd->Open(&m_MemPEFile);
			m_pPEImportWnd->Open(&m_MemPEFile);
			m_pPEExportWnd->Open(&m_MemPEFile);
			m_pPEDataDirectoryWnd->Open(&m_MemPEFile);
		}
	}

	void CPEExplorerForm::Create()
	{
		if (IsWindow())
			Show(WISP_SH_MINSIZE);
		else	CWispForm::Create(0, WISP_SH_MINSIZE);
	}

```

`source/WispSyser/peexplorerform.hpp`:

```hpp

#ifndef _PEEXPLORERFORM_HPP_
#define _PEEXPLORERFORM_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wisptabwnd.hpp"
#include "../Wisp/wispcombobox.hpp"
#include "../Wisp/wisplist.hpp"
#include "../EXEAnalyzer/pefile.hpp"

struct CPEHeaderWnd : public CWispWnd
{
	CWispList m_COFF;
	CWispList m_WIN;
	CListStringItem *m_pItems[33];

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool InitContext();
	bool Open(CPEFile *pPEFile);
};

struct CPERelcationWnd : public CWispWnd
{
	CWispList m_ModuleList;
	CWispList m_EntryList;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool InitContext();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
};

///
struct CPEImportModuleList : public CWispList
{
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnMouseDblClick(WISP_MSG *pMsg);
};

struct CPEImportEntryList : public CWispList
{
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnMouseDblClick(WISP_MSG *pMsg);
};

struct CPEImportWnd : public CWispWnd
{
	CPEImportModuleList m_ModuleList;
	CPEImportEntryList m_EntryList;
	CPEFile *m_pPEFile;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdSelectEntry(WISP_MSG *pMsg);

	bool InitContext();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool Open(CPEFile *pPEFile);
	ULONG_PTR GetImageBase(const char *szModuleName);
};
///
struct CPEExportList : public CWispList
{
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnMouseDblClick(WISP_MSG *pMsg);
};

struct CPEExportWnd : public CWispWnd
{
	CPEExportList m_ExportList;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool InitContext();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool Open(CPEFile *pPEFile);
};
///
struct CPEDataDirectoryList : public CWispList
{
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnMouseDblClick(WISP_MSG *pMsg);
};

struct CPEDataDirectoryWnd : public CWispWnd
{
	CPEDataDirectoryList m_DirectoryList;
	CListStringItem *m_pItems[16];

	bool OnCreate(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	bool InitContext();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool Open(CPEFile *pPEFile);
};

///
struct CPEExplorerForm : public CWispForm
{
	CPEFile m_MemPEFile;//CMemPEFile
	CPEHeaderWnd *m_pPEHeaderWnd;
	CWispTabWnd *m_pTabWnd;
	CPERelcationWnd *m_pPERelcationWnd;
	CPEImportWnd *m_pPEImportWnd;
	CPEExportWnd *m_pPEExportWnd;
	CPEDataDirectoryWnd *m_pPEDataDirectoryWnd;
	CWispComboBox *m_pModuleList;

	CPEExplorerForm();
	virtual ~CPEExplorerForm();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdModuleSelect(WISP_MSG *pMsg);
	bool SelectModule(ULONG_PTR Address);
	bool OpenModule(ULONG_PTR Address);
	void Open(ULONG_PTR Address);
	void Create();
};

#endif
```

`source/WispSyser/plugin.cpp`:

```cpp
    #include "plugin.hpp"
 
    void OnDebuggerOpen()
    {
            //Syser Loaded Notify
            //::DbgPrint("SPCommand : OnDebuggerOpen\n");
    }
 
    void OnDebuggerClose()
    {
            //Syser Unload Notify
            //::DbgPrint("SPCommand : OnDebuggerClose\n");
    }
 
    void OnDebuggerPlunge()
    {
            //Syser
            //::DbgPrint("SPCommand : OnDebuggerPlunge\n");
    }
 
    SYSER_PLUGIN_MODULE PluginModule =
    {
        L"Syser Command Plugin Module",
        OnDebuggerOpen,
        OnDebuggerClose,
        OnDebuggerPlunge,
    };
 
    int syser_calc(int argc, const wchar_t *argv[], const wchar_t *szCommandLine, void *pUserData)
    {
            DWORD dwValue;
            if(argc>=2)
            {
                    if(gpSyserPluginUI->CalcExp(argv[1], &dwValue))
                    {
                            gpSyserPluginUI->Outputf(WSTR("%s = %08x\n"), argv[1], dwValue);
                    }
            }
            gpSyserPluginUI->Outputf(WSTR("hello world!\n"));
            return 0;
    }
 
    BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)
    {
        switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
            if(!gpSyserPluginUI->RegisterPluginModule(WSTR("SPCommand"), &PluginModule))
                return FALSE;
            gpSyserPluginUI->InsertCmd(WSTR("calc"), syser_calc, NULL, WSTR("calc expression value."), WSTR("calc [parameter]"));
            //::DbgPrint("SPCommand : DllAttach\n");
            break;
        case DLL_PROCESS_DETACH:
            gpSyserPluginUI->RemoveCmd(WSTR("calc"));
            gpSyserPluginUI->UnregisterPluginModule(WSTR("SPCommand"));
            //::DbgPrint("SPCommand : DllDetach\n");
            break;    
 
        case DLL_THREAD_ATTACH:
            break;        
 
        case DLL_THREAD_DETACH:
            break;
        }    
        return TRUE;  
    }

```

`source/WispSyser/plugin.hpp`:

```hpp

#ifndef _PLUGIN_HPP_
#define _PLUGIN_HPP_

#include "../Code/define.h"

	typedef void (*FPMenuProc)();
	typedef int (*FPCmd)(int argc, const WCHAR *argv[], const WCHAR *szCommandLine, void *pUserData);

	typedef void (*PVFV)();

	struct SYSER_PLUGIN_MODULE
	{
		WCHAR PluginInfo[32];
		PVFV fpOnDebuggerOpen;
		PVFV fpOnDebuggerClose;
		PVFV fpOnDebuggerPlunge;
	};

	struct CSyserPluginUI
	{
		virtual bool RegisterPluginModule(const WCHAR *ModuleName, SYSER_PLUGIN_MODULE *pPluginModule) = 0;
		virtual bool UnregisterPluginModule(const WCHAR *ModuleName) = 0;

		virtual int GetInstrLen(ULONG_PTR Address) = 0;

		virtual bool CalcExp(const WCHAR *szExp, ULONG_PTR *pResult) = 0;

		virtual bool InsertCmd(const WCHAR *szCmd, FPCmd pCmdProc, void *pUserData, const WCHAR *pComment, const WCHAR *pUsage) = 0;
		virtual void RemoveCmd(const WCHAR *szCmd) = 0;
		virtual int RunCmd(const WCHAR *szCmd) = 0;

		virtual void Outputf(const WCHAR *szFormat, ...) = 0;
		virtual void Output(const unsigned long *szMsg) = 0;

		virtual void *InsertMenu(void *hParentMenu, const WCHAR *szMenuName, FPMenuProc fpMenuProc) = 0;
		virtual bool RemoveMenu(void *hMenu) = 0;
		virtual bool EnableMenu(void *hMenu, bool bEnable) = 0;

		virtual void *GetMainTabWnd() = 0;
		virtual void *GetMainMenu() = 0;
		virtual void *GetWisp() = 0;

		virtual unsigned long WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size) = 0;
		virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) = 0;
	};

	extern "C" __declspec(dllimport) CSyserPluginUI *gpSyserPluginUI;

#endif
```

`source/WispSyser/pluginlistform.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "pluginlistform.hpp"

WISP_FORM_RES_ITEM PluginListForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 400, 200}, 0, 0xB, WSTR("Plugin List"), (void*)("\\SyserIcon\\Plugin.ico"), WSTR("Syser Plugin List !")},
	{WISP_CTRL_LIST, {5, 5, 300, 160}, 1, 0x10006, 0, 0, 0},
	{WISP_CTRL_STATIC_DIB, {315, 30, 64, 64}, 0, 0, 0, (void*)("\\SyserIcon\\Plugin.ico"), 0},
	{WISP_CTRL_BUTTON, {312, 120, 70, 20}, WISP_ID_OK, 0, WSTR("OK"), 0, 0},
	{0},
};

	CPluginListForm::CPluginListForm()
	{
		m_Resource = PluginListForm;
	}

	CPluginListForm::~CPluginListForm()
	{
	}

	WISP_MSG_MAP_BEGIN(CPluginListForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
	WISP_MSG_MAP_END(CWispForm)

	void CPluginListForm::UpdateContext()
	{
		for (map<TWideString, SYSER_PLUGIN_MODULE>::IT it = gpSyser->m_PluginMap.begin();
			it != gpSyser->m_PluginMap.end(); ++it)
		{
			CListStringItem *pItem = m_pList->InsertItem(it->first.operator const WCHAR*(), 0, 0, 0, -1);
			m_pList->SetItemText(pItem, 1, it->second.PluginInfo);
		}
	}

	bool CPluginListForm::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pList = (CWispList *)GetFormItem(1);
		m_pList->InsertColumn(WSTR("Module Name"), 100, 0, 0, -1);
		m_pList->InsertColumn(WSTR("Information"), 190, 0, 0, -1);
		UpdateContext();
		return true;
	}

	void CPluginListForm::Create()
	{
		if (IsWindow())
		{
			UpdateContext();
			Show(WISP_SH_MINSIZE);
		} else
		{
			CWispForm::Create(0, WISP_SH_MINSIZE);
		}
	}

```

`source/WispSyser/pluginlistform.hpp`:

```hpp

#ifndef _PLUGINLISTFORM_HPP_
#define _PLUGINLISTFORM_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wisplist.hpp"

struct CPluginListForm : public CWispForm
{
	CWispList *m_pList;

	CPluginListForm();
	virtual ~CPluginListForm();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	void UpdateContext();
	bool OnCreateForm(WISP_MSG *pMsg);
	void Create();
};

#endif

```

`source/WispSyser/processlist.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "processlist.hpp"
#include "syserconfig.hpp"

	WISP_MSG_MAP_BEGIN(CProcessList)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
	WISP_MSG_MAP_END(CWispList)

	CProcessList::CProcessList()
	{
	}

	CProcessList::~CProcessList()
	{
	}

	bool CProcessList::OnUpdate(WISP_MSG *pMsg)
	{
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		UpdateItemColor(0);
		return true;
	}

	bool CProcessList::OnCreate(WISP_MSG *pMsg)
	{
		AttachTitleDIB(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xF));
		m_ItemColor = gSyserColors.Color[1];
		m_Style |= 0x1000000;
		SetBGColor(gSyserColors.Color[0]);
		InsertColumn(WSTR("Name"), 200, 0, 0, -1);
		InsertColumn(WSTR("ID"), 80, 0, 0, -1);
		InsertColumn(WSTR("User Name"), 80, 0, 0, -1);
		DeleteAllChildrenItems(0);
		m_pSystemList = InsertItem(WSTR("System Process List"), 0, 0, 0, -1);
		SetItemText(m_pSystemList, 1, WSTR("SYSTEM"));
		UpdateContext();
		return true;
	}

	bool CProcessList::OnClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}

	void CProcessList::OnLButton(CListStringItem *Item, int nCol)
	{
		if (Item != m_pSystemList)
		{
			WCHAR Text[256];
			GetItemText(Item, 1, Text, 256);
			if (Text[0] == '0' && Text[1] == 'x')
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("close"), 0);
				WCHAR szCmd[256];
				TSPrintf(szCmd, WSTR("open \\PID:%s"), &Text[2]);
				gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(szCmd, 0);
				Destroy();
			}
		}
	}
#ifndef _RING0_
#include <comdef.h>
#include <winnt.h>

	BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
	{
	//	HANDLE hProcess = GetCurrentProcess();
	//	HANDLE hToken;
	//	OpenProcessToken(hProcess, TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hToken);

		LUID luid;
		if ( !LookupPrivilegeValue(NULL, lpszPrivilege, &luid))
		{
			//printf("LookupPrivilegeValue error: %u\n", GetLastError() );
			return FALSE;
		}

		TOKEN_PRIVILEGES tp;

		tp.PrivilegeCount = 1;
		tp.Privileges[0].Luid = luid;

		if (bEnablePrivilege)
			tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
		else	tp.Privileges[0].Attributes = 0;

		if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL))
		{
			//printf("AdjustTokenPrivileges error: %u\n", GetLastError() );
			return FALSE;
		}

		if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
		{
			//printf("The token does not have the specified privilege. \n");
			return FALSE;
		}
		return TRUE;
	}

	bool GetOwnerName(HANDLE hProcess, WCHAR *pOwnerName, DWORD MaxSize)
	{
		*pOwnerName = 0;

		HANDLE hToken;
		if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken))
		{
	//		if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &hToken))
				return false;

	//		SetPrivilege(hToken, SE_DEBUG_NAME, TRUE);
			//TODO
		}

		DWORD Size = 0;
		PTOKEN_USER ptu = NULL;
		GetTokenInformation(hToken, TokenUser, (LPVOID)ptu, 0, &Size);

		if (Size == 0)
		{
			CloseHandle(hToken);
			return false;
		}

		ptu = (PTOKEN_USER)(new BYTE[Size]);
		if (!GetTokenInformation(hToken, TokenUser, (LPVOID)ptu, Size, &Size))
		{
			delete []ptu;
			CloseHandle(hToken);
			return false;
		}

		SID_NAME_USE SidType;
		WCHAR Domain[MAX_FN_LEN];
		DWORD dwSize = MaxSize;
		Size = MAX_FN_LEN;
		bool ret = LookupAccountSidW(NULL, ptu->User.Sid, pOwnerName, &dwSize, Domain, &Size, &SidType);

		delete []ptu;
		CloseHandle(hToken);
	
		return ret;
	}

#include <tlhelp32.h>
#include <psapi.h>
#include <wow64apiset.h>
#endif
	bool CProcessList::UpdateContext()
	{
#ifndef _RING0_
		int SubListSize = 0;
		int MainListSize = 0;

		HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (hProcessSnap == INVALID_HANDLE_VALUE)
			return false;

		CListStringItem *Item = GetItem(0, m_pSystemList);
		CListStringItem *NextItem = GetNext(m_pSystemList, 0);

		PROCESSENTRY32W pe32;
		pe32.dwSize = sizeof(pe32);
		if(Process32FirstW(hProcessSnap, &pe32))
		{
		do {
		//	SetPrivilege(GetCurrentProcess(), SE_DEBUG_NAME, TRUE);
			HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pe32.th32ProcessID);

			WCHAR OwnerName[MAX_FN_LEN];
			GetOwnerName(hProcess, OwnerName, MAX_FN_LEN);
	
			if (!OwnerName[0])
				TStrCpy(OwnerName, WSTR("SYSTEM"));

			CListStringItem *pSystemList = NULL;
			if (!TStrCmp(OwnerName, WSTR("SYSTEM")))
			{
				pSystemList = m_pSystemList;
				++SubListSize;
			} else
			{
				pSystemList = 0;
				++MainListSize;
			}

			WCHAR szModule[MAX_FN_LEN];
			TStrCpy(szModule, TGetFileName(pe32.szExeFile));
		#if 1
			BOOL bIsWow64 = FALSE;
			if (IsWow64Process(hProcess, &bIsWow64));
			if (bIsWow64)
				TStrCat(szModule, "*32");
		#endif

			CListStringItem *Item = InsertItem(szModule, pSystemList, 0, 0, -1);

			PROCESS_MEMORY_COUNTERS pmc;
			pmc.cb = 0;
			pmc.PageFaultCount = 0;
			pmc.PeakWorkingSetSize = 0;
			pmc.WorkingSetSize = 0;
			pmc.QuotaPeakPagedPoolUsage = 0;
			pmc.QuotaPagedPoolUsage = 0;
			pmc.QuotaPeakNonPagedPoolUsage = 0;
			pmc.QuotaNonPagedPoolUsage = 0;
			pmc.PagefileUsage = 0;
			pmc.PeakPagefileUsage = 0;
			GetProcessMemoryInfo(hProcess, &pmc, sizeof(pmc));
			
			SetItemValue(Item, 0, pe32.th32ProcessID);
			SetItemFormat(Item, 1, pe32.th32ProcessID, WSTR("0x%X"));
			SetItemText(Item, 2, OwnerName);
			GetNext(Item, 0);

			CloseHandle(hProcess);
		} while (Process32NextW(hProcessSnap, &pe32));
		}

		CloseHandle(hProcessSnap);

		Adjust(0, MainListSize + 1);
		Adjust(m_pSystemList, SubListSize);
#endif
		return true;
	}

	void CProcessList::Create()
	{
		if (IsWindow())
		{
			Destroy();
		} else
		{
			WISP_RECT Rect;
			Rect.x = 0;
			Rect.y = 0;
			Rect.cx = 500;
			Rect.cy = 350;
			CreateWnd(WSTR("Processes"), Rect, 0, 0, 0x300BB, WISP_SH_MINSIZE);
			Center(0);
		}
	}

```

`source/WispSyser/processlist.hpp`:

```hpp

#ifndef _PROCESSLIST_HPP_
#define _PROCESSLIST_HPP_

#include "../Wisp/wisplist.hpp"

struct CProcessList : public CWispList
{
	CListStringItem *m_pSystemList;

	CProcessList();
	virtual ~CProcessList();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnClose(WISP_MSG *pMsg);

	virtual void OnLButton(CListStringItem *Item, int nCol) override;

	bool UpdateContext();
	void Create();
};

#endif
```

`source/WispSyser/reghelpwnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "reghelpwnd.hpp"

	WISP_MSG_MAP_BEGIN(CRegHelpWnd)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
	WISP_MSG_MAP_END(CWispWnd)

	CRegHelpWnd::CRegHelpWnd()
	{
		m_RegisterGroup = -1;
	}
	CRegHelpWnd::~CRegHelpWnd()
	{
	}

//
	stRegisterBitName stCR4Name[] = {
			{WSTR("Reserved (Set to 0)"), 31, 21, NULL},
			{WSTR(""),10, 1,WSTR("OSXMMEX")},
			{WSTR(""),9, 1, WSTR("OSFXSR")},
			{WSTR("P\nC\nE"),8,1,NULL},
			{WSTR("P\nG\nE"),7,1,NULL},
			{WSTR("M\nC\nE"),6,1,NULL},
			{WSTR("P\nA\nE"),5,1,NULL},
			{WSTR("P\nS\nE"),4,1,NULL},
			{WSTR("D\nE"),3,1,NULL},
			{WSTR("T\nS\nD"),2,1,NULL},
			{WSTR("P\nV\nI"),1,1,NULL},
			{WSTR("V\nM\nE"),0,1,NULL},
			{NULL,0,0,NULL}};
	stRegisterBitName stCR3Name[] = {
			{WSTR("Page-Directory Base"),31,20,NULL},
			{WSTR("P\nC\nD"),4,1,NULL},
			{WSTR("P\nW\nT"),3,1,NULL},
			{NULL,0,0,NULL}};
	stRegisterBitName stCR2Name[] = {
			{WSTR("Page-Fault Linear Address"),31,32,NULL},
			{NULL,0,0,NULL}};
	stRegisterBitName stCR0Name[] = {
			{WSTR("P\nG"),31,1,NULL},
			{WSTR("C\nD"),30,1,NULL},
			{WSTR("N\nW"),29,1,NULL},
			{WSTR("A\nM"),18,1,NULL},
			{WSTR("W\nP"),16,1,NULL},
			{WSTR("N\nE"),5,1,NULL},
			{WSTR("E\nT"),4,1,NULL},
			{WSTR("T\nS"),3,1,NULL},
			{WSTR("E\nM"),2,1,NULL},
			{WSTR("M\nP"),1,1,NULL},
			{WSTR("P\nE"),0,1,NULL},
			{NULL,0,0,NULL}};
//
	stRegisterBitName stDR7Name[] = {
			{WSTR("L\n0"),0,1,NULL},
			{WSTR("G\n0"),1,1,NULL},
			{WSTR("L\n1"),2,1,NULL},
			{WSTR("G\n1"),3,1,NULL},
			{WSTR("L\n2"),4,1,NULL},
			{WSTR("G\n2"),5,1,NULL},
			{WSTR("L\n3"),6,1,NULL},
			{WSTR("G\n3"),7,1,NULL},
			{WSTR("L\nE"),8,1,NULL},
			{WSTR("G\nE"),9,1,NULL},
			{WSTR("1"),10,1,NULL},
			{WSTR("0"),11,1,NULL},
			{WSTR("0"),12,1,NULL},
			{WSTR("G\nD"),13,1,NULL},
			{WSTR("0"),14,1,NULL},
			{WSTR("0"),15,1,NULL},
			{WSTR("R/W\n0"),17,2,NULL},
			{WSTR("LEN\n0"),19,2,NULL},
			{WSTR("R/W\n1"),21,2,NULL},
			{WSTR("LEN\n1"),23,2,NULL},
			{WSTR("R/W\n2"),25,2,NULL},
			{WSTR("LEN\n2"),27,2,NULL},
			{WSTR("R/W\n3"),29,2,NULL},
			{WSTR("LEN\n4"),31,2,NULL},
			{NULL,0,0,NULL}};

	stRegisterBitName stDR6Name[] = {
			{WSTR("B\n0"),0,1,NULL},
			{WSTR("B\n1"),1,1,NULL},
			{WSTR("B\n2"),2,1,NULL},
			{WSTR("B\n3"),3,1,NULL},
			{WSTR("1"),4,1,NULL},
			{WSTR("1"),5,1,NULL},
			{WSTR("1"),6,1,NULL},
			{WSTR("1"),7,1,NULL},
			{WSTR("1"),8,1,NULL},
			{WSTR("1"),9,1,NULL},
			{WSTR("1"),10,1,NULL},
			{WSTR("1"),11,1,NULL},
			{WSTR("0"),12,1,NULL},
			{WSTR("B\nD"),13,1,NULL},
			{WSTR("B\nS"),14,1,NULL},
			{WSTR("B\nT"),15,1,NULL},
			{WSTR("Reserved(set to 1)"),31,16,NULL},
			{NULL,0,0,NULL}};

	stRegisterBitName stDR5Name[] = {
			{WSTR("Reserved"),31,32,NULL},
			{NULL,0,0,NULL}};

	stRegisterBitName stDR4Name[] = {
			{WSTR("Reserved"),31,32,NULL},
			{NULL,0,0,NULL}};

	stRegisterBitName stDR3Name[] = {
			{WSTR("Breakpoint Linear Address"),31,32,NULL},
			{NULL,0,0,NULL}};

	stRegisterBitName stDR2Name[] = {
			{WSTR("Breakpoint 2 Linear Address"),31,32,NULL},
			{NULL,0,0,NULL}};

	stRegisterBitName stDR1Name[] = {
			{WSTR("Breakpoint 1 Linear Address"),31,32,NULL},
			{NULL,0,0,NULL}};

	stRegisterBitName stDR0Name[] = {
			{WSTR("Breakpoint 0 Linear Address"),31,32,NULL},
			{NULL,0,0,NULL}};
//
	stRegisterBitName SystemSegmentDesc0[] = {
			{WSTR("Base 31:24"),31,8,NULL},
			{WSTR("G"),23,1,NULL},
			{WSTR("B"),22,1,NULL},
			{WSTR("0"),21,1,NULL},
			{WSTR("A\nV\nL"),20,1,NULL},
			{WSTR("Limit\n19:16"),19,4,NULL},
			{WSTR("P"),15,1,NULL},
			{WSTR("D\nP\nL"),14,2,NULL},
			{WSTR("1"),12,1,NULL},
			{WSTR("Type"),11,4,NULL},
			{WSTR("Base 23:16"),7,8,NULL},
			{NULL,0,0,NULL}};
	stRegisterBitName SystemSegmentDesc1[] = {
			{WSTR("Base Address 15:00"),31,16,NULL},
			{WSTR("Segment Limit 15:00"),15,16,NULL},			
			{NULL,0,0,NULL}};

	stRegisterBitName CodeSegmentDesc0[] = {
			{WSTR("Base 31:24"),31,8,NULL},
			{WSTR("G"),23,1,NULL},
			{WSTR("D"),22,1,NULL},
			{WSTR("0"),21,1,NULL},
			{WSTR("A\nV\nL"),20,1,NULL},
			{WSTR("Limit\n19:16"),19,4,NULL},
			{WSTR("P"),15,1,NULL},
			{WSTR("D\nP\nL"),14,2,NULL},
			{WSTR("1"),12,1,NULL},
			{WSTR("Type"),11,4,NULL},
			{WSTR("Base 23:16"),7,8,NULL},
			{NULL,0,0,NULL}};
	stRegisterBitName CodeSegmentDesc1[] = {
			{WSTR("Base Address 15:00"),31,16,NULL},
			{WSTR("Segment Limit 15:00"),15,16,NULL},			
			{NULL,0,0,NULL}};

	stRegisterBitName DataSegmentDesc0[] = {
			{WSTR("Base 31:24"),31,8,NULL},
			{WSTR("G"),23,1,NULL},
			{WSTR("0"),21,1,NULL},
			{WSTR("Limit\n19:16"),19,4,NULL},
			{WSTR("P"),15,1,NULL},
			{WSTR("D\nP\nL"),14,2,NULL},
			{WSTR("0"),12,1,NULL},
			{WSTR("Type"),11,4,NULL},
			{WSTR("Base 23:16"),7,8,NULL},
			{NULL,0,0,NULL}};
	stRegisterBitName DataSegmentDesc1[] = {
			{WSTR("Base Address 15:00"),31,16,NULL},
			{WSTR("Segment Limit 15:00"),15,16,NULL},			
			{NULL,0,0,NULL}};

//
	stRegisterBitName stEFlagsName[] = {
			{WSTR("Reserved(set to 0)"),31,10,NULL},
			{WSTR("I\nD"),21,1,WSTR("ID   -- Identification Flag")},
			{WSTR("V\nI\nP"),20,1,WSTR("VIP  -- Virtual Interrupt Pending")},
			{WSTR("V\nI\nF"),19,1,WSTR("VIF  -- Virtual Interrupt Flag")},
			{WSTR("A\nC"),18,1,WSTR("AC   -- Alignment Check")},
			{WSTR("V\nM"),17,1,WSTR("VM   -- Virtual-8086 Mode")},
			{WSTR("R\nF"),16,1,WSTR("RF   -- Resume Flag")},
			{WSTR("0"),15,1,NULL},
			{WSTR("N\nT"),14,1,WSTR("NT   -- Nested Task Flag")},
			{WSTR("IOPL"),13,2,WSTR("IOPL -- I/O Privilege Level")},
			{WSTR("O\nF"),11,1,NULL},
			{WSTR("O\nF"),10,1,NULL},
			{WSTR("I\nF"),9,1,WSTR("IF   -- Interrupt Enable Flag")},
			{WSTR("T\nF"),8,1,WSTR("TF   -- Trap Flag")},
			{WSTR("S\nF"),7,1,WSTR("SF   -- Sign Flag")},
			{WSTR("Z\nF"),6,1,WSTR("ZF   -- Zero Flag")},
			{WSTR("0"),5,1,NULL},
			{WSTR("A\nF"),4,1,WSTR("AF   -- Auxiliary Carry Flag")},
			{WSTR("0"),3,1,NULL},
			{WSTR("P\nF"),2,1,WSTR("PF   -- Parity Flag")},
			{WSTR("1"),1,1,NULL},
			{WSTR("C\nF"),0,1,WSTR("CF   -- Carry Flag")},
			{NULL,0,0,NULL}};
//
	stRegisterBitName PageDirEntry4M[] = {
			{WSTR("Page Base Address"),31,10,NULL},
			{WSTR("Reserved"),21,9,NULL},
			{WSTR("P\nA\nT"),12,1,WSTR("Page Table Attribute Index")},
			{WSTR("Avail."),11,3,WSTR("Available for system programmer's use")},
			{WSTR("G"),8,1,WSTR("Global page")},
			{WSTR("P\nS"),7,1,WSTR("Page size(1 indicates 4 MBytes)")},
			{WSTR("D"),6,1,WSTR("Dirty")},
			{WSTR("A"),5,1,WSTR("Accessed")},
			{WSTR("P\nC\nD"),4,1,WSTR("Cache disabled")},
			{WSTR("P\nW\nT"),3,1,WSTR("Write-through")},
			{WSTR("U\n/\nS"),2,1,WSTR("User/Supervisor")},
			{WSTR("R\n/\nW"),1,1,WSTR("Read/Write")},
			{WSTR("P"),0,1,WSTR("Present")},
			{NULL,0,0,NULL}};
//
	stRegisterBitName PageDirEntry4K[] = {
			{WSTR("Page-Table Base Address"),31,20,NULL},
			{WSTR("Avail"),11,3,WSTR("Available for system programmer's use")},
			{WSTR("G"),8,1,WSTR("Global page (Ignored)")},
			{WSTR("P\nS"),7,1,WSTR("Page size(0 indicates 4 KBytes)")},
			{WSTR("0"),6,1,WSTR("Reserved (set to 0)")},
			{WSTR("A"),5,1,WSTR("Accessed")},
			{WSTR("P\nC\nD"),4,1,WSTR("Cache disabled")},
			{WSTR("P\nW\nT"),3,1,WSTR("Write-through")},
			{WSTR("U\n/\nS"),2,1,WSTR("User/Supervisor")},
			{WSTR("R\n/\nW"),1,1,WSTR("Read/Write")},
			{WSTR("P"),0,1,WSTR("Present")},
			{NULL,0,0,NULL}};

	stRegisterBitName PageTabEntry4K[] = {
			{WSTR("Page Base Address"),31,20,NULL},
			{WSTR("Avail"),11,3,WSTR("Available for system programmer's use")},
			{WSTR("G"),8,1,WSTR("Global page (Ignored)")},
			{WSTR("P\nA\nT"),7,1,WSTR("Page Table Attribute Index")},
			{WSTR("D"),6,1,WSTR("Dirty")},
			{WSTR("A"),5,1,WSTR("Accessed")},
			{WSTR("P\nC\nD"),4,1,WSTR("Cache disabled")},
			{WSTR("P\nW\nT"),3,1,WSTR("Write-through")},
			{WSTR("U\n/\nS"),2,1,WSTR("User/Supervisor")},
			{WSTR("R\n/\nW"),1,1,WSTR("Read/Write")},
			{WSTR("P"),0,1,WSTR("Present")},
			{NULL,0,0,NULL}};

//
	bool CRegHelpWnd::OnUpdateClient(WISP_MSG *pMsg)
	{

		int FontHeight = m_ClientDC.GetTextHeight((WCHAR)0);//WSTR("M"));
		m_ClientDC.DrawFullRect(&m_ClientRect, gpCurWisp->m_pWispDrawObj->m_crSystem[1]);
		int y = 10;
		//CWispDC WispDC;

		if (m_RegisterGroup == 0)
		{
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, 10, 0x80000FFF, 0xFFFFF800, 0x7FF, 0, m_ClientDC, stCR4Name, WSTR("CR4"));
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, FontHeight + 100, 0x8000183D, 0xFE7, 0x81C, 0, m_ClientDC, stCR3Name, WSTR("CR3"));
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			y = 2 * FontHeight + 145;
			DrawRegister(10, y, 0x80000001, 0, 0, 0, m_ClientDC, stCR2Name, WSTR("CR2"));
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			y += FontHeight + 45;
			DrawRegister(10, y, 0x80000001, 0xFFFFFFFF, 0, 0, m_ClientDC, 0, WSTR("CR1"));
			y += FontHeight + 45;
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, y, 0xF00F807F, 0x1FFAFFC0, 0x7007803F, 0, m_ClientDC, stCR0Name, WSTR("CR0"));
		}

		if (m_RegisterGroup == 1)
		{
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, y, 0xFFFFFFFF, 0xDC00, 0xAAAAB3FF, 0, m_ClientDC, stDR7Name, WSTR("DR7"));
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			y += FontHeight + 45;
			DrawRegister(10, y, 0x8001FFFF, 0xFFFF1FF0, 0xF00F, 0, m_ClientDC, stDR6Name, WSTR("DR6"));
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			y += FontHeight + 45;
			DrawRegister(10, y, 0x80000001, 0xFFFFFFFF, 0, 0, m_ClientDC, stDR5Name, WSTR("DR5"));
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			y += FontHeight + 45;
			DrawRegister(10, y, 0x80000001, 0xFFFFFFFF, 0, 0, m_ClientDC, stDR4Name, WSTR("DR4"));
			y += FontHeight + 45;
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, y, 0x80000001, 0, 0, 0, m_ClientDC, stDR3Name, WSTR("DR0 - DR3"));
		}

		if (m_RegisterGroup == 2)
		{
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, y, 0x81F9F981, 0x200000, 0x80F8D880, 0, m_ClientDC, SystemSegmentDesc0, 0);
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			y += FontHeight + 45;
			DrawRegister(10, y, 0x80018001, 0, 0x8000, 0, m_ClientDC, SystemSegmentDesc1, 0);
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			y += FontHeight + 45;
			DrawRegister(10, y, 0x81F9F981, 0x200000, 0x80F8D880, 0, m_ClientDC, CodeSegmentDesc0, 0);
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			y += FontHeight + 45;
			DrawRegister(10, y, 0x80018001, 0, 0x8000, 0, m_ClientDC, CodeSegmentDesc1, 0);
			y += FontHeight + 45;
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, y, 0x81F9F981, 0x700000, 0x80F8D880, 0, m_ClientDC, DataSegmentDesc0, 0);
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			y += FontHeight + 45;
			DrawRegister(10, y, 0x80018001, 0, 0x8000, 0, m_ClientDC, DataSegmentDesc1, 0);
		}

		if (m_RegisterGroup == 3)
		{
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(40, y, 0x807FFFFF, 0xFFC0802A, 0x3FEFFFu, 1, m_ClientDC, stEFlagsName, 0);
		}

		if (m_RegisterGroup == 4)
		{
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, y, 0x80603BFF, 0x3FE000, 0x2019FF, 0, m_ClientDC, PageDirEntry4M, 0);
		}

		if (m_RegisterGroup == 5)
		{
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, y, 0x80003BFF, 0, 0x9FF, 0, m_ClientDC, PageDirEntry4K, 0);
			//memcpy(&WispDC, &m_ClientDC, sizeof(WispDC));
			DrawRegister(10, 225, 0x80003BFF, 0, 0x9FF, 0, m_ClientDC, PageTabEntry4K, 0);
		}
 
		return false;
	}

	bool CRegHelpWnd::DrawRegister(int x, int y, unsigned int NumberMask, unsigned int ReservedMask, unsigned int LineMask, unsigned int OtherMask, CWispDC DrawDC, stRegisterBitName *RegBitName, const WCHAR *RegisterName)
	{
		int FontHeight = DrawDC.GetTextHeight(0);//L"M");
		WISP_RECT rc;

		rc.x = x;
		rc.cy = FontHeight + 45;
		rc.y = y;
		rc.cx = 481;
		DrawDC.DrawFullRect(&rc, gpCurWisp->m_pWispDrawObj->m_crSystem[1]);

		int posy = FontHeight + y;

		rc.y = posy;
		rc.cx = 15;
		rc.cy = 45;
		int v27 = 31;
		int v25 = x;
		do {
			rc.x = v25;
			if ( ((ReservedMask >> v27) & 1) != 0)
				DrawDC.DrawFullRect(&rc, gpCurWisp->m_pWispDrawObj->m_crSystem[13]);
			--v27;
			v25 += 15;
		} while (v27 >= 0);

		rc.y = y;
		rc.cx = 15;
		rc.cy = FontHeight;
		int v11 = 31;
		int v12_v1 = x;
		do {
			rc.x = v12_v1;
			if ( ((NumberMask >> v11) & 1) != 0)
			{
				WCHAR DisplayOut[4];
				TSPrintf(DisplayOut, WSTR("%d"), v11);
				DrawDC.DrawString(DisplayOut, &rc, 0x25, 0, -1);
			}
			if ( ((LineMask >> v11) & 1) != 0 && v11 != 31)
				DrawDC.DrawVLine(rc.x, FontHeight + rc.y, rc.y + FontHeight + 44, gpCurWisp->m_pWispDrawObj->m_crSystem[0]);
			v12_v1 += 15;
			--v11;
		} while (v11 >= 0);

		if (RegBitName)
		{
			bool bDescriptorExist = false;
			rc.y = posy;
			rc.cy = 45;

			int i = 0;

			int DescriptorFieldMaxLen = 0;
			stRegisterBitName *regBitName = RegBitName;
			while (regBitName->BitLen != 0)
			{
				if (i > 31) break;
				rc.x = x + 15 * (31 - regBitName->BeginBitIndex);
				rc.cx = 15 * regBitName->BitLen;
				if (regBitName->RegName)
					DrawDC.DrawString(regBitName->RegName, &rc, 5, 0, -1);
				if (regBitName->Descriptor)
				{
					bDescriptorExist = true;
					int nTmp = 15 * (regBitName->BeginBitIndex - 31) + DrawDC.GetTextExtent(regBitName->Descriptor, -1, 0);
					if (DescriptorFieldMaxLen < nTmp)
						DescriptorFieldMaxLen = nTmp;
				}
				++i;
				++regBitName;
			}

			if (bDescriptorExist)
			{
				rc.cy = FontHeight;
				rc.x = x - DescriptorFieldMaxLen;

				int i = 0;
				int tmpy = 0;

				stRegisterBitName *regBitName = RegBitName;
				while (regBitName->BitLen != 0)
				{
					if (i > 31) break;
					if (regBitName->Descriptor)
					{
						rc.y = FontHeight + (FontHeight + 2)*tmpy + y + 65;
						int tlen = DrawDC.GetTextExtent(regBitName->Descriptor, -1, 0);
						int px = x - 15 * regBitName->BeginBitIndex;
						rc.cx = tlen;
						int py = (FontHeight + 2) / 2 + rc.y - 2;
						px += 472;
						DrawDC.DrawHLine(rc.x + tlen, px, py, gpCurWisp->m_pWispDrawObj->m_crSystem[0]);
						DrawDC.DrawVLine(px, posy + 47, py, gpCurWisp->m_pWispDrawObj->m_crSystem[0]);
						DrawDC.DrawString(regBitName->Descriptor, &rc, 0x24, 0, -1);
						++tmpy;
					}
					++i;
					++regBitName;
				}
			}
		}

		rc.x = x;
		rc.y = posy;
		rc.cx = 481;
		rc.cy = 45;
		DrawDC.DrawRect(&rc, gpCurWisp->m_pWispDrawObj->m_crSystem[0]);
		if (RegisterName)
		{
			rc.x = x + 490;
			rc.y = posy;
			DrawDC.DrawString(RegisterName, &rc, 0x104, 0, -1);
		}
		return false;
	}

	int CRegHelpWnd::SetRegisterGroup(int index)
	{
		if (index >= 0 && m_RegisterGroup < 6)
			m_RegisterGroup = index;
		return 0;
	}


	WISP_MSG_MAP_BEGIN(CX86RegHelpTabWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
	WISP_MSG_MAP_END(CWispTabWnd)


	bool CX86RegHelpTabWnd::OnCreate(WISP_MSG *pMsg)
	{
		WISP_RECT Rect;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		m_RegisterGroup[0].CreateWnd(WSTR("Control Register"), Rect, this, 0, 0, WISP_SH_MINSIZE);
		m_RegisterGroup[0].SetRegisterGroup(0);
		InsertWnd(WSTR("Control"), &m_RegisterGroup[0], 0);

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		m_RegisterGroup[1].CreateWnd(WSTR("Debug Register"), Rect, this, 0, 0, WISP_SH_MINSIZE);
		m_RegisterGroup[1].SetRegisterGroup(1);
		InsertWnd(WSTR("Debug"), &m_RegisterGroup[1], 0);

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		m_RegisterGroup[2].CreateWnd(WSTR("Segment Descriptor"), Rect, this, 0, 0, WISP_SH_MINSIZE);
		m_RegisterGroup[2].SetRegisterGroup(2);
		InsertWnd(WSTR("Segment Descriptor"), &m_RegisterGroup[2], 0);

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		m_RegisterGroup[3].CreateWnd(WSTR("Flags Register"), Rect, this, 0, 0, WISP_SH_MINSIZE);
		m_RegisterGroup[3].SetRegisterGroup(3);
		InsertWnd(WSTR("Flags Register"), &m_RegisterGroup[3], 0);

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		m_RegisterGroup[4].CreateWnd(WSTR("Flags Register"), Rect, this, 0, 0, WISP_SH_MINSIZE);
		m_RegisterGroup[4].SetRegisterGroup(4);
		InsertWnd(WSTR("Page Directory Entry (4M)"), &m_RegisterGroup[4], 0);

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		m_RegisterGroup[5].CreateWnd(WSTR("Flags Register"), Rect, this, 0, 0, WISP_SH_MINSIZE);
		m_RegisterGroup[5].SetRegisterGroup(5);
		InsertWnd(WSTR("Page Map (4K)"), &m_RegisterGroup[5], 0);
 
		return true;
	}

	void CX86RegHelpTabWnd::Create()
	{
		if (IsWindow())
		{
			Show(WISP_SH_MINSIZE);
		} else
		{
			WISP_RECT Rect;
			Rect.x = 0;
			Rect.y = 0;
			Rect.cx = 560;
			Rect.cy = 400;
			CreateWnd(WSTR("Register Help Wnd"), Rect, 0, 0, 0xBB, WISP_SH_MINSIZE);
			Center(nullptr);
		}
	}

```

`source/WispSyser/reghelpwnd.hpp`:

```hpp

#ifndef _REGHELPWND_HPP_
#define _REGHELPWND_HPP_

#include "../Wisp/wispwnd.hpp"
#include "../Wisp/wisptabwnd.hpp"

struct stRegisterBitName
{
	const WCHAR* RegName;
	int BeginBitIndex;
	int BitLen;
	const WCHAR* Descriptor;
};

struct CRegHelpWnd: public CWispWnd
{
	int m_RegisterGroup;

	CRegHelpWnd();
	virtual ~CRegHelpWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnUpdateClient(WISP_MSG *pMsg);

	bool DrawRegister(int x, int y, unsigned int NumberMask, unsigned int ReservedMask, unsigned int LineMask, unsigned int OtherMask, CWispDC DrawDC, stRegisterBitName *RegBitName, const WCHAR *RegisterName);
	int SetRegisterGroup(int index);
};

struct CX86RegHelpTabWnd: public CWispTabWnd
{
	CRegHelpWnd m_RegisterGroup[6];

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	void Create();
};

#endif
```

`source/WispSyser/resource.cpp`:

```cpp

#include "resource.hpp"

WISP_MENU_GROUP_ITEM SystemExplorerCharacterSetTablesMenu[] =
{
	{WSTR("IBM ASCII"), EVENT_ID_IBM, 0x67, 0, 0},
	{WSTR("ANSI ASCII"), EVENT_ID_ANSI, 0x67, 0, 0},
	{WSTR("EBCDIC"), EVENT_ID_EBCDIC, 0x67, 0, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerRecentFilesMenu[] =
{
	{WSTR("Empty"), EVENT_ID_FILE0, 0x84, 0, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerFileMenu[] =
{
	{WSTR("Open"), EVENT_ID_OPEN, 8, 0x100000, 0},
	{WSTR("Close"), EVENT_ID_CLOSE, 9, 0x100000, 0},
	{WSTR("Load Symbol Files"), EVENT_ID_LOADSYM, 0x0A, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Recent Files"), 0, 0x24, 1, SystemExplorerRecentFilesMenu},
	{0, 0, 0, 4, 0},
	{WSTR("Save Comments"), EVENT_ID_SAVECMT, 0x93, 0x100000, 0},
	{WSTR("Load Comments"), EVENT_ID_LOADCMT, 0x93, 0x100000, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerEditMenu[] =
{
	{WSTR("Undo"), EVENT_ID_EDIT_UNDO, 0xC8, 0, 0},
	{WSTR("Redo"), EVENT_ID_EDIT_REDO, 0xC9, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Cut"), EVENT_ID_EDIT_CUT, 0xC5, 0, 0},
	{WSTR("Copy"), EVENT_ID_EDIT_COPY, 0xC6, 0, 0},
	{WSTR("Paste"), EVENT_ID_EDIT_PASTE, 0xC7, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Find"), EVENT_ID_EDIT_FIND, 0xC, 0, 0},
	{WSTR("Relpace"), EVENT_ID_EDIT_REPLACE, 0x10E, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Go to...    Ctrl+G"), EVENT_ID_EDIT_GOTO, 0xE8, 0, 0},
	{0}
};

WISP_MENU_GROUP_ITEM SystemExplorerDebugMenu[] =
{
#ifndef _RING0_
	{WSTR("Reset"), EVENT_ID_DBG_RESET, 0x10, 0, 0},
#endif
	{WSTR("Continue      F5"), EVENT_ID_GO, 3, 0, 0},
	{WSTR("Return        F6"), EVENT_ID_DBG_RETURN, 2, 0, 0},
	{WSTR("Step          F8"), EVENT_ID_DBG_STEP, 0, 0, 0},
	{WSTR("Proceed       F10"), EVENT_ID_DBG_PROCEED, 1, 0, 0},
	{WSTR("Step Branch   F11"), EVENT_ID_DBG_STEPB, 0, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Break Point   Ctrl+F9"), EVENT_ID_BREAK_POINT, 4, 0, 0},
	{WSTR("Enable All Breakpoints"), EVENT_ID_BP_ENABLE_ALL, 0xF3, 0, 0},
	{WSTR("Disable All Breakpoints"), EVENT_ID_BP_DISABLE_ALL, 0xF4, 0, 0},
	{WSTR("Remove All Breakpoints"), EVENT_ID_BP_REMOVE_ALL, 0xF2, 0, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerMonitorMenu[] =
{
	{WSTR("Register View                 Alt+G"), EVENT_ID_REGVIEW, 0x34, 0, 0},
	{WSTR("Data View                     Alt+D"), EVENT_ID_DATAVIEW, 0x59, 0, 0},
	{WSTR("Call Stack                    Alt+C"), EVENT_ID_CALLSTACK, 0x12, 0, 0},
	{WSTR("Run Trace List"), EVENT_ID_RUNTRACE, 0xB5, 0, 0},
	{WSTR("Comment List"), EVENT_ID_CMTLIST, 0x93, 0, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerViewMenu[] =
{
	{WSTR("Save Position                 Shift+Enter"), EVENT_ID_SAVEPOS, 0x18, 0, 0},
	{WSTR("Jump To Previous Position     Backspace"), EVENT_ID_PREVPOS, 0x15, 0, 0},
	{WSTR("Jump To Next Position         Ctrl+Enter"), EVENT_ID_NEXTPOS, 0x14, 0, 0},
	{WSTR("Empty Position List"), EVENT_ID_CLRPOS, 0x26, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Toggle   BookMark             Ctrl+K"), EVENT_ID_TOGGLE_BM, 0xD0, 0, 0},
	{WSTR("Previous BookMark             Ctrl+P"), EVENT_ID_PREV_BM, 0xD2, 0, 0},
	{WSTR("Next     BookMark             Ctrl+N"), EVENT_ID_NEXT_BM, 0xD1, 0, 0},
	{WSTR("Clear    BookMark             Ctrl+L"), EVENT_ID_CLEAR_BM, 0xD3, 0, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerPlugins[] =
{
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerOptionMenu[] =
{
	{WSTR("Option"), EVENT_ID_CONFIG_OPTION, 0x33, 0, 0},
	{WSTR("Debugger Select"), EVENT_ID_DBG_LIST, 0x35, 0, 0},
	{WSTR("Plugin List"), EVENT_ID_PLUGINS, 0x1D, 0, 0},
	{WSTR("Plugins"), EVENT_ID_PLUGINS, 0x1D, 1, SystemExplorerPlugins}, //++ ??? TODO
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerToolsMenu[] =
{
	{WSTR("Memory Search"), EVENT_ID_MEMSEARCH, 0xDF, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Calculator"), EVENT_ID_CALC, 6, 0, 0},
	{WSTR("Soft Keyboard"), EVENT_ID_SOFTKB, 7, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("PE Explorer"), EVENT_ID_PE_EXPLORER, 0x0E, 0, 0},
	{WSTR("Character Set Tables"), 0, 0x24, 1, SystemExplorerCharacterSetTablesMenu},
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerHelpMenu[] =
{
	{WSTR("Register Help"), EVENT_ID_REG_HELP, 0x34, 0, 0},
#ifndef _RING0_
	{WSTR("Check New Version"), EVENT_ID_CHECK_NEW_VER, 0x68, 0, 0},
#endif
	{WSTR("About Syser"), EVENT_ID_ABOUT, 0x3E, 0, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerInformationMenu[] =
{
//#ifdef _RING0_
	{WSTR("IDT"), EVENT_ID_IDT, 0x1A, 0, 0},
	{WSTR("GDT"), EVENT_ID_GDT, 0x1A, 0, 0},
	{WSTR("LDT"), EVENT_ID_LDT, 0x1A, 0, 0},
	{WSTR("Page Map"), EVENT_ID_PAGEMAP, 0x33, 0, 0},
	{0, 0, 0, 4, 0},
//#endif
	{WSTR("String References"), EVENT_ID_STRREF, 0x0F, 0, 0},
	{WSTR("Processes"), EVENT_ID_PROCESS, 0x0F, 0, 0},
	{WSTR("Threads"), EVENT_ID_THREADS, 0xD4, 0, 0},
	{WSTR("Modules"), EVENT_ID_MODULES, 0xDC, 0, 0},
	{WSTR("Functions"), EVENT_ID_FUNCTIONS, 0xDC, 0, 0},
//	{WSTR("SEH chain"), EVENT_ID_SEH, 0xDC, 0, 0}, //???
#ifdef _RING0_
	{WSTR("Object Directory"), EVENT_ID_OBJDIR, 0xDC, 0, 0}, //???
	{WSTR("HWND"), EVENT_ID_HWND, 0xDC, 0, 0},
#endif
	{0},
};

WISP_MENU_GROUP_ITEM SystemExplorerMainMenu[] =
{
#ifndef _RING0_
	{WSTR("File"), 0, 0x3D, 1, SystemExplorerFileMenu},
#endif
//TODO	{WSTR("Edit"), 0, 0x3D, 1, SystemExplorerEditMenu},
	{WSTR("Debug"), 0, 0x39, 1, SystemExplorerDebugMenu},
	{WSTR("Monitor"), 0, 0x35, 1, SystemExplorerMonitorMenu},
	{WSTR("View"), 0, 0x7E, 1, SystemExplorerViewMenu},
	{WSTR("Information"), 0, 0x5F, 1, SystemExplorerInformationMenu},
#ifndef _RING0_
	{WSTR("Option"), 0, 0x33, 1, SystemExplorerOptionMenu},
#endif
	{WSTR("Tools"), 0, 0x76, 1, SystemExplorerToolsMenu},
	{WSTR("Help"), 0, 0x1E, 1, SystemExplorerHelpMenu},
	{0},
};

WISP_TOOLBAR_RES_ITEM SystemExplorerToolbar[] =
{
#ifndef _RING0_
	{EVENT_ID_OPEN, 8, 0, WSTR("File -> Open"), 0, 0x200},
	{EVENT_ID_CLOSE, 9, 0, WSTR("File -> Close"), 0, 0x200},
	{EVENT_ID_DBG_RESET, 0x10, 0, WSTR("Debug -> Reset"), 0, 0x200},
	{0, 0, 0x10000, 0, 0, 0},
#endif
	{EVENT_ID_DBG_STEP, 0, 0, WSTR("Debug -> Step F8"), 0, 0},
	{EVENT_ID_DBG_PROCEED, 1, 0, WSTR("Debug -> Proceed F10"), 0, 0},
	{EVENT_ID_DBG_RETURN, 2, 0, WSTR("Debug -> Return F6"), 0, 0},
	{EVENT_ID_GO, 3, 0, WSTR("Debug -> Continue F5"), 0, 0},
	{0, 0, 0x10000, 0, 0, 0},
	{EVENT_ID_SAVEPOS, 0x18, 0, WSTR("View -> Save Position     Shift+Enter"), 0, 0x200},
	{EVENT_ID_PREVPOS, 0x15, 0, WSTR("View -> Jump To Previous Position    Backspace<-"), 0, 0x200},
	{EVENT_ID_NEXTPOS, 0x14, 0, WSTR("View -> Jump To Next Position    Ctrl+Enter"), 0, 0x200},
	{EVENT_ID_CLRPOS, 0x26, 0, WSTR("View -> Empty Position List"), 0, 0x200},
	{0, 0, 0x10000, 0, 0, 0},
	{EVENT_ID_BREAK_POINT, 4, 0, WSTR("Debug -> Break point Ctrl+F9"), 0, 0},
	{EVENT_ID_CALLSTACK, 0x12, 0, WSTR("Monitor -> Call Stack ALT+C"), 0, 0},
	{EVENT_ID_RUNTRACE, 0xB5, 0, WSTR("Monitor -> Run Trace List"), 0, 0},
	{EVENT_ID_CMTLIST, 0x93, 0, WSTR("Monitor -> Comment List"), 0, 0},
	{0, 0, 0x10000, 0, 0, 0},
	{EVENT_ID_TOGGLE_BM, 0xD0, 0, WSTR("View -> Toggle BookMark Ctrl+K"), 0, 0x200},
	{EVENT_ID_PREV_BM, 0xD2, 0, WSTR("View -> Previous BookMark Ctrl+P"), 0, 0x200},
	{EVENT_ID_NEXT_BM, 0xD1, 0, WSTR("View -> Next BookMark Ctrl+N"), 0, 0x200},
	{EVENT_ID_CLEAR_BM, 0xD3, 0, WSTR("View -> Clear BookMark Ctrl+L"), 0, 0x200},
	{0, 0, 0x10000, 0, 0, 0},
	{EVENT_ID_MEMSEARCH, 0xDF, 0, WSTR("Tools -> Memory Search"), 0, 0},
	{EVENT_ID_SOFTKB, 7, 0, WSTR("Tools -> Soft keyboard"), 0, 0},
	{EVENT_ID_INSTRINFO, 0, 0x20001, WSTR("Instruction Information"), 0x12C, 0x4040242},
	{WISP_ID_STATIC_DIB, 0x1E, 0x20002, 0, 0, 0},
	{0},
};

//SourceDebug

WISP_MENU_GROUP_ITEM SourceDebugDebugMenu[] =
{
	{WSTR("Continue      F5"), EVENT_ID_GO, 3, 0x100000, 0},
	{WSTR("Return        F6"), EVENT_ID_DBG_RETURN, 2, 0x100000, 0},
	{WSTR("Step          F8"), EVENT_ID_DBG_STEP, 0, 0x100000, 0},
	{WSTR("Proceed       F10"), EVENT_ID_DBG_PROCEED, 1, 0x100000, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Break point   Ctrl+F9"), EVENT_ID_BREAK_POINT, 4, 0, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SourceDebugMonitorMenu[] =
{
	{WSTR("Register View                 Alt+G"), EVENT_ID_REGVIEW, 0x34, 0, 0},
	{WSTR("Data View                     Alt+D"), EVENT_ID_DATAVIEW, 0x59, 0, 0},
	{WSTR("Call Stack                    Alt+C"), EVENT_ID_CALLSTACK, 0x12, 0, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SourceDebugViewMenu[] =
{
	{WSTR("Toggle   BookMark    Ctrl+K"), EVENT_ID_TOGGLE_BM, 0xD0, 0x100000, 0},
	{WSTR("Next     BookMark    Ctrl+N"), EVENT_ID_NEXT_BM, 0xD1, 0x100000, 0},
	{WSTR("Previous BookMark    Ctrl+P"), EVENT_ID_PREV_BM, 0xD2, 0x100000, 0},
	{WSTR("Clear    BookMark    Ctrl+L"), EVENT_ID_CLEAR_BM, 0xD3, 0x100000, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Go To Line           Ctrl+G"), EVENT_ID_SOURCECODEWND_GOTOLINE, 0x10B, 0x100000, 0},
	{0},
};

WISP_MENU_GROUP_ITEM SourceDebugMainMenu[] =
{
	{WSTR("Debug"), 0, 0x39, 1, SourceDebugDebugMenu},
	{WSTR("Monitor"), 0, 0x35, 1, SourceDebugMonitorMenu},
	{WSTR("View"), 0, 0x7E, 1, SourceDebugViewMenu},
	{0},
};

WISP_TOOLBAR_RES_ITEM SourceDebugToolbar[] =
{
	{EVENT_ID_DBG_STEP, 0, 0, WSTR("Step"), 0, 0x200},
	{EVENT_ID_DBG_PROCEED, 1, 0, WSTR("Proceed"), 0, 0x200},
	{EVENT_ID_DBG_RETURN, 2, 0, WSTR("Return"), 0, 0x200},
	{EVENT_ID_GO, 3, 0, WSTR("Continue"), 0, 0x200},
	{0, 0, 0x10000, 0, 0, 0},
	{EVENT_ID_BREAK_POINT, 4, 0, WSTR("Break point"), 0, 0},
	{EVENT_ID_SOURCECODEWND_GOTOLINE, 0x10B, 0, WSTR("Go To Line Ctrl+G"), 0, 0x200},
	{0, 0, 0x10000, 0, 0, 0},
	{EVENT_ID_TOGGLE_BM, 0xD0, 0, WSTR("Toggle BookMark Ctrl+K"), 0, 0x200},
	{EVENT_ID_NEXT_BM, 0xD1, 0, WSTR("Next BookMark Ctrl+N"), 0, 0x200},
	{EVENT_ID_PREV_BM, 0xD2, 0, WSTR("Previous BookMark Ctrl+P"), 0, 0x200},
	{EVENT_ID_CLEAR_BM, 0xD3, 0, WSTR("Clear BookMark Ctrl+L"), 0, 0x200},
	{0},
};

//
```

`source/WispSyser/resource.hpp`:

```hpp

#ifndef _RESOURCE_HPP_
#define _RESOURCE_HPP_

#include "../Wisp/wispmenu.hpp"
#include "../Wisp/wisptoolbar.hpp"

enum
{
	CMD_ID_SYSEXPLORER = 1,
	CMD_ID_CONSOLE = 2,
//DV 3,
//PEH 4, HWPROP
//PER 5,
//PEI 6,
//PEE 7,
//CBP 8,
//DBP 9,

	CMD_ID_TRACE = 0xB,
	CMD_ID_CALL_STACK = 0xC,
	CMD_ID_CMTLIST = 0xD,
	CMD_ID_MODULES = 0xE, //HWND
	CMD_ID_THREADS = 0xF,
	CMD_ID_SEH = 0x10,

	CMD_ID_SOURCE_MAIN_SPLIT = 0x12,
	CMD_ID_SOURCE_VIEW_PLIT = 0x13,
	CMD_ID_SYSTEM_MAIN_SPLIT = 0x14,
	CMD_ID_SYSTEM_VIEW_SPLIT = 0x15,
	CMD_ID_SYSTEM_MONIT_SPLIT = 0x16,
	CMD_ID_MULTICODE = 0x17,
	CMD_ID_MULTIDATA = 0x18,
	CMD_ID_TERMWND = 0x19,
	CMD_ID_GENE_REG = 0x1A,
	CMD_ID_FPU_REG = 0x1B,
	CMD_ID_SSE_REG = 0x1C,

	CMD_ID_CV0 = 0xF5,
	CMD_ID_CV1 = 0xF6,
	CMD_ID_CV2 = 0xF7,
	CMD_ID_CV3 = 0xF8,
	CMD_ID_CV4 = 0xF9,
	CMD_ID_CV5 = 0xFA,
	CMD_ID_CV6 = 0xFB,
	CMD_ID_CV7 = 0xFC,
	CMD_ID_CV8 = 0xFD,

	CMD_ID_SOURCE = 0xCE,
	CMD_ID_SDS = 0xD0,
	CMD_ID_WATCH = 0xD1,

	CMD_ID_DV0 = 0x100,
	CMD_ID_DV1 = 0x101,
	CMD_ID_DV2 = 0x102,
	CMD_ID_DV3 = 0x103,
	CMD_ID_DV4 = 0x104,
	CMD_ID_DV5 = 0x105,
	CMD_ID_DV6 = 0x106,
	CMD_ID_DV7 = 0x107,
	CMD_ID_DV8 = 0x108,

//PEH 0x101
//PEH 0x102
//PEI 0x103
//PEI 0x104
//PED 0x105,

	//0x259,
	//0x25A,
//
	EVENT_ID_OPEN = 0x21,
	EVENT_ID_CLOSE = 0x22,
	EVENT_ID_SAVECMT = 0x23,
	EVENT_ID_LOADCMT = 0x24,
	EVENT_ID_LOADSYM = 0x25,
//0x26,
	EVENT_ID_NEXTPOS = 0x27,
	EVENT_ID_PREVPOS = 0x28,
	EVENT_ID_SAVEPOS = 0x29,
	EVENT_ID_CLRPOS = 0x2A,
	EVENT_ID_SEARCH_TRANSFER_REF = 0x2B,
	EVENT_ID_SEARCH_OPERAND_REF = 0x2C,
	EVENT_ID_DBG_RESET = 0x2D,
	EVENT_ID_DBG_STEP = 0x2E,
	EVENT_ID_DBG_PROCEED = 0x2F,
	EVENT_ID_DBG_STEPB = 0x30,
	EVENT_ID_DBG_RETURN = 0x31,
	EVENT_ID_GO = 0x32,
	EVENT_ID_BREAK_POINT = 0x33,
	EVENT_ID_DBG_LIST = 0x34,
	EVENT_ID_CONFIG_OPTION = 0x35,
	EVENT_ID_PLUGINS = 0x36,
	EVENT_ID_GENE_REG = 0x37,
	EVENT_ID_FPU_REG = 0x38,
	EVENT_ID_SSE_REG = 0x39,
	EVENT_ID_SDS_FOCUS = 0x3A,
//0x3B,
	EVENT_ID_WATCH_LIST = 0x3C,
	EVENT_ID_SRC_CONSOLE = 0x3D,
	EVENT_ID_STACK_WATCH_LIST = 0x3E,
	EVENT_ID_IDT = 0x3F,
	EVENT_ID_GDT = 0x40,
	EVENT_ID_LDT = 0x41,
	EVENT_ID_PROCESS = 0x42,
	EVENT_ID_THREADS = 0x43,
	EVENT_ID_MODULES = 0x44,
	EVENT_ID_FUNCTIONS = 0x45,
	EVENT_ID_HWND = 0x46,
	EVENT_ID_RUNTRACE = 0x47,
	EVENT_ID_MEMSEARCH = 0x48,
	EVENT_ID_CMTLIST = 0x49,
	EVENT_ID_PAGEMAP = 0x4A,
	EVENT_ID_REG_HELP = 0x4B,
	EVENT_ID_ABOUT = 0x4C,
	EVENT_ID_CHECK_NEW_VER = 0x4D,
	EVENT_ID_OBJDIR = 0x4E,
//OLD SYSER 0x4F,
	EVENT_ID_CALC = 0x50,
	EVENT_ID_CALLSTACK = 0x51,
	EVENT_ID_REGVIEW = 0x52,
	EVENT_ID_DATAVIEW = 0x53,
	EVENT_ID_SOFTKB = 0x54,
	EVENT_ID_HOTKEY = 0x55,
	EVENT_ID_PE_EXPLORER = 0x56,
	EVENT_ID_IBM = 0x57,
	EVENT_ID_EBCDIC = 0x58,
	EVENT_ID_ANSI = 0x59,
//? 0x5A,
//? 0x5B,
	EVENT_ID_EDIT_UNDO = 0x5C,
	EVENT_ID_EDIT_REDO = 0x5D,
	EVENT_ID_EDIT_CUT = 0x5E,
	EVENT_ID_EDIT_COPY = 0x5F,
	EVENT_ID_EDIT_PASTE = 0x60,
	EVENT_ID_EDIT_GOTO = 0x61,
	EVENT_ID_EDIT_FIND = 0x62,
	EVENT_ID_EDIT_REPLACE = 0x63,
	EVENT_ID_TOGGLE_BM = 0x64,
	EVENT_ID_NEXT_BM = 0x65,
	EVENT_ID_PREV_BM = 0x66,
	EVENT_ID_CLEAR_BM = 0x67,
	EVENT_ID_SEH = 0x68,
	EVENT_ID_MENU_FILE = 0x69,
	EVENT_ID_MENU_DEBUG = 0x6A,
	EVENT_ID_MENU_MONITOR = 0x6B,
	EVENT_ID_MENU_VIEW = 0x6C,
	EVENT_ID_MENU_INFO = 0x6D,
	EVENT_ID_MENU_OPTION = 0x6E,
	EVENT_ID_MENU_TOOLS = 0x6F,
	EVENT_ID_MENU_HELP = 0x70,
	EVENT_ID_FILE0 = 0x71,
	EVENT_ID_FILE1 = 0x72,
	EVENT_ID_FILE2 = 0x73,
	EVENT_ID_FILE3 = 0x74,
	EVENT_ID_FILE4 = 0x75,
	EVENT_ID_FILE5 = 0x76,
	EVENT_ID_FILE6 = 0x77,
	EVENT_ID_FILE7 = 0x78,
	EVENT_ID_FILE8 = 0x79,
	EVENT_ID_ACTIVE_MODULE = 0x7A,
	EVENT_ID_INSTRINFO = 0x7B,
	EVENT_ID_CAX_DATA = 0x7C,
	EVENT_ID_CBX_DATA = 0x7D,
	EVENT_ID_CCX_DATA = 0x7E,
	EVENT_ID_CDX_DATA = 0x7F,
	EVENT_ID_CSP_DATA = 0x80,
	EVENT_ID_CBP_DATA = 0x81,
	EVENT_ID_CSI_DATA = 0x82,
	EVENT_ID_CDI_DATA = 0x83,
	EVENT_ID_R8_DATA = 0x300,
	EVENT_ID_R9_DATA = 0x301,
	EVENT_ID_R10_DATA = 0x302,
	EVENT_ID_R11_DATA = 0x303,
	EVENT_ID_R12_DATA = 0x304,
	EVENT_ID_R13_DATA = 0x305,
	EVENT_ID_R14_DATA = 0x306,
	EVENT_ID_R15_DATA = 0x307,
	EVENT_ID_CIP_DATA = 0x84,
	EVENT_ID_CAX_CODE = 0x85,
	EVENT_ID_CBX_CODE = 0x86,
	EVENT_ID_CCX_CODE = 0x87,
	EVENT_ID_CDX_CODE = 0x88,
	EVENT_ID_CSP_CODE = 0x89,
	EVENT_ID_CBP_CODE = 0x8A,
	EVENT_ID_CSI_CODE = 0x8B,
	EVENT_ID_CDI_CODE = 0x8C,
	EVENT_ID_R8_CODE = 0x400,
	EVENT_ID_R9_CODE = 0x401,
	EVENT_ID_R10_CODE = 0x402,
	EVENT_ID_R11_CODE = 0x403,
	EVENT_ID_R12_CODE = 0x404,
	EVENT_ID_R13_CODE = 0x405,
	EVENT_ID_R14_CODE = 0x406,
	EVENT_ID_R15_CODE = 0x407,
	EVENT_ID_CIP_CODE = 0x8D,
	EVENT_ID_SHOW_CODE = 0x8E,
	EVENT_ID_SHOW_CODE_AT = 0x8F,
	EVENT_ID_SHOW_CSP_ADDR = 0x90,
	EVENT_ID_SHOW_CBP_ADDR = 0x91,
	EVENT_ID_DATA_FOCUS = 0x92,
	EVENT_ID_SHOW_DATA = 0x93,
	EVENT_ID_SHOW_DATA_AT = 0x94,
	EVENT_ID_NEW_DATA = 0x95,
	EVENT_ID_DISASM = 0x96,
	EVENT_ID_NEW_CODE = 0x97,
	EVENT_ID_DASM_PHYS_ADDR = 0x98,
	EVENT_ID_SHOW_PHYS_ADDR = 0x99,
	EVENT_ID_SHOW_OP = 0x9A,
	EVENT_ID_ATTACH_TYPE = 0x9B,
	EVENT_ID_SHOW_OFFSET = 0x9C,
	EVENT_ID_DATA_WIDTH = 0x700, //+++
	EVENT_ID_FIND_FORM = 0x9D,
//0x9E, ???
	EVENT_ID_DV_ADDR_MODE = 0x9F,
	EVENT_ID_DV0 = 0xA0,
	EVENT_ID_DV1 = 0xA1,
	EVENT_ID_DV2 = 0xA2,
	EVENT_ID_DV3 = 0xA3,
	EVENT_ID_DV4 = 0xA4,
	EVENT_ID_DV5 = 0xA5,
	EVENT_ID_DV6 = 0xA6,
	EVENT_ID_DV7 = 0xA7,
	EVENT_ID_DV8 = 0xA8,
	EVENT_ID_OP_BFLIP = 0xA9,
	EVENT_ID_OP_BINV = 0xAA,
	EVENT_ID_OP_SHL = 0xAB,
	EVENT_ID_OP_SHR = 0xAC,
	EVENT_ID_OP_ROL = 0xAD,
	EVENT_ID_OP_ROR = 0xAE,
	EVENT_ID_OP_BSHL = 0xAF,
	EVENT_ID_OP_BSHR = 0xB0,
	EVENT_ID_OP_XOR = 0xB1,
	EVENT_ID_OP_OR = 0xB2,
	EVENT_ID_OP_AND = 0xB3,
	EVENT_ID_OP_SIG = 0xB4,
	EVENT_ID_OP_ADD = 0xB5,
	EVENT_ID_OP_SUB = 0xB6,
	EVENT_ID_OP_MUL = 0xB7,
	EVENT_ID_OP_DIV = 0xB8,
	EVENT_ID_OP_MOD = 0xB9,
	EVENT_ID_OP_UPR = 0xBA,
	EVENT_ID_OP_LWR = 0xBB,
	EVENT_ID_OP_INV = 0xBC,
	EVENT_ID_GOTO_KTHREAD = 0xBD,
	EVENT_ID_GOTO_KPROCESS = 0xBE,
	EVENT_ID_GOTO_THREAD_START_ADDR = 0xBF,
	EVENT_ID_GOTO_THREAD_EIP = 0xC0,
	EVENT_ID_BP_THREAD = 0xC1,
	EVENT_ID_BP_PROCESS = 0xC2,
	EVENT_ID_CODE_FOCUS = 0xC3,
	EVENT_ID_FOLLOW_CIP_AUTO = 0xC4,
	EVENT_ID_FOLLOW_CIP_SYSEXPLORER = 0xC5,
	EVENT_ID_FOLLOW_CIP_SRCEXPLORER = 0xC6,
	EVENT_ID_IDENTIFY_FUNCTION = 0xC7, //??? TODO CHECK
	EVENT_ID_DV_SHOW_DATA_AT = 0xC8,
	EVENT_ID_CV_OPEN = 0xC9,
	EVENT_ID_DV_SHOW_DATA_AT_REL = 0xCA,
	EVENT_ID_COPYVAL = 0xCB,
	EVENT_ID_COPYADDR = 0xCC,
	EVENT_ID_COPYSEL = 0xCD,
	EVENT_ID_COPYSEL_CLANG = 0xCE,
	EVENT_ID_COPYSEL_SPACE = 0xCF,
	EVENT_ID_FLOAT_MODE = 0xD0,
	EVENT_ID_CV_ADDR_MODE = 0xD1,
	EVENT_ID_CV_OFFSET_MODE = 0xD2,
	EVENT_ID_CV_SWITCH_SYM = 0xD3,
	EVENT_ID_CV_FULL_SYM = 0xD4,
	EVENT_ID_REL_CSP = 0xD5,
	EVENT_ID_REL_CBP = 0xD6,
	EVENT_ID_LOW_HIGH_ADDR = 0xD7,
	EVENT_ID_REL_CIP = 0xD8,
	EVENT_ID_EDIT_CODE = 0xD9,
	EVENT_ID_EDIT_CMT = 0xDA,
	EVENT_ID_STRREF = 0xDB,
	EVENT_ID_STRFIND = 0xDC,
	EVENT_ID_CV_NEXT_CIP = 0xDD,
	EVENT_ID_CV_PREV_CIP = 0xDE,
	EVENT_ID_CV_SHOW_AT = 0xDF,
	EVENT_ID_CV_NEXT = 0xE0,
	EVENT_ID_CV_PREV = 0xE1,
	EVENT_ID_CV0 = 0xE2,
	EVENT_ID_CV1 = 0xE3,
	EVENT_ID_CV2 = 0xE4,
	EVENT_ID_CV3 = 0xE5,
	EVENT_ID_CV4 = 0xE6,
	EVENT_ID_CV5 = 0xE7,
	EVENT_ID_CV6 = 0xE8,
	EVENT_ID_CV7 = 0xE9,
	EVENT_ID_CV8 = 0xEA,
	EVENT_ID_HISTORY_NEXT = 0xEB,
	EVENT_ID_HISTORY_PREV = 0xEC,
	EVENT_ID_SEARCH_AGAIN = 0xED,
	EVENT_ID_SEARCH = 0xEE,
//0xEF, EVENT_ID_HEX_WATCH = 0xEF,
	EVENT_ID_DEL_WATCH = 0xF0,
	EVENT_ID_WATCH_ADD = 0xF1,
	EVENT_ID_GOTO_HERE = 0xF2, //EVENT_ID_GOTO_MODULE_BASE
//0xF3,				   //EVENT_ID_ANALYZE_FUNCTION
	EVENT_ID_WATCH_DEL = 0xF4, //UNLOAD


	EVENT_ID_SOURCECODEWND_ADDWATCH = 0x114,
	EVENT_ID_SOURCECODEWND_EXPANSION = 0x115,
	EVENT_ID_SOURCECODEWND_COLLAPSE = 0x116,
	EVENT_ID_SOURCECODEWND_GOTOLINE = 0x117,
	EVENT_ID_INSREMBP = 0x118, //TOGGLE_BP
	EVENT_ID_ENDISMBP = 0x119, //SWITCH_BP
	EVENT_ID_BP_ENABLE_ALL = 0x11A,
	EVENT_ID_BP_REMOVE_ALL = 0x11B,
	EVENT_ID_BP_DISABLE_ALL = 0x11C,
//0x11D,
//0x11E,
	EVENT_ID_SHOW_HERE = 0x11F,
};

//
extern WISP_MENU_GROUP_ITEM SystemExplorerMainMenu[];
extern WISP_TOOLBAR_RES_ITEM SystemExplorerToolbar[];

//
extern WISP_MENU_GROUP_ITEM SourceDebugMainMenu[];
extern WISP_TOOLBAR_RES_ITEM SourceDebugToolbar[];

#endif
```

`source/WispSyser/runtrace.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "runtrace.hpp"

	CRunTrace::CRunTrace()
	{
		m_MaxSize = 300;

		m_pTraces = new CTracePoint[m_MaxSize];
		memset(m_pTraces, 0, m_MaxSize*sizeof(CTracePoint));

		m_WriteIndex = 0;

		m_pCPUType = new unsigned long[m_MaxSize];
		memset(m_pCPUType, 0, m_MaxSize*sizeof(unsigned long));

		m_pCPUReg = new ULONG_PTR[m_MaxSize*2];
		memset(m_pCPUReg, 0, m_MaxSize*2*sizeof(ULONG_PTR));

		m_CPURegWriteIndex = 0;
		XXX = 0;
		m_nTracesIndex = 0;
		m_CPURegReadIndex = 0;
		m_bSaveREG = true;
	}
	CRunTrace::~CRunTrace()
	{
		delete []m_pTraces;
		m_pTraces = 0;
		delete []m_pCPUType;
		m_pCPUType = 0;
		delete []m_pCPUReg;
		m_pCPUReg = 0;
	}

	unsigned long CRunTrace::UpdateContext(ULONG_PTR Address, ULONG_PTR CIP, unsigned short nWndIndex)
	{
		if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
			return 0;

		if (m_WriteIndex >= m_MaxSize)
			Rotate();

		m_pTraces[m_WriteIndex%m_MaxSize].Address = Address;
		m_pTraces[m_WriteIndex%m_MaxSize].Offset = CIP - Address;
		m_pTraces[m_WriteIndex%m_MaxSize].nWndIndex = nWndIndex;

		unsigned long CpuType = 0;

		if (m_bSaveREG)
		{
			m_bSaveREG = false;

		//	memcpy(&m_CurCPU, &Reg, sizeof(m_CurCPU));
			m_CurCPU.CAX = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCAX;
			m_CurCPU.CCX = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCCX;
			m_CurCPU.CDX = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDX;
			m_CurCPU.CBX = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBX;
			m_CurCPU.CSP = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP;
			m_CurCPU.CBP = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP;
			m_CurCPU.CSI = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSI;
			m_CurCPU.CDI = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDI;
		#ifdef _X64_
			m_CurCPU.R8 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR8;
			m_CurCPU.R9 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR9;
			m_CurCPU.R10 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR10;
			m_CurCPU.R11 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR11;
			m_CurCPU.R12 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR12;
			m_CurCPU.R13 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR13;
			m_CurCPU.R14 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR14;
			m_CurCPU.R15 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR15;
		#endif
			m_CurCPU.CIP = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP;
			m_CurCPU.EFL = *(unsigned long *)gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pEFL;


			memcpy(&m_LastCPU, &m_CurCPU, sizeof(m_LastCPU));
		} else
		{
			X86_CPU_REG CurCPU;
			//memcpy(&CurCPU, &Reg, sizeof(CurCPU));
			CurCPU.CAX = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCAX;
			CurCPU.CCX = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCCX;
			CurCPU.CDX = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDX;
			CurCPU.CBX = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBX;
			CurCPU.CSP = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP;
			CurCPU.CBP = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP;
			CurCPU.CSI = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSI;
			CurCPU.CDI = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDI;
		#ifdef _X64_
			CurCPU.R8 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR8;
			CurCPU.R9 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR9;
			CurCPU.R10 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR10;
			CurCPU.R11 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR11;
			CurCPU.R12 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR12;
			CurCPU.R13 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR13;
			CurCPU.R14 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR14;
			CurCPU.R15 = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR15;
		#endif
			CurCPU.CIP = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP;
			CurCPU.EFL = *(unsigned long *)gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pEFL;

			if (CurCPU.CAX != m_LastCPU.CAX)
			{
				CpuType |= 1;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.CAX;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.CBX != m_LastCPU.CBX)
			{
				CpuType |= 2;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.CBX;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.CCX != m_LastCPU.CCX)
			{
				CpuType |= 4;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.CCX;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.CDX != m_LastCPU.CDX)
			{
				CpuType |= 8;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.CDX;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.CSP != m_LastCPU.CSP)
			{
				CpuType |= 0x10;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.CSP;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.CBP != m_LastCPU.CBP)
			{
				CpuType |= 0x20;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.CBP;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.CSI != m_LastCPU.CSI)
			{
				CpuType |= 0x40;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.CSI;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.CDI != m_LastCPU.CDI)
			{
				CpuType |= 0x80;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.CDI;
				++m_CPURegWriteIndex;
			}
		#ifdef _X64_
			if (CurCPU.R8 != m_LastCPU.R8)
			{
				CpuType |= 0x100;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.R8;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.R9 != m_LastCPU.R9)
			{
				CpuType |= 0x200;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.R9;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.R10 != m_LastCPU.R10)
			{
				CpuType |= 0x400;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.R10;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.R11 != m_LastCPU.R11)
			{
				CpuType |= 0x800;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.R11;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.R12 != m_LastCPU.R12)
			{
				CpuType |= 0x1000;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.R12;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.R13 != m_LastCPU.R13)
			{
				CpuType |= 0x2000;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.R13;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.R14 != m_LastCPU.R14)
			{
				CpuType |= 0x4000;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.R14;
				++m_CPURegWriteIndex;
			}

			if (CurCPU.R15 != m_LastCPU.R15)
			{
				CpuType |= 0x8000;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.R15;
				++m_CPURegWriteIndex;
			}
		#endif
			if (CurCPU.CIP != m_LastCPU.CIP)
			{
				CpuType |= 0x20000;
			//	m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.CIP;
			//	++m_CPURegWriteIndex;
			}

			if (CurCPU.EFL != m_LastCPU.EFL)
			{
				CpuType |= 0x10000;
				m_pCPUReg[m_CPURegWriteIndex % (m_MaxSize*2)] = CurCPU.EFL;
				++m_CPURegWriteIndex;
			}

			memcpy(&m_LastCPU, &CurCPU, sizeof(m_LastCPU));
			m_pCPUType[m_WriteIndex % m_MaxSize] = CpuType;
		}
		m_LastWriteIndex = ++m_WriteIndex % m_MaxSize;
		unsigned long TracesContext = ++m_TracesContext;
		MAX_LIMIT(TracesContext, m_MaxSize);
		return TracesContext;
	}

	void CRunTrace::ReadContext(unsigned long TracePoint, X86_CPU_REG *pCPUReg, unsigned long *pCPUType)
	{
		unsigned long CPURegReadIndex = m_CPURegReadIndex;
		unsigned long CPUType = 0; //???
		memcpy(pCPUReg, &m_CurCPU, sizeof(X86_CPU_REG));
		if (TracePoint)
		{
			unsigned long n;
			for (n = 1; n <= TracePoint; ++n)
			{
				CPUType = m_pCPUType[(n + m_CPURegReadIndex) % m_MaxSize];
				if (CPUType != 0)
				{
					if (CPUType & 1)     pCPUReg->CAX = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 2)     pCPUReg->CBX = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 4)     pCPUReg->CCX = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 8)     pCPUReg->CDX = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x10)  pCPUReg->CSP = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x20)  pCPUReg->CBP = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x40)  pCPUReg->CSI = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x80)  pCPUReg->CDI = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
				#ifdef _X64_
					if (CPUType & 0x100) pCPUReg->R8 = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x200) pCPUReg->R9 = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x400) pCPUReg->R10 = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x800) pCPUReg->R11 = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x1000) pCPUReg->R12 = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x2000) pCPUReg->R13 = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x4000) pCPUReg->R14 = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
					if (CPUType & 0x8000) pCPUReg->R15 = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
				#endif
					if (CPUType & 0x10000) pCPUReg->EFL = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
				//	if (CPUType & 0x20000) pCPUReg->CIP = m_pCPUReg[CPURegReadIndex++ % (m_MaxSize*2)];
				}
			}
			if (pCPUType)
				*pCPUType = CPUType;
		} else
		if (pCPUType)
		{
			*pCPUType = m_pCPUType[m_CPURegReadIndex % m_MaxSize];
		}
	}

	unsigned long CRunTrace::Count(unsigned long CpuType) const
	{
		unsigned long n = 0;
		for (int i = 0; i < 32; ++i)
		{
			if (CpuType & 1)
				++n;
			CpuType >>= 1;
		}
		return n;
	}

	void CRunTrace::Rotate()
	{
		X86_CPU_REG CpuReg;
		unsigned long CpuType;
		ReadContext(1, &CpuReg, &CpuType);
		m_nTracesIndex = (m_nTracesIndex+1)%m_MaxSize;
		m_CPURegReadIndex += Count(m_pCPUType[m_nTracesIndex]);
		memcpy(&m_CurCPU, &CpuReg, sizeof(m_CurCPU));
	}

	CTracePoint *CRunTrace::GetTracePoint(unsigned long TracePoint) const
	{
		if (TracePoint >= m_MaxSize || TracePoint >= m_WriteIndex)
			return nullptr;
		return &m_pTraces[(TracePoint+m_nTracesIndex)%m_MaxSize];
	}


```

`source/WispSyser/runtrace.hpp`:

```hpp

#ifndef _RUNTRACE_HPP_
#define _RUNTRACE_HPP_

#include "../EXEAnalyzer/x86debugger.hpp"

struct CTracePoint
{
	ULONG_PTR Address;
	unsigned short Offset;
	unsigned short nWndIndex;
};

struct CRunTrace
{
	unsigned long m_MaxSize;
	unsigned long m_WriteIndex; //m_WriteTraceIndex
	CTracePoint *m_pTraces;
	bool m_bSaveREG;
	unsigned long m_LastWriteIndex;
	unsigned long m_CPURegWriteIndex;
	unsigned long XXX;
	unsigned long m_nTracesIndex;
	unsigned long m_CPURegReadIndex;
	X86_CPU_REG m_CurCPU;
	X86_CPU_REG m_LastCPU;
	unsigned long *m_pCPUType;
	ULONG_PTR *m_pCPUReg;
	unsigned long m_TracesContext;

	CRunTrace();
	~CRunTrace();

	unsigned long UpdateContext(ULONG_PTR Address, ULONG_PTR CIP, unsigned short nWndIndex);
	void ReadContext(unsigned long TracePoint, X86_CPU_REG *pCPUReg, unsigned long *pCPUType);
	unsigned long Count(unsigned long CpuType) const;

	void Rotate();
	CTracePoint *GetTracePoint(unsigned long TracePoint) const;
};

#endif

```

`source/WispSyser/runtracewnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "runtracewnd.hpp"
#include "syserconfig.hpp"
#include "codeview.hpp"

enum
{
  RT_BACK = 0,
  RT_ADDR = 1,
  RT_INST = 2,
  RT_REGS = 3,
};

	WISP_MSG_MAP_BEGIN(CRunTraceWnd)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
		WISP_MSG_MAP(WISP_WM_MOUSE_DBLCLICK, OnMouseDblClick)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_COMMAND, CWispList::OnCommand)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	WISP_EVENT_MAP_BEGIN(CRunTraceWnd)
//		WISP_EVENT_MAP(0x, OnEvent)
	WISP_EVENT_MAP_END

	CRunTraceWnd::CRunTraceWnd()
	{
	}
	CRunTraceWnd::~CRunTraceWnd()
	{
	}

	bool CRunTraceWnd::OnUpdate(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}

	bool CRunTraceWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_ColorFocus = gSyserColors.Color[2];

		m_Color[1] = gSyserColors.Color[6];
		m_Color[2] = gSyserColors.Color[9];
		m_Color[3] = gSyserColors.Color[10];
		m_Color[4] = gSyserColors.Color[11];
		m_Color[5] = gSyserColors.Color[12];
		m_Color[6] = gSyserColors.Color[13];
		m_Color[7] = gSyserColors.Color[14];
		m_Color[8] = gSyserColors.Color[15];
		m_Color[9] = gSyserColors.Color[16];
		m_Color[10] = gSyserColors.Color[17];
		m_Color[11] = gSyserColors.Color[18];
		m_Color[12] = gSyserColors.Color[19];
		m_Color[13] = gSyserColors.Color[20];
		m_Color[14] = gSyserColors.Color[21];
		m_Color[15] = gSyserColors.Color[22];
		m_ClientDC.m_pColor = m_Color;

		AttachTitleDIB(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xB5));
		m_ItemColor = gSyserColors.Color[1];

		SetBGColor(gSyserColors.Color[0]);

		int Ext = m_ClientDC.GetTextExtent(WSTR("X"), -1, 0);

		InsertColumn(WSTR("Back"), 40, 0, 0, -1);
		InsertColumn(WSTR("Address"), (3+ADDR_SIZE)*Ext+3, 0, 0, -1); //60
		InsertColumn(WSTR("Instruction"), 180, 0, 0, -1);
		InsertColumn(WSTR("Modified Registers"), 120, 0, 0, -1);

		SetBGColor(0);

		UpdateContext();
		return true;
	}
	bool CRunTraceWnd::OnClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}

	bool CRunTraceWnd::OnMouseDblClick(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (Item)
		{
			unsigned long Addr = GetItemValue(Item, RT_BACK);
			gpSyser->m_MainFrame.m_SystemExplorer.TracePoint(Addr);
		}
		return true;
	}
	bool CRunTraceWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.bKeyDown && pMsg->KeyEvent.KeyType == VK_RETURN)
			OnMouseDblClick(0);
		return true;
	}
	//bool CRunTraceWnd::OnCommand(WISP_MSG *pMsg)
	//bool CRunTraceWnd::OnEvent(WISP_MSG *pMsg)

	void CRunTraceWnd::UpdateContext()
	{
		if (IsWindow())
		{
			DeleteAllChildrenItems(0);
			CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();

			CListStringItem *Item = 0;
			unsigned long TracePoint = 0;

			WCHAR Buffer[200];
			WCHAR szReg[20];

			unsigned long ColorString[256];

			unsigned long Pos = gpSyser->m_MainFrame.m_SystemExplorer.m_CIPRegWndTrace - 1;
			CTracePoint *pTrace;
			while((pTrace = gpSyser->m_MainFrame.m_SystemExplorer.m_RunTrace.GetTracePoint(TracePoint)))
			{
				ColorString[0] = 0;

				ULONG_PTR Address = pTrace->Address + pTrace->Offset;

				TSPrintf(Buffer, WSTR("%d"), Pos);
				Item = InsertItem(Buffer, 0, 0, 0, -1);
				SetItemColor(Item, RT_BACK, gSyserColors.Color[1]);
				SetItemValue(Item, RT_BACK, TracePoint);
				SetItemFormat(Item, RT_ADDR, Address, WSTR("" F0ADDR "X"));
				SetItemColor(Item, RT_ADDR, gSyserColors.Color[9]);

				if (pWnd)
					pWnd->ColorDasm(Address, 16, ColorString, 0, 0, 0);
				SetItemTextColor(Item, RT_INST, ColorString);
				Buffer[0] = 0;
				X86_CPU_REG CPUReg;
				unsigned long CPUType;
				gpSyser->m_MainFrame.m_SystemExplorer.m_RunTrace.ReadContext(TracePoint, &CPUReg, &CPUType);
				if (CPUType)
				{
					if (CPUType & 1)
					{
						TSPrintf(szReg, WSTR("EAX=" F0ADDR "X "), CPUReg.CAX);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 2)
					{
						TSPrintf(szReg, WSTR("EBX=" F0ADDR "X "), CPUReg.CBX);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 4)
					{
						TSPrintf(szReg, WSTR("ECX=" F0ADDR "X "), CPUReg.CCX);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 8)
					{
						TSPrintf(szReg, WSTR("EDX=" F0ADDR "X "), CPUReg.CDX);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x40)
					{
						TSPrintf(szReg, WSTR("ESI=" F0ADDR "X "), CPUReg.CSI);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x80)
					{
						TSPrintf(szReg, WSTR("EDI=" F0ADDR "X "), CPUReg.CDI);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x10)
					{
						TSPrintf(szReg, WSTR("ESP=" F0ADDR "X "), CPUReg.CSP);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x20)
					{
						TSPrintf(szReg, WSTR("EBP=" F0ADDR "X "), CPUReg.CBP);
						TStrCat(Buffer, szReg);
					}
				#ifdef _X64_
					if (CPUType & 0x100)
					{
						TSPrintf(szReg, WSTR("R8=" F0ADDR "X "), CPUReg.R8);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x200)
					{
						TSPrintf(szReg, WSTR("R9=" F0ADDR "X "), CPUReg.R9);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x400)
					{
						TSPrintf(szReg, WSTR("R10=" F0ADDR "X "), CPUReg.R10);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x800)
					{
						TSPrintf(szReg, WSTR("R11=" F0ADDR "X "), CPUReg.R11);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x1000)
					{
						TSPrintf(szReg, WSTR("R12=" F0ADDR "X "), CPUReg.R12);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x2000)
					{
						TSPrintf(szReg, WSTR("R13=" F0ADDR "X "), CPUReg.R13);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x4000)
					{
						TSPrintf(szReg, WSTR("R14=" F0ADDR "X "), CPUReg.R14);
						TStrCat(Buffer, szReg);
					}
					if (CPUType & 0x8000)
					{
						TSPrintf(szReg, WSTR("R15=" F0ADDR "X "), CPUReg.R15);
						TStrCat(Buffer, szReg);
					}
				#endif
				}
				SetItemText(Item, RT_REGS, Buffer);
				SetItemColor(Item, RT_REGS, gSyserColors.Color[4]);
				--Pos;
				++TracePoint;
			}

			if (Item)
			{
				if (!CheckItemPage(Item))
					Scroll(Item, -1);
			}
		}
	}

	void CRunTraceWnd::Create()
	{
		if (IsWindow())
		{
			Destroy();
		} else
		{
			CreateWnd(WSTR("Run Trace List"), 0, 0, 500, 280, 0, 0xB, 0x10100BB, WISP_SH_MINSIZE);
			Center(0);
		}
	}

```

`source/WispSyser/runtracewnd.hpp`:

```hpp

#ifndef _RUNTRACEWND_HPP_
#define _RUNTRACEWND_HPP_

#include "../Wisp/wisplist.hpp"

struct CRunTraceWnd : public CWispList
{
	unsigned long m_Color[16];

	CRunTraceWnd();
	virtual ~CRunTraceWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnClose(WISP_MSG *pMsg);
	bool OnMouseDblClick(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	//bool OnCommand(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	void UpdateContext();

	void Create();
};

#endif
```

`source/WispSyser/sdsmodulelist.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "sdsmodulelist.hpp"
#include "syserconfig.hpp"

WISP_MENU_GROUP_ITEM SDSModuleListPopupMenu[] =
{
	{WSTR("Set As Active Module"), 0x7A, 0x38, 0, 0}, //EVENT_ID_ACTIVE_MODULE
	{WSTR("Unload"), 0xF4, 0x17, 0, 0}, //EVENT_ID_WATCH_DEL ???
	{0},
};

	WISP_MSG_MAP_BEGIN(CSDSModuleList)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)


	WISP_EVENT_MAP_BEGIN(CSDSModuleList)
		WISP_EVENT_MAP(0x7A, OnEventActive)
		WISP_EVENT_MAP(0xF4, OnEventUnload)
	WISP_EVENT_MAP_END

	bool CSDSModuleList::OnCreate(WISP_MSG *pMsg)
	{
		m_ColorFocus = gSyserColors.Color[2];
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		CWispDIBList *pDIBList = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF);
		m_pDibC = pDIBList->GetDIB(0xF8);
		m_pDibCPP = pDIBList->GetDIB(0xF6);
		m_pDibH = pDIBList->GetDIB(0xF7);
		m_pDibMod = pDIBList->GetDIB(0xE3);
		m_PopupMenu.LoadPopupMenuGroup(SDSModuleListPopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		InsertColumn(WSTR("Module Name"), 150, 0, 0, -1);
		InsertColumn(WSTR("File Count / Size"), 150, 0, 0, -1);
		SetOwner(this);
		m_pItem = 0;
		return true;
	}
	bool CSDSModuleList::OnDestroy(WISP_MSG *pMsg)
	{
		m_PopupMenu.Destroy();
		return true;
	}

	bool CSDSModuleList::OnEventActive(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item && !GetItemLevel(Item))
		{
			CSDSModule *pSDSMod = (CSDSModule *)GetItemValue(Item, 0);
			ExpandSDSModule(pSDSMod);
		}
		return true;
	}


	bool CSDSModuleList::OnEventUnload(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item && !GetItemLevel(Item))
		{
			CSDSModule *pSDSMod = (CSDSModule *)GetItemValue(Item, 0);
			gpSyser->m_SyserUI.UnloadSDSModule(pSDSMod);
		}
		return true;
	}


	void CSDSModuleList::ExpandModule(CListStringItem *Item)
	{
		if (m_pItem)
		{
			SetItemColor(m_pItem, 0, m_ItemColor);
			Collapse(m_pItem);
		}
		m_pItem = Item;
		m_pSDSMod = (CSDSModule *)GetItemValue(Item, 0);
		SetItemColor(m_pItem, 0, gSyserColors.Color[2]);
		Expand(m_pItem);
	}

	void CSDSModuleList::ShowPopupMenu()
	{
		CListStringItem *Item = FindItem(0, 8);
		m_PopupMenu.Enable(0x7A, Item && Item != m_pItem);
		m_PopupMenu.Point(0, true);
	}

	bool CSDSModuleList::OnKeyEvent(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FullFindItem(0, 8);
		if (Item)
		{
			if (pMsg->KeyEvent.KeyType == VK_RETURN &&
				pMsg->KeyEvent.bKeyDown && GetItemLevel(Item) == 1)
				OnMouseDblClick(Item, 1);

			if (pMsg->KeyEvent.KeyType == VK_RBUTTON &&
				!pMsg->KeyEvent.bKeyDown && GetItemLevel(Item) == 0)
				ShowPopupMenu();
		}
		return true;
	}

	void CSDSModuleList::OnMouseDblClick(CListStringItem *Item, int nCol)
	{
		int level = GetItemLevel(Item);
		if (level == 0)
		{
			if (m_pSDSMod == (CSDSModule *)GetItemValue(Item, 0))
				return;
			ExpandModule(Item);
		}

		if (level == 1)
		{
			CSDSModule *pSDSMod = (CSDSModule *)GetItemValue(Item, 0);
			unsigned long FileID = GetItemValue(Item, 1);
			gpSyser->m_MainFrame.m_SourceDebugFrameWnd.OpenSrcView(pSDSMod, FileID, 1);
			Focus();
		}
	}

	void CSDSModuleList::AppendSrcFiles(CListStringItem *ParentItem, CSDSModule *pSDSMod)
	{
		unsigned long Len = 0;
		SrcFileNameID *SrcFileName = pSDSMod->GetSrcFiles(&Len);
		if (!SrcFileName) return;

		for (unsigned long n = 0; n < Len; ++n)
		{
			if (SrcFileName[n].FileSize)
			{
				CWispDIB *pDib = 0;
				const char *pFileName = TStrRChr(SrcFileName[n].FileName, '\\');
				const char *pFileExt = TGetFileExt(pFileName + 1);
				if (pFileExt && !TStrICmp(pFileExt, "c"))
				{
					pDib = m_pDibC;
				} else
				if (pFileExt && !TStrICmp(pFileExt, "cpp"))
				{
					pDib = m_pDibCPP;
				} else
				if (pFileExt && (TStrICmp(pFileExt, "h") && TStrICmp(pFileExt, "hpp")))
				{
					pDib = 0;
				} else
				{
					pDib = m_pDibH;
				}
				CListStringItem *Item = 0;
				if (pFileName)
					Item = InsertItemStr(pFileName+1, ParentItem, 0, pDib, -1);
				else	Item = InsertItemStr(SrcFileName[n].FileName, ParentItem, 0, pDib, -1);
				SetItemFormat(Item, 1, SrcFileName[n].FileSize, WSTR("%d Byte(s)"));
				SetItemValue(Item, 0, (unsigned long long)pSDSMod);
				SetItemValue(Item, 1, (unsigned long long)SrcFileName[n].FileID);
			}
		}
	}

	void CSDSModuleList::AppendSDSModule(CSDSModule *pSDSMod)
	{
		CListStringItem *Item = InsertItemStr(TGetFileName(pSDSMod->m_ExeFileName.operator const char*()), 0, 0, m_pDibMod, -1);
		SetItemFormat(Item, 1, pSDSMod->GetSrcFilesCount(), WSTR("%d Source Code File(s)"));
		SetItemValue(Item, 0, (unsigned long long)pSDSMod);
		if (!m_pSDSMod)
			ExpandModule(Item);
		AppendSrcFiles(Item, pSDSMod);
	}

	bool CSDSModuleList::RemoveSDSModule(CSDSModule *pSDSMod)
	{
		CListStringItem *Item = GetNext(0, 0);
		if (!Item)
			return false;
		while (pSDSMod != (CSDSModule *)GetItemValue(Item, 0))
		{
			Item = GetNext(Item, 0);
			if (!Item)
				return false;
		}

		if (m_pSDSMod == pSDSMod)
		{
			m_pSDSMod = 0;
			m_pItem = 0;
		}

		map<SCWKEY, CSourceCodeWnd*>::IT it = gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_MultiSourceCodeView.m_SourceCodeWndMap.begin();
		while (it)
		{
			if (it->first.pSDSMod == pSDSMod)
			{
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_MultiSourceCodeView.RemoveWnd(it++->second, true);//->pSrcWnd);
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.RemoveSDSModule(pSDSMod);
			} else
			{
				++it;
			}
		}
		DeleteItem(Item);
		if (gpSyser->m_bActive)
			Update((WISP_RECT*)0);
		return true;
	}

	void CSDSModuleList::ExpandSDSModule(CSDSModule *pSDSMod)
	{
		if (m_pSDSMod != pSDSMod)
		{
			CListStringItem *Item = GetNext(0, 0);
			while (Item)
			{
				if (pSDSMod == (CSDSModule *)GetItemValue(Item, 0))
				{
					ExpandModule(Item);
					return;
				}
				Item = GetNext(Item, 0);
			}
		}
	}

```

`source/WispSyser/sdsmodulelist.hpp`:

```hpp

#ifndef _SDSMODULELIST_HPP_
#define _SDSMODULELIST_HPP_

#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispmenu.hpp"
#include "../EXEAnalyzer/sdsmodule.hpp"

struct CSDSModuleList : public CWispList
{
	CWispDIB *m_pDibC;
	CWispDIB *m_pDibCPP;
	CWispDIB *m_pDibH;
	CWispDIB *m_pDibMod;
	CListStringItem *m_pItem;
	CSDSModule *m_pSDSMod;
	CWispMenu m_PopupMenu;

	bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventActive(WISP_MSG *pMsg);
	bool OnEventUnload(WISP_MSG *pMsg);

	void ExpandModule(CListStringItem *Item);
	void ShowPopupMenu();
	bool OnKeyEvent(WISP_MSG *pMsg);

	virtual void OnMouseDblClick(CListStringItem *Item, int nCol) override;

	void AppendSrcFiles(CListStringItem *ParentItem, CSDSModule *pSDSMod);
	void AppendSDSModule(CSDSModule *pSDSMod);
	bool RemoveSDSModule(CSDSModule *pSDSMod);
	void ExpandSDSModule(CSDSModule *pSDSMod);
};

#endif
```

`source/WispSyser/searchdialog.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "searchdialog.hpp"
#include "modulelist.hpp"

WISP_FORM_RES_ITEM SearchDialogForm[] =
{
	{WISP_CTRL_FORM, {0, 0, 391, 220}, 0, 0xB, WSTR("Search"), (void*)"\\Toolbar.bmp#16#16:119", 0},
	{WISP_CTRL_STATIC_GROUP, {10, 10, 364, 80}, 0, 0, WSTR("Search Method"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {20, 32, 16, 16}, 0, 0, 0, (void*)"\\Toolbar.bmp#16#16:119", 0},
	{WISP_CTRL_STATIC_STRING, {40, 32, 45, 16}, 0, 0, WSTR("Type"), 0, 0},
	{WISP_CTRL_COMBO_BOX, {80, 30, 135, 20}, 1, 0x9040006, 0, 0, 0},
	{WISP_CTRL_CHECK_BOX, {230, 30, 100, 20}, 3, 0x20000000, WSTR("Match case"), 0, 0},
	{WISP_CTRL_STATIC_DIB, {20, 62, 16, 16}, 0, 0, 0, (void*)"\\Toolbar.bmp#16#16:5", 0},
	{WISP_CTRL_STATIC_STRING, {40, 62, 45, 18}, 0, 0, WSTR("Value"), 0, 0},
	{WISP_CTRL_EDIT, {80, 60, 280, 18}, 2, 0x1000006, 0, 0, 0},
	{WISP_CTRL_STATIC_DIB, {20, 116, 16, 16}, 0, 0, 0, (void*)"\\Toolbar.bmp#16#16:13*16+12", 0},
	{WISP_CTRL_STATIC_GROUP, {10, 95, 364, 50}, 0, 0, WSTR("Range"), 0, 0},
	{WISP_CTRL_STATIC_STRING, {40, 116, 40, 16}, 0, 0, WSTR("Begin"), 0, 0},
	{WISP_CTRL_EDIT, {80, 115, 70, 16}, 6, 0x1000006, 0, 0, 0},
	{WISP_CTRL_STATIC_STRING, {160, 116, 25, 16}, 0, 0, WSTR("End"), 0, 0},
	{WISP_CTRL_EDIT, {190, 115, 70, 16}, 7, 0x1000006, 0, 0, 0},
	{WISP_CTRL_BUTTON, {270, 113, 90, 20}, 8, 0, WSTR("Select Module"), 0, 0},
	{WISP_CTRL_BUTTON, {100, 160, 68, 20}, 9, 0, WSTR("Find"), 0, 0},
	{WISP_CTRL_BUTTON, {210, 160, 68, 20}, 0xA, 0x200, WSTR("Find Next"), 0, 0},
	{0},
};

	WISP_MSG_MAP_BEGIN(CSearchDialog)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

	WISP_CMD_MAP_BEGIN(CSearchDialog)
		WISP_CMD_MAP(1, OnCmd1)
	WISP_CMD_MAP_END

	WISP_EVENT_MAP_BEGIN(CSearchDialog)
		WISP_EVENT_MAP(8, OnEventModule)
		WISP_EVENT_MAP(9, OnEventOK)
		WISP_EVENT_MAP(10, OnEventSearch)
	WISP_EVENT_MAP_END


	CSearchDialog::CSearchDialog()
	{
		m_Resource = SearchDialogForm;
	}
	CSearchDialog::~CSearchDialog()
	{
	}

	bool CSearchDialog::OnCreateForm(WISP_MSG *pMsg)
	{
		m_pBegin = (CWispEdit *)GetFormItem(6);
		m_pEnd = (CWispEdit *)GetFormItem(7);
		m_pValue = (CWispEdit *)GetFormItem(2);
		m_pWidth = (CWispComboBox *)GetFormItem(1);
		m_pCase = (CWispCheckBox *)GetFormItem(3);

		static const WCHAR *Select[] =
			{
				WSTR("Text (Ansi)"),
				WSTR("Text (Unicode)"),
				WSTR("BYTE (s)"),
				WSTR("WORD  Value"),
				WSTR("DWORD Value"),
				WSTR("QWORD Value"),
				//NULL,
			};

		for (unsigned long i = 0; i < lenof(Select); ++i)
		{
			m_pWidth->m_ComboList.InsertItem(Select[i], 0, 0, 0, -1);
		}
		m_pWidth->SetCurSel(0);
		CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP);
		if (!pDbgMod)
			pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP);
		if (pDbgMod)
		{
			WCHAR Buffer[32];

			uNumToStr(pDbgMod->m_ImageBase, Buffer, 16);
			m_pBegin->SetWindowText(Buffer);

			uNumToStr(pDbgMod->m_ImageBase + pDbgMod->m_ImageSize, Buffer, 16);
			m_pEnd->SetWindowText(Buffer);
		}
		return true;
	}

	bool CSearchDialog::OnCmd1(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000400)
			m_pCase->EnableWindow(pMsg->Command.Param1 <= 1);
		return true;
	}

	bool CSearchDialog::OnEventModule(WISP_MSG *pMsg)
	{
		CModuleListWnd ModuleList;
		ModuleList.Create(true);
		if (ModuleList.m_pDbgMod)
		{
			WCHAR szNumber[32];

			uNumToStr(ModuleList.m_pDbgMod->m_ImageBase, szNumber, 16);
			m_pBegin->SetWindowText(szNumber);

			uNumToStr(ModuleList.m_pDbgMod->m_ImageBase + ModuleList.m_pDbgMod->m_ImageSize, szNumber, 16);
			m_pEnd->SetWindowText(szNumber);

			Update(&m_ClientRect);
		}
		return true;
	}

	bool CSearchDialog::OnEventOK(WISP_MSG *pMsg)
	{
		int width = m_pWidth->GetCurSel();
		if (width != -1)
		{
			if (m_pValue->m_WndText.m_nLength == 0)
			{
				gpCurWisp->MsgBox(WSTR("Invalid Search Data !"), WSTR("Error"), 0x40001, 0);
				return true;
			}

			if (!USHexStrToNum(m_pBegin->GetWindowText().operator const WCHAR*(), &m_Begin))
			{
				gpCurWisp->MsgBox(WSTR("Invalid Search Range !"), WSTR("Error"), 0x40001, 0);
				return true;
			}

			if (!USHexStrToNum(m_pEnd->GetWindowText().operator const WCHAR*(), &m_End))
			{
				gpCurWisp->MsgBox(WSTR("Invalid Search Range !"), WSTR("Error"), 0x40001, 0);
				return true;
			}

			if (m_Begin >= m_End)
			{
				gpCurWisp->MsgBox(WSTR("Invalid Search Range !"), WSTR("Error"), 0x40001, 0);
				return true;
			}

			m_bCase = true;
			memset(m_PatternBuffer, 0, sizeof(m_PatternBuffer));
			if (width == 0)
			{
				m_SearchResultLen = UnicodeToAnsi(m_pValue->m_WndText.operator const WCHAR*(), m_PatternBuffer, 64);
				m_bCase = (m_pCase->m_Style & 0x400) != 0;
			} else
			if (width == 1)
			{
				m_SearchResultLen = TStrCpyLimit(m_PatternBuffer, m_pValue->m_WndText.operator const WCHAR*(), 32)*2;
				m_bCase = (m_pCase->m_Style & 0x400) != 0;
			} else
			if (width == 2)
			{
				m_SearchResultLen = THexBytesToASCII(m_pValue->m_WndText.operator const WCHAR*(), m_PatternBuffer, 64);
				if (m_SearchResultLen == 0)
				{
					gpCurWisp->MsgBox(WSTR("Invalid Search Data !"), WSTR("Error"), 0x40001, 0);
					return true;
				}
			} else
			if (width == 3)
			{
				if (!USHexStrToNum(m_pValue->GetWindowText().operator const WCHAR*(), (unsigned short*)m_PatternBuffer))
				{
					gpCurWisp->MsgBox(WSTR("Invalid Search Data !"), WSTR("Error"), 0x40001, 0);
					return true;
				}
				m_SearchResultLen = 2;
			} else
			if (width == 4)
			{
				if (!USHexStrToNum(m_pValue->GetWindowText().operator const WCHAR*(), (unsigned long*)m_PatternBuffer))
				{
					gpCurWisp->MsgBox(WSTR("Invalid Search Data !"), WSTR("Error"), 0x40001, 0);
					return true;
				}
				m_SearchResultLen = 4;
			} else
			if (width == 5)
			{
				if (!USHexStrToNum(m_pValue->GetWindowText().operator const WCHAR*(), (ULONG_PTR*)m_PatternBuffer))
				{
					gpCurWisp->MsgBox(WSTR("Invalid Search Data !"), WSTR("Error"), 0x40001, 0);
					return true;
				}
				m_SearchResultLen = 8;
			}

			m_SearchResult = gpSyser->m_pDebugger->SearchMemory(m_Begin, m_End - m_Begin, m_PatternBuffer, m_SearchResultLen, m_bCase);
			if (m_SearchResult == -1)
			{
				gpCurWisp->MsgBox(WSTR("The special data was not found !"), WSTR("Data Search"), 0x40001, 0);
			} else
			{
				CWispBaseWnd *pWnd = (CWispBaseWnd *)GetFormItem(10);
				pWnd->EnableWindow(1);
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(m_SearchResult, m_SearchResultLen);
			}
			return true;
		}
		return true;
	}

	bool CSearchDialog::OnEventSearch(WISP_MSG *pMsg)
	{
		m_SearchResult = gpSyser->m_pDebugger->SearchMemory(m_SearchResultLen + m_SearchResult, m_End - m_SearchResult, m_PatternBuffer, m_SearchResultLen, m_bCase);
		if (m_SearchResult == -1)
		{
			CWispBaseWnd *pWnd = (CWispBaseWnd *)GetFormItem(10);
			pWnd->EnableWindow(0);
			gpCurWisp->MsgBox(WSTR("The special data was not found !"), WSTR("Data Search"), 0x40001, 0);
		} else
		{
			gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(m_SearchResult, m_SearchResultLen); //ULONG_PTR,unsigned long
		}
		return true;
	}

```

`source/WispSyser/searchdialog.hpp`:

```hpp

#ifndef _SEARCHDIALOG_HPP_
#define _SEARCHDIALOG_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wispedit.hpp"
#include "../Wisp/wispcheckbox.hpp"
#include "../Wisp/wispcombobox.hpp"

struct CSearchDialog : public CWispForm
{
	CWispComboBox *m_pWidth;
	CWispEdit *m_pBegin;
	CWispEdit *m_pEnd;
	CWispEdit *m_pValue;
	CWispCheckBox *m_pCase;
	ULONG_PTR m_Begin;
	ULONG_PTR m_End;
	ULONG_PTR m_SearchResult;
	bool m_bCase;
	char m_PatternBuffer[64];
	unsigned long m_SearchResultLen;

	CSearchDialog();
	virtual ~CSearchDialog();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreateForm(WISP_MSG *pMsg);

	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmd1(WISP_MSG *pMsg);

	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventModule(WISP_MSG *pMsg);
	bool OnEventOK(WISP_MSG *pMsg);
	bool OnEventSearch(WISP_MSG *pMsg);
};

#endif
```

`source/WispSyser/sehchainwnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "sehchainwnd.hpp"
#include "syserconfig.hpp"

	CSEHChainWnd::CSEHChainWnd()
	{
	}
	CSEHChainWnd::~CSEHChainWnd()
	{
	}

	WISP_MSG_MAP_BEGIN(CSEHChainWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_CLOSE, OnClose)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)


	WISP_EVENT_MAP_BEGIN(CSEHChainWnd)
//		WISP_EVENT_MAP(..., OnEvent...)
	WISP_EVENT_MAP_END


	bool CSEHChainWnd::OnCreate(WISP_MSG *pMsg)
	{
		InsertColumn(WSTR("Address"), 70, 0, 0, -1);
		InsertColumn(WSTR("SE Handler"), 200, 0, 0, -1);
		UpdateContext();
		return true;
	}
	bool CSEHChainWnd::OnClose(WISP_MSG *pMsg)
	{
		Show(WISP_SH_HIDDEN);
		return false;
	}

	void CSEHChainWnd::Create()
	{
		if (IsWindow())
		{
			Show(WISP_SH_MINSIZE);
		} else
		{
			CreateWnd(WSTR("SEH Chain"), 0,0,620,280, 0, 0x10, 0x100BB, WISP_SH_MINSIZE);
			Center(0);
		}
	}

	void CSEHChainWnd::UpdateContext()
	{
		WCHAR display[20];

		X86_CPU_REG_PTR CpuReg;
		gpSyser->m_pDebugger->GetX86RegPtr(&CpuReg);

		ULONG_PTR AddressTIB;
		unsigned long Limit;
		gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pFS, &AddressTIB, &Limit);

		unsigned long Mem[2];
		if (gpSyser->m_pDebugger->ReadMemory(AddressTIB, Mem, 8) == 8)
		{
			while (Mem[0] != -1)
			{
				AddressTIB = Mem[0];
				if (gpSyser->m_pDebugger->ReadMemory(AddressTIB, Mem, 8) != 8) break;
				TSPrintf(display, WSTR("%08X"), AddressTIB);
				CListStringItem *pItem = InsertItem(display, 0, 0, 0, -1);
				SetItemFormat(pItem, 1, Mem[1], WSTR("%X"));
			}
		}
	}

```

`source/WispSyser/sehchainwnd.hpp`:

```hpp

#ifndef _SEHCHAINWND_HPP_
#define _SEHCHAINWND_HPP_

#include "../Wisp/wisplist.hpp"

struct CSEHChainWnd : public CWispList
{
	CSEHChainWnd();
	virtual ~CSEHChainWnd();

        virtual bool MsgProc(WISP_MSG *pMsg) override;
        bool OnCreate(WISP_MSG *pMsg);
        bool OnClose(WISP_MSG *pMsg);
        bool OnEvent(WISP_MSG *pMsg);

        void UpdateContext();

        void Create();
};

#endif
```

`source/WispSyser/sharecmd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "syserdefine.hpp"

int expr_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc < 2)
	{
		WCHAR szCmd[64];
		TSPrintf(szCmd, WSTR("help %s"), argv[0]);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(szCmd, 0);
		return -1;
	}

	ULONG_PTR Result;
	char szSym[256];
	if (USHexStrToNum(argv[1], &Result) && gpSyser->m_SyserUI.GetSymbol(Result, szSym, 64))
	{
		WCHAR Buffer[256];
		TStrCpy(Buffer, szSym);
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<F>%s\n"), Buffer);
		return 0;
	}

	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Result))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %s is Invalid !\n"), argv[1]);
		return -1;
	}

	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Hex : " HEXFMT "\n"), Result);
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Dec : " DECFMT "\n"), Result);
	return 0;
}

int cv_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
	if (!pWnd) return -1;
	CListStringItem *Item = pWnd->GetRootItem();
	while (Item)
	{
		WCHAR Buffer[256];

		pWnd->GetItemText(Item, CV_ADDR, Buffer, lenof(Buffer));
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%s "), Buffer);

		pWnd->GetItemText(Item, CV_CODE, Buffer, lenof(Buffer));
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-20s "), Buffer);

		pWnd->GetItemText(Item, CV_INST, Buffer, lenof(Buffer));
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-30s "), Buffer);

		pWnd->GetItemText(Item, CV_CMT, Buffer, lenof(Buffer));
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%s\n"), Buffer);

		Item = pWnd->GetNext(Item, 0);
	}
	return 0;
}

int dv_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	ULONG_PTR Addr = -1;
	CDataView *pWnd = (CDataView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd();
	if (!pWnd) return -1;
	int nLines_Page = pWnd->m_nLines_Page;
	if (argc > 1)
	{
		ULONG_PTR Address;
                if (gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
                {
                        Addr = pWnd->m_CurAddr;
                        pWnd->m_CurAddr = Address;
                }

		ULONG_PTR Result;
                if (argc > 2 && gpSyser->m_SyserUI.CalcExp(argv[2], &Result))
                        nLines_Page = Result;
	}

	int nLine = 0;
	while (nLine < nLines_Page)
	{
		ULONG_PTR Address = pWnd->m_CurAddr + nLine * pWnd->m_nByte_Line;
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("" F0ADDR "X   "), Address);
		unsigned int Len = pWnd->m_ImageBase + pWnd->m_ImageSize - nLine * pWnd->m_nByte_Line - pWnd->m_CurAddr;
		MAX_LIMIT(Len, pWnd->m_nByte_Line);

		WCHAR szSpaces[32];
		TStrCpy(szSpaces, CWispHexWnd::m_Spaces);
		szSpaces[pWnd->m_ShowLength] = 0;
	
		WCHAR String[512];
		unsigned char Buffer[32];

		int LenAlign = (int)Len/pWnd->m_ShowLength;
		if (LenAlign % pWnd->m_ShowLength)
			++LenAlign;

		pWnd->m_LenArray[nLine][HEX_HEX_INDEX] = pWnd->m_ShowLength * LenAlign * 3;

		for (int i = 0; i < LenAlign; ++i)
		{
			if (pWnd->ReadMemory(Address + i * pWnd->m_ShowLength, Buffer, pWnd->m_ShowLength))
				THexBytesToStr(Buffer, String, Len, pWnd->m_ShowLength, szSpaces);
			else	TStrCpy(String, CWispHexWnd::m_UnReadable);
			String[pWnd->m_ShowLength*2] = 0;
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%s "), String);
		}

		for (int i = 0; i < Len; ++i)
		{
			if (pWnd->ReadMemory(Address+i, Buffer, 1))
				THexBytesToPrint(Buffer, String, 1);
			else	TStrCpy(String, CWispHexWnd::m_UnReadableASCII);
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%c"), String[0]);
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("\n"));
		++nLine;
	}

	if (Addr != -1)
		pWnd->m_CurAddr = Addr;
	return 0;
}

int sw_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
	{
		if (argc == 1)
		{
			if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP)
				gpSyser->m_MainFrame.m_SystemExplorer.m_StackWatchList.UpdateContext(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP, false);
			return 0;
		}

		ULONG_PTR Address;
		if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Input error!\n"));
			return -1;
		}
		gpSyser->m_MainFrame.m_SystemExplorer.m_StackWatchList.UpdateContext(Address, false);
	}
	return 0;
}

int d_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc  > 3)
		return 1;
	bool widthsame = false;

	switch ((*argv)[1])
	{
	case 'B':
	case 'b':
		if (pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveDataWidth() == 1) widthsame = 1;
		else	pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveDataWidth(1);
		break;
	case 'W':
	case 'w':
		if (pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveDataWidth() == 2) widthsame = 1;
		else	pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveDataWidth(2);
		break;
	case 'D':
	case 'd':
		if (pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveDataWidth() == 4) widthsame = 1;
		else	pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveDataWidth(4);
		break;
#ifdef _X64_
	case 'Q':
	case 'q':
		if (pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveDataWidth() == 8) widthsame = 1;
		else	pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveDataWidth(8);
		break;
#endif
	}

	if (argc == 1)
	{
		if (!widthsame) return 0;
		CDataView *pWnd = (CDataView *)pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd();
		if (!pWnd) return 1;
		ULONG_PTR Addr = pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveAddress();
		Addr += pWnd->m_nLines_Page * 16;
		if (pWnd->m_bShowOffset)
			Addr -= 16;
		pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveAddress(Addr, 0);
		return 0;
	} else
	if (argc == 2)
	{
		CDataView *pWnd = (CDataView *)pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd();
		if (!pWnd) return 1;
		
		if (!TStrICmp(argv[1], WSTR("-")))
		{
			pWnd->OnEventPrevHistory(0);
			return 0;
		}
		if (!TStrICmp(argv[1], WSTR("+")))
		{
			pWnd->OnEventNextHistory(0);
			return 0;
		}
		ULONG_PTR Address;
		if (gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
		{
			pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveAddress(Address, argv[1]);
			return 0;
		}
		return 1;
	} else
	if (argc == 3)
	{
		if (!TStrICmp(argv[1], WSTR("-")))
		{
			ULONG_PTR Address;
			if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Address))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %<3>Input error !\n"));
				return -1;
			}
			if (!pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd())
				return 1;
			pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveAddress(
			pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveAddress()-Address, 0);
			return 0;
		}

		if (!TStrICmp(argv[1], WSTR("+")))
		{
			ULONG_PTR Address;
			if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Address))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %<3>Input error !\n"));
				return -1;
			}
			if (!pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd())
				return 1;
			pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveAddress(
			pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveAddress()+Address, 0);
			return 0;
		}
#if 0
		if (!TStrICmp(argv[1], WSTR("-P")))
		{
			ULONG_PTR Address;
			if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Address))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %<3>Input error !\n"));
				return -1;
			}
			if (!MapToVAddr(Address, &Address, 1, 0, 0))
				return 1;
			pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveAddress(Address, 0);
			return 0;
		}
#endif
	} else
	if (argc == 0)
	{
		//???
		//pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveAddress(?, 0);
	}
	return 1;
}

int wc_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	pSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(CV_TAB); //CV_TAB(0)
	if (argc == 1)
	{
		CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
		pWnd->Focus();
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Press ESC to return console\n"));
		return 0;
	}

	ULONG_PTR Addr = 0;
	CCodeView *pWnd = 0;
	if (*argv[1] == '-')
	{
		if (pSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetWndCount()>1)
		{
			int Index = pSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWndIndex();
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.RemoveWnd(Index, true);
			gpSyser->m_MainFrame.FocusActive();
		}
		return 0;
	} else
	if (*argv[1] == '+')
	{
		Addr = static_cast<CCodeView*>(gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd())->m_CurAddr;
		pWnd = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.InsertView(0);
		if (!pWnd) return 1;
	} else
	{
		ULONG_PTR Index;
		if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Index))
			Index = 0;

		pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetWnd(Index);
		if (pWnd)
		{
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.ChangeActiveWnd(pWnd);

			Addr = static_cast<CCodeView*>(gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd())->m_CurAddr;
		} else
		{
			Addr = static_cast<CCodeView*>(gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd())->m_CurAddr;
			pWnd = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.InsertView(0);
			if (!pWnd) return 1;
		}
	}
	ULONG_PTR Address;
	if (argc > 2 && gpSyser->m_SyserUI.CalcExp(argv[2], &Address))
	{
		pWnd->GotoAddr(Address, true);
	} else
	if (Addr)
	{
		pWnd->GotoAddr(Addr, true);
	}
	pWnd->Focus();
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Press ESC to return console\n"));
	return 0;
}

int wd_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	pSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(CV_TAB); //CV_TAB(0)
	if (argc == 1)
	{
		CDataView *pWnd = (CDataView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd();
		pWnd->Focus();
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Press ESC to return console\n"));
		return 0;
	}

	ULONG_PTR Addr = 0;
	CDataView *pWnd = 0;
	if (*argv[1] == '-')
	{
		if (pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetWndCount()>1)
		{
			int Index = pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWndIndex();
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.RemoveWnd(Index, true);
			gpSyser->m_MainFrame.FocusActive();
		}
		return 0;
	} else
	if (*argv[1] == '+')
	{
		Addr = static_cast<CDataView*>(gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd())->m_CurAddr;
		pWnd = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.InsertView(0);
		if (!pWnd) return 1;
	} else
	{
		ULONG_PTR Index;
		if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Index))
			Index = 0;

		pWnd = (CDataView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetWnd(Index);
		if (pWnd)
		{
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.ChangeActiveWnd(pWnd);

			Addr = static_cast<CDataView*>(gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd())->m_CurAddr;
		} else
		{
			Addr = static_cast<CDataView*>(gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd())->m_CurAddr;
			pWnd = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.InsertView(0);
			if (!pWnd) return 1;
		}
	}
	ULONG_PTR Address;
	if (argc > 2 && gpSyser->m_SyserUI.CalcExp(argv[2], &Address))
	{
		pWnd->ViewAddress(Address, true);
	} else
	if (Addr)
	{
		pWnd->ViewAddress(Addr, true);
	}
	pWnd->Focus();
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Press ESC to return console\n"));
	return 0;
}

int ws_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	pSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(CV_TAB); //CV_TAB(0)
	pSyser->m_MainFrame.m_SystemExplorer.m_ContextTabWnd.SetActiveWnd(CV_S_TAB); //CV_S_TAB(0)
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Press ESC to return console\n"));
	return 0;
}

int ww_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	pSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(CV_TAB); //CV_TAB(0)
	pSyser->m_MainFrame.m_SystemExplorer.m_ContextTabWnd.SetActiveWnd(CV_W_TAB); //CV_W_TAB(1)
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Press ESC to return console\n"));
	return 0;
}

int wr_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	pSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(CV_TAB); //CV_TAB(0)
	CWispTabWnd *pWnd = (CWispTabWnd *)pSyser->m_MainFrame.m_SystemExplorer.m_RegTabWnd.GetActiveWnd();
	if (pWnd) pWnd->SetActiveWnd(CV_REG_GENE_TAB); //CV_REG_GENE_TAB(0)
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Press ESC to return console\n"));
	return 0;
}

int wf_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	pSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(CV_TAB); //CV_TAB(0)
	CWispTabWnd *pWnd = (CWispTabWnd *)pSyser->m_MainFrame.m_SystemExplorer.m_RegTabWnd.GetActiveWnd();
	if (pWnd) pWnd->SetActiveWnd(CV_REG_FPU_TAB); //CV_REG_FPU_TAB(1)
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Press ESC to return console\n"));
	return 0;
}

int wx_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	pSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(CV_TAB); //CV_TAB(0)
	CWispTabWnd *pWnd = (CWispTabWnd *)pSyser->m_MainFrame.m_SystemExplorer.m_RegTabWnd.GetActiveWnd();
	if (pWnd) pWnd->SetActiveWnd(CV_REG_SSE_TAB); //CV_REG_SSE_TAB(2)
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Press ESC to return console\n"));
	return 0;
}

int dex_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc == 1)
	{
		unsigned long Index = 0;
		TListIter<WISP_TAB_WND_ITEM> It = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.m_WndList.Begin();
		while (It != gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.m_WndList.End())
		{
			CDataView *pWnd = static_cast<CDataView*>(It->pWnd);
			bool Float = pWnd->GetFloatAddressMode() == true;
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("DataView[%d] Float Address %<f>%s %<1>Address " F0ADDR "X %s\n"),
					Index, Float?WSTR("On "):WSTR("Off"),
					pWnd->GetFloatAddress(pWnd->m_FloatAddressStr.operator const WCHAR*()),
					pWnd->m_FloatAddressStr.operator const WCHAR*());
			++It;
			++Index;
		}
	} else
	{
		ULONG_PTR Index;
		if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Index))
			Index = 0;
		CDataView *pWnd = (CDataView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetWnd(Index);
		if (!pWnd)
			pWnd = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.InsertView(0);
		if (pWnd)
		{
			bool Float = pWnd->GetFloatAddressMode() == true;
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("DataView[%d] Float Address %<f>%s %<1>Address " F0ADDR "X %s\n"),
					Index, Float?WSTR("On "):WSTR("Off"),
					pWnd->GetFloatAddress(pWnd->m_FloatAddressStr.operator const WCHAR*()),
					pWnd->m_FloatAddressStr.operator const WCHAR*());
		}
	}
	return 0;
}

int isf_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc < 2)
	{
		WCHAR szCmd[64];
		TSPrintf(szCmd, WSTR("help %s"), argv[0]);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(szCmd, 0);
		return -1;
	}

	ULONG_PTR Result;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Result))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n")); //WSTR("Error : %s is Invalid !\n"), argv[1]);
		return -1;
	}

	CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Result);
	if (!pDbgMod)
		return 1;
	{
		//TODO gpSyser->m_SyserUI.m_SymAnalyzer.???(pDbgMod, Result); //pDbgMod->+30);
		//TODO gpSyser->m_MainFrame.m_SystemExplorer.m_SymAnalyzer.???(pDbgMod, Result); //pDbgMod->+30);
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
	}
	return 0;
}

SYSER_CMD_ENTRY ShareCmdTable[] =
{
	{ WSTR("?"), WSTR("Calculate expression"), expr_command, 
	0},

	{ WSTR("cv"), WSTR("Print Code View string to console"), cv_command,
		WSTR("cv: Dump CodeView context to console (then you can save console histroy by loader)\n"
		"Format: cv\n"
		"Example1: cv\n") },
	{ WSTR("dv"), WSTR("Print Data View string to console"), dv_command,
		WSTR("dv: Dump DataView context to console (then you can save console histroy by loader)\n"
		"Format: dv\n"
		"Example1: dv\n") },

	{ WSTR("sw"), WSTR("Show data at stack watch"), sw_command, 
	0},

	{ WSTR("d"), WSTR("Show memory data"), d_command, 
		WSTR("d,db,dw,dd,dq: Show memory data\n"
		"Format: d[b,w,d,q] address\n"
		"Example1: d[b,w,d,q] 401000\n"
		"Example2: d[b,w,d,q] ESI+8\n"
		"Example3: d[b,w,d,q] +\n"
		"Example4: d[b,w,d,q] -\n"
		"Example5: d[b,w,d,q] + offset\n"
		"Example5: d[b,w,d,q] - offset\n")},
	{ WSTR("db"), WSTR("Show memory data (BYTE)"), d_command, 
		WSTR("d,db,dw,dd,dq: Show memory data\n"
		"Format: d[b,w,d,q] address\n"
		"Example1: d[b,w,d,q] 401000\n"
		"Example2: d[b,w,d,q] ESI+8\n"
		"Example3: d[b,w,d,q] +\n"
		"Example4: d[b,w,d,q] -\n"
		"Example5: d[b,w,d,q] + offset\n"
		"Example5: d[b,w,d,q] - offset\n")},
	{ WSTR("dw"), WSTR("Show memory data (WORD)"), d_command, 
		WSTR("d,db,dw,dd,dq: Show memory data\n"
		"Format: d[b,w,d,q] address\n"
		"Example1: d[b,w,d,q] 401000\n"
		"Example2: d[b,w,d,q] ESI+8\n"
		"Example3: d[b,w,d,q] +\n"
		"Example4: d[b,w,d,q] -\n"
		"Example5: d[b,w,d,q] + offset\n"
		"Example5: d[b,w,d,q] - offset\n")},
	{ WSTR("dd"), WSTR("Show memory data (DWORD)"), d_command, 
		WSTR("d,db,dw,dd,dq: Show memory data\n"
		"Format: d[b,w,d,q] address\n"
		"Example1: d[b,w,d,q] 401000\n"
		"Example2: d[b,w,d,q] ESI+8\n"
		"Example3: d[b,w,d,q] +\n"
		"Example4: d[b,w,d,q] -\n"
		"Example5: d[b,w,d,q] + offset\n"
		"Example5: d[b,w,d,q] - offset\n")},
	{ WSTR("dq"), WSTR("Show memory data (QWORD)"), d_command, 
		WSTR("d,db,dw,dd,dq: Show memory data\n"
		"Format: d[b,w,d,q] address\n"
		"Example1: d[b,w,d,q] 401000\n"
		"Example2: d[b,w,d,q] ESI+8\n"
		"Example3: d[b,w,d,q] +\n"
		"Example4: d[b,w,d,q] -\n"
		"Example5: d[b,w,d,q] + offset\n"
		"Example5: d[b,w,d,q] - offset\n")},

	{ WSTR("wc"), WSTR("focus code view (wc + to add new view)"), wc_command,
		WSTR("wc,wd: Code,Data Window command\n"
		"Format: wc[d] [+][-] [address][index_of_windows]\n"
		"Example1: wc[d] + eip+5\n"
		"Example2: wc[d] 1                   (focus code[data] window 1)\n"
		"Example3: wc[d] +                   (add new code[data] window)\n"
		"Example4: wc[d] -                   (remove current code[data] window)\n" )},
	{ WSTR("code"), WSTR("focus code view (code + to add new view)"), wc_command,
		WSTR("code: Code Window command\n"
		"Format: code [+][-] [address][index_of_windows]\n"
		"Example1: code + eip+5\n"
		"Example2: code 1                   (focus code window 1)\n"
		"Example3: code +                   (add new code window)\n"
		"Example4: code -                   (remove current code window)\n")},

	{ WSTR("wd"), WSTR("focus data view (wc + to add new view)"), wd_command,
		WSTR("wd,wc: Data,Code Window command\n"
		"Format: wd[c] [+][-] [address][index_of_windows]\n"
		"Example1: wd[c] + eip+5\n"
		"Example2: wd[c] 1                   (focus data[code] window 1)\n"
		"Example3: wd[c] +                   (add new data[code] window)\n"
		"Example4: wd[c] -                   (remove current data[code] window)\n" )},
	{ WSTR("data"), WSTR("focus data view (data + to add new view)"), wd_command,
		WSTR("data: Data Window command\n"
		"Format: data [+][-] [address][index_of_windows]\n"
		"Example1: data + eip+5\n"
		"Example2: data 1                   (focus data window 1)\n"
		"Example3: data +                   (add new data window)\n"
		"Example4: data -                   (remove current data window)\n")},

	{ WSTR("ws"), WSTR("focus stack watch list (HotKey ALT+S)"), ws_command, 
	0},
	{ WSTR("ww"), WSTR("focus watch list (HotKey ALT+S)"), ww_command, 
	0},
	{ WSTR("wr"), WSTR("focus register list (HotKey ALT+R)"), wr_command, 
	0},
	{ WSTR("wf"), WSTR("focus FPU register list (HotKey ALT+F)"), wf_command, 
	0},
	{ WSTR("wx"), WSTR("focus XMM register list (HotKey ALT+X)"), wx_command, 
	0},
	{ WSTR("dex"), WSTR("switch data view float address mode"), dex_command, 
	0},
	{ WSTR("isf"), WSTR("Identify standard C(++) library function"), isf_command, 
		WSTR("isf: Identify standard C(++) library function\n"
		"Format: isf address    (if address is a standard C(++) library function and symbols will be inserted automaticly)\n"
		"Example1: isf 401000\n")},
	{0},
};

```

`source/WispSyser/sourcecodewnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "sourcecodewnd.hpp"
#include "syserconfig.hpp"
#include "resource.hpp"
#include "strinputwnd.hpp"

//#include<vector>
//#include<string>

	extern const char *teststr;

	extern char *yytext;
	extern int yyleng;
	extern void yy_set_input(const char *str);
	extern int yylex();
	extern void yyrestart(FILE*);

WISP_MENU_GROUP_ITEM SourceCodePopupMenu[] =
{
	{WSTR("Insert/Remove  Breakpoint         F9"), EVENT_ID_INSREMBP, 0xF3, 0, 0},
	{WSTR("Enable/Disable Breakpoint"), EVENT_ID_ENDISMBP, 0xF4, 0, 0},
	{WSTR("Toggle BookMark                   Ctrl+K"), EVENT_ID_TOGGLE_BM, 0xD0, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Go To Line                        Ctrl+G"), EVENT_ID_SOURCECODEWND_GOTOLINE, 0x10B, 0, 0},
	{WSTR("Go To Here                        F7"), EVENT_ID_GOTO_HERE, 0x10D, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Add Watch"), EVENT_ID_SOURCECODEWND_ADDWATCH, 0x10C, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Expansion All"), EVENT_ID_SOURCECODEWND_EXPANSION, 0x109, 0, 0},
	{WSTR("Collapse  All"), EVENT_ID_SOURCECODEWND_COLLAPSE, 0x10A, 0, 0},
	{0},
};

	WISP_MSG_MAP_BEGIN(CSourceCodeWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_UPDATE_CLIENT, OnUpdateClient)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	
	WISP_EVENT_MAP_BEGIN(CSourceCodeWnd)
		WISP_EVENT_MAP(EVENT_ID_SOURCECODEWND_EXPANSION, OnEventExpansion)
		WISP_EVENT_MAP(EVENT_ID_SOURCECODEWND_COLLAPSE, OnEventCollapse)
		WISP_EVENT_MAP(EVENT_ID_SOURCECODEWND_GOTOLINE, OnEventGotoLine)
		WISP_EVENT_MAP(EVENT_ID_INSREMBP, OnEventInsDelBP)
		WISP_EVENT_MAP(EVENT_ID_ENDISMBP, OnEventEnDisBP)

		WISP_EVENT_MAP(EVENT_ID_GOTO_HERE, OnEventGotoHere)
		WISP_EVENT_MAP(EVENT_ID_SHOW_HERE, OnEventShowHere)

		WISP_EVENT_MAP(EVENT_ID_SOURCECODEWND_ADDWATCH, OnEventAddWatch)

		WISP_EVENT_MAP(EVENT_ID_TOGGLE_BM, OnEventToggleBM) //0x64
	//	WISP_EVENT_MAP(EVENT_ID_NEXT_BM, OnEventNextBM)
	//	WISP_EVENT_MAP(EVENT_ID_PREV_BM, OnEventPrevBM)
	//	WISP_EVENT_MAP(EVENT_ID_CLEAR_BM, OnEventClearBM)

	WISP_EVENT_MAP_END

	CSourceCodeWnd::CSourceCodeWnd()
	{
		m_CurrentFileID = 0;
		m_FileOpen = false;
		m_TxtFileLineNumber = 0;
		m_bComment = false;
		m_CurAddr = 0;
	}
	CSourceCodeWnd::~CSourceCodeWnd()
	{
	}


	bool CSourceCodeWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_Style |= 0x2000000;
		InsertColumn(WSTR("Mark"), 40, 0, 0, -1);
		InsertColumn(WSTR("Source Code"), 512, 0, 0, -1);
		m_nCtrlCol = 1;
		Recalc(false);
		m_PopupMenu.LoadPopupMenuGroup(SourceCodePopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));

		m_Color[1] = gSyserColors.Color[6];

		m_Color[2] = gSyserColors.Color[9];
		m_Color[3] = gSyserColors.Color[10];
		m_Color[4] = gSyserColors.Color[11];
		m_Color[5] = gSyserColors.Color[12];
		m_Color[6] = gSyserColors.Color[13];
		m_Color[7] = gSyserColors.Color[14];
		m_Color[8] = gSyserColors.Color[15];
		m_Color[9] = gSyserColors.Color[16];
		m_Color[10] = gSyserColors.Color[17];
		m_Color[11] = gSyserColors.Color[18];
		m_Color[12] = gSyserColors.Color[19];
		m_Color[13] = gSyserColors.Color[20];
		m_Color[14] = gSyserColors.Color[21];
		m_Color[15] = gSyserColors.Color[22];

		m_Color[27] = gSyserColors.Color[37];  // 0xFFFFFF,   //Keyword
		m_Color[28] = gSyserColors.Color[38];  // 0xC0C0C0,   //Identifier
		m_Color[29] = gSyserColors.Color[39];  // 0x4080FF,   //Preprocessor Keyword
		m_Color[30] = gSyserColors.Color[40];  // 0x808080,   //Comment block
		m_Color[31] = gSyserColors.Color[41];  // 0x808080,   //Comment line
		m_Color[32] = gSyserColors.Color[42];  // 0xFFFF00,   //String
		m_Color[33] = gSyserColors.Color[43];  // 0x00FF80,   //Numerical
		m_Color[34] = gSyserColors.Color[44];  // 0xFFFFFF,   //Operation
		m_Color[35] = gSyserColors.Color[45];  // 0xE17D7D,   //Class name
		m_Color[36] = gSyserColors.Color[46];  // 0xE17D7D,   //Struct name
		m_Color[37] = gSyserColors.Color[47];  // 0xE17D7D,   //Union name
		m_Color[38] = gSyserColors.Color[48];  // 0xE17D7D,   //Typedef name
		m_Color[39] = gSyserColors.Color[49];  // 0xFF8000,   //Function name
		m_Color[40] = gSyserColors.Color[50];  // 0x7B7B7B,   //Unknown

		m_ClientDC.m_pColor = m_Color;
		m_ColorFocus = gSyserColors.Color[35];
		m_ColorUnFocus = gSyserColors.Color[36];
		m_crBGColor = gSyserColors.Color[34];
		m_bBGColor = true;
		m_ItemColor = gSyserColors.Color[43];
		m_pLineMarkDIBList = gpCurWisp->m_DIBLib.LoadDIBList("\\SyserApp\\LineMark.bmp", 16, 16, 0, 0xFF00FF);
		m_pLineMarkDIBList->SetColorKey(0);
		return true;
	}
	bool CSourceCodeWnd::OnDestroy(WISP_MSG *pMsg)
	{
		if (m_FileOpen)
			DeleteAllChildrenItems(0);
		m_PopupMenu.Destroy();
		return true;
	}

	bool CSourceCodeWnd::IsAddWatch()
	{
		m_WatchVar.Empty();
		m_WatchVarComplex.Empty();
		TListIter<CListStringItem> It;
		Point2Iter(&m_LogicMousePosWnd, It);
		if (!It) return true; //???
		CListStringItem *Item = &*It;

		WCHAR OutText[512];
		TStrCpy(OutText, "");

		WISP_RECT Rect;
		GetItemRect(Item, 1, &Rect);
		if (m_LogicMousePosWnd.x < Rect.x) return false;
		if (m_LogicMousePosWnd.x > (Rect.x + Rect.cx)) return false;

		unsigned long LineNumber = GetItemValue(Item, 1);
		unsigned int MaxLen = m_LogicMousePosWnd.x - m_nSpaceWidth - Rect.x;
		CListStringItem::CONTENT *Content = GetItemContent(Item, 1);
		const WCHAR *str = Content->String.operator const WCHAR*();
		unsigned int nLen = m_ClientDC.GetTextLen(str, MaxLen);
		if (nLen == -1) return false;

		char szString[512];
		TStrCpy(szString, ((unsigned long *)str)+1); //???

		yy_set_input(szString);

		int sol = 0;
		int eol = 0;

		yyrestart(0);

		for (;;)
		{
			int Lex = yylex();
		#if 1
			switch (Lex)
			{
			case 0:
				return true;
			case 660:
				break;
			case 679:
				break;
			case 705:
				if (sol == 0)
					sol = eol;
				break;
			default:
				sol = 0;
				break;
			}
		#else
			if (Lex == 0) return true;
			if (Lex != 660) // . L_PERIOD
			{
				if (Lex == 679) // -> L_POINTSTO
				{
				} else
				if (Lex == 705) // string
				{
					if (sol == 0)
						sol = eol;
				} else
				{
					sol = 0;
				}
			}
		#endif
			if (nLen >= eol && nLen < yyleng + eol)
			{
				if (Lex != 705) return false;
				break;
			}
			eol += yyleng;
		}

		TAnsiString String;

		if (sol != eol)
		{
			szString[eol + yyleng] = 0;
			bool bFunc = false;
			unsigned long offset = 0;
			void *ptr = m_pSDSMod->GetGlobal(&szString[sol], m_CurrentFileID, LineNumber, &bFunc, &offset);
			if (!ptr) return false;

			m_WatchVarComplex = &szString[sol];
			String.Empty();
			if (!bFunc)
			{
				DATATYPE *data = (DATATYPE*)ptr;
				char Output[512];
				int OutputLen = 512;
				memset(Output, 0, 512);
				String = m_pSDSMod->GetOutput(data->TypeID, Output, &OutputLen);
				String += " ";
				if (data->ClassID)
				{
					BASICTYPE *udt = m_pSDSMod->GetGlobal(data->ClassID);
					if (udt && (udt->Elem.Type == ELEM_STRUCT ||
						    udt->Elem.Type == ELEM_CLASS ||
						    udt->Elem.Type == ELEM_UNION))
					{
						String += m_pSDSMod->GetOutput(data->ClassID, Output, &OutputLen);
						String += "::";
					}
				}
				String += data->name;
				TStrCpy(OutText, String.operator const char*());
				m_WatchVar = yytext;
				return true;
			}
		} else
		{
		#if 1 //+++
			if (GetOutput(yytext, Item, String))
			{
				TStrCpy(OutText, String.operator const char*());
				m_WatchVar = yytext;
				return true;
			}
		#endif
			if (m_pSDSMod->GetGlobal(yytext, true))
			{
				m_WatchVar = yytext;
				return true;
			}
		#if 0 //+++			
			if (GetOutput(yytext, Item, String))
			{
				TStrCpy(OutText, String.operator const char*());
				m_WatchVar = yytext;
				return true;
			}
		#endif
		}
		return false;
	}

	void CSourceCodeWnd::OnPopupMenu(WISP_MSG *pMsg)
	{
		if (IsAddWatch())
			m_PopupMenu.EnableItem(EVENT_ID_SOURCECODEWND_ADDWATCH);
		else	m_PopupMenu.DisableItem(EVENT_ID_SOURCECODEWND_ADDWATCH);
		m_PopupMenu.Point(0, 1);
	}
	bool CSourceCodeWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.bKeyDown)
		{
			switch (pMsg->KeyEvent.KeyType)
			{
			case VK_RBUTTON:{
				m_LogicMousePosWnd = pMsg->MsgMouseWndPT;
				m_LogicMousePosWnd = pMsg->m_LogicMousePosWnd;
				int Index;
				Point2Index(&pMsg->m_LogicMousePosWnd, &Index);
				if (Index > 0 && Index < 4096)
					OnPopupMenu(pMsg);
				//TODO ???
				} break;
			case VK_F7:
				OnEventGotoLine(0);
				break;
			case VK_F9:
				OnEventInsDelBP(0);
				break;
			}
		}
		return true;
	}

	bool CSourceCodeWnd::OnUpdateClient(WISP_MSG *pMsg)
	{
		CWispList::OnUpdateClient(pMsg);
		int Index = 0;
		WISP_RECT Rect;
		Rect.x = 0;
		if (m_Columns.Size())
			Rect.x = m_Columns.Begin()->nRealWidth - 20;
		Rect.y = m_nLayoutHeight;
		Rect.cx = 16;
		Rect.cy = 16;
		if (m_RootIter != m_RootItem.End() && m_nVSBPage > 0)
		{
		TListIter<CListStringItem> It = m_RootIter;
		while (Index < m_nVSBPage)
		{
			CListStringItem *Item = &*It;
			unsigned long pic = GetItemValue(Item, 0);
			if (pic & 8) m_ClientDC.DrawDIB(&Rect, m_pLineMarkDIBList->m_DIBList + 1);
			if (pic & 1) m_ClientDC.DrawDIB(&Rect, m_pLineMarkDIBList->m_DIBList + 0);
			if (pic & 2) m_ClientDC.DrawDIB(&Rect, m_pLineMarkDIBList->m_DIBList + 2);
			else
			if (pic & 4) m_ClientDC.DrawDIB(&Rect, m_pLineMarkDIBList->m_DIBList + 3);
			Rect.y += m_nLineHeight;
			if (!NextOpen(It))
				break;
			++Index;
		}
		}
		return false;
	}

	bool CSourceCodeWnd::OnEventExpansion(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetItem(0, 0);
		while (Item)
		{
			if (GetItem(0, Item))
				Expand(Item);
			Item = GetNext(Item, 0);
		}
		Update((WISP_RECT*)0);
		return true;
	}
	bool CSourceCodeWnd::OnEventCollapse(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetItem(0, 0);
		CListStringItem *Parent = GetItemParent(GetRootItem());
		if (GetItemParent(Item) != Parent)
			Scroll(Parent, 0);
		while (Item)
		{
			if (GetItem(0, Item))
				Collapse(Item);
			Item = GetNext(Item, 0);
		}
		Update((WISP_RECT*)0);
		return true;
	}

	bool CSourceCodeWnd::OnEventGotoLine(WISP_MSG *pMsg)
	{
		TWideString String;
		WCHAR szString[64];
		TSPrintf(szString, WSTR("Line number (1 - %d):  "), m_TxtFileLineNumber - 1);
		CListStringItem *Item = GetNext(0, 8);
		if (Item)
		{
			unsigned long LineNum = GetItemValue(Item, 1);
			String.Format(WSTR("%d"), LineNum);
		} else
		{
			String = WSTR("1");
		}

		if (CStrInputWnd::Input(&String, szString, WSTR("Please Input ....")))
		{
			unsigned long LineNumber = 0;
			if (USDecStrToNum(String.operator const WCHAR*(), &LineNumber))
			{
				if (LineNumber >= 1)
				{
					CListStringItem *Item = GetItem(LineNumber - 1, 0);
					if (Item)
					{
						Scroll(Item, -1);
						Select(Item);
						Focus();
					}
				}
			}
		}
		return true;
	}
	bool CSourceCodeWnd::OnEventAddWatch(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_TypeViewerWnd.AddWatch(m_WatchVar.operator const char*(), NULL);
		return true;
	}
	bool CSourceCodeWnd::OnEventToggleBM(WISP_MSG *pMsg)
	{
		ToggleBM();
		return true;
	}

	unsigned long CSourceCodeWnd::GetAddr(CListStringItem *Item)
	{
		unsigned long LineNumber = GetItemValue(Item, 1);
		if (!GetItemLevel(Item))
		{
			map<unsigned long, MAPFilesLN>::IT it = m_FileLNMap.find(LineNumber);
			if (it == m_FileLNMap.end())
			{
				FilesLN *fileln = m_pSDSMod->GetFilesLN(m_CurrentFileID, LineNumber);
				if (!fileln) return 0;
				LineNumber = fileln->address;
			} else
			{
				LineNumber = it->second.fileln->address;
			}
		}
		return LineNumber;
	}

	bool CSourceCodeWnd::OnEventInsDelBP(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FullFindItem(0, 8);
		if (Item)
		{
			unsigned long Addr = GetAddr(Item);
			CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp,m_pSDSMod->GetFILESIG().CheckSum);
			if (pDbgMod)
			{
				gpSyser->m_SyserUI.ToggleInsertBP(Addr + pDbgMod->m_ImageBase);
			} else
			{
				TListIter<unsigned long> It = m_pSDSMod->m_BreakPoints.Find(Addr);
				if (It == m_pSDSMod->m_BreakPoints.End())
					m_pSDSMod->m_BreakPoints.Append(&Addr);
				else	m_pSDSMod->m_BreakPoints.Remove(It);
				UpdateContextPics();
			}
		}
		return true;
	}
	bool CSourceCodeWnd::OnEventEnDisBP(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FullFindItem(0, 8);
		if (Item)
		{
			unsigned long Addr = GetAddr(Item);
			CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp,m_pSDSMod->GetFILESIG().CheckSum);
			if (pDbgMod)
			{
				gpSyser->m_SyserUI.ToggleEnableBP(Addr + pDbgMod->m_ImageBase);
			}
		}
		return true;
	}

	bool CSourceCodeWnd::OnEventGotoHere(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FullFindItem(0, 8);
		if (Item)
		{
			unsigned long Addr = GetAddr(Item);
			CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp,m_pSDSMod->GetFILESIG().CheckSum);
			if (pDbgMod)
			{
				gpSyser->m_pDebugger->SetCodeBP(Addr + pDbgMod->m_ImageBase, 0x200, BP_STATE_ENABLE);
				gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("x"), 0);
			}
		}
		return true;
	}

	bool CSourceCodeWnd::OnEventShowHere(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FullFindItem(0, 8);
		if (Item)
		{
			unsigned long Addr = GetAddr(Item);
			CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp,m_pSDSMod->GetFILESIG().CheckSum);
			if (pDbgMod)
			{
				*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP = Addr + pDbgMod->m_ImageBase;
				gpSyser->m_pDebugger->UpdateRegisters();
				gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
			}
		}
		return true;
	}

	void CSourceCodeWnd::OnLButton(CListStringItem *Item, int nCol)
	{
		if (nCol == 0)
			OnEventInsDelBP(0);
	}

	void CSourceCodeWnd::OnRButton(CListStringItem *Item, int nCol)
	{
		if (nCol == 0)
			ToggleBM();
	}

	bool CSourceCodeWnd::GetTipText(CListStringItem *Item, int nCol, int *pPosX, int *pPosY, WCHAR *pOutText)
	{
		if (gSyserConfig.iSourceCodeShowTips == 0) return false;
		if (nCol != 1) return false;

		TStrCpy(pOutText, "");

		WISP_RECT Rect;
		GetItemRect(Item, 1, &Rect);

		unsigned long LineNumber = GetItemValue(Item, 1);
		unsigned int MaxLen = m_pWispBase->m_MousePT.x - m_nSpaceWidth - m_ScrClientRect.x - Rect.x;
		CListStringItem::CONTENT *Content = GetItemContent(Item, 1);
		const WCHAR *str = Content->String.operator const WCHAR*();
		unsigned int nLen = m_ClientDC.GetTextLen(str, MaxLen); //???
		if (nLen == -1) return false;

		char szString[512];
		TStrCpy(szString, ((unsigned long *)str)+1); //???
		*pPosX += MaxLen + 10;
		*pPosY += 16;

		yy_set_input(szString);

		int sol = 0;
		int eol = 0;

		yyrestart(0);

		for (;;)
		{
			int Lex = yylex();
		#if 1
			switch (Lex)
			{
			case 0:
				return true;
			case 660:
				break;
			case 679:
				break;
			case 705:
				if (sol == 0)
					sol = eol;
				break;
			default:
				sol = 0;
				break;
			}
		#else
			if (Lex == 0) return true;
			if (Lex != 660) // . L_PERIOD
			{
				if (Lex == 679) // -> L_POINTSTO
				{
				} else
				if (Lex == 705) // string
				{
					if (sol == 0)
						sol = eol;
				} else
				{
					sol = 0;
				}
			}
		#endif
			if (nLen >= eol && nLen < yyleng + eol)
			{
				if (Lex != 705) return false;
				break;
			}
			eol += yyleng;
		}

		TAnsiString String;

		if (sol != eol)
		{
			szString[eol + yyleng] = 0;
			bool bFunc = false;
			unsigned long offset = 0;
			void *ptr = m_pSDSMod->GetGlobal(&szString[sol], m_CurrentFileID, LineNumber, &bFunc, &offset);
			if (!ptr) return false;

			String.Empty();
			if (bFunc)
			{
				FUNCTION *func = (FUNCTION*)ptr;
				char Buffer[512];
				int Len = 512;
				memset(Buffer, 0, 512);
				m_pSDSMod->GetOutputFunc(func, Buffer, &Len);
				String = Buffer;
			} else
			{
				DATATYPE *data = (DATATYPE*)ptr;
				char Output[512];
				int OutputLen = 512;
				memset(Output, 0, 512);
				String = m_pSDSMod->GetOutput(data->TypeID, Output, &OutputLen);
				String += " ";
				if (data->ClassID)
				{
					BASICTYPE *udt = m_pSDSMod->GetGlobal(data->ClassID);
					if (udt && (udt->Elem.Type == ELEM_STRUCT ||
						    udt->Elem.Type == ELEM_CLASS ||
						    udt->Elem.Type == ELEM_UNION))
					{
						String += m_pSDSMod->GetOutput(data->ClassID, Output, &OutputLen);
						String += "::";
					}
				}
				String += data->name;
			}
			TStrCpy(pOutText, String.operator const char*());
			return true;
		} else
		{
		#if 1 //+++
			if (GetOutput(yytext, Item, String))
			{
				TStrCpy(pOutText, String.operator const char*());
				return true;
			}
		#endif
			BASICTYPE *type = m_pSDSMod->GetGlobal(yytext, true);
			if (type)
			{
				switch (type->Elem.Type)
				{
				case ELEM_ENUM:{
					String.Empty();
					m_pSDSMod->GetOutputEnum((ENUMTYPE*)type, String);
					TStrCpy(pOutText, String.operator const char*());
					break;}
				case ELEM_STRUCT:{
					TStrCpy(pOutText, "struct ");
					TStrCat(pOutText, yytext);
					break;}
				case ELEM_CLASS:{
					TStrCpy(pOutText, "class ");
					TStrCat(pOutText, yytext);
					break;}
				case ELEM_UNION:{
					TStrCpy(pOutText, "union ");
					TStrCat(pOutText, yytext);
					break;}
				case ELEM_TYPEDEF:{
					String.Empty();
					m_pSDSMod->GetOutputTypedef((TYPEDEFTYPE*)type, String);
					TStrCpy(pOutText, String.operator const char*());
					break;}
				default:
					goto func;
				}
				return true;
			}
		func:
		#if 0 //+++
			if (GetOutput(yytext, Item, String))
			{
				TStrCpy(pOutText, String.operator const char*());
				return true;
			}
		#endif
			return false;
		}
		return false;
	}

	bool CSourceCodeWnd::Edit(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (IsColorString(String.operator const WCHAR*()))
		{	
			WCHAR Buffer[512];
			TStrCpyLimit(Buffer, ((unsigned long*)String.operator const WCHAR*())+1, 512);
			m_EditWnd.m_WndText = Buffer;
		}
		return true;
	}

	bool CSourceCodeWnd::OnEditing(CListStringItem *Item, int nCol, TWideString& String)
	{
		return false;
	}

	void CSourceCodeWnd::ClearBM()
	{
		m_Bookmark.clear();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();
		UpdateContextPics();
	}
	bool CSourceCodeWnd::IsBM(unsigned long LineNumber)
	{
		return m_Bookmark.find(LineNumber) != m_Bookmark.end();
	}
	void CSourceCodeWnd::ToggleBM()
	{
		CListStringItem *Item = FullFindItem(0, 8);
		if (Item)
		{
			if (GetItemLevel(Item))
				Item = GetItemParent(Item);
			unsigned long LineNumber = GetItemValue(Item, 1);
			map<unsigned long,CListStringItem *>::IT it = m_Bookmark.find(LineNumber);
			if (it)
				m_Bookmark.erase(it);
			else	m_Bookmark.insert(_Tmap_pair<unsigned long,CListStringItem *>(LineNumber, Item));
			gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();
			UpdateContextPics();
		}
	}
	void CSourceCodeWnd::NextBM()
	{
		CListStringItem *Item = FindItem(0, 8);
		if (!Item)
			Item = GetRootItem();
		if (Item)
		{
			if (GetItemLevel(Item))
				Item = GetItemParent(Item);
			unsigned long LineNumber = GetItemValue(Item, 1);
			map<unsigned long,CListStringItem *>::IT it = m_Bookmark.find_near(LineNumber);
			if (it) ++it;
			if (!it) it = m_Bookmark.begin();
			if (it)
			{
				Scroll(it->second, -1);
				Select(it->second);
			}
		}
	}
	void CSourceCodeWnd::PrevBM()
	{
		CListStringItem *Item = FindItem(0, 8);
		if (!Item)
			Item = GetRootItem();
		if (Item)
		{
			if (GetItemLevel(Item))
				Item = GetItemParent(Item);
			unsigned long LineNumber = GetItemValue(Item, 1);
			map<unsigned long,CListStringItem *>::IT it = m_Bookmark.find_near(LineNumber);
			if (it && FindItem(0, 8) == it->second)
				--it;
			if (!it) it = m_Bookmark.rbegin();
			if (it)
			{
				Scroll(it->second, -1);
				Select(it->second);
			}
		}
	}

	void CSourceCodeWnd::ShowLineNum(unsigned long LineNumber)
	{
		CListStringItem *Item = GetItem(0, 0);
		if (Item)
		{
			while (Item)
			{
				unsigned long lineNum = GetItemValue(Item, 1);
				if (lineNum == LineNumber)
					break;
				Item = GetNext(Item, 0);
			}
			if (Item && !CheckItemPage(Item))
			{
				Scroll(Item, -1);
				Select(Item);
			}
		}
	}

	unsigned long *CSourceCodeWnd::OptItemToCS(_OPERAND_ITEM *OpArray, int nOp, unsigned long *pColorString, _INSTRUCTION_INFORMATION *pDasmInstr)
	{
		WCHAR szBuffer[32];

		for (int n = 0; n < nOp; ++n)
		{
			_OPERAND_ITEM *pOp = &OpArray[n];
			if (pOp->mode == OP_Invalid) break;
			if (n > 0)
				pColorString += ColorStrCpy(pColorString, ",", COLOR_OPTR, 0);
			if (pOp->mode == OP_Address)
			{
				if (pOp->opersize != -1)
				{
					pColorString += ColorStrCpy(pColorString, CInstrSym::m_SizeSym[pOp->opersize], COLOR_KEYWORD, 0);
					pColorString += ColorStrCpy(pColorString, " PTR ", COLOR_KEYWORD, 0);
				}

				if (pDasmInstr->SegmentPrefix != -1)
				{
					pColorString += ColorStrCpy(pColorString, CInstrSym::m_SegStr[pDasmInstr->SegmentPrefix], COLOR_SEG_REG, 0);
					pColorString += ColorStrCpy(pColorString, ":", COLOR_OPTR, 0);
				}

				pColorString += ColorStrCpy(pColorString, "[", COLOR_OPTR, 0);
				if (pOp->addr.base != -1)
					pColorString += ColorStrCpy(pColorString, CInstrSym::m_RegStr[pOp->addr.address_size][pOp->addr.base], COLOR_REGISTER, 0);

				if (pOp->addr.index != -1)
				{
					if (pOp->addr.base != -1)
						pColorString += ColorStrCpy(pColorString, "+", COLOR_OPTR, 0);
					pColorString += ColorStrCpy(pColorString, CInstrSym::m_RegStr[pOp->addr.address_size][pOp->addr.index], COLOR_REGISTER, 0);
					if (pOp->addr.scale >= 1)
					{
						pColorString += ColorStrCpy(pColorString, "*", COLOR_OPTR, 0);
						pColorString += ColorStrCpy(pColorString, CInstrSym::m_ScaleStr[pOp->addr.scale], COLOR_OPTR, 0);
					}
				}

				if (pOp->addr.displacement || (pOp->addr.base == -1 && pOp->addr.index == -1))
				{
					if (pOp->addr.index != -1 || pOp->addr.base != -1)
					{
						//TODO
						const char *Symbol;
						if (GetSign(&pOp->addr))
						{
							pColorString += ColorStrCpy(pColorString, "+", COLOR_OPTR, 0);
							if (/*pOp->addr.index == -1 &&*/ pOp->addr.address_size == CODE_MODE && /*pOp->addr.base == STACKREG &&*/
								(Symbol = m_CurrentFunction.GetSymbol(pOp->addr.displacement, pOp->addr.base/*STACKREG*/, 0)))
							{
								pColorString += ColorStrCpy(pColorString, Symbol, COLOR_SYMBOL, 0);
							} else
							{
								TSPrintf(szBuffer, CInstrSym::m_SizePtr[GetSize(pOp->addr.displacement)], pOp->addr.displacement);
								pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
							}
						} else
						{
							pColorString += ColorStrCpy(pColorString, "-", COLOR_OPTR, 0);
							if (/*pOp->addr.index == -1 &&*/ pOp->addr.address_size == CODE_MODE && /*pOp->addr.base == STACKREG &&*/
								(Symbol = m_CurrentFunction.GetSymbol(pOp->addr.displacement, pOp->addr.base/*STACKREG*/, 0)))
							{
								pColorString += ColorStrCpy(pColorString, Symbol, COLOR_SYMBOL, 0);
							} else
							{
								TSPrintf(szBuffer, CInstrSym::m_SizePtr[GetSize(pOp->addr.displacement)], -pOp->addr.displacement);
								pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
							}
						}
					} else
					{
						TSPrintf(szBuffer, CInstrSym::m_SizePtr[GetSize(pOp->addr.displacement)], pOp->addr.displacement);
						pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
					}
				}
				pColorString += ColorStrCpy(pColorString, "]", COLOR_OPTR, 0);
			} else
			{
				switch (pOp->mode)
				{
				case OP_Register:
					pColorString += ColorStrCpy(pColorString, pOp->string, COLOR_REGISTER, 0);
					break;
				case OP_Segment:
					pColorString += ColorStrCpy(pColorString, pOp->string, COLOR_SEG_REG, 0);
					break;
				case OP_Immed:
				case OP_Near:
					pColorString += ColorStrCpy(pColorString, pOp->string, COLOR_IMMED, 0);
					break;
				case OP_Far:
					TSPrintf(szBuffer, WSTR("%04X"), pOp->farptr.segment);
					pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
					pColorString += ColorStrCpy(pColorString, WSTR(":"), COLOR_OPTR, 0);
					TSPrintf(szBuffer, CInstrSym::m_ScaleStr[pOp->opersize+2], pOp->farptr.offset); //???
					pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
					break;
				case OP_Datadup:
					if (n == 0)
					for (n = 0; n < pOp->datadup.count; ++n)
					{
						if (n > 0)
							pColorString += ColorStrCpy(pColorString, ",", COLOR_OPTR, 0);
						TSPrintf(szBuffer, WSTR("%02X"), pOp->datadup.buffer[n]);
						pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
					}
					break;
				case OP_Symbol:
					if (pOp->symbol.boffset)
						pColorString += ColorStrCpy(pColorString, "OFFSET ", COLOR_KEYWORD, 0);
					pColorString += ColorStrCpy(pColorString, pOp->symbol.string, COLOR_SYMBOL, 0);
					break;
				case OP_Align:
					if (n == 0)
					{
						TSPrintf(szBuffer, WSTR("%X"), pOp->align.nBytes);
						pColorString += ColorStrCpy(pColorString, szBuffer, COLOR_IMMED, 0);
					}
					break;
				default: break;
				}
			}
		}
		return pColorString;
	}

	unsigned long *CSourceCodeWnd::InstrToCS(_INSTRUCTION_INFORMATION *pDasmInstr, unsigned long *pColorString)
	{
		bool bFirstLine = true;
		if (pDasmInstr->Lock != -1)
		{
			ColorStrCpy(pColorString, pDasmInstr->LockName, COLOR_PREFIX, 0);
			ColorStrCat(pColorString, " ", 0, 0);
			pColorString += TStrFillTail(pColorString, m_pSyserCodeDoc->m_UxAlign, (unsigned long)32);
			bFirstLine = false;
		}
		if (pDasmInstr->Repeat != -1)
		{
			ColorStrCpy(pColorString, pDasmInstr->RepeatName, COLOR_PREFIX, 0);
			ColorStrCat(pColorString, " ", 0, 0);
			if (bFirstLine)
			{
				pColorString += TStrFillTail(pColorString, m_pSyserCodeDoc->m_UxAlign, (unsigned long)32);
				pColorString += TStrLen(pColorString);
				bFirstLine = false;
			} else
			{
				pColorString += TStrLen(pColorString);
				pColorString += TStrLen(pColorString);
			}

		}
		ColorStrCpy(pColorString, pDasmInstr->Name, COLOR_OPCODE, 0);
		ColorStrCat(pColorString, " ", 0, 0);
		if (pDasmInstr->Name[0] && bFirstLine)
			pColorString += TStrFillTail(pColorString, m_pSyserCodeDoc->m_UxAlign, (unsigned long)32);
		else	pColorString += TStrLen(pColorString);
		return OptItemToCS(pDasmInstr->op, 3, pColorString, pDasmInstr);
	}

	unsigned long *CSourceCodeWnd::ColorDasm(ULONG_PTR ImageBase, ULONG_PTR Address, unsigned int MaxSize, unsigned long *pColorString, int nCodeAlign)
	{
		unsigned char CodeBuff[64];
		_INSTRUCTION_INFORMATION DasmInstr;
		DasmInstr.CodeBuff = CodeBuff;
		DasmInstr.eip = Address;
		DasmInstr.pasm = nullptr;

		if (Address < m_CurrentFunction.m_ImageBase || Address >= m_CurrentFunction.m_ImageHighBase)
		{
			m_CurrentFunction.Init(m_pSDSMod, m_pSDSMod->GetFunction(Address - ImageBase));
		}

		unsigned long CodeLen = m_pSyserCodeDoc->Dasm(&DasmInstr, 0, MaxSize);
		if (nCodeAlign)
		{
			if (DasmInstr.OpCode == -1)
			{
				ColorStrCpy(pColorString, WSTR("??"), COLOR_IMMED, 0);
			} else
			{
				WCHAR Buffer[64];
				THexBytesToStr(DasmInstr.CodeBuff, Buffer, CodeLen, 1, (WCHAR*)0);
				ColorStrCpy(pColorString, Buffer, COLOR_IMMED, 0);
			}
			pColorString += TStrFillTail(pColorString, nCodeAlign, (unsigned long)32);
		}
		InstrToCS(&DasmInstr, pColorString);
		return pColorString;
	}

	void CSourceCodeWnd::GetColorKeyword(char *String, unsigned long *pColorString, int *pLen)
	{
		if (gSyserConfig.iSourceCodeSyntaxColors == 0)
		{
			if (*pLen > 1)
			{
				ColorStrCpy(pColorString, "", 40, 0);// // 0x7B7B7B,   //Unknown
				*pLen -= 1;
			}

			if (*pLen > TStrLen(String))
			{
				ColorStrCat(pColorString, String, 27, 0);// // 0xFFFFFF,   //Keyword
				*pLen -= TStrLen(String);
			}
			return;
		}
		unsigned long nKeywords = 0;

		yy_set_input(String);

		if (*pLen > 1)
		{
			ColorStrCpy(pColorString, "", 40, 0);// // 0x7B7B7B,   //Unknown
			*pLen -= 1;
		}

		if (!m_bComment)
			yyrestart(0);

		unsigned long nLastPos = 0;
		for (int Lex = yylex(); Lex; Lex = yylex())
		{
			nLastPos += yyleng;
			if (m_bComment && Lex != 703) continue; //wait a end of cmt block
			++nKeywords;
			if (Lex >= 512 && Lex <= 631)
			{
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 27, 0);// // 0xFFFFFF,   //Keyword
					*pLen -= yyleng;//TStrLen(yytext);
				}
			} else
			if (Lex >= 632 && Lex <= 645)
			{
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 29, 0);// // 0x4080FF,   //Preprocessor Keyword
					*pLen -= yyleng;//TStrLen(yytext);
				}
			} else
			if (Lex >= 652 && Lex <= 700)
			{
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 34, 0);// // 0xFFFFFF,   //Operation
					*pLen -= yyleng;//TStrLen(yytext);
				}
			} else
	
			switch (Lex)
			{
			//case 512 ... 631:
			//	ColorStrCat(pColorString, yytext, 27, 0);// // 0xFFFFFF,   //Keyword
			//	break;
			//case 632 ... 645:
			//	ColorStrCat(pColorString, yytext, 29, 0);// // 0x4080FF,   //Preprocessor Keyword
			//	break;
                        case 646: // numbers??? 8
                        case 647: // numbers??? 4461
                        case 648: // hex??? 0xff
                        case 649: // float??? 0.0
                        case 650: // 'string' ???
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 33, 0);// // 0x00FF80,   //Numerical
					*pLen -= yyleng;//TStrLen(yytext);
				}
				break;
                        case 651: // "string"
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 32, 0);// // 0xFFFF00,   //String
					*pLen -= yyleng;//TStrLen(yytext);
				}
				break;
			//case 652 ... 700:
			//	ColorStrCat(pColorString, yytext, 34, 0);// // 0xFFFFFF,   //Operation
			//	break;
                        case 701: // ...
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 32, 0);// // 0xFFFF00,   //String
					*pLen -= yyleng;//TStrLen(yytext);
				}
				break;
			case 702: // /*
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 30, 0);// // 0x808080,   //Comment block
					*pLen -= yyleng;//TStrLen(yytext);
				}
				m_bComment = true;
				break;
			case 703: // */
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 30, 0);// // 0x808080,   //Comment block
					*pLen -= yyleng;//TStrLen(yytext);
				}
				m_bComment = false;
				break;
			case 704: // //
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 31, 0);// // 0x808080,   //Comment line
					*pLen -= yyleng;//TStrLen(yytext);
				}
				break;
			case 705: {
				BASICTYPE *type = m_pSDSMod->GetGlobal(yytext, true);
				if (type)
				{
					switch (type->Elem.Type)
					{
					case ELEM_STRUCT:
						if (*pLen > yyleng)//TStrLen(yytext))
						{
							ColorStrCat(pColorString, yytext, 36, 0);// // 0xE17D7D,   //Struct name
							*pLen -= yyleng;//TStrLen(yytext);
						}
						break;
					case ELEM_CLASS:
						if (*pLen > yyleng)//TStrLen(yytext))
						{
							ColorStrCat(pColorString, yytext, 35, 0);// // 0xE17D7D,   //Class name
							*pLen -= yyleng;//TStrLen(yytext);
						}
						break;
					case ELEM_UNION:
						if (*pLen > yyleng)//TStrLen(yytext))
						{
							ColorStrCat(pColorString, yytext, 37, 0);// // 0xE17D7D,   //Union name
							*pLen -= yyleng;//TStrLen(yytext);
						}
						break;
					case ELEM_TYPEDEF:
						if (*pLen > yyleng)//TStrLen(yytext))
						{
							ColorStrCat(pColorString, yytext, 38, 0);// // 0xE17D7D,   //Typedef name
							*pLen -= yyleng;//TStrLen(yytext);
						}
						break;
					default:
						if (*pLen > yyleng)//TStrLen(yytext))
						{
							ColorStrCat(pColorString, yytext, 28, 0);// // 0xC0C0C0,   //Identifier
							*pLen -= yyleng;//TStrLen(yytext);
						}
						break;
					}
				} else
			#if 1 //TODO improve O(1)
				if (m_pSDSMod->GetFunction(yytext, true))
				{
					if (*pLen > yyleng)//TStrLen(yytext))
					{
						ColorStrCat(pColorString, yytext, 39, 0);// // 0xFF8000,   //Function name
						*pLen -= yyleng;//TStrLen(yytext);
					}
				} else
			#endif
				{
					if (*pLen > yyleng)//TStrLen(yytext))
					{
						ColorStrCat(pColorString, yytext, 28, 0);// // 0xC0C0C0,   //Identifier
						*pLen -= yyleng;//TStrLen(yytext);
					}
				}
				break; }
			default:
				if (*pLen > yyleng)//TStrLen(yytext))
				{
					ColorStrCat(pColorString, yytext, 40, 0);// // 0x7B7B7B,   //Unknown
					*pLen -= yyleng;//TStrLen(yytext);
				}
				break;
			}
		}

		if (m_bComment)
		{
			if (nKeywords == 0)
			{
				if (*pLen > yyleng)//TStrLen(String))
				{
					ColorStrCpy(pColorString, String, 30, 0);// // 0x808080,   //Comment block
					*pLen -= yyleng;//TStrLen(String);
				}
			} else
			{
				int len = nLastPos;//String-teststr;
				if (*pLen > len)//yyleng)//TStrLen(String))
				{
					ColorStrCat(pColorString, String+len, 30, 0);// // 0x808080,   //Comment block
					*pLen -= len;//yyleng;//TStrLen(String);
				}
			}
		}
	}
//#define TXTDEBUG
#ifdef TXTDEBUG
FILE *f = NULL;
#endif
	void CSourceCodeWnd::OpenSrcFile(const char *Text, unsigned int Size, SrcFileNameID *SrcFile)
	{
		if (m_FileOpen) return;

		m_pSyserCodeDoc = &gpSyser->m_SyserUI.m_SyserCodeDoc;

		CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp, m_pSDSMod->GetFILESIG().CheckSum);
		if (!pDbgMod)
		{
			if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger)
					pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp, m_pSDSMod->GetFILESIG().CheckSum);
		}
		ULONG_PTR ImageBase = pDbgMod ? pDbgMod->m_ImageBase : 0;
		m_CurrentFileID = SrcFile->FileID;
		m_FileOpen = true;
		if (Text)
		{
			m_SrcTxtFile.Create(Size, (unsigned char*)Text, false);
			m_SrcTxtFile.OpenEx(0, 0, 3);
		} else
		{
			m_SrcTxtFile.OpenEx(SrcFile->FileName, 0, 3);
		}
		m_TxtFileLineNumber = m_SrcTxtFile.m_StrList.Size();

		int ColorStringLen = 256;
		unsigned long ColorString[256];
		unsigned long MaxSize = 1000;
		WCHAR *TextBufferW = new WCHAR[MaxSize];

#ifdef TXTDEBUG
	f = fopen("LOGSRC", "w");
//fprintf(f,"StringsLen %d\n", SDSFile->StringsLen);
//fflush(f);
#endif

		m_pSDSMod->GetFilesLN(m_CurrentFileID, &m_FileLNMap);
#if 0
	gpSyser->m_MainFrame.CreateProgress(WSTR(""), m_SrcTxtFile.m_StrList.Size());
	unsigned long Progress = m_SrcTxtFile.m_StrList.Size()/100;
#endif
		unsigned long nLineNum = 1;
		TListIter<char*> It = m_SrcTxtFile.m_StrList.Begin();
		while (It != m_SrcTxtFile.m_StrList.End())
		{
#ifdef TXTDEBUG
fprintf(f,"nLineNum %d, %s\n", nLineNum, *It);
fflush(f);
#endif
			ColorStringLen = 256;
			GetColorKeyword(*It, ColorString, &ColorStringLen);
			unsigned int NewSize = TStrLen(*It)+1;
			if (NewSize > MaxSize)
			{
				delete []TextBufferW;
				MaxSize = NewSize;
				TextBufferW = new WCHAR[NewSize];
			}
			unsigned long ulen = AnsiToUnicode(*It, TextBufferW, NewSize); //long

			for (unsigned long n = 0; n < ulen; ++n)
			{
				ColorString[n] = (ColorString[n] & 0xFFFF0000) | TextBufferW[n];
				if (!TextBufferW[n])
					ColorString[n] = 0;
			}

			WCHAR NumStr[20];
			uNumToStr(nLineNum, NumStr, 10);
			if (gSyserConfig.iSourceCodeShowLineNumbers == 0)
			{
				NumStr[0] = L' ';
				NumStr[1] = 0;
			}
			CListStringItem *Item = InsertItem(NumStr, 0, 0, 0, -1);
			SetItemValue(Item, 0, 0);
			SetItemTextColor(Item, 1, ColorString);
			SetItemValue(Item, 1, nLineNum);
			if (ImageBase)
			{
				map<unsigned long, MAPFilesLN>::IT it = m_FileLNMap.find(nLineNum);
				if (it != m_FileLNMap.end())
				{
					if (it->second.fileln->statement & 1)
					{
						unsigned long rva = it->second.fileln->address;
						ULONG_PTR Addr = ImageBase+rva;
						unsigned long length = it->second.fileln->length;
#ifdef TXTDEBUG
fprintf(f,"statement addr %08x rva %08x length %d\n", Addr, rva, length);
fflush(f);
#endif
						while(length>0)
						{
							char szString[256];
						#ifdef _X64_
							TSPrintf(szString, "%016I64x ", Addr); //14
						#else
							TSPrintf(szString, "%08x      ", Addr); //14
						#endif
							unsigned long CodeLen = m_pSyserCodeDoc->InstrLen(Addr, 16);
							if (!CodeLen) CodeLen = 1;
							unsigned char CodeBuf[52];
							m_pSyserCodeDoc->ReadMemory(Addr, CodeBuf, CodeLen);
							ColorStrCpy(ColorString, szString, 2, 1);
						#ifdef _X64_
							ColorDasm(ImageBase, Addr, 16, &ColorString[17], 0); //
						#else
							ColorDasm(ImageBase, Addr, 16, &ColorString[14], 0); //
						#endif
#ifdef TXTDEBUG
char szColorString[1024];
memset(szColorString, 0, sizeof(szColorString));
for (unsigned long n = 0; ColorString[n]; n++)
	szColorString[n] = ColorString[n]&0xff;
fprintf(f,"dasm %s\n", szColorString);
fflush(f);
#endif
							CListStringItem *DasmItem = InsertItem(WSTR(""), Item, 0, 0, -1);
							SetItemValue(DasmItem, 0, 0);
							SetItemTextColor(DasmItem, 1, ColorString);
							SetItemValue(DasmItem, 1, rva);
							if (CodeLen == 1 && CodeBuf[0] == 0xC3) break;
							if (CodeLen > length)
							{
								break; //???
							}
							length -= CodeLen;
							rva += CodeLen;
							Addr += CodeLen;
						}
					}
				}
			}
			++nLineNum;
#if 0
	if (Progress && !(nLineNum%Progress))
	gpSyser->m_MainFrame.UpdateProgress(nLineNum);
#endif
			++It;
		}
#if 0
	gpSyser->m_MainFrame.DestroyProgress();
#endif
#ifdef TXTDEBUG
fclose(f);
#endif
		if (ImageBase)
			m_CurAddr = ImageBase;
		m_SrcTxtFile.Close();
		delete []TextBufferW;
	}

	void CSourceCodeWnd::UpdateContextSrc()
	{
		if (!m_FileOpen)
			return;

		if (!m_pSDSMod)
			return;

		CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp, m_pSDSMod->GetFILESIG().CheckSum);
		if (!pDbgMod)
		{
			if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger)
					pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp, m_pSDSMod->GetFILESIG().CheckSum);
		}
		ULONG_PTR ImageBase = pDbgMod ? pDbgMod->m_ImageBase : 0;
		unsigned long nLineNum = 1;
		CListStringItem *Item = FindItem(0, 0);
		while (Item)
		{
			if (FindItem(Item, 0))
			{
				if (ImageBase && m_CurAddr == ImageBase)
					break;
				DeleteAllChildrenItems(Item);
			}
			if (ImageBase)
			{
				map<unsigned long, MAPFilesLN>::IT it = m_FileLNMap.find(nLineNum);
				if (it != m_FileLNMap.end())
				{
					unsigned long rva = it->second.fileln->address;
					ULONG_PTR Addr = ImageBase+rva;
					unsigned long length = it->second.fileln->length;
					while(length>0)
					{
						char szString[256];
					#ifdef _X64_
						TSPrintf(szString, "%016I64x ", Addr); //14
					#else
						TSPrintf(szString, "%08x      ", Addr); //14
					#endif
						unsigned long CodeLen = m_pSyserCodeDoc->InstrLen(Addr, 16);
						if (!CodeLen) CodeLen = 1;
						unsigned char CodeBuf[52];
						m_pSyserCodeDoc->ReadMemory(Addr, CodeBuf, CodeLen);
						unsigned long ColorString[256];
						ColorStrCpy(ColorString, szString, 2, 1);
					#ifdef _X64_
						ColorDasm(ImageBase, Addr, 16, &ColorString[17], 0); //
					#else
						ColorDasm(ImageBase, Addr, 16, &ColorString[14], 0); //
					#endif
						CListStringItem *DasmItem = InsertItem(WSTR(""), Item, 0, 0, -1);
						SetItemValue(DasmItem, 0, 0);
						SetItemTextColor(DasmItem, 1, ColorString);
						SetItemValue(DasmItem, 1, rva);
						if (CodeLen == 1 && CodeBuf[0] == 0xC3) break;
						if (CodeLen > length)
						{
							break; //???
						}

						length -= CodeLen;
						rva += CodeLen;
						Addr += CodeLen;
					}
				}
			}
			SetItemValue(Item, 0, 0);
			Item = GetNext(Item, 0);
			++nLineNum;
		}

		if (ImageBase)
		{
			if (m_CurAddr != ImageBase)
				m_CurAddr = ImageBase;
		}
	}

	bool CSourceCodeWnd::UpdateContextPics()
	{
		if (!m_FileOpen)
			return false;

		if (!m_pSDSMod)
			return false;

		CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp, m_pSDSMod->GetFILESIG().CheckSum);
		if (!pDbgMod)
		{
			if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger)
					pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(m_pSDSMod->GetFILESIG().TimeStamp, m_pSDSMod->GetFILESIG().CheckSum);
		}
		ULONG_PTR ImageBase = pDbgMod ? pDbgMod->m_ImageBase : 0;

		bool ret = false;
		unsigned long nLineNum = 1;
		CListStringItem *Item = FindItem(0, 0);
		while (Item)
		{
			unsigned long pic = 0;

			map<unsigned long, MAPFilesLN>::IT it = m_FileLNMap.find(nLineNum);
			if (it)
			{
				if (ImageBase)
				{
					bool open = false;
					CListStringItem *SubItem = GetItem(0, Item);
					while (SubItem)
					{
						
						unsigned long rva = GetItemValue(SubItem, 1);
						pic = m_pSyserCodeDoc->GetPic(ImageBase + rva);
						if (pic & 1)
							open = true;
						SetItemValue(SubItem, 0, (unsigned long long)pic);
						SubItem = GetNext(SubItem, 0);
					}
					pic = m_pSyserCodeDoc->GetPic(ImageBase + it->second.fileln->address);
					if (open)
					{
						pic |= 1;
						ret = true;
					}
				} else
				{
					pic = 0;
					if (m_pSDSMod->m_BreakPoints.Size())
					{
						TListIter<unsigned long> It = m_pSDSMod->m_BreakPoints.Find(it->second.fileln->address);
						if (It != m_pSDSMod->m_BreakPoints.End())
							pic = 2;
					}
				}
			}
			
			if (IsBM(nLineNum))
				pic |= 8;
			SetItemValue(Item, 0, (unsigned long long)pic);
			
			++nLineNum;
			Item = GetNext(Item, 0);
		}
		Update((WISP_RECT*)0);
		return ret;
	}

	bool CSourceCodeWnd::GetOutput(char *Str, CListStringItem *Item, TAnsiString & String)
	{
		char Buffer[512];
		int Len = 512;

		FilesLN *filesLN = nullptr;
		TList<FilesLN*> ListFilesLN;
		
		unsigned long LineNumber = GetItemValue(Item, 1);
		map<unsigned long, MAPFilesLN>::IT it = m_FileLNMap.find(LineNumber);
		if (it == m_FileLNMap.end())
			filesLN = m_pSDSMod->GetFilesLN(m_CurrentFileID, LineNumber);
		else	filesLN = it->second.fileln;

		if (!filesLN) return false;
		
		FUNCTION *func = m_pSDSMod->GetFunction(filesLN->address);
		if (!func) return false;

		if (m_CurrentFunction.m_pFunc != func)
			m_CurrentFunction.Init(m_pSDSMod, func);

		DATATYPE *data = m_CurrentFunction.GetLocal(Str, true);
		if (data)
		{
			String = m_pSDSMod->GetOutput(data->TypeID, Buffer, &Len);
			String += " ";
			if (data->ClassID)
			{
				BASICTYPE *type = m_pSDSMod->GetGlobal(data->ClassID);
				if (type && (type->Elem.Type == ELEM_STRUCT ||
					     type->Elem.Type == ELEM_CLASS ||
					     type->Elem.Type == ELEM_UNION))
				{
					String += m_pSDSMod->GetOutput(data->ClassID, Buffer, &Len);
					String += "::";
				}
			}
			String += data->name;
		} else
		{
			func = m_CurrentFunction.GetFunction(Str, 1);
			if (!func) return false;

			memset(Buffer, 0, 512);
			m_pSDSMod->GetOutputFunc(func, Buffer, &Len);
			String = Buffer;
		}
		return true;
	}

```

`source/WispSyser/sourcecodewnd.hpp`:

```hpp

#ifndef _SOURCECODEWND_HPP_
#define _SOURCECODEWND_HPP_

//#include "../Wisp/wispbase.hpp"
//#include "SyserRing3.hpp"
#include "syserui.hpp"
#include "../Code/alt/altmap.hpp"
#include "../Code/srctxtfile.hpp"
#include "../Wisp/wisplist.hpp"
#include "currentfunction.hpp"
#include "../EXEAnalyzer/sdsmodule.hpp"

struct CSourceCodeWnd : public CWispList
{
	unsigned long m_Color[41];
	CSrcTXTFile m_SrcTxtFile;
	bool m_FileOpen;
	unsigned long m_TxtFileLineNumber;
	map<unsigned long, MAPFilesLN> m_FileLNMap;
	CCurrentFunction m_CurrentFunction;
	bool m_bComment;
	//???
	CSyserCodeDoc *m_pSyserCodeDoc;
	CWispDIBList *m_pLineMarkDIBList;
	unsigned long m_CurrentFileID;
	CSDSModule *m_pSDSMod;
	CWispMenu m_PopupMenu;
	WISP_POINT m_LogicMousePosWnd;
	map<unsigned long,CListStringItem *> m_Bookmark;
	ULONG_PTR m_CurAddr;

	TAnsiString m_WatchVar;
	TAnsiString m_WatchVarComplex;

	CSourceCodeWnd();
	virtual ~CSourceCodeWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool IsAddWatch();
	void OnPopupMenu(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnUpdateClient(WISP_MSG *pMsg);

	bool OnEventExpansion(WISP_MSG *pMsg);
	bool OnEventCollapse(WISP_MSG *pMsg);
	bool OnEventGotoLine(WISP_MSG *pMsg);
	bool OnEventAddWatch(WISP_MSG *pMsg);
	bool OnEventToggleBM(WISP_MSG *pMsg);
	unsigned long GetAddr(CListStringItem *Item);
	bool OnEventInsDelBP(WISP_MSG *pMsg);
	bool OnEventEnDisBP(WISP_MSG *pMsg);
	bool OnEventGotoHere(WISP_MSG *pMsg);
	bool OnEventShowHere(WISP_MSG *pMsg);

	virtual void OnLButton(CListStringItem *Item, int nCol) override;
	virtual void OnRButton(CListStringItem *Item, int nCol) override;

	virtual bool GetTipText(CListStringItem *Item, int nCol, int *pPosX, int *pPosY, WCHAR *pOutText) override;

	virtual bool Edit(CListStringItem *Item, int nCol, TWideString& String) override;
	virtual bool OnEditing(CListStringItem *Item, int nCol, TWideString& String) override;

	void ClearBM();
	bool IsBM(unsigned long Address);
	void ToggleBM();
	void NextBM();
	void PrevBM();

	void ShowLineNum(unsigned long LineNumber);

	unsigned long *OptItemToCS(_OPERAND_ITEM *OpArray, int nOp, unsigned long *pColorString, _INSTRUCTION_INFORMATION *pDasmInstr);
	unsigned long *InstrToCS(_INSTRUCTION_INFORMATION *pDasmInstr, unsigned long *pColorString);
	unsigned long *ColorDasm(ULONG_PTR ImageBase, ULONG_PTR Address, unsigned int MaxSize, unsigned long *pColorString, int nCodeAlign);
	void GetColorKeyword(char *String, unsigned long *pColorString, int *pLen);
	void OpenSrcFile(const char *Text, unsigned int Size, SrcFileNameID *SrcFile);
	void UpdateContextSrc();
	bool UpdateContextPics();

	bool GetOutput(char *Str, CListStringItem *Item, TAnsiString & String);
};

#endif

```

`source/WispSyser/sourcedebugframewnd.cpp`:

```cpp

#include "sourcedebugframewnd.hpp"
#include "resource.hpp"
#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"

	CSourceDebugFrameWnd::CSourceDebugFrameWnd()
	{
	}
	CSourceDebugFrameWnd::~CSourceDebugFrameWnd()
	{
	}

	WISP_MSG_MAP_BEGIN(CSourceDebugFrameWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispSplitWnd)

	bool CSourceDebugFrameWnd::OnCreate(WISP_MSG *pMsg)
	{
		m_DIBList.Load("\\SyserIcon\\SourceCodeIcon.bmp", 16, 16, 80);

		m_MainMenu.LoadMenuGroup(this, WISP_ID_MAIN_MENU, SourceDebugMainMenu, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		m_MainMenu.SetOwner(this);

		m_Toolbar.CreateEx(this, m_MainMenu.m_WindowRect.cy, -1, WISP_ID_MAIN_TOOLBAR, 0);
		m_Toolbar.LoadToolbar(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF), SourceDebugToolbar);
		m_Toolbar.SetOwner(this);

		WISP_RECT Rect;
		Rect.x = 0;
		Rect.y = m_MainMenu.m_WindowRect.cy + m_Toolbar.m_WindowRect.cy;
		Rect.cx = m_ClientRect.cx;
		Rect.cy = m_ClientRect.cy - Rect.y;
		if (!m_MainSplitWnd.CreateWnd(0, Rect, this, CMD_ID_SOURCE_MAIN_SPLIT, 0x10000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_ViewSplitWnd.CreateWnd(0, Rect, &m_MainSplitWnd, CMD_ID_SOURCE_VIEW_PLIT, 0x20000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_SDSModuleListTabWnd.CreateWnd(0, Rect, &m_ViewSplitWnd, 0, 0x20000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_MultiSourceCodeView.CreateWnd(0, Rect, &m_ViewSplitWnd, CMD_ID_SOURCE, 0x200000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_SDSModuleList.CreateWnd(0, Rect, &m_SDSModuleListTabWnd, CMD_ID_SDS, 0x1030000, WISP_SH_MINSIZE))
			return false;

		m_SDSModuleListTabWnd.InsertWnd(WSTR("SDS Modules ALT+S"), &m_SDSModuleList, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xD5));

		m_ViewSplitWnd.InsertWnd(&m_MultiSourceCodeView, 0, (m_ClientRect.cx/3)*2, -1);
		m_ViewSplitWnd.InsertWnd(&m_SDSModuleListTabWnd, 0, (m_ClientRect.cx/3), -1);
		m_ViewSplitWnd.AdjustWndPos();

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_ContextTabWnd.CreateWnd(0, Rect, &m_MainSplitWnd, 0, 0x10000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_TypeViewerWnd.CreateWnd(0, Rect, &m_ContextTabWnd, CMD_ID_WATCH, 0x1030000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_TerminalWnd.CreateWnd(0, Rect, &m_ContextTabWnd, CMD_ID_TERMWND, 0, WISP_SH_MINSIZE))
			return false;

		m_TerminalWnd.AttachConsole(&gpSyser->m_MainFrame.m_ConsoleWnd);

		m_ContextTabWnd.InsertWnd(WSTR("Watch ALT+W"), &m_TypeViewerWnd, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x35));
		m_ContextTabWnd.InsertWnd(WSTR("Console F1"), &m_TerminalWnd, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x3F));

		m_MainSplitWnd.InsertWnd(&m_ViewSplitWnd, 0, m_ClientRect.cy - 200, -1);
		m_MainSplitWnd.InsertWnd(&m_ContextTabWnd, 0, 200, -1);
		m_MainSplitWnd.AdjustWndPos();

//		gpSyser->RegisterHotKeyEvent(EVENT_ID_GO, this);
//		gpSyser->RegisterHotKeyEvent(EVENT_ID_DBG_STEP, this);
//		gpSyser->RegisterHotKeyEvent(EVENT_ID_DBG_PROCEED, this);
//		gpSyser->RegisterHotKeyEvent(EVENT_ID_DBG_STEPB, this); //???
//		gpSyser->RegisterHotKeyEvent(EVENT_ID_DBG_RETURN, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_TOGGLE_BM, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_NEXT_BM, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_PREV_BM, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_CLEAR_BM, this);

		RegisterKeyEvent(EVENT_ID_SDS_FOCUS, 'S', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_WATCH_LIST, 'W', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_SRC_CONSOLE, 'p', 0, 1);
		RegisterKeyEvent(EVENT_ID_SOURCECODEWND_GOTOLINE, 'G', WISP_SK_CTRL, 1);
		RegisterKeyEvent(EVENT_ID_MENU_DEBUG, 'D', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_MONITOR, 'M', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_VIEW, 'V', WISP_SK_ALT, 1);
		return true;
	}

	bool CSourceDebugFrameWnd::OnDestroy(WISP_MSG *pMsg)
	{
		m_DIBList.Destroy();
		return true;
	}

	WISP_CMD_MAP_BEGIN(CSourceDebugFrameWnd)
//		WISP_CMD_MAP(..., ...)
	WISP_CMD_MAP_END

	WISP_EVENT_MAP_BEGIN(CSourceDebugFrameWnd)
		WISP_EVENT_MAP(EVENT_ID_DBG_STEP, OnEventDbgStep)
		WISP_EVENT_MAP(EVENT_ID_DBG_PROCEED, OnEventDbgProceed)

		WISP_EVENT_MAP(EVENT_ID_DBG_RETURN, OnEventDbgReturn)
		WISP_EVENT_MAP(EVENT_ID_GO, OnEventDbgContinue)
		WISP_EVENT_MAP(EVENT_ID_BREAK_POINT, OnEventBreakPointForm)
		WISP_EVENT_MAP(EVENT_ID_SDS_FOCUS, OnEventSDSModuleList)
		WISP_EVENT_MAP(EVENT_ID_WATCH_LIST, OnEventWatchView)
		WISP_EVENT_MAP(EVENT_ID_SRC_CONSOLE, OnEventTerminal)
		WISP_EVENT_MAP(EVENT_ID_CALLSTACK, OnEventCallStack)
		WISP_EVENT_MAP(EVENT_ID_REGVIEW, OnEventRegView)
		WISP_EVENT_MAP(EVENT_ID_DATAVIEW, OnEventDataViewForm)

		WISP_EVENT_MAP(EVENT_ID_TOGGLE_BM, OnEventToggleBM)
		WISP_EVENT_MAP(EVENT_ID_NEXT_BM, OnEventNextBM)
		WISP_EVENT_MAP(EVENT_ID_PREV_BM, OnEventPrevBM)
		WISP_EVENT_MAP(EVENT_ID_CLEAR_BM, OnEventClearBM)
		
		WISP_EVENT_MAP(EVENT_ID_MENU_DEBUG, OnEventMenuDebug)
		WISP_EVENT_MAP(EVENT_ID_MENU_MONITOR, OnEventMenuMonitor)
		WISP_EVENT_MAP(EVENT_ID_MENU_VIEW, OnEventMenuView)
		WISP_EVENT_MAP(EVENT_ID_SOURCECODEWND_GOTOLINE, OnEventGotoLine)
//		WISP_EVENT_MAP(..., ...)
	WISP_EVENT_MAP_END

	void CSourceDebugFrameWnd::AdjustSplit()
	{
		m_MainSplitWnd.SetSize(0, (m_ClientRect.cy*7) / 10);
		m_MainSplitWnd.AdjustWndPos();

		m_ViewSplitWnd.SetSize(0, (m_ClientRect.cx*7) / 10);
		m_ViewSplitWnd.AdjustWndPos();
	}

	bool CSourceDebugFrameWnd::OnSize(WISP_MSG *pMsg)
	{
		m_Toolbar.Resize(pMsg->Sizing.Size.cx, m_Toolbar.m_WindowRect.cy, true);
		m_MainSplitWnd.Resize(m_ClientRect.cx, m_ClientRect.cy - m_MainMenu.m_WindowRect.cy - m_Toolbar.m_WindowRect.cy, true);
		AdjustSplit();
		return true;
	}

	bool CSourceDebugFrameWnd::OnEventDbgStep(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("st"), 0);
		return false;
	}
	bool CSourceDebugFrameWnd::OnEventDbgProceed(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("sp"), 0);
		return false;
	}
	bool CSourceDebugFrameWnd::OnEventDbgReturn(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("p ret"), 0);
		return false;
	}
	bool CSourceDebugFrameWnd::OnEventDbgContinue(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("x"), 0);
		return false;
	}
	bool CSourceDebugFrameWnd::OnEventBreakPointForm(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_BreakPointForm.Create();
		return true;
	}
	bool CSourceDebugFrameWnd::OnEventSDSModuleList(WISP_MSG *pMsg)
	{
		m_SDSModuleList.Focus();
		return true;
	}
	bool CSourceDebugFrameWnd::OnEventWatchView(WISP_MSG *pMsg)
	{
		m_ContextTabWnd.SetActiveWnd(SRC_W_TAB); //SRC_W_TAB(0)
		m_TypeViewerWnd.Focus();
		return true;
	}
	bool CSourceDebugFrameWnd::OnEventTerminal(WISP_MSG *pMsg)
	{
		m_ContextTabWnd.SetActiveWnd(SRC_T_TAB); //SRC_T_TAB(1)
		m_TerminalWnd.Focus();
		return true;
	}

	bool CSourceDebugFrameWnd::OnEventCallStack(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_CallStackWnd.Create();
		return true;
	}

	bool CSourceDebugFrameWnd::OnEventRegView(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_SystemExplorer.OnEventRegView(pMsg);
		return true;
	}
	bool CSourceDebugFrameWnd::OnEventDataViewForm(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_SystemExplorer.OnEventDataViewForm(pMsg);
		return true;
	}

	bool CSourceDebugFrameWnd::OnEventToggleBM(WISP_MSG *pMsg)
	{
		CSourceCodeWnd *pWnd = (CSourceCodeWnd*)m_MultiSourceCodeView.GetActiveWnd();
		if (pWnd) pWnd->ToggleBM();
		return true;
	}

	bool CSourceDebugFrameWnd::OnEventNextBM(WISP_MSG *pMsg)
	{
		CSourceCodeWnd *pWnd = (CSourceCodeWnd*)m_MultiSourceCodeView.GetActiveWnd();
		if (pWnd) pWnd->NextBM();
		return true;
	}

	bool CSourceDebugFrameWnd::OnEventPrevBM(WISP_MSG *pMsg)
	{
		CSourceCodeWnd *pWnd = (CSourceCodeWnd*)m_MultiSourceCodeView.GetActiveWnd();
		if (pWnd) pWnd->PrevBM();
		return true;
	}

	bool CSourceDebugFrameWnd::OnEventClearBM(WISP_MSG *pMsg)
	{
		CSourceCodeWnd *pWnd = (CSourceCodeWnd*)m_MultiSourceCodeView.GetActiveWnd();
		if (pWnd) pWnd->ClearBM();
		return true;
	}

	bool CSourceDebugFrameWnd::OnEventMenuDebug(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("Debug"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSourceDebugFrameWnd::OnEventMenuMonitor(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("Monitor"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSourceDebugFrameWnd::OnEventMenuView(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("View"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSourceDebugFrameWnd::OnEventGotoLine(WISP_MSG *pMsg)
	{
		CSourceCodeWnd *pWnd = (CSourceCodeWnd*)m_MultiSourceCodeView.GetActiveWnd();
		if (pWnd) pWnd->OnEventGotoLine(pMsg);
		return true;
	}

	bool CSourceDebugFrameWnd::OnGetFocus(WISP_MSG *pMsg)
	{
		CWispBaseWnd *pWnd = m_MultiSourceCodeView.GetActiveWnd();
		if (pWnd)
		{
			pWnd->Focus();
			return false;
		}
		return true;
	}

	void CSourceDebugFrameWnd::UpdateMenu()
	{
		CSourceCodeWnd *pWnd = (CSourceCodeWnd *)m_MultiSourceCodeView.GetActiveWnd();

		m_Toolbar.Enable(EVENT_ID_SOURCECODEWND_GOTOLINE, pWnd != 0);
		m_MainMenu.Enable(EVENT_ID_SOURCECODEWND_GOTOLINE, pWnd != 0);

		m_Toolbar.Enable(EVENT_ID_TOGGLE_BM, pWnd != 0);
		m_MainMenu.Enable(EVENT_ID_TOGGLE_BM, pWnd != 0);

		m_Toolbar.Enable(EVENT_ID_NEXT_BM, pWnd && pWnd->m_Bookmark.size() > 0);
		m_MainMenu.Enable(EVENT_ID_NEXT_BM, pWnd && pWnd->m_Bookmark.size() > 0);

		m_Toolbar.Enable(EVENT_ID_PREV_BM, pWnd && pWnd->m_Bookmark.size() > 0);
		m_MainMenu.Enable(EVENT_ID_PREV_BM, pWnd && pWnd->m_Bookmark.size() > 0);

		m_Toolbar.Enable(EVENT_ID_CLEAR_BM, pWnd && pWnd->m_Bookmark.size() > 0);
		m_MainMenu.Enable(EVENT_ID_CLEAR_BM, pWnd && pWnd->m_Bookmark.size() > 0);

		m_Toolbar.Enable(EVENT_ID_DBG_STEP, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_DBG_STEP, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_DBG_PROCEED, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_DBG_PROCEED, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_DBG_RETURN, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_DBG_RETURN, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_GO, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_GO, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Update((WISP_RECT*)0);
	}

	void CSourceDebugFrameWnd::UpdateContext(bool bUpdateSrc)
	{
		if (bUpdateSrc)
		{
			CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP);
			if (pSDSMod)	
			{
				TList<FilesLN*> ListFilesLN;
				m_SDSModuleList.ExpandSDSModule(pSDSMod);
				if (pSDSMod->GetFilesLN(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP - pSDSMod->m_pDbgModule->m_ImageBase, &ListFilesLN))
				{
					FilesLN *fln = *ListFilesLN[0];
					OpenSrcView(pSDSMod, fln->FileID, fln->lineNumber);
				}
			}
		}
		m_MultiSourceCodeView.UpdateContext();
		m_TypeViewerWnd.UpdateContext();
	}

	CSourceCodeWnd *CSourceDebugFrameWnd::OpenSrcView(CSDSModule *pSDSMod, unsigned long FileID, unsigned long LineNumber)
	{
		SCWKEY Key;
		Key.FileID = FileID;
		Key.pSDSMod = pSDSMod;
		map<SCWKEY,CSourceCodeWnd *>::IT it = m_MultiSourceCodeView.m_SourceCodeWndMap.find(Key);
		if (it)
		{
			if (it->second)
				m_MultiSourceCodeView.ChangeActiveWnd(it->second);
			it->second->ShowLineNum(LineNumber);
			it->second->UpdateContextSrc();
		} else
		{
			SrcFileNameID *SrcFile = pSDSMod->GetSrcFileNameID(FileID);
			if (!SrcFile)	
				return nullptr;
			if (!SrcFile->FileSize)
				return nullptr;
			map<SCWKEY,CSourceCodeWnd *>::IT newit = m_MultiSourceCodeView.m_SourceCodeWndMap.insert(_Tmap_pair<SCWKEY,CSourceCodeWnd *>(Key,(CSourceCodeWnd *)0));
			if (!newit)
				return nullptr;
			newit->second = new CSourceCodeWnd;
			newit->second->m_pSDSMod = pSDSMod;
			newit->second->m_CurrentFileID = FileID;
			newit->second->CreateWnd(0, 0,0,0,0, &m_MultiSourceCodeView, FileID + 1, 0x41030000, WISP_SH_MINSIZE);
			newit->second->m_AdvStyle |= 1;
			WCHAR FileName[MAX_FN_LEN];
			TStrCpy(FileName, TGetFileName(SrcFile->FileName));
			m_MultiSourceCodeView.InsertWnd(FileName, newit->second, 0);
			newit->second->OpenSrcFile(SrcFile->Text, SrcFile->FileSize, SrcFile);
			m_MultiSourceCodeView.ChangeActiveWnd(newit->second);
			newit->second->ShowLineNum(LineNumber);
			it = newit;
		}

		if (it->second->UpdateContextPics())
		{
			if (gSyserConfig.iFollowMode == 0)
				gpSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(SRC_TAB); //SRC_TAB(2)
		}
		Update((WISP_RECT*)0);
		return it->second;
	}

	void CSourceDebugFrameWnd::RemoveSDSModule(CSDSModule *pSDSMod)
	{
		if (pSDSMod)
			m_TypeViewerWnd.RemoveSDSModule(pSDSMod);
	}

```

`source/WispSyser/sourcedebugframewnd.hpp`:

```hpp

#ifndef _SOURCEDEBUGFRAMEWND_HPP_
#define _SOURCEDEBUGFRAMEWND_HPP_

#include "../Wisp/wispwnd.hpp"
#include "../Wisp/wispstatic.hpp"
#include "../Wisp/wispmenu.hpp"
#include "../Wisp/wispedit.hpp"
#include "../Wisp/wisptoolbar.hpp"
#include "../Wisp/wisptabwnd.hpp"
#include "../Wisp/wispsplitwnd.hpp"
//#include "..\Wisp/wispconsolewnd.hpp"
#include "../Wisp/wispdib.hpp"

#include "sdsmodulelist.hpp"
#include "terminalwnd.hpp"
#include "multisourcecodeview.hpp"
#include "typeviewerwnd.hpp"
#include "../EXEAnalyzer/sdsmodule.hpp"
#include "sourcecodewnd.hpp"

#define SRC_W_TAB 0
#define SRC_T_TAB 1

struct CSourceDebugFrameWnd : public CWispSplitWnd
{
	CSDSModuleList m_SDSModuleList;
	CWispTabWnd m_SDSModuleListTabWnd;
	CWispTabWnd m_ContextTabWnd; //TAB
	CTerminalWnd m_TerminalWnd;
	CMultiSourceCodeView m_MultiSourceCodeView;
	CTypeViewerWnd m_TypeViewerWnd;
	CWispToolbar m_Toolbar;
	CWispMenu m_MainMenu;
	CWispSplitWnd m_ViewSplitWnd;
	CWispSplitWnd m_MainSplitWnd;
	CWispDIBList m_DIBList;

	CSourceDebugFrameWnd();
	virtual ~CSourceDebugFrameWnd();
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	void AdjustSplit();
	bool OnSize(WISP_MSG *pMsg);
	bool OnGetFocus(WISP_MSG *pMsg);

	bool OnEventDbgStep(WISP_MSG *pMsg);
	bool OnEventDbgProceed(WISP_MSG *pMsg);
	bool OnEventDbgReturn(WISP_MSG *pMsg);
	bool OnEventDbgContinue(WISP_MSG *pMsg);
	bool OnEventBreakPointForm(WISP_MSG *pMsg);
	bool OnEventSDSModuleList(WISP_MSG *pMsg);
	bool OnEventWatchView(WISP_MSG *pMsg);
	bool OnEventTerminal(WISP_MSG *pMsg);

	bool OnEventCallStack(WISP_MSG *pMsg);

	bool OnEventRegView(WISP_MSG *pMsg);
	bool OnEventDataViewForm(WISP_MSG *pMsg);

	bool OnEventToggleBM(WISP_MSG *pMsg);
	bool OnEventNextBM(WISP_MSG *pMsg);
	bool OnEventPrevBM(WISP_MSG *pMsg);
	bool OnEventClearBM(WISP_MSG *pMsg);

	bool OnEventMenuDebug(WISP_MSG *pMsg);
	bool OnEventMenuMonitor(WISP_MSG *pMsg);
	bool OnEventMenuView(WISP_MSG *pMsg);
	bool OnEventGotoLine(WISP_MSG *pMsg);

	void UpdateMenu();
	void UpdateContext(bool bUpdateSrc);

	CSourceCodeWnd *OpenSrcView(CSDSModule *pSDSMod, unsigned long FileID, unsigned long LineNumber);
	void RemoveSDSModule(CSDSModule *pSDSMod);
};

#endif
```

`source/WispSyser/sseregisterlist.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "sseregisterlist.hpp"
#include "syserconfig.hpp"

	WISP_MSG_MAP_BEGIN(CSSERegisterList)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
	WISP_MSG_MAP_END(CWispList)

	CSSERegisterList::CSSERegisterList()
	{
		memset(m_OldXMMRegister, 0, sizeof(m_OldXMMRegister));
	}
	CSSERegisterList::~CSSERegisterList()
	{
	}

	bool CSSERegisterList::OnUpdate(WISP_MSG *pMsg)
	{
		m_ColorChanges = gSyserColors.Color[4];
		m_ColorSame = gSyserColors.Color[1];
		m_ColorFocus = gSyserColors.Color[2];
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		UpdateItemColor(0);
		return true;
	}

	bool CSSERegisterList::OnCreate(WISP_MSG *pMsg)
	{
		m_ColorChanges = gSyserColors.Color[4];
		m_ColorSame = gSyserColors.Color[1];
		m_ColorFocus = gSyserColors.Color[2];
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		InsertColumn(WSTR("Register"), 60, 0, 0, -1);
		InsertColumn(WSTR("Value"), 240, 1, 0, -1);
		m_hSSE128RegItem[SSE_REG_0] = InsertItem(WSTR("XMM0"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_1] = InsertItem(WSTR("XMM1"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_2] = InsertItem(WSTR("XMM2"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_3] = InsertItem(WSTR("XMM3"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_4] = InsertItem(WSTR("XMM4"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_5] = InsertItem(WSTR("XMM5"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_6] = InsertItem(WSTR("XMM6"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_7] = InsertItem(WSTR("XMM7"), 0, 0, 0, -1);
	#ifdef _X64_
		m_hSSE128RegItem[SSE_REG_8] = InsertItem(WSTR("XMM8"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_9] = InsertItem(WSTR("XMM9"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_10] = InsertItem(WSTR("XMM10"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_11] = InsertItem(WSTR("XMM11"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_12] = InsertItem(WSTR("XMM12"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_13] = InsertItem(WSTR("XMM13"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_14] = InsertItem(WSTR("XMM14"), 0, 0, 0, -1);
		m_hSSE128RegItem[SSE_REG_15] = InsertItem(WSTR("XMM15"), 0, 0, 0, -1);
	#endif
		ResetContext();
		return true;
	}
	bool CSSERegisterList::OnGetFocus(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 0);
		if (Item) Select(Item);
		return true;
	}
	void CSSERegisterList::ResetContext()
	{
		Select(m_hSSE128RegItem[SSE_REG_0]);
		SetItemText(m_hSSE128RegItem[SSE_REG_0], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_1], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_2], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_3], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_4], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_5], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_6], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_7], 1, WSTR("????????"));
	#ifdef _X64_
		SetItemText(m_hSSE128RegItem[SSE_REG_8], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_9], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_10], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_11], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_12], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_13], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_14], 1, WSTR("????????"));
		SetItemText(m_hSSE128RegItem[SSE_REG_15], 1, WSTR("????????"));
	#endif
		memset(m_OldXMMRegister, 0, sizeof(m_OldXMMRegister));
	}

	void CSSERegisterList::UpdateContext()
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && IsWindow())
		{
			if (GetActiveCPU() == m_nCPU)
				memcpy(&m_CPUREGPTR, &gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR, sizeof(m_CPUREGPTR));
			else	gpSyser->m_pDebugger->GetX86RegPtr(&m_CPUREGPTR, m_nCPU);

			WCHAR Buffer[64];

			for (int n = 0; n < SSE_REG_COUNT; ++n)
			{
				unsigned long *pXMM = (unsigned long*)m_CPUREGPTR.GetXMM(n);
				TSPrintf(Buffer, WSTR("%08x %08x %08x %08x"), pXMM[3], pXMM[2], pXMM[1], pXMM[0]);
				SetItemText(m_hSSE128RegItem[n], 1, Buffer);

				bool Same = !memcmp(&m_OldXMMRegister[0][n], pXMM, 16);
				if (!Same) memcpy(&m_OldXMMRegister[0][n], pXMM, 16);
				
				SetItemColor(m_hSSE128RegItem[n], 1, Same ? m_ColorSame:m_ColorChanges);
			}
			Update(&m_ClientRect);
		}
	}

```

`source/WispSyser/sseregisterlist.hpp`:

```hpp

#ifndef _SSEREGISTERLIST_HPP_
#define _SSEREGISTERLIST_HPP_

#include "../Wisp/wisplist.hpp"
#include "../EXEAnalyzer/x86debugger.hpp"

enum SSE_REG_INDEX
{
  SSE_REG_0 = 0,
  SSE_REG_1,
  SSE_REG_2,
  SSE_REG_3,
  SSE_REG_4,
  SSE_REG_5,
  SSE_REG_6,
  SSE_REG_7,
#ifdef _X64_
  SSE_REG_8,
  SSE_REG_9,
  SSE_REG_10,
  SSE_REG_11,
  SSE_REG_12,
  SSE_REG_13,
  SSE_REG_14,
  SSE_REG_15,
#endif
  SSE_REG_COUNT,
};

struct CSSERegisterList : public CWispList
{
	CListStringItem *m_hSSE128RegItem[SSE_REG_COUNT];
	unsigned long m_OldXMMRegister[4][SSE_REG_COUNT];
	unsigned long m_ColorChanges;
	unsigned long m_ColorSame;
	int m_nCPU;
	X86_CPU_REG_PTR m_CPUREGPTR;

	CSSERegisterList();
	virtual ~CSSERegisterList();

	bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnGetFocus(WISP_MSG *pMsg);
	void ResetContext();
	void UpdateContext();
};

#endif
```

`source/WispSyser/stackwatchlist.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "stackwatchlist.hpp"
#include "syserconfig.hpp"
#include "resource.hpp"

	WISP_MSG_MAP_BEGIN(CStackWatchList)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_SCROLL_EVENT, OnScrollEvent)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	WISP_EVENT_MAP_BEGIN(CStackWatchList)
		WISP_EVENT_MAP(EVENT_ID_SHOW_CODE, OnEventShowCode)
		WISP_EVENT_MAP(EVENT_ID_SHOW_CODE_AT, OnEventGotoCode)
		WISP_EVENT_MAP(EVENT_ID_SHOW_CSP_ADDR, OnEventShowCSP)
		WISP_EVENT_MAP(EVENT_ID_SHOW_CBP_ADDR, OnEventShowCBP)
		WISP_EVENT_MAP(EVENT_ID_SHOW_DATA, OnEventShowData)
		WISP_EVENT_MAP(EVENT_ID_SHOW_DATA_AT, OnEventGotoData)
		WISP_EVENT_MAP(EVENT_ID_CV_ADDR_MODE, OnEventAddressMode)
		WISP_EVENT_MAP(EVENT_ID_CV_OFFSET_MODE, OnEventOffsetMode)
		WISP_EVENT_MAP(EVENT_ID_REL_CSP, OnEventRelCSP)
		WISP_EVENT_MAP(EVENT_ID_REL_CBP, OnEventRelCBP)
		WISP_EVENT_MAP(EVENT_ID_LOW_HIGH_ADDR, OnEventToggleOrder)
	WISP_EVENT_MAP_END

	WISP_CMD_MAP_BEGIN(CStackWatchList)
		WISP_CMD_MAP(WISP_ID_VSPIN_SCROLL, OnCmdVSpinScroll)
	WISP_CMD_MAP_END

WISP_MENU_GROUP_ITEM StackWatchListPopupMenu[] =
{
	{WSTR("Show Data "), EVENT_ID_SHOW_DATA, 0x7F, 0, 0},
	{WSTR("Show Code "), EVENT_ID_SHOW_CODE, 0x7E, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Show " CSPSTR " Address"), EVENT_ID_SHOW_CSP_ADDR, 0x77, 0, 0},
	{WSTR("Show " CBPSTR " Address"), EVENT_ID_SHOW_CBP_ADDR, 0x77, 0, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Address Mode"), EVENT_ID_CV_ADDR_MODE, 0, 2, 0},
	{WSTR("Offset  Mode"), EVENT_ID_CV_OFFSET_MODE, 0, 2, 0},
	{WSTR("Relative to " CSPSTR ""), EVENT_ID_REL_CSP, 0, 2, 0},
	{WSTR("Relative to " CBPSTR ""), EVENT_ID_REL_CBP, 0, 2, 0},
	{0, 0, 0, 4, 0},
	{WSTR("Low->High Address"), EVENT_ID_LOW_HIGH_ADDR, 0, 0, 0},
	{0},
};

enum
{
  SWL_ADDR = 0,
  SWL_VALUE = 1,
  SWL_CONTEXT = 2,
};


	CStackWatchList::CStackWatchList()
	{
		m_nScrollLine = 2;
		m_bOrder = true;
	}
	CStackWatchList::~CStackWatchList()
	{
	}

	bool CStackWatchList::OnUpdate(WISP_MSG *pMsg)
	{
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		UpdateItemColor(0);
		//TODO
		return true;
	}

	bool CStackWatchList::OnCreate(WISP_MSG *pMsg)
	{
		m_Style |= 0x2000000;
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		int Ext = m_ClientDC.GetTextExtent(WSTR("X"), -1, 0);
		InsertColumn(WSTR("Address"), (1+ADDR_SIZE) * Ext, 0, 0, -1);
		InsertColumn(WSTR("Value[F2]"), (2+ADDR_SIZE) * Ext, 1, 0, -1);
		InsertColumn(WSTR("Context"), 100, 0, 0, -1);
                m_CurAddr = 0;
		for (int i = 0; i < m_nVSBPage; ++i)
		{
			CListStringItem *Item = InsertItem(WSTR("" UNREADSTR ""), 0, 0, 0, -1);
			SetItemText(Item, SWL_VALUE, WSTR("" UNREADSTR ""));
		}
		
		m_pScrollBar[0]->Style = 0;
		m_pScrollBar[0]->bHide = 0;
		m_PopupMenu.LoadPopupMenuGroup(StackWatchListPopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		m_pMenuShowCode = m_PopupMenu.GetItem(EVENT_ID_SHOW_CODE);
		m_pMenuShowData = m_PopupMenu.GetItem(EVENT_ID_SHOW_DATA);
		m_pMenuOrder = m_PopupMenu.GetItem(EVENT_ID_LOW_HIGH_ADDR);
		LoadKeyMap();
		return true;
	}
	bool CStackWatchList::OnDestroy(WISP_MSG *pMsg)
	{
		m_PopupMenu.Destroy();
		return true;
	}
	bool CStackWatchList::OnSize(WISP_MSG *pMsg)
	{
		if (pMsg->Sizing.ScrSize.cy)
		{
			ResetContext();
			if (gpSyser->m_pDebugger && gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
				UpdateContext(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP, false);
		}
		return true;
	}
	bool CStackWatchList::OnScrollEvent(WISP_MSG *pMsg)
	{
		if (!gpSyser->m_pDebugger || !gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
			return false;

		if (pMsg->ScrollEvent.Type == WISP_SCROLL_BAR_VERT)
		{
			ULONG_PTR Addr;
			switch (pMsg->ScrollEvent.Event)
			{
			case WISP_SB_INC:
				Addr = m_bOrder?(m_CurAddr+sizeof(Addr)):(m_CurAddr-sizeof(Addr));
				UpdateContext(Addr, true);
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			case WISP_SB_DEC:
				Addr = m_bOrder?(m_CurAddr-sizeof(Addr)):(m_CurAddr+sizeof(Addr));
				UpdateContext(Addr, true);
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			case WISP_SB_PAGE_UP:
				Addr = m_bOrder?(m_CurAddr-m_pScrollBar[0]->Page*sizeof(Addr)):(m_CurAddr+m_pScrollBar[0]->Page*sizeof(Addr));
				UpdateContext(Addr, true);
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			case WISP_SB_PAGE_DOWN:
				Addr = m_bOrder?(m_CurAddr+m_pScrollBar[0]->Page*sizeof(Addr)):(m_CurAddr-m_pScrollBar[0]->Page*sizeof(Addr));
				UpdateContext(Addr, true);
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			case WISP_SB_POS_CHANGE:
				Addr = m_bOrder?(m_CurAddr+pMsg->ScrollEvent.Delta*sizeof(Addr)):(m_CurAddr-pMsg->ScrollEvent.Delta*sizeof(Addr));
				UpdateContext(Addr, true);
				break;
			default:
				SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 1);
				break;
			}
			return false;
		}
		return true;
	}
	void CStackWatchList::OnKeyRButton(WISP_MSG *pMsg)
	{
		WCHAR szMenu[128];
		WCHAR szHotKey[50];

		bool bReadOK = false;
	#if 0 //+++ UNUSE
		if (pMsg)
		{
			WISP_RECT Rect;
			CListStringItem *Item = GetItem(0, 0);
			GetItemRect(Item, SWL_ADDR, &Rect);
		}
	#endif
		CListStringItem *Item = GetNext(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, SWL_VALUE);
			unsigned char Mem;
			if (gpSyser->m_pDebugger->ReadMemory(Addr, &Mem, 1) == 1)
				bReadOK = true;
			CListStringItem::CONTENT *Content = GetItemContent(Item, SWL_VALUE);

			gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_SHOW_CODE_AT), szHotKey);
			TSPrintf(szMenu, WSTR("Show code at:%s  %s"), Content->String.operator const WCHAR*(), szHotKey);
			m_PopupMenu.SetItemText(m_pMenuShowCode, szMenu);

			gpSyser->m_MainFrame.m_KeyMappingPage.GetHotKey(GetKeyMap(EVENT_ID_SHOW_DATA_AT), szHotKey);
			TSPrintf(szMenu, WSTR("Show data at:%s  %s"), Content->String.operator const WCHAR*(), szHotKey);
			m_PopupMenu.SetItemText(m_pMenuShowData, szMenu);
		}
		m_PopupMenu.Enable(m_pMenuShowCode, bReadOK);
		m_PopupMenu.Enable(m_pMenuShowData, Item && bReadOK);
	
		m_PopupMenu.Checked(EVENT_ID_CV_ADDR_MODE, m_Mode == SWL_MODE_ADDR);
		m_PopupMenu.Checked(EVENT_ID_CV_OFFSET_MODE, m_Mode == SWL_MODE_REL);
		m_PopupMenu.Checked(EVENT_ID_REL_CSP, m_Mode == SWL_MODE_CSP);
		m_PopupMenu.Checked(EVENT_ID_REL_CBP, m_Mode == SWL_MODE_CBP);

		CWispDIB *pDIB;
		if (m_bOrder)
		{
			pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xAF);
			TStrCpy(szMenu, WSTR("High-->Low Address"));
		} else
		{
			pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xAE);
			TStrCpy(szMenu, WSTR("Low-->High Address"));
		}
		m_PopupMenu.SetItemText(m_pMenuOrder, szMenu);
		m_PopupMenu.SetDIB(m_pMenuOrder, pDIB);
		m_PopupMenu.Point(0, 1);
	}
	unsigned int CStackWatchList::GetKeyMap(unsigned int CmdID)
	{
		for (map<unsigned int, unsigned int>::IT it = m_KeyMap.begin();
			it != m_KeyMap.end(); ++it)
		{
			if (it->second == CmdID)
				return it->first;
		}
		return 0;
	}
	bool CStackWatchList::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen) return true;

		if (!pMsg->KeyEvent.bKeyDown) return true;

		map<unsigned int, unsigned int>::IT it = m_KeyMap.find(pMsg->KeyEvent.KeyType);
		if (it != m_KeyMap.end())
		{
			WISP_MSG Msg;
			Msg.Command.CmdID = it->second;
			return OnEvent(&Msg);
		}

		switch (pMsg->KeyEvent.KeyType)
		{
		case VK_RBUTTON:
			OnKeyRButton(pMsg); //Menu
			break;
		case 0x53: //S
		case 0x57: //W
			OnEventToggleOrder(0);
			break;
		case VK_F2:
			CListStringItem *Item = FullFindItem(0, 8);
			if (Item) EditItem(Item, SWL_VALUE);
			break;
		}
		return true;
	}

	bool CStackWatchList::OnEventShowCode(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, SWL_VALUE);
			ULONG_PTR Mem;
			if (gpSyser->m_pDebugger->ReadMemory(Addr, &Mem, sizeof(Mem)) == sizeof(Mem))
			{
				Addr = GetItemValue(Item, SWL_VALUE);
				gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(Addr, true);
			}
		}
		return true;
	}
	bool CStackWatchList::OnEventGotoCode(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, SWL_ADDR);
			ULONG_PTR Mem;
			if (gpSyser->m_pDebugger->ReadMemory(Addr, &Mem, sizeof(Mem)) == sizeof(Mem))
			{
				Addr = GetItemValue(Item, SWL_ADDR);
				gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(Addr, true);
			}
		}
		return true;
	}

	bool CStackWatchList::OnEventShowData(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, SWL_VALUE);
			ULONG_PTR Mem;
			if (gpSyser->m_pDebugger->ReadMemory(Addr, &Mem, sizeof(Mem)) == sizeof(Mem))
			{
				Addr = GetItemValue(Item, SWL_VALUE);
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
			}
		}
		return true;
	}
	bool CStackWatchList::OnEventGotoData(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (Item)
		{
			ULONG_PTR Addr = GetItemValue(Item, SWL_ADDR);
			ULONG_PTR Mem;
			if (gpSyser->m_pDebugger->ReadMemory(Addr, &Mem, sizeof(Mem)) == sizeof(Mem))
			{
				Addr = GetItemValue(Item, SWL_ADDR);
				gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Addr, 0);
			}
		}
		return true;
	}

	bool CStackWatchList::OnEventAddressMode(WISP_MSG *pMsg)
	{
		m_Mode = SWL_MODE_ADDR;
		UpdateContext(m_CurAddr, true);
		return true;
	}
	bool CStackWatchList::OnEventOffsetMode(WISP_MSG *pMsg)
	{
		CListStringItem *Item = FindItem(0, 8);
		if (Item)
		{
			m_RelCIP = GetItemValue(Item, SWL_ADDR);
			m_Mode = SWL_MODE_REL;
			UpdateContext(m_CurAddr, true);
		}
		return true;
	}
	bool CStackWatchList::OnEventRelCSP(WISP_MSG *pMsg)
	{
		m_Mode = SWL_MODE_CSP;
		UpdateContext(m_CurAddr, true);
		return true;
	}
	bool CStackWatchList::OnEventRelCBP(WISP_MSG *pMsg)
	{
		m_Mode = SWL_MODE_CBP;
		UpdateContext(m_CurAddr, true);
		return true;
	}
	bool CStackWatchList::OnEventToggleOrder(WISP_MSG *pMsg)
	{
		ULONG_PTR Addr = m_bOrder ? (m_CurAddr + sizeof(Addr) * m_nVSBPage) : (m_CurAddr - sizeof(Addr) * m_nVSBPage);
		m_bOrder = !m_bOrder;
		UpdateContext(Addr, true);
		return true;
	}
	bool CStackWatchList::OnEventShowCBP(WISP_MSG *pMsg)
	{
		UpdateContext(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP, 0);
		return true;
	}

	bool CStackWatchList::OnEventShowCSP(WISP_MSG *pMsg)
	{
		UpdateContext(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP, 0);
		return true;
	}

	bool CStackWatchList::OnCmdVSpinScroll(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002)
			SetScrollBarCurPos(0, m_nVSBPage * m_nScrollLine, 0); //m_nItemCount
		return true;
	}

	void CStackWatchList::OnLButton(CListStringItem *Item, int nCol)
	{
		if (nCol == SWL_ADDR)
		{
			switch (m_Mode)
			{
			case SWL_MODE_ADDR: OnEventOffsetMode(0); break;
			case SWL_MODE_REL: OnEventRelCSP(0); break;
			case SWL_MODE_CSP: OnEventRelCBP(0); break;
			case SWL_MODE_CBP: OnEventAddressMode(0); break;
			}
		}
	}

	bool CStackWatchList::Edit(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (gpSyser->m_pDebugger && gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		{
			if (nCol == SWL_VALUE)
			{
				CListStringItem::CONTENT *Content = GetItemContent(Item, SWL_VALUE);
				if (!TStrCmp(Content->String.operator const WCHAR*(), WSTR("" UNREADSTR "")))
					return false;
			}
			return true;
		}
		return false;
	}
	bool CStackWatchList::OnEditing(CListStringItem *Item, int nCol, TWideString& String)
	{
		ULONG_PTR Result;
		if (!gpSyser->m_SyserUI.CalcExp(String.operator const WCHAR*(), &Result))
			return false;
		if (nCol == SWL_ADDR)
			return false;
		if (nCol != SWL_VALUE)
			return false;

		CListStringItem::CONTENT *Content = GetItemContent(Item, SWL_VALUE);
		if (Content->String == String)
			return false;

		ULONG_PTR Addr = GetItemValue(Item, SWL_ADDR);
		ULONG_PTR Mem;
		if (gpSyser->m_pDebugger->WriteMemory(Addr, &Mem, sizeof(Mem)) != sizeof(Mem))
			return false;
		m_EditWnd.m_WndText.Format(WSTR("" F0ADDR "X"), Mem);
		
		unsigned long ColorString[256];
		unsigned char Type;
		DrawContext(Addr, Mem, ColorString, 256, &Type);
		SetItemTextColor(Item, SWL_CONTEXT, ColorString);
		return true;
	}

	void CStackWatchList::DrawContextSEH(ULONG_PTR Address, ULONG_PTR Value, unsigned long *pColorString, int MaxSize)
	{
#ifndef _X64_
		map<unsigned long, unsigned long>::IT it = m_SEHMap_1.find(Address);
		if (it == m_SEHMap_1.end())
		{
			if (m_SEHMap_2.find(Value) != m_SEHMap_2.end())
			{
				Address -= 4;
				if (m_SEHMap_1.find(Address) != m_SEHMap_1.end())
				{
					ColorStrCat(pColorString, "SEH Handler", 2, 0);
				}
			}
		} else
		if (it == m_SEHMap_1.rbegin()) //???
		{
			ColorStrCat(pColorString, "End of SEH chain", 2, 0);
		} else
		{
			ColorStrCat(pColorString, "Pointer to next SEH record", 2, 0);
		}
#endif
	}

	bool CStackWatchList::DrawContext(ULONG_PTR Address, ULONG_PTR Value, unsigned long *pColorString, int MaxSize, unsigned char *pType)
	{
		*pColorString = 0;
		WCHAR szString[256];
		szString[0] = 0;
		int Len = 0;
		if (Address == *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP)
			Len += ColorStrCpy(pColorString, "<-" CSPSTR " ", 1, 3); //??? Cat
		if (Address == *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP)
			Len += ColorStrCat(pColorString, "<-" CBPSTR " ", 1, 5);

		DrawContextSEH(Address, Value, pColorString, MaxSize);

		char Encode;
		if (gpSyser->m_SyserUI.ReadString(Value, szString, MaxSize - Len - 1, &Encode))
		{
			if (Encode == 0)
				ColorStrCat(pColorString, szString, 6, 0);
			else
			if (Encode == 1)
				ColorStrCat(pColorString, szString, 9, 0);
			if (pType) *pType = Encode;
			return true;
		}

		char Buffer[256];
		Buffer[0] = 0;

		char szSym[256];
		if (gpSyser->m_SyserUI.GetSymbolOffset(Value, szSym))
		{
			if (pType) *pType = 2;
			if (TStrChr(szSym, '+'))
			{
				unsigned long CodeLen = gpSyser->m_SyserUI.m_SyserCodeDoc.GetCall(Value, Buffer, 0);
				if (CodeLen)
				{
					ULONG_PTR FromAddr;
					if (gpSyser->m_SyserUI.m_SyserCodeDoc.GetReturn(Value - CodeLen, &FromAddr))
						TSPrintf(Buffer, "Return to " F0ADDR "X from " F0ADDR "X ", Value, FromAddr);
					else	TSPrintf(Buffer, "Return to " F0ADDR "X ", Value);
				} else
				{
					Buffer[0] = 0;
				}
			}
			ColorStrCat(pColorString, Buffer, 2, 0);
			ColorStrCat(pColorString, szSym, 1, 0);
		} else
		{
			szSym[0] = 0;
			unsigned long CodeLen = gpSyser->m_SyserUI.m_SyserCodeDoc.GetCall(Value, Buffer, 0);
			if (CodeLen == 0) return false;

			ULONG_PTR FromAddr;
			if (gpSyser->m_SyserUI.m_SyserCodeDoc.GetReturn(Value - CodeLen, &FromAddr))
				TSPrintf(Buffer, "Return to " F0ADDR "X from " F0ADDR "X ", Value, FromAddr);
			else	TSPrintf(Buffer, "(return to " F0ADDR "X)", Value);
			ColorStrCat(pColorString, Buffer, 2, 0);
			if (pType) *pType = 3;
		}
		return true;
	}
	void CStackWatchList::GetAddress(ULONG_PTR Address, WCHAR *pString)
	{
		WCHAR Buffer[32];
		LONG_PTR Offset = 0;
		if (m_Mode == SWL_MODE_ADDR)
		{
			TSPrintf(pString, WSTR("" F0ADDR "X"), Address);
			return;
		} else
		if (m_Mode == SWL_MODE_REL)
		{
			Offset = Address - m_RelCIP;
			TStrCpy(Buffer, "$");
		} else
		if (m_Mode == SWL_MODE_CSP)
		{
			Offset = Address - *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP;
			TStrCpy(Buffer, CSPSTR);
		} else
		if (m_Mode == SWL_MODE_CBP)
		{
			Offset = Address - *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP;
			TStrCpy(Buffer, CBPSTR);
		}
		if (Offset>0) TSPrintf(pString, WSTR("%s+%X"), Buffer, Offset);
		else
		if (Offset<0) TSPrintf(pString, WSTR("%s-%X"), Buffer, -Offset);
		else
		{
			TStrCpy(pString, Buffer);
			TStrCat(pString, "==>");
		}
	}
	void CStackWatchList::LoadKeyMap()
	{
		if (!gpSyser->GetHotKey(EVENT_ID_SHOW_CODE, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0xD,       EVENT_ID_SHOW_CODE)); //VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_SHOW_DATA_AT, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x4000000D,EVENT_ID_SHOW_DATA_AT)); //WISP_SK_CTRL VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_SHOW_DATA, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x1000000D,EVENT_ID_SHOW_DATA)); //WISP_SK_SHIFT VK_RETURN
		if (!gpSyser->GetHotKey(EVENT_ID_SHOW_CODE_AT, m_KeyMap)) m_KeyMap.insert(_Tmap_pair<unsigned int, unsigned int>(0x2000000D,EVENT_ID_SHOW_CODE_AT)); //WISP_SK_ALT VK_RETURN
	}
	void CStackWatchList::ResetContext()
	{
		Adjust(0, m_nVSBPage);
		ClearItem(0);
		CListStringItem *Item = GetItem(0, 0);
		if (Item) Select(Item);
		SetScrollBarInfo(0, m_nVSBPage * m_nScrollLine, m_nVSBPage * (2 * m_nScrollLine + 1), m_nVSBPage, 0, 1);
#ifndef _X64_
		m_SEHMap_1.clear();
		m_SEHMap_2.clear();
#endif
	}
	void CStackWatchList::UpdateContextSEH()
	{
#ifndef _X64_
		m_SEHMap_1.clear();
		m_SEHMap_2.clear();

		ULONG_PTR AddressTIB;
		unsigned long Limit;
		if (gpSyser->m_pDebugger->GetSegRegBase(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pFS, &AddressTIB, &Limit))
		{
			ULONG_PTR ExceptionList;
			if (gpSyser->m_SyserUI.m_SyserCodeDoc.ReadMemory(AddressTIB, &ExceptionList, 4) == 4)
			{
				for (int records = 0; records < 100; ++records)
				{
					unsigned long Mem[2];
					if (gpSyser->m_SyserUI.m_SyserCodeDoc.ReadMemory(ExceptionList, Mem, 8) != 8) break;

					m_SEHMap_1.insert(_Tmap_pair<unsigned long,unsigned long>(ExceptionList, Mem[1]));
					m_SEHMap_2.insert(_Tmap_pair<unsigned long,unsigned long>(Mem[1], ExceptionList));
					ExceptionList = Mem[0];
					if (ExceptionList == -1) break;
				}
			}
		}
#endif
	}
	void CStackWatchList::UpdateContext(ULONG_PTR Addr, bool bCurAddr)
	{
		UpdateContextSEH();
		if (bCurAddr)
		{
			m_CurAddr = Addr;
		} else
		{
			if (m_bOrder)
			{
				if (Addr < m_CurAddr + (m_nVSBPage*sizeof(Addr))/sizeof(Addr) ||
				    Addr >= m_CurAddr + (m_nVSBPage*3*sizeof(Addr))/sizeof(Addr))
					m_CurAddr = Addr - sizeof(Addr) * ((int)m_nVSBPage / 2);
			} else
			{
				if (Addr > m_CurAddr - (m_nVSBPage*sizeof(Addr))/sizeof(Addr) ||
				    Addr <= m_CurAddr - (m_nVSBPage*3*sizeof(Addr))/sizeof(Addr))
					m_CurAddr = Addr + sizeof(Addr) * ((int)m_nVSBPage / 2);
			}
			Addr = m_CurAddr;
		}

		unsigned long ColorString[256];
		WCHAR Buffer[256];

		CListStringItem *Item = GetNext(0, 0);
		while (Item)
		{
			GetAddress(Addr, Buffer);
			if (Addr == *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP)
			{
				ColorStrCpy(ColorString, Buffer, 1, 3);
				SetItemTextColor(Item, SWL_ADDR, ColorString);
			} else
			if (Addr == *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP)
			{
				ColorStrCpy(ColorString, Buffer, 1, 5);
				SetItemTextColor(Item, SWL_ADDR, ColorString);
			} else
			{
				SetItemText(Item, SWL_ADDR, Buffer);
			}

			ULONG_PTR Value;
			if (gpSyser->m_pDebugger->ReadMemory(Addr, &Value, sizeof(Value)) == sizeof(Value))
				TSPrintf(Buffer, WSTR("" F0ADDR "X"), Value);
			else	TStrCpy(Buffer, WSTR("" UNREADSTR ""));

			SetItemValue(Item, SWL_ADDR, Addr);
			SetItemText(Item, SWL_VALUE, Buffer);
			SetItemValue(Item, SWL_VALUE, Value);
			unsigned char Type;
			DrawContext(Addr, Value, ColorString, 256, &Type);
			SetItemTextColor(Item, SWL_CONTEXT, ColorString);
			if (m_bOrder)
				Addr += sizeof(Addr);
			else	Addr -= sizeof(Addr);
			Item = GetNext(Item, 0);
		}
		Update(&m_ClientRect);
	}

```

`source/WispSyser/stackwatchlist.hpp`:

```hpp

#ifndef _STACKWATCHLIST_HPP_
#define _STACKWATCHLIST_HPP_

#include "../Code/alt/altmap.hpp"
#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispmenu.hpp"

enum
{
  SWL_MODE_ADDR = 0,
  SWL_MODE_REL = 1,
  SWL_MODE_CSP = 2,
  SWL_MODE_CBP = 3,
};

struct CStackWatchList : public CWispList
{
	int m_nScrollLine;
	ULONG_PTR m_CurAddr;
	CWispMenu::MenuItem *m_pMenuShowCode;
	CWispMenu::MenuItem *m_pMenuShowData;
	CWispMenu::MenuItem *m_pMenuOrder;
	CWispMenu m_PopupMenu;
	int m_Mode;
	ULONG_PTR m_RelCIP;
	bool m_bOrder;
	map<unsigned int, unsigned int> m_KeyMap;
#ifndef _X64_
	map<unsigned long, unsigned long> m_SEHMap_1;
	map<unsigned long, unsigned long> m_SEHMap_2;
#endif

	CStackWatchList();
	virtual ~CStackWatchList();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnSize(WISP_MSG *pMsg);
	bool OnScrollEvent(WISP_MSG *pMsg);
	void OnKeyRButton(WISP_MSG *pMsg);
	unsigned int GetKeyMap(unsigned int CmdID);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	bool OnEventShowCode(WISP_MSG *pMsg);
	bool OnEventGotoCode(WISP_MSG *pMsg);
	bool OnEventShowData(WISP_MSG *pMsg);
	bool OnEventGotoData(WISP_MSG *pMsg);
	bool OnEventAddressMode(WISP_MSG *pMsg);
	bool OnEventOffsetMode(WISP_MSG *pMsg);
	bool OnEventRelCSP(WISP_MSG *pMsg);
	bool OnEventRelCBP(WISP_MSG *pMsg);
	bool OnEventToggleOrder(WISP_MSG *pMsg);
	bool OnEventShowCBP(WISP_MSG *pMsg);
	bool OnEventShowCSP(WISP_MSG *pMsg);

	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdVSpinScroll(WISP_MSG *pMsg);

	virtual void OnLButton(CListStringItem *Item, int nCol) override;

	virtual bool Edit(CListStringItem *Item, int nCol, TWideString& String) override;
	virtual bool OnEditing(CListStringItem *Item, int nCol, TWideString& String) override;

	void DrawContextSEH(ULONG_PTR Address, ULONG_PTR Value, unsigned long *pColorString, int MaxSize);
	bool DrawContext(ULONG_PTR Address, ULONG_PTR Value, unsigned long *pColorString, int MaxSize, unsigned char *pType);
	void GetAddress(ULONG_PTR Address, WCHAR *pString);
	void LoadKeyMap();
	void ResetContext();
	void UpdateContextSEH();
	void UpdateContext(ULONG_PTR Addr, bool bCurAddr);
};

#endif
```

`source/WispSyser/strinputwnd.cpp`:

```cpp

#include "strinputwnd.hpp"

	WISP_MSG_MAP_BEGIN(CStrInputWnd)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP_ON_COMMAND
	WISP_MSG_MAP_END(CWispForm)

	WISP_CMD_MAP_BEGIN(CStrInputWnd)
		WISP_CMD_MAP(WISP_ID_OK, OnCmdOK)
	WISP_CMD_MAP_END

WISP_FORM_RES_ITEM StrInput[] =
{
	{WISP_CTRL_FORM, {0, 0, 300, 100}, 0, 0xB, WSTR("Please Input ..."), 0, 0},
	{WISP_CTRL_STATIC_GROUP, {10, 10, 270, 50}, 2, 0, WSTR("Text"), 0, 0},
	{WISP_CTRL_EDIT, {20, 30, 200, 16}, 1, 0x1000006, 0, 0, 0},
	{WISP_CTRL_BUTTON, {230, 30, 40, 16}, WISP_ID_OK, 0, WSTR("OK"), 0, 0},
	{0}
};

	CStrInputWnd::CStrInputWnd()
	{
		m_szCaption = 0;
		m_szDefault = 0;
		m_Resource = StrInput;
	}

	CStrInputWnd::~CStrInputWnd()
	{
	}

	bool CStrInputWnd::OnCreateForm(WISP_MSG *pMsg)
	{
		if (m_szDefault)
		{
			CWispWnd *pWnd = (CWispWnd *)GetFormItem(2);
			pWnd->SetWindowText(m_szDefault);
		}
		if (m_szCaption)
			SetWindowText(m_szCaption);
		return true;
	}

	bool CStrInputWnd::OnCmdOK(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000002)
		{
			CWispWnd *pWnd = (CWispWnd *)GetFormItem(1);
			*m_pResult = pWnd->GetWindowText();
		}
		return true;
	}

	bool CStrInputWnd::Input(TWideString *Result, const WCHAR *szDefault, const WCHAR *szCaption)
	{
		CStrInputWnd InputWnd;
		InputWnd.m_pResult = Result;
		InputWnd.m_szDefault = szDefault;
		InputWnd.m_szCaption = szCaption;
		InputWnd.Create(0, 5);
		return InputWnd.m_Result == WISP_ID_OK;
	}


```

`source/WispSyser/strinputwnd.hpp`:

```hpp

#ifndef _STRINPUTWND_HPP_
#define _STRINPUTWND_HPP_

#include "../Wisp/wispform.hpp"

struct CStrInputWnd : public CWispForm
{
	TWideString *m_pResult;
	const WCHAR *m_szCaption;
	const WCHAR *m_szDefault;

	CStrInputWnd();
	virtual ~CStrInputWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreateForm(WISP_MSG *pMsg);
	bool OnCommand(WISP_MSG *pMsg);
	bool OnCmdOK(WISP_MSG *pMsg);
	
	static bool Input(TWideString *Result, const WCHAR *szDefault, const WCHAR *szCaption);
};

#endif
```

`source/WispSyser/sysercmd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "syserdefine.hpp"
#include "../Code/time.hpp"

int bc_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	if (argc < 2)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), *argv);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return -1;
	}

	if (argv[1][0] == '*')
	{
		gpSyser->m_pDebugger->DelAllCodeBP(0, 0x100);
		gpSyser->m_pDebugger->DelAllDataBP(0, 0x100);
		gpSyser->m_SyserUI.m_ModuleBPMap.clear();
		gpSyser->m_SyserUI.m_ModuleLoadBPMap.clear();
#if 1
		for (map<unsigned long, TList<CSyser::BPR>>::IT it = gpSyser->m_ProcsBPR.begin();
			it != gpSyser->m_ProcsBPR.end(); ++it)
		{
			it->second.Clear();
		}
		gpSyser->m_ProcsBPR.clear();
#endif
		gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		gpSyser->m_MainFrame.Update((WISP_RECT*)0);
		return 0;
	}

	ULONG_PTR Result;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Result))
	{
		char szBuffer[MAX_FN_LEN];
		UnicodeToAnsi(argv[1], szBuffer, MAX_FN_LEN);
		if (gpSyser->m_SyserUI.m_ModuleLoadBPMap.erase(szBuffer)>0)
		return 0;
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Input error!\n"));
		return 1;
	}

	if (Result > 0x1000)
	{
		int Count = 0;
		Count += gpSyser->m_SyserUI.RemoveBP(Result);
		Count += gpSyser->m_pDebugger->DelDataBP(Result, 0, 0x300);
		if (Count == 0)
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: breakpoint isn't exist !\n"));
			return 0;
		}
		gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		gpSyser->m_MainFrame.Update((WISP_RECT*)0);
		return 0;
	}
	int Index = 0;
{
	map<unsigned long long, BREAK_POINT>::IT it = gpSyser->m_pDebugger->m_pCodeBPMap->begin();
	//while (it != gpSyser->m_pDebugger->m_pCodeBPMap->end())
	while (it)
	{
		if (!(it->second.Type & 0x300) && !it->second.pModule)
		{
			if (Index == Result)
			{
				gpSyser->m_pDebugger->DelCodeBP(it->second);
				gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
				gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
				gpSyser->m_MainFrame.Update((WISP_RECT*)0);
				return 0;
			}
			++Index;
		}
		++it;
	}
}
{
	map<ULONG_PTR, BREAK_POINT::MODULE>::IT it = gpSyser->m_SyserUI.m_ModuleBPMap.begin();
	//while (it != gpSyser->m_SyserUI.m_ModuleBPMap.end())
	while (it)
	{
		if (Index == Result)
		{
			gpSyser->m_SyserUI.RemoveBP(it->first);
			gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
			gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
			gpSyser->m_MainFrame.Update((WISP_RECT*)0);
			return 0;
		}
		++Index;
		++it;
	}
}
{
	TListIter<BREAK_POINT> It = gpSyser->m_pDebugger->m_pDataBPList->Begin();
	while (It != gpSyser->m_pDebugger->m_pDataBPList->End())
	{
		if (!(It->Type & 0x300))
		{
			if (Index == Result)
			{
				gpSyser->m_pDebugger->DelDataBP(*It);
				gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
				gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
				gpSyser->m_MainFrame.Update((WISP_RECT*)0);
				return 0;
			}
			++Index;			
		}
		++It;
	}
}
{
	map<TAnsiNoCaseString,MODULE_LOAD>::IT it = gpSyser->m_SyserUI.m_ModuleLoadBPMap.begin();
	//while (it != gpSyser->m_SyserUI.m_ModuleLoadBPMap.end())
	while (it)
	{
		if (Index == Result)
		{
			gpSyser->m_SyserUI.m_ModuleLoadBPMap.erase(it);
			return 0;
		}
		++it;
	}
}
#if 0
{
	for (map<unsigned long,TList<CSyser::BPR>>::IT it = gpSyser->m_ProcsBPR.begin();
		it != gpSyser->m_ProcsBPR.end(); ++it)
	{
		if (gpSyser->m_SysInfo.GetProcess(it->first))
		{
			TListIter<CSyser::BPR> It = it->second.Begin();
			while (It != it->second.End())
			{
				if (Index == Result)
				{
					it->second.Remove(It);
					if (!it->second.Size())
						gpSyser->m_ProcsBPR.erase(it);
					return 0;
				}
				++It;
				++Index;
			}
		}
	}
}
#endif
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: breakpoint isn't exist !\n"));
	return 0;
}

void ShowCodeBP(int *Index, BREAK_POINT *BreakPoint, bool ALL)
{
	if (ALL || (!(BreakPoint->Type & 0x300) && !BreakPoint->pModule))
	{
		if (!*Index)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Index OwnerProcess   Type     Address    Name\n"));
		WCHAR Buffer[128];
		TStrCpy(Buffer, "Code");

		WCHAR Owner[128];
		AnsiToUnicode(BreakPoint->Owner.operator const char*(), Owner, lenof(Owner));
		WCHAR Name[128];
		AnsiToUnicode(BreakPoint->Name.operator const char*(), Name, lenof(Name));

		if (ALL)
		{
			typedef _Tmap_pair<unsigned long long, BREAK_POINT> PBP;
			PBP *p = CONTAINING_RECORD_MY1(BreakPoint, PBP, second);
			//unsigned int it; //BreakPoint-8 //TODO
			if (BreakPoint->State)
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-5X %<B>%-14s %<7>%-8s %<4>" F0ADDR "X   %<1>%s " F0ADDR "X\n"), *Index, Owner, Buffer, BreakPoint->Address, Name, p->first);
			else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<C>%-5X %-14s %-8s " F0ADDR "X   %s  " F0ADDR "X\n"), *Index, Owner, Buffer, BreakPoint->Address, Name, p->first);
		} else
		{
			if (BreakPoint->State)
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-5X %<B>%-14s %<7>%-8s %<4>" F0ADDR "X   %<1>%s\n"), *Index, Owner, Buffer, BreakPoint->Address, Name);
			else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<C>%-5X %-14s %-8s " F0ADDR "X   %s\n"), *Index, Owner, Buffer, BreakPoint->Address, Name);
		}
		++*Index;
	}
}

void ShowModuleBP(int *Index, BREAK_POINT::MODULE *BreakPoint, bool ALL)
{
	if (!*Index)
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Index OwnerProcess   Type     Address    Name\n"));
	WCHAR Buffer[MAX_FN_LEN];
	AnsiToUnicode(BreakPoint->Name.operator const char*(), Buffer, lenof(Buffer));
	typedef _Tmap_pair<ULONG_PTR, BREAK_POINT::MODULE> PBP;
	PBP *p = CONTAINING_RECORD_MY1(BreakPoint, PBP, second);
	//unsigned int it; //BreakPoint-4 //TODO
	if (BreakPoint->State)
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-5X %<B><All Process>  %<7>Code     %<4>" F0ADDR "X   %<1>%s\n"), *Index, p->first, Buffer);
	else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<C>%-5X <All Process>  Code     " F0ADDR "X   %s\n"), *Index, p->first, Buffer);
	++*Index;
}

void ShowDataBP(int *Index, BREAK_POINT *BreakPoint, bool ALL)
{
	if (ALL || !(BreakPoint->Type & 0x300))
	{
		if (!*Index)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Index OwnerProcess   Type     Address    Name\n"));
		WCHAR Buffer[128];
		TStrCpy(Buffer, "Data");
		TStrCat(Buffer, BreakPoint->TypeName.operator const char*());
		WCHAR Owner[128];
		AnsiToUnicode(BreakPoint->Owner.operator const char*(), Owner, lenof(Owner));
		WCHAR Name[128];
		AnsiToUnicode(BreakPoint->Name.operator const char*(), Name, lenof(Name));

		if (BreakPoint->State)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-5X %<B>%-14s %<7>%-8s %<4>" F0ADDR "X   %<1>%s\n"), *Index, Owner, Buffer, BreakPoint->Address, Name);
		else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<C>%-5X %-14s %-8s " F0ADDR "X   %s\n"), *Index, Owner, Buffer, BreakPoint->Address, Name);
		++*Index;
	}
}

void ShowModuleLoadBP(int *Index, MODULE_LOAD *BreakPoint, const char *Name, bool ALL)
{
	if (ALL || !(BreakPoint->Type & 0x300))
	{
		if (!*Index) 
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Index OwnerProcess   Type     Address    Name\n"));
		WCHAR Buffer[MAX_FN_LEN];
		AnsiToUnicode(Name, Buffer, lenof(Buffer));
		if (BreakPoint->State)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-5X %<B><All Process>  %<7>BPLoad   %<4>EntryPoint %<1>%s\n"), *Index, Buffer);
		else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<C>%-5X <All Process>  BPLoad   EntryPoint %s\n"), *Index, Buffer);
	}
}

void ShowProcBP(int *Index, CSyser::BPR *BreakPoint, const char *Name, bool ALL)
{
	if (!*Index)
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Index OwnerProcess   Type     Address    Name\n"));
	if (BreakPoint->State)
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-5X %<B>%-14s %<7>%-8s %<4>" F0ADDR "X-" F0ADDR "X\n"), *Index, Name, WSTR("BMR"), BreakPoint->Address, BreakPoint->Address + BreakPoint->Size);
	else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<C>-5X %<B>%-14s %-8s " F0ADDR "X-" F0ADDR "X\n"), *Index, Name, WSTR("BMR"), BreakPoint->Address, BreakPoint->Address + BreakPoint->Size);
}

int bl_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	bool ALL = argc > 1 && argv[1][0] == '*';
	int Count = 0;
{
	for (map<unsigned long long, BREAK_POINT>::IT it = gpSyser->m_pDebugger->m_pCodeBPMap->begin();
		it != gpSyser->m_pDebugger->m_pCodeBPMap->end(); ++it)
	{
		ShowCodeBP(&Count, &it->second, ALL);
	}
}
{
	map<ULONG_PTR, BREAK_POINT::MODULE>::IT it = gpSyser->m_SyserUI.m_ModuleBPMap.begin();
	//while (it != gpSyser->m_SyserUI.m_ModuleBPMap.end())
	while (it)
	{
		ShowModuleBP(&Count, &it->second, ALL);
		++it;
	}
}
{
	for (TListIter<BREAK_POINT> It = gpSyser->m_pDebugger->m_pDataBPList->Begin();
		It != gpSyser->m_pDebugger->m_pDataBPList->End(); ++It)
	{
		ShowDataBP(&Count, &*It, ALL);
	}
}
{
	for (map<TAnsiNoCaseString,MODULE_LOAD>::IT it = gpSyser->m_SyserUI.m_ModuleLoadBPMap.begin();
		it != gpSyser->m_SyserUI.m_ModuleLoadBPMap.end(); ++it)
	{
		ShowModuleLoadBP(&Count, &it->second, it->first.operator const char*(), ALL);
	}
}
#if 0
{
	for (map<unsigned long,TList<CSyser::BPR>>::IT it = gpSyser->m_ProcsBPR.begin();
		it != gpSyser->m_ProcsBPR.end(); ++it)
	{
		CDbgProcess *pDbgProc = gpSyser->m_SysInfo.GetProcess(it->first);
		if (pDbgProc)
		{
			for (TListIter<CSyser::BPR> It = It->second.Begin();
				It != It->second.End(); ++It)
			{
				ShowProcBP(&Count, &*It, pDbgProc->m_ProcessName.operator const char*(), ALL);
			}
		}
	}
}
#endif
	if (Count == 0)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Breakpoint doesn't exist!\n"));
	}
	return 0;
}

int bd_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	if (argc < 2)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), *argv);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return -1;
	}

	if (argv[1][0] == '*')
	{
		gpSyser->m_pDebugger->DisableAllCodeBP(0, 0x300);
		gpSyser->m_pDebugger->DisableAllDataBP(0, 0x300);
		gpSyser->m_SyserUI.EnableModuleOnloadBP(false);
		gpSyser->m_SyserUI.EnableAllModuleBP(false);

		gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		gpSyser->m_MainFrame.Update((WISP_RECT*)0);
		return 0;
	}

	ULONG_PTR Result;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Result))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Input error!\n"));
		return 1;
	}

	if (Result > 0x1000)
	{
		int Count = 0;
		Count += gpSyser->m_pDebugger->DisableCodeBP(Result, 0, 0x300);
		Count += gpSyser->m_pDebugger->DisableDataBP(Result, 0, 0x300);
		Count += gpSyser->m_SyserUI.EnableModuleBP(Result, false);
		if (Count == 0)
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: breakpoint isn't exist !\n"));
			return 0;
		}
		gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		gpSyser->m_MainFrame.Update((WISP_RECT*)0);
		return 0;
	}
	int Index = 0;
{
	map<unsigned long long, BREAK_POINT>::IT it = gpSyser->m_pDebugger->m_pCodeBPMap->begin();
	//while (it != gpSyser->m_pDebugger->m_pCodeBPMap->end())
	while (it)
	{
		if (!(it->second.Type & 0x300) && !it->second.pModule)
		{
			if (Index == Result)
			{
				gpSyser->m_pDebugger->DisableCodeBP(it->second);
				gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
				gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
				gpSyser->m_MainFrame.Update((WISP_RECT*)0);
				return 0;
			}
			++Index;
		}
		++it;
	}
}
{
	map<ULONG_PTR, BREAK_POINT::MODULE>::IT it = gpSyser->m_SyserUI.m_ModuleBPMap.begin();
	//while (it != gpSyser->m_SyserUI.m_ModuleBPMap.end())
	while (it)
	{
		if (Index == Result)
		{
			gpSyser->m_SyserUI.EnableModuleBP(it->first, false);
			gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
			gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
			gpSyser->m_MainFrame.Update((WISP_RECT*)0);
			return 0;
		}
		++Index;
		++it;
	}
}
{
	TListIter<BREAK_POINT> It = gpSyser->m_pDebugger->m_pDataBPList->Begin();
	while (It != gpSyser->m_pDebugger->m_pDataBPList->End())
	{
		if (!(It->Type & 0x300))
		{
			if (Index == Result)
			{
				gpSyser->m_pDebugger->DisableDataBP(*It);
				gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
				gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
				gpSyser->m_MainFrame.Update((WISP_RECT*)0);
				return 0;
			}
			++Index;			
		}
		++It;
	}
}
{
	map<TAnsiNoCaseString,MODULE_LOAD>::IT it = gpSyser->m_SyserUI.m_ModuleLoadBPMap.begin();
	//while (it != gpSyser->m_SyserUI.m_ModuleLoadBPMap.end())
	while (it)
	{
		if (!(it->second.Type & 0x300))
		{
			if (Index == Result)
			{
				it->second.State = 0; //??? BP_STATE_DISABLE
				return 0;
			}
			++Index;
		}
		++it;
	}
}
#if 0
{
	for (map<unsigned long,TList<CSyser::BPR>>::IT it = gpSyser->m_ProcsBPR.begin();
		it != gpSyser->m_ProcsBPR.end(); ++it)
	{
		if (gpSyser->m_SysInfo.GetProcess(it->first))
		{
			for (TListIter<CSyser::BPR> It = it->second.Begin();
				It != it->second.End(); ++It)
			{
				if (Index == Result)
				{
					it->second.State = 0; //??? BP_STATE_DISABLE
					return 0;
				}
				++Index;
			}
		}
	}
}
#endif
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: breakpoint isn't exist !\n"));
	return 0;
}

int be_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	if (argc < 2)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), *argv);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return -1;
	}

	if (argv[1][0] == '*')
	{
		gpSyser->m_pDebugger->EnableAllCodeBP(0, 0x300);
		gpSyser->m_pDebugger->EnableAllDataBP(0, 0x300);
		gpSyser->m_SyserUI.EnableModuleOnloadBP(true);
		gpSyser->m_SyserUI.EnableAllModuleBP(true);

		gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		gpSyser->m_MainFrame.Update((WISP_RECT*)0);
		return 0;
	}

	ULONG_PTR Result;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Result))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Input error!\n"));
		return 1;
	}

	if (Result > 0x1000)
	{
		int Count = 0;
		Count += gpSyser->m_pDebugger->EnableCodeBP(Result, 0, 0x300);
		Count += gpSyser->m_pDebugger->EnableDataBP(Result, 0, 0x300);
		Count += gpSyser->m_SyserUI.EnableModuleBP(Result, true);
		if (Count == 0)
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: breakpoint isn't exist !\n"));
			return 0;
		}
		gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		gpSyser->m_MainFrame.Update((WISP_RECT*)0);
		return 0;
	}
	int Index = 0;
{
	map<unsigned long long, BREAK_POINT>::IT it = gpSyser->m_pDebugger->m_pCodeBPMap->begin();
	//while (it != gpSyser->m_pDebugger->m_pCodeBPMap->end())
	while (it)
	{
		if (!(it->second.Type & 0x300) && !it->second.pModule)
		{
			if (Index == Result)
			{
				gpSyser->m_pDebugger->EnableCodeBP(it->second);
				gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
				gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
				gpSyser->m_MainFrame.Update((WISP_RECT*)0);
				return 0;
			}
			++Index;
		}
		++it;
	}
}
{
	map<ULONG_PTR, BREAK_POINT::MODULE>::IT it = gpSyser->m_SyserUI.m_ModuleBPMap.begin();
	//while (it != gpSyser->m_SyserUI.m_ModuleBPMap.end())
	while (it)
	{
		if (Index == Result)
		{
			gpSyser->m_SyserUI.EnableModuleBP(it->first, true);
			gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
			gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
			gpSyser->m_MainFrame.Update((WISP_RECT*)0);
			return 0;
		}
		++Index;
		++it;
	}
}
{
	TListIter<BREAK_POINT> It = gpSyser->m_pDebugger->m_pDataBPList->Begin();
	while (It != gpSyser->m_pDebugger->m_pDataBPList->End())
	{
		if (!(It->Type & 0x300))
		{
			if (Index == Result)
			{
				gpSyser->m_pDebugger->EnableDataBP(*It);
				gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
				gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
				gpSyser->m_MainFrame.Update((WISP_RECT*)0);
				return 0;
			}
			++Index;			
		}
		++It;
	}
}
{
	map<TAnsiNoCaseString,MODULE_LOAD>::IT it = gpSyser->m_SyserUI.m_ModuleLoadBPMap.begin();
	//while (it != gpSyser->m_SyserUI.m_ModuleLoadBPMap.end())
	while (it)
	{
		if (!(it->second.Type & 0x300))
		{
			if (Index == Result)
			{
				it->second.State = 1; //??? BP_STATE_ENABLE
				return 0;
			}
			++Index;
		}
		++it;
	}
}
#if 0
{
	for (map<unsigned long,TList<CSyser::BPR>>::IT it = gpSyser->m_ProcsBPR.begin();
		it != gpSyser->m_ProcsBPR.end(); ++it)
	{
		if (gpSyser->m_SysInfo.GetProcess(it->first))
		{
			for (TListIter<CSyser::BPR> It = it->second.Begin();
				It != it->second.End(); ++It)
			{
				if (Index == Result)
				{
					it->second.State = 1; //??? BP_STATE_ENABLE
					return 0;
				}
				++Index;
			}
		}
	}
}
#endif
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: breakpoint isn't exist !\n"));
	return 0;
}

int GetCondition(int argc, const WCHAR **argv, const WCHAR *szCmd, char *Condition, int MaxLen)
{
	int n = 2;
	while (n<argc)
	{
		if (!TStrICmp(argv[n++], "if"))
			break;
	}

	if (n<argc)
	{
		const WCHAR *Start = &szCmd[argv[n] - argv[0]];

		while (n<argc)
		{
			if (!TStrICmp(argv[n], "do"))
				break;
			++n;
		}

		if (n<argc)
		{
			const WCHAR *End = &szCmd[argv[n] - argv[0]];
			while (End[-1] == 0x20 && End>Start)
				--End;
			int Len = End - Start + 1;
			if (Len >= MaxLen)
				Len = MaxLen;
			MaxLen = Len;
		}
		return TStrCpyLimit(Condition, Start, MaxLen);
	}
	*Condition = 0;
	return 0;
}

int GetCommand(int argc, const WCHAR **argv, const WCHAR *szCmd, char *Command, int MaxLen)
{
	int n = 2;
	while (n<argc)
	{
		if (!TStrICmp(argv[n++], "do"))
			break;
	}
	if (n<argc)
	{
		const WCHAR *Start = &szCmd[argv[n] - argv[0]];
		return TStrCpyLimit(Command, Start, MaxLen);
	}
	*Command = 0;
	return 0;
}

int bpx_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	if (argc < 2)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), *argv);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return 1;
	}

	char Name[256];
	UnicodeToAnsi(argv[1], Name, lenof(Name));

	char Condition[256];
	if (GetCondition(argc, argv, szCmd, Condition, lenof(Condition))>0 &&
		!gpSyser->m_SyserUI.CalcExp(Condition, 0))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Invalid condition string !\n"));
		return -1;
	}

	char Command[256];
	GetCommand(argc, argv, szCmd, Command, lenof(Command));

	ULONG_PTR Result;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Result))
	{
//		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Counldn't find symbol %<F>%s%<1> in [%<B>%s%<1>] process space\n"), argv[1], gpSyser->m_pDebugger->m_ProcessName.operator const char*());
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Counldn't find symbol %<F>%s\n"), argv[1]);
		return -1; //FIX
	} else
	if (!gpSyser->m_SyserUI.InsertBP(Result, Name, Condition, Command))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Fail to set code breakpoint at " F0ADDR "X!\n"), Result);
		return -1; //FIX
	} else
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Set code break point at %<B>" F0ADDR "X%<1>!\n"), Result);
	}
	gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
	gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
	gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
	gpSyser->m_MainFrame.Update((WISP_RECT*)0);
	return 0;
}

int bpload_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc == 1)
	{
		for (map<TAnsiNoCaseString,MODULE_LOAD>::IT it = gpSyser->m_SyserUI.m_ModuleLoadBPMap.begin();
			it != gpSyser->m_SyserUI.m_ModuleLoadBPMap.end(); ++it)
		{
			WCHAR szModule[MAX_FN_LEN];
			AnsiToUnicode(it->first.operator const char*(), szModule, lenof(szModule));
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%s\n"), szModule);
		}
	} else
	if (argc == 2)
	{
		char szModule[MAX_FN_LEN];
		UnicodeToAnsi(argv[1], szModule, MAX_FN_LEN);
		gpSyser->m_SyserUI.InsertModuleOnloadBP(szModule, 0, 1); //Type, BP_STATE_ENABLE
	}
	return 0;
}

int bpm_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
//	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
//		return 1;

	if (argc < 2)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), *argv);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return 1;
	}

	int Size = 0;

	switch (argv[0][3])
	{
	case 'B':
	case 'b':
		Size = 1;
		break;
	case 'D':
	case 'd':
		Size = 4;
		break;
	case 'W':
	case 'w':
		Size = 2;
		break;
	default:
		Size = 0;
		break;
	}

	ULONG_PTR Result;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Result))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	int Type = 0xC;
	if (argc > 2)
	{
		if (!TStrICmp(argv[2], "if"));
		else
		if (!TStrICmp(argv[2], "do"));
		else
		if (!TStrICmp(argv[2], "rw"));
		else
		if (!TStrICmp(argv[2], "w"))
			Type = 4;
		else
		if (!TStrICmp(argv[2], "x"))
			Type = 2;
		else
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Invalid access type !\n"));
			return -1;
		}
	}

	char Condition[256];
	if (GetCondition(argc, argv, szCmd, Condition, lenof(Condition))>0 &&
		!gpSyser->m_SyserUI.CalcExp(Condition, 0))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Invalid condition string !\n"));
		return -1;
	}

	char Command[256];
	GetCommand(argc, argv, szCmd, Command, lenof(Command));

	BREAK_POINT *BreakPoint = gpSyser->m_pDebugger->SetDataBP(Result, Type, BP_STATE_ENABLE, Size);
	if (!BreakPoint)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Fail to set data breakpoint at " F0ADDR "X!\n"), Result);
		return -1; //FIX
	} else
	{
		if (Condition[0])
			BreakPoint->Condition = Condition;
		if (Command[0])
			BreakPoint->Command = Command;

		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Set data break point at %<B>" F0ADDR "X%<1>!\n"), Result);
	}

	gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
	gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
	gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
	gpSyser->m_MainFrame.Update((WISP_RECT*)0);
	return 0;
}

int bpio_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	if (argc < 2)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), *argv);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return 1;
	}

	ULONG_PTR Result;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Result) || Result > 0xFFFF)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	char Condition[256];
	if (GetCondition(argc, argv, szCmd, Condition, lenof(Condition))>0 &&
		!gpSyser->m_SyserUI.CalcExp(Condition, 0))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Invalid condition string !\n"));
		return -1;
	}

	char Command[256];
	GetCommand(argc, argv, szCmd, Command, lenof(Command));

	BREAK_POINT *BreakPoint = gpSyser->m_pDebugger->SetDataBP(Result, 0x30, BP_STATE_ENABLE, 0);
	if (!BreakPoint)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Fail to set IO breakpoint at " F0ADDR "X!\n"), Result);
		return -1; //FIX
	} else
	{
		if (Condition[0])
			BreakPoint->Condition = Condition;
		if (Command[0])
			BreakPoint->Command = Command;

		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Set IO break point at %<B>" F0ADDR "X%<1>!\n"), Result);
	}

	gpSyser->m_MainFrame.m_BreakPointForm.CreateShow();
	gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
	gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
	gpSyser->m_MainFrame.Update((WISP_RECT*)0);
	return 0;
}

int x_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (pSyser->m_pDebugger)
		pSyser->m_pDebugger->ContinueDebug(true);
	return 0;
}

int g_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc != 2)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), *argv);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return -1;
	}

	ULONG_PTR Address;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	if (!gpSyser->m_pDebugger->SetCodeBP(Address, 0x200, BP_STATE_ENABLE))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Fail to set breakpoint at " F0ADDR "X\n"), Address);
		return -1;
	}

	gpSyser->m_pDebugger->ContinueDebug(true);
	return 0;
}

bool IsCode(unsigned char *CodeBuf, ULONG_PTR CIP, ULONG_PTR *pLen)
{
#if 1
	char pasm[200];
	DIS_CPU DisCPU;
	_INSTRUCTION_INFORMATION DasmInstr;

	DasmInstr.pasm = pasm;
	DasmInstr.U_x1 = 6;
	DasmInstr.U_x2 = 12;

	unsigned long CodeLen = Disassembly(&DasmInstr, CodeBuf, CIP, gpSyser->m_pDebugger->m_CodeMode, &DisCPU);
	if (CodeLen)
	{
		if (DasmInstr.OpCode == C_PUSHF ||
		    DasmInstr.OpCode == C_POPF)
		{
			*pLen = CodeLen;
			return true;
		}

		if ((!TStrICmp(DasmInstr.Name, "mov") &&
			DasmInstr.op[0].mode == OP_Segment &&
			!TStrICmp(DasmInstr.op[0].string, "ss")) ||

		    (!TStrICmp(DasmInstr.Name, "pop") &&
			DasmInstr.op[0].mode == OP_Segment &&
			!TStrICmp(DasmInstr.op[0].string, "ss")))
		{
			if (gpSyser->m_pDebugger->ReadMemory(CodeLen + *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP, CodeBuf, 16) != 16)
				return false;

			memset(&DasmInstr, 0, sizeof(DasmInstr));
			unsigned long NextCodeLen = Disassembly(&DasmInstr, CodeBuf, CodeLen + CIP, gpSyser->m_pDebugger->m_CodeMode, &DisCPU);
			if (NextCodeLen)
			{
				if (DasmInstr.OpCode == C_PUSHF ||
				    DasmInstr.OpCode == C_POPF)
				{
					*pLen = CodeLen + NextCodeLen;
					return true;
				}
			}
		}
		return false;
	}
#endif
	if (CodeBuf[0] == 0x66)
	{
		if (CodeBuf[1] == 0x9C || CodeBuf[1] == 0x9D)
		{
			*pLen = 2;
			return true;
		}
	} else
	if (CodeBuf[0] == 0x9C || CodeBuf[0] == 0x9D)
	{
		*pLen = 1;
		return true;
	}
	return false;
}

int t_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	if (argc > 1)
	{
		unsigned long Step;
		if (USHexStrToNum(argv[1], &Step))
		{
			gpSyser->m_SyserUI.m_DebugInterface.Trace(Step);
		} else
		{
			ULONG_PTR Test;
			if (!gpSyser->m_SyserUI.CalcExp(&szCmd[argv[1] - argv[0]], &Test))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Input error!\n"));
				return -1;
			}
			char Condition[256];
			UnicodeToAnsi(&szCmd[argv[1] - argv[0]], Condition, 256);
			gpSyser->m_SyserUI.m_DebugInterface.Trace(Condition);
		}
	} else
	if (gpSyser->m_SyserUI.m_DebugInterface.m_State == 0) //CONTINUE
	{
		gpSyser->m_SyserUI.m_DebugInterface.Trace(1);
	}
	ULONG_PTR Addr = 0;
	unsigned char CodeBuf[MAX_INSTR_LEN];
	if (!gpSyser->m_pDebugger->ReadMemory(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP, CodeBuf, sizeof(CodeBuf)) ||
		!IsCode(CodeBuf, *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP, &Addr))
	{
		gpSyser->m_pDebugger->SetSingleStep();
		gpSyser->m_pDebugger->ContinueDebug(false);
		return 0;
	}

	Addr += *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP;
	if (!gpSyser->m_pDebugger->SetCodeBP(Addr, 0x200, BP_STATE_ENABLE))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Fail to set Debug BP at " F0ADDR "X\n"), Addr);
		return 0; //???
	}
	gpSyser->m_pDebugger->ContinueDebug(false);
	return 0;
}

int st_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP);
	if (!pSDSMod)
		return -1;
	//unsigned long
	ULONG_PTR Addr = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP - pSDSMod->m_pDbgModule->m_ImageBase;
	ULONG_PTR ImageBase = pSDSMod->m_pDbgModule->m_ImageBase;
	TList<FilesLN*> ListFilesLN;
	if (!pSDSMod->GetFilesLN(Addr, &ListFilesLN))
		return -1;
	FilesLN *pFilesLN = *ListFilesLN[0];
	CSourceCodeWnd *pSrcWnd = gpSyser->m_MainFrame.m_SourceDebugFrameWnd.OpenSrcView(pSDSMod, pFilesLN->FileID, pFilesLN->lineNumber);
	if (!pSrcWnd)
		return -1;

	CListStringItem *Item = pSrcWnd->GetItem(pFilesLN->lineNumber-1, 0);
	if (!Item)
		return -1;

	if (Item->uStatus & 1)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("T"), 0);
		return 0;
	}
	unsigned long EndAddr = pFilesLN->address + pFilesLN->length;
	gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("T"), 0);
	gpSyser->m_SyserUI.m_DebugInterface.Trace(ImageBase + pFilesLN->address, ImageBase + EndAddr, 0);
	return 0;
}

int tb_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	t_command(1,argv,szCmd,pSyser);
	return 0;
}

int p_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	bool bRestoreScr = false;
	if (argc > 1)
	{
		unsigned long Step;
		if (USHexStrToNum(argv[1], &Step))
		{
			gpSyser->m_SyserUI.m_DebugInterface.Step(Step);
			bRestoreScr = true;
		} else
		if (!TStrICmp(argv[1], "ret"))
		{
			gpSyser->m_SyserUI.m_DebugInterface.Return(gpSyser->m_pDebugger);
			bRestoreScr = true;
		} else
		{
			ULONG_PTR Test;
			if (!gpSyser->m_SyserUI.CalcExp(&szCmd[argv[1] - argv[0]], &Test))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Input error!\n"));
				return -1;
			}
			char Condition[256];
			UnicodeToAnsi(&szCmd[argv[1] - argv[0]], Condition, lenof(Condition));
			gpSyser->m_SyserUI.m_DebugInterface.Step(Condition);
		}
	} else
	if (gpSyser->m_SyserUI.m_DebugInterface.m_State == 0) //CONTINUE
	{
		gpSyser->m_SyserUI.m_DebugInterface.Trace(1);
	}

	if (gpSyser->m_SyserUI.m_SyserCodeDoc.IsProcessCode(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP))
	{
		ULONG_PTR Offset = gpSyser->m_SyserUI.m_SyserCodeDoc.InstrLen(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP, MAX_INSTR_LEN);
		Offset += *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP;
		gpSyser->m_pDebugger->SetCodeBP(Offset, 0x200, BP_STATE_ENABLE);
		gpSyser->m_pDebugger->ContinueDebug(bRestoreScr);
		return 0;
	}

	ULONG_PTR Addr = 0;
	unsigned char CodeBuf[MAX_INSTR_LEN];
	if (gpSyser->m_pDebugger->ReadMemory(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP, CodeBuf, sizeof(CodeBuf)) != sizeof(CodeBuf) ||
		!IsCode(CodeBuf, *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP, &Addr))
	{
		gpSyser->m_pDebugger->SetSingleStep();
		gpSyser->m_pDebugger->ContinueDebug(bRestoreScr);
		return 0;
	}

	Addr += *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP;
	if (!gpSyser->m_pDebugger->SetCodeBP(Addr, 0x200, BP_STATE_ENABLE))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Fail to set Debug BP at " F0ADDR "X\n"), Addr);
		return 0; //???
	}
	gpSyser->m_pDebugger->ContinueDebug(bRestoreScr);
	return 0;
}

int sp_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP);
	if (!pSDSMod)
		return -1;
	//unsigned long
	ULONG_PTR Addr = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP - pSDSMod->m_pDbgModule->m_ImageBase;
	ULONG_PTR ImageBase = pSDSMod->m_pDbgModule->m_ImageBase;
	TList<FilesLN*> ListFilesLN;
	if (!pSDSMod->GetFilesLN(Addr, &ListFilesLN))
		return -1;
	FilesLN *pFilesLN = *ListFilesLN[0];
	CSourceCodeWnd *pSrcWnd = gpSyser->m_MainFrame.m_SourceDebugFrameWnd.OpenSrcView(pSDSMod, pFilesLN->FileID, pFilesLN->lineNumber);
	if (!pSrcWnd)
		return -1;

	CListStringItem *Item = pSrcWnd->GetItem(pFilesLN->lineNumber-1, 0);
	if (!Item)
		return -1;

	if (Item->uStatus & 1)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("P"), 0);
		return 0;
	}
	unsigned long EndAddr = pFilesLN->address + pFilesLN->length;
	gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("P"), 0);
	gpSyser->m_SyserUI.m_DebugInterface.Step(ImageBase + pFilesLN->address, ImageBase + EndAddr, 0);
	return 0;
}

int skip_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;
	X86_CPU_REG_PTR CpuREGPtr;
	pSyser->m_pDebugger->GetX86RegPtr(&CpuREGPtr);
	*CpuREGPtr.pCIP += pSyser->m_SyserUI.m_SyserCodeDoc.InstrLen(*CpuREGPtr.pCIP, MAX_INSTR_LEN);
	pSyser->m_pDebugger->UpdateRegisters();
	gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
	return 0;
}

int stack_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;
#if 0
			gpSyser->m_pDebugger->SaveRegisters();
			for(ULONG nFrame = 0; nFrame < 256; nFrame++)
			{
				STACK_FRAME StackFrame;

				if (!gpSyser->m_pDebugger->GetStack(&StackFrame)) break;

		#if 1
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%2d from %016I64X   STACK %016I64X    FRAME %016I64X    RET %016I64X %s\n"),
					nFrame,
					StackFrame.AddrPC,//.Offset,
					StackFrame.AddrStack,//.Offset,
					StackFrame.AddrFrame,//.Offset,
					StackFrame.AddrReturn,//.Offset,
					WSTR(""));//name);
		#endif
				if (StackFrame.AddrPC == StackFrame.AddrReturn) break;
				if (StackFrame.AddrPC == 0) break;
				if (StackFrame.AddrReturn == 0) break;

				char szFuncName[64];
				ULONG_PTR Addr;
				if (gpSyser->m_SyserUI.m_SyserCodeDoc.GetCall(StackFrame.AddrReturn, szFuncName, &Addr))
				{
					if (!szFuncName[0])
					{
						CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Addr);
						if (!pDbgMod)
						{
							if (gpSyser->m_pSysDebugger != gpSyser->m_pDebugger)
								pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(Addr);
						}

						if (pDbgMod)
						{
							unsigned long Offset = Addr - pDbgMod->m_ImageBase;
							TSPrintf(szFuncName, "%s+0x%X", pDbgMod->m_FileTitle.operator const char*(), Offset);
						} else
						{
							TSPrintf(szFuncName, "unknown_function");
						}
					}
				#if 0
					TListIter<Frame> It = m_Frames.Append();
					It->Address = StackFrame.AddrFrame;//Address; //Frame
					It->Return = StackFrame.AddrReturn;
					It->FuncAddr = Addr;
					It->FuncName = szFuncName;
				#endif
				}
			}

	return 0;
#endif
	ULONG_PTR Addr;
	if (argc == 1)
	{
		Addr = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP;
	} else
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Addr))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
		return -1;
	}
	gpSyser->m_SyserUI.m_CallStack.UpdateContext(Addr);
	if (gpSyser->m_SyserUI.m_CallStack.m_Frames.Size())
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("CallReturn Frame    Function Name\n"));
	else	gpSyser->m_SyserUI.m_CallStack.UpdateContext(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP);

	if (gpSyser->m_SyserUI.m_CallStack.m_Frames.Size())
	{
		TListIter<CCallStack::Frame> It = gpSyser->m_SyserUI.m_CallStack.m_Frames.Begin();
		while (It != gpSyser->m_SyserUI.m_CallStack.m_Frames.End())
		{
			WCHAR szFunc[256];
			AnsiToUnicode(It->FuncName.operator const char*(), szFunc, lenof(szFunc));
			if (gpSyser->m_SyserUI.m_CallStack.m_HeadIt == It)
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<7>" F0ADDR "X   " F0ADDR "X %s\n"), It->Return, It->Address, szFunc);
			else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("" F0ADDR "X   " F0ADDR "X %s\n"), It->Return, It->Address, szFunc);
			++It;
		}
	} else
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("CallReturn Frame    Function Name  count=0\n"));
	}
	return 0;
}

int u_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;

	if (argc == 1)
	{
		ULONG_PTR Addr = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP;
		if (argv[0][0] != '.')
		{
			CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
			int n = pWnd->GetItemCount(0, true);
			CListStringItem *Item = pWnd->GetItem(n, 0);
			Addr = pWnd->GetItemValue(Item, 1);
		}
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.SetActiveAddress(Addr, true);
		return 0;
	} else
	if (argc == 2)
	{
		if (!TStrICmp(argv[1], WSTR("-")))
		{
			CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
			pWnd->OnEventPrevPos(0);
			return 0;
		}

		if (!TStrICmp(argv[1], WSTR("+")))
		{
			CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
			pWnd->OnEventNextPos(0);
			return 0;
		}
		ULONG_PTR Address;
		if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %<3>Input error !\n"));
			return 1;
		}
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.SetActiveAddress(Address, true);
		return 0;
	} else
	if (argc == 3)
	{
		if (!TStrICmp(argv[1], WSTR("-")))
		{
			ULONG_PTR Address;
			if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Address))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %<3>Input error !\n"));
				return 1;
			}
			if (!gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd())
				return 1;
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.SetActiveAddress(
			pSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveAddress()-Address, true);
			return 0;
		}

		if (!TStrICmp(argv[1], WSTR("+")))
		{
			ULONG_PTR Address;
			if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Address))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %<3>Input error !\n"));
				return 1;
			}
			if (!gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd())
				return 1;
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.SetActiveAddress(
			pSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveAddress()+Address, true);
			return 0;
		}

		if (!TStrICmp(argv[1], WSTR("-a")))
		{
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.InsertView(0);
			ULONG_PTR Address;
			if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Address))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %<3>Input error !\n"));
				return 1;
			}
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.SetActiveAddress(Address, true);
			return 0;
		}
	}
	return 1;
}

int src_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	ULONG_PTR Addr;
	if (argc == 1)
	{
		Addr = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP;
	} else
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Addr))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return 1;
	}
	CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(Addr);
	if (!pSDSMod)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Couldn't find source code in SDS Module list !\n"));
		return -1;
	}
	gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.ExpandSDSModule(pSDSMod);
	TList<FilesLN*> ListFilesLN;
	if (pSDSMod->GetFilesLN(Addr, &ListFilesLN))
	{
		gpSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(SRC_TAB); //SRC_TAB(2)
		FilesLN *pFilesLN = *ListFilesLN[0];
		CSourceCodeWnd *pSrcWnd = gpSyser->m_MainFrame.m_SourceDebugFrameWnd.OpenSrcView(pSDSMod, pFilesLN->FileID, pFilesLN->lineNumber);
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_MultiSourceCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_TypeViewerWnd.UpdateContext();
	}
	return 0;
}

int sym_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	int Count = 0;

	WCHAR Buffer[MAX_FN_LEN];
	char szMod[MAX_FN_LEN];

	WCHAR szStr[64];
	char szSym[64];

	if (argc == 4)
	{
		int ADDOK = 0;
		ULONG_PTR Result;
		if (!TStrICmp(argv[1], "-a") || !TStrICmp(argv[1], "/a"))
		{
			//char szSym[64];
			UnicodeToAnsi(argv[2], szSym, 64);

			if (!gpSyser->m_SyserUI.CalcExp(argv[3], &Result))
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %s input error!\n"), argv[3]);
			} else
			{
				CDbgModule *pDbgMod = pSyser->m_pDebugger->m_DbgModuleList.FindModule(Result);
				if (!pDbgMod)
					pDbgMod = pSyser->m_pSysDebugger->m_DbgModuleList.FindModule(Result);
				if (pDbgMod)
				{
					if (!pDbgMod->m_pSymbolModule)
					{
						CSymbolModule *pSymMod = gpSyser->m_SyserUI.m_SymbolContainer.InsertModule(pDbgMod->m_TimeStamp, pDbgMod->m_CheckSum);
						if (pSymMod)
							pSymMod->m_ModuleName = pDbgMod->m_pName;
						pDbgMod->SetSymbolModule(pSymMod);
					}
					ADDOK = pDbgMod->m_pSymbolModule->Set(Result - pDbgMod->m_ImageBase, szSym);
				} else
				{
					ADDOK = gpSyser->m_SyserUI.m_SyserCodeDoc.TExpCalc<char,ULONG_PTR,1>::InsertSym(szSym, Result);
				}
			}
		}
		if (ADDOK)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Add '%s' ==> " F0ADDR "X succeed\n"), argv[2], Result);
		else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Add symbols error!\n"));
		return 0;
	} else
	if (argc < 2)
	{
		//WCHAR Buffer[MAX_FN_LEN];
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("symbols ModuleName\n"));
		map<unsigned long long, CSymbolModule>::IT it = gpSyser->m_SyserUI.m_SymbolContainer.m_SymbolModulesMap.begin();
		//while (it != gpSyser->m_SyserUI.m_SymbolContainer.m_SymbolModulesMap.end())
		while (it)
		{
			if (it->second.m_ModuleName.IsEmpty())
			{
				TStrCpy(Buffer, "<No Name>");
			} else
			{
				AnsiToUnicode(it->second.m_ModuleName.operator const char*(), Buffer, lenof(Buffer));
			}
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-5d   %s\n"), it->second.m_SymbolMap.size(), TGetFileName(Buffer));
			++it;
		}
		return 0;
	}

	//char szMod[MAX_FN_LEN];
	//char szSym[64];

	if (argc == 2)
	{
		UnicodeToAnsi(argv[1], szSym, 64);
		szMod[0] = 0;
	} else
	{
		UnicodeToAnsi(argv[1], szMod, MAX_FN_LEN);
		UnicodeToAnsi(argv[2], szSym, 64);
	}
{
	map<unsigned long long, CSymbolModule>::IT it = gpSyser->m_SyserUI.m_SymbolContainer.m_SymbolModulesMap.begin();
	//while (it != gpSyser->m_SyserUI.m_SymbolContainer.m_SymbolModulesMap.end())
	while (it)
	{
		if (it->second.m_ImageBase &&
			(TCmpModuleName(it->second.m_ModuleName.operator const char*(), szMod) || !szMod[0]))
		{
			map<ULONG_PTR, TAnsiNoCaseString>::IT ix = it->second.m_SymbolMap.begin();
			//while (ix != it->second.m_SymbolMap.end())
			while (ix)
			{
				if (TIMatchWithPattern(szSym, ix->second.operator const char*()))
				{
					//WCHAR szStr[64];
					AnsiToUnicode(ix->second.operator const char*(), szStr, lenof(szStr));
					if (it->second.m_ModuleName.IsEmpty())
					{
						TStrCpy(Buffer, "<No Name>");
					} else
					{
						AnsiToUnicode(it->second.m_ModuleName.operator const char*(), Buffer, lenof(Buffer));
					}
					gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<B>" F0ADDR "X %<1>: %<F>%s  %<1><%s>\n"),
						it->second.m_ImageBase + ix->first, szStr, TGetFileName(Buffer));
					++Count;
				}
				++ix;
			}
		}
		++it;
	}
}
{
	map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
	//while (it != gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.end())
	while (it)
	{
		if (it->second.m_pSymbolModule && !it->second.m_pSymbolModule->m_ImageBase &&
			(TCmpModuleName(it->second.m_pName, szMod) || !szMod[0]))
		{
			map<ULONG_PTR, TAnsiNoCaseString>::IT ix = it->second.m_pSymbolModule->m_SymbolMap.begin();
			//while (ix != it->second.m_pSymbolModule->m_SymbolMap.end())
			while (ix)
			{
				if (TIMatchWithPattern(szSym, ix->second.operator const char*()))
				{
					//WCHAR szStr[64];
					AnsiToUnicode(ix->second.operator const char*(), szStr, lenof(szStr));
					if (it->second.m_pSymbolModule->m_ModuleName.IsEmpty())
					{
						TStrCpy(Buffer, "<No Name>");
					} else
					{
						AnsiToUnicode(it->second.m_pSymbolModule->m_ModuleName.operator const char*(), Buffer, lenof(Buffer));
					}
					gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<B>" F0ADDR "X %<1>: %<F>%s  %<1><%s>\n"),
						it->second.m_ImageBase + ix->first, szStr, TGetFileName(Buffer));
					++Count;
				}
				++ix;
			}
		}
		++it;
	}
}
	if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger)
{
	map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
	//while (it != gpSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.end())
	while (it)
	{
		if (it->second.m_pSymbolModule && !it->second.m_pSymbolModule->m_ImageBase &&
			(TCmpModuleName(it->second.m_pName, szMod) || !szMod[0]))
		{
			map<ULONG_PTR, TAnsiNoCaseString>::IT ix = it->second.m_pSymbolModule->m_SymbolMap.begin();
			//while (ix != it->second.m_pSymbolModule->m_SymbolMap.end())
			while (ix)
			{
				if (TIMatchWithPattern(szSym, ix->second.operator const char*()))
				{
					//WCHAR szStr[64];
					AnsiToUnicode(ix->second.operator const char*(), szStr, lenof(szStr));
					if (it->second.m_pSymbolModule->m_ModuleName.IsEmpty())
					{
						TStrCpy(Buffer, "<No Name>");
					} else
					{
						AnsiToUnicode(it->second.m_pSymbolModule->m_ModuleName.operator const char*(), Buffer, lenof(Buffer));
					}
					gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<B>" F0ADDR "X %<1>: %<F>%s  %<1><%s>\n"),
						it->second.m_ImageBase + ix->first, szStr, TGetFileName(Buffer));
					++Count;
				}
				++ix;
			}
		}
		++it;
	}
}
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%d Symbol(s)\n"), Count);
	return 0;
}

int symmod_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	int Count = 0;
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Ref  SymbolCount FullFileName\n"));
	map<unsigned long long, CSymbolModule>::IT it = gpSyser->m_SyserUI.m_SymbolContainer.m_SymbolModulesMap.begin();
	//while (it != gpSyser->m_SyserUI.m_SymbolContainer.m_SymbolModulesMap.end())
	while (it)
	{
		WCHAR szModuleName[MAX_FN_LEN];
		AnsiToUnicode(it->second.m_ModuleName.operator const char*(), szModuleName, lenof(szModuleName));
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-4d %-8d    %s\n"),
			it->second.m_RefCount,
			it->second.m_SymbolMap.size(),
			szModuleName);
		++Count;
		++it;
	}
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%d Module(s)\n"), Count);
	return 0;
}

int sdsmod_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	unsigned int Count = 0;
	for (map<FILESIG, CSDSModule>::IT it = gpSyser->m_SyserUI.m_SDSModulesMap.begin();
		it != gpSyser->m_SyserUI.m_SDSModulesMap.end(); ++it)
	{
		if (Count == 0)
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("File BP(s) Size(k) CheckSum TimeStamp ModuleName\n"));
		WCHAR szModuleName[MAX_FN_LEN];
		AnsiToUnicode(it->second.m_ExeFileName.operator const char*(), szModuleName, lenof(szModuleName));
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-4d %7dk %08X %08X  %s\n"),
				it->second.m_BreakPoints.Size(),
				it->second.m_MemSize / 1024,
				it->second.GetFILESIG().CheckSum,
				it->second.GetFILESIG().TimeStamp,
				szModuleName);
		++Count;
	}
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%d Module(s)\n"), Count);
	return 0;
}

int cmt_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;
	for (map<unsigned long long, CCommentModule>::IT It = gpSyser->m_SyserUI.m_CommentContainer.m_CommentModulesMap.begin();
		It; ++It)
	{
		WCHAR szModuleName[MAX_FN_LEN];
		AnsiToUnicode(It->second.m_ModuleName.operator const char*(), szModuleName, lenof(szModuleName));
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Comment Module : %<F>%s\n"), szModuleName);
		for (map<ULONG_PTR, TAnsiString>::IT it2 = It->second.m_CommentMap.begin();
			it2 != It->second.m_CommentMap.end(); ++it2)
		{
			WCHAR szComment[260];
			AnsiToUnicode(it2->second.operator const char*(), szComment, lenof(szComment));
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<5>" F0ADDR "X %<F>%s\n"), it2->first, szComment);
		}
	}
	return 0;
}

int seg_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;
	if (argc != 2)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : seg segment_name\n"));
		return 1;
	}
	for (int i = 0; i < SEG_IDX_MAX; ++i) //lenof(CInstrSym::m_SegStr)
	{
		if (!TStrICmp(argv[1], CInstrSym::m_SegStr[i]))
		{
			unsigned long Seg = 0;
			switch (i)
			{
			case ES_IDX: Seg = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pES; break;
			case CS_IDX: Seg = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCS; break;
			case SS_IDX: Seg = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pSS; break;
			case DS_IDX: Seg = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pDS; break;
			case FS_IDX: Seg = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pFS; break;
			case GS_IDX: Seg = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pGS; break;
			default:Seg = 0; break;
			}
			ULONG_PTR Base = 0;
			if (pSyser->m_pDebugger->GetSegRegBase(Seg, &Base, 0))
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Seg %s : Base %08X\n"), CInstrSym::m_SegStr[i], Base);
			else	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Seg %s isn't present !\n"), CInstrSym::m_SegStr[i]);
			return 0;
		}
	}
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : %<3>Input error !\n"));
	return 1;
}

int r_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 1;
	if (argc < 2)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Usage : seg segment_name\n"));
		return 1;
	}
	if (argc < 3)
	{
		ULONG_PTR Result;
		if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Result))
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
			return -1;
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%s = %X\n"), argv[1], Result);
		return 0;
	}

	ULONG_PTR Result;
	if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Result))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
		return -1;
	}
	char Buffer[64];
	UnicodeToAnsi(argv[1], Buffer, 64);
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.TExpCalc<char,ULONG_PTR,1>::UpdateSym(Buffer, Result))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
		return -1;
	}
	gpSyser->m_pDebugger->UpdateRegisters();
	gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
	return 0;
}

int m_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc != 4)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), *argv);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return -1;
	}

	ULONG_PTR Src;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Src))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	ULONG_PTR Len;
	if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Len))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Invalid Length!\n"));
		return -1;
	}

	ULONG_PTR Dst;
	if (!gpSyser->m_SyserUI.CalcExp(argv[3], &Dst))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	if (Len > 0x10000)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Length too large!\n"));
		return -1;
	}

	unsigned long Res = gpSyser->m_pDebugger->MoveMemory(Dst, Src, Len);
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%X bytes moved!\n"), Res);
	gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
	return 0;
}

int f_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc < 4)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), argv[0]);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return -1;
	}

	ULONG_PTR Address;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	ULONG_PTR Length;
	if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Length))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
		return -1;
	}

	unsigned char Buffer[256];
	memset(Buffer, 0, sizeof(Buffer));

	unsigned long Len = 0;
	const WCHAR *Str = &szCmd[argv[3] - argv[0]];

	if (*Str == '"' || *Str == '\'')
	{
		int n = 0;
		++Str;
		while (Str && (*Str != '"' && *Str != '\'') && n < 255)
		{
			Buffer[n++] = *Str++;
		}
		Buffer[n]=0;
		Len = n+1; //???
	} else
	{
		Len = THexBytesToASCII(Str, Buffer, 256);
		if (Len == 0)
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
			return -1;
		}
	}

	unsigned long Count = 0;
	while (Length>0)
	{
		unsigned long WLen = MIN(Length, Len);
		if (pSyser->m_pDebugger->WriteMemory(Address+Count, Buffer, WLen) != WLen)
			break;
		Length -= WLen;
		Count += WLen;
	}
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%d Byte(s) filled !\n"), Count);
	gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
	return 0;
}

int s_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	static unsigned char gBuffer[256];
	static unsigned long gFoundCodeView = 0;
	static unsigned long gStartCodeView = 0;
	static unsigned long gPatternLen = 0;
	static ULONG_PTR gAddress = 0;
	static ULONG_PTR gLength = 0;

	unsigned long PatternLen;
	ULONG_PTR Address;
	ULONG_PTR Length;

	if (argc < 4)
	{
		if (argc != 1 || gLength == 0)
		{
			WCHAR Buffer[64];
			TSPrintf(Buffer, WSTR("help %s"), argv[0]);
			gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
			return -1;
		}
		Length = gLength;
		PatternLen = gPatternLen;
		Address = gAddress;
	} else
	{
		switch (argv[0][1])
		{
		case 0:
		case 'D':
		case 'd':
			gStartCodeView = 0;
			break;
		case 'C':
		case 'c':
			gStartCodeView = 1;
			break;
		}

		gFoundCodeView = gStartCodeView;

		if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
			return -1;
		}

		if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Length))
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
			return -1;
		}

		//static unsigned char gBuffer[256];
		memset(gBuffer, 0, sizeof(gBuffer));

		//unsigned long gPatternLen = 0;
		const WCHAR *Str = &szCmd[argv[3] - argv[0]];

		if (*Str == '"' || *Str == '\'')
		{
			int n = 0;
			++Str;
			gPatternLen = 0;
			while (Str && (*Str != '"' && *Str != '\'') && n < 255)
			{
				gBuffer[n++] = *Str++;
			}
			gBuffer[n] = 0;
			PatternLen = n;
			gPatternLen = PatternLen;
		} else
		{
			PatternLen = THexBytesToASCII(Str, gBuffer, 256);
			gPatternLen = PatternLen;
			if (PatternLen == 0)
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
				return -1;
			}
		}
	}

	ULONG_PTR Res = gpSyser->m_pDebugger->SearchMemory(Address, Length, gBuffer, PatternLen, true); //bCaseCmp
	if (Res == -1)
	{
		gLength = 0;
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Couldn't found in range!\n"));
		return 0;
	} else
	{
		switch (argv[0][1])
		{
		case 0:
			gFoundCodeView = gStartCodeView;
			break;
		case 'D':
		case 'd':
			gStartCodeView = 1;
			break;
		case 'C':
		case 'c':
			gStartCodeView = 0;
			break;
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Found at " F0ADDR "X\n"), Res);
		gLength = Address + Length - (Res + 1);
		gAddress = Res + 1;
		if (gFoundCodeView)
			gpSyser->m_MainFrame.m_SystemExplorer.CodeGotoAddr(Res, true);
		else	gpSyser->m_MainFrame.m_SystemExplorer.DataGotoAddr(Res, gPatternLen);
	}
	return 0;
}

int c_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc != 4)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), *argv);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return -1;
	}

	ULONG_PTR Src;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Src))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	ULONG_PTR Len;
	if (!gpSyser->m_SyserUI.CalcExp(argv[2], &Len))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Invalid Length!\n"));
		return -1;
	}

	ULONG_PTR Dst;
	if (!gpSyser->m_SyserUI.CalcExp(argv[3], &Dst))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	if (Len > 0x10000)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Length too large!\n"));
		return -1;
	}

	unsigned long Res = gpSyser->m_pDebugger->CompareMemory(Dst, Src, Len);
	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%X bytes is same!\n"), Res);
	gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
	return 0;
}

int a_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		return 0;
	
	if (argc < 3)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), argv[0]);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return -1;
	}

	ULONG_PTR Address;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	char szAsmCmd[128];
	TStrCpyLimit(szAsmCmd, &szCmd[argv[2] - argv[0]], 128);
	unsigned char CodeBuf[64];
	unsigned long CodeLen = gpSyser->m_SyserUI.m_SyserCodeDoc.Asm(szAsmCmd, CodeBuf, Address);
	if (!CodeLen)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid asm code string!\n"));
		return -1;
	}

	if (pSyser->m_pDebugger->WriteMemory(Address, CodeBuf, CodeLen) != CodeLen)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Fail to write code to " F0ADDR "X!\n"), Address);//argv[1]); //??? Address
		return -1;
	}
	gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
	return 0;
}

int e_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc < 2)
	{
		WCHAR Buffer[64];
		TSPrintf(Buffer, WSTR("help %s"), argv[0]);
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return -1;
	}

	ULONG_PTR Address;
	if (!gpSyser->m_SyserUI.CalcExp(argv[1], &Address))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Address!\n"));
		return -1;
	}

	if (argc == 2)
	{
		pSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.SetActiveAddress(Address, argv[1]);
		return 0;
	}

	unsigned char Buffer[256];
	memset(Buffer, 0, sizeof(Buffer));

	unsigned long Len = 0;
	const WCHAR *Str = &szCmd[argv[2] - argv[0]];
	
	switch (argv[1][0])
	{
	case 'D':
	case 'd':
		if (!gpSyser->m_SyserUI.CalcExp(Str, (ULONG_PTR*)Buffer))
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
			return -1;
		}
		Len = 4;
		break;
	case 'W':
	case 'w':
		if (!gpSyser->m_SyserUI.CalcExp(Str, (ULONG_PTR*)Buffer))
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
			return -1;
		}
		Len = 2;
		break;
	default:
		if (*Str == '"' || *Str == '\'')
		{
			int n = 0;
			++Str;
			while (Str && (*Str != '"' && *Str != '\'') && n < 255)
			{
				Buffer[n++] = *Str++;
			}
			Buffer[n]=0;
			Len = n+1;
		} else
		{
			Len = THexBytesToASCII(Str, Buffer, 256);
			if (Len == 0)
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Invalid Parameter!\n"));
				return -1;
			}
		}
	}
	if (pSyser->m_pDebugger->WriteMemory(Address, Buffer, Len) == Len)
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%<3>Error %<1>: Fail to write memory!\n"));
	gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
	return 0;
}

void ShowDbgModule(CDbgModule *pDbgMod)
{
	char szTimeStamp[32];
	Time2Str(pDbgMod->m_TimeStamp - gpSyser->m_TimeOffset, szTimeStamp);

	WCHAR TimeStamp[30];
	TStrCpy(TimeStamp, szTimeStamp);

	WCHAR FileTitle[MAX_FN_LEN];
	AnsiToUnicode(pDbgMod->m_FileTitle.operator const char*(), FileTitle, lenof(FileTitle));

	WCHAR FullFileName[MAX_FN_LEN];
	AnsiToUnicode(pDbgMod->m_FullFileName.operator const char*(), FullFileName, lenof(FullFileName));

	gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%-20s " F0ADDR "X  %08X  %08X %-20s%s\n"),
		FileTitle, pDbgMod->m_ImageBase, pDbgMod->m_ImageSize, pDbgMod->m_CheckSum, TimeStamp, FullFileName);
}

int mod_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (argc == 1)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("ModuleName           ImageBase ImageSize CheckSum TimeStamp           FullFileName\n"));
		for (map<CMemoryImage, CDbgModule>::IT it = pSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
			it != pSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.end(); ++it)
		{
			ShowDbgModule(&it->second);
		}
		return 0;
	}

	ULONG_PTR Address = -1;

	int cmd = 0;
	int start = 1;
	if (!TStrCmp(argv[1], "-u"))
	{
		cmd = 1;
		start = 2;
	} else
	if (!TStrCmp(argv[1], "-s"))
	{
		cmd = 2;
		start = 2;
	} 

	if (start < argc && gpSyser->m_SyserUI.CalcExp(argv[start], &Address))
	{
		CDbgModule *pDbgMod = pSyser->m_pSysDebugger->m_DbgModuleList.FindModule(Address);
		if (!pDbgMod)
		{
			pDbgMod = pSyser->m_pDebugger->m_DbgModuleList.FindModule(Address);
			if (!pDbgMod)
			{
				gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Can't find this module locate on " F0ADDR "X\n"), Address); //???
				return 1;
			}
		}
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("ModuleName           ImageBase ImageSize FullFileName\n"));
		ShowDbgModule(pDbgMod);
	} else
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("ModuleName           ImageBase ImageSize FullFileName\n"));
		if (pSyser->m_pSysDebugger != pSyser->m_pDebugger && cmd != 2) //-u
		{
			for (map<CMemoryImage, CDbgModule>::IT it = pSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
				it != pSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.end(); ++it)
			{
				if (start < argc)
				{
					WCHAR Buffer[MAX_FN_LEN];
					AnsiToUnicode(it->second.m_FullFileName.operator const char*(), Buffer, lenof(Buffer));
					for (int n = start; n < argc; ++n)
					{
						if (!TCmpModuleName(Buffer, argv[n]) &&
						    !TIMatchWithPattern(argv[n], TGetFileName(Buffer)))
							continue;
						ShowDbgModule(&it->second);
					}
				} else
				{
					ShowDbgModule(&it->second);
				}
			}
		}

		if (cmd != 1) //-s
		{
			for (map<CMemoryImage, CDbgModule>::IT it = pSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
				it != pSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.end(); ++it)
			{
				if (start < argc)
				{
					WCHAR Buffer[MAX_FN_LEN];
					AnsiToUnicode(it->second.m_FullFileName.operator const char*(), Buffer, lenof(Buffer));
					for (int n = start; n < argc; ++n)
					{
						if (!TCmpModuleName(Buffer, argv[n]) &&
						    !TIMatchWithPattern(argv[n], TGetFileName(Buffer)))
							continue;
						ShowDbgModule(&it->second);
					}
				} else
				{
					ShowDbgModule(&it->second);
				}
			}
		}
	}
	return 0;
}

int open_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!pSyser->m_pDebugger)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : please load debugger first !\n"));
		return 1;
	}

	if (pSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		pSyser->m_SyserUI.m_SyserCodeDoc.Close();

	char szFileName[MAX_FN_LEN];
	if (argc != 1)
	{
		UnicodeToAnsi(&szCmd[argv[1] - argv[0]], szFileName, MAX_FN_LEN);
	} else
	{
	#if 0
		OPENFILENAMEA ofn;
		memset(&ofn, 0, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hInstance = gpSyser->m_hInstance;
		ofn.hwndOwner = gpSyser->m_hWnd;

		char szFilter[MAX_FN_LEN];
		UnicodeToAnsi(gpSyser->m_szDbgFileNameFilter.operator const WCHAR*(), szFilter, MAX_FN_LEN);
		
		int Len = TStrLen(szFilter);
		MAX_LIMIT(Len, MAX_FN_LEN);

		for (int i = Len; i >= 0; --i)
		{
			if (szFilter[i] == '|')
				szFilter[i] = 0;
		}

		ofn.lpstrFile = szFileName;
		ofn.lpstrFilter = szFilter;
		ofn.nMaxFile = MAX_FN_LEN;
		szFileName[0] = 0;
		gpSyser->LockTimer();
		if (!::GetOpenFileNameA(&ofn))
		{
			gpSyser->UnlockTimer();
			return 1;
		}
		gpSyser->UnlockTimer();

		TStrCpy(szFileName, ofn.lpstrFile);
	#else
		if (!gpSyser->OpenFileDialog(szFileName))
			return 1;
	#endif
	}

	if (!pSyser->m_SyserUI.m_SyserCodeDoc.Open(szFileName))
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : Fail to open !\n"));
		return 1;
	}	
	return 0;
}

int close_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!pSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && gpSyser->m_SyserUI.m_SyserCodeDoc.m_ExeFilePath.IsEmpty())
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Error : please open file first !\n"));
		return 1;
	}
	pSyser->m_SyserUI.m_SyserCodeDoc.Close();
	return 0;
}

int reset_command(int argc, const WCHAR **argv, const WCHAR *szCmd, CSyser *pSyser)
{
	if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen || gpSyser->m_SyserUI.m_SyserCodeDoc.m_ExeFilePath.IsEmpty())
		return 1;
	WCHAR szFileName[MAX_FN_LEN];
	AnsiToUnicode(gpSyser->m_SyserUI.m_SyserCodeDoc.m_ExeFilePath.operator const char*(), szFileName, lenof(szFileName));
	if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("close"), 0);
	WCHAR szOpenCmd[MAX_FN_LEN];
	TSPrintf(szOpenCmd, WSTR("open %s"), szFileName);
	gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(szOpenCmd, 0);
	return 0;
}

SYSER_CMD_ENTRY SysCmdTable[] =
{
	{ WSTR("bc"), WSTR("Clear breakpoint"), bc_command, 
		WSTR("bc: Clear breakpoint\n"
		"Format: bc address_or_index[*]\n"
		"Example1: bc *\n"
		"Example2: bc 1\n"
		"Example3: bc 401000\n")},
	{ WSTR("bl"), WSTR("List breakpoints"), bl_command, 
		WSTR("bl: List breakpoint\n"
		"Format: bl\n"
		"Example1: bl\n")},
	{ WSTR("bd"), WSTR("Disable breakpoints"), bd_command, 
		WSTR("bd: Disable breakpoint\n"
		"Format: bd address_or_index[*]\n"
		"Example1: bd *\n"
		"Example2: bd 1\n"
		"Example3: bd 401000\n")},
	{ WSTR("be"), WSTR("Enable breakpoints"), be_command, 
		WSTR("be: Enable breakpoint\n"
		"Format: be address_or_index[*]\n"
		"Example1: be *\n"
		"Example2: be 1\n"
		"Example3: be 401000\n")},
	{ WSTR("bpx"), WSTR("Set breakpoint"), bpx_command, 
		WSTR("bpx: Set breakpoint\n"
		"Format: bpx address [if condition_string] [do command_string]\n"
		"Example1: bpx 401000 EAX==0302\n"
		"Example2: bpx MessageBoxA\n"
		"Example3: bpx 402000 rw if (*esi)&FF==0 do d eip\n")},
	{ WSTR("bpload"), WSTR("Set module loading breakpoint"), bpload_command, 
		WSTR("bpload: Set module loading breakpoint\n"
		"Format: bpload module_name\n"
		"Example1: bpload kernel32\n"
		"Example2: bpload user32.dll\n")},
	{ WSTR("bpm"), WSTR("Breakpoint on memory access"), bpm_command, 
		WSTR("bpm,bpmb,bpmw,bpmd: Set data access breakpoint\n"
		"Format: bpm address [rw,w,x] [if condition_string] [do command_string]\n"
		"Example1: bpm 401000 w\n"
		"Example2: bpmw 401000 rw       (set word access breakpoint)\n"
		"Example3: bpm esi w if *eax==00 do d esi;bc *\n")},
	{ WSTR("bpmb"), WSTR("Breakpoint on memory access (BYTE)"), bpm_command, 
		WSTR("bpm,bpmb,bpmw,bpmd: Set data access breakpoint\n"
		"Format: bpm address [rw,w,x] [if condition_string] [do command_string]\n"
		"Example1: bpm 401000 w\n"
		"Example2: bpmw 401000 rw       (set word access breakpoint)\n"
		"Example3: bpm esi w if *eax==00 do d esi;bc *\n")},
	{ WSTR("bpmw"), WSTR("Breakpoint on memory access (WORD)"), bpm_command, 
		WSTR("bpm,bpmb,bpmw,bpmd: Set data access breakpoint\n"
		"Format: bpm address [rw,w,x] [if condition_string] [do command_string]\n"
		"Example1: bpm 401000 w\n"
		"Example2: bpmw 401000 rw       (set word access breakpoint)\n"
		"Example3: bpm esi w if *eax==00 do d esi;bc *\n")},
	{ WSTR("bpmd"), WSTR("Breakpoint on memory access (DWORD)"), bpm_command, 
		WSTR("bpm,bpmb,bpmw,bpmd: Set data access breakpoint\n"
		"Format: bpm address [rw,w,x] [if condition_string] [do command_string]\n"
		"Example1: bpm 401000 w\n"
		"Example2: bpmw 401000 rw       (set word access breakpoint)\n"
		"Example3: bpm esi w if *eax==00 do d esi;bc *\n")},
	{ WSTR("bpio"), WSTR("Breakpoint on I/O port access"), bpio_command, 
		WSTR("bpio: Set a breakpoint on an I/O Port access\n"
		"Format: bpio I/O_port [r,w,rw] [if condition_string] [do command_string]\n"
		"Example1: bpio 3E8 rw\n"
		"Example2: bpio 2E4 rw if eax==0 do dd esi\n")},
	{ WSTR("x"), WSTR("Return to host and continue running"), x_command, 
		WSTR("x: exit debugger (continue)\n"
		"format: x\n")},
	{ WSTR("exit"), WSTR("Return to host and continue running"), x_command, 
		WSTR("x: exit debugger (continue)\n"
		"format: x\n")},
	{ WSTR("g"), WSTR("Go to address"), g_command, 
		WSTR("go : set one-time breakpoint at specify address\n"
		"Format: go address\n"
		"Example1: go " CIPSTR "+20\n"
		"Example2: go 402000\n")},
	{ WSTR("t"), WSTR("Trace one instruction"), t_command, 
		WSTR("t: Trace one instruction\n"
		"Format: t [step count] [condition]\n"
		"Example1: t 100                       (run 100 t steps)\n"
		"Example2: t " CIPSTR "<401000 && " CIPSTR ">402000  (break " CIPSTR " jump out of 401000 - 402000)\n")},
	{ WSTR("st"), WSTR("Trace one source code line"), st_command, 
		WSTR("st: Trace one source code line\n"
		"Format: st\n"
		"Example1: st\n")},
	{ WSTR("tb"), WSTR("Trace and break at next branch"), tb_command, 
		0},
	{ WSTR("p"), WSTR("Execute one program step"), p_command, 
		WSTR("p: Execute one program step (skip CALL,REP )\n"
		"Format: p [step count] [condition] [ret]\n"
		"Example1: p 100                       (run 100 p steps)\n"
		"Example2: p " CIPSTR "<401000 && " CIPSTR ">402000  (break " CIPSTR " jump out of 401000 - 402000)\n"
		"Example3: p ret                       (stop at return)\n")},
	{ WSTR("sp"), WSTR("Execute one source code step"), sp_command, 
		WSTR("sp: Execute one source code step\n"
		"Format: sp\n"
		"Example1: sp\n)")},
	{ WSTR("skip"), WSTR("Skip current instruction"), skip_command, 
		0},
	{ WSTR("stack"), WSTR("Display call stack context"), stack_command, 
		WSTR("stack: Display call stack\n"
		"Format: stack [call_frame_address]\n"
		"Example1: stack             (analyse from ebp)\n"
		"Example2: stack  124000     (analyse from 124000)\n")},
	{ WSTR("u"), WSTR("Unassemble instructions"), u_command, 
		WSTR("u: Unassemble instructions\n"
		"Format: u address\n"
		"Exapmle1: u 401000\n"
		"Exapmle2: u eip+1000\n"
		"Example3: u +\n"
		"Example4: u -\n"
		"Example5: u + offset\n"
		"Example6: u - offset\n"
		"Example6: u -a address\n")},
	{ WSTR("."), WSTR("Locate " CIPSTR " instruction in Code View"), u_command, 
		WSTR(".: Locate " CIPSTR " instruction in Code View (== u eip)\n"
		"Format: .\n")},
	{ WSTR("src"), WSTR("Locate address in Source Code File"), src_command, 
		WSTR("src: Locate address in Source Code File\n"
		"Format: src [address]\n"
		"Example1: src (==src EIP)\n"
		"Example2: src 401000\n")},
	{ WSTR("sym"), WSTR("List symbols"), sym_command, 
		WSTR("sym: List symbols\n"
		"Format: sym [module_name] [symbol_wildcard] | -a symbol value\n"
		"Example1: sym kernel32 *         (List all symbols of kernel32.dll)\n"
		"Example2: sym CreateFile?        (List CreateFileA and CreateFileW)\n"
		"Example3: sym -a mysymbol 4013af (Add owner labels)\n")},
	{ WSTR("symmod"), WSTR("Display all symbol modules"), symmod_command,
		0},
	{ WSTR("sdsmod"), WSTR("Display all sds symbol modules"), sdsmod_command,
		WSTR("sdsmod: List all syser symbol modules loaded\n"
		"Format: sdsmod\n")},
	{ WSTR("cmt"), WSTR("List module comment in current process"), cmt_command,
		WSTR("cmt: List module comment in current process\n"
		"Format: cmt\n")},
	{ WSTR("seg"), WSTR("Display segment information"), seg_command,
		WSTR("seg: Display segment information\n"
		"Format: seg segment_register_name\n"
		"Example1: seg cs\n"
		"Example2: seg 08")},
	{ WSTR("r"), WSTR("Display/Change Register Value"), r_command,
		WSTR("r: Display/Change  Register Value\n"
		"Format: r reg_name [value]\n"
		"Example1: r eip 402000\n"
		"Example2: r eax 80001000\n"
		"Example3: r ah 10\n"
		"Example4: r ebx")},
	{ WSTR("m"), WSTR("Move data"), m_command, 
		WSTR("m: Move data\n"
		"Format: m source_address length dest_address (length is HEX bytes)\n"
		"Example1: m esi 100 edi\n"
		"Example2: m 402000 E00 403000\n")},
	{ WSTR("f"), WSTR("Fill memory with data"), f_command, 
		WSTR("f: Fill memory\n"
		"Format: f address length data_string\n"
		"Example1: f esi 4 80001000\n"
		"Example2: f 401000 5 E9,00,00,00,10\n"
		"Example3: f 401000 1000 \"hello\"\n")},
	{ WSTR("s"), WSTR("Search binary data or string"), s_command, 
		WSTR("s: Search memory\n"
		"Format: s address length data_string\n"
		"Example1: s 401000 1000 \"CreateFileA\"\n"
		"Example2: s " CIPSTR " 2000 FF,15,00,00,10,40\n"
		"Example3: s           (continue last search operation)\n")},
	{ WSTR("sc"), WSTR("Search binary data or string,show search resoult at code view"), s_command, 
		WSTR("s: Search memory\n"
		"Format: s address length data_string\n"
		"Example1: s 401000 1000 \"CreateFileA\"\n"
		"Example2: s " CIPSTR " 2000 FF,15,00,00,10,40\n"
		"Example3: s           (continue last search operation)\n")},
	{ WSTR("sd"), WSTR("Search binary data or string,show search resoult at data view"), s_command, 
		WSTR("s: Search memory\n"
		"Format: s address length data_string\n"
		"Example1: s 401000 1000 \"CreateFileA\"\n"
		"Example2: s " CIPSTR " 2000 FF,15,00,00,10,40\n"
		"Example3: s           (continue last search operation)\n")},
	{ WSTR("c"), WSTR("Compare two data blocks"), c_command, 
		WSTR("c: Compare two data blocks\n"
		"Format: c source_address length dest_address (length is HEX bytes)\n"
		"Example1: c esi 100 edi\n"
		"Example2: c 402000 E00 403000\n")},
	{ WSTR("a"), WSTR("modify memory by assemble code"), a_command, 
		WSTR("a: Modify memory by assemble code\n"
		"Format: a address asm_string\n"
		"Example1: a 401000 inc eax\n"
		"Example2: a EIP mov eax,ebx\n")},
	{ WSTR("e"), WSTR("Edit memory"), e_command, 
		WSTR("e,eb,ew,ed:  Edit memory\n"
		"Format: e address data_value\n"
		"Example1: e 403000 00,01,02,04\n"
		"Example2: e ESI \"Hello\"\n"
		"Example3: eb 401000 10\n"
		"Example4: ew 401000 2030\n"
		"Example5: ed 401000 40506070\n")},
	{ WSTR("eb"), WSTR("Edit memory (BYTE)"), e_command, 
		WSTR("e,eb,ew,ed:  Edit memory\n"
		"Format: e address data_value\n"
		"Example1: e 403000 00,01,02,04\n"
		"Example2: e ESI \"Hello\"\n"
		"Example3: eb 401000 10\n"
		"Example4: ew 401000 2030\n"
		"Example5: ed 401000 40506070\n")},
	{ WSTR("ew"), WSTR("Edit memory (WORD)"), e_command, 
		WSTR("e,eb,ew,ed:  Edit memory\n"
		"Format: e address data_value\n"
		"Example1: e 403000 00,01,02,04\n"
		"Example2: e ESI \"Hello\"\n"
		"Example3: eb 401000 10\n"
		"Example4: ew 401000 2030\n"
		"Example5: ed 401000 40506070\n")},
	{ WSTR("ed"), WSTR("Edit memory (DWORD)"), e_command, 
		WSTR("e,eb,ew,ed:  Edit memory\n"
		"Format: e address data_value\n"
		"Example1: e 403000 00,01,02,04\n"
		"Example2: e ESI \"Hello\"\n"
		"Example3: eb 401000 10\n"
		"Example4: ew 401000 2030\n"
		"Example5: ed 401000 40506070\n")},
	{ WSTR("mod"), WSTR("Display Modules"), mod_command, 
		WSTR("mod: List modules of current process\n"
		"Format: mod [address][mod_name]\n"
		"Example1: mod eip           (display module's name on current eip)\n"
		"Example2: mod nt*           (display module's name fit to \"nt*\")\n")},

	{ WSTR("open"), WSTR("open file"), open_command, 
		0},
	{ WSTR("close"), WSTR("close file"), close_command, 
		0},
	{ WSTR("reset"), WSTR("reset debug state"), reset_command, 
		0},

	{0},
};

```

`source/WispSyser/syserconfig.cpp`:

```cpp

#include "syserconfig.hpp"
#include "../Code/imagefile.hpp"

SYSER_CFG gSyserConfig;

SYSER_CFG gSyserDefConfig =
{
	0,			//; iID
	0,			//; iSplitRight
	0,			//; iBigFont
	WSTR(""),		//; szFontFileName
	0,			//; iFollowMode
	1,			//; iShowStartSplash
	0,			//; iShowFullSym
	0,			//; iShowCCByte
	10,			//; iMouseSensitivity
	500,			//; iHistoryLines
	1,			//; iSourceCodeShowTips
	1,			//; iSourceCodeSyntaxColors
	1,			//; iSourceCodeShowLineNumbers
	1,			//; iConnectType
	1,			//; iComPort
	0,			//; iVideoDetectMode
	512,			//; iStackSize
	1,			//; iHardTimerEnable
#ifdef _X64_
	WSTR("sdx64.dll"),	//; szDebuggerFileName
#else
	WSTR("sdx32.dll"),	//; szDebuggerFileName
#endif
	1024,			//; iWidth
	768,			//; iHeight
	1024,			//; iWidthMax
	768,			//; iHeightMax
	12,			//; iGeneralHeapSize
	15,			//; iSourceHeapSize
	0,			//; iAzertyKeyboard
	2,			//; i3here
	0,			//; i1here
	1,			//; faultsCmdStatus
};

SYSER_COLORS gSyserColors;

SYSER_COLORS gSyserDefColors = 
{0,
	{
//MONITOR
	0,		//Background
	0xFFFFFF,	//Item text
	0x50B0FF,	//Selected frame
	0x58587F,	//Selected frame when lost focus
	0xFF0000,	//Changed item text
	0x80C4FF,	
//CV
	0,		//Background
	0x50B0FF,	//Selected frame
	0x58587F,	//Selected frame when lost focus

	0xFFFFFF,	//Address
	0xFFFFFF,	//Prefix
	0xFFFFFF,	//Operate Code
	0x00FFFF,	//Register
	0x00C0C0,	//Segment Register
	0x00FF80,	//Immed
	0xFFFFFF,	//Operater
	0xFFFF00,	//Symbol
	0xFFFF00,	//Comment
	0xFFFFFF,	//Keyword
	0xFFFF00,	//String
	0xFF0000,	//BPX Strip
	0x808080,	//EIP Strip
	0xFF8000,	//BPX EIP Strip
	0xFF8000,	//API Name
	0xFF7D7D,	//Param Type
	0xC0C0C0,	//Param Name
	0xFFFFFF,	//Jump Line
	0xFFFF00,	//Actived Jump Line
	0x6838C6,	//Prefix Byte
	0x991622,	//Opcode Byte
	0x1A33E4,	//RegRM Byte
	0x39EF04,	//SIB Byte
	0xD01FDF,	//Other Opcode Byte
	0x707070,	//3dNow! Immediate Byte
//SV
	0,		//Background
	0x50B0FF,	//Selected frame
	0x58587F,	//Selected frame when lost focus

	0xFFFFFF,	//Keyword
	0xC0C0C0,	//Identifier
	0x4080FF,	//Preprocessor Keyword
	0x808080,	//Comment block
	0x808080,	//Comment line
	0xFFFF00,	//String
	0x00FF80,	//Numerical
	0xFFFFFF,	//Operation
	0xE17D7D,	//Class name
	0xE17D7D,	//Struct name
	0xE17D7D,	//Union name
	0xE17D7D,	//Typedef name
	0xFF8000,	//Function name
	0x7B7B7B,	//Unknown
	}
};

bool ReadConfig(const char *FileName, void *Buffer, unsigned long Size)
{
	CImageFile File;
	if (!File.Open(FileName, 0))
	{
		return false;
	}

	if (Size != File.m_FileSize)
	{
		File.Close();
		return false;
	}

	if (!File.ReadFile(Buffer, Size))
	{
		File.Close();
		return false;
	}

	unsigned long CodeID = TGetCodeID((unsigned char*)Buffer + 4, Size - 4);
	if (CodeID == 0)
	{
		File.Close();
		return false;
	}

	if (CodeID != *(unsigned long*)Buffer)
	{
		File.Close();
		return false;
	}
	File.Close();
	return true;	
}

bool ReadConfigSize(const char *FileName, void *Buffer, unsigned long Size, unsigned long *FileSize)
{
	CImageFile File;
	if (!File.Open(FileName, 0))
	{
		return false;
	}

	if (Size < File.m_FileSize)
	{
		File.Close();
		return false;
	}

	*FileSize = File.m_FileSize;

	if (!File.ReadFile(Buffer, Size))
	{
		File.Close();
		return false;
	}

	unsigned long CodeID = TGetCodeID((unsigned char*)Buffer + 4, Size - 4);
	if (CodeID == 0)
	{
		File.Close();
		return false;
	}

	if (CodeID != *(unsigned long*)Buffer)
	{
		File.Close();
		return false;
	}
	File.Close();
	return true;	
}

bool WriteConfig(const char *FileName, void *Buffer, unsigned long Size)
{
	CImageFile File;
	if (!File.Create(FileName, 0))
	{
		return false;
	}

	unsigned long CodeID = TGetCodeID((unsigned char*)Buffer + 4, Size - 4);
	*(unsigned long*)Buffer = CodeID;

	if (!File.WriteFile(Buffer, Size))
	{
		File.Close();
		return false;
	}

	File.Close();
	return true;
}

```

`source/WispSyser/syserconfig.hpp`:

```hpp

#ifndef _SYSERCONFIG_HPP_
#define _SYSERCONFIG_HPP_

#include "../Code/define.h"

#pragma pack(push, 1)
struct SYSER_CONFIG
{
	unsigned int iID;
};
#pragma pack(pop)

#pragma pack(push, 1)
struct SYSER_CFG //: public SYSER_CONFIG
{
	unsigned int iID;
	unsigned int iSplitRight;
	unsigned int iBigFont;
	WCHAR szFontFileName[MAX_FN_LEN];
	unsigned int iFollowMode;
	unsigned int iShowStartSplash;
	unsigned int iShowFullSym;
	unsigned int iShowCCByte;
	unsigned int iMouseSensitivity;
	unsigned int iHistoryLines;
	unsigned int iSourceCodeShowTips;
	unsigned int iSourceCodeSyntaxColors;
	unsigned int iSourceCodeShowLineNumbers;
	unsigned int iConnectType;
	unsigned int iComPort;
	unsigned int iVideoDetectMode;
	unsigned int iStackSize;
	unsigned int iHardTimerEnable;
	WCHAR szDebuggerFileName[MAX_FN_LEN];
	unsigned int iWidth;
	unsigned int iHeight;
	unsigned int iWidthMax;
	unsigned int iHeightMax;
	unsigned int iGeneralHeapSize;
	unsigned int iSourceHeapSize;
	unsigned int iAzertyKeyboard;
	unsigned int i3here;
	unsigned int i1here;
	unsigned int faultsCmdStatus;
};
#pragma pack(pop)

extern SYSER_CFG gSyserConfig;
extern SYSER_CFG gSyserDefConfig;

enum CV_COLOR
{
  COLOR_NULL = 0,
  COLOR_BG = 1,
  COLOR_ADDRESS = 2,
  COLOR_PREFIX = 3,
  COLOR_OPCODE = 4,
  COLOR_REGISTER = 5,
  COLOR_SEG_REG = 6,
  COLOR_IMMED = 7,
  COLOR_OPTR = 8,
  COLOR_SYMBOL = 9,
  COLOR_COMMENT = 10,
  COLOR_KEYWORD = 11,
  COLOR_STRING = 12,
  COLOR_BPX_STRIP = 13,
  COLOR_EIP_STRIP = 14,
  COLOR_BPX_EIP_STRIP = 15,
  COLOR_API_NAME = 16,
  COLOR_PARAM_TYPE = 17,
  COLOR_PARAM_NAME = 18,
  COLOR_JMP_LINE = 19,
  COLOR_ACTIVE_JMP_LINE = 20,
  COLOR_PREFIX_BYTE = 21,
  COLOR_OPCODE_BYTE = 22,
  COLOR_REGRM_BYTE = 23,
  COLOR_SIB_BYTE = 24,
  COLOR_OTHER_OPCODE_BYTE = 25,
  COLOR_AMD3DNOW_BYTE = 26,
  COLOR_MAX = 27,
};
#if 0
enum SV_COLOR
{
  COLOR_NULL = 0,
  COLOR_BG = 1,
//TODO
};
#endif
#pragma pack(push, 1)
struct SYSER_COLORS //: public SYSER_CONFIG
{
	unsigned int iID;
	unsigned long Color[51];
};
#pragma pack(pop)

extern SYSER_COLORS gSyserColors;
extern SYSER_COLORS gSyserDefColors;

bool ReadConfig(const char *FileName, void *Buffer, unsigned long Size);
bool ReadConfigSize(const char *FileName, void *Buffer, unsigned long Size, unsigned long *FileSize);
bool WriteConfig(const char *FileName, void *Buffer, unsigned long Size);

#endif

```

`source/WispSyser/syserdefine.hpp`:

```hpp

#ifndef _SYSERDEFINE_HPP_
#define _SYSERDEFINE_HPP_

#include "../Code/define.h"
//#include "../Code/cmdparser.hpp"

struct SYSER_CMD_ENTRY
{
	const WCHAR *CmdStr;
	const WCHAR *CmdCmt;
	void *CmdProc; //CMDPROC
	const WCHAR *CmdUsage;
};

extern SYSER_CMD_ENTRY SysCmdTable[];
extern SYSER_CMD_ENTRY ShareCmdTable[];
extern SYSER_CMD_ENTRY OtherCmdTable[];

#endif

```

`source/WispSyser/syseroptionform.cpp`:

```cpp

#include "syseroptionform.hpp"
#include "syserconfig.hpp"
#include "../Code/sysdep.hpp"
#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"

unsigned int ConfigChanged = 0;
unsigned int ColorsChanged = 0;

bool CheckMouseSensitivity(unsigned int *Value)
{
        return *Value >= 1 && *Value <= 30;
}

const WCHAR *Select[] =
{
	WSTR("No"),
	WSTR("Yes"),
	0,
};

const WCHAR *EIPFollowMode[] =
{
	WSTR("Automatic (Relative to EIP)"),
	WSTR("System Explorer"),
	WSTR("Source Explorer"),
	0,
};

bool CheckHistoryLines(unsigned int *Value)
{
        return *Value >= 100 && *Value <= 1000;
}

const WCHAR *SelectMonitor[] =
{
	WSTR("Left"),
	WSTR("Right"),
	0,
};

OPTION_FORM Debugger[] =
{
	{WSTR("Monitor Position"), OPTION_INT, &gSyserConfig.iSplitRight, 4, SelectMonitor, 0, &ConfigChanged, 0},
	{WSTR("Big Font (Restart Syser to apply)"), OPTION_INT, &gSyserConfig.iBigFont, 4, Select, 0, &ConfigChanged, 0},
	{WSTR("BDF Font File Name"), OPTION_STR, &gSyserConfig.szFontFileName, MAX_FN_LEN, 0, 0, &ConfigChanged, 0},
	{WSTR("EIP Follow Mode"), OPTION_INT, &gSyserConfig.iFollowMode, 4, EIPFollowMode, 0, &ConfigChanged, 0},
	{WSTR("Show Full Symbol (Include Module Name)"), OPTION_INT, &gSyserConfig.iShowFullSym, 4, Select, 0, &ConfigChanged, 0},
//	{WSTR("Mouse Sensitivity [1 - 30]"), OPTION_STRNUM, &gSyserConfig.iMouseSensitivity, 4, 0, CheckMouseSensitivity, &ConfigChanged, 0},
	{WSTR("Command Histroy lines [100 - 10000]"), OPTION_STRNUM, &gSyserConfig.iHistoryLines, 4, 0, CheckHistoryLines, &ConfigChanged, 0},
	{WSTR("Default Debugger Module"), OPTION_STR, &gSyserConfig.szDebuggerFileName, MAX_FN_LEN, 0, 0, &ConfigChanged, 0},
	{0},
};

OPTION_FORM SourceCodeDebugger[] =
{
	{WSTR("Syntax Color"), OPTION_INT, &gSyserConfig.iSourceCodeSyntaxColors, 4, Select, 0, &ConfigChanged, 0},
	{WSTR("Show Tips"), OPTION_INT, &gSyserConfig.iSourceCodeShowTips, 4, Select, 0, &ConfigChanged, 0},
	{WSTR("Show Line Numbers"), OPTION_INT, &gSyserConfig.iSourceCodeShowLineNumbers, 4, Select, 0, &ConfigChanged, 0},
	{0},
};

bool CheckHeapSize(unsigned int *Value)
{
        return *Value >= 15 && *Value <= 40;
}

bool CheckSourceHeapSize(unsigned int *Value)
{
        return *Value >= 6 && *Value <= 60;
}

bool CheckStackSize(unsigned int *Value)
{
        return *Value >= 512 && *Value <= 4096;
}

const WCHAR *SelectEnable[] =
{
	WSTR("Disable"),
	WSTR("Enable"),
	0,
};

bool CheckWidth(unsigned int *Value)
{
        return *Value >= 640 && *Value <= 2048;
}

bool CheckHeight(unsigned int *Value)
{
        return *Value >= 480 && *Value <= 2048;
}

OPTION_FORM Advance[] =
{
	{WSTR("Geneal heap size [15 - 40]M"), OPTION_STRNUM, &gSyserConfig.iGeneralHeapSize, 4, 0, CheckHeapSize, &ConfigChanged, 0},
	{WSTR("Source Code heap size [6 - 40]M"), OPTION_STRNUM, &gSyserConfig.iSourceHeapSize, 4, 0, CheckSourceHeapSize, &ConfigChanged, 0},
	{WSTR("Stack size [512 - 4096]K"), OPTION_STRNUM, &gSyserConfig.iStackSize, 4, 0, CheckStackSize, &ConfigChanged, 0},
	{WSTR("Enable Hardware Timer"), OPTION_INT, &gSyserConfig.iHardTimerEnable, 4, SelectEnable, 0, &ConfigChanged, 0},
	{WSTR("Max window width  [640 - 2048]"), OPTION_STRNUM, &gSyserConfig.iWidthMax, 4, 0, CheckWidth, &ConfigChanged, 0},
	{WSTR("Max window height [480 - 2048]"), OPTION_STRNUM, &gSyserConfig.iHeightMax, 4, 0, CheckHeight, &ConfigChanged, 0},
	{0},
};

//colors
OPTION_FORM SyserOptionMonitorColors[] =
{
	{WSTR("Background"), OPTION_COLOR, &gSyserColors.Color[0], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Item text"), OPTION_COLOR, &gSyserColors.Color[1], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Selected frame"), OPTION_COLOR, &gSyserColors.Color[2], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Selected frame when lost focus"), OPTION_COLOR, &gSyserColors.Color[3], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Changed item text"), OPTION_COLOR, &gSyserColors.Color[4], 4, 0, 0, &ColorsChanged, 0},
	{0},
};

OPTION_FORM SyserOptionCodeViewColors[] =
{
	{WSTR("Background"), OPTION_COLOR, &gSyserColors.Color[6], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Selected frame"), OPTION_COLOR, &gSyserColors.Color[7], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Selected frame when lost focus"), OPTION_COLOR, &gSyserColors.Color[8], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Address"), OPTION_COLOR, &gSyserColors.Color[9], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Prefix"), OPTION_COLOR, &gSyserColors.Color[10], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Operate Code"), OPTION_COLOR, &gSyserColors.Color[11], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Register"), OPTION_COLOR, &gSyserColors.Color[12], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Segment Register"), OPTION_COLOR, &gSyserColors.Color[13], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Immed"), OPTION_COLOR, &gSyserColors.Color[14], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Operater"), OPTION_COLOR, &gSyserColors.Color[15], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Symbol"), OPTION_COLOR, &gSyserColors.Color[16], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Comment"), OPTION_COLOR, &gSyserColors.Color[17], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Keyword"), OPTION_COLOR, &gSyserColors.Color[18], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("String"), OPTION_COLOR, &gSyserColors.Color[19], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("BPX Strip"), OPTION_COLOR, &gSyserColors.Color[20], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("EIP Strip"), OPTION_COLOR, &gSyserColors.Color[21], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("BPX EIP Strip"), OPTION_COLOR, &gSyserColors.Color[22], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("API Name"), OPTION_COLOR, &gSyserColors.Color[23], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Param Type"), OPTION_COLOR, &gSyserColors.Color[24], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Param Name"), OPTION_COLOR, &gSyserColors.Color[25], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Jump Line"), OPTION_COLOR, &gSyserColors.Color[26], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Actived Jump Line"), OPTION_COLOR, &gSyserColors.Color[27], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Prefix Byte"), OPTION_COLOR, &gSyserColors.Color[28], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Opcode Byte"), OPTION_COLOR, &gSyserColors.Color[29], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("RegRM Byte"), OPTION_COLOR, &gSyserColors.Color[30], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("SIB Byte"), OPTION_COLOR, &gSyserColors.Color[31], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Other Opcode Byte"), OPTION_COLOR, &gSyserColors.Color[32], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("3dNow! Immediate Byte"), OPTION_COLOR, &gSyserColors.Color[33], 4, 0, 0, &ColorsChanged, 0},
	{0},
};

OPTION_FORM SyserOptionSrcCodeColors[] =
{
	{WSTR("Background"), OPTION_COLOR, &gSyserColors.Color[34], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Selected frame"), OPTION_COLOR, &gSyserColors.Color[35], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Selected frame when lost focus"), OPTION_COLOR, &gSyserColors.Color[35], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Keyword"), OPTION_COLOR, &gSyserColors.Color[36], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Identifier"), OPTION_COLOR, &gSyserColors.Color[37], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Preprocessor Keyword"), OPTION_COLOR, &gSyserColors.Color[38], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Comment block"), OPTION_COLOR, &gSyserColors.Color[39], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Comment line"), OPTION_COLOR, &gSyserColors.Color[40], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("String"), OPTION_COLOR, &gSyserColors.Color[41], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Numerical"), OPTION_COLOR, &gSyserColors.Color[42], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Operation"), OPTION_COLOR, &gSyserColors.Color[43], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Class name"), OPTION_COLOR, &gSyserColors.Color[44], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Struct name"), OPTION_COLOR, &gSyserColors.Color[45], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Union name"), OPTION_COLOR, &gSyserColors.Color[46], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Typedef name"), OPTION_COLOR, &gSyserColors.Color[47], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Function name"), OPTION_COLOR, &gSyserColors.Color[48], 4, 0, 0, &ColorsChanged, 0},
	{WSTR("Unknown"), OPTION_COLOR, &gSyserColors.Color[49], 4, 0, 0, &ColorsChanged, 0},
	{0},
};

OPTION_FORM SyserOptionColors[] =
{
	{WSTR("Monitor window"), OPTION_SUB, SyserOptionMonitorColors, 0, 0, 0, 0, 0},
	{WSTR("Code View"), OPTION_SUB, SyserOptionCodeViewColors, 0, 0, 0, 0, 0},
	{WSTR("Source Code View"), OPTION_SUB, SyserOptionSrcCodeColors, 0, 0, 0, 0, 0},
	{0},
};

OPTION_FORM SyserOptionForm[] =
{
	{WSTR("Debugger"), OPTION_SUB, Debugger, 0, 0, 0, 0, 0},
	{WSTR("Source Code Debugger"), OPTION_SUB, SourceCodeDebugger, 0, 0, 0, 0, 0},
#ifdef _RING0_
	{WSTR("Developer Advance Option (Restart Syser to apply)"), OPTION_SUB, &Advance, 0, 0, 0, 0, 0},
#endif
	{WSTR("Colors"), OPTION_SUB, SyserOptionColors, 0, 0, 0, 0, 0},
	{0},
};

	CSyserOptionForm::CSyserOptionForm()
	{
		m_OptionForm = SyserOptionForm;
	}

	CSyserOptionForm::~CSyserOptionForm()
	{
	}

	bool CSyserOptionForm::InitWnd()
	{
		m_Style |= 0xB;
		return CWispWnd::InitWnd();
	}

	WISP_MSG_MAP_BEGIN(CSyserOptionForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
	WISP_MSG_MAP_END(CWispOptionForm)

	bool CSyserOptionForm::OnCreateForm(WISP_MSG *pMsg)
	{
		CWispOptionForm::OnCreateForm(pMsg);
		CWispOptionForm::LoadTexts(0);
		Resize(m_BorderSize*2 + m_WindowRect.cx, m_BorderSize*2 + m_WindowRect.cy + m_CaptionRect.cy, true);
		SetWindowText(WSTR("Option"));
		return false;
	}

	void CSyserOptionForm::OnApply()
	{
		if (ConfigChanged)
		{
			ConfigChanged = 0;
			char szConfig[MAX_FN_LEN];
			GetModulePath(szConfig, true);
			TStrCat(szConfig, "Syser.cfg");
			WriteConfig(szConfig, &gSyserConfig, sizeof(gSyserConfig));
		}

		if (ColorsChanged)
		{
			ColorsChanged = 0;
			char szConfig[MAX_FN_LEN];
			GetModulePath(szConfig, true);
			TStrCat(szConfig, "SyserColor.cfg");
			WriteConfig(szConfig, &gSyserColors, sizeof(gSyserColors));
		}
		gpSyser->m_MainFrame.Update((WISP_RECT*)0);
	}

	bool CSyserOptionForm::OnDefaulting()
	{
		memcpy(&gSyserConfig, &gSyserDefConfig, sizeof(gSyserConfig));
		ConfigChanged = 0;

		memcpy(&gSyserColors, &gSyserDefColors, sizeof(gSyserColors));
		ColorsChanged = 0;

		gpSyser->m_MainFrame.Update((WISP_RECT*)0);
		return true;
	}

	void CSyserOptionForm::OnDefault()
	{
		char szConfig[MAX_FN_LEN];
		GetModulePath(szConfig, true);
		TStrCat(szConfig, "Syser.cfg");
		WriteConfig(szConfig, &gSyserConfig, sizeof(gSyserConfig));

		char szColorConfig[MAX_FN_LEN];
		GetModulePath(szColorConfig, true);
		TStrCat(szColorConfig, "SyserColor.cfg");
		WriteConfig(szColorConfig, &gSyserColors, sizeof(gSyserColors));
	}

```

`source/WispSyser/syseroptionform.hpp`:

```hpp

#ifndef _SYSEROPTIONFORM_HPP_
#define _SYSEROPTIONFORM_HPP_

#include "../Wisp/wispoptionform.hpp"

struct CSyserOptionForm : public CWispOptionForm
{
	CSyserOptionForm();
	virtual ~CSyserOptionForm();
	virtual bool InitWnd() override;
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnCreateForm(WISP_MSG *pMsg);
	virtual void OnApply() override;

        virtual bool OnDefaulting() override;
        virtual void OnDefault() override;
};

#endif
```

`source/WispSyser/syserui.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "syserui.hpp"
#include "../EXEAnalyzer/pefile.hpp"
#include "syserconfig.hpp"
#include "../Code/sysdep.hpp"
#include "../Code/imagefile.hpp"

	CSyserCodeDoc::CSyserCodeDoc()
	{
		AddFunc(":", 3, Reg, this);
	}

	TExpCalc<char,ULONG_PTR,1>::EXPITEM * CSyserCodeDoc::Reg(TListIter<TExpCalc<char,ULONG_PTR,1>::EXPITEM> It, TList<TExpCalc<char,ULONG_PTR,1>::EXPITEM> & Expression, TExpCalc<char,ULONG_PTR,1> *pThis)
	{
		if (!TExpCalc<char,ULONG_PTR,1>::CheckResult(0, It, 1, Expression))
			return nullptr;
		if (It-1 == Expression.End())
			return nullptr;
		TExpCalc<char,ULONG_PTR,1>::EXPITEM *ExpItem = It.Prev();
		for (unsigned long i = 0; i < 5; ++i) //SEG_IDX_MAX lenof(CInstrSym::m_SegStr)
		{
			if (!TStrNICmp(CInstrSym::m_SegStr[i], ExpItem->Str, 2))
			{
				ExpItem->Value = 0;
				gpSyser->m_pDebugger->GetSegRegBase(i, &ExpItem->Value, 0);
				ExpItem->Value += It.Next()->Value;
				TExpCalc<char,ULONG_PTR,1>::RemoveExpr(It, 2, Expression);
				return ExpItem;
			}
		}
		return nullptr;
	}

	void CSyserCodeDoc::InsertX86RegSym(X86_CPU_REG_PTR *pCPURegPtr)
	{
	#ifdef _X64_
		TExpCalc<char,ULONG_PTR,1>::InsertSym("RAX", pCPURegPtr->pCAX, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("RBX", pCPURegPtr->pCBX, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("RCX", pCPURegPtr->pCCX, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("RDX", pCPURegPtr->pCDX, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("RBP", pCPURegPtr->pCBP, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("RSP", pCPURegPtr->pCSP, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("RSI", pCPURegPtr->pCSI, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("RDI", pCPURegPtr->pCDI, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("RIP", pCPURegPtr->pCIP, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R8", pCPURegPtr->pR8, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R9", pCPURegPtr->pR9, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R10", pCPURegPtr->pR10, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R11", pCPURegPtr->pR11, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R12", pCPURegPtr->pR12, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R13", pCPURegPtr->pR13, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R14", pCPURegPtr->pR14, 8);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R15", pCPURegPtr->pR15, 8);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("EAX", pCPURegPtr->pCAX, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EBX", pCPURegPtr->pCBX, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("ECX", pCPURegPtr->pCCX, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EDX", pCPURegPtr->pCDX, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EBP", pCPURegPtr->pCBP, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("ESP", pCPURegPtr->pCSP, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("ESI", pCPURegPtr->pCSI, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EDI", pCPURegPtr->pCDI, 4);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("EIP", pCPURegPtr->pCIP, 4);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("EFLAG", (unsigned long long*)pCPURegPtr->pEFL, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EFL", (unsigned long long*)pCPURegPtr->pEFL, 4);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("R8D", pCPURegPtr->pR8, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R9D", pCPURegPtr->pR9, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R10D", pCPURegPtr->pR10, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R11D", pCPURegPtr->pR11, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R12D", pCPURegPtr->pR12, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R13D", pCPURegPtr->pR13, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R14D", pCPURegPtr->pR14, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R15D", pCPURegPtr->pR15, 4);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("AX", pCPURegPtr->pCAX, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("BX", pCPURegPtr->pCBX, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("CX", pCPURegPtr->pCCX, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("DX", pCPURegPtr->pCDX, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("BP", pCPURegPtr->pCBP, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("SP", pCPURegPtr->pCSP, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("SI", pCPURegPtr->pCSI, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("DI", pCPURegPtr->pCDI, 2);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("IP", pCPURegPtr->pCIP, 2);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("R8W", pCPURegPtr->pR8, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R9W", pCPURegPtr->pR9, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R10W", pCPURegPtr->pR10, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R11W", pCPURegPtr->pR11, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R12W", pCPURegPtr->pR12, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R13W", pCPURegPtr->pR13, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R14W", pCPURegPtr->pR14, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R15W", pCPURegPtr->pR15, 2);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("AH", pCPURegPtr->pCAX + 1, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("BH", pCPURegPtr->pCBX + 1, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("CH", pCPURegPtr->pCCX + 1, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("DH", pCPURegPtr->pCDX + 1, 1);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("AL", pCPURegPtr->pCAX, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("BL", pCPURegPtr->pCBX, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("CL", pCPURegPtr->pCCX, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("DL", pCPURegPtr->pCDX, 1);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("BPL", pCPURegPtr->pCBP, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("SPL", pCPURegPtr->pCSP, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("SIL", pCPURegPtr->pCSI, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("DIL", pCPURegPtr->pCDI, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R8B", pCPURegPtr->pR8, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R9B", pCPURegPtr->pR9, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R10B", pCPURegPtr->pR10, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R11B", pCPURegPtr->pR11, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R12B", pCPURegPtr->pR12, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R13B", pCPURegPtr->pR13, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R14B", pCPURegPtr->pR14, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("R15B", pCPURegPtr->pR15, 1);
	#else
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EAX", pCPURegPtr->pCAX, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EBX", pCPURegPtr->pCBX, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("ECX", pCPURegPtr->pCCX, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EDX", pCPURegPtr->pCDX, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EBP", pCPURegPtr->pCBP, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("ESP", pCPURegPtr->pCSP, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("ESI", pCPURegPtr->pCSI, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EDI", pCPURegPtr->pCDI, 4);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("EIP", pCPURegPtr->pCIP, 4);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("EFLAG", (ULONG_PTR*)pCPURegPtr->pEFL, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("EFL", (ULONG_PTR*)pCPURegPtr->pEFL, 4);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("AX", pCPURegPtr->pCAX, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("BX", pCPURegPtr->pCBX, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("CX", pCPURegPtr->pCCX, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("DX", pCPURegPtr->pCDX, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("BP", pCPURegPtr->pCBP, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("SP", pCPURegPtr->pCSP, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("SI", pCPURegPtr->pCSI, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("DI", pCPURegPtr->pCDI, 2);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("IP", pCPURegPtr->pCIP, 2);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("AH", pCPURegPtr->pCAX + 1, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("BH", pCPURegPtr->pCBX + 1, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("CH", pCPURegPtr->pCCX + 1, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("DH", pCPURegPtr->pCDX + 1, 1);

		TExpCalc<char,ULONG_PTR,1>::InsertSym("AL", pCPURegPtr->pCAX, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("BL", pCPURegPtr->pCBX, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("CL", pCPURegPtr->pCCX, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("DL", pCPURegPtr->pCDX, 1);
	#endif
	}

	bool CSyserCodeDoc::Open(const char *szModule) //04
	{
		if (!gpSyser->m_pDebugger || m_bOpen)
			return false;
		gpSyser->m_SyserUI.m_DebugInterface.Reset();
		if (!gpSyser->m_pDebugger->Open(szModule))
			return false;
		gpSyser->m_pSysDebugger = gpSyser->m_pDebugger;
		CCodeDoc::Open(szModule);
		gpSyser->m_pDebugger->GetX86RegPtr(&m_CPUREGPTR);
		m_ExeFilePath = szModule;
		InsertX86RegSym(&m_CPUREGPTR);
		
		TExpCalc<char,ULONG_PTR,1>::InsertSym("OPCODE", (ULONG_PTR*)&m_OPCODE, 1);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("OPCODE2", (ULONG_PTR*)&m_OPCODE, 2);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("OPCODE3", (ULONG_PTR*)&m_OPCODE, 3);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("OPCODE4", (ULONG_PTR*)&m_OPCODE, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("PID", (ULONG_PTR*)&m_PID, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("TID", (ULONG_PTR*)&m_TID, 4);
		TExpCalc<char,ULONG_PTR,1>::InsertSym("BPCOUNT", (ULONG_PTR*)&m_BPCOUNT, 4);

		for (map<TWideString, SYSER_PLUGIN_MODULE>::IT it = gpSyser->m_PluginMap.begin();
			it != gpSyser->m_PluginMap.end(); ++it)
		{
			if (it->second.fpOnDebuggerOpen)
				it->second.fpOnDebuggerOpen();
		}

		gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();

		gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);

		gpSyser->AddHistory(szModule, 0);

		return true;
	}
	void CSyserCodeDoc::Close()			//08
	{
		if (m_bOpen)
		{
			for (map<TWideString, SYSER_PLUGIN_MODULE>::IT it = gpSyser->m_PluginMap.begin();
				it != gpSyser->m_PluginMap.end(); ++it)
			{
				if (it->second.fpOnDebuggerClose)
					it->second.fpOnDebuggerClose();
			}

			if (gpSyser->m_pDebugger)
				gpSyser->m_pDebugger->Close();

			for (map<FILESIG, CSDSModule>::IT it = gpSyser->m_SyserUI.m_SDSModulesMap.begin();
				it != gpSyser->m_SyserUI.m_SDSModulesMap.end();++it)
			{
				gpSyser->m_SyserUI.UnloadSDSModule(&it->second);
			}

			TExpCalc<char,ULONG_PTR,1>::Reset();

			CCodeDoc::Close();

			if (gpSyser->m_bActive && gpSyser->m_MainFrame.IsWindow())
			{
				gpSyser->m_MainFrame.m_SystemExplorer.ResetContext();
				gpSyser->m_MainFrame.m_SystemExplorer.UpdateMenu();
				gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateMenu();
				gpSyser->m_MainFrame.Update(&gpSyser->m_MainFrame.m_ClientRect);
				gpSyser->m_MainFrame.m_StaticText.SetWindowText(WSTR(""));
			}

			memset(&m_CPUREGPTR, 0, sizeof(m_CPUREGPTR));

			//m_ExeFilePath.Empty(); //???
		}
	}
	unsigned long CSyserCodeDoc::ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) //0C
	{
		if (!m_bOpen)
			return 0;

		unsigned long Len = gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size);
		if (Len)
		{
			if (!gSyserConfig.iShowCCByte && Size)
			{
				for (unsigned long i = 0; i < Size; ++i)
				{
					if (static_cast<unsigned char *>(Buffer)[i] == 0xCC)
					{
						BREAK_POINT *BreakPoint = gpSyser->m_pDebugger->GetCodeBP(Address+i, 0, 0);
						if (BreakPoint && BreakPoint->State == BP_STATE_ENABLE)
							static_cast<unsigned char *>(Buffer)[i] = BreakPoint->CCBackup;
					}
				}
			}
		}
		return Len;
	}
	ULONG_PTR CSyserCodeDoc::GetInstrAddress(ULONG_PTR Address, long Count) //10
	{
		if (Count < 0)
		{
			Count = -Count;
			do {
				unsigned long Len = CInstrSym::PrevInstrLen(Address);
				MIN_LIMIT(Len, 1);
				Address -= Len;
				--Count;
			} while (Count);
		} else
		if (Count > 0)
		{
			Count = Count;
			do {
				unsigned long Len = CInstrSym::InstrLen(Address, MAX_INSTR_LEN);
				MIN_LIMIT(Len, 1);
				Address += Len;
				--Count;
			} while (Count);
		}
		return Address;
	}

	bool CSyserCodeDoc::GetSymbol(ULONG_PTR Address, WCHAR *szName, int Length) //14
	{
		char Buffer[256];
		if (gpSyser->m_SyserUI.GetSymbol(Address, Buffer, 256))
		{
			AnsiToUnicode(Buffer, szName, Length);
			return true;
		}
		return false;
	}
	bool CSyserCodeDoc::GetComment(ULONG_PTR Address, WCHAR *szName, int Length) //18
	{
		if (!m_bOpen)
			return false;
		const char *pStr = gpSyser->m_pDebugger->m_DbgModuleList.GetComment(Address);
		if (!pStr)
		{
			if (gpSyser->m_pDebugger == gpSyser->m_pSysDebugger)
				return false;
			pStr = gpSyser->m_pSysDebugger->m_DbgModuleList.GetComment(Address);
			if (!pStr)
				return false;
		}
		TStrCpyLimit(szName, pStr, Length);
		return true;
	}
	bool CSyserCodeDoc::SetComment(ULONG_PTR Address, const WCHAR *szName) //1C
	{
		if (!m_bOpen)
			return false;
		CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Address);
		if (!pDbgMod)
			return false;
		if (!pDbgMod->m_pCommentModule && !gpSyser->m_SyserUI.m_CommentContainer.FindModule(pDbgMod->m_TimeStamp, pDbgMod->m_CheckSum))
		{
			CCommentModule *cmod = gpSyser->m_SyserUI.m_CommentContainer.InsertModule(pDbgMod->m_TimeStamp, pDbgMod->m_CheckSum);
			if (!cmod)
				return false;
			cmod->m_ModuleName = pDbgMod->m_FullFileName.operator const char*(); //???
			gpSyser->m_SyserUI.SetCommentModule(cmod);
		}
		char Buffer[128];
		UnicodeToAnsi(szName, Buffer, lenof(Buffer));
		if (!pDbgMod->m_pCommentModule)
			return false;
		return pDbgMod->m_pCommentModule->Set(Address - pDbgMod->m_ImageBase, Buffer);
	}

	//bool CSyserCodeDoc::GetFunction(ULONG_PTR Address, WCHAR *szName, int Length) //20

	unsigned long CSyserCodeDoc::GetPic(ULONG_PTR Address) //24
	{
		unsigned long Type = 0;
		if (!m_bOpen)
			return Type;

		if (Address == *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP)
			Type |= 1;

		BREAK_POINT *BreakPoint = gpSyser->m_pDebugger->GetCodeBP(Address, 0, 0x300);
		if (BreakPoint)
		{
			if (BreakPoint->State == BP_STATE_ENABLE)
				Type |= 2;
			else
			if (BreakPoint->State == BP_STATE_RECOV)
				Type |= 2;
			else
			if (BreakPoint->State == BP_STATE_DISABLE)
				Type |= 4;
			
		} else
		{
			map<ULONG_PTR, BREAK_POINT::MODULE>::IT it = gpSyser->m_SyserUI.m_ModuleBPMap.find(Address);
			if (it != gpSyser->m_SyserUI.m_ModuleBPMap.end())
				Type |= (it->second.State == BP_STATE_DISABLE) ? 4:2;
		}

		if (gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.IsBM(Address))
			Type |= 8;

		return Type;
	}

	bool CSyserCodeDoc::AddrToSym(ULONG_PTR Address, char *szSym, unsigned int SymLen)
	{
		return gpSyser->m_SyserUI.GetSymbol(Address, szSym, SymLen);
	}

	bool CSyserCodeDoc::GetSymbolBase(ULONG_PTR *BaseAddr)
	{
		if (gpSyser->m_pDebugger->m_DbgModuleList.GetSymbolBase(BaseAddr))
			return true;
		if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger)
		{
			if (gpSyser->m_pSysDebugger->m_DbgModuleList.GetSymbolBase(BaseAddr))
				return true;
		}
		return false;
	}

	bool CSyserCodeDoc::GetValue(const char *szItem, ULONG_PTR *pValue) const
	{
	//	if (!gpSyser->m_pDebugger)
	//		return false;

		if (TExpCalc<char,ULONG_PTR,1>::GetValue(szItem, pValue))
			return true;

		if (!gpSyser->m_pDebugger)
			return false;

		if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger)
		{
			for (map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
				it != gpSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.end(); ++it)
			{
				if (it->second.GetSymboBaseAddr(szItem, pValue))
					return true;
			}
		}

			for (map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
				it != gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.end(); ++it)
			{
				if (it->second.GetSymboBaseAddr(szItem, pValue))
					return true;
			}

		for (map<unsigned long long, CSymbolModule>::IT it = gpSyser->m_SyserUI.m_SymbolContainer.m_SymbolModulesMap.begin();
			it; ++it)
		{
			if (it->second.m_ImageBase && it->second.GetAddr(szItem, pValue))
				return true;
		}
		return false;
	}

	ULONG_PTR CSyserCodeDoc::ReadValue(ULONG_PTR Address)
	{
		ULONG_PTR Value = 0;
		//CSyserCodeDoc::
		ReadMemory(Address, &Value, sizeof(Value)); //???
		return Value;
	}

	void CSyserCodeDoc::OnTestCondition()
	{
		if (gpSyser->m_pDebugger->ReadMemory(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP, &m_OPCODE, 4) != 4)
			m_OPCODE = -1;
	}

	void CSyserCodeDoc::GetInstrInfo(WCHAR *pStr)
	{
		if (m_bOpen)
		{
			gpSyser->m_pDebugger->SaveRegisters();
			X86_CPU_REG_PTR CpuReg;
			gpSyser->m_pDebugger->GetX86RegPtr(&CpuReg);
			DIS_CPU DisCPU;

		#ifdef _X64_
			DisCPU.gen_reg[EAX_IDX].rerx = *CpuReg.pCAX;
			DisCPU.gen_reg[EBX_IDX].rerx = *CpuReg.pCBX;
			DisCPU.gen_reg[ECX_IDX].rerx = *CpuReg.pCCX;
			DisCPU.gen_reg[EDX_IDX].rerx = *CpuReg.pCDX;
			DisCPU.gen_reg[ESI_IDX].rerx = *CpuReg.pCSI;
			DisCPU.gen_reg[EDI_IDX].rerx = *CpuReg.pCDI;
			DisCPU.gen_reg[EBP_IDX].rerx = *CpuReg.pCBP;
			DisCPU.gen_reg[ESP_IDX].rerx = *CpuReg.pCSP;
			DisCPU.gen_reg[R8_IDX].rerx = *CpuReg.pR8;
			DisCPU.gen_reg[R9_IDX].rerx = *CpuReg.pR9;
			DisCPU.gen_reg[R10_IDX].rerx = *CpuReg.pR10;
			DisCPU.gen_reg[R11_IDX].rerx = *CpuReg.pR11;
			DisCPU.gen_reg[R12_IDX].rerx = *CpuReg.pR12;
			DisCPU.gen_reg[R13_IDX].rerx = *CpuReg.pR13;
			DisCPU.gen_reg[R14_IDX].rerx = *CpuReg.pR14;
			DisCPU.gen_reg[R15_IDX].rerx = *CpuReg.pR15;
		#else
			DisCPU.gen_reg[EAX_IDX].rerx = *CpuReg.pCAX;
			DisCPU.gen_reg[EBX_IDX].rerx = *CpuReg.pCBX;
			DisCPU.gen_reg[ECX_IDX].rerx = *CpuReg.pCCX;
			DisCPU.gen_reg[EDX_IDX].rerx = *CpuReg.pCDX;
			DisCPU.gen_reg[ESI_IDX].rerx = *CpuReg.pCSI;
			DisCPU.gen_reg[EDI_IDX].rerx = *CpuReg.pCDI;
			DisCPU.gen_reg[EBP_IDX].rerx = *CpuReg.pCBP;
			DisCPU.gen_reg[ESP_IDX].rerx = *CpuReg.pCSP;
		#endif
			//DisCPU.EFL = *CpuReg.pEFL;

			DisCPU.SEG_BASE[CS_IDX] = 0;
			DisCPU.SEG_BASE[DS_IDX] = 0;
			DisCPU.SEG_BASE[ES_IDX] = 0;
			DisCPU.SEG_BASE[FS_IDX] = 0;
			DisCPU.SEG_BASE[GS_IDX] = 0;
			DisCPU.SEG_BASE[SS_IDX] = 0;

			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pCS, &DisCPU.SEG_BASE[CS_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pDS, &DisCPU.SEG_BASE[DS_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pES, &DisCPU.SEG_BASE[ES_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pFS, &DisCPU.SEG_BASE[FS_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pGS, &DisCPU.SEG_BASE[GS_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pSS, &DisCPU.SEG_BASE[SS_IDX], 0);

			_INSTRUCTION_INFORMATION InstInfo;
			unsigned char CodeBuff[256];

			InstInfo.CodeBuff = CodeBuff;
			InstInfo.CodeMode = gpSyser->m_pDebugger->m_CodeMode;
			InstInfo.pasm = nullptr;
			InstInfo.eip = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP;

			CInstrSym::Dasm(&InstInfo, &DisCPU, MAX_INSTR_LEN);

			pStr[0] = 0;
			for (int i = 0; i < 3; ++i)
			{
				if (InstInfo.op[i].mode == OP_Address)
				{
					CInstrSym::OptItemSymToCS(&InstInfo.op[i], pStr, &InstInfo);
				}
			}
		}
	}

	unsigned long CSyserCodeDoc::ReadColorString(ULONG_PTR Address, unsigned long *pColorString, unsigned long MaxSize)
	{
		WCHAR Buffer[256];
		char Encode;
		if (gpSyser->m_SyserUI.ReadString(Address, Buffer, 256, &Encode))
		{
			if (Encode == 0)
				return ColorStrCat(pColorString, Buffer, 6, 0);
			else
			if (Encode == 1)
				return ColorStrCat(pColorString, Buffer, 9, 0);
			return 0;
		}

		char szSym[64+64]; //???
		if (AddrToSym(Address, szSym, 64))
		{
			return ColorStrCat(pColorString, szSym, 1, 0);
		}
		return 0;
	}

	void CSyserCodeDoc::ContextCS(unsigned long *pColorString, int MaxLen)
	{
		if (m_bOpen)
		{
			gpSyser->m_pDebugger->SaveRegisters();
			X86_CPU_REG_PTR CpuReg;
			gpSyser->m_pDebugger->GetX86RegPtr(&CpuReg);
			DIS_CPU DisCPU;

		#ifdef _X64_
			DisCPU.gen_reg[EAX_IDX].rerx = *CpuReg.pCAX;
			DisCPU.gen_reg[EBX_IDX].rerx = *CpuReg.pCBX;
			DisCPU.gen_reg[ECX_IDX].rerx = *CpuReg.pCCX;
			DisCPU.gen_reg[EDX_IDX].rerx = *CpuReg.pCDX;
			DisCPU.gen_reg[ESI_IDX].rerx = *CpuReg.pCSI;
			DisCPU.gen_reg[EDI_IDX].rerx = *CpuReg.pCDI;
			DisCPU.gen_reg[EBP_IDX].rerx = *CpuReg.pCBP;
			DisCPU.gen_reg[ESP_IDX].rerx = *CpuReg.pCSP;
			DisCPU.gen_reg[R8_IDX].rerx = *CpuReg.pR8;
			DisCPU.gen_reg[R9_IDX].rerx = *CpuReg.pR9;
			DisCPU.gen_reg[R10_IDX].rerx = *CpuReg.pR10;
			DisCPU.gen_reg[R11_IDX].rerx = *CpuReg.pR11;
			DisCPU.gen_reg[R12_IDX].rerx = *CpuReg.pR12;
			DisCPU.gen_reg[R13_IDX].rerx = *CpuReg.pR13;
			DisCPU.gen_reg[R14_IDX].rerx = *CpuReg.pR14;
			DisCPU.gen_reg[R15_IDX].rerx = *CpuReg.pR15;
		#else
			DisCPU.gen_reg[EAX_IDX].rerx = *CpuReg.pCAX;
			DisCPU.gen_reg[EBX_IDX].rerx = *CpuReg.pCBX;
			DisCPU.gen_reg[ECX_IDX].rerx = *CpuReg.pCCX;
			DisCPU.gen_reg[EDX_IDX].rerx = *CpuReg.pCDX;
			DisCPU.gen_reg[ESI_IDX].rerx = *CpuReg.pCSI;
			DisCPU.gen_reg[EDI_IDX].rerx = *CpuReg.pCDI;
			DisCPU.gen_reg[EBP_IDX].rerx = *CpuReg.pCBP;
			DisCPU.gen_reg[ESP_IDX].rerx = *CpuReg.pCSP;
		#endif
			//DisCPU.EFL = *CpuReg.pEFL;

			DisCPU.SEG_BASE[CS_IDX] = 0;
			DisCPU.SEG_BASE[DS_IDX] = 0;
			DisCPU.SEG_BASE[ES_IDX] = 0;
			DisCPU.SEG_BASE[FS_IDX] = 0;
			DisCPU.SEG_BASE[GS_IDX] = 0;
			DisCPU.SEG_BASE[SS_IDX] = 0;

			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pCS, &DisCPU.SEG_BASE[CS_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pDS, &DisCPU.SEG_BASE[DS_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pES, &DisCPU.SEG_BASE[ES_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pFS, &DisCPU.SEG_BASE[FS_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pGS, &DisCPU.SEG_BASE[GS_IDX], 0);
			gpSyser->m_pDebugger->GetSegRegBase(*CpuReg.pSS, &DisCPU.SEG_BASE[SS_IDX], 0);

			_INSTRUCTION_INFORMATION InstInfo;
			unsigned char CodeBuff[256];

			InstInfo.CodeBuff = CodeBuff;
			InstInfo.CodeMode = gpSyser->m_pDebugger->m_CodeMode;
			InstInfo.pasm = nullptr;
			InstInfo.eip = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP;

			CInstrSym::Dasm(&InstInfo, &DisCPU, MAX_INSTR_LEN);

			pColorString[0] = 0;
			for (int i = 0; i < 3; ++i)
			{
				if (InstInfo.op[i].mode == OP_Address)
				{
					ReadColorString(InstInfo.op[i].addr.line_address, pColorString, MaxLen);
				} else
				if (InstInfo.op[i].mode == OP_Register)
				{
					switch (InstInfo.op[i].reg.reg_index)
					{
				#ifdef _X64_
					case EAX_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCAX, pColorString, MaxLen); break;
					case ECX_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCCX, pColorString, MaxLen); break;
					case EDX_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDX, pColorString, MaxLen); break;
					case EBX_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBX, pColorString, MaxLen); break;
					case ESP_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP, pColorString, MaxLen); break;
					case EBP_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP, pColorString, MaxLen); break;
					case ESI_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSI, pColorString, MaxLen); break;
					case EDI_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDI, pColorString, MaxLen); break;

					case R8_IDX:  ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR8,  pColorString, MaxLen); break;
					case R9_IDX:  ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR9,  pColorString, MaxLen); break;
					case R10_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR10, pColorString, MaxLen); break;
					case R11_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR11, pColorString, MaxLen); break;
					case R12_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR12, pColorString, MaxLen); break;
					case R13_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR13, pColorString, MaxLen); break;
					case R14_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR14, pColorString, MaxLen); break;
					case R15_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pR15, pColorString, MaxLen); break;
				#else
					case EAX_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCAX, pColorString, MaxLen); break;
					case ECX_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCCX, pColorString, MaxLen); break;
					case EDX_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDX, pColorString, MaxLen); break;
					case EBX_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBX, pColorString, MaxLen); break;
					case ESP_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP, pColorString, MaxLen); break;
					case EBP_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP, pColorString, MaxLen); break;
					case ESI_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSI, pColorString, MaxLen); break;
					case EDI_IDX: ReadColorString(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDI, pColorString, MaxLen); break;
				#endif
					}
				}
			}
		}
	}

	bool CSyserCodeDoc::IsDasm(ULONG_PTR Address, unsigned long Size)
	{
		unsigned long i = 0;
		while (i < Size)
		{
			if (Address+i == *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP)
				return true;
			unsigned long Len = CInstrSym::InstrLen(Address+i, MAX_INSTR_LEN);
			MIN_LIMIT(Len, 1);
			i += Len;
		}
		return false;
	}
// DI
	void CSyserDI::OnLoadModule(CDebugger *pDebugger, const char *szName, ULONG_PTR ImageBase, unsigned long ImageSize, unsigned long TimeStamp, unsigned long CheckSum)
	{
		CDbgModule *pDbgMod = pDebugger->m_DbgModuleList.InsertModule(szName, ImageBase, ImageSize, TimeStamp, CheckSum);
		if (pDbgMod)
		{
			CCommentModule *cmod = m_pCommentContainer->FindModule(TimeStamp, CheckSum);
			if (cmod)
				pDbgMod->SetCommentModule(cmod);

			CSymbolModule *pSymMod = m_pSymbolContainer->FindModule(TimeStamp, CheckSum);
			if (pSymMod)
			{
				pDbgMod->SetSymbolModule(pSymMod);
			} else
			{
				//TODO IsExist PDB, callback for allow to load
				//gpSyser->m_SyserUI.LoadPDBSym(szName, ImageBase, ImageSize); //delay load pdb on plunge
				//gpSyser->m_SyserUI.LoadPESym(szName, pDbgMod);
			}
		}
	}
	void CSyserDI::OnUnloadModule(CDebugger *pDebugger, ULONG_PTR ImageBase)
	{
		CDbgModule *pDbgMod = pDebugger->m_DbgModuleList.FindModule(ImageBase);
		if (pDbgMod)
		{
		//#ifdef _RING0_
			CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(pDbgMod->m_ImageBase);
			if (pSDSMod
				)
				gpSyser->m_SyserUI.UnloadSDSModule(pSDSMod);
		//#endif
			map<unsigned long long, BREAK_POINT>::IT it = pDebugger->m_pCodeBPMap->begin();
			//while (it != pDebugger->m_pCodeBPMap->end())
			while (it)
			{
				if (pDebugger->m_dwProcessId == it->second.ProcessID &&
					it->second.Address >= pDbgMod->m_ImageBase &&
					it->second.Address <= pDbgMod->m_ImageBase + pDbgMod->m_ImageSize)
				{
					map<unsigned long long, BREAK_POINT>::IT p = it;
					p->second.State = BP_STATE_DISABLE;
					++it; //???
					pDebugger->DelCodeBP(p->second); //???
				} else
				{
					++it;
				}
			}
			pDebugger->m_DbgModuleList.RemoveModule(pDbgMod->m_ImageBase);
		}
	}
	void CSyserDI::OnTestCondition()
	{
		gpSyser->m_SyserUI.m_SyserCodeDoc.OnTestCondition();
	}

	bool CSyserDI::Close(bool bExit)
	{
		if (bExit)
		{
			gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("close"), 0);
		} else
		{
			gpSyser->m_MainFrame.m_SystemExplorer.ViewCodeAddress(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP);
			gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
		}
		return true;
	}
	bool CSyserDI::Plunge(unsigned int Code)
	{
		if (!gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
			return false;

		gpSyser->m_PID = gpSyser->m_pDebugger->m_dwProcessId;
		gpSyser->m_TID = gpSyser->m_pDebugger->m_dwThreadId;

		gpSyser->m_SyserUI.m_SyserCodeDoc.m_PID = gpSyser->m_pDebugger->m_dwProcessId;
		gpSyser->m_SyserUI.m_SyserCodeDoc.m_TID = gpSyser->m_pDebugger->m_dwThreadId;

		gpSyser->m_MainFrame.m_MainTabWnd.SetActiveWnd(gSyserConfig.iFollowMode == SRC_TAB ? SRC_TAB : CV_TAB); //SRC_TAB(2) CV_TAB(0)
		gpSyser->m_MainFrame.m_SystemExplorer.ViewCodeAddress(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP);
		gpSyser->m_MainFrame.m_SystemExplorer.UpdateRegView();
	//+++

		for (map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
			it != gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.end(); ++it)
		{
			if (it->second.m_LoadPDB)
			{
				it->second.m_LoadPDB = false;
				gpSyser->m_SyserUI.LoadPDBSym(it->second.m_FullFileName.operator const char*(), it->second.m_ImageBase, it->second.m_ImageSize); //delay load pdb on plunge
				gpSyser->m_SyserUI.LoadPESym(it->second.m_FullFileName.operator const char*(), &it->second);
			}
		}

		UpdateContext();

		for (map<TWideString, SYSER_PLUGIN_MODULE>::IT it = gpSyser->m_PluginMap.begin();
			it != gpSyser->m_PluginMap.end(); ++it)
		{
			if (it->second.fpOnDebuggerPlunge)
				it->second.fpOnDebuggerPlunge();
		}
		gpSyser->m_MainFrame.FocusActive();
		return true;
	}

	bool CSyserDI::OnExit(bool bExit)
	{
		WISP_MSG Msg;
		Msg.hWnd = &gpSyser->m_MainFrame;
		Msg.bExit = bExit;
		Msg.Msg = 31; //Close
		gpSyser->PostMessage(&Msg);
		return true;
	}
	bool CSyserDI::OnDebugException(unsigned int Code)
	{
		WISP_MSG Msg;
		Msg.hWnd = &gpSyser->m_MainFrame;
		Msg.Code = Code;
		Msg.Msg = 30; //Plunge
		gpSyser->PostMessage(&Msg);
		return true;
	}

	void CSyserDI::DisplayMsg(const char *szMsg)
	{
		WCHAR Buffer[512];
		AnsiToUnicode(szMsg, Buffer, lenof(Buffer));
		gpSyser->m_MainFrame.m_SystemExplorer.m_TerminalWnd.OutPut(Buffer);
	}
	void CSyserDI::UpdateContext()
	{
		gpSyser->m_MainFrame.m_SystemExplorer.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(true);

		gpSyser->m_SyserUI.m_CallStack.UpdateContext(0);
		gpSyser->m_MainFrame.m_CallStackWnd.UpdateContext();
	}
	bool CSyserDI::TestCondition(const char *Condition, BREAK_POINT *pBP)
	{
		if (!Condition[0])
			return true;
		if (pBP) gpSyser->m_SyserUI.m_SyserCodeDoc.m_BPCOUNT = pBP->HitCount;
		ULONG_PTR Result;
		return gpSyser->m_SyserUI.m_SyserCodeDoc.CalcExpression(Condition, &Result) && Result;
	}
	bool CSyserDI::RunCmd(const char *szCmd)
	{
		WCHAR Buffer[256];
		AnsiToUnicode(szCmd, Buffer, lenof(Buffer));
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(Buffer, 0);
		return true;
	}
	void CSyserDI::RunCmds(const char *szCmds)
	{
		if (szCmds[0])
		{
			WCHAR Buffer[1024];
			AnsiToUnicode(szCmds, Buffer, lenof(Buffer));
			gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmds(Buffer, ';');
		}
	}

	CDebugger *CSyserDI::GetDebugger()
	{
		return gpSyser->m_pDebugger;
	}

//STACK
	CCallStack::CCallStack()
	{
		m_Address = 0;
	}

	void CCallStack::UpdateContext(ULONG_PTR Address)
	{
		m_HeadIt.Reset(); //??? move under m_Address != Address
#if 0
		if (Address == 0)
			Address = gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP?*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP:0;

		if (m_Address != Address)
		{
			m_Address = Address;
			m_Frames.Clear();

			//gpSyser->m_pDebugger->InitGetStack(Address); //TODO frame.AddrStack.Offset = Address
			gpSyser->m_pDebugger->SaveRegisters();
			for(ULONG nFrame = 0; nFrame < 256; nFrame++)
			{
				STACK_FRAME StackFrame;

				if (!gpSyser->m_pDebugger->GetStack(&StackFrame)) break;

				if (StackFrame.AddrPC == StackFrame.AddrReturn) break;
				if (StackFrame.AddrPC == 0) break;
				if (StackFrame.AddrReturn == 0) break;

				if (StackFrame.AddrPC)
				{
					char szFuncName[64];
					ULONG_PTR Addr;
					if (gpSyser->m_SyserUI.m_SyserCodeDoc.GetCall(StackFrame.AddrReturn, szFuncName, &Addr))
					{
						if (!szFuncName[0])
						{
							CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Addr);
							if (!pDbgMod)
							{
								if (gpSyser->m_pSysDebugger != gpSyser->m_pDebugger)
									pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(Addr);
							}

							if (pDbgMod)
							{
								unsigned long Offset = Addr - pDbgMod->m_ImageBase;
								TSPrintf(szFuncName, "%s+0x%X", pDbgMod->m_FileTitle.operator const char*(), Offset);
							} else
							{
								TSPrintf(szFuncName, "unknown_function");
							}
						}
						TListIter<Frame> It = m_Frames.Append();
						It->Address = StackFrame.AddrFrame;//Address; //Frame
						It->Return = StackFrame.AddrReturn;
						It->FuncAddr = Addr;
						It->FuncName = szFuncName;
					}
		#if 0
			gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("%2d from %016X   STACK %016X    FRAME %016X    RET %016X %s\n"),
					nFrame,
					StackFrame.AddrPC,//.Offset,
					StackFrame.AddrStack,//.Offset,
					StackFrame.AddrFrame,//.Offset,
					StackFrame.AddrReturn,//.Offset,
					WSTR(""));//name);
		#endif
				} else
				{
					//break;
				}
				if (StackFrame.AddrReturn == 0) break;
			}

			if (m_Frames.Size())
				m_HeadIt = m_Frames.Begin();

		}
#endif
#ifndef _X64_
		if (Address == 0)
			Address = gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP?*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP:0;

		if (m_Address != Address)
		{
			m_Address = Address;
			m_Frames.Clear();
			for (int i = 0; i < 256; ++i)
			{
				ULONG_PTR Mem[2];
				if (gpSyser->m_pDebugger->ReadMemory(Address, Mem, sizeof(Mem)) != sizeof(Mem) || Mem[0] <= Address)
					break;
				char szFuncName[64];
				ULONG_PTR Addr;
				if (gpSyser->m_SyserUI.m_SyserCodeDoc.GetCall(Mem[1], szFuncName, &Addr))
				{
					if (!szFuncName[0])
					{
						CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(Addr);
						if (!pDbgMod)
						{
							if (gpSyser->m_pSysDebugger != gpSyser->m_pDebugger)
								pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(Addr);
						}

						if (pDbgMod)
						{
							unsigned long Offset = Addr - pDbgMod->m_ImageBase;
							TSPrintf(szFuncName, "%s+0x%X", pDbgMod->m_FileTitle.operator const char*(), Offset);
						} else
						{
							TSPrintf(szFuncName, "unknown_function");
						}
					}
					TListIter<Frame> It = m_Frames.Append();
					It->Address = Address; //Frame
					It->Return = Mem[1];
					It->FuncAddr = Addr;
					It->FuncName = szFuncName;
				}
				Address = Mem[0];
			}

			if (m_Frames.Size())
				m_HeadIt = m_Frames.Begin();
		}
#endif
	}

// UI
	bool CSyserUI::RegisterPluginModule(const WCHAR *ModuleName, SYSER_PLUGIN_MODULE *pPluginModule)
	{
		map<TWideString, SYSER_PLUGIN_MODULE>::IT it = gpSyser->m_PluginMap.insert(_Tmap_pair<const WCHAR*,SYSER_PLUGIN_MODULE>(ModuleName,SYSER_PLUGIN_MODULE()));
		if (it == gpSyser->m_PluginMap.end())
			return false;
		it->second = *pPluginModule;
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Syser : Register Plugin Module %s (%s)\n"), ModuleName, pPluginModule->PluginInfo);
		return true;
	}
	bool CSyserUI::UnregisterPluginModule(const WCHAR *ModuleName)
	{
		map<TWideString, SYSER_PLUGIN_MODULE>::IT it = gpSyser->m_PluginMap.find(ModuleName);
		if (it == gpSyser->m_PluginMap.end())
			return false;
		gpSyser->m_PluginMap.erase(it);
		gpSyser->m_MainFrame.m_ConsoleWnd.Printf(WSTR("Syser : Unregister Plugin Module %s\n"), ModuleName);
		return true;
	}

	int CSyserUI::GetInstrLen(ULONG_PTR Address)
	{
		return m_SyserCodeDoc.InstrLen(Address, MAX_INSTR_LEN);
	}

	bool CSyserUI::CalcExp(const char *szExp, ULONG_PTR *pResult)
	{
		return m_SyserCodeDoc.CalcExpression(szExp, pResult);
	}

	bool CSyserUI::CalcExp(const WCHAR *szExp, ULONG_PTR *pResult)
	{
		if (!szExp) return false;
		char Buffer[256];
		UnicodeToAnsi(szExp, Buffer, lenof(Buffer));
		return m_SyserCodeDoc.CalcExpression(Buffer, pResult);
	}

	bool CSyserUI::InsertCmd(const WCHAR *szCmd, FPCmd pCmdProc, void *pUserData, const WCHAR *pComment, const WCHAR *pUsage)
	{
		return gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::InsertCmd(szCmd, (CMDPROC)pCmdProc, pUserData, pComment, pUsage);
	}
	void CSyserUI::RemoveCmd(const WCHAR *szCmd)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::RemoveCmd(szCmd);
	}
	int CSyserUI::RunCmd(const WCHAR *szCmd)
	{
		return gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(szCmd, 0);
	}

	void CSyserUI::Outputf(const WCHAR *szFormat, ...)
	{
		va_list va;
		va_start(va, szFormat);
		gpSyser->m_MainFrame.m_ConsoleWnd.VPrintf(szFormat, va); //return Length TODO
		va_end(va);
	}
	void CSyserUI::Output(const unsigned long *szMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.OutPut(szMsg);
	}

	void *CSyserUI::InsertMenu(void *hParentMenu, const WCHAR *szMenuName, FPMenuProc fpMenuProc)
	{
		CWispMenu::MenuItem *Item = gpSyser->m_MainFrame.m_SystemExplorer.m_MainMenu.GetItem(WSTR("Plugin"));
		if (!Item)
			return nullptr;
		CWispMenu *Menu = gpSyser->m_MainFrame.m_SystemExplorer.m_MainMenu.GetMenu(Item);
		if (!Menu)
			return nullptr;
		CWispMenu::MenuItem *r = Menu->AppendMenu(-1, szMenuName, 0, 0, 0, (unsigned long long)fpMenuProc);
		Menu->Adjust();
		return r;
	}
	bool CSyserUI::RemoveMenu(void *hMenu)
	{
		CWispMenu::MenuItem *Item = gpSyser->m_MainFrame.m_SystemExplorer.m_MainMenu.GetItem(WSTR("Plugin"));
		if (!Item)
			return false;
		CWispMenu *Menu = gpSyser->m_MainFrame.m_SystemExplorer.m_MainMenu.GetMenu(Item);
		if (!Menu)
			return false;
		bool r = Menu->RemoveMenu((CWispMenu::MenuItem *)hMenu);
		Menu->Adjust();
		return r;
	}
	bool CSyserUI::EnableMenu(void *hMenu, bool bEnable)
	{
		return gpSyser->m_MainFrame.m_SystemExplorer.m_MainMenu.GetMenu((CWispMenu::MenuItem *)hMenu)->Enable((CWispMenu::MenuItem *)hMenu, bEnable);
	}

	void *CSyserUI::GetMainTabWnd()
	{
		return &gpSyser->m_MainFrame.m_MainTabWnd;
	}
	void *CSyserUI::GetMainMenu()
	{
		return &gpSyser->m_MainFrame.m_SystemExplorer.m_MainMenu;
	}
	void *CSyserUI::GetWisp()
	{
		return gpCurWisp;
	}

	unsigned long CSyserUI::WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size)
	{
		if (gpSyser && gpSyser->m_pDebugger && Size && Buffer)
			return gpSyser->m_pDebugger->WriteMemory(Address, Buffer, Size);
		return 0;
	}
	unsigned long CSyserUI::ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size)
	{
		if (gpSyser && gpSyser->m_pDebugger && Size && Buffer)
			return gpSyser->m_pDebugger->ReadMemory(Address, Buffer, Size);
		return 0;
	}

	bool CSyserUI::ReadUString(ULONG_PTR Address, WCHAR *pString, unsigned long Size)
	{
		char Buffer[256];
		char UBuffer[256*2];
		unsigned long Len = m_SyserCodeDoc.ReadMemory(Address, Buffer, 256);
		unsigned long RLen;
		if (Len >= 10 && UNormalize(Buffer, Len, UBuffer, 256*2, &RLen))
		{
			int PrefixLen = TStrCpy(pString, "UNICODE \"");
			TStrCpyLimit(&pString[PrefixLen], (WCHAR*)UBuffer, Size - PrefixLen - 1);
			TStrCat(pString, "\"");
			return true;
		}
		return false;
	}

	bool CSyserUI::ReadAString(ULONG_PTR Address, char *pString, unsigned long Size)
	{
		char Buffer[256];
		char ABuffer[256];
		unsigned long Len = m_SyserCodeDoc.ReadMemory(Address, Buffer, 256);
		unsigned long RLen;
		if (Len >= 10 && ANormalize(Buffer, Len, ABuffer, 256, &RLen))
		{
			int PrefixLen = TStrCpy(pString, "ASCII \"");
			TStrCpyLimit(&pString[PrefixLen], ABuffer, Size - PrefixLen - 1);
			TStrCat(pString, "\"");
			return true;
		}
		return false;

	}

	bool CSyserUI::ReadString(ULONG_PTR Address, WCHAR *pString, unsigned long Size, char *Encode)
	{
		if (ReadUString(Address, pString, Size))
		{
			*Encode = 1;
			return true;
		}

		char AString[256];
		if (ReadAString(Address, AString, 256))
		{
			TStrCpyLimit(pString, AString, Size); //???
			AnsiToUnicode(AString, pString, Size); //???
			*Encode = 0;
			return true;
		}
		return false;
	}

	bool CSyserUI::GetSymbol(ULONG_PTR Address, char *szName, int Length)
	{
		if (!gpSyser->m_pDebugger)
			return false;

		if (gSyserConfig.iShowFullSym)
		{
			if (gpSyser->m_pDebugger->m_DbgModuleList.GetFullSymbol(Address, szName, Length))
				return true;
			
			if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger && gpSyser->m_pSysDebugger)
			{
				if (gpSyser->m_pSysDebugger->m_DbgModuleList.GetFullSymbol(Address, szName, Length))
					return true;
			}

			if (gpSyser->m_SyserUI.m_SymbolContainer.GetFullSymbol(Address, szName, Length))
				return true;
			return false;
		}
		
		const char *pStr = gpSyser->m_pDebugger->m_DbgModuleList.GetSymbol(Address);
		if (pStr)
		{
			TStrCpyLimit(szName, pStr, Length);
			return true;
		}

		if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger && gpSyser->m_pSysDebugger)
		{
			pStr = gpSyser->m_pSysDebugger->m_DbgModuleList.GetSymbol(Address);
			if (pStr)
			{
				TStrCpyLimit(szName, pStr, Length);
				return true;
			}
		}

		pStr = gpSyser->m_SyserUI.m_SymbolContainer.GetSymbol(Address);
		if (pStr)
		{
			TStrCpyLimit(szName, pStr, Length);
			return true;
		}
		
		return false;
	}

	bool CSyserUI::GetSymbolOffset(ULONG_PTR Address, char *szName)
	{
		szName[0] = 0;
		ULONG_PTR Base = Address;

		if (!gpSyser->m_pDebugger->m_DbgModuleList.GetSymbolBase(&Base))
		{
			if (gpSyser->m_pDebugger == gpSyser->m_pSysDebugger)
				return false;

			if (!gpSyser->m_pSysDebugger->m_DbgModuleList.GetSymbolBase(&Base))
				return false;
		}

		char Buffer[256];
		if (!GetSymbol(Base, Buffer, 64))
			return false;

		if (Base == Address)
		{
			TStrCpy(szName, Buffer);
		} else
		if (Base < Address)
		{
			TSPrintf(szName, "%s+0x%X", Buffer, Address - Base);
		} else
		if (Base > Address)
		{
			TSPrintf(szName, "%s-0x%X", Buffer, Base - Address);
		}
		return true;
	}

	unsigned long CSyserUI::SetCommentModule(CCommentModule *pCommentModule)
	{
		unsigned long Count = 0;
			CDebugger *pDebugger = gpSyser->m_pDebugger;
			CDbgModule *pDbgMod = pDebugger->m_DbgModuleList.FindModule(pCommentModule->m_TimeStamp, pCommentModule->m_CheckSum);
			if (pDbgMod && !pDbgMod->m_pCommentModule)
			{
				pDbgMod->SetCommentModule(pCommentModule);
				++Count;
			}
		return Count;
	}

	unsigned long CSyserUI::RemoveCommentModule(CCommentModule *pCommentModule)
	{
		unsigned long Count = 0;
			CDebugger *pDebugger = gpSyser->m_pDebugger;
			for (map<CMemoryImage, CDbgModule>::IT it2 = pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
				it2 != pDebugger->m_DbgModuleList.m_DbgModuleMap.end(); ++it2)
			{
				if (it2->second.m_pCommentModule == pCommentModule)
				{
					it2->second.RemoveCommentModule(&m_CommentContainer);
					++Count;
				}
			}
		return Count;
	}

	unsigned long CSyserUI::SetSymbolModule(CSymbolModule *pSymMod)
	{
		unsigned long Count = 0;
			CDebugger *pDebugger = gpSyser->m_pDebugger;
			CDbgModule *pDbgMod = pDebugger->m_DbgModuleList.FindModule(pSymMod->m_TimeStamp, pSymMod->m_CheckSum);
			if (pDbgMod && !pDbgMod->m_pSymbolModule)
			{
				pDbgMod->SetSymbolModule(pSymMod);
				++Count;
			}
		return Count;
	}

	unsigned long CSyserUI::LoadSDSModuleSym(CSDSModule *pSDSMod)
	{
		if (!pSDSMod)
			return 0;
		if (!pSDSMod->m_pSDSFile)
			return 0;

		CSymbolModule *pSymMod = m_SymbolContainer.FindModule(pSDSMod->GetFILESIG().TimeStamp, pSDSMod->GetFILESIG().CheckSum);
		if (!pSymMod)
			return 0;
		unsigned long Count = 0;
	//
	{
		unsigned long Len = 0;
		DATATYPE *data = pSDSMod->GetLocal(&Len);
		for (unsigned long n = 0; n < Len; ++n)
		{
			if (data[n].locationType == LocIsStatic)
			{
				if (data[n].Static.rva == 0) continue; //+++
				pSymMod->Add(data[n].Static.rva, data[n].name);
				++Count;
			}
		}
	}
	//	//skip first 1
	{
		unsigned long Len = 0;
		FUNCTION **func = pSDSMod->GetFunctions(&Len);
		for (unsigned long n = 1; n < Len; ++n)
		{
			if (func[n]->rva == 0) continue;
			pSymMod->Add(func[n]->rva, func[n]->name);
			++Count;
		}
	}
	//
	{
		unsigned long Len = 0;
		PUBSYM *pubsym = pSDSMod->GetPublicSymbols(&Len);
		for (unsigned long n = 1; n < Len; ++n)
		{
			if (pubsym[n].rva == 0) continue; //+++
			pSymMod->Add(pubsym[n].rva, pubsym[n].name);
			++Count;
		}
	}
		return Count;
	}

	CSDSModule *CSyserUI::FindSDSModule(ULONG_PTR ImageBase)
	{
		CDbgModule *pDbgMod = gpSyser->m_pDebugger->m_DbgModuleList.FindModule(ImageBase);
		if (!pDbgMod)
		{
			if (gpSyser->m_pDebugger == gpSyser->m_pSysDebugger)
				return nullptr;
			pDbgMod = gpSyser->m_pSysDebugger->m_DbgModuleList.FindModule(ImageBase);
			if (!pDbgMod)
				return nullptr;
		}
		map<FILESIG, CSDSModule>::IT it = m_SDSModulesMap.find(FILESIG(pDbgMod->m_TimeStamp, pDbgMod->m_CheckSum));
		if (!it)
		{
			it = m_SDSModulesMap.find(FILESIG(1, 1));
			if (!it)
				return nullptr;
		}
		it->second.m_pDbgModule = pDbgMod;
		return &it->second;
	}

	bool CSyserUI::UnloadSDSModule(CSDSModule *pSDSMod)
	{
		map<FILESIG, CSDSModule>::IT it = m_SDSModulesMap.find(pSDSMod->GetFILESIG());
		if (!it)
			return false;
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.RemoveSDSModule(&it->second);
		
		CSymbolModule *pSymMod = m_SymbolContainer.FindModule(pSDSMod->GetFILESIG().TimeStamp, pSDSMod->GetFILESIG().CheckSum);
		if (pSymMod)
			--pSymMod->m_RefCount;
		DebugPrintf("Syser : Unload SDS %s\n", TGetFileName(pSDSMod->m_SDSFileName.operator const char*()));
		m_SDSModulesMap.erase(it);
		return true;
	}

	CSDSModule *CSyserUI::LoadSDSModule(const char *SDSFullFileName)
	{
		FILESIG FileSig = CSDSModule::GetFILESIG(SDSFullFileName);
		if (FileSig.TimeStamp == 0 && FileSig.CheckSum == 0)
			return nullptr;
		map<FILESIG, CSDSModule>::IT it = m_SDSModulesMap.insert(_Tmap_pair<FILESIG, CSDSModule>(FileSig, (CSDSModule*)0));
		if (!it)
		{
			DebugPrintf("Syser : Same SDS is already loaded!\n");
			return nullptr;
		}
		if (!it->second.Load(SDSFullFileName))
		{
			DebugPrintf("Syser : Fail to load SDS %s\n", SDSFullFileName);
			m_SDSModulesMap.erase(it);
			return nullptr;
		}

		it->second.m_ExeFileName = TGetFileName(it->second.GetExeFileName());
		CSymbolModule *pSymMod = gpSyser->m_SyserUI.m_SymbolContainer.FindModule(FileSig.TimeStamp, FileSig.CheckSum);
		if (!pSymMod)
		{
			pSymMod = gpSyser->m_SyserUI.m_SymbolContainer.InsertModule(FileSig.TimeStamp, FileSig.CheckSum);
			if (!pSymMod)
			{
				DebugPrintf("Syser : Fail to insert %s Symbol Module\n", SDSFullFileName);
				m_SDSModulesMap.erase(it);
				return nullptr;
			}
			pSymMod->m_ModuleName = it->second.m_ExeFileName;
			gpSyser->m_SyserUI.SetSymbolModule(pSymMod);
		}
		int symbols = gpSyser->m_SyserUI.LoadSDSModuleSym(&it->second);
		int sources = it->second.GetSrcFilesCount();
		if (!sources)
		{
			m_SDSModulesMap.erase(it);
			DebugPrintf("Syser : Load SDS %s < %d symbols >\n", TGetFileName(SDSFullFileName), symbols);
			return nullptr;
		}
		++pSymMod->m_RefCount;
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.AppendSDSModule(&it->second);
		DebugPrintf("Syser : Load SDS %s < %d symbols , %d source code files >\n", TGetFileName(SDSFullFileName), symbols, sources);
		return &it->second;
	}

	bool CSyserUI::LoadPDBSym(const char *szModule, ULONG_PTR ImageBase, unsigned long ImageSize)
	{
		char SDSFullFileName[MAX_FN_LEN];
		if (!gpSyser->m_SourceDebug.CheckSDS(szModule, SDSFullFileName))
		{
			//TODO dialog "Try load pdb?"
			if (!gpSyser->m_SourceDebug.Load(szModule, SDSFullFileName, eUseSourcesExtern))
				return false;
		}

		CSDSModule *pSDSMod = LoadSDSModule(SDSFullFileName);
		if (!pSDSMod)
		{
			return false;
		}
	//	pSDSMod->m_dwProcessId = gpSyser->m_pSysDebugger->m_dwProcessId;
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_MultiSourceCodeView.UpdateContext();
		return true;
	}

struct DLLDEFMAP
{
	const char *FileDll;
	const char *FileDef;
};

DLLDEFMAP gDllDefTable[] =
	{
		{"mfc42.dll","mfc42.def"},
		{"mfc70.dll","mfc70.def"},
		{"mfc71.dll","mfc71.def"},
		{"mfc80.dll","mfc80.def"},
		{"mfc90.dll","mfc90.def"},

		{"mfc42d.dll","mfc42d.def"},
		{"mfc70d.dll","mfc70d.def"},
		{"mfc71d.dll","mfc71d.def"},
		{"mfc80d.dll","mfc80d.def"},
		{"mfc90d.dll","mfc90d.def"},

		{"mfc42u.dll","mfc42u.def"},
		{"mfc70u.dll","mfc70u.def"},
		{"mfc71u.dll","mfc71u.def"},
		{"mfc80u.dll","mfc80u.def"},
		{"mfc90u.dll","mfc90u.def"},

		{"mfc42ud.dll","mfc42ud.def"},
		{"mfc70ud.dll","mfc70ud.def"},
		{"mfc71ud.dll","mfc71ud.def"},
		{"mfc80ud.dll","mfc80ud.def"},
		{"mfc90ud.dll","mfc90ud.def"},
	};

	const char *GetDefFile(const char *DllFileName)
	{
		int l = TStrLen(DllFileName)-10; //??? WTF
		if (l <= 0) return nullptr;
		DllFileName += l; //??? WTF
		for (int n = 0; n < lenof(gDllDefTable); ++n)
		{
			if (TStrIStr(DllFileName, gDllDefTable[n].FileDll))
				return gDllDefTable[n].FileDef;
		}
		return nullptr;
	}

#include "../Code/fileiont.hpp"

	char *FileRead(const char *FileName, unsigned long *MemLen)
	{
		CLocalFileIO File;
		char *pMem = nullptr;
		*MemLen = 0;
		HANDLE Handle;
		if (File.OpenFile(FileName, &Handle, 0x1'0000))
		{
			unsigned long long Length = File.GetFileLength(Handle);
			if (Length <= 0x10'0000)
			{
				pMem = new char[Length+1];
				if (pMem)
				{
					*MemLen = File.ReadFile(Handle, pMem, Length, 0);
					if (*MemLen != Length)
					{
						*MemLen = 0;
						delete []pMem;
						pMem = nullptr;
					}
				}
			}
			File.CloseHandle(Handle);
		}
		return pMem;
	}

#define MFC_NAMES 10'000

	const char **ReadDefFile(char *Mem, int MemLen)
	{
		const char **pDefMem = new const char*[MFC_NAMES];
		if (pDefMem)
		{
			memset(pDefMem, 0, sizeof(char*)*MFC_NAMES);
			unsigned long Offset = 0;
			for (unsigned long n = 0; n < MemLen; ++n) //<= ???
			{
				if (Mem[n] == '\n')
				{
					Mem[n] = 0;
					const char *StrNum = &Mem[Offset];
					while (IS_DIGIT(Mem[Offset])) ++Offset;
					Mem[Offset] = 0;
					++Offset;
					unsigned long OrdFunc;
					if (USDecStrToNum(StrNum, &OrdFunc))
					{
						while (Mem[Offset] &&
							(Mem[Offset]==' '||Mem[Offset]=='\t')) ++Offset;
						if (OrdFunc < MFC_NAMES)
							pDefMem[OrdFunc] = &Mem[Offset];
					}
					Offset = n;// ???; //TODO
				}
			}
		}
		return pDefMem;
	}

	CSymbolModule * CSyserUI::LoadPESym(const char *szModule, CDbgModule *pDbgMod)
	{
		CPEFile PEFile;
		if (!PEFile.Open(szModule, 0))
			return nullptr;

		CSymbolModule *pSymMod = m_SymbolContainer.FindModule(PEFile.m_PEHead.TimeDateStamp, PEFile.m_PEHead.CheckSum);
		if (!pSymMod)
		{
			pSymMod = m_SymbolContainer.InsertModule(PEFile.m_PEHead.TimeDateStamp, PEFile.m_PEHead.CheckSum);
			if (pSymMod)
				pSymMod->m_ModuleName = szModule;
			if (pDbgMod)
				pDbgMod->SetSymbolModule(pSymMod);
			else	SetSymbolModule(pSymMod);
		}

		const char **DefNames = nullptr;
		const char *DefFileName = GetDefFile(szModule);
		char *Mem = nullptr;
		const char **DefFileMem = nullptr;
		if (DefFileName)
		{
			char szDefFileName[MAX_FN_LEN];
		//#ifdef _RING0_
		//	::GetWindowsDirectoryA(szDefFileName, MAX_FN_LEN);
		//	TStrCat(szDefFileName, "\\system32\\drivers\\plugin\\");
		//#else
			GetModulePath(szDefFileName, true); //+++
			TStrCat(szDefFileName, "\\plugin\\"); //+++
		//#endif
			TStrCat(szDefFileName, DefFileName);
			unsigned long MemLen = 0;
			Mem = FileRead(szDefFileName, &MemLen);
			if (Mem)
			{
				DefFileMem = ReadDefFile(Mem, MemLen);
				if (!DefFileMem)
				{
					delete []Mem;
					Mem = nullptr;
				}
			}
			szDefFileName[0] = 0;

			DefNames = DefFileMem;
		}

		for (int i = 0; i < PEFile.m_ExportFuncCount; ++i)
		{
			const char *FuncName = PEFile.m_ExportFunc[i].FuncName;
			if (DefNames)
			{
				if (PEFile.m_ExportFunc[i].FuncOrd < MFC_NAMES)
				{
					if (DefNames[PEFile.m_ExportFunc[i].FuncOrd])
						FuncName = DefNames[PEFile.m_ExportFunc[i].FuncOrd];
				}
			}
			pSymMod->Add(PEFile.m_ExportFunc[i].Address - PEFile.m_ImageBase, FuncName);
		}

		if (DefNames)
		{
			delete []DefNames;
			delete []Mem;
		}

		char szTitle[MAX_FN_LEN];
		TGetFileTitle(szModule, szTitle);
		pSymMod->Add(0, szTitle);
		PEFile.Close();
		return pSymMod;
	}

	CSymbolModule * CSyserUI::LoadMap(const char *szMapFile, const char *szModule, CDbgModule *pDbgMod)
	{
		CPEFile PEFile;
		if (!PEFile.Open(szModule, 0))
			return nullptr;

		CSymbolModule *pSymMod = m_SymbolContainer.FindModule(PEFile.m_PEHead.TimeDateStamp, PEFile.m_PEHead.CheckSum);
		if (!pSymMod)
		{
			pSymMod = m_SymbolContainer.InsertModule(PEFile.m_PEHead.TimeDateStamp, PEFile.m_PEHead.CheckSum);
			if (pSymMod)
				pSymMod->m_ModuleName = szModule;
			if (pDbgMod)
				pDbgMod->SetSymbolModule(pSymMod);
			else	SetSymbolModule(pSymMod);
		}

		CTXTFile MapFile;
		if (!MapFile.Open(szMapFile, 0))
			return nullptr;

		//TODO X64 MAP FILE
		TList<char *>::IT It = MapFile.m_StrList.Begin();
		while (It != MapFile.m_StrList.End())
		{
			char *Str = *It;

			while (*Str==' '||*Str=='\t') ++Str;
			if (Str[4]!=':') { ++It; continue; }
			Str[4] = 0;
			unsigned long SecNum = 0;
			if (!USHexStrToNum(Str, &SecNum)) { ++It; continue; }
			if (SecNum > PEFile.m_SectCount) { ++It; continue; }
			if (Str[13]=='H'||Str[13]=='h') { ++It; continue; }
			Str[13] = 0;
			ULONG_PTR Addr = 0;
			if (!USHexStrToNum(Str+5, &Addr)) { ++It; continue; }
			if (Addr > PEFile.m_Section[SecNum].VirtualSize) { ++It; continue; }
			Str += 14;
			while (*Str==' '||*Str=='\t') ++Str;
			pSymMod->Add(Addr, Str);
			++It;
		}

		char szTitle[MAX_FN_LEN];
		TGetFileTitle(szModule, szTitle);
		pSymMod->Add(0, szTitle);
		PEFile.Close();
		return pSymMod;
	}

	unsigned long CSyserUI::GetModuleName(char *szModule)
	{
		unsigned long Len = TStrLen(szModule);

		map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
		//while (it != gpSyser->m_pDebugger->m_DbgModuleList.m_DbgModuleMap.end())
		while (it)
		{
			if (it->second.m_pSymbolModule)
			{
				map<ULONG_PTR, TAnsiNoCaseString>::IT si = it->second.m_pSymbolModule->m_SymbolMap.begin();
				//while (si != it->second.m_pSymbolModule->m_SymbolMap.end())
				while (si)
				{
					if (!TStrNICmp(szModule, si->second.operator const char*(), Len))
					{
						return TStrCpyLimit(szModule, si->second.operator const char*(), 64);
					}
					++si;
				}
			}	
			++it;
		}

		if (gpSyser->m_pDebugger != gpSyser->m_pSysDebugger)
		{
			map<CMemoryImage, CDbgModule>::IT it = gpSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.begin();
			//while (it != gpSyser->m_pSysDebugger->m_DbgModuleList.m_DbgModuleMap.end())
			while (it)
			{
				if (it->second.m_pSymbolModule)
				{
					map<ULONG_PTR, TAnsiNoCaseString>::IT si = it->second.m_pSymbolModule->m_SymbolMap.begin();
					//while (si != it->second.m_pSymbolModule->m_SymbolMap.end())
					while (si)
					{
						if (!TStrNICmp(szModule, si->second.operator const char*(), Len))
						{
							return TStrCpyLimit(szModule, si->second.operator const char*(), 64);
						}
						++si;
					}
				}	
				++it;
			}
		}
		return Len;
	}

	bool CSyserUI::IsGlobeModule(ULONG_PTR Address, const char *szFullFileName)
	{
		//TODO RING0
		return false;
	}

	bool CSyserUI::ToggleInsertBP(ULONG_PTR Address)
	{
		bool ret;
		BREAK_POINT *BreakPoint = gpSyser->m_pDebugger->GetCodeBP(Address, 0, 0x300);
		if (BreakPoint)
			ret = gpSyser->m_pDebugger->DelCodeBP(*BreakPoint);
		else	ret = gpSyser->m_pDebugger->SetCodeBP(Address, 0, BP_STATE_ENABLE) != 0;
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.UpdateContext(false);
		gpSyser->m_MainFrame.Update((WISP_RECT*)0);
		return ret;
	}

	bool CSyserUI::ToggleEnableBP(ULONG_PTR Address)
	{
		BREAK_POINT *BreakPoint = gpSyser->m_pDebugger->GetCodeBP(Address, 0, 0x300);
		if (!BreakPoint)
			return false;
		if (BreakPoint->State == BP_STATE_ENABLE)
			return gpSyser->m_pDebugger->DisableCodeBP(*BreakPoint);
		return gpSyser->m_pDebugger->EnableCodeBP(*BreakPoint);
	}

	bool CSyserUI::InsertBP(ULONG_PTR Address, const char *szName, const char *szCondition, const char *szCommand)
	{
		BREAK_POINT *BreakPoint = gpSyser->m_pDebugger->SetCodeBP(Address, 0, BP_STATE_ENABLE);
		if (!BreakPoint)
			return false;
		if (szCondition && *szCondition)
			BreakPoint->Condition = szCondition;
		if (szName && *szName)
			BreakPoint->Name = szName;
		if (szCommand && *szCommand)
			BreakPoint->Command = szCommand;
		return true;
	}

	bool CSyserUI::RemoveBP(ULONG_PTR Address)
	{
		return gpSyser->m_pDebugger->DelCodeBP(Address, 0, 0x300);
		//
	}

	bool CSyserUI::EnableModuleBP(ULONG_PTR Address, bool Enable)
	{
		return false;
	}

	void CSyserUI::EnableAllModuleBP(bool Enable)
	{
	}

	bool CSyserUI::InsertModuleOnloadBP(const char *szName, unsigned int Type, unsigned int State)
	{
		map<TAnsiNoCaseString, MODULE_LOAD>::IT it = m_ModuleLoadBPMap.insert(_Tmap_pair<TAnsiNoCaseString, MODULE_LOAD>(szName, (MODULE_LOAD*)0));
		if (!it) return false;
		it->second.Type = Type;
		it->second.State = State;
		return true;
	}

	void CSyserUI::EnableModuleOnloadBP(bool Enable)
	{
		map<TAnsiNoCaseString,MODULE_LOAD>::IT it = m_ModuleLoadBPMap.begin();
		//while (it != m_ModuleLoadBPMap.end())
		while (it)
		{
			if (!(it->second.Type & 0x300))
				it->second.State = Enable ? 1:0; //BP_STATE_ENABLE:BP_STATE_DISABLE;
			++it;
		}
	}

	void CSyserUI::LoadAPIDef()
	{
		char szModuleName[MAX_FN_LEN];
	//TODO _RING0_
		GetModulePath(szModuleName, true);
		TStrCat(szModuleName, "APIDef.lib");
		CImageFileStream File;
		if (!File.Open(szModuleName, 0))
		{
			DebugPrintf("Syser : Fail to load APIDef %s\n", szModuleName);
			return;
		}

		unsigned long LoadSize = m_APIDef.Read(File);
		DebugPrintf("Syser : Load API %d records\n", m_APIDef.size());
		unsigned long FileSize = File.GetFileLength();
		if (LoadSize != FileSize)
		{
			DebugPrintf("Syser : **********Invalid API Define Data , Load Size [%d] != File Size [%d]**********\n", LoadSize, FileSize);
		}

		File.Close();
	}

	bool CSyserUI::SaveComment()
	{
		char szFileName[MAX_FN_LEN];
		GetModulePath(szFileName, true);
	#if 0
		TStrCat(szFileName, "Syser.cmt");
	#else
		TStrCat(szFileName, TGetFileName(m_SyserCodeDoc.m_ExeFilePath.operator const char*()));
		TStrCat(szFileName, ".cmt");
	#endif
		if (m_CommentContainer.m_CommentModulesMap.size()==0)
		{
			gpFileIO->DeleteFile(szFileName);
			return true;
		}
		CImageFileStream File;
		if (!File.Create(szFileName, 0))
			return false;
		m_CommentContainer.Write(File);
		File.Close();

		for (map<unsigned long long, CCommentModule>::IT it = m_CommentContainer.m_CommentModulesMap.begin();
			it != m_CommentContainer.m_CommentModulesMap.end(); ++it) //???++
		{
			++(it->second.m_RefCount);
		}
		return true;
	}

	bool CSyserUI::LoadComment()
	{
		char szFileName[MAX_FN_LEN];
		GetModulePath(szFileName, true);
	#if 0
		TStrCat(szFileName, "Syser.cmt");
	#else
		TStrCat(szFileName, TGetFileName(m_SyserCodeDoc.m_ExeFilePath.operator const char*()));
		TStrCat(szFileName, ".cmt");
	#endif
		CImageFileStream File;
		if (!File.Open(szFileName, 0))
			return false;
	{
		map<unsigned long long, CCommentModule>::IT it = m_CommentContainer.m_CommentModulesMap.begin();
		while (it != m_CommentContainer.m_CommentModulesMap.end())
		{
			RemoveCommentModule(&it++->second);
		}
	}
		m_CommentContainer.Read(File);
		File.Close();
	{
		for (map<unsigned long long, CCommentModule>::IT it = m_CommentContainer.m_CommentModulesMap.begin();
			it != m_CommentContainer.m_CommentModulesMap.end(); ++it) //???++
		{
			SetCommentModule(&it->second);
			++(it->second.m_RefCount);
		}
	}
		gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.UpdateContext();
		return true;
	}

```

`source/WispSyser/syserui.hpp`:

```hpp

#ifndef _SYSERUI_HPP_
#define _SYSERUI_HPP_

#include "plugin.hpp"
#include "../EXEAnalyzer/symbol.hpp"
#include "../EXEAnalyzer/debugger.hpp"
#include "../EXEAnalyzer/x86debugger.hpp"
#include "../EXEAnalyzer/instrsym.hpp"
#include "../Code/alt/altexpcalc.hpp"
#include "../EXEAnalyzer/sdsmodule.hpp"

	typedef TExpCalc<char,ULONG_PTR,1> TSyserExpCalc; //NoCase String

	struct CSyserCodeDoc : CCodeDoc, CInstrSym, TSyserExpCalc//TExpCalc<char,ULONG_PTR,1>
	{
		X86_CPU_REG_PTR m_CPUREGPTR;
		unsigned long m_OPCODE;
		unsigned long m_PID;
		unsigned long m_TID;
		unsigned long m_BPCOUNT;
		TAnsiString m_ExeFilePath;

		CSyserCodeDoc();

		static TExpCalc<char,ULONG_PTR,1>::EXPITEM * Reg(TListIter<TExpCalc<char,ULONG_PTR,1>::EXPITEM> It, TList<TExpCalc<char,ULONG_PTR,1>::EXPITEM> & Expression, TExpCalc<char,ULONG_PTR,1> *pThis);

		void InsertX86RegSym(X86_CPU_REG_PTR *pCPURegPtr);
		virtual bool Open(const char *szModule) override; //04 TODO PARAM
		virtual void Close() override;			//08
		virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) override; //0C
		virtual ULONG_PTR GetInstrAddress(ULONG_PTR Address, long Count) override; //10

		virtual bool GetSymbol(ULONG_PTR Address, WCHAR *szName, int Length) override; //14
		virtual bool GetComment(ULONG_PTR Address, WCHAR *szName, int Length) override; //18
		virtual bool SetComment(ULONG_PTR Address, const WCHAR *szName) override; //1C
		//virtual bool GetFunction(ULONG_PTR Address, WCHAR *szName, int Length) override; //20
		virtual unsigned long GetPic(ULONG_PTR Address) override; //24

		virtual bool AddrToSym(ULONG_PTR Address, char *szSym, unsigned int SymLen) override;

		virtual bool GetSymbolBase(ULONG_PTR *BaseAddr) override;

		virtual bool GetValue(const char *szItem, ULONG_PTR *pValue) const override;
		virtual ULONG_PTR ReadValue(ULONG_PTR Address) override;

		void OnTestCondition();
		void GetInstrInfo(WCHAR *pInstrInfoStr);
		unsigned long ReadColorString(ULONG_PTR Address, unsigned long *pColorString, unsigned long MaxSize);
		void ContextCS(unsigned long *pColorString, int MaxLen);
		bool IsDasm(ULONG_PTR Address, unsigned long Size);
	};

	struct CSyserDI : public CDebugInterface
	{
		virtual void OnLoadModule(CDebugger *pDebugger, const char *szName, ULONG_PTR ImageBase, unsigned long ImageSize, unsigned long TimeStamp, unsigned long CheckSum) override;
		virtual void OnUnloadModule(CDebugger *pDebugger, ULONG_PTR ImageBase) override;
		virtual void OnTestCondition() override;

		virtual bool Close(bool bExit) override;
		virtual bool Plunge(unsigned int Code) override;

		virtual bool OnExit(bool bExit) override;
		virtual bool OnDebugException(unsigned int Code) override;

		virtual void DisplayMsg(const char *szMsg) override;
		virtual void UpdateContext() override;
		virtual bool TestCondition(const char *Condition, BREAK_POINT *pBP) override;
		virtual bool RunCmd(const char *szCmd) override;
		virtual void RunCmds(const char *szCmds) override;

		virtual CDebugger *GetDebugger() override;
	};

	struct CCallStack
	{
		struct Frame
		{
			ULONG_PTR Address;
			ULONG_PTR Return;
			ULONG_PTR FuncAddr;
			TAnsiString FuncName;
		};

		TList<Frame> m_Frames;
		TListIter<Frame> m_HeadIt;
		ULONG_PTR m_Address;

		CCallStack();
		void UpdateContext(ULONG_PTR Address);
	};

	struct MODULE_LOAD
	{
		unsigned long State;
		unsigned long Type;
	};

	struct APIFunctionArguments : public TList<TAnsiString>
	{
		unsigned long Read(ALT::ALTFileStream &Stream)
		{
			Clear();
			unsigned long Len = 4;
			unsigned long Count = 0;
			if (Stream.Read(&Count, Len) != Len) return 0;

			while (Count>0)
			{
				unsigned long PLen = Append(0)->Read(Stream);
				if (!PLen)
					return 0;
				Len += PLen;
				--Count;
			}
			return Len;
		}
	};

	struct APIFunction
	{
		TAnsiString Return;
		APIFunctionArguments Arguments;
		unsigned long Declaration;

		unsigned long Read(ALT::ALTFileStream &Stream)
		{
			unsigned long Ret = 0;
			unsigned long RLen = Return.Read(Stream);
			if (!RLen) return 0;
			Ret += RLen;
			unsigned long ALen= Arguments.Read(Stream);
			if (!ALen) return 0;
			Ret += ALen;
			unsigned long SLen = Stream.Read(&Declaration, 4);
			if (!SLen) return 0;
			Ret += SLen+4;
			return Ret;
		}
	};

	struct CAPIDef : public map<TAnsiNoCaseString, APIFunction> //multimap
	{
		unsigned long Read(ALT::ALTFileStream &Stream)
		{
			TAnsiNoCaseString Name;
			clear();	
			unsigned long Len = 4;
			unsigned long Count = 0;
			if (Stream.Read(&Count, Len) != Len) return 0;

			while (Count>0)
			{
				unsigned long NLen = Name.Read(Stream);
				if (!NLen) return 0;
				Len += NLen;

				//InsertNonUnique
				map<TAnsiNoCaseString, APIFunction>::IT it = insert(
						_Tmap_pair<TAnsiNoCaseString, APIFunction>(Name,APIFunction()));
				if (it == end()) return 0;

				unsigned long Ret = it->second.Read(Stream);
				if (!Ret)
					return 0;
				Len += Ret;
				--Count;
			}
			return Len;
		}
	};

	struct CSyserUI : public CSyserPluginUI
	{
		CAPIDef m_APIDef;
		CSyserCodeDoc m_SyserCodeDoc;
		CSymbolContainer m_SymbolContainer;
		CCommentContainer m_CommentContainer;
		CSyserDI m_DebugInterface;
		map<FILESIG, CSDSModule> m_SDSModulesMap;
		CCallStack m_CallStack;

		//redirect BP place 
		map<unsigned long long, BREAK_POINT> m_CodeBPMap;
		TList<BREAK_POINT> m_DataBPList;

		map<ULONG_PTR, BREAK_POINT::MODULE> m_ModuleBPMap;
		map<TAnsiNoCaseString, MODULE_LOAD> m_ModuleLoadBPMap;

		void SetCodeMode(int Mode)
		{
			m_SyserCodeDoc.m_Mode = Mode;
		}

		CSyserUI()
		{
			m_DebugInterface.m_pCodeDoc = &m_SyserCodeDoc;
			m_DebugInterface.m_pCommentContainer = &m_CommentContainer;
			m_DebugInterface.m_pSymbolContainer = &m_SymbolContainer;
		}

		~CSyserUI()
		{
		}

		virtual bool RegisterPluginModule(const WCHAR *ModuleName, SYSER_PLUGIN_MODULE *pPluginModule) override;
		virtual bool UnregisterPluginModule(const WCHAR *ModuleName) override;

		virtual int GetInstrLen(ULONG_PTR Address) override;

		bool CalcExp(const char *szExp, ULONG_PTR *pResult);
		virtual bool CalcExp(const WCHAR *szExp, ULONG_PTR *pResult) override;

		virtual bool InsertCmd(const WCHAR *szCmd, FPCmd pCmdProc, void *pUserData, const WCHAR *pComment, const WCHAR *pUsage) override;
		virtual void RemoveCmd(const WCHAR *szCmd) override;
		virtual int RunCmd(const WCHAR *szCmd) override;

		virtual void Outputf(const WCHAR *szFormat, ...) override;
		virtual void Output(const unsigned long *szMsg) override;

		virtual void *InsertMenu(void *hParentMenu, const WCHAR *szMenuName, FPMenuProc fpMenuProc) override;
		virtual bool RemoveMenu(void *hMenu) override;
		virtual bool EnableMenu(void *hMenu, bool bEnable) override;

		virtual void *GetMainTabWnd() override;
		virtual void *GetMainMenu() override;
		virtual void *GetWisp() override;

		virtual unsigned long WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size) override;
		virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) override;

		bool ReadUString(ULONG_PTR Address, WCHAR *pString, unsigned long Size);
		bool ReadAString(ULONG_PTR Address, char *pString, unsigned long Size);
		bool ReadString(ULONG_PTR Address, WCHAR *String, unsigned long Size, char *Encode);
		bool GetSymbol(ULONG_PTR Address, char *szName, int Length);
		bool GetSymbolOffset(ULONG_PTR Address, char *szName);
		unsigned long SetCommentModule(CCommentModule *pCommentModule);
		unsigned long RemoveCommentModule(CCommentModule *pCommentModule);
		unsigned long SetSymbolModule(CSymbolModule *pSymMod);

		unsigned long LoadSDSModuleSym(CSDSModule *pSDSMod);
		CSDSModule *FindSDSModule(ULONG_PTR ImageBase);
		bool UnloadSDSModule(CSDSModule *pSDSMod);
		CSDSModule *LoadSDSModule(const char *FileName);

		bool LoadPDBSym(const char *szModule, ULONG_PTR ImageBase, unsigned long ImageSize);

		CSymbolModule *LoadPESym(const char *szModule, CDbgModule *pDbgMod);
		CSymbolModule *LoadMap(const char *szMapFile, const char *szModule, CDbgModule *pDbgMod);
		unsigned long GetModuleName(char *szModuleName);
		bool IsGlobeModule(ULONG_PTR Address, const char *szFullFileName);

		bool ToggleInsertBP(ULONG_PTR Address);
		bool ToggleEnableBP(ULONG_PTR Address);
		bool InsertBP(ULONG_PTR Address, const char *szName, const char *szCondition, const char *szCommand);
		bool RemoveBP(ULONG_PTR Address);
		bool EnableModuleBP(ULONG_PTR Address, bool Enable);
		void EnableAllModuleBP(bool Enable);

		bool InsertModuleOnloadBP(const char *szName, unsigned int Type, unsigned int State);
		void EnableModuleOnloadBP(bool Enable);

		void LoadAPIDef();
		bool SaveComment();
		bool LoadComment();
	};

#endif
```

`source/WispSyser/systemexplorer.cpp`:

```cpp

#include "systemexplorer.hpp"
#include "resource.hpp"
#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "aboutform.hpp"
#include "syserconfig.hpp"
#include "../Code/sysdep.hpp"

//#define LSPLIT

//TODO
	int dwCPUNumbers = 3;

	int GetActiveCPU()
	{
		//TODO
		return 0;
	}


//
	CSystemExplorer::CSystemExplorer()
	{
		m_SplitRight = 0;//gSyserConfig.iSplitRight;
		m_pCodeView = 0;
		m_nCPUNumbers = 1;
		m_pTypeViewerWnd = nullptr;
	}
	CSystemExplorer::~CSystemExplorer()
	{
	}

	void CSystemExplorer::Hide()
	{
		CCodeView *pWnd = (CCodeView *)m_MultiCodeView.GetActiveWnd();
		if (pWnd && pWnd->m_TipWnd.IsWindowShow())
			pWnd->HideTip();
	}

	WISP_MSG_MAP_BEGIN(CSystemExplorer)
		WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_SIZE, OnSize)
		WISP_MSG_MAP(WISP_WM_GET_FOCUS, OnGetFocus)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispWnd)

	WISP_CMD_MAP_BEGIN(CSystemExplorer)
		WISP_CMD_MAP(CMD_ID_SYSTEM_MAIN_SPLIT, OnCmdMainSplit)
		WISP_CMD_MAP(CMD_ID_SYSTEM_VIEW_SPLIT, OnCmdViewSplit)
		WISP_CMD_MAP(CMD_ID_SYSTEM_MONIT_SPLIT, OnCmdMoniteSplit)
		WISP_CMD_MAP(0x45, OnCmdGotoFunction)
	WISP_CMD_MAP_END

	WISP_EVENT_MAP_BEGIN(CSystemExplorer)

		WISP_EVENT_MAP(EVENT_ID_OPEN, OnEventOpen)
		WISP_EVENT_MAP(EVENT_ID_CLOSE, OnEventClose)

		WISP_EVENT_MAP(EVENT_ID_SAVECMT, OnEventSaveComment)
		WISP_EVENT_MAP(EVENT_ID_LOADCMT, OnEventLoadComment)

		WISP_EVENT_MAP(EVENT_ID_LOADSYM, OnEventLoadSymbol)

		WISP_EVENT_MAP(EVENT_ID_NEXTPOS, OnEventNextPos)
		WISP_EVENT_MAP(EVENT_ID_PREVPOS, OnEventPrevPos)
		WISP_EVENT_MAP(EVENT_ID_SAVEPOS, OnEventSavePos)
		WISP_EVENT_MAP(EVENT_ID_CLRPOS, OnEventResetPos)
		WISP_EVENT_MAP(EVENT_ID_DBG_RESET, OnEventDbgReset)
		WISP_EVENT_MAP(EVENT_ID_DBG_STEP, OnEventDbgStep)
		WISP_EVENT_MAP(EVENT_ID_DBG_PROCEED, OnEventDbgProceed)
		WISP_EVENT_MAP(EVENT_ID_DBG_STEPB, OnEventStepBranch)
		WISP_EVENT_MAP(EVENT_ID_DBG_RETURN, OnEventDbgReturn)
		WISP_EVENT_MAP(EVENT_ID_GO, OnEventDbgContinue)
		WISP_EVENT_MAP(EVENT_ID_BREAK_POINT, OnEventBreakPointForm)
		WISP_EVENT_MAP(EVENT_ID_DBG_LIST, OnEventDebuggerSelectForm)
		WISP_EVENT_MAP(EVENT_ID_CONFIG_OPTION, OnEventOptionForm)
		WISP_EVENT_MAP(EVENT_ID_PLUGINS, OnEventPluginListForm)
		WISP_EVENT_MAP(EVENT_ID_GENE_REG, OnEventTabGeneReg)
		WISP_EVENT_MAP(EVENT_ID_FPU_REG, OnEventTabFPUReg)
		WISP_EVENT_MAP(EVENT_ID_SSE_REG, OnEventTabSSEReg)

		WISP_EVENT_MAP(EVENT_ID_WATCH_LIST, OnEventWatch)
		WISP_EVENT_MAP(EVENT_ID_STACK_WATCH_LIST, OnEventStack)
		WISP_EVENT_MAP(EVENT_ID_IDT, OnEventIDT)
		WISP_EVENT_MAP(EVENT_ID_GDT, OnEventGDT)
		WISP_EVENT_MAP(EVENT_ID_LDT, OnEventLDT)
		WISP_EVENT_MAP(EVENT_ID_PROCESS, OnEventProcessList)
		WISP_EVENT_MAP(EVENT_ID_THREADS, OnEventThreadList)
		WISP_EVENT_MAP(EVENT_ID_MODULES, OnEventModuleList)
		WISP_EVENT_MAP(EVENT_ID_FUNCTIONS, OnEventFunctionList)
		WISP_EVENT_MAP(EVENT_ID_HWND, OnEventHwndList)
		WISP_EVENT_MAP(EVENT_ID_RUNTRACE, OnEventRunTrace)
		WISP_EVENT_MAP(EVENT_ID_MEMSEARCH, OnEventSeachDialog)
		WISP_EVENT_MAP(EVENT_ID_CMTLIST, OnEventCommentList)
		WISP_EVENT_MAP(EVENT_ID_PAGEMAP, OnEventPageMap)
		WISP_EVENT_MAP(EVENT_ID_REG_HELP, OnEventRegHelp)
		WISP_EVENT_MAP(EVENT_ID_ABOUT, OnEventAboutForm)
		WISP_EVENT_MAP(EVENT_ID_CHECK_NEW_VER, OnEventCheckNew)
		WISP_EVENT_MAP(EVENT_ID_OBJDIR, OnEventObjDirWnd)

		WISP_EVENT_MAP(EVENT_ID_CALC, OnEventCalc)
		WISP_EVENT_MAP(EVENT_ID_CALLSTACK, OnEventCallStack)
		WISP_EVENT_MAP(EVENT_ID_REGVIEW, OnEventRegView)
		WISP_EVENT_MAP(EVENT_ID_DATAVIEW, OnEventDataViewForm)
		WISP_EVENT_MAP(EVENT_ID_SOFTKB, OnEventSoftKB)
		WISP_EVENT_MAP(EVENT_ID_HOTKEY, OnEventKeyMap)
		WISP_EVENT_MAP(EVENT_ID_PE_EXPLORER, OnEventPEExplorerForm)
		WISP_EVENT_MAP(EVENT_ID_IBM, OnEventIBM)
		WISP_EVENT_MAP(EVENT_ID_EBCDIC, OnEventEBCDI)
		WISP_EVENT_MAP(EVENT_ID_ANSI, OnEventANSI)

		WISP_EVENT_MAP(EVENT_ID_TOGGLE_BM, OnEventToggleBM)
		WISP_EVENT_MAP(EVENT_ID_NEXT_BM, OnEventNextBM)
		WISP_EVENT_MAP(EVENT_ID_PREV_BM, OnEventPrevBM)
		WISP_EVENT_MAP(EVENT_ID_CLEAR_BM, OnEventClearBM)

		WISP_EVENT_MAP(EVENT_ID_SEH, OnEventSEH)
		WISP_EVENT_MAP(EVENT_ID_MENU_FILE, OnEventFile)
		WISP_EVENT_MAP(EVENT_ID_MENU_DEBUG, OnEventDebug)
		WISP_EVENT_MAP(EVENT_ID_MENU_MONITOR, OnEventMonitor)
		WISP_EVENT_MAP(EVENT_ID_MENU_VIEW, OnEventView)
		WISP_EVENT_MAP(EVENT_ID_MENU_INFO, OnEventInformation)
		WISP_EVENT_MAP(EVENT_ID_MENU_OPTION, OnEventOption)
		WISP_EVENT_MAP(EVENT_ID_MENU_TOOLS, OnEventTools)
		WISP_EVENT_MAP(EVENT_ID_MENU_HELP, OnEventHelp)

		WISP_EVENT_MAP(EVENT_ID_DATA_FOCUS, OnEventDataShow)
		WISP_EVENT_MAP(EVENT_ID_CODE_FOCUS, OnEventCodeShow)

		WISP_EVENT_MAP(EVENT_ID_STRREF, OnEventStrRef)

		WISP_EVENT_MAP(EVENT_ID_CV_NEXT_CIP, OnEventNextCVTrace)
		WISP_EVENT_MAP(EVENT_ID_CV_PREV_CIP, OnEventPrevCVTrace)

		WISP_EVENT_MAP(EVENT_ID_BP_ENABLE_ALL, OnEventBPEnableAll)
		WISP_EVENT_MAP(EVENT_ID_BP_REMOVE_ALL, OnEventBPRemoveAll)
		WISP_EVENT_MAP(EVENT_ID_BP_DISABLE_ALL, OnEventBPDisableAll)

		WISP_EVENT_MAP_DEFAULT(OnEventLoadHistory)

	WISP_EVENT_MAP_END

	bool CSystemExplorer::CreateRegsTabs(WISP_MSG *pMsg)
	{
		m_nCPUNumbers = dwCPUNumbers;

		m_pRegsTabWnd = new CWispTabWnd[m_nCPUNumbers];
		if (!m_pRegsTabWnd) return false;

		m_pFpuRegisterList = new CFpuRegisterList[m_nCPUNumbers];
		m_pSSERegisterList = new CSSERegisterList[m_nCPUNumbers];
		m_pGeneRegList = new CGeneRegList[m_nCPUNumbers];

		WISP_RECT Rect;
		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 170;
		Rect.cy = 310;

		if (!m_pFpuRegisterList || !m_pSSERegisterList || !m_pGeneRegList ||
			!m_RegTabWnd.CreateWnd(WSTR(""), Rect, &m_MoniteSplitWnd, 0, 0x10000, WISP_SH_MINSIZE))
		{
			SafeDeleteAry(m_pRegsTabWnd);
			SafeDeleteAry(m_pFpuRegisterList);
			SafeDeleteAry(m_pSSERegisterList);
			SafeDeleteAry(m_pGeneRegList);
			return false;
		}

		int nActiveCPU = GetActiveCPU();

		for (int nCPU = 0; nCPU < m_nCPUNumbers; ++nCPU)
		{
			WISP_RECT RectTab;
			RectTab.x = 0;
			RectTab.y = 0;
			RectTab.cx = 170;
			RectTab.cy = 310;

			if (!m_pRegsTabWnd[nCPU].CreateWnd(WSTR("Reg"), RectTab, &m_RegTabWnd, 0, 0x20000, WISP_SH_MINSIZE))
				return false;

                        WISP_RECT RectGene;
			RectGene.x = 0;
			RectGene.y = 0;
			RectGene.cx = 0;
			RectGene.cy = 0;
			if (!m_pGeneRegList[nCPU].CreateWnd(0, RectGene, &m_pRegsTabWnd[nCPU], CMD_ID_GENE_REG, 0x1030000, WISP_SH_MINSIZE))
				return false;
			m_pGeneRegList[nCPU].SetOwner(this);
			m_pGeneRegList[nCPU].m_nCPU = nCPU;

                        WISP_RECT RectFpu;
			RectFpu.x = 0;
			RectFpu.y = 0;
			RectFpu.cx = 0;
			RectFpu.cy = 0;
			if (!m_pFpuRegisterList[nCPU].CreateWnd(0, RectFpu, &m_pRegsTabWnd[nCPU], CMD_ID_FPU_REG, 0x1030000, WISP_SH_MINSIZE))
				return false;
			m_pFpuRegisterList[nCPU].SetOwner(this);
			m_pFpuRegisterList[nCPU].m_nCPU = nCPU;

                        WISP_RECT RectSSE;
			RectSSE.x = 0;
			RectSSE.y = 0;
			RectSSE.cx = 0;
			RectSSE.cy = 0;
			if (!m_pSSERegisterList[nCPU].CreateWnd(0, RectSSE, &m_pRegsTabWnd[nCPU], CMD_ID_SSE_REG, 0x1030000, WISP_SH_MINSIZE))
				return false;
			m_pSSERegisterList[nCPU].SetOwner(this);
			m_pSSERegisterList[nCPU].m_nCPU = nCPU;
			
			m_pRegsTabWnd[nCPU].InsertWnd(WSTR("REG ALT+R"), &m_pGeneRegList[nCPU], gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x34));
			m_pRegsTabWnd[nCPU].InsertWnd(WSTR("FPU ALT+F"), &m_pFpuRegisterList[nCPU], gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x3A));
			m_pRegsTabWnd[nCPU].InsertWnd(WSTR("MMX ALT+X"), &m_pSSERegisterList[nCPU], gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x30));

			WCHAR szCPUNum[20];
			if (nCPU == nActiveCPU)
				TSPrintf(szCPUNum, WSTR("*CPU %d "), nCPU);
			else	TSPrintf(szCPUNum, WSTR(" CPU %d "), nCPU);

			m_RegTabWnd.InsertWnd(szCPUNum, &m_pRegsTabWnd[nCPU], 0);

			m_pGeneRegList[nCPU].UpdateContext();
			m_pFpuRegisterList[nCPU].UpdateContext();
			m_pSSERegisterList[nCPU].UpdateContext();
		}

		return true;
	}

	bool CSystemExplorer::OnUpdate(WISP_MSG *pMsg)
	{
		if (m_SplitRight != gSyserConfig.iSplitRight)
		{
			m_SplitRight = gSyserConfig.iSplitRight;
			m_MainSplitWnd.m_WndList.Reverse();
			AdjustSplit();
		}
		return true;
	}

	bool CSystemExplorer::OnCreate(WISP_MSG *pMsg)
	{
		m_MainMenu.LoadMenuGroup(this, WISP_ID_MAIN_MENU, SystemExplorerMainMenu, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		m_MainMenu.SetOwner(this);

		m_InfoStr.Create(WSTR(""), //680,
				m_MainMenu.m_FullMenuWidth + 16 + 150,
				m_MainMenu.m_ClientRect.cy - 16, 138, 16, &m_MainMenu, 0, 0, 1);

		m_VersionStr.Create(0, //530,
				m_MainMenu.m_FullMenuWidth + 16,
				m_MainMenu.m_ClientRect.cy - 16, 138, 16, &m_MainMenu, 0, 0, 1);
		m_VersionStr.m_WindowDC.m_TextColor = 0xFF0000;

		WCHAR szVersion[256];
		TStrCpy(szVersion, "Ver: ");
		//TStrCat(szVersion, "1.99.1900.1220");
		TStrCat(szVersion, "Develop");
		m_VersionStr.SetWindowText(szVersion);

		m_Toolbar.CreateEx(this, m_MainMenu.m_WindowRect.cy, -1, WISP_ID_MAIN_TOOLBAR, 0);
		m_Toolbar.LoadToolbar(gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF), SystemExplorerToolbar);
		m_Toolbar.SetOwner(this);

		m_pInstrInfo = (CWispEdit*)m_Toolbar.GetItem(EVENT_ID_INSTRINFO);
		if (!m_pInstrInfo)
			return false;

		WISP_RECT Rect;
		
		Rect.x = 0;
		Rect.y = m_MainMenu.m_WindowRect.cy + m_Toolbar.m_WindowRect.cy;
		Rect.cx = m_ClientRect.cx;
		Rect.cy = m_ClientRect.cy - Rect.y;
		if (!m_MainSplitWnd.CreateWnd(0, Rect, this, CMD_ID_SYSTEM_MAIN_SPLIT, 0x20000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_ViewSplitWnd.CreateWnd(0, Rect, &m_MainSplitWnd, CMD_ID_SYSTEM_VIEW_SPLIT, 0x10000, WISP_SH_MINSIZE))
			return false;

		m_ViewSplitWnd.SetOwner(this);

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_MoniteSplitWnd.CreateWnd(0, Rect, &m_MainSplitWnd, CMD_ID_SYSTEM_MONIT_SPLIT, 0x10000, WISP_SH_MINSIZE))
			return false;

		m_MoniteSplitWnd.SetOwner(this);
		m_MainSplitWnd.InsertWnd(&m_MoniteSplitWnd, 0, 250, -1);
		m_MainSplitWnd.InsertWnd(&m_ViewSplitWnd, 0, 200, -1);
		m_MainSplitWnd.AdjustWndPos();

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_MultiDataView.CreateWnd(0, Rect, &m_ViewSplitWnd, CMD_ID_MULTIDATA, 0xE10000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_MultiCodeView.CreateWnd(0, Rect, &m_ViewSplitWnd, CMD_ID_MULTICODE, 0xE10000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_TerminalWnd.CreateWnd(0, Rect, &m_ViewSplitWnd, CMD_ID_TERMWND, 0, WISP_SH_MINSIZE))
			return false;

		m_TerminalWnd.AttachConsole(&gpSyser->m_MainFrame.m_ConsoleWnd);
		m_TerminalWnd.SetHistoryLines(350);

		m_ViewSplitWnd.InsertWnd(&m_MultiDataView, 0, 90, -1);
		m_ViewSplitWnd.InsertWnd(&m_MultiCodeView, 0, ((CWispWnd*)gpCurWisp->m_pRootWnd)->m_ClientRect.cy/2, -1);
		m_ViewSplitWnd.InsertWnd(&m_TerminalWnd, 0, 30, -1);
		m_ViewSplitWnd.AdjustWndPos();

		if (!CreateRegsTabs(pMsg))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 170;
		Rect.cy = 200;
		if (!m_ContextTabWnd.CreateWnd(WSTR("Context"), Rect, &m_MoniteSplitWnd, 0, 0x20000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_WatchList.CreateWnd(0, Rect, &m_ContextTabWnd, 0, 0x1030000, WISP_SH_MINSIZE))
			return false;

		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		if (!m_StackWatchList.CreateWnd(0, Rect, &m_ContextTabWnd, 0, 0x1010000, WISP_SH_MINSIZE))
			return false;

		m_ContextTabWnd.InsertWnd(WSTR("Stack ALT+S"), &m_StackWatchList, gpCurWisp->m_DIBLib.LoadDIB("\\SyserIcon\\Stack.bmp", 0, 0xFF00FF));
		m_ContextTabWnd.InsertWnd(WSTR("Watch ALT+W"), &m_WatchList, gpCurWisp->m_DIBLib.LoadDIB("\\SyserIcon\\Watch.bmp", 0, 0xFF00FF));

		m_MoniteSplitWnd.InsertWnd(&m_RegTabWnd, 0, m_RegTabWnd.m_WindowRect.cy, -1);
		m_MoniteSplitWnd.InsertWnd(&m_ContextTabWnd, 0, m_ContextTabWnd.m_WindowRect.cy, -1);
		m_MoniteSplitWnd.AdjustWndPos();

		RegisterKeyEvent(EVENT_ID_GENE_REG, 'R', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_FPU_REG, 'F', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_SSE_REG, 'X', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_WATCH_LIST, 'W', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_STACK_WATCH_LIST, 'S', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_CODE_FOCUS, 'p', 0, 1);
		RegisterKeyEvent(EVENT_ID_DATA_FOCUS, 'p', WISP_SK_SHIFT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_FILE, 'F', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_DEBUG, 'D', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_MONITOR, 'M', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_VIEW, 'V', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_INFO, 'I', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_OPTION, 'O', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_TOOLS, 'T', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_MENU_HELP, 'H', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_CV_NEXT_CIP, 'k', WISP_SK_ALT, 1);
		RegisterKeyEvent(EVENT_ID_CV_PREV_CIP, 'm', WISP_SK_ALT, 1);

		gpSyser->RegisterHotKeyEvent(EVENT_ID_TOGGLE_BM, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_NEXT_BM, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_PREV_BM, this);
		gpSyser->RegisterHotKeyEvent(EVENT_ID_CLEAR_BM, this);
 
		return true;
	}
	bool CSystemExplorer::OnDestroy(WISP_MSG *pMsg)
	{
		m_MainMenu.Destroy();
		return true;
	}

	bool CSystemExplorer::OnCmdMainSplit(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == WISP_ID_LBUTTON_DBLCLICK && pMsg->Command.Param1 == 0)
		{
			if (((WISP_SPLIT_WND*)pMsg->Command.Param2)->SizeXorY >= 125)
				m_MainSplitWnd.SetSize(0, 0);
			else	m_MainSplitWnd.SetSize(0, 250);
			m_MainSplitWnd.AdjustWndPos();
		}
		return true;
	}
	bool CSystemExplorer::OnCmdViewSplit(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == WISP_ID_LBUTTON_DBLCLICK && pMsg->Command.Param1 == 0)
		{
			int Size = (m_ClientRect.cy*2)/10;
			if (Size <= ((WISP_SPLIT_WND*)pMsg->Command.Param2)->SizeXorY)
			{
				m_ViewSplitWnd.SetSize(0, Size);
				m_ViewSplitWnd.AdjustWndPos();
			}
		}
		return true;
	}
	bool CSystemExplorer::OnCmdMoniteSplit(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == WISP_ID_RBUTTON_DBLCLICK && pMsg->Command.Param1 == 0)
		{
			if (((WISP_SPLIT_WND*)pMsg->Command.Param2)->SizeXorY > 300)
				m_MoniteSplitWnd.SetSize(0, 300);
			else	m_MoniteSplitWnd.SetSize(0, m_MoniteSplitWnd.m_ClientRect.cy - 5);
			m_MoniteSplitWnd.AdjustWndPos();
		} else
		if (pMsg->Command.CmdMsg == WISP_ID_LBUTTON_DBLCLICK && pMsg->Command.Param1 == 0)
		{
			if (((WISP_SPLIT_WND*)pMsg->Command.Param2)->SizeXorY >= 100)
				m_MoniteSplitWnd.SetSize(0, 0);
			else	m_MoniteSplitWnd.SetSize(0, 300);
			m_MoniteSplitWnd.AdjustWndPos();
		}
		return true;
	}

	bool CSystemExplorer::OnCmdGotoFunction(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == WISP_ID_LBUTTON_DBLCLICK)
		{
			ULONG_PTR Addr = m_FunctionListWnd.GetItemValue((CListStringItem *)pMsg->Command.Param2, CV_ADDR);
			gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.SetActiveAddress(Addr, true);
		}
		return true;
	}
//
	void CSystemExplorer::AdjustSplit()
	{
		if (!gSyserConfig.iSplitRight)
		{
			m_MainSplitWnd.SetSize(0, (m_ClientRect.cx*2) / 10);
			m_MainSplitWnd.SetSize(1, (m_ClientRect.cx*8) / 10);
		} else
		{
			m_MainSplitWnd.SetSize(0, (m_ClientRect.cx*8) / 10);
			m_MainSplitWnd.SetSize(1, (m_ClientRect.cx*2) / 10);
		}
		m_MainSplitWnd.AdjustWndPos();

		m_ViewSplitWnd.SetSize(0, (m_ClientRect.cy*3) / 20);
		m_ViewSplitWnd.SetSize(1, (m_ClientRect.cy*12) / 20);
		m_ViewSplitWnd.SetSize(2, (m_ClientRect.cy*5) / 20);
		m_ViewSplitWnd.AdjustWndPos();
	}
	bool CSystemExplorer::OnSize(WISP_MSG *pMsg)
	{
		m_Toolbar.Resize(pMsg->Sizing.Size.cx, m_Toolbar.m_WindowRect.cy, true);
		m_MainSplitWnd.Resize(m_ClientRect.cx, m_ClientRect.cy - m_MainMenu.m_WindowRect.cy - m_Toolbar.m_WindowRect.cy, true);
		AdjustSplit();
		return true;
	}
	bool CSystemExplorer::OnGetFocus(WISP_MSG *pMsg)
	{
		m_TerminalWnd.Focus();
		return false;
	}

	bool CSystemExplorer::OnEventOpen(WISP_MSG *pMsg)
	{
		if (!gpSyser->m_pDebugger)
			return true;

		char szFileName[MAX_FN_LEN];
	#if 0
		if (gpSyser->m_szDbgFileNameFilter.m_nLength)
		{
			OPENFILENAMEA ofn;
			memset(&ofn, 0, sizeof(ofn));
			ofn.lStructSize = sizeof(ofn);
			ofn.hInstance = gpSyser->m_hInstance;
			ofn.hwndOwner = gpSyser->m_hWnd;

			char szFilter[MAX_FN_LEN];
			UnicodeToAnsi(gpSyser->m_szDbgFileNameFilter.operator const WCHAR*(), szFilter, MAX_FN_LEN);

			int Len = TStrLen(szFilter); //TStrLen(szFilter, MAX_FN_LEN);
			MAX_LIMIT(Len, MAX_FN_LEN-1);

			for (int i = Len; i >= 0; --i) //TStrReplace(szFilter, Len, '|', '\0');
			{
				if (szFilter[i] == '|')
					szFilter[i] = 0;
			}

			ofn.lpstrFilter = szFilter;
			ofn.lpstrFile = szFileName;
			ofn.nMaxFile = MAX_FN_LEN;
			szFileName[0] = 0;
			gpSyser->LockTimer();
			if (!::GetOpenFileNameA(&ofn))
			{
				gpSyser->UnlockTimer();
				return true;
			}
			gpSyser->UnlockTimer();

			TStrCpy(szFileName, ofn.lpstrFile);
		} else
		{
			szFileName[0] = 0;
		}
	#else
		if (!gpSyser->OpenFileDialog(szFileName))
			return true;
	#endif
		if (!gpSyser->m_SyserUI.m_SyserCodeDoc.Open(szFileName))
			gpSyser->m_MainFrame.m_SystemExplorer.m_TerminalWnd.Printf(WSTR("Fail to open file !\n"));
		return true;
	}

	bool CSystemExplorer::OnEventClose(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("close"), 0);
		return true;
	}

	bool CSystemExplorer::OnEventSaveComment(WISP_MSG *pMsg)
	{
		gpSyser->m_SyserUI.SaveComment();
		return true;
	}
	bool CSystemExplorer::OnEventLoadComment(WISP_MSG *pMsg)
	{
		gpSyser->m_SyserUI.LoadComment();
		return true;
	}
	bool CSystemExplorer::OnEventLoadSymbol(WISP_MSG *pMsg)
	{
		char szSDSDir[MAX_FN_LEN]; 
		char szSDSFullFileName[MAX_FN_LEN];

		OPENFILENAMEA ofn;
		memset(&ofn, 0, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn); //0x4C;
		ofn.hInstance = gpSyser->m_hInstance;
		ofn.hwndOwner = gpSyser->m_hWnd;
		ofn.lpstrFilter = "Symbol Files";
		ofn.nMaxFile = MAX_FN_LEN;
		ofn.lpstrFile = szSDSFullFileName;
		GetModulePath(szSDSDir, true);
		TStrCat(szSDSDir, "Symbols");
		szSDSFullFileName[0] = 0;
		ofn.lpstrInitialDir = szSDSDir;
		gpSyser->LockTimer();
		if (!::GetOpenFileNameA(&ofn))
		{
			gpSyser->UnlockTimer();
		} else
		{
			gpSyser->UnlockTimer();
			gpSyser->m_SyserUI.LoadSDSModule(szSDSFullFileName);
		}
		return true;
	}
	bool CSystemExplorer::OnEventNextPos(WISP_MSG *pMsg)
	{
		m_pCodeView->OnEventNextPos(pMsg);
		return true;
	}
	bool CSystemExplorer::OnEventPrevPos(WISP_MSG *pMsg)
	{
		m_pCodeView->OnEventPrevPos(pMsg);
		return true;
	}
	bool CSystemExplorer::OnEventSavePos(WISP_MSG *pMsg)
	{
		m_pCodeView->OnEventSavePos(pMsg);
		return true;
	}
	bool CSystemExplorer::OnEventResetPos(WISP_MSG *pMsg)
	{
		m_pCodeView->OnEventResetPos(pMsg);
		return true;
	}
	bool CSystemExplorer::OnEventDbgReset(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("reset"), 0);
		return true;
	}
	bool CSystemExplorer::OnEventDbgStep(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("t"), 0);
		return true;
	}
	bool CSystemExplorer::OnEventDbgProceed(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("p"), 0);
		return true;
	}
	bool CSystemExplorer::OnEventStepBranch(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("tb"), 0);
		return true;
	}
	bool CSystemExplorer::OnEventDbgReturn(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("p ret"), 0);
		return true;
	}
	bool CSystemExplorer::OnEventDbgContinue(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("x"), 0);
		return true;
	}
	bool CSystemExplorer::OnEventBreakPointForm(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_BreakPointForm.Create();
		return pMsg->Command.CmdMsg != 0x80002000;
	}

	bool CSystemExplorer::OnEventDebuggerSelectForm(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_DebuggerSelectForm.Create();
		return true;
	}

	bool CSystemExplorer::OnEventOptionForm(WISP_MSG *pMsg)
	{
		if (m_SyserOptionForm.IsWindow())
			m_SyserOptionForm.Show(WISP_SH_MINSIZE);
		else	m_SyserOptionForm.Create(0, WISP_SH_MINSIZE);
		return true;
	}

	bool CSystemExplorer::OnEventPluginListForm(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_PluginListForm.Create();
		return true;
	}

	bool CSystemExplorer::OnEventTabGeneReg(WISP_MSG *pMsg)
	{
		CWispTabWnd *pWnd = (CWispTabWnd *)m_RegTabWnd.GetActiveWnd();
		if (pWnd) pWnd->SetActiveWnd(CV_REG_GENE_TAB); //CV_REG_GENE_TAB(0)
		return false;
	}
	bool CSystemExplorer::OnEventTabFPUReg(WISP_MSG *pMsg)
	{
		CWispTabWnd *pWnd = (CWispTabWnd *)m_RegTabWnd.GetActiveWnd();
		if (pWnd) pWnd->SetActiveWnd(CV_REG_FPU_TAB); //CV_REG_FPU_TAB(1)
		return false;
	}
	bool CSystemExplorer::OnEventTabSSEReg(WISP_MSG *pMsg)
	{
		CWispTabWnd *pWnd = (CWispTabWnd *)m_RegTabWnd.GetActiveWnd();
		if (pWnd) pWnd->SetActiveWnd(CV_REG_SSE_TAB); //CV_REG_SSE_TAB(2)
		return false;
	}

	bool CSystemExplorer::OnEventWatch(WISP_MSG *pMsg)
	{
		m_ContextTabWnd.SetActiveWnd(CV_W_TAB); //CV_W_TAB(1)
		return false;
	}
	bool CSystemExplorer::OnEventStack(WISP_MSG *pMsg)
	{
		m_ContextTabWnd.SetActiveWnd(CV_S_TAB); //CV_S_TAB(0)
		return false;
	}
	bool CSystemExplorer::OnEventIDT(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_IDTWnd.Create();
		return true;
	}
	bool CSystemExplorer::OnEventGDT(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_GDTWnd.Create();
		return true;
	}
	bool CSystemExplorer::OnEventLDT(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_GDTWnd.Create();
		return true;
	}
	bool CSystemExplorer::OnEventProcessList(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ProcessList.Create();
		return true;
	}
	bool CSystemExplorer::OnEventThreadList(WISP_MSG *pMsg)
	{
		//m_ThreadListWnd.Create(); TODO
		return true;
	}
	bool CSystemExplorer::OnEventModuleList(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ModuleListWnd.Create(false);
		return true;
	}
	bool CSystemExplorer::OnEventFunctionList(WISP_MSG *pMsg)
	{
		if (m_FunctionListWnd.IsWindow())
		{
			m_FunctionListWnd.Show(WISP_SH_MINSIZE);
		} else
		{
			m_FunctionListWnd.CreateWnd(WSTR("Functions"), 0,0,500,350, 0, 0x45, 0x100BB, WISP_SH_MINSIZE);
			m_FunctionListWnd.SetOwner(this);
			m_FunctionListWnd.m_ItemColor = gSyserColors.Color[1];
			m_FunctionListWnd.m_Style |= 0x1000000;
			m_FunctionListWnd.SetBGColor(gSyserColors.Color[0]);
			m_FunctionListWnd.InsertColumn(WSTR("Function name"), 240, 0, 0, -1);
			m_FunctionListWnd.InsertColumn(WSTR("Start"), 80, 0, 0, -1);
			m_FunctionListWnd.InsertColumn(WSTR("Length"), 80, 0, 0, -1);
			m_FunctionListWnd.InsertColumn(WSTR("BP based frame"), 80, 0, 0, -1);
		}
		m_FunctionListWnd.Center(0);
		return true;
	}
	bool CSystemExplorer::OnEventHwndList(WISP_MSG *pMsg)
	{
		//TODO gpSyser->m_MainFrame.m_HwndListWnd.Create();
		return true;
	}
	bool CSystemExplorer::OnEventRunTrace(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_RunTraceWnd.Create();
		return true;
	}
	bool CSystemExplorer::OnEventSeachDialog(WISP_MSG *pMsg)
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
			m_SearchDialog.Create(nullptr, 1);
		return true;
	}
	bool CSystemExplorer::OnEventCommentList(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_CommentList.Create();
		return true;
	}
	bool CSystemExplorer::OnEventPageMap(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_PageMapWnd.Create();
		return true;
	}
	bool CSystemExplorer::OnEventRegHelp(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_X86RegHelpTabWnd.Create();
		return true;
	}

	bool CSystemExplorer::OnEventAboutForm(WISP_MSG *pMsg)
	{
		CAboutForm AboutForm;
		AboutForm.Create(0, WISP_SH_MODAL_BLOCK);
		return true;
	}

	bool CSystemExplorer::OnEventCheckNew(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}
	bool CSystemExplorer::OnEventObjDirWnd(WISP_MSG *pMsg)
	{
		//TODO
		//m_ObjectDirectoryWnd.Create();
		return true;
	}

	bool CSystemExplorer::OnEventCalc(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_CalcWnd.Create();
		return true;
	}

	bool CSystemExplorer::OnEventCallStack(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_CallStackWnd.Create();
		return true;
	}

	bool CSystemExplorer::OnEventRegView(WISP_MSG *pMsg)
	{
		if (!gpSyser->m_MainFrame.m_pGeneRegList)
			gpSyser->m_MainFrame.m_pGeneRegList = new CGeneRegList[dwCPUNumbers];

		int nActiveCPU = GetActiveCPU();

		if (gpSyser->m_MainFrame.m_CPUTabWnd.IsWindow())
		{
			gpSyser->m_MainFrame.m_CPUTabWnd.Destroy();
			for (int i = 0; i < dwCPUNumbers; ++i)
			{
				gpSyser->m_MainFrame.m_pGeneRegList[i].Destroy();
			}
			return true;
		}

		WISP_RECT Rect;
		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 320;
		Rect.cy = 210;
		
		gpSyser->m_MainFrame.m_CPUTabWnd.CreateWnd(WSTR("Register View"), Rect, 0, 0, 0x200BB, WISP_SH_MINSIZE);

		for (int nCPU = 0; nCPU < dwCPUNumbers; ++nCPU)
		{
			Rect.x = 0;
			Rect.y = 0;
			Rect.cx = 0;
			Rect.cy = 0;
			if (!gpSyser->m_MainFrame.m_pGeneRegList[nCPU].CreateWnd(0, Rect, &gpSyser->m_MainFrame.m_CPUTabWnd, CMD_ID_GENE_REG, 0x1030000, WISP_SH_MINSIZE))
				return false;
			gpSyser->m_MainFrame.m_pGeneRegList[nCPU].m_nCPU = nCPU;

			WCHAR szCPUNum[20];
			if (nCPU == nActiveCPU)
				TSPrintf(szCPUNum, WSTR("*CPU %d "), nCPU);
			else	TSPrintf(szCPUNum, WSTR(" CPU %d "), nCPU);

			gpSyser->m_MainFrame.m_CPUTabWnd.InsertWnd(szCPUNum, &gpSyser->m_MainFrame.m_pGeneRegList[nCPU], 0);
			gpSyser->m_MainFrame.m_pGeneRegList[nCPU].UpdateContext();
		}
		return true;
	}
	bool CSystemExplorer::OnEventDataViewForm(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_DataViewForm.Create();
		return true;
	}
	bool CSystemExplorer::OnEventSoftKB(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_SoftKeyboard.Create();
		return true;
	}
	bool CSystemExplorer::OnEventKeyMap(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}
	bool CSystemExplorer::OnEventPEExplorerForm(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_PEExplorerForm.Create();
		return true;
	}
	bool CSystemExplorer::OnEventIBM(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}
	bool CSystemExplorer::OnEventEBCDI(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}
	bool CSystemExplorer::OnEventANSI(WISP_MSG *pMsg)
	{
		//TODO
		return true;
	}

	bool CSystemExplorer::OnEventToggleBM(WISP_MSG *pMsg)
	{
		m_MultiCodeView.ToggleBM();
		return true;
	}
	bool CSystemExplorer::OnEventNextBM(WISP_MSG *pMsg)
	{
		m_MultiCodeView.NextBM();
		return true;
	}
	bool CSystemExplorer::OnEventPrevBM(WISP_MSG *pMsg)
	{
		m_MultiCodeView.PrevBM();
		return true;
	}
	bool CSystemExplorer::OnEventClearBM(WISP_MSG *pMsg)
	{
		m_MultiCodeView.ClearBM();
		return true;
	}

	bool CSystemExplorer::OnEventSEH(WISP_MSG *pMsg)
	{
#ifndef _X64_
		m_SEHChainWnd.Create();
#endif
		return true;
	}
	bool CSystemExplorer::OnEventFile(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("File"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSystemExplorer::OnEventDebug(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("Debug"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSystemExplorer::OnEventMonitor(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("Monitor"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSystemExplorer::OnEventView(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("View"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSystemExplorer::OnEventInformation(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("Information"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSystemExplorer::OnEventOption(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("Option"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSystemExplorer::OnEventTools(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("Tools"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}
	bool CSystemExplorer::OnEventHelp(WISP_MSG *pMsg)
	{
		m_MainMenu.Focus();
		CWispMenu::MenuItem *Item = m_MainMenu.GetItem(WSTR("Help"));
		if (Item)
		{
			m_MainMenu.UpdateItem(Item);
			WISP_MSG Msg;
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_RETURN;
			m_MainMenu.OnKeyEvent(&Msg);
			Msg.KeyEvent.bKeyDown = true;
			Msg.KeyEvent.KeyType = VK_DOWN;
			m_MainMenu.OnKeyEvent(&Msg);
		}
		return true;
	}

	bool CSystemExplorer::OnEventDataShow(WISP_MSG *pMsg)
	{
		CWispBaseWnd *pWnd = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiDataView.GetActiveWnd();
		if (pWnd) pWnd->Focus();
		return true;
	}
	bool CSystemExplorer::OnEventCodeShow(WISP_MSG *pMsg)
	{
		CWispBaseWnd *pWnd = gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
		if (pWnd) pWnd->Focus();
		return true;
	}

	bool CSystemExplorer::OnEventStrRef(WISP_MSG *pMsg)
	{
		if (gpSyser->m_MainFrame.m_FindListWnd.IsWindow())
			gpSyser->m_MainFrame.m_FindListWnd.Destroy();
		gpSyser->m_MainFrame.m_FindListWnd.CreateWnd(WSTR("String Reference"), 0,0,564,344, 0, EVENT_ID_STRFIND, 0x300BB, WISP_SH_MINSIZE);
		return true;
	}

	bool CSystemExplorer::OnEventNextCVTrace(WISP_MSG *pMsg)
	{
		CTracePoint *pTrace = gpSyser->m_MainFrame.m_SystemExplorer.NextCIP();
		if (!pTrace) return false;
		CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
		if (pWnd)
		{
			pWnd->GotoAddr(pTrace->Address, false);
			pWnd->SelectAddr(pTrace->Address + pTrace->Offset);
		}
		return true;
	}
	bool CSystemExplorer::OnEventPrevCVTrace(WISP_MSG *pMsg)
	{
		CTracePoint *pTrace = gpSyser->m_MainFrame.m_SystemExplorer.PrevCIP();
		if (!pTrace) return false;
		CCodeView *pWnd = (CCodeView *)gpSyser->m_MainFrame.m_SystemExplorer.m_MultiCodeView.GetActiveWnd();
		if (pWnd)
		{
			pWnd->GotoAddr(pTrace->Address, false);
			pWnd->SelectAddr(pTrace->Address + pTrace->Offset);
		}
		return true;
	}

	bool CSystemExplorer::OnEventBPEnableAll(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("be *"), 0);
		return true;
	}
	bool CSystemExplorer::OnEventBPRemoveAll(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("bc *"), 0);
		return true;
	}
	bool CSystemExplorer::OnEventBPDisableAll(WISP_MSG *pMsg)
	{
		gpSyser->m_MainFrame.m_ConsoleWnd.CCmdParser::ParseCmd(WSTR("bd *"), 0);
		return true;
	}

	bool CSystemExplorer::OnEventLoadHistory(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdID >= EVENT_ID_FILE1 && pMsg->Command.CmdID <= EVENT_ID_FILE8)
		{
			TListIter<RECENT_HISTORY_ITEM> It = gpSyser->m_HistoryList[pMsg->Command.CmdID-EVENT_ID_FILE1];
			if (It != gpSyser->m_HistoryList.End())
			{
				gpSyser->m_SyserUI.m_SyserCodeDoc.Close();
				gpSyser->m_SyserUI.m_SyserCodeDoc.Open(It->FileName.operator const char*());
			}
		}
		return true;
	}

	bool CSystemExplorer::OnEventTypeViewerWnd(WISP_MSG *pMsg)
	{
		m_pTypeViewerWnd = new CTypeViewerWnd;
		WISP_RECT Rect;
		Rect.x = 0;
		Rect.y = 0;
		Rect.cx = 0;
		Rect.cy = 0;
		m_pTypeViewerWnd->CreateWnd(0, Rect, &m_ContextTabWnd, 0, 0x30006, 1); //SHOW_SH_MINSIZE
		m_pTypeViewerWnd->m_AdvStyle |= 1; //????
		CWispDIB *pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0xE2);
		int Index = m_ContextTabWnd.InsertWnd(WSTR("Struct Viewer"), m_pTypeViewerWnd, pDIB);
		m_ContextTabWnd.SetActiveWnd(Index);
		return true;
	}

	void CSystemExplorer::ResetContext()
	{
		for (int i = 0; i < dwCPUNumbers; ++i)
		{
			m_pGeneRegList[i].ResetContext();
			m_pFpuRegisterList[i].ResetContext();
			m_pSSERegisterList[i].ResetContext();
		}
		m_StackWatchList.ResetContext();
		m_WatchList.ResetContext();
		m_MultiCodeView.ResetContext();
		m_MultiDataView.ResetContext();
		if (m_pTypeViewerWnd)
			m_pTypeViewerWnd->ResetContext();
		gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_TypeViewerWnd.ResetContext();
		m_pInstrInfo->SetWindowText(WSTR(""));
		m_InfoStr.SetWindowText(WSTR(""));
	}

	void CSystemExplorer::UpdateMenu()
	{
		m_Toolbar.Enable(EVENT_ID_OPEN, !gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_OPEN, !gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_CLOSE, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_CLOSE, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_DBG_RESET, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_DBG_RESET, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_GO, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_GO, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_DBG_RETURN, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_DBG_RETURN, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_DBG_STEP, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_DBG_STEP, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_DBG_PROCEED, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_DBG_PROCEED, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_DBG_STEPB, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_DBG_STEPB, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_SAVECMT, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_SAVECMT, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_LOADCMT, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_LOADCMT, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_FILE0, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_FILE0, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_SAVEPOS, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_SAVEPOS, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		m_Toolbar.Enable(EVENT_ID_PREVPOS, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_pCodeView->m_HistoryIter != m_pCodeView->m_History.Begin());
		m_MainMenu.Enable(EVENT_ID_PREVPOS, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_pCodeView->m_HistoryIter != m_pCodeView->m_History.Begin());

		m_Toolbar.Enable(EVENT_ID_NEXTPOS, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_pCodeView->m_HistoryIter != m_pCodeView->m_History.End()-1);
		m_MainMenu.Enable(EVENT_ID_NEXTPOS, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_pCodeView->m_HistoryIter != m_pCodeView->m_History.End()-1);

		m_Toolbar.Enable(EVENT_ID_CLRPOS, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_pCodeView->m_History.Size()>1);
		m_MainMenu.Enable(EVENT_ID_CLRPOS, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_pCodeView->m_History.Size()>1);

		m_Toolbar.Enable(EVENT_ID_TOGGLE_BM, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);
		m_MainMenu.Enable(EVENT_ID_TOGGLE_BM, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen);

		//Bookmark
		m_Toolbar.Enable(EVENT_ID_NEXT_BM, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_MultiCodeView.m_Bookmark.size()>0);
		m_MainMenu.Enable(EVENT_ID_NEXT_BM, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_MultiCodeView.m_Bookmark.size()>0);

		m_Toolbar.Enable(EVENT_ID_PREV_BM, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_MultiCodeView.m_Bookmark.size()>0);
		m_MainMenu.Enable(EVENT_ID_PREV_BM, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_MultiCodeView.m_Bookmark.size()>0);

		m_Toolbar.Enable(EVENT_ID_CLEAR_BM, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_MultiCodeView.m_Bookmark.size()>0);
		m_MainMenu.Enable(EVENT_ID_CLEAR_BM, gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && m_MultiCodeView.m_Bookmark.size()>0);

		m_Toolbar.Update((WISP_RECT*)0);
	}

	void CSystemExplorer::UpdateContext()
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen)
		{
			int nActiveCPU = GetActiveCPU();

			CWispBaseWnd *pFocusWnd = m_pWispBase->m_pFocusWnd;

			m_RegTabWnd.SetActiveWnd(nActiveCPU);

			WCHAR Buffer[128];
			TSPrintf(Buffer, WSTR("PID:%x TID:%x "), gpSyser->m_PID, gpSyser->m_TID);
			m_InfoStr.SetWindowText(Buffer);

			for (int nCPU = 0; nCPU < dwCPUNumbers; ++nCPU)
			{
				m_pGeneRegList[nCPU].UpdateContext();
				m_pFpuRegisterList[nCPU].UpdateContext();
				m_pSSERegisterList[nCPU].UpdateContext();

				if (dwCPUNumbers < 2 || m_pGeneRegList[nCPU].m_nCPU != nActiveCPU)
					TSPrintf(Buffer, WSTR(" CPU %d "), nCPU);
				else	TSPrintf(Buffer, WSTR("*CPU %d "), nCPU);

				m_RegTabWnd.SetTabText(nCPU, Buffer);

				//RegView
				if (gpSyser->m_MainFrame.m_pGeneRegList && gpSyser->m_MainFrame.m_pGeneRegList[nCPU].IsWindow())
				{
					gpSyser->m_MainFrame.m_pGeneRegList[nCPU].UpdateContext();
					if (nCPU == nActiveCPU)
						gpSyser->m_MainFrame.m_CPUTabWnd.SetActiveWnd(nActiveCPU);
					gpSyser->m_MainFrame.m_CPUTabWnd.SetTabText(nCPU, Buffer);
				}
			}
	
			m_WatchList.UpdateContext();
			m_StackWatchList.UpdateContext(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP, false);
			m_MultiCodeView.UpdateContext();
			m_MultiDataView.UpdateContext();
			if (m_pTypeViewerWnd)
				m_pTypeViewerWnd->UpdateContext();
			gpSyser->m_SyserUI.m_SyserCodeDoc.GetInstrInfo(Buffer);
			m_pInstrInfo->SetWindowText(Buffer);

			gpSyser->m_MainFrame.m_DataViewForm.UpdateContext();
			gpSyser->m_MainFrame.m_RunTraceWnd.UpdateContext();
			pFocusWnd->Focus();
			Update((WISP_RECT*)0);
		}
	}

	void CSystemExplorer::UpdateRegView()
	{
		CCodeView *pWnd = (CCodeView *)m_MultiCodeView.GetActiveWnd();
		if (pWnd)
		{
			int nWndIndex = m_MultiCodeView.GetActiveWndIndex();
			unsigned long Index = m_RunTrace.UpdateContext(pWnd->m_CurAddr, *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP, nWndIndex);
			m_CIPRegWndTrace = Index;
			m_CIPTrace = Index;

			for (int nCPU = 0; nCPU < m_nCPUNumbers; ++nCPU)
			{
				m_pGeneRegList[nCPU].EnableWindow(true);
			}
		}
	}

	void CSystemExplorer::ViewCodeAddress(ULONG_PTR Address)
	{
		if (gpSyser->m_pDebugger->m_CodeMode != gpSyser->m_SyserUI.m_SyserCodeDoc.m_Mode)
			gpSyser->m_SyserUI.SetCodeMode(gpSyser->m_pDebugger->m_CodeMode);

		CCodeView *pWnd = (CCodeView *)m_MultiCodeView.GetActiveWnd();
		if (pWnd)
		{
			ULONG_PTR Start;
			ULONG_PTR End;
			pWnd->GetCodeRange(&Start, &End);
			WCHAR Buffer[64];
			TSPrintf(Buffer, WSTR("" F0ADDR "X"), Address);
			m_MultiCodeView.SetTabText(m_MultiCodeView.GetActiveWndIndex(), Buffer);
			if (Address < Start || Address >= End)
			{
				pWnd->GotoAddr(Address, false);
			} else
			if (!gpSyser->m_SyserUI.m_SyserCodeDoc.IsDasm(Start, End - Start))
			{
				pWnd->GotoAddr(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP, false);
			}
		}
	}

	void CSystemExplorer::ResetView()
	{
		if (gpSyser->m_bActive)
		{
			m_MultiCodeView.ResetContext();
			m_MultiDataView.ResetContext();
		}
	}

	void CSystemExplorer::SelectCodeAddress(ULONG_PTR Address)
	{
		m_pCodeView->SelectAddress(Address);
	}

	void CSystemExplorer::CodeGotoAddr(ULONG_PTR Address, bool bHistory)
	{
		m_pCodeView->GotoAddr(Address, bHistory);
	}

	void CSystemExplorer::DataGotoAddr(ULONG_PTR Address, unsigned long Size)
	{
		CDataView *pWnd = (CDataView *)m_MultiDataView.GetActiveWnd();
		if (pWnd)
		{
			if (Size>0)
			{
				pWnd->m_bSelect = true;
				pWnd->m_SelStart = Address;
				pWnd->m_SelEnd = Address + Size - 1;
			} else
			{
				pWnd->m_bSelect = false;
			}
			pWnd->ViewAddress(Address, true);
		}
	}

	CTracePoint *CSystemExplorer::PrevCIP()
	{
		if (m_CIPTrace == 1)
			return nullptr;
		--m_CIPTrace;

		for (int nCPU = 0; nCPU < m_nCPUNumbers; ++nCPU)
		{
			if (!((m_pGeneRegList[nCPU].m_Style >> 9)&1))
				m_pGeneRegList[nCPU].EnableWindow(false);
		}

		if (m_CIPTrace == m_CIPRegWndTrace)
		{
			for (int nCPU = 0; nCPU < m_nCPUNumbers; ++nCPU)
			{
				m_pGeneRegList[nCPU].EnableWindow(true);
			}
		}

		CTracePoint *pTrace = m_RunTrace.GetTracePoint(m_CIPTrace-1);
		if (pTrace)
		{
			ULONG_PTR Addr = pTrace->Address + pTrace->Offset;
			unsigned long CPUType;
			X86_CPU_REG CpuREG;
			m_RunTrace.ReadContext(m_CIPTrace - 1, &CpuREG, &CPUType);
			CWispTabWnd *pWnd = (CWispTabWnd *)m_RegTabWnd.GetActiveWnd();
			if (pWnd)
			{
				CGeneRegList *pRegWnd = (CGeneRegList *)pWnd->GetWnd(0);
				pRegWnd->UpdateContextTrace(CPUType, &CpuREG, Addr);
				pRegWnd->Update((WISP_RECT*)0);
			}
		}
		return pTrace;
	}

	CTracePoint *CSystemExplorer::NextCIP()
	{
		if (m_CIPTrace == m_CIPRegWndTrace)
			return nullptr;
		++m_CIPTrace;
		if (m_CIPTrace == m_CIPRegWndTrace)
		{
			for (int nCPU = 0; nCPU < m_nCPUNumbers; ++nCPU)
			{
				m_pGeneRegList[nCPU].EnableWindow(true);
			}
		} else
		{
			for (int nCPU = 0; nCPU < m_nCPUNumbers; ++nCPU)
			{
				if (!((m_pGeneRegList[nCPU].m_Style >> 9)&1))
					m_pGeneRegList[nCPU].EnableWindow(false);
			}
		}

		CTracePoint *pTrace = m_RunTrace.GetTracePoint(m_CIPTrace-1);
		if (pTrace)
		{
			ULONG_PTR Addr = pTrace->Address + pTrace->Offset;
			unsigned long CPUType;
			X86_CPU_REG CpuREG;
			m_RunTrace.ReadContext(m_CIPTrace - 1, &CpuREG, &CPUType);
			CWispTabWnd *pWnd = (CWispTabWnd *)m_RegTabWnd.GetActiveWnd();
			if (pWnd)
			{
				CGeneRegList *pRegWnd = (CGeneRegList *)pWnd->GetWnd(0);
				pRegWnd->UpdateContextTrace(CPUType, &CpuREG, Addr);
				pRegWnd->Update((WISP_RECT*)0);
			}
		}
		return pTrace;
	}

	//from RunTraceWnd
	bool CSystemExplorer::TracePoint(unsigned int TracePoint)
	{
		m_CIPTrace = TracePoint + 2;
		CTracePoint *pTrace = PrevCIP();
		if (!pTrace) return false;
		CCodeView *pWnd = (CCodeView *)m_MultiCodeView.GetActiveWnd();
		if (!pWnd) return false;
		pWnd->GotoAddr(pTrace->Address, false);
		pWnd->SelectAddr(pTrace->Address + pTrace->Offset);
		return true;
	}

```

`source/WispSyser/systemexplorer.hpp`:

```hpp

#ifndef _SYSTEMEXPLORER_HPP_
#define _SYSTEMEXPLORER_HPP_

#include "../Code/define.h"
#include "../Code/alt/altmap.hpp"

#include "../Wisp/wispwnd.hpp"
#include "../Wisp/wispstatic.hpp"
#include "../Wisp/wispmenu.hpp"
#include "../Wisp/wispedit.hpp"
#include "../Wisp/wisptoolbar.hpp"
#include "../Wisp/wisptabwnd.hpp"
#include "../Wisp/wispsplitwnd.hpp"

#include "watchlist.hpp"
#include "stackwatchlist.hpp"
#include "multicodeview.hpp"
#include "multidataview.hpp"
#include "genereglist.hpp"
#include "fpuregisterlist.hpp"
#include "sseregisterlist.hpp"
#include "terminalwnd.hpp"
#include "syseroptionform.hpp"
#include "codeview.hpp"
#include "runtrace.hpp"
#ifndef _X64_
#include "sehchainwnd.hpp"
#endif
#include "searchdialog.hpp"
#include "typeviewerwnd.hpp"

//TODO
int GetActiveCPU();

struct CMainMenu : public CWispMenu
{
};

	struct StringRef
	{
		ULONG_PTR Address;
		unsigned long Len;
		StringRef(ULONG_PTR Address_, unsigned long Len_):
			Address(Address_), Len(Len_)
		{}
	};

#define CV_REG_GENE_TAB 0
#define CV_REG_FPU_TAB 1
#define CV_REG_SSE_TAB 2

#define CV_S_TAB 0
#define CV_W_TAB 1

struct CSystemExplorer : public CWispWnd
{
	CSyserOptionForm m_SyserOptionForm;
	CSearchDialog m_SearchDialog;
	CMainMenu m_MainMenu;
	CWispStaticStr m_VersionStr;
	CWispStaticStr m_InfoStr;
	CWispEdit *m_pInstrInfo;
	CWispToolbar m_Toolbar;
	CWatchList m_WatchList;
	CStackWatchList m_StackWatchList;
	CWispTabWnd m_RegTabWnd; //TAB
	CWispTabWnd m_ContextTabWnd; //TAB
	int m_SplitRight;
	CWispSplitWnd m_ViewSplitWnd;
	CWispSplitWnd m_MainSplitWnd;
	CWispSplitWnd m_MoniteSplitWnd;

	CMultiCodeView m_MultiCodeView;
	CMultiDataView m_MultiDataView;

	int m_nCPUNumbers;
	CFpuRegisterList *m_pFpuRegisterList;
	CSSERegisterList *m_pSSERegisterList;
	CGeneRegList *m_pGeneRegList;
	CWispTabWnd *m_pRegsTabWnd;

	CTerminalWnd m_TerminalWnd;
	CCodeView *m_pCodeView;

	CRunTrace m_RunTrace;
	//X86_CPU_REG m_CPUReg;
	unsigned int m_CIPTrace;
	unsigned int m_CIPRegWndTrace;

	//CThreadListWnd m_ThreadListWnd;
#ifndef _X64_
	CSEHChainWnd m_SEHChainWnd;
#endif
	map<ULONG_PTR,StringRef> m_FoundStringRefMap;
	//CAnalyzer m_Analyzer;
	CWispList m_FunctionListWnd;

	CTypeViewerWnd *m_pTypeViewerWnd;	//+++

	CSystemExplorer();
	virtual ~CSystemExplorer();

	virtual void Hide() override;
	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool CreateRegsTabs(WISP_MSG *pMsg);

	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);

	bool OnCmdMainSplit(WISP_MSG *pMsg);
	bool OnCmdViewSplit(WISP_MSG *pMsg);
	bool OnCmdMoniteSplit(WISP_MSG *pMsg);
	bool OnCmdGotoFunction(WISP_MSG *pMsg);

	bool OnCommand(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);
	void AdjustSplit();
	bool OnSize(WISP_MSG *pMsg);
	bool OnGetFocus(WISP_MSG *pMsg);

	bool OnEventOpen(WISP_MSG *pMsg);
	bool OnEventClose(WISP_MSG *pMsg);

	bool OnEventSaveComment(WISP_MSG *pMsg);
	bool OnEventLoadComment(WISP_MSG *pMsg);
	bool OnEventLoadSymbol(WISP_MSG *pMsg);
	bool OnEventNextPos(WISP_MSG *pMsg);
	bool OnEventPrevPos(WISP_MSG *pMsg);
	bool OnEventSavePos(WISP_MSG *pMsg);
	bool OnEventResetPos(WISP_MSG *pMsg);
	bool OnEventDbgReset(WISP_MSG *pMsg);
	bool OnEventDbgStep(WISP_MSG *pMsg);
	bool OnEventDbgProceed(WISP_MSG *pMsg);
	bool OnEventStepBranch(WISP_MSG *pMsg);
	bool OnEventDbgReturn(WISP_MSG *pMsg);
	bool OnEventDbgContinue(WISP_MSG *pMsg);
	bool OnEventBreakPointForm(WISP_MSG *pMsg);

	bool OnEventDebuggerSelectForm(WISP_MSG *pMsg);
	bool OnEventOptionForm(WISP_MSG *pMsg);
	bool OnEventPluginListForm(WISP_MSG *pMsg);

	bool OnEventTabGeneReg(WISP_MSG *pMsg);
	bool OnEventTabFPUReg(WISP_MSG *pMsg);
	bool OnEventTabSSEReg(WISP_MSG *pMsg);

	bool OnEventWatch(WISP_MSG *pMsg);
	bool OnEventStack(WISP_MSG *pMsg);
	bool OnEventIDT(WISP_MSG *pMsg);
	bool OnEventGDT(WISP_MSG *pMsg);
	bool OnEventLDT(WISP_MSG *pMsg);
	bool OnEventProcessList(WISP_MSG *pMsg);
	bool OnEventThreadList(WISP_MSG *pMsg);
	bool OnEventModuleList(WISP_MSG *pMsg);
	bool OnEventFunctionList(WISP_MSG *pMsg);
	bool OnEventHwndList(WISP_MSG *pMsg);
	bool OnEventRunTrace(WISP_MSG *pMsg);
	bool OnEventSeachDialog(WISP_MSG *pMsg);
	bool OnEventCommentList(WISP_MSG *pMsg);
	bool OnEventPageMap(WISP_MSG *pMsg);
	bool OnEventRegHelp(WISP_MSG *pMsg);

	bool OnEventAboutForm(WISP_MSG *pMsg);

	bool OnEventCheckNew(WISP_MSG *pMsg);
	bool OnEventObjDirWnd(WISP_MSG *pMsg);

	bool OnEventCalc(WISP_MSG *pMsg);

	bool OnEventCallStack(WISP_MSG *pMsg);

	bool OnEventRegView(WISP_MSG *pMsg);
	bool OnEventDataViewForm(WISP_MSG *pMsg);
	bool OnEventSoftKB(WISP_MSG *pMsg);
	bool OnEventKeyMap(WISP_MSG *pMsg);
	bool OnEventPEExplorerForm(WISP_MSG *pMsg);
	bool OnEventIBM(WISP_MSG *pMsg);
	bool OnEventEBCDI(WISP_MSG *pMsg);
	bool OnEventANSI(WISP_MSG *pMsg);

	bool OnEventToggleBM(WISP_MSG *pMsg);
	bool OnEventNextBM(WISP_MSG *pMsg);
	bool OnEventPrevBM(WISP_MSG *pMsg);
	bool OnEventClearBM(WISP_MSG *pMsg);

	bool OnEventSEH(WISP_MSG *pMsg);
	bool OnEventFile(WISP_MSG *pMsg);
	bool OnEventDebug(WISP_MSG *pMsg);
	bool OnEventMonitor(WISP_MSG *pMsg);
	bool OnEventView(WISP_MSG *pMsg);
	bool OnEventInformation(WISP_MSG *pMsg);
	bool OnEventOption(WISP_MSG *pMsg);
	bool OnEventTools(WISP_MSG *pMsg);
	bool OnEventHelp(WISP_MSG *pMsg);

	bool OnEventDataShow(WISP_MSG *pMsg);
	bool OnEventCodeShow(WISP_MSG *pMsg);

	bool OnEventStrRef(WISP_MSG *pMsg);

	bool OnEventNextCVTrace(WISP_MSG *pMsg);
	bool OnEventPrevCVTrace(WISP_MSG *pMsg);

	bool OnEventBPEnableAll(WISP_MSG *pMsg);
	bool OnEventBPRemoveAll(WISP_MSG *pMsg);
	bool OnEventBPDisableAll(WISP_MSG *pMsg);

	bool OnEventLoadHistory(WISP_MSG *pMsg);

	bool OnEventTypeViewerWnd(WISP_MSG *pMsg);

	void ResetContext();
	void UpdateMenu();
	void UpdateContext();
	void UpdateRegView();
	void ViewCodeAddress(ULONG_PTR Address);
	void ResetView();
	void SelectCodeAddress(ULONG_PTR Address);
	void CodeGotoAddr(ULONG_PTR Address, bool bHistory);
	void DataGotoAddr(ULONG_PTR Address, unsigned long Size);

	CTracePoint *PrevCIP();
	CTracePoint *NextCIP();
	bool TracePoint(unsigned int TracePoint);
};

#endif
```

`source/WispSyser/terminalwnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"

#include "terminalwnd.hpp"

	WISP_MSG_MAP_BEGIN(CTerminalWnd)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
	WISP_MSG_MAP_END(CWispTerminalWnd)

	bool CTerminalWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.KeyType == VK_TAB && pMsg->KeyEvent.bKeyDown)
		{
			WCHAR *pStr = TStrRChr(m_InputStr.operator const WCHAR*(), 0x20);
			if (pStr && TStrLen(pStr)>2)
			{
				char szStr[64];
				int Len = TStrCpy(szStr, pStr+1);
				if (gpSyser->m_SyserUI.GetModuleName(szStr) > Len)
				{
					m_InputStr.SetAt(PTR_DELTA(pStr,m_InputStr.m_pData)/2+1, 0);
					WCHAR szuStr[64];
					AnsiToUnicode(szStr, szuStr, lenof(szuStr));
					m_InputStr += szuStr;
					m_CaretPos.x = m_InputStr.m_nLength;
				}
			}
		}
		return true;
	}	

```

`source/WispSyser/terminalwnd.hpp`:

```hpp

#ifndef _TERMINALWND_HPP_
#define _TERMINALWND_HPP_

#include "../Wisp/wispconsolewnd.hpp"

struct CTerminalWnd : public CWispTerminalWnd
{
	virtual bool MsgProc(WISP_MSG *pMsg) override;
	bool OnKeyEvent(WISP_MSG *pMsg);
};

#endif
```

`source/WispSyser/typeviewerform.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "typeviewerform.hpp"
#include "syserconfig.hpp"

	//TODO CHOOSE MODULE SYMBOL MENU

WISP_FORM_RES_ITEM TypeViewerForm[] =
{

	{WISP_CTRL_FORM, {0, 0, 386, 268}, 0, 0xB, WSTR("Attach Type"), (void*)"\\SyserIcon\\Plugin.ico", 0},
	{WISP_CTRL_STATIC_GROUP, {166, 10, 204, 56}, 0, 0, WSTR("Description"), 0, 0},
	{WISP_CTRL_STATIC_STRING, {174, 30, 204, 56}, 8, 0, WSTR(""), 0, 0},
	{WISP_CTRL_STATIC_GROUP, {166, 75, 204, 106}, 0, 0, WSTR("Options"), 0, 0},
	{WISP_CTRL_LIST, {5, 5, 155, 230}, 3, 0x10006, 0, 0, 0},
	{WISP_CTRL_RADIO_BOX, {176, 90, 100, 16}, 4, 0x1000006, WSTR("Floating Type"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {176, 110, 90, 16}, 5, 0x1000006, WSTR("Lock Type"), 0, 0},
	{WISP_CTRL_STATIC_STRING, {194, 135, 45, 16}, 0xC, 0, WSTR("Address:"), 0, 0},
	{WISP_CTRL_EDIT, {245, 135, 93, 16}, 0xD, 0x1000006, 0, 0, 0},
	{WISP_CTRL_RADIO_BOX, {245, 155, 45, 16}, 0xA, 0x1000006, WSTR("Dec"), 0, 0},
	{WISP_CTRL_RADIO_BOX, {301, 155, 45, 16}, 9, 0x1000006, WSTR("Hex"), 0, 0},
	{WISP_CTRL_BUTTON, {185, 197, 68, 25}, 1, 0, WSTR("OK"), 0, 0},
	{WISP_CTRL_BUTTON, {280, 197, 68, 25}, 2, 0, WSTR("Cancel"), 0, 0},
	{0},
};

	WISP_MSG_MAP_BEGIN(CStructViewerForm)
		WISP_MSG_MAP(WISP_WM_CREATE_FORM, OnCreateForm)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP_ON_COMMAND
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispForm)

        WISP_CMD_MAP_BEGIN(CStructViewerForm)
		WISP_CMD_MAP(3, OnCmdSelect)
        WISP_CMD_MAP_END

        WISP_EVENT_MAP_BEGIN(CStructViewerForm)
		WISP_EVENT_MAP(1, OnEventAdd)
		WISP_EVENT_MAP(2, OnEventClose)

		WISP_EVENT_MAP(4, OnEventFloating)
		WISP_EVENT_MAP(5, OnEventLock)

		WISP_EVENT_MAP(9, OnEventLock) //+++
		WISP_EVENT_MAP(10, OnEventLock) //+++
        WISP_EVENT_MAP_END

	CStructViewerForm::CStructViewerForm()
	{
		m_Resource = TypeViewerForm;
	}
	CStructViewerForm::~CStructViewerForm()
	{
	}

	bool CStructViewerForm::OnCreateForm(WISP_MSG *pMsg)
	{
		m_DIBList.Load("\\sysericon\\SourceCodeIcon.bmp", 16, 16, 80);
		m_DIBList.SetColorKey(0xFF00);

		m_ItemOk = (CWispButton*)GetFormItem(1);
		m_ItemCancel = (CWispButton*)GetFormItem(2);

		m_ItemFloatingType = (CWispRadioBox*)GetFormItem(4);
		m_ItemLockType = (CWispRadioBox*)GetFormItem(5);

		m_ItemDescription = (CWispStaticStr*)GetFormItem(8);

		m_ItemDec = (CWispRadioBox*)GetFormItem(0xA);
		m_ItemHex = (CWispRadioBox*)GetFormItem(9);

		m_ItemAddress = (CWispEdit*)GetFormItem(0xD);
		m_ItemAddressStr = (CWispStaticStr*)GetFormItem(0xC);
		m_ItemOptions = (CWispList*)GetFormItem(3);
		m_ItemOptions->InsertColumn(WSTR(""), 500, 0, 0, -1);

		m_ItemHex->Enable(1);
		m_ItemFloatingType->Enable(1);

		m_ItemAddress->EnableWindow(0);
		m_ItemHex->EnableWindow(0);
		m_ItemDec->EnableWindow(0);
		m_ItemAddressStr->EnableWindow(0);
		m_ItemOk->EnableWindow(0);

		m_ItemDescription = (CWispStaticStr*)GetFormItem(8);
		m_ItemDescription->SetWindowText(WSTR("Attach type to address."));

		ULONG_PTR Address = gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP?*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP:0;
		m_pSDSMod = gpSyser->m_SyserUI.FindSDSModule(Address);

		UpdateContext();
 		return true;
	}

	bool CStructViewerForm::OnDestroy(WISP_MSG *pMsg)
	{
		//
		return true;
	}

	bool CStructViewerForm::OnCmdSelect(WISP_MSG *pMsg)
	{
		if (pMsg->Command.CmdMsg == 0x80000105)
			m_ItemOk->EnableWindow(1);
		return true;
	}

	bool CStructViewerForm::OnEventAdd(WISP_MSG *pMsg)	
	{
		CListStringItem *Item = m_ItemOptions->GetNext(0, 8);
		if (Item)
		{
			unsigned long ID = m_ItemOptions->GetItemValue(Item, 0);
			if (!gpSyser->m_MainFrame.m_SystemExplorer.m_pTypeViewerWnd)
				gpSyser->m_MainFrame.m_SystemExplorer.OnEventTypeViewerWnd(nullptr);
			if (gpSyser->m_MainFrame.m_SystemExplorer.m_pTypeViewerWnd)
			{
				//OLD CSDSModule *pSDSMod = gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_pSDSMod;
				//ULONG_PTR Address = gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP?*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP:0;
				//CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(Address);
				gpSyser->m_MainFrame.m_SystemExplorer.m_pTypeViewerWnd->Show(m_pSDSMod, ID, m_Address, TV_FUNC_MASK|TV_HEX_MASK|TV_STATIC_MASK, nullptr, nullptr);
			}
		}
		CWispBaseWnd::Close();
		return true;
	}
	bool CStructViewerForm::OnEventClose(WISP_MSG *pMsg)
	{
		CWispBaseWnd::Close();
		return true;
	}
	bool CStructViewerForm::OnEventLock(WISP_MSG *pMsg)
	{
		m_ItemAddress->EnableWindow(1);
		m_ItemHex->EnableWindow(1);
		m_ItemDec->EnableWindow(1);
		m_ItemAddressStr->EnableWindow(1);

		WCHAR Buffer[30];
		if (m_ItemHex->m_Style & 0x400)
			TSPrintf(Buffer, WSTR("%X"), m_Address);
		else	TSPrintf(Buffer, WSTR("%d"), m_Address);
		m_ItemAddress->SetWindowText(Buffer);

		return true;
	}
	//bool CStructViewerForm::OnEventLockUpdate(WISP_MSG *pMsg)
	bool CStructViewerForm::OnEventFloating(WISP_MSG *pMsg)
	{
		m_ItemAddress->EnableWindow(0);
		m_ItemHex->EnableWindow(0);
		m_ItemDec->EnableWindow(0);
		m_ItemAddressStr->EnableWindow(0);
		const WCHAR *Str = m_ItemAddress->GetWindowText().operator const WCHAR*();
		ULONG_PTR Result = 0;
		if (m_ItemHex->m_Style & 0x400)
		{
			if (USHexStrToNum(Str, &Result)) m_Address = Result;
		} else
		{
			if (USDecStrToNum(Str, &Result)) m_Address = Result;
		}
		m_ItemAddress->SetWindowText(WSTR(""));
		return true;
	}
	bool CStructViewerForm::Create(CWispWnd *pParentWnd, int ShowMode, ULONG_PTR Address)
	{
		m_Address = Address;
		return CWispForm::Create(pParentWnd, ShowMode);
	}

	void CStructViewerForm::UpdateContext()
	{
		//OLD CSDSModule *pSDSMod = gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_pSDSMod;
		//ULONG_PTR Address = gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP?*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP:0;
		//CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(Address);
		if (m_pSDSMod)
		{
			m_ItemOptions->DeleteAllChildrenItems(nullptr);
			unsigned long Len = 0;
			BASICTYPE **type = m_pSDSMod->GetGlobal(&Len);

			for (unsigned long n = 1; n < Len; ++n)
			{
				if (type[n]->Elem.Type == ELEM_CLASS)
				{
					CListStringItem *Item = m_ItemOptions->InsertItemStr(type[n]->Elem.Name, 0, 0, m_DIBList.GetDIB(0), -1);
					m_ItemOptions->SetItemValue(Item, 0, n);
				}
			}

			for (unsigned long n = 1; n < Len; ++n)
			{
				if (type[n]->Elem.Type == ELEM_STRUCT)
				{
					CListStringItem *Item = m_ItemOptions->InsertItemStr(type[n]->Elem.Name, 0, 0, m_DIBList.GetDIB(0x36), -1);
					m_ItemOptions->SetItemValue(Item, 0, n);
				}
			}

			for (unsigned long n = 1; n < Len; ++n)
			{
				if (type[n]->Elem.Type == ELEM_UNION)
				{
					CListStringItem *Item = m_ItemOptions->InsertItemStr(type[n]->Elem.Name, 0, 0, m_DIBList.GetDIB(0x48), -1);
					m_ItemOptions->SetItemValue(Item, 0, n);
				}
			}
		}
	}

```

`source/WispSyser/typeviewerform.hpp`:

```hpp

#ifndef _TYPEVIEWERFORM_HPP_
#define _TYPEVIEWERFORM_HPP_

#include "../Wisp/wispform.hpp"
#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispedit.hpp"
#include "../Wisp/wispbutton.hpp"
#include "../Wisp/wispradiobox.hpp"
#include "../Wisp/wispstatic.hpp"
#include "../EXEAnalyzer/sdsmodule.hpp"

struct CStructViewerForm : public CWispForm
{
	CWispStaticStr *m_ItemDescription;
	CWispStaticStr *m_ItemAddressStr;
	CWispList *m_ItemOptions;
	CWispButton *m_ItemOk;
	CWispButton *m_ItemCancel;
	CWispRadioBox *m_ItemFloatingType;
	CWispRadioBox *m_ItemLockType;
	CWispRadioBox *m_ItemDec;
	CWispRadioBox *m_ItemHex;
	unsigned long X;
	CWispEdit *m_ItemAddress;
	CWispDIBList m_DIBList;
	ULONG_PTR m_Address;
	CSDSModule *m_pSDSMod;

	CStructViewerForm();
	virtual ~CStructViewerForm();

        virtual bool MsgProc(WISP_MSG *pMsg) override;

        bool OnCreateForm(WISP_MSG *pMsg);
        bool OnDestroy(WISP_MSG *pMsg);
        bool OnCommand(WISP_MSG *pMsg);
        bool OnCmdSelect(WISP_MSG *pMsg);
        bool OnEvent(WISP_MSG *pMsg);
        bool OnEventAdd(WISP_MSG *pMsg);
        bool OnEventClose(WISP_MSG *pMsg);
        bool OnEventLock(WISP_MSG *pMsg);
        bool OnEventFloating(WISP_MSG *pMsg);

	bool Create(CWispWnd *pParentWnd, int ShowMode, ULONG_PTR Address);
	void UpdateContext();
};

#endif
```

`source/WispSyser/typeviewerwnd.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "typeviewerwnd.hpp"
#include "syserconfig.hpp"

enum
{
  TV_NAME = 0,
  TV_VALUE = 1,
  TV_TYPE = 2,
  TV_OFFSET = 3,
};

	WISP_MSG_MAP_BEGIN(CTypeViewerWnd)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

	WISP_EVENT_MAP_BEGIN(CTypeViewerWnd)
		WISP_EVENT_MAP(0xF0, OnEventDelete) //EVENT_ID_DEL_WATCH
		WISP_EVENT_MAP(0xEF, OnEventHex) //EVENT_ID_HEX_WATCH
	WISP_EVENT_MAP_END

WISP_MENU_GROUP_ITEM TypeViewerPopupMenu[] =
{
	{WSTR("Delete Watch"), 0xF0, 0xCA, 0, 0}, //EVENT_ID_DEL_WATCH
	{WSTR("Hexadecimal Display"), 0xEF, 0xD, 0, 0}, //EVENT_ID_HEX_WATCH
	{0},
};

//#define TXTDEBUG

#ifdef TXTDEBUG
FILE *f = NULL;
#endif

	CTypeViewerWnd::CTypeViewerWnd()
	{
		m_pFirstItem = nullptr;
#ifdef TXTDEBUG
	f = fopen("LOGWATCH", "w");
fprintf(f,"Start logging\n");
fflush(f);
#endif
	}
	CTypeViewerWnd::~CTypeViewerWnd()
	{
#ifdef TXTDEBUG
fclose(f);
#endif
	}

	bool CTypeViewerWnd::OnCreate(WISP_MSG *pMsg)
	{
		InsertColumn(WSTR("Name F2"), 100, 1, 0, -1);
		InsertColumn(WSTR("Value"), 400, 1, 0, -1);
		InsertColumn(WSTR("Type"), 100, 0, 0, -1);
		InsertColumn(WSTR("Offset"), 90, 0, 0, -1);

		m_ColorFocus = gSyserColors.Color[2];
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);

		m_PopupMenu.LoadPopupMenuGroup(TypeViewerPopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		m_pMenuItemRemove = m_PopupMenu.GetItem(0xF0); //EVENT_ID_DEL_WATCH
		ResetContext();
		return true;
	}
	bool CTypeViewerWnd::OnDestroy(WISP_MSG *pMsg)
	{
		m_PopupMenu.Destroy();
		return true;
	}

	bool CTypeViewerWnd::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (pMsg->KeyEvent.bKeyDown)
		{
			if (pMsg->KeyEvent.KeyType == VK_F2)
			{
				CListStringItem *Item = GetNext(0, 8);
				if (Item) EditItem(Item, TV_NAME);
			}
		} else
		{
			if (pMsg->KeyEvent.KeyType == 0x40000048) //H
				m_PopupMenu.Point(0, 1);
			else
			if (pMsg->KeyEvent.KeyType == VK_RBUTTON)
			{
				CListStringItem *Item = GetNext(0, 8);
				m_PopupMenu.Enable(m_pMenuItemRemove, Item && Item != m_pFirstItem);
				m_PopupMenu.Point(0, 1);
			}
		}
		return true;
	}

	bool CTypeViewerWnd::OnEventDelete(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (Item) //+++
		{
			if (GetItemParent(Item) != GetItemParent(GetItem(0, 0)))
				return false;
			if (Item && Item != m_pFirstItem)
				DeleteItem(Item);
		}
		return true;
	}

	bool CTypeViewerWnd::OnEventHex(WISP_MSG *pMsg)
	{
		CListStringItem *FirstItem = FullFindItem(0, 8);
		if (FirstItem)
		{
			CListStringItem *LastItem = GetNext(FirstItem, 0);
			CListStringItem *Item = FirstItem;
			do {
				TVValue Value;
				GetItemComplexValue(Item, TV_VALUE, GETPAIR(&Value.Address, &Value.Options));
				Value.Options ^= TV_HEX_MASK;
				SetItemComplexValue(Item, TV_VALUE, SETPAIR(Value.Address, Value.Options));

				GetItemContent(Item, TV_NAME);
				Item = FullFindItem(Item, 0);
			} while (Item != LastItem && Item);
			WCHAR Str[512];
			int Len = 512;
			UpdateWatch(FirstItem, Str, Len, 0);
		}
		return true;
	}

	bool CTypeViewerWnd::Edit(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (!Item) return false;
		TVName Name;
		TVValue Value;
		TVType Type;
		TVOffset Offset;
		if (!GetItems(Item, &Name, &Value, &Type, &Offset)) return false;
		if (nCol == TV_NAME)
		{
			return GetItemParent(Item) == GetItemParent(GetItem(0, 0));
		}
		if (nCol != TV_VALUE) return false;

		//if (Value.Options < 0) return false; // & 0x8000'0000
		if (Value.Options & TV_CLOSE_MASK) return false;

		if (!Name.pSDSMod) return false;

		if ((Value.Options & TV_FUNC_MASK) &&
		      (Value.Options & TV_VTBL_MASK))
			return false;

		unsigned long NewID = Name.ID;

		if (Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = Name.pSDSMod->GetLocal(Name.ID);
			if (!data) return false;
			NewID = data->TypeID;
		}

		POINTERREFTYPE *pr = (POINTERREFTYPE *)Name.pSDSMod->GetGlobal(NewID);
		if (!pr) return false;
		if (pr->Elem.Type == ELEM_POINTERREF)
		{
			pr = (POINTERREFTYPE *)Name.pSDSMod->GetGlobal(pr->ID);
			if (!pr) return false;
		}
		return pr->Elem.Type == ELEM_BASE_TYPE || pr->Elem.Type == ELEM_POINTER;
	}


	bool CTypeViewerWnd::AddWatch(CListStringItem *Item)
	{
		CWispDIB *pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
#ifdef TXTDEBUG
fprintf(f,"%s DIB %d %d\n", __func__, pDIB->m_PaintRect.cx,pDIB->m_PaintRect.cy);
fflush(f);
#endif

		if (!Item) return false;
		TVName Name;
		TVValue Value;
		TVType Type;
		TVOffset Offset;
		if (!GetItems(Item, &Name, &Value, &Type, &Offset)) return false;
		unsigned long NewID = Name.ID;
		if (!Name.pSDSMod) return false;
		//if (Value.Options < 0) return false; //0x8000'0000
		if (Value.Options & TV_CLOSE_MASK) return false;

		if (Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = Name.pSDSMod->GetLocal(Name.ID);
			if (!data) return false;
			NewID = data->TypeID;
			switch (data->access)
			{
			case CV_private:
				pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11F);
				break;
			case CV_protected:
				pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11E);
				break;
			case CV_public:
				pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
				break;
			}
		}
	//	pDIB = 0; //BUG TODO ????
		BASICTYPE *type = Name.pSDSMod->GetGlobal(NewID);
		if (!type) return false; //+++
		if (type->Elem.Type == ELEM_FUNC_TYPE)
			pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x120);
		SetItemDIB(Item, TV_NAME, pDIB);
		WCHAR Buffer[512];
		char szBuffer[512];
		int Len = 512;
		switch (type->Elem.Type)
		{
		case ELEM_BASE_TYPE:{
#ifdef TXTDEBUG
fprintf(f,"%s ELEM_BASE_TYPE\n", __func__);
fflush(f);
#endif
				unsigned long long Address = 0;
				GetOutputValue(Name.pSDSMod, type, Value.Address, Value.Options, Buffer, nullptr, &Address);
				SetItemText(Item, TV_VALUE, Buffer);
				SetItemComplexValue(Item, TV_TYPE, SETPAIR(Address, 0)); //???????????????
				const char *Str = Name.pSDSMod->GetName(type);
				SetItemText(Item, TV_TYPE, Str);
			} break;
		case ELEM_POINTER:{
#ifdef TXTDEBUG
fprintf(f,"%s POINTER\n", __func__);
fflush(f);
#endif
				unsigned long long Address = 0;
				if (type->Elem.Length && type->Elem.Length <= 8)
					gpSyser->m_pDebugger->ReadMemory(Value.Address, &Address, type->Elem.Length);
				TSPrintf(Buffer, WSTR("0x" F0ADDR "x"), Address); //TODO X64
				SetItemComplexValue(Item, TV_TYPE, SETPAIR(Address, 0));
				SetItemText(Item, TV_VALUE, Buffer);
				if (((POINTERTYPE*)type)->Num == 1)
				{
					BASICTYPE *bt = Name.pSDSMod->GetGlobal( ((POINTERTYPE*)type)->ID);
					if (bt && bt->Elem.Type == ELEM_BASE_TYPE && bt->Elem.Length == 1)
					{
						memset(szBuffer, 0, sizeof(szBuffer));
						TSPrintf(szBuffer, "0x" F0ADDR "x \"", Address); //TODO X64
						unsigned long Result = gpSyser->m_pDebugger->ReadMemory(Address, &szBuffer[ADDR_SIZE+4], 256);
						for (unsigned long n = 0; n < Result; ++n)
						{
							if (!Buffer[n])
							{
								TStrCpy(&szBuffer[n+ADDR_SIZE+4], "\"");
								SetItemText(Item, TV_VALUE, szBuffer);
							}
						}
					}
				}
				CListStringItem *NewItem = InsertItem(WSTR(".."), Item, 0, nullptr, -1);
				Value.Options |= TV_CLOSE_MASK;
				SetItemComplexValue(NewItem, TV_VALUE, SETPAIR(0, Value.Options));
				Name.pSDSMod->GetOutput(type, szBuffer, &Len);
				SetItemText(Item, TV_TYPE, szBuffer);
			} break;
		case ELEM_POINTERREF:{
#ifdef TXTDEBUG
fprintf(f,"%s POITERREF\n", __func__);
fflush(f);
#endif
				Name.pSDSMod->GetOutput(type, szBuffer, &Len);
				SetItemText(Item, TV_TYPE, szBuffer);
				BASICTYPE *bt = (BASICTYPE *)Name.pSDSMod->GetGlobal( ((POINTERREFTYPE*)type)->ID);
				if (!bt) return false;
				ULONG_PTR Address = 0;
				gpSyser->m_pDebugger->ReadMemory(Value.Address, &Address, sizeof(Address));
				TSPrintf(Buffer, WSTR("0x" F0ADDR "x"), Address); //TODO X64
				SetItemText(Item, TV_VALUE, Buffer);
				if (bt->Elem.Type == ELEM_CLASS ||
				    bt->Elem.Type == ELEM_STRUCT ||
				    bt->Elem.Type == ELEM_UNION ||
				    bt->Elem.Type == ELEM_POINTER)
				{
					CListStringItem *NewItem = InsertItem(WSTR(".."), Item, 0, nullptr, -1);
					Value.Options |= TV_CLOSE_MASK;
					SetItemComplexValue(NewItem, TV_VALUE, SETPAIR(0, Value.Options));
				}
				if (bt->Elem.Type == ELEM_BASE_TYPE)
				{
					unsigned long long Result = 0;
					GetOutputValue(Name.pSDSMod, bt, Address, Value.Options, Buffer, nullptr, &Result);
					SetItemText(Item, TV_VALUE, Buffer);
				}
			} break;
		case ELEM_ARRAY:{
#ifdef TXTDEBUG
fprintf(f,"%s ELEM_ARRAY\n", __func__);
fflush(f);
#endif
				TSPrintf(Buffer, WSTR("0x" F0ADDR "x"), Value.Address); //TODO X64
				SetItemText(Item, TV_VALUE, Buffer);
				CListStringItem *NewItem = InsertItem(WSTR(".."), Item, 0, nullptr, -1);
				Value.Options |= TV_CLOSE_MASK;
				SetItemComplexValue(NewItem, TV_VALUE, SETPAIR(0, Value.Options));
				Name.pSDSMod->GetOutput(type, szBuffer, &Len);
				SetItemText(Item, TV_TYPE, szBuffer);
			} break;
		case ELEM_STRUCT:
		case ELEM_CLASS:
		case ELEM_UNION:{
#ifdef TXTDEBUG
fprintf(f,"%s ELEM_UDT\n", __func__);
fflush(f);
#endif
				CListStringItem *NewItem = InsertItem(WSTR(".."), Item, 0, nullptr, -1);
				Value.Options |= TV_CLOSE_MASK;
				SetItemComplexValue(NewItem, TV_VALUE, SETPAIR(0, Value.Options));
				Name.pSDSMod->GetOutput(type, szBuffer, &Len);
				SetItemText(Item, TV_TYPE, szBuffer);
				SetItemText(Item, TV_VALUE, "{...}");
			} break;
		case ELEM_FUNC_TYPE:{
#ifdef TXTDEBUG
fprintf(f,"%s ELEM_FUNC\n", __func__);
fflush(f);
#endif
				//TSPrintf(Buffer, WSTR("0x" F0ADDR "x  "), *(ULONG_PTR*)Value.Address); //TODO X64
				TSPrintf(Buffer, WSTR("0x" F0ADDR "x  "), Value.Address); //TODO X64
				SetItemText(Item, TV_VALUE, Buffer);
				FUNCTION *pFunc = Name.pSDSMod->GetFunctionByID(Type.ID);
				if (pFunc) //func
				{
					TStrCpy(szBuffer, Buffer);
					Len = 512/2;
					Name.pSDSMod->GetOutputFunc(pFunc, &szBuffer[ADDR_SIZE+4], &Len); //sizeof("0x%08x  ")
					SetItemText(Item, TV_VALUE, szBuffer);
					Len = 512/2;
					Name.pSDSMod->GetOutput(type, szBuffer, &Len);
					SetItemText(Item, TV_TYPE, szBuffer);
				}
			} break;
		}
		return true;
	}

	void CTypeViewerWnd::AddWatch(const WCHAR *String, CListStringItem *Item)
	{
		if (!Item)
		{
			Item = m_pFirstItem;
			ResetItems();
		}

		CSDSModule *pSDSMod = gpSyser->m_MainFrame.m_SourceDebugFrameWnd.m_SDSModuleList.m_pSDSMod;

		SetItemComplexValue(Item, TV_NAME, SETPAIR(pSDSMod, 0));
		SetItemText(Item, TV_NAME, String);
		SetItemComplexValue(Item, TV_VALUE, SETPAIR(0, TV_DATA_MASK | TV_CLOSE_MASK | TV_NEW_MASK));
									 // 2000'0000 | 8000'0000 | 100'0000
		SetItemText(Item, TV_VALUE, WSTR(""));
		SetItemFormat(Item, TV_OFFSET, 0, WSTR("%X"));
		if (pSDSMod)
		{
		#if 1
			TStaticAnsiString Str = String;
		#else
			char Buffer[256];
			char *pBuffer = Buffer;
			int Len = TStrLen(String)+1;
			if (Len >= 256)
				pBuffer = new char[Len];
			TStrCpy(pBuffer, String);
		#endif
#ifdef TXTDEBUG
fprintf(f,"add varname %s %s\n",pBuffer, __func__);
fflush(f);
#endif

			ULONG_PTR Address = 0;
			DATATYPE *Data;
			FUNCTION *pFunc;

			if (ReadX(Str/*.operator char*()pBuffer*/, &Address, &Data, &pSDSMod))
			{
				SetItemFormat(Item, TV_OFFSET, Address, WSTR("0x" F0ADDR "x")); //TODO X64

				SetItemComplexValue(Item, TV_NAME, SETPAIR(pSDSMod, Data->ID));
				SetItemComplexValue(Item, TV_TYPE, SETPAIR(0, 0));

				SetItemComplexValue(Item, TV_VALUE, SETPAIR(Address, TV_DATA_MASK | TV_NEW_MASK));
				AddWatch(Item);
#ifdef TXTDEBUG
fprintf(f,"%s attach data 0x%08\n", __func__,Address);
fflush(f);
#endif
			} else
			if (ReadX(Str/*.operator char*()pBuffer*/, &Address, &pFunc, &pSDSMod))
			{
				pSDSMod->GetGlobal(pFunc->ReturnCallID); //???
				SetItemComplexValue(Item, TV_NAME, SETPAIR(pSDSMod, pFunc->ReturnCallID));
				CListStringItem::CONTENT *Content = GetItemContent(Item, TV_TYPE);
				SetItemComplexValue(Item, TV_TYPE, SETPAIR(Address, pFunc->ID));
				SetItemComplexValue(Item, TV_VALUE, SETPAIR(Content->v1, TV_FUNC_MASK | TV_NEW_MASK));
				AddWatch(Item);
#ifdef TXTDEBUG
fprintf(f,"%s attach fun 0x%08\n", __func__,Address);
fflush(f);
#endif
			}
		#if 0
			if (pBuffer != Buffer)
				delete []pBuffer;
		#endif
		}
	}

	void CTypeViewerWnd::AddWatch(const char *szString, CListStringItem *Item)
	{
	#if 1
		TStaticWideString Str = szString;
		AddWatch(Str/*.operator WCHAR*()*/, Item);
	#else
		WCHAR Buffer[256];
		WCHAR *pBuffer = Buffer;
		unsigned int Len = TStrLen(szString)+1;
		if (Len >= 256)
			pBuffer = new WCHAR[Len];

		TStrCpy(pBuffer, szString);

		AddWatch(pBuffer, Item);

		if (pBuffer != Buffer)
			delete []pBuffer;
	#endif
	}

	bool CTypeViewerWnd::OnEditing(CListStringItem *Item, int nCol, TWideString& String)
	{
		//Item &&
		if (Item != m_pFirstItem)
		{
			if (String.m_nLength != 0) return true;
			if (GetItemParent(Item) == GetItemParent(GetItem(0, 0)))
				DeleteItem(Item);
			return false;
		}

		if (String.m_nLength == 0)
			return false;
		AddWatch(String.operator const WCHAR*(), nullptr);
		return true;
	}

	bool CTypeViewerWnd::Write(ULONG_PTR Address, CSDSModule *pSDSMod, unsigned int ID, unsigned long long Value)
	{
		unsigned long Result = 0;
		if (!pSDSMod) return false;
		if (!ID) return false;
		BASICTYPE *type = pSDSMod->GetGlobal(ID);
		if (!type) return false;
		if (type->Elem.Type == ELEM_BASE_TYPE ||
		    type->Elem.Type == ELEM_POINTER)
		{
			if (type->Elem.Length && type->Elem.Length <= 8)
			{
				Result = gpSyser->m_pDebugger->WriteMemory(Address, &Value, type->Elem.Length);
			}
		}
		return Result == type->Elem.Length;
	}

struct BASETYPEMAP
{
	unsigned long Type;
	const char *Name;
};

	BASETYPEMAP gBaseTypeMap[] =
	{
		{0, "NoType"},
		{1, "void"},
		{0x80, "char"},
		{0x100, "wchar"},
		{0x80, "char"},
		{0x100, "short"},
		{0x200, "int"},
		{0x400, "__int64"},
		{0x1000, "unsigned short int"},
		{0x800, "unsigned char"},
		{0x1000, "unsigned short"},
		{0x2000, "unsigned int"},
		{0x4000, "unsigned __int64"},
		{0x200, "float"},
		{0x400, "double"},
		{9, "BCD"},
		{0x800, "bool"},
		{0x200, "long"},
		{0x2000, "unsigned long"},
		{0x19, "Currency"},
		{0x1a, "date"},
		{0x1b, "variant"},
		{0x1c, "complex"},
		{0x1d, "bit"},
		{0x1e, "BSTR"},
		{0x1f, "HRESULT"},
		{0, 0},
	};

	unsigned long GetBasicType(const char *Str)
	{
		for (unsigned long n = 0; n < lenof(gBaseTypeMap); ++n) //27
		{
			if (!TStrCmp(gBaseTypeMap[n].Name, Str))
				return gBaseTypeMap[n].Type;
		}
		return 0;
	}

	bool CTypeViewerWnd::EDIT(CListStringItem *Item)
	{
		TVInfo info;
		memset(&info, 0, sizeof(info));
		if (!GetItems(Item, &info)) return false;

		unsigned long ID = info.Name.ID;
		ULONG_PTR Address = info.Value.Address;

		if (!info.Name.pSDSMod)	return false;

		//if (info.Value.Options < 0) //??? TODO 0x8000'0000
		if (info.Value.Options & TV_CLOSE_MASK) return false;

		if (info.Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
			if (!data) return false;
			ID = data->TypeID;
		}

		CListStringItem::CONTENT *Content = GetItemContent(Item, TV_VALUE);
		const WCHAR *Str = Content->String.operator const WCHAR*();
		BASICTYPE *type = info.Name.pSDSMod->GetGlobal(ID);
		if (type)
		{
			bool OK = false;
			if (type->Elem.Type != ELEM_BASE_TYPE)
			{
				if (type->Elem.Type == ELEM_POINTER)
				{
					int n = 0;
					while (Str[n])
					{
						if (Str[n] == L'x' || Str[n] == L'X')
						{
							++n;
							break;
						}
						++n;
					}
					ULONG_PTR Result = 0;
					OK = USHexStrToNum(&Str[n], &Result);
					if (OK)
						Write(info.Value.Address, info.Name.pSDSMod, ID, Result);
					return OK;
				} else
				if (type->Elem.Type == ELEM_POINTERREF)
				{
					POINTERREFTYPE *pt = (POINTERREFTYPE *)type;
					//BASICTYPE *
					type = (BASICTYPE *)info.Name.pSDSMod->GetGlobal(pt->ID);
					if (!type) return false;
					if (type->Elem.Type != ELEM_BASE_TYPE) return false;
					ULONG_PTR Value = 0;
					if (gpSyser->m_pDebugger->ReadMemory(info.Value.Address, &Value, sizeof(Value)) != sizeof(Value))
						return false;
					Address = Value;
					ID = pt->ID;
				} else
				{
					//
					return false;
				}
			}
			//ELEM_BASIC_TYPE ???
			unsigned long basictype = GetBasicType(type->Elem.Name);
			if (basictype == 0xA || //???	//bool
			    basictype == 0xD || //???	//long
			    basictype == 0x80 || //char
			    basictype == 0x100 || //short
			    basictype == 0x200 || //int
			    basictype == 0x400) //__int64
			{
				LONG_PTR Result = 0;
				if (info.Value.Options & TV_HEX_MASK)
				{
					int n = 0;
					while (Str[n])
					{
						if (Str[n] == L'x' || Str[n] == L'X')
						{
							++n;
							break;
						}
						++n;
					}
					OK = USHexStrToNum(&Str[n], &Result);
				} else	OK = USDecStrToNum(Str, &Result);

				if (OK)
					Write(Address, info.Name.pSDSMod, ID, Result);
				return OK;
			} else
			if (basictype == 0xE || //???			//unsigned long
			    basictype == 0x800 || //bool
			    basictype == 0x1000 || //unsigned short int
			    basictype == 0x2000 || //unsigned long		unsigned int
			    basictype == 0x4000) //unsigned __int64
			{
				ULONG_PTR Result = 0;
				if (info.Value.Options & TV_HEX_MASK)
				{
					int n = 0;
					while (Str[n])
					{
						if (Str[n] == L'x' || Str[n] == L'X')
						{
							++n;
							break;
						}
						++n;
					}
					OK = USHexStrToNum(&Str[n], &Result);
				} else	OK = USDecStrToNum(Str, &Result);

				if (OK)
					Write(Address, info.Name.pSDSMod, ID, Result);
				return OK;
			}
		}
		return false;
	}

	void CTypeViewerWnd::OnEdit(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (Item != m_pFirstItem)
		{
			EDIT(Item);
			UpdateContext();
		}
	}

	BASICTYPE *CTypeViewerWnd::GetPointerRefType(CSDSModule *pSDSMod, unsigned long ID)
	{
		DATATYPE *data = pSDSMod->GetLocal(ID);
		if (!data) return nullptr;
		POINTERREFTYPE *ptr = (POINTERREFTYPE *)pSDSMod->GetGlobal(data->TypeID);
		if (!ptr) return nullptr;
		if (ptr->Elem.Type == ELEM_POINTERREF)
			return pSDSMod->GetGlobal(ptr->ID);
		return nullptr;
	}

	void CTypeViewerWnd::ExpandVTable(CListStringItem *Item, TVInfo *info)
	{
		CWispDIB *pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
		if (info->Name.pSDSMod && info->Name.ID)
		{
			ULONG_PTR Address = info->Value.Address;
			unsigned long NewID = info->Name.ID;
			if (info->Value.Options & TV_DATA_MASK)
			{
				DATATYPE *data = info->Name.pSDSMod->GetLocal(info->Name.ID);
				if (!data) return;
				NewID = data->TypeID;
			}
			BASICTYPE *basetype = (BASICTYPE*)info->Name.pSDSMod->GetGlobal("unsigned int", 1);
			if (!basetype) return;
			
			UDTYPE *udt = (UDTYPE*)info->Name.pSDSMod->GetGlobal(NewID);
			if (!udt) return;
			if (!udt->PubSymbols) return;

			for (int n = 0; n < udt->PubSymbolsLen ; ++n)
			{
				if (udt->PubSymbols[n].ID == NewID)
				{
					CLASSPUBSYM *pubsym = &udt->PubSymbols[n];

					ULONG_PTR Addr = info->Name.pSDSMod->m_pDbgModule->m_ImageBase + pubsym->rva;

					//unsigned long long Address = 0;
					//if (type->Elem.Length && type->Elem.Length <= 8)
					unsigned long Result = gpSyser->m_pDebugger->ReadMemory(Address, &Addr, sizeof(Addr)); //TODO X64 type->Elem.Length);

					CListStringItem *NewItem = InsertItemStr("__vfptr", Item, 0, pDIB, -1);
					CListStringItem::CONTENT *Content = GetItemContent(NewItem, TV_TYPE);
					const char *pStrSym = info->Name.pSDSMod->m_pDbgModule->GetSymbol(Addr);
					if (!pStrSym)
						pStrSym = "";
					char szString[256];
					TSPrintf(szString, "0x" F0ADDR "x  %s", Addr, pStrSym); //TODO X64
					SetItemText(NewItem, TV_VALUE, szString);
					SetItemComplexValue(NewItem, TV_NAME, SETPAIR(info->Name.pSDSMod, basetype->Elem.ID));
					SetItemComplexValue(NewItem, TV_VALUE, SETPAIR(Address, TV_FUNC_MASK | TV_VTBL_MASK)); //??? &Content->v1
					SetItemComplexValue(NewItem, TV_TYPE, SETPAIR(Addr, 0));
					SetItemText(NewItem, TV_TYPE, "*");

					if (Result == sizeof(Addr) && Addr)

					if (pubsym->length & ~3) //-4
					for (int i = 0; i < pubsym->length/4; ++i)
					{
						ULONG_PTR PAddr = 0;
						if (gpSyser->m_pDebugger->ReadMemory(Addr, &PAddr, sizeof(PAddr)) != sizeof(PAddr) || !PAddr)
							break;
						TSPrintf(szString, "[0x%x]", i);
						CWispDIB *pVDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x120);
						CListStringItem *SubItem = InsertItemStr(szString, NewItem, 0, pVDIB, -1);
						CListStringItem::CONTENT *Content = GetItemContent(SubItem, TV_TYPE);

						char FuncName[256];
						int FuncNameLen = 256;

						const char *pStrSym = info->Name.pSDSMod->m_pDbgModule->GetSymbol(PAddr);
						if (!pStrSym)
						{
							unsigned char CodeBuf[16];
							if (gpSyser->m_pDebugger->ReadMemory(PAddr, CodeBuf, 5) == 5 && CodeBuf[0] == 0xE9)
							{
								FUNCTION *pFunc = info->Name.pSDSMod->GetFunction(*(long*)&CodeBuf[1] - info->Name.pSDSMod->m_pDbgModule->m_ImageBase + PAddr + 5); //TODO X64
								szString[0] = 0; //???
								FuncName[0] = 0; //+++
								FuncNameLen = 256;
								if (pFunc)
									pStrSym = info->Name.pSDSMod->GetOutputFunc(pFunc, FuncName, &FuncNameLen);
							}
						}
						
						if (!pStrSym)
							pStrSym = "";
						TSPrintf(szString, "0x" F0ADDR "x  %s", PAddr, pStrSym); //TODO X64
						SetItemText(SubItem, TV_VALUE, szString);
						SetItemComplexValue(SubItem, TV_NAME, SETPAIR(info->Name.pSDSMod, basetype->Elem.ID));
						SetItemComplexValue(SubItem, TV_VALUE, SETPAIR(Content->v1, TV_FUNC_MASK | TV_VTBL_MASK)); //??? &Content->v1
						SetItemComplexValue(SubItem, TV_TYPE, SETPAIR(PAddr, 0));
						SetItemText(NewItem, TV_TYPE, "*");
						Addr += sizeof(ULONG_PTR);
					}
				}
			}
		}
	}

	void CTypeViewerWnd::ExpandPointer(CListStringItem *Item)
	{
		if (!Item) return;
		TVInfo info;
		info.Name.ID = 0;
		info.Name.pSDSMod = 0;
		if (!GetItems(Item, &info)) return;
		unsigned long NewID = info.Name.ID;
		if (!info.Name.pSDSMod) return;
		if (info.Name.ID == 0) return;
		unsigned long Options = info.Value.Options;
		if (info.Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
			if (!data) return;
			NewID = data->TypeID;
		}
		POINTERTYPE *pt = (POINTERTYPE *)info.Name.pSDSMod->GetGlobal(NewID);
		if (!pt) return; //+++
		unsigned long long value = 0;
		gpSyser->m_pDebugger->ReadMemory(info.Value.Address, &value, pt->Elem.Length);

		if (pt->Num <= 1)
		{
			Options = (Options & ~TV_DATA_MASK) | TV_FUNC_MASK;
			info.Value.Address = value;
			info.Name.ID = pt->ID;
			info.Value.Options = Options;
			BASICTYPE *bt = (BASICTYPE*)info.Name.pSDSMod->GetGlobal(pt->ID);
			if (!bt) return;
			switch (bt->Elem.Type)
			{
			case ELEM_BASE_TYPE:
				ShowBaseType(info.Name.pSDSMod, info.Name.ID, value, Options, Item, "", false);
				break;
			case ELEM_STRUCT:
			case ELEM_CLASS:
			case ELEM_UNION:
				ExpandStruct(Item, &info);
				break;
			}
		} else
		{
			Show(info.Name.pSDSMod, pt->PrevID, value, Options, Item, "");
		}
	}

	void CTypeViewerWnd::ExpandPointerRef(CListStringItem *Item)
	{
		if (!Item) return;
		TVInfo info;
		info.Name.ID = 0;
		info.Name.pSDSMod = 0;
		if (!GetItems(Item, &info)) return;
		//unsigned long NewID = info.Name.ID;
		if (!info.Name.pSDSMod) return;
		if (info.Name.ID == 0) return;
		unsigned long Options = info.Value.Options;
		POINTERREFTYPE *ptr = nullptr;
		if (info.Value.Options & TV_DATA_MASK)
		{
			ptr = (POINTERREFTYPE *)GetPointerRefType(info.Name.pSDSMod, info.Name.ID);
		} else
		{
			ptr = (POINTERREFTYPE *)info.Name.pSDSMod->GetGlobal(info.Name.ID);
		}
		if (!ptr) return; //+++
		unsigned long long value = 0;
		gpSyser->m_pDebugger->ReadMemory(info.Value.Address, &value, sizeof(ULONG_PTR));

		Options = (Options & ~TV_DATA_MASK) | TV_FUNC_MASK;
		info.Value.Address = value;
		info.Name.ID = ptr->ID;
		info.Value.Options = Options;
		BASICTYPE *bt = (BASICTYPE*)info.Name.pSDSMod->GetGlobal(ptr->ID);
		if (!bt) return;
		switch (bt->Elem.Type)
		{
		case ELEM_BASE_TYPE:
			ShowBaseType(info.Name.pSDSMod, info.Name.ID, value, Options, Item, "", false);
			break;
		case ELEM_STRUCT:
		case ELEM_CLASS:
		case ELEM_UNION:
			ExpandStruct(Item, &info);
			break;
		}
	}

	void CTypeViewerWnd::ExpandArray(CListStringItem *Item)
	{
		if (!Item) return;
		TVName Name;
		TVValue Value;
		TVType Type;
		TVOffset Offset;
		if (!GetItems(Item, &Name, &Value, &Type, &Offset)) return;
		unsigned long NewID = Name.ID;
		ULONG_PTR Address = Value.Address;
		if (!Name.pSDSMod) return;
		if (Name.ID == 0) return;
		if (Value.Options & TV_CLOSE_MASK) return;

		if (Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = Name.pSDSMod->GetLocal(Name.ID);
			if (!data) return;
			NewID = data->TypeID;
		}
		ARRAYTYPE *at = (ARRAYTYPE *)Name.pSDSMod->GetGlobal(NewID);
		if (at && at->Elem.Type == ELEM_ARRAY)
		{
			if (at->Size <= 1)
			{
				BASICTYPE *bt = (BASICTYPE *)Name.pSDSMod->GetGlobal(at->ID);
				if (!bt) return; //+++
				Value.Options = (Value.Options & ~TV_DATA_MASK) | TV_FUNC_MASK;
				char VarName[20];
				for (int n = 0; n < at->Values[0].Size; ++n)
				{
					TSPrintf(VarName, "[%d]", n);
					Show(Name.pSDSMod, bt->Elem.ID, Address, Value.Options, Item, VarName);
					Address += bt->Elem.Length;
				}
			} else
			{
				Name.pSDSMod->GetGlobal(at->ParentID); //???
			}
		}
	}

	void CTypeViewerWnd::ExpandStruct(CListStringItem *Item, TVInfo *info)
	{
		if (!Item) return;

		unsigned long Options = info->Value.Options;
		unsigned long NewID = info->Name.ID;
		ULONG_PTR Address = info->Value.Address;
		if (!info->Name.pSDSMod) return;
		if (info->Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = info->Name.pSDSMod->GetLocal(info->Name.ID);
			if (!data) return;
			NewID = data->TypeID;
		}
		UDTYPE *udt = (UDTYPE *)info->Name.pSDSMod->GetGlobal(NewID);
		if (udt->BaseClassLen == 0 && udt->vtable) //0x100
		{
			ExpandVTable(Item, info);
#ifdef TXTDEBUG
fprintf(f,"%s vtbl\n", __func__);
fflush(f);
#endif
		}
		for (int n = 0; n < udt->BaseClassLen; ++n)
		{
			BASECLASSTYPE *bc = (BASECLASSTYPE *)info->Name.pSDSMod->GetGlobal(udt->BaseClass[n]);
			if (!bc) return; //+++
#ifdef TXTDEBUG
fprintf(f,"%s bc\n", __func__);
fflush(f);
#endif
			ShowStruct(info->Name.pSDSMod, bc->ID, Address + bc->Offset, Options, Item, nullptr, false);
		}

		bool bitfield = false;
		ULONG_PTR HighAddr = Address;
		unsigned long BTID = 0;
		unsigned long NextPos = 0;
		ULONG_PTR Addr = 0; //???

		for (int n = 0; n < udt->DataLen; ++n)
		{
			DATATYPE *data = info->Name.pSDSMod->GetLocal(udt->Data[n]);
			if (!data) return; //+++
			BASICTYPE *bt = (BASICTYPE *)info->Name.pSDSMod->GetGlobal(data->TypeID);
			if (!bt) return;

			switch (data->locationType)
			{
			case LocIsStatic: {
				Addr = data->Static.rva + info->Name.pSDSMod->m_pDbgModule->m_ImageBase;
				bitfield = false;
				} break;
			case LocIsThisRel: {
				Addr = Address + data->ThisRel.offset;
				bitfield = false;
				HighAddr = Addr + bt->Elem.Length;
				} break;
			case LocIsBitField: {
				if (bitfield)
				{
					if (BTID == bt->Elem.ID &&  data->BitField.bitPosition >= NextPos)
					{
						NextPos = data->BitField.length + NextPos;
					} else
					{
						Addr = HighAddr + data->BitField.offset;
						BTID = bt->Elem.ID;
						HighAddr += bt->Elem.Length;
						NextPos = data->BitField.bitPosition + data->BitField.length;
					}
				} else
				{
					BTID = bt->Elem.ID;
					Addr = HighAddr + data->BitField.offset;
					bitfield = true;
					NextPos = data->BitField.bitPosition + data->BitField.length;
					HighAddr += bt->Elem.Length;
				}
				} break;
			default:
				bitfield = false;
				break;
			}
			switch (bt->Elem.Type)
			{
			case ELEM_BASE_TYPE:{
				Options = (Options & ~TV_FUNC_MASK) | TV_DATA_MASK;
				ShowBaseType(info->Name.pSDSMod, data->ID, Addr, Options, Item, data->name, true);
				} break;
			case ELEM_POINTER:
			case ELEM_POINTERREF:{
				ShowPointer(info->Name.pSDSMod, data->ID, Addr, Options, Item, data->name, true);
				} break;
			case ELEM_ARRAY:{
				ShowArray(info->Name.pSDSMod, data->ID, Addr, Options, Item, data->name, true);
				} break;
			case ELEM_ENUM:{
				ShowEnum(info->Name.pSDSMod, data->ID, Addr, Options, Item, data->name, true);
				} break;
			case ELEM_STRUCT:
			case ELEM_CLASS:
			case ELEM_UNION:{
				ShowStruct(info->Name.pSDSMod, data->ID, Addr, Options, Item, data->name, true);
				} break;
			}
		}
	}

	void CTypeViewerWnd::EXPAND(CListStringItem *Item)
	{
		if (!Item) return;
		TVInfo info;
		if (!GetItems(Item, &info)) return;
		if (info.Value.Options & TV_CLOSE_MASK) return;
		if (!info.Name.pSDSMod) return;
#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif
		//if (info.Value.Options >= 0 && info.Name.pSDSMod) //>= 0 0x8000'0000 ???
		{
			unsigned long NewID = info.Name.ID;
			if (info.Value.Options & TV_DATA_MASK)
			{
				DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
				if (!data) return;
				NewID = data->TypeID;
			}
			BASICTYPE *type = info.Name.pSDSMod->GetGlobal(NewID);
			if (!type) return;
			switch (type->Elem.Type)
			{
			case ELEM_POINTER:
				ExpandPointer(Item);
				break;
			case ELEM_POINTERREF:
				ExpandPointerRef(Item);
				break;
			case ELEM_ARRAY:
				ExpandArray(Item);
				break;
			case ELEM_STRUCT:
			case ELEM_CLASS:
			case ELEM_UNION:
				ExpandStruct(Item, &info);
				break;
			}
		}
	}

	void CTypeViewerWnd::OnExpand(CListStringItem *Item)
	{
		GetItemValue(Item, TV_NAME); //???
		GetItemValue(Item, TV_VALUE); //???
		CListStringItem *SubItem = GetItem(0, Item); //0 ??? TV_NAME
		if (!TStrCmp(GetItemContent(SubItem, TV_NAME)->String.operator const WCHAR*(), ".."))
		{
			DeleteAllChildrenItems(Item);
			EXPAND(Item);
			Expand(Item);
		}
	}

	void CTypeViewerWnd::ResetItems()
	{
		m_pFirstItem = InsertItem(nullptr, nullptr, 0, nullptr, -1);
		SetItemComplexValue(m_pFirstItem, TV_NAME, SETPAIR(0, 0));
		SetItemComplexValue(m_pFirstItem, TV_VALUE, SETPAIR(0, 0));
		SetItemComplexValue(m_pFirstItem, TV_TYPE, SETPAIR(0, 0));
		SetItemComplexValue(m_pFirstItem, TV_OFFSET, SETPAIR(0, 0));
	}

	void CTypeViewerWnd::ResetContext()
	{
		DeleteAllChildrenItems(0);
		ResetItems();
		Select(m_pFirstItem);
	}

	bool CTypeViewerWnd::UpdateArray(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address)
	{
#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif

		if (!Item) return false;
		TVInfo info;
		if (!GetItems(Item, &info)) return false;
		unsigned long NewID  = info.Name.ID;
		if (!info.Name.pSDSMod) return false;
		if (info.Name.ID == 0) return false;
		if (info.Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
			if (!data) return false;
			NewID = data->TypeID;
		}
		ARRAYTYPE *at = (ARRAYTYPE *)info.Name.pSDSMod->GetGlobal(NewID);
		if (!at) return false;
		if (at->Size == 1)
		{
			Item = FullFindItem(Item, 0);
			BASICTYPE *e = info.Name.pSDSMod->GetGlobal(at->ID);
			for (int n = 0; n < at->Values[0].Size && Item; ++n)
			{
				UpdateWatch(Item, Str, StrLen, Address);
				Address += e->Elem.Length;
				Item = GetNext(Item, 0);
			}
		}
		return true;
	}

	bool CTypeViewerWnd::UpdateBaseClassPointer(CListStringItem *Item, ULONG_PTR Address)
	{
#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif

		TVInfo info;
		if (!GetItems(Item, &info)) return false;
		unsigned long NewID = info.Name.ID;
		if (!info.Name.pSDSMod) return false;
		if (info.Name.ID == 0) return false;
		if (info.Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
			if (!data) return false;
			NewID = data->TypeID;
		}
		POINTERTYPE *pt = (POINTERTYPE *)info.Name.pSDSMod->GetGlobal(NewID);
		if (!pt) return false;
		if (pt->Elem.Type != ELEM_POINTER) return false;
		if (pt->Num != 1) return false;
		
		UDTYPE *udt = (UDTYPE*)info.Name.pSDSMod->GetGlobal(pt->ID);
		if (!udt) return false;
		if (udt->Elem.Type == ELEM_CLASS ||
		    udt->Elem.Type == ELEM_STRUCT ||
		    udt->Elem.Type == ELEM_UNION)
		{
			for (int n = 0; n < udt->BaseClassLen; ++n)
			{
				BASECLASSTYPE *bt = (BASECLASSTYPE *)info.Name.pSDSMod->GetGlobal(udt->BaseClass[n]);
				if (!bt) return false; //+++ ???
				SetAddress(Item, bt->ID, Address + bt->Offset);
			}
			return true;
		}
		return false;
	}

	bool CTypeViewerWnd::UpdateStructPointer(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address)
	{
		if (!Item) return false;
#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif

		UpdateBaseClassPointer(Item, Address);
		Item = FullFindItem(Item, 0);
		while (Item)
		{
			ULONG_PTR NewAddress = 0;
			GetItemText(Item, TV_NAME, Str, StrLen);
			TVInfo info;
			if (GetItems(Item, &info))
			{
				unsigned long NewID = info.Name.ID;
				if ((info.Value.Options & TV_CLOSE_MASK)==0 &&
				    info.Name.pSDSMod &&
				    info.Name.ID != 0)
				{
					if (info.Value.Options & TV_DATA_MASK)
					{
						DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
						if (data)
						{
							NewID = data->TypeID;
							if (data->locationType == LocIsThisRel)
								NewAddress = Address + data->ThisRel.offset;
						}
					}
					if (info.Name.pSDSMod->GetGlobal(NewID))
						UpdateWatch(Item, Str, StrLen, NewAddress);
				}
			}
			Item = GetNext(Item, 0);
		}
		return true;
	}

	bool CTypeViewerWnd::UpdateStructPointerRef(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address)
	{
		if (!Item) return false;
#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif

		Item = FullFindItem(Item, 0);
		while (Item)
		{
			ULONG_PTR NewAddress = 0;
			GetItemText(Item, TV_NAME, Str, StrLen);
			TVInfo info;
			if (GetItems(Item, &info))
			{
				unsigned long NewID = info.Name.ID;
				if ((info.Value.Options & TV_CLOSE_MASK)==0 &&
				    info.Name.pSDSMod &&
				    info.Name.ID != 0)
				{
					if (info.Value.Options & TV_DATA_MASK)
					{
						DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
						if (data)
						{
							NewID = data->TypeID;
							if (data->locationType == LocIsThisRel)
								NewAddress = Address + data->ThisRel.offset;
						}
					}
					if (info.Name.pSDSMod->GetGlobal(NewID))
						UpdateWatch(Item, Str, StrLen, NewAddress);
				}
			}
			Item = GetNext(Item, 0);
		}
		return true;
	}

	bool CTypeViewerWnd::UpdateBaseClass(CListStringItem *Item, ULONG_PTR Address)
	{
#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif

		TVInfo info;
		if (!GetItems(Item, &info)) return false;
		unsigned long NewID = info.Name.ID;
		if (!info.Name.pSDSMod) return false;
		if (info.Name.ID == 0) return false;
		if (info.Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
			if (!data) return false;
			NewID = data->TypeID;
		}
		UDTYPE *udt = (UDTYPE*)info.Name.pSDSMod->GetGlobal(NewID);
		if (!udt) return false;
		if (udt->Elem.Type == ELEM_CLASS ||
		    udt->Elem.Type == ELEM_STRUCT ||
		    udt->Elem.Type == ELEM_UNION)
		{
			for (int n = 0; n < udt->BaseClassLen; ++n)
			{
				BASECLASSTYPE *bt = (BASECLASSTYPE *)info.Name.pSDSMod->GetGlobal(udt->BaseClass[n]);
				if (!bt) return false; //+++ ???
				SetAddress(Item, bt->ID, Address + bt->Offset);
			}
			return true;
		}
		return false;
	}

	bool CTypeViewerWnd::UpdateStruct(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address)
	{
		if (!Item) return false;
#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif
		UpdateBaseClass(Item, Address);
		CListStringItem *NextItem = FullFindItem(Item, 0);
		while (NextItem)
		{
			GetItemText(NextItem, TV_NAME, Str, StrLen);
			TVInfo info;
			if (GetItems(NextItem, &info))
			{
				ULONG_PTR NewAddress = info.Value.Address;
				unsigned long NewID = info.Name.ID;
				if ((info.Value.Options & TV_CLOSE_MASK)==0 &&
				    info.Name.pSDSMod &&
				    info.Name.ID != 0)
				{
					if (info.Value.Options & TV_DATA_MASK)
					{
						DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
						if (data)
						{
							NewID = data->TypeID;
							if (data->locationType == LocIsThisRel)
								NewAddress = Address + data->ThisRel.offset;
						}
					}
					if (info.Name.pSDSMod->GetGlobal(NewID))
						UpdateWatch(NextItem, Str, StrLen, NewAddress);
				}
			}
			NextItem = GetNext(NextItem, 0);
		}
		return true;
	}

	bool CTypeViewerWnd::UpdateWatch(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address)
	{
		TVInfo info;
		memset(&info, 0, sizeof(info));
		if (!GetItems(Item, &info)) return false;

		if (!Address)
			Address = info.Value.Address;
		SetItemComplexValue(Item, TV_VALUE, SETPAIR(Address, info.Value.Options));
		if (info.Value.Options & TV_CLOSE_MASK) return true;
		unsigned long NewID = info.Name.ID;
		if (!info.Name.pSDSMod) return false;
		if (info.Value.Options & TV_DATA_MASK)
		{
			DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
			if (!data) return false;
			NewID = data->TypeID;
		}
		BASICTYPE *type = info.Name.pSDSMod->GetGlobal(NewID);
		if (!type) return false;
		switch (type->Elem.Type)
		{
		case ELEM_BASE_TYPE:{
#ifdef TXTDEBUG
fprintf(f,"ELEM_BASE_TYPE %s\n", __func__);
fflush(f);
#endif
			DATATYPE *data = info.Name.pSDSMod->GetLocal(info.Name.ID);
			unsigned long long Value = 0;
			int Len = 0;
			GetOutputValue(info.Name.pSDSMod, type, Address, info.Value.Options, Str, &Len, &Value);
			bool Changed = false;
			if (data && data->locationType == LocIsBitField) //+++ TEST IT
			{
				unsigned long long BitValue = Value >> data->BitField.bitPosition;
				BitValue &= ~(~0LL << data->BitField.length); //TODO ???

				unsigned long long OldBitValue = info.Type.X >> data->BitField.bitPosition;
				OldBitValue &= ~(~0LL << data->BitField.length); //TODO ???

				Changed = OldBitValue != BitValue;
			} else
			{
				Changed = info.Type.X != Value;
			}

			SetItemColor(Item, TV_VALUE, 0xFFFFFF);
			if (Changed)
				SetItemColor(Item, TV_VALUE, 0xFF0000);

			if (data && data->locationType == LocIsBitField) //+++ TEST IT
			{
				unsigned long long BitValue = Value >> data->BitField.bitPosition;
				BitValue &= ~(~0LL << data->BitField.length); //TODO ???
				if (info.Value.Options & TV_HEX_MASK)
					TSPrintf(&Str[Len], WSTR(" (%I64x)"), BitValue);
				else	TSPrintf(&Str[Len], WSTR(" (%I64d)"), BitValue);
			}

			SetItemText(Item, TV_VALUE, Str);
			SetItemComplexValue(Item, TV_TYPE, SETPAIR(Value, 0));
			} break;
		case ELEM_POINTER:{
#ifdef TXTDEBUG
fprintf(f,"ELEM_POINTER %s\n", __func__);
fflush(f);
#endif
			POINTERTYPE *pt = (POINTERTYPE*)type;
			unsigned long long Value = 0;
			if (gpSyser->m_pDebugger->ReadMemory(Address, &Value, pt->Elem.Length) != pt->Elem.Length) //???
				break;
			TSPrintf(Str, WSTR("0x" F0ADDR "x"), Value); //TODO X64
			SetItemColor(Item, TV_VALUE, 0xFFFFFF);
			if (info.Type.X != Value)
				SetItemColor(Item, TV_VALUE, 0xFF0000);
			SetItemText(Item, TV_VALUE, Str);
			if (pt->Num == 1)
			{
				BASICTYPE *bt = info.Name.pSDSMod->GetGlobal( ((POINTERTYPE*)type)->ID);
				if (!bt) break;
				switch (bt->Elem.Type)
				{
				case ELEM_BASE_TYPE:{
						if (bt->Elem.Length == 1)
						{
							char *str = (char*)Str; //??? jut reuse it, latter will fill WCHAR*
							TSPrintf(str, "0x" F0ADDR "x \"", Value); //TODO X64
							unsigned long r = gpSyser->m_pDebugger->ReadMemory(Value, str + ADDR_SIZE+4, StrLen*2 - (ADDR_SIZE+4+3));
							for (int n = 0; n < r; ++n)
							{
								if (!str[n+ADDR_SIZE+4])
								{
									TStrCpy(&str[n+ADDR_SIZE+4], "\"");
									SetItemText(Item, TV_VALUE, str);
									break;
								}
							}
							Item = FullFindItem(Item, 0);

							ULONGLONG Addr = 0;
							ULONGLONG Options = 0;
							GetItemComplexValue(Item, TV_VALUE, GETPAIR(&Addr, &Options));
							SetItemComplexValue(Item, TV_VALUE, SETPAIR(Value, Options));

							GetOutputValue(info.Name.pSDSMod, bt, Value, info.Value.Options, Str, nullptr, &Value);
							SetItemText(Item, TV_VALUE, Str);
						}
					} break;
				case ELEM_CLASS:
				case ELEM_STRUCT:
				case ELEM_UNION:{
					UpdateStructPointer(Item, Str, StrLen, Value);
					} break;
				}
			}
			} break;
		case ELEM_POINTERREF:{
#ifdef TXTDEBUG
fprintf(f,"ELEM_POINTERREF %s\n", __func__);
fflush(f);
#endif
			ULONG_PTR Value = 0;
			if (gpSyser->m_pDebugger->ReadMemory(Address, &Value, sizeof(Value)) != sizeof(Value)) //???
				break;
			TSPrintf(Str, WSTR("0x" F0ADDR "x"), Value); //TODO X64
			SetItemText(Item, TV_VALUE, Str);
			BASICTYPE *bt = info.Name.pSDSMod->GetGlobal( ((POINTERREFTYPE*)type)->ID);
			if (!bt) break;
			switch (bt->Elem.Type)
			{
			case ELEM_BASE_TYPE:{
				ULONGLONG Addr = 0;
				ULONGLONG Options = 0;
				GetItemComplexValue(Item, TV_VALUE, GETPAIR(&Addr, &Options));
				SetItemComplexValue(Item, TV_VALUE, SETPAIR(Value, Options));
				unsigned long long v = 0;
				GetOutputValue(info.Name.pSDSMod, bt, Value, info.Value.Options, Str, nullptr, &v);
				SetItemText(Item, TV_VALUE, Str);
				} break;
			case ELEM_STRUCT:
			case ELEM_CLASS:
			case ELEM_UNION:{
				UpdateStructPointerRef(Item, Str, StrLen, Value);
				} break;
			}
			} break;
		case ELEM_ARRAY:{
#ifdef TXTDEBUG
fprintf(f,"ELEM_ARRAY %s\n", __func__);
fflush(f);
#endif
			TSPrintf(Str, WSTR("0x" F0ADDR "x"), Address); //TODO X64
			SetItemText(Item, TV_VALUE, Str);
			UpdateArray(Item, Str, StrLen, Address);
			} break;
		case ELEM_ENUM:{
#ifdef TXTDEBUG
fprintf(f,"ELEM_ENUM %s\n", __func__);
fflush(f);
#endif
			unsigned long long Value = 0;
			BASICTYPE *bt = info.Name.pSDSMod->GetGlobal( ((ENUMTYPE*)type)->ID);
			if (GetOutputValue(info.Name.pSDSMod, bt, Address, info.Value.Options, Str, nullptr, &Value))
			{
				const char *name = info.Name.pSDSMod->GetEnumName(NewID, Value);
				if (name)
				{
					SetItemText(Item, TV_VALUE, name);
					break;
				}
			}
			SetItemText(Item, TV_VALUE, Str);
			} break;
		case ELEM_STRUCT:
		case ELEM_CLASS:
		case ELEM_UNION:{
#ifdef TXTDEBUG
fprintf(f,"ELEM_UDT %s\n", __func__);
fflush(f);
#endif
			UpdateStruct(Item, Str, StrLen, Address);
			} break;
		}
		return true;
	}

	bool CTypeViewerWnd::ReadX(const char *Name, ULONG_PTR *Address, FUNCTION **Func, CSDSModule **SDSMod)
	{
		CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP);
		if (!pSDSMod) return false;
		ULONG_PTR ImageBase = pSDSMod->m_pDbgModule->m_ImageBase;

		FUNCTION *pFunc = pSDSMod->GetFunction(Name, true);
		if (!pFunc)
		{
			pFunc = pSDSMod->GetFunction(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP - ImageBase);
			if (!pFunc) return false;
			if (pFunc->ClassID == 0) return false;
			pFunc = pSDSMod->GetFunction(Name, (UDTYPE*)pSDSMod->GetGlobal(pFunc->ClassID), false);
			if (!pFunc) return false;
		}
		*Address = ImageBase + pFunc->rva;
		*Func = pFunc;
		*SDSMod = pSDSMod;
		return true;
	}

	bool CTypeViewerWnd::ReadX(unsigned long regid, ULONG_PTR *Value)
	{
		switch (regid)
		{
	#ifdef _X64_
                case CV_AMD64_RAX:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCAX;
			return true;
                case CV_AMD64_RCX:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCCX;
			return true;
                case CV_AMD64_RDX:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDX;
			return true;
                case CV_AMD64_RBX:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBX;
			return true;
                case CV_AMD64_RSP:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP;
			return true;
                case CV_AMD64_RBP:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP;
			return true;
                case CV_AMD64_RSI:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSI;
			return true;
                case CV_AMD64_RDI:
                       	*Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDI;
			return true;
		default:;
	#else
                case CV_REG_EAX:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCAX;
			return true;
                case CV_REG_ECX:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCCX;
			return true;
                case CV_REG_EDX:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDX;
			return true;
                case CV_REG_EBX:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBX;
			return true;
                case CV_REG_ESP:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSP;
			return true;
                case CV_REG_EBP:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCBP;
			return true;
                case CV_REG_ESI:
                        *Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCSI;
			return true;
                case CV_REG_EDI:
                       	*Value = *gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCDI;
			return true;
		default:;
	#endif
		}
		return false;
	}

	bool CTypeViewerWnd::ReadX(CSDSModule *pSDSMod, FUNCTION *pFunc, ULONG_PTR *Value)
	{
		DATATYPE *data = pSDSMod->GetClassLocal("this", pFunc);
		if (!data) return false;
		ULONG_PTR Address = 0;
		ULONG_PTR MemValue = 0;
		switch (data->locationType)
		{
		case LocIsStatic:
			Address = pSDSMod->m_pDbgModule->m_ImageBase + data->Static.rva;
			break;
		case LocIsRegRel: {
			if (!ReadX(data->RegRel.registerId, &MemValue)) return false;
			Address = MemValue + data->RegRel.offset;
			} break;
		case LocIsEnregistered: {
			if (!ReadX(data->Enregistered.registerId, &MemValue)) return false;
			Address = MemValue;
			} break;
		default:
			return false;
		}
		if (gpSyser->m_pDebugger->ReadMemory(Address, &MemValue, sizeof(MemValue)) == sizeof(MemValue))
		{
			if (Value) *Value = MemValue;
			return true;
		}
		return false;
	}

	bool CTypeViewerWnd::ReadX(const char *Name, ULONG_PTR *Address, DATATYPE **Data, CSDSModule **SDSMod)
	{
		CSDSModule *pSDSMod = gpSyser->m_SyserUI.FindSDSModule(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP);
		if (!pSDSMod) return false;
		ULONG_PTR ImageBase = pSDSMod->m_pDbgModule->m_ImageBase;
		DATATYPE *data = nullptr;
		FUNCTION *pFunc = pSDSMod->GetFunction(*gpSyser->m_SyserUI.m_SyserCodeDoc.m_CPUREGPTR.pCIP - ImageBase);
		if (!pFunc)
		{
			data = pSDSMod->GetLocal(Name, DataIsGlobal);
			if (!data) return false;
		} else
		{
			data = pSDSMod->GetClassLocal(Name, pFunc);
			if (!data)
			{
				data = pSDSMod->GetLocal(Name, DataIsGlobal);
				if (!data) return false;
			}
		}
		switch (data->locationType)
		{
		case LocIsStatic: {
			*Address = ImageBase + data->Static.rva;
			*Data = data;
			*SDSMod = pSDSMod;
			return true;
			} break;
		case LocIsRegRel: {
			ULONG_PTR Value = 0;
			if (!ReadX(data->RegRel.registerId, &Value)) return false;
			*Address = Value + data->RegRel.offset;
			*Data = data;
			*SDSMod = pSDSMod;
			return true;
			} break;
		case LocIsThisRel: {
			ULONG_PTR Value = 0;
			if (!ReadX(pSDSMod, pFunc, &Value)) return false;
			*Address = Value + data->ThisRel.offset;
			*Data = data;
			*SDSMod = pSDSMod;
			return true;
			} break;
		default:;
		}
		return false;
	}


	void CTypeViewerWnd::UpdateContext()
	{
		WCHAR Name[512];

#ifdef TXTDEBUG
fprintf(f,"%s >\n", __func__);
fflush(f);
#endif
		int n = 0;
		CListStringItem *Item = GetItem(0,0);
		while (Item != m_pFirstItem)
		{
			if (GetItemText(Item, TV_NAME, Name, lenof(Name)))
			{
				char szName[lenof(Name)];
				TStrCpy(szName, Name);
#ifdef TXTDEBUG
fprintf(f,"N %d, VarName %s %s\n", n, szName,__func__);
fflush(f);
#endif
				ULONGLONG Options = 0;
				ULONGLONG Addr = 0;
				GetItemComplexValue(Item, TV_VALUE, GETPAIR(&Addr, &Options));
				if (!(Options & TV_STATIC_MASK))
			  { //+++
				ULONG_PTR Address = 0;
				DATATYPE *Data = nullptr;
				CSDSModule *pSDSMod = nullptr;
				TVInfo info;
				if (!ReadX(szName, &Address, &Data, &pSDSMod))
				{
					DeleteAllChildrenItems(Item);

					ULONGLONG Options = 0;
					ULONGLONG Addr = 0;
					GetItemComplexValue(Item, TV_VALUE, GETPAIR(&Addr, &Options));
					Options |= TV_CLOSE_MASK;
					SetItemComplexValue(Item, TV_VALUE, SETPAIR(Addr, Options));

					TStrCpy(szName, "Error: symbol \"");
					TStrCat(szName, Name);
					TStrCat(szName, "\" not found");
					SetItemText(Item, TV_VALUE, szName);
					SetItemText(Item, TV_TYPE, "");
				} else
				if (GetItems(Item, &info))
				{
					if (info.Value.Options & TV_CLOSE_MASK)
					{
						AddWatch(Name, Item);
					} else
					if (info.Value.Options & TV_DATA_MASK)
					{
						if (Data->ID != info.Name.ID)
						{
							DeleteAllChildrenItems(Item);
							AddWatch(Name, Item);
						} else
						if (info.Value.Address != Address)
						{
							info.Value.Address = Address;
							SetItemComplexValue(Item, TV_VALUE, SETPAIR(info.Value.Address, info.Value.Options));
						}
					}
				}
			  } //+++
			}
#ifdef TXTDEBUG
fprintf(f,"N %d %s\n", n, __func__);
fflush(f);
#endif
			++n;
			Item = GetNext(Item, 0);
		}

		{
		CListStringItem *Item = GetItem(0, 0);
		while (Item != m_pFirstItem)
		{
			UpdateWatch(Item, Name, lenof(Name), 0);
#ifdef TXTDEBUG
			char szName[512];
			TStrCpy(szName, Name);
fprintf(f,"update VarName %s %s\n", szName,__func__);
fflush(f);
#endif
			Item = GetNext(Item, 0);
		}
		}
#ifdef TXTDEBUG
fprintf(f,"%s <\n", __func__);
fflush(f);
#endif
	}

	void CTypeViewerWnd::RemoveSDSModule(CSDSModule *pSDSMod)
	{
		TVInfo info;
		TList<CListStringItem *> List;
		CListStringItem *Item = GetNext(0, 0);
		while (Item != m_pFirstItem)
		{
			if (GetItems(Item, &info) &&
				//info.Value.Options >= 0 && //??? !( & 0x8000'0000)
				!(info.Value.Options & TV_CLOSE_MASK) &&
				pSDSMod == info.Name.pSDSMod)
			{
				List.Append(&Item);
			}
			Item = GetNext(Item, 0);
		}
		TList<CListStringItem *>::IT It = List.Begin();
		while (It != List.End())
		{
			DeleteItem(*It);
			++It;
		}
	}

	void CTypeViewerWnd::ShowBaseType(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal)
	{
		WCHAR DisplayOut[60];
		TStrCpy(DisplayOut, WSTR("" UNREADSTR ""));

#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif
		CWispDIB *pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
		if (pSDSMod)
		{
			unsigned long NewID = ID;
			if (bLocal)
			{
				DATATYPE *data = pSDSMod->GetLocal(ID);
				if (!data) return;
				NewID = data->TypeID;
				if (!VarName)
					VarName = data->name;
				switch (data->access)
				{
				case CV_private:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11F);
					break;
				case CV_protected:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11E);
					break;
				case CV_public:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
					break;
				}
			}

			BASICTYPE *type = pSDSMod->GetGlobal(NewID);
			if (type)
			{
				Options = (Options & ~(TV_DATA_MASK | TV_FUNC_MASK)) | (bLocal ? TV_DATA_MASK : TV_FUNC_MASK);
				CListStringItem *SubItem = InsertItemStr(VarName, Item, 0, pDIB, -1);
				SetItemComplexValue(SubItem, TV_NAME, SETPAIR(pSDSMod, (!bLocal ? NewID : ID)));
				SetItemComplexValue(SubItem, TV_VALUE, SETPAIR(Address, Options));
			#if 1 //TODO data unavail
				DATATYPE *data = pSDSMod->GetLocal(ID);
				if (data && data->locationType == LocIsBitField) //+++ TEST IT
				{
					WCHAR Str[30];
					int Len = TStrCpy(Str, type->Elem.Name);
					if (data->BitField.length == 1)
						TSPrintf(&Str[Len], WSTR(" (Bit %d)"), data->BitField.bitPosition);
					else	TSPrintf(&Str[Len], WSTR(" (Bit %d-%d)"), data->BitField.bitPosition, data->BitField.bitPosition+data->BitField.length-1);
					
					SetItemText(SubItem, TV_TYPE, Str);
#ifdef TXTDEBUG
fprintf(f,"%s %s %d, %d\n", __func__, data->name, data->BitField.bitPosition, data->BitField.length);
fflush(f);
#endif
				} else
			#endif
				{
					SetItemText(SubItem, TV_TYPE, type->Elem.Name);
				}
				SetItemFormat(SubItem, TV_OFFSET, Address, WSTR("0x" F0ADDR "x")); //TODO X64
				unsigned long long Value = 0;
				int Len = 0;
				GetOutputValue(pSDSMod, type, Address, Options, DisplayOut, &Len, &Value);
				SetItemComplexValue(SubItem, TV_TYPE, SETPAIR(Value, 0)); //???----------------
				if (data && data->locationType == LocIsBitField) //+++ TEST IT
				{
					unsigned long long BitValue = Value >> data->BitField.bitPosition;
					BitValue &= ~(~0LL << data->BitField.length); //TODO ???
					if (Options & TV_HEX_MASK)
						TSPrintf(&DisplayOut[Len], WSTR(" (%I64x)"), BitValue);
					else	TSPrintf(&DisplayOut[Len], WSTR(" (%I64d)"), BitValue);
				}
				SetItemText(SubItem, TV_VALUE, DisplayOut);
			}
		}
	}

	void CTypeViewerWnd::ShowPointer(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal)
	{
		WCHAR szUnread[sizeof(UNREADSTR)+1];
		TStrCpy(szUnread, WSTR("" UNREADSTR ""));

		char OutputType[512];
		int OutputTypeLen = 512;

#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif

		CWispDIB *pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
		if (pSDSMod)
		{
			unsigned long NewID = ID;
			if (bLocal)
			{
				DATATYPE *data = pSDSMod->GetLocal(ID);
				if (!data) return;
				NewID = data->TypeID;
				//if (!VarName)
				//	VarName = data->name;
				switch (data->access)
				{
				case CV_private:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11F);
					break;
				case CV_protected:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11E);
					break;
				case CV_public:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
					break;
				}
			}

			POINTERTYPE *pt = (POINTERTYPE*)pSDSMod->GetGlobal(NewID);
			if (pt && pt->Elem.Type == ELEM_POINTER)
			{
				unsigned long long Value = 0;
				unsigned long Result = 0;
				if (pt->Elem.Length && pt->Elem.Length <= 8)
					Result = gpSyser->m_pDebugger->ReadMemory(Address, &Value, pt->Elem.Length);
				WCHAR szValue[30];
				if (Result == pt->Elem.Length && Result)
					TSPrintf(szValue, WSTR("0x" F0ADDR "x"), Value); //TODO X64 ???
				else	TStrCpy(szValue, szUnread);
				BASICTYPE *bt = pSDSMod->GetGlobal(pt->ID);
				pSDSMod->GetOutput(pt, OutputType, &OutputTypeLen);
				bool bvoidptr = !TStrCmp(OutputType, "void*");
				if (bt->Elem.Type == ELEM_FUNC_TYPE)
					bvoidptr = true;
				OutputType[0] = 0;
				pSDSMod->GetOutput(pt, OutputType, &OutputTypeLen);
				CListStringItem *NewItem = nullptr;
				if (VarName)
					NewItem = InsertItemStr(VarName, Item, 0, pDIB, -1);
				else	NewItem = InsertItemStr(OutputType, Item, 0, pDIB, -1);
				SetItemText(NewItem, TV_TYPE, OutputType);
				SetItemComplexValue(NewItem, TV_TYPE, SETPAIR(Value, 0)); //???
				SetItemComplexValue(NewItem, TV_NAME, SETPAIR(pSDSMod, (!bLocal ? NewID : ID)));
				SetItemText(NewItem, TV_VALUE, szValue);
				unsigned long PointerOptions = (bLocal ? TV_DATA_MASK : TV_FUNC_MASK) | (Options & ~(TV_FUNC_MASK|TV_DATA_MASK));
				SetItemComplexValue(NewItem, TV_VALUE, SETPAIR(Address, PointerOptions));
				SetItemFormat(NewItem, TV_OFFSET, Address, WSTR("0x" F0ADDR "x ")); //TODO X64
				SetItemComplexValue(NewItem, TV_TYPE, SETPAIR(0, 0));
				if (bt->Elem.Type == ELEM_BASE_TYPE && bt->Elem.Length == 1)
				{
					TSPrintf(OutputType, "0x" F0ADDR "x \"", Value); //TODO X64
					unsigned long Result = gpSyser->m_pDebugger->ReadMemory(Value, &OutputType[ADDR_SIZE+4], 512-(ADDR_SIZE+4+3)); //15
					for (int n = 0; n < Result; ++n)
					{
						if (!OutputType[n+ADDR_SIZE+4]) //TODO X64 +12
						{
							OutputType[n+ADDR_SIZE+5] = 0;
							OutputType[n+ADDR_SIZE+4] = '"';
							SetItemText(NewItem, TV_VALUE, OutputType);
							break;
						}
					}
				}

				if (!bvoidptr)
				{
					NewItem = InsertItem(WSTR(".."), NewItem, 0, nullptr, -1);
					SetItemComplexValue(NewItem, TV_VALUE, SETPAIR(Address, (PointerOptions | TV_CLOSE_MASK)));
				}
				SetItemText(NewItem, TV_TYPE, OutputType);
				SetItemComplexValue(NewItem, TV_TYPE, SETPAIR(0, ID)); //???
			}
		}
	}

	void CTypeViewerWnd::ShowArray(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal)
	{
		char DisplayOut[512];
		int DisplayOutLen = 512;

#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif

		CWispDIB *pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
		if (pSDSMod)
		{
			unsigned long NewID = ID;
			if (bLocal)
			{
				DATATYPE *data = pSDSMod->GetLocal(ID);
				if (!data) return;
				NewID = data->TypeID;
				if (!VarName)
					VarName = data->name;
				switch (data->access)
				{
				case CV_private:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11F);
					break;
				case CV_protected:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11E);
					break;
				case CV_public:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
					break;
				}
			}

			BASICTYPE *type = pSDSMod->GetGlobal(NewID);
			if (type)
			{
				WCHAR szAddress[30];
				TSPrintf(szAddress, WSTR("0x" F0ADDR "x"), Address); //TODO X64
				pSDSMod->GetOutput(type, DisplayOut, &DisplayOutLen);
				CListStringItem *Item1;
				if (VarName)
					Item1 = InsertItemStr(VarName, Item, 0, pDIB, -1);
				else	Item1 = InsertItemStr(DisplayOut, Item, 0, pDIB, -1);
				SetItemText(Item1, TV_TYPE, DisplayOut);
				SetItemComplexValue(Item1, TV_NAME, SETPAIR(pSDSMod, (!bLocal ? NewID : ID)));
				SetItemText(Item1, TV_VALUE, szAddress);
				Options = (Options & ~(TV_DATA_MASK | TV_FUNC_MASK)) | (bLocal ? TV_DATA_MASK : TV_FUNC_MASK);
				SetItemComplexValue(Item1, TV_VALUE, SETPAIR(Address, Options));
				SetItemFormat(Item1, TV_OFFSET, Address, WSTR("0x" F0ADDR "x")); //TODO X64
				SetItemComplexValue(Item1, TV_TYPE, SETPAIR(0, ID));

				CListStringItem *SubItem = InsertItem(WSTR(".."), Item1, 0, nullptr, -1);
				SetItemComplexValue(SubItem, TV_VALUE, SETPAIR(ID, TV_CLOSE_MASK)); //??? ID
			}
		}
	}

	void CTypeViewerWnd::ShowEnum(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal)
	{
		if (pSDSMod)
		{
			unsigned long NewID = ID;
			if (bLocal)
			{
				DATATYPE *data = pSDSMod->GetLocal(ID);
				if (!data) return;
				NewID = data->TypeID;
			}

			BASICTYPE *type = pSDSMod->GetGlobal(NewID);
			if (type && type->Elem.Type == ELEM_ENUM)
			{
				WCHAR szAddress[30];
				TSPrintf(szAddress, WSTR("0x" F0ADDR "x"), Address); //TODO X64
				char DisplayOut[512];
				int DisplayOutLen = 512;
				pSDSMod->GetOutput(type, DisplayOut, &DisplayOutLen);
				if (VarName)
					Item = InsertItemStr(VarName, Item, 0, nullptr, -1);
				else	Item = InsertItemStr(DisplayOut, Item, 0, nullptr, -1);

				SetItemComplexValue(Item, TV_NAME, SETPAIR(pSDSMod, (!bLocal ? NewID : ID)));
				Options = (Options & ~(TV_DATA_MASK | TV_FUNC_MASK)) | (bLocal ? TV_DATA_MASK : TV_FUNC_MASK);
				SetItemComplexValue(Item, TV_VALUE, SETPAIR(Address, Options));
				SetItemComplexValue(Item, TV_TYPE, SETPAIR(0, ID));
				SetItemText(Item, TV_TYPE, DisplayOut);

				unsigned long long Value = 0;
				if (GetOutputValue(pSDSMod, pSDSMod->GetGlobal( ((ENUMTYPE*)type)->ID), Address, Options, szAddress, nullptr, &Value) )
				{
					const char *Name = pSDSMod->GetEnumName(ID, Value);
					if (Name)
						SetItemText(Item, TV_VALUE, Name);
					else	SetItemText(Item, TV_VALUE, szAddress);
				} else
				{
					SetItemText(Item, TV_VALUE, szAddress);
				}
				SetItemFormat(Item, TV_OFFSET, Address, WSTR("%X"));
			}
		}
	}

	void CTypeViewerWnd::ShowStruct(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal)
	{
		char DisplayOut[512];
		int DisplayOutLen = 512;

#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif
		CWispDIB *pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
		if (pSDSMod)
		{
			unsigned long NewID = ID;
			if (bLocal)
			{
				DATATYPE *data = pSDSMod->GetLocal(ID);
				if (!data) return;
				NewID = data->TypeID;
				if (!VarName)
					VarName = data->name;
				switch (data->access)
				{
				case CV_private:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11F);
					break;
				case CV_protected:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11E);
					break;
				case CV_public:
					pDIB = gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF)->GetDIB(0x11D);
					break;
				}
			}

			BASICTYPE *type = pSDSMod->GetGlobal(NewID);
			if (type && (type->Elem.Type == ELEM_CLASS || type->Elem.Type == ELEM_STRUCT))
			{
			#if 1
				TStaticAnsiString Str(TStrLen(type->Elem.Name)+1+8);
			#else
				char Buffer[256];
				char *pBuffer = Buffer;
				unsigned int Len = TStrLen(type->Elem.Name) + 9; //??? 
				if (Len >= 256)
					pBuffer = new char[Len];
				*pBuffer = 0;
				//TStrCpy(pBuffer, String);
			#endif
				switch (type->Elem.Type)
				{
				case ELEM_STRUCT:
					TSPrintf((char*)Str/*pBuffer*/, "struct %s", type->Elem.Name);
					break;
				case ELEM_CLASS:
					TSPrintf((char*)Str/*pBuffer*/, "class %s", type->Elem.Name);
					break;
				case ELEM_UNION:
					TSPrintf((char*)Str/*pBuffer*/, "union %s", type->Elem.Name);
					break;
				}

				const char *Name = type->Elem.Name; //Str ???
				CListStringItem *NewItem = InsertItemStr(Name, Item, 0, nullptr, -1); //??? pDIB
				SetItemText(NewItem, TV_TYPE, Name);

				if (VarName)
					SetItemText(NewItem, TV_NAME, VarName);
				SetItemComplexValue(NewItem, TV_NAME, SETPAIR(pSDSMod, (!bLocal ? NewID : ID)));
				SetItemText(NewItem, TV_VALUE, WSTR("{...}"));
				SetItemComplexValue(NewItem, TV_TYPE, SETPAIR(0, 0));

				Options = (Options & ~(TV_DATA_MASK | TV_FUNC_MASK)) | (bLocal ? TV_DATA_MASK : TV_FUNC_MASK);
				SetItemComplexValue(NewItem, TV_VALUE, SETPAIR(Address, Options));

				SetItemFormat(NewItem, TV_OFFSET, Address, WSTR("0x" F0ADDR "x")); //TODO X64

				CListStringItem *SubItem = InsertItem(WSTR(".."), NewItem, 0, nullptr, -1);
				Options |= TV_CLOSE_MASK;
				SetItemComplexValue(SubItem, TV_VALUE, SETPAIR(0, Options));
			#if 0
				if (pBuffer != Buffer)
					delete []pBuffer;
			#endif
			}
		}
	}

	void CTypeViewerWnd::Show(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName)
	{
#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif
		if (pSDSMod)
		{
			BASICTYPE *type = pSDSMod->GetGlobal(ID);
			if (type)
			{
				if (!Item)
				{
					DeleteItem(m_pFirstItem);
					m_pFirstItem = nullptr;
				}

				switch (type->Elem.Type)
				{
				case ELEM_BASE_TYPE:
					ShowBaseType(pSDSMod, ID, Address, Options, Item, VarName, false);
					break;
				case ELEM_POINTER:
					ShowPointer(pSDSMod, ID, Address, Options, Item, VarName, false);
					break;
				case ELEM_ARRAY:
					ShowArray(pSDSMod, ID, Address, Options, Item, VarName, false);
					break;
				case ELEM_ENUM:
					ShowEnum(pSDSMod, ID, Address, Options, Item, VarName, false);
					break;
				case ELEM_STRUCT:
				case ELEM_CLASS:
				case ELEM_UNION:
					ShowStruct(pSDSMod, ID, Address, Options, Item, VarName, false);
					break;
				}

				if (!m_pFirstItem) //+++
				{
					ResetItems();
				}
			}
		}
	}

	bool CTypeViewerWnd::GetOutputValue(CSDSModule *pSDSMod, BASICTYPE *Type, ULONG_PTR Address, unsigned long Options, WCHAR *DisplayOut, int *DisplayOutLen, unsigned long long *Value)
	{
		WCHAR szUnread[sizeof(UNREADSTR)+1];
		TStrCpy(szUnread, WSTR("" UNREADSTR ""));
		int Len = 0;
		*DisplayOut = 0;
		if (DisplayOutLen) *DisplayOutLen = 0;
#ifdef TXTDEBUG
fprintf(f,"%s\n", __func__);
fflush(f);
#endif
		if (pSDSMod && Type && Type->Elem.Type == ELEM_BASE_TYPE)
		{
			*Value = 0;
			unsigned long basetype = GetBasicType(Type->Elem.Name);
			unsigned long Result = 0;
			if (Type->Elem.Length && Type->Elem.Length <= 8)
			{
				Result = gpSyser->m_pDebugger->ReadMemory(Address, Value, Type->Elem.Length);
			}
		#if 0
			if (data && data->locationType == LocIsBitField) //+++ TEST IT
			{
				unsigned long long BitValue = Value >> data->BitField.bitPosition;
				BitValue &= ~(~0LL << data->BitField.length); //TODO ???
				Value = BitValue;
			}
		#endif
			if (Result == Type->Elem.Length && Result)
			{
				switch (basetype)
				{
				case 0x2: { //0x80 char
					char v = *Value;
					if (Options & TV_HEX_MASK)
					{
						if (v <= 0)
							Len = TSPrintf(DisplayOut, WSTR("0x%02x"), v);
						else	Len = TSPrintf(DisplayOut, WSTR("0x%02x '%c'"), v, v);
					} else
					{
						if (v <= 0)
							Len = TSPrintf(DisplayOut, WSTR("%d"), v);
						else	Len = TSPrintf(DisplayOut, WSTR("%d '%c'"), v, v);
					}
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0xA: { // bool
					if (*(bool*)Value)
						Len = TStrCpy(DisplayOut, "true");
					else	Len = TStrCpy(DisplayOut, "false");
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0xD: { // long
					long v = *Value;
					if (Options & TV_HEX_MASK)
						Len = TSPrintf(DisplayOut, WSTR("0x%x"), v);
					else	Len = TSPrintf(DisplayOut, WSTR("%d"), v);
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0xE: { // unsigned long
					unsigned long v = *Value;
					if (Options & TV_HEX_MASK)
						Len = TSPrintf(DisplayOut, WSTR("0x%08x"), v);
					else	Len = TSPrintf(DisplayOut, WSTR("%u"), v);
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0x80: { //0x2 char
					char v = *Value;
					if (Options & TV_HEX_MASK)
					{
						if (v <= 0)
							Len = TSPrintf(DisplayOut, WSTR("0x%02x"), v);
						else	Len = TSPrintf(DisplayOut, WSTR("0x%02x '%c'"), v, v);
					} else
					{
						if (v <= 0)
							Len = TSPrintf(DisplayOut, WSTR("%d"), v);
						else	Len = TSPrintf(DisplayOut, WSTR("%d '%c'"), v, v);
					}
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0x100: { // short
					short v = *Value;
					if (Options & TV_HEX_MASK)
						Len = TSPrintf(DisplayOut, WSTR("0x%x"), v);
					else	Len = TSPrintf(DisplayOut, WSTR("%d"), v);
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0x200: { // int
					int v = *Value;
					if (Options & TV_HEX_MASK)
						Len = TSPrintf(DisplayOut, WSTR("0x%x"), v);
					else	Len = TSPrintf(DisplayOut, WSTR("%d"), v);
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0x400: { // __int64
					__int64 v = *Value;
					if (Options & TV_HEX_MASK)
						Len = TSPrintf(DisplayOut, WSTR("0x%I64x"), v);
					else	Len = TSPrintf(DisplayOut, WSTR("%I64d"), v);
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0x800: { // unsigned char
					unsigned char v = *Value;
					if (Options & TV_HEX_MASK)
					{
						if (v > 0x80 || v == 0)
							Len = TSPrintf(DisplayOut, WSTR("0x%02x"), v);
						else	Len = TSPrintf(DisplayOut, WSTR("0x%0x '%c'"), v, v);
					} else
					{
						if (v > 0x80 || v == 0)
							Len = TSPrintf(DisplayOut, WSTR("%d"), v);
						else	Len = TSPrintf(DisplayOut, WSTR("%d '%c'"), v, v);
					}
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0x1000: { // unsigned short
					unsigned short v = *Value;
					if (Options & TV_HEX_MASK)
						Len = TSPrintf(DisplayOut, WSTR("0x%x"), v);
					else	Len = TSPrintf(DisplayOut, WSTR("%u"), v);
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0x2000: { // unsigned int
					unsigned int v = *Value;
					if (Options & TV_HEX_MASK)
						Len = TSPrintf(DisplayOut, WSTR("0x%08x"), v);
					else	Len = TSPrintf(DisplayOut, WSTR("%u"), v);
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				case 0x4000: { // unsigned __int64
					unsigned __int64 v = *Value;
					if (Options & TV_HEX_MASK)
						Len = TSPrintf(DisplayOut, WSTR("0x%I64x"), v);
					else	Len = TSPrintf(DisplayOut, WSTR("%I64u"), v);
					if (DisplayOutLen) *DisplayOutLen = Len;
					return true;
					} break;
				}
			}
			Len = TStrCpy(DisplayOut, szUnread);
			if (DisplayOutLen) *DisplayOutLen = Len;
		}
		return false;
	}

	bool CTypeViewerWnd::GetItems(CListStringItem *Item, TVName *Name, TVValue *Value, TVType *Type, TVOffset *Offset)
	{
		if (!Item) return false;
		ULONGLONG v1,v2;
		GetItemComplexValue(Item, TV_NAME, GETPAIR(&v1, &v2));
		Name->pSDSMod = (CSDSModule*)v1;
		Name->ID = v2;
		GetItemComplexValue(Item, TV_VALUE, GETPAIR(&v1, &v2));
		Value->Address = v1;
		Value->Options = v2;
		GetItemComplexValue(Item, TV_TYPE, GETPAIR(&v1, &v2));
		Type->X = v1;
		Type->ID = v2;
		GetItemComplexValue(Item, TV_OFFSET, GETPAIR(&v1, &v2));
		Offset->X = v1;
		Offset->ID = v2;
		return true;
	}

	bool CTypeViewerWnd::GetItems(CListStringItem *Item, TVInfo *info)
	{
		if (!Item) return false;
		ULONGLONG v1,v2;
		GetItemComplexValue(Item, TV_NAME, GETPAIR(&v1, &v2));
		info->Name.pSDSMod = (CSDSModule*)v1;
		info->Name.ID = v2;
		GetItemComplexValue(Item, TV_VALUE, GETPAIR(&v1, &v2));
		info->Value.Address = v1;
		info->Value.Options = v2;
		GetItemComplexValue(Item, TV_TYPE, GETPAIR(&v1, &v2));
		info->Type.X = v1;
		info->Type.ID = v2;
		GetItemComplexValue(Item, TV_OFFSET, GETPAIR(&v1, &v2));
		info->Offset.X = v1;
		info->Offset.ID = v2;
		return true;
	}

	bool CTypeViewerWnd::SetItemComplexValue(CListStringItem *Item, int nCol, ULONGLONG v1, ULONGLONG v2)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		if (!Content) return false;
		Content->v1 = v1;
		Content->v2 = v2;
		return true;
	}

	bool CTypeViewerWnd::GetItemComplexValue(CListStringItem *Item, int nCol, ULONGLONG *v1, ULONGLONG *v2)
	{
		CListStringItem::CONTENT *Content = GetItemContent(Item, nCol);
		if (!Content) return false;
		*v1 = Content->v1;
		*v2 = Content->v2;
		return true;
	}

	bool CTypeViewerWnd::SetAddress(CListStringItem *Item, unsigned long ID, ULONG_PTR Address)
	{
		Item = FullFindItem(Item, 0);
		while (Item)
		{
			TVInfo info;
			if (GetItems(Item, &info) && info.Name.ID == ID && (info.Value.Options & TV_FUNC_MASK)) //FUNC
			{
				WCHAR Buffer[256];
				GetItemText(Item, TV_NAME, Buffer, lenof(Buffer));
				SetItemComplexValue(Item, TV_VALUE, SETPAIR(Address, info.Value.Options));
				return true;
			}
			Item = GetNext(Item, 0);
		}
		return false;
	}

```

`source/WispSyser/typeviewerwnd.hpp`:

```hpp

#ifndef _TYPEVIEWERWND_HPP_
#define _TYPEVIEWERWND_HPP_

#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispmenu.hpp"
#include "../EXEAnalyzer/sdsmodule.hpp"

struct TVName
{
	unsigned long ID;
	CSDSModule *pSDSMod;
};

#define TV_STATIC_MASK	   0x8'0000 //+++
#define TV_VTBL_MASK	  0x80'0000
#define TV_NEW_MASK	 0x100'0000
// 0x200'0000
#define TV_HEX_MASK	 0x400'0000
// 0x800'0000
//0x1000'0000
#define TV_DATA_MASK	0x2000'0000
#define TV_FUNC_MASK	0x4000'0000
#define TV_CLOSE_MASK	0x8000'0000

struct TVValue
{
	unsigned long long Address;
	unsigned long long Options; //TODO bitfield
};

struct TVType
{
	unsigned long long X; //Address/Value
	unsigned long long ID;
};

struct TVOffset
{
	unsigned long long X; //Address
	unsigned long long ID;
};

struct TVInfo
{
	TVName Name;
	TVValue Value;
	TVType Type;
	TVOffset Offset;
};

#define SETPAIR(x,y) ((ULONGLONG)x), ((ULONGLONG)y)
#define GETPAIR(x,y) ((ULONGLONG*)x), ((ULONGLONG*)y)

struct CTypeViewerWnd : public CWispList
{
	CWispMenu m_PopupMenu;
	CWispMenu::MenuItem *m_pMenuItemRemove;
	CListStringItem *m_pFirstItem;

	CTypeViewerWnd();
	virtual ~CTypeViewerWnd();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);

	bool OnKeyEvent(WISP_MSG *pMsg);

	bool OnEvent(WISP_MSG *pMsg);

	bool OnEventDelete(WISP_MSG *pMsg);
	bool OnEventHex(WISP_MSG *pMsg);

	virtual bool Edit(CListStringItem *Item, int nCol, TWideString& String) override; //Content? 0x80000111 //+54

	bool AddWatch(CListStringItem *pItem);
	void AddWatch(const WCHAR *String, CListStringItem *pItem);
	void AddWatch(const char *szString, CListStringItem *pItem);
	virtual bool OnEditing(CListStringItem *Item, int nCol, TWideString& String) override; //80000113,80000112 //+58

	bool Write(ULONG_PTR Address, CSDSModule *pSDSMod, unsigned int ID, unsigned long long Value);
	bool EDIT(CListStringItem *Item);
	virtual void OnEdit(CListStringItem *Item, int nCol, TWideString& String) override; //0x8000010E //+5C

	BASICTYPE *GetPointerRefType(CSDSModule *pSDSMod, unsigned long ID);
	void ExpandVTable(CListStringItem *Item, TVInfo *info);

	void ExpandPointer(CListStringItem *Item);
	void ExpandPointerRef(CListStringItem *Item);
	void ExpandArray(CListStringItem *Item);
	void ExpandStruct(CListStringItem *Item, TVInfo *info);

	void EXPAND(CListStringItem *Item);
	virtual void OnExpand(CListStringItem *Item) override; //+64

	void ResetItems();

	void ResetContext();

	bool UpdateArray(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address);
	bool UpdateBaseClassPointer(CListStringItem *Item, ULONG_PTR Address);
	bool UpdateStructPointer(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address);
	bool UpdateStructPointerRef(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address);
	bool UpdateBaseClass(CListStringItem *Item, ULONG_PTR Address);
	bool UpdateStruct(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address);
	bool UpdateWatch(CListStringItem *Item, WCHAR *Str, unsigned int StrLen, ULONG_PTR Address);

	bool ReadX(const char *Name, ULONG_PTR *Address, FUNCTION **pFunc, CSDSModule **SDSMod);
	bool ReadX(unsigned long regid, ULONG_PTR *Value);
	bool ReadX(CSDSModule *pSDSMod, FUNCTION *pFunc, ULONG_PTR *Value);
	bool ReadX(const char *Name, ULONG_PTR *Address, DATATYPE **Data, CSDSModule **SDSMod);
	void UpdateContext();

	void RemoveSDSModule(CSDSModule *pSDSMod);

	void ShowBaseType(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal);
	void ShowPointer(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal);
	void ShowArray(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal);
	void ShowEnum(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal);
	void ShowStruct(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName, bool bLocal);
	void Show(CSDSModule *pSDSMod, unsigned long ID, ULONG_PTR Address, unsigned long Options, CListStringItem *Item, const char *VarName);

	bool GetOutputValue(CSDSModule *pSDSMod, BASICTYPE *Type, ULONG_PTR Address, unsigned long Options, WCHAR *DisplayOut, int *DisplayOutLen, unsigned long long *Value);

	bool GetItems(CListStringItem *Item, TVName *tvname, TVValue *tvvalue, TVType *tvtype, TVOffset *tvoffset);
	bool GetItems(CListStringItem *Item, TVInfo *info);

	bool SetItemComplexValue(CListStringItem *Item, int nCol, ULONGLONG v1, ULONGLONG v2);
	bool GetItemComplexValue(CListStringItem *Item, int nCol, ULONGLONG *v1, ULONGLONG *v2);

	bool SetAddress(CListStringItem *Item, unsigned long ID, ULONG_PTR Address);
};

#endif
```

`source/WispSyser/watchlist.cpp`:

```cpp

#include "../Wisp/wispbase.hpp"
#include "SyserRing3.hpp"
#include "watchlist.hpp"
#include "syserconfig.hpp"

enum
{
  WL_EXPR = 0,
  WL_VALUE = 1,
  WL_CONTEXT = 2,
};

	void CWatchList::ResetContext()
	{
		DeleteAllChildrenItems(0);
		m_pFirstItem = InsertItem(0, 0, 0, 0, -1);
		Select(m_pFirstItem);
	}

	void CWatchList::UpdateLine(CListStringItem *pItem)
	{
		WCHAR Buffer[256];
		WCHAR *pStr = Buffer;
		char Encode = 0;
		ULONG_PTR Result;
		if (gpSyser->m_SyserUI.CalcExp(GetItemContent(pItem, WL_EXPR)->String.operator const WCHAR*(), &Result))
		{
			SetItemFormat(pItem, WL_VALUE, Result, WSTR("" HEXFMT ""));
			char szSym[256];
			if (gpSyser->m_SyserUI.GetSymbol(Result, szSym, 256) || // 64/256 ???
				(!gpSyser->m_SyserUI.ReadString(Result, Buffer, 256, &Encode) &&
				gpSyser->m_SyserUI.GetSymbolOffset(Result, szSym)))
			{
				TStrCpy(Buffer, szSym);
				pStr = Buffer;
			}
		} else
		{
			SetItemText(pItem, WL_VALUE, WSTR("" UNREADSTR ""));
		}
		SetItemText(pItem, WL_CONTEXT, pStr);
	}

	void CWatchList::UpdateContext()
	{
		CListStringItem *pItem = GetItem(0, 0);
		while (pItem && pItem != m_pFirstItem)
		{
			UpdateLine(pItem);
			pItem = GetNext(pItem, 0);
		}
		Update(&m_ClientRect);
	}

	CWatchList::CWatchList()
	{
		m_pFirstItem = 0;
	}

	CWatchList::~CWatchList()
	{
	}

	WISP_MSG_MAP_BEGIN(CWatchList)
	//	WISP_MSG_MAP(WISP_WM_UPDATE, OnUpdate)
		WISP_MSG_MAP(WISP_WM_CREATE, OnCreate)
		WISP_MSG_MAP(WISP_WM_DESTROY, OnDestroy)
		WISP_MSG_MAP(WISP_WM_KEY_EVENT, OnKeyEvent)
		WISP_MSG_MAP_ON_EVENT
	WISP_MSG_MAP_END(CWispList)

WISP_MENU_GROUP_ITEM WatchListPopupMenu[] = 
{
	{WSTR("Add"), 0xF1, 0x80, 0, 0 }, //EVENT_ID_WATCH_ADD
	{WSTR("Remove"), 0xF4, 0xCA, 0, 0}, //EVENT_ID_WATCH_DEL
	{0},
};

	bool CWatchList::OnUpdate(WISP_MSG *pMsg)
	{
		m_ItemColor = gSyserColors.Color[1];
		SetBGColor(gSyserColors.Color[0]);
		UpdateItemColor(0);
		//TODO
		return true;
	}

	bool CWatchList::OnCreate(WISP_MSG *pMsg)
	{
		m_ItemColor = gSyserColors.Color[1];
		m_Style |= 0x2000000;
		SetBGColor(gSyserColors.Color[0]);
		m_PopupMenu.LoadPopupMenuGroup(WatchListPopupMenu, this, gpCurWisp->m_DIBLib.LoadDIBList("\\Toolbar.bmp", 16, 16, 0, 0xFF00FF));
		m_pMenuItemRemove = m_PopupMenu.GetItem(0xF4);
		InsertColumn(WSTR("Expression[F2]"), 90, 1, 0, -1);
		InsertColumn(WSTR("Value"), 70, 0, 0, -1);
		InsertColumn(WSTR("Context"), 60, 0, 0, -1);
		ResetContext();
		return true;
	}

	bool CWatchList::OnDestroy(WISP_MSG *pMsg)
	{
		m_PopupMenu.Destroy();
		return true;
	}

	bool CWatchList::OnKeyEvent(WISP_MSG *pMsg)
	{
		if (gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen && !pMsg->KeyEvent.bKeyDown)
		{
			if (pMsg->KeyEvent.KeyType == VK_RBUTTON)
			{
				CListStringItem *Item = GetNext(0, 8);
				m_PopupMenu.Enable(m_pMenuItemRemove, Item && Item != m_pFirstItem);
				m_PopupMenu.Point(0, 1);
			} else
			if (pMsg->KeyEvent.KeyType == VK_F2)
			{
				CListStringItem *Item = GetNext(0, 8);
				if (Item)
					EditItem(Item, WL_EXPR);
			}
		}
		return true;
	}

	bool CWatchList::OnEventAdd(WISP_MSG *pMsg)
	{
		EditItem(m_pFirstItem, WL_EXPR);
		return true;
	}

	bool CWatchList::OnEventDel(WISP_MSG *pMsg)
	{
		CListStringItem *Item = GetNext(0, 8);
		if (Item && Item != m_pFirstItem)
			DeleteItem(Item);
		return true;
	}

	WISP_EVENT_MAP_BEGIN(CWatchList)
		WISP_EVENT_MAP(0xF1, OnEventAdd) //EVENT_ID_WATCH_ADD
		WISP_EVENT_MAP(0xF4, OnEventDel) //EVENT_ID_WATCH_DEL
	WISP_EVENT_MAP_END

	bool CWatchList::Edit(CListStringItem *Item, int nCol, TWideString& String)
	{
		return gpSyser->m_SyserUI.m_SyserCodeDoc.m_bOpen != 0;
	}
	bool CWatchList::OnEditing(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (Item == m_pFirstItem)
		{
			if (String.m_nLength)
			{
				m_pFirstItem = InsertItem(0, 0, 0, 0, -1);
				return true;
			}
		} else
		{
			if (String.m_nLength) return true;
			DeleteItem(Item);
		}
		return false;
	}
	void CWatchList::OnEdit(CListStringItem *Item, int nCol, TWideString& String)
	{
		if (nCol == WL_EXPR)
		{
			UpdateLine(Item);
		}
	}

```

`source/WispSyser/watchlist.hpp`:

```hpp

#ifndef _WATCHLIST_HPP_
#define _WATCHLIST_HPP_

#include "../Wisp/wisplist.hpp"
#include "../Wisp/wispmenu.hpp"

struct CWatchList : public CWispList
{
	void ResetContext();
	void UpdateLine(CListStringItem *pItem);
	void UpdateContext();

	CListStringItem *m_pFirstItem;
	CWispMenu m_PopupMenu;
	CWispMenu::MenuItem *m_pMenuItemRemove;

	CWatchList();
	virtual ~CWatchList();

	virtual bool MsgProc(WISP_MSG *pMsg) override;

	bool OnUpdate(WISP_MSG *pMsg);
	bool OnCreate(WISP_MSG *pMsg);
	bool OnDestroy(WISP_MSG *pMsg);
	bool OnKeyEvent(WISP_MSG *pMsg);
	bool OnEventAdd(WISP_MSG *pMsg);
	bool OnEventDel(WISP_MSG *pMsg);
	bool OnEvent(WISP_MSG *pMsg);

	virtual bool Edit(CListStringItem *Item, int nCol, TWideString& String) override;
	virtual bool OnEditing(CListStringItem *Item, int nCol, TWideString& String) override;
	virtual void OnEdit(CListStringItem *Item, int nCol, TWideString& String) override;
};

#endif
```

`source/WispSyser/windowsmsg.cpp`:

```cpp

#include "othercmd.hpp"

WINDOWS_MSG_ENTRY stMsgList[] =
	{
      {0, "CB_OKAY" },
      {0, "LB_OKAY" },
      {0, "WM_NULL" },
      {0x1, "WM_CREATE" },
      {0x2, "WM_DESTROY" },
      {0x3, "WM_MOVE" },
      {0x4, "WM_SIZEWAIT" },
      {0x5, "WM_SIZE" },
      {0x6, "WM_ACTIVATE" },
      {0x7, "WM_SETFOCUS" },
      {0x8, "WM_KILLFOCUS" },
      {0x9, "WM_SETVISIBLE" },
      {0xA, "WM_ENABLE" },
      {0xB, "WM_SETREDRAW" },
      {0xC, "WM_SETTEXT" },
      {0xD, "WM_GETTEXT" },
      {0xE, "WM_GETTEXTLENGTH" },
      {0xF, "WM_PAINT" },
      {0x10, "WM_CLOSE" },
      {0x11, "WM_QUERYENDSESSION" },
      {0x12, "WM_QUIT" },
      {0x13, "WM_QUERYOPEN" },
      {0x14, "WM_ERASEBKGND" },
      {0x15, "WM_SYSCOLORCHANGE" },
      {0x16, "WM_ENDSESSION" },
      {0x17, "WM_SYSTEMERROR" },
      {0x18, "WM_SHOWWINDOW" },
      {0x19, "WM_CTLCOLOR" },
      {0x1A, "WM_SETTINGCHANGE" },
      {0x1A, "WM_WININICHANGE" },
      {0x1B, "WM_DEVMODECHANGE" },
      {0x1C, "WM_ACTIVATEAPP" },
      {0x1D, "WM_FONTCHANGE" },
      {0x1E, "WM_TIMECHANGE" },
      {0x1F, "WM_CANCELMODE" },
      {0x20, "WM_SETCURSOR" },
      {0x21, "WM_MOUSEACTIVATE" },
      {0x22, "WM_CHILDACTIVATE" },
      {0x23, "WM_QUEUESYNC" },
      {0x24, "WM_GETMINMAXINFO" },
      {0x26, "WM_PAINTICON" },
      {0x27, "WM_ICONERASEBKGND" },
      {0x28, "WM_NEXTDLGCTL" },
      {0x29, "WM_ALTTABACTIVE" },
      {0x2A, "WM_SPOOLERSTATUS" },
      {0x2B, "WM_DRAWITEM" },
      {0x2C, "WM_MEASUREITEM" },
      {0x2D, "WM_DELETEITEM" },
      {0x2E, "WM_VKEYTOITEM" },
      {0x2F, "WM_CHARTOITEM" },
      {0x30, "WM_SETFONT" },
      {0x31, "WM_GETFONT" },
      {0x32, "WM_SETHOTKEY" },
      {0x33, "WM_GETHOTKEY" },
      {0x34, "WM_FILESYSCHANGE" },
      {0x35, "WM_ISACTIVEICON" },
      {0x36, "WM_QUERYPARKICON" },
      {0x37, "WM_QUERYDRAGICON" },
      {0x38, "WM_QUERYSAVESTATE" },
      {0x39, "WM_COMPAREITEM" },
      {0x3D, "WM_GETOBJECT" },
      {0x41, "WM_COMPACTING" },
      {0x44, "WM_COMMNOTIFY" },
      {0x46, "WM_WINDOWPOSCHANGING" },
      {0x47, "WM_WINDOWPOSCHANGED" },
      {0x48, "WM_POWER" },
      {0x4A, "WM_COPYDATA" },
      {0x4B, "WM_CANCELJOURNAL" },
      {0x4E, "WM_NOTIFY" },
      {0x50, "WM_INPUTLANGCHANGEREQUEST" },
      {0x51, "WM_INPUTLANGCHANGE" },
      {0x52, "WM_TCARD" },
      {0x53, "WM_HELP" },
      {0x54, "WM_USERCHANGED" },
      {0x55, "WM_NOTIFYFORMAT" },
      {0x7B, "WM_CONTEXTMENU" },
      {0x7C, "WM_STYLECHANGING" },
      {0x7D, "WM_STYLECHANGED" },
      {0x7E, "WM_DISPLAYCHANGE" },
      {0x7F, "WM_GETICON" },
      {0x80, "WM_SETICON" },
      {0x81, "WM_NCCREATE" },
      {0x82, "WM_NCDESTROY" },
      {0x83, "WM_NCCALCSIZE" },
      {0x84, "WM_NCHITTEST" },
      {0x85, "WM_NCPAINT" },
      {0x86, "WM_NCACTIVATE" },
      {0x87, "WM_GETDLGCODE" },
      {0x88, "WM_SYNCPAINT" },
      {0xA0, "WM_NCMOUSEMOVE" },
      {0xA1, "WM_NCLBUTTONDOWN" },
      {0xA2, "WM_NCLBUTTONUP" },
      {0xA3, "WM_NCLBUTTONDBLCLK" },
      {0xA4, "WM_NCRBUTTONDOWN" },
      {0xA5, "WM_NCRBUTTONUP" },
      {0xA6, "WM_NCRBUTTONDBLCLK" },
      {0xA7, "WM_NCMBUTTONDOWN" },
      {0xA8, "WM_NCMBUTTONUP" },
      {0xA9, "WM_NCMBUTTONDBLCLK" },
      {0xB0, "EM_GETSEL" },
      {0xB1, "EM_SETSEL" },
      {0xB2, "EM_GETRECT" },
      {0xB3, "EM_SETRECT" },
      {0xB4, "EM_SETRECTNP" },
      {0xB5, "EM_SCROLL" },
      {0xB6, "EM_LINESCROLL" },
      {0xB7, "EM_SCROLLCARET" },
      {0xB8, "EM_GETMODIFY" },
      {0xB9, "EM_SETMODIFY" },
      {0xBA, "EM_GETLINECOUNT" },
      {0xBB, "EM_LINEINDEX" },
      {0xBC, "EM_SETHANDLE" },
      {0xBD, "EM_GETHANDLE" },
      {0xBE, "EM_GETTHUMB" },
      {0xC1, "EM_LINELENGTH" },
      {0xC2, "EM_REPLACESEL" },
      {0xC4, "EM_GETLINE" },
      {0xC5, "EM_LIMITTEXT" },
      {0xC5, "EM_SETLIMITTEXT" },
      {0xC6, "EM_CANUNDO" },
      {0xC7, "EM_UNDO" },
      {0xC8, "EM_FMTLINES" },
      {0xC9, "EM_LINEFROMCHAR" },
      {0xCB, "EM_SETTABSTOPS" },
      {0xCC, "EM_SETPASSWORDCHAR" },
      {0xCD, "EM_EMPTYUNDOBUFFER" },
      {0xCE, "EM_GETFIRSTVISIBLELINE" },
      {0xCF, "EM_SETREADONLY" },
      {0xD0, "EM_SETWORDBREAKPROC" },
      {0xD1, "EM_GETWORDBREAKPROC" },
      {0xD2, "EM_GETPASSWORDCHAR" },
      {0xD3, "EM_SETMARGINS" },
      {0xD4, "EM_GETMARGINS" },
      {0xD5, "EM_GETLIMITTEXT" },
      {0xD6, "EM_POSFROMCHAR" },
      {0xD7, "EM_CHARFROMPOS" },
      {0xD8, "EM_SETIMESTATUS" },
      {0xD9, "EM_GETIMESTATUS" },
      {0xF0, "BM_GETCHECK" },
      {0xF1, "BM_SETCHECK" },
      {0xF2, "BM_GETSTATE" },
      {0xF3, "BM_SETSTATE" },
      {0xF4, "BM_SETSTYLE" },
      {0xF5, "BM_CLICK" },
      {0xF6, "BM_GETIMAGE" },
      {0xF7, "BM_SETIMAGE" },
      {0x100, "WM_KEYFIRST" },
      {0x100, "WM_KEYDOWN" },
      {0x101, "WM_KEYUP" },
      {0x102, "WM_CHAR" },
      {0x103, "WM_DEADCHAR" },
      {0x104, "WM_SYSKEYDOWN" },
      {0x105, "WM_SYSKEYUP" },
      {0x106, "WM_SYSCHAR" },
      {0x107, "WM_SYSDEADCHAR" },
      {0x108, "WM_KEYLAST" },
      {0x10D, "WM_IME_STARTCOMPOSITION" },
      {0x10E, "WM_IME_ENDCOMPOSITION" },
      {0x10F, "WM_IME_COMPOSITION" },
      {0x10F, "WM_IME_KEYLAST" },
      {0x110, "WM_INITDIALOG" },
      {0x111, "WM_COMMAND" },
      {0x112, "WM_SYSCOMMAND" },
      {0x113, "WM_TIMER" },
      {0x114, "WM_HSCROLL" },
      {0x115, "WM_VSCROLL" },
      {0x116, "WM_INITMENU" },
      {0x117, "WM_INITMENUPOPUP" },
      {0x11F, "WM_MENUSELECT" },
      {0x120, "WM_MENUCHAR" },
      {0x121, "WM_ENTERIDLE" },
      {0x122, "WM_MENURBUTTONUP" },
      {0x123, "WM_MENUDRAG" },
      {0x124, "WM_MENUGETOBJECT" },
      {0x125, "WM_UNINITMENUPOPUP" },
      {0x126, "WM_MENUCOMMAND" },
      {0x127, "WM_KEYBOARDCUES" },
      {0x132, "WM_CTLCOLORMSGBOX" },
      {0x133, "WM_CTLCOLOREDIT" },
      {0x134, "WM_CTLCOLORLISTBOX" },
      {0x135, "WM_CTLCOLORBTN" },
      {0x136, "WM_CTLCOLORDLG" },
      {0x137, "WM_CTLCOLORSCROLLBAR" },
      {0x138, "WM_CTLCOLORSTATIC" },
      {0x140, "CB_GETEDITSEL" },
      {0x141, "CB_LIMITTEXT" },
      {0x142, "CB_SETEDITSEL" },
      {0x143, "CB_ADDSTRING" },
      {0x144, "CB_DELETESTRING" },
      {0x145, "CB_DIR" },
      {0x146, "CB_GETCOUNT" },
      {0x147, "CB_GETCURSEL" },
      {0x148, "CB_GETLBTEXT" },
      {0x149, "CB_GETLBTEXTLEN" },
      {0x14A, "CB_INSERTSTRING" },
      {0x14B, "CB_RESETCONTENT" },
      {0x14C, "CB_FINDSTRING" },
      {0x14D, "CB_SELECTSTRING" },
      {0x14E, "CB_SETCURSEL" },
      {0x14F, "CB_SHOWDROPDOWN" },
      {0x150, "CB_GETITEMDATA" },
      {0x151, "CB_SETITEMDATA" },
      {0x152, "CB_GETDROPPEDCONTROLRECT" },
      {0x153, "CB_SETITEMHEIGHT" },
      {0x154, "CB_GETITEMHEIGHT" },
      {0x155, "CB_SETEXTENDEDUI" },
      {0x156, "CB_GETEXTENDEDUI" },
      {0x157, "CB_GETDROPPEDSTATE" },
      {0x158, "CB_FINDSTRINGEXACT" },
      {0x159, "CB_SETLOCALE" },
      {0x15A, "CB_GETLOCALE" },
      {0x15B, "CB_MSGMAX" },
      {0x15B, "CB_GETTOPINDEX" },
      {0x15C, "CB_SETTOPINDEX" },
      {0x15D, "CB_GETHORIZONTALEXTENT" },
      {0x15E, "CB_SETHORIZONTALEXTENT" },
      {0x15F, "CB_GETDROPPEDWIDTH" },
      {0x160, "CB_SETDROPPEDWIDTH" },
      {0x161, "CB_INITSTORAGE" },
      {0x162, "CB_MSGMAX" },
      {0x163, "CB_MSGMAX" },
      {0x163, "CB_MULTIPLEADDSTRING" },
      {0x180, "LB_ADDSTRING" },
      {0x181, "LB_INSERTSTRING" },
      {0x182, "LB_DELETESTRING" },
      {0x183, "LB_SELITEMRANGEEX" },
      {0x184, "LB_RESETCONTENT" },
      {0x185, "LB_SETSEL" },
      {0x186, "LB_SETCURSEL" },
      {0x187, "LB_GETSEL" },
      {0x188, "LB_GETCURSEL" },
      {0x189, "LB_GETTEXT" },
      {0x18A, "LB_GETTEXTLEN" },
      {0x18B, "LB_GETCOUNT" },
      {0x18C, "LB_SELECTSTRING" },
      {0x18D, "LB_DIR" },
      {0x18E, "LB_GETTOPINDEX" },
      {0x18F, "LB_FINDSTRING" },
      {0x190, "LB_GETSELCOUNT" },
      {0x191, "LB_GETSELITEMS" },
      {0x192, "LB_SETTABSTOPS" },
      {0x193, "LB_GETHORIZONTALEXTENT" },
      {0x194, "LB_SETHORIZONTALEXTENT" },
      {0x195, "LB_SETCOLUMNWIDTH" },
      {0x196, "LB_ADDFILE" },
      {0x197, "LB_SETTOPINDEX" },
      {0x198, "LB_GETITEMRECT" },
      {0x199, "LB_GETITEMDATA" },
      {0x19A, "LB_SETITEMDATA" },
      {0x19B, "LB_SELITEMRANGE" },
      {0x19C, "LB_SETANCHORINDEX" },
      {0x19D, "LB_GETANCHORINDEX" },
      {0x19E, "LB_SETCARETINDEX" },
      {0x19F, "LB_GETCARETINDEX" },
      {0x1A0, "LB_SETITEMHEIGHT" },
      {0x1A1, "LB_GETITEMHEIGHT" },
      {0x1A2, "LB_FINDSTRINGEXACT" },
      {0x1A5, "LB_SETLOCALE" },
      {0x1A6, "LB_GETLOCALE" },
      {0x1A7, "LB_SETCOUNT" },
      {0x1A8, "LB_INITSTORAGE" },
      {0x1A8, "LB_MSGMAX" },
      {0x1A9, "LB_ITEMFROMPOINT" },
      {0x1B0, "LB_MSGMAX" },
      {0x1B1, "LB_MULTIPLEADDSTRING" },
      {0x1B1, "LB_MSGMAX" },
      {0x200, "WM_MOUSEMOVE" },
      {0x200, "WM_MOUSEFIRST" },
      {0x201, "WM_LBUTTONDOWN" },
      {0x202, "WM_LBUTTONUP" },
      {0x203, "WM_LBUTTONDBLCLK" },
      {0x204, "WM_RBUTTONDOWN" },
      {0x205, "WM_RBUTTONUP" },
      {0x206, "WM_RBUTTONDBLCLK" },
      {0x207, "WM_MBUTTONDOWN" },
      {0x208, "WM_MBUTTONUP" },
      {0x209, "WM_MOUSELAST" },
      {0x209, "WM_MBUTTONDBLCLK" },
      {0x20A, "WM_MOUSEWHEEL" },
      {0x20A, "WM_MOUSELAST" },
      {0x210, "WM_PARENTNOTIFY" },
      {0x211, "WM_ENTERMENULOOP" },
      {0x212, "WM_EXITMENULOOP" },
      {0x213, "WM_NEXTMENU" },
      {0x214, "WM_SIZING" },
      {0x215, "WM_CAPTURECHANGED" },
      {0x216, "WM_MOVING" },
      {0x218, "WM_POWERBROADCAST" },
      {0x219, "WM_DEVICECHANGE" },
      {0x220, "WM_MDICREATE" },
      {0x221, "WM_MDIDESTROY" },
      {0x222, "WM_MDIACTIVATE" },
      {0x223, "WM_MDIRESTORE" },
      {0x224, "WM_MDINEXT" },
      {0x225, "WM_MDIMAXIMIZE" },
      {0x226, "WM_MDITILE" },
      {0x227, "WM_MDICASCADE" },
      {0x228, "WM_MDIICONARRANGE" },
      {0x229, "WM_MDIGETACTIVE" },
      {0x22A, "WM_DROPOBJECT" },
      {0x22B, "WM_QUERYDROPOBJECT" },
      {0x22C, "WM_BEGINDRAG" },
      {0x22D, "WM_DRAGLOOP" },
      {0x22E, "WM_DRAGSELECT" },
      {0x22F, "WM_DRAGMOVE" },
      {0x230, "WM_MDISETMENU" },
      {0x231, "WM_ENTERSIZEMOVE" },
      {0x232, "WM_EXITSIZEMOVE" },
      {0x233, "WM_DROPFILES" },
      {0x234, "WM_MDIREFRESHMENU" },
      {0x281, "WM_IME_SETCONTEXT" },
      {0x282, "WM_IME_NOTIFY" },
      {0x283, "WM_IME_CONTROL" },
      {0x284, "WM_IME_COMPOSITIONFULL" },
      {0x285, "WM_IME_SELECT" },
      {0x286, "WM_IME_CHAR" },
      {0x288, "WM_IME_REQUEST" },
      {0x290, "WM_IME_KEYDOWN" },
      {0x291, "WM_IME_KEYUP" },
      {0x2A0, "WM_NCMOUSEHOVER" },
      {0x2A1, "WM_MOUSEHOVER" },
      {0x2A2, "WM_NCMOUSELEAVE" },
      {0x2A3, "WM_MOUSELEAVE" },
      {0x300, "WM_CUT" },
      {0x301, "WM_COPY" },
      {0x302, "WM_PASTE" },
      {0x303, "WM_CLEAR" },
      {0x304, "WM_UNDO" },
      {0x305, "WM_RENDERFORMAT" },
      {0x306, "WM_RENDERALLFORMATS" },
      {0x307, "WM_DESTROYCLIPBOARD" },
      {0x308, "WM_DRAWCLIPBOARD" },
      {0x309, "WM_PAINTCLIPBOARD" },
      {0x30A, "WM_VSCROLLCLIPBOARD" },
      {0x30B, "WM_SIZECLIPBOARD" },
      {0x30C, "WM_ASKCBFORMATNAME" },
      {0x30D, "WM_CHANGECBCHAIN" },
      {0x30E, "WM_HSCROLLCLIPBOARD" },
      {0x30F, "WM_QUERYNEWPALETTE" },
      {0x310, "WM_PALETTEISCHANGING" },
      {0x311, "WM_PALETTECHANGED" },
      {0x312, "WM_HOTKEY" },
      {0x317, "WM_PRINT" },
      {0x318, "WM_PRINTCLIENT" },
      {0x358, "WM_HANDHELDFIRST" },
      {0x35F, "WM_HANDHELDLAST" },
      {0x360, "WM_AFXFIRST" },
      {0x360, "WM_QUERYAFXWNDPROC" },
      {0x361, "WM_SIZEPARENT" },
      {0x362, "WM_SETMESSAGESTRING" },
      {0x363, "WM_IDLEUPDATECMDUI" },
      {0x364, "WM_INITIALUPDATE" },
      {0x365, "WM_COMMANDHELP" },
      {0x366, "WM_HELPHITTEST" },
      {0x367, "WM_EXITHELPMODE" },
      {0x368, "WM_RECALCPARENT" },
      {0x369, "WM_SIZECHILD" },
      {0x36A, "WM_KICKIDLE" },
      {0x36B, "WM_QUERYCENTERWND" },
      {0x36C, "WM_DISABLEMODAL" },
      {0x36D, "WM_FLOATSTATUS" },
      {0x36E, "WM_ACTIVATETOPLEVEL" },
      {0x36F, "WM_QUERY3DCONTROLS" },
      {0x37F, "WM_AFXLAST" },
      {0x380, "WM_PENWINFIRST" },
      {0x38F, "WM_PENWINLAST" },
      {0x3E0, "WM_DDE_FIRST" },
      {0x3E0, "WM_DDE_INITIATE" },
      {0x3E1, "WM_DDE_TERMINATE" },
      {0x3E2, "WM_DDE_ADVISE" },
      {0x3E3, "WM_DDE_UNADVISE" },
      {0x3E4, "WM_DDE_ACK" },
      {0x3E5, "WM_DDE_DATA" },
      {0x3E6, "WM_DDE_REQUEST" },
      {0x3E7, "WM_DDE_POKE" },
      {0x3E8, "WM_DDE_LAST" },
      {0x3E8, "WM_DDE_EXECUTE" },
      {0x400, "WM_USER" },
      {0x400, "TBM_GETPOS" },
      {0x401, "CBEM_INSERTITEMA" },
      {0x401, "SB_SETTEXTA" },
      {0x401, "TBM_GETRANGEMIN" },
      {0x401, "RB_INSERTBANDA" },
      {0x401, "PBM_SETRANGE" },
      {0x401, "HKM_SETHOTKEY" },
      {0x401, "TTM_ACTIVATE" },
      {0x402, "HKM_GETHOTKEY" },
      {0x402, "CBEM_SETIMAGELIST" },
      {0x402, "SB_GETTEXTA" },
      {0x402, "RB_DELETEBAND" },
      {0x402, "PBM_SETPOS" },
      {0x402, "TBM_GETRANGEMAX" },
      {0x403, "PBM_DELTAPOS" },
      {0x403, "TTM_SETDELAYTIME" },
      {0x403, "SB_GETTEXTLENGTHA" },
      {0x403, "TBM_GETTIC" },
      {0x403, "RB_GETBARINFO" },
      {0x403, "HKM_SETRULES" },
      {0x403, "CBEM_GETIMAGELIST" },
      {0x404, "PBM_SETSTEP" },
      {0x404, "TTM_ADDTOOLA" },
      {0x404, "CBEM_GETITEMA" },
      {0x404, "RB_SETBARINFO" },
      {0x404, "TBM_SETTIC" },
      {0x404, "SB_SETPARTS" },
      {0x405, "RB_GETBANDINFO" },
      {0x405, "CBEM_SETITEMA" },
      {0x405, "PBM_STEPIT" },
      {0x405, "TBM_SETPOS" },
      {0x405, "TTM_DELTOOLA" },
      {0x406, "TBM_SETRANGE" },
      {0x406, "CBEM_GETCOMBOCONTROL" },
      {0x406, "SB_GETPARTS" },
      {0x406, "RB_SETBANDINFOA" },
      {0x406, "TTM_NEWTOOLRECTA" },
      {0x406, "PBM_SETRANGE32" },
      {0x407, "SB_GETBORDERS" },
      {0x407, "RB_SETPARENT" },
      {0x407, "PBM_GETRANGE" },
      {0x407, "TTM_RELAYEVENT" },
      {0x407, "TBM_SETRANGEMIN" },
      {0x407, "CBEM_GETEDITCONTROL" },
      {0x408, "RB_HITTEST" },
      {0x408, "CBEM_SETEXSTYLE" },
      {0x408, "SB_SETMINHEIGHT" },
      {0x408, "PBM_GETPOS" },
      {0x408, "CBEM_SETEXSTYLE" },
      {0x408, "TBM_SETRANGEMAX" },
      {0x408, "TTM_GETTOOLINFOA" },
      {0x409, "CBEM_GETEXSTYLE" },
      {0x409, "CBEM_GETEXTENDEDSTYLE" },
      {0x409, "CBEM_GETEXSTYLE" },
      {0x409, "SB_SIMPLE" },
      {0x409, "RB_GETRECT" },
      {0x409, "PBM_SETBARCOLOR" },
      {0x409, "TBM_CLEARTICS" },
      {0x409, "TTM_SETTOOLINFOA" },
      {0x40A, "TBM_SETSEL" },
      {0x40A, "CBEM_HASEDITCHANGED" },
      {0x40A, "TTM_HITTESTA" },
      {0x40A, "RB_INSERTBANDW" },
      {0x40A, "SB_GETRECT" },
      {0x40B, "TTM_GETTEXTA" },
      {0x40B, "SB_SETTEXTW" },
      {0x40B, "RB_SETBANDINFOW" },
      {0x40B, "TBM_SETSELSTART" },
      {0x40B, "CBEM_INSERTITEMW" },
      {0x40C, "RB_GETBANDCOUNT" },
      {0x40C, "CBEM_SETITEMW" },
      {0x40C, "TBM_SETSELEND" },
      {0x40C, "SB_GETTEXTW" },
      {0x40C, "TTM_UPDATETIPTEXTA" },
      {0x40D, "SB_GETTEXTLENGTHW" },
      {0x40D, "CBEM_GETITEMW" },
      {0x40D, "RB_GETROWCOUNT" },
      {0x40D, "TTM_GETTOOLCOUNT" },
      {0x40E, "CBEM_SETEXTENDEDSTYLE" },
      {0x40E, "TTM_ENUMTOOLSA" },
      {0x40E, "SB_ISSIMPLE" },
      {0x40E, "TBM_GETPTICS" },
      {0x40E, "RB_GETROWHEIGHT" },
      {0x40F, "SB_SETICON" },
      {0x40F, "TBM_GETTICPOS" },
      {0x40F, "TTM_GETCURRENTTOOLA" },
      {0x410, "TTM_WINDOWFROMPOINT" },
      {0x410, "TBM_GETNUMTICS" },
      {0x410, "SB_SETTIPTEXTA" },
      {0x410, "RB_IDTOINDEX" },
      {0x411, "RB_GETTOOLTIPS" },
      {0x411, "TTM_TRACKACTIVATE" },
      {0x411, "SB_SETTIPTEXTW" },
      {0x411, "TBM_GETSELSTART" },
      {0x412, "RB_SETTOOLTIPS" },
      {0x412, "TTM_TRACKPOSITION" },
      {0x412, "TBM_GETSELEND" },
      {0x412, "SB_GETTIPTEXTA" },
      {0x413, "RB_SETBKCOLOR" },
      {0x413, "TTM_SETTIPBKCOLOR" },
      {0x413, "TBM_CLEARSEL" },
      {0x413, "SB_GETTIPTEXTW" },
      {0x414, "SB_GETICON" },
      {0x414, "TTM_SETTIPTEXTCOLOR" },
      {0x414, "TBM_SETTICFREQ" },
      {0x414, "RB_GETBKCOLOR" },
      {0x415, "RB_SETTEXTCOLOR" },
      {0x415, "TTM_GETDELAYTIME" },
      {0x415, "TBM_SETPAGESIZE" },
      {0x416, "RB_GETTEXTCOLOR" },
      {0x416, "TTM_GETTIPBKCOLOR" },
      {0x416, "TBM_GETPAGESIZE" },
      {0x417, "TTM_GETTIPTEXTCOLOR" },
      {0x417, "TBM_SETLINESIZE" },
      {0x417, "RB_SIZETORECT" },
      {0x418, "TBM_GETLINESIZE" },
      {0x418, "RB_BEGINDRAG" },
      {0x418, "TTM_SETMAXTIPWIDTH" },
      {0x419, "RB_ENDDRAG" },
      {0x419, "TBM_GETTHUMBRECT" },
      {0x419, "TTM_GETMAXTIPWIDTH" },
      {0x41A, "RB_DRAGMOVE" },
      {0x41A, "TBM_GETCHANNELRECT" },
      {0x41A, "TTM_SETMARGIN" },
      {0x41B, "TBM_SETTHUMBLENGTH" },
      {0x41B, "TTM_GETMARGIN" },
      {0x41B, "RB_GETBARHEIGHT" },
      {0x41C, "TBM_GETTHUMBLENGTH" },
      {0x41C, "TTM_POP" },
      {0x41C, "RB_GETBANDINFOW" },
      {0x41D, "RB_GETBANDINFOA" },
      {0x41D, "TBM_SETTOOLTIPS" },
      {0x41D, "TTM_UPDATE" },
      {0x41E, "TBM_GETTOOLTIPS" },
      {0x41E, "RB_MINIMIZEBAND" },
      {0x41F, "TBM_SETTIPSIDE" },
      {0x41F, "RB_MAXIMIZEBAND" },
      {0x420, "TBM_SETBUDDY" },
      {0x421, "TBM_GETBUDDY" },
      {0x422, "RB_GETBANDBORDERS" },
      {0x423, "RB_SHOWBAND" },
      {0x425, "RB_SETPALETTE" },
      {0x426, "RB_GETPALETTE" },
      {0x427, "RB_MOVEBAND" },
      {0x428, "RB_SETBANDFOCUS" },
      {0x429, "RB_GETBANDFOCUS" },
      {0x42A, "RB_CYCLEFOCUS" },
      {0x42B, "RB_SETEXTENDEDSTYLE" },
      {0x432, "TTM_ADDTOOLW" },
      {0x433, "TTM_DELTOOLW" },
      {0x434, "TTM_NEWTOOLRECTW" },
      {0x435, "TTM_GETTOOLINFOW" },
      {0x436, "TTM_SETTOOLINFOW" },
      {0x437, "TTM_HITTESTW" },
      {0x438, "TTM_GETTEXTW" },
      {0x439, "TTM_UPDATETIPTEXTW" },
      {0x43A, "TTM_ENUMTOOLSW" },
      {0x43B, "TTM_GETCURRENTTOOLW" },
      {0x464, "IPM_CLEARADDRESS" },
      {0x464, "ACM_OPENA" },
      {0x465, "UDM_SETRANGE" },
      {0x465, "ACM_PLAY" },
      {0x465, "IPM_SETADDRESS" },
      {0x466, "IPM_GETADDRESS" },
      {0x466, "ACM_STOP" },
      {0x466, "UDM_GETRANGE" },
      {0x467, "ACM_OPENW" },
      {0x467, "IPM_SETRANGE" },
      {0x467, "UDM_SETPOS" },
      {0x468, "IPM_SETFOCUS" },
      {0x468, "UDM_GETPOS" },
      {0x469, "IPM_ISBLANK" },
      {0x469, "UDM_SETBUDDY" },
      {0x46A, "UDM_GETBUDDY" },
      {0x46B, "UDM_SETACCEL" },
      {0x46C, "UDM_GETACCEL" },
      {0x46D, "UDM_SETBASE" },
      {0x46E, "UDM_GETBASE" },
      {0x46F, "UDM_SETRANGE32" },
      {0x470, "UDM_GETRANGE32" },
      {0x485, "DL_BEGINDRAG" },
      {0x486, "DL_DRAGGING" },
      {0x487, "DL_DROPPED" },
      {0x488, "DL_CANCELDRAG" },
      {0x1000, "LVM_GETBKCOLOR" },
      {0x1000, "MCM_FIRST" },
      {0x1000, "LVM_FIRST" },
      {0x1000, "DTM_FIRST" },
      {0x1001, "LVM_SETBKCOLOR" },
      {0x1001, "MCM_GETCURSEL" },
      {0x1001, "DTM_GETSYSTEMTIME" },
      {0x1002, "LVM_GETIMAGELIST" },
      {0x1002, "MCM_SETCURSEL" },
      {0x1002, "DTM_SETSYSTEMTIME" },
      {0x1003, "MCM_GETMAXSELCOUNT" },
      {0x1003, "LVM_SETIMAGELIST" },
      {0x1003, "DTM_GETRANGE" },
      {0x1004, "DTM_SETRANGE" },
      {0x1004, "LVM_GETITEMCOUNT" },
      {0x1004, "MCM_SETMAXSELCOUNT" },
      {0x1005, "LVM_GETITEMA" },
      {0x1005, "DTM_SETFORMATA" },
      {0x1005, "MCM_GETSELRANGE" },
      {0x1006, "MCM_SETSELRANGE" },
      {0x1006, "DTM_SETMCCOLOR" },
      {0x1006, "LVM_SETITEMA" },
      {0x1007, "DTM_GETMCCOLOR" },
      {0x1007, "LVM_INSERTITEMA" },
      {0x1007, "MCM_GETMONTHRANGE" },
      {0x1008, "LVM_DELETEITEM" },
      {0x1008, "DTM_GETMONTHCAL" },
      {0x1008, "MCM_SETDAYSTATE" },
      {0x1009, "LVM_DELETEALLITEMS" },
      {0x1009, "DTM_SETMCFONT" },
      {0x1009, "MCM_GETMINREQRECT" },
      {0x100A, "LVM_GETCALLBACKMASK" },
      {0x100A, "MCM_SETCOLOR" },
      {0x100A, "DTM_GETMCFONT" },
      {0x100B, "LVM_SETCALLBACKMASK" },
      {0x100B, "MCM_GETCOLOR" },
      {0x100C, "LVM_GETNEXTITEM" },
      {0x100C, "MCM_SETTODAY" },
      {0x100D, "MCM_GETTODAY" },
      {0x100E, "MCM_HITTEST" },
      {0x100F, "LVM_SETITEMPOSITION" },
      {0x100F, "MCM_SETFIRSTDAYOFWEEK" },
      {0x1010, "LVM_GETITEMPOSITION" },
      {0x1010, "MCM_GETFIRSTDAYOFWEEK" },
      {0x1011, "LVM_GETSTRINGWIDTHA" },
      {0x1011, "MCM_GETRANGE" },
      {0x1012, "LVM_HITTEST" },
      {0x1012, "MCM_SETRANGE" },
      {0x1013, "LVM_ENSUREVISIBLE" },
      {0x1013, "MCM_GETMONTHDELTA" },
      {0x1014, "LVM_SCROLL" },
      {0x1014, "MCM_SETMONTHDELTA" },
      {0x1015, "MCM_GETMAXTODAYWIDTH" },
      {0x1015, "LVM_REDRAWITEMS" },
      {0x1016, "LVM_ARRANGE" },
      {0x1017, "LVM_EDITLABELA" },
      {0x1018, "LVM_GETEDITCONTROL" },
      {0x1019, "LVM_GETCOLUMNA" },
      {0x101A, "LVM_SETCOLUMNA" },
      {0x101B, "LVM_INSERTCOLUMNA" },
      {0x101C, "LVM_DELETECOLUMN" },
      {0x101D, "LVM_GETCOLUMNWIDTH" },
      {0x101D, "LVM_SETCOLUMNWIDTH" },
      {0x101E, "LVM_GETHEADER" },
      {0x1021, "LVM_CREATEDRAGIMAGE" },
      {0x1022, "LVM_GETVIEWRECT" },
      {0x1023, "LVM_GETTEXTCOLOR" },
      {0x1024, "LVM_SETTEXTCOLOR" },
      {0x1025, "LVM_GETTEXTBKCOLOR" },
      {0x1026, "LVM_SETTEXTBKCOLOR" },
      {0x1027, "LVM_GETTOPINDEX" },
      {0x1028, "LVM_GETCOUNTPERPAGE" },
      {0x1029, "LVM_GETORIGIN" },
      {0x102A, "LVM_UPDATE" },
      {0x102B, "LVM_SETITEMSTATE" },
      {0x102C, "LVM_GETITEMSTATE" },
      {0x102D, "LVM_GETITEMTEXTA" },
      {0x102E, "LVM_SETITEMTEXTA" },
      {0x102F, "LVM_SETITEMCOUNT" },
      {0x1030, "LVM_SORTITEMS" },
      {0x1031, "LVM_SETITEMPOSITION32" },
      {0x1032, "LVM_GETSELECTEDCOUNT" },
      {0x1032, "DTM_SETFORMATW" },
      {0x1033, "LVM_GETITEMSPACING" },
      {0x1034, "LVM_GETISEARCHSTRINGA" },
      {0x1035, "LVM_SETICONSPACING" },
      {0x1036, "LVM_SETEXTENDEDLISTVIEWSTYLE" },
      {0x1037, "LVM_GETEXTENDEDLISTVIEWSTYLE" },
      {0x1038, "LVM_GETSUBITEMRECT" },
      {0x1039, "LVM_SUBITEMHITTEST" },
      {0x103A, "LVM_SETCOLUMNORDERARRAY" },
      {0x103B, "LVM_GETCOLUMNORDERARRAY" },
      {0x103C, "LVM_SETHOTITEM" },
      {0x103D, "LVM_GETHOTITEM" },
      {0x103E, "LVM_SETHOTCURSOR" },
      {0x103F, "LVM_GETHOTCURSOR" },
      {0x1040, "LVM_APPROXIMATEVIEWRECT" },
      {0x1041, "LVM_SETWORKAREAS" },
      {0x1042, "LVM_GETSELECTIONMARK" },
      {0x1043, "LVM_SETSELECTIONMARK" },
      {0x1044, "LVM_SETBKIMAGEA" },
      {0x1045, "LVM_GETBKIMAGEA" },
      {0x1046, "LVM_GETWORKAREAS" },
      {0x1047, "LVM_SETHOVERTIME" },
      {0x1048, "LVM_GETHOVERTIME" },
      {0x1049, "LVM_GETNUMBEROFWORKAREAS" },
      {0x104A, "LVM_SETTOOLTIPS" },
      {0x104B, "LVM_GETITEMW" },
      {0x104C, "LVM_SETITEMW" },
      {0x104D, "LVM_INSERTITEMW" },
      {0x104E, "LVM_GETTOOLTIPS" },
      {0x1051, "LVM_SORTITEMSEX" },
      {0x1057, "LVM_GETSTRINGWIDTHW" },
      {0x105F, "LVM_GETCOLUMNW" },
      {0x1060, "LVM_SETCOLUMNW" },
      {0x1061, "LVM_INSERTCOLUMNW" },
      {0x1073, "LVM_GETITEMTEXTW" },
      {0x1074, "LVM_SETITEMTEXTW" },
      {0x1075, "LVM_GETISEARCHSTRINGW" },
      {0x1076, "LVM_EDITLABELW" },
      {0x108A, "LVM_SETBKIMAGEW" },
      {0x108B, "LVM_GETBKIMAGEW" },
      {0x1100, "TVM_INSERTITEMA" },
      {0x1100, "TV_FIRST" },
      {0x1101, "TVM_DELETEITEM" },
      {0x1102, "TVM_EXPAND" },
      {0x1104, "TVM_GETITEMRECT" },
      {0x1105, "TVM_GETCOUNT" },
      {0x1106, "TVM_GETINDENT" },
      {0x1107, "TVM_SETINDENT" },
      {0x1108, "TVM_GETIMAGELIST" },
      {0x1109, "TVM_SETIMAGELIST" },
      {0x110A, "TVM_GETNEXTITEM" },
      {0x110B, "TVM_SELECTITEM" },
      {0x110C, "TVM_GETITEMA" },
      {0x110D, "TVM_SETITEMA" },
      {0x110E, "TVM_EDITLABELA" },
      {0x110F, "TVM_GETEDITCONTROL" },
      {0x1110, "TVM_GETVISIBLECOUNT" },
      {0x1111, "TVM_HITTEST" },
      {0x1112, "TVM_CREATEDRAGIMAGE" },
      {0x1113, "TVM_SORTCHILDREN" },
      {0x1114, "TVM_ENSUREVISIBLE" },
      {0x1115, "TVM_SORTCHILDRENCB" },
      {0x1116, "TVM_ENDEDITLABELNOW" },
      {0x1117, "TVM_GETISEARCHSTRINGA" },
      {0x1118, "TVM_SETTOOLTIPS" },
      {0x1119, "TVM_GETTOOLTIPS" },
      {0x111A, "TVM_SETINSERTMARK" },
      {0x111B, "TVM_SETITEMHEIGHT" },
      {0x111C, "TVM_GETITEMHEIGHT" },
      {0x111D, "TVM_SETBKCOLOR" },
      {0x111E, "TVM_SETTEXTCOLOR" },
      {0x111F, "TVM_GETBKCOLOR" },
      {0x1120, "TVM_GETTEXTCOLOR" },
      {0x1121, "TVM_SETSCROLLTIME" },
      {0x1122, "TVM_GETSCROLLTIME" },
      {0x1125, "TVM_SETINSERTMARKCOLOR" },
      {0x1126, "TVM_GETINSERTMARKCOLOR" },
      {0x1127, "TVM_GETITEMSTATE" },
      {0x113E, "TVM_GETITEMW" },
      {0x113F, "TVM_SETITEMW" },
      {0x1140, "TVM_GETISEARCHSTRINGW" },
      {0x1141, "TVM_EDITLABELW" },
      {0x1146, "TVM_INSERTITEMW" },
      {0x1200, "HDM_FIRST" },
      {0x1200, "HDM_GETITEMCOUNT" },
      {0x1201, "HDM_INSERTITEMA" },
      {0x1202, "HDM_DELETEITEM" },
      {0x1203, "HDM_GETITEMA" },
      {0x1204, "HDM_SETITEMA" },
      {0x1205, "HDM_LAYOUT" },
      {0x1206, "HDM_HITTEST" },
      {0x1207, "HDM_GETITEMRECT" },
      {0x1208, "HDM_SETIMAGELIST" },
      {0x1209, "HDM_GETIMAGELIST" },
      {0x120A, "HDM_INSERTITEMW" },
      {0x120B, "HDM_GETITEMW" },
      {0x120C, "HDM_SETITEMW" },
      {0x120F, "HDM_ORDERTOINDEX" },
      {0x1210, "HDM_CREATEDRAGIMAGE" },
      {0x1211, "HDM_GETORDERARRAY" },
      {0x1212, "HDM_SETORDERARRAY" },
      {0x1213, "HDM_SETHOTDIVIDER" },
      {0x1216, "HDM_SETFILTERCHANGETIMEOUT" },
      {0x1217, "HDM_EDITFILTER" },
      {0x1218, "HDM_CLEARFILTER" },
      {0x1300, "TCM_FIRST" },
      {0x1302, "TCM_GETIMAGELIST" },
      {0x1303, "TCM_SETIMAGELIST" },
      {0x1304, "TCM_GETITEMCOUNT" },
      {0x1305, "TCM_GETITEMA" },
      {0x1306, "TCM_SETITEMA" },
      {0x1307, "TCM_INSERTITEMA" },
      {0x1308, "TCM_DELETEITEM" },
      {0x1309, "TCM_DELETEALLITEMS" },
      {0x130A, "TCM_GETITEMRECT" },
      {0x130B, "TCM_GETCURSEL" },
      {0x130C, "TCM_SETCURSEL" },
      {0x130D, "TCM_HITTEST" },
      {0x130E, "TCM_SETITEMEXTRA" },
      {0x1328, "TCM_ADJUSTRECT" },
      {0x1329, "TCM_SETITEMSIZE" },
      {0x132A, "TCM_REMOVEIMAGE" },
      {0x132B, "TCM_SETPADDING" },
      {0x132C, "TCM_GETROWCOUNT" },
      {0x132D, "TCM_GETTOOLTIPS" },
      {0x132E, "TCM_SETTOOLTIPS" },
      {0x132F, "TCM_GETCURFOCUS" },
      {0x1330, "TCM_SETCURFOCUS" },
      {0x1331, "TCM_SETMINTABWIDTH" },
      {0x1332, "TCM_DESELECTALL" },
      {0x1333, "TCM_HIGHLIGHTITEM" },
      {0x1334, "TCM_SETEXTENDEDSTYLE" },
      {0x1335, "TCM_GETEXTENDEDSTYLE" },
      {0x133C, "TCM_GETITEMW" },
      {0x133D, "TCM_SETITEMW" },
      {0x133E, "TCM_INSERTITEMW" },
      {0x1400, "PGM_FIRST" },
      {0x1401, "PGM_SETCHILD" },
      {0x1402, "PGM_RECALCSIZE" },
      {0x1403, "PGM_FORWARDMOUSE" },
      {0x1404, "PGM_SETBKCOLOR" },
      {0x1405, "PGM_GETBKCOLOR" },
      {0x1406, "PGM_SETBORDER" },
      {0x1407, "PGM_GETBORDER" },
      {0x1408, "PGM_SETPOS" },
      {0x1409, "PGM_GETPOS" },
      {0x140A, "PGM_SETBUTTONSIZE" },
      {0x140B, "PGM_GETBUTTONSIZE" },
      {0x140C, "PGM_GETBUTTONSTATE" },
      {0x2000, "CCM_FIRST" },
      {0x2001, "PBM_SETBKCOLOR" },
      {0x2001, "CCM_SETBKCOLOR" },
      {0x2002, "CCM_SETCOLORSCHEME" },
      {0x2003, "CCM_GETCOLORSCHEME" },
      {0x2004, "PGM_GETDROPTARGET" },
      {0x2004, "CCM_GETDROPTARGET" },
      {0x2005, "MCM_SETUNICODEFORMAT" },
      {0x2005, "RB_SETUNICODEFORMAT" },
      {0x2005, "LVM_SETUNICODEFORMAT" },
      {0x2005, "CCM_SETUNICODEFORMAT" },
      {0x2005, "UDM_SETUNICODEFORMAT" },
      {0x2005, "HDM_SETUNICODEFORMAT" },
      {0x2005, "TBM_SETUNICODEFORMAT" },
      {0x2006, "CCM_GETUNICODEFORMAT" },
      {0x2006, "RB_GETUNICODEFORMAT" },
      {0x2006, "HDM_GETUNICODEFORMAT" },
      {0x2006, "TBM_GETUNICODEFORMAT" },
      {0x2006, "UDM_GETUNICODEFORMAT" },
      {0x2006, "MCM_GETUNICODEFORMAT" },
      {0x2006, "LVM_GETUNICODEFORMAT" },
      {0x2007, "CCM_SETVERSION" },
      {0x2008, "CCM_GETVERSION" },
      {0x2009, "CCM_SETNOTIFYWINDOW" },
      {0x2200, "CCM_LAST" },
      {0x8000, "WM_APP" },
      {0x12014, "HDM_SETBITMAPMARGIN" },
      {0x12015, "HDM_GETBITMAPMARGIN" },
      {0xFFFFFFFE, "CB_ERRSPACE" },
      {0xFFFFFFFE, "LB_ERRSPACE" },
      {0xFFFFFFFF, "CB_ERR" },
      {0xFFFFFFFF, "LB_ERR" },
	{0, NULL},
	};

```

`source/WispSyser/winerror.cpp`:

```cpp

#include "othercmd.hpp"

WINERROR_ENTRY stWinErrorList[] =
	{
      {0, "The operation completed successfully.", "ERROR_SUCCESS" },
      {0x1, "Incorrect function.", "ERROR_INVALID_FUNCTION" },
      {0x2, "The system cannot find the file specified.", "ERROR_FILE_NOT_FOUND" },
      {0x3, "The system cannot find the path specified.", "ERROR_PATH_NOT_FOUND" },
      {0x4, "The system cannot open the file.", "ERROR_TOO_MANY_OPEN_FILES" },
      {0x5, "Access is denied.", "ERROR_ACCESS_DENIED" },
      {0x6, "The handle is invalid.", "ERROR_INVALID_HANDLE" },
      {0x7, "The storage control blocks were destroyed.", "ERROR_ARENA_TRASHED" },
      {0x8, "Not enough storage is available to process this command.", "ERROR_NOT_ENOUGH_MEMORY" },
      {0x9, "The storage control block address is invalid.", "ERROR_INVALID_BLOCK" },
      {0xA, "The environment is incorrect.", "ERROR_BAD_ENVIRONMENT" },
      {0xB, "An attempt was made to load a program with an incorrect format.", "ERROR_BAD_FORMAT" },
      {0xC, "The access code is invalid.", "ERROR_INVALID_ACCESS" },
      {0xD, "The data is invalid.", "ERROR_INVALID_DATA" },
      {0xE, "Not enough storage is available to complete this operation.", "ERROR_OUTOFMEMORY" },
      {0xF, "The system cannot find the drive specified.", "ERROR_INVALID_DRIVE" },
      {0x10, "The directory cannot be removed.", "ERROR_CURRENT_DIRECTORY" },
      {0x11, "The system cannot move the file to a different disk drive.", "ERROR_NOT_SAME_DEVICE" },
      {0x12, "There are no more files.", "ERROR_NO_MORE_FILES" },
      {0x13, "The media is write protected.", "ERROR_WRITE_PROTECT" },
      {0x14, "The system cannot find the device specified.", "ERROR_BAD_UNIT" },
      {0x15, "The device is not ready.", "ERROR_NOT_READY" },
      {0x16, "The device does not recognize the command.", "ERROR_BAD_COMMAND" },
      {0x17, "Data error (cyclic redundancy check).", "ERROR_CRC" },
      {0x18, "The program issued a command but the command length is incorrect.", "ERROR_BAD_LENGTH" },
      {0x19, "The drive cannot locate a specific area or track on the disk.", "ERROR_SEEK" },
      {0x1A, "The specified disk or diskette cannot be accessed.", "ERROR_NOT_DOS_DISK" },
      {0x1B, "The drive cannot find the sector requested.", "ERROR_SECTOR_NOT_FOUND" },
      {0x1C, "The printer is out of paper.", "ERROR_OUT_OF_PAPER" },
      {0x1D, "The system cannot write to the specified device.", "ERROR_WRITE_FAULT" },
      {0x1E, "The system cannot read from the specified device.", "ERROR_READ_FAULT" },
      {0x1F, "A device attached to the system is not functioning.", "ERROR_GEN_FAILURE" },
      {0x20, "The process cannot access the file because it is being used by another process.", "ERROR_SHARING_VIOLATION" },
      {0x21, "The process cannot access the file because another process has locked a portion of the file.", "ERROR_LOCK_VIOLATION" },
      {0x22, "The wrong diskette is in the drive. Insert %2 (Volume Serial Number: %3) into drive %1.", "ERROR_WRONG_DISK" },
      {0x24, "Too many files opened for sharing.", "ERROR_SHARING_BUFFER_EXCEEDED" },
      {0x26, "Reached the end of the file.", "ERROR_HANDLE_EOF" },
      {0x27, "The disk is full.", "ERROR_HANDLE_DISK_FULL" },
      {0x32, "The request is not supported.", "ERROR_NOT_SUPPORTED" },
      {0x33, "Windows cannot find the network path. Verify that the network path is correct and the destination computer is not busy or turned off. If Windows still cannot find the network path, contact your network administrator.", "ERROR_REM_NOT_LIST" },
      {0x34, "You were not connected because a duplicate name exists on the network. Go to System in the Control Panel to change the computer name and try again.", "ERROR_DUP_NAME" },
      {0x35, "The network path was not found.", "ERROR_BAD_NETPATH" },
      {0x36, "The network is busy.", "ERROR_NETWORK_BUSY" },
      {0x37, "The specified network resource or device is no longer available.", "ERROR_DEV_NOT_EXIST" },
      {0x38, "The network BIOS command limit has been reached.", "ERROR_TOO_MANY_CMDS" },
      {0x39, "A network adapter hardware error occurred.", "ERROR_ADAP_HDW_ERR" },
      {0x3A, "The specified server cannot perform the requested operation.", "ERROR_BAD_NET_RESP" },
      {0x3B, "An unexpected network error occurred.", "ERROR_UNEXP_NET_ERR" },
      {0x3C, "The remote adapter is not compatible.", "ERROR_BAD_REM_ADAP" },
      {0x3D, "The printer queue is full.", "ERROR_PRINTQ_FULL" },
      {0x3E, "Space to store the file waiting to be printed is not available on the server.", "ERROR_NO_SPOOL_SPACE" },
      {0x3F, "Your file waiting to be printed was deleted.", "ERROR_PRINT_CANCELLED" },
      {0x40, "The specified network name is no longer available.", "ERROR_NETNAME_DELETED" },
      {0x41, "Network access is denied.", "ERROR_NETWORK_ACCESS_DENIED" },
      {0x42, "The network resource type is not correct.", "ERROR_BAD_DEV_TYPE" },
      {0x43, "The network name cannot be found.", "ERROR_BAD_NET_NAME" },
      {0x44, "The name limit for the local computer network adapter card was exceeded.", "ERROR_TOO_MANY_NAMES" },
      {0x45, "The network BIOS session limit was exceeded.", "ERROR_TOO_MANY_SESS" },
      {0x46, "The remote server has been paused or is in the process of being started.", "ERROR_SHARING_PAUSED" },
      {0x47, "No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.", "ERROR_REQ_NOT_ACCEP" },
      {0x48, "The specified printer or disk device has been paused.", "ERROR_REDIR_PAUSED" },
      {0x50, "The file exists.", "ERROR_FILE_EXISTS" },
      {0x52, "The directory or file cannot be created.", "ERROR_CANNOT_MAKE" },
      {0x53, "Fail on INT 24.", "ERROR_FAIL_I24" },
      {0x54, "Storage to process this request is not available.", "ERROR_OUT_OF_STRUCTURES" },
      {0x55, "The local device name is already in use.", "ERROR_ALREADY_ASSIGNED" },
      {0x56, "The specified network password is not correct.", "ERROR_INVALID_PASSWORD" },
      {0x57, "The parameter is incorrect.", "ERROR_INVALID_PARAMETER" },
      {0x58, "A write fault occurred on the network.", "ERROR_NET_WRITE_FAULT" },
      {0x59, "The system cannot start another process at this time.", "ERROR_NO_PROC_SLOTS" },
      {0x64, "Cannot create another system semaphore.", "ERROR_TOO_MANY_SEMAPHORES" },
      {0x65, "The exclusive semaphore is owned by another process.", "ERROR_EXCL_SEM_ALREADY_OWNED" },
      {0x66, "The semaphore is set and cannot be closed.", "ERROR_SEM_IS_SET" },
      {0x67, "The semaphore cannot be set again.", "ERROR_TOO_MANY_SEM_REQUESTS" },
      {0x68, "Cannot request exclusive semaphores at interrupt time.", "ERROR_INVALID_AT_INTERRUPT_TIME" },
      {0x69, "The previous ownership of this semaphore has ended.", "ERROR_SEM_OWNER_DIED" },
      {0x6A, "Insert the diskette for drive %1.", "ERROR_SEM_USER_LIMIT" },
      {0x6B, "The program stopped because an alternate diskette was not inserted.", "ERROR_DISK_CHANGE" },
      {0x6C, "The disk is in use or locked by another process.", "ERROR_DRIVE_LOCKED" },
      {0x6D, "The pipe has been ended.", "ERROR_BROKEN_PIPE" },
      {0x6E, "The system cannot open the device or file specified.", "ERROR_OPEN_FAILED" },
      {0x6F, "The file name is too long.", "ERROR_BUFFER_OVERFLOW" },
      {0x70, "There is not enough space on the disk.", "ERROR_DISK_FULL" },
      {0x71, "No more internal file identifiers available.", "ERROR_NO_MORE_SEARCH_HANDLES" },
      {0x72, "The target internal file identifier is incorrect.", "ERROR_INVALID_TARGET_HANDLE" },
      {0x75, "The IOCTL call made by the application program is not correct.", "ERROR_INVALID_CATEGORY" },
      {0x76, "The verify-on-write switch parameter value is not correct.", "ERROR_INVALID_VERIFY_SWITCH" },
      {0x77, "The system does not support the command requested.", "ERROR_BAD_DRIVER_LEVEL" },
      {0x78, "This function is not supported on this system.", "ERROR_CALL_NOT_IMPLEMENTED" },
      {0x79, "The semaphore timeout period has expired.", "ERROR_SEM_TIMEOUT" },
      {0x7A, "The data area passed to a system call is too small.", "ERROR_INSUFFICIENT_BUFFER" },
      {0x7B, "The filename, directory name, or volume label syntax is incorrect.", "ERROR_INVALID_NAME" },
      {0x7C, "The system call level is not correct.", "ERROR_INVALID_LEVEL" },
      {0x7D, "The disk has no volume label.", "ERROR_NO_VOLUME_LABEL" },
      {0x7E, "The specified module could not be found.", "ERROR_MOD_NOT_FOUND" },
      {0x7F, "The specified procedure could not be found.", "ERROR_PROC_NOT_FOUND" },
      {0x80, "There are no child processes to wait for.", "ERROR_WAIT_NO_CHILDREN" },
      {0x81, "The %1 application cannot be run in Win32 mode.", "ERROR_CHILD_NOT_COMPLETE" },
      {0x82, "Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.", "ERROR_DIRECT_ACCESS_HANDLE" },
      {0x83, "An attempt was made to move the file pointer before the beginning of the file.", "ERROR_NEGATIVE_SEEK" },
      {0x84, "The file pointer cannot be set on the specified device or file.", "ERROR_SEEK_ON_DEVICE" },
      {0x85, "A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.", "ERROR_IS_JOIN_TARGET" },
      {0x86, "An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.", "ERROR_IS_JOINED" },
      {0x87, "An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.", "ERROR_IS_SUBSTED" },
      {0x88, "The system tried to delete the JOIN of a drive that is not joined.", "ERROR_NOT_JOINED" },
      {0x89, "The system tried to delete the substitution of a drive that is not substituted.", "ERROR_NOT_SUBSTED" },
      {0x8A, "The system tried to join a drive to a directory on a joined drive.", "ERROR_JOIN_TO_JOIN" },
      {0x8B, "The system tried to substitute a drive to a directory on a substituted drive.", "ERROR_SUBST_TO_SUBST" },
      {0x8C, "The system tried to join a drive to a directory on a substituted drive.", "ERROR_JOIN_TO_SUBST" },
      {0x8D, "The system tried to SUBST a drive to a directory on a joined drive.", "ERROR_SUBST_TO_JOIN" },
      {0x8E, "The system cannot perform a JOIN or SUBST at this time.", "ERROR_BUSY_DRIVE" },
      {0x8F, "The system cannot join or substitute a drive to or for a directory on the same drive.", "ERROR_SAME_DRIVE" },
      {0x90, "The directory is not a subdirectory of the root directory.", "ERROR_DIR_NOT_ROOT" },
      {0x91, "The directory is not empty.", "ERROR_DIR_NOT_EMPTY" },
      {0x92, "The path specified is being used in a substitute.", "ERROR_IS_SUBST_PATH" },
      {0x93, "Not enough resources are available to process this command.", "ERROR_IS_JOIN_PATH" },
      {0x94, "The path specified cannot be used at this time.", "ERROR_PATH_BUSY" },
      {0x95, "An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute.", "ERROR_IS_SUBST_TARGET" },
      {0x96, "System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.", "ERROR_SYSTEM_TRACE" },
      {0x97, "The number of specified semaphore events for DosMuxSemWait is not correct.", "ERROR_INVALID_EVENT_COUNT" },
      {0x98, "DosMuxSemWait did not execute; too many semaphores are already set.", "ERROR_TOO_MANY_MUXWAITERS" },
      {0x99, "The DosMuxSemWait list is not correct.", "ERROR_INVALID_LIST_FORMAT" },
      {0x9A, "The volume label you entered exceeds the label character limit of the target file system.", "ERROR_LABEL_TOO_LONG" },
      {0x9B, "Cannot create another thread.", "ERROR_TOO_MANY_TCBS" },
      {0x9C, "The recipient process has refused the signal.", "ERROR_SIGNAL_REFUSED" },
      {0x9D, "The segment is already discarded and cannot be locked.", "ERROR_DISCARDED" },
      {0x9E, "The segment is already unlocked.", "ERROR_NOT_LOCKED" },
      {0x9F, "The address for the thread ID is not correct.", "ERROR_BAD_THREADID_ADDR" },
      {0xA0, "The argument string passed to DosExecPgm is not correct.", "ERROR_BAD_ARGUMENTS" },
      {0xA1, "The specified path is invalid.", "ERROR_BAD_PATHNAME" },
      {0xA2, "A signal is already pending.", "ERROR_SIGNAL_PENDING" },
      {0xA4, "No more threads can be created in the system.", "ERROR_MAX_THRDS_REACHED" },
      {0xA7, "Unable to lock a region of a file.", "ERROR_LOCK_FAILED" },
      {0xAA, "The requested resource is in use.", "ERROR_BUSY" },
      {0xAD, "A lock request was not outstanding for the supplied cancel region.", "ERROR_CANCEL_VIOLATION" },
      {0xAE, "The file system does not support atomic changes to the lock type.", "ERROR_ATOMIC_LOCKS_NOT_SUPPORTED" },
      {0xB4, "The system detected a segment number that was not correct.", "ERROR_INVALID_SEGMENT_NUMBER" },
      {0xB6, "The operating system cannot run %1.", "ERROR_INVALID_ORDINAL" },
      {0xB7, "Cannot create a file when that file already exists.", "ERROR_ALREADY_EXISTS" },
      {0xBA, "The flag passed is not correct.", "ERROR_INVALID_FLAG_NUMBER" },
      {0xBB, "The specified system semaphore name was not found.", "ERROR_SEM_NOT_FOUND" },
      {0xBC, "The operating system cannot run %1.", "ERROR_INVALID_STARTING_CODESEG" },
      {0xBD, "The operating system cannot run %1.", "ERROR_INVALID_STACKSEG" },
      {0xBE, "The operating system cannot run %1.", "ERROR_INVALID_MODULETYPE" },
      {0xBF, "Cannot run %1 in Win32 mode.", "ERROR_INVALID_EXE_SIGNATURE" },
      {0xC0, "The operating system cannot run %1.", "ERROR_EXE_MARKED_INVALID" },
      {0xC1, "%1 is not a valid Win32 application.", "ERROR_BAD_EXE_FORMAT" },
      {0xC2, "The operating system cannot run %1.", "ERROR_ITERATED_DATA_EXCEEDS_64k" },
      {0xC3, "The operating system cannot run %1.", "ERROR_INVALID_MINALLOCSIZE" },
      {0xC4, "The operating system cannot run this application program.", "ERROR_DYNLINK_FROM_INVALID_RING" },
      {0xC5, "The operating system is not presently configured to run this application.", "ERROR_IOPL_NOT_ENABLED" },
      {0xC6, "The operating system cannot run %1.", "ERROR_INVALID_SEGDPL" },
      {0xC7, "The operating system cannot run this application program.", "ERROR_AUTODATASEG_EXCEEDS_64k" },
      {0xC8, "The code segment cannot be greater than or equal to 64K.", "ERROR_RING2SEG_MUST_BE_MOVABLE" },
      {0xC9, "The operating system cannot run %1.", "ERROR_RELOC_CHAIN_XEEDS_SEGLIM" },
      {0xCA, "The operating system cannot run %1.", "ERROR_INFLOOP_IN_RELOC_CHAIN" },
      {0xCB, "The system could not find the environment option that was entered.", "ERROR_ENVVAR_NOT_FOUND" },
      {0xCD, "No process in the command subtree has a signal handler.", "ERROR_NO_SIGNAL_SENT" },
      {0xCE, "The filename or extension is too long.", "ERROR_FILENAME_EXCED_RANGE" },
      {0xCF, "The ring 2 stack is in use.", "ERROR_RING2_STACK_IN_USE" },
      {0xD0, "The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified.", "ERROR_META_EXPANSION_TOO_LONG" },
      {0xD1, "The signal being posted is not correct.", "ERROR_INVALID_SIGNAL_NUMBER" },
      {0xD2, "The signal handler cannot be set.", "ERROR_THREAD_1_INACTIVE" },
      {0xD4, "The segment is locked and cannot be reallocated.", "ERROR_LOCKED" },
      {0xD6, "Too many dynamic-link modules are attached to this program or dynamic-link module.", "ERROR_TOO_MANY_MODULES" },
      {0xD7, "Cannot nest calls to LoadModule.", "ERROR_NESTING_NOT_ALLOWED" },
      {0xD8, "The image file %1 is valid, but is for a machine type other than the current machine.", "ERROR_EXE_MACHINE_TYPE_MISMATCH" },
      {0xD9, "The image file %1 is signed, unable to modify.", "ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY" },
      {0xDA, "The image file %1 is strong signed, unable to modify.", "ERRO_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY" },
      {0xE6, "The pipe state is invalid.", "ERROR_BAD_PIPE" },
      {0xE7, "All pipe instances are busy.", "ERROR_PIPE_BUSY" },
      {0xE8, "The pipe is being closed.", "ERROR_NO_DATA" },
      {0xE9, "No process is on the other end of the pipe.", "ERROR_PIPE_NOT_CONNECTED" },
      {0xEA, "More data is available.", "ERROR_MORE_DATA" },
      {0xF0, "The session was canceled.", "ERROR_VC_DISCONNECTED" },
      {0xFE, "The specified extended attribute name was invalid.", "ERROR_INVALID_EA_NAME" },
      {0xFF, "The extended attributes are inconsistent.", "ERROR_EA_LIST_INCONSISTENT" },
      {0x102, "The wait operation timed out.", "WAIT_TIMEOUT" },
      {0x103, "No more data is available.", "ERROR_NO_MORE_ITEMS" },
      {0x10A, "The copy functions cannot be used.", "ERROR_CANNOT_COPY" },
      {0x10B, "The directory name is invalid.", "ERROR_DIRECTORY" },
      {0x113, "The extended attributes did not fit in the buffer.", "ERROR_EAS_DIDNT_FIT" },
      {0x114, "The extended attribute file on the mounted file system is corrupt.", "ERROR_EA_FILE_CORRUPT" },
      {0x115, "The extended attribute table file is full.", "ERROR_EA_TABLE_FULL" },
      {0x116, "The specified extended attribute handle is invalid.", "ERROR_INVALID_EA_HANDLE" },
      {0x11A, "The mounted file system does not support extended attributes.", "ERROR_EAS_NOT_SUPPORTED" },
      {0x120, "Attempt to release mutex not owned by caller.", "ERROR_NOT_OWNER" },
      {0x12A, "Too many posts were made to a semaphore.", "ERROR_TOO_MANY_POSTS" },
      {0x12B, "Only part of a ReadProcessMemory or WriteProcessMemory request was completed.", "ERROR_PARTIAL_COPY" },
      {0x12C, "The oplock request is denied.", "ERROR_OPLOCK_NOT_GRANTED" },
      {0x12D, "An invalid oplock acknowledgment was received by the system.", "ERROR_INVALID_OPLOCK_PROTOCOL" },
      {0x12E, "The volume is too fragmented to complete this operation.", "ERROR_DISK_TOO_FRAGMENTED" },
      {0x12F, "The file cannot be opened because it is in the process of being deleted.", "ERROR_DELETE_PENDING" },
      {0x13D, "The system cannot find message text for message number 0x%1 in the message file for %2.", "ERROR_MR_MID_NOT_FOUND" },
      {0x13E, "The scope specified was not found.", "ERROR_SCOPE_NOT_FOUND" },
      {0x1E7, "Attempt to access invalid address.", "ERROR_INVALID_ADDRESS" },
      {0x216, "Arithmetic result exceeded 32 bits.", "ERROR_ARITHMETIC_OVERFLOW" },
      {0x217, "There is a process on other end of the pipe.", "ERROR_PIPE_CONNECTED" },
      {0x218, "Waiting for a process to open the other end of the pipe.", "ERROR_PIPE_LISTENING" },
      {0x219, "An error occurred in the ACPI subsystem.", "ERROR_ACPI_ERROR" },
      {0x21A, "An error occurred in the ABIOS subsystem", "ERROR_ABIOS_ERROR" },
      {0x21B, "A warning occurred in the WX86 subsystem.", "ERROR_WX86_WARNING" },
      {0x21C, "An error occurred in the WX86 subsystem.", "ERROR_WX86_ERROR" },
      {0x21D, "An attempt was made to cancel or set a timer that has an associated APC and the subject thread is not the thread that originally set the timer with an associated APC routine.", "ERROR_TIMER_NOT_CANCELED" },
      {0x21E, "Unwind exception code.", "ERROR_UNWIND" },
      {0x21F, "An invalid or unaligned stack was encountered during an unwind operation.", "ERROR_BAD_STACK" },
      {0x220, "An invalid unwind target was encountered during an unwind operation.", "ERROR_INVALID_UNWIND_TARGET" },
      {0x221, "Invalid Object Attributes specified to NtCreatePort or invalid Port Attributes specified to NtConnectPort", "ERROR_INVALID_PORT_ATTRIBUTES" },
      {0x222, "Length of message passed to NtRequestPort or NtRequestWaitReplyPort was longer than the maximum message allowed by the port.", "ERROR_PORT_MESSAGE_TOO_LONG" },
      {0x223, "An attempt was made to lower a quota limit below the current usage.", "ERROR_INVALID_QUOTA_LOWER" },
      {0x224, "An attempt was made to attach to a device that was already attached to another device.", "ERROR_DEVICE_ALREADY_ATTACHED" },
      {0x225, "An attempt was made to execute an instruction at an unaligned address and the host system does not support unaligned instruction references.", "ERROR_INSTRUCTION_MISALIGNMENT" },
      {0x226, "Profiling not started.", "ERROR_PROFILING_NOT_STARTED" },
      {0x227, "Profiling not stopped.", "ERROR_PROFILING_NOT_STOPPED" },
      {0x228, "The passed ACL did not contain the minimum required information.", "ERROR_COULD_NOT_INTERPRET" },
      {0x229, "The number of active profiling objects is at the maximum and no more may be started.", "ERROR_PROFILING_AT_LIMIT" },
      {0x22A, "Used to indicate that an operation cannot continue without blocking for I/O.", "ERROR_CANT_WAIT" },
      {0x22B, "Indicates that a thread attempted to terminate itself by default (called NtTerminateThread with NULL) and it was the last thread in the current process.", "ERROR_CANT_TERMINATE_SELF" },
      {0x22C, "If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception. ", "ERROR_UNEXPECTED_MM_CREATE_ERR" },
      {0x22D, "If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception. ", "ERROR_UNEXPECTED_MM_MAP_ERROR" },
      {0x22E, "If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception. ", "ERROR_UNEXPECTED_MM_EXTEND_ERR" },
      {0x22F, "A malformed function table was encountered during an unwind operation.", "ERROR_BAD_FUNCTION_TABLE" },
      {0x230, "Indicates that an attempt was made to assign protection to a file system file or directory and one of the SIDs in the security descriptor could not be translated into a GUID that could be stored by the file system. This causes the protection attempt to fail, which may cause a file creation attempt to fail. ", "ERROR_NO_GUID_TRANSLATION" },
      {0x231, "Indicates that an attempt was made to grow an LDT by setting its size, or that the size was not an even number of selectors.", "ERROR_INVALID_LDT_SIZE" },
      {0x233, "Indicates that the starting value for the LDT information was not an integral multiple of the selector size.", "ERROR_INVALID_LDT_OFFSET" },
      {0x234, "Indicates that the user supplied an invalid descriptor when trying to set up Ldt descriptors.", "ERROR_INVALID_LDT_DESCRIPTOR" },
      {0x235, "Indicates a process has too many threads to perform the requested action. For example, assignment of a primary token may only be performed when a process has zero or one threads.", "ERROR_TOO_MANY_THREADS" },
      {0x236, "An attempt was made to operate on a thread within a specific process, but the thread specified is not in the process specified.", "ERROR_THREAD_NOT_IN_PROCESS" },
      {0x237, "Page file quota was exceeded.", "ERROR_PAGEFILE_QUOTA_EXCEEDED" },
      {0x238, "The Netlogon service cannot start because another Netlogon service running in the domain conflicts with the specified role.", "ERROR_LOGON_SERVER_CONFLICT" },
      {0x239, "The SAM database on a Windows Server is significantly out of synchronization with the copy on the Domain Controller. A complete synchronization is required.", "ERROR_SYNCHRONIZATION_REQUIRED" },
      {0x23A, "The NtCreateFile API failed. This error should never be returned to an application, it is a place holder for the Windows Lan Manager Redirector to use in its internal error mapping routines.", "ERROR_NET_OPEN_FAILED" },
      {0x23B, "The I/O permissions for the process could not be changed.", "ERROR_IO_PRIVILEGE_FAILED" },
      {0x23C, "The application terminated as a result of a CTRL+C.", "ERROR_CONTROL_C_EXIT" },
      {0x23D, "The required system file %hs is bad or missing.", "ERROR_MISSING_SYSTEMFILE" },
      {0x23E, "The exception %s (0x%08lx) occurred in the application at location 0x%08lx.", "ERROR_UNHANDLED_EXCEPTION" },
      {0x23F, "The application failed to initialize properly (0x%lx). Click on OK to terminate the application.", "ERROR_APP_INIT_FAILURE" },
      {0x240, "The creation of the paging file %hs failed (%lx). The requested size was %ld.", "ERROR_PAGEFILE_CREATE_FAILED" },
      {0x242, "No paging file was specified in the system configuration.", "ERROR_NO_PAGEFILE" },
      {0x243, "A real-mode application issued a floating-point instruction and floating-point hardware is not present.", "ERROR_ILLEGAL_FLOAT_CONTEXT" },
      {0x244, "An event pair synchronization operation was performed using the thread specific client/server event pair object, but no event pair object was associated with the thread.", "ERROR_NO_EVENT_PAIR" },
      {0x245, "A Windows Server has an incorrect configuration.", "ERROR_DOMAIN_CTRLR_CONFIG_ERROR" },
      {0x246, "An illegal character was encountered. For a multi-byte character set this includes a lead byte without a succeeding trail byte. For the Unicode character set this includes the characters 0xFFFF and 0xFFFE.", "ERROR_ILLEGAL_CHARACTER" },
      {0x247, "The Unicode character is not defined in the Unicode character set installed on the system.", "ERROR_UNDEFINED_CHARACTER" },
      {0x248, "The paging file cannot be created on a floppy diskette.", "ERROR_FLOPPY_VOLUME" },
      {0x249, "The system bios failed to connect a system interrupt to the device or bus for which the device is connected. ", "ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT" },
      {0x24A, "This operation is only allowed for the Primary Domain Controller of the domain.", "ERROR_BACKUP_CONTROLLER" },
      {0x24B, "An attempt was made to acquire a mutant such that its maximum count would have been exceeded.", "ERROR_MUTANT_LIMIT_EXCEEDED" },
      {0x24C, "A volume has been accessed for which a file system driver is required that has not yet been loaded.", "ERROR_FS_DRIVER_REQUIRED" },
      {0x24D, "The registry cannot load the hive (file): %hs or its log or alternate. It is corrupt, absent, or not writable.", "ERROR_CANNOT_LOAD_REGISTRY_FILE" },
      {0x24E, "An unexpected failure occurred while processing a DebugActiveProcess API request. You may choose OK to terminate the process, or Cancel to ignore the error.", "ERROR_DEBUG_ATTACH_FAILED" },
      {0x24F, "The %hs system process terminated unexpectedly with a status of 0x%08x (0x%08x 0x%08x). The system has been shut down. ", "ERROR_SYSTEM_PROCESS_TERMINATED" },
      {0x250, "The TDI client could not handle the data received during an indication.", "ERROR_DATA_NOT_ACCEPTED" },
      {0x251, "NTVDM encountered a hard error.", "ERROR_VDM_HARD_ERROR" },
      {0x252, "The driver %hs failed to complete a cancelled I/O request in the allotted time.", "ERROR_DRIVER_CANCEL_TIMEOUT" },
      {0x253, "An attempt was made to reply to an LPC message, but the thread specified by the client ID in the message was not waiting on that message.", "ERROR_REPLY_MESSAGE_MISMATCH" },
      {0x254, "Windows was unable to save all the data for the file %hs. The data has been lost. This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere. ", "ERROR_LOST_WRITEBEHIND_DATA" },
      {0x255, "The parameter(s) passed to the server in the client/server shared memory window were invalid. Too much data may have been put in the shared memory window.", "ERROR_CLIENT_SERVER_PARAMETERS_INVALID" },
      {0x256, "The stream is not a tiny stream.", "ERROR_NOT_TINY_STREAM" },
      {0x257, "The request must be handled by the stack overflow code.", "ERROR_STACK_OVERFLOW_READ" },
      {0x258, "Internal OFS status codes indicating how an allocation operation is handled. Either it is retried after the containing onode is moved or the extent stream is converted to a large stream.", "ERROR_CONVERT_TO_LARGE" },
      {0x259, "The attempt to find the object found an object matching by ID on the volume but it is out of the scope of the handle used for the operation.", "ERROR_FOUND_OUT_OF_SCOPE" },
      {0x25A, "The bucket array must be grown. Retry transaction after doing so.", "ERROR_ALLOCATE_BUCKET" },
      {0x25B, "The user/kernel marshalling buffer has overflowed.", "ERROR_MARSHALL_OVERFLOW" },
      {0x25C, "The supplied variant structure contains invalid data.", "ERROR_INVALID_VARIANT" },
      {0x25D, "The specified buffer contains ill-formed data.", "ERROR_BAD_COMPRESSION_BUFFER" },
      {0x25E, "An attempt to generate a security audit failed.", "ERROR_AUDIT_FAILED" },
      {0x25F, "The timer resolution was not previously set by the current process.", "ERROR_TIMER_RESOLUTION_NOT_SET" },
      {0x260, "There is insufficient account information to log you on.", "ERROR_INSUFFICIENT_LOGON_INFO" },
      {0x261, "The dynamic link library %hs is not written correctly. The stack pointer has been left in an inconsistent state. The entrypoint should be declared as WINAPI or STDCALL. Select YES to fail the DLL load. Select NO to continue execution. Selecting NO may cause the application to operate incorrectly. ", "ERROR_BAD_DLL_ENTRYPOINT" },
      {0x262, "The %hs service is not written correctly. The stack pointer has been left in an inconsistent state. The callback entrypoint should be declared as WINAPI or STDCALL. Selecting OK will cause the service to continue operation. However, the service process may operate incorrectly. ", "ERROR_BAD_SERVICE_ENTRYPOINT" },
      {0x263, "There is an IP address conflict with another system on the network", "ERROR_IP_ADDRESS_CONFLICT1" },
      {0x264, "There is an IP address conflict with another system on the network", "ERROR_IP_ADDRESS_CONFLICT2" },
      {0x265, "The system has reached the maximum size allowed for the system part of the registry. Additional storage requests will be ignored.", "ERROR_REGISTRY_QUOTA_LIMIT" },
      {0x266, "A callback return system service cannot be executed when no callback is active.", "ERROR_NO_CALLBACK_ACTIVE" },
      {0x267, "The password provided is too short to meet the policy of your user account. Please choose a longer password. ", "ERROR_PWD_TOO_SHORT" },
      {0x268, "The policy of your user account does not allow you to change passwords too frequently. This is done to prevent users from changing back to a familiar, but potentially discovered, password. If you feel your password has been compromised then please contact your administrator immediately to have a new one assigned. ", "ERROR_PWD_TOO_RECENT" },
      {0x269, "You have attempted to change your password to one that you have used in the past. The policy of your user account does not allow this. Please select a password that you have not previously used. ", "ERROR_PWD_HISTORY_CONFLICT" },
      {0x26A, "The specified compression format is unsupported.", "ERROR_UNSUPPORTED_COMPRESSION" },
      {0x26B, "The specified hardware profile configuration is invalid.", "ERROR_INVALID_HW_PROFILE" },
      {0x26C, "The specified Plug and Play registry device path is invalid.", "ERROR_INVALID_PLUGPLAY_DEVICE_PATH" },
      {0x26D, "The specified quota list is internally inconsistent with its descriptor.", "ERROR_QUOTA_LIST_INCONSISTENT" },
      {0x26E, "The evaluation period for this installation of Windows has expired. This system will shutdown in 1 hour. To restore access to this installation of Windows, please upgrade this installation using a licensed distribution of this product.", "ERROR_EVALUATION_EXPIRATION" },
      {0x26F, "The system DLL %hs was relocated in memory. The application will not run properly. The relocation occurred because the DLL %hs occupied an address range reserved for Windows system DLLs. The vendor supplying the DLL should be contacted for a new DLL. ", "ERROR_ILLEGAL_DLL_RELOCATION" },
      {0x270, "The application failed to initialize because the window station is shutting down.", "ERROR_DLL_INIT_FAILED_LOGOFF" },
      {0x271, "The validation process needs to continue on to the next step.", "ERROR_VALIDATE_CONTINUE" },
      {0x272, "There are no more matches for the current index enumeration.", "ERROR_NO_MORE_MATCHES" },
      {0x273, "The range could not be added to the range list because of a conflict.", "ERROR_RANGE_LIST_CONFLICT" },
      {0x274, "The server process is running under a SID different than that required by client.", "ERROR_SERVER_SID_MISMATCH" },
      {0x275, "A group marked use for deny only cannot be enabled.", "ERROR_CANT_ENABLE_DENY_ONLY" },
      {0x276, "Multiple floating point faults.", "ERROR_FLOAT_MULTIPLE_FAULTS" },
      {0x277, "Multiple floating point traps.", "ERROR_FLOAT_MULTIPLE_TRAPS" },
      {0x278, "The requested interface is not supported.", "ERROR_NOINTERFACE" },
      {0x279, "The driver %hs does not support standby mode. Updating this driver may allow the system to go to standby mode.", "ERROR_DRIVER_FAILED_SLEEP" },
      {0x27A, "The system file %1 has become corrupt and has been replaced.", "ERROR_CORRUPT_SYSTEM_FILE" },
      {0x27B, "Your system is low on virtual memory. Windows is increasing the size of your virtual memory paging file. During this process, memory requests for some applications may be denied. For more information, see Help. ", "ERROR_COMMITMENT_MINIMUM" },
      {0x27C, "A device was removed so enumeration must be restarted.", "ERROR_PNP_RESTART_ENUMERATION" },
      {0x27D, "The system image %s is not properly signed. The file has been replaced with the signed file. The system has been shut down.", "ERROR_SYSTEM_IMAGE_BAD_SIGNATURE" },
      {0x27E, "Device will not start without a reboot.", "ERROR_PNP_REBOOT_REQUIRED" },
      {0x27F, "There is not enough power to complete the requested operation.", "ERROR_INSUFFICIENT_POWER" },
      {0x281, "The system is in the process of shutting down.", "ERROR_SYSTEM_SHUTDOWN" },
      {0x282, "An attempt to remove a processes DebugPort was made, but a port was not already associated with the process.", "ERROR_PORT_NOT_SET" },
      {0x283, "This version of Windows is not compatible with the behavior version of directory forest, domain or domain controller.", "ERROR_DS_VERSION_CHECK_FAILURE" },
      {0x284, "The specified range could not be found in the range list.", "ERROR_RANGE_NOT_FOUND" },
      {0x286, "The driver was not loaded because the system is booting into safe mode.", "ERROR_NOT_SAFE_MODE_DRIVER" },
      {0x287, "The driver was not loaded because it failed it's initialization call.", "ERROR_FAILED_DRIVER_ENTRY" },
      {0x288, "The \"%hs\" encountered an error while applying power or reading the device configuration. This may be caused by a failure of your hardware or by a poor connection. ", "ERROR_DEVICE_ENUMERATION_ERROR" },
      {0x289, "The create operation failed because the name contained at least one mount point which resolves to a volume to which the specified device object is not attached.", "ERROR_MOUNT_POINT_NOT_RESOLVED" },
      {0x28A, "The device object parameter is either not a valid device object or is not attached to the volume specified by the file name.", "ERROR_INVALID_DEVICE_OBJECT_PARAMETER" },
      {0x28B, "A Machine Check Error has occurred. Please check the system eventlog for additional information.", "ERROR_MCA_OCCURED" },
      {0x28C, "There was error [%2] processing the driver database.", "ERROR_DRIVER_DATABASE_ERROR" },
      {0x28D, "System hive size has exceeded its limit.", "ERROR_SYSTEM_HIVE_TOO_LARGE" },
      {0x28E, "The driver could not be loaded because a previous version of the driver is still in memory.", "ERROR_DRIVER_FAILED_PRIOR_UNLOAD" },
      {0x28F, "Please wait while the Volume Shadow Copy Service prepares volume %hs for hibernation.", "ERROR_VOLSNAP_PREPARE_HIBERNATE" },
      {0x290, "The system has failed to hibernate (The error code is %hs). Hibernation will be disabled until the system is restarted.", "ERROR_HIBERNATION_FAILURE" },
      {0x291, "The %hs display driver has stopped working normally. Save your work and reboot the system to restore full display functionality. The next time you reboot the machine a dialog will be displayed giving you a chance to report this failure to Microsoft. ", "ERROR_HUNG_DISPLAY_DRIVER_THREAD" },
      {0x299, "The requested operation could not be completed due to a file system limitation.", "ERROR_FILE_SYSTEM_LIMITATION" },
      {0x29C, "An assertion failure has occurred.", "ERROR_ASSERTION_FAILURE" },
      {0x29D, "Application verifier has found an error in the current process.", "ERROR_VERIFIER_STOP" },
      {0x29E, "WOW Assertion Error.", "ERROR_WOW_ASSERTION" },
      {0x29F, "A device is missing in the system BIOS MPS table. This device will not be used. Please contact your system vendor for system BIOS update. ", "ERROR_PNP_BAD_MPS_TABLE" },
      {0x2A0, "A translator failed to translate resources.", "ERROR_PNP_TRANSLATION_FAILED" },
      {0x2A1, "A IRQ translator failed to translate resources.", "ERROR_PNP_IRQ_TRANSLATION_FAILED" },
      {0x2A2, "Driver %2 returned invalid ID for a child device (%3).", "ERROR_PNP_INVALID_ID" },
      {0x2A3, "The system debugger was awakened by an interrupt.", "ERROR_WAKE_SYSTEM_DEBUGGER" },
      {0x2A4, "Handles to objects have been automatically closed as a result of the requested operation.", "ERROR_HANDLES_CLOSED" },
      {0x2A5, "he specified access control list (ACL) contained more information than was expected.", "ERROR_EXTRANEOUS_INFORMATION" },
      {0x2A6, "This warning level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted. The commit has NOT been completed, but has not been rolled back either (so it may still be committed if desired). ", "ERROR_RXACT_COMMIT_NECESSARY" },
      {0x2A7, "The media may have changed.", "ERROR_MEDIA_CHECK" },
      {0x2A8, "During the translation of a global identifier (GUID) to a Windows security ID (SID), no administratively-defined GUID prefix was found. A substitute prefix was used, which will not compromise system security. However, this may provide a more restrictive access than intended. ", "ERROR_GUID_SUBSTITUTION_MADE" },
      {0x2A9, "The create operation stopped after reaching a symbolic link.", "ERROR_STOPPED_ON_SYMLINK" },
      {0x2AA, "A long jump has been executed.", "ERROR_LONGJUMP" },
      {0x2AB, "The Plug and Play query operation was not successful.", "ERROR_PLUGPLAY_QUERY_VETOED" },
      {0x2AC, "A frame consolidation has been executed.", "ERROR_UNWIND_CONSOLIDATE" },
      {0x2AD, "Registry hive (file): %hs was corrupted and it has been recovered. Some data might have been lost. ", "ERROR_REGISTRY_HIVE_RECOVERED" },
      {0x2AE, "The application is attempting to run executable code from the module %hs. This may be insecure. An alternative, %hs, is available. Should the application use the secure module %hs?", "ERROR_DLL_MIGHT_BE_INSECURE" },
      {0x2AF, "The application is loading executable code from the module %hs. This is secure, but may be incompatible with previous releases of the operating system. An alternative, %hs, is available. Should the application use the secure module %hs?", "ERROR_DLL_MIGHT_BE_INCOMPATIBLE" },
      {0x2B0, "Debugger did not handle the exception.", "ERROR_DBG_EXCEPTION_NOT_HANDLED" },
      {0x2B1, "Debugger will reply later.", "ERROR_DBG_REPLY_LATER" },
      {0x2B2, "Debugger can not provide handle.", "ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE" },
      {0x2B3, "Debugger terminated thread.", "ERROR_DBG_TERMINATE_THREAD" },
      {0x2B4, "Debugger terminated process.", "ERROR_DBG_TERMINATE_PROCESS" },
      {0x2B5, "Debugger got control C.", "ERROR_DBG_CONTROL_C" },
      {0x2B6, "Debugger printed exception on control C.", "ERROR_DBG_PRINTEXCEPTION_C" },
      {0x2B7, "Debugger received RIP exception.", "ERROR_DBG_RIPEXCEPTION" },
      {0x2B8, "Debugger received control break.", "ERROR_DBG_CONTROL_BREAK" },
      {0x2B9, "Debugger command communication exception.", "ERROR_DBG_COMMAND_EXCEPTION" },
      {0x2BA, "An attempt was made to create an object and the object name already existed.", "ERROR_OBJECT_NAME_EXISTS" },
      {0x2BB, "A thread termination occurred while the thread was suspended. The thread was resumed, and termination proceeded.", "ERROR_THREAD_WAS_SUSPENDED" },
      {0x2BC, "An image file could not be mapped at the address specified in the image file. Local fixups must be performed on this image.", "ERROR_IMAGE_NOT_AT_BASE" },
      {0x2BD, "This informational level status indicates that a specified registry sub-tree transaction state did not yet exist and had to be created.", "ERROR_RXACT_STATE_CREATED" },
      {0x2BE, "A virtual DOS machine (VDM) is loading, unloading, or moving an MS-DOS or Win16 program segment image. An exception is raised so a debugger can load, unload or track symbols and breakpoints within these 16-bit segments. ", "ERROR_SEGMENT_NOTIFICATION" },
      {0x2BF, "The process cannot switch to the startup current directory %hs. Select OK to set current directory to %hs, or select CANCEL to exit. ", "ERROR_BAD_CURRENT_DIRECTORY" },
      {0x2C0, "To satisfy a read request, the NT fault-tolerant file system successfully read the requested data from a redundant copy. This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was unable to reassign the failing area of the device. ", "ERROR_FT_READ_RECOVERY_FROM_BACKUP" },
      {0x2C1, "To satisfy a write request, the NT fault-tolerant file system successfully wrote a redundant copy of the information. This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was not able to reassign the failing area of the device. ", "ERROR_FT_WRITE_RECOVERY" },
      {0x2C2, "The image file %hs is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.", "ERROR_IMAGE_MACHINE_TYPE_MISMATCH" },
      {0x2C3, "The network transport returned partial data to its client. The remaining data will be sent later.", "ERROR_RECEIVE_PARTIAL" },
      {0x2C4, "The network transport returned data to its client that was marked as expedited by the remote system.", "ERROR_RECEIVE_EXPEDITED" },
      {0x2C5, "The network transport returned partial data to its client and this data was marked as expedited by the remote system. The remaining data will be sent later.", "ERROR_RECEIVE_PARTIAL_EXPEDITED" },
      {0x2C6, "The TDI indication has completed successfully.", "ERROR_EVENT_DONE" },
      {0x2C7, "The TDI indication has entered the pending state.", "ERROR_EVENT_PENDING" },
      {0x2C8, "Checking file system on %wZ.", "ERROR_CHECKING_FILE_SYSTEM" },
      {0x2CA, "The specified registry key is referenced by a predefined handle.", "ERROR_PREDEFINED_HANDLE" },
      {0x2CB, "The page protection of a locked page was changed to 'No Access' and the page was unlocked from memory and from the process.", "ERROR_WAS_UNLOCKED" },
      {0x2CD, "One of the pages to lock was already locked.", "ERROR_WAS_LOCKED" },
      {0x2D0, "The image file %hs is valid, but is for a machine type other than the current machine.", "ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE" },
      {0x2D1, "A yield execution was performed and no thread was available to run.", "ERROR_NO_YIELD_PERFORMED" },
      {0x2D2, "The resumable flag to a timer API was ignored.", "ERROR_TIMER_RESUME_IGNORED" },
      {0x2D3, "The arbiter has deferred arbitration of these resources to its parent.", "ERROR_ARBITRATION_UNHANDLED" },
      {0x2D4, "The device \"%hs\" has detected a CardBus card in its slot, but the firmware on this system is not configured to allow the CardBus controller to be run in CardBus mode. The operating system will currently accept only 16-bit (R2) pc-cards on this controller. ", "ERROR_CARDBUS_NOT_SUPPORTED" },
      {0x2D5, "The CPUs in this multiprocessor system are not all the same revision level. To use all processors the operating system restricts itself to the features of the least capable processor in the system. Should problems occur with this system, contact the CPU manufacturer to see if this mix of processors is supported. ", "ERROR_MP_PROCESSOR_MISMATCH" },
      {0x2D6, "The system was put into hibernation.", "ERROR_HIBERNATED" },
      {0x2D7, "The system was resumed from hibernation.", "ERROR_RESUME_HIBERNATION" },
      {0x2D8, "Windows has detected that the system firmware (BIOS) was updated [previous firmware date = %2, current firmware date %3].", "ERROR_FIRMWARE_UPDATED" },
      {0x2D9, "A device driver is leaking locked I/O pages causing system degradation. The system has automatically enabled tracking code in order to try and catch the culprit.", "ERROR_DRIVERS_LEAKING_LOCKED_PAGES" },
      {0x2DA, "The system has awoken", "ERROR_WAKE_SYSTEM" },
      {0x2E5, "A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.", "ERROR_REPARSE" },
      {0x2E6, "An open/create operation completed while an oplock break is underway.", "ERROR_OPLOCK_BREAK_IN_PROGRESS" },
      {0x2E7, "A new volume has been mounted by a file system.", "ERROR_VOLUME_MOUNTED" },
      {0x2E8, "This success level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted. The commit has now been completed.", "ERROR_RXACT_COMMITTED" },
      {0x2E9, "This indicates that a notify change request has been completed due to closing the handle which made the notify change request.", "ERROR_NOTIFY_CLEANUP" },
      {0x2EA, "An attempt was made to connect to the remote server %hs on the primary transport, but the connection failed. The computer WAS able to connect on a secondary transport. ", "ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED" },
      {0x2EB, "Page fault was a transition fault.", "ERROR_PAGE_FAULT_TRANSITION" },
      {0x2EC, "Page fault was a demand zero fault.", "ERROR_PAGE_FAULT_DEMAND_ZERO" },
      {0x2ED, "Page fault was a demand zero fault.", "ERROR_PAGE_FAULT_COPY_ON_WRITE" },
      {0x2EE, "Page fault was a demand zero fault.", "ERROR_PAGE_FAULT_GUARD_PAGE" },
      {0x2EF, "Page fault was satisfied by reading from a secondary storage device.", "ERROR_PAGE_FAULT_PAGING_FILE" },
      {0x2F0, "Cached page was locked during operation.", "ERROR_CACHE_PAGE_LOCKED" },
      {0x2F1, "Crash dump exists in paging file.", "ERROR_CRASH_DUMP" },
      {0x2F2, "Specified buffer contains all zeros.", "ERROR_BUFFER_ALL_ZEROS" },
      {0x2F3, "A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.", "ERROR_REPARSE_OBJECT" },
      {0x2F4, "The device has succeeded a query-stop and its resource requirements have changed.", "ERROR_RESOURCE_REQUIREMENTS_CHANGED" },
      {0x2F5, "The translator has translated these resources into the global space and no further translations should be performed.", "ERROR_TRANSLATION_COMPLETE" },
      {0x2F6, "A process being terminated has no threads to terminate.", "ERROR_NOTHING_TO_TERMINATE" },
      {0x2F7, "The specified process is not part of a job.", "ERROR_PROCESS_NOT_IN_JOB" },
      {0x2F8, "The specified process is part of a job.", "ERROR_PROCESS_IN_JOB" },
      {0x2F9, "The system is now ready for hibernation.", "ERROR_VOLSNAP_HIBERNATE_READY" },
      {0x2FA, "A file system or file system filter driver has successfully completed an FsFilter operation.", "ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY" },
      {0x2FB, "The specified interrupt vector was already connected.", "ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED" },
      {0x2FC, "The specified interrupt vector is still connected.", "ERROR_INTERRUPT_STILL_CONNECTED" },
      {0x2FD, "An operation is blocked waiting for an oplock.", "ERROR_WAIT_FOR_OPLOCK" },
      {0x2FE, "Debugger handled exception.", "ERROR_DBG_EXCEPTION_HANDLED" },
      {0x2FF, "Debugger continued", "ERROR_DBG_CONTINUE" },
      {0x300, "An exception occurred in a user mode callback and the kernel callback frame should be removed.", "ERROR_CALLBACK_POP_STACK" },
      {0x301, "Compression is disabled for this volume.", "ERROR_COMPRESSION_DISABLED" },
      {0x302, "The data provider cannot fetch backwards through a result set.", "ERROR_CANTFETCHBACKWARDS" },
      {0x303, "The data provider cannot scroll backwards through a result set.", "ERROR_CANTSCROLLBACKWARDS" },
      {0x304, "The data provider requires that previously fetched data is released before asking for more data.", "ERROR_ROWSNOTRELEASED" },
      {0x305, "The data provider was not able to interpret the flags set for a column binding in an accessor.", "ERROR_BAD_ACCESSOR_FLAGS" },
      {0x306, "One or more errors occurred while processing the request.", "ERROR_ERRORS_ENCOUNTERED" },
      {0x307, "The implementation is not capable of performing the request.", "ERROR_NOT_CAPABLE" },
      {0x308, "The client of a component requested an operation which is not valid given the state of the component instance.", "ERROR_REQUEST_OUT_OF_SEQUENCE" },
      {0x309, "A version number could not be parsed.", "ERROR_VERSION_PARSE_ERROR" },
      {0x30A, "The iterator's start position is invalid.", "ERROR_BADSTARTPOSITION" },
      {0x3E2, "Access to the extended attribute was denied.", "ERROR_EA_ACCESS_DENIED" },
      {0x3E3, "The I/O operation has been aborted because of either a thread exit or an application request.", "ERROR_OPERATION_ABORTED" },
      {0x3E4, "Overlapped I/O event is not in a signaled state.", "ERROR_IO_INCOMPLETE" },
      {0x3E5, "Overlapped I/O operation is in progress.", "ERROR_IO_PENDING" },
      {0x3E6, "Invalid access to memory location.", "ERROR_NOACCESS" },
      {0x3E7, "Error performing inpage operation.", "ERROR_SWAPERROR" },
      {0x3E9, "Recursion too deep; the stack overflowed.", "ERROR_STACK_OVERFLOW" },
      {0x3EA, "The window cannot act on the sent message.", "ERROR_INVALID_MESSAGE" },
      {0x3EB, "Cannot complete this function.", "ERROR_CAN_NOT_COMPLETE" },
      {0x3EC, "Invalid flags.", "ERROR_INVALID_FLAGS" },
      {0x3ED, "The volume does not contain a recognized file system. Please make sure that all required file system drivers are loaded and that the volume is not corrupted.", "ERROR_UNRECOGNIZED_VOLUME" },
      {0x3EE, "The volume for a file has been externally altered so that the opened file is no longer valid.", "ERROR_FILE_INVALID" },
      {0x3EF, "The requested operation cannot be performed in full-screen mode.", "ERROR_FULLSCREEN_MODE" },
      {0x3F0, "An attempt was made to reference a token that does not exist.", "ERROR_NO_TOKEN" },
      {0x3F1, "The configuration registry database is corrupt.", "ERROR_BADDB" },
      {0x3F2, "The configuration registry key is invalid.", "ERROR_BADKEY" },
      {0x3F3, "The configuration registry key could not be opened.", "ERROR_CANTOPEN" },
      {0x3F4, "The configuration registry key could not be read.", "ERROR_CANTREAD" },
      {0x3F5, "The configuration registry key could not be written.", "ERROR_CANTWRITE" },
      {0x3F6, "One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.", "ERROR_REGISTRY_RECOVERED" },
      {0x3F7, "The registry is corrupted. The structure of one of the files containing registry data is corrupted, or the system's memory image of the file is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.", "ERROR_REGISTRY_CORRUPT" },
      {0x3F8, "An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.", "ERROR_REGISTRY_IO_FAILED" },
      {0x3F9, "The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.", "ERROR_NOT_REGISTRY_FILE" },
      {0x3FA, "Illegal operation attempted on a registry key that has been marked for deletion.", "ERROR_KEY_DELETED" },
      {0x3FB, "System could not allocate the required space in a registry log.", "ERROR_NO_LOG_SPACE" },
      {0x3FC, "Cannot create a symbolic link in a registry key that already has subkeys or values.", "ERROR_KEY_HAS_CHILDREN" },
      {0x3FD, "Cannot create a stable subkey under a volatile parent key.", "ERROR_CHILD_MUST_BE_VOLATILE" },
      {0x3FE, "A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes.", "ERROR_NOTIFY_ENUM_DIR" },
      {0x41B, "A stop control has been sent to a service that other running services are dependent on.", "ERROR_DEPENDENT_SERVICES_RUNNING" },
      {0x41C, "The requested control is not valid for this service.", "ERROR_INVALID_SERVICE_CONTROL" },
      {0x41D, "The service did not respond to the start or control request in a timely fashion.", "ERROR_SERVICE_REQUEST_TIMEOUT" },
      {0x41E, "A thread could not be created for the service.", "ERROR_SERVICE_NO_THREAD" },
      {0x41F, "The service database is locked.", "ERROR_SERVICE_DATABASE_LOCKED" },
      {0x420, "An instance of the service is already running.", "ERROR_SERVICE_ALREADY_RUNNING" },
      {0x421, "The account name is invalid or does not exist, or the password is invalid for the account name specified.", "ERROR_INVALID_SERVICE_ACCOUNT" },
      {0x422, "The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.", "ERROR_SERVICE_DISABLED" },
      {0x423, "Circular service dependency was specified.", "ERROR_CIRCULAR_DEPENDENCY" },
      {0x424, "The specified service does not exist as an installed service.", "ERROR_SERVICE_DOES_NOT_EXIST" },
      {0x425, "The service cannot accept control messages at this time.", "ERROR_SERVICE_CANNOT_ACCEPT_CTRL" },
      {0x426, "The service has not been started.", "ERROR_SERVICE_NOT_ACTIVE" },
      {0x427, "The service process could not connect to the service controller.", "ERROR_FAILED_SERVICE_CONTROLLER_CONNECT" },
      {0x428, "An exception occurred in the service when handling the control request.", "ERROR_EXCEPTION_IN_SERVICE" },
      {0x429, "The database specified does not exist.", "ERROR_DATABASE_DOES_NOT_EXIST" },
      {0x42A, "The service has returned a service-specific error code.", "ERROR_SERVICE_SPECIFIC_ERROR" },
      {0x42B, "The process terminated unexpectedly.", "ERROR_PROCESS_ABORTED" },
      {0x42C, "The dependency service or group failed to start.", "ERROR_SERVICE_DEPENDENCY_FAIL" },
      {0x42D, "The service did not start due to a logon failure.", "ERROR_SERVICE_LOGON_FAILED" },
      {0x42E, "After starting, the service hung in a start-pending state.", "ERROR_SERVICE_START_HANG" },
      {0x42F, "The specified service database lock is invalid.", "ERROR_INVALID_SERVICE_LOCK" },
      {0x430, "The specified service has been marked for deletion.", "ERROR_SERVICE_MARKED_FOR_DELETE" },
      {0x431, "The specified service already exists.", "ERROR_SERVICE_EXISTS" },
      {0x432, "The system is currently running with the last-known-good configuration.", "ERROR_ALREADY_RUNNING_LKG" },
      {0x433, "The dependency service does not exist or has been marked for deletion.", "ERROR_SERVICE_DEPENDENCY_DELETED" },
      {0x434, "The current boot has already been accepted for use as the last-known-good control set.", "ERROR_BOOT_ALREADY_ACCEPTED" },
      {0x435, "No attempts to start the service have been made since the last boot.", "ERROR_SERVICE_NEVER_STARTED" },
      {0x436, "The name is already in use as either a service name or a service display name.", "ERROR_DUPLICATE_SERVICE_NAME" },
      {0x437, "The account specified for this service is different from the account specified for other services running in the same process.", "ERROR_DIFFERENT_SERVICE_ACCOUNT" },
      {0x438, "Failure actions can only be set for Win32 services, not for drivers.", "ERROR_CANNOT_DETECT_DRIVER_FAILURE" },
      {0x439, "This service runs in the same process as the service control manager. Therefore, the service control manager cannot take action if this service's process terminates unexpectedly.", "ERROR_CANNOT_DETECT_PROCESS_ABORT" },
      {0x43A, "No recovery program has been configured for this service.", "ERROR_NO_RECOVERY_PROGRAM" },
      {0x43B, "The executable program that this service is configured to run in does not implement the service.", "ERROR_SERVICE_NOT_IN_EXE" },
      {0x43C, "This service cannot be started in Safe Mode.", "ERROR_NOT_SAFEBOOT_SERVICE" },
      {0x44C, "The physical end of the tape has been reached.", "ERROR_END_OF_MEDIA" },
      {0x44D, "A tape access reached a filemark.", "ERROR_FILEMARK_DETECTED" },
      {0x44E, "The beginning of the tape or a partition was encountered.", "ERROR_BEGINNING_OF_MEDIA" },
      {0x44F, "A tape access reached the end of a set of files.", "ERROR_SETMARK_DETECTED" },
      {0x450, "No more data is on the tape.", "ERROR_NO_DATA_DETECTED" },
      {0x451, "Tape could not be partitioned.", "ERROR_PARTITION_FAILURE" },
      {0x452, "When accessing a new tape of a multivolume partition, the current block size is incorrect.", "ERROR_INVALID_BLOCK_LENGTH" },
      {0x453, "Tape partition information could not be found when loading a tape.", "ERROR_DEVICE_NOT_PARTITIONED" },
      {0x454, "Unable to lock the media eject mechanism.", "ERROR_UNABLE_TO_LOCK_MEDIA" },
      {0x455, "Unable to unload the media.", "ERROR_UNABLE_TO_UNLOAD_MEDIA" },
      {0x456, "The media in the drive may have changed.", "ERROR_MEDIA_CHANGED" },
      {0x457, "The I/O bus was reset.", "ERROR_BUS_RESET" },
      {0x458, "No media in drive.", "ERROR_NO_MEDIA_IN_DRIVE" },
      {0x459, "No mapping for the Unicode character exists in the target multi-byte code page.", "ERROR_NO_UNICODE_TRANSLATION" },
      {0x45A, "A dynamic link library (DLL) initialization routine failed.", "ERROR_DLL_INIT_FAILED" },
      {0x45B, "A system shutdown is in progress.", "ERROR_SHUTDOWN_IN_PROGRESS" },
      {0x45C, "Unable to abort the system shutdown because no shutdown was in progress.", "ERROR_NO_SHUTDOWN_IN_PROGRESS" },
      {0x45D, "The request could not be performed because of an I/O device error.", "ERROR_IO_DEVICE" },
      {0x45E, "No serial device was successfully initialized. The serial driver will unload.", "ERROR_SERIAL_NO_DEVICE" },
      {0x45F, "Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.", "ERROR_IRQ_BUSY" },
      {0x460, "A serial I/O operation was completed by another write to the serial port. (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)", "ERROR_MORE_WRITES" },
      {0x461, "A serial I/O operation completed because the timeout period expired. (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)", "ERROR_COUNTER_TIMEOUT" },
      {0x462, "No ID address mark was found on the floppy disk.", "ERROR_FLOPPY_ID_MARK_NOT_FOUND" },
      {0x463, "Mismatch between the floppy disk sector ID field and the floppy disk controller track address.", "ERROR_FLOPPY_WRONG_CYLINDER" },
      {0x464, "The floppy disk controller reported an error that is not recognized by the floppy disk driver.", "ERROR_FLOPPY_UNKNOWN_ERROR" },
      {0x465, "The floppy disk controller returned inconsistent results in its registers.", "ERROR_FLOPPY_BAD_REGISTERS" },
      {0x466, "While accessing the hard disk, a recalibrate operation failed, even after retries.", "ERROR_DISK_RECALIBRATE_FAILED" },
      {0x467, "While accessing the hard disk, a disk operation failed even after retries.", "ERROR_DISK_OPERATION_FAILED" },
      {0x468, "While accessing the hard disk, a disk controller reset was needed, but even that failed.", "ERROR_DISK_RESET_FAILED" },
      {0x469, "Physical end of tape encountered.", "ERROR_EOM_OVERFLOW" },
      {0x46A, "Not enough server storage is available to process this command.", "ERROR_NOT_ENOUGH_SERVER_MEMORY" },
      {0x46B, "A potential deadlock condition has been detected.", "ERROR_POSSIBLE_DEADLOCK" },
      {0x46C, "The base address or the file offset specified does not have the proper alignment.", "ERROR_MAPPED_ALIGNMENT" },
      {0x474, "An attempt to change the system power state was vetoed by another application or driver.", "ERROR_SET_POWER_STATE_VETOED" },
      {0x475, "The system BIOS failed an attempt to change the system power state.", "ERROR_SET_POWER_STATE_FAILED" },
      {0x476, "An attempt was made to create more links on a file than the file system supports.", "ERROR_TOO_MANY_LINKS" },
      {0x47E, "The specified program requires a newer version of Windows.", "ERROR_OLD_WIN_VERSION" },
      {0x47F, "The specified program is not a Windows or MS-DOS program.", "ERROR_APP_WRONG_OS" },
      {0x480, "Cannot start more than one instance of the specified program.", "ERROR_SINGLE_INSTANCE_APP" },
      {0x481, "The specified program was written for an earlier version of Windows.", "ERROR_RMODE_APP" },
      {0x482, "One of the library files needed to run this application is damaged.", "ERROR_INVALID_DLL" },
      {0x483, "No application is associated with the specified file for this operation.", "ERROR_NO_ASSOCIATION" },
      {0x484, "An error occurred in sending the command to the application.", "ERROR_DDE_FAIL" },
      {0x485, "One of the library files needed to run this application cannot be found.", "ERROR_DLL_NOT_FOUND" },
      {0x486, "The current process has used all of its system allowance of handles for Window Manager objects.", "ERROR_NO_MORE_USER_HANDLES" },
      {0x487, "The message can be used only with synchronous operations.", "ERROR_MESSAGE_SYNC_ONLY" },
      {0x488, "The indicated source element has no media.", "ERROR_SOURCE_ELEMENT_EMPTY" },
      {0x489, "The indicated destination element already contains media.", "ERROR_DESTINATION_ELEMENT_FULL" },
      {0x48A, "The indicated element does not exist.", "ERROR_ILLEGAL_ELEMENT_ADDRESS" },
      {0x48B, "The indicated element is part of a magazine that is not present.", "ERROR_MAGAZINE_NOT_PRESENT" },
      {0x48C, "The indicated device requires reinitialization due to hardware errors.", "ERROR_DEVICE_REINITIALIZATION_NEEDED" },
      {0x48D, "The device has indicated that cleaning is required before further operations are attempted.", "ERROR_DEVICE_REQUIRES_CLEANING" },
      {0x48E, "The device has indicated that its door is open.", "ERROR_DEVICE_DOOR_OPEN" },
      {0x48F, "The device is not connected.", "ERROR_DEVICE_NOT_CONNECTED" },
      {0x490, "Element not found.", "ERROR_NOT_FOUND" },
      {0x491, "There was no match for the specified key in the index.", "ERROR_NO_MATCH" },
      {0x492, "The property set specified does not exist on the object.", "ERROR_SET_NOT_FOUND" },
      {0x493, "The point passed to GetMouseMovePointsEx is not in the buffer.", "ERROR_POINT_NOT_FOUND" },
      {0x494, "The tracking (workstation) service is not running.", "ERROR_NO_TRACKING_SERVICE" },
      {0x495, "The Volume ID could not be found.", "ERROR_NO_VOLUME_ID" },
      {0x497, "Unable to remove the file to be replaced.", "ERROR_UNABLE_TO_REMOVE_REPLACED" },
      {0x498, "Unable to move the replacement file to the file to be replaced. The file to be replaced has retained its original name.", "ERROR_UNABLE_TO_MOVE_REPLACEMENT" },
      {0x499, "Unable to move the replacement file to the file to be replaced. The file to be replaced has been renamed using the backup name.", "ERROR_UNABLE_TO_MOVE_REPLACEMENT_2" },
      {0x49A, "The volume change journal is being deleted.", "ERROR_JOURNAL_DELETE_IN_PROGRESS" },
      {0x49B, "The volume change journal is not active.", "ERROR_JOURNAL_NOT_ACTIVE" },
      {0x49C, "A file was found, but it may not be the correct file.", "ERROR_POTENTIAL_FILE_FOUND" },
      {0x49D, "The journal entry has been deleted from the journal.", "ERROR_JOURNAL_ENTRY_DELETED" },
      {0x4B0, "The specified device name is invalid.", "ERROR_BAD_DEVICE" },
      {0x4B1, "The device is not currently connected but it is a remembered connection.", "ERROR_CONNECTION_UNAVAIL" },
      {0x4B2, "The local device name has a remembered connection to another network resource.", "ERROR_DEVICE_ALREADY_REMEMBERED" },
      {0x4B3, "The network path was either typed incorrectly, does not exist, or the network provider is not currently available. Please try retyping the path or contact your network administrator.", "ERROR_NO_NET_OR_BAD_PATH" },
      {0x4B4, "The specified network provider name is invalid.", "ERROR_BAD_PROVIDER" },
      {0x4B5, "Unable to open the network connection profile.", "ERROR_CANNOT_OPEN_PROFILE" },
      {0x4B6, "The network connection profile is corrupted.", "ERROR_BAD_PROFILE" },
      {0x4B7, "Cannot enumerate a noncontainer.", "ERROR_NOT_CONTAINER" },
      {0x4B8, "An extended error has occurred.", "ERROR_EXTENDED_ERROR" },
      {0x4B9, "The format of the specified group name is invalid.", "ERROR_INVALID_GROUPNAME" },
      {0x4BA, "The format of the specified computer name is invalid.", "ERROR_INVALID_COMPUTERNAME" },
      {0x4BB, "The format of the specified event name is invalid.", "ERROR_INVALID_EVENTNAME" },
      {0x4BC, "The format of the specified domain name is invalid.", "ERROR_INVALID_DOMAINNAME" },
      {0x4BD, "The format of the specified service name is invalid.", "ERROR_INVALID_SERVICENAME" },
      {0x4BE, "The format of the specified network name is invalid.", "ERROR_INVALID_NETNAME" },
      {0x4BF, "The format of the specified share name is invalid.", "ERROR_INVALID_SHARENAME" },
      {0x4C0, "The format of the specified password is invalid.", "ERROR_INVALID_PASSWORDNAME" },
      {0x4C1, "The format of the specified message name is invalid.", "ERROR_INVALID_MESSAGENAME" },
      {0x4C2, "The format of the specified message destination is invalid.", "ERROR_INVALID_MESSAGEDEST" },
      {0x4C3, "Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or shared resource and try again.", "ERROR_SESSION_CREDENTIAL_CONFLICT" },
      {0x4C4, "An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.", "ERROR_REMOTE_SESSION_LIMIT_EXCEEDED" },
      {0x4C5, "The workgroup or domain name is already in use by another computer on the network.", "ERROR_DUP_DOMAINNAME" },
      {0x4C6, "The network is not present or not started.", "ERROR_NO_NETWORK" },
      {0x4C7, "The operation was canceled by the user.", "ERROR_CANCELLED" },
      {0x4C8, "The requested operation cannot be performed on a file with a user-mapped section open.", "ERROR_USER_MAPPED_FILE" },
      {0x4C9, "The remote system refused the network connection.", "ERROR_CONNECTION_REFUSED" },
      {0x4CA, "The network connection was gracefully closed.", "ERROR_GRACEFUL_DISCONNECT" },
      {0x4CB, "The network transport endpoint already has an address associated with it.", "ERROR_ADDRESS_ALREADY_ASSOCIATED" },
      {0x4CC, "An address has not yet been associated with the network endpoint.", "ERROR_ADDRESS_NOT_ASSOCIATED" },
      {0x4CD, "An operation was attempted on a nonexistent network connection.", "ERROR_CONNECTION_INVALID" },
      {0x4CE, "An invalid operation was attempted on an active network connection.", "ERROR_CONNECTION_ACTIVE" },
      {0x4CF, "The network location cannot be reached. For information about network troubleshooting, see Windows Help.", "ERROR_NETWORK_UNREACHABLE" },
      {0x4D0, "The network location cannot be reached. For information about network troubleshooting, see Windows Help.", "ERROR_HOST_UNREACHABLE" },
      {0x4D1, "The network location cannot be reached. For information about network troubleshooting, see Windows Help.", "ERROR_PROTOCOL_UNREACHABLE" },
      {0x4D2, "No service is operating at the destination network endpoint on the remote system.", "ERROR_PORT_UNREACHABLE" },
      {0x4D3, "The request was aborted.", "ERROR_REQUEST_ABORTED" },
      {0x4D4, "The network connection was aborted by the local system.", "ERROR_CONNECTION_ABORTED" },
      {0x4D5, "The operation could not be completed. A retry should be performed.", "ERROR_RETRY" },
      {0x4D6, "A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.", "ERROR_CONNECTION_COUNT_LIMIT" },
      {0x4D7, "Attempting to log in during an unauthorized time of day for this account.", "ERROR_LOGIN_TIME_RESTRICTION" },
      {0x4D8, "The account is not authorized to log in from this station.", "ERROR_LOGIN_WKSTA_RESTRICTION" },
      {0x4D9, "The network address could not be used for the operation requested.", "ERROR_INCORRECT_ADDRESS" },
      {0x4DA, "The service is already registered.", "ERROR_ALREADY_REGISTERED" },
      {0x4DB, "The specified service does not exist.", "ERROR_SERVICE_NOT_FOUND" },
      {0x4DC, "The operation being requested was not performed because the user has not been authenticated.", "ERROR_NOT_AUTHENTICATED" },
      {0x4DD, "The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist.", "ERROR_NOT_LOGGED_ON" },
      {0x4DE, "Continue with work in progress.", "ERROR_CONTINUE" },
      {0x4DF, "An attempt was made to perform an initialization operation when initialization has already been completed.", "ERROR_ALREADY_INITIALIZED" },
      {0x4E0, "No more local devices.", "ERROR_NO_MORE_DEVICES" },
      {0x4E1, "The specified site does not exist.", "ERROR_NO_SUCH_SITE" },
      {0x4E2, "A domain controller with the specified name already exists.", "ERROR_DOMAIN_CONTROLLER_EXISTS" },
      {0x4E3, "This operation is supported only when you are connected to the server.", "ERROR_ONLY_IF_CONNECTED" },
      {0x4E4, "The group policy framework should call the extension even if there are no changes.", "ERROR_OVERRIDE_NOCHANGES" },
      {0x4E5, "The specified user does not have a valid profile.", "ERROR_BAD_USER_PROFILE" },
      {0x4E6, "This operation is not supported on a computer running Windows Server 2003 for Small Business Server.", "ERROR_NOT_SUPPORTED_ON_SBS" },
      {0x4E7, "The server machine is shutting down.", "ERROR_SERVER_SHUTDOWN_IN_PROGRESS" },
      {0x4E8, "The remote system is not available. For information about network troubleshooting, see Windows Help.", "ERROR_HOST_DOWN" },
      {0x4E9, "The security identifier provided is not from an account domain.", "ERROR_NON_ACCOUNT_SID" },
      {0x4EA, "The security identifier provided does not have a domain component.", "ERROR_NON_DOMAIN_SID" },
      {0x4EB, "AppHelp dialog canceled thus preventing the application from starting.", "ERROR_APPHELP_BLOCK" },
      {0x4EC, "Windows cannot open this program because it has been prevented by a software restriction policy. For more information, open Event Viewer or contact your system administrator.", "ERROR_ACCESS_DISABLED_BY_POLICY" },
      {0x4ED, "A program attempt to use an invalid register value. Normally caused by an uninitialized register. This error is Itanium specific.", "ERROR_REG_NAT_CONSUMPTION" },
      {0x4EE, "The share is currently offline or does not exist.", "ERROR_CSCSHARE_OFFLINE" },
      {0x4EF, "The kerberos protocol encountered an error while validating the KDC certificate during smartcard logon.", "ERROR_PKINIT_FAILURE" },
      {0x4F0, "The kerberos protocol encountered an error while attempting to utilize the smartcard subsystem.", "ERROR_SMARTCARD_SUBSYSTEM_FAILURE" },
      {0x4F1, "The system detected a possible attempt to compromise security. Please ensure that you can contact the server that authenticated you.", "ERROR_DOWNGRADE_DETECTED" },
      {0x4F2, "The smartcard certificate used for authentication has been revoked. Please contact your system administrator. There may be additional information in the event log.", "SEC_E_SMARTCARD_CERT_REVOKED" },
      {0x4F3, "An untrusted certificate authority was detected while processing the smartcard certificate used for authentication. Please contact your system administrator.", "SEC_E_ISSUING_CA_UNTRUSTED" },
      {0x4F4, "The revocation status of the smartcard certificate used for authentication could not be determined. Please contact your system administrator.", "SEC_E_REVOCATION_OFFLINE_C" },
      {0x4F5, "The smartcard certificate used for authentication was not trusted. Please contact your system administrator.", "SEC_E_PKINIT_CLIENT_FAILUR" },
      {0x4F6, "The smartcard certificate used for authentication has expired. Please contact your system administrator.", "SEC_E_SMARTCARD_CERT_EXPIRED" },
      {0x4F7, "The machine is locked and cannot be shut down without the force option.", "ERROR_MACHINE_LOCKED" },
      {0x4F9, "An application-defined callback gave invalid data when called.", "ERROR_CALLBACK_SUPPLIED_INVALID_DATA" },
      {0x4FA, "The group policy framework should call the extension in the synchronous foreground policy refresh.", "ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED" },
      {0x4FB, "This driver has been blocked from loading.", "ERROR_DRIVER_BLOCKED" },
      {0x4FC, "A dynamic link library (DLL) referenced a module that was neither a DLL nor the process's executable image.", "ERROR_INVALID_IMPORT_OF_NON_DLL" },
      {0x4FD, "Windows cannot open this program since it has been disabled.", "ERROR_ACCESS_DISABLED_WEBBLADE" },
      {0x4FE, "Windows cannot open this program because the license enforcement system has been tampered with or become corrupted.", "ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER" },
      {0x4FF, "A transaction recovery failed.", "ERROR_RECOVERY_FAILURE" },
      {0x500, "The current thread has already been converted to a fiber.", "ERROR_ALREADY_FIBER" },
      {0x501, "The current thread has already been converted from a fiber.", "ERROR_ALREADY_THREAD" },
      {0x502, "The system detected an overrun of a stack-based buffer in this application. This overrun could potentially allow a malicious user to gain control of this application.", "ERROR_STACK_BUFFER_OVERRUN" },
      {0x503, "Data present in one of the parameters is more than the function can operate on.", "ERROR_PARAMETER_QUOTA_EXCEEDED" },
      {0x504, "An attempt to do an operation on a debug object failed because the object is in the process of being deleted.", "ERROR_DEBUGGER_INACTIVE" },
      {0x505, "An attempt to delay-load a .dll or get a function address in a delay-loaded .dll failed.", "ERROR_DELAY_LOAD_FAILED" },
      {0x506, "%1 is a 16-bit application. You do not have permissions to execute 16-bit applications. Check your permissions with your system administrator.", "ERROR_VDM_DISALLOWED" },
      {0x507, "Insufficient information exists to identify the cause of failure.", "ERROR_UNIDENTIFIED_ERROR" },
      {0x508, "An invalid budget or period parameter was specified.", "ERROR_INVALID_BANDWIDTH_PARAMETERS" },
      {0x509, "An attempt was made to join a thread to a reserve whose affinity did not intersect the reserve affinity or an attempt was made to associate a process with a reserve whose affinity did not intersect the reserve affinity.", "ERROR_AFFINITY_NOT_COMPATIBLE" },
      {0x50A, "An attempt was made to join a thread to a reserve which was already joined to another reserve.", "ERROR_THREAD_ALREADY_IN_RESERVE" },
      {0x50B, "An attempt was made to disjoin a thread from a reserve, but the thread was not joined to the reserve.", "ERROR_THREAD_NOT_IN_RESERVE" },
      {0x50C, "An attempt was made to disjoin a thread from a reserve whose process is associated with a reserve.", "ERROR_THREAD_PROCESS_IN_RESERVE" },
      {0x50D, "An attempt was made to associate a process with a reserve that was already associated with a reserve.", "ERROR_PROCESS_ALREADY_IN_RESERVE" },
      {0x50E, "An attempt was made to disassociate a process from a reserve, but the process did not have an associated reserve.", "ERROR_PROCESS_NOT_IN_RESERVE" },
      {0x50F, "An attempt was made to associate a process with a reserve, but the process contained thread joined to a reserve.", "ERROR_PROCESS_THREADS_IN_RESERVE" },
      {0x510, "An attempt was made to set the affinity of a thread or a process, but the thread or process was joined or associated with a reserve.", "ERROR_AFFINITY_NOT_SET_IN_RESERVE" },
      {0x511, "An operation attempted to exceed an implementation-defined limit.", "ERROR_IMPLEMENTATION_LIMIT" },
      {0x512, "The requested object is for internal DS operations only.", "ERROR_DS_CACHE_ONLY" },
      {0x514, "Not all privileges referenced are assigned to the caller.", "ERROR_NOT_ALL_ASSIGNED" },
      {0x515, "Some mapping between account names and security IDs was not done.", "ERROR_SOME_NOT_MAPPED" },
      {0x516, "No system quota limits are specifically set for this account.", "ERROR_NO_QUOTAS_FOR_ACCOUNT" },
      {0x517, "No encryption key is available. A well-known encryption key was returned.", "ERROR_LOCAL_USER_SESSION_KEY" },
      {0x518, "The password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.", "ERROR_NULL_LM_PASSWORD" },
      {0x519, "The revision level is unknown.", "ERROR_UNKNOWN_REVISION" },
      {0x51A, "Indicates two revision levels are incompatible.", "ERROR_REVISION_MISMATCH" },
      {0x51B, "This security ID may not be assigned as the owner of this object.", "ERROR_INVALID_OWNER" },
      {0x51C, "This security ID may not be assigned as the primary group of an object.", "ERROR_INVALID_PRIMARY_GROUP" },
      {0x51D, "An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.", "ERROR_NO_IMPERSONATION_TOKEN" },
      {0x51E, "The group may not be disabled.", "ERROR_CANT_DISABLE_MANDATORY" },
      {0x51F, "There are currently no logon servers available to service the logon request.", "ERROR_NO_LOGON_SERVERS" },
      {0x520, "A specified logon session does not exist. It may already have been terminated.", "ERROR_NO_SUCH_LOGON_SESSION" },
      {0x521, "A specified privilege does not exist.", "ERROR_NO_SUCH_PRIVILEGE" },
      {0x522, "A required privilege is not held by the client.", "ERROR_PRIVILEGE_NOT_HELD" },
      {0x523, "The name provided is not a properly formed account name.", "ERROR_INVALID_ACCOUNT_NAME" },
      {0x524, "The specified user already exists.", "ERROR_USER_EXISTS" },
      {0x525, "The specified user does not exist.", "ERROR_NO_SUCH_USER" },
      {0x526, "The specified group already exists.", "ERROR_GROUP_EXISTS" },
      {0x527, "The specified group does not exist.", "ERROR_NO_SUCH_GROUP" },
      {0x528, "Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.", "ERROR_MEMBER_IN_GROUP" },
      {0x529, "The specified user account is not a member of the specified group account.", "ERROR_MEMBER_NOT_IN_GROUP" },
      {0x52A, "The last remaining administration account cannot be disabled or deleted.", "ERROR_LAST_ADMIN" },
      {0x52B, "Unable to update the password. The value provided as the current password is incorrect.", "ERROR_WRONG_PASSWORD" },
      {0x52C, "Unable to update the password. The value provided for the new password contains values that are not allowed in passwords.", "ERROR_ILL_FORMED_PASSWORD" },
      {0x52D, "Unable to update the password. The value provided for the new password does not meet the length, complexity, or history requirement of the domain.", "ERROR_PASSWORD_RESTRICTION" },
      {0x52E, "Logon failure: unknown user name or bad password.", "ERROR_LOGON_FAILURE" },
      {0x52F, "Logon failure: user account restriction. Possible reasons are blank passwords not allowed, logon hour restrictions, or a policy restriction has been enforced.", "ERROR_ACCOUNT_RESTRICTION" },
      {0x530, "Logon failure: account logon time restriction violation.", "ERROR_INVALID_LOGON_HOURS" },
      {0x531, "Logon failure: user not allowed to log on to this computer.", "ERROR_INVALID_WORKSTATION" },
      {0x532, "Logon failure: the specified account password has expired.", "ERROR_PASSWORD_EXPIRED" },
      {0x533, "Logon failure: account currently disabled.", "ERROR_ACCOUNT_DISABLED" },
      {0x534, "No mapping between account names and security IDs was done.", "ERROR_NONE_MAPPED" },
      {0x535, "Too many local user identifiers (LUIDs) were requested at one time.", "ERROR_TOO_MANY_LUIDS_REQUESTED" },
      {0x536, "No more local user identifiers (LUIDs) are available.", "ERROR_LUIDS_EXHAUSTED" },
      {0x537, "The subauthority part of a security ID is invalid for this particular use.", "ERROR_INVALID_SUB_AUTHORITY" },
      {0x538, "The access control list (ACL) structure is invalid.", "ERROR_INVALID_ACL" },
      {0x539, "The security ID structure is invalid.", "ERROR_INVALID_SID" },
      {0x53A, "The security descriptor structure is invalid.", "ERROR_INVALID_SECURITY_DESCR" },
      {0x53C, "The inherited access control list (ACL) or access control entry (ACE) could not be built.", "ERROR_BAD_INHERITANCE_ACL" },
      {0x53D, "The server is currently disabled.", "ERROR_SERVER_DISABLED" },
      {0x53E, "The server is currently enabled.", "ERROR_SERVER_NOT_DISABLED" },
      {0x53F, "The value provided was an invalid value for an identifier authority.", "ERROR_INVALID_ID_AUTHORITY" },
      {0x540, "No more memory is available for security information updates.", "ERROR_ALLOTTED_SPACE_EXCEEDED" },
      {0x541, "The specified attributes are invalid, or incompatible with the attributes for the group as a whole.", "ERROR_INVALID_GROUP_ATTRIBUTES" },
      {0x542, "Either a required impersonation level was not provided, or the provided impersonation level is invalid.", "ERROR_BAD_IMPERSONATION_LEVEL" },
      {0x543, "Cannot open an anonymous level security token.", "ERROR_CANT_OPEN_ANONYMOUS" },
      {0x544, "The validation information class requested was invalid.", "ERROR_BAD_VALIDATION_CLASS" },
      {0x545, "The type of the token is inappropriate for its attempted use.", "ERROR_BAD_TOKEN_TYPE" },
      {0x546, "Unable to perform a security operation on an object that has no associated security.", "ERROR_NO_SECURITY_ON_OBJECT" },
      {0x547, "Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.", "ERROR_CANT_ACCESS_DOMAIN_INFO" },
      {0x548, "The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.", "ERROR_INVALID_SERVER_STATE" },
      {0x549, "The domain was in the wrong state to perform the security operation.", "ERROR_INVALID_DOMAIN_STATE" },
      {0x54A, "This operation is only allowed for the Primary Domain Controller of the domain.", "ERROR_INVALID_DOMAIN_ROLE" },
      {0x54B, "The specified domain either does not exist or could not be contacted.", "ERROR_NO_SUCH_DOMAIN" },
      {0x54C, "The specified domain already exists.", "ERROR_DOMAIN_EXISTS" },
      {0x54D, "An attempt was made to exceed the limit on the number of domains per server.", "ERROR_DOMAIN_LIMIT_EXCEEDED" },
      {0x54E, "Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.", "ERROR_INTERNAL_DB_CORRUPTION" },
      {0x54F, "An internal error occurred.", "ERROR_INTERNAL_ERROR" },
      {0x550, "Generic access types were contained in an access mask which should already be mapped to nongeneric types.", "ERROR_GENERIC_NOT_MAPPED" },
      {0x551, "A security descriptor is not in the right format (absolute or self-relative).", "ERROR_BAD_DESCRIPTOR_FORMAT" },
      {0x552, "The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.", "ERROR_NOT_LOGON_PROCESS" },
      {0x553, "Cannot start a new logon session with an ID that is already in use.", "ERROR_LOGON_SESSION_EXISTS" },
      {0x554, "A specified authentication package is unknown.", "ERROR_NO_SUCH_PACKAGE" },
      {0x555, "The logon session is not in a state that is consistent with the requested operation.", "ERROR_BAD_LOGON_SESSION_STATE" },
      {0x556, "The logon session ID is already in use.", "ERROR_LOGON_SESSION_COLLISION" },
      {0x557, "A logon request contained an invalid logon type value.", "ERROR_INVALID_LOGON_TYPE" },
      {0x558, "Unable to impersonate using a named pipe until data has been read from that pipe.", "ERROR_CANNOT_IMPERSONATE" },
      {0x559, "The transaction state of a registry subtree is incompatible with the requested operation.", "ERROR_RXACT_INVALID_STATE" },
      {0x55A, "An internal security database corruption has been encountered.", "ERROR_RXACT_COMMIT_FAILURE" },
      {0x55B, "Cannot perform this operation on built-in accounts.", "ERROR_SPECIAL_ACCOUNT" },
      {0x55C, "Cannot perform this operation on this built-in special group.", "ERROR_SPECIAL_GROUP" },
      {0x55D, "Cannot perform this operation on this built-in special user.", "ERROR_SPECIAL_USER" },
      {0x55E, "The user cannot be removed from a group because the group is currently the user's primary group.", "ERROR_MEMBERS_PRIMARY_GROUP" },
      {0x55F, "The token is already in use as a primary token.", "ERROR_TOKEN_ALREADY_IN_USE" },
      {0x560, "The specified local group does not exist.", "ERROR_NO_SUCH_ALIAS" },
      {0x561, "The specified account name is not a member of the local group.", "ERROR_MEMBER_NOT_IN_ALIAS" },
      {0x562, "The specified account name is already a member of the local group.", "ERROR_MEMBER_IN_ALIAS" },
      {0x563, "The specified local group already exists.", "ERROR_ALIAS_EXISTS" },
      {0x564, "Logon failure: the user has not been granted the requested logon type at this computer.", "ERROR_LOGON_NOT_GRANTED" },
      {0x565, "The maximum number of secrets that may be stored in a single system has been exceeded.", "ERROR_TOO_MANY_SECRETS" },
      {0x566, "The length of a secret exceeds the maximum length allowed.", "ERROR_SECRET_TOO_LONG" },
      {0x567, "The local security authority database contains an internal inconsistency.", "ERROR_INTERNAL_DB_ERROR" },
      {0x568, "During a logon attempt, the user's security context accumulated too many security IDs.", "ERROR_TOO_MANY_CONTEXT_IDS" },
      {0x569, "Logon failure: the user has not been granted the requested logon type at this computer.", "ERROR_LOGON_TYPE_NOT_GRANTED" },
      {0x56A, "A cross-encrypted password is necessary to change a user password.", "ERROR_NT_CROSS_ENCRYPTION_REQUIRED" },
      {0x56B, "A new member could not be added to or removed from the local group because the member does not exist.", "ERROR_NO_SUCH_MEMBER" },
      {0x56C, "A new member could not be added to a local group because the member has the wrong account type.", "ERROR_INVALID_MEMBER" },
      {0x56D, "Too many security IDs have been specified.", "ERROR_TOO_MANY_SIDS" },
      {0x56E, "A cross-encrypted password is necessary to change this user password.", "ERROR_LM_CROSS_ENCRYPTION_REQUIRED" },
      {0x56F, "Indicates an ACL contains no inheritable components.", "ERROR_NO_INHERITANCE" },
      {0x570, "The file or directory is corrupted and unreadable.", "ERROR_FILE_CORRUPT" },
      {0x571, "The disk structure is corrupted and unreadable.", "ERROR_DISK_CORRUPT" },
      {0x572, "There is no user session key for the specified logon session.", "ERROR_NO_USER_SESSION_KEY" },
      {0x573, "The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.", "ERROR_LICENSE_QUOTA_EXCEEDED" },
      {0x574, "Logon Failure: The target account name is incorrect.", "ERROR_WRONG_TARGET_NAME" },
      {0x575, "Mutual Authentication failed. The server's password is out of date at the domain controller.", "ERROR_MUTUAL_AUTH_FAILED" },
      {0x576, "There is a time and/or date difference between the client and server.", "ERROR_TIME_SKEW" },
      {0x577, "This operation cannot be performed on the current domain.", "ERROR_CURRENT_DOMAIN_NOT_ALLOWED" },
      {0x578, "Invalid window handle.", "ERROR_INVALID_WINDOW_HANDLE" },
      {0x579, "Invalid menu handle.", "ERROR_INVALID_MENU_HANDLE" },
      {0x57A, "Invalid cursor handle.", "ERROR_INVALID_CURSOR_HANDLE" },
      {0x57B, "Invalid accelerator table handle.", "ERROR_INVALID_ACCEL_HANDLE" },
      {0x57C, "Invalid hook handle.", "ERROR_INVALID_HOOK_HANDLE" },
      {0x57D, "Invalid handle to a multiple-window position structure.", "ERROR_INVALID_DWP_HANDLE" },
      {0x57E, "Cannot create a top-level child window.", "ERROR_TLW_WITH_WSCHILD" },
      {0x57F, "Cannot find window class.", "ERROR_CANNOT_FIND_WND_CLASS" },
      {0x580, "Invalid window; it belongs to other thread.", "ERROR_WINDOW_OF_OTHER_THREAD" },
      {0x581, "Hot key is already registered.", "ERROR_HOTKEY_ALREADY_REGISTERED" },
      {0x582, "Class already exists.", "ERROR_CLASS_ALREADY_EXISTS" },
      {0x583, "Class does not exist.", "ERROR_CLASS_DOES_NOT_EXIST" },
      {0x584, "Class still has open windows.", "ERROR_CLASS_HAS_WINDOWS" },
      {0x585, "Invalid index.", "ERROR_INVALID_INDEX" },
      {0x586, "Invalid icon handle.", "ERROR_INVALID_ICON_HANDLE" },
      {0x587, "Using private DIALOG window words.", "ERROR_PRIVATE_DIALOG_INDEX" },
      {0x588, "The list box identifier was not found.", "ERROR_LISTBOX_ID_NOT_FOUND" },
      {0x589, "No wildcards were found.", "ERROR_NO_WILDCARD_CHARACTERS" },
      {0x58A, "Thread does not have a clipboard open.", "ERROR_CLIPBOARD_NOT_OPEN" },
      {0x58B, "Hot key is not registered.", "ERROR_HOTKEY_NOT_REGISTERED" },
      {0x58C, "The window is not a valid dialog window.", "ERROR_WINDOW_NOT_DIALOG" },
      {0x58D, "Control ID not found.", "ERROR_CONTROL_ID_NOT_FOUND" },
      {0x58E, "Invalid message for a combo box because it does not have an edit control.", "ERROR_INVALID_COMBOBOX_MESSAGE" },
      {0x58F, "The window is not a combo box.", "ERROR_WINDOW_NOT_COMBOBOX" },
      {0x590, "Height must be less than 256.", "ERROR_INVALID_EDIT_HEIGHT" },
      {0x591, "Invalid device context (DC) handle.", "ERROR_DC_NOT_FOUND" },
      {0x592, "Invalid hook procedure type.", "ERROR_INVALID_HOOK_FILTER" },
      {0x593, "Invalid hook procedure.", "ERROR_INVALID_FILTER_PROC" },
      {0x594, "Cannot set nonlocal hook without a module handle.", "ERROR_HOOK_NEEDS_HMOD" },
      {0x595, "This hook procedure can only be set globally.", "ERROR_GLOBAL_ONLY_HOOK" },
      {0x596, "The journal hook procedure is already installed.", "ERROR_JOURNAL_HOOK_SET" },
      {0x597, "The hook procedure is not installed.", "ERROR_HOOK_NOT_INSTALLED" },
      {0x598, "Invalid message for single-selection list box.", "ERROR_INVALID_LB_MESSAGE" },
      {0x599, "LB_SETCOUNT sent to non-lazy list box.", "ERROR_SETCOUNT_ON_BAD_LB" },
      {0x59A, "This list box does not support tab stops.", "ERROR_LB_WITHOUT_TABSTOPS" },
      {0x59B, "Cannot destroy object created by another thread.", "ERROR_DESTROY_OBJECT_OF_OTHER_THREAD" },
      {0x59C, "Child windows cannot have menus.", "ERROR_CHILD_WINDOW_MENU" },
      {0x59D, "The window does not have a system menu.", "ERROR_NO_SYSTEM_MENU" },
      {0x59E, "Invalid message box style.", "ERROR_INVALID_MSGBOX_STYLE" },
      {0x59F, "Invalid system-wide (SPI_*) parameter.", "ERROR_INVALID_SPI_VALUE" },
      {0x5A0, "Screen already locked.", "ERROR_SCREEN_ALREADY_LOCKED" },
      {0x5A1, "All handles to windows in a multiple-window position structure must have the same parent.", "ERROR_HWNDS_HAVE_DIFF_PARENT" },
      {0x5A2, "The window is not a child window.", "ERROR_NOT_CHILD_WINDOW" },
      {0x5A3, "Invalid GW_* command.", "ERROR_INVALID_GW_COMMAND" },
      {0x5A4, "Invalid thread identifier.", "ERROR_INVALID_THREAD_ID" },
      {0x5A5, "Cannot process a message from a window that is not a multiple document interface (MDI) window.", "ERROR_NON_MDICHILD_WINDOW" },
      {0x5A6, "Popup menu already active.", "ERROR_POPUP_ALREADY_ACTIVE" },
      {0x5A7, "The window does not have scroll bars.", "ERROR_NO_SCROLLBARS" },
      {0x5A8, "Scroll bar range cannot be greater than MAXLONG.", "ERROR_INVALID_SCROLLBAR_RANGE" },
      {0x5A9, "Cannot show or remove the window in the way specified.", "ERROR_INVALID_SHOWWIN_COMMAND" },
      {0x5AA, "Insufficient system resources exist to complete the requested service.", "ERROR_NO_SYSTEM_RESOURCES" },
      {0x5AB, "Insufficient system resources exist to complete the requested service.", "ERROR_NONPAGED_SYSTEM_RESOURCES" },
      {0x5AC, "Insufficient system resources exist to complete the requested service.", "ERROR_PAGED_SYSTEM_RESOURCES" },
      {0x5AD, "Insufficient quota to complete the requested service.", "ERROR_WORKING_SET_QUOTA" },
      {0x5AE, "Insufficient quota to complete the requested service.", "ERROR_PAGEFILE_QUOTA" },
      {0x5AF, "The paging file is too small for this operation to complete.", "ERROR_COMMITMENT_LIMIT" },
      {0x5B0, "A menu item was not found.", "ERROR_MENU_ITEM_NOT_FOUND" },
      {0x5B1, "Invalid keyboard layout handle.", "ERROR_INVALID_KEYBOARD_HANDLE" },
      {0x5B2, "Hook type not allowed.", "ERROR_HOOK_TYPE_NOT_ALLOWED" },
      {0x5B3, "This operation requires an interactive window station.", "ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION" },
      {0x5B4, "This operation returned because the timeout period expired.", "ERROR_TIMEOUT" },
      {0x5B5, "Invalid monitor handle.", "ERROR_INVALID_MONITOR_HANDLE" },
      {0x5DC, "The event log file is corrupted.", "ERROR_EVENTLOG_FILE_CORRUPT" },
      {0x5DD, "No event log file could be opened, so the event logging service did not start.", "ERROR_EVENTLOG_CANT_START" },
      {0x5DE, "The event log file is full.", "ERROR_LOG_FILE_FULL" },
      {0x5DF, "The event log file has changed between read operations.", "ERROR_EVENTLOG_FILE_CHANGED" },
      {0x641, "The Windows Installer service could not be accessed. This can occur if you are running Windows in safe mode, or if the Windows Installer is not correctly installed. Contact your support personnel for assistance.", "ERROR_INSTALL_SERVICE_FAILURE" },
      {0x642, "User cancelled installation.", "ERROR_INSTALL_USEREXIT" },
      {0x643, "Fatal error during installation.", "ERROR_INSTALL_FAILURE" },
      {0x644, "Installation suspended, incomplete.", "ERROR_INSTALL_SUSPEND" },
      {0x645, "This action is only valid for products that are currently installed.", "ERROR_UNKNOWN_PRODUCT" },
      {0x646, "Feature ID not registered.", "ERROR_UNKNOWN_FEATURE" },
      {0x647, "Component ID not registered.", "ERROR_UNKNOWN_COMPONENT" },
      {0x648, "Unknown property.", "ERROR_UNKNOWN_PROPERTY" },
      {0x649, "Handle is in an invalid state.", "ERROR_INVALID_HANDLE_STATE" },
      {0x64A, "The configuration data for this product is corrupt. Contact your support personnel.", "ERROR_BAD_CONFIGURATION" },
      {0x64B, "Component qualifier not present.", "ERROR_INDEX_ABSENT" },
      {0x64C, "The installation source for this product is not available. Verify that the source exists and that you can access it.", "ERROR_INSTALL_SOURCE_ABSENT" },
      {0x64D, "This installation package cannot be installed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.", "ERROR_INSTALL_PACKAGE_VERSION" },
      {0x64E, "Product is uninstalled.", "ERROR_PRODUCT_UNINSTALLED" },
      {0x64F, "SQL query syntax invalid or unsupported.", "ERROR_BAD_QUERY_SYNTAX" },
      {0x650, "Record field does not exist.", "ERROR_INVALID_FIELD" },
      {0x651, "The device has been removed.", "ERROR_DEVICE_REMOVED" },
      {0x652, "Another installation is already in progress. Complete that installation before proceeding with this install.", "ERROR_INSTALL_ALREADY_RUNNING" },
      {0x653, "This installation package could not be opened. Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package.", "ERROR_INSTALL_PACKAGE_OPEN_FAILED" },
      {0x654, "This installation package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer package.", "ERROR_INSTALL_PACKAGE_INVALID" },
      {0x655, "There was an error starting the Windows Installer service user interface. Contact your support personnel.", "ERROR_INSTALL_UI_FAILURE" },
      {0x656, "Error opening installation log file. Verify that the specified log file location exists and that you can write to it.", "ERROR_INSTALL_LOG_FAILURE" },
      {0x657, "The language of this installation package is not supported by your system.", "ERROR_INSTALL_LANGUAGE_UNSUPPORTED" },
      {0x658, "Error applying transforms. Verify that the specified transform paths are valid.", "ERROR_INSTALL_TRANSFORM_FAILURE" },
      {0x659, "This installation is forbidden by system policy. Contact your system administrator.", "ERROR_INSTALL_PACKAGE_REJECTED" },
      {0x65A, "Function could not be executed.", "ERROR_FUNCTION_NOT_CALLED" },
      {0x65B, "Function failed during execution.", "ERROR_FUNCTION_FAILED" },
      {0x65C, "Invalid or unknown table specified.", "ERROR_INVALID_TABLE" },
      {0x65D, "Data supplied is of wrong type.", "ERROR_DATATYPE_MISMATCH" },
      {0x65E, "Data of this type is not supported.", "ERROR_UNSUPPORTED_TYPE" },
      {0x65F, "The Windows Installer service failed to start. Contact your support personnel.", "ERROR_CREATE_FAILED" },
      {0x660, "The Temp folder is on a drive that is full or inaccessible. Free up space on the drive or verify that you have write permission on the Temp folder.", "ERROR_INSTALL_TEMP_UNWRITABLE" },
      {0x661, "This installation package is not supported by this processor type. Contact your product vendor.", "ERROR_INSTALL_PLATFORM_UNSUPPORTED" },
      {0x662, "Component not used on this computer.", "ERROR_INSTALL_NOTUSED" },
      {0x663, "This patch package could not be opened. Verify that the patch package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer patch package.", "ERROR_PATCH_PACKAGE_OPEN_FAILED" },
      {0x664, "This patch package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer patch package.", "ERROR_PATCH_PACKAGE_INVALID" },
      {0x665, "This patch package cannot be processed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.", "ERROR_PATCH_PACKAGE_UNSUPPORTED" },
      {0x666, "Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.", "ERROR_PRODUCT_VERSION" },
      {0x667, "Invalid command line argument. Consult the Windows Installer SDK for detailed command line help.", "ERROR_INVALID_COMMAND_LINE" },
      {0x668, "Only administrators have permission to add, remove, or configure server software during a Terminal Services remote session. If you want to install or configure software on the server, contact your network administrator.", "ERROR_INSTALL_REMOTE_DISALLOWED" },
      {0x669, "The requested operation completed successfully. The system will be restarted so the changes can take effect.", "ERROR_SUCCESS_REBOOT_INITIATED" },
      {0x66A, "The upgrade patch cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade patch may update a different version of the program. Verify that the program to be upgraded exists on your computer and that you have the correct upgrade patch.", "ERROR_PATCH_TARGET_NOT_FOUND" },
      {0x66B, "The patch package is not permitted by software restriction policy.", "ERROR_PATCH_PACKAGE_REJECTED" },
      {0x66C, "One or more customizations are not permitted by software restriction policy.", "ERROR_INSTALL_TRANSFORM_REJECTED" },
      {0x66D, "The Windows Installer does not permit installation from a Remote Desktop Connection.", "ERROR_INSTALL_REMOTE_PROHIBITED" },
      {0x6A4, "The string binding is invalid.", "RPC_S_INVALID_STRING_BINDING" },
      {0x6A5, "The binding handle is not the correct type.", "RPC_S_WRONG_KIND_OF_BINDING" },
      {0x6A6, "The binding handle is invalid.", "RPC_S_INVALID_BINDING" },
      {0x6A7, "The RPC protocol sequence is not supported.", "RPC_S_PROTSEQ_NOT_SUPPORTED" },
      {0x6A8, "The RPC protocol sequence is invalid.", "RPC_S_INVALID_RPC_PROTSEQ" },
      {0x6A9, "The string universal unique identifier (UUID) is invalid.", "RPC_S_INVALID_STRING_UUID" },
      {0x6AA, "The endpoint format is invalid.", "RPC_S_INVALID_ENDPOINT_FORMAT" },
      {0x6AB, "The network address is invalid.", "RPC_S_INVALID_NET_ADDR" },
      {0x6AC, "No endpoint was found.", "RPC_S_NO_ENDPOINT_FOUND" },
      {0x6AD, "The timeout value is invalid.", "RPC_S_INVALID_TIMEOUT" },
      {0x6AE, "The object universal unique identifier (UUID) was not found.", "RPC_S_OBJECT_NOT_FOUND" },
      {0x6AF, "The object universal unique identifier (UUID) has already been registered.", "RPC_S_ALREADY_REGISTERED" },
      {0x6B0, "The type universal unique identifier (UUID) has already been registered.", "RPC_S_TYPE_ALREADY_REGISTERED" },
      {0x6B1, "The RPC server is already listening.", "RPC_S_ALREADY_LISTENING" },
      {0x6B2, "No protocol sequences have been registered.", "RPC_S_NO_PROTSEQS_REGISTERED" },
      {0x6B3, "The RPC server is not listening.", "RPC_S_NOT_LISTENING" },
      {0x6B4, "The manager type is unknown.", "RPC_S_UNKNOWN_MGR_TYPE" },
      {0x6B5, "The interface is unknown.", "RPC_S_UNKNOWN_IF" },
      {0x6B6, "There are no bindings.", "RPC_S_NO_BINDINGS" },
      {0x6B7, "There are no protocol sequences.", "RPC_S_NO_PROTSEQS" },
      {0x6B8, "The endpoint cannot be created.", "RPC_S_CANT_CREATE_ENDPOINT" },
      {0x6B9, "Not enough resources are available to complete this operation.", "RPC_S_OUT_OF_RESOURCES" },
      {0x6BA, "The RPC server is unavailable.", "RPC_S_SERVER_UNAVAILABLE" },
      {0x6BB, "The RPC server is too busy to complete this operation.", "RPC_S_SERVER_TOO_BUSY" },
      {0x6BC, "The network options are invalid.", "RPC_S_INVALID_NETWORK_OPTIONS" },
      {0x6BD, "There are no remote procedure calls active on this thread.", "RPC_S_NO_CALL_ACTIVE" },
      {0x6BE, "The remote procedure call failed.", "RPC_S_CALL_FAILED" },
      {0x6BF, "The remote procedure call failed and did not execute.", "RPC_S_CALL_FAILED_DNE" },
      {0x6C0, "A remote procedure call (RPC) protocol error occurred.", "RPC_S_PROTOCOL_ERROR" },
      {0x6C2, "The transfer syntax is not supported by the RPC server.", "RPC_S_UNSUPPORTED_TRANS_SYN" },
      {0x6C4, "The universal unique identifier (UUID) type is not supported.", "RPC_S_UNSUPPORTED_TYPE" },
      {0x6C5, "The tag is invalid.", "RPC_S_INVALID_TAG" },
      {0x6C6, "The array bounds are invalid.", "RPC_S_INVALID_BOUND" },
      {0x6C7, "The binding does not contain an entry name.", "RPC_S_NO_ENTRY_NAME" },
      {0x6C8, "The name syntax is invalid.", "RPC_S_INVALID_NAME_SYNTAX" },
      {0x6C9, "The name syntax is not supported.", "RPC_S_UNSUPPORTED_NAME_SYNTAX" },
      {0x6CB, "No network address is available to use to construct a universal unique identifier (UUID).", "RPC_S_UUID_NO_ADDRESS" },
      {0x6CC, "The endpoint is a duplicate.", "RPC_S_DUPLICATE_ENDPOINT" },
      {0x6CD, "The authentication type is unknown.", "RPC_S_UNKNOWN_AUTHN_TYPE" },
      {0x6CE, "The maximum number of calls is too small.", "RPC_S_MAX_CALLS_TOO_SMALL" },
      {0x6CF, "The string is too long.", "RPC_S_STRING_TOO_LONG" },
      {0x6D0, "The RPC protocol sequence was not found.", "RPC_S_PROTSEQ_NOT_FOUND" },
      {0x6D1, "The procedure number is out of range.", "RPC_S_PROCNUM_OUT_OF_RANGE" },
      {0x6D2, "The binding does not contain any authentication information.", "RPC_S_BINDING_HAS_NO_AUTH" },
      {0x6D3, "The authentication service is unknown.", "RPC_S_UNKNOWN_AUTHN_SERVICE" },
      {0x6D4, "The authentication level is unknown.", "RPC_S_UNKNOWN_AUTHN_LEVEL" },
      {0x6D5, "The security context is invalid.", "RPC_S_INVALID_AUTH_IDENTITY" },
      {0x6D6, "The authorization service is unknown.", "RPC_S_UNKNOWN_AUTHZ_SERVICE" },
      {0x6D7, "The entry is invalid.", "EPT_S_INVALID_ENTRY" },
      {0x6D8, "The server endpoint cannot perform the operation.", "EPT_S_CANT_PERFORM_OP" },
      {0x6D9, "There are no more endpoints available from the endpoint mapper.", "EPT_S_NOT_REGISTERED" },
      {0x6DA, "No interfaces have been exported.", "RPC_S_NOTHING_TO_EXPORT" },
      {0x6DB, "The entry name is incomplete.", "RPC_S_INCOMPLETE_NAME" },
      {0x6DC, "The version option is invalid.", "RPC_S_INVALID_VERS_OPTION" },
      {0x6DD, "There are no more members.", "RPC_S_NO_MORE_MEMBERS" },
      {0x6DE, "There is nothing to unexport.", "RPC_S_NOT_ALL_OBJS_UNEXPORTED" },
      {0x6DF, "The interface was not found.", "RPC_S_INTERFACE_NOT_FOUND" },
      {0x6E0, "The entry already exists.", "RPC_S_ENTRY_ALREADY_EXISTS" },
      {0x6E1, "The entry is not found.", "RPC_S_ENTRY_NOT_FOUND" },
      {0x6E2, "The name service is unavailable.", "RPC_S_NAME_SERVICE_UNAVAILABLE" },
      {0x6E3, "The network address family is invalid.", "RPC_S_INVALID_NAF_ID" },
      {0x6E4, "The requested operation is not supported.", "RPC_S_CANNOT_SUPPORT" },
      {0x6E5, "No security context is available to allow impersonation.", "RPC_S_NO_CONTEXT_AVAILABLE" },
      {0x6E6, "An internal error occurred in a remote procedure call (RPC).", "RPC_S_INTERNAL_ERROR" },
      {0x6E7, "The RPC server attempted an integer division by zero.", "RPC_S_ZERO_DIVIDE" },
      {0x6E8, "An addressing error occurred in the RPC server.", "RPC_S_ADDRESS_ERROR" },
      {0x6E9, "A floating-point operation at the RPC server caused a division by zero.", "RPC_S_FP_DIV_ZERO" },
      {0x6EA, "A floating-point underflow occurred at the RPC server.", "RPC_S_FP_UNDERFLOW" },
      {0x6EB, "A floating-point overflow occurred at the RPC server.", "RPC_S_FP_OVERFLOW" },
      {0x6EC, "The list of RPC servers available for the binding of auto handles has been exhausted.", "RPC_X_NO_MORE_ENTRIES" },
      {0x6ED, "Unable to open the character translation table file.", "RPC_X_SS_CHAR_TRANS_OPEN_FAIL" },
      {0x6EE, "The file containing the character translation table has fewer than 512 bytes.", "RPC_X_SS_CHAR_TRANS_SHORT_FILE" },
      {0x6EF, "A null context handle was passed from the client to the host during a remote procedure call.", "RPC_X_SS_IN_NULL_CONTEXT" },
      {0x6F1, "The context handle changed during a remote procedure call.", "RPC_X_SS_CONTEXT_DAMAGED" },
      {0x6F2, "The binding handles passed to a remote procedure call do not match.", "RPC_X_SS_HANDLES_MISMATCH" },
      {0x6F3, "The stub is unable to get the remote procedure call handle.", "RPC_X_SS_CANNOT_GET_CALL_HANDLE" },
      {0x6F4, "A null reference pointer was passed to the stub.", "RPC_X_NULL_REF_POINTER" },
      {0x6F5, "The enumeration value is out of range.", "RPC_X_ENUM_VALUE_OUT_OF_RANGE" },
      {0x6F6, "The byte count is too small.", "RPC_X_BYTE_COUNT_TOO_SMALL" },
      {0x6F7, "The stub received bad data.", "RPC_X_BAD_STUB_DATA" },
      {0x6F8, "The supplied user buffer is not valid for the requested operation.", "ERROR_INVALID_USER_BUFFER" },
      {0x6F9, "The disk media is not recognized. It may not be formatted.", "ERROR_UNRECOGNIZED_MEDIA" },
      {0x6FA, "The workstation does not have a trust secret.", "ERROR_NO_TRUST_LSA_SECRET" },
      {0x6FB, "The security database on the server does not have a computer account for this workstation trust relationship.", "ERROR_NO_TRUST_SAM_ACCOUNT" },
      {0x6FC, "The trust relationship between the primary domain and the trusted domain failed.", "ERROR_TRUSTED_DOMAIN_FAILURE" },
      {0x6FD, "The trust relationship between this workstation and the primary domain failed.", "ERROR_TRUSTED_RELATIONSHIP_FAILURE" },
      {0x6FE, "The network logon failed.", "ERROR_TRUST_FAILURE" },
      {0x6FF, "A remote procedure call is already in progress for this thread.", "RPC_S_CALL_IN_PROGRESS" },
      {0x700, "An attempt was made to logon, but the network logon service was not started.", "ERROR_NETLOGON_NOT_STARTED" },
      {0x701, "The user's account has expired.", "ERROR_ACCOUNT_EXPIRED" },
      {0x702, "The redirector is in use and cannot be unloaded.", "ERROR_REDIRECTOR_HAS_OPEN_HANDLES" },
      {0x703, "The specified printer driver is already installed.", "ERROR_PRINTER_DRIVER_ALREADY_INSTALLED" },
      {0x704, "The specified port is unknown.", "ERROR_UNKNOWN_PORT" },
      {0x705, "The printer driver is unknown.", "ERROR_UNKNOWN_PRINTER_DRIVER" },
      {0x706, "The print processor is unknown.", "ERROR_UNKNOWN_PRINTPROCESSOR" },
      {0x707, "The specified separator file is invalid.", "ERROR_INVALID_SEPARATOR_FILE" },
      {0x708, "The specified priority is invalid.", "ERROR_INVALID_PRIORITY" },
      {0x709, "The printer name is invalid.", "ERROR_INVALID_PRINTER_NAME" },
      {0x70A, "The printer already exists.", "ERROR_PRINTER_ALREADY_EXISTS" },
      {0x70B, "The printer command is invalid.", "ERROR_INVALID_PRINTER_COMMAND" },
      {0x70C, "The specified datatype is invalid.", "ERROR_INVALID_DATATYPE" },
      {0x70D, "The environment specified is invalid.", "ERROR_INVALID_ENVIRONMENT" },
      {0x70E, "There are no more bindings.", "RPC_S_NO_MORE_BINDINGS" },
      {0x70F, "The account used is an interdomain trust account. Use your global user account or local user account to access this server.", "ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT" },
      {0x710, "The account used is a computer account. Use your global user account or local user account to access this server.", "ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT" },
      {0x711, "The account used is a server trust account. Use your global user account or local user account to access this server.", "ERROR_NOLOGON_SERVER_TRUST_ACCOUNT" },
      {0x712, "The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain.", "ERROR_DOMAIN_TRUST_INCONSISTENT" },
      {0x713, "The server is in use and cannot be unloaded.", "ERROR_SERVER_HAS_OPEN_HANDLES" },
      {0x714, "The specified image file did not contain a resource section.", "ERROR_RESOURCE_DATA_NOT_FOUND" },
      {0x715, "The specified resource type cannot be found in the image file.", "ERROR_RESOURCE_TYPE_NOT_FOUND" },
      {0x716, "The specified resource name cannot be found in the image file.", "ERROR_RESOURCE_NAME_NOT_FOUND" },
      {0x717, "The specified resource language ID cannot be found in the image file.", "ERROR_RESOURCE_LANG_NOT_FOUND" },
      {0x718, "Not enough quota is available to process this command.", "ERROR_NOT_ENOUGH_QUOTA" },
      {0x719, "No interfaces have been registered.", "RPC_S_NO_INTERFACES" },
      {0x71A, "The remote procedure call was cancelled.", "RPC_S_CALL_CANCELLED" },
      {0x71B, "The binding handle does not contain all required information.", "RPC_S_BINDING_INCOMPLETE" },
      {0x71C, "A communications failure occurred during a remote procedure call.", "RPC_S_COMM_FAILURE" },
      {0x71D, "The requested authentication level is not supported.", "RPC_S_UNSUPPORTED_AUTHN_LEVEL" },
      {0x71E, "No principal name registered.", "RPC_S_NO_PRINC_NAME" },
      {0x71F, "The error specified is not a valid Windows RPC error code.", "RPC_S_NOT_RPC_ERROR" },
      {0x720, "A UUID that is valid only on this computer has been allocated.", "RPC_S_UUID_LOCAL_ONLY" },
      {0x721, "A security package specific error occurred.", "RPC_S_SEC_PKG_ERROR" },
      {0x722, "Thread is not canceled.", "RPC_S_NOT_CANCELLED" },
      {0x723, "Invalid operation on the encoding/decoding handle.", "RPC_X_INVALID_ES_ACTION" },
      {0x724, "Incompatible version of the serializing package.", "RPC_X_WRONG_ES_VERSION" },
      {0x725, "Incompatible version of the RPC stub.", "RPC_X_WRONG_STUB_VERSION" },
      {0x726, "The RPC pipe object is invalid or corrupted.", "RPC_X_INVALID_PIPE_OBJECT" },
      {0x727, "An invalid operation was attempted on an RPC pipe object.", "RPC_X_WRONG_PIPE_ORDER" },
      {0x728, "Unsupported RPC pipe version.", "RPC_X_WRONG_PIPE_VERSION" },
      {0x76A, "The group member was not found.", "RPC_S_GROUP_MEMBER_NOT_FOUND" },
      {0x76B, "The endpoint mapper database entry could not be created.", "EPT_S_CANT_CREATE" },
      {0x76C, "The object universal unique identifier (UUID) is the nil UUID.", "RPC_S_INVALID_OBJECT" },
      {0x76D, "The specified time is invalid.", "ERROR_INVALID_TIME" },
      {0x76E, "The specified form name is invalid.", "ERROR_INVALID_FORM_NAME" },
      {0x76F, "The specified form size is invalid.", "ERROR_INVALID_FORM_SIZE" },
      {0x770, "The specified printer handle is already being waited on", "ERROR_ALREADY_WAITING" },
      {0x771, "The specified printer has been deleted.", "ERROR_PRINTER_DELETED" },
      {0x772, "The state of the printer is invalid.", "ERROR_INVALID_PRINTER_STATE" },
      {0x773, "The user's password must be changed before logging on the first time.", "ERROR_PASSWORD_MUST_CHANGE" },
      {0x774, "Could not find the domain controller for this domain.", "ERROR_DOMAIN_CONTROLLER_NOT_FOUND" },
      {0x775, "The referenced account is currently locked out and may not be used to log on.", "ERROR_ACCOUNT_LOCKED_OUT" },
      {0x776, "The object exporter specified was not found.", "OR_INVALID_OXID" },
      {0x777, "The object specified was not found.", "OR_INVALID_OID" },
      {0x778, "The object resolver set specified was not found.", "OR_INVALID_SET" },
      {0x779, "Some data remains to be sent in the request buffer.", "RPC_S_SEND_INCOMPLETE" },
      {0x77A, "Invalid asynchronous remote procedure call handle.", "RPC_S_INVALID_ASYNC_HANDLE" },
      {0x77B, "Invalid asynchronous RPC call handle for this operation.", "RPC_S_INVALID_ASYNC_CALL" },
      {0x77C, "The RPC pipe object has already been closed.", "RPC_X_PIPE_CLOSED" },
      {0x77D, "The RPC call completed before all pipes were processed.", "RPC_X_PIPE_DISCIPLINE_ERROR" },
      {0x77E, "No more data is available from the RPC pipe.", "RPC_X_PIPE_EMPTY" },
      {0x77F, "No site name is available for this machine.", "ERROR_NO_SITENAME" },
      {0x780, "The file cannot be accessed by the system.", "ERROR_CANT_ACCESS_FILE" },
      {0x781, "The name of the file cannot be resolved by the system.", "ERROR_CANT_RESOLVE_FILENAME" },
      {0x782, "The entry is not of the expected type.", "RPC_S_ENTRY_TYPE_MISMATCH" },
      {0x783, "Not all object UUIDs could be exported to the specified entry.", "RPC_S_NOT_ALL_OBJS_EXPORTED" },
      {0x784, "Interface could not be exported to the specified entry.", "RPC_S_INTERFACE_NOT_EXPORTED" },
      {0x785, "The specified profile entry could not be added.", "RPC_S_PROFILE_NOT_ADDED" },
      {0x786, "The specified profile element could not be added.", "RPC_S_PRF_ELT_NOT_ADDED" },
      {0x787, "The specified profile element could not be removed.", "RPC_S_PRF_ELT_NOT_REMOVED" },
      {0x788, "The group element could not be added.", "RPC_S_GRP_ELT_NOT_ADDED" },
      {0x789, "The group element could not be removed.", "RPC_S_GRP_ELT_NOT_REMOVED" },
      {0x78A, "The printer driver is not compatible with a policy enabled on your computer that blocks NT 4.0 drivers.", "ERROR_KM_DRIVER_BLOCKED" },
      {0x78B, "The context has expired and can no longer be used.", "ERROR_CONTEXT_EXPIRED" },
      {0x78C, "The current user's delegated trust creation quota has been exceeded.", "ERROR_PER_USER_TRUST_QUOTA_EXCEEDED" },
      {0x78D, "The total delegated trust creation quota has been exceeded.", "ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED" },
      {0x78E, "The current user's delegated trust deletion quota has been exceeded.", "ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED" },
      {0x7D0, "The pixel format is invalid.", "ERROR_INVALID_PIXEL_FORMAT" },
      {0x7D1, "The specified driver is invalid.", "ERROR_BAD_DRIVER" },
      {0x7D2, "The window style or class attribute is invalid for this operation.", "ERROR_INVALID_WINDOW_STYLE" },
      {0x7D3, "The requested metafile operation is not supported.", "ERROR_METAFILE_NOT_SUPPORTED" },
      {0x7D4, "The requested transformation operation is not supported.", "ERROR_TRANSFORM_NOT_SUPPORTED" },
      {0x7D5, "The requested clipping operation is not supported.", "ERROR_CLIPPING_NOT_SUPPORTED" },
      {0x7DA, "The specified color management module is invalid.", "ERROR_INVALID_CMM" },
      {0x7DB, "The specified color profile is invalid.", "ERROR_INVALID_PROFILE" },
      {0x7DC, "The specified tag was not found.", "ERROR_TAG_NOT_FOUND" },
      {0x7DD, "A required tag is not present.", "ERROR_TAG_NOT_PRESENT" },
      {0x7DE, "The specified tag is already present.", "ERROR_DUPLICATE_TAG" },
      {0x7DF, "The specified color profile is not associated with any device.", "ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE" },
      {0x7E0, "The specified color profile was not found.", "ERROR_PROFILE_NOT_FOUND" },
      {0x7E1, "The specified color space is invalid.", "ERROR_INVALID_COLORSPACE" },
      {0x7E2, "Image Color Management is not enabled.", "ERROR_ICM_NOT_ENABLED" },
      {0x7E3, "There was an error while deleting the color transform.", "ERROR_DELETING_ICM_XFORM" },
      {0x7E4, "The specified color transform is invalid.", "ERROR_INVALID_TRANSFORM" },
      {0x7E5, "The specified transform does not match the bitmap's color space.", "ERROR_COLORSPACE_MISMATCH" },
      {0x7E6, "The specified named color index is not present in the profile.", "ERROR_INVALID_COLORINDEX" },
      {0x83C, "The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified.", "ERROR_CONNECTED_OTHER_PASSWORD" },
      {0x83D, "The network connection was made successfully using default credentials.", "ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT" },
      {0x89A, "The specified username is invalid.", "ERROR_BAD_USERNAME" },
      {0x8CA, "This network connection does not exist.", "ERROR_NOT_CONNECTED" },
      {0x961, "This network connection has files open or requests pending.", "ERROR_OPEN_FILES" },
      {0x962, "Active connections still exist.", "ERROR_ACTIVE_CONNECTIONS" },
      {0x964, "The device is in use by an active process and cannot be disconnected.", "ERROR_DEVICE_IN_USE" },
      {0xBB8, "The specified print monitor is unknown.", "ERROR_UNKNOWN_PRINT_MONITOR" },
      {0xBB9, "The specified printer driver is currently in use.", "ERROR_PRINTER_DRIVER_IN_USE" },
      {0xBBA, "The spool file was not found.", "ERROR_SPOOL_FILE_NOT_FOUND" },
      {0xBBB, "A StartDocPrinter call was not issued.", "ERROR_SPL_NO_STARTDOC" },
      {0xBBC, "An AddJob call was not issued.", "ERROR_SPL_NO_ADDJOB" },
      {0xBBD, "The specified print processor has already been installed.", "ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED" },
      {0xBBE, "The specified print monitor has already been installed.", "ERROR_PRINT_MONITOR_ALREADY_INSTALLED" },
      {0xBBF, "The specified print monitor does not have the required functions.", "ERROR_INVALID_PRINT_MONITOR" },
      {0xBC0, "The specified print monitor is currently in use.", "ERROR_PRINT_MONITOR_IN_USE" },
      {0xBC1, "The requested operation is not allowed when there are jobs queued to the printer.", "ERROR_PRINTER_HAS_JOBS_QUEUED" },
      {0xBC2, "The requested operation is successful. Changes will not be effective until the system is rebooted.", "ERROR_SUCCESS_REBOOT_REQUIRED" },
      {0xBC3, "The requested operation is successful. Changes will not be effective until the service is restarted.", "ERROR_SUCCESS_RESTART_REQUIRED" },
      {0xBC4, "No printers were found.", "ERROR_PRINTER_NOT_FOUND" },
      {0xBC5, "The printer driver is known to be unreliable.", "ERROR_PRINTER_DRIVER_WARNED" },
      {0xBC6, "The printer driver is known to harm the system.", "ERROR_PRINTER_DRIVER_BLOCKED" },
      {0xC1C, "The XML contains an entity reference to an undefined entity.", "ERROR_XML_UNDEFINED_ENTITY" },
      {0xC1D, "The XML contains a malformed entity reference.", "ERROR_XML_MALFORMED_ENTITY" },
      {0xC1E, "The XML contains a character which is not permitted in XML.", "ERROR_XML_CHAR_NOT_IN_RANGE" },
      {0xC80, "The manifest contained a duplicate definition for external proxy stub %1 at (%1:%2,%3)", "ERROR_PCM_COMPILER_DUPLICATE_EXTERNAL_PROXY" },
      {0xC81, "The manifest already contains a reference to %4 - a second reference was found at (%1:%2,%3)", "ERROR_PCM_COMPILER_DUPLICATE_ASSEMBLY_REFERENCE" },
      {0xC82, "The assembly reference at (%1:%2,%3) is invalid.", "ERROR_PCM_COMPILER_INVALID_ASSEMBLY_REFERENCE" },
      {0xC83, "The assembly definition at (%1:%2,%3) is invalid.", "ERROR_PCM_COMPILER_INVALID_ASSEMBLY_DEFINITION" },
      {0xC84, "The manifest already contained the window class %4, found a second declaration at (%1:%2,%3)", "ERROR_PCM_COMPILER_DUPLICATE_WINDOW_CLASS" },
      {0xC85, "The manifest already declared the progId %4, found a second declaration at (%1:%2,%3)", "ERROR_PCM_COMPILER_DUPLICATE_PROGID" },
      {0xC86, "Only one noInherit tag may be present in a manifest, found a second tag at (%1:%2,%3)", "ERROR_PCM_COMPILER_DUPLICATE_NOINHERIT" },
      {0xC87, "Only one noInheritable tag may be present in a manifest, found a second tag at (%1:%2,%3)", "ERROR_PCM_COMPILER_DUPLICATE_NOINHERITABLE" },
      {0xC88, "The manifest contained a duplicate declaration of COM class %4 at (%1:%2,%3)", "ERROR_PCM_COMPILER_DUPLICATE_COM_CLASS" },
      {0xC89, "The manifest already declared the file %4, a second definition was found at (%1:%2,%3)", "ERROR_PCM_COMPILER_DUPLICATE_FILE_NAME" },
      {0xC8A, "CLR surrogate %1 was already defined, second definition at (%1:%2,%3) is invalid.", "ERROR_PCM_COMPILER_DUPLICATE_CLR_SURROGATE" },
      {0xC8B, "Type library %1 was already defined, second definition at (%1:%2,%3) is invalid.", "ERROR_PCM_COMPILER_DUPLICATE_TYPE_LIBRARY" },
      {0xC8C, "Proxy stub definition %1 was already defined, second definition at (%1:%2,%3) is invalid.", "ERROR_PCM_COMPILER_DUPLICATE_PROXY_STUB" },
      {0xC8D, "Category friendly name %4 was already used, second definition was found at (%1:%2,%3) is invalid.", "ERROR_PCM_COMPILER_DUPLICATE_CATEGORY_NAME" },
      {0xC8E, "Only one top-level assemblyIdentity tag may be present in a manifest. A second tag with identity %4 was found at (%1:%2,%3)", "ERROR_PCM_COMPILER_DUPLICATE_TOP_LEVEL_IDENTITY_FOUND" },
      {0xC8F, "The root element for a manifest found at (%1:%2,%3) was not expected or was of the wrong version.", "ERROR_PCM_COMPILER_UNKNOWN_ROOT_ELEMENT" },
      {0xC90, "The element found at (%1:%2,%3) was not expected according to the manifest schema.", "ERROR_PCM_COMPILER_INVALID_ELEMENT" },
      {0xC91, "The element found at (%1:%2,%3) was missing the required attribute '%4'. See the manifest schema for more information", "ERROR_PCM_COMPILER_MISSING_REQUIRED_ATTRIBUTE" },
      {0xC92, "The attribute value %4 at (%1:%2,%3) was invalid according to the schema.", "ERROR_PCM_COMPILER_INVALID_ATTRIBUTE_VALUE" },
      {0xC93, "PCDATA or CDATA found at (%1:%2,%3) in the source document was not expected in the parent element %4.", "ERROR_PCM_COMPILER_UNEXPECTED_PCDATA" },
      {0xC94, "The string table entry with culture %4, name %5, and value '%6' at (%1:%2,%3) duplicated a previous entry.", "ERROR_PCM_DUPLICATE_STRING_TABLE_ENTRY" },
      {0xFA0, "WINS encountered an error while processing the command.", "ERROR_WINS_INTERNAL" },
      {0xFA1, "The local WINS cannot be deleted.", "ERROR_CAN_NOT_DEL_LOCAL_WINS" },
      {0xFA2, "The importation from the file failed.", "ERROR_STATIC_INIT" },
      {0xFA3, "The backup failed. Was a full backup done before?", "ERROR_INC_BACKUP" },
      {0xFA4, "The backup failed. Check the directory to which you are backing the database.", "ERROR_FULL_BACKUP" },
      {0xFA5, "The name does not exist in the WINS database.", "ERROR_REC_NON_EXISTENT" },
      {0xFA6, "Replication with a nonconfigured partner is not allowed.", "ERROR_RPL_NOT_ALLOWED" },
      {0x1004, "The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address.", "ERROR_DHCP_ADDRESS_CONFLICT" },
      {0x1068, "The GUID passed was not recognized as valid by a WMI data provider.", "ERROR_WMI_GUID_NOT_FOUND" },
      {0x1069, "The instance name passed was not recognized as valid by a WMI data provider.", "ERROR_WMI_INSTANCE_NOT_FOUND" },
      {0x106A, "The data item ID passed was not recognized as valid by a WMI data provider.", "ERROR_WMI_ITEMID_NOT_FOUND" },
      {0x106B, "The WMI request could not be completed and should be retried.", "ERROR_WMI_TRY_AGAIN" },
      {0x106C, "The WMI data provider could not be located.", "ERROR_WMI_DP_NOT_FOUND" },
      {0x106D, "The WMI data provider references an instance set that has not been registered.", "ERROR_WMI_UNRESOLVED_INSTANCE_REF" },
      {0x106E, "The WMI data block or event notification has already been enabled.", "ERROR_WMI_ALREADY_ENABLED" },
      {0x106F, "The WMI data block is no longer available.", "ERROR_WMI_GUID_DISCONNECTED" },
      {0x1070, "The WMI data service is not available.", "ERROR_WMI_SERVER_UNAVAILABLE" },
      {0x1071, "The WMI data provider failed to carry out the request.", "ERROR_WMI_DP_FAILED" },
      {0x1072, "The WMI MOF information is not valid.", "ERROR_WMI_INVALID_MOF" },
      {0x1073, "The WMI registration information is not valid.", "ERROR_WMI_INVALID_REGINFO" },
      {0x1074, "The WMI data block or event notification has already been disabled.", "ERROR_WMI_ALREADY_DISABLED" },
      {0x1075, "The WMI data item or data block is read only.", "ERROR_WMI_READ_ONLY" },
      {0x1076, "The WMI data item or data block could not be changed.", "ERROR_WMI_SET_FAILURE" },
      {0x10CC, "The media identifier does not represent a valid medium.", "ERROR_INVALID_MEDIA" },
      {0x10CD, "The library identifier does not represent a valid library.", "ERROR_INVALID_LIBRARY" },
      {0x10CE, "The media pool identifier does not represent a valid media pool.", "ERROR_INVALID_MEDIA_POOL" },
      {0x10CF, "The drive and medium are not compatible or exist in different libraries.", "ERROR_DRIVE_MEDIA_MISMATCH" },
      {0x10D0, "The medium currently exists in an offline library and must be online to perform this operation.", "ERROR_MEDIA_OFFLINE" },
      {0x10D1, "The operation cannot be performed on an offline library.", "ERROR_LIBRARY_OFFLINE" },
      {0x10D2, "The library, drive, or media pool is empty.", "ERROR_EMPTY" },
      {0x10D3, "The library, drive, or media pool must be empty to perform this operation.", "ERROR_NOT_EMPTY" },
      {0x10D4, "No media is currently available in this media pool or library.", "ERROR_MEDIA_UNAVAILABLE" },
      {0x10D5, "A resource required for this operation is disabled.", "ERROR_RESOURCE_DISABLED" },
      {0x10D6, "The media identifier does not represent a valid cleaner.", "ERROR_INVALID_CLEANER" },
      {0x10D7, "The drive cannot be cleaned or does not support cleaning.", "ERROR_UNABLE_TO_CLEAN" },
      {0x10D8, "The object identifier does not represent a valid object.", "ERROR_OBJECT_NOT_FOUND" },
      {0x10D9, "Unable to read from or write to the database.", "ERROR_DATABASE_FAILURE" },
      {0x10DA, "The database is full.", "ERROR_DATABASE_FULL" },
      {0x10DB, "The medium is not compatible with the device or media pool.", "ERROR_MEDIA_INCOMPATIBLE" },
      {0x10DC, "The resource required for this operation does not exist.", "ERROR_RESOURCE_NOT_PRESENT" },
      {0x10DD, "The operation identifier is not valid.", "ERROR_INVALID_OPERATION" },
      {0x10DE, "The media is not mounted or ready for use.", "ERROR_MEDIA_NOT_AVAILABLE" },
      {0x10DF, "The device is not ready for use.", "ERROR_DEVICE_NOT_AVAILABLE" },
      {0x10E0, "The operator or administrator has refused the request.", "ERROR_REQUEST_REFUSED" },
      {0x10E1, "The drive identifier does not represent a valid drive.", "ERROR_INVALID_DRIVE_OBJECT" },
      {0x10E2, "Library is full. No slot is available for use.", "ERROR_LIBRARY_FULL" },
      {0x10E3, "The transport cannot access the medium.", "ERROR_MEDIUM_NOT_ACCESSIBLE" },
      {0x10E4, "Unable to load the medium into the drive.", "ERROR_UNABLE_TO_LOAD_MEDIUM" },
      {0x10E5, "Unable to retrieve status about the drive.", "ERROR_UNABLE_TO_INVENTORY_DRIVE" },
      {0x10E6, "Unable to retrieve status about the slot.", "ERROR_UNABLE_TO_INVENTORY_SLOT" },
      {0x10E7, "Unable to retrieve status about the transport.", "ERROR_UNABLE_TO_INVENTORY_TRANSPORT" },
      {0x10E8, "Cannot use the transport because it is already in use.", "ERROR_TRANSPORT_FULL" },
      {0x10E9, "Unable to open or close the inject/eject port.", "ERROR_CONTROLLING_IEPORT" },
      {0x10EA, "Unable to eject the media because it is in a drive.", "ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA" },
      {0x10EB, "A cleaner slot is already reserved.", "ERROR_CLEANER_SLOT_SET" },
      {0x10EC, "A cleaner slot is not reserved.", "ERROR_CLEANER_SLOT_NOT_SET" },
      {0x10ED, "The cleaner cartridge has performed the maximum number of drive cleanings.", "ERROR_CLEANER_CARTRIDGE_SPENT" },
      {0x10EE, "Unexpected on-medium identifier.", "ERROR_UNEXPECTED_OMID" },
      {0x10EF, "The last remaining item in this group or resource cannot be deleted.", "ERROR_CANT_DELETE_LAST_ITEM" },
      {0x10F0, "The message provided exceeds the maximum size allowed for this parameter.", "ERROR_MESSAGE_EXCEEDS_MAX_SIZE" },
      {0x10F1, "The volume contains system or paging files.", "ERROR_VOLUME_CONTAINS_SYS_FILES" },
      {0x10F2, "The media type cannot be removed from this library since at least one drive in the library reports it can support this media type.", "ERROR_INDIGENOUS_TYPE" },
      {0x10F3, "This offline media cannot be mounted on this system since no enabled drives are present which can be used.", "ERROR_NO_SUPPORTING_DRIVES" },
      {0x10F4, "A cleaner cartridge is present in the tape library.", "ERROR_CLEANER_CARTRIDGE_INSTALLED" },
      {0x10FE, "The remote storage service was not able to recall the file.", "ERROR_FILE_OFFLINE" },
      {0x10FF, "The remote storage service is not operational at this time.", "ERROR_REMOTE_STORAGE_NOT_ACTIVE" },
      {0x1100, "The remote storage service encountered a media error.", "ERROR_REMOTE_STORAGE_MEDIA_ERROR" },
      {0x1126, "The file or directory is not a reparse point.", "ERROR_NOT_A_REPARSE_POINT" },
      {0x1127, "The reparse point attribute cannot be set because it conflicts with an existing attribute.", "ERROR_REPARSE_ATTRIBUTE_CONFLICT" },
      {0x1128, "The data present in the reparse point buffer is invalid.", "ERROR_INVALID_REPARSE_DATA" },
      {0x1129, "The tag present in the reparse point buffer is invalid.", "ERROR_REPARSE_TAG_INVALID" },
      {0x112A, "There is a mismatch between the tag specified in the request and the tag present in the reparse point.", "ERROR_REPARSE_TAG_MISMATCH" },
      {0x1194, "Single Instance Storage is not available on this volume.", "ERROR_VOLUME_NOT_SIS_ENABLED" },
      {0x1389, "The cluster resource cannot be moved to another group because other resources are dependent on it.", "ERROR_DEPENDENT_RESOURCE_EXISTS" },
      {0x138A, "The cluster resource dependency cannot be found.", "ERROR_DEPENDENCY_NOT_FOUND" },
      {0x138B, "The cluster resource cannot be made dependent on the specified resource because it is already dependent.", "ERROR_DEPENDENCY_ALREADY_EXISTS" },
      {0x138C, "The cluster resource is not online.", "ERROR_RESOURCE_NOT_ONLINE" },
      {0x138D, "A cluster node is not available for this operation.", "ERROR_HOST_NODE_NOT_AVAILABLE" },
      {0x138E, "The cluster resource is not available.", "ERROR_RESOURCE_NOT_AVAILABLE" },
      {0x138F, "The cluster resource could not be found.", "ERROR_RESOURCE_NOT_FOUND" },
      {0x1390, "The cluster is being shut down.", "ERROR_SHUTDOWN_CLUSTER" },
      {0x1391, "A cluster node cannot be evicted from the cluster unless the node is down.", "ERROR_CANT_EVICT_ACTIVE_NODE" },
      {0x1392, "The object already exists.", "ERROR_OBJECT_ALREADY_EXISTS" },
      {0x1393, "The object is already in the list.", "ERROR_OBJECT_IN_LIST" },
      {0x1394, "The cluster group is not available for any new requests.", "ERROR_GROUP_NOT_AVAILABLE" },
      {0x1395, "The cluster group could not be found.", "ERROR_GROUP_NOT_FOUND" },
      {0x1396, "The operation could not be completed because the cluster group is not online.", "ERROR_GROUP_NOT_ONLINE" },
      {0x1397, "The cluster node is not the owner of the resource.", "ERROR_HOST_NODE_NOT_RESOURCE_OWNER" },
      {0x1398, "The cluster node is not the owner of the group.", "ERROR_HOST_NODE_NOT_GROUP_OWNER" },
      {0x1399, "The cluster resource could not be created in the specified resource monitor.", "ERROR_RESMON_CREATE_FAILED" },
      {0x139A, "The cluster resource could not be brought online by the resource monitor.", "ERROR_RESMON_ONLINE_FAILED" },
      {0x139B, "The operation could not be completed because the cluster resource is online.", "ERROR_RESOURCE_ONLINE" },
      {0x139C, "The cluster resource could not be deleted or brought offline because it is the quorum resource.", "ERROR_QUORUM_RESOURCE" },
      {0x139D, "The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.", "ERROR_NOT_QUORUM_CAPABLE" },
      {0x139E, "The cluster software is shutting down.", "ERROR_CLUSTER_SHUTTING_DOWN" },
      {0x139F, "The group or resource is not in the correct state to perform the requested operation.", "ERROR_INVALID_STATE" },
      {0x13A0, "The properties were stored but not all changes will take effect until the next time the resource is brought online.", "ERROR_RESOURCE_PROPERTIES_STORED" },
      {0x13A1, "The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.", "ERROR_NOT_QUORUM_CLASS" },
      {0x13A2, "The cluster resource could not be deleted since it is a core resource.", "ERROR_CORE_RESOURCE" },
      {0x13A3, "The quorum resource failed to come online.", "ERROR_QUORUM_RESOURCE_ONLINE_FAILED" },
      {0x13A4, "The quorum log could not be created or mounted successfully.", "ERROR_QUORUMLOG_OPEN_FAILED" },
      {0x13A5, "The cluster log is corrupt.", "ERROR_CLUSTERLOG_CORRUPT" },
      {0x13A6, "The record could not be written to the cluster log since it exceeds the maximum size.", "ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE" },
      {0x13A7, "The cluster log exceeds its maximum size.", "ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE" },
      {0x13A8, "No checkpoint record was found in the cluster log.", "ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND" },
      {0x13A9, "The minimum required disk space needed for logging is not available.", "ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE" },
      {0x13AA, "The cluster node failed to take control of the quorum resource because the resource is owned by another active node.", "ERROR_QUORUM_OWNER_ALIVE" },
      {0x13AB, "A cluster network is not available for this operation.", "ERROR_NETWORK_NOT_AVAILABLE" },
      {0x13AC, "A cluster node is not available for this operation.", "ERROR_NODE_NOT_AVAILABLE" },
      {0x13AD, "All cluster nodes must be running to perform this operation.", "ERROR_ALL_NODES_NOT_AVAILABLE" },
      {0x13AE, "A cluster resource failed.", "ERROR_RESOURCE_FAILED" },
      {0x13AF, "The cluster node is not valid.", "ERROR_CLUSTER_INVALID_NODE" },
      {0x13B0, "The cluster node already exists.", "ERROR_CLUSTER_NODE_EXISTS" },
      {0x13B1, "A node is in the process of joining the cluster.", "ERROR_CLUSTER_JOIN_IN_PROGRESS" },
      {0x13B2, "The cluster node was not found.", "ERROR_CLUSTER_NODE_NOT_FOUND" },
      {0x13B3, "The cluster local node information was not found.", "ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND" },
      {0x13B4, "The cluster network already exists.", "ERROR_CLUSTER_NETWORK_EXISTS" },
      {0x13B5, "The cluster network was not found.", "ERROR_CLUSTER_NETWORK_NOT_FOUND" },
      {0x13B6, "The cluster network interface already exists.", "ERROR_CLUSTER_NETINTERFACE_EXISTS" },
      {0x13B7, "The cluster network interface was not found.", "ERROR_CLUSTER_NETINTERFACE_NOT_FOUND" },
      {0x13B8, "The cluster request is not valid for this object.", "ERROR_CLUSTER_INVALID_REQUEST" },
      {0x13B9, "The cluster network provider is not valid.", "ERROR_CLUSTER_INVALID_NETWORK_PROVIDER" },
      {0x13BA, "The cluster node is down.", "ERROR_CLUSTER_NODE_DOWN" },
      {0x13BB, "The cluster node is not reachable.", "ERROR_CLUSTER_NODE_UNREACHABLE" },
      {0x13BC, "The cluster node is not a member of the cluster.", "ERROR_CLUSTER_NODE_NOT_MEMBER" },
      {0x13BD, "A cluster join operation is not in progress.", "ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS" },
      {0x13BE, "The cluster network is not valid.", "ERROR_CLUSTER_INVALID_NETWORK" },
      {0x13C0, "The cluster node is up.", "ERROR_CLUSTER_NODE_UP" },
      {0x13C1, "The cluster IP address is already in use.", "ERROR_CLUSTER_IPADDR_IN_USE" },
      {0x13C2, "The cluster node is not paused.", "ERROR_CLUSTER_NODE_NOT_PAUSED" },
      {0x13C3, "No cluster security context is available.", "ERROR_CLUSTER_NO_SECURITY_CONTEXT" },
      {0x13C4, "The cluster network is not configured for internal cluster communication.", "ERROR_CLUSTER_NETWORK_NOT_INTERNAL" },
      {0x13C5, "The cluster node is already up.", "ERROR_CLUSTER_NODE_ALREADY_UP" },
      {0x13C6, "The cluster node is already down.", "ERROR_CLUSTER_NODE_ALREADY_DOWN" },
      {0x13C7, "The cluster network is already online.", "ERROR_CLUSTER_NETWORK_ALREADY_ONLINE" },
      {0x13C8, "The cluster network is already offline.", "ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE" },
      {0x13C9, "The cluster node is already a member of the cluster.", "ERROR_CLUSTER_NODE_ALREADY_MEMBER" },
      {0x13CA, "The cluster network is the only one configured for internal cluster communication between two or more active cluster nodes. The internal communication capability cannot be removed from the network.", "ERROR_CLUSTER_LAST_INTERNAL_NETWORK" },
      {0x13CB, "One or more cluster resources depend on the network to provide service to clients. The client access capability cannot be removed from the network.", "ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS" },
      {0x13CC, "This operation cannot be performed on the cluster resource as it the quorum resource. You may not bring the quorum resource offline or modify its possible owners list.", "ERROR_INVALID_OPERATION_ON_QUORUM" },
      {0x13CD, "The cluster quorum resource is not allowed to have any dependencies.", "ERROR_DEPENDENCY_NOT_ALLOWED" },
      {0x13CE, "The cluster node is paused.", "ERROR_CLUSTER_NODE_PAUSED" },
      {0x13CF, "The cluster resource cannot be brought online. The owner node cannot run this resource.", "ERROR_NODE_CANT_HOST_RESOURCE" },
      {0x13D0, "The cluster node is not ready to perform the requested operation.", "ERROR_CLUSTER_NODE_NOT_READY" },
      {0x13D1, "The cluster node is shutting down.", "ERROR_CLUSTER_NODE_SHUTTING_DOWN" },
      {0x13D2, "The cluster join operation was aborted.", "ERROR_CLUSTER_JOIN_ABORTED" },
      {0x13D3, "The cluster join operation failed due to incompatible software versions between the joining node and its sponsor.", "ERROR_CLUSTER_INCOMPATIBLE_VERSIONS" },
      {0x13D4, "This resource cannot be created because the cluster has reached the limit on the number of resources it can monitor.", "ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED" },
      {0x13D5, "The system configuration changed during the cluster join or form operation. The join or form operation was aborted.", "ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED" },
      {0x13D6, "The specified resource type was not found.", "ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND" },
      {0x13D7, "The specified node does not support a resource of this type. This may be due to version inconsistencies or due to the absence of the resource DLL on this node.", "ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED" },
      {0x13D8, "The specified resource name is supported by this resource DLL. This may be due to a bad (or changed) name supplied to the resource DLL.", "ERROR_CLUSTER_RESNAME_NOT_FOUND" },
      {0x13D9, "No authentication package could be registered with the RPC server.", "ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED" },
      {0x13DA, "You cannot bring the group online because the owner of the group is not in the preferred list for the group. To change the owner node for the group, move the group.", "ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST" },
      {0x13DB, "The join operation failed because the cluster database sequence number has changed or is incompatible with the locker node. This may happen during a join operation if the cluster database was changing during the join.", "ERROR_CLUSTER_DATABASE_SEQMISMATCH" },
      {0x13DC, "The resource monitor will not allow the fail operation to be performed while the resource is in its current state. This may happen if the resource is in a pending state.", "ERROR_RESMON_INVALID_STATE" },
      {0x13DD, "A non locker code got a request to reserve the lock for making global updates.", "ERROR_CLUSTER_GUM_NOT_LOCKER" },
      {0x13DE, "The quorum disk could not be located by the cluster service.", "ERROR_QUORUM_DISK_NOT_FOUND" },
      {0x13DF, "The backup up cluster database is possibly corrupt.", "ERROR_DATABASE_BACKUP_CORRUPT" },
      {0x13E0, "A DFS root already exists in this cluster node.", "ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT" },
      {0x13E1, "An attempt to modify a resource property failed because it conflicts with another existing property.", "ERROR_RESOURCE_PROPERTY_UNCHANGEABLE" },
      {0x1702, "An operation was attempted that is incompatible with the current membership state of the node.", "ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE" },
      {0x1703, "The quorum resource does not contain the quorum log.", "ERROR_CLUSTER_QUORUMLOG_NOT_FOUND" },
      {0x1704, "The membership engine requested shutdown of the cluster service on this node.", "ERROR_CLUSTER_MEMBERSHIP_HALT" },
      {0x1705, "The join operation failed because the cluster instance ID of the joining node does not match the cluster instance ID of the sponsor node.", "ERROR_CLUSTER_INSTANCE_ID_MISMATCH" },
      {0x1706, "A matching network for the specified IP address could not be found. Please also specify a subnet mask and a cluster network.", "ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP" },
      {0x1707, "The actual data type of the property did not match the expected data type of the property.", "ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH" },
      {0x1708, "The cluster node was evicted from the cluster successfully, but the node was not cleaned up. Extended status information explaining why the node was not cleaned up is available.", "ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP" },
      {0x1709, "Two or more parameter values specified for a resource's properties are in conflict.", "ERROR_CLUSTER_PARAMETER_MISMATCH" },
      {0x170A, "This computer cannot be made a member of a cluster.", "ERROR_NODE_CANNOT_BE_CLUSTERED" },
      {0x170B, "This computer cannot be made a member of a cluster because it does not have the correct version of Windows installed.", "ERROR_CLUSTER_WRONG_OS_VERSION" },
      {0x170C, "A cluster cannot be created with the specified cluster name because that cluster name is already in use. Specify a different name for the cluster.", "ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME" },
      {0x170D, "The cluster configuration action has already been committed.", "ERROR_CLUSCFG_ALREADY_COMMITTED" },
      {0x170E, "The cluster configuration action could not be rolled back.", "ERROR_CLUSCFG_ROLLBACK_FAILED" },
      {0x170F, "The drive letter assigned to a system disk on one node conflicted with the driver letter assigned to a disk on another node.", "ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT" },
      {0x1710, "One or more nodes in the cluster are running a version of Windows that does not support this operation.", "ERROR_CLUSTER_OLD_VERSION" },
      {0x1711, "The name of the corresponding computer account doesn't match the Network Name for this resource.", "ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME" },
      {0x1712, "No network adapters are available.", "ERROR_CLUSTER_NO_NET_ADAPTERS" },
      {0x1713, "The cluster node has been poisoned.", "ERROR_CLUSTER_POISONED" },
      {0x1770, "The specified file could not be encrypted.", "ERROR_ENCRYPTION_FAILED" },
      {0x1771, "The specified file could not be decrypted.", "ERROR_DECRYPTION_FAILED" },
      {0x1772, "The specified file is encrypted and the user does not have the ability to decrypt it.", "ERROR_FILE_ENCRYPTED" },
      {0x1773, "There is no valid encryption recovery policy configured for this system.", "ERROR_NO_RECOVERY_POLICY" },
      {0x1774, "The required encryption driver is not loaded for this system.", "ERROR_NO_EFS" },
      {0x1775, "The file was encrypted with a different encryption driver than is currently loaded.", "ERROR_WRONG_EFS" },
      {0x1776, "There are no EFS keys defined for the user.", "ERROR_NO_USER_KEYS" },
      {0x1777, "The specified file is not encrypted.", "ERROR_FILE_NOT_ENCRYPTED" },
      {0x1778, "The specified file is not in the defined EFS export format.", "ERROR_NOT_EXPORT_FORMAT" },
      {0x1779, "The specified file is read only.", "ERROR_FILE_READ_ONLY" },
      {0x177A, "The directory has been disabled for encryption.", "ERROR_DIR_EFS_DISALLOWED" },
      {0x177B, "The server is not trusted for remote encryption operation.", "ERROR_EFS_SERVER_NOT_TRUSTED" },
      {0x177C, "Recovery policy configured for this system contains invalid recovery certificate.", "ERROR_BAD_RECOVERY_POLICY" },
      {0x177D, "The encryption algorithm used on the source file needs a bigger key buffer than the one on the destination file.", "ERROR_EFS_ALG_BLOB_TOO_BIG" },
      {0x177E, "The disk partition does not support file encryption.", "ERROR_VOLUME_NOT_SUPPORT_EFS" },
      {0x177F, "This machine is disabled for file encryption.", "ERROR_EFS_DISABLED" },
      {0x1780, "A newer system is required to decrypt this encrypted file.", "ERROR_EFS_VERSION_NOT_SUPPORT" },
      {0x17E6, "The list of servers for this workgroup is not currently available.", "ERROR_NO_BROWSER_SERVERS_FOUND" },
      {0x1838, "The Task Scheduler service must be configured to run in the System account to function properly. Individual tasks may be configured to run in other accounts.", "SCHED_E_SERVICE_NOT_LOCALSYSTEM" },
      {0x1B59, "The specified session name is invalid.", "ERROR_CTX_WINSTATION_NAME_INVALID" },
      {0x1B5A, "The specified protocol driver is invalid.", "ERROR_CTX_INVALID_PD" },
      {0x1B5B, "The specified protocol driver was not found in the system path.", "ERROR_CTX_PD_NOT_FOUND" },
      {0x1B5C, "The specified terminal connection driver was not found in the system path.", "ERROR_CTX_WD_NOT_FOUND" },
      {0x1B5D, "A registry key for event logging could not be created for this session.", "ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY" },
      {0x1B5E, "A service with the same name already exists on the system.", "ERROR_CTX_SERVICE_NAME_COLLISION" },
      {0x1B5F, "A close operation is pending on the session.", "ERROR_CTX_CLOSE_PENDING" },
      {0x1B60, "There are no free output buffers available.", "ERROR_CTX_NO_OUTBUF" },
      {0x1B61, "The MODEM.INF file was not found.", "ERROR_CTX_MODEM_INF_NOT_FOUND" },
      {0x1B62, "The modem name was not found in MODEM.INF.", "ERROR_CTX_INVALID_MODEMNAME" },
      {0x1B63, "The modem did not accept the command sent to it. Verify that the configured modem name matches the attached modem.", "ERROR_CTX_MODEM_RESPONSE_ERROR" },
      {0x1B64, "The modem did not respond to the command sent to it. Verify that the modem is properly cabled and powered on.", "ERROR_CTX_MODEM_RESPONSE_TIMEOUT" },
      {0x1B65, "Carrier detect has failed or carrier has been dropped due to disconnect.", "ERROR_CTX_MODEM_RESPONSE_NO_CARRIER" },
      {0x1B66, "Dial tone not detected within the required time. Verify that the phone cable is properly attached and functional.", "ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE" },
      {0x1B67, "Busy signal detected at remote site on callback.", "ERROR_CTX_MODEM_RESPONSE_BUSY" },
      {0x1B68, "Voice detected at remote site on callback.", "ERROR_CTX_MODEM_RESPONSE_VOICE" },
      {0x1B69, "Transport driver error", "ERROR_CTX_TD_ERROR" },
      {0x1B6E, "The specified session cannot be found.", "ERROR_CTX_WINSTATION_NOT_FOUND" },
      {0x1B6F, "The specified session name is already in use.", "ERROR_CTX_WINSTATION_ALREADY_EXISTS" },
      {0x1B70, "The requested operation cannot be completed because the terminal connection is currently busy processing a connect, disconnect, reset, or delete operation.", "ERROR_CTX_WINSTATION_BUSY" },
      {0x1B71, "An attempt has been made to connect to a session whose video mode is not supported by the current client.", "ERROR_CTX_BAD_VIDEO_MODE" },
      {0x1B7B, "The application attempted to enable DOS graphics mode. DOS graphics mode is not supported.", "ERROR_CTX_GRAPHICS_INVALID" },
      {0x1B7D, "Your interactive logon privilege has been disabled. Please contact your administrator.", "ERROR_CTX_LOGON_DISABLED" },
      {0x1B7E, "The requested operation can be performed only on the system console. This is most often the result of a driver or system DLL requiring direct console access.", "ERROR_CTX_NOT_CONSOLE" },
      {0x1B80, "The client failed to respond to the server connect message.", "ERROR_CTX_CLIENT_QUERY_TIMEOUT" },
      {0x1B81, "Disconnecting the console session is not supported.", "ERROR_CTX_CONSOLE_DISCONNECT" },
      {0x1B82, "Reconnecting a disconnected session to the console is not supported.", "ERROR_CTX_CONSOLE_CONNECT" },
      {0x1B84, "The request to control another session remotely was denied.", "ERROR_CTX_SHADOW_DENIED" },
      {0x1B85, "The requested session access is denied.", "ERROR_CTX_WINSTATION_ACCESS_DENIED" },
      {0x1B89, "The specified terminal connection driver is invalid.", "ERROR_CTX_INVALID_WD" },
      {0x1B8A, "The requested session cannot be controlled remotely. This may be because the session is disconnected or does not currently have a user logged on.", "ERROR_CTX_SHADOW_INVALID" },
      {0x1B8B, "The requested session is not configured to allow remote control.", "ERROR_CTX_SHADOW_DISABLED" },
      {0x1B8C, "Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number is currently being used by another user. Please call your system administrator to obtain a unique license number.", "ERROR_CTX_CLIENT_LICENSE_IN_USE" },
      {0x1B8D, "Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number has not been entered for this copy of the Terminal Server client. Please contact your system administrator.", "ERROR_CTX_CLIENT_LICENSE_NOT_SET" },
      {0x1B8E, "The system has reached its licensed logon limit. Please try again later.", "ERROR_CTX_LICENSE_NOT_AVAILABLE" },
      {0x1B8F, "The client you are using is not licensed to use this system. Your logon request is denied.", "ERROR_CTX_LICENSE_CLIENT_INVALID" },
      {0x1B90, "The system license has expired. Your logon request is denied.", "ERROR_CTX_LICENSE_EXPIRED" },
      {0x1B91, "Remote control could not be terminated because the specified session is not currently being remotely controlled.", "ERROR_CTX_SHADOW_NOT_RUNNING" },
      {0x1B92, "The remote control of the console was terminated because the display mode was changed. Changing the display mode in a remote control session is not supported.", "ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE" },
      {0x1B93, "Activation has already been reset the maximum number of times for this installation. Your activation timer will not be cleared.", "ERROR_ACTIVATION_COUNT_EXCEEDED" },
      {0x1B94, "Remote logins are currently disabled.", "ERROR_CTX_WINSTATIONS_DISABLED" },
      {0x1B95, "You do not have the proper encryption level to access this Session.", "ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED" },
      {0x1B96, "The user %s\\%s is currently logged on to this computer. Only the current user or an administrator can log on to this computer.", "ERROR_CTX_SESSION_IN_USE" },
      {0x1B97, "The user %s\\%s is already logged on to the console of this computer. You do not have permission to log in at this time. To resolve this issue, contact %s\\%s and have them log off.", "ERROR_CTX_NO_FORCE_LOGOFF" },
      {0x1B98, "Unable to log you on because of an account restriction.", "ERROR_CTX_ACCOUNT_RESTRICTION" },
      {0x1B99, "The RDP protocol component %2 detected an error in the protocol stream and has disconnected the client.", "ERROR_RDP_PROTOCOL_ERROR" },
      {0x1B9A, "The Client Drive Mapping Service Has Connected on Terminal Connection.", "ERROR_CTX_CDM_CONNECT" },
      {0x1B9B, "The Client Drive Mapping Service Has Disconnected on Terminal Connection.", "ERROR_CTX_CDM_DISCONNECT" },
      {0x1F41, "The file replication service API was called incorrectly.", "FRS_ERR_INVALID_API_SEQUENCE" },
      {0x1F42, "The file replication service cannot be started.", "FRS_ERR_STARTING_SERVICE" },
      {0x1F43, "The file replication service cannot be stopped.", "FRS_ERR_STOPPING_SERVICE" },
      {0x1F44, "The file replication service API terminated the request. The event log may have more information.", "FRS_ERR_INTERNAL_API" },
      {0x1F45, "The file replication service terminated the request. The event log may have more information.", "FRS_ERR_INTERNAL" },
      {0x1F46, "The file replication service cannot be contacted. The event log may have more information.", "FRS_ERR_SERVICE_COMM" },
      {0x1F47, "The file replication service cannot satisfy the request because the user has insufficient privileges. The event log may have more information.", "FRS_ERR_INSUFFICIENT_PRIV" },
      {0x1F48, "The file replication service cannot satisfy the request because authenticated RPC is not available. The event log may have more information.", "FRS_ERR_AUTHENTICATION" },
      {0x1F49, "The file replication service cannot satisfy the request because the user has insufficient privileges on the domain controller. The event log may have more information.", "FRS_ERR_PARENT_INSUFFICIENT_PRIV" },
      {0x1F4A, "The file replication service cannot satisfy the request because authenticated RPC is not available on the domain controller. The event log may have more information.", "FRS_ERR_PARENT_AUTHENTICATION" },
      {0x1F4B, "The file replication service cannot communicate with the file replication service on the domain controller. The event log may have more information.", "FRS_ERR_CHILD_TO_PARENT_COMM" },
      {0x1F4C, "The file replication service on the domain controller cannot communicate with the file replication service on this computer. The event log may have more information.", "FRS_ERR_PARENT_TO_CHILD_COMM" },
      {0x1F4D, "The file replication service cannot populate the system volume because of an internal error. The event log may have more information.", "FRS_ERR_SYSVOL_POPULATE" },
      {0x1F4E, "The file replication service cannot populate the system volume because of an internal timeout. The event log may have more information.", "FRS_ERR_SYSVOL_POPULATE_TIMEOUT" },
      {0x1F4F, "The file replication service cannot process the request. The system volume is busy with a previous request.", "FRS_ERR_SYSVOL_IS_BUSY" },
      {0x1F50, "The file replication service cannot stop replicating the system volume because of an internal error. The event log may have more information.", "FRS_ERR_SYSVOL_DEMOTE" },
      {0x1F51, "The file replication service detected an invalid parameter.", "FRS_ERR_INVALID_SERVICE_PARAMETER" },
      {0x2008, "An error occurred while installing the directory service. For more information, see the event log.", "ERROR_DS_NOT_INSTALLED" },
      {0x2009, "The directory service evaluated group memberships locally.", "ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY" },
      {0x200A, "The specified directory service attribute or value does not exist.", "ERROR_DS_NO_ATTRIBUTE_OR_VALUE" },
      {0x200B, "The attribute syntax specified to the directory service is invalid.", "ERROR_DS_INVALID_ATTRIBUTE_SYNTAX" },
      {0x200C, "The attribute type specified to the directory service is not defined.", "ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED" },
      {0x200D, "The specified directory service attribute or value already exists.", "ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS" },
      {0x200E, "The directory service is busy.", "ERROR_DS_BUSY" },
      {0x200F, "The directory service is unavailable.", "ERROR_DS_UNAVAILABLE" },
      {0x2010, "The directory service was unable to allocate a relative identifier.", "ERROR_DS_NO_RIDS_ALLOCATED" },
      {0x2011, "The directory service has exhausted the pool of relative identifiers.", "ERROR_DS_NO_MORE_RIDS" },
      {0x2012, "The requested operation could not be performed because the directory service is not the master for that type of operation.", "ERROR_DS_INCORRECT_ROLE_OWNER" },
      {0x2013, "The directory service was unable to initialize the subsystem that allocates relative identifiers.", "ERROR_DS_RIDMGR_INIT_ERROR" },
      {0x2014, "The requested operation did not satisfy one or more constraints associated with the class of the object.", "ERROR_DS_OBJ_CLASS_VIOLATION" },
      {0x2015, "The directory service can perform the requested operation only on a leaf object.", "ERROR_DS_CANT_ON_NON_LEAF" },
      {0x2016, "The directory service cannot perform the requested operation on the RDN attribute of an object.", "ERROR_DS_CANT_ON_RDN" },
      {0x2017, "The directory service detected an attempt to modify the object class of an object.", "ERROR_DS_CANT_MOD_OBJ_CLASS" },
      {0x2018, "The requested cross-domain move operation could not be performed.", "ERROR_DS_CROSS_DOM_MOVE_ERROR" },
      {0x2019, "Unable to contact the global catalog server.", "ERROR_DS_GC_NOT_AVAILABLE" },
      {0x201A, "The policy object is shared and can only be modified at the root.", "ERROR_SHARED_POLICY" },
      {0x201B, "The policy object does not exist.", "ERROR_POLICY_OBJECT_NOT_FOUND" },
      {0x201C, "The requested policy information is only in the directory service.", "ERROR_POLICY_ONLY_IN_DS" },
      {0x201D, "A domain controller promotion is currently active.", "ERROR_PROMOTION_ACTIVE" },
      {0x201E, "A domain controller promotion is not currently active", "ERROR_NO_PROMOTION_ACTIVE" },
      {0x2020, "An operations error occurred.", "ERROR_DS_OPERATIONS_ERROR" },
      {0x2021, "A protocol error occurred.", "ERROR_DS_PROTOCOL_ERROR" },
      {0x2022, "The time limit for this request was exceeded.", "ERROR_DS_TIMELIMIT_EXCEEDED" },
      {0x2023, "The size limit for this request was exceeded.", "ERROR_DS_SIZELIMIT_EXCEEDED" },
      {0x2024, "The administrative limit for this request was exceeded.", "ERROR_DS_ADMIN_LIMIT_EXCEEDED" },
      {0x2025, "The compare response was false.", "ERROR_DS_COMPARE_FALSE" },
      {0x2026, "The compare response was true.", "ERROR_DS_COMPARE_TRUE" },
      {0x2027, "The requested authentication method is not supported by the server.", "ERROR_DS_AUTH_METHOD_NOT_SUPPORTED" },
      {0x2028, "A more secure authentication method is required for this server.", "ERROR_DS_STRONG_AUTH_REQUIRED" },
      {0x2029, "Inappropriate authentication.", "ERROR_DS_INAPPROPRIATE_AUTH" },
      {0x202A, "The authentication mechanism is unknown.", "ERROR_DS_AUTH_UNKNOWN" },
      {0x202B, "A referral was returned from the server.", "ERROR_DS_REFERRAL" },
      {0x202C, "The server does not support the requested critical extension.", "ERROR_DS_UNAVAILABLE_CRIT_EXTENSION" },
      {0x202D, "This request requires a secure connection.", "ERROR_DS_CONFIDENTIALITY_REQUIRED" },
      {0x202E, "Inappropriate matching.", "ERROR_DS_INAPPROPRIATE_MATCHING" },
      {0x202F, "A constraint violation occurred.", "ERROR_DS_CONSTRAINT_VIOLATION" },
      {0x2030, "There is no such object on the server.", "ERROR_DS_NO_SUCH_OBJECT" },
      {0x2031, "There is an alias problem.", "ERROR_DS_ALIAS_PROBLEM" },
      {0x2032, "An invalid dn syntax has been specified.", "ERROR_DS_INVALID_DN_SYNTAX" },
      {0x2033, "The object is a leaf object.", "ERROR_DS_IS_LEAF" },
      {0x2034, "There is an alias dereferencing problem.", "ERROR_DS_ALIAS_DEREF_PROBLEM" },
      {0x2035, "The server is unwilling to process the request.", "ERROR_DS_UNWILLING_TO_PERFORM" },
      {0x2036, "A loop has been detected.", "ERROR_DS_LOOP_DETECT" },
      {0x2037, "There is a naming violation.", "ERROR_DS_NAMING_VIOLATION" },
      {0x2038, "The result set is too large.", "ERROR_DS_OBJECT_RESULTS_TOO_LARGE" },
      {0x2039, "The operation affects multiple DSAs", "ERROR_DS_AFFECTS_MULTIPLE_DSAS" },
      {0x203A, "The server is not operational.", "ERROR_DS_SERVER_DOWN" },
      {0x203B, "A local error has occurred.", "ERROR_DS_LOCAL_ERROR" },
      {0x203C, "An encoding error has occurred.", "ERROR_DS_ENCODING_ERROR" },
      {0x203D, "A decoding error has occurred.", "ERROR_DS_DECODING_ERROR" },
      {0x203E, "The search filter cannot be recognized.", "ERROR_DS_FILTER_UNKNOWN" },
      {0x203F, "One or more parameters are illegal.", "ERROR_DS_PARAM_ERROR" },
      {0x2040, "The specified method is not supported.", "ERROR_DS_NOT_SUPPORTED" },
      {0x2041, "No results were returned.", "ERROR_DS_NO_RESULTS_RETURNED" },
      {0x2042, "The specified control is not supported by the server.", "ERROR_DS_CONTROL_NOT_FOUND" },
      {0x2043, "A referral loop was detected by the client.", "ERROR_DS_CLIENT_LOOP" },
      {0x2044, "The preset referral limit was exceeded.", "ERROR_DS_REFERRAL_LIMIT_EXCEEDED" },
      {0x2045, "The search requires a SORT control.", "ERROR_DS_SORT_CONTROL_MISSING" },
      {0x2046, "The search results exceed the offset range specified.", "ERROR_DS_OFFSET_RANGE_ERROR" },
      {0x206D, "The root object must be the head of a naming context. The root object cannot have an instantiated parent.", "ERROR_DS_ROOT_MUST_BE_NC" },
      {0x206E, "The add replica operation cannot be performed. The naming context must be writeable in order to create the replica.", "ERROR_DS_ADD_REPLICA_INHIBITED" },
      {0x206F, "A reference to an attribute that is not defined in the schema occurred.", "ERROR_DS_ATT_NOT_DEF_IN_SCHEMA" },
      {0x2070, "The maximum size of an object has been exceeded.", "ERROR_DS_MAX_OBJ_SIZE_EXCEEDED" },
      {0x2071, "An attempt was made to add an object to the directory with a name that is already in use.", "ERROR_DS_OBJ_STRING_NAME_EXISTS" },
      {0x2072, "An attempt was made to add an object of a class that does not have an RDN defined in the schema.", "ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA" },
      {0x2073, "An attempt was made to add an object using an RDN that is not the RDN defined in the schema.", "ERROR_DS_RDN_DOESNT_MATCH_SCHEMA" },
      {0x2074, "None of the requested attributes were found on the objects.", "ERROR_DS_NO_REQUESTED_ATTS_FOUND" },
      {0x2075, "The user buffer is too small.", "ERROR_DS_USER_BUFFER_TO_SMALL" },
      {0x2076, "The attribute specified in the operation is not present on the object.", "ERROR_DS_ATT_IS_NOT_ON_OBJ" },
      {0x2077, "Illegal modify operation. Some aspect of the modification is not permitted.", "ERROR_DS_ILLEGAL_MOD_OPERATION" },
      {0x2078, "The specified object is too large.", "ERROR_DS_OBJ_TOO_LARGE" },
      {0x2079, "The specified instance type is not valid.", "ERROR_DS_BAD_INSTANCE_TYPE" },
      {0x207A, "The operation must be performed at a master DSA.", "ERROR_DS_MASTERDSA_REQUIRED" },
      {0x207B, "The object class attribute must be specified.", "ERROR_DS_OBJECT_CLASS_REQUIRED" },
      {0x207C, "A required attribute is missing.", "ERROR_DS_MISSING_REQUIRED_ATT" },
      {0x207D, "An attempt was made to modify an object to include an attribute that is not legal for its class", "ERROR_DS_ATT_NOT_DEF_FOR_CLASS" },
      {0x207E, "The specified attribute is already present on the object.", "ERROR_DS_ATT_ALREADY_EXISTS" },
      {0x2080, "The specified attribute is not present, or has no values.", "ERROR_DS_CANT_ADD_ATT_VALUES" },
      {0x2081, "Multiple values were specified for an attribute that can have only one value.", "ERROR_DS_SINGLE_VALUE_CONSTRAINT" },
      {0x2082, "A value for the attribute was not in the acceptable range of values.", "ERROR_DS_RANGE_CONSTRAINT" },
      {0x2083, "The specified value already exists.", "ERROR_DS_ATT_VAL_ALREADY_EXISTS" },
      {0x2084, "The attribute cannot be removed because it is not present on the object.", "ERROR_DS_CANT_REM_MISSING_ATT" },
      {0x2085, "The attribute value cannot be removed because it is not present on the object.", "ERROR_DS_CANT_REM_MISSING_ATT_VAL" },
      {0x2086, "The specified root object cannot be a subref.", "ERROR_DS_ROOT_CANT_BE_SUBREF" },
      {0x2087, "Chaining is not permitted.", "ERROR_DS_NO_CHAINING" },
      {0x2088, "Chained evaluation is not permitted.", "ERROR_DS_NO_CHAINED_EVAL" },
      {0x2089, "The operation could not be performed because the object's parent is either uninstantiated or deleted.", "ERROR_DS_NO_PARENT_OBJECT" },
      {0x208A, "Having a parent that is an alias is not permitted. Aliases are leaf objects.", "ERROR_DS_PARENT_IS_AN_ALIAS" },
      {0x208B, "The object and parent must be of the same type, either both masters or both replicas.", "ERROR_DS_CANT_MIX_MASTER_AND_REPS" },
      {0x208C, "The operation cannot be performed because child objects exist. This operation can only be performed on a leaf object.", "ERROR_DS_CHILDREN_EXIST" },
      {0x208D, "Directory object not found.", "ERROR_DS_OBJ_NOT_FOUND" },
      {0x208E, "The aliased object is missing.", "ERROR_DS_ALIASED_OBJ_MISSING" },
      {0x208F, "The object name has bad syntax.", "ERROR_DS_BAD_NAME_SYNTAX" },
      {0x2090, "It is not permitted for an alias to refer to another alias.", "ERROR_DS_ALIAS_POINTS_TO_ALIAS" },
      {0x2091, "The alias cannot be dereferenced.", "ERROR_DS_CANT_DEREF_ALIAS" },
      {0x2092, "The operation is out of scope.", "ERROR_DS_OUT_OF_SCOPE" },
      {0x2093, "The operation cannot continue because the object is in the process of being removed.", "ERROR_DS_OBJECT_BEING_REMOVED" },
      {0x2094, "The DSA object cannot be deleted.", "ERROR_DS_CANT_DELETE_DSA_OBJ" },
      {0x2095, "A directory service error has occurred.", "ERROR_DS_GENERIC_ERROR" },
      {0x2096, "The operation can only be performed on an internal master DSA object.", "ERROR_DS_DSA_MUST_BE_INT_MASTER" },
      {0x2097, "The object must be of class DSA.", "ERROR_DS_CLASS_NOT_DSA" },
      {0x2098, "Insufficient access rights to perform the operation.", "ERROR_DS_INSUFF_ACCESS_RIGHTS" },
      {0x2099, "The object cannot be added because the parent is not on the list of possible superiors.", "ERROR_DS_ILLEGAL_SUPERIOR" },
      {0x209A, "Access to the attribute is not permitted because the attribute is owned by the Security Accounts Manager (SAM).", "ERROR_DS_ATTRIBUTE_OWNED_BY_SAM" },
      {0x209B, "The name has too many parts.", "ERROR_DS_NAME_TOO_MANY_PARTS" },
      {0x209C, "The name is too long.", "ERROR_DS_NAME_TOO_LONG" },
      {0x209D, "The name value is too long.", "ERROR_DS_NAME_VALUE_TOO_LONG" },
      {0x209E, "The directory service encountered an error parsing a name.", "ERROR_DS_NAME_UNPARSEABLE" },
      {0x209F, "The directory service cannot get the attribute type for a name.", "ERROR_DS_NAME_TYPE_UNKNOWN" },
      {0x20A0, "The name does not identify an object; the name identifies a phantom.", "ERROR_DS_NOT_AN_OBJECT" },
      {0x20A1, "The security descriptor is too short.", "ERROR_DS_SEC_DESC_TOO_SHORT" },
      {0x20A2, "The security descriptor is invalid.", "ERROR_DS_SEC_DESC_INVALID" },
      {0x20A3, "Failed to create name for deleted object.", "ERROR_DS_NO_DELETED_NAME" },
      {0x20A4, "The parent of a new subref must exist.", "ERROR_DS_SUBREF_MUST_HAVE_PARENT" },
      {0x20A5, "The object must be a naming context.", "ERROR_DS_NCNAME_MUST_BE_NC" },
      {0x20A6, "It is not permitted to add an attribute which is owned by the system.", "ERROR_DS_CANT_ADD_SYSTEM_ONLY" },
      {0x20A7, "The class of the object must be structural; you cannot instantiate an abstract class.", "ERROR_DS_CLASS_MUST_BE_CONCRETE" },
      {0x20A8, "The schema object could not be found.", "ERROR_DS_INVALID_DMD" },
      {0x20A9, "A local object with this GUID (dead or alive) already exists.", "ERROR_DS_OBJ_GUID_EXISTS" },
      {0x20AA, "The operation cannot be performed on a back link.", "ERROR_DS_NOT_ON_BACKLINK" },
      {0x20AB, "The cross reference for the specified naming context could not be found.", "ERROR_DS_NO_CROSSREF_FOR_NC" },
      {0x20AC, "The operation could not be performed because the directory service is shutting down.", "ERROR_DS_SHUTTING_DOWN" },
      {0x20AD, "The directory service request is invalid.", "ERROR_DS_UNKNOWN_OPERATION" },
      {0x20AE, "The role owner attribute could not be read.", "ERROR_DS_INVALID_ROLE_OWNER" },
      {0x20AF, "The requested FSMO operation failed. The current FSMO holder could not be reached.", "ERROR_DS_COULDNT_CONTACT_FSMO" },
      {0x20B0, "Modification of a DN across a naming context is not permitted.", "ERROR_DS_CROSS_NC_DN_RENAME" },
      {0x20B1, "The attribute cannot be modified because it is owned by the system.", "ERROR_DS_CANT_MOD_SYSTEM_ONLY" },
      {0x20B2, "Only the replicator can perform this function.", "ERROR_DS_REPLICATOR_ONLY" },
      {0x20B3, "The specified class is not defined.", "ERROR_DS_OBJ_CLASS_NOT_DEFINED" },
      {0x20B4, "The specified class is not a subclass.", "ERROR_DS_OBJ_CLASS_NOT_SUBCLASS" },
      {0x20B5, "The name reference is invalid.", "ERROR_DS_NAME_REFERENCE_INVALID" },
      {0x20B6, "A cross reference already exists.", "ERROR_DS_CROSS_REF_EXISTS" },
      {0x20B7, "It is not permitted to delete a master cross reference.", "ERROR_DS_CANT_DEL_MASTER_CROSSREF" },
      {0x20B8, "Subtree notifications are only supported on NC heads.", "ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD" },
      {0x20B9, "Notification filter is too complex.", "ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX" },
      {0x20BA, "Schema update failed: duplicate RDN.", "ERROR_DS_DUP_RDN" },
      {0x20BB, "Schema update failed: duplicate OID", "ERROR_DS_DUP_OID" },
      {0x20BC, "Schema update failed: duplicate MAPI identifier.", "ERROR_DS_DUP_MAPI_ID" },
      {0x20BD, "Schema update failed: duplicate schema-id GUID.", "ERROR_DS_DUP_SCHEMA_ID_GUID" },
      {0x20BE, "Schema update failed: duplicate LDAP display name.", "ERROR_DS_DUP_LDAP_DISPLAY_NAME" },
      {0x20BF, "Schema update failed: range-lower less than range upper", "ERROR_DS_SEMANTIC_ATT_TEST" },
      {0x20C0, "Schema update failed: syntax mismatch", "ERROR_DS_SYNTAX_MISMATCH" },
      {0x20C1, "Schema deletion failed: attribute is used in must-contain", "ERROR_DS_EXISTS_IN_MUST_HAVE" },
      {0x20C2, "Schema deletion failed: attribute is used in may-contain", "ERROR_DS_EXISTS_IN_MAY_HAVE" },
      {0x20C3, "Schema update failed: attribute in may-contain does not exist", "ERROR_DS_NONEXISTENT_MAY_HAVE" },
      {0x20C4, "Schema update failed: attribute in must-contain does not exist", "ERROR_DS_NONEXISTENT_MUST_HAVE" },
      {0x20C5, "Schema update failed: class in aux-class list does not exist or is not an auxiliary class", "ERROR_DS_AUX_CLS_TEST_FAIL" },
      {0x20C6, "Schema update failed: class in poss-superiors does not exist", "ERROR_DS_NONEXISTENT_POSS_SUP" },
      {0x20C7, "Schema update failed: class in subclassof list does not exist or does not satisfy hierarchy rules", "ERROR_DS_SUB_CLS_TEST_FAIL" },
      {0x20C8, "Schema update failed: Rdn-Att-Id has wrong syntax", "ERROR_DS_BAD_RDN_ATT_ID_SYNTAX" },
      {0x20C9, "Schema deletion failed: class is used as auxiliary class", "ERROR_DS_EXISTS_IN_AUX_CLS" },
      {0x20CA, "Schema deletion failed: class is used as sub class", "ERROR_DS_EXISTS_IN_SUB_CLS" },
      {0x20CB, "Schema deletion failed: class is used as poss superior", "ERROR_DS_EXISTS_IN_POSS_SUP" },
      {0x20CC, "Schema update failed in recalculating validation cache.", "ERROR_DS_RECALCSCHEMA_FAILED" },
      {0x20CD, "The tree deletion is not finished.", "ERROR_DS_TREE_DELETE_NOT_FINISHED" },
      {0x20CE, "The requested delete operation could not be performed.", "ERROR_DS_CANT_DELETE" },
      {0x20CF, "Cannot read the governs class identifier for the schema record.", "ERROR_DS_ATT_SCHEMA_REQ_ID" },
      {0x20D0, "The attribute schema has bad syntax.", "ERROR_DS_BAD_ATT_SCHEMA_SYNTAX" },
      {0x20D1, "The attribute could not be cached.", "ERROR_DS_CANT_CACHE_ATT" },
      {0x20D2, "The class could not be cached.", "ERROR_DS_CANT_CACHE_CLASS" },
      {0x20D3, "The attribute could not be removed from the cache.", "ERROR_DS_CANT_REMOVE_ATT_CACHE" },
      {0x20D4, "The class could not be removed from the cache.", "ERROR_DS_CANT_REMOVE_CLASS_CACHE" },
      {0x20D5, "The distinguished name attribute could not be read.", "ERROR_DS_CANT_RETRIEVE_DN" },
      {0x20D6, "No superior reference has been configured for the directory service. The directory service is therefore unable to issue referrals to objects outside this forest.", "ERROR_DS_MISSING_SUPREF" },
      {0x20D7, "The instance type attribute could not be retrieved.", "ERROR_DS_CANT_RETRIEVE_INSTANCE" },
      {0x20D8, "An internal error has occurred.", "ERROR_DS_CODE_INCONSISTENCY" },
      {0x20D9, "A database error has occurred.", "ERROR_DS_DATABASE_ERROR" },
      {0x20DA, "The attribute GOVERNSID is missing.", "ERROR_DS_GOVERNSID_MISSING" },
      {0x20DB, "An expected attribute is missing.", "ERROR_DS_MISSING_EXPECTED_ATT" },
      {0x20DC, "The specified naming context is missing a cross reference.", "ERROR_DS_NCNAME_MISSING_CR_REF" },
      {0x20DD, "A security checking error has occurred.", "ERROR_DS_SECURITY_CHECKING_ERROR" },
      {0x20DE, "The schema is not loaded.", "ERROR_DS_SCHEMA_NOT_LOADED" },
      {0x20DF, "Schema allocation failed. Please check if the machine is running low on memory.", "ERROR_DS_SCHEMA_ALLOC_FAILED" },
      {0x20E0, "Failed to obtain the required syntax for the attribute schema.", "ERROR_DS_ATT_SCHEMA_REQ_SYNTAX" },
      {0x20E1, "The global catalog verification failed. The global catalog is not available or does not support the operation. Some part of the directory is currently not available.", "ERROR_DS_GCVERIFY_ERROR" },
      {0x20E2, "The replication operation failed because of a schema mismatch between the servers involved.", "ERROR_DS_DRA_SCHEMA_MISMATCH" },
      {0x20E3, "The DSA object could not be found.", "ERROR_DS_CANT_FIND_DSA_OBJ" },
      {0x20E4, "The naming context could not be found.", "ERROR_DS_CANT_FIND_EXPECTED_NC" },
      {0x20E5, "The naming context could not be found in the cache.", "ERROR_DS_CANT_FIND_NC_IN_CACHE" },
      {0x20E6, "The child object could not be retrieved.", "ERROR_DS_CANT_RETRIEVE_CHILD" },
      {0x20E7, "The modification was not permitted for security reasons.", "ERROR_DS_SECURITY_ILLEGAL_MODIFY" },
      {0x20E8, "The operation cannot replace the hidden record.", "ERROR_DS_CANT_REPLACE_HIDDEN_REC" },
      {0x20E9, "The hierarchy file is invalid.", "ERROR_DS_BAD_HIERARCHY_FILE" },
      {0x20EA, "The attempt to build the hierarchy table failed.", "ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED" },
      {0x20EB, "The directory configuration parameter is missing from the registry.", "ERROR_DS_CONFIG_PARAM_MISSING" },
      {0x20EC, "The attempt to count the address book indices failed.", "ERROR_DS_COUNTING_AB_INDICES_FAILED" },
      {0x20ED, "The allocation of the hierarchy table failed.", "ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED" },
      {0x20EE, "The directory service encountered an internal failure.", "ERROR_DS_INTERNAL_FAILURE" },
      {0x20EF, "The directory service encountered an unknown failure.", "ERROR_DS_UNKNOWN_ERROR" },
      {0x20F0, "A root object requires a class of 'top'.", "ERROR_DS_ROOT_REQUIRES_CLASS_TOP" },
      {0x20F1, "This directory server is shutting down, and cannot take ownership of new floating single-master operation roles.", "ERROR_DS_REFUSING_FSMO_ROLES" },
      {0x20F2, "The directory service is missing mandatory configuration information, and is unable to determine the ownership of floating single-master operation roles.", "ERROR_DS_MISSING_FSMO_SETTINGS" },
      {0x20F3, "The directory service was unable to transfer ownership of one or more floating single-master operation roles to other servers.", "ERROR_DS_UNABLE_TO_SURRENDER_ROLES" },
      {0x20F4, "The replication operation failed.", "ERROR_DS_DRA_GENERIC" },
      {0x20F5, "An invalid parameter was specified for this replication operation.", "ERROR_DS_DRA_INVALID_PARAMETER" },
      {0x20F6, "The directory service is too busy to complete the replication operation at this time.", "ERROR_DS_DRA_BUSY" },
      {0x20F7, "The distinguished name specified for this replication operation is invalid.", "ERROR_DS_DRA_BAD_DN" },
      {0x20F8, "The naming context specified for this replication operation is invalid.", "ERROR_DS_DRA_BAD_NC" },
      {0x20F9, "The distinguished name specified for this replication operation already exists.", "ERROR_DS_DRA_DN_EXISTS" },
      {0x20FA, "The replication system encountered an internal error.", "ERROR_DS_DRA_INTERNAL_ERROR" },
      {0x20FB, "The replication operation encountered a database inconsistency.", "ERROR_DS_DRA_INCONSISTENT_DIT" },
      {0x20FC, "The server specified for this replication operation could not be contacted.", "ERROR_DS_DRA_CONNECTION_FAILED" },
      {0x20FD, "The replication operation encountered an object with an invalid instance type.", "ERROR_DS_DRA_BAD_INSTANCE_TYPE" },
      {0x20FE, "The replication operation failed to allocate memory.", "ERROR_DS_DRA_OUT_OF_MEM" },
      {0x20FF, "The replication operation encountered an error with the mail system.", "ERROR_DS_DRA_MAIL_PROBLEM" },
      {0x2100, "The replication reference information for the target server already exists.", "ERROR_DS_DRA_REF_ALREADY_EXISTS" },
      {0x2101, "The replication reference information for the target server does not exist.", "ERROR_DS_DRA_REF_NOT_FOUND" },
      {0x2102, "The naming context cannot be removed because it is replicated to another server.", "ERROR_DS_DRA_OBJ_IS_REP_SOURCE" },
      {0x2103, "The replication operation encountered a database error.", "ERROR_DS_DRA_DB_ERROR" },
      {0x2104, "The naming context is in the process of being removed or is not replicated from the specified server.", "ERROR_DS_DRA_NO_REPLICA" },
      {0x2105, "Replication access was denied.", "ERROR_DS_DRA_ACCESS_DENIED" },
      {0x2106, "The requested operation is not supported by this version of the directory service.", "ERROR_DS_DRA_NOT_SUPPORTED" },
      {0x2107, "The replication remote procedure call was cancelled.", "ERROR_DS_DRA_RPC_CANCELLED" },
      {0x2108, "The source server is currently rejecting replication requests.", "ERROR_DS_DRA_SOURCE_DISABLED" },
      {0x2109, "The destination server is currently rejecting replication requests.", "ERROR_DS_DRA_SINK_DISABLED" },
      {0x210A, "The replication operation failed due to a collision of object names.", "ERROR_DS_DRA_NAME_COLLISION" },
      {0x210B, "The replication source has been reinstalled.", "ERROR_DS_DRA_SOURCE_REINSTALLED" },
      {0x210C, "The replication operation failed because a required parent object is missing.", "ERROR_DS_DRA_MISSING_PARENT" },
      {0x210D, "The replication operation was preempted.", "ERROR_DS_DRA_PREEMPTED" },
      {0x210E, "The replication synchronization attempt was abandoned because of a lack of updates.", "ERROR_DS_DRA_ABANDON_SYNC" },
      {0x210F, "The replication operation was terminated because the system is shutting down.", "ERROR_DS_DRA_SHUTDOWN" },
      {0x2110, "Synchronization attempt failed because the destination DC is currently waiting to synchronize new partial attributes from source. This condition is normal if a recent schema change modified the partial attribute set. The destination partial attribute set is not a subset of the source partial attribute set.", "ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET" },
      {0x2111, "The replication synchronization attempt failed because a master replica attempted to sync from a partial replica.", "ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA" },
      {0x2112, "The server specified for this replication operation was contacted, but that server was unable to contact an additional server needed to complete the operation.", "ERROR_DS_DRA_EXTN_CONNECTION_FAILED" },
      {0x2113, "The version of the Active Directory schema of the source forest is not compatible with the version of Active Directory on this computer.", "ERROR_DS_INSTALL_SCHEMA_MISMATCH" },
      {0x2114, "Schema update failed: An attribute with the same link identifier already exists.", "ERROR_DS_DUP_LINK_ID" },
      {0x2115, "Name translation: Generic processing error.", "ERROR_DS_NAME_ERROR_RESOLVING" },
      {0x2116, "Name translation: Could not find the name or insufficient right to see name.", "ERROR_DS_NAME_ERROR_NOT_FOUND" },
      {0x2117, "Name translation: Input name mapped to more than one output name.", "ERROR_DS_NAME_ERROR_NOT_UNIQUE" },
      {0x2118, "Name translation: Input name found, but not the associated output format.", "ERROR_DS_NAME_ERROR_NO_MAPPING" },
      {0x2119, "Name translation: Unable to resolve completely, only the domain was found.", "ERROR_DS_NAME_ERROR_DOMAIN_ONLY" },
      {0x211A, "Name translation: Unable to perform purely syntactical mapping at the client without going out to the wire.", "ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING" },
      {0x211B, "Modification of a constructed attribute is not allowed.", "ERROR_DS_CONSTRUCTED_ATT_MOD" },
      {0x211C, "The OM-Object-Class specified is incorrect for an attribute with the specified syntax.", "ERROR_DS_WRONG_OM_OBJ_CLASS" },
      {0x211D, "The replication request has been posted; waiting for reply.", "ERROR_DS_DRA_REPL_PENDING" },
      {0x211E, "The requested operation requires a directory service, and none was available.", "ERROR_DS_DS_REQUIRED" },
      {0x211F, "The LDAP display name of the class or attribute contains non-ASCII characters.", "ERROR_DS_INVALID_LDAP_DISPLAY_NAME" },
      {0x2120, "The requested search operation is only supported for base searches.", "ERROR_DS_NON_BASE_SEARCH" },
      {0x2121, "The search failed to retrieve attributes from the database.", "ERROR_DS_CANT_RETRIEVE_ATTS" },
      {0x2122, "The schema update operation tried to add a backward link attribute that has no corresponding forward link.", "ERROR_DS_BACKLINK_WITHOUT_LINK" },
      {0x2123, "Source and destination of a cross domain move do not agree on the object's epoch number. Either source or destination does not have the latest version of the object.", "ERROR_DS_EPOCH_MISMATCH" },
      {0x2124, "Source and destination of a cross domain move do not agree on the object's current name. Either source or destination does not have the latest version of the object.", "ERROR_DS_SRC_NAME_MISMATCH" },
      {0x2125, "Source and destination of a cross domain move operation are identical. Caller should use local move operation instead of cross domain move operation.", "ERROR_DS_SRC_AND_DST_NC_IDENTICAL" },
      {0x2126, "Source and destination for a cross domain move are not in agreement on the naming contexts in the forest. Either source or destination does not have the latest version of the Partitions container.", "ERROR_DS_DST_NC_MISMATCH" },
      {0x2127, "Destination of a cross domain move is not authoritative for the destination naming context.", "ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC" },
      {0x2128, "Source and destination of a cross domain move do not agree on the identity of the source object. Either source or destination does not have the latest version of the source object.", "ERROR_DS_SRC_GUID_MISMATCH" },
      {0x2129, "Object being moved across domains is already known to be deleted by the destination server. The source server does not have the latest version of the source object.", "ERROR_DS_CANT_MOVE_DELETED_OBJECT" },
      {0x212A, "Another operation, which requires exclusive access to the PDC PSMO, is already in progress.", "ERROR_DS_PDC_OPERATION_IN_PROGRESS" },
      {0x212B, "A cross domain move operation failed such that the two versions of the moved object exist - one each in the source and destination domains. The destination object needs to be removed to restore the system to a consistent state.", "ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD" },
      {0x212C, "This object may not be moved across domain boundaries either because cross domain moves for this class are disallowed, or the object has some special characteristics, e.g.: trust account or restricted RID, which prevent its move.", "ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION" },
      {0x212D, "Can't move objects with memberships across domain boundaries as once moved, this would violate the membership conditions of the account group. Remove the object from any account group memberships and retry.", "ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS" },
      {0x212E, "A naming context head must be the immediate child of another naming context head, not of an interior node.", "ERROR_DS_NC_MUST_HAVE_NC_PARENT" },
      {0x212F, "The directory cannot validate the proposed naming context name because it does not hold a replica of the naming context above the proposed naming context. Please ensure that the domain naming master role is held by a server that is configured as a global catalog server, and that the server is up to date with its replication partners. (Applies only to Windows 2000 Domain Naming masters)", "ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE" },
      {0x2130, "Destination domain must be in native mode.", "ERROR_DS_DST_DOMAIN_NOT_NATIVE" },
      {0x2131, "The operation cannot be performed because the server does not have an infrastructure container in the domain of interest.", "ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER" },
      {0x2132, "Cross-domain move of non-empty account groups is not allowed.", "ERROR_DS_CANT_MOVE_ACCOUNT_GROUP" },
      {0x2133, "Cross-domain move of non-empty resource groups is not allowed.", "ERROR_DS_CANT_MOVE_RESOURCE_GROUP" },
      {0x2134, "The search flags for the attribute are invalid. The ANR bit is valid only on attributes of Unicode or Teletex strings.", "ERROR_DS_INVALID_SEARCH_FLAG" },
      {0x2135, "Tree deletions starting at an object which has an NC head as a descendant are not allowed.", "ERROR_DS_NO_TREE_DELETE_ABOVE_NC" },
      {0x2136, "The directory service failed to lock a tree in preparation for a tree deletion because the tree was in use.", "ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE" },
      {0x2137, "The directory service failed to identify the list of objects to delete while attempting a tree deletion.", "ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE" },
      {0x2138, "Security Accounts Manager initialization failed because of the following error: %1. Error Status: 0x%2. Click OK to shut down the system and reboot into Directory Services Restore Mode. Check the event log for detailed information.", "ERROR_DS_SAM_INIT_FAILURE" },
      {0x2139, "Only an administrator can modify the membership list of an administrative group.", "ERROR_DS_SENSITIVE_GROUP_VIOLATION" },
      {0x213A, "Cannot change the primary group ID of a domain controller account.", "ERROR_DS_CANT_MOD_PRIMARYGROUPID" },
      {0x213B, "An attempt is made to modify the base schema.", "ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD" },
      {0x213C, "Adding a new mandatory attribute to an existing class, deleting a mandatory attribute from an existing class, or adding an optional attribute to the special class Top that is not a backlink attribute (directly or through inheritance, for example, by adding or deleting an auxiliary class) is not allowed.", "ERROR_DS_NONSAFE_SCHEMA_CHANGE" },
      {0x213D, "Schema update is not allowed on this DC because the DC is not the schema FSMO Role Owner.", "ERROR_DS_SCHEMA_UPDATE_DISALLOWED" },
      {0x213E, "An object of this class cannot be created under the schema container. You can only create attribute-schema and class-schema objects under the schema container.", "ERROR_DS_CANT_CREATE_UNDER_SCHEMA" },
      {0x213F, "The replica/child install failed to get the objectVersion attribute on the schema container on the source DC. Either the attribute is missing on the schema container or the credentials supplied do not have permission to read it.", "ERROR_DS_INSTALL_NO_SRC_SCH_VERSION" },
      {0x2140, "The replica/child install failed to read the objectVersion attribute in the SCHEMA section of the file schema.ini in the system32 directory.", "ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE" },
      {0x2141, "The specified group type is invalid.", "ERROR_DS_INVALID_GROUP_TYPE" },
      {0x2142, "Cannot nest global groups in a mixed domain if the group is security-enabled.", "ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN" },
      {0x2143, "Cannot nest local groups in a mixed domain if the group is security-enabled.", "ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN" },
      {0x2144, "A global group cannot have a local group as a member.", "ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER" },
      {0x2145, "A global group cannot have a universal group as a member.", "ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER" },
      {0x2146, "A universal group cannot have a local group as a member.", "ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER" },
      {0x2147, "A global group cannot have a cross-domain member.", "ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER" },
      {0x2148, "A local group cannot have another cross-domain local group as a member.", "ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER" },
      {0x2149, "A group with primary members cannot change to a security-disabled group.", "ERROR_DS_HAVE_PRIMARY_MEMBERS" },
      {0x214A, "The schema cache load failed to convert the string default SD on a class-schema object.", "ERROR_DS_STRING_SD_CONVERSION_FAILED" },
      {0x214B, "Only DSAs configured to be Global Catalog servers should be allowed to hold the Domain Naming Master FSMO role. (Applies only to Windows 2000 servers)", "ERROR_DS_NAMING_MASTER_GC" },
      {0x214C, "The DSA operation is unable to proceed because of a DNS lookup failure.", "ERROR_DS_LOOKUP_FAILURE" },
      {0x214D, "While processing a change to the DNS Host Name for an object, the Service Principal Name values could not be kept in sync.", "ERROR_DS_COULDNT_UPDATE_SPNS" },
      {0x214E, "The Security Descriptor attribute could not be read.", "ERROR_DS_CANT_RETRIEVE_SD" },
      {0x214F, "The object requested was not found, but an object with that key was found.", "ERROR_DS_KEY_NOT_UNIQUE" },
      {0x2150, "The syntax of the linked attributed being added is incorrect. Forward links can only have syntax 2.5.5.1, 2.5.5.7, and 2.5.5.14, and backlinks can only have syntax 2.5.5.1.", "ERROR_DS_WRONG_LINKED_ATT_SYNTAX" },
      {0x2151, "Security Account Manager needs to get the boot password.", "ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD" },
      {0x2152, "Security Account Manager needs to get the boot key from floppy disk.", "ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY" },
      {0x2153, "Directory Service cannot start.", "ERROR_DS_CANT_START" },
      {0x2154, "Directory Services could not start.", "ERROR_DS_INIT_FAILURE" },
      {0x2155, "The connection between client and server requires packet privacy or better.", "ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION" },
      {0x2156, "The source domain may not be in the same forest as destination.", "ERROR_DS_SOURCE_DOMAIN_IN_FOREST" },
      {0x2157, "The destination domain must be in the forest.", "ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST" },
      {0x2158, "The operation requires that destination domain auditing be enabled.", "ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED" },
      {0x2159, "The operation couldn't locate a DC for the source domain.", "ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN" },
      {0x215A, "The source object must be a group or user.", "ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER" },
      {0x215B, "The source object's SID already exists in destination forest.", "ERROR_DS_SRC_SID_EXISTS_IN_FOREST" },
      {0x215C, "The source and destination object must be of the same type.", "ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH" },
      {0x215D, "Security Accounts Manager initialization failed because of the following error: %1. Error Status: 0x%2. Click OK to shut down the system and reboot into Safe Mode. Check the event log for detailed information.", "ERROR_SAM_INIT_FAILURE" },
      {0x215E, "Schema information could not be included in the replication request.", "ERROR_DS_DRA_SCHEMA_INFO_SHIP" },
      {0x215F, "The replication operation could not be completed due to a schema incompatibility.", "ERROR_DS_DRA_SCHEMA_CONFLICT" },
      {0x2160, "The replication operation could not be completed due to a previous schema incompatibility.", "ERROR_DS_DRA_EARLIER_SCHEMA_CONLICT" },
      {0x2161, "The replication update could not be applied because either the source or the destination has not yet received information regarding a recent cross-domain move operation.", "ERROR_DS_DRA_OBJ_NC_MISMATCH" },
      {0x2162, "The requested domain could not be deleted because there exist domain controllers that still host this domain.", "ERROR_DS_NC_STILL_HAS_DSAS" },
      {0x2163, "The requested operation can be performed only on a global catalog server.", "ERROR_DS_GC_REQUIRED" },
      {0x2164, "A local group can only be a member of other local groups in the same domain.", "ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY" },
      {0x2165, "Foreign security principals cannot be members of universal groups.", "ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS" },
      {0x2166, "The attribute is not allowed to be replicated to the GC because of security reasons.", "ERROR_DS_CANT_ADD_TO_GC" },
      {0x2167, "The checkpoint with the PDC could not be taken because there are too many modifications being processed currently.", "ERROR_DS_NO_CHECKPOINT_WITH_PDC" },
      {0x2168, "The operation requires that source domain auditing be enabled.", "ERROR_DS_SOURCE_AUDITING_NOT_ENABLED" },
      {0x2169, "Security principal objects can only be created inside domain naming contexts.", "ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC" },
      {0x216A, "A Service Principal Name (SPN) could not be constructed because the provided hostname is not in the necessary format.", "ERROR_DS_INVALID_NAME_FOR_SPN" },
      {0x216B, "A Filter was passed that uses constructed attributes.", "ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS" },
      {0x216C, "The unicodePwd attribute value must be enclosed in double quotes.", "ERROR_DS_UNICODEPWD_NOT_IN_QUOTES" },
      {0x216D, "Your computer could not be joined to the domain. You have exceeded the maximum number of computer accounts you are allowed to create in this domain. Contact your system administrator to have this limit reset or increased.", "ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED" },
      {0x216E, "For security reasons, the operation must be run on the destination DC.", "ERROR_DS_MUST_BE_RUN_ON_DST_DC" },
      {0x216F, "For security reasons, the source DC must be NT4SP4 or greater.", "ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER" },
      {0x2170, "Critical Directory Service System objects cannot be deleted during tree delete operations. The tree delete may have been partially performed.", "ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ" },
      {0x2171, "Directory Services could not start because of the following error: %1. Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.", "ERROR_DS_INIT_FAILURE_CONSOLE" },
      {0x2172, "Security Accounts Manager initialization failed because of the following error: %1. Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.", "ERROR_DS_SAM_INIT_FAILURE_CONSOLE" },
      {0x2173, "The version of the operating system installed is incompatible with the current forest functional level. You must upgrade to a new version of the operating system before this server can become a domain controller in this forest.", "ERROR_DS_FOREST_VERSION_TOO_HIGH" },
      {0x2174, "The version of the operating system installed is incompatible with the current domain functional level. You must upgrade to a new version of the operating system before this server can become a domain controller in this domain.", "ERROR_DS_DOMAIN_VERSION_TOO_HIGH" },
      {0x2175, "This version of the operating system installed on this server no longer supports the current forest functional level. You must raise the forest functional level before this server can become a domain controller in this forest.", "ERROR_DS_FOREST_VERSION_TOO_LOW" },
      {0x2176, "This version of the operating system installed on this server no longer supports the current domain functional level. You must raise the domain functional level before this server can become a domain controller in this domain.", "ERROR_DS_DOMAIN_VERSION_TOO_LOW" },
      {0x2177, "The version of the operating system installed on this server is incompatible with the functional level of the domain or forest.", "ERROR_DS_INCOMPATIBLE_VERSION" },
      {0x2178, "The functional level of the domain (or forest) cannot be raised to the requested value, because there exist one or more domain controllers in the domain (or forest) that are at a lower incompatible functional level.", "ERROR_DS_LOW_DSA_VERSION" },
      {0x2179, "The forest functional level cannot be raised to the requested level since one or more domains are still in mixed domain mode. All domains in the forest must be in native mode before you can raise the forest functional level.", "ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN" },
      {0x217A, "The sort order requested is not supported.", "ERROR_DS_NOT_SUPPORTED_SORT_ORDER" },
      {0x217B, "The requested name already exists as a unique identifier.", "ERROR_DS_NAME_NOT_UNIQUE" },
      {0x217C, "The machine account was created pre-NT4. The account needs to be recreated.", "ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4" },
      {0x217D, "The database is out of version store.", "ERROR_DS_OUT_OF_VERSION_STORE" },
      {0x217E, "Unable to continue operation because multiple conflicting controls were used.", "ERROR_DS_INCOMPATIBLE_CONTROLS_USED" },
      {0x217F, "Unable to find a valid security descriptor reference domain for this partition.", "ERROR_DS_NO_REF_DOMAIN" },
      {0x2180, "Schema update failed: The link identifier is reserved.", "ERROR_DS_RESERVED_LINK_ID" },
      {0x2181, "Schema update failed: There are no link identifiers available.", "ERROR_DS_LINK_ID_NOT_AVAILABLE" },
      {0x2182, "An account group cannot have a universal group as a member.", "ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER" },
      {0x2183, "Rename or move operations on naming context heads or read-only objects are not allowed.", "ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE" },
      {0x2184, "Move operations on objects in the schema naming context are not allowed.", "ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC" },
      {0x2185, "A system flag has been set on the object and does not allow the object to be moved or renamed.", "ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG" },
      {0x2186, "This object is not allowed to change its grandparent container. Moves are not forbidden on this object, but are restricted to sibling containers.", "ERROR_DS_MODIFYDN_WRONG_GRANDPARENT" },
      {0x2187, "Unable to resolve completely, a referral to another forest is generated.", "ERROR_DS_NAME_ERROR_TRUST_REFERRAL" },
      {0x2188, "The requested action is not supported on standard server.", "ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER" },
      {0x2189, "Could not access a partition of the Active Directory located on a remote server. Make sure at least one server is running for the partition in question.", "ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD" },
      {0x218A, "The directory cannot validate the proposed naming context (or partition) name because it does not hold a replica nor can it contact a replica of the naming context above the proposed naming context. Please ensure that the parent naming context is properly registered in DNS, and at least one replica of this naming context is reachable by the Domain Naming master.", "ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2" },
      {0x218B, "The thread limit for this request was exceeded.", "ERROR_DS_THREAD_LIMIT_EXCEEDED" },
      {0x218C, "The Global catalog server is not in the closet site.", "ERROR_DS_NOT_CLOSEST" },
      {0x218D, "The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the corresponding server object in the local DS database has no serverReference attribute.", "ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF" },
      {0x218E, "The Directory Service failed to enter single user mode.", "ERROR_DS_SINGLE_USER_MODE_FAILED" },
      {0x218F, "The Directory Service cannot parse the script because of a syntax error.", "ERROR_DS_NTDSCRIPT_SYNTAX_ERROR" },
      {0x2190, "The Directory Service cannot process the script because of an error.", "ERROR_DS_NTDSCRIPT_PROCESS_ERROR" },
      {0x2191, "The directory service cannot perform the requested operation because the servers involved are of different replication epochs (which is usually related to a domain rename that is in progress).", "ERROR_DS_DIFFERENT_REPL_EPOCHS" },
      {0x2192, "The directory service binding must be renegotiated due to a change in the server extensions information.", "ERROR_DS_DRS_EXTENSIONS_CHANGED" },
      {0x2193, "Operation not allowed on a disabled cross ref.", "ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR" },
      {0x2194, "Schema update failed: No values for msDS-IntId are available.", "ERROR_DS_NO_MSDS_INTID" },
      {0x2195, "Schema update failed: Duplicate msDS-IntId. Retry the operation.", "ERROR_DS_DUP_MSDS_INTID" },
      {0x2196, "Schema deletion failed: attribute is used in rDNAttID.", "ERROR_DS_EXISTS_IN_RDNATTID" },
      {0x2197, "The directory service failed to authorize the request.", "ERROR_DS_AUTHORIZATION_FAILED" },
      {0x2198, "The Directory Service cannot process the script because it is invalid.", "ERROR_DS_INVALID_SCRIPT" },
      {0x2199, "The remote create cross reference operation failed on the Domain Naming Master FSMO. The operation's error is in the extended data.", "ERROR_DS_REMOTE_CROSSREF_OP_FAILED" },
      {0x219A, "A cross reference is in use locally with the same name.", "ERROR_DS_CROSS_REF_BUSY" },
      {0x219B, "The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the server's domain has been deleted from the forest.", "ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN" },
      {0x219C, "Writeable NCs prevent this DC from demoting.", "ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC" },
      {0x219D, "The requested object has a non-unique identifier and cannot be retrieved.", "ERROR_DS_DUPLICATE_ID_FOUND" },
      {0x219E, "Insufficient attributes were given to create an object. This object may not exist because it may have been deleted and already garbage collected.", "ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT" },
      {0x219F, "The group cannot be converted due to attribute restrictions on the requested group type.", "ERROR_DS_GROUP_CONVERSION_ERROR" },
      {0x21A0, "Cross-domain move of non-empty basic application groups is not allowed.", "ERROR_DS_CANT_MOVE_APP_BASIC_GROUP" },
      {0x21A1, "Cross-domain move on non-empty query based application groups is not allowed.", "ERROR_DS_CANT_MOVE_APP_QUERY_GROUP" },
      {0x21A2, "The role owner could not be verified because replication of its partition has not occurred recently.", "ERROR_DS_ROLE_NOT_VERIFIED" },
      {0x21A3, "The target container for a redirection of a well-known object container cannot already be a special container.", "ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL" },
      {0x21A4, "The Directory Service cannot perform the requested operation because a domain rename operation is in progress.", "ERROR_DS_DOMAIN_RENAME_IN_PROGRESS" },
      {0x21A5, "The Active Directory detected an Active Directory child partition below the requested new partition name. The Active Directory's partition hierarchy must be created in a top-down method.", "ERROR_DS_EXISTING_AD_CHILD_NC" },
      {0x21A6, "The Active Directory cannot replicate with this server because the time since the last replication with this server has exceeded the tombstone lifetime.", "ERROR_DS_REPL_LIFETIME_EXCEEDED" },
      {0x21A7, "The requested operation is not allowed on an object under the system container.", "ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER" },
      {0x21A8, "The LDAP servers network send queue has filled up because the client is not processing the results of it's requests fast enough. No more requests will be processed until the client catches up. If the client does not catch up then it will be disconnected.", "ERROR_DS_LDAP_SEND_QUEUE_FULL" },
      {0x21A9, "The scheduled replication did not take place because the system was too busy to execute the request within the schedule window. The replication queue is overloaded. Consider reducing the number of partners or decreasing the scheduled replication frequency.", "ERROR_DS_DRA_OUT_SCHEDULE_WINDOW" },
      {0x2329, "DNS server unable to interpret format.", "DNS_ERROR_RCODE_FORMAT_ERROR" },
      {0x232A, "DNS server failure.", "DNS_ERROR_RCODE_SERVER_FAILURE" },
      {0x232B, "DNS name does not exist.", "DNS_ERROR_RCODE_NAME_ERROR" },
      {0x232C, "DNS request not supported by name server.", "DNS_ERROR_RCODE_NOT_IMPLEMENTED" },
      {0x232D, "DNS operation refused.", "DNS_ERROR_RCODE_REFUSED" },
      {0x232E, "DNS name that ought not exist, does exist.", "DNS_ERROR_RCODE_YXDOMAIN" },
      {0x232F, "DNS RR set that ought not exist, does exist.", "DNS_ERROR_RCODE_YXRRSET" },
      {0x2330, "DNS RR set that ought to exist, does not exist.", "DNS_ERROR_RCODE_NXRRSET" },
      {0x2331, "DNS server not authoritative for zone.", "DNS_ERROR_RCODE_NOTAUTH" },
      {0x2332, "DNS name in update or prereq is not in zone.", "DNS_ERROR_RCODE_NOTZONE" },
      {0x2338, "DNS signature failed to verify.", "DNS_ERROR_RCODE_BADSIG" },
      {0x2339, "DNS bad key.", "DNS_ERROR_RCODE_BADKEY" },
      {0x233A, "DNS signature validity expired.", "DNS_ERROR_RCODE_BADTIME" },
      {0x251D, "No records found for given DNS query.", "DNS_INFO_NO_RECORDS" },
      {0x251E, "Bad DNS packet.", "DNS_ERROR_BAD_PACKET" },
      {0x251F, "No DNS packet.", "DNS_ERROR_NO_PACKET" },
      {0x2520, "DNS error, check rcode.", "DNS_ERROR_RCODE" },
      {0x2521, "Unsecured DNS packet.", "DNS_ERROR_UNSECURE_PACKET" },
      {0x254F, "Invalid DNS type.", "DNS_ERROR_INVALID_TYPE" },
      {0x2550, "Invalid IP address.", "DNS_ERROR_INVALID_IP_ADDRESS" },
      {0x2551, "Invalid property.", "DNS_ERROR_INVALID_PROPERTY" },
      {0x2552, "Try DNS operation again later.", "DNS_ERROR_TRY_AGAIN_LATER" },
      {0x2553, "Record for given name and type is not unique.", "DNS_ERROR_NOT_UNIQUE" },
      {0x2554, "DNS name does not comply with RFC specifications.", "DNS_ERROR_NON_RFC_NAME" },
      {0x2555, "DNS name is a fully-qualified DNS name.", "DNS_STATUS_FQDN" },
      {0x2556, "DNS name is dotted (multi-label).", "DNS_STATUS_DOTTED_NAME" },
      {0x2557, "DNS name is a single-part name.", "DNS_STATUS_SINGLE_PART_NAME" },
      {0x2558, "DSN name contains an invalid character.", "DNS_ERROR_INVALID_NAME_CHAR" },
      {0x2559, "DNS name is entirely numeric.", "DNS_ERROR_NUMERIC_NAME" },
      {0x255A, "The operation requested is not permitted on a DNS root server.", "DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER" },
      {0x255B, "The record could not be created because this part of the DNS namespace has been delegated to another server.", "DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION" },
      {0x255C, "The DNS server could not find a set of root hints.", "DNS_ERROR_CANNOT_FIND_ROOT_HINTS" },
      {0x255D, "The DNS server found root hints but they were not consistent across all adapters.", "DNS_ERROR_INCONSISTENT_ROOT_HINTS" },
      {0x2581, "DNS zone does not exist.", "DNS_ERROR_ZONE_DOES_NOT_EXIST" },
      {0x2582, "DNS zone information not available.", "DNS_ERROR_NO_ZONE_INFO" },
      {0x2583, "Invalid operation for DNS zone.", "DNS_ERROR_INVALID_ZONE_OPERATION" },
      {0x2584, "Invalid DNS zone configuration.", "DNS_ERROR_ZONE_CONFIGURATION_ERROR" },
      {0x2585, "DNS zone has no start of authority (SOA) record.", "DNS_ERROR_ZONE_HAS_NO_SOA_RECORD" },
      {0x2586, "DNS zone has no name server (NS) record.", "DNS_ERROR_ZONE_HAS_NO_NS_RECORDS" },
      {0x2587, "DNS zone is locked.", "DNS_ERROR_ZONE_LOCKED" },
      {0x2588, "DNS zone creation failed.", "DNS_ERROR_ZONE_CREATION_FAILED" },
      {0x2589, "DNS zone already exists.", "DNS_ERROR_ZONE_ALREADY_EXISTS" },
      {0x258A, "DNS automatic zone already exists.", "DNS_ERROR_AUTOZONE_ALREADY_EXISTS" },
      {0x258B, "Invalid DNS zone type.", "DNS_ERROR_INVALID_ZONE_TYPE" },
      {0x258C, "Secondary DNS zone requires master IP address.", "DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP" },
      {0x258D, "DNS zone not secondary.", "DNS_ERROR_ZONE_NOT_SECONDARY" },
      {0x258E, "Need secondary IP address.", "DNS_ERROR_NEED_SECONDARY_ADDRESSES" },
      {0x258F, "WINS initialization failed.", "DNS_ERROR_WINS_INIT_FAILED" },
      {0x2590, "Need WINS servers.", "DNS_ERROR_NEED_WINS_SERVERS" },
      {0x2591, "NBTSTAT initialization call failed.", "DNS_ERROR_NBSTAT_INIT_FAILED" },
      {0x2592, "Invalid delete of start of authority (SOA)", "DNS_ERROR_SOA_DELETE_INVALID" },
      {0x2593, "A conditional forwarding zone already exists for that name.", "DNS_ERROR_FORWARDER_ALREADY_EXISTS" },
      {0x2594, "This zone must be configured with one or more master DNS server IP addresses.", "DNS_ERROR_ZONE_REQUIRES_MASTER_IP" },
      {0x2595, "The operation cannot be performed because this zone is shutdown.", "DNS_ERROR_ZONE_IS_SHUTDOWN" },
      {0x25B3, "Primary DNS zone requires datafile.", "DNS_ERROR_PRIMARY_REQUIRES_DATAFILE" },
      {0x25B4, "Invalid datafile name for DNS zone.", "DNS_ERROR_INVALID_DATAFILE_NAME" },
      {0x25B5, "Failed to open datafile for DNS zone.", "DNS_ERROR_DATAFILE_OPEN_FAILURE" },
      {0x25B6, "Failed to write datafile for DNS zone.", "DNS_ERROR_FILE_WRITEBACK_FAILED" },
      {0x25B7, "Failure while reading datafile for DNS zone.", "DNS_ERROR_DATAFILE_PARSING" },
      {0x25E5, "DNS record does not exist.", "DNS_ERROR_RECORD_DOES_NOT_EXIST" },
      {0x25E6, "DNS record format error.", "DNS_ERROR_RECORD_FORMAT" },
      {0x25E7, "Node creation failure in DNS.", "DNS_ERROR_NODE_CREATION_FAILED" },
      {0x25E8, "Unknown DNS record type.", "DNS_ERROR_UNKNOWN_RECORD_TYPE" },
      {0x25E9, "DNS record timed out.", "DNS_ERROR_RECORD_TIMED_OUT" },
      {0x25EA, "Name not in DNS zone.", "DNS_ERROR_NAME_NOT_IN_ZONE" },
      {0x25EB, "CNAME loop detected.", "DNS_ERROR_CNAME_LOOP" },
      {0x25EC, "Node is a CNAME DNS record.", "DNS_ERROR_NODE_IS_CNAME" },
      {0x25ED, "A CNAME record already exists for given name.", "DNS_ERROR_CNAME_COLLISION" },
      {0x25EE, "Record only at DNS zone root.", "DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT" },
      {0x25EF, "DNS record already exists.", "DNS_ERROR_RECORD_ALREADY_EXISTS" },
      {0x25F0, "Secondary DNS zone data error.", "DNS_ERROR_SECONDARY_DATA" },
      {0x25F1, "Could not create DNS cache data.", "DNS_ERROR_NO_CREATE_CACHE_DATA" },
      {0x25F2, "DNS name does not exist.", "DNS_ERROR_NAME_DOES_NOT_EXIST" },
      {0x25F3, "Could not create pointer (PTR) record.", "DNS_WARNING_PTR_CREATE_FAILED" },
      {0x25F4, "DNS domain was undeleted.", "DNS_WARNING_DOMAIN_UNDELETED" },
      {0x25F5, "The directory service is unavailable.", "DNS_ERROR_DS_UNAVAILABLE" },
      {0x25F6, "DNS zone already exists in the directory service.", "DNS_ERROR_DS_ZONE_ALREADY_EXISTS" },
      {0x25F7, "DNS server not creating or reading the boot file for the directory service integrated DNS zone.", "DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE" },
      {0x2617, "DNS AXFR (zone transfer) complete.", "DNS_INFO_AXFR_COMPLETE" },
      {0x2618, "DNS zone transfer failed.", "DNS_ERROR_AXFR" },
      {0x2619, "Added local WINS server.", "DNS_INFO_ADDED_LOCAL_WINS" },
      {0x2649, "Secure update call needs to continue update request.", "DNS_STATUS_CONTINUE_NEEDED" },
      {0x267B, "TCP/IP network protocol not installed.", "DNS_ERROR_NO_TCPIP" },
      {0x267C, "No DNS servers configured for local system.", "DNS_ERROR_NO_DNS_SERVERS" },
      {0x26AD, "The specified directory partition does not exist.", "DNS_ERROR_DP_DOES_NOT_EXIST" },
      {0x26AE, "The specified directory partition already exists.", "DNS_ERROR_DP_ALREADY_EXISTS" },
      {0x26AF, "The DNS server is not enlisted in the specified directory partition.", "DNS_ERROR_DP_NOT_ENLISTED" },
      {0x26B0, "The DNS server is already enlisted in the specified directory partition.", "DNS_ERROR_DP_ALREADY_ENLISTED" },
      {0x26B1, "The directory partition is not available at this time. Please wait a few minutes and try again.", "DNS_ERROR_DP_NOT_AVAILABLE" },
      {0x26B2, "The application directory partition operation failed. The domain controller holding the domain naming master role is down or unable to service the request or is not running Windows Server 2003.", "DNS_ERROR_DP_FSMO_ERROR" },
      {0x2714, "A blocking operation was interrupted by a call to WSACancelBlockingCall.", "WSAEINTR" },
      {0x2719, "The file handle supplied is not valid.", "WSAEBADF" },
      {0x271D, "An attempt was made to access a socket in a way forbidden by its access permissions.", "WSAEACCES" },
      {0x271E, "The system detected an invalid pointer address in attempting to use a pointer argument in a call.", "WSAEFAULT" },
      {0x2726, "An invalid argument was supplied.", "WSAEINVAL" },
      {0x2728, "Too many open sockets.", "WSAEMFILE" },
      {0x2733, "A non-blocking socket operation could not be completed immediately.", "WSAEWOULDBLOCK" },
      {0x2734, "A blocking operation is currently executing.", "WSAEINPROGRESS" },
      {0x2735, "An operation was attempted on a non-blocking socket that already had an operation in progress.", "WSAEALREADY" },
      {0x2736, "An operation was attempted on something that is not a socket.", "WSAENOTSOCK" },
      {0x2737, "A required address was omitted from an operation on a socket.", "WSAEDESTADDRREQ" },
      {0x2738, "A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram into was smaller than the datagram itself.", "WSAEMSGSIZE" },
      {0x2739, "A protocol was specified in the socket function call that does not support the semantics of the socket type requested.", "WSAEPROTOTYPE" },
      {0x273A, "An unknown, invalid, or unsupported option or level was specified in a getsockopt or setsockopt call.", "WSAENOPROTOOPT" },
      {0x273B, "The requested protocol has not been configured into the system, or no implementation for it exists.", "WSAEPROTONOSUPPORT" },
      {0x273C, "The support for the specified socket type does not exist in this address family.", "WSAESOCKTNOSUPPORT" },
      {0x273D, "The attempted operation is not supported for the type of object referenced.", "WSAEOPNOTSUPP" },
      {0x273E, "The protocol family has not been configured into the system or no implementation for it exists.", "WSAEPFNOSUPPORT" },
      {0x273F, "An address incompatible with the requested protocol was used.", "WSAEAFNOSUPPORT" },
      {0x2740, "Only one usage of each socket address (protocol/network address/port) is normally permitted.", "WSAEADDRINUSE" },
      {0x2741, "The requested address is not valid in its context.", "WSAEADDRNOTAVAIL" },
      {0x2742, "A socket operation encountered a dead network.", "WSAENETDOWN" },
      {0x2743, "A socket operation was attempted to an unreachable network.", "WSAENETUNREACH" },
      {0x2744, "The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.", "WSAENETRESET" },
      {0x2745, "An established connection was aborted by the software in your host machine.", "WSAECONNABORTED" },
      {0x2746, "An existing connection was forcibly closed by the remote host.", "WSAECONNRESET" },
      {0x2747, "An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.", "WSAENOBUFS" },
      {0x2748, "A connect request was made on an already connected socket.", "WSAEISCONN" },
      {0x2749, "A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using a sendto call) no address was supplied.", "WSAENOTCONN" },
      {0x274A, "A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call.", "WSAESHUTDOWN" },
      {0x274B, "Too many references to some kernel object.", "WSAETOOMANYREFS" },
      {0x274C, "A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.", "WSAETIMEDOUT" },
      {0x274D, "No connection could be made because the target machine actively refused it.", "WSAECONNREFUSED" },
      {0x274E, "Cannot translate name.", "WSAELOOP" },
      {0x274F, "Name component or name was too long.", "WSAENAMETOOLONG" },
      {0x2750, "A socket operation failed because the destination host was down.", "WSAEHOSTDOWN" },
      {0x2751, "A socket operation was attempted to an unreachable host.", "WSAEHOSTUNREACH" },
      {0x2752, "Cannot remove a directory that is not empty.", "WSAENOTEMPTY" },
      {0x2753, "A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously.", "WSAEPROCLIM" },
      {0x2754, "Ran out of quota.", "WSAEUSERS" },
      {0x2755, "Ran out of disk quota.", "WSAEDQUOT" },
      {0x2756, "File handle reference is no longer available.", "WSAESTALE" },
      {0x2757, "Item is not available locally.", "WSAEREMOTE" },
      {0x276B, "WSAStartup cannot function at this time because the underlying system it uses to provide network services is currently unavailable.", "WSASYSNOTREADY" },
      {0x276C, "The Windows Sockets version requested is not supported.", "WSAVERNOTSUPPORTED" },
      {0x276D, "Either the application has not called WSAStartup, or WSAStartup failed.", "WSANOTINITIALISED" },
      {0x2775, "Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown sequence.", "WSAEDISCON" },
      {0x2776, "No more results can be returned by WSALookupServiceNext.", "WSAENOMORE" },
      {0x2777, "A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.", "WSAECANCELLED" },
      {0x2778, "The procedure call table is invalid.", "WSAEINVALIDPROCTABLE" },
      {0x2779, "The requested service provider is invalid.", "WSAEINVALIDPROVIDER" },
      {0x277A, "The requested service provider could not be loaded or initialized.", "WSAEPROVIDERFAILEDINIT" },
      {0x277B, "A system call that should never fail has failed.", "WSASYSCALLFAILURE" },
      {0x277C, "No such service is known. The service cannot be found in the specified name space.", "WSASERVICE_NOT_FOUND" },
      {0x277D, "The specified class was not found.", "WSATYPE_NOT_FOUND" },
      {0x277E, "No more results can be returned by WSALookupServiceNext.", "WSA_E_NO_MORE" },
      {0x277F, "A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.", "WSA_E_CANCELLED" },
      {0x2780, "A database query failed because it was actively refused.", "WSAEREFUSED" },
      {0x2AF9, "No such host is known.", "WSAHOST_NOT_FOUND" },
      {0x2AFA, "This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server.", "WSATRY_AGAIN" },
      {0x2AFB, "A non-recoverable error occurred during a database lookup.", "WSANO_RECOVERY" },
      {0x2AFC, "The requested name is valid, but no data of the requested type was found.", "WSANO_DATA" },
      {0x2AFD, "At least one reserve has arrived.", "WSA_QOS_RECEIVERS" },
      {0x2AFE, "At least one path has arrived.", "WSA_QOS_SENDERS" },
      {0x2AFF, "There are no senders.", "WSA_QOS_NO_SENDERS" },
      {0x2B00, "There are no receivers.", "WSA_QOS_NO_RECEIVERS" },
      {0x2B01, "Reserve has been confirmed.", "WSA_QOS_REQUEST_CONFIRMED" },
      {0x2B02, "Error due to lack of resources.", "WSA_QOS_ADMISSION_FAILURE" },
      {0x2B03, "Rejected for administrative reasons - bad credentials.", "WSA_QOS_POLICY_FAILURE" },
      {0x2B04, "Unknown or conflicting style.", "WSA_QOS_BAD_STYLE" },
      {0x2B05, "Problem with some part of the filterspec or providerspecific buffer in general.", "WSA_QOS_BAD_OBJECT" },
      {0x2B06, "Problem with some part of the flowspec.", "WSA_QOS_TRAFFIC_CTRL_ERROR" },
      {0x2B07, "General QOS error.", "WSA_QOS_GENERIC_ERROR" },
      {0x2B08, "An invalid or unrecognized service type was found in the flowspec.", "WSA_QOS_ESERVICETYPE" },
      {0x2B09, "An invalid or inconsistent flowspec was found in the QOS structure.", "WSA_QOS_EFLOWSPEC" },
      {0x2B0A, "Invalid QOS provider-specific buffer.", "WSA_QOS_EPROVSPECBUF" },
      {0x2B0B, "An invalid QOS filter style was used.", "WSA_QOS_EFILTERSTYLE" },
      {0x2B0C, "An invalid QOS filter type was used.", "WSA_QOS_EFILTERTYPE" },
      {0x2B0D, "An incorrect number of QOS FILTERSPECs were specified in the FLOWDESCRIPTOR.", "WSA_QOS_EFILTERCOUNT" },
      {0x2B0E, "An object with an invalid ObjectLength field was specified in the QOS provider-specific buffer.", "WSA_QOS_EOBJLENGTH" },
      {0x2B0F, "An incorrect number of flow descriptors was specified in the QOS structure.", "WSA_QOS_EFLOWCOUNT" },
      {0x2B10, "An unrecognized object was found in the QOS provider-specific buffer.", "WSA_QOS_EUNKNOWNPSOBJ" },
      {0x2B11, "An invalid policy object was found in the QOS provider-specific buffer.", "WSA_QOS_EPOLICYOBJ" },
      {0x2B12, "An invalid QOS flow descriptor was found in the flow descriptor list.", "WSA_QOS_EFLOWDESC" },
      {0x2B13, "An invalid or inconsistent flowspec was found in the QOS provider-specific buffer.", "WSA_QOS_EPSFLOWSPEC" },
      {0x2B14, "An invalid FILTERSPEC was found in the QOS provider-specific buffer.", "WSA_QOS_EPSFILTERSPEC" },
      {0x2B15, "An invalid shape discard mode object was found in the QOS provider-specific buffer.", "WSA_QOS_ESDMODEOBJ" },
      {0x2B16, "An invalid shaping rate object was found in the QOS provider-specific buffer.", "WSA_QOS_ESHAPERATEOBJ" },
      {0x2B17, "A reserved policy element was found in the QOS provider-specific buffer.", "WSA_QOS_RESERVED_PETYPE" },
      {0x2EE0, "The IO was completed by a filter.", "ERROR_FLT_IO_COMPLETE" },
      {0x2EE1, "The buffer is too small to contain the entry. No information has been written to the buffer.", "ERROR_FLT_BUFFER_TOO_SMALL" },
      {0x2EE2, "A handler was not defined by the filter for this operation.", "ERROR_FLT_NO_HANDLER_DEFINED" },
      {0x2EE3, "A context is already defined for this object.", "ERROR_FLT_CONTEXT_ALREADY_DEFINED" },
      {0x2EE4, "Asynchronous requests are not valid for this operation.", "ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST" },
      {0x2EE5, "Disallow the Fast IO path for this operation.", "ERROR_FLT_DISALLOW_FAST_IO" },
      {0x2EE6, "An invalid name request was made. The name requested cannot be retrieved at this time.", "ERROR_FLT_INVALID_NAME_REQUEST" },
      {0x2EE7, "Posting this operation to a worker thread for further processing is not safe at this time because it could lead to a system deadlock. ", "ERROR_FLT_NOT_SAFE_TO_POST_OPERATION" },
      {0x2EE8, "The Filter Manager was not initialized when a filter tried to register. Make sure that the Filter Manager is getting loaded as a driver. ", "ERROR_FLT_NOT_INITIALIZED" },
      {0x2EE9, "The filter is not ready for attachment to volumes because it has not finished initializing (FltStartFiltering has not been called). ", "ERROR_FLT_FILTER_NOT_READY" },
      {0x2EEA, "The filter must cleanup any operation specific context at this time because it is being removed from the system before the operation is completed by the lower drivers. ", "ERROR_FLT_POST_OPERATION_CLEANUP" },
      {0x2EEB, "The Filter Manager had an internal error from which it cannot recover, therefore the operation has been failed. This is usually the result of a filter returning an invalid value from a pre-operation callback.", "ERROR_FLT_INTERNAL_ERROR" },
      {0x2EEC, "The object specified for this action is in the process of being deleted, therefore the action requested cannot be completed at this time.", "ERROR_FLT_DELETING_OBJECT" },
      {0x2EED, "Non-paged pool must be used for this type of context.", "ERROR_FLT_MUST_BE_NONPAGED_POOL" },
      {0x2EEE, "A duplicate handler definition has been provided for an operation.", "ERROR_FLT_DUPLICATE_ENTRY" },
      {0x2EEF, "The callback data queue has been disabled.", "ERROR_FLT_CBDQ_DISABLED" },
      {0x2EF0, "Do not attach the filter to the volume at this time.", "ERROR_FLT_DO_NOT_ATTACH" },
      {0x2EF1, "Do not detach the filter from the volume at this time.", "ERROR_FLT_DO_NOT_DETACH" },
      {0x2EF2, "An instance already exists at this altitude on the volume specified.", "ERROR_FLT_INSTANCE_ALTITUDE_COLLISION" },
      {0x2EF3, "An instance already exists with this name on the volume specified.", "ERROR_FLT_INSTANCE_NAME_COLLISION" },
      {0x2EF4, "The system could not find the filter specified.", "ERROR_FLT_FILTER_NOT_FOUND" },
      {0x2EF5, "The system could not find the volume specified.", "ERROR_FLT_VOLUME_NOT_FOUND" },
      {0x2EF6, "The system could not find the instance specified.", "ERROR_FLT_INSTANCE_NOT_FOUND" },
      {0x2EF7, "No registered context allocation definition was found for the given request.", "ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND" },
      {0x2EF8, "An invalid parameter was specified during context registration.", "ERROR_FLT_INVALID_CONTEXT_REGISTRATION" },
      {0x2EF9, "The name requested was not found in Filter Manager's name cache and could not be retrieved from the file system.", "ERROR_FLT_NAME_CACHE_MISS" },
      {0x2EFA, "The requested device object does not exist for the given volume.", "ERROR_FLT_NO_DEVICE_OBJECT" },
      {0x2EFB, "The specified volume is already mounted.", "ERROR_FLT_VOLUME_ALREADY_MOUNTED" },
      {0x2EFC, "No waiter is present for the filter's reply to this message.", "ERROR_FLT_NO_WAITER_FOR_REPLY" },
      {0x32C8, "The specified quick mode policy already exists.", "ERROR_IPSEC_QM_POLICY_EXISTS" },
      {0x32C9, "The specified quick mode policy was not found.", "ERROR_IPSEC_QM_POLICY_NOT_FOUND" },
      {0x32CA, "The specified quick mode policy is being used.", "ERROR_IPSEC_QM_POLICY_IN_USE" },
      {0x32CB, "The specified main mode policy already exists.", "ERROR_IPSEC_MM_POLICY_EXISTS" },
      {0x32CC, "The specified main mode policy was not found.", "ERROR_IPSEC_MM_POLICY_NOT_FOUND" },
      {0x32CD, "The specified main mode policy is being used.", "ERROR_IPSEC_MM_POLICY_IN_USE" },
      {0x32CE, "The specified main mode filter already exists.", "ERROR_IPSEC_MM_FILTER_EXISTS" },
      {0x32CF, "The specified main mode filter was not found.", "ERROR_IPSEC_MM_FILTER_NOT_FOUND" },
      {0x32D0, "The specified transport mode filter already exists.", "ERROR_IPSEC_TRANSPORT_FILTER_EXISTS" },
      {0x32D1, "The specified transport mode filter does not exist.", "ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND" },
      {0x32D2, "The specified main mode authentication list exists.", "ERROR_IPSEC_MM_AUTH_EXISTS" },
      {0x32D3, "The specified main mode authentication list was not found.", "ERROR_IPSEC_MM_AUTH_NOT_FOUND" },
      {0x32D4, "The specified quick mode policy is being used.", "ERROR_IPSEC_MM_AUTH_IN_USE" },
      {0x32D5, "The specified main mode policy was not found.", "ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND" },
      {0x32D6, "The specified quick mode policy was not found.", "ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND" },
      {0x32D7, "The manifest file contains one or more syntax errors.", "ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND" },
      {0x32D8, "The application attempted to activate a disabled activation context.", "ERROR_IPSEC_TUNNEL_FILTER_EXISTS" },
      {0x32D9, "The requested lookup key was not found in any active activation context.", "ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND" },
      {0x32DA, "The Main Mode filter is pending deletion.", "ERROR_IPSEC_MM_FILTER_PENDING_DELETION" },
      {0x32DB, "The transport filter is pending deletion.", "ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION" },
      {0x32DC, "The tunnel filter is pending deletion.", "ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION" },
      {0x32DD, "The Main Mode policy is pending deletion.", "ERROR_IPSEC_MM_POLICY_PENDING_DELETION" },
      {0x32DE, "The Main Mode authentication bundle is pending deletion.", "ERROR_IPSEC_MM_AUTH_PENDING_DELETION" },
      {0x32DF, "The Quick Mode policy is pending deletion.", "ERROR_IPSEC_QM_POLICY_PENDING_DELETION" },
      {0x32E0, "The Main Mode policy was successfully added, but some of the requested offers are not supported.", "WARNING_IPSEC_MM_POLICY_PRUNED" },
      {0x32E1, "The Quick Mode policy was successfully added, but some of the requested offers are not supported.", "WARNING_IPSEC_QM_POLICY_PRUNED" },
      {0x35E9, "IKE authentication credentials are unacceptable.", "ERROR_IPSEC_IKE_AUTH_FAIL" },
      {0x35EA, "IKE security attributes are unacceptable.", "ERROR_IPSEC_IKE_ATTRIB_FAIL" },
      {0x35EB, "IKE Negotiation in progress.", "ERROR_IPSEC_IKE_NEGOTIATION_PENDING" },
      {0x35EC, "General processing error.", "ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR" },
      {0x35ED, "Negotiation timed out.", "ERROR_IPSEC_IKE_TIMED_OUT" },
      {0x35EE, "IKE failed to find valid machine certificate.", "ERROR_IPSEC_IKE_NO_CERT" },
      {0x35EF, "IKE SA deleted by peer before establishment completed.", "ERROR_IPSEC_IKE_SA_DELETED" },
      {0x35F0, "IKE SA deleted before establishment completed.", "ERROR_IPSEC_IKE_SA_REAPED" },
      {0x35F1, "Negotiation request sat in Queue too long.", "ERROR_IPSEC_IKE_MM_ACQUIRE_DROP" },
      {0x35F2, "Negotiation request sat in Queue too long.", "ERROR_IPSEC_IKE_QM_ACQUIRE_DROP" },
      {0x35F3, "Negotiation request sat in Queue too long.", "ERROR_IPSEC_IKE_QUEUE_DROP_MM" },
      {0x35F4, "Negotiation request sat in Queue too long.", "ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM" },
      {0x35F5, "No response from peer.", "ERROR_IPSEC_IKE_DROP_NO_RESPONSE" },
      {0x35F6, "Negotiation took too long.", "ERROR_IPSEC_IKE_MM_DELAY_DROP" },
      {0x35F7, "Negotiation took too long.", "ERROR_IPSEC_IKE_QM_DELAY_DROP" },
      {0x35F8, "Unknown error occurred.", "ERROR_IPSEC_IKE_ERROR" },
      {0x35F9, "Certificate Revocation Check failed.", "ERROR_IPSEC_IKE_CRL_FAILED" },
      {0x35FA, "Invalid certificate key usage.", "ERROR_IPSEC_IKE_INVALID_KEY_USAGE" },
      {0x35FB, "Invalid certificate type.", "ERROR_IPSEC_IKE_INVALID_CERT_TYPE" },
      {0x35FC, "No private key associated with machine certificate.", "ERROR_IPSEC_IKE_NO_PRIVATE_KEY" },
      {0x35FE, "Failure in Diffie-Hellman computation.", "ERROR_IPSEC_IKE_DH_FAIL" },
      {0x3600, "Invalid header.", "ERROR_IPSEC_IKE_INVALID_HEADER" },
      {0x3601, "No policy configured.", "ERROR_IPSEC_IKE_NO_POLICY" },
      {0x3602, "Failed to verify signature.", "ERROR_IPSEC_IKE_INVALID_SIGNATURE" },
      {0x3603, "Failed to authenticate using Kerberos.", "ERROR_IPSEC_IKE_KERBEROS_ERROR" },
      {0x3604, "Peer's certificate did not have a public key.", "ERROR_IPSEC_IKE_NO_PUBLIC_KEY" },
      {0x3605, "Error processing error payload.", "ERROR_IPSEC_IKE_PROCESS_ERR" },
      {0x3606, "Error processing SA payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_SA" },
      {0x3607, "Error processing Proposal payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_PROP" },
      {0x3608, "Error processing Transform payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_TRANS" },
      {0x3609, "Error processing KE payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_KE" },
      {0x360A, "Error processing ID payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_ID" },
      {0x360B, "Error processing Cert payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_CERT" },
      {0x360C, "Error processing Certificate Request payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ" },
      {0x360D, "Error processing Hash payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_HASH" },
      {0x360E, "Error processing Signature payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_SIG" },
      {0x360F, "Error processing Nonce payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_NONCE" },
      {0x3610, "Error processing Notify payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY" },
      {0x3611, "Error processing Delete Payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_DELETE" },
      {0x3612, "Error processing VendorId payload.", "ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR" },
      {0x3613, "Invalid payload received.", "ERROR_IPSEC_IKE_INVALID_PAYLOAD" },
      {0x3614, "Soft SA loaded.", "ERROR_IPSEC_IKE_LOAD_SOFT_SA" },
      {0x3615, "Soft SA torn down.", "ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN" },
      {0x3616, "Invalid cookie received..", "ERROR_IPSEC_IKE_INVALID_COOKIE" },
      {0x3617, "Peer failed to send valid machine certificate.", "ERROR_IPSEC_IKE_NO_PEER_CERT" },
      {0x3618, "Certification Revocation check of peer's certificate failed.", "ERROR_IPSEC_IKE_PEER_CRL_FAILED" },
      {0x3619, "New policy invalidated SAs formed with old policy.", "ERROR_IPSEC_IKE_POLICY_CHANGE" },
      {0x361A, "There is no available Main Mode IKE policy.", "ERROR_IPSEC_IKE_NO_MM_POLICY" },
      {0x361B, "Failed to enabled TCB privilege.", "ERROR_IPSEC_IKE_NOTCBPRIV" },
      {0x361C, "Failed to load SECURITY.DLL.", "ERROR_IPSEC_IKE_SECLOADFAIL" },
      {0x361D, "Failed to obtain security function table dispatch address from SSPI.", "ERROR_IPSEC_IKE_FAILSSPINIT" },
      {0x361E, "Failed to query Kerberos package to obtain max token size.", "ERROR_IPSEC_IKE_FAILQUERYSSP" },
      {0x361F, "Failed to obtain Kerberos server credentials for ISAKMP/ERROR_IPSEC_IKE service. Kerberos authentication will not function. The most likely reason for this is lack of domain membership. This is normal if your computer is a member of a workgroup.", "ERROR_IPSEC_IKE_SRVACQFAIL" },
      {0x3620, "Failed to determine SSPI principal name for ISAKMP/ERROR_IPSEC_IKE service (QueryCredentialsAttributes).", "ERROR_IPSEC_IKE_SRVQUERYCRED" },
      {0x3621, "Failed to obtain new SPI for the inbound SA from IPSec driver. The most common cause for this is that the driver does not have the correct filter. Check your policy to verify the filters.", "ERROR_IPSEC_IKE_GETSPIFAIL" },
      {0x3622, "Given filter is invalid.", "ERROR_IPSEC_IKE_INVALID_FILTER" },
      {0x3623, "Memory allocation failed.", "ERROR_IPSEC_IKE_OUT_OF_MEMORY" },
      {0x3624, "Failed to add Security Association to IPSec Driver. The most common cause for this is if the IKE negotiation took too long to complete. If the problem persists, reduce the load on the faulting machine.", "ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED" },
      {0x3625, "Invalid policy.", "ERROR_IPSEC_IKE_INVALID_POLICY" },
      {0x3626, "Invalid DOI.", "ERROR_IPSEC_IKE_UNKNOWN_DOI" },
      {0x3627, "Invalid situation.", "ERROR_IPSEC_IKE_INVALID_SITUATION" },
      {0x3628, "Diffie-Hellman failure.", "ERROR_IPSEC_IKE_DH_FAILURE" },
      {0x3629, "Invalid Diffie-Hellman group.", "ERROR_IPSEC_IKE_INVALID_GROUP" },
      {0x362A, "Error encrypting payload.", "ERROR_IPSEC_IKE_ENCRYPT" },
      {0x362B, "Error decrypting payload.", "ERROR_IPSEC_IKE_DECRYPT" },
      {0x362C, "Policy match error.", "ERROR_IPSEC_IKE_POLICY_MATCH" },
      {0x362D, "Unsupported ID.", "ERROR_IPSEC_IKE_UNSUPPORTED_ID" },
      {0x362E, "Hash verification failed.", "ERROR_IPSEC_IKE_INVALID_HASH" },
      {0x362F, "Invalid hash algorithm.", "ERROR_IPSEC_IKE_INVALID_HASH_ALG" },
      {0x3630, "Invalid hash size.", "ERROR_IPSEC_IKE_INVALID_HASH_SIZE" },
      {0x3631, "Invalid encryption algorithm.", "ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG" },
      {0x3632, "Invalid authentication algorithm.", "ERROR_IPSEC_IKE_INVALID_AUTH_ALG" },
      {0x3633, "Invalid certificate signature.", "ERROR_IPSEC_IKE_INVALID_SIG" },
      {0x3634, "Load failed.", "ERROR_IPSEC_IKE_LOAD_FAILED" },
      {0x3635, "Deleted via RPC call.", "ERROR_IPSEC_IKE_RPC_DELETE" },
      {0x3636, "Temporary state created to perform reinit. This is not a real failure.", "ERROR_IPSEC_IKE_BENIGN_REINIT" },
      {0x3637, "The lifetime value received in the Responder Lifetime Notify is below the Windows 2000 configured minimum value. Please fix the policy on the peer machine.", "ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY" },
      {0x3639, "Key length in certificate is too small for configured security requirements.", "ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN" },
      {0x363A, "Max number of established MM SAs to peer exceeded.", "ERROR_IPSEC_IKE_MM_LIMIT" },
      {0x363B, "IKE received a policy that disables negotiation.", "ERROR_IPSEC_IKE_NEGOTIATION_DISABLED" },
      {0x363C, "ERROR_IPSEC_IKE_NEG_STATUS_END", "ERROR_IPSEC_IKE_NEG_STATUS_END" },
      {0x36B0, "The requested section was not present in the activation context.", "ERROR_SXS_SECTION_NOT_FOUND" },
      {0x36B1, "This application has failed to start because the application configuration is incorrect. Reinstalling the application may fix this problem.", "ERROR_SXS_CANT_GEN_ACTCTX" },
      {0x36B2, "The application binding data format is invalid.", "ERROR_SXS_INVALID_ACTCTXDATA_FORMAT" },
      {0x36B3, "The referenced assembly is not installed on your system.", "ERROR_SXS_ASSEMBLY_NOT_FOUND" },
      {0x36B4, "The manifest file does not begin with the required tag and format information.", "ERROR_SXS_MANIFEST_FORMAT_ERROR" },
      {0x36B5, "The manifest file contains one or more syntax errors.", "ERROR_SXS_MANIFEST_PARSE_ERROR" },
      {0x36B6, "The application attempted to activate a disabled activation context.", "ERROR_SXS_ACTIVATION_CONTEXT_DISABLED" },
      {0x36B7, "The requested lookup key was not found in any active activation context.", "ERROR_SXS_KEY_NOT_FOUND" },
      {0x36B8, "A component version required by the application conflicts with another component version already active.", "ERROR_SXS_VERSION_CONFLICT" },
      {0x36B9, "The type requested activation context section does not match the query API used.", "ERROR_SXS_WRONG_SECTION_TYPE" },
      {0x36BA, "Lack of system resources has required isolated activation to be disabled for the current thread of execution.", "ERROR_SXS_THREAD_QUERIES_DISABLED" },
      {0x36BB, "An attempt to set the process default activation context failed because the process default activation context was already set.", "ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET" },
      {0x36BC, "The encoding group identifier specified is not recognized.", "ERROR_SXS_UNKNOWN_ENCODING_GROUP" },
      {0x36BD, "The encoding requested is not recognized.", "ERROR_SXS_UNKNOWN_ENCODING" },
      {0x36BE, "The manifest contains a reference to an invalid URI.", "ERROR_SXS_INVALID_XML_NAMESPACE_URI" },
      {0x36BF, "The application manifest contains a reference to a dependent assembly which is not installed.", "ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED" },
      {0x36C0, "The manifest for an assembly used by the application has a reference to a dependent assembly which is not installed.", "ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED" },
      {0x36C1, "The manifest contains an attribute for the assembly identity which is not valid.", "ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE" },
      {0x36C2, "The manifest is missing the required default namespace specification on the assembly element.", "ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE" },
      {0x36C3, "The manifest has a default namespace specified on the assembly element but its value is not \"urn:schemas-microsoft-com:asm.v1\".", "ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE" },
      {0x36C4, "The private manifest probe has crossed the reparse-point-associated path.", "ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT" },
      {0x36C5, "Two or more components referenced directly or indirectly by the application manifest have files by the same name.", "ERROR_SXS_DUPLICATE_DLL_NAME" },
      {0x36C6, "Two or more components referenced directly or indirectly by the application manifest have window classes with the same name.", "ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME" },
      {0x36C7, "Two or more components referenced directly or indirectly by the application manifest have the same COM server CLSIDs.", "ERROR_SXS_DUPLICATE_CLSID" },
      {0x36C8, "Two or more components referenced directly or indirectly by the application manifest have proxies for the same COM interface IIDs.", "ERROR_SXS_DUPLICATE_IID" },
      {0x36C9, "Two or more components referenced directly or indirectly by the application manifest have the same COM type library TLBIDs.", "ERROR_SXS_DUPLICATE_TLBID" },
      {0x36CA, "Two or more components referenced directly or indirectly by the application manifest have the same COM ProgIDs.", "ERROR_SXS_DUPLICATE_PROGID" },
      {0x36CB, "Two or more components referenced directly or indirectly by the application manifest are different versions of the same component which is not permitted.", "ERROR_SXS_DUPLICATE_ASSEMBLY_NAME" },
      {0x36CC, "A component's file does not match the verification information present in the component manifest.", "ERROR_SXS_FILE_HASH_MISMATCH" },
      {0x36CD, "The policy manifest contains one or more syntax errors.", "ERROR_SXS_POLICY_PARSE_ERROR" },
      {0x36CE, "Manifest Parse Error : A string literal was expected, but no opening quote character was found.", "ERROR_SXS_XML_E_MISSINGQUOTE" },
      {0x36CF, "Manifest Parse Error : Incorrect syntax was used in a comment.", "ERROR_SXS_XML_E_COMMENTSYNTAX" },
      {0x36D0, "Manifest Parse Error : A name was started with an invalid character.", "ERROR_SXS_XML_E_BADSTARTNAMECHAR" },
      {0x36D1, "Manifest Parse Error : A name contained an invalid character.", "ERROR_SXS_XML_E_BADNAMECHAR" },
      {0x36D2, "Manifest Parse Error : A string literal contained an invalid character.", "ERROR_SXS_XML_E_BADCHARINSTRING" },
      {0x36D3, "Manifest Parse Error : Invalid syntax for an XML declaration.", "ERROR_SXS_XML_E_XMLDECLSYNTAX" },
      {0x36D4, "Manifest Parse Error : An invalid character was found in text content.", "ERROR_SXS_XML_E_BADCHARDATA" },
      {0x36D5, "Manifest Parse Error : Required white space was missing.", "ERROR_SXS_XML_E_MISSINGWHITESPACE" },
      {0x36D6, "Manifest Parse Error : The character '>' was expected.", "ERROR_SXS_XML_E_EXPECTINGTAGEND" },
      {0x36D7, "Manifest Parse Error : A semi colon character was expected.", "ERROR_SXS_XML_E_MISSINGSEMICOLON" },
      {0x36D8, "Manifest Parse Error : Unbalanced parentheses.", "ERROR_SXS_XML_E_UNBALANCEDPAREN" },
      {0x36D9, "Manifest Parse Error : Internal error.", "ERROR_SXS_XML_E_INTERNALERROR" },
      {0x36DA, "Manifest Parse Error : White space is not allowed at this location.", "ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE" },
      {0x36DB, "Manifest Parse Error : End of file reached in invalid state for current encoding.", "ERROR_SXS_XML_E_INCOMPLETE_ENCODING" },
      {0x36DC, "Manifest Parse Error : Missing parenthesis.", "ERROR_SXS_XML_E_MISSING_PAREN" },
      {0x36DD, "Manifest Parse Error : A single or double closing quote character (\' or \") is missing.", "ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE" },
      {0x36DE, "Manifest Parse Error : Multiple colons are not allowed in a name.", "ERROR_SXS_XML_E_MULTIPLE_COLONS" },
      {0x36DF, "Manifest Parse Error : Invalid character for decimal digit.", "ERROR_SXS_XML_E_INVALID_DECIMAL" },
      {0x36E0, "Manifest Parse Error : Invalid character for hexadecimal digit.", "ERROR_SXS_XML_E_INVALID_HEXIDECIMAL" },
      {0x36E1, "Manifest Parse Error : Invalid Unicode character value for this platform.", "ERROR_SXS_XML_E_INVALID_UNICODE" },
      {0x36E2, "Manifest Parse Error : Expecting white space or '?'.", "ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK" },
      {0x36E3, "Manifest Parse Error : End tag was not expected at this location.", "ERROR_SXS_XML_E_UNEXPECTEDENDTAG" },
      {0x36E4, "Manifest Parse Error : The following tags were not closed: %1.", "ERROR_SXS_XML_E_UNCLOSEDTAG" },
      {0x36E5, "Manifest Parse Error : Duplicate attribute.", "ERROR_SXS_XML_E_DUPLICATEATTRIBUTE" },
      {0x36E6, "Manifest Parse Error : Only one top level element is allowed in an XML document.", "ERROR_SXS_XML_E_MULTIPLEROOTS" },
      {0x36E7, "Manifest Parse Error : Invalid at the top level of the document.", "ERROR_SXS_XML_E_INVALIDATROOTLEVEL" },
      {0x36E8, "Manifest Parse Error : Invalid XML declaration.", "ERROR_SXS_XML_E_BADXMLDECL" },
      {0x36E9, "Manifest Parse Error : XML document must have a top level element.", "ERROR_SXS_XML_E_MISSINGROOT" },
      {0x36EA, "Manifest Parse Error : Unexpected end of file.", "ERROR_SXS_XML_E_UNEXPECTEDEOF" },
      {0x36EB, "Manifest Parse Error : Parameter entities cannot be used inside markup declarations in an internal subset.", "ERROR_SXS_XML_E_BADPEREFINSUBSET" },
      {0x36EC, "Manifest Parse Error : Element was not closed.", "ERROR_SXS_XML_E_UNCLOSEDSTARTTAG" },
      {0x36ED, "Manifest Parse Error : End element was missing the character '>'.", "ERROR_SXS_XML_E_UNCLOSEDENDTAG" },
      {0x36EE, "Manifest Parse Error : A string literal was not closed.", "ERROR_SXS_XML_E_UNCLOSEDSTRING" },
      {0x36EF, "Manifest Parse Error : A comment was not closed.", "ERROR_SXS_XML_E_UNCLOSEDCOMMENT" },
      {0x36F0, "Manifest Parse Error : A declaration was not closed.", "ERROR_SXS_XML_E_UNCLOSEDDECL" },
      {0x36F1, "Manifest Parse Error : A CDATA section was not closed.", "ERROR_SXS_XML_E_UNCLOSEDCDATA" },
      {0x36F2, "Manifest Parse Error : The namespace prefix is not allowed to start with the reserved string \"xml\".", "ERROR_SXS_XML_E_RESERVEDNAMESPACE" },
      {0x36F3, "Manifest Parse Error : System does not support the specified encoding.", "ERROR_SXS_XML_E_INVALIDENCODING" },
      {0x36F4, "Manifest Parse Error : Switch from current encoding to specified encoding not supported.", "ERROR_SXS_XML_E_INVALIDSWITCH" },
      {0x36F5, "Manifest Parse Error : The name 'xml' is reserved and must be lower case.", "ERROR_SXS_XML_E_BADXMLCASE" },
      {0x36F6, "Manifest Parse Error : The standalone attribute must have the value 'yes' or 'no'.", "ERROR_SXS_XML_E_INVALID_STANDALONE" },
      {0x36F7, "Manifest Parse Error : The standalone attribute cannot be used in external entities.", "ERROR_SXS_XML_E_UNEXPECTED_STANDALONE" },
      {0x36F8, "Manifest Parse Error : Invalid version number.", "ERROR_SXS_XML_E_INVALID_VERSION" },
      {0x36F9, "Manifest Parse Error : Missing equals sign between attribute and attribute value.", "ERROR_SXS_XML_E_MISSINGEQUALS" },
      {0x36FA, "Assembly Protection Error: Unable to recover the specified assembly.", "ERROR_SXS_PROTECTION_RECOVERY_FAILED" },
      {0x36FB, "Assembly Protection Error: The public key for an assembly was too short to be allowed.", "ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT" },
      {0x36FC, "Assembly Protection Error: The catalog for an assembly is not valid, or does not match the assembly's manifest.", "ERROR_SXS_PROTECTION_CATALOG_NOT_VALID" },
      {0x36FD, "An HRESULT could not be translated to a corresponding Win32 error code.", "ERROR_SXS_UNTRANSLATABLE_HRESULT" },
      {0x36FE, "Assembly Protection Error: The catalog for an assembly is missing.", "ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING" },
      {0x36FF, "The supplied assembly identity is missing one or more attributes which must be present in this context.", "ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE" },
      {0x3700, "The supplied assembly identity has one or more attribute names that contain characters not permitted in XML names.", "ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME" },
      {0x3701, "The referenced assembly could not be found.", "ERROR_SXS_ASSEMBLY_MISSING" },
      {0x3702, "The activation context activation stack for the running thread of execution is corrupt.", "ERROR_SXS_CORRUPT_ACTIVATION_STACK" },
      {0x3703, "The application isolation metadata for this process or thread has become corrupt.", "ERROR_SXS_CORRUPTION" },
      {0x3704, "The activation context being deactivated is not the most recently activated one.", "ERROR_SXS_EARLY_DEACTIVATION" },
      {0x3705, "The activation context being deactivated is not active for the current thread of execution.", "ERROR_SXS_INVALID_DEACTIVATION" },
      {0x3706, "The activation context being deactivated has already been deactivated.", "ERROR_SXS_MULTIPLE_DEACTIVATION" },
      {0x3707, "A component used by the isolation facility has requested to terminate the process.", "ERROR_SXS_PROCESS_TERMINATION_REQUESTED" },
      {0x3708, "A kernel mode component is releasing a reference on an activation context.", "ERROR_SXS_RELEASE_ACTIVATION_CONTEXT" },
      {0x3709, "The activation context of system default assembly could not be generated.", "ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY" },
      {0x370A, "The value of an attribute in an identity is not within the legal range.", "ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE" },
      {0x370B, "The name of an attribute in an identity is not within the legal range.", "ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME" },
      {0x370C, "An identity contains two definitions for the same attribute.", "ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE" },
      {0x370D, "The identity string is malformed. This may be due to a trailing comma, more than two unnamed attributes, missing attribute name or missing attribute value.", "ERROR_SXS_IDENTITY_PARSE_ERROR" },
      {0x3A98, "The specified channel path is invalid. See extended error info for more details.", "ERROR_EVT_INVALID_CHANNEL_PATH" },
      {0x3A99, "The specified query is invalid. See extended error info for more details.", "ERROR_EVT_INVALID_QUERY" },
      {0x3A9A, "The publisher did indicate they have a manifest/resource but a manifest/resource could not be found.", "ERROR_EVT_PUBLISHER_MANIFEST_NOT_FOUND" },
      {0x3A9B, "The publisher does not have a manifest and is performing an operation which requires they have a manifest.", "ERROR_EVT_PUBLISHER_MANIFEST_NOT_SPECIFIED" },
      {0x3A9C, "There is no registered template for specified event id.", "ERROR_EVT_NO_REGISTERED_TEMPLATE" },
      {0x3A9D, "The specified event was declared in the manifest to go a different channel than the one this publisher handle is bound to.", "ERROR_EVT_EVENT_CHANNEL_MISMATCH" },
      {0x3A9E, "The type of a specified substitution value does not match the type expected from the template definition. ", "ERROR_EVT_UNEXPECTED_VALUE_TYPE" },
      {0x3A9F, "The number of specified substitution values does not match the number expected from the template definition.", "ERROR_EVT_UNEXPECTED_NUM_VALUES" },
      {0x3AA0, "The specified channel could not be found. Check channel configuration.", "ERROR_EVT_CHANNEL_NOT_FOUND" },
      {0x3AA1, "The specified xml text was not well-formed. See Extended Error for more details.", "ERROR_EVT_MALFORMED_XML_TEXT" },
      {0x3AA2, "The specified channel path selects more than one instance of a channel. The operation requires that only one channel be selected. It may be necessary to scope channel path to version / publicKeyToken to select only one instance. ", "ERROR_EVT_CHANNEL_PATH_TOO_GENERAL" },
      {0x3AA3, "The query specified in channel configuration is not allowed to select any channel other than the one the config is associated with. ", "ERROR_EVT_CONFIG_QUERY_NOT_SCOPED_TO_CHANNEL" },
	{0, NULL, NULL},
	};

```

`source/WispSyser/winwisp.cpp`:

```cpp

#include <stdarg.h>
#include "../Code/sysdep.hpp"
#include "winwisp.hpp"
#include "../wisp/wispbasewnd.hpp"

//#include <winuser.h>
//#include <windowsx.h>
//#include <winuser.h>

	CWinWisp *pWinWisp = NULL;


	CWinWisp::CWinWisp()
	{
		pWinWisp = this;

		m_hRResize = 0;
		m_hLResize = 0;
		m_hHResize = 0;
		m_hVResize = 0;
		m_hDrag = 0;
		m_hArrow = 0;

		m_dwStyle = WS_VISIBLE|WS_CAPTION|WS_SYSMENU|WS_SIZEBOX|WS_GROUP|WS_MAXIMIZEBOX; //0x10CF0000;
		m_dwExStyle = 0;

		m_pTaskBarIconName = 0;
		m_hTaskBarIcon = 0;
	}

	CWinWisp::~CWinWisp()
	{
	}

	bool CWinWisp::UnregisterTaskBar(int)
	{
		NOTIFYICONDATAA data;

		data.cbSize = sizeof(NOTIFYICONDATAA);
		data.hWnd = m_hWnd;
		data.uID = 0;

		if (m_hTaskBarIcon)
		{
			::DestroyIcon(m_hTaskBarIcon);
			m_hTaskBarIcon = 0;
		}
		return ::Shell_NotifyIconA(NIM_DELETE, &data);
	}

	bool CWinWisp::RegisterTaskBar(const char *HintName, const char *IconName)
	{
		NOTIFYICONDATAA data;

		m_pTaskBarIconName = IconName;
		m_TaskBarHintName = HintName;

		data.cbSize = sizeof(NOTIFYICONDATAA);
		data.hWnd = m_hWnd;
		data.uID = 0;
		data.uFlags = NIF_TIP | NIF_ICON | NIF_MESSAGE;
		data.uCallbackMessage = 0x500; //WM_USER+
		data.hIcon = ::LoadIconA(m_hInstance, IconName);

		m_hTaskBarIcon = data.hIcon;
		TStrCpy(data.szTip, HintName);

		return ::Shell_NotifyIconA(NIM_ADD, &data);
	}

	bool CWinWisp::UpdateTaskBar(const char *IconName)
	{
		NOTIFYICONDATAA data;

		data.cbSize = sizeof(NOTIFYICONDATAA);
		data.hWnd = m_hWnd;
		data.uID = 0;
		data.uFlags = NIF_ICON;

		if (m_hTaskBarIcon)
			::DestroyIcon(m_hTaskBarIcon);

		data.hIcon = ::LoadIconA(m_hInstance, IconName);
		m_hTaskBarIcon = data.hIcon;

		return ::Shell_NotifyIconA(NIM_MODIFY, &data);
	}

	bool CWinWisp::CreateFrame(const WCHAR *WndName, int Width, int Height, int Bpp)
	{
		RECT Rect;
		::GetWindowRect(GetDesktopWindow(), &Rect);
		DesktopSize.cx = Rect.right - Rect.left;
		DesktopSize.cy = Rect.bottom - Rect.top;

		if (!m_hArrow)
			m_hArrow = ::LoadCursorA(0, IDC_ARROW);

		if (!m_hDrag)
			m_hDrag = ::LoadCursorA(0, IDC_ARROW); //IDC_HANG

		if (!m_hVResize)
			m_hVResize = ::LoadCursorA(0, IDC_SIZENS);
		if (!m_hHResize)
			m_hHResize = ::LoadCursorA(0, IDC_SIZEWE);
		if (!m_hLResize)
			m_hLResize = ::LoadCursorA(0, IDC_SIZENWSE);
		if (!m_hRResize)
			m_hRResize = ::LoadCursorA(0, IDC_SIZENESW);

		WNDCLASSEXA ExClass;

		ExClass.cbSize = sizeof(WNDCLASSEXA);
		ExClass.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW; 
		ExClass.lpfnWndProc = CWinWisp::DefaultWindowProc;
		ExClass.cbClsExtra = 0;
		ExClass.cbWndExtra = 0;
		ExClass.hInstance = m_hInstance;
		ExClass.hIcon = m_hWindowClassIcon;
		ExClass.hCursor = m_hArrow;
		ExClass.hbrBackground = 0;
		ExClass.lpszMenuName = 0;
		ExClass.lpszClassName = "WispWindowClass";
		ExClass.hIconSm = 0;
		::RegisterClassExA(&ExClass);

		char WindowName[256];
		UnicodeToAnsi(WndName, WindowName, lenof(WindowName));

		m_hWnd = ::CreateWindowExA(m_dwExStyle, "WispWindowClass", WindowName, m_dwStyle,
				CW_USEDEFAULT, CW_USEDEFAULT, Width, Height, 0, 0, m_hInstance, 0);

		RECT ClientRect;
		RECT WindowRect;

		::GetClientRect(m_hWnd, &ClientRect);
		::GetWindowRect(m_hWnd, &WindowRect);

		m_PaintRect.x = WindowRect.right - WindowRect.left - (ClientRect.right - ClientRect.left);
		m_PaintRect.y = WindowRect.bottom - WindowRect.top - (ClientRect.bottom - ClientRect.top);

		if (m_nShowCmd == 3) //SW_MAXIMIZE
		{
			Width = ::GetSystemMetrics(SM_CXFULLSCREEN);
			Height = ::GetSystemMetrics(SM_CYFULLSCREEN);
		}

		::SetWindowPos(m_hWnd, 0, (GetSystemMetrics(SM_CXFULLSCREEN) - m_PaintRect.x - Width) / 2,
					(GetSystemMetrics(SM_CYFULLSCREEN) - m_PaintRect.y - Height) / 2,
					m_PaintRect.x + Width, m_PaintRect.y + Height, 
					SWP_NOACTIVATE | SWP_NOZORDER);

		if (m_dwStyle & WS_VISIBLE)
		{
			::ShowWindow(m_hWnd, m_nShowCmd);
			::UpdateWindow(m_hWnd);
		}

		m_PaintRect.cy = 0;
		m_PaintRect.cx = 0;
		m_hWndDC = ::GetDC(m_hWnd);
		m_hPaintDC = ::CreateCompatibleDC(m_hWndDC);

		CreateFrameBuffer(Width, Height);
		return true;
	}

	bool CWinWisp::BeginResize(int Width, int Height)
	{
		CreateFrameBuffer(Width, Height);
		return true;
	}

	bool CWinWisp::EndResize(int Width, int Height)
	{
		::SetWindowPos(m_hWnd, 0,  0, 0, m_PaintRect.x + Width, m_PaintRect.y + Height, 
				SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
		return true;
	}

	void CWinWisp::DestroyFrame()
	{
		if (m_hArrow)
			::DestroyCursor(m_hArrow);

		if (m_hDrag)
			::DestroyCursor(m_hDrag);

		if (m_hVResize)
			::DestroyCursor(m_hVResize);
		if (m_hHResize)
			::DestroyCursor(m_hHResize);
		if (m_hLResize)
			::DestroyCursor(m_hLResize);
		if (m_hRResize)
			::DestroyCursor(m_hRResize);
		::DestroyWindow(m_hWnd);
	}

	void CWinWisp::BeginDrag()
	{
		::SetCapture(m_hWnd);
	}

	void CWinWisp::EndDrag()
	{
		::ReleaseCapture();
	}

	void CWinWisp::BeginDraw(WISP_RECT *pRect)
	{
		::GdiFlush();
	}

	void CWinWisp::EndDraw(WISP_RECT *pRect)
	{
		if (!pRect) pRect = &gpCurWisp->m_pRootWnd->m_WindowRect;

		::BitBlt(m_hWndDC, pRect->x, pRect->y, pRect->cx, pRect->cy,
			m_hPaintDC, pRect->x, pRect->y, SRCCOPY);

		//StretchBlt(m_hWndDC, pRect->x, pRect->y, pRect->cx, pRect->cy,
		//	m_hPaintDC, pRect->x, pRect->y, src_cx, src_cy, SRCCOPY);

		//AlphaBlt(
		//TransparentBlt(
	}

	const WCHAR *CWinWisp::GetClipboard()
	{
		if (!::IsClipboardFormatAvailable(CF_TEXT))
			return m_ClipString; //cstr

		::OpenClipboard(m_hWnd);

		HANDLE hClipboard = ::GetClipboardData(CF_TEXT);
		const char *buffer = (const char *)::GlobalLock(hClipboard);
		if (buffer)
		{
			int bufferLen = TStrLen(buffer) + 1;
			m_ClipString.Preallocate(bufferLen, 0);
			m_ClipString.Truncate( AnsiToUnicode(buffer, m_ClipString.data(), bufferLen) );
			::GlobalUnlock(hClipboard);
			::CloseClipboard();
			return CWispBase::GetClipboard();
		}

		::CloseClipboard();
		return m_ClipString; //cstr
	}

	bool CWinWisp::SetClipboard(const WCHAR *Text)
	{
		CWispBase::SetClipboard(Text);
		if (::OpenClipboard(m_hWnd))
		{
			::EmptyClipboard();
			int TextLen = TStrLen(Text)+1;
			HGLOBAL clipbuffer = ::GlobalAlloc(0x2042, TextLen*2); //GMEM_DDESHARE | GHND //GMEM_MOVEABLE | GMEM_ZEROINIT
			char *buffer = (CHAR *)::GlobalLock(clipbuffer);
			UnicodeToAnsi(Text, buffer, TextLen*2);
			::GlobalUnlock(clipbuffer);
			::SetClipboardData(CF_TEXT, clipbuffer);
			::CloseClipboard();
		}
		return true;
	}
		#define MYBPP 32
	void CWinWisp::CreateFrameBuffer(int Width, int Height)
	{
		if (Width > 0 && Height > 0)
		{
			m_FrameBufferInfo.Bpp = MYBPP;
			m_FrameBufferInfo.Width = Width;
			m_FrameBufferInfo.Height = Height;

			if (m_PaintRect.cx >= Width &&
			    m_PaintRect.cy >= Height
				&& m_PaintRect.cx < Width  + MYBPP &&
				   m_PaintRect.cy < Height + MYBPP)
			{
				return;
			}

			if (m_PaintRect.cx < Width + MYBPP) //CLAMP
				m_PaintRect.cx = Width + MYBPP;
			else	m_PaintRect.cx = Width;

			if (m_PaintRect.cy < Height + MYBPP) //CLAMP
				m_PaintRect.cy = Height + MYBPP;
			else	m_PaintRect.cy = Height;

			BITMAPINFO bitmap;

			bitmap.bmiHeader.biBitCount = MYBPP;
			bitmap.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
			bitmap.bmiHeader.biCompression = BI_RGB;
			bitmap.bmiHeader.biPlanes = 1;
			bitmap.bmiHeader.biSizeImage = 0;
			bitmap.bmiHeader.biClrUsed = 0;
			bitmap.bmiHeader.biClrImportant = 0;
			bitmap.bmiHeader.biHeight = -m_PaintRect.cy;
			bitmap.bmiHeader.biWidth = m_PaintRect.cx;

			m_hPaintBitmap = ::CreateDIBSection(NULL, &bitmap, DIB_RGB_COLORS,
					(void **)&m_FrameBufferInfo.VideoBuffer, NULL, 0);

			::DeleteObject(SelectObject(m_hPaintDC, m_hPaintBitmap));

			m_FrameBufferInfo.LineDistance = m_PaintRect.cx * (m_FrameBufferInfo.Bpp / 8);
			m_FrameBufferInfo.VideoBufferSize = m_PaintRect.cy * m_FrameBufferInfo.LineDistance;

			//DebugPrintf("%dx%d, %d, %d", Width, Height, MYBPP, m_FrameBufferInfo.LineDistance);
		}
	}

	void CWinWisp::SetCursor(unsigned int CursorType, WISP_POINT *pHotPT, WISP_SIZE *pSize, CWispDIB *pDIB)
	{
		if (m_bHideMouse)
		{
			switch (CursorType)
			{
			case WISP_CT_ARROW:
				::SetClassLongPtrA(m_hWnd, GCLP_HCURSOR, (LONG_PTR)m_hArrow);
				break;
			case WISP_CT_RESIZE_VERT:
				::SetClassLongPtrA(m_hWnd, GCLP_HCURSOR, (LONG_PTR)m_hVResize);
				break;
			case WISP_CT_RESIZE_HORZ:
				::SetClassLongPtrA(m_hWnd, GCLP_HCURSOR, (LONG_PTR)m_hHResize);
				break;
			case WISP_CT_DRAG:
				::SetClassLongPtrA(m_hWnd, GCLP_HCURSOR, (LONG_PTR)m_hDrag);
				break;
			case WISP_CT_RESIZE_LEFT_LEAN:
				::SetClassLongPtrA(m_hWnd, GCLP_HCURSOR, (LONG_PTR)m_hLResize);
				break;	
			case WISP_CT_RESIZE_RIGHT_LEAN:
				::SetClassLongPtrA(m_hWnd, GCLP_HCURSOR, (LONG_PTR)m_hRResize);
				break;
			default:
				return;
			}
		} else
		{
			CWispBase::SetCursor(CursorType, pHotPT, pSize, pDIB);
		}
	}

	void CWinWisp::ChangeCursor(LONG_PTR Style, unsigned int CursorType, WISP_POINT *pHotPT, WISP_SIZE *pSize)
	{
		ICONINFO Info;

		if (::GetIconInfo((HICON)Style, &Info))
		{
			pHotPT->x = Info.xHotspot;
			pHotPT->y = Info.yHotspot;
			pSize->cy = 0;
			pSize->cx = 0;
			::SetClassLongPtrA(m_hWnd, GCLP_HCURSOR, Style);
		}
	}

	int CWinWisp::WinMainStart(HINSTANCE hInstance, const char* lpCmdLine, int nShowCmd)
	{
		m_hInstance = hInstance;
		m_nShowCmd = nShowCmd;
		m_lpCmdLine = lpCmdLine;

		::InitializeCriticalSection(&m_hCriticalSection);
		int Result = 0;

		if (Start())
		{
			Pump();
			Result = Stop();
		}

		::DeleteCriticalSection(&m_hCriticalSection);
		return Result;
	}

	bool CWinWisp::WakeUpMsgThread()
	{
		if (m_bInCriticalSection)
			::PostMessageA(m_hWnd, 0x410, 0, 0);
		return true;
	}

	bool CWinWisp::SleepMsgThread()
	{
		MSG Msg;

		if (m_bActive && ::GetMessageA(&Msg, 0, 0, 0))
		{
			::TranslateMessage(&Msg);
			::DispatchMessageA(&Msg);
			return true;
		}
		m_bActive = false;
		return true;
	}


	bool CWinWisp::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch (uMsg)
		{
		case WM_CREATE:
			pWinWisp->m_TaskbarWM = ::RegisterWindowMessageA("TaskbarCreated");
			::ShowCursor(pWinWisp->m_bHideMouse);
			::SetTimer(hWnd, 0, 30, 0);
			break;

		case WM_DESTROY:
			pWinWisp->m_bActive = false;
			break;

		case WM_ACTIVATE:
			if (pWinWisp->m_pRootWnd)
			{
				pWinWisp->ResetInput();
				pWinWisp->EndDraw(0);
			}
			break;

		case WM_ERASEBKGND:
			if (pWinWisp->m_pRootWnd)
				pWinWisp->EndDraw(0);
			break;

		case WM_NCCALCSIZE:
			if (pWinWisp->m_pRootWnd)
			{
				if (wParam)
				{
					RECT *rect = (RECT*)lParam;

					int x = rect->right - rect->left - pWinWisp->m_PaintRect.x;
					int y = rect->bottom - rect->top - pWinWisp->m_PaintRect.y;

					if (x > 0 && y > 0)
					{
						pWinWisp->EnterMsgCriticalSection();
						pWinWisp->m_pRootWnd->m_State = 2; //WISP_WSTATE_RESIZE
						pWinWisp->m_pRootWnd->Resize(x, y, true);
						pWinWisp->m_pRootWnd->m_State = WISP_WSTATE_RESET;
						pWinWisp->Update();
						pWinWisp->LeaveMsgCriticalSection();
					}
				}
			}
			return false;	//continue pass to windows proc

		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
			if (pWinWisp->m_pRootWnd)
			{
				for (int n = 0; n < LOWORD(lParam); ++n)
					pWinWisp->SendKeyEvent(wParam, true, HIWORD(lParam));
			}
			break;

		case WM_KEYUP:
		case WM_SYSKEYUP:
			if (pWinWisp->m_pRootWnd)
			{
				for (int n = 0; n < LOWORD(lParam); ++n)
					pWinWisp->SendKeyEvent(wParam, false, HIWORD(lParam));
			}
			break;

		case WM_TIMER:
			pWinWisp->SendTimer(20);
			break;

		case WM_MOUSEMOVE:
			if (pWinWisp->m_pRootWnd)
				pWinWisp->SendMousePosChg(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
			break;

		case WM_LBUTTONDOWN:
			if (pWinWisp->m_pRootWnd)
				pWinWisp->SendKeyEvent(1, true, 0); //VK_LBUTTON, true, 0
			break;

		case WM_LBUTTONUP:
			if (pWinWisp->m_pRootWnd)
				pWinWisp->SendKeyEvent(1, false, 0); //VK_LBUTTON, false, 0
			break;

		case WM_LBUTTONDBLCLK:
			if (pWinWisp->m_pRootWnd)
				pWinWisp->SendMouseDblClick(1); //VK_LBUTTON
			break;

		case WM_RBUTTONDOWN:
			if (pWinWisp->m_pRootWnd)
				pWinWisp->SendKeyEvent(2, true, 0); //VK_RBUTTON, true, 0
			break;

		case WM_RBUTTONUP:
			if (pWinWisp->m_pRootWnd)
				pWinWisp->SendKeyEvent(2, false, 0); //VK_RBUTTON, false, 0
			break;

		case WM_RBUTTONDBLCLK:
			if (pWinWisp->m_pRootWnd)
				pWinWisp->SendMouseDblClick(2); //VK_RBUTTON
			break;

		case WM_MOUSEWHEEL:
			if (pWinWisp->m_pRootWnd)
				pWinWisp->SendMouseWheel(GET_WHEEL_DELTA_WPARAM(wParam) / WHEEL_DELTA);
			break;

		case 0x410: //WakeUpMsgThread
			break;

		//case 0x500: //???

		default:
			if (uMsg != pWinWisp->m_TaskbarWM)
				return false; //contiue pass to windows proc

			if (pWinWisp->m_pTaskBarIconName)
				pWinWisp->RegisterTaskBar(pWinWisp->m_TaskBarHintName, pWinWisp->m_pTaskBarIconName);
			break;
		}
		return true; //stop pass to windows proc
	}

	LRESULT CALLBACK CWinWisp::DefaultWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		if (pWinWisp->WindowProc(hWnd, uMsg, wParam, lParam))
			return 0;

		return ::DefWindowProcA(hWnd, uMsg, wParam, lParam);
	}

	void CWinWisp::EnterMsgCriticalSection()
	{
		::EnterCriticalSection(&m_hCriticalSection);
	}

	void CWinWisp::LeaveMsgCriticalSection()
	{
		::LeaveCriticalSection(&m_hCriticalSection);
	}

#include <Shlobj.h>

	bool CWinWisp::GetOpenFolderName(WCHAR *Path, const WCHAR *Title)
	{
		IMalloc *Iface;

		if (FAILED(::SHGetMalloc(&Iface)))
			return false;

		BROWSEINFOW bi;

		bi.hwndOwner = m_hWnd;
		bi.pidlRoot = 0;
		bi.pszDisplayName = 0;
		bi.lpszTitle = (LPCWSTR)Title;
		bi.ulFlags = 0x49;	//??? BIF_NEWDIALOGSTYLE | BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS
		bi.lpfn = 0;
		bi.lParam = 0;
		bool Result = false;
		ITEMIDLIST *pidl = ::SHBrowseForFolderW(&bi);
		if (pidl)
		{
			Result = ::SHGetPathFromIDListW(pidl, (LPWSTR)Path) != 0;
			Iface->Free(pidl);
		}
		Iface->Release();
		return Result;
	}

	bool CWinWisp::GetOpenFileName(const WCHAR *lpstrInitialDir, const WCHAR *lpstrFilter, int, WCHAR *lpstrFile, int nMaxFile)
	{
		WCHAR Filter[MAX_FN_LEN];
		OPENFILENAMEW ofn;

		memset(&ofn, 0, sizeof(ofn)); //0x58
		ofn.lStructSize = sizeof(ofn); //0x58
		ofn.hInstance = m_hInstance;
		ofn.hwndOwner = m_hWnd;
		TStrCpy(Filter, lpstrFilter);
		int Len = TStrLen(Filter);
		MAX_LIMIT(Len, MAX_FN_LEN);
		for (int i = 0; i < Len; ++i)
		{
			if (Filter[Len-i] == '|') //-1 ???
				Filter[Len-i] = 0; //-1 ???
		}
		ofn.lpstrFilter = (LPCWSTR)Filter;
		ofn.nMaxFile = nMaxFile;
		ofn.lpstrFile = (LPWSTR)lpstrFile;
		ofn.lpstrInitialDir = (LPCWSTR)lpstrInitialDir;
		*lpstrFile = 0;
		return ::GetOpenFileNameW(&ofn) != 0;
	}


	void CWinWisp::ReportMsg(const WCHAR *Format, ...)
	{
		WCHAR Buffer[512];
		va_list va;
		va_start(va, Format);
		TSPrintf(Buffer, Format, va);
		va_end(va);

		if (!m_pRootWnd)
		{
			wprintf(WSTR("%s"), Buffer);
			return;
		}
		::OutputDebugStringW((LPCWSTR)Buffer);
	}



```

`source/WispSyser/winwisp.hpp`:

```hpp

#ifndef _WINWISP_HPP_
#define _WINWISP_HPP_

//#include "../Code/osdefine.hpp"
#include "../Code/define.h"

#include "../Wisp/wispapp.hpp"

//#include <stdio.h>


//#define _WIN32_WINDOWS 0x0410
//#define _WIN32_WINNT 0x0500

//#define WIN32_LEAN_AND_MEAN

//#include <winresrc.h>
//#include <winuser.h>

//#include <windows.h>
//#include <windowsx.h>

	struct CWinWisp : public CWispApp
	{
		long m_dwStyle;
		long m_dwExStyle;
		HWND m_hWnd;
		HINSTANCE m_hInstance;
		HICON m_hWindowClassIcon;
		HICON m_hTaskBarIcon;

		int m_nShowCmd;
		const char *m_lpCmdLine;

		HDC m_hWndDC;
		HDC m_hPaintDC;
		HBITMAP m_hPaintBitmap;

		HCURSOR m_hArrow;
		HCURSOR m_hDrag;
		HCURSOR m_hVResize;
		HCURSOR m_hHResize;
		HCURSOR m_hLResize;
		HCURSOR m_hRResize;

		WISP_RECT m_PaintRect;
		CRITICAL_SECTION m_hCriticalSection;
		TAnsiString m_TaskBarHintName;
		const char *m_pTaskBarIconName;
		long m_TaskbarWM;
		WISP_SIZE DesktopSize;


	public:
		CWinWisp();
		virtual  ~CWinWisp();

		virtual bool CreateFrame(const WCHAR *WndName, int Width, int Height, int Bpp) override;
		virtual void DestroyFrame() override;

		virtual bool EndResize(int Width, int Height) override;
		virtual bool BeginResize(int Width, int Height) override;

		virtual void BeginDrag() override;
		virtual void EndDrag() override;

		virtual bool WakeUpMsgThread() override;
		virtual bool SleepMsgThread() override;

		virtual void EnterMsgCriticalSection() override;
		virtual void LeaveMsgCriticalSection() override;

		virtual void BeginDraw(WISP_RECT *pRect) override;
		virtual void EndDraw(WISP_RECT *pRect) override;

		virtual void SetCursor(unsigned int CursorType, WISP_POINT *pHotPT, WISP_SIZE *pSize, CWispDIB *pDIB) override;
		virtual void ChangeCursor(LONG_PTR Style, unsigned int CursorType, WISP_POINT *pHotPT, WISP_SIZE *pSize) override;

		virtual const WCHAR *GetClipboard() override;
		virtual bool SetClipboard(const WCHAR *Text) override;


		virtual bool GetOpenFolderName(WCHAR *Path, const WCHAR *Title) override;

		virtual bool GetOpenFileName(const WCHAR *lpstrInitialDir, const WCHAR *lpstrFilter, int, WCHAR *lpstrFile, int nMaxFile) override;

		virtual void ReportMsg(const WCHAR *Format, ...) override;

		virtual bool WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

		
		bool UnregisterTaskBar(int);
		bool RegisterTaskBar(const char *HintName, const char *IconName);
		bool UpdateTaskBar(const char *IconName);

		void CreateFrameBuffer(int Width, int Height);

		static LRESULT CALLBACK DefaultWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

		int WinMainStart(HINSTANCE hInstance, const char *lpCmdLine, int nShowCmd);
	};

#endif

```

`source/WispSyser/x87x64double.asm`:

```asm

.code

REAL10toDOUBLE	PROC, ipt:PTR QWORD, opt:PTR REAL8
;	mov rax, ipt
;	fld TBYTE PTR [rax]
	fld TBYTE PTR [rcx]
;	mov rax, opt
;	fstp REAL8 PTR [rax]
	fstp REAL8 PTR [rdx]
	ret
REAL10toDOUBLE	ENDP
END
```

`source/WispSyser/x87x86double.asm`:

```asm

.386
.model flat, C

.code

REAL10toDOUBLE	PROC, ipt:PTR QWORD, opt:PTR REAL8
	mov eax, ipt
	fld TBYTE PTR [eax]
	mov eax, opt
	fstp REAL8 PTR [eax]
	ret
REAL10toDOUBLE	ENDP
END
```

`source/pdb2sds.cpp`:

```cpp
#include <stdlib.h>
#include <stdio.h>
#include "Code/alt/altlist.hpp"
#include "Code/alt/altmap.hpp"
#include "Code/sysdep.hpp"

#include "Code/define.h"
#include "Code/tstrmem.hpp"

#include "EXEAnalyzer/sourcedebug.hpp"
#include "EXEAnalyzer/sdsmodule.hpp"


void CreateProgress(unsigned long MaxPos)
{
	printf("\n%d ", MaxPos);
}

void UpdateProgress(unsigned long Pos)
{
	printf("*");
}

void UpdateCaption(const WCHAR *Text)
{
	char szText[256];
	TStrCpy(szText, Text);
	printf("%s ", szText);
}

void DestroyProgress()
{
	printf("\n");
}

	CSourceDebug SourceDebug;

int main(int argc, char *argv[])
{
	if (argc < 2)
	{
		printf("error: incorrect args!\n%s file.pdb\nor\n%s file.exe", TGetFileName(argv[0]),TGetFileName(argv[0]));
		return 1;
	}
	SourceDebug.m_CreateProgress = CreateProgress;
	SourceDebug.m_UpdateProgress = UpdateProgress;
	SourceDebug.m_UpdateCaption = UpdateCaption;
	SourceDebug.m_DestroyProgress = DestroyProgress;

	char szModule[MAX_FN_LEN];
	//TStrCpy(szModule, "L:\\flash2G_my\\syser\\Syser\\source\\x32_\\syserx32.exe"); //SYSER
	TStrCpy(szModule, "L:\\flash2G_my\\syser\\Syser\\source\\x32_\\testx32.exe"); //TEST
	TStrCpy(szModule, argv[1]);
	//TStrCpy(szModule, "L:\\flash2G_my\\syser\\Syser\\source\\x32\\testx32.exe"); //WORK
	char SDSFullFileName[MAX_FN_LEN];
	char *pSDSFullFileName = SDSFullFileName;
	SDSFullFileName[0] = 0;
	//TStrCpy(SDSFullFileName, "L:\\flash2G_my\\syser\\Syser\\source\\x32\\testx32.exe.sds"); //MY LAST
//	TStrCpy(SDSFullFileName, "L:\\flash2G_my\\syser\\Syser\\source\\x32_\\testx32.exe.sds"); //MY LAST
	//TStrCpy(SDSFullFileName, "L:\\flash2G_my\\syser\\Syser\\source\\x32_\\testx32.exe.sds_MY"); //ERROR
	//TStrCpy(SDSFullFileName, "L:\\flash2G_my\\syser\\Syser\\source\\x32_\\testx32.exe.sds_SYS");
//#define LOAD_SDS
//#ifndef LOAD_SDS
	if (pSDSFullFileName[0] == 0)
{
	printf("OPEN Module %s\n", szModule);
	if (!SourceDebug.CheckSDS(szModule, pSDSFullFileName))
	{
		if (!SourceDebug.Load(szModule, pSDSFullFileName, eUseSourcesNone))
		{
			printf("OPEN ERROR\n");
			return 1;
		} else
		{
			printf("Convert OK\n");
		}
	} else
	{
		printf("Check SDS OK\n");
	}
}
//#endif
	printf("SDSFile %s\n", pSDSFullFileName);
	//printf("SIZE %d\n", sizeof(SDSFILE));

	CSDSModule sdsmodule;
	if (!sdsmodule.Load(pSDSFullFileName))
	{
		printf("Check Load SDS: ERROR\n");
		return 1;
	}

	FILESIG FileSig = CSDSModule::GetFILESIG(pSDSFullFileName);
	printf("Sig: Timestamp 0x%08x CheckSum 0x%08x\n", FileSig.TimeStamp, FileSig.CheckSum);
	if (FileSig.TimeStamp == 0 && FileSig.CheckSum == 0)
	{
		printf("Sig - ERROR\n", FileSig.TimeStamp, FileSig.CheckSum);
		return 1;
	}
	return 0;
}

```

`source/resource.rc`:

```rc
#include <windows.h>

101 ICON "Syser.ico"

2250 DIALOG 0, 0, 218, 55
STYLE DS_SETFONT | DS_CONTROL | WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN
CAPTION ""
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
FONT 8, "MS Shell DLG"
{
   CONTROL "&Arguments:", -1, STATIC, SS_LEFT | SS_CENTERIMAGE | WS_CHILD | WS_VISIBLE | WS_GROUP, 7, 7, 47, 12 
   CONTROL "", 2251, EDIT, ES_LEFT | ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP, 54, 7, 155, 12 
   CONTROL "&Start directory:", -1, STATIC, SS_LEFT | SS_CENTERIMAGE | WS_CHILD | WS_VISIBLE | WS_GROUP, 7, 22, 47, 12 
   CONTROL "", 2253, EDIT, ES_LEFT | ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP, 54, 22, 155, 12 
   CONTROL "&Debug child processes also", 2252, BUTTON, BS_AUTOCHECKBOX | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 7, 40, 150, 12 
}

```

`source/syser.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <dependency>
    <dependentAssembly>
      <assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"/>
    </dependentAssembly>
  </dependency>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel
          level="asInvoker"
          uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
    <application> 
      <!--The ID below indicates application support for Windows Vista --> 
        <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
      <!--The ID below indicates application support for Windows 7 --> 
        <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/> 
      <!--The ID below indicates application support for Windows 8 --> 
        <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/> 
      <!--The ID below indicates application support for Windows 8.1 --> 
        <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/> 
      <!--The ID below indicates application support for Windows 10 --> 
        <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/> 
    </application> 
  </compatibility>
</assembly>
```

`source/unpack.cpp`:

```cpp

#include "Code/define.h"
#include "Code/polyfs.hpp"

int CopyCallback(CFileIO *pSrcIO, CFileIO *pDstIO,
		const char *pSrcPath, const char *pDstPath, unsigned long Length, void *Data)
{
	printf("copy: %s -> %s, %d\n", pSrcPath, pDstPath, Length);
	return 0;
}

int main(int argc, char *argv[])
{
	if (argc != 3)
	{
		printf("usage %s: File.dat UnpackDir\n", argv[0]);
		return 1;
	}

	CPFSFileIO PFSFileIO;
	PFSFileIO.ChangeFileIO(gpFileIO);
	
	if (!PFSFileIO.OpenDisk(argv[1], 1))
	{
		PFSFileIO.CloseDisk();
		printf("OpenDisk: error");
		return 1;
	}

	if (!CFileIO::XCopy(&PFSFileIO, gpFileIO, "\\", argv[2], CopyCallback, 0))
	{
		printf("XCopy: error");
	}

	PFSFileIO.CloseDisk();	
	return 0;
}

```

`x32/README`:

```

avail name for expcalc and any expr in syser

under x64:
RAX RBX RCX RDX RBP RSP RSI RDI RIP R8 R9 R10 R11 R12 R13 R14 R15
EAX EBX ECX EDX EBP ESP ESI EDI EIP R8D R9D R10D R11D R12D R13D R14D R15D EFLAG EFL
AX BX CX DX BP SP SI DI IP R8W R9W R10W R11W R12W R13W R14W R15W
AH BH CH DH AL BL CL DL BPL SPL SIL DIL R8B R9B R10B R11B R12B R13B R14B R15B

under x86:
EAX EBX ECX EDX EBP ESP ESI EDI EIP EFLAG EFL
AX BX CX DX BP SP SI DI IP
AH BH CH DH AL BL CL DL

for both x64,x86:

seg through ":", as example ":ds"
ES CS SS DS FS GS

PID - process id
TID - thread id

BPCOUNT - hit count to BreakPoint, if BreakPoint with condition
OPCODE OPCODE1 OPCODE2 OPCODE4 - bytes on BreakPoint, if BreakPoint with condition
```

`x32/cmake32_debug.bat`:

```bat
..\cmake.bat -G"NMake Makefiles" --debug-output --trace --trace-expand --debug-trycompile -DCMAKE_BUILD_TYPE=Debug ..\source\ -DPLATFORM=x32 > build32_release.log 2>&1
```

`x32/cmake32_release.bat`:

```bat
..\cmake.bat -G"NMake Makefiles" --debug-output --trace --trace-expand --debug-trycompile -DCMAKE_BUILD_TYPE=Release ..\source\ -DPLATFORM=x32 > build32_release.log 2>&1
```

`x32/cmake_build.bat`:

```bat
..\cmake.bat --build . -v > cbuild.log 2>&1
```

`x32/cmake_clean.bat`:

```bat
..\cmake.bat --build . --target clean -v > cclean.log 2>&1
```

`x32/plugin.hpp`:

```hpp

#ifndef _PLUGIN_HPP_
#define _PLUGIN_HPP_

#include "../Code/define.h"

	typedef void (*FPMenuProc)();
	typedef int (*FPCmd)(int argc, const WCHAR *argv[], const WCHAR *szCommandLine, void *pUserData);

	typedef void (*PVFV)();

	struct SYSER_PLUGIN_MODULE
	{
		WCHAR PluginInfo[32];
		PVFV fpOnDebuggerOpen;
		PVFV fpOnDebuggerClose;
		PVFV fpOnDebuggerPlunge;
	};

	struct CSyserPluginUI
	{
		virtual bool RegisterPluginModule(const WCHAR *ModuleName, SYSER_PLUGIN_MODULE *pPluginModule) = 0;
		virtual bool UnregisterPluginModule(const WCHAR *ModuleName) = 0;

		virtual int GetInstrLen(ULONG_PTR Address) = 0;

		virtual bool CalcExp(const WCHAR *szExp, ULONG_PTR *pResult) = 0;

		virtual bool InsertCmd(const WCHAR *szCmd, FPCmd pCmdProc, void *pUserData, const WCHAR *pComment, const WCHAR *pUsage) = 0;
		virtual void RemoveCmd(const WCHAR *szCmd) = 0;
		virtual int RunCmd(const WCHAR *szCmd) = 0;

		virtual void Outputf(const WCHAR *szFormat, ...) = 0;
		virtual void Output(const unsigned long *szMsg) = 0;

		virtual void *InsertMenu(void *hParentMenu, const WCHAR *szMenuName, FPMenuProc fpMenuProc) = 0;
		virtual bool RemoveMenu(void *hMenu) = 0;
		virtual bool EnableMenu(void *hMenu, bool bEnable) = 0;

		virtual void *GetMainTabWnd() = 0;
		virtual void *GetMainMenu() = 0;
		virtual void *GetWisp() = 0;

		virtual unsigned long WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size) = 0;
		virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) = 0;
	};

	extern "C" __declspec(dllimport) CSyserPluginUI *gpSyserPluginUI;

#endif
```

`x64/README`:

```

avail name for expcalc and any expr in syser

under x64:
RAX RBX RCX RDX RBP RSP RSI RDI RIP R8 R9 R10 R11 R12 R13 R14 R15
EAX EBX ECX EDX EBP ESP ESI EDI EIP R8D R9D R10D R11D R12D R13D R14D R15D EFLAG EFL
AX BX CX DX BP SP SI DI IP R8W R9W R10W R11W R12W R13W R14W R15W
AH BH CH DH AL BL CL DL BPL SPL SIL DIL R8B R9B R10B R11B R12B R13B R14B R15B

under x86:
EAX EBX ECX EDX EBP ESP ESI EDI EIP EFLAG EFL
AX BX CX DX BP SP SI DI IP
AH BH CH DH AL BL CL DL

for both x64,x86:

seg through ":", as example ":ds"
ES CS SS DS FS GS

PID - process id
TID - thread id

BPCOUNT - hit count to BreakPoint, if BreakPoint with condition
OPCODE OPCODE1 OPCODE2 OPCODE4 - bytes on BreakPoint, if BreakPoint with condition
```

`x64/cmake64_debug.bat`:

```bat
..\cmake.bat -G"NMake Makefiles" --debug-output --trace --trace-expand --debug-trycompile -DCMAKE_BUILD_TYPE=Debug ..\source\ -DPLATFORM=x64 > build64_debug.log 2>&1
```

`x64/cmake64_release.bat`:

```bat
..\cmake.bat -G"NMake Makefiles" --debug-output --trace --trace-expand --debug-trycompile -DCMAKE_BUILD_TYPE=Release ..\source\ -DPLATFORM=x64 > build64_release.log 2>&1
```

`x64/cmake_build.bat`:

```bat
..\cmake.bat --build . -v > cbuild.log 2>&1
```

`x64/cmake_clean.bat`:

```bat
..\cmake.bat --build . --target clean -v > cclean.log 2>&1
```

`x64/plugin.hpp`:

```hpp

#ifndef _PLUGIN_HPP_
#define _PLUGIN_HPP_

#include "../Code/define.h"

	typedef void (*FPMenuProc)();
	typedef int (*FPCmd)(int argc, const WCHAR *argv[], const WCHAR *szCommandLine, void *pUserData);

	typedef void (*PVFV)();

	struct SYSER_PLUGIN_MODULE
	{
		WCHAR PluginInfo[32];
		PVFV fpOnDebuggerOpen;
		PVFV fpOnDebuggerClose;
		PVFV fpOnDebuggerPlunge;
	};

	struct CSyserPluginUI
	{
		virtual bool RegisterPluginModule(const WCHAR *ModuleName, SYSER_PLUGIN_MODULE *pPluginModule) = 0;
		virtual bool UnregisterPluginModule(const WCHAR *ModuleName) = 0;

		virtual int GetInstrLen(ULONG_PTR Address) = 0;

		virtual bool CalcExp(const WCHAR *szExp, ULONG_PTR *pResult) = 0;

		virtual bool InsertCmd(const WCHAR *szCmd, FPCmd pCmdProc, void *pUserData, const WCHAR *pComment, const WCHAR *pUsage) = 0;
		virtual void RemoveCmd(const WCHAR *szCmd) = 0;
		virtual int RunCmd(const WCHAR *szCmd) = 0;

		virtual void Outputf(const WCHAR *szFormat, ...) = 0;
		virtual void Output(const unsigned long *szMsg) = 0;

		virtual void *InsertMenu(void *hParentMenu, const WCHAR *szMenuName, FPMenuProc fpMenuProc) = 0;
		virtual bool RemoveMenu(void *hMenu) = 0;
		virtual bool EnableMenu(void *hMenu, bool bEnable) = 0;

		virtual void *GetMainTabWnd() = 0;
		virtual void *GetMainMenu() = 0;
		virtual void *GetWisp() = 0;

		virtual unsigned long WriteMemory(ULONG_PTR Address, const void *Buffer, unsigned long Size) = 0;
		virtual unsigned long ReadMemory(ULONG_PTR Address, void *Buffer, unsigned long Size) = 0;
	};

	extern "C" __declspec(dllimport) CSyserPluginUI *gpSyserPluginUI;

#endif
```