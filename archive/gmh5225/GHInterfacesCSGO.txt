Project Path: arc_gmh5225_GHInterfacesCSGO_0bx19eq1

Source Tree:

```txt
arc_gmh5225_GHInterfacesCSGO_0bx19eq1
├── CMakeLists.txt
├── LICENSE
├── README.md
├── include
│   ├── ghooks
│   │   └── GHooks.hpp
│   ├── interface
│   │   └── GHInterfaces.hpp
│   ├── internals
│   │   ├── icliententitylist.hpp
│   │   └── usercmd.hpp
│   └── vmt
│       └── VMThook.hpp
├── packages
│   ├── client_client.so
│   ├── csgo_linux64
│   └── launcher_client.so
├── sources
│   ├── CMakeLists.txt
│   ├── LauncherClient.cpp
│   ├── ghooks
│   │   └── GHooks.cpp
│   ├── interface
│   │   └── GHInterfaces.cpp
│   └── vmt
│       └── VMThook.cpp
├── submodules
│   └── googletest
└── tests
    ├── CMakeLists.txt
    └── Simple.cpp

```

`CMakeLists.txt`:

```txt
# Information cmake
cmake_minimum_required(VERSION 3.0.2)

# Information projec
project(model_cpp VERSION 0.1 LANGUAGES CXX)
set(LIB_MAJOR_VERSION "0")
set(LIB_MINOR_VERSION "1")
set(LIB_PATCH_VERSION "0")


# Information for builds
set(FLAGS_DEBUG OFF )
set(BUILD_TESTS OFF )
set(BUILD_BENCHMARK OFF )
set(FLAGS_OPTIMIZATIONS ON)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_THREAD_LIBS_INIT "-lpthread")
set(CMAKE_HAVE_THREADS_LIBRARY 1)
set(CMAKE_USE_WIN32_THREADS_INIT 0)
set(CMAKE_USE_PTHREADS_INIT 1)
set(THREADS_PREFER_PTHREAD_FLAG ON)

# add subdirectory
add_subdirectory( sources/ )
if(BUILD_TESTS)
	add_subdirectory( tests/ )
endif()
if(BUILD_BENCHMARK)
	add_subdirectory( benchmark/ )
endif()

# set flags
set(CMAKE_CXX_FLAGS "-O2 -Os") # default flags

if(FLAGS_OPTIMIZATIONS)
  set(CMAKE_CXX_FLAGS "-ftree-vectorize -mavx -fno-stack-protector -march=native -O2 -Os -fdelete-null-pointer-checks -fdelete-dead-exceptions")
elseif(FLAGS_DEBUG)
  set(CMAKE_CXX_FLAGS "-fsanitize=address -fms-extensions --all-warnings -DDEBUG -g  -O2 -Os  -Wvolatile  -Warray-bounds --extra-warnings")
endif()

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Mob

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# GHInterfacesCSGO

Simple base hook for CS:GO on linux


# Running 

![csgo](https://labs.moblog.in/style/image/csgo/run_cs.png)
![csgo](https://labs.moblog.in/style/image/csgo/hook_done.png)


# Compile 

Adjust the settings ![config.hpp](config/config.hpp) !! to point to the correct path relative to the folder.

```
cd build
cmake ..
make
```

# Installation

> `mv launcher_client.so bin/linux64/launcher_client.so`

# Help ? 

How does the code work? take a look at the article I made to explain how it develops

> [Reconstructing the vtable of CS:GO on Linux. ](https://www.moblog.in/2023-06-28-reconstruct-csgo-vtable)

```

`include/ghooks/GHooks.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <csignal>
#include "vmt/VMThook.hpp"
#include "internals/icliententitylist.hpp"

#define CLIENT_DLL_INTERFACE_VERSION "VClient018" // EXPOSE_SINGLE_INTERFACE_GLOBALVAR( CHLClient, IBaseClientDLL, "VClient018", gHLClient );
#define VCLIENTENTITYLIST_INTERFACE_VERSION	"VClientEntityList003"
#define ALIGN_ADDR(addr) ((void *)((size_t)(addr) & ~(sysconf(_SC_PAGE_SIZE) - 1)))

class GHooks
{
private:
    static size_t m_page_size;

public:
    static void GetClientModeSharedVTABLE(int sig, siginfo_t *info, void *ucontext);

    // class
    struct ClientModeShared
    {
        uint64_t *vTable;
        uint64_t *g_pClientMode;
        size_t vTableSize;
    };

    struct CHLClient
    {
        uint64_t *vTable;
        size_t vTableSize;
    };

    CSGO::IClientEntityList *ClientEntityList;

    GHooks();
    ~GHooks();

    void Start();
    void ReadjustPagesVTABLE();

    ClientModeShared getClassClientModeShared();
    CHLClient getClassCHLClient();
    CSGO::IClientEntityList* getClassClientEntityList();
};
```

`include/interface/GHInterfaces.hpp`:

```hpp
#pragma once

#include <string>
#include <fcntl.h>
#include <unistd.h>
#include <vector>
#include <stdint.h>
#include <dlfcn.h>

typedef void* (*InstantiateInterfaceFn)();

class InterfaceReg
{
public:
	InstantiateInterfaceFn	m_CreateFn;
	const char				*m_pName;
	InterfaceReg			*m_pNext; // For the global list.
	static InterfaceReg		*s_pInterfaceRegs;
};

// interface return status
enum 
{
	IFACE_OK = 0,
	IFACE_FAILED
};

class GHInterfaces
{
private:
    const std::string m_file;
    void *m_dl;
    Dl_info m_info;

    bool Memcmp(const uint8_t *data, const std::vector<uint8_t>& pattern, const std::vector<uint8_t>& mask);

public:
    GHInterfaces(const std::string _file);
    ~GHInterfaces();

    u_int64_t IndexFunctionOffsetVtable64(u_int64_t _function, off_t _vtable_address);
    u_int64_t IndexFunctionOffsetVtable32(u_int64_t _function, off_t _vtable_address);
    uintptr_t FindPattern(const std::vector<uint8_t> &_pattern, const std::vector<uint8_t> &_mask, size_t _size);
    void *CreateInterfaceFN(const std::string _class);
    void* GetBaseAddress();
};
```

`include/internals/icliententitylist.hpp`:

```hpp
#include <stdint.h>

#pragma once

namespace CSGO
{
    class IClientEntity
    {
    public:
        // Delete yourself.
        virtual void Release(void) = 0;

        // Network origin + angles
        virtual const void *&GetAbsOrigin(void) const = 0;
        virtual const void *&GetAbsAngles(void) const = 0;

        virtual void **GetMouth(void) = 0;

        // Retrieve sound spatialization info for the specified sound on this entity
        // Return false to indicate sound is not audible
        virtual bool GetSoundSpatialization(void *&info) = 0;

        virtual bool IsBlurred(void) = 0;
        virtual void* GetModelName(void) const = 0;
    };

    class IClientEntityList
    {
    public:
        // Get IClientNetworkable interface for specified entity
        virtual void *GetClientNetworkable(int entnum) = 0;
        virtual void *GetClientNetworkableFromHandle(void *hEnt) = 0;
        virtual void *GetClientUnknownFromHandle(void *hEnt) = 0;

        // NOTE: This function is only a convenience wrapper.
        // It returns GetClientNetworkable( entnum )->GetIClientEntity().
        virtual IClientEntity *GetClientEntity(int entnum) = 0;
        virtual IClientEntity *GetClientEntityFromHandle(unsigned long *hEnt) = 0;

        // Returns number of entities currently in use
        virtual int NumberOfEntities(bool bIncludeNonNetworkable) = 0;

        // Returns highest index actually used
        virtual int GetHighestEntityIndex(void) = 0;

        // Sizes entity list to specified size
        virtual void SetMaxEntities(int maxents) = 0;
        virtual int GetMaxEntities() = 0;
        virtual void *GetClientNetworkableArray() = 0;
    };
}
```

`include/internals/usercmd.hpp`:

```hpp
#pragma once

namespace CSGO
{

struct CUserCmd {
    enum {
        IN_ATTACK = 1 << 0,
        IN_JUMP = 1 << 1,
        IN_DUCK = 1 << 2,
        IN_FORWARD = 1 << 3,
        IN_BACK = 1 << 4,
        IN_USE = 1 << 5,
        IN_MOVELEFT = 1 << 9,
        IN_MOVERIGHT = 1 << 10,
        IN_ATTACK2 = 1 << 11,
        IN_SCORE = 1 << 16,
        IN_BULLRUSH = 1 << 22
    };
    void* vmt;
    int commandNumber;
    int tickCount;
    void* viewangles;
    void* aimdirection;
    float forwardmove;
    float sidemove;
    float upmove;
    int buttons;
    char impulse;
    int weaponselect;
    int weaponsubtype;
    int randomSeed;
    short mousedx;
    short mousedy;
    bool hasbeenpredicted;
    void* viewanglesBackup;
    int buttonsBackup;
};
}
```

`include/vmt/VMThook.hpp`:

```hpp
#pragma once

#include <stdint.h>
#include <cstddef>

class VMTHook
{
public:
    VMTHook(uint64_t *_vtable_address, int _size);
    ~VMTHook();

    void VMTInstallHook(unsigned int _index_function, uintptr_t address_function_hook);
    void VMTUninstall(unsigned int _index_function);
    uint64_t *VMTGetVTableCopy();

private:
    uint64_t *m_vtable;
    uint64_t *m_vtable_copy;
    size_t m_vtable_size;

    inline void Memcpy(uint64_t *_dst, uint64_t *_src, int _size);
};
```

`sources/CMakeLists.txt`:

```txt
# Information cmake
cmake_minimum_required(VERSION 3.0.2)

# set variables

set(CMAKE_SHARED_LIBRARY_PREFIX "")

# add subdirectory

# add executable and target libraries
add_library( launcher_client SHARED LauncherClient.cpp)

target_include_directories (launcher_client PRIVATE 
		../include/
		../
		../packages/
		../interfaces
		../submodules/lief/include
)

file(GLOB_RECURSE SOURCES
        *.cpp
)

target_sources(launcher_client PRIVATE 
		${SOURCES}
)
```

`sources/LauncherClient.cpp`:

```cpp
#include <dlfcn.h>
#include <iostream>
#include <thread>
#include <unistd.h>
#include <sys/mman.h>
#include "config/config.hpp"
#include "ghooks/GHooks.hpp"
#include "internals/usercmd.hpp"
#include "internals/icliententitylist.hpp"

extern "C"
{

    CSGO::IClientEntityList *ClientEntityList;

    static bool (*CreateMove)(void *_this, float flInputSampleTime, CSGO::CUserCmd *cmd);
    bool CreateMoveHook(void *_this, float flInputSampleTime, CSGO::CUserCmd *cmd)
    {
        std::cout << "[*] Hooked Function CreateMove" << std::endl
                  << "Cmd.buttons = " << cmd->buttons << std::endl;

        for (int i = 0; i < 64; i++)
        {
            auto player = ClientEntityList->GetClientEntity(i);
            if (player)
                std::cout << "Player " << std::dec << i << std::endl;
        }

        return CreateMove(_this, flInputSampleTime, cmd);
    }

    void ClientModeSharedHook()
    {
        GHooks hooks;

        hooks.Start();

        sleep(10);

        // Hooks
        std::cout << "[*] Hooking Methods Class ClientModeShared" << std::endl;

        VMTHook vmt_hook_client(hooks.getClassClientModeShared().vTable, hooks.getClassClientModeShared().vTableSize);

        ClientEntityList = hooks.getClassClientEntityList();

        CreateMove = reinterpret_cast<bool (*)(void *_this, float flInputSampleTime, CSGO::CUserCmd *cmd)>(hooks.getClassClientModeShared().vTable[25]);

        vmt_hook_client.VMTInstallHook(25, (uint64_t)&CreateMoveHook);

        *(uint64_t *)hooks.getClassClientModeShared().g_pClientMode = (uint64_t)vmt_hook_client.VMTGetVTableCopy();
    }

    void ThreadHooks()
    {
        sleep(TIMEOUT); // wait csgo load is libraries

        std::cout << "[*] Starting Hooks" << std::endl;

        ClientModeSharedHook();
    }

    void LauncherMain(int argc, const char **argv)
    {
        std::cout << "[*] Loading LauncherClient.so" << std::endl;

        void *dl = dlopen(BACKUP_LAUNCHER, RTLD_NOW);
        if (dl)
        {
            void *LauncherMain = dlsym(dl, "LauncherMain");
            if (LauncherMain)
            {
                static void (*LauncherMain_o)(int argc, const char **argv) = reinterpret_cast<void (*)(int argc, const char **argv)>(LauncherMain);
                std::thread hooks_thread(ThreadHooks);

                LauncherMain_o(argc, argv);
            }

            dlclose(dl);
        }
        else
        {
            throw std::runtime_error("[!] Erro in open library : " + std::string(BACKUP_LAUNCHER));
        }
    }
}

```

`sources/ghooks/GHooks.cpp`:

```cpp
#include "ghooks/GHooks.hpp"
#include "interface/GHInterfaces.hpp"
#include "config/config.hpp"

#include <iostream>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ucontext.h>
#include <sys/mman.h>

size_t GHooks::m_page_size = sysconf(_SC_PAGE_SIZE);

// class
GHooks::ClientModeShared clientModeShared;
GHooks::CHLClient chlClient;

GHooks::GHooks()
{
}

GHooks::~GHooks()
{
}

void sig_trap_capture(int sig, siginfo_t *info, void *ucontext)
{
	GHooks::GetClientModeSharedVTABLE(sig, info, ucontext);
}

// Função de tratamento do sinal
void GHooks::GetClientModeSharedVTABLE(int sig, siginfo_t *info, void *ucontext)
{
	if (sig == SIGTRAP)
	{
		std::cout << "[*] Received SIGTRAP (INT3) signal." << std::endl;

		ucontext_t *context = static_cast<ucontext_t *>(ucontext);

		unsigned long long rax = context->uc_mcontext.gregs[REG_RAX];
		std::cout << "[*] RAX [0x" << std::hex << rax << "]" << std::endl;

		clientModeShared.vTable = *(uint64_t **)rax; // get vtable class ClientModeShared
		clientModeShared.g_pClientMode = (uint64_t *)rax;
		clientModeShared.vTableSize = 0;
		while (clientModeShared.vTable[clientModeShared.vTableSize] != NULL)
		{
			++clientModeShared.vTableSize;
		}

		strncpy((char *)chlClient.vTable[10] + 35, "\xFF\xE2", 2); // recover bytes

		// adjustment permission in memory for read and exec
		if (mprotect(ALIGN_ADDR(chlClient.vTable[10]), m_page_size, PROT_READ | PROT_EXEC) != 0)
		{
			perror("[!] mprotect error ");
		}
	}
}

void GHooks::Start()
{
	GHInterfaces inter(CLIENT_CLIENT);

	void *vClient = inter.CreateInterfaceFN(CLIENT_DLL_INTERFACE_VERSION);
	ClientEntityList = reinterpret_cast<CSGO::IClientEntityList*>(inter.CreateInterfaceFN(VCLIENTENTITYLIST_INTERFACE_VERSION));

	chlClient.vTable = *(uint64_t **)(vClient + 0x0); // get vtable class CHLClient
	chlClient.vTableSize = 0;
	while (chlClient.vTable[chlClient.vTableSize] != NULL)
	{
		++chlClient.vTableSize;
	}

	// Get Pointer pClientMode
	{
		struct sigaction sa;
		sa.sa_flags = SA_SIGINFO;
		sa.sa_sigaction = sig_trap_capture;
		sigemptyset(&sa.sa_mask);

		if (sigaction(SIGTRAP, &sa, nullptr) == -1)
		{
			perror("[!] sigaction error ");
			return;
		}
	}

	// adjustment permission in memory for write
	if (mprotect(ALIGN_ADDR(chlClient.vTable[10]), m_page_size, PROT_READ | PROT_WRITE | PROT_EXEC | PROT_NONE) != 0)
	{
		perror("[!] mprotect error ");
	}
	// insert signal int3 (breakpoint)
	strncpy((char *)chlClient.vTable[10] + 35, "\xCC\x00", 2);
}

GHooks::ClientModeShared GHooks::getClassClientModeShared()
{
	return clientModeShared;
}

GHooks::CHLClient GHooks::getClassCHLClient()
{
	return chlClient;
}

CSGO::IClientEntityList *GHooks::getClassClientEntityList()
{
	return ClientEntityList;
}
```

`sources/interface/GHInterfaces.cpp`:

```cpp
#include "interface/GHInterfaces.hpp"

#include <stdexcept>
#include <iostream>
#include <stdint.h>

GHInterfaces::GHInterfaces(const std::string _file) : m_file(_file),
                                                      m_dl(dlopen(m_file.c_str(), RTLD_LAZY | RTLD_NOLOAD))
{
    dladdr(m_dl, &m_info);
}

GHInterfaces::~GHInterfaces()
{
}

u_int64_t GHInterfaces::IndexFunctionOffsetVtable64(u_int64_t _function, off_t _vtable_address)
{
    return (((_function - _vtable_address) / 8) - 1);
}

u_int64_t GHInterfaces::IndexFunctionOffsetVtable32(u_int64_t _function, off_t _vtable_address)
{
    return (((_function - _vtable_address) / 4) - 1);
}

bool GHInterfaces::Memcmp(const uint8_t *_data, const std::vector<uint8_t> &_pattern, const std::vector<uint8_t> &_mask)
{
    for (size_t i = 0; i < _pattern.size(); ++i)
    {
        if (*_data++ != _pattern[i] && _mask[i] != '?')
            return false;
    }
    return true;
}

uintptr_t GHInterfaces::FindPattern(const std::vector<uint8_t> &_pattern, const std::vector<uint8_t> &_mask, size_t _size)
{
    uintptr_t address = reinterpret_cast<uintptr_t>(m_info.dli_fbase);
    uintptr_t end_address = 0;

    std::cout << "[*] Scanning memory in base address : 0x" << std::hex << address << "\n";
    for (size_t i = 0; i < _size; i++)
    {
        end_address = address + i;
        if (GHInterfaces::Memcmp(reinterpret_cast<uint8_t *>(end_address), _pattern, _mask))
        {
            std::cout << "[*] Scan found memory in address : 0x" << end_address << "\n";
            return end_address;
        }
    }

    std::cout << "[*] Not found pattern, end memory : 0x" << end_address << "\n";

    return 0;
}

void *GHInterfaces::CreateInterfaceFN(const std::string _class)
{
    if (m_dl)
    {
        // get InterfaceRegs pointer 1 attempt (better case)
        void *create_interface = dlsym(m_dl, "s_pInterfaceRegs");
        if (create_interface)
        {
            for (const InterfaceReg *current = *reinterpret_cast<InterfaceReg **>(create_interface); current; current = current->m_pNext)
            {
                if (std::string(current->m_pName).find(_class) != std::string::npos)
                {
                    std::cout << "[*] Found class " << _class << " Address " << current->m_pNext << std::endl;
                    return current->m_CreateFn();
                }
            }
        }
        else
        {
            std::cout << "[*] Getting Interface 2 attempt " << std::endl;
            void *create_interface = dlsym(m_dl, "CreateInterface");

            static void *(*CreateInterfaceFn)(const char *pName, int *pReturnCode);

            CreateInterfaceFn = reinterpret_cast<void *(*)(const char *pName, int *pReturnCode)>(create_interface);

            void *CreateFn = CreateInterfaceFn(_class.c_str(), nullptr);
            if (CreateFn != (void *)IFACE_FAILED)
            {
                std::cout << "[*] Found class " << _class << " Address " << CreateFn << std::endl;
                return CreateFn;
            }
        }

        std::cout << "[*]  Not found interface " << _class << std::endl;
        return nullptr;
    }
    else
    {
        throw std::runtime_error("[*] Error dl " + std::string(dlerror()));
    }
}

void* GHInterfaces::GetBaseAddress()
{
    return m_info.dli_fbase;
}
```

`sources/vmt/VMThook.cpp`:

```cpp
#include "vmt/VMThook.hpp"

#include <stdexcept>
#include <iostream>
#include <sys/mman.h>
#include <unistd.h>

VMTHook::VMTHook(uint64_t *_vtable_address, int _size) : m_vtable(_vtable_address),
                                                         m_vtable_size(_size)

{
    m_vtable_copy = new uint64_t[_size]; // first allocate array of row pointer

    Memcpy(m_vtable_copy, _vtable_address, _size);

    std::cout << "[*] VTable [" << _vtable_address << "] successfully copied" << std::endl;
}

VMTHook::~VMTHook()
{
}

void VMTHook::VMTInstallHook(uint _index_function, uintptr_t address_function_hook)
{
    if (_index_function > m_vtable_size)
        throw std::runtime_error("[!] Index exceeded VTable");

    m_vtable_copy[_index_function] = address_function_hook;
}

void VMTHook::VMTUninstall(uint _index_function)
{
    if (_index_function > m_vtable_size)
        throw std::runtime_error("[!] Index exceeded VTable");

    m_vtable_copy[_index_function] = m_vtable[_index_function];
}

uint64_t *VMTHook::VMTGetVTableCopy()
{
    return m_vtable_copy;
}

void VMTHook::Memcpy(uint64_t *_dst, uint64_t *_src, int _size)
{
    for (int i = 0; i < _size; i++)
    {
        _dst[i] = _src[i];
    }
}

```

`tests/CMakeLists.txt`:

```txt
# Information cmake
cmake_minimum_required(VERSION 3.0.2)

include(GoogleTest)

# add subdirectory
add_subdirectory( ../submodules/googletest build/googletest)

add_definitions(-DUNIT_TESTS)
set(PROJECT_SOURCES
	Simple.cpp
)

add_executable(model_test ${PROJECT_SOURCES})

target_include_directories (model_test PRIVATE 
		../include/
		../packages/
)


target_link_libraries(model_test gtest gtest_main)
```

`tests/Simple.cpp`:

```cpp
#include <gtest/gtest.h>

class Test : public testing::Test
{
public:

};

TEST_F(Test, SimpleTest)
{
	ASSERT_EQ(1,1);
}
```